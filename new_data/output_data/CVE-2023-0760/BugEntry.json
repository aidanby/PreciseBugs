{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n\n\n#ifndef GPAC_DISABLE_ISOM\n\nvoid co64_box_del(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr;\n\tptr = (GF_ChunkLargeOffsetBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\nGF_Err co64_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\n\tif ((u64)ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in co64\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->offsets = (u64 *) gf_malloc(ptr->nb_entries * sizeof(u64) );\n\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\tptr->alloc_size = ptr->nb_entries;\n\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\tptr->offsets[entries] = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *co64_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkLargeOffsetBox, GF_ISOM_BOX_TYPE_CO64);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err co64_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u64(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err co64_box_size(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cprt_box_del(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->notice)\n\t\tgf_free(ptr->notice);\n\tgf_free(ptr);\n}\n\n\nGF_Box *chpl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChapterListBox, GF_ISOM_BOX_TYPE_CHPL);\n\ttmp->list = gf_list_new();\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid chpl_box_del(GF_Box *s)\n{\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\tif (ptr == NULL) return;\n\twhile (gf_list_count(ptr->list)) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, 0);\n\t\tif (ce->name) gf_free(ce->name);\n\t\tgf_free(ce);\n\t\tgf_list_rem(ptr->list, 0);\n\t}\n\tgf_list_del(ptr->list);\n\tgf_free(ptr);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err chpl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChapterEntry *ce;\n\tu32 nb_chaps, len, i, count;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5)\n\t/*reserved or ???*/\n\tgf_bs_read_u32(bs);\n\tnb_chaps = gf_bs_read_u8(bs);\n\n\tcount = 0;\n\twhile (nb_chaps) {\n\t\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\t\tif (!ce) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 9)\n\t\tce->start_time = gf_bs_read_u64(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\tif (ptr->size<len) return GF_ISOM_INVALID_FILE;\n\t\tif (len) {\n\t\t\tce->name = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\t\tif (!ce->name) return GF_OUT_OF_MEM;\n\t\t\tISOM_DECREASE_SIZE(ptr, len)\n\t\t\tgf_bs_read_data(bs, ce->name, len);\n\t\t\tce->name[len] = 0;\n\t\t} else {\n\t\t\tce->name = gf_strdup(\"\");\n\t\t}\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *) gf_list_get(ptr->list, i);\n\t\t\tif (ace->start_time >= ce->start_time) {\n\t\t\t\tgf_list_insert(ptr->list, ce, i);\n\t\t\t\tce = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ce) gf_list_add(ptr->list, ce);\n\t\tcount++;\n\t\tnb_chaps--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chpl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tcount = gf_list_count(ptr->list);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tu32 len;\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tgf_bs_write_u64(bs, ce->start_time);\n\t\tif (ce->name) {\n\t\t\tlen = (u32) strlen(ce->name);\n\t\t\tif (len>255) len = 255;\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ce->name, len);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err chpl_box_size(GF_Box *s)\n{\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\tptr->size += 5;\n\n\tcount = gf_list_count(ptr->list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tptr->size += 9; /*64bit time stamp + 8bit str len*/\n\t\tif (ce->name) ptr->size += strlen(ce->name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Err cprt_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguageCode[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[2] = gf_bs_read_int(bs, 5);\n\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguageCode[0] || ptr->packedLanguageCode[1] || ptr->packedLanguageCode[2]) {\n\t\tptr->packedLanguageCode[0] += 0x60;\n\t\tptr->packedLanguageCode[1] += 0x60;\n\t\tptr->packedLanguageCode[2] += 0x60;\n\t} else {\n\t\tptr->packedLanguageCode[0] = 'u';\n\t\tptr->packedLanguageCode[1] = 'n';\n\t\tptr->packedLanguageCode[2] = 'd';\n\t}\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tptr->notice = (char*)gf_malloc((bytesToRead+1) * sizeof(char));\n\t\tif (ptr->notice == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->notice, bytesToRead);\n\t\tptr->notice[bytesToRead] = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *cprt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CopyrightBox, GF_ISOM_BOX_TYPE_CPRT);\n\ttmp->packedLanguageCode[0] = 'u';\n\ttmp->packedLanguageCode[1] = 'n';\n\ttmp->packedLanguageCode[2] = 'd';\n\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cprt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 1);\n\tif (ptr->packedLanguageCode[0]) {\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[0] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[1] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[2] - 0x60, 5);\n\t} else {\n\t\tgf_bs_write_int(bs, 0, 15);\n\t}\n\tif (ptr->notice) {\n\t\tgf_bs_write_data(bs, ptr->notice, (u32) (strlen(ptr->notice) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err cprt_box_size(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tptr->size += 2;\n\tif (ptr->notice)\n\t\tptr->size += strlen(ptr->notice) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid kind_box_del(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->schemeURI) gf_free(ptr->schemeURI);\n\tif (ptr->value) gf_free(ptr->value);\n\tgf_free(ptr);\n}\n\nGF_Err kind_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tchar *data;\n\t\tu32 schemeURIlen;\n\t\tdata = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (!data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, data, bytesToRead);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (data[bytesToRead-1]) {\n\t\t\tdata = (char*)gf_realloc(data, sizeof(char)*(bytesToRead + 1));\n\t\t\tif (!data) return GF_OUT_OF_MEM;\n\t\t\tdata[bytesToRead] = 0;\n\t\t\tbytesToRead++;\n\t\t}\n\t\tptr->schemeURI = gf_strdup(data);\n\t\tif (!ptr->schemeURI) return GF_OUT_OF_MEM;\n\t\tschemeURIlen = (u32) strlen(data);\n\t\tif (bytesToRead > schemeURIlen+1) {\n\t\t\t/* read the value */\n\t\t\tchar *data_value = data + schemeURIlen +1;\n\t\t\tptr->value = gf_strdup(data_value);\n\t\t\tif (!ptr->value) return GF_OUT_OF_MEM;\n\t\t}\n\t\tgf_free(data);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *kind_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_KindBox, GF_ISOM_BOX_TYPE_KIND);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err kind_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n    if (ptr->schemeURI)\n        gf_bs_write_data(bs, ptr->schemeURI, (u32) (strlen(ptr->schemeURI) + 1 ));\n    else\n        gf_bs_write_u8(bs, 0);\n\n    if (ptr->value) {\n\t\tgf_bs_write_data(bs, ptr->value, (u32) (strlen(ptr->value) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err kind_box_size(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n    ptr->size += (ptr->schemeURI ? strlen(ptr->schemeURI) : 0) + 1;\n\tif (ptr->value) {\n\t\tptr->size += strlen(ptr->value) + 1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ctts_box_del(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err ctts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tu32 sampleCount;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_DttsEntry) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = (GF_DttsEntry *)gf_malloc(sizeof(GF_DttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\tsampleCount = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tif (ptr->version)\n\t\t\tptr->entries[i].decodingOffset = gf_bs_read_int(bs, 32);\n\t\telse\n\t\t\tptr->entries[i].decodingOffset = (s32) gf_bs_read_u32(bs);\n\n\t\tif (ptr->max_cts_delta <= ABS(ptr->entries[i].decodingOffset)) {\n\t\t\tptr->max_cts_delta = ABS(ptr->entries[i].decodingOffset);\n\t\t\t//ptr->sample_num_max_cts_delta = sampleCount;\n\t\t}\n\t\tsampleCount += ptr->entries[i].sampleCount;\n\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastSampleNumber = sampleCount;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *ctts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionOffsetBox, GF_ISOM_BOX_TYPE_CTTS);\n\treturn (GF_Box *) tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ctts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tif (ptr->version) {\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].decodingOffset, 32);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->entries[i].decodingOffset);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ctts_box_size(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cslg_box_del(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err cslg_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->compositionToDTSShift = gf_bs_read_int(bs, 32);\n\tptr->leastDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->greatestDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->compositionStartTime = gf_bs_read_int(bs, 32);\n\tptr->compositionEndTime = gf_bs_read_int(bs, 32);\n\treturn GF_OK;\n}\n\nGF_Box *cslg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionToDecodeBox, GF_ISOM_BOX_TYPE_CSLG);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cslg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->compositionToDTSShift, 32);\n\tgf_bs_write_int(bs, ptr->leastDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->greatestDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->compositionStartTime, 32);\n\tgf_bs_write_int(bs, ptr->compositionEndTime, 32);\n\treturn GF_OK;\n}\n\nGF_Err cslg_box_size(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tptr->size += 20;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ccst_box_del(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tif (ptr) gf_free(ptr);\n\treturn;\n}\n\nGF_Err ccst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->all_ref_pics_intra = gf_bs_read_int(bs, 1);\n\tptr->intra_pred_used = gf_bs_read_int(bs, 1);\n\tptr->max_ref_per_pic = gf_bs_read_int(bs, 4);\n\tptr->reserved = gf_bs_read_int(bs, 26);\n\treturn GF_OK;\n}\n\nGF_Box *ccst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CodingConstraintsBox, GF_ISOM_BOX_TYPE_CCST);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ccst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->all_ref_pics_intra, 1);\n\tgf_bs_write_int(bs, ptr->intra_pred_used, 1);\n\tgf_bs_write_int(bs, ptr->max_ref_per_pic, 4);\n\tgf_bs_write_int(bs, 0, 26);\n\treturn GF_OK;\n}\n\nGF_Err ccst_box_size(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid url_box_del(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif (ptr->size) {\n\t\tu32 location_size = (u32) ptr->size;\n\t\tif (location_size < 1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in svhd box\\n\", ptr->size));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->location = (char*)gf_malloc(location_size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, location_size);\n\t\tif (ptr->location[location_size-1]) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] url box location is not 0-terminated\\n\" ));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *url_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURLBox, GF_ISOM_BOX_TYPE_URL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err url_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err url_box_size(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid urn_box_del(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tif (ptr->nameURN) gf_free(ptr->nameURN);\n\tgf_free(ptr);\n}\n\n\nGF_Err urn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, to_read;\n\tchar *tmpName;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (! ptr->size ) return GF_OK;\n\n\t//here we have to handle that in a clever way\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\t//get the data\n\tgf_bs_read_data(bs, tmpName, to_read);\n\n\t//then get the break\n\ti = 0;\n\twhile ( (i < to_read) && (tmpName[i] != 0) ) {\n\t\ti++;\n\t}\n\t//check the data is consistent\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//no NULL char, URL is not specified\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;\n\t\tptr->location = NULL;\n\t\treturn GF_OK;\n\t}\n\t//OK, this has both URN and URL\n\tptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));\n\tif (!ptr->nameURN) {\n\t\tgf_free(tmpName);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(ptr->nameURN, tmpName, i + 1);\n\n\tif (tmpName[to_read - 1] != 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] urn box contains invalid location field\\n\" ));\n\t}\n\telse {\n\t\tptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));\n\t\tif (!ptr->location) {\n\t\t\tgf_free(tmpName);\n\t\t\tgf_free(ptr->nameURN);\n\t\t\tptr->nameURN = NULL;\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tmemcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));\n\t}\n\n\tgf_free(tmpName);\n\treturn GF_OK;\n}\n\nGF_Box *urn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURNBox, GF_ISOM_BOX_TYPE_URN);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err urn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\t//to check, the spec says: First name, then location\n\t\tif (ptr->nameURN) {\n\t\t\tgf_bs_write_data(bs, ptr->nameURN, (u32)strlen(ptr->nameURN) + 1);\n\t\t}\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err urn_box_size(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->nameURN) ptr->size += 1 + strlen(ptr->nameURN);\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid unkn_box_del(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err unkn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 bytesToRead, sub_size, sub_a;\n\tGF_BitStream *sub_bs;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (!bytesToRead) return GF_OK;\n\tif (bytesToRead>1000000) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unknown box %s (0x%08X) with payload larger than 1 MBytes, ignoring\\n\", gf_4cc_to_str(ptr->type), ptr->type ));\n\t\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\t\treturn GF_OK;\n\t}\n\n\tptr->data = (char*)gf_malloc(bytesToRead);\n\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\tptr->dataSize = bytesToRead;\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\n\t//try to parse container boxes, check if next 8 bytes match a subbox\n\tsub_bs = gf_bs_new(ptr->data, ptr->dataSize, GF_BITSTREAM_READ);\n\tsub_size = gf_bs_read_u32(sub_bs);\n\tsub_a = gf_bs_read_u8(sub_bs);\n\te = (sub_size && (sub_size <= ptr->dataSize)) ? GF_OK : GF_NOT_SUPPORTED;\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\n\tif (e == GF_OK) {\n\t\tgf_bs_seek(sub_bs, 0);\n\t\tgf_bs_set_cookie(sub_bs, GF_ISOM_BS_COOKIE_NO_LOGS);\n\t\te = gf_isom_box_array_read(s, sub_bs);\n\t}\n\tgf_bs_del(sub_bs);\n\tif (e==GF_OK) {\n\t\tgf_free(ptr->data);\n\t\tptr->data = NULL;\n\t\tptr->dataSize = 0;\n\t} else if (s->child_boxes) {\n\t\tgf_isom_box_array_del(s->child_boxes);\n\t\ts->child_boxes=NULL;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *unkn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownBox, GF_ISOM_BOX_TYPE_UNKNOWN);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err unkn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 type;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->original_4cc == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\ttype = s->type;\n\tptr->type = ptr->original_4cc;\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = type;\n\tif (e) return e;\n\n\tif (ptr->sai_type) {\n\t\tif (ptr->saio_box) {\n\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\tgf_bs_seek(bs, ptr->saio_box->offset_first_offset_field);\n\t\t\tif (ptr->saio_box->version)\n\t\t\t\tgf_bs_write_u64(bs, pos);\n\t\t\telse\n\t\t\t\tgf_bs_write_u32(bs, (u32) pos);\n\t\t\tgf_bs_seek(bs, pos);\n\t\t} else {\n\t\t\tptr->sai_offset = gf_bs_get_position(bs);\n\t\t}\n\t}\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err unkn_box_size(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tptr->size += ptr->dataSize;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid def_parent_box_del(GF_Box *s)\n{\n\tif (s) gf_free(s);\n}\n\n\nGF_Err def_parent_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *def_parent_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, 0);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITEHintSa\n\nGF_Err def_parent_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err def_parent_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid def_parent_full_box_del(GF_Box *s)\n{\n\tif (s) gf_free(s);\n}\n\n\nGF_Err def_parent_full_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *def_parent_full_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, 0);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITEHintSa\n\nGF_Err def_parent_full_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err def_parent_full_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid uuid_box_del(GF_Box *s)\n{\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err uuid_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead);\n\t\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\t\tptr->dataSize = bytesToRead;\n\t\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *uuid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownUUIDBox, GF_ISOM_BOX_TYPE_UUID);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err uuid_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox*)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err uuid_box_size(GF_Box *s)\n{\n\tGF_UnknownUUIDBox*ptr = (GF_UnknownUUIDBox*)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid dinf_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err dinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_DataInformationBox *ptr = (GF_DataInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_DREF:\n\t\tBOX_FIELD_ASSIGN(dref, GF_DataReferenceBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataInformationBox *dinf;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) {\n\t\treturn e;\n\t}\n\tdinf = (GF_DataInformationBox *)s;\n\tif (!dinf->dref) {\n\t\tif (! (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t}\n\t\tdinf->dref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&dinf->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *dinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataInformationBox, GF_ISOM_BOX_TYPE_DINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err dinf_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid dref_box_del(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *) s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err dref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tgf_bs_read_u32(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *dref_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataReferenceBox, GF_ISOM_BOX_TYPE_DREF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dref_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count;\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tcount = ptr->child_boxes ? gf_list_count(ptr->child_boxes) : 0;\n\tgf_bs_write_u32(bs, count);\n\treturn GF_OK;\n}\n\nGF_Err dref_box_size(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid edts_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err edts_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\tif (a->type == GF_ISOM_BOX_TYPE_ELST) {\n\t\tBOX_FIELD_ASSIGN(editList, GF_EditListBox)\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err edts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *edts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditBox, GF_ISOM_BOX_TYPE_EDTS);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err edts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (ptr->editList && gf_list_count(ptr->editList->entryList)) {\n\t\treturn gf_isom_box_write_header(s, bs);\n\t} else {\n\t\ts->size = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err edts_box_size(GF_Box *s)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (!ptr->editList || ! gf_list_count(ptr->editList->entryList)) {\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid elst_box_del(GF_Box *s)\n{\n\tGF_EditListBox *ptr;\n\tu32 nb_entries;\n\tu32 i;\n\n\tptr = (GF_EditListBox *)s;\n\tif (ptr == NULL) return;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tfor (i = 0; i < nb_entries; i++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (p) gf_free(p);\n\t}\n\tgf_list_del(ptr->entryList);\n\tgf_free(ptr);\n}\n\nGF_Err elst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\ts32 tr;\n\tu32 nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tnb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->version == 1) {\n\t\tif (nb_entries > ptr->size / 20) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (nb_entries > ptr->size / 12) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\n\tfor (entries = 0; entries < nb_entries; entries++) {\n\t\tGF_EdtsEntry *p;\n\t\tGF_SAFEALLOC(p, GF_EdtsEntry);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tif (ptr->version == 1) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\tp->segmentDuration = gf_bs_read_u64(bs);\n\t\t\tp->mediaTime = (s64) gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\t\tp->segmentDuration = gf_bs_read_u32(bs);\n\t\t\ttr = gf_bs_read_u32(bs);\n\t\t\tp->mediaTime = (s64) tr;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tp->mediaRate = gf_bs_read_u32(bs);\n\t\tgf_list_add(ptr->entryList, p);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditListBox, GF_ISOM_BOX_TYPE_ELST);\n\ttmp->entryList = gf_list_new();\n\tif (!tmp->entryList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tu32 nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\n\tnb_entries = gf_list_count(ptr->entryList);\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, nb_entries);\n\tfor (i = 0; i < nb_entries; i++ ) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (ptr->version == 1) {\n\t\t\tgf_bs_write_u64(bs, p->segmentDuration);\n\t\t\tgf_bs_write_u64(bs, p->mediaTime);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->segmentDuration);\n\t\t\tgf_bs_write_u32(bs, (s32) p->mediaTime);\n\t\t}\n\t\tgf_bs_write_u32(bs, p->mediaRate);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elst_box_size(GF_Box *s)\n{\n\tu32 durtimebytes;\n\tu32 i, nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\t//entry count\n\tptr->size += 4;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tptr->version = 0;\n\tfor (i=0; i<nb_entries; i++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif ((p->segmentDuration>0xFFFFFFFF) || (p->mediaTime>0xFFFFFFFF)) {\n\t\t\tptr->version = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdurtimebytes = (ptr->version == 1 ? 16 : 8) + 4;\n\tptr->size += (nb_entries * durtimebytes);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid esds_box_del(GF_Box *s)\n{\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\tif (ptr == NULL)\treturn;\n\tif (ptr->desc) gf_odf_desc_del((GF_Descriptor *)ptr->desc);\n\tgf_free(ptr);\n}\n\n\nGF_Err esds_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e=GF_OK;\n\tu32 descSize;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\n\tdescSize = (u32) (ptr->size);\n\n\tif (descSize) {\n\t\tchar *enc_desc = (char*)gf_malloc(sizeof(char) * descSize);\n\t\tif (!enc_desc) return GF_OUT_OF_MEM;\n\t\t//get the payload\n\t\tgf_bs_read_data(bs, enc_desc, descSize);\n\t\t//send it to the OD Codec\n\t\te = gf_odf_desc_read(enc_desc, descSize, (GF_Descriptor **) &ptr->desc);\n\t\t//OK, free our desc\n\t\tgf_free(enc_desc);\n\n\t\tif (ptr->desc && (ptr->desc->tag!=GF_ODF_ESD_TAG) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid descriptor tag 0x%x in esds\\n\", ptr->desc->tag));\n\t\t\tgf_odf_desc_del((GF_Descriptor*)ptr->desc);\n\t\t\tptr->desc=NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tif (e) {\n\t\t\tptr->desc = NULL;\n\t\t} else {\n\t\t\t/*fix broken files*/\n\t\t\tif (ptr->desc && !ptr->desc->URLString) {\n\t\t\t\tif (!ptr->desc->slConfig) {\n\t\t\t\t\tptr->desc->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t} else if (ptr->desc->slConfig->predefined != SLPredef_MP4) {\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t\tgf_odf_slc_set_pref(ptr->desc->slConfig);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *esds_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ESDBox, GF_ISOM_BOX_TYPE_ESDS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err esds_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu8 *enc_desc;\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\t//make sure we write with no ESID and no OCRESID\n    if (ptr->desc) {\n        ptr->desc->ESID = 0;\n        ptr->desc->OCRESID = 0;\n    }\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\te = gf_odf_desc_write((GF_Descriptor *)ptr->desc, &enc_desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, enc_desc, descSize);\n\t//free our buffer\n\tgf_free(enc_desc);\n\treturn GF_OK;\n}\n\nGF_Err esds_box_size(GF_Box *s)\n{\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\t//make sure we write with no ESID and no OCRESID\n    if (ptr->desc) {\n        ptr->desc->ESID = 0;\n        ptr->desc->OCRESID = 0;\n    }\n\tdescSize = gf_odf_desc_size((GF_Descriptor *)ptr->desc);\n\tptr->size += descSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid free_box_del(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err free_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\n\tif (ptr->size > 0xFFFFFFFF) return GF_IO_ERR;\n\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->data, bytesToRead);\n\t\tptr->dataSize = bytesToRead;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *free_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FreeSpaceBox, GF_ISOM_BOX_TYPE_FREE);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err free_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->original_4cc) {\n\t\tu32 t = s->type;\n\t\ts->type=ptr->original_4cc;\n\t\te = gf_isom_box_write_header(s, bs);\n\t\ts->type=t;\n\t} else {\n\t\te = gf_isom_box_write_header(s, bs);\n\t}\n\tif (e) return e;\n\tif (ptr->dataSize)\t{\n\t\tif (ptr->data) {\n\t\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t\t} else {\n\t\t\tu32 i = 0;\n\t\t\twhile (i<ptr->dataSize) {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err free_box_size(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ftyp_box_del(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\tif (ptr->altBrand) gf_free(ptr->altBrand);\n\tgf_free(ptr);\n}\n\nGF_Box *ftyp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FileTypeBox, GF_ISOM_BOX_TYPE_FTYP);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err ftyp_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->majorBrand = gf_bs_read_u32(bs);\n\tptr->minorVersion = gf_bs_read_u32(bs);\n\n\tif (ptr->size % 4) return GF_ISOM_INVALID_FILE;\n\tptr->altCount = ( (u32) (ptr->size)) / 4;\n\tif (!ptr->altCount) return GF_OK;\n\n\tptr->altBrand = (u32*)gf_malloc(sizeof(u32)*ptr->altCount);\n\tif (!ptr->altBrand) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i<ptr->altCount; i++) {\n\t\tptr->altBrand[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ftyp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->majorBrand);\n\tgf_bs_write_u32(bs, ptr->minorVersion);\n\tfor (i=0; i<ptr->altCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->altBrand[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ftyp_box_size(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tptr->size += 8 + ptr->altCount * 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnrm_box_del(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericSampleEntryBox, GF_ISOM_BOX_TYPE_GNRM);\n\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n//dummy\nGF_Err gnrm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tif (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRM;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrm_box_size(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRM;\n\tptr->size += 8+ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gnrv_box_del(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrv_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericVisualSampleEntryBox, GF_ISOM_BOX_TYPE_GNRV);\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnrv_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrv_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tif (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRV;\n\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)ptr, bs);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrv_box_size(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRV;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnra_box_del(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericAudioSampleEntryBox, GF_ISOM_BOX_TYPE_GNRA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err gnra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tif (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRA;\n\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox *)ptr, bs);\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gnra_box_size(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRA;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hdlr_box_del(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->nameUTF8) gf_free(ptr->nameUTF8);\n\tgf_free(ptr);\n}\n\n\nGF_Err hdlr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 cookie;\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->reserved1 = gf_bs_read_u32(bs);\n\tptr->handlerType = gf_bs_read_u32(bs);\n\tgf_bs_read_data(bs, (char*)ptr->reserved2, 12);\n\n\tcookie = gf_bs_get_cookie(bs);\n\tif (ptr->handlerType==GF_ISOM_MEDIA_VISUAL)\n\t\tcookie |= GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\telse\n\t\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\n\tif (ptr->size) {\n\t\tu32 name_size = (u32) ptr->size;\n\t\tif (name_size < 1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in hdlr\\n\", ptr->size));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->nameUTF8 = (char*)gf_malloc(name_size);\n\t\tif (!ptr->nameUTF8) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->nameUTF8, name_size);\n\n\t\t//patch for old QT files - we cannot rely on checking if str[0]==len(str+1) since we may have\n\t\t//cases where the first character of the string decimal value is indeed the same as the string length!!\n\t\t//we had this issue with encryption_import test\n\t\t//we therefore only check if last char is null, and if not so assume old QT style\n\t\tif (ptr->nameUTF8[name_size-1]) {\n\t\t\tif (name_size > 1)\n\t\t\t\tmemmove(ptr->nameUTF8, ptr->nameUTF8+1, sizeof(char) * (u32) (name_size-1) );\n\t\t\tptr->nameUTF8[name_size-1] = 0;\n\t\t\tptr->store_counted_string = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *hdlr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HandlerBox, GF_ISOM_BOX_TYPE_HDLR);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hdlr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->reserved1);\n\tgf_bs_write_u32(bs, ptr->handlerType);\n\tgf_bs_write_data(bs, (char*)ptr->reserved2, 12);\n\n\tif (ptr->nameUTF8) {\n\t\tu32 len = (u32)strlen(ptr->nameUTF8);\n\t\tif (ptr->store_counted_string) {\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err hdlr_box_size(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tptr->size += 20 + 1; //null term or counted string\n\tif (ptr->nameUTF8) {\n\t\tptr->size += strlen(ptr->nameUTF8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid hinf_box_del(GF_Box *s)\n{\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tgf_free(hinf);\n}\n\nGF_Box *hinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintInfoBox, GF_ISOM_BOX_TYPE_HINF);\n\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err hinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MAXR:\n\t\tif (!is_rem) {\n\t\t\tu32 i=0;\n\t\t\tGF_MAXRBox *maxR;\n\t\t\twhile ((maxR = (GF_MAXRBox *)gf_list_enum(hinf->child_boxes, &i))) {\n\t\t\t\tif ((maxR->type==GF_ISOM_BOX_TYPE_MAXR) && (maxR->granularity == ((GF_MAXRBox *)a)->granularity))\n\t\t\t\t\tERROR_ON_DUPLICATED_BOX(a, s)\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err hinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_HintInfoBox *ptr = (GF_HintInfoBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err hinf_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hmhd_box_del(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err hmhd_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 16);\n\tptr->maxPDUSize = gf_bs_read_u16(bs);\n\tptr->avgPDUSize = gf_bs_read_u16(bs);\n\tptr->maxBitrate = gf_bs_read_u32(bs);\n\tptr->avgBitrate = gf_bs_read_u32(bs);\n\tptr->slidingAverageBitrate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *hmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintMediaHeaderBox, GF_ISOM_BOX_TYPE_HMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->maxPDUSize);\n\tgf_bs_write_u16(bs, ptr->avgPDUSize);\n\tgf_bs_write_u32(bs, ptr->maxBitrate);\n\tgf_bs_write_u32(bs, ptr->avgBitrate);\n\tgf_bs_write_u32(bs, ptr->slidingAverageBitrate);\n\treturn GF_OK;\n}\n\nGF_Err hmhd_box_size(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tptr->size += 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hnti_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintTrackInfoBox, GF_ISOM_BOX_TYPE_HNTI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid hnti_box_del(GF_Box *a)\n{\n\tgf_free(a);\n}\n\nGF_Err hnti_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintTrackInfoBox *ptr = (GF_HintTrackInfoBox *)s;\n\tif (!ptr || !a) return GF_BAD_PARAM;\n\n\tswitch (a->type) {\n\t//this is the value for GF_RTPBox - same as HintSampleEntry for RTP !!!\n\tcase GF_ISOM_BOX_TYPE_RTP:\n\tcase GF_ISOM_BOX_TYPE_SDP:\n\t\tBOX_FIELD_ASSIGN(SDP, GF_Box)\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err hnti_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hnti_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\n\nGF_Err hnti_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tGF_SDPBox\n**********************************************************/\n\nvoid sdp_box_del(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err sdp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in sdp box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *sdp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SDPBox, GF_ISOM_BOX_TYPE_SDP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sdp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//don't write the NULL char!!!\n\tif (ptr->sdpText)\n\t\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\nGF_Err sdp_box_size(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\t//don't count the NULL char!!!\n\tif (ptr->sdpText)\n\t\tptr->size += strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid rtp_hnti_box_del(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err rtp_hnti_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->subType = gf_bs_read_u32(bs);\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in rtp_hnti box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\n\nGF_Box *rtp_hnti_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPBox, GF_ISOM_BOX_TYPE_RTP);\n\ttmp->subType = GF_ISOM_BOX_TYPE_SDP;\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtp_hnti_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->subType);\n\t//don't write the NULL char!!!\n\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\n\nGF_Err rtp_hnti_box_size(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tptr->size += 4 + strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTRPY GF_Box\n**********************************************************/\n\nvoid trpy_box_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err trpy_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *trpy_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TRPYBox, GF_ISOM_BOX_TYPE_TRPY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trpy_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err trpy_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTOTL GF_Box\n**********************************************************/\n\nvoid totl_box_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err totl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *totl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TOTLBox, GF_ISOM_BOX_TYPE_TOTL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err totl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err totl_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNUMP GF_Box\n**********************************************************/\n\nvoid nump_box_del(GF_Box *s)\n{\n\tgf_free((GF_NUMPBox *)s);\n}\nGF_Err nump_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbPackets = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *nump_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NUMPBox, GF_ISOM_BOX_TYPE_NUMP);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err nump_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err nump_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNPCK GF_Box\n**********************************************************/\n\nvoid npck_box_del(GF_Box *s)\n{\n\tgf_free((GF_NPCKBox *)s);\n}\nGF_Err npck_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbPackets = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *npck_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NPCKBox, GF_ISOM_BOX_TYPE_NPCK);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err npck_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err npck_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTPYL GF_Box\n**********************************************************/\n\nvoid tpyl_box_del(GF_Box *s)\n{\n\tgf_free((GF_NTYLBox *)s);\n}\nGF_Err tpyl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *tpyl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NTYLBox, GF_ISOM_BOX_TYPE_TPYL);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpyl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpyl_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTPAY GF_Box\n**********************************************************/\n\nvoid tpay_box_del(GF_Box *s)\n{\n\tgf_free((GF_TPAYBox *)s);\n}\nGF_Err tpay_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tpay_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TPAYBox, GF_ISOM_BOX_TYPE_TPAY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpay_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpay_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tMAXR GF_Box\n**********************************************************/\n\nvoid maxr_box_del(GF_Box *s)\n{\n\tgf_free((GF_MAXRBox *)s);\n}\nGF_Err maxr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->granularity = gf_bs_read_u32(bs);\n\tptr->maxDataRate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *maxr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MAXRBox, GF_ISOM_BOX_TYPE_MAXR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err maxr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->granularity);\n\tgf_bs_write_u32(bs, ptr->maxDataRate);\n\treturn GF_OK;\n}\nGF_Err maxr_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMED GF_Box\n**********************************************************/\n\nvoid dmed_box_del(GF_Box *s)\n{\n\tgf_free((GF_DMEDBox *)s);\n}\nGF_Err dmed_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dmed_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMEDBox, GF_ISOM_BOX_TYPE_DMED);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmed_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dmed_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDIMM GF_Box\n**********************************************************/\n\nvoid dimm_box_del(GF_Box *s)\n{\n\tgf_free((GF_DIMMBox *)s);\n}\nGF_Err dimm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dimm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMMBox, GF_ISOM_BOX_TYPE_DIMM);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dimm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dimm_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDREP GF_Box\n**********************************************************/\n\nvoid drep_box_del(GF_Box *s)\n{\n\tgf_free((GF_DREPBox *)s);\n}\nGF_Err drep_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *drep_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DREPBox, GF_ISOM_BOX_TYPE_DREP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err drep_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err drep_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n/**********************************************************\n\t\tTMIN GF_Box\n**********************************************************/\n\nvoid tmin_box_del(GF_Box *s)\n{\n\tgf_free((GF_TMINBox *)s);\n}\nGF_Err tmin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->minTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMINBox, GF_ISOM_BOX_TYPE_TMIN);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->minTime);\n\treturn GF_OK;\n}\nGF_Err tmin_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTMAX GF_Box\n**********************************************************/\n\nvoid tmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_TMAXBox *)s);\n}\nGF_Err tmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMAXBox, GF_ISOM_BOX_TYPE_TMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxTime);\n\treturn GF_OK;\n}\nGF_Err tmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPMAX GF_Box\n**********************************************************/\n\nvoid pmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_PMAXBox *)s);\n}\nGF_Err pmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxSize = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *pmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PMAXBox, GF_ISOM_BOX_TYPE_PMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err pmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxSize);\n\treturn GF_OK;\n}\nGF_Err pmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMAX GF_Box\n**********************************************************/\n\nvoid dmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_DMAXBox *)s);\n}\nGF_Err dmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxDur = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *dmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMAXBox, GF_ISOM_BOX_TYPE_DMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxDur);\n\treturn GF_OK;\n}\nGF_Err dmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid payt_box_del(GF_Box *s)\n{\n\tGF_PAYTBox *payt = (GF_PAYTBox *)s;\n\tif (payt->payloadString) gf_free(payt->payloadString);\n\tgf_free(payt);\n}\nGF_Err payt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5 );\n\tptr->payloadCode = gf_bs_read_u32(bs);\n\tlength = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, length);\n\tptr->payloadString = (char*)gf_malloc(sizeof(char) * (length+1) );\n\tif (! ptr->payloadString) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->payloadString, length);\n\tptr->payloadString[length] = 0;\n\n\treturn GF_OK;\n}\nGF_Box *payt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PAYTBox, GF_ISOM_BOX_TYPE_PAYT);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err payt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_Err e;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->payloadCode);\n    len = ptr->payloadString ? (u32) strlen(ptr->payloadString) : 0;\n\tgf_bs_write_u8(bs, len);\n\tif (len) gf_bs_write_data(bs, ptr->payloadString, len);\n\treturn GF_OK;\n}\nGF_Err payt_box_size(GF_Box *s)\n{\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\ts->size += 4 + 1;\n\tif (ptr->payloadString) ptr->size += strlen(ptr->payloadString);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid name_box_del(GF_Box *s)\n{\n\tGF_NameBox *name = (GF_NameBox *)s;\n\tif (name->string) gf_free(name->string);\n\tgf_free(name);\n}\nGF_Err name_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in name box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->string = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (! ptr->string) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->string, length);\n\tptr->string[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *name_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NameBox, GF_ISOM_BOX_TYPE_NAME);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err name_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->string) {\n\t\tgf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string) + 1);\n\t}\n\treturn GF_OK;\n}\nGF_Err name_box_size(GF_Box *s)\n{\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr->string) ptr->size += strlen(ptr->string) + 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tssy_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err tssy_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tgf_bs_read_int(bs, 6);\n\tptr->timestamp_sync = gf_bs_read_int(bs, 2);\n\treturn GF_OK;\n}\nGF_Box *tssy_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeStampSynchronyBox, GF_ISOM_BOX_TYPE_TSSY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tssy_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 6);\n\tgf_bs_write_int(bs, ptr->timestamp_sync, 2);\n\treturn GF_OK;\n}\nGF_Err tssy_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid srpp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err srpp_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_SCHI:\n\t\tBOX_FIELD_ASSIGN(info, GF_SchemeInformationBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SCHM:\n\t\tBOX_FIELD_ASSIGN(scheme_type, GF_SchemeTypeBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err srpp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 16)\n\tptr->encryption_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->encryption_algorithm_rtcp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtcp = gf_bs_read_u32(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\nGF_Box *srpp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SRTPProcessBox, GF_ISOM_BOX_TYPE_SRPP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err srpp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtcp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtcp);\n\n\treturn GF_OK;\n}\nGF_Err srpp_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\ts->size += 16;\n\tgf_isom_check_position(s, (GF_Box*)ptr->info, &pos);\n\tgf_isom_check_position(s, (GF_Box*)ptr->scheme_type, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid rssr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err rssr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->ssrc = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *rssr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ReceivedSsrcBox, GF_ISOM_BOX_TYPE_RSSR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rssr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->ssrc);\n\treturn GF_OK;\n}\nGF_Err rssr_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid iods_box_del(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->descriptor) gf_odf_desc_del(ptr->descriptor);\n\tgf_free(ptr);\n}\n\n\nGF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tchar *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\t//use the OD codec...\n\tdescSize = (u32) (ptr->size);\n\tdesc = (char*)gf_malloc(sizeof(char) * descSize);\n\tif (!desc) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, desc, descSize);\n\te = gf_odf_desc_read(desc, descSize, &ptr->descriptor);\n\t//OK, free our desc\n\tgf_free(desc);\n\n\tif (e) return e;\n\tswitch (ptr->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid descriptor in iods, tag %u found but only %u or %u allowed\\n\", ptr->descriptor->tag, GF_ODF_ISOM_IOD_TAG, GF_ODF_ISOM_OD_TAG ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *iods_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ObjectDescriptorBox, GF_ISOM_BOX_TYPE_IODS);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err iods_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tu8 *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//call our OD codec\n\te = gf_odf_desc_write(ptr->descriptor, &desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, desc, descSize);\n\t//and free our stuff maybe!!\n\tgf_free(desc);\n\treturn GF_OK;\n}\n\nGF_Err iods_box_size(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\tptr->size += gf_odf_desc_size(ptr->descriptor);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdat_box_del(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (!s) return;\n\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdat_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_IMDA) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_MDAT;\n\t\tptr->is_imda = 1;\n\t\tISOM_DECREASE_SIZE(s, 4)\n\t\tptr->imda_id = gf_bs_read_u32(bs);\n\t}\n\n\tptr->dataSize = s->size;\n\tptr->bsOffset = gf_bs_get_position(bs);\n\n\t//store idat for rewrite\n\tif (ptr->type==GF_ISOM_BOX_TYPE_IDAT) {\n\t\tptr->data = gf_malloc(sizeof(u8) * (size_t)ptr->dataSize);\n\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->data, (u32) ptr->dataSize);\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\t//then skip these bytes\n\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Box *mdat_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaDataBox, GF_ISOM_BOX_TYPE_MDAT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdat_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (ptr->is_imda) {\n\t\ts->type = GF_ISOM_BOX_TYPE_IMDA;\n\t\te = gf_isom_box_write_header(s, bs);\n\t\ts->type = GF_ISOM_BOX_TYPE_MDAT;\n\t\tif (e) return e;\n\t\tgf_bs_write_u32(bs, ptr->imda_id);\n\t} else {\n\t\te = gf_isom_box_write_header(s, bs);\n\t\tif (e) return e;\n\t}\n\n\t//make sure we have some data ...\n\t//if not, we handle that independently (edit files)\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, (u32) ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mdat_box_size(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tptr->size += ptr->dataSize;\n\tif (ptr->is_imda)\n\t\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdhd_box_del(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mdhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 28)\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Media header timescale is 0 - defaulting to 90000\\n\" ));\n\t\tptr->timeScale = 90000;\n\t}\n\n\tptr->original_duration = ptr->duration;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\t//our padding bit\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguage[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[2] = gf_bs_read_int(bs, 5);\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguage[0] || ptr->packedLanguage[1] || ptr->packedLanguage[2]) {\n\t\tptr->packedLanguage[0] += 0x60;\n\t\tptr->packedLanguage[1] += 0x60;\n\t\tptr->packedLanguage[2] += 0x60;\n\t} else {\n\t\tptr->packedLanguage[0] = 'u';\n\t\tptr->packedLanguage[1] = 'n';\n\t\tptr->packedLanguage[2] = 'd';\n\t}\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mdhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaHeaderBox, GF_ISOM_BOX_TYPE_MDHD);\n\n\ttmp->packedLanguage[0] = 'u';\n\ttmp->packedLanguage[1] = 'n';\n\ttmp->packedLanguage[2] = 'd';\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\t//SPECS: BIT(1) of padding\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_int(bs, ptr->packedLanguage[0] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[1] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[2] - 0x60, 5);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err mdhd_box_size(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += 4;\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mdia_box_del(GF_Box *s)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->nalu_parser) gf_bs_del(ptr->nalu_parser);\n\tif (ptr->nalu_out_bs) gf_bs_del(ptr->nalu_out_bs);\n\tif (ptr->nalu_ps_bs) gf_bs_del(ptr->nalu_ps_bs);\n\tif (ptr->extracted_bs) gf_bs_del(ptr->extracted_bs);\n\tif (ptr->extracted_samp) gf_isom_sample_del(&ptr->extracted_samp);\n\tif (ptr->in_sample_buffer) gf_free(ptr->in_sample_buffer);\n\tif (ptr->tmp_nal_copy_buffer) gf_free(ptr->tmp_nal_copy_buffer);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdia_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_MDHD:\n\t\tBOX_FIELD_ASSIGN(mediaHeader, GF_MediaHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_HDLR:\n\t\tBOX_FIELD_ASSIGN(handler, GF_HandlerBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MINF:\n\t\tBOX_FIELD_ASSIGN(information, GF_MediaInformationBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err mdia_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 cookie = gf_bs_get_cookie(bs);\n\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\te = gf_isom_box_array_read(s, bs);\n\tgf_bs_set_cookie(bs, cookie);\n\n\tif (e) return e;\n\tif (!((GF_MediaBox *)s)->information) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->handler) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing HandlerBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->mediaHeader) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mdia_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_MDIA);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdia_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mdia_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box*)ptr->mediaHeader, &pos);\n\t//then handler\n\tgf_isom_check_position(s, (GF_Box*)ptr->handler, &pos);\n\n#if 0\n\t//elng before info for CMAF info - we deactiveate for now, no specific errors raised and CMAF should not impose any order\n\tGF_Box *elng = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ELNG);\n\tif (elng)\n\t\tgf_isom_check_position(s, elng, &pos);\n#endif\n\n\t//then info\n\tgf_isom_check_position(s, (GF_Box*)ptr->information, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mfra_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->tfra_list);\n\tgf_free(ptr);\n}\n\nGF_Box *mfra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_MFRA);\n\ttmp->tfra_list = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfra_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFRA:\n\t\tBOX_FIELD_LIST_ASSIGN(tfra_list);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MFRO:\n\t\tBOX_FIELD_ASSIGN(mfro, GF_MovieFragmentRandomAccessOffsetBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mfra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mfra_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tgf_isom_check_position_list(s, ptr->tfra_list, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->mfro, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tfra_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Box *tfra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_TFRA);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err tfra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_RandomAccessEntry *p = 0;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\n\tptr->track_id = gf_bs_read_u32(bs);\n\tif (gf_bs_read_int(bs, 26) != 0)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->traf_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\tptr->trun_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\tptr->sample_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->version == 1) {\n\t\tif (ptr->nb_entries > ptr->size / (16+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (ptr->nb_entries > ptr->size / (8+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\tif (ptr->nb_entries) {\n\t\tif ((u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_RandomAccessEntry)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tp = (GF_RandomAccessEntry *) gf_malloc(sizeof(GF_RandomAccessEntry) * ptr->nb_entries);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t}\n\n\tptr->entries = p;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tmemset(p, 0, sizeof(GF_RandomAccessEntry));\n\n\t\tif (ptr->version == 1) {\n\t\t\tp->time = gf_bs_read_u64(bs);\n\t\t\tp->moof_offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tp->time = gf_bs_read_u32(bs);\n\t\t\tp->moof_offset = gf_bs_read_u32(bs);\n\t\t}\n\t\tp->traf_number = gf_bs_read_int(bs, ptr->traf_bits);\n\t\tp->trun_number = gf_bs_read_int(bs, ptr->trun_bits);\n\t\tp->sample_number = gf_bs_read_int(bs, ptr->sample_bits);\n\n\t\t++p;\n\t}\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, sap_nb_entries;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->track_id);\n\tgf_bs_write_int(bs, 0, 26);\n\n\tgf_bs_write_int(bs, ptr->traf_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->trun_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->sample_bits/8 - 1, 2);\n\n\tsap_nb_entries = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (p->trun_number) sap_nb_entries++;\n\t}\n\n\tgf_bs_write_u32(bs, sap_nb_entries);\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (!p->trun_number) continue;\n\t\tif (ptr->version==1) {\n\t\t\tgf_bs_write_u64(bs, p->time);\n\t\t\tgf_bs_write_u64(bs, p->moof_offset);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->time);\n\t\t\tgf_bs_write_u32(bs, (u32) p->moof_offset);\n\t\t}\n\t\tgf_bs_write_int(bs, p->traf_number, ptr->traf_bits);\n\t\tgf_bs_write_int(bs, p->trun_number, ptr->trun_bits);\n\t\tgf_bs_write_int(bs, p->sample_number, ptr->sample_bits);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfra_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\tptr->size += 12;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (!p->trun_number) continue;\n\t\tptr->size +=  ((ptr->version==1) ? 16 : 8 ) + ptr->traf_bits/8 + ptr->trun_bits/8 + ptr->sample_bits/8;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid mfro_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Box *mfro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessOffsetBox, GF_ISOM_BOX_TYPE_MFRO);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->container_size = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->container_size);\n\treturn GF_OK;\n}\n\nGF_Err mfro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid elng_box_del(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->extended_language) gf_free(ptr->extended_language);\n\tgf_free(ptr);\n}\n\nGF_Err elng_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->size) {\n\t\tptr->extended_language = (char*)gf_malloc((u32) ptr->size);\n\t\tif (ptr->extended_language == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->extended_language, (u32) ptr->size);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (ptr->extended_language[ptr->size-1]) {\n\t\t\tchar *str = (char*)gf_malloc((u32) ptr->size + 1);\n\t\t\tif (!str) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(str, ptr->extended_language, (u32) ptr->size);\n\t\t\tstr[ptr->size] = 0;\n\t\t\tgf_free(ptr->extended_language);\n\t\t\tptr->extended_language = str;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elng_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_ELNG);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elng_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->extended_language) {\n\t\tgf_bs_write_data(bs, ptr->extended_language, (u32)(strlen(ptr->extended_language)+1));\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elng_box_size(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->extended_language) {\n\t\tptr->size += strlen(ptr->extended_language)+1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mfhd_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mfhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->sequence_number = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mfhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentHeaderBox, GF_ISOM_BOX_TYPE_MFHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mfhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->sequence_number);\n\treturn GF_OK;\n}\n\nGF_Err mfhd_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid minf_box_del(GF_Box *s)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\t//if we have a Handler not self-contained, delete it (the self-contained belongs to the movie)\n\tif (ptr->dataHandler) {\n\t\tgf_isom_datamap_close(ptr);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err minf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_NMHD:\n\tcase GF_ISOM_BOX_TYPE_STHD:\n\tcase GF_ISOM_BOX_TYPE_VMHD:\n\tcase GF_ISOM_BOX_TYPE_SMHD:\n\tcase GF_ISOM_BOX_TYPE_HMHD:\n\tcase GF_ISOM_BOX_TYPE_GMHD:\n\t\tBOX_FIELD_ASSIGN(InfoHeader, GF_Box)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_DINF:\n\t\tBOX_FIELD_ASSIGN(dataInformation, GF_DataInformationBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_STBL:\n\t\tBOX_FIELD_ASSIGN(sampleTable, GF_SampleTableBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err minf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tGF_Err e;\n\n\te = gf_isom_box_array_read(s, bs);\n\n\tif (!e && ! ptr->dataInformation) {\n\t\tGF_Box *url;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing DataInformationBox\\n\"));\n\t\t//commented on purpose, we are still able to handle the file, we only throw an error but keep processing\n//\t\te = GF_ISOM_INVALID_FILE;\n\n\t\t//add a dinf box to avoid any access to a null dinf\n\t\tptr->dataInformation = (GF_DataInformationBox *) gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DINF);\n\t\tif (!ptr->dataInformation) return GF_OUT_OF_MEM;\n\n\t\tptr->dataInformation->dref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&ptr->dataInformation->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t\tif (!ptr->dataInformation->dref) return GF_OUT_OF_MEM;\n\n\t\turl = gf_isom_box_new_parent(&ptr->dataInformation->dref->child_boxes, GF_ISOM_BOX_TYPE_URL);\n\t\tif (!url) return GF_OUT_OF_MEM;\n\t\t((GF_FullBox*)url)->flags = 1;\n\t}\n\treturn e;\n}\n\nGF_Box *minf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaInformationBox, GF_ISOM_BOX_TYPE_MINF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err minf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err minf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box *)ptr->InfoHeader, &pos);\n\t//then dataInfo\n\tgf_isom_check_position(s, (GF_Box *)ptr->dataInformation, &pos);\n\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_MVCI), &pos);\n\t//then sampleTable\n\tgf_isom_check_position(s, (GF_Box *)ptr->sampleTable, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid moof_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tif (ptr == NULL) return;\n\n\tgf_list_del(ptr->TrackList);\n\tif (ptr->PSSHs) gf_list_del(ptr->PSSHs);\n\tif (ptr->mdat) gf_free(ptr->mdat);\n\t//happens if error while fragmenting, the emsg boxes are not part of the moof hierarchy !\n\tif (ptr->emsgs) {\n\t\twhile (1) {\n\t\t\tGF_Box *emsg = gf_list_pop_front(ptr->emsgs);\n\t\t\tif (!emsg) break;\n\t\t\tgf_isom_box_del(emsg);\n\t\t}\n\t\tgf_list_del(ptr->emsgs);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err moof_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MFHD:\n\t\tBOX_FIELD_ASSIGN(mfhd, GF_MovieFragmentHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRAF:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\tBOX_FIELD_LIST_ASSIGN(PSSHs)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err moof_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *moof_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentBox, GF_ISOM_BOX_TYPE_MOOF);\n\ttmp->TrackList = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err moof_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err moof_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\t//Header First\n\tgf_isom_check_position(s, (GF_Box *)ptr->mfhd, &pos);\n\t//then PSSH\n\tgf_isom_check_position_list(s, ptr->PSSHs, &pos);\n\t//then the track list\n\tgf_isom_check_position_list(s, ptr->TrackList, &pos);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\nvoid moov_box_del(GF_Box *s)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->trackList);\n\tgf_free(ptr);\n}\n\nGF_Err moov_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_IODS:\n\t\tBOX_FIELD_ASSIGN(iods, GF_ObjectDescriptorBox)\n\t\t//if no IOD, delete the box\n\t\tif (ptr->iods && !ptr->iods->descriptor) {\n\t\t\tptr->iods = NULL;\n\t\t\tgf_isom_box_del_parent(&s->child_boxes, a);\n\t\t}\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MVHD:\n\t\tBOX_FIELD_ASSIGN(mvhd, GF_MovieHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tBOX_FIELD_ASSIGN(udta, GF_UserDataBox)\n\t\treturn GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tcase GF_ISOM_BOX_TYPE_MVEX:\n\t\tBOX_FIELD_ASSIGN(mvex, GF_MovieExtendsBox)\n\t\tif (ptr->mvex)\n\t\t\tptr->mvex->mov = ptr->mov;\n\t\treturn GF_OK;\n#endif\n\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tBOX_FIELD_ASSIGN(meta, GF_MetaBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_TRAK:\n\t\tif (is_rem) {\n\t\t\tgf_list_del_item(ptr->trackList, a);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t{\n\t\t\tGF_TrackBox *tk = (GF_TrackBox *)a;\n\t\t\t//set our pointer to this obj\n\t\t\ttk->moov = ptr;\n\t\t\ttk->index = gf_list_count(ptr->trackList);\n\t\t\tif (tk->References) {\n\t\t\t\tGF_TrackReferenceTypeBox *dpnd=NULL;\n\t\t\t\tTrack_FindRef(tk, GF_ISOM_REF_BASE, &dpnd);\n\t\t\t\tif (dpnd)\n\t\t\t\t\ttk->nb_base_refs = dpnd->trackIDCount;\n\t\t\t}\n\t\t}\n\t\treturn gf_list_add(ptr->trackList, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err moov_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *moov_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieBox, GF_ISOM_BOX_TYPE_MOOV);\n\ttmp->trackList = gf_list_new();\n\tif (!tmp->trackList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err moov_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err moov_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *) ptr->mvhd, &pos);\n\tgf_isom_check_position(s, (GF_Box *) ptr->iods, &pos);\n\tgf_isom_check_position(s, (GF_Box *) ptr->meta, &pos);\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex && !ptr->mvex_after_traks) {\n\t\tgf_isom_check_position(s, (GF_Box *) ptr->mvex, &pos);\n\t}\n#endif\n\tgf_isom_check_position_list(s, ptr->trackList, &pos);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex && ptr->mvex_after_traks) {\n\t\tgf_isom_check_position(s, (GF_Box *) ptr->mvex, &pos);\n\t}\n#endif\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid audio_sample_entry_box_del(GF_Box *s)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err audio_sample_entry_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_UnknownBox *wave = NULL;\n\tBool drop_wave=GF_FALSE;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_DAMR:\n\tcase GF_ISOM_BOX_TYPE_DEVC:\n\tcase GF_ISOM_BOX_TYPE_DQCP:\n\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\tBOX_FIELD_ASSIGN(cfg_3gpp, GF_3GPPConfigBox)\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_DOPS:\n\t\tBOX_FIELD_ASSIGN(cfg_opus, GF_OpusSpecificBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAC3:\n\t\tBOX_FIELD_ASSIGN(cfg_ac3, GF_AC3ConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DEC3:\n\t\tBOX_FIELD_ASSIGN(cfg_ac3, GF_AC3ConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DMLP:\n\t\tBOX_FIELD_ASSIGN(cfg_mlp, GF_TrueHDConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MHAC:\n\t\tBOX_FIELD_ASSIGN(cfg_mha, GF_MHAConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DFLA:\n\t\tBOX_FIELD_ASSIGN(cfg_flac, GF_FLACConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\twave = (GF_UnknownBox *)a;\n\t\t/*HACK for QT files: get the esds box from the track*/\n\t\tif (s->type == GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\tif (is_rem) {\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\t//wave subboxes may have been properly parsed\n \t\t\tif ((wave->original_4cc == GF_QT_BOX_TYPE_WAVE) && gf_list_count(wave->child_boxes)) {\n \t\t\t\tu32 i;\n                for (i =0; i<gf_list_count(wave->child_boxes); i++) {\n                    GF_Box *inner_box = (GF_Box *)gf_list_get(wave->child_boxes, i);\n                    if (inner_box->type == GF_ISOM_BOX_TYPE_ESDS) {\n                        ptr->esd = (GF_ESDBox *)inner_box;\n \t\t\t\t\t\tif (ptr->qtff_mode & GF_ISOM_AUDIO_QTFF_CONVERT_FLAG) {\n                        \tgf_list_rem(a->child_boxes, i);\n                        \tdrop_wave=GF_TRUE;\n                        \tptr->compression_id = 0;\n                        \tgf_list_add(ptr->child_boxes, inner_box);\n\t\t\t\t\t\t}\n                    }\n                }\n\t\t\t\tif (drop_wave) {\n\t\t\t\t\tgf_isom_box_del_parent(&ptr->child_boxes, a);\n                \tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\t\t\t\tptr->version = 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n                ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n                return GF_OK;\n            }\n            gf_isom_box_del_parent(&ptr->child_boxes, a);\n            return GF_ISOM_INVALID_MEDIA;\n\n\t\t}\n \t\tptr->qtff_mode &= ~GF_ISOM_AUDIO_QTFF_CONVERT_FLAG;\n\n \t\tif ((wave->original_4cc == GF_QT_BOX_TYPE_WAVE) && gf_list_count(wave->child_boxes)) {\n\t\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\t\t}\n\t\treturn GF_OK;\n\tcase GF_QT_BOX_TYPE_WAVE:\n\t{\n\t\tu32 subtype = 0;\n\t\tGF_Box **cfg_ptr = NULL;\n\t\tif (s->type == GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->esd;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_ESDS;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_AC3) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_ac3;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DAC3;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_EC3) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_ac3;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DEC3;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_OPUS) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_opus;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DOPS;\n\t\t}\n\t\telse if ((s->type == GF_ISOM_BOX_TYPE_MHA1)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHA2)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHM1)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHM2)\n\t\t) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_mha;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_MHAC;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_mlp;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DMLP;\n\t\t}\n\n\t\tif (cfg_ptr) {\n\t\t\tif (is_rem) {\n\t\t\t\t*cfg_ptr = NULL;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (*cfg_ptr) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\t//wave subboxes may have been properly parsed\n \t\t\tif (gf_list_count(a->child_boxes)) {\n \t\t\t\tu32 i;\n                for (i =0; i<gf_list_count(a->child_boxes); i++) {\n                    GF_Box *inner_box = (GF_Box *)gf_list_get(a->child_boxes, i);\n                    if (inner_box->type == subtype) {\n                        *cfg_ptr = inner_box;\n \t\t\t\t\t\tif (ptr->qtff_mode & GF_ISOM_AUDIO_QTFF_CONVERT_FLAG) {\n                        \tgf_list_rem(a->child_boxes, i);\n                        \tdrop_wave=GF_TRUE;\n                        \tgf_list_add(ptr->child_boxes, inner_box);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n                    }\n                }\n\t\t\t\tif (drop_wave) {\n\t\t\t\t\tgf_isom_box_del_parent(&ptr->child_boxes, a);\n                \tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\t\t\t\tptr->compression_id = 0;\n\t\t\t\t\tptr->version = 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n                ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n                return GF_OK;\n            }\n\t\t}\n\t}\n \t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\nGF_Err audio_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_QT_CONV) {\n \t\tptr->qtff_mode |= GF_ISOM_AUDIO_QTFF_CONVERT_FLAG;\n \t}\n\n\te = gf_isom_box_array_read(s, bs);\n\tif (!e) {\n\t\tif (s->type==GF_ISOM_BOX_TYPE_ENCA) {\n\t\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\tif (sinf && sinf->original_format) {\n\t\t\t\tu32 type = sinf->original_format->data_format;\n\t\t\t\tswitch (type) {\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\t\tif (ptr->cfg_3gpp) ptr->cfg_3gpp->cfg.type = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tif (!data) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\tgf_bs_set_cookie(mybs, GF_ISOM_BS_COOKIE_NO_LOGS);\n\t\t\tif (ptr->esd) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *)ptr->esd);\n\t\t\tptr->esd = NULL;\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\t\t\tgf_bs_del(mybs);\n\n\t\t\tif ((e==GF_OK) && ptr->esd && (ptr->esd->type == GF_ISOM_BOX_TYPE_ESDS)) {\n\t\t\t\tif (!ptr->child_boxes) ptr->child_boxes = gf_list_new();\n\t\t\t\tgf_list_add(ptr->child_boxes, ptr->esd);\n\t\t\t} else if (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd = NULL;\n\t\t\t}\n\t\t\te = GF_OK;\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}\n\nGF_Box *audio_sample_entry_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_MP4A);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *enca_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_ENCA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err audio_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox*)s, bs);\n\treturn GF_OK;\n}\n\nGF_Err audio_sample_entry_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox*)s);\n\tif (ptr->qtff_mode)\n\t\treturn GF_OK;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_mha, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_opus, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_ac3, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_flac, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_mlp, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gen_sample_entry_box_del(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(ptr);\n}\n\n\nGF_Err gen_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)s, bs);\n\tif (e) return e;\n\tISOM_DECREASE_SIZE(s, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *gen_sample_entry_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleEntryBox, GF_QT_SUBTYPE_C608);//type will be overriten\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gen_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err gen_sample_entry_box_size(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mp4s_box_del(GF_Box *s)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err mp4s_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mp4s_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *encs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mp4s_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n    return GF_OK;\n}\n\nGF_Err mp4s_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n    return GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid video_sample_entry_box_del(GF_Box *s)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\t/*for publishing*/\n\tif (ptr->emul_esd) gf_odf_desc_del((GF_Descriptor *)ptr->emul_esd);\n\tgf_free(ptr);\n}\n\nGF_Err video_sample_entry_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RINF:\n\t\tBOX_FIELD_ASSIGN(rinf, GF_RestrictedSchemeInfoBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVCC:\n\t\tBOX_FIELD_ASSIGN(avc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVCC:\n\t\tBOX_FIELD_ASSIGN(hevc_config, GF_HEVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VVCC:\n\t\tBOX_FIELD_ASSIGN(vvc_config, GF_VVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVCC:\n\t\tBOX_FIELD_ASSIGN(svc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MVCC:\n\t\tBOX_FIELD_ASSIGN(mvc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHVC:\n\t\tBOX_FIELD_ASSIGN(lhvc_config, GF_HEVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV1C:\n\t\tBOX_FIELD_ASSIGN(av1_config, GF_AV1ConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VPCC:\n\t\tBOX_FIELD_ASSIGN(vp_config, GF_VPConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DVCC:\n\tcase GF_ISOM_BOX_TYPE_DVVC:\n\t\tBOX_FIELD_ASSIGN(dovi_config, GF_DOVIConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (! memcmp(((GF_UnknownUUIDBox*)a)->uuid, GF_ISOM_IPOD_EXT, 16)) {\n\t\t\tBOX_FIELD_ASSIGN(ipod_ext, GF_UnknownUUIDBox)\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_D263:\n\t\tBOX_FIELD_ASSIGN(cfg_3gpp, GF_3GPPConfigBox)\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tif (ptr->cfg_3gpp)\n\t\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_JP2H:\n\t\tBOX_FIELD_ASSIGN(jp2h, GF_J2KHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_PASP:\n\tcase GF_ISOM_BOX_TYPE_CLAP:\n\tcase GF_ISOM_BOX_TYPE_COLR:\n\tcase GF_ISOM_BOX_TYPE_MDCV:\n\tcase GF_ISOM_BOX_TYPE_CLLI:\n\tcase GF_ISOM_BOX_TYPE_CCST:\n\tcase GF_ISOM_BOX_TYPE_AUXI:\n\tcase GF_ISOM_BOX_TYPE_RVCC:\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tif (!is_rem && !gf_isom_box_check_unique(s->child_boxes, a)) {\n\t\t\tERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err video_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGVisualSampleEntryBox *mp4v = (GF_MPEGVisualSampleEntryBox*)s;\n\tGF_Err e;\n\te = gf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *)s, bs);\n\tif (e) return e;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\t/*this is an AVC sample desc*/\n\tif (mp4v->avc_config || mp4v->svc_config || mp4v->mvc_config)\n\t\tAVC_RewriteESDescriptor(mp4v);\n\t/*this is an HEVC sample desc*/\n\tif (mp4v->hevc_config || mp4v->lhvc_config || (mp4v->type==GF_ISOM_BOX_TYPE_HVT1))\n\t\tHEVC_RewriteESDescriptor(mp4v);\n\t/*this is an AV1 sample desc*/\n\tif (mp4v->av1_config)\n\t\tAV1_RewriteESDescriptor(mp4v);\n\t/*this is a VP8-9 sample desc*/\n\tif (mp4v->vp_config)\n\t\tVP9_RewriteESDescriptor(mp4v);\n\n\tif (s->type==GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\tif (sinf && sinf->original_format) {\n\t\t\tu32 type = sinf->original_format->data_format;\n\t\t\tswitch (type) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tif (mp4v->cfg_3gpp) mp4v->cfg_3gpp->cfg.type = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *video_sample_entry_box_new()\n{\n\tGF_MPEGVisualSampleEntryBox *tmp;\n\tGF_SAFEALLOC(tmp, GF_MPEGVisualSampleEntryBox);\n\tif (tmp == NULL) return NULL;\n\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox *)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err video_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)s, bs);\n\treturn GF_OK;\n}\n\nGF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\n\t/*make sure we write the config box first, we don't care about the rest*/\n\n\t/*mp4v*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\t/*avc / SVC + MVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\n\t/*HEVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t/*VVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\t\n\t/*AV1*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t/*VPx*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\n\t/*JP2H*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\n\t/*DolbyVision*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mvex_box_del(GF_Box *s)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->TrackExList);\n\tgf_list_del(ptr->TrackExPropList);\n\tgf_free(ptr);\n}\n\n\nGF_Err mvex_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TREX:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackExList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TREP:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackExPropList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MEHD:\n\t\tBOX_FIELD_ASSIGN(mehd, GF_MovieExtendsHeaderBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\n\nGF_Err mvex_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mvex_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsBox, GF_ISOM_BOX_TYPE_MVEX);\n\ttmp->TrackExList = gf_list_new();\n\tif (!tmp->TrackExList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\ttmp->TrackExPropList = gf_list_new();\n\tif (!tmp->TrackExPropList) {\n\t\tgf_list_del(tmp->TrackExList);\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mvex_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mvex_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *) s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->mehd, &pos);\n\tgf_isom_check_position_list(s, ptr->TrackExList, &pos);\n\tgf_isom_check_position_list(s, ptr->TrackExPropList, &pos);\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *mehd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsHeaderBox, GF_ISOM_BOX_TYPE_MEHD);\n\treturn (GF_Box *)tmp;\n}\nvoid mehd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err mehd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->fragment_duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->fragment_duration = (u64) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err mehd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->fragment_duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->fragment_duration);\n\t}\n\treturn GF_OK;\n}\nGF_Err mehd_box_size(GF_Box *s)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tptr->version = (ptr->fragment_duration>0xFFFFFFFF) ? 1 : 0;\n\ts->size += (ptr->version == 1) ? 8 : 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid mvhd_box_del(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err mvhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 28);\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie header timescale is invalid (0) - defaulting to 600\\n\" ));\n\t\tptr->timeScale = 600;\n\t}\n\tISOM_DECREASE_SIZE(ptr, 80);\n\tptr->preferredRate = gf_bs_read_u32(bs);\n\tptr->preferredVolume = gf_bs_read_u16(bs);\n\tgf_bs_read_data(bs, ptr->reserved, 10);\n\tptr->matrixA = gf_bs_read_u32(bs);\n\tptr->matrixB = gf_bs_read_u32(bs);\n\tptr->matrixU = gf_bs_read_u32(bs);\n\tptr->matrixC = gf_bs_read_u32(bs);\n\tptr->matrixD = gf_bs_read_u32(bs);\n\tptr->matrixV = gf_bs_read_u32(bs);\n\tptr->matrixX = gf_bs_read_u32(bs);\n\tptr->matrixY = gf_bs_read_u32(bs);\n\tptr->matrixW = gf_bs_read_u32(bs);\n\tptr->previewTime = gf_bs_read_u32(bs);\n\tptr->previewDuration = gf_bs_read_u32(bs);\n\tptr->posterTime = gf_bs_read_u32(bs);\n\tptr->selectionTime = gf_bs_read_u32(bs);\n\tptr->selectionDuration = gf_bs_read_u32(bs);\n\tptr->currentTime = gf_bs_read_u32(bs);\n\tptr->nextTrackID = gf_bs_read_u32(bs);\n\tptr->original_duration = ptr->duration;\n\treturn GF_OK;\n}\n\nGF_Box *mvhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieHeaderBox, GF_ISOM_BOX_TYPE_MVHD);\n\n\ttmp->preferredRate = (1<<16);\n\ttmp->preferredVolume = (1<<8);\n\n\ttmp->matrixA = (1<<16);\n\ttmp->matrixD = (1<<16);\n\ttmp->matrixW = (1<<30);\n\n\ttmp->nextTrackID = 1;\n\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mvhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->preferredRate);\n\tgf_bs_write_u16(bs, ptr->preferredVolume);\n\tgf_bs_write_data(bs, ptr->reserved, 10);\n\tgf_bs_write_u32(bs, ptr->matrixA);\n\tgf_bs_write_u32(bs, ptr->matrixB);\n\tgf_bs_write_u32(bs, ptr->matrixU);\n\tgf_bs_write_u32(bs, ptr->matrixC);\n\tgf_bs_write_u32(bs, ptr->matrixD);\n\tgf_bs_write_u32(bs, ptr->matrixV);\n\tgf_bs_write_u32(bs, ptr->matrixX);\n\tgf_bs_write_u32(bs, ptr->matrixY);\n\tgf_bs_write_u32(bs, ptr->matrixW);\n\tgf_bs_write_u32(bs, ptr->previewTime);\n\tgf_bs_write_u32(bs, ptr->previewDuration);\n\tgf_bs_write_u32(bs, ptr->posterTime);\n\tgf_bs_write_u32(bs, ptr->selectionTime);\n\tgf_bs_write_u32(bs, ptr->selectionDuration);\n\tgf_bs_write_u32(bs, ptr->currentTime);\n\tgf_bs_write_u32(bs, ptr->nextTrackID);\n\treturn GF_OK;\n}\n\nGF_Err mvhd_box_size(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\tptr->size += 80;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid nmhd_box_del(GF_Box *s)\n{\n\tGF_MPEGMediaHeaderBox *ptr = (GF_MPEGMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\n\nGF_Err nmhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\nGF_Box *nmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGMediaHeaderBox, GF_ISOM_BOX_TYPE_NMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err nmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err nmhd_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid padb_box_del(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->padbits) gf_free(ptr->padbits);\n\tgf_free(ptr);\n}\n\n\nGF_Err padb_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->SampleCount = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->SampleCount/2) //half byte per sample\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->padbits = (u8 *)gf_malloc(sizeof(u8)*ptr->SampleCount);\n\tif (!ptr->padbits) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_read_int(bs, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tptr->padbits[i+1] = gf_bs_read_int(bs, 3);\n\t\t} else {\n\t\t\tgf_bs_read_int(bs, 3);\n\t\t}\n\t\tgf_bs_read_int(bs, 1);\n\t\tptr->padbits[i] = gf_bs_read_int(bs, 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *padb_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PaddingBitsBox, GF_ISOM_BOX_TYPE_PADB);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err padb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->SampleCount, 32);\n\n\tfor (i=0 ; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tgf_bs_write_int(bs, ptr->padbits[i+1], 3);\n\t\t} else {\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t}\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tgf_bs_write_int(bs, ptr->padbits[i], 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err padb_box_size(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\tptr->size += 4;\n\tif (ptr->SampleCount) ptr->size += (ptr->SampleCount + 1) / 2;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rely_box_del(GF_Box *s)\n{\n\tGF_RelyHintBox *rely = (GF_RelyHintBox *)s;\n\tgf_free(rely);\n}\n\nGF_Err rely_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1);\n\tptr->reserved = gf_bs_read_int(bs, 6);\n\tptr->preferred = gf_bs_read_int(bs, 1);\n\tptr->required = gf_bs_read_int(bs, 1);\n\treturn GF_OK;\n}\n\nGF_Box *rely_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RelyHintBox, GF_ISOM_BOX_TYPE_RELY);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rely_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->reserved, 6);\n\tgf_bs_write_int(bs, ptr->preferred, 1);\n\tgf_bs_write_int(bs, ptr->required, 1);\n\treturn GF_OK;\n}\n\nGF_Err rely_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rtpo_box_del(GF_Box *s)\n{\n\tGF_RTPOBox *rtpo = (GF_RTPOBox *)s;\n\tgf_free(rtpo);\n}\n\nGF_Err rtpo_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->timeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *rtpo_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPOBox, GF_ISOM_BOX_TYPE_RTPO);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtpo_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//here we have no pb, just remembed that some entries will have to\n\t//be 4-bytes aligned ...\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeOffset);\n\treturn GF_OK;\n}\n\nGF_Err rtpo_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid smhd_box_del(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tif (ptr == NULL ) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err smhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->balance = gf_bs_read_u16(bs);\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *smhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SoundMediaHeaderBox, GF_ISOM_BOX_TYPE_SMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err smhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->balance);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err smhd_box_size(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\n\tptr->reserved = 0;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid snro_box_del(GF_Box *s)\n{\n\tGF_SeqOffHintEntryBox *snro = (GF_SeqOffHintEntryBox *)s;\n\tgf_free(snro);\n}\n\nGF_Err snro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->SeqOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *snro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SeqOffHintEntryBox, GF_ISOM_BOX_TYPE_SNRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err snro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->SeqOffset);\n\treturn GF_OK;\n}\n\nGF_Err snro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stbl_box_del(GF_Box *s)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->sub_samples) gf_list_del(ptr->sub_samples);\n\tif (ptr->sampleGroups) gf_list_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_list_del(ptr->sampleGroupsDescription);\n\tif (ptr->sai_sizes) gf_list_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_list_del(ptr->sai_offsets);\n\tif (ptr->traf_map) {\n\t\tif (ptr->traf_map->frag_starts) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->traf_map->nb_entries; i++) {\n\t\t\t\tif (ptr->traf_map->frag_starts[i].moof_template)\n\t\t\t\t\tgf_free(ptr->traf_map->frag_starts[i].moof_template);\n\t\t\t}\n\t\t\tgf_free(ptr->traf_map->frag_starts);\n\t\t}\n\t\tgf_free(ptr->traf_map);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err stbl_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STTS:\n\t\tBOX_FIELD_ASSIGN(TimeToSample, GF_TimeToSampleBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CTTS:\n\t\tBOX_FIELD_ASSIGN(CompositionOffset, GF_CompositionOffsetBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CSLG:\n\t\tBOX_FIELD_ASSIGN(CompositionToDecode, GF_CompositionToDecodeBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSS:\n\t\tBOX_FIELD_ASSIGN(SyncSample, GF_SyncSampleBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSD:\n\t\tBOX_FIELD_ASSIGN(SampleDescription, GF_SampleDescriptionBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STZ2:\n\tcase GF_ISOM_BOX_TYPE_STSZ:\n\t\tBOX_FIELD_ASSIGN(SampleSize, GF_SampleSizeBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSC:\n\t\tBOX_FIELD_ASSIGN(SampleToChunk, GF_SampleToChunkBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_PADB:\n\t\tBOX_FIELD_ASSIGN(PaddingBits, GF_PaddingBitsBox)\n\t\tbreak;\n\n\t//WARNING: AS THIS MAY CHANGE DYNAMICALLY DURING EDIT,\n\tcase GF_ISOM_BOX_TYPE_CO64:\n\tcase GF_ISOM_BOX_TYPE_STCO:\n\t\tBOX_FIELD_ASSIGN(ChunkOffset, GF_Box)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSH:\n\t\tBOX_FIELD_ASSIGN(ShadowSync, GF_ShadowSyncBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STDP:\n\t\tBOX_FIELD_ASSIGN(DegradationPriority, GF_DegradationPriorityBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tBOX_FIELD_ASSIGN(SampleDep, GF_SampleDependencyTypeBox)\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tBOX_FIELD_LIST_ASSIGN(sub_samples)\n\t\t//check subsample box\n\t\tif (!is_rem) {\n\t\t\tGF_SubSampleInformationBox *subs = (GF_SubSampleInformationBox *)a;\n\t\t\tGF_SubSampleInfoEntry *ent = gf_list_get(subs->Samples, 0);\n\t\t\tif (!ent) {\n\t\t\t\tgf_list_rem(subs->Samples, 0);\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] first entry in SubSample in track SampleTable is invalid\\n\"));\n\t\t\t}\n\t\t\telse if (ent->sample_delta==0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] first entry in SubSample in track SampleTable has sample_delta of 0, should be one. Fixing\\n\"));\n\t\t\t\tent->sample_delta = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\tcase GF_ISOM_BOX_TYPE_CSGP:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroups)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroupsDescription)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_sizes)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_offsets)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\n\n\nGF_Err stbl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\t//we need to parse DegPrior in a special way\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->SyncSample)\n\t\tptr->no_sync_found = 1;\n\n\tptr->nb_sgpd_in_stbl = gf_list_count(ptr->sampleGroupsDescription);\n\tptr->nb_stbl_boxes = gf_list_count(ptr->child_boxes);\n\n\tif (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_CLONE_TRACK)\n\t\treturn GF_OK;\n//\treturn GF_OK;\n\n#define CHECK_BOX(_name) \\\n\tif (!ptr->_name) {\\\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Mandatory box %s is missing\\n\", #_name)); \\\n\t\treturn GF_ISOM_INVALID_FILE; \\\n\t}\n\n\tCHECK_BOX(SampleToChunk)\n\tCHECK_BOX(SampleSize)\n\tCHECK_BOX(ChunkOffset)\n\tCHECK_BOX(TimeToSample)\n\n\t//sanity check\n\tif (ptr->SampleSize->sampleCount) {\n\t\tif (!ptr->TimeToSample->nb_entries || !ptr->SampleToChunk->nb_entries)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tu32 i, max_chunks=0;\n\tif (ptr->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tmax_chunks = ((GF_ChunkOffsetBox *)ptr->ChunkOffset)->nb_entries;\n\t}\n\telse if (ptr->ChunkOffset->type == GF_ISOM_BOX_TYPE_CO64) {\n\t\tmax_chunks = ((GF_ChunkOffsetBox *)ptr->ChunkOffset)->nb_entries;\n\t}\n\n\t//sanity check on stsc vs chunk offset tables\n\tfor (i=0; i<ptr->SampleToChunk->nb_entries; i++) {\n\t\tGF_StscEntry *ent = &ptr->SampleToChunk->entries[i];\n\t\tif (!i && (ent->firstChunk!=1)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk of first entry shall be 1 but is %u\\n\", ent->firstChunk));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (ptr->SampleToChunk->entries[i].firstChunk > max_chunks) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk is %u but number of chunks defined %u\\n\", ptr->SampleToChunk->entries[i].firstChunk, max_chunks));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (i+1 == ptr->SampleToChunk->nb_entries) break;\n\t\tGF_StscEntry *next_ent = &ptr->SampleToChunk->entries[i+1];\n\t\tif (next_ent->firstChunk < ent->firstChunk) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk (%u) for entry %u is greater than first_chunk (%u) for entry %u\\n\", i+1, ent->firstChunk, i+2, next_ent->firstChunk));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stbl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleTableBox, GF_ISOM_BOX_TYPE_STBL);\n\t//maxSamplePer chunk is 10 by default\n\ttmp->MaxSamplePerChunk = 10;\n\ttmp->groupID = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stbl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err stbl_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleDescription, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->TimeToSample, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->CompositionOffset, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->CompositionToDecode, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SyncSample, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->ShadowSync, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleToChunk, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleSize, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->ChunkOffset, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->DegradationPriority, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleDep, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->PaddingBits, &pos);\n\n\tif (ptr->sub_samples) {\n\t\tgf_isom_check_position_list(s, ptr->sub_samples, &pos);\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t}\n\tif (ptr->sampleGroups) {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t}\n\tif (ptr->sai_sizes) {\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t}\n\tif (ptr->sai_offsets) {\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stco_box_del(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\n\nGF_Err stco_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->nb_entries > ptr->size / 4 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stco\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (ptr->nb_entries) {\n\t\tptr->offsets = (u32 *) gf_malloc(ptr->nb_entries * sizeof(u32) );\n\t\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->nb_entries;\n\n\t\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\t\tptr->offsets[entries] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stco_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkOffsetBox, GF_ISOM_BOX_TYPE_STCO);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stco_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stco_box_size(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stdp_box_del(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\tif (ptr == NULL ) return;\n\tif (ptr->priorities) gf_free(ptr->priorities);\n\tgf_free(ptr);\n}\n\n//this is called through stbl_read...\nGF_Err stdp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\t/*out-of-order stdp, assume no padding at the end and take the entire remaining data for entries*/\n\tif (!ptr->nb_entries) ptr->nb_entries = (u32) ptr->size / 2;\n\telse if (ptr->nb_entries > ptr->size / 2) return GF_ISOM_INVALID_FILE;\n\n\tptr->priorities = (u16 *) gf_malloc(ptr->nb_entries * sizeof(u16));\n\tif (ptr->priorities == NULL) return GF_OUT_OF_MEM;\n\tfor (entry = 0; entry < ptr->nb_entries; entry++) {\n\t\tptr->priorities[entry] = gf_bs_read_u16(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, (2*ptr->nb_entries) );\n\treturn GF_OK;\n}\n\nGF_Box *stdp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DegradationPriorityBox, GF_ISOM_BOX_TYPE_STDP);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stdp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->priorities[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stdp_box_size(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\tptr->size += (2 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsc_box_del(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->nb_entries > ptr->size / 12 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_StscEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsc\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = NULL;\n\tif (ptr->nb_entries) {\n\t\tptr->entries = gf_malloc(sizeof(GF_StscEntry)*ptr->alloc_size);\n\t\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\t}\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].firstChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].samplesPerChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDescriptionIndex = gf_bs_read_u32(bs);\n\t\tptr->entries[i].isEdited = 0;\n\t\tptr->entries[i].nextChunk = 0;\n\t\tif (!ptr->entries[i].firstChunk) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] invalid first chunk 0 in stsc entry\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t//update the next chunk in the previous entry\n\t\tif (i) ptr->entries[i-1].nextChunk = ptr->entries[i].firstChunk;\n\t}\n\tptr->currentIndex = 0;\n\tptr->firstSampleInCurrentChunk = 0;\n\tptr->currentChunk = 0;\n\tptr->ghostNumber = 0;\n\treturn GF_OK;\n}\n\nGF_Box *stsc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleToChunkBox, GF_ISOM_BOX_TYPE_STSC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].firstChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].samplesPerChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDescriptionIndex);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsc_box_size(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tptr->size += 4 + (12 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsd_box_del(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err stsd_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_UnknownBox *def;\n\tif (!a) return GF_OK;\n\n\tif (is_rem || gf_box_valid_in_parent(a, \"stsd\")) {\n\t\treturn GF_OK;\n\t}\n\tswitch (a->type) {\n\t//unknown sample description: we need a specific box to handle the data ref index\n\t//rather than a default box ...\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\tdef = (GF_UnknownBox *)a;\n\t\t/*we need at least 8 bytes for unknown sample entries*/\n\t\tif (def->dataSize < 8) {\n\t\t\tgf_isom_box_del_parent(&s->child_boxes, a);\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t}\n\t\treturn GF_OK;\n\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Cannot process box of type %s\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n}\n\n\nGF_Err stsd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tISOM_DECREASE_SIZE(s, 4)\n\tgf_bs_read_u32(bs);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *stsd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDescriptionBox, GF_ISOM_BOX_TYPE_STSD);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 nb_entries;\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tnb_entries = gf_list_count(ptr->child_boxes);\n\tgf_bs_write_u32(bs, nb_entries);\n\treturn GF_OK;\n}\n\nGF_Err stsd_box_size(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsh_box_del(GF_Box *s)\n{\n\tu32 i = 0;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tif (ptr == NULL) return;\n\twhile ( (ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i)) ) {\n\t\tgf_free(ent);\n\t}\n\tgf_list_del(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err stsh_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 4)\n\tcount = gf_bs_read_u32(bs);\n\tif (ptr->size / 8 < count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i = 0; i < count; i++) {\n\t\tGF_StshEntry *ent = (GF_StshEntry *) gf_malloc(sizeof(GF_StshEntry));\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tent->shadowedSampleNumber = gf_bs_read_u32(bs);\n\t\tent->syncSampleNumber = gf_bs_read_u32(bs);\n\t\te = gf_list_add(ptr->entries, ent);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsh_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);\n\n\ttmp->entries = gf_list_new();\n\tif (!tmp->entries) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsh_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, gf_list_count(ptr->entries));\n\ti=0;\n\twhile ((ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i))) {\n\t\tgf_bs_write_u32(bs, ent->shadowedSampleNumber);\n\t\tgf_bs_write_u32(bs, ent->syncSampleNumber);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsh_box_size(GF_Box *s)\n{\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tptr->size += 4 + (8 * gf_list_count(ptr->entries));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stss_box_del(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sampleNumbers) gf_free(ptr->sampleNumbers);\n\tgf_free(ptr);\n}\n\nGF_Err stss_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->size / 4 <  ptr->nb_entries || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stss\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->sampleNumbers = (u32 *) gf_malloc( ptr->alloc_size * sizeof(u32));\n\tif (ptr->sampleNumbers == NULL) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->sampleNumbers[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stss_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SyncSampleBox, GF_ISOM_BOX_TYPE_STSS);\n\treturn (GF_Box*)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stss_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->sampleNumbers[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stss_box_size(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsz_box_del(GF_Box *s)\n{\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sizes) gf_free(ptr->sizes);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsz_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, estSize;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//support for CompactSizes\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->sampleSize = gf_bs_read_u32(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\t} else {\n\t\t//24-reserved\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tgf_bs_read_int(bs, 24);\n\t\ti = gf_bs_read_u8(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\t\tswitch (i) {\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tptr->sampleSize = i;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//try to fix the file\n\t\t\t//no samples, no parsing pb\n\t\t\tif (!ptr->sampleCount) {\n\t\t\t\tptr->sampleSize = 16;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\testSize = (u32) (ptr->size) / ptr->sampleCount;\n\t\t\tif (!estSize && ((ptr->sampleCount+1)/2 == (ptr->size)) ) {\n\t\t\t\tptr->sampleSize = 4;\n\t\t\t\tbreak;\n\t\t\t} else if (estSize == 1 || estSize == 2) {\n\t\t\t\tptr->sampleSize = 8 * estSize;\n\t\t\t} else {\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t}\n\tif (ptr->sampleCount && (u64)ptr->sampleCount > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (! ptr->sampleSize && ptr->sampleCount) {\n\t\t\tif (ptr->sampleCount > ptr->size / 4) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\t\tptr->alloc_size = ptr->sampleCount;\n\t\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\t\tptr->sizes[i] = gf_bs_read_u32(bs);\n\t\t\t\tif (ptr->max_size < ptr->sizes[i])\n\t\t\t\t\tptr->max_size = ptr->sizes[i];\n\t\t\t\tptr->total_size += ptr->sizes[i];\n\t\t\t\tptr->total_samples++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (ptr->sampleSize==4) {\n\t\t\tif (ptr->sampleCount / 2 > ptr->size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ptr->sampleCount > ptr->size / (ptr->sampleSize/8)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t\t//note we could optimize the mem usage by keeping the table compact\n\t\t//in memory. But that would complicate both caching and editing\n\t\t//we therefore keep all sizes as u32 and uncompress the table\n\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->sampleCount;\n\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tu32 s_size;\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\ts_size = ptr->sizes[i] = gf_bs_read_int(bs, 4);\n\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\tptr->total_size += s_size;\n\t\t\t\tptr->total_samples++;\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\ts_size = ptr->sizes[i+1] = gf_bs_read_int(bs, 4);\n\t\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\t\tptr->total_size += s_size;\n\t\t\t\t\tptr->total_samples++;\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_read_int(bs, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts_size = ptr->sizes[i] = gf_bs_read_int(bs, ptr->sampleSize);\n\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\tptr->total_size += s_size;\n\t\t\t\tptr->total_samples++;\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsz_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleSizeBox, 0);\n\n\t//type is unknown here, can be regular or compact table\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsz_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//in both versions this is still valid\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tgf_bs_write_u32(bs, ptr->sampleSize);\n\t} else {\n\t\tgf_bs_write_u24(bs, 0);\n\t\tgf_bs_write_u8(bs, ptr->sampleSize);\n\t}\n\tgf_bs_write_u32(bs, ptr->sampleCount);\n\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\tgf_bs_write_u32(bs, ptr->sizes ? ptr->sizes[i] : 0);\n\t\t}\n\t} else {\n\t\tif (!ptr->sizes) return GF_ISOM_INVALID_FILE;\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], 4);\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i+1], 4);\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], ptr->sampleSize);\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsz_box_size(GF_Box *s)\n{\n\tu32 i, fieldSize, size;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\tptr->size += 8;\n\tif (!ptr->sampleCount) return GF_OK;\n\n\t//regular table\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\tif (!ptr->sizes) return GF_ISOM_INVALID_FILE;\n\n\t//compact size table\n\tfieldSize = 4;\n\tsize = ptr->sizes[0];\n\n\tfor (i=0; i < ptr->sampleCount; i++) {\n\t\tif (ptr->sizes[i] <= 0xF) {\n\t\t}\n\t\t//switch to 8-bit table\n\t\telse if (ptr->sizes[i] <= 0xFF) {\n\t\t\tfieldSize = 8;\n\t\t}\n\t\t//switch to 16-bit table\n\t\telse if (ptr->sizes[i] <= 0xFFFF) {\n\t\t\tfieldSize = 16;\n\t\t}\n\t\t//switch to 32-bit table\n\t\telse {\n\t\t\tfieldSize = 32;\n\t\t}\n\n\t\t//check the size\n\t\tif (size != ptr->sizes[i]) size = 0;\n\t}\n\t//if all samples are of the same size, switch to regular (more compact)\n\tif (size) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->sampleSize = size;\n\t\tgf_free(ptr->sizes);\n\t\tptr->sizes = NULL;\n\t\treturn GF_OK;\n\t}\n\n\tif (fieldSize == 32) {\n\t\t//oops, doesn't fit in a compact table\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\n\t//make sure we are a compact table (no need to change the mem representation)\n\tptr->type = GF_ISOM_BOX_TYPE_STZ2;\n\tptr->sampleSize = fieldSize;\n\tif (fieldSize == 4) {\n\t\t//do not forget the 0 padding field for odd count\n\t\tptr->size += (ptr->sampleCount + 1) / 2;\n\t} else {\n\t\tptr->size += (ptr->sampleCount) * (fieldSize/8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stts_box_del(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tBool logged=GF_FALSE;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastDTS = 0;\n#endif\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->size / 8 < ptr->nb_entries || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_SttsEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = gf_malloc(sizeof(GF_SttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDelta = gf_bs_read_u32(bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tptr->w_currentSampleNum += ptr->entries[i].sampleCount;\n\t\tptr->w_LastDTS += (u64)ptr->entries[i].sampleCount * ptr->entries[i].sampleDelta;\n#endif\n\t\tif (ptr->max_ts_delta<ptr->entries[i].sampleDelta)\n\t\t\tptr->max_ts_delta = ptr->entries[i].sampleDelta;\n\n\t\tif (!ptr->entries[i].sampleDelta) {\n\t\t\tif ((i+1<ptr->nb_entries) ) {\n\t\t\t\tif (!logged) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Found stts entry with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\t\tlogged=GF_TRUE;\n\t\t\t\t}\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t} else if (ptr->entries[i].sampleCount>1) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] more than one stts entry at the end of the track with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t}\n\t\t}\n\t\t//cf issue 1644: some media streams may have sample duration > 2^31 (ttml mostly), we cannot patch this\n\t\t//for now we disable the check, one opt could be to have the check only for some media types, or only for the first entry\n#if 0\n\t\telse if ((s32) ptr->entries[i].sampleDelta < 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] stts entry %d has negative duration %d - forbidden ! Fixing to 1, sync may get lost (consider reimport raw media)\\n\", i, (s32) ptr->entries[i].sampleDelta ));\n\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t}\n#endif\n\n\t}\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries*8);\n\n\t//remove the last sample delta.\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (ptr->nb_entries) ptr->w_LastDTS -= ptr->entries[ptr->nb_entries-1].sampleDelta;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *stts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeToSampleBox, GF_ISOM_BOX_TYPE_STTS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDelta);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stts_box_size(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid tfhd_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err tfhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->base_data_offset = gf_bs_read_u64(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->sample_desc_index = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_size = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *tfhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentHeaderBox, GF_ISOM_BOX_TYPE_TFHD);\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err tfhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->trackID);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tgf_bs_write_u64(bs, ptr->base_data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tgf_bs_write_u32(bs, ptr->sample_desc_index);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfhd_box_size(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tptr->size += 4;\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) ptr->size += 8;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tims_box_del(GF_Box *s)\n{\n\tGF_TSHintEntryBox *tims = (GF_TSHintEntryBox *)s;\n\tgf_free(tims);\n}\n\nGF_Err tims_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->timeScale = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tims_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TSHintEntryBox, GF_ISOM_BOX_TYPE_TIMS);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tims_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeScale);\n\treturn GF_OK;\n}\n\nGF_Err tims_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tkhd_box_del(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err tkhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 32);\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tptr->initial_duration = ptr->duration;\n\n\tISOM_DECREASE_SIZE(ptr, 60);\n\tptr->reserved2[0] = gf_bs_read_u32(bs);\n\tptr->reserved2[1] = gf_bs_read_u32(bs);\n\tptr->layer = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->volume = gf_bs_read_u16(bs);\n\tptr->reserved3 = gf_bs_read_u16(bs);\n\tptr->matrix[0] = gf_bs_read_u32(bs);\n\tptr->matrix[1] = gf_bs_read_u32(bs);\n\tptr->matrix[2] = gf_bs_read_u32(bs);\n\tptr->matrix[3] = gf_bs_read_u32(bs);\n\tptr->matrix[4] = gf_bs_read_u32(bs);\n\tptr->matrix[5] = gf_bs_read_u32(bs);\n\tptr->matrix[6] = gf_bs_read_u32(bs);\n\tptr->matrix[7] = gf_bs_read_u32(bs);\n\tptr->matrix[8] = gf_bs_read_u32(bs);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->height = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tkhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackHeaderBox, GF_ISOM_BOX_TYPE_TKHD);\n\ttmp->matrix[0] = 0x00010000;\n\ttmp->matrix[4] = 0x00010000;\n\ttmp->matrix[8] = 0x40000000;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tkhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->reserved2[0]);\n\tgf_bs_write_u32(bs, ptr->reserved2[1]);\n\tgf_bs_write_u16(bs, ptr->layer);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u16(bs, ptr->volume);\n\tgf_bs_write_u16(bs, ptr->reserved3);\n\tgf_bs_write_u32(bs, ptr->matrix[0]);\n\tgf_bs_write_u32(bs, ptr->matrix[1]);\n\tgf_bs_write_u32(bs, ptr->matrix[2]);\n\tgf_bs_write_u32(bs, ptr->matrix[3]);\n\tgf_bs_write_u32(bs, ptr->matrix[4]);\n\tgf_bs_write_u32(bs, ptr->matrix[5]);\n\tgf_bs_write_u32(bs, ptr->matrix[6]);\n\tgf_bs_write_u32(bs, ptr->matrix[7]);\n\tgf_bs_write_u32(bs, ptr->matrix[8]);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u32(bs, ptr->height);\n\treturn GF_OK;\n}\n\nGF_Err tkhd_box_size(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\tptr->size += (ptr->version == 1) ? 32 : 20;\n\tptr->size += 60;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid traf_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sub_samples) gf_list_del(ptr->sub_samples);\n\tgf_list_del(ptr->TrackRuns);\n\tif (ptr->sampleGroups) gf_list_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_list_del(ptr->sampleGroupsDescription);\n\tif (ptr->sai_sizes) gf_list_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_list_del(ptr->sai_offsets);\n\tgf_free(ptr);\n}\n\nGF_Err traf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFHD:\n\t\tBOX_FIELD_ASSIGN(tfhd, GF_TrackFragmentHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRUN:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackRuns)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tBOX_FIELD_ASSIGN(sdtp, GF_SampleDependencyTypeBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TFDT:\n\t\tBOX_FIELD_ASSIGN(tfdt, GF_TFBaseMediaDecodeTimeBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tBOX_FIELD_LIST_ASSIGN(sub_samples)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\tcase GF_ISOM_BOX_TYPE_CSGP:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroups)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroupsDescription)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_sizes)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_offsets)\n\t\treturn GF_OK;\n\t//we will throw an error if both PIFF_PSEC and SENC are found. Not such files seen yet\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\t\tif (!is_rem)\n\t\t\t\tptr->sample_encryption->traf = ptr;\n\t\t\treturn GF_OK;\n\t\t} else if ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_TFXD) {\n\t\t\tBOX_FIELD_ASSIGN(tfxd, GF_MSSTimeExtBox)\n\t\t\treturn GF_OK;\n\t\t} else if ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_TFRF) {\n\t\t\tBOX_FIELD_ASSIGN(tfrf, GF_MSSTimeRefBox)\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\tif (!is_rem)\n\t\t\tptr->sample_encryption->traf = ptr;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err traf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->tfhd) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackFragmentHeaderBox \\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *traf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentBox, GF_ISOM_BOX_TYPE_TRAF);\n\ttmp->TrackRuns = gf_list_new();\n\n\tif (gf_sys_old_arch_compat())\n\t\ttmp->no_sdtp_first_flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err traf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err traf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *) s;\n\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box *)ptr->tfhd, &pos);\n\tgf_isom_check_position_list(s, ptr->sub_samples, &pos);\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->tfdt, &pos);\n\n\t//cmaf-like\n\tif (ptr->truns_first) {\n\t\tgf_isom_check_position_list(s, ptr->TrackRuns, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t\t//senc MUST be after saio in GPAC, as senc writing uses info from saio writing\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->sample_encryption, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t\t//subsamples will be last\n\t} else {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->sample_encryption, &pos);\n\t\tgf_isom_check_position_list(s, ptr->TrackRuns, &pos);\n\t}\n\n\t//when sdtp is present (smooth-like) write it after the trun box\n\tgf_isom_check_position(s, (GF_Box *)ptr->sdtp, &pos);\n\n\t//tfxd should be last ...\n\tif (ptr->tfxd)\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->tfxd, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *tfxd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MSSTimeExtBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TFXD;\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfxd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err tfxd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tif (ptr->version == 0x01) {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u64(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u32(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u32(bs);\n\t}\n\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfxd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, 0);\n\tif (ptr->version) {\n\t\tgf_bs_write_u64(bs, ptr->absolute_time_in_track_timescale);\n\t\tgf_bs_write_u64(bs, ptr->fragment_duration_in_track_timescale);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->absolute_time_in_track_timescale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->fragment_duration_in_track_timescale);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfxd_box_size(GF_Box *s)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)s;\n\ts->size += 4 + (ptr->version ? 16 : 8);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\n\nGF_Box *tfrf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MSSTimeRefBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TFRF;\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfrf_box_del(GF_Box *s)\n{\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox *)s;\n\tif (ptr->frags) gf_free(ptr->frags);\n\tgf_free(s);\n}\n\n\nGF_Err tfrf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 5);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\tptr->frags_count = gf_bs_read_u8(bs);\n\tptr->frags = gf_malloc(sizeof(GF_MSSTimeEntry) * ptr->frags_count);\n\tif (!ptr->frags) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->frags_count; i++) {\n\t\tif (ptr->version == 0x01) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\tptr->frags[i].absolute_time_in_track_timescale = gf_bs_read_u64(bs);\n\t\t\tptr->frags[i].fragment_duration_in_track_timescale = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\t\tptr->frags[i].absolute_time_in_track_timescale = gf_bs_read_u32(bs);\n\t\t\tptr->frags[i].fragment_duration_in_track_timescale = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfrf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, 0);\n\tgf_bs_write_u8(bs, ptr->frags_count);\n\tfor (i=0; i<ptr->frags_count; i++) {\n\t\tif (ptr->version==0x01) {\n\t\t\tgf_bs_write_u64(bs, ptr->frags[i].absolute_time_in_track_timescale);\n\t\t\tgf_bs_write_u64(bs, ptr->frags[i].fragment_duration_in_track_timescale);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->frags[i].absolute_time_in_track_timescale);\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->frags[i].fragment_duration_in_track_timescale);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfrf_box_size(GF_Box *s)\n{\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox*)s;\n\ts->size += 5;\n\tif (ptr->version) s->size += 16 * ptr->frags_count;\n\telse s->size += 8 * ptr->frags_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid trak_box_del(GF_Box *s)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->chunk_cache)\n\t\tgf_bs_del(ptr->chunk_cache);\n#endif\n\tgf_free(s);\n}\n\nstatic void stsd_switch_box(GF_BitStream *bs, GF_Box *box, GF_UnknownBox *a, u8 **data, u32 *data_size, u32 *EntryType, GF_SampleDescriptionBox *stsd, u32 stsd_idx)\n{\n\tif (gf_bs_available(bs)) {\n\t\tGF_Err e;\n\t\tu32 count_subb;\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_NO_LOGS);\n\t\te = gf_isom_box_array_read(box, bs);\n\t\tcount_subb = box->child_boxes ? gf_list_count(box->child_boxes) : 0;\n\t\tif (count_subb && !e) {\n\t\t\tu32 i;\n\t\t\tGF_BitStream *new_dsi = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t//serialize all unknown boxes\n\t\t\tfor (i=0; i<count_subb; i++) {\n\t\t\t\tGF_UnknownBox *priv = gf_list_get(box->child_boxes, i);\n\t\t\t\tif (priv->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\t\t\tgf_bs_write_u32(new_dsi, 8 + priv->dataSize);\n\t\t\t\tgf_bs_write_u32(new_dsi, priv->original_4cc);\n\t\t\t\tgf_bs_write_data(new_dsi, priv->data, priv->dataSize);\n\t\t\t\tgf_list_rem(box->child_boxes, i);\n\t\t\t\tgf_isom_box_del((GF_Box*)priv);\n\t\t\t\tcount_subb--;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tif (*data) gf_free(*data);\n\t\t\tgf_bs_get_content(new_dsi, data, data_size);\n\t\t\tgf_bs_del(new_dsi);\n\t\t} else {\n\t\t\t*data_size = 0;\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\tif (!*data_size && *data) {\n\t\tgf_free(*data);\n\t\t*data = NULL;\n\t}\n\tbox->size = 0;\n\t*EntryType = a->original_4cc;\n\tgf_list_rem(stsd->child_boxes, stsd_idx);\n\tgf_isom_box_del((GF_Box *)a);\n\tgf_list_insert(stsd->child_boxes, box, stsd_idx);\n}\n\n\nstatic GF_Err gf_isom_check_sample_desc(GF_TrackBox *trak)\n{\n\tGF_BitStream *bs;\n\tGF_UnknownBox *a;\n\tu32 i;\n\tGF_Err e;\n\tGF_SampleTableBox *stbl;\n\n\tif (!trak->Media || !trak->Media->information) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no media box !\\n\" ));\n\t\treturn GF_OK;\n\t}\n\tif (!trak->Media->information->sampleTable) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample table !\\n\" ));\n\t\ttrak->Media->information->sampleTable = (GF_SampleTableBox *) gf_isom_box_new_parent(&trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_STBL);\n\t}\n\tstbl = trak->Media->information->sampleTable;\n\n\tif (!stbl->SampleDescription) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample description box !\\n\" ));\n\t\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\t\treturn GF_OK;\n\t}\n\n\ti=0;\n\twhile ((a = (GF_UnknownBox*)gf_list_enum(stbl->SampleDescription->child_boxes, &i))) {\n\t\tGF_ProtectionSchemeInfoBox *sinf;\n\t\tu32 base_ent_type = 0;\n\t\tu32 type = a->type;\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (!sinf || !sinf->original_format) return GF_ISOM_INVALID_FILE;\n\t\t\ttype = sinf->original_format->data_format;\n\t\t\tbase_ent_type = ((GF_SampleEntryBox *)a)->internal_type;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_MP4S)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Protected sample entry %s uses incompatible sample description %s\\n\", gf_4cc_to_str(a->type), gf_4cc_to_str(type) ));\n\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tcontinue;\n\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tcase GF_ISOM_BOX_TYPE_MP3:\n\t\tcase GF_ISOM_BOX_TYPE_MHA1:\n\t\tcase GF_ISOM_BOX_TYPE_MHA2:\n\t\tcase GF_ISOM_BOX_TYPE_MHM1:\n\t\tcase GF_ISOM_BOX_TYPE_MHM2:\n\t\tcase GF_ISOM_BOX_TYPE_OPUS:\n\t\tcase GF_ISOM_BOX_TYPE_AC3:\n\t\tcase GF_ISOM_BOX_TYPE_EC3:\n\t\tcase GF_QT_SUBTYPE_RAW_AUD:\n\t\tcase GF_QT_SUBTYPE_TWOS:\n\t\tcase GF_QT_SUBTYPE_SOWT:\n\t\tcase GF_QT_SUBTYPE_FL32:\n\t\tcase GF_QT_SUBTYPE_FL64:\n\t\tcase GF_QT_SUBTYPE_IN24:\n\t\tcase GF_QT_SUBTYPE_IN32:\n\t\tcase GF_QT_SUBTYPE_ULAW:\n\t\tcase GF_QT_SUBTYPE_ALAW:\n\t\tcase GF_QT_SUBTYPE_ADPCM:\n\t\tcase GF_QT_SUBTYPE_IMA_ADPCM:\n\t\tcase GF_QT_SUBTYPE_DVCA:\n\t\tcase GF_QT_SUBTYPE_QDMC:\n\t\tcase GF_QT_SUBTYPE_QDMC2:\n\t\tcase GF_QT_SUBTYPE_QCELP:\n\t\tcase GF_QT_SUBTYPE_kMP3:\n\t\tcase GF_ISOM_BOX_TYPE_IPCM:\n\t\tcase GF_ISOM_BOX_TYPE_FPCM:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_AUDIO))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tcase GF_ISOM_BOX_TYPE_VP08:\n\t\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tcase GF_ISOM_BOX_TYPE_AV1C:\n\t\tcase GF_ISOM_BOX_TYPE_JPEG:\n\t\tcase GF_ISOM_BOX_TYPE_PNG:\n\t\tcase GF_ISOM_BOX_TYPE_JP2K:\n\t\tcase GF_ISOM_BOX_TYPE_MJP2:\n\t\tcase GF_QT_SUBTYPE_APCH:\n\t\tcase GF_QT_SUBTYPE_APCO:\n\t\tcase GF_QT_SUBTYPE_APCN:\n\t\tcase GF_QT_SUBTYPE_APCS:\n\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tcase GF_QT_SUBTYPE_RAW_VID:\n\t\tcase GF_QT_SUBTYPE_YUYV:\n\t\tcase GF_QT_SUBTYPE_UYVY:\n\t\tcase GF_QT_SUBTYPE_YUV444:\n\t\tcase GF_QT_SUBTYPE_YUVA444:\n\t\tcase GF_QT_SUBTYPE_YUV422_10:\n\t\tcase GF_QT_SUBTYPE_YUV444_10:\n\t\tcase GF_QT_SUBTYPE_YUV422_16:\n\t\tcase GF_QT_SUBTYPE_YUV420:\n\t\tcase GF_QT_SUBTYPE_I420:\n\t\tcase GF_QT_SUBTYPE_IYUV:\n\t\tcase GF_QT_SUBTYPE_YV12:\n\t\tcase GF_QT_SUBTYPE_YVYU:\n\t\tcase GF_QT_SUBTYPE_RGBA:\n\t\tcase GF_QT_SUBTYPE_ABGR:\n\t\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_VIDEO))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\n\t\tcase GF_ISOM_BOX_TYPE_METX:\n\t\tcase GF_ISOM_BOX_TYPE_METT:\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tcase GF_ISOM_BOX_TYPE_GHNT:\n\t\tcase GF_ISOM_BOX_TYPE_RTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_SRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_FDP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RTCP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_DIMS:\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_GENERIC))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (gf_box_valid_in_parent((GF_Box *) a, \"stsd\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unexpected box %s in stsd!\\n\", gf_4cc_to_str(a->type)));\n\t\t\tcontinue;\n\t\t}\n\t\t//we are sure to have an unknown box here\n\t\tassert(a->type==GF_ISOM_BOX_TYPE_UNKNOWN);\n\n\t\tif (!a->data || (a->dataSize<8) ) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Sample description %s does not have at least 8 bytes!\\n\", gf_4cc_to_str(a->original_4cc) ));\n\t\t\tcontinue;\n\t\t}\n\t\telse if (a->dataSize > a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Sample description %s has wrong data size %d!\\n\", gf_4cc_to_str(a->original_4cc), a->dataSize));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*only process visual or audio\n\t\tnote: no need for new_box_parent here since we always store sample descriptions in child_boxes*/\n\t\tswitch (trak->Media->handler->handlerType) {\n        case GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t{\n\t\t\tGF_GenericVisualSampleEntryBox *genv = (GF_GenericVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgenv->size = a->size-8;\n\t\t\tgf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *) genv, bs);\n\n\t\t\tstsd_switch_box(bs, (GF_Box *) genv, a, &genv->data, &genv->data_size, &genv->EntryType, trak->Media->information->sampleTable->SampleDescription, i-1);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t{\n\t\t\tGF_GenericAudioSampleEntryBox *gena = (GF_GenericAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\t\tgena->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox *) gena, bs);\n\n\t\t\tstsd_switch_box(bs, (GF_Box *) gena, a, &gena->data, &gena->data_size, &gena->EntryType, trak->Media->information->sampleTable->SampleDescription, i-1);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t{\n\t\t\tGF_GenericSampleEntryBox *genm = (GF_GenericSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\t\tgenm->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\n\t\t\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)genm, bs);\n\t\t\tif (e) return e;\n\n\t\t\tstsd_switch_box(bs, (GF_Box *) genm, a, &genm->data, &genm->data_size, &genm->EntryType, trak->Media->information->sampleTable->SampleDescription, i-1);\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err trak_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TKHD:\n\t\tBOX_FIELD_ASSIGN(Header, GF_TrackHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_EDTS:\n\t\tBOX_FIELD_ASSIGN(editBox, GF_EditBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tBOX_FIELD_ASSIGN(udta, GF_UserDataBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tBOX_FIELD_ASSIGN(meta, GF_MetaBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TREF:\n\t\tBOX_FIELD_ASSIGN(References, GF_TrackReferenceBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MDIA:\n\t\tBOX_FIELD_ASSIGN(Media, GF_MediaBox)\n\t\tif (!is_rem)\n\t\t\t((GF_MediaBox *)a)->mediaTrack = ptr;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRGR:\n\t\tBOX_FIELD_ASSIGN(groups, GF_TrackGroupBox)\n\t\treturn GF_OK;\n\tcase GF_QT_BOX_TYPE_TAPT:\n\t\tBOX_FIELD_ASSIGN(Aperture, GF_Box)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (((GF_UnknownUUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err trak_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\te = gf_isom_check_sample_desc(ptr);\n\tif (e) return e;\n\n\tif (!ptr->Header) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media->information || !ptr->Media->information->sampleTable) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid MediaBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media->information->sampleTable->SampleSize || (ptr->Media->information->sampleTable->SampleSize->sampleCount==0)) {\n\t\tif (ptr->Header->initial_duration) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Track with no samples but duration defined, ignoring duration\\n\"));\n\t\t\tptr->Header->initial_duration = 0;\n\t\t}\n\t}\n\n\tfor (i=0; i<gf_list_count(ptr->Media->information->sampleTable->child_boxes); i++) {\n\t\tGF_Box *a = gf_list_get(ptr->Media->information->sampleTable->child_boxes, i);\n\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *) a;\n\t\t\tbreak;\n\t\t}\n\t\telse if (a->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *)a;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *trak_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackBox, GF_ISOM_BOX_TYPE_TRAK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trak_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stri_box_del(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->attribute_list) gf_free(ptr->attribute_list);\n\tgf_free(ptr);\n}\n\nGF_Err stri_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tsize_t i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->switch_group = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->sub_track_id = gf_bs_read_u32(bs);\n\tptr->attribute_count = ptr->size / 4;\n\tif ((u64)ptr->attribute_count > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in stri\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tGF_SAFE_ALLOC_N(ptr->attribute_list, (size_t)ptr->attribute_count, u32);\n\tif (!ptr->attribute_list) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->attribute_list[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stri_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackInformationBox, GF_ISOM_BOX_TYPE_STRI);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stri_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->switch_group);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u32(bs, ptr->sub_track_id);\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->attribute_list[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stri_box_size(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\n\tptr->size += 8 + 4 * ptr->attribute_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsg_box_del(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->group_description_index) gf_free(ptr->group_description_index);\n\tgf_free(ptr);\n}\n\nGF_Err stsg_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tISOM_DECREASE_SIZE(s, 6);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tptr->nb_groups = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(s, ptr->nb_groups*4);\n\tGF_SAFE_ALLOC_N(ptr->group_description_index, ptr->nb_groups, u32);\n\tif (!ptr->group_description_index) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tptr->group_description_index[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackSampleGroupBox, GF_ISOM_BOX_TYPE_STSG);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->grouping_type);\n\tgf_bs_write_u16(bs, ptr->nb_groups);\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tgf_bs_write_u32(bs, ptr->group_description_index[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsg_box_size(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tptr->size += 6 + 4 * ptr->nb_groups;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid strk_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err strk_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STRI:\n\t\tBOX_FIELD_ASSIGN(info, GF_SubTrackInformationBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_STRD:\n\t\tBOX_FIELD_ASSIGN(strd, GF_Box)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err strk_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->info) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing SubTrackInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *strk_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackBox, GF_ISOM_BOX_TYPE_STRK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err strk_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err strk_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid tref_box_del(GF_Box *s)\n{\n\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err tref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *tref_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceBox, GF_ISOM_BOX_TYPE_TREF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tref_box_write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err tref_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid reftype_box_del(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (!ptr) return;\n\tif (ptr->trackIDs) gf_free(ptr->trackIDs);\n\tgf_free(ptr);\n}\n\n\nGF_Err reftype_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\n\tbytesToRead = (u32) (ptr->size);\n\tif (!bytesToRead) return GF_OK;\n\n\tptr->trackIDCount = (u32) (bytesToRead) / sizeof(u32);\n\tptr->trackIDs = (GF_ISOTrackID *) gf_malloc(ptr->trackIDCount * sizeof(GF_ISOTrackID));\n\tif (!ptr->trackIDs) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tptr->trackIDs[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *reftype_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceTypeBox, GF_ISOM_BOX_TYPE_REFT);\n\treturn (GF_Box *)tmp;\n}\n\n\nGF_Err reftype_AddRefTrack(GF_TrackReferenceTypeBox *ref, GF_ISOTrackID trackID, u16 *outRefIndex)\n{\n\tu32 i;\n\tif (!ref || !trackID) return GF_BAD_PARAM;\n\n\tif (outRefIndex) *outRefIndex = 0;\n\t//don't add a dep if already here !!\n\tfor (i = 0; i < ref->trackIDCount; i++) {\n\t\tif (ref->trackIDs[i] == trackID) {\n\t\t\tif (outRefIndex) *outRefIndex = i+1;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tref->trackIDs = (GF_ISOTrackID *) gf_realloc(ref->trackIDs, (ref->trackIDCount + 1) * sizeof(GF_ISOTrackID) );\n\tif (!ref->trackIDs) return GF_OUT_OF_MEM;\n\tref->trackIDs[ref->trackIDCount] = trackID;\n\tref->trackIDCount++;\n\tif (outRefIndex) *outRefIndex = ref->trackIDCount;\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err reftype_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (ptr->reference_type == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->reference_type;\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = GF_ISOM_BOX_TYPE_REFT;\n\tif (e) return e;\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->trackIDs[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err reftype_box_size(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (ptr->trackIDCount)\n\t\tptr->size += (ptr->trackIDCount * sizeof(u32));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trex_box_del(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trex_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->trackID = gf_bs_read_u32(bs);\n\tptr->def_sample_desc_index = gf_bs_read_u32(bs);\n\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\tptr->def_sample_size = gf_bs_read_u32(bs);\n\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *trex_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtendsBox, GF_ISOM_BOX_TYPE_TREX);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trex_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\t//we always write 1 in trex default sample desc as using 0 breaks chrome/opera/...\n\tgf_bs_write_u32(bs, ptr->def_sample_desc_index ? ptr->def_sample_desc_index : 1);\n\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\treturn GF_OK;\n}\n\nGF_Err trex_box_size(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tptr->size += 20;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid trep_box_del(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trep_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *trep_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtensionPropertiesBox, GF_ISOM_BOX_TYPE_TREP);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trep_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\treturn GF_OK;\n}\n\nGF_Err trep_box_size(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trun_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->samples) gf_free(ptr->samples);\n\tif (ptr->cache) gf_bs_del(ptr->cache);\n\tif (ptr->sample_order) gf_free(ptr->sample_order);\n\tgf_free(ptr);\n}\n\n#ifdef GF_ENABLE_CTRN\n\nstatic u32 ctrn_field_size(u32 field_idx)\n{\n\tif (field_idx==3) return 4;\n\treturn field_idx;\n}\n\nu32 gf_isom_ctrn_field_size_bits(u32 field_idx)\n{\n\tif (field_idx==3) return 32;\n\treturn field_idx*8;\n}\nstatic u32 ctrn_read_flags(GF_BitStream *bs, u32 nbbits)\n{\n\tu32 val = gf_bs_read_int(bs, nbbits);\n\tif (nbbits==16) val <<= 16;\n\telse if (nbbits==8) val <<= 24;\n\treturn val;\n}\n\nstatic GF_Err ctrn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count, flags, first_idx=0;\n\tBool inherit_dur, inherit_size, inherit_flags, inherit_ctso;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\tflags = ptr->flags;\n\tptr->ctrn_flags = flags;\n\tptr->flags = 0;\n\n\tptr->sample_count = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\n\tif (flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tif (flags & GF_ISOM_CTRN_DATAOFFSET_16) {\n\t\t\tptr->data_offset = gf_bs_read_u16(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\t} else {\n\t\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\t}\n\t\tptr->flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\t}\n\tif (flags & GF_ISOM_CTRN_CTSO_MULTIPLIER) {\n\t\tptr->ctso_multiplier = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t}\n\t/*no sample dur/sample_flag/size/ctso for first or following, create a pack sample */\n\tif (! (flags & 0x00FFFF00)) {\n\t\tGF_SAFEALLOC(ent, GF_TrunEntry);\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tent->nb_pack = ptr->sample_count;\n\t\tgf_list_add(ptr->entries, ent);\n\t\treturn GF_OK;\n\t}\n\t/*allocate all entries*/\n\tfor (i=0; i<ptr->sample_count; i++) {\n\t\tGF_SAFEALLOC(ent, GF_TrunEntry);\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tgf_list_add(ptr->entries, ent);\n\t}\n\t//unpack flags\n\tptr->ctrn_first_dur = (flags>>22) & 0x3;\n\tptr->ctrn_first_size = (flags>>20) & 0x3;\n\tptr->ctrn_first_sample_flags = (flags>>18) & 0x3;\n\tptr->ctrn_first_ctts = (flags>>16) & 0x3;\n\tptr->ctrn_dur = (flags>>14) & 0x3;\n\tptr->ctrn_size = (flags>>12) & 0x3;\n\tptr->ctrn_sample_flags = (flags>>10) & 0x3;\n\tptr->ctrn_ctts = (flags>>8) & 0x3;\n\n\tinherit_dur = flags & GF_ISOM_CTRN_INHERIT_DUR;\n\tinherit_size = flags & GF_ISOM_CTRN_INHERIT_SIZE;\n\tinherit_flags = flags & GF_ISOM_CTRN_INHERIT_FLAGS;\n\tinherit_ctso = flags & GF_ISOM_CTRN_INHERIT_CTSO;\n\n\tif (flags & GF_ISOM_CTRN_FIRST_SAMPLE) {\n\t\tent = gf_list_get(ptr->entries, 0);\n\t\tfirst_idx = 1;\n\t\tif (!inherit_dur && ptr->ctrn_first_dur) {\n\t\t\tent->Duration = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_dur) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_dur) );\n\t\t}\n\t\tif (!inherit_size && ptr->ctrn_first_size) {\n\t\t\tent->size = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_size) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_size) );\n\t\t}\n\t\tif (!inherit_flags && ptr->ctrn_first_sample_flags) {\n\t\t\tent->flags = ctrn_read_flags(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_sample_flags) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_sample_flags) );\n\t\t}\n\t\tif (!inherit_ctso && ptr->ctrn_first_ctts) {\n\t\t\tent->CTS_Offset = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_ctts) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_ctts) );\n\t\t\tif (ptr->ctso_multiplier)\n\t\t\t\tent->CTS_Offset *= (s32) ptr->ctso_multiplier;\n\t\t}\n\t}\n\tcount = ptr->sample_count - first_idx;\n\tif (!inherit_dur && ptr->ctrn_dur) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_dur);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->Duration = gf_bs_read_int(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_size && ptr->ctrn_size) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_size);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->size = gf_bs_read_int(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_flags && ptr->ctrn_sample_flags) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_sample_flags);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->flags = ctrn_read_flags(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_ctso && ptr->ctrn_ctts) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_ctts);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->CTS_Offset = gf_bs_read_int(bs, nbbits);\n\t\t\tif (ptr->ctso_multiplier)\n\t\t\t\tent->CTS_Offset *= (s32) ptr->ctso_multiplier;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->type == GF_ISOM_BOX_TYPE_CTRN) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_TRUN;\n\t\tptr->use_ctrn = GF_TRUE;\n\t\treturn ctrn_box_read(s, bs);\n\t}\n#endif\n\n\t//check this is a good file\n\tif ((ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) && (ptr->flags & GF_ISOM_TRUN_FLAGS))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->sample_count = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->first_sample_flags = gf_bs_read_u32(bs);\n\t}\n\tif (! (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) {\n\t\tptr->samples = gf_malloc(sizeof(GF_TrunEntry));\n\t\tif (!ptr->samples) return GF_OUT_OF_MEM;\n\t\t//memset to 0 !!\n\t\tmemset(ptr->samples, 0, sizeof(GF_TrunEntry));\n\t\tptr->sample_alloc = ptr->nb_samples = 1;\n\t\tptr->samples[0].nb_pack = ptr->sample_count;\n\t} else {\n\t\t//if we get here, at least one flag (so at least 4 bytes) is set, check size\n\t\tif (ptr->sample_count * 4 > ptr->size) {\n\t\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count*4);\n\t\t}\n\t\tif ((u64)ptr->sample_count > (u64)SIZE_MAX/sizeof(GF_TrunEntry)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of samples %d in trun\\n\", ptr->sample_count));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->samples = gf_malloc(sizeof(GF_TrunEntry) * ptr->sample_count);\n\t\tif (!ptr->samples) return GF_OUT_OF_MEM;\n\t\tptr->sample_alloc = ptr->nb_samples = ptr->sample_count;\n\t\t//memset to 0 upfront\n\t\tmemset(ptr->samples, 0, ptr->sample_count * sizeof(GF_TrunEntry));\n\n\t\t//read each entry (even though nothing may be written)\n\t\tfor (i=0; i<ptr->sample_count; i++) {\n\t\t\tu32 trun_size = 0;\n\t\t\tGF_TrunEntry *p = &ptr->samples[i];\n\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\t\tp->Duration = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\t\tp->size = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tp->flags = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tp->CTS_Offset = (u32) gf_bs_read_u32(bs);\n\t\t\t\t} else {\n\t\t\t\t\tp->CTS_Offset = (s32) gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tISOM_DECREASE_SIZE(ptr, trun_size);\n\t\t}\n\t}\n\t/*todo parse sample reorder*/\n\tif (ptr->size) {\n\t\tgf_bs_skip_bytes(bs, ptr->size);\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trun_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRunBox, GF_ISOM_BOX_TYPE_TRUN);\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#ifdef GF_ENABLE_CTRN\nstatic void ctrn_write_sample_flags(GF_BitStream *bs, u32 flags, u32 field_size)\n{\n\tif (!field_size) return;\n\n\tif (field_size==8) flags = flags>>24;\n\telse if (field_size==16) flags = flags>>16;\n\tgf_bs_write_int(bs, flags, field_size);\n}\n\n\nstatic void ctrn_write_ctso(GF_TrackFragmentRunBox *ctrn, GF_BitStream *bs, u32 ctso, u32 field_size)\n{\n\tif (!field_size) return;\n\n\tif (ctrn->ctso_multiplier) {\n\t\tgf_bs_write_int(bs, ctso / ctrn->ctso_multiplier, field_size);\n\t} else {\n\t\tgf_bs_write_int(bs, ctso, field_size);\n\t}\n}\n\nGF_Err ctrn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, count, flags;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *ctrn = (GF_TrackFragmentRunBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tflags = ctrn->flags;\n\tctrn->flags = ctrn->ctrn_flags;\n\tctrn->type = GF_ISOM_BOX_TYPE_CTRN;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tctrn->flags = flags;\n\tctrn->type = GF_ISOM_BOX_TYPE_TRUN;\n\n\tgf_bs_write_u16(bs, ctrn->sample_count);\n\tif (ctrn->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tif (ctrn->ctrn_flags & GF_ISOM_CTRN_DATAOFFSET_16) {\n\t\t\tgf_bs_write_u16(bs, ctrn->data_offset);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, ctrn->data_offset);\n\t\t}\n\t}\n\tif (ctrn->ctso_multiplier) {\n\t\tgf_bs_write_u16(bs, ctrn->ctso_multiplier);\n\t}\n\t/*we always write first sample using first flags*/\n\tent = gf_list_get(ctrn->entries, 0);\n\tgf_bs_write_int(bs, ent->Duration, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_dur) );\n\tgf_bs_write_int(bs, ent->size, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_size) );\n\tctrn_write_sample_flags(bs, ent->flags, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_sample_flags) );\n\tctrn_write_ctso(ctrn,bs, ent->CTS_Offset, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_ctts) );\n\n\tcount = gf_list_count(ctrn->entries);\n\tif (ctrn->ctrn_dur) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_dur);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tgf_bs_write_int(bs, a_ent->Duration, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_size) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_size);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tgf_bs_write_int(bs, a_ent->size, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_sample_flags) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_sample_flags);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tctrn_write_sample_flags(bs, a_ent->flags, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_ctts) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_ctts);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tctrn_write_ctso(ctrn, bs, a_ent->CTS_Offset, nbbits);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->use_ctrn)\n\t\treturn ctrn_box_write(s, bs);\n#endif\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tgf_bs_write_u32(bs, ptr->data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tgf_bs_write_u32(bs, ptr->first_sample_flags);\n\t}\n\n\tif (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) )  {\n\t\tfor (i=0; i<ptr->nb_samples; i++) {\n\t\t\tGF_TrunEntry *p = &ptr->samples[i];\n\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\t\tgf_bs_write_u32(bs, p->Duration);\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\t\tgf_bs_write_u32(bs, p->size);\n\t\t\t}\n\t\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tgf_bs_write_u32(bs, p->flags);\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tgf_bs_write_u32(bs, p->CTS_Offset);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) p->CTS_Offset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ptr->sample_order) {\n\t\tu32 nb_bits = 8;\n\t\tif (ptr->sample_count>0xFFFFFF) nb_bits = 32;\n\t\telse if (ptr->sample_count>0xFFFF) nb_bits = 24;\n\t\telse if (ptr->sample_count>0xFF) nb_bits = 16;\n\n\t\tfor (i=0; i<ptr->sample_count; i++) {\n\t\t\tgf_bs_write_int(bs, ptr->sample_order[i], nb_bits);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifdef GF_ENABLE_CTRN\nstatic u32 ctrn_sample_flags_to_index(u32 val)\n{\n\tif (!val) return 0;\n\tif (val & 0x0000FFFF)\n\t\treturn 3;\n\tif (val & 0x00FF0000)\n\t\treturn 2;\n\treturn 1;\n}\nstatic u32 ctrn_u32_to_index(u32 val)\n{\n\tif (!val) return 0;\n\tif (val<=255) return 1;\n\tif (val<=65535) return 2;\n\treturn 3;\n}\nstatic u32 ctrn_s32_to_index(s32 val)\n{\n\tif (!val) return 0;\n\tif (ABS(val)<=127) return 1;\n\tif (ABS(val)<=32767) return 2;\n\treturn 3;\n}\nstatic u32 ctrn_ctts_to_index(GF_TrackFragmentRunBox *ctrn, s32 ctts)\n{\n\tif (!(ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET))\n\t\treturn 0;\n\n\tif (!ctts) return 0;\n\n\tif (ctrn->version) {\n\t\tif (ctrn->ctso_multiplier) return ctrn_s32_to_index(ctts / ctrn->ctso_multiplier);\n\t\treturn ctrn_s32_to_index(ctts);\n\t}\n\tassert(ctts>0);\n\tif (ctrn->ctso_multiplier) return ctrn_u32_to_index((u32)ctts / ctrn->ctso_multiplier);\n\treturn ctrn_s32_to_index((u32)ctts);\n}\n\nstatic GF_Err ctrn_box_size(GF_TrackFragmentRunBox *ctrn)\n{\n\tBool use_ctso_multi = GF_TRUE;\n\tu32 i, count;\n\tGF_TrunEntry *ent;\n\n\tctrn->ctrn_flags = 0;\n\tctrn->ctrn_first_dur = ctrn->ctrn_first_size = ctrn->ctrn_first_sample_flags = ctrn->ctrn_first_ctts = 0;\n\tctrn->ctrn_dur = ctrn->ctrn_size = ctrn->ctrn_sample_flags = ctrn->ctrn_ctts = 0;\n\n\tctrn->size += 2; //16 bits for sample count\n\tif (ctrn->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tctrn->ctrn_flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\t\tif (ABS(ctrn->data_offset) < 32767) {\n\t\t\tctrn->size += 2;\n\t\t\tctrn->ctrn_flags |= GF_ISOM_CTRN_DATAOFFSET_16;\n\t\t} else\n\t\t\tctrn->size += 4;\n\t}\n\n\tcount = gf_list_count(ctrn->entries);\n\tif (ctrn->ctso_multiplier && (ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET) && (ctrn->ctso_multiplier<=0xFFFF) ) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tif (a_ent->CTS_Offset % ctrn->ctso_multiplier) {\n\t\t\t\tuse_ctso_multi = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tuse_ctso_multi = GF_FALSE;\n\t}\n\tif (ctrn->use_inherit) {\n\t\tuse_ctso_multi = GF_FALSE;\n\t\tctrn->ctrn_flags |= 0xB0; //duration=1,size=0,flags=1,cts=1 << 4\n\t}\n\n\tif (use_ctso_multi) {\n\t\tctrn->size += 2;\n\t\tctrn->ctrn_flags |= GF_ISOM_CTRN_CTSO_MULTIPLIER;\n\t} else {\n\t\tctrn->ctso_multiplier = 0;\n\t}\n\n\t/*we always write first sample using first flags*/\n\tent = gf_list_get(ctrn->entries, 0);\n\tctrn->ctrn_flags |= GF_ISOM_CTRN_FIRST_SAMPLE;\n\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_DURATION)) {\n\t\tctrn->ctrn_first_dur = ctrn_u32_to_index(ent->Duration);\n\t\tif (ctrn->ctrn_first_dur) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_dur);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_dur<<22;\n\t\t}\n\t}\n\n\tif (ctrn->flags & GF_ISOM_TRUN_SIZE) {\n\t\tctrn->ctrn_first_size = ctrn_u32_to_index(ent->size);\n\t\tif (ctrn->ctrn_first_size) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_size);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_size<<20;\n\t\t}\n\t}\n\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_FLAGS)) {\n\t\tctrn->ctrn_first_sample_flags = ctrn_sample_flags_to_index(ent->flags);\n\t\tif (ctrn->ctrn_first_sample_flags) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_sample_flags);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_sample_flags<<18;\n\t\t}\n\t}\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET)) {\n\t\tctrn->ctrn_first_ctts = ctrn_ctts_to_index(ctrn, ent->CTS_Offset);\n\t\tif (ctrn->ctrn_first_ctts) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_ctts);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_ctts<<16;\n\t\t}\n\t}\n\n\tfor (i=1; i<count; i++) {\n\t\tu8 field_idx;\n\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\n\t\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_DURATION)) {\n\t\t\tfield_idx = ctrn_u32_to_index(a_ent->Duration);\n\t\t\tif (ctrn->ctrn_dur < field_idx)\n\t\t\t\tctrn->ctrn_dur = field_idx;\n\t\t}\n\t\tif (ctrn->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\tfield_idx = ctrn_u32_to_index(a_ent->size);\n\t\t\tif (ctrn->ctrn_size < field_idx)\n\t\t\t\tctrn->ctrn_size = field_idx;\n\t\t}\n\t\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_FLAGS)) {\n\t\t\tfield_idx = ctrn_sample_flags_to_index(a_ent->flags);\n\t\t\tif (ctrn->ctrn_sample_flags < field_idx)\n\t\t\t\tctrn->ctrn_sample_flags = field_idx;\n\t\t}\n\t\tif (!ctrn->use_inherit) {\n\t\t\tfield_idx = ctrn_ctts_to_index(ctrn, a_ent->CTS_Offset);\n\t\t\tif (ctrn->ctrn_ctts < field_idx)\n\t\t\t\tctrn->ctrn_ctts = field_idx;\n\t\t}\n\t}\n\tcount-=1;\n\tif (ctrn->ctrn_dur) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_dur);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_dur<<14;\n\t}\n\tif (ctrn->ctrn_size) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_size);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_size<<12;\n\t}\n\tif (ctrn->ctrn_sample_flags) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_sample_flags);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_sample_flags<<10;\n\t}\n\tif (ctrn->ctrn_ctts) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_ctts);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_ctts<<8;\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_size(GF_Box *s)\n{\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->use_ctrn)\n\t\treturn ctrn_box_size(ptr);\n#endif\n\n\tptr->size += 4;\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) ptr->size += 4;\n\n\tif (ptr->sample_order) {\n\t\tu32 nb_bytes = 1;\n\t\tif (ptr->sample_count>0xFFFFFF) nb_bytes = 4;\n\t\telse if (ptr->sample_count>0xFFFF) nb_bytes = 3;\n\t\telse if (ptr->sample_count>0xFF) nb_bytes = 2;\n\t\tptr->size += ptr->sample_count*nb_bytes;\n\t}\n\n\tif (! (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) {\n\t\treturn GF_OK;\n\t}\n\n\t//if nothing to do, this will be skipped automatically\n\tif (ptr->flags & GF_ISOM_TRUN_DURATION) ptr->size += 4*ptr->nb_samples;\n\tif (ptr->flags & GF_ISOM_TRUN_SIZE) ptr->size += 4*ptr->nb_samples;\n\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) ptr->size += 4*ptr->nb_samples;\n\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) ptr->size += 4*ptr->nb_samples;\n\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tsro_box_del(GF_Box *s)\n{\n\tGF_TimeOffHintEntryBox *tsro = (GF_TimeOffHintEntryBox *)s;\n\tgf_free(tsro);\n}\n\nGF_Err tsro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->TimeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tsro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeOffHintEntryBox, GF_ISOM_BOX_TYPE_TSRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tsro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->TimeOffset);\n\treturn GF_OK;\n}\n\nGF_Err tsro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid udta_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (ptr == NULL) return;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\tgf_list_del(ptr->recordList);\n\tgf_free(ptr);\n}\n\nGF_UserDataMap *udta_getEntry(GF_UserDataBox *ptr, u32 box_type, bin128 *uuid)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tif (ptr == NULL) return NULL;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tif (map->boxType == box_type) {\n\t\t\tif ((box_type != GF_ISOM_BOX_TYPE_UUID) || !uuid) return map;\n\t\t\tif (!memcmp(map->uuid, *uuid, 16)) return map;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nGF_Err udta_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_Err e;\n\tu32 box_type;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\tif (!a) return GF_OK;\n\n\t//detach from parent list if any\n\tgf_list_del_item(ptr->child_boxes, a);\n\n\t/* for unknown udta boxes, we reference them by their original box type */\n\tbox_type = a->type;\n\tif (box_type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tGF_UnknownBox* unkn = (GF_UnknownBox *)a;\n\t\tbox_type = unkn->original_4cc;\n\t}\n\n\tmap = udta_getEntry(ptr, box_type, (a->type==GF_ISOM_BOX_TYPE_UUID) ? & ((GF_UUIDBox *)a)->uuid : NULL);\n\tif (map == NULL) {\n\t\tif (is_rem) return GF_OK;\n\n\t\tmap = (GF_UserDataMap *) gf_malloc(sizeof(GF_UserDataMap));\n\t\tif (map == NULL) return GF_OUT_OF_MEM;\n\t\tmemset(map, 0, sizeof(GF_UserDataMap));\n\n\t\tmap->boxType = box_type;\n\t\tif (a->type == GF_ISOM_BOX_TYPE_UUID)\n\t\t\tmemcpy(map->uuid, ((GF_UUIDBox *)a)->uuid, 16);\n\t\tmap->boxes = gf_list_new();\n\t\tif (!map->boxes) {\n\t\t\tgf_free(map);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(ptr->recordList, map);\n\t\tif (e) return e;\n\t}\n\tif (is_rem) {\n\t\tgf_list_del_item(map->boxes, a);\n\t\treturn GF_OK;\n\t}\n\tu32 i, count = gf_list_count(map->boxes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(map->boxes, i);\n\t\tu32 btype = b->type;\n\t\tif (b->type==GF_ISOM_BOX_TYPE_UNKNOWN) btype = ((GF_UnknownBox*)b)->original_4cc;\n\t\tif (btype != box_type) continue;\n\t\tif (box_type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (memcmp( ((GF_UUIDBox *)a)->uuid, ((GF_UUIDBox *)b)->uuid, 16)) continue;\n\t\t}\n\t\tgf_isom_box_del(b);\n\t\tgf_list_rem(map->boxes, i);\n\t\tbreak;\n\t}\n\treturn gf_list_add(map->boxes, a);\n}\n\n\nGF_Err udta_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\tif (s->size==4) {\n\t\tu32 val = gf_bs_read_u32(bs);\n\t\ts->size = 0;\n\t\tif (val) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] udta has 4 remaining bytes set to %08X but they should be 0\\n\", val));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *udta_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UserDataBox, GF_ISOM_BOX_TYPE_UDTA);\n\ttmp->recordList = gf_list_new();\n\tif (!tmp->recordList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err udta_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_write(s, map->boxes, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err udta_box_size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_size(s, map->boxes);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid vmhd_box_del(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err vmhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->reserved = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\n\nGF_Box *vmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_VideoMediaHeaderBox, GF_ISOM_BOX_TYPE_VMHD);\n\ttmp->flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err vmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err vmhd_box_size(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid void_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err void_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tif (s->size) return GF_ISOM_INVALID_FILE;\n\treturn GF_OK;\n}\n\nGF_Box *void_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, GF_ISOM_BOX_TYPE_VOID);\n\treturn tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err void_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err void_box_size(GF_Box *s)\n{\n\ts->size = 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *pdin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProgressiveDownloadBox, GF_ISOM_BOX_TYPE_PDIN);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pdin_box_del(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->rates) gf_free(ptr->rates);\n\tif (ptr->times) gf_free(ptr->times);\n\tgf_free(ptr);\n}\n\n\nGF_Err pdin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\n\tptr->count = (u32) (ptr->size) / 8;\n\tptr->rates = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tif (!ptr->rates) return GF_OUT_OF_MEM;\n\tptr->times = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tif (!ptr->times) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->count; i++) {\n\t\tptr->rates[i] = gf_bs_read_u32(bs);\n\t\tptr->times[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pdin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tfor (i=0; i<ptr->count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->rates[i]);\n\t\tgf_bs_write_u32(bs, ptr->times[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pdin_box_size(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\tptr->size += 8*ptr->count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *sdtp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDependencyTypeBox, GF_ISOM_BOX_TYPE_SDTP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid sdtp_box_del(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info) gf_free(ptr->sample_info);\n\tgf_free(ptr);\n}\n\n\nGF_Err sdtp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\n\t/*out-of-order sdtp, assume no padding at the end*/\n\tif (!ptr->sampleCount) ptr->sampleCount = (u32) ptr->size;\n\telse if (ptr->sampleCount > (u32) ptr->size) return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_info = (u8 *) gf_malloc(sizeof(u8)*ptr->sampleCount);\n\tif (!ptr->sample_info) return GF_OUT_OF_MEM;\n\tptr->sample_alloc = ptr->sampleCount;\n\tgf_bs_read_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\tISOM_DECREASE_SIZE(ptr, ptr->sampleCount);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sdtp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\treturn GF_OK;\n}\n\nGF_Err sdtp_box_size(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\tptr->size += ptr->sampleCount;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *pasp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PixelAspectRatioBox, GF_ISOM_BOX_TYPE_PASP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pasp_box_del(GF_Box *s)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err pasp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->hSpacing = gf_bs_read_u32(bs);\n\tptr->vSpacing = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pasp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->hSpacing);\n\tgf_bs_write_u32(bs, ptr->vSpacing);\n\treturn GF_OK;\n}\n\nGF_Err pasp_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *clap_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CleanApertureBox, GF_ISOM_BOX_TYPE_CLAP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid clap_box_del(GF_Box *s)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err clap_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 32);\n\tptr->cleanApertureWidthN = gf_bs_read_u32(bs);\n\tptr->cleanApertureWidthD = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightN = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightD = gf_bs_read_u32(bs);\n\tptr->horizOffN = (s32) gf_bs_read_u32(bs);\n\tptr->horizOffD = gf_bs_read_u32(bs);\n\tptr->vertOffN = (s32) gf_bs_read_u32(bs);\n\tptr->vertOffD = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err clap_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthD);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightD);\n\tgf_bs_write_u32(bs, (u32) ptr->horizOffN);\n\tgf_bs_write_u32(bs, ptr->horizOffD);\n\tgf_bs_write_u32(bs, (u32) ptr->vertOffN);\n\tgf_bs_write_u32(bs, ptr->vertOffD);\n\treturn GF_OK;\n}\n\nGF_Err clap_box_size(GF_Box *s)\n{\n\ts->size += 32;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *metx_box_new()\n{\n\t//type is overridden by the box constructor\n\tISOM_DECL_BOX_ALLOC(GF_MetaDataSampleEntryBox, GF_ISOM_BOX_TYPE_METX);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid metx_box_del(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tif (ptr->xml_namespace) gf_free(ptr->xml_namespace);\n\tif (ptr->xml_schema_loc) gf_free(ptr->xml_schema_loc);\n\tif (ptr->mime_type) gf_free(ptr->mime_type);\n\tgf_free(ptr);\n}\n\n\nGF_Err metx_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TXTC:\n\t\t//we allow the config box on metx\n\t\tBOX_FIELD_ASSIGN(config, GF_TextConfigBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err metx_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 size, i;\n\tGF_Err e;\n\tchar *str;\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\tif (ptr->size > (u64)SIZE_MAX) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size \"LLU\" in metx\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tsize = (u32) ptr->size;\n\tstr = gf_malloc(sizeof(char)*size);\n\tif (!str) return GF_OUT_OF_MEM;\n\ti=0;\n\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i]) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!size && i>1 && str[i-1]) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (i>1) {\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t} else {\n\t\t\tptr->content_encoding = gf_strdup(str);\n\t\t}\n\t}\n\n\ti=0;\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i]) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!size && i>1 && str[i-1]) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (i>1) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t\t}\n\t\t}\n\n\t\ti=0;\n\t\twhile (size) {\n\t\t\tstr[i] = gf_bs_read_u8(bs);\n\t\t\tsize--;\n\t\t\tif (!str[i]) {\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (!size && i>1 && str[i-1]) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\t\tgf_free(str);\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (i>1) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->mime_type = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t}\n\t\t}\n\t}\n\t//mett, sbtt, stxt, stpp\n\telse {\n\t\tif (i>1) ptr->mime_type = gf_strdup(str);\n\t}\n\tptr->size = size;\n\tgf_free(str);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err metx_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tgf_bs_write_data(bs, ptr->content_encoding, (u32) strlen(ptr->content_encoding));\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (ptr->xml_namespace)\n\t\t\tgf_bs_write_data(bs, ptr->xml_namespace, (u32) strlen(ptr->xml_namespace));\n\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tgf_bs_write_data(bs, ptr->xml_schema_loc, (u32) strlen(ptr->xml_schema_loc));\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err metx_box_size(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tptr->size += 8;\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tptr->size += strlen(ptr->content_encoding);\n\t\tptr->size++;\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\n\t\tif (ptr->xml_namespace)\n\t\t\tptr->size += strlen(ptr->xml_namespace);\n\t\tptr->size++;\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tptr->size += strlen(ptr->xml_schema_loc);\n\t\tptr->size++;\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tptr->size += strlen(ptr->mime_type);\n\t\t\tptr->size++;\n\t\t}\n\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tptr->size += strlen(ptr->mime_type);\n\t\tptr->size++;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* SimpleTextSampleEntry */\nGF_Box *txtc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextConfigBox, GF_ISOM_BOX_TYPE_TXTC);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid txtc_box_del(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->config) gf_free(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err txtc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\tif ((u32)ptr->size >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in txtc box\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->config = (char *)gf_malloc(sizeof(char)*((u32) ptr->size+1));\n\tif (!ptr->config) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->config, (u32) ptr->size);\n\tptr->config[ptr->size] = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err txtc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->config)\n\t\tgf_bs_write_data(bs, ptr->config, (u32) strlen(ptr->config));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err txtc_box_size(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tif (ptr->config)\n\t\tptr->size += strlen(ptr->config);\n\tptr->size++;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dac3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *dec3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\ttmp->cfg.is_ec3 = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dac3_box_del(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tgf_free(ptr);\n}\n\n\nGF_Err dac3_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tpos = gf_bs_get_position(bs);\n\te = gf_odf_ac3_config_parse_bs(bs, ptr->cfg.is_ec3, &ptr->cfg);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs) - pos;\n\tISOM_DECREASE_SIZE(ptr, pos);\n\n\tif (ptr->size>=2) {\n\t\tptr->size-=2;\n\t\tgf_bs_read_int(bs, 7);\n\t\tptr->cfg.atmos_ec3_ext = gf_bs_read_int(bs, 1);\n\t\tptr->cfg.complexity_index_type = gf_bs_read_u8(bs);\n\t}\n\t//the rest is reserved\n\tgf_bs_skip_bytes(bs, ptr->size);\n\tptr->size = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\t\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dac3_box_size(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) {\n\t\tu32 i;\n\t\ts->size += 2;\n\t\tfor (i=0; i<ptr->cfg.nb_streams; i++) {\n\t\t\ts->size += 3;\n\t\t\tif (ptr->cfg.streams[i].nb_dep_sub)\n\t\t\t\ts->size += 1;\n\t\t}\n\t} else {\n\t\ts->size += 3;\n\t}\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\ts->size += 2;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid lsrc_box_del(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->hdr) gf_free(ptr->hdr);\n\tgf_free(ptr);\n}\n\n\nGF_Err lsrc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->hdr_size = (u32) ptr->size;\n\tptr->hdr = gf_malloc(sizeof(char)*ptr->hdr_size);\n\tif (!ptr->hdr) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Box *lsrc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASERConfigurationBox, GF_ISOM_BOX_TYPE_LSRC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err lsrc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Err lsrc_box_size(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->size += ptr->hdr_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid lsr1_box_del(GF_Box *s)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err lsr1_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_LSRC:\n\t\tBOX_FIELD_ASSIGN(lsr_config, GF_LASERConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tBOX_FIELD_ASSIGN(descr, GF_MPEG4ExtensionDescriptorsBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *lsr1_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASeRSampleEntryBox, GF_ISOM_BOX_TYPE_LSR1);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err lsr1_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err lsr1_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *)ptr->lsr_config, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid sidx_box_del(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->refs) gf_free(ptr->refs);\n\tgf_free(ptr);\n}\n\nGF_Err sidx_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->reference_ID = gf_bs_read_u32(bs);\n\tptr->timescale = gf_bs_read_u32(bs);\n\n\tif (ptr->version==0) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->earliest_presentation_time = gf_bs_read_u32(bs);\n\t\tptr->first_offset = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->earliest_presentation_time = gf_bs_read_u64(bs);\n\t\tptr->first_offset = gf_bs_read_u64(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tgf_bs_read_u16(bs); /* reserved */\n\tptr->nb_refs = gf_bs_read_u16(bs);\n\n\tptr->refs = gf_malloc(sizeof(GF_SIDXReference)*ptr->nb_refs);\n\tif (!ptr->refs) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->nb_refs; i++) {\n\t\tptr->refs[i].reference_type = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].reference_size = gf_bs_read_int(bs, 31);\n\t\tptr->refs[i].subsegment_duration = gf_bs_read_u32(bs);\n\t\tptr->refs[i].starts_with_SAP = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].SAP_type = gf_bs_read_int(bs, 3);\n\t\tptr->refs[i].SAP_delta_time = gf_bs_read_int(bs, 28);\n\n\t\tISOM_DECREASE_SIZE(ptr, 12);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *sidx_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SegmentIndexBox, GF_ISOM_BOX_TYPE_SIDX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sidx_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->reference_ID);\n\tgf_bs_write_u32(bs, ptr->timescale);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->earliest_presentation_time);\n\t\tgf_bs_write_u32(bs, (u32) ptr->first_offset);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->earliest_presentation_time);\n\t\tgf_bs_write_u64(bs, ptr->first_offset);\n\t}\n\tgf_bs_write_u16(bs, 0);\n\tgf_bs_write_u16(bs, ptr->nb_refs);\n\tfor (i=0; i<ptr->nb_refs; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_type, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_size, 31);\n\t\tgf_bs_write_u32(bs, ptr->refs[i].subsegment_duration);\n\t\tgf_bs_write_int(bs, ptr->refs[i].starts_with_SAP, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_type, 3);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_delta_time, 28);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sidx_box_size(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tptr->size += 12;\n\tif (ptr->version==0) {\n\t\tptr->size += 8;\n\t} else {\n\t\tptr->size += 16;\n\t}\n\tptr->size += ptr->nb_refs * 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ssix_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->subsegments) {\n\t\tfor (i = 0; i < ptr->subsegment_alloc; i++) {\n\t\t\tGF_SubsegmentInfo *subsegment = &ptr->subsegments[i];\n\t\t\tif (subsegment->ranges) gf_free(subsegment->ranges);\n\t\t}\n\t\tgf_free(ptr->subsegments);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err ssix_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i,j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\t//each subseg has at least one range_count (4 bytes), abort if not enough bytes (broken box)\n\tif (ptr->size / 4 < ptr->subsegment_count || (u64)ptr->subsegment_count > (u64)SIZE_MAX/sizeof(GF_SubsegmentInfo))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->subsegment_alloc = ptr->subsegment_count;\n\tGF_SAFE_ALLOC_N(ptr->subsegments, ptr->subsegment_count, GF_SubsegmentInfo);\n\tif (!ptr->subsegments)\n\t    return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tGF_SubsegmentInfo *subseg = &ptr->subsegments[i];\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tsubseg->range_count = gf_bs_read_u32(bs);\n\t\t//each range is 4 bytes, abort if not enough bytes\n\t\tif (ptr->size / 4 < subseg->range_count || (u64)subseg->range_count > (u64)SIZE_MAX/sizeof(GF_SubsegmentRangeInfo))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tsubseg->ranges = (GF_SubsegmentRangeInfo*) gf_malloc(sizeof(GF_SubsegmentRangeInfo) * subseg->range_count);\n\t\tif (!subseg->ranges) return GF_OUT_OF_MEM;\n\t\tfor (j = 0; j < subseg->range_count; j++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tsubseg->ranges[j].level = gf_bs_read_u8(bs);\n\t\t\tsubseg->ranges[j].range_size = gf_bs_read_u24(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *ssix_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubsegmentIndexBox, GF_ISOM_BOX_TYPE_SSIX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ssix_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\tfor (i = 0; i<ptr->subsegment_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->subsegments[i].range_count);\n\t\tfor (j = 0; j < ptr->subsegments[i].range_count; j++) {\n\t\t\tgf_bs_write_u8(bs, ptr->subsegments[i].ranges[j].level);\n\t\t\tgf_bs_write_u24(bs, ptr->subsegments[i].ranges[j].range_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ssix_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tptr->size += 4;\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tptr->size += 4 + 4 * ptr->subsegments[i].range_count;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid leva_box_del(GF_Box *s)\n{\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->levels) gf_free(ptr->levels);\n\tgf_free(ptr);\n}\n\nGF_Err leva_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->level_count = gf_bs_read_u8(bs);\n\t//each level is at least 5 bytes\n\tif (ptr->size / 5 < ptr->level_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tGF_SAFE_ALLOC_N(ptr->levels, ptr->level_count, GF_LevelAssignment);\n\tif (!ptr->levels) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tGF_LevelAssignment *level = &ptr->levels[i];\n\t\tu8 tmp;\n\t\tif (!level || ptr->size < 5) return GF_BAD_PARAM;\n\t\tISOM_DECREASE_SIZE(ptr, 5)\n\n\t\tlevel->track_id = gf_bs_read_u32(bs);\n\t\ttmp = gf_bs_read_u8(bs);\n\t\tlevel->padding_flag = tmp >> 7;\n\t\tlevel->type = tmp & 0x7F;\n\t\tif (level->type == 0) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 1) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t\tlevel->grouping_type_parameter = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 4) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlevel->sub_track_id = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *leva_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LevelAssignmentBox, GF_ISOM_BOX_TYPE_LEVA);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err leva_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->level_count);\n\tfor (i = 0; i<ptr->level_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->levels[i].track_id);\n\t\tgf_bs_write_u8(bs, ptr->levels[i].padding_flag << 7 | (ptr->levels[i].type & 0x7F));\n\t\tif (ptr->levels[i].type == 0) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type_parameter);\n\t\t}\n\t\telse if (ptr->levels[i].type == 4) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].sub_track_id);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err leva_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tptr->size += 1;\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->levels[i].type == 0 || ptr->levels[i].type == 4) {\n\t\t\tptr->size += 4;\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tptr->size += 8;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *pcrb_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PcrInfoBox, GF_ISOM_BOX_TYPE_PCRB);\n\treturn (GF_Box *)tmp;\n}\n\nvoid pcrb_box_del(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->pcr_values) gf_free(ptr->pcr_values);\n\tgf_free(ptr);\n}\n\nGF_Err pcrb_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\n\tif ((u64)ptr->subsegment_count > ptr->size / 8 || (u64)ptr->subsegment_count > (u64)SIZE_MAX/sizeof(u64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of subsegment %d in pcrb\\n\", ptr->subsegment_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->pcr_values = gf_malloc(sizeof(u64)*ptr->subsegment_count);\n\tif (!ptr->pcr_values) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->subsegment_count; i++) {\n\t\tu64 data1 = gf_bs_read_u32(bs);\n\t\tu64 data2 = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 6);\n\t\tptr->pcr_values[i] = (data1 << 10) | (data2 >> 6);\n\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pcrb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\n\tfor (i=0; i<ptr->subsegment_count; i++ ) {\n\t\tu32 data1 = (u32) (ptr->pcr_values[i] >> 10);\n\t\tu16 data2 = (u16) (ptr->pcr_values[i] << 6);\n\n\t\tgf_bs_write_u32(bs, data1);\n\t\tgf_bs_write_u16(bs, data2);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pcrb_box_size(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tptr->size += 4;\n\tptr->size += ptr->subsegment_count * 6;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *subs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubSampleInformationBox, GF_ISOM_BOX_TYPE_SUBS);\n\ttmp->Samples = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid subs_box_del(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->Samples)) {\n\t\tGF_SubSampleInfoEntry *pSamp;\n\t\tpSamp = (GF_SubSampleInfoEntry*)gf_list_get(ptr->Samples, 0);\n\t\twhile (gf_list_count(pSamp->SubSamples)) {\n\t\t\tGF_SubSampleEntry *pSubSamp;\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, 0);\n\t\t\tgf_free(pSubSamp);\n\t\t\tgf_list_rem(pSamp->SubSamples, 0);\n\t\t}\n\t\tgf_list_del(pSamp->SubSamples);\n\t\tgf_free(pSamp);\n\t\tgf_list_rem(ptr->Samples, 0);\n\t}\n\tgf_list_del(ptr->Samples);\n\tgf_free(ptr);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err subs_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j, entry_count;\n\tu16 subsample_count;\n\tGF_SubSampleEntry *pSubSamp;\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tentry_count = gf_list_count(ptr->Samples);\n\tgf_bs_write_u32(bs, entry_count);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\tgf_bs_write_u32(bs, pSamp->sample_delta);\n\t\tgf_bs_write_u16(bs, subsample_count);\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, j);\n\t\t\tif (ptr->version == 1) {\n\t\t\t\tgf_bs_write_u32(bs, pSubSamp->subsample_size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u16(bs, pSubSamp->subsample_size);\n\t\t\t}\n\t\t\tgf_bs_write_u8(bs, pSubSamp->subsample_priority);\n\t\t\tgf_bs_write_u8(bs, pSubSamp->discardable);\n\t\t\tgf_bs_write_u32(bs, pSubSamp->reserved);\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Err subs_box_size(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\tu32 entry_count, i;\n\tu16 subsample_count;\n\n\t// add 4 byte for entry_count\n\tptr->size += 4;\n\tentry_count = gf_list_count(ptr->Samples);\n\tfor (i=0; i<entry_count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\t// 4 byte for sample_delta, 2 byte for subsample_count\n\t\t// and 6 + (4 or 2) bytes for each subsample\n\t\tptr->size += 4 + 2 + subsample_count * (6 + (ptr->version==1 ? 4 : 2));\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Err subs_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tu32 entry_count, i, j;\n\tu16 subsample_count;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tentry_count = gf_bs_read_u32(bs);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tu32 subs_size=0;\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_malloc(sizeof(GF_SubSampleInfoEntry));\n\t\tif (!pSamp) return GF_OUT_OF_MEM;\n\n\t\tmemset(pSamp, 0, sizeof(GF_SubSampleInfoEntry));\n\t\tpSamp->SubSamples = gf_list_new();\n\t\tpSamp->sample_delta = gf_bs_read_u32(bs);\n\t\tsubsample_count = gf_bs_read_u16(bs);\n\t\tsubs_size=6;\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tGF_SubSampleEntry *pSubSamp = (GF_SubSampleEntry*) gf_malloc(sizeof(GF_SubSampleEntry));\n\t\t\tif (!pSubSamp) return GF_OUT_OF_MEM;\n\n\t\t\tmemset(pSubSamp, 0, sizeof(GF_SubSampleEntry));\n\t\t\tif (ptr->version==1) {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u32(bs);\n\t\t\t\tsubs_size+=4;\n\t\t\t} else {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u16(bs);\n\t\t\t\tsubs_size+=2;\n\t\t\t}\n\t\t\tpSubSamp->subsample_priority = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->discardable = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->reserved = gf_bs_read_u32(bs);\n\t\t\tsubs_size+=6;\n\n\t\t\tgf_list_add(pSamp->SubSamples, pSubSamp);\n\t\t}\n\t\tgf_list_add(ptr->Samples, pSamp);\n\t\tISOM_DECREASE_SIZE(ptr, subs_size);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\nGF_Box *tfdt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TFBaseMediaDecodeTimeBox, GF_ISOM_BOX_TYPE_TFDT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfdt_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->baseMediaDecodeTime = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfdt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->version==1) {\n\t\tgf_bs_write_u64(bs, ptr->baseMediaDecodeTime);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->baseMediaDecodeTime);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfdt_box_size(GF_Box *s)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (!ptr->version && (ptr->baseMediaDecodeTime<=0xFFFFFFFF)) {\n\t\t//ptr->version = 0;\n\t\tptr->size += 4;\n\t} else {\n\t\tptr->version = 1;\n\t\tptr->size += 8;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nGF_Box *rvcc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RVCConfigurationBox, GF_ISOM_BOX_TYPE_RVCC);\n\treturn (GF_Box *)tmp;\n}\n\nvoid rvcc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err rvcc_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->predefined_rvc_config = gf_bs_read_u16(bs);\n\tif (!ptr->predefined_rvc_config) {\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\tptr->rvc_meta_idx = gf_bs_read_u16(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err rvcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->predefined_rvc_config);\n\tif (!ptr->predefined_rvc_config) {\n\t\tgf_bs_write_u16(bs, ptr->rvc_meta_idx);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err rvcc_box_size(GF_Box *s)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox *)s;\n\tptr->size += 2;\n\tif (! ptr->predefined_rvc_config) ptr->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *sbgp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupBox, GF_ISOM_BOX_TYPE_SBGP);\n\treturn (GF_Box *)tmp;\n}\nvoid sbgp_box_del(GF_Box *a)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox *)a;\n\tif (p->sample_entries) gf_free(p->sample_entries);\n\tgf_free(p);\n}\n\nGF_Err sbgp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleGroupBox *ptr = (GF_SampleGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tptr->entry_count = gf_bs_read_u32(bs);\n\n\tif (ptr->size < sizeof(GF_SampleGroupEntry)*ptr->entry_count || (u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(GF_SampleGroupEntry))\n\t    return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_entries = gf_malloc(sizeof(GF_SampleGroupEntry)*ptr->entry_count);\n\tif (!ptr->sample_entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->sample_entries[i].sample_count = gf_bs_read_u32(bs);\n\t\tptr->sample_entries[i].group_description_index = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sbgp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version==1)\n\t\tgf_bs_write_u32(bs, p->grouping_type_parameter);\n\n\tgf_bs_write_u32(bs, p->entry_count);\n\tfor (i = 0; i<p->entry_count; i++ ) {\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].sample_count);\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].group_description_index);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sbgp_box_size(GF_Box *s)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\tp->size += 8;\n\tif (p->grouping_type_parameter) p->version=1;\n\n\tif (p->version==1) p->size += 4;\n\tp->size += 8*p->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nstatic void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes)\n{\n\tBool null_size_ok = GF_FALSE;\n\tGF_DefaultSampleGroupDescriptionEntry *def_ptr;\n\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t{\n\t\tGF_RollRecoveryEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_RollRecoveryEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->roll_distance = gf_bs_read_int(bs, 16);\n\t\t*total_bytes = 2;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t{\n\t\tGF_VisualRandomAccessEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->num_leading_samples_known = gf_bs_read_int(bs, 1);\n\t\tptr->num_leading_samples = gf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t{\n\t\tGF_SAPEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SAPEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->dependent_flag = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 3);\n\t\tptr->SAP_type = gf_bs_read_int(bs, 4);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t{\n\t\tGF_SYNCEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SYNCEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_int(bs, 2);\n\t\tptr->NALU_type = gf_bs_read_int(bs, 6);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t{\n\t\tGF_TemporalLevelEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_TemporalLevelEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->level_independently_decodable = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *ptr;\n\t\tif (bytes_in_box<3) return NULL;\n\t\tGF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tBool use_mkey = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7); //reserved\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->IsProtected = gf_bs_read_u8(bs);\n\t\tbytes_in_box -= 3;\n\t\tif (use_mkey) {\n\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\tu32 i, count = gf_bs_read_u16(bs);\n\t\t\tbytes_in_box -= 2;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tu8 ivsize = gf_bs_read_u8(bs);\n\t\t\t\tgf_bs_skip_bytes(bs, 16);\n\t\t\t\tbytes_in_box -= 17;\n\t\t\t\tif (!ivsize) {\n\t\t\t\t\t//const IV\n\t\t\t\t\tivsize = gf_bs_read_u8(bs);\n\t\t\t\t\tgf_bs_skip_bytes(bs, ivsize);\n\t\t\t\t\tbytes_in_box -= 1 + ivsize;\n\t\t\t\t}\n\t\t\t\tif (bytes_in_box<0) {\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 1 + (u32) (gf_bs_get_position(bs) - pos);\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\tptr->key_info[0] = 1;\n\t\t\tgf_bs_read_data(bs, ptr->key_info + 1, ptr->key_info_size - 1);\n\t\t\t*total_bytes = 3 + ptr->key_info_size - 1;\n\n\t\t\tif (!gf_cenc_validate_key_info(ptr->key_info, ptr->key_info_size)) {\n\t\t\t\tgf_free(ptr->key_info);\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tbin128 kid;\n\t\t\tu8 const_iv_size = 0;\n\t\t\tu8 iv_size = gf_bs_read_u8(bs);\n\t\t\tgf_bs_read_data(bs, kid, 16);\n\t\t\tbytes_in_box -= 17;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t*total_bytes = 20;\n\t\t\tif ((ptr->IsProtected == 1) && !iv_size) {\n\t\t\t\tconst_iv_size = gf_bs_read_u8(bs);\n\t\t\t\tif ((const_iv_size != 8) && (const_iv_size != 16)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group have invalid constant_IV size\\n\"));\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 20;\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info_size += 1 + const_iv_size;\n\t\t\t}\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr->key_info[0] = 0;\n\t\t\tptr->key_info[1] = 0;\n\t\t\tptr->key_info[2] = 0;\n\t\t\tptr->key_info[3] = iv_size;\n\t\t\tmemcpy(ptr->key_info+4, kid, 16);\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info[20] = const_iv_size;\n\t\t\t\tgf_bs_read_data(bs, (char *)ptr->key_info+21, const_iv_size);\n\t\t\t\t*total_bytes += 1 + const_iv_size;\n\t\t\t}\n\t\t}\n\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t{\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_oinf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] oinf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t{\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_linf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] linf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tif (! entry_size) {\n\t\t\tu32 flags = gf_bs_peek_bits(bs, 24, 0);\n\t\t\tif (flags & 0x10000) entry_size=3;\n\t\t\telse {\n\t\t\t\tif (flags & 0x80000) entry_size=7;\n\t\t\t\telse entry_size=11;\n\t\t\t\t//have dependency list\n\t\t\t\tif (flags & 0x200000) {\n\t\t\t\t\tu32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);\n\t\t\t\t\tentry_size += 2 + 2*nb_entries;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] trif sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tif (! entry_size) {\n\t\t\tu64 start = gf_bs_get_position(bs);\n\t\t\tBool rle, large_size;\n\t\t\tu32 entry_count;\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tlarge_size = gf_bs_read_int(bs, 1);\n\t\t\trle = gf_bs_read_int(bs, 1);\n\t\t\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tgf_bs_seek(bs, start);\n\t\t\tentry_size = 1 + (large_size ? 2 : 1);\n\t\t\tentry_size += entry_count * 2;\n\t\t\tif (rle) entry_size += entry_count * (large_size ? 2 : 1);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] nalm sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\tnull_size_ok = GF_TRUE;\n\t\tbreak;\n\t//TODO, add support for these ones ?\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\tentry_size = 20;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\tentry_size = 2;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureOrderEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->subpic_id_info_flag = gf_bs_read_int(bs, 1);\n\t\tptr->num_subpic_ref_idx = gf_bs_read_int(bs, 15);\n\t\t*total_bytes = 2;\n\t\tptr->subp_track_ref_idx = gf_malloc(sizeof(u16) * ptr->num_subpic_ref_idx);\n\t\tif (!ptr->subp_track_ref_idx) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->num_subpic_ref_idx; i++) {\n\t\t\tptr->subp_track_ref_idx[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\tif (ptr->subpic_id_info_flag) {\n\t\t\tptr->spinfo.subpic_id_len_minus1 = gf_bs_read_int(bs, 4);\n\t\t\tptr->spinfo.subpic_id_bit_pos = gf_bs_read_int(bs, 12);\n\t\t\tptr->spinfo.start_code_emul_flag = gf_bs_read_int(bs, 1);\n\t\t\tptr->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (ptr->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 6);\n\t\t\t} else {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 4);\n\t\t\t\tgf_bs_read_int(bs, 2);\n\t\t\t}\n\t\t\t*total_bytes += 3;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureLayoutMapEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->groupID_info_4cc = gf_bs_read_u32(bs);\n\t\tptr->nb_entries = 1 + gf_bs_read_u16(bs);\n\t\t*total_bytes = 6;\n\t\tptr->groupIDs = gf_malloc(sizeof(u16) * ptr->nb_entries);\n\t\tif (!ptr->groupIDs) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tptr->groupIDs[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\treturn ptr;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!entry_size && !null_size_ok) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\\n\", gf_4cc_to_str( grouping_type) ));\n\t\treturn NULL;\n\t}\n\tGF_SAFEALLOC(def_ptr, GF_DefaultSampleGroupDescriptionEntry);\n\tif (!def_ptr) return NULL;\n\tif (entry_size) {\n\t\tdef_ptr->length = entry_size;\n\t\tdef_ptr->data = (u8 *) gf_malloc(sizeof(u8)*def_ptr->length);\n\t\tif (!def_ptr->data) {\n\t\t\tgf_free(def_ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tgf_bs_read_data(bs, (char *) def_ptr->data, def_ptr->length);\n\t\t*total_bytes = entry_size;\n\t}\n\treturn def_ptr;\n}\n\nvoid sgpd_del_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_free(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tif (seig->key_info) gf_free(seig->key_info);\n\t\tgf_free(entry);\n\t}\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_del_entry(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_del_entry(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *)entry;\n\t\tif (spor->subp_track_ref_idx) gf_free(spor->subp_track_ref_idx);\n\t\tgf_free(spor);\n\t}\n\t\treturn;\n\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\tif (sulm->groupIDs) gf_free(sulm->groupIDs);\n\t\tgf_free(sulm);\n\t\treturn;\n\t}\n\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->data) gf_free(ptr->data);\n\t\tgf_free(ptr);\n\t}\n\t}\n}\n\nvoid sgpd_write_entry(u32 grouping_type, void *entry, GF_BitStream *bs)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\tgf_bs_write_int(bs, ((GF_RollRecoveryEntry*)entry)->roll_distance, 16);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known, 1);\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->dependent_flag, 1);\n\t\tgf_bs_write_int(bs, 0, 3);\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->SAP_type, 4);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\tgf_bs_write_int(bs, 0, 2);\n\t\tgf_bs_write_int(bs, ((GF_SYNCEntry*)entry)->NALU_type, 6);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\tgf_bs_write_int(bs, ((GF_TemporalLevelEntry*)entry)->level_independently_decodable, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tBool use_mkey = seig->key_info[0];\n\t\tu32 nb_keys = 1;\n\t\tif (use_mkey) {\n\t\t\tnb_keys = seig->key_info[1];\n\t\t\tnb_keys<<=8;\n\t\t\tnb_keys |= seig->key_info[2];\n\t\t}\n\t\tgf_bs_write_int(bs, use_mkey ? 1 : 0, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, seig->crypt_byte_block, 4);\n\t\tgf_bs_write_int(bs, seig->skip_byte_block, 4);\n\t\tgf_bs_write_u8(bs, seig->IsProtected);\n\t\tif (nb_keys>1) {\n\t\t\tgf_bs_write_data(bs, seig->key_info+1, seig->key_info_size-1);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, seig->key_info+3, seig->key_info_size - 3);\n\t\t}\n\t}\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_write_entry(entry, bs);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_write_entry(entry, bs);\n\t\treturn;\n\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *) entry;\n\t\tgf_bs_write_int(bs, spor->subpic_id_info_flag, 1);\n\t\tgf_bs_write_int(bs, spor->num_subpic_ref_idx, 15);\n\t\tfor (i=0; i<spor->num_subpic_ref_idx; i++) {\n\t\t\tgf_bs_write_u16(bs, spor->subp_track_ref_idx[i]);\n\t\t}\n\t\tif (spor->subpic_id_info_flag) {\n\t\t\tgf_bs_write_int(bs, spor->spinfo.subpic_id_len_minus1, 4);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.subpic_id_bit_pos, 12);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.start_code_emul_flag, 1);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.pps_sps_subpic_id_flag, 1);\n\t\t\tif (spor->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tgf_bs_write_int(bs, spor->spinfo.xps_id, 6);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, spor->spinfo.xps_id, 4);\n\t\t\t\tgf_bs_write_int(bs, 0, 2);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\tgf_bs_write_u32(bs, sulm->groupID_info_4cc);\n\t\tgf_bs_write_u16(bs, sulm->nb_entries - 1);\n\t\tfor (i=0; i<sulm->nb_entries; i++) {\n\t\t\tgf_bs_write_u16(bs, sulm->groupIDs[i]);\n\t\t}\n\t\treturn;\n\t}\n\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->length)\n\t\t\tgf_bs_write_data(bs, (char *) ptr->data, ptr->length);\n\t}\n\t}\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nstatic u32 sgpd_size_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\treturn 1;\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\treturn 20;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\treturn 0;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tBool use_mkey = seig->key_info[0] ? GF_TRUE : GF_FALSE;\n\t\tif (use_mkey) {\n\t\t\treturn 3 + seig->key_info_size-1;\n\t\t}\n\t\treturn seig->key_info_size; //== 3 + (seig->key_info_size-3);\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\treturn gf_isom_oinf_size_entry(entry);\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\treturn gf_isom_linf_size_entry(entry);\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *)entry;\n\t\tu32 s = 2 + 2*spor->num_subpic_ref_idx;\n\t\tif (spor->subpic_id_info_flag) {\n\t\t\ts += 3;\n\t\t}\n\t\treturn s;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\treturn 6 + 2*sulm->nb_entries;\n\t}\n\n\tdefault:\n\t\treturn ((GF_DefaultSampleGroupDescriptionEntry *)entry)->length;\n\t}\n}\n#endif\n\nGF_Box *sgpd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupDescriptionBox, GF_ISOM_BOX_TYPE_SGPD);\n\t/*version 0 is deprecated, use v1 by default*/\n\ttmp->version = 1;\n\ttmp->group_descriptions = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid sgpd_box_del(GF_Box *a)\n{\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)a;\n\twhile (gf_list_count(p->group_descriptions)) {\n\t\tvoid *ptr = gf_list_last(p->group_descriptions);\n\t\tsgpd_del_entry(p->grouping_type, ptr);\n\t\tgf_list_rem_last(p->group_descriptions);\n\t}\n\tgf_list_del(p->group_descriptions);\n\tgf_free(p);\n}\n\nGF_Err sgpd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry_count;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tISOM_DECREASE_SIZE(p, 8);\n\tp->grouping_type = gf_bs_read_u32(bs);\n\n\tif (p->version>=1) {\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t\tp->default_length = gf_bs_read_u32(bs);\n\t}\n\tif (p->version>=2) {\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t\tp->default_description_index = gf_bs_read_u32(bs);\n\t}\n\tentry_count = gf_bs_read_u32(bs);\n\n\tif (entry_count>p->size)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\twhile (entry_count) {\n\t\tvoid *ptr;\n\t\tu32 parsed_bytes=0;\n\t\tu32 size = p->default_length;\n\t\tif ((p->version>=1) && !size) {\n\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(p, 4);\n\t\t}\n\t\tptr = sgpd_parse_entry(p->grouping_type, bs, (s32) p->size, size, &parsed_bytes);\n\t\t//don't return an error, just stop parsing so that we skip over the sgpd box\n\t\tif (!ptr) return GF_OK;\n\t\tgf_list_add(p->group_descriptions, ptr);\n\n\t\tISOM_DECREASE_SIZE(p, parsed_bytes);\n\t\tentry_count--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sgpd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, nb_descs;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\tGF_Err e;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version>=1) gf_bs_write_u32(bs, p->default_length);\n\tif (p->version>=2) gf_bs_write_u32(bs, p->default_description_index);\n\tnb_descs = gf_list_count(p->group_descriptions);\n\tgf_bs_write_u32(bs, nb_descs);\n\n\tfor (i=0; i<nb_descs; i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tif ((p->version >= 1) && !p->default_length) {\n\t\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\t\tgf_bs_write_u32(bs, size);\n\t\t}\n\t\tsgpd_write_entry(p->grouping_type, ptr, bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sgpd_box_size(GF_Box *s)\n{\n\tu32 i, nb_descs;\n\tBool use_def_size = GF_TRUE;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tp->size += 8;\n\n\t//we force all sample groups to version 1, v0 being deprecated\n\tif (!p->version)\n\t\tp->version = 1;\n\tp->size += 4;\n\n\tif (p->version>=2)\n\t\tp->size += 4;\n\tp->default_length = 0;\n\n\tnb_descs = gf_list_count(p->group_descriptions);\n\tfor (i=0; i<nb_descs; i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\tp->size += size;\n\t\tif (use_def_size && !p->default_length) {\n\t\t\tp->default_length = size;\n\t\t} else if (p->default_length != size) {\n\t\t\tuse_def_size = GF_FALSE;\n\t\t\tp->default_length = 0;\n\t\t}\n\t}\n\tif (p->version>=1) {\n\t\tif (!p->default_length) p->size += nb_descs * 4;\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid saiz_box_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info_size) gf_free(ptr->sample_info_size);\n\tgf_free(ptr);\n}\n\n\nGF_Err saiz_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 5);\n\tptr->default_sample_info_size = gf_bs_read_u8(bs);\n\tptr->sample_count = gf_bs_read_u32(bs);\n\n\tif (ptr->default_sample_info_size == 0) {\n\t\tif (ptr->size < ptr->sample_count)\n\t\t    return GF_ISOM_INVALID_FILE;\n\n\t\tptr->sample_info_size = gf_malloc(sizeof(u8)*ptr->sample_count);\n\t\tptr->sample_alloc = ptr->sample_count;\n\t\tif (!ptr->sample_info_size)\n\t\t    return GF_OUT_OF_MEM;\n\n\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count);\n\t\tgf_bs_read_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saiz_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoSizeBox, GF_ISOM_BOX_TYPE_SAIZ);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saiz_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\tgf_bs_write_u8(bs, ptr->default_sample_info_size);\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\tif (!ptr->default_sample_info_size) {\n\t\tif (!ptr->sample_info_size)\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\telse\n\t\t\tgf_bs_write_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saiz_box_size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox *ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 5;\n\tif (ptr->default_sample_info_size==0)  ptr->size += ptr->sample_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nvoid saio_box_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tif (ptr->cached_data) gf_free(ptr->cached_data);\n\tgf_free(ptr);\n}\n\n\nGF_Err saio_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *)s;\n\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->entry_count = gf_bs_read_u32(bs);\n\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\tif (ptr->size / (ptr->version == 0 ? 4 : 8) < ptr->entry_count || (u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(u64))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tptr->offsets = gf_malloc(sizeof(u64)*ptr->entry_count);\n\t\tif (!ptr->offsets)\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tptr->entry_alloc = ptr->entry_count;\n\t\tif (ptr->version==0) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets[i] = gf_bs_read_u32(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets[i] = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saio_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoOffsetBox, GF_ISOM_BOX_TYPE_SAIO);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saio_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\n\n\tgf_bs_write_u32(bs, ptr->entry_count);\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\tif (ptr->sai_data) {\n\t\t\tif (ptr->sai_data->sai_offset) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) ptr->sai_data->sai_offset);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_u64(bs, ptr->sai_data->sai_offset);\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tptr->sai_data->saio_box = ptr;\n\t\t}\n\n\t\t//store position in bitstream before writing data - offsets can be NULL if a single offset is rewritten later on (cf senc_box_write)\n\t\tptr->offset_first_offset_field = gf_bs_get_position(bs);\n\t\tif (ptr->version==0) {\n\t\t\tif (!ptr->offsets) {\n\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) ptr->offsets[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ptr->offsets) {\n\t\t\t\tgf_bs_write_u64(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u64(bs, ptr->offsets[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saio_box_size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 4;\n\t//a little optim here: in cenc, the saio always points to a single data block, only one entry is needed\n\tswitch (ptr->aux_info_type) {\n\tcase GF_ISOM_CENC_SCHEME:\n\tcase GF_ISOM_CBC_SCHEME:\n\tcase GF_ISOM_CENS_SCHEME:\n\tcase GF_ISOM_CBCS_SCHEME:\n\t\tif (ptr->offsets) gf_free(ptr->offsets);\n\t\tptr->offsets = NULL;\n\t\tptr->entry_alloc = 0;\n\t\tptr->entry_count = 1;\n\t\tbreak;\n\t}\n\n\tptr->size += ((ptr->version==1) ? 8 : 4) * ptr->entry_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nvoid prft_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err prft_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tptr->refTrackID = gf_bs_read_u32(bs);\n\tptr->ntp = gf_bs_read_u64(bs);\n\tif (ptr->version==0) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->timestamp = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->timestamp = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *prft_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProducerReferenceTimeBox, GF_ISOM_BOX_TYPE_PRFT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err prft_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->refTrackID);\n\tgf_bs_write_u64(bs, ptr->ntp);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->timestamp);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->timestamp);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err prft_box_size(GF_Box *s)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox*)s;\n\n\tptr->size += 4+8+ (ptr->version ? 8 : 4);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *trgr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupBox, GF_ISOM_BOX_TYPE_TRGR);\n\ttmp->groups = gf_list_new();\n\tif (!tmp->groups) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgr_box_del(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->groups);\n\tgf_free(ptr);\n}\n\n\nGF_Err trgr_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\n\tBOX_FIELD_LIST_ASSIGN(groups)\n\treturn gf_list_add(ptr->groups, a);\n}\n\n\nGF_Err trgr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trgr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err trgr_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *) s;\n\tgf_isom_check_position_list(s, ptr->groups, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *trgt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgt_box_del(GF_Box *s)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err trgt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->track_group_id = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trgt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->group_type == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\ts->type = ptr->group_type;\n\te = gf_isom_full_box_write(s, bs);\n\ts->type = GF_ISOM_BOX_TYPE_TRGT;\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->track_group_id);\n\treturn GF_OK;\n}\n\nGF_Err trgt_box_size(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\n\tptr->size+= 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *stvi_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_StereoVideoBox, GF_ISOM_BOX_TYPE_STVI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid stvi_box_del(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->stereo_indication_type) gf_free(ptr->stereo_indication_type);\n\tgf_free(ptr);\n}\n\nGF_Err stvi_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tgf_bs_read_int(bs, 30);\n\tptr->single_view_allowed = gf_bs_read_int(bs, 2);\n\tptr->stereo_scheme = gf_bs_read_u32(bs);\n\tptr->sit_len = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, ptr->sit_len);\n\n\tptr->stereo_indication_type = gf_malloc(sizeof(char)*ptr->sit_len);\n\tif (!ptr->stereo_indication_type) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stvi_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, 0, 30);\n\tgf_bs_write_int(bs, ptr->single_view_allowed, 2);\n\tgf_bs_write_u32(bs, ptr->stereo_scheme);\n\tgf_bs_write_u32(bs, ptr->sit_len);\n\tgf_bs_write_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\n\treturn GF_OK;\n}\n\nGF_Err stvi_box_size(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tptr->size+= 12 + ptr->sit_len;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fiin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDItemInformationBox, GF_ISOM_BOX_TYPE_FIIN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fiin_box_del(GF_Box *s)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->partition_entries) gf_list_del(ptr->partition_entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err fiin_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_PAEN:\n\t\tBOX_FIELD_LIST_ASSIGN(partition_entries)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SEGR:\n\t\tBOX_FIELD_ASSIGN(session_info, FDSessionGroupBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_GITN:\n\t\tBOX_FIELD_ASSIGN(group_id_to_name, GroupIdToNameBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fiin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_u16(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fiin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, gf_list_count(ptr->partition_entries) );\n\treturn GF_OK;\n}\n\nGF_Err fiin_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\ts->size+= 2;\n\tgf_isom_check_position_list(s, ptr->partition_entries, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *paen_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDPartitionEntryBox, GF_ISOM_BOX_TYPE_PAEN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid paen_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err paen_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FPAR:\n\t\tBOX_FIELD_ASSIGN(blocks_and_symbols, FilePartitionBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FECR:\n\t\tBOX_FIELD_ASSIGN(FEC_symbol_locations, FECReservoirBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FIRE:\n\t\tBOX_FIELD_ASSIGN(File_symbol_locations, FileReservoirBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err paen_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err paen_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tif (!s) return GF_BAD_PARAM;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err paen_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *fpar_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FilePartitionBox, GF_ISOM_BOX_TYPE_FPAR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fpar_box_del(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->scheme_specific_info) gf_free(ptr->scheme_specific_info);\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err gf_isom_read_null_terminated_string(GF_Box *s, GF_BitStream *bs, u64 size, char **out_str)\n{\n\tu32 len=10;\n\tu32 i=0;\n\n\t*out_str = gf_malloc(sizeof(char)*len);\n\tif (! *out_str) return GF_OUT_OF_MEM;\n\n\tif (!s->size) {\n\t\t*out_str[0] = 0;\n\t\treturn GF_OK;\n\t}\n\n\twhile (1) {\n\t\tISOM_DECREASE_SIZE(s, 1 );\n\t\t(*out_str)[i] = gf_bs_read_u8(bs);\n\t\tif (!(*out_str)[i]) break;\n\t\ti++;\n\t\tif (i==len) {\n\t\t\tlen += 10;\n\t\t\t*out_str = gf_realloc(*out_str, sizeof(char)*len);\n\t\t}\n\t\tif (gf_bs_available(bs) == 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] missing null character in null terminated string\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (i >= size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] string bigger than container, probably missing null character\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, ((ptr->version ? 4 : 2) + 12) );\n\tptr->itemID = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tptr->packet_payload_size = gf_bs_read_u16(bs);\n\tgf_bs_read_u8(bs);\n\tptr->FEC_encoding_ID = gf_bs_read_u8(bs);\n\tptr->FEC_instance_ID = gf_bs_read_u16(bs);\n\tptr->max_source_block_length = gf_bs_read_u16(bs);\n\tptr->encoding_symbol_length = gf_bs_read_u16(bs);\n\tptr->max_number_of_encoding_symbols = gf_bs_read_u16(bs);\n\n\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_specific_info);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tif (ptr->nb_entries > ptr->size / 6 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(FilePartitionEntry))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * 6 );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FilePartitionEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].block_count = gf_bs_read_u16(bs);\n\t\tptr->entries[i].block_size = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fpar_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFilePartitionBox *ptr = (FilePartitionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->itemID, ptr->version ? 32 : 16);\n\tgf_bs_write_u16(bs, ptr->packet_payload_size);\n\tgf_bs_write_u8(bs, 0);\n\tgf_bs_write_u8(bs, ptr->FEC_encoding_ID);\n\tgf_bs_write_u16(bs, ptr->FEC_instance_ID);\n\tgf_bs_write_u16(bs, ptr->max_source_block_length);\n\tgf_bs_write_u16(bs, ptr->encoding_symbol_length);\n\tgf_bs_write_u16(bs, ptr->max_number_of_encoding_symbols);\n\tif (ptr->scheme_specific_info) {\n\t\tgf_bs_write_data(bs, ptr->scheme_specific_info, (u32)strlen(ptr->scheme_specific_info) );\n\t}\n\t//null terminated string\n\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->entries[i].block_count);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].block_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_box_size(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tptr->size += 13 + (ptr->version ? 8 : 4);\n\tif (ptr->scheme_specific_info)\n\t\tptr->size += strlen(ptr->scheme_specific_info);\n\n\tptr->size+= ptr->nb_entries * 6;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *fecr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FECReservoirBox, GF_ISOM_BOX_TYPE_FECR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fecr_box_del(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err fecr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\n\tif (ptr->nb_entries > ptr->size / (ptr->version ? 8 : 6) || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(FECReservoirEntry) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in fecr\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * (ptr->version ? 8 : 6) );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FECReservoirEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].item_id = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\t\tptr->entries[i].symbol_count = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fecr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].item_id, ptr->version ? 32 : 16);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].symbol_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fecr_box_size(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tptr->size += (ptr->version ? 4 : 2) +  ptr->nb_entries * (ptr->version ? 8 : 6);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *segr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid segr_box_del(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tif (ptr->session_groups[i].group_ids) gf_free(ptr->session_groups[i].group_ids);\n\t\tif (ptr->session_groups[i].channels) gf_free(ptr->session_groups[i].channels);\n\t}\n\tif (ptr->session_groups) gf_free(ptr->session_groups);\n\tgf_free(ptr);\n}\n\nGF_Err segr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->num_session_groups = gf_bs_read_u16(bs);\n\tif (ptr->size < ptr->num_session_groups) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in segr\\n\", ptr->num_session_groups));\n\t\tptr->num_session_groups = 0;\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->session_groups, ptr->num_session_groups, SessionGroupEntry);\n\tif (!ptr->session_groups) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->session_groups[i].nb_groups = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\n\t\tISOM_DECREASE_SIZE(ptr, ptr->session_groups[i].nb_groups*4);\n\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].group_ids, ptr->session_groups[i].nb_groups, u32);\n\t\tif (!ptr->session_groups[i].group_ids) return GF_OUT_OF_MEM;\n\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tptr->session_groups[i].group_ids[k] = gf_bs_read_u32(bs);\n\t\t}\n\n\t\tptr->session_groups[i].nb_channels = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->session_groups[i].nb_channels*4);\n\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].channels, ptr->session_groups[i].nb_channels, u32);\n\t\tif (!ptr->session_groups[i].channels) return GF_OUT_OF_MEM;\n\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tptr->session_groups[i].channels[k] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err segr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tGF_Err e;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->num_session_groups);\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tgf_bs_write_u8(bs, ptr->session_groups[i].nb_groups);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].group_ids[k]);\n\t\t}\n\n\t\tgf_bs_write_u16(bs, ptr->session_groups[i].nb_channels);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].channels[k]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err segr_box_size(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->size += 1 + 4*ptr->session_groups[i].nb_groups;\n\t\tptr->size += 2 + 4*ptr->session_groups[i].nb_channels;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *gitn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GroupIdToNameBox, GF_ISOM_BOX_TYPE_GITN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) {\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t\t}\n\t\tgf_free(ptr->entries);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err gitn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->nb_entries = gf_bs_read_u16(bs);\n\tif (ptr->size / 4 < ptr->nb_entries)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, GroupIdNameEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->entries[i].group_id = gf_bs_read_u32(bs);\n\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->entries[i].name);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gitn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].group_id);\n\t\tif (ptr->entries[i].name) gf_bs_write_data(bs, ptr->entries[i].name, (u32)strlen(ptr->entries[i].name) );\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gitn_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->entries[i].name) ptr->size += strlen(ptr->entries[i].name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nGF_Box *fdpa_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FDpacketBox, GF_ISOM_BOX_TYPE_FDPA);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fdpa_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->headers) {\n\t\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\t\tif (ptr->headers[i].data) gf_free(ptr->headers[i].data);\n\t\t}\n\t\tgf_free(ptr->headers);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err fdpa_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tptr->info.sender_current_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.expected_residual_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.session_close_bit = gf_bs_read_int(bs, 1);\n\tptr->info.object_close_bit = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 4);\n\tptr->info.transport_object_identifier = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->header_ext_count = gf_bs_read_u16(bs);\n\tif (ptr->size / 2 < ptr->header_ext_count) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in fdpa\\n\", ptr->header_ext_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->headers, ptr->header_ext_count, GF_LCTheaderExtension);\n\tif (!ptr->headers) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->headers[i].header_extension_type = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 3);\n\t\t\tgf_bs_read_data(bs, (char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\t\tptr->headers[i].data_length = gf_bs_read_u8(bs);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tptr->headers[i].data_length = 4*ptr->headers[i].data_length - 2;\n\t\t\t\tif (ptr->size < sizeof(char) * ptr->headers[i].data_length)\n\t\t\t\t    return GF_ISOM_INVALID_FILE;\n\t\t\t\tptr->headers[i].data = gf_malloc(sizeof(char) * ptr->headers[i].data_length);\n\t\t\t\tif (!ptr->headers[i].data) return GF_OUT_OF_MEM;\n\n\t\t\t\tISOM_DECREASE_SIZE(ptr, ptr->headers[i].data_length);\n\t\t\t\tgf_bs_read_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdpa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->info.sender_current_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.expected_residual_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.session_close_bit, 1);\n\tgf_bs_write_int(bs, ptr->info.object_close_bit, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_u16(bs, ptr->info.transport_object_identifier);\n\tgf_bs_write_u16(bs, ptr->header_ext_count);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tgf_bs_write_u8(bs, ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_write_data(bs, (const char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, ptr->headers[i].data_length ? (ptr->headers[i].data_length+2)/4 : 0);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tgf_bs_write_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdpa_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tptr->size += 5;\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->size += 1;\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tptr->size += 3;\n\t\t} else {\n\t\t\tptr->size += 1 + ptr->headers[i].data_length;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *extr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ExtraDataBox, GF_ISOM_BOX_TYPE_EXTR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid extr_box_del(GF_Box *s)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->feci) gf_isom_box_del((GF_Box*)ptr->feci);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err extr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\n\te = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);\n\tif (e) return e;\n\tif (!ptr->feci || ptr->feci->size > ptr->size) return GF_ISOM_INVALID_MEDIA;\n\tptr->data_length = (u32) (ptr->size - ptr->feci->size);\n\tptr->data = gf_malloc(sizeof(char)*ptr->data_length);\n\tif (!ptr->data) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->data, ptr->data_length);\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err extr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tif (ptr->feci) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->feci, bs);\n\t\tif (e) return e;\n\t}\n\tgf_bs_write_data(bs, ptr->data, ptr->data_length);\n\treturn GF_OK;\n}\n\nGF_Err extr_box_size(GF_Box *s)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\tptr->size += ptr->data_length;\n\tif (ptr->feci) {\n\t\tGF_Err e = gf_isom_box_size((GF_Box*)ptr->feci);\n\t\tif (e) return e;\n\t\tptr->size += ptr->feci->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fdsa_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintSample, GF_ISOM_BOX_TYPE_FDSA);\n\tif (!tmp) return NULL;\n\ttmp->packetTable = gf_list_new();\n\ttmp->hint_subtype = GF_ISOM_BOX_TYPE_FDP_STSD;\n\treturn (GF_Box*)tmp;\n}\n\nvoid fdsa_box_del(GF_Box *s)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tgf_list_del(ptr->packetTable);\n\tgf_free(ptr);\n}\n\nGF_Err fdsa_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FDPA:\n\t\tBOX_FIELD_LIST_ASSIGN(packetTable)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_EXTR:\n\t\tBOX_FIELD_ASSIGN(extra_data, GF_ExtraDataBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\nGF_Err fdsa_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdsa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintSample *ptr = (GF_HintSample *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\te = gf_isom_box_array_write(s, ptr->packetTable, bs);\n\tif (e) return e;\n\tif (ptr->extra_data) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->extra_data, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdsa_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n\nvoid trik_box_del(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err trik_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->entry_count = (u32) ptr->size;\n\tif ((u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(GF_TrickPlayBoxEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in trik\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->entries = (GF_TrickPlayBoxEntry *) gf_malloc(ptr->entry_count * sizeof(GF_TrickPlayBoxEntry) );\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i< ptr->entry_count; i++) {\n\t\tptr->entries[i].pic_type = gf_bs_read_int(bs, 2);\n\t\tptr->entries[i].dependency_level = gf_bs_read_int(bs, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trik_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrickPlayBox, GF_ISOM_BOX_TYPE_TRIK);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trik_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i=0; i < ptr->entry_count; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].pic_type, 2);\n\t\tgf_bs_write_int(bs, ptr->entries[i].dependency_level, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err trik_box_size(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->size += 8 * ptr->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid bloc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err bloc_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->baseLocation, 256);\n\tptr->baseLocation[256]=0;\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->basePurlLocation, 256);\n\tISOM_DECREASE_SIZE(s, 512)\n\tptr->basePurlLocation[256]=0;\n\tgf_bs_skip_bytes(bs, 512);\n\treturn GF_OK;\n}\n\nGF_Box *bloc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_BaseLocationBox, GF_ISOM_BOX_TYPE_BLOC);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err bloc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (const char *) ptr->baseLocation, 256);\n\tgf_bs_write_data(bs, (const char *) ptr->basePurlLocation, 256);\n\tfor (i=0; i < 64; i++ ) {\n\t\tgf_bs_write_u64(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err bloc_box_size(GF_Box *s)\n{\n\ts->size += 1024;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ainf_box_del(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\tif (ptr->APID) gf_free(ptr->APID);\n\tgf_free(s);\n}\n\nGF_Err ainf_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 4)\n\tptr->profile_version = gf_bs_read_u32(bs);\n\treturn gf_isom_read_null_terminated_string(s, bs, s->size, &ptr->APID);\n}\n\nGF_Box *ainf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AssetInformationBox, GF_ISOM_BOX_TYPE_AINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ainf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->profile_version);\n    if (ptr->APID)\n        gf_bs_write_data(bs, ptr->APID, (u32) strlen(ptr->APID) );\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err ainf_box_size(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n    s->size += 4 + (ptr->APID ? strlen(ptr->APID) : 0 ) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mhac_box_del(GF_Box *s)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\tif (ptr->mha_config) gf_free(ptr->mha_config);\n\tgf_free(s);\n}\n\nGF_Err mhac_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 5)\n\tptr->configuration_version = gf_bs_read_u8(bs);\n\tptr->mha_pl_indication = gf_bs_read_u8(bs);\n\tptr->reference_channel_layout = gf_bs_read_u8(bs);\n\tptr->mha_config_size = gf_bs_read_u16(bs);\n\tif (ptr->mha_config_size) {\n\t\tISOM_DECREASE_SIZE(s, ptr->mha_config_size)\n\n\t\tptr->mha_config = gf_malloc(sizeof(char)*ptr->mha_config_size);\n\t\tif (!ptr->mha_config) return GF_OUT_OF_MEM;\n\n\t\tgf_bs_read_data(bs, ptr->mha_config, ptr->mha_config_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mhac_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MHAConfigBox, GF_ISOM_BOX_TYPE_MHAC);\n\ttmp->configuration_version = 1;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mhac_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->configuration_version);\n\tgf_bs_write_u8(bs, ptr->mha_pl_indication);\n\tgf_bs_write_u8(bs, ptr->reference_channel_layout);\n\tgf_bs_write_u16(bs, ptr->mha_config ? ptr->mha_config_size : 0);\n\tif (ptr->mha_config && ptr->mha_config_size)\n\t\tgf_bs_write_data(bs, ptr->mha_config, ptr->mha_config_size);\n\n\treturn GF_OK;\n}\n\nGF_Err mhac_box_size(GF_Box *s)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\ts->size += 5;\n\tif (ptr->mha_config_size && ptr->mha_config) s->size += ptr->mha_config_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mhap_box_del(GF_Box *s)\n{\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\tif (ptr->compat_profiles) gf_free(ptr->compat_profiles);\n\tgf_free(s);\n}\n\nGF_Err mhap_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->num_profiles = gf_bs_read_u8(bs);\n\tif (!ptr->num_profiles) return GF_OK;\n\n\tISOM_DECREASE_SIZE(s, ptr->num_profiles)\n\tptr->compat_profiles = gf_malloc(sizeof(u8) * ptr->num_profiles);\n\tif (!ptr->compat_profiles) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->num_profiles; i++) {\n\t\tptr->compat_profiles[i] = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mhap_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MHACompatibleProfilesBox, GF_ISOM_BOX_TYPE_MHAP);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mhap_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->num_profiles);\n\tfor (i=0; i<ptr->num_profiles; i++) {\n\t\tgf_bs_write_u8(bs, ptr->compat_profiles[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mhap_box_size(GF_Box *s)\n{\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\ts->size += 1 + ptr->num_profiles;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid jp2h_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err jp2h_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_J2KHeaderBox *ptr = (GF_J2KHeaderBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_IHDR:\n\t\tBOX_FIELD_ASSIGN(ihdr, GF_J2KImageHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_COLR:\n\t\tBOX_FIELD_ASSIGN(colr, GF_ColourInformationBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\nGF_Err jp2h_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *jp2h_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_J2KHeaderBox, GF_ISOM_BOX_TYPE_JP2H);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err jp2h_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err jp2h_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid ihdr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err ihdr_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_J2KImageHeaderBox *ptr = (GF_J2KImageHeaderBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 14)\n\n\tptr->height = gf_bs_read_u32(bs);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->nb_comp = gf_bs_read_u16(bs);\n\tptr->bpc = gf_bs_read_u8(bs);\n\tptr->Comp = gf_bs_read_u8(bs);\n\tptr->UnkC = gf_bs_read_u8(bs);\n\tptr->IPR = gf_bs_read_u8(bs);\n\n\treturn GF_OK;\n}\n\nGF_Box *ihdr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_J2KImageHeaderBox, GF_ISOM_BOX_TYPE_IHDR);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ihdr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_J2KImageHeaderBox *ptr = (GF_J2KImageHeaderBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->height);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u16(bs, ptr->nb_comp);\n\tgf_bs_write_u8(bs, ptr->bpc);\n\tgf_bs_write_u8(bs, ptr->Comp);\n\tgf_bs_write_u8(bs, ptr->UnkC);\n\tgf_bs_write_u8(bs, ptr->IPR);\n\treturn GF_OK;\n}\n\nGF_Err ihdr_box_size(GF_Box *s)\n{\n\ts->size += 14;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* Dolby Vision */\n\nGF_Box *dvcC_box_new()\n{\n\tGF_DOVIConfigurationBox *tmp = (GF_DOVIConfigurationBox *)gf_malloc(sizeof(GF_DOVIConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_DOVIConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_DVCC;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dvcC_box_del(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err dvcC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *)s;\n\n\t//GF_DOVIDecoderConfigurationRecord\n\tISOM_DECREASE_SIZE(ptr, 24)\n\tptr->DOVIConfig.dv_version_major = gf_bs_read_u8(bs);\n\tptr->DOVIConfig.dv_version_minor = gf_bs_read_u8(bs);\n\tptr->DOVIConfig.dv_profile = gf_bs_read_int(bs, 7);\n\tptr->DOVIConfig.dv_level = gf_bs_read_int(bs, 6);\n\tptr->DOVIConfig.rpu_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.el_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.bl_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.dv_bl_signal_compatibility_id = gf_bs_read_int(bs, 4);\n\tif (gf_bs_read_int(bs, 28) != 0)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC reserved bits are not zero\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (gf_bs_read_u32(bs) != 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC reserved bits are not zero\\n\"));\n\t\t}\n\t}\n\tswitch (ptr->DOVIConfig.dv_bl_signal_compatibility_id) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 6:\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC compatibility ID %d is not valid (only 0, 1, 2, 4 or 6 defined), patching to 0\\n\", ptr->DOVIConfig.dv_bl_signal_compatibility_id));\n\t\tptr->DOVIConfig.dv_bl_signal_compatibility_id = 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dvcC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t//GF_DOVIDecoderConfigurationRecord\n\tgf_bs_write_u8(bs,  ptr->DOVIConfig.dv_version_major);\n\tgf_bs_write_u8(bs,  ptr->DOVIConfig.dv_version_minor);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_profile, 7);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_level, 6);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.rpu_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.el_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.bl_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_bl_signal_compatibility_id, 4);\n\tgf_bs_write_int(bs, 0, 28);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\n\treturn GF_OK;\n}\n\nGF_Err dvcC_box_size(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *)s;\n\n\tptr->size += 24;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dvvC_box_new()\n{\n\tGF_DOVIConfigurationBox *tmp = (GF_DOVIConfigurationBox *)gf_malloc(sizeof(GF_DOVIConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_DOVIConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_DVVC;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dvvC_box_del(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err dvvC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn dvcC_box_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dvvC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn dvcC_box_write(s, bs);\n}\n\nGF_Err dvvC_box_size(GF_Box *s)\n{\n\treturn dvcC_box_size(s);\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *dOps_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OpusSpecificBox, GF_ISOM_BOX_TYPE_DOPS);\n\treturn (GF_Box *)tmp;\n}\n\nvoid dOps_box_del(GF_Box *s)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (ptr) gf_free(ptr);\n}\n\n//we don't use odf_opus_cfg read due to endianness\nGF_Err dOps_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tptr->opcfg.version = gf_bs_read_u8(bs);\n\tif (ptr->opcfg.version) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Opus config version not 0 !\\n\", ptr->size));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\t//force version to 1 as used in ogg/opus\n\tptr->opcfg.version = 1;\n\tptr->opcfg.OutputChannelCount = gf_bs_read_u8(bs);\n\tptr->opcfg.PreSkip = gf_bs_read_u16(bs);\n\tptr->opcfg.InputSampleRate = gf_bs_read_u32(bs);\n\tptr->opcfg.OutputGain = gf_bs_read_u16(bs);\n\tptr->opcfg.ChannelMappingFamily = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, 11)\n\tif (ptr->size) {\n\t\tISOM_DECREASE_SIZE(ptr, 2+ptr->opcfg.OutputChannelCount);\n\t\tptr->opcfg.StreamCount = gf_bs_read_u8(bs);\n\t\tptr->opcfg.CoupledCount = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *) ptr->opcfg.ChannelMapping, ptr->opcfg.OutputChannelCount);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n//we don't use odf_opus_cfg write due to endianness\nGF_Err dOps_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//we always write 0 - the version may also be set to 1 when fed from ffenc or opus+ogg\n\tgf_bs_write_u8(bs, /*ptr->opcfg.version*/ 0);\n\tgf_bs_write_u8(bs, ptr->opcfg.OutputChannelCount);\n\tgf_bs_write_u16(bs, ptr->opcfg.PreSkip);\n\tgf_bs_write_u32(bs, ptr->opcfg.InputSampleRate);\n\tgf_bs_write_u16(bs, ptr->opcfg.OutputGain);\n\tgf_bs_write_u8(bs, ptr->opcfg.ChannelMappingFamily);\n\tif (ptr->opcfg.ChannelMappingFamily) {\n\t\tgf_bs_write_u8(bs, ptr->opcfg.StreamCount);\n\t\tgf_bs_write_u8(bs, ptr->opcfg.CoupledCount);\n\t\tgf_bs_write_data(bs, (char *) ptr->opcfg.ChannelMapping, ptr->opcfg.OutputChannelCount);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dOps_box_size(GF_Box *s)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tptr->size += 11;\n\tif (ptr->opcfg.ChannelMappingFamily)\n\t\tptr->size += 2 + ptr->opcfg.OutputChannelCount;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid dfla_box_del(GF_Box *s)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err dfla_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->dataSize = (u32) ptr->size;\n\tptr->size=0;\n\tptr->data = gf_malloc(ptr->dataSize);\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Box *dfla_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FLACConfigBox, GF_ISOM_BOX_TYPE_DFLA);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dfla_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Err dfla_box_size(GF_Box *s)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid mvcg_box_del(GF_Box *s)\n{\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err mvcg_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tISOM_DECREASE_SIZE(s, 7)\n\tptr->multiview_group_id = gf_bs_read_u32(bs);\n\tptr->num_entries = gf_bs_read_u16(bs);\n\tgf_bs_read_u8(bs);\n\tptr->entries = gf_malloc(ptr->num_entries * sizeof(MVCIEntry));\n\tmemset(ptr->entries, 0, ptr->num_entries * sizeof(MVCIEntry));\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->entries[i].entry_type = gf_bs_read_u8(bs);\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tISOM_DECREASE_SIZE(s, 4)\n\t\t\tptr->entries[i].trackID = gf_bs_read_u32(bs);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tISOM_DECREASE_SIZE(s, 6)\n\t\t\tptr->entries[i].trackID = gf_bs_read_u32(bs);\n\t\t\tptr->entries[i].tierID = gf_bs_read_u16(bs);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tptr->entries[i].output_view_id = gf_bs_read_int(bs, 10);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tISOM_DECREASE_SIZE(s, 4)\n\t\t\tgf_bs_read_int(bs, 6)\t;\n\t\t\tptr->entries[i].start_view_id = gf_bs_read_int(bs, 10);\n\t\t\tptr->entries[i].view_count = gf_bs_read_u16(bs);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mvcg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MultiviewGroupBox, GF_ISOM_BOX_TYPE_MVCG);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mvcg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\n\tgf_bs_write_u32(bs, ptr->multiview_group_id);\n\tgf_bs_write_u16(bs, ptr->num_entries);\n\tgf_bs_write_u8(bs, 0);\n\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tgf_bs_write_u8(bs, ptr->entries[i].entry_type);\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tgf_bs_write_u32(bs, ptr->entries[i].trackID);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgf_bs_write_u32(bs, ptr->entries[i].trackID);\n\t\t\tgf_bs_write_u16(bs, ptr->entries[i].tierID);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgf_bs_write_int(bs, 0, 6);\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].output_view_id, 10);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgf_bs_write_int(bs, 0, 6)\t;\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].start_view_id, 10);\n\t\t\tgf_bs_write_u16(bs, ptr->entries[i].view_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mvcg_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\n\tptr->size += 7;\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tptr->size += 1 + 6;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tptr->size += 1 + 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid vwid_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tif (ptr->views) {\n\t\tfor (i=0; i<ptr->num_views; i++) {\n\t\t\tif (ptr->views[i].view_refs)\n\t\t\t\tgf_free(ptr->views[i].view_refs);\n\t\t}\n\t\tgf_free(ptr->views);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err vwid_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tISOM_DECREASE_SIZE(s, 3)\n\tgf_bs_read_int(bs, 2);\n\tptr->min_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->max_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->num_views = gf_bs_read_u16(bs);\n\tif (ptr->num_views > ptr->size / 6)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->views = gf_malloc(sizeof(ViewIDEntry)*ptr->num_views);\n\tmemset(ptr->views, 0, sizeof(ViewIDEntry)*ptr->num_views);\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tu32 j;\n\t\tISOM_DECREASE_SIZE(s, 6)\n\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_id = gf_bs_read_int(bs, 10);\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_order_index = gf_bs_read_int(bs, 10);\n\t\tptr->views[i].texture_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].texture_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].base_view_type = gf_bs_read_int(bs, 2);\n\t\tptr->views[i].num_ref_views = gf_bs_read_int(bs, 10);\n\n\t\tif (ptr->views[i].num_ref_views > ptr->size / 2)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\n\t\tptr->views[i].view_refs = gf_malloc(sizeof(ViewIDRefViewEntry)*ptr->views[i].num_ref_views);\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 4);\n\t\t\tptr->views[i].view_refs[j].dep_comp_idc = gf_bs_read_int(bs, 2);\n\t\t\tptr->views[i].view_refs[j].ref_view_id = gf_bs_read_int(bs, 10);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *vwid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ViewIdentifierBox, GF_ISOM_BOX_TYPE_VWID);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err vwid_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, 0, 2);\n\tgf_bs_write_int(bs, ptr->min_temporal_id, 3);\n\tgf_bs_write_int(bs, ptr->max_temporal_id, 3);\n\tgf_bs_write_u16(bs, ptr->num_views);\n\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tgf_bs_write_int(bs, 0, 6);\n\t\tgf_bs_write_int(bs, ptr->views[i].view_id, 10);\n\t\tgf_bs_write_int(bs, 0, 6);\n\t\tgf_bs_write_int(bs, ptr->views[i].view_order_index, 10);\n\n\t\tgf_bs_write_int(bs, ptr->views[i].texture_in_stream, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].texture_in_track, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].depth_in_stream, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].depth_in_track, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].base_view_type, 2);\n\t\tgf_bs_write_int(bs, ptr->views[i].num_ref_views, 10);\n\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\tgf_bs_write_int(bs, ptr->views[i].view_refs[j].dep_comp_idc, 2);\n\t\t\tgf_bs_write_int(bs, ptr->views[i].view_refs[j].ref_view_id, 10);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err vwid_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tptr->size += 3;\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tptr->size += 6 + 2 * ptr->views[i].num_ref_views;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid pcmC_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err pcmC_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 2)\n\tptr->format_flags = gf_bs_read_u8(bs);\n\tptr->PCM_sample_size = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\nGF_Box *pcmC_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PCMConfigBox, GF_ISOM_BOX_TYPE_PCMC);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pcmC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->format_flags);\n\tgf_bs_write_u8(bs, ptr->PCM_sample_size);\n\treturn GF_OK;\n}\n\nGF_Err pcmC_box_size(GF_Box *s)\n{\n\ts->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid chnl_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err chnl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->layout.stream_structure = gf_bs_read_u8(bs);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.definedLayout = gf_bs_read_u8(bs);\n\t\tif (ptr->layout.definedLayout) {\n\t\t\tu32 remain = (u32) ptr->size;\n\t\t\tif (ptr->layout.stream_structure & 2) remain--;\n\t\t\tptr->layout.channels_count = 0;\n\t\t\twhile (remain) {\n\t\t\t\tISOM_DECREASE_SIZE(s, 1)\n\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].position = gf_bs_read_u8(bs);\n\t\t\t\tremain--;\n\t\t\t\tif (ptr->layout.layouts[ptr->layout.channels_count].position == 126) {\n\t\t\t\t\tISOM_DECREASE_SIZE(s, 3)\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].azimuth = gf_bs_read_int(bs, 16);\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].elevation = gf_bs_read_int(bs, 8);\n\t\t\t\t\tremain-=3;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(s, 8)\n\t\t\tptr->layout.omittedChannelsMap = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.object_count = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *chnl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChannelLayoutBox, GF_ISOM_BOX_TYPE_CHNL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chnl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->layout.stream_structure);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tgf_bs_write_u8(bs, ptr->layout.definedLayout);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\tgf_bs_write_u8(bs, ptr->layout.layouts[i].position);\n\t\t\t\tif (ptr->layout.layouts[i].position==126) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].azimuth, 16);\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].elevation, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u64(bs, ptr->layout.omittedChannelsMap);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tgf_bs_write_u8(bs, ptr->layout.object_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err chnl_box_size(GF_Box *s)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\ts->size += 1;\n\tif (ptr->layout.stream_structure & 1) {\n\t\ts->size += 1;\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\ts->size+=1;\n\t\t\t\tif (ptr->layout.layouts[i].position==126)\n\t\t\t\t\ts->size+=3;\n\t\t\t}\n\t\t} else {\n\t\t\ts->size += 8;\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\ts->size += 1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *emsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EventMessageBox, GF_ISOM_BOX_TYPE_EMSG);\n\treturn (GF_Box *)tmp;\n}\n\nvoid emsg_box_del(GF_Box *s)\n{\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->scheme_id_uri) gf_free(ptr->scheme_id_uri);\n\tif (ptr->value) gf_free(ptr->value);\n\tif (ptr->message_data) gf_free(ptr->message_data);\n\tgf_free(ptr);\n}\n\nGF_Err emsg_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\tif (ptr->version==0) {\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_id_uri);\n\t\tif (e) return e;\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->value);\n\t\tif (e) return e;\n\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->timescale = gf_bs_read_u32(bs);\n\t\tptr->presentation_time_delta = gf_bs_read_u32(bs);\n\t\tptr->event_duration = gf_bs_read_u32(bs);\n\t\tptr->event_id = gf_bs_read_u32(bs);\n\t} else if (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->timescale = gf_bs_read_u32(bs);\n\t\tptr->presentation_time_delta = gf_bs_read_u64(bs);\n\t\tptr->event_duration = gf_bs_read_u32(bs);\n\t\tptr->event_id = gf_bs_read_u32(bs);\n\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_id_uri);\n\t\tif (e) return e;\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->value);\n\t\tif (e) return e;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\tif (ptr->size) {\n\t\tif (ptr->size>0xFFFFFFFUL) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] emsg message data size too big (\"LLU\") to be loaded\\n\", ptr->size));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tptr->message_data_size = (u32) ptr->size;\n\t\tptr->message_data = gf_malloc(ptr->message_data_size);\n\t\tif (!ptr->message_data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->message_data, ptr->message_data_size);\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err emsg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 len;\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->version==1) {\n\t\tgf_bs_write_u32(bs, ptr->timescale);\n\t\tgf_bs_write_u64(bs, ptr->presentation_time_delta);\n\t\tgf_bs_write_u32(bs, ptr->event_duration);\n\t\tgf_bs_write_u32(bs, ptr->event_id);\n\t}\n\n\tlen = ptr->scheme_id_uri ? (u32) strlen(ptr->scheme_id_uri) : 0;\n\tif (len) gf_bs_write_data(bs, ptr->scheme_id_uri, len);\n\tgf_bs_write_u8(bs, 0);\n\n\tlen = ptr->value ? (u32) strlen(ptr->value) : 0;\n\tif (len) gf_bs_write_data(bs, ptr->value, len);\n\tgf_bs_write_u8(bs, 0);\n\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, ptr->timescale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->presentation_time_delta);\n\t\tgf_bs_write_u32(bs, ptr->event_duration);\n\t\tgf_bs_write_u32(bs, ptr->event_id);\n\t}\n\tif (ptr->message_data)\n\t\tgf_bs_write_data(bs, ptr->message_data, ptr->message_data_size);\n\treturn GF_OK;\n}\n\nGF_Err emsg_box_size(GF_Box *s)\n{\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\tif (ptr->version) {\n\t\tptr->size += 20;\n\t} else {\n\t\tptr->size += 16;\n\t}\n\tptr->size+=2; //1 NULL-terminated strings\n\tif (ptr->scheme_id_uri) ptr->size += strlen(ptr->scheme_id_uri);\n\tif (ptr->value) ptr->size += strlen(ptr->value);\n\tif (ptr->message_data)\n\t\tptr->size += ptr->message_data_size;\n\n\treturn GF_OK;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\n\n\nGF_Box *csgp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompactSampleGroupBox, GF_ISOM_BOX_TYPE_CSGP);\n\treturn (GF_Box *)tmp;\n}\nvoid csgp_box_del(GF_Box *a)\n{\n\tGF_CompactSampleGroupBox *p = (GF_CompactSampleGroupBox *)a;\n\tif (p->patterns) {\n\t\tu32 i;\n\t\tfor (i=0; i<p->pattern_count; i++) {\n\t\t\tif (p->patterns[i].sample_group_description_indices)\n\t\t\t\tgf_free(p->patterns[i].sample_group_description_indices);\n\t\t}\n\t\tgf_free(p->patterns);\n\t}\n\tgf_free(p);\n}\n\nu32 get_size_by_code(u32 code)\n{\n\tif (code==0) return 4;\n\tif (code==1) return 8;\n\tif (code==2) return 16;\n\treturn 32;\n}\nGF_Err csgp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, bits, gidx_mask;\n\tBool index_msb_indicates_fragment_local_description, grouping_type_parameter_present;\n\tu32 pattern_size, scount_size, index_size;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tindex_msb_indicates_fragment_local_description = (ptr->flags & (1<<7)) ? GF_TRUE : GF_FALSE;\n\tgrouping_type_parameter_present = (ptr->flags & (1<<6)) ? GF_TRUE : GF_FALSE;\n\n\tpattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tscount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tindex_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\tif (((pattern_size==4) && (scount_size!=4)) || ((pattern_size!=4) && (scount_size==4))) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern_size and sample_count_size mare not both 4 bits\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tif (grouping_type_parameter_present) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->pattern_count = gf_bs_read_u32(bs);\n\n\n\tif ( (ptr->size / ( (pattern_size + scount_size) / 8 ) < ptr->pattern_count) || (u64)ptr->pattern_count > (u64)SIZE_MAX/sizeof(GF_CompactSampleGroupPattern) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern_count value (%lu) invalid\\n\", ptr->pattern_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->patterns = gf_malloc(sizeof(GF_CompactSampleGroupPattern) * ptr->pattern_count);\n\tif (!ptr->patterns) return GF_OUT_OF_MEM;\n\tmemset(ptr->patterns, 0, sizeof(GF_CompactSampleGroupPattern) * ptr->pattern_count);\n\n\tu64 patterns_sizes=0;\n\tbits = 0;\n\tfor (i=0; i<ptr->pattern_count; i++) {\n\t\tptr->patterns[i].length = gf_bs_read_int(bs, pattern_size);\n\t\tptr->patterns[i].sample_count = gf_bs_read_int(bs, scount_size);\n\t\tbits += pattern_size + scount_size;\n\t\tif (! (bits % 8)) {\n\t\t\tbits/=8;\n\t\t\tISOM_DECREASE_SIZE(ptr, bits);\n\t\t\tbits=0;\n\t\t}\n\t\tpatterns_sizes+=ptr->patterns[i].length;\n\t\tif (patterns_sizes * index_size > ptr->size*8) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern cumulated sizes \"LLU\" larger than box size \"LLU\"\\n\", patterns_sizes, ptr->size));\n\t\t\tptr->patterns[i].sample_group_description_indices = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tif ( (u64)ptr->patterns[i].length > (u64)SIZE_MAX/sizeof(u32) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern #%d value (%lu) invalid\\n\", i, ptr->patterns[i].length));\n\t\t\tptr->patterns[i].sample_group_description_indices = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->patterns[i].sample_group_description_indices = gf_malloc(sizeof(u32) * ptr->patterns[i].length);\n\t\tif (!ptr->patterns[i].sample_group_description_indices) return GF_OUT_OF_MEM;\n\t}\n\tbits = 0;\n\tgidx_mask = ((u32)1) << (index_size-1);\n\tfor (i=0; i<ptr->pattern_count; i++) {\n\t\tu32 j;\n\t\tfor (j=0; j<ptr->patterns[i].length; j++) {\n\t\t\tu32 idx = gf_bs_read_int(bs, index_size);\n\t\t\tif (index_msb_indicates_fragment_local_description) {\n\t\t\t\t//MSB set, this is a index of a group described in the fragment\n\t\t\t\tif (idx & gidx_mask) {\n\t\t\t\t\tidx += 0x10000;\n\t\t\t\t\tidx &= ~gidx_mask;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->patterns[i].sample_group_description_indices[j] = idx;\n\t\t\tbits += index_size;\n\n\t\t\tif (! (bits % 8)) {\n\t\t\t\tbits/=8;\n\t\t\t\tISOM_DECREASE_SIZE(ptr, bits);\n\t\t\t\tbits=0;\n\t\t\t}\n\t\t}\n\t}\n\tif (bits)\n\t\tgf_bs_align(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err csgp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox*)s;\n\tu32 pattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tu32 scount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tu32 index_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_int(bs, ptr->flags, 24);\n\tgf_bs_write_u32(bs, ptr->grouping_type);\n\n\tif (ptr->flags & (1<<6))\n\t\tgf_bs_write_u32(bs, ptr->grouping_type_parameter);\n\n\tgf_bs_write_u32(bs, ptr->pattern_count);\n\n\tfor (i = 0; i<ptr->pattern_count; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->patterns[i].length, pattern_size);\n\t\tgf_bs_write_int(bs, ptr->patterns[i].sample_count, scount_size);\n\t}\n\n\tfor (i = 0; i<ptr->pattern_count; i++ ) {\n\t\tu32 j;\n\t\tfor (j=0; j<ptr->patterns[i].length; j++) {\n\t\t\tu32 idx = ptr->patterns[i].sample_group_description_indices[j];\n\t\t\tif (idx > 0x10000) {\n\t\t\t\tidx -= 0x10000;\n\t\t\t\tgf_bs_write_int(bs, 1, 1);\n\t\t\t\tgf_bs_write_int(bs, idx, index_size-1);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, idx, index_size);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_align(bs);\n\treturn GF_OK;\n}\n\nGF_Err csgp_box_size(GF_Box *s)\n{\n\tu32 i, bits;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox*)s;\n\tu32 pattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tu32 scount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tu32 index_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\tptr->size += 12; //v, flags , grouping_type, pattern_length\n\tif (ptr->flags & (1<<6))\n\t\tptr->size+=4;\n\n\tptr->size += ptr->pattern_count * (pattern_size + scount_size) / 8;\n\tbits=0;\n\tfor (i=0; i<ptr->pattern_count; i++)\n\t\tbits += ptr->patterns[i].length * index_size;\n\tptr->size += bits/8;\n\tif (bits % 8) ptr->size++;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dmlp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrueHDConfigBox, GF_ISOM_BOX_TYPE_DMLP);\n\treturn (GF_Box *)tmp;\n}\n\nvoid dmlp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err dmlp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrueHDConfigBox *ptr = (GF_TrueHDConfigBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 10)\n\tptr->format_info = gf_bs_read_u32(bs);\n\tptr->peak_data_rate = gf_bs_read_int(bs, 15);\n\tgf_bs_read_int(bs, 1);\n\tgf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dmlp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrueHDConfigBox *ptr = (GF_TrueHDConfigBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->format_info);\n\tgf_bs_write_int(bs, ptr->peak_data_rate, 15);\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err dmlp_box_size(GF_Box *s)\n{\n\ts->size += 10;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *xtra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_XtraBox, GF_ISOM_BOX_TYPE_XTRA);\n\ttmp->tags = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid xtra_box_del(GF_Box *s)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (gf_list_count(ptr->tags)) {\n\t\tGF_XtraTag *tag = gf_list_pop_back(ptr->tags);\n\t\tif (tag->name) gf_free(tag->name);\n\t\tif (tag->prop_value) gf_free(tag->prop_value);\n\t\tgf_free(tag);\n\t}\n\tgf_list_del(ptr->tags);\n\tgf_free(s);\n}\n\nGF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (ptr->size) {\n\t\tGF_XtraTag *tag;\n\t\tu32 prop_type = 0;\n\n\t\tchar *data=NULL, *data2=NULL;\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 8)\n\t\ts32 tag_size = gf_bs_read_u32(bs);\n\t\tu32 name_size = gf_bs_read_u32(bs);\n\t\tif (tag_size < 8) return GF_ISOM_INVALID_FILE;\n\n\t\ttag_size -= 8;\n\t\tif ((tag_size>ptr->size) || (name_size>ptr->size)) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 10)\n\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)\n\t\tdata = gf_malloc(sizeof(char) * (name_size+1));\n\t\tgf_bs_read_data(bs, data, name_size);\n\t\tdata[name_size] = 0;\n\t\ttag_size-=name_size;\n\n\t\tu32 flags = gf_bs_read_u32(bs);\n\t\tu32 prop_size = gf_bs_read_u32(bs);\n\t\ttag_size-=8;\n\n\t\tif (prop_size>4) {\n\t\t\ttag_size-=2;\n\t\t\tprop_type = gf_bs_read_u16(bs);\n\t\t\tprop_size -= 6;\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)\n\t\t\t//add 3 extra bytes for UTF16 case string dump (3 because we need 0-aligned short value)\n\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+3));\n\t\t\tgf_bs_read_data(bs, data2, prop_size);\n\t\t\tdata2[prop_size] = 0;\n\t\t\tdata2[prop_size+1] = 0;\n\t\t\tdata2[prop_size+2] = 0;\n\t\t\ttag_size-=prop_size;\n\t\t} else {\n\t\t\tprop_size = 0;\n\t\t}\n\t\tGF_SAFEALLOC(tag, GF_XtraTag)\n\t\ttag->flags = flags;\n\t\ttag->name = data;\n\t\ttag->prop_size = prop_size;\n\t\ttag->prop_value = data2;\n\t\ttag->prop_type = prop_type;\n\t\tgf_list_add(ptr->tags, tag);\n\n\t\tif (tag_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isom] invalid tag size in Xtra !\\n\"));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err xtra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\tu32 i, count = gf_list_count(ptr->tags);\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_XtraTag *tag = gf_list_get(ptr->tags, i);\n\t\tu32 tag_size = 16;\n\t\tu32 name_len = tag->name ? (u32) strlen(tag->name) : 0;\n\t\ttag_size += name_len;\n\t\tif (tag->prop_value) {\n\t\t\ttag_size += 2 + tag->prop_size;\n\t\t}\n\t\tgf_bs_write_u32(bs, tag_size);\n\t\tgf_bs_write_u32(bs, name_len);\n\t\tgf_bs_write_data(bs, tag->name, name_len);\n\t\tgf_bs_write_u32(bs, tag->flags);\n\t\tgf_bs_write_u32(bs, 6 + tag->prop_size);\n\t\tgf_bs_write_u16(bs, tag->prop_type);\n\t\tgf_bs_write_data(bs, tag->prop_value, tag->prop_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err xtra_box_size(GF_Box *s)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\tu32 i, count = gf_list_count(ptr->tags);\n\tfor (i=0; i<count; i++) {\n\t\tGF_XtraTag *tag = gf_list_get(ptr->tags, i);\n\t\tptr->size += 18 + (u32) strlen(tag->name) + tag->prop_size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *st3d_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Stereo3DBox, GF_ISOM_BOX_TYPE_ST3D);\n\treturn (GF_Box *)tmp;\n}\n\nvoid st3d_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err st3d_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Stereo3DBox *ptr = (GF_Stereo3DBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->stereo_type = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err st3d_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_Stereo3DBox *ptr = (GF_Stereo3DBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->stereo_type);\n\treturn GF_OK;\n}\n\nGF_Err st3d_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *svhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SphericalVideoInfoBox, GF_ISOM_BOX_TYPE_SVHD);\n\treturn (GF_Box *)tmp;\n}\n\nvoid svhd_box_del(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string) gf_free(ptr->string);\n\tgf_free(s);\n}\n\n\nGF_Err svhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif ((u32)ptr->size >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in svhd box\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->string = gf_malloc(sizeof(char) * ((u32) ptr->size+1));\n\tif (!ptr->string) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->string, (u32) ptr->size);\n\tptr->string[ptr->size] = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err svhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->string)\n\t\tgf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err svhd_box_size(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string)\n\t\ts->size += (u32) strlen(ptr->string);\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *prhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProjectionHeaderBox, GF_ISOM_BOX_TYPE_PRHD);\n\treturn (GF_Box *)tmp;\n}\n\nvoid prhd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err prhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionHeaderBox *ptr = (GF_ProjectionHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 12)\n\tptr->yaw = (s32) gf_bs_read_u32(bs);\n\tptr->pitch = (s32) gf_bs_read_u32(bs);\n\tptr->roll = (s32) gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err prhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProjectionHeaderBox *ptr = (GF_ProjectionHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->yaw);\n\tgf_bs_write_u32(bs, ptr->pitch);\n\tgf_bs_write_u32(bs, ptr->roll);\n\treturn GF_OK;\n}\n\nGF_Err prhd_box_size(GF_Box *s)\n{\n\ts->size += 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *proj_type_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProjectionTypeBox, GF_ISOM_BOX_TYPE_EQUI); //will be overwritten\n\treturn (GF_Box *)tmp;\n}\n\nvoid proj_type_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err proj_type_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->layout = gf_bs_read_u32(bs);\n\t\tptr->padding = gf_bs_read_u32(bs);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->bounds_top = gf_bs_read_u32(bs);\n\t\tptr->bounds_bottom = gf_bs_read_u32(bs);\n\t\tptr->bounds_left = gf_bs_read_u32(bs);\n\t\tptr->bounds_right = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->crc = gf_bs_read_u32(bs);\n\t\tptr->encoding_4cc = gf_bs_read_u32(bs);\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err proj_type_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tgf_bs_write_u32(bs, ptr->layout);\n\t\tgf_bs_write_u32(bs, ptr->padding);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tgf_bs_write_u32(bs, ptr->bounds_top);\n\t\tgf_bs_write_u32(bs, ptr->bounds_bottom);\n\t\tgf_bs_write_u32(bs, ptr->bounds_left);\n\t\tgf_bs_write_u32(bs, ptr->bounds_right);\n\t} else {\n\t\tgf_bs_write_u32(bs, ptr->crc);\n\t\tgf_bs_write_u32(bs, ptr->encoding_4cc);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err proj_type_box_size(GF_Box *s)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP)\n\t\ts->size += 8;\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI)\n\t\ts->size += 16;\n\telse\n\t\ts->size += 8;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n//Add this funct to handle incomplete files...\n//bytesExpected is 0 most of the time. If the file is incomplete, bytesExpected\n//is the number of bytes missing to parse the box...\nGF_Err gf_isom_parse_root_box(GF_Box **outBox, GF_BitStream *bs, u32 *box_type, u64 *bytesExpected, Bool progressive_mode)\n{\n\tGF_Err ret;\n\tu64 start;\n\tstart = gf_bs_get_position(bs);\n\tret = gf_isom_box_parse_ex(outBox, bs, 0, GF_TRUE, 0);\n\tif (ret == GF_ISOM_INCOMPLETE_FILE) {\n\t\tif (!*outBox) {\n\t\t\t// We could not even read the box size, we at least need 8 bytes\n\t\t\t*bytesExpected = 8;\n\t\t\tif (box_type) *box_type = 0;\n\t\t\tGF_LOG(progressive_mode ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete box - start \"LLU\"\\n\", start));\n\t\t}\n\t\telse {\n\t\t\tu32 type = (*outBox)->type;\n\t\t\tif (type==GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\ttype = ((GF_UnknownBox *) (*outBox))->original_4cc;\n\n\t\t\t*bytesExpected = (*outBox)->size;\n\t\t\tif (box_type) *box_type = (*outBox)->type;\n\n\t\t\tGF_LOG(progressive_mode ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete box %s - start \"LLU\" size \"LLU\"\\n\", gf_4cc_to_str(type), start, (*outBox)->size));\n\t\t\tgf_isom_box_del(*outBox);\n\t\t\t*outBox = NULL;\n\t\t}\n\t\tgf_bs_seek(bs, start);\n\t}\n\treturn ret;\n}\n\nu32 gf_isom_solve_uuid_box(u8 *UUID)\n{\n\tu32 i;\n\tchar strUUID[33], strChar[3];\n\tstrUUID[0] = 0;\n\tstrUUID[32] = 0;\n\tfor (i=0; i<16; i++) {\n\t\tsnprintf(strChar, 3, \"%02X\", (unsigned char) UUID[i]);\n\t\tstrcat(strUUID, strChar);\n\t}\n\tif (!strnicmp(strUUID, \"8974dbce7be74c5184f97148f9882554\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TENC;\n\tif (!strnicmp(strUUID, \"A5D40B30E81411DDBA2F0800200C9A66\", 32))\n\t\treturn GF_ISOM_BOX_UUID_MSSM;\n\tif (!strnicmp(strUUID, \"D4807EF2CA3946958E5426CB9E46A79F\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TFRF;\n\tif (!strnicmp(strUUID, \"6D1D9B0542D544E680E2141DAFF757B2\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TFXD;\n\tif (!strnicmp(strUUID, \"A2394F525A9B4F14A2446C427C648DF4\", 32))\n\t\treturn GF_ISOM_BOX_UUID_PSEC;\n\tif (!strnicmp(strUUID, \"D08A4F1810F34A82B6C832D8ABA183D3\", 32))\n\t\treturn GF_ISOM_BOX_UUID_PSSH;\n\n\treturn 0;\n}\n\nstatic GF_Err gf_isom_full_box_read(GF_Box *ptr, GF_BitStream *bs);\n\nu64 unused_bytes = 0;\n\n#define GF_SKIP_BOX 10\n\nGF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box, u64 parent_size)\n{\n\tu32 type, uuid_type, hdr_size, restore_type;\n\tu64 size, start, comp_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_BitStream *uncomp_bs = NULL;\n\tu8 *uncomp_data = NULL;\n\tu32 compressed_size=0;\n\tGF_Box *newBox;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\t\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tcomp_start = start = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t\treturn GF_SKIP_BOX;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tif (is_root_box && (size>=8)) {\n\t\t\tBool do_uncompress = GF_FALSE;\n\t\t\tu8 *compb = NULL;\n\t\t\tu32 osize = 0;\n\t\t\tu32 otype = type;\n\t\t\tif (type==GF_4CC('!', 'm', 'o', 'f')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOF;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 'm', 'o', 'v')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOV;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 'i', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SIDX;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 's', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SSIX;\n\t\t\t}\n\n\t\t\tif (do_uncompress) {\n\t\t\t\tcompb = gf_malloc((u32) (size-8));\n\t\t\t\tif (!compb) return GF_OUT_OF_MEM;\n\n\t\t\t\tcompressed_size = (u32) (size - 8);\n\t\t\t\tgf_bs_read_data(bs, compb, compressed_size);\n\t\t\t\te = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);\n\t\t\t\tif (e) {\n\t\t\t\t\tgf_free(compb);\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\t//keep size as complete box size for tests below\n\t\t\t\tsize = osize + 8;\n\t\t\t\tuncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);\n\t\t\t\tbs = uncomp_bs;\n\t\t\t\tstart = 0;\n\t\t\t\tgf_free(compb);\n\t\t\t}\n\t\t}\n\t}\n\n#define ERR_EXIT(_e) { \\\n\t\tif (uncomp_bs) {\\\n\t\t\tgf_free(uncomp_data);\\\n\t\t\tgf_bs_del(uncomp_bs); \\\n\t\t}\\\n\t\treturn _e;\\\n\t}\n\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tif (!skip_logs)\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), size,  start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLD\" less than box header size %d\\n\", gf_4cc_to_str(type), size, hdr_size));\n\t\tERR_EXIT(GF_ISOM_INVALID_FILE);\n\t}\n\t//if parent size is given, make sure box fits within parent\n\tif (parent_size && (parent_size<size)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLU\" is larger than remaining parent size \"LLU\"\\n\", gf_4cc_to_str(type), size, parent_size ));\n\t\tERR_EXIT(GF_ISOM_INVALID_FILE);\n\t}\n\trestore_type = 0;\n\tif ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {\n\t\tu64 cookie = gf_bs_get_cookie(bs);\n\t\trestore_type = type;\n\t\tif (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)\n\t\t\ttype = GF_QT_SUBTYPE_RAW_VID;\n\t\telse\n\t\t\ttype = GF_QT_SUBTYPE_RAW_AUD;\n\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tif (restore_type)\n\t\tnewBox->type = restore_type;\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tif (e) {\n\t\tif (gf_opts_get_bool(\"core\", \"no-check\"))\n\t\t\te = GF_OK;\n\t}\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (uncomp_bs) {\n\t\tgf_free(uncomp_data);\n\t\tgf_bs_del(uncomp_bs);\n\t\tif (e) {\n\t\t\tgf_isom_box_del(newBox);\n\t\t\t*outBox = NULL;\n\t\t\treturn e;\n\t\t}\n\t\t//move size to real bitstream offsets for tests below\n\t\tsize -= 8;\n\t\t//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset\n\t\tif (type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\t((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for moov in order to properly recompute chunk offset\n\t\telse if (type==GF_ISOM_BOX_TYPE_MOOV) {\n\t\t\t((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t\t((GF_MovieBox *)newBox)->file_offset = comp_start;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\tnewBox->internal_flags = GF_ISOM_BOX_COMPRESSED;\n\t}\n\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\t\tif (is_root_box && (e==GF_SKIP_BOX))\n\t\t\te = GF_ISOM_INVALID_FILE;\n\n\t\tif (!skip_logs && (e!=GF_SKIP_BOX)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), size, start, (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t\tunused_bytes += to_skip;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_box_parse(GF_Box **outBox, GF_BitStream *bs)\n{\n\treturn gf_isom_box_parse_ex(outBox, bs, 0, GF_FALSE, 0);\n}\n\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\n\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\n\nvoid gf_isom_box_array_reset_parent(GF_List **child_boxes, GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del_parent(child_boxes, a);\n\t}\n\tgf_list_reset(boxlist);\n}\nvoid gf_isom_box_array_del_parent(GF_List **child_boxes, GF_List *boxlist)\n{\n\tif (!boxlist) return;\n\tgf_isom_box_array_reset_parent(child_boxes, boxlist);\n\tgf_list_del(boxlist);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_EXPORT\nGF_Err gf_isom_box_write_header(GF_Box *ptr, GF_BitStream *bs)\n{\n\tu64 start;\n\tif (! bs || !ptr) return GF_BAD_PARAM;\n\tif (!ptr->size) return GF_ISOM_INVALID_FILE;\n\n\tstart = gf_bs_get_position(bs);\n\tif (ptr->size > 0xFFFFFFFF) {\n\t\tgf_bs_write_u32(bs, 1);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->size);\n\t}\n\tgf_bs_write_u32(bs, ptr->type);\n\tif (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\tu32 i;\n\t\tBool conv_uuid = GF_TRUE;\n\t\tGF_UUIDBox *uuidb = (GF_UUIDBox *)ptr;\n\t\tchar strUUID[32];\n\n\t\tswitch (uuidb->internal_4cc) {\n\t\tcase GF_ISOM_BOX_UUID_TENC:\n\t\t\tmemcpy(strUUID, \"8974dbce7be74c5184f97148f9882554\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_PSEC:\n\t\t\tmemcpy(strUUID, \"A2394F525A9B4F14A2446C427C648DF4\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_MSSM:\n\t\t\tmemcpy(strUUID, \"A5D40B30E81411DDBA2F0800200C9A66\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_PSSH:\n\t\t\tmemcpy(strUUID, \"D08A4F1810F34A82B6C832D8ABA183D3\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_TFXD:\n\t\t\tmemcpy(strUUID, \"6D1D9B0542D544E680E2141DAFF757B2\", 32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconv_uuid = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (conv_uuid) {\n\t\t\tchar uuid[16];\n\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\tchar t[3];\n\t\t\t\tt[2] = 0;\n\t\t\t\tt[0] = strUUID[2*i];\n\t\t\t\tt[1] = strUUID[2*i+1];\n\t\t\t\tuuid[i] = (u8) strtol(t, NULL, 16);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, uuid, 16);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, uuidb->uuid, 16);\n\t\t}\n\t}\n\tif (ptr->size > 0xFFFFFFFF)\n\t\tgf_bs_write_u64(bs, ptr->size);\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Written Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(ptr->type), ptr->size, start));\n\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_full_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FullBox *ptr = (GF_FullBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_box_array_write(GF_Box *parent, GF_List *list, GF_BitStream *bs)\n{\n\tu32 count, i;\n\tGF_Err e;\n\tif (!list) return GF_OK;\n\tcount = gf_list_count(list);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(list, i);\n\t\tif (a) {\n\t\t\te = gf_isom_box_write(a, bs);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Error %s writing box %s\\n\", gf_error_to_string(e), gf_4cc_to_str(a->type) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_box_array_size(GF_Box *parent, GF_List *list)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tif (! list) return GF_OK;\n\n\tcount = gf_list_count(list);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(list, i);\n\t\tif (a) {\n\t\t\te = gf_isom_box_size(a);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Error %s computing box %s size\\n\", gf_error_to_string(e), gf_4cc_to_str(a->type) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tparent->size += a->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box * unkn_box_new();\nvoid unkn_box_del(GF_Box *);\nGF_Err unkn_box_read(GF_Box *s, GF_BitStream *bs);\nGF_Err unkn_box_write(GF_Box *s, GF_BitStream *bs);\nGF_Err unkn_box_size(GF_Box *s);\nGF_Err unkn_box_dump(GF_Box *a, FILE * trace);\n\n//definition of boxes new/del/read/write/size. For now still exported since some files other than box_funcs.c call them\n//this should be fixed by only using gf_isom_box_new\n\n#define ISOM_BOX_IMPL_DECL(a_name) \\\n\t\tGF_Box * a_name##_box_new(); \\\n\t\tvoid a_name##_box_del(GF_Box *); \\\n\t\tGF_Err a_name##_box_read(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_write(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_size(GF_Box *s);\\\n\t\tGF_Err a_name##_box_dump(GF_Box *a, FILE * trace);\n\n#define ISOM_BOX_IMPL_DECL_CHILD(a_name) \\\n\t\tGF_Box * a_name##_box_new(); \\\n\t\tvoid a_name##_box_del(GF_Box *); \\\n\t\tGF_Err a_name##_box_read(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_write(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_size(GF_Box *s);\\\n\t\tGF_Err a_name##_box_dump(GF_Box *a, FILE * trace);\\\n\t\tGF_Err a_name##_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\\\n\n\nISOM_BOX_IMPL_DECL(reftype)\nISOM_BOX_IMPL_DECL(ireftype)\nISOM_BOX_IMPL_DECL(free)\nISOM_BOX_IMPL_DECL(wide)\nISOM_BOX_IMPL_DECL(mdat)\nISOM_BOX_IMPL_DECL(imda)\nISOM_BOX_IMPL_DECL_CHILD(moov)\nISOM_BOX_IMPL_DECL(mvhd)\nISOM_BOX_IMPL_DECL(mdhd)\nISOM_BOX_IMPL_DECL(vmhd)\nISOM_BOX_IMPL_DECL(smhd)\nISOM_BOX_IMPL_DECL(hmhd)\nISOM_BOX_IMPL_DECL(nmhd)\nISOM_BOX_IMPL_DECL_CHILD(stbl)\nISOM_BOX_IMPL_DECL_CHILD(dinf)\nISOM_BOX_IMPL_DECL(url)\nISOM_BOX_IMPL_DECL(urn)\nISOM_BOX_IMPL_DECL(cprt)\nISOM_BOX_IMPL_DECL(kind)\nISOM_BOX_IMPL_DECL(chpl)\nISOM_BOX_IMPL_DECL(hdlr)\nISOM_BOX_IMPL_DECL(iods)\nISOM_BOX_IMPL_DECL_CHILD(trak)\nISOM_BOX_IMPL_DECL_CHILD(mp4s)\nISOM_BOX_IMPL_DECL_CHILD(audio_sample_entry)\nISOM_BOX_IMPL_DECL(gen_sample_entry)\nISOM_BOX_IMPL_DECL_CHILD(edts)\nISOM_BOX_IMPL_DECL_CHILD(udta)\nISOM_BOX_IMPL_DECL(dref)\nISOM_BOX_IMPL_DECL_CHILD(stsd)\nISOM_BOX_IMPL_DECL(stts)\nISOM_BOX_IMPL_DECL(ctts)\nISOM_BOX_IMPL_DECL(stsh)\nISOM_BOX_IMPL_DECL(elst)\nISOM_BOX_IMPL_DECL(stsc)\nISOM_BOX_IMPL_DECL(stsz)\nISOM_BOX_IMPL_DECL(stco)\nISOM_BOX_IMPL_DECL(stss)\nISOM_BOX_IMPL_DECL(stdp)\nISOM_BOX_IMPL_DECL(sdtp)\nISOM_BOX_IMPL_DECL(co64)\nISOM_BOX_IMPL_DECL(esds)\nISOM_BOX_IMPL_DECL_CHILD(minf)\nISOM_BOX_IMPL_DECL(tkhd)\nISOM_BOX_IMPL_DECL(tref)\nISOM_BOX_IMPL_DECL_CHILD(mdia)\nISOM_BOX_IMPL_DECL_CHILD(mfra)\nISOM_BOX_IMPL_DECL(tfra)\nISOM_BOX_IMPL_DECL(mfro)\nISOM_BOX_IMPL_DECL(uuid)\nISOM_BOX_IMPL_DECL(void)\nISOM_BOX_IMPL_DECL(gnrm)\nISOM_BOX_IMPL_DECL(gnrv)\nISOM_BOX_IMPL_DECL(gnra)\nISOM_BOX_IMPL_DECL(pdin)\nISOM_BOX_IMPL_DECL(def_parent)\nISOM_BOX_IMPL_DECL(def_parent_full)\nISOM_BOX_IMPL_DECL(csgp)\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nISOM_BOX_IMPL_DECL_CHILD(hinf)\nISOM_BOX_IMPL_DECL(trpy)\nISOM_BOX_IMPL_DECL(totl)\nISOM_BOX_IMPL_DECL(nump)\nISOM_BOX_IMPL_DECL(npck)\nISOM_BOX_IMPL_DECL(tpyl)\nISOM_BOX_IMPL_DECL(tpay)\nISOM_BOX_IMPL_DECL(maxr)\nISOM_BOX_IMPL_DECL(dmed)\nISOM_BOX_IMPL_DECL(dimm)\nISOM_BOX_IMPL_DECL(drep)\nISOM_BOX_IMPL_DECL(tmin)\nISOM_BOX_IMPL_DECL(tmax)\nISOM_BOX_IMPL_DECL(pmax)\nISOM_BOX_IMPL_DECL(dmax)\nISOM_BOX_IMPL_DECL(payt)\nISOM_BOX_IMPL_DECL(name)\nISOM_BOX_IMPL_DECL(rely)\nISOM_BOX_IMPL_DECL(snro)\nISOM_BOX_IMPL_DECL(tims)\nISOM_BOX_IMPL_DECL(tsro)\nISOM_BOX_IMPL_DECL(ghnt)\nISOM_BOX_IMPL_DECL_CHILD(hnti)\nISOM_BOX_IMPL_DECL(sdp)\nISOM_BOX_IMPL_DECL(rtpo)\nISOM_BOX_IMPL_DECL(tssy)\nISOM_BOX_IMPL_DECL(rssr)\nISOM_BOX_IMPL_DECL_CHILD(srpp)\nISOM_BOX_IMPL_DECL(rtp_hnti)\n\n#endif\n\nISOM_BOX_IMPL_DECL(ftyp)\nISOM_BOX_IMPL_DECL(padb)\nISOM_BOX_IMPL_DECL(gppc)\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nISOM_BOX_IMPL_DECL_CHILD(mvex)\nISOM_BOX_IMPL_DECL(trex)\nISOM_BOX_IMPL_DECL_CHILD(moof)\nISOM_BOX_IMPL_DECL(mfhd)\nISOM_BOX_IMPL_DECL_CHILD(traf)\nISOM_BOX_IMPL_DECL(tfhd)\nISOM_BOX_IMPL_DECL(trun)\nISOM_BOX_IMPL_DECL(styp)\nISOM_BOX_IMPL_DECL(mehd)\n/*smooth streaming timing*/\nISOM_BOX_IMPL_DECL(tfxd)\nISOM_BOX_IMPL_DECL(tfrf)\n\n#endif\n\n/*avc ext*/\nISOM_BOX_IMPL_DECL(avcc)\nISOM_BOX_IMPL_DECL_CHILD(video_sample_entry)\nISOM_BOX_IMPL_DECL(m4ds)\nISOM_BOX_IMPL_DECL(btrt)\nISOM_BOX_IMPL_DECL(mehd)\n\n/*3GPP streaming text*/\nISOM_BOX_IMPL_DECL(ftab)\nISOM_BOX_IMPL_DECL_CHILD(tx3g)\nISOM_BOX_IMPL_DECL(text)\nISOM_BOX_IMPL_DECL(styl)\nISOM_BOX_IMPL_DECL(hlit)\nISOM_BOX_IMPL_DECL(hclr)\nISOM_BOX_IMPL_DECL(krok)\nISOM_BOX_IMPL_DECL(dlay)\nISOM_BOX_IMPL_DECL(href)\nISOM_BOX_IMPL_DECL(tbox)\nISOM_BOX_IMPL_DECL(blnk)\nISOM_BOX_IMPL_DECL(twrp)\n\n\n#ifndef GPAC_DISABLE_VTT\n\n/*WebVTT boxes*/\nISOM_BOX_IMPL_DECL(boxstring);\nISOM_BOX_IMPL_DECL_CHILD(vtcu)\nISOM_BOX_IMPL_DECL(vtte)\nISOM_BOX_IMPL_DECL_CHILD(wvtt)\n\n#endif //GPAC_DISABLE_VTT\n\n/* Items functions */\nISOM_BOX_IMPL_DECL_CHILD(meta)\nISOM_BOX_IMPL_DECL(xml)\nISOM_BOX_IMPL_DECL(bxml)\nISOM_BOX_IMPL_DECL(iloc)\nISOM_BOX_IMPL_DECL(pitm)\nISOM_BOX_IMPL_DECL_CHILD(ipro)\nISOM_BOX_IMPL_DECL(infe)\nISOM_BOX_IMPL_DECL_CHILD(iinf)\nISOM_BOX_IMPL_DECL_CHILD(iref)\nISOM_BOX_IMPL_DECL_CHILD(sinf)\nISOM_BOX_IMPL_DECL(frma)\nISOM_BOX_IMPL_DECL(schm)\nISOM_BOX_IMPL_DECL_CHILD(schi)\nISOM_BOX_IMPL_DECL(enca)\nISOM_BOX_IMPL_DECL(encs)\nISOM_BOX_IMPL_DECL(encv)\nISOM_BOX_IMPL_DECL(resv)\n\n\n/** ISMACryp functions **/\nISOM_BOX_IMPL_DECL(iKMS)\nISOM_BOX_IMPL_DECL(iSFM)\nISOM_BOX_IMPL_DECL(iSLT)\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n/* Adobe extensions */\nISOM_BOX_IMPL_DECL(abst)\nISOM_BOX_IMPL_DECL(afra)\nISOM_BOX_IMPL_DECL(asrt)\nISOM_BOX_IMPL_DECL(afrt)\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n\n/* Apple extensions */\nISOM_BOX_IMPL_DECL(ilst)\nISOM_BOX_IMPL_DECL(ilst_item)\nISOM_BOX_IMPL_DECL(databox)\nISOM_BOX_IMPL_DECL(gmin)\nISOM_BOX_IMPL_DECL(alis)\nISOM_BOX_IMPL_DECL(clef)\n\n/*OMA extensions*/\nISOM_BOX_IMPL_DECL(ohdr)\nISOM_BOX_IMPL_DECL(grpi)\nISOM_BOX_IMPL_DECL(mdri)\nISOM_BOX_IMPL_DECL(odtt)\nISOM_BOX_IMPL_DECL(odrb)\nISOM_BOX_IMPL_DECL(odkm)\n\n\nISOM_BOX_IMPL_DECL(pasp)\nISOM_BOX_IMPL_DECL(clap)\nISOM_BOX_IMPL_DECL_CHILD(metx)\nISOM_BOX_IMPL_DECL(txtc)\nISOM_BOX_IMPL_DECL(tsel)\nISOM_BOX_IMPL_DECL(dimC)\nISOM_BOX_IMPL_DECL_CHILD(dims)\nISOM_BOX_IMPL_DECL(diST)\nISOM_BOX_IMPL_DECL(ac3)\nISOM_BOX_IMPL_DECL(ec3)\nISOM_BOX_IMPL_DECL(dac3)\nISOM_BOX_IMPL_DECL(dec3)\nISOM_BOX_IMPL_DECL(dmlp)\nISOM_BOX_IMPL_DECL(lsrc)\nISOM_BOX_IMPL_DECL_CHILD(lsr1)\nISOM_BOX_IMPL_DECL(mvcg)\nISOM_BOX_IMPL_DECL(vwid)\n\nISOM_BOX_IMPL_DECL(subs)\n\nISOM_BOX_IMPL_DECL(tmcd)\nISOM_BOX_IMPL_DECL(tcmi)\nISOM_BOX_IMPL_DECL(fiel)\nISOM_BOX_IMPL_DECL(gama)\nISOM_BOX_IMPL_DECL(chrm)\nISOM_BOX_IMPL_DECL(chan)\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nISOM_BOX_IMPL_DECL(sidx)\nISOM_BOX_IMPL_DECL(ssix)\nISOM_BOX_IMPL_DECL(leva)\nISOM_BOX_IMPL_DECL(pcrb)\nISOM_BOX_IMPL_DECL(tfdt)\nISOM_BOX_IMPL_DECL(emsg)\n\n#endif\n\nISOM_BOX_IMPL_DECL(rvcc)\nISOM_BOX_IMPL_DECL(sbgp)\nISOM_BOX_IMPL_DECL(sgpd)\nISOM_BOX_IMPL_DECL(saiz)\nISOM_BOX_IMPL_DECL(saio)\n\nISOM_BOX_IMPL_DECL(pssh)\n\nISOM_BOX_IMPL_DECL(tenc)\nISOM_BOX_IMPL_DECL(piff_tenc)\nISOM_BOX_IMPL_DECL(piff_psec)\nISOM_BOX_IMPL_DECL(piff_pssh)\nISOM_BOX_IMPL_DECL(senc)\nISOM_BOX_IMPL_DECL(cslg)\nISOM_BOX_IMPL_DECL(ccst)\nISOM_BOX_IMPL_DECL(auxi)\nISOM_BOX_IMPL_DECL(hvcc)\nISOM_BOX_IMPL_DECL(av1c)\nISOM_BOX_IMPL_DECL(dOps)\nISOM_BOX_IMPL_DECL(prft)\nISOM_BOX_IMPL_DECL(vvcc)\nISOM_BOX_IMPL_DECL(vvnc)\n\n//VPx\nISOM_BOX_IMPL_DECL(vpcc)\nISOM_BOX_IMPL_DECL(SmDm)\nISOM_BOX_IMPL_DECL(CoLL)\n\nISOM_BOX_IMPL_DECL(trep)\n\n//FEC\nISOM_BOX_IMPL_DECL_CHILD(fiin)\nISOM_BOX_IMPL_DECL_CHILD(paen)\nISOM_BOX_IMPL_DECL(fpar)\nISOM_BOX_IMPL_DECL(fecr)\nISOM_BOX_IMPL_DECL(segr)\nISOM_BOX_IMPL_DECL(gitn)\nISOM_BOX_IMPL_DECL_CHILD(fdsa)\nISOM_BOX_IMPL_DECL(fdpa)\nISOM_BOX_IMPL_DECL(extr)\n\n\n/*\n\tAdobe's protection boxes\n*/\nISOM_BOX_IMPL_DECL_CHILD(adkm)\nISOM_BOX_IMPL_DECL_CHILD(ahdr)\nISOM_BOX_IMPL_DECL_CHILD(aprm)\nISOM_BOX_IMPL_DECL(aeib)\nISOM_BOX_IMPL_DECL_CHILD(akey)\nISOM_BOX_IMPL_DECL(flxs)\nISOM_BOX_IMPL_DECL(adaf)\n\n/* Image File Format declarations */\nISOM_BOX_IMPL_DECL(ispe)\nISOM_BOX_IMPL_DECL(colr)\nISOM_BOX_IMPL_DECL(pixi)\nISOM_BOX_IMPL_DECL(rloc)\nISOM_BOX_IMPL_DECL(irot)\nISOM_BOX_IMPL_DECL(imir)\nISOM_BOX_IMPL_DECL(ipco)\nISOM_BOX_IMPL_DECL_CHILD(iprp)\nISOM_BOX_IMPL_DECL(ipma)\nISOM_BOX_IMPL_DECL_CHILD(trgr)\nISOM_BOX_IMPL_DECL(trgt)\nISOM_BOX_IMPL_DECL(ienc)\nISOM_BOX_IMPL_DECL(iaux)\n\n/* MIAF declarations */\nISOM_BOX_IMPL_DECL(clli)\nISOM_BOX_IMPL_DECL(mdcv)\n\n/* AVIF declarations */\nISOM_BOX_IMPL_DECL(a1lx)\nISOM_BOX_IMPL_DECL(a1op)\n\nISOM_BOX_IMPL_DECL(grpl)\n\nISOM_BOX_IMPL_DECL_CHILD(strk)\nISOM_BOX_IMPL_DECL(stri)\nISOM_BOX_IMPL_DECL(stsg)\nISOM_BOX_IMPL_DECL(elng)\nISOM_BOX_IMPL_DECL(stvi)\nISOM_BOX_IMPL_DECL(auxc)\nISOM_BOX_IMPL_DECL(oinf)\nISOM_BOX_IMPL_DECL(tols)\n\nISOM_BOX_IMPL_DECL(trik)\nISOM_BOX_IMPL_DECL(bloc)\nISOM_BOX_IMPL_DECL(ainf)\nISOM_BOX_IMPL_DECL(mhac)\nISOM_BOX_IMPL_DECL(mhap)\n\nISOM_BOX_IMPL_DECL(grptype)\n\nISOM_BOX_IMPL_DECL_CHILD(jp2h)\nISOM_BOX_IMPL_DECL(ihdr)\nISOM_BOX_IMPL_DECL(load)\n\n/* Dolby Vision */\nISOM_BOX_IMPL_DECL(dvcC)\nISOM_BOX_IMPL_DECL(dvvC)\nISOM_BOX_IMPL_DECL(dvhe)\nISOM_BOX_IMPL_DECL(dfla)\n\nISOM_BOX_IMPL_DECL(pcmC)\nISOM_BOX_IMPL_DECL(chnl)\n\nISOM_BOX_IMPL_DECL(xtra)\n\nISOM_BOX_IMPL_DECL(st3d)\nISOM_BOX_IMPL_DECL(svhd)\nISOM_BOX_IMPL_DECL(prhd)\nISOM_BOX_IMPL_DECL(proj_type)\n//ISOM_BOX_IMPL_DECL(mesh)\n\nISOM_BOX_IMPL_DECL(keys)\n\n#define BOX_DEFINE(__type, b_rad, __par) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, \"p12\", GF_FALSE}\n\n#define BOX_DEFINE_CHILD(__type, b_rad, __par) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, \"p12\", GF_FALSE, b_rad##_on_child_box}\n\n#define BOX_DEFINE_S(__type, b_rad, __par, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, __spec, GF_FALSE }\n\n#define BOX_DEFINE_S_CHILD(__type, b_rad, __par, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, __spec, GF_FALSE, b_rad##_on_child_box}\n\n#define FBOX_DEFINE(__type, b_rad, __par, __max_v) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, \"p12\", GF_FALSE }\n\n#define FBOX_DEFINE_CHILD(__type, b_rad, __par, __max_v) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, \"p12\", GF_FALSE, b_rad##_on_child_box}\n\n#define FBOX_DEFINE_FLAGS(__type, b_rad, __par, __max_v, flags) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, flags, __par, \"p12\", GF_FALSE }\n\n#define FBOX_DEFINE_FLAGS_S(__type, b_rad, __par, __max_v, flags, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, flags, __par, __spec, GF_FALSE }\n\n#define FBOX_DEFINE_S(__type, b_rad, __par, __max_v, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, __spec, GF_FALSE }\n\n#define FBOX_DEFINE_S_CHILD(__type, b_rad, __par, __max_v, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, __spec, GF_FALSE, b_rad##_on_child_box}\n\n#define TREF_DEFINE(__type, b_rad, __par, __4cc, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 0, 0, __par, __spec, GF_FALSE }\n\n#define TRGT_DEFINE(__type, b_rad, __par, __4cc, max_version, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 1+max_version, 0, __par, __spec, GF_FALSE }\n\n#define SGPD_DEFINE(__type, b_rad, __par, __4cc, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 1, 0, __par, __spec, GF_FALSE }\n\n#define ITUNES_TAG(_val) \\\n\tBOX_DEFINE_S( _val, ilst_item, \"ilst data\", \"apple\")\n\nstatic struct box_registry_entry {\n\tu32 box_4cc;\n\tGF_Box * (*new_fn)();\n\tvoid (*del_fn)(GF_Box *a);\n\tGF_Err (*read_fn)(GF_Box *s, GF_BitStream *bs);\n\tGF_Err (*write_fn)(GF_Box *s, GF_BitStream *bs);\n\tGF_Err (*size_fn)(GF_Box *a);\n\tGF_Err (*dump_fn)(GF_Box *a, FILE *trace);\n\tu32 alt_4cc;//used for sample grouping type and track / item reference types\n\tu8 max_version_plus_one;\n\tu32 flags;\n\tconst char *parents_4cc;\n\tconst char *spec;\n\tBool disabled;\n\tGF_Err (*add_rem_fn)(GF_Box *par, GF_Box *b, Bool is_remove);\n} box_registry [] =\n{\n\t//DO NOT MOVE THE FIRST ENTRY\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_UNKNOWN, unkn, \"unknown\", \"unknown\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_UUID, uuid, \"unknown\", \"unknown\"),\n\n\t//all track reference types\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_META, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_HINT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_FONT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_HIND, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_VDEP, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_VPLX, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SUBT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_THUMB, \"p12\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OD, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_DECODE, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OCR, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_IPI, \"p14\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_BASE, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SCAL, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_TBAS, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SABT, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OREF, \"p15\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ADDA, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ADRC, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ILOC, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_AVCP, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SWTO, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SWFR, \"p15\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_CHAP, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_TMCD, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_CDEP, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SCPT, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SSRC, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_LYRA, \"apple\"),\n\n\t//all item reference types\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_TBAS, \"p12\"),\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_ILOC, \"p12\"),\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_FDEL, \"p12\"),\n\n\t//all sample group descriptions\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_ROLL, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_PROL, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_RAP, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SEIG, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_OINF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_LINF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TRIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_NALM, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TELE, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_RASH, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_ALST, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SAP, \"p12\"),\n\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVLL, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVSS, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_DTRT, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_MVIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SCIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SCNM, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_STSA, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TSAS, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SYNC, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TSCL, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_VIPR, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_LBLI, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SPOR, \"p15\"),\n\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_3GAG, \"3gpp\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVCB, \"3gpp\"),\n\n\t//internal boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRM, gnrm, \"stsd\", \"unknown\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRV, gnrv, \"stsd\", \"unknown\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRA, gnra, \"stsd\", \"unknown\"),\n\n\t//all track group types\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_MSRC, 0, \"p12\" ),\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_STER, 0, \"p12\" ),\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_CSTG, 0, \"p15\" ),\n\n\t//part12 boxes\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FREE, free, \"*\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SKIP, free, \"*\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_MDAT, mdat, \"file\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_IDAT, mdat, \"meta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_IMDA, mdat, \"file\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MOOV, moov, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MVHD, mvhd, \"moov\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MDHD, mdhd, \"mdia\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_VMHD, vmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SMHD, smhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_HMHD, hmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_NMHD, nmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STHD, nmhd, \"minf\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STBL, stbl, \"minf\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_DINF, dinf, \"minf meta\"),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_URL, url, \"dref\", 0, 1),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_URN, urn, \"dref\", 0, 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CPRT, cprt, \"udta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_KIND, kind, \"udta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_HDLR, hdlr, \"mdia meta minf\", 0),\t//minf container is OK in QT ...\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRAK, trak, \"moov\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_EDTS, edts, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_UDTA, udta, \"moov trak moof traf\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_DREF, dref, \"dinf\", 0),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STSD, stsd, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STTS, stts, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CTTS, ctts, \"stbl\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CSLG, cslg, \"stbl trep\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSH, stsh, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ELST, elst, \"edts\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSC, stsc, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSZ, stsz, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STZ2, stsz, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STCO, stco, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSS, stss, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STDP, stdp, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SDTP, sdtp, \"stbl traf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CO64, co64, \"stbl\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MINF, minf, \"mdia\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TKHD, tkhd, \"trak\", 1, 0x000001 | 0x000002 | 0x000004 | 0x000008),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TREF, tref, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MDIA, mdia, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MFRA, mfra, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MFRO, mfro, \"mfra\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TFRA, tfra, \"mfra\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ELNG, elng, \"mdia\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PDIN, pdin, \"file\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SBGP, sbgp, \"stbl traf\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", 2),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_CSGP, csgp, \"stbl traf\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIZ, saiz, \"stbl traf\", 0, 0),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIZ, saiz, \"stbl traf\", 0, 1),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIO, saio, \"stbl traf\", 1, 0),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIO, saio, \"stbl traf\", 1, 1),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_SUBS, subs, \"stbl traf\", 0, 7), //warning flags are not used as a bit mask but as an enum!!\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRGR, trgr, \"trak\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FTYP, ftyp, \"file otyp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_OTYP, def_parent, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PADB, padb, \"stbl\", 0),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_BTRT, btrt, \"sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PASP, pasp, \"video_sample_entry ipco\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_CLAP, clap, \"video_sample_entry ipco\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_META, meta, \"file moov trak moof traf udta\"),\t//apple uses meta in moov->udta\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_XML, xml, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_BXML, bxml, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ILOC, iloc, \"meta\", 2),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PITM, pitm, \"meta\", 1),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IPRO, ipro, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_INFE, infe, \"iinf\", 3),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IINF, iinf, \"meta\", 1),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IREF, iref, \"meta\", 1),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SINF, sinf, \"ipro sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RINF, sinf, \"sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FRMA, frma, \"sinf rinf\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SCHM, schm, \"sinf rinf\", 0, 1),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SCHI, schi, \"sinf rinf\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCA, audio_sample_entry, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCV, video_sample_entry, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_RESV, video_sample_entry, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TSEL, tsel, \"udta\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STRK, strk, \"udta\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STRI, stri, \"strk\", 0),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_STRD, def_parent, \"strk\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSG, stsg, \"strd\", 0),\n\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCS, mp4s, \"stsd\"),\n\t//THIS HAS TO BE FIXED, not extensible\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCT, mp4s, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCM, mp4s, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCF, mp4s, \"stsd\"),\n\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_METX, metx, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_METT, metx, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STVI, stvi, \"schi\", 0),\n\n\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CHNL, chnl, \"audio_sample_entry\", 0),\n\n\t//FEC\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_FIIN, fiin, \"meta\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_PAEN, paen, \"fiin\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FPAR, fpar, \"paen\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FECR, fecr, \"paen\", 1),\n\t//fire uses the same box syntax as fecr\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FIRE, fecr, \"paen\", 1),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SEGR, segr, \"fiin\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_GITN, gitn, \"fiin\", 0),\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_FDSA, fdsa, \"fdp_sample\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FDPA, fdpa, \"fdsa\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_EXTR, extr, \"fdsa\"),\n#endif\n\n\t//full boxes todo\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_ASSP, assp, 1),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_MERE, assp, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_SRAT, srat, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_CHNL, chnl, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_DMIX, dmix, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_TLOU, alou, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_ALOU, alou, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_URI, uri, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_URII, urii, 0),\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SRTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FDP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RRTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTCP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_HNTI, hnti, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SDP, sdp, \"hnti\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_HINF, hinf, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TRPY, trpy, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NUMP, nump, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TPYL, tpyl, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TOTL, totl, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NPCK, npck, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TPAY, tpay, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_MAXR, maxr, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DMED, dmed, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DIMM, dimm, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DREP, drep, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TMIN, tmin, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TMAX, tmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PMAX, pmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DMAX, dmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PAYT, payt, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTP, rtp_hnti, \"hnti\"),\n\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTPO, rtpo, \"rtp_packet\"),\n\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RELY, rely, \"rtp srtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TIMS, tims, \"rtp srtp rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TSRO, tsro, \"rtp srtp rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SNRO, snro, \"rtp srtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NAME, name, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TSSY, tssy, \"rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RSSR, rssr, \"rrtp\"),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SRPP, srpp, \"srtp\", 0),\n\n#endif\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MVEX, mvex, \"moov\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MEHD, mehd, \"mvex\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TREX, trex, \"mvex\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_LEVA, leva, \"mvex\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TREP, trep, \"mvex\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MOOF, moof, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MFHD, mfhd, \"moof\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRAF, traf, \"moof\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TFHD, tfhd, \"traf\", 0, 0x000001|0x000002|0x000008|0x000010|0x000020|0x010000|0x020000),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TRUN, trun, \"traf\", 0, 0x000001|0x000004|0x000100|0x000200|0x000400|0x000800),\n#ifdef GF_ENABLE_CTRN\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_CTRN, trun, \"traf\", 0, 0),\n#endif\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TFDT, tfdt, \"traf\", 1),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_STYP, ftyp, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PRFT, prft, \"file\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SIDX, sidx, \"file\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SSIX, ssix, \"file\", 0),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PCRB, pcrb, \"file\", \"dash\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_EMSG, emsg, \"file\", 1, \"dash\"),\n#endif\n\n\n\t//part14 boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IODS, iods, \"moov\", 0, \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4S, mp4s, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4V, video_sample_entry, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4A, audio_sample_entry, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_M4DS, m4ds, \"sample_entry\", \"p14\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ESDS, esds, \"mp4a mp4s mp4v encv enca encs resv wave\", 0, \"p14\"),\n\n\t//part 15 boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AVCC, avcc, \"avc1 avc2 avc3 avc4 encv resv ipco dva1 dvav\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SVCC, avcc, \"avc1 avc2 avc3 avc4 svc1 svc2 encv resv\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MVCC, avcc, \"avc1 avc2 avc3 avc4 mvc1 mvc2 encv resv\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HVCC, hvcc, \"hvc1 hev1 hvc2 hev2 encv resv ipco dvh1 dvhe\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_LHVC, hvcc, \"hvc1 hev1 hvc2 hev2 lhv1 lhe1 encv resv ipco\", \"p15\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VVCC, vvcc, \"vvc1 vvi1 encv resv ipco dvhe\", 0, \"p15\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VVNC, vvnc, \"vvs1 encv resv ipco dvhe\", 0, \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC3, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC4, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_SVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HEV1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVC2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HEV2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LHV1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LHE1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVT1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVI1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVS1, video_sample_entry, \"stsd\", \"p15\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MVCI, def_parent_full, \"minf\", 0, \"p15\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MVCG, mvcg, \"mvci\", 0, \"p15\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VWID, vwid, \"video_sample_entry\", 0, \"p15\"),\n\n\t//mpegh 3D audio boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHA1, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHA2, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHM1, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHM2, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MHAC, mhac, \"mha1 mha2 mhm1 mhm2 wave\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MHAP, mhap, \"mha1 mha2 mhm1 mhm2 wave\", \"mpegh3Daudio\"),\n\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_IPCM, audio_sample_entry, \"stsd\", \"23003_5\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_FPCM, audio_sample_entry, \"stsd\", \"23003_5\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PCMC, pcmC, \"ipcm fpcm\", 0, \"23003_5\"),\n\n\t//AV1 in ISOBMFF boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_AV01, video_sample_entry, \"stsd\", \"av1\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_AV1C, av1c, \"av01 encv resv ipco dav1\", \"av1\"),\n\n\t// VP8-9 boxes\n\tFBOX_DEFINE_FLAGS_S( GF_ISOM_BOX_TYPE_VPCC, vpcc, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VP08, video_sample_entry, \"stsd\", \"vp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VP09, video_sample_entry, \"stsd\", \"vp\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_SMDM, SmDm, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_COLL, CoLL, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\n\t//Opus in ISOBMFF boxes\n#ifndef GPAC_DISABLE_OGG\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_OPUS, audio_sample_entry, \"stsd\", \"Opus\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DOPS, dOps, \"Opus wave enca\", \"Opus\"),\n#endif\n\n\t//part20 boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LSR1, lsr1, \"stsd\", \"p20\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_LSRC, lsrc, \"lsr1\", \"p20\"),\n\n\t//part30 boxes\n#ifndef GPAC_DISABLE_TTXT\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STXT, metx, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TXTC, txtc, \"stxt mett sbtt\", 0),\n\t//we allow mime in any sample entry, not restricted in the spec ...\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MIME, txtc, \"sample_entry\", 0),\n#ifndef GPAC_DISABLE_VTT\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_WVTT, wvtt, \"stsd\", \"p30\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VTCC_CUE, vtcu, \"vtt_sample\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTE, vtte, \"vtt_sample\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTC_CONFIG, boxstring, \"wvtt\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CTIM, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IDEN, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_STTG, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PAYL, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTA, boxstring, \"vttc\", \"p30\"),\n#endif\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STPP, metx, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SBTT, metx, \"stsd\"),\n#endif\n\n\t//Image File Format\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_IPRP, iprp, \"meta\", \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IPCO, ipco, \"iprp\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISPE, ispe, \"ipco\", 0, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_COLR, colr, \"video_sample_entry ipco encv resv\", \"iff\"),\n\t//defined as a secondary box for now to avoid conflicts with master hashes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_COLR, colr, \"jp2h\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PIXI, pixi, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_RLOC, rloc, \"ipco\", 0, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IROT, irot, \"ipco\", \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IMIR, imir, \"ipco\", \"iff\"),\n\tFBOX_DEFINE_FLAGS_S( GF_ISOM_BOX_TYPE_IPMA, ipma, \"iprp\", 1, 1, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GRPL, grpl, \"meta\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CCST, ccst, \"sample_entry\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AUXI, auxi, \"sample_entry\", 0, \"iff\"),\n\tTRGT_DEFINE(GF_ISOM_BOX_TYPE_GRPT, grptype, \"grpl\", GF_ISOM_BOX_TYPE_ALTR, 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AUXC, auxc, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_OINF, oinf, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TOLS, tols, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IENC, ienc, \"ipco\", 0, \"cenc\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IAUX, iaux, \"ipco\", 0, \"cenc\"),\n\n\t//MIAF\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_CLLI, clli, \"video_sample_entry ipco encv resv\", \"p12\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MDCV, mdcv, \"video_sample_entry ipco encv resv\", \"p12\"),\n\n\t//AVIF\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_A1LX, a1lx, \"ipco\", \"avif\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_A1OP, a1op, \"ipco\", \"avif\"),\n\n\t//other MPEG boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_RVCC, rvcc, \"avc1 avc2 avc3 avc4 svc1 svc2 hvc1 hev1 hvc2 hev2 lhv1 lhe1 encv resv\", \"rvc\"),\n\n\t//3GPP boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_AMR, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_AMR_WB, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_QCELP, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_EVRC, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_SMV, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_H263, video_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DAMR, gppc, \"samr sawb enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DEVC, gppc, \"sevc enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DQCP, gppc, \"sqcp enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DSMV, gppc, \"ssmv enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_D263, gppc, \"s263 encv\", \"3gpp\"),\n\t//3gpp timed text\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_TX3G, tx3g, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TEXT, text, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_FTAB, ftab, \"tx3g text enct\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_STYL, styl, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HLIT, hlit, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HCLR, hclr, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_KROK, krok, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DLAY, dlay, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HREF, href, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TBOX, tbox, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_BLNK, blnk, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TWRP, twrp, \"text_sample\", \"3gpp\"),\n\t//3GPP dims\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_DIMS, dims, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DIMC, dimC, \"dims encs\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DIST, diST, \"dims\", \"3gpp\"),\n\n\n\t//CENC boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PSSH, pssh, \"moov moof meta\", 0, \"cenc\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TENC, tenc, \"schi\", 1, \"cenc\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SENC, senc, \"trak traf\", \"cenc\"),\n\n\t// ISMA 1.1 boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IKMS, iKMS, \"schi\", 0, \"isma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISFM, iSFM, \"schi\", 0, \"isma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISLT, iSLT, \"schi\", 0, \"isma\"),\n\n\t//OMA boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODKM, odkm, \"schi\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_OHDR, ohdr, \"odkm\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GRPI, grpi, \"ohdr\", 0, \"oma\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MDRI, mdri, \"file\", \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODTT, odtt, \"mdri\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODRB, odrb, \"mdri\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODAF, iSFM, \"schi\", 0, \"oma\"),\n\n\t//apple boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP3, audio_sample_entry, \"stsd\", \"apple\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CHPL, chpl, \"udta\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VOID, void, \"\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_WIDE, wide, \"*\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ILST, ilst, \"meta\", \"apple\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DATA, databox, \"ilst *\", 0, \"apple\"),\n\n\tITUNES_TAG(GF_ISOM_ITUNE_NAME),\n\tITUNES_TAG(GF_ISOM_ITUNE_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_ALBUM_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_ALBUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_GROUP),\n\tITUNES_TAG(GF_ISOM_ITUNE_WRITER),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMMENT),\n\tITUNES_TAG(GF_ISOM_ITUNE_GENRE_USER),\n\tITUNES_TAG(GF_ISOM_ITUNE_GENRE),\n\tITUNES_TAG(GF_ISOM_ITUNE_CREATED),\n\tITUNES_TAG(GF_ISOM_ITUNE_TRACKNUMBER),\n\tITUNES_TAG(GF_ISOM_ITUNE_DISK),\n\tITUNES_TAG(GF_ISOM_ITUNE_TEMPO),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMPILATION),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_SHOW),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_EPISODE),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_SEASON),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_EPISODE_NUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_NETWORK),\n\tITUNES_TAG(GF_ISOM_ITUNE_DESCRIPTION),\n\tITUNES_TAG(GF_ISOM_ITUNE_LONG_DESCRIPTION),\n\tITUNES_TAG(GF_ISOM_ITUNE_LYRICS),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_NAME),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ALB_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ALBUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_COMPOSER),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_SHOW),\n\tITUNES_TAG(GF_ISOM_ITUNE_COVER_ART),\n\tITUNES_TAG(GF_ISOM_ITUNE_COPYRIGHT),\n\tITUNES_TAG(GF_ISOM_ITUNE_TOOL),\n\tITUNES_TAG(GF_ISOM_ITUNE_ENCODER),\n\tITUNES_TAG(GF_ISOM_ITUNE_PURCHASE_DATE),\n\tITUNES_TAG(GF_ISOM_ITUNE_PODCAST),\n\tITUNES_TAG(GF_ISOM_ITUNE_PODCAST_URL),\n\tITUNES_TAG(GF_ISOM_ITUNE_KEYWORDS),\n\tITUNES_TAG(GF_ISOM_ITUNE_CATEGORY),\n\tITUNES_TAG(GF_ISOM_ITUNE_HD_VIDEO),\n\tITUNES_TAG(GF_ISOM_ITUNE_MEDIA_TYPE),\n\tITUNES_TAG(GF_ISOM_ITUNE_RATING),\n\tITUNES_TAG(GF_ISOM_ITUNE_GAPLESS),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMPOSER),\n\tITUNES_TAG(GF_ISOM_ITUNE_TRACK),\n\tITUNES_TAG(GF_ISOM_ITUNE_CONDUCTOR),\n\tITUNES_TAG(GF_ISOM_ITUNE_ART_DIRECTOR),\n\tITUNES_TAG(GF_ISOM_ITUNE_ARRANGER),\n\tITUNES_TAG(GF_ISOM_ITUNE_LYRICIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_COPY_ACK),\n\tITUNES_TAG(GF_ISOM_ITUNE_SONG_DESC),\n\tITUNES_TAG(GF_ISOM_ITUNE_DIRECTOR),\n\tITUNES_TAG(GF_ISOM_ITUNE_EQ_PRESET),\n\tITUNES_TAG(GF_ISOM_ITUNE_LINER_NOTES),\n\tITUNES_TAG(GF_ISOM_ITUNE_REC_COMPANY),\n\tITUNES_TAG(GF_ISOM_ITUNE_ORIG_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_PHONO_RIGHTS),\n\tITUNES_TAG(GF_ISOM_ITUNE_PRODUCER),\n\tITUNES_TAG(GF_ISOM_ITUNE_PERFORMER),\n\tITUNES_TAG(GF_ISOM_ITUNE_PUBLISHER),\n\tITUNES_TAG(GF_ISOM_ITUNE_SOUND_ENG),\n\tITUNES_TAG(GF_ISOM_ITUNE_SOLOIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_CREDITS),\n\tITUNES_TAG(GF_ISOM_ITUNE_THANKS),\n\tITUNES_TAG(GF_ISOM_ITUNE_ONLINE),\n\tITUNES_TAG(GF_ISOM_ITUNE_EXEC_PRODUCER),\n\tITUNES_TAG(GF_ISOM_ITUNE_LOCATION),\n\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_iTunesSpecificInfo, ilst_item, \"ilst data\", \"apple\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_GMHD, def_parent, \"minf\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_LOAD, load, \"trak\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_TAPT, def_parent, \"trak\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_GMIN, gmin, \"gmhd\", 0, \"apple\"),\n\tFBOX_DEFINE_FLAGS_S( GF_QT_BOX_TYPE_ALIS, alis, \"dref\", 0, 1, \"apple\"),\n\tFBOX_DEFINE_FLAGS_S( GF_QT_BOX_TYPE_CIOS, alis, \"dref\", 0, 1, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_CLEF, clef, \"tapt\", 0, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_PROF, clef, \"tapt\", 0, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_ENOF, clef, \"tapt\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_WAVE, def_parent, \"audio_sample_entry\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_CHAN, chan, \"audio_sample_entry\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_FRMA, frma, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TERMINATOR, unkn, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_ENDA, chrm, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TMCD, def_parent, \"gmhd\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_NAME, unkn, \"tmcd\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_TCMI, tcmi, \"tmcd\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_FIEL, fiel, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_GAMA, gama, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_CHRM, chrm, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_SUBTYPE_TEXT, unkn, \"gmhd\", \"apple\"),\n\n\t//QT and prores sample entry types\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TMCD, tmcd, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_SUBTYPE_C608, gen_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCH, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCO, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCS, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCN, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_AP4X, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_AP4H, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RAW_AUD, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_TWOS, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_SOWT, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_FL32, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_FL64, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IN24, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IN32, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ULAW, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ALAW, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ADPCM, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IMA_ADPCM, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_DVCA, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QDMC, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QDMC2, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QCELP, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_kMP3, audio_sample_entry, \"stsd\", \"apple\"),\n\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RAW_VID, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUYV, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_UYVY, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV444, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUVA444, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV422_10, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV444_10, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV422_16, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV420, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_I420, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IYUV, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YV12, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YVYU, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RGBA, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ABGR, video_sample_entry, \"stsd\", \"apple\"),\n\t\n\tFBOX_DEFINE_S(GF_QT_BOX_TYPE_STPS, stss, \"stbl\", 0, \"apple\"),\n\n\t//dolby boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AC3, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_EC3, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DAC3, dac3, \"ac-3 wave enca\", \"dolby\"),\n\t{GF_ISOM_BOX_TYPE_DEC3, dec3_box_new, dac3_box_del, dac3_box_read, dac3_box_write, dac3_box_size, dac3_box_dump, 0, 0, 0, \"ec-3 wave enca\", \"dolby\" },\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DVCC, dvcC, \"dvav dva1 dvhe dvh1 dav1 avc1 avc2 avc3 avc4 hev1 hvc1 av01 encv resv\", \"DolbyVision\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DVVC, dvvC, \"dvav dva1 dvhe dvh1 dav1 avc1 avc2 avc3 avc4 hev1 hvc1 av01 encv resv\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVHE, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVH1, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVA1, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVAV, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DAV1, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MLPA, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DMLP, dmlp, \"mlpa enca\", \"dolby\"),\n\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HVCE, hvcc, \"hvc1 hev1 hvc2 hev2 encv resv ipco dvh1 dvhe\", \"DolbyVision\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AVCE, avcc, \"avc1 avc2 avc3 avc4 encv resv ipco dva1 dvav\", \"DolbyVision\"),\n\n\n\t//Adobe boxes\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ABST, abst, \"file\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AFRA, afra, \"file\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ASRT, asrt, \"abst\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AFRT, afrt, \"abst\", 0, \"adobe\"),\n#endif\n\t/*Adobe's protection boxes*/\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_ADKM, adkm, \"schi\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AHDR, ahdr, \"adkm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ADAF, adaf, \"adkm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_APRM, aprm, \"ahdr\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AEIB, aeib, \"aprm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AKEY, akey, \"aprm\", 0, \"adobe\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_FLXS, flxs, \"akey\", \"adobe\"),\n\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TRIK, trik, \"traf\", 0, \"dece\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_BLOC, bloc, \"file\", 0, \"dece\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_AINF, ainf, \"moov\", 0, 0x000001, \"dece\"),\n\n\n\t//internally handled UUID for smooth - the code points are only used during creation and assigned to UUIDBox->internal4CC\n\t//the box type is still \"uuid\", and the factory is used to read/write/size/dump the code\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TENC, piff_tenc, \"schi\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_PSEC, piff_psec, \"trak traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_PSSH, piff_pssh, \"moov moof\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFXD, tfxd, \"traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFRF, tfrf, \"traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_MSSM, uuid, \"file\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFRF, uuid, \"traf\", \"smooth\"),\n\n\n\t//J2K boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_MJP2, video_sample_entry, \"stsd\", \"j2k\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JP2H, jp2h, \"mjp2 encv\", \"j2k\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_IHDR, ihdr, \"jp2h\", \"j2k\"),\n\n\t/* Image tracks */\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JPEG, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JP2K, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_PNG, video_sample_entry, \"stsd\", \"apple\"),\n\n\n\t//flac in ISOBMFF boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_FLAC, audio_sample_entry, \"stsd\", \"Flac\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DFLA, dfla, \"fLaC enca\", 0, \"Flac\"),\n\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_XTRA, xtra, \"udta\", \"WMA\"),\n\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ST3D, st3d, \"video_sample_entry\", 0, \"youtube\"),\n\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SV3D, def_parent, \"video_sample_entry\", \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SVHD, svhd, \"sv3d\", 0, \"youtube\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PROJ, def_parent, \"sv3d\", \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PRHD, prhd, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CBMP, proj_type, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_EQUI, proj_type, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MESH, proj_type, \"proj\", 0, \"youtube\"),\n\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_KEYS, keys, \"meta\", 0, \"apple\"),\n\n\tBOX_DEFINE_S(GF_QT_SUBTYPE_ALAC, unkn, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S(GF_ISOM_SUBTYPE_FFV1, unkn, \"stsd\", \"ffmpeg\"),\n\n\tBOX_DEFINE_S(GF_4CC('v','c','-','1'), unkn, \"stsd\", \"smpte-RP2025\"),\n\tBOX_DEFINE_S(GF_4CC('d','v','c','1'), unkn, \"vc-1 ipco\", \"smpte-RP2025\"),\n\n\tBOX_DEFINE_S(GF_4CC('G','M','C','W'), unkn, \"stsd\", \"GPAC\"),\n\tBOX_DEFINE_S(GF_4CC('G','M','C','C'), unkn, \"GMCW\", \"GPAC\"),\n\n\t/* for now we don't parse these*/\n\tBOX_DEFINE_S(GF_4CC('u','n','c','C'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('c','m','p','d'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('c','p','a','l'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('c','p','a','t'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('c','l','e','v'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('s','p','l','z'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('s','n','u','c'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('s','b','p','m'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('c','l','o','c'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('f','p','c','k'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('d','i','s','i'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('d','e','p','i'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\n/*\n\tGF_ISOM_BOX_TYPE_CBMP\t= GF_4CC( 'c', 'b', 'm', 'p' ),\n\tGF_ISOM_BOX_TYPE_EQUI\t= GF_4CC( 'e', 'q', 'u', 'i' ),\n\tGF_ISOM_BOX_TYPE_MSHP\t= GF_4CC( 'm', 's', 'h', 'p' ),\n\tGF_ISOM_BOX_TYPE_MESH\t= GF_4CC( 'm', 'e', 's', 'h' ),\n*/\n\n};\n\nBool gf_box_valid_in_parent(GF_Box *a, const char *parent_4cc)\n{\n\tif (!a || !a->registry || !a->registry->parents_4cc) return GF_FALSE;\n\tif (strstr(a->registry->parents_4cc, parent_4cc) != NULL) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_num_supported_boxes()\n{\n\treturn sizeof(box_registry) / sizeof(struct box_registry_entry);\n}\n\nvoid gf_isom_registry_disable(u32 boxCode, Bool disable)\n{\n\tu32 i=0, count = gf_isom_get_num_supported_boxes();\n\tfor (i=1; i<count; i++) {\n\t\tif (box_registry[i].box_4cc==boxCode) {\n\t\t\tbox_registry[i].disabled = disable;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic u32 get_box_reg_idx(u32 boxCode, u32 parent_type, u32 start_from)\n{\n\tu32 i=0, count = gf_isom_get_num_supported_boxes();\n\tif (!start_from) start_from = 1;\n\n\tfor (i=start_from; i<count; i++) {\n\t\tu32 start_par_from;\n\t\tif (box_registry[i].box_4cc != boxCode)\n\t\t\tcontinue;\n\n\t\tif (!parent_type)\n\t\t\treturn i;\n\t\tif (strstr(box_registry[i].parents_4cc, gf_4cc_to_str(parent_type)) != NULL)\n\t\t\treturn i;\n\t\tif (strstr(box_registry[i].parents_4cc, \"*\") != NULL)\n\t\t\treturn i;\n\n\t\tif (strstr(box_registry[i].parents_4cc, \"sample_entry\") == NULL)\n\t\t\tcontinue;\n\n\t\t/*parent is a sample entry, check if the parent_type matches a sample entry box (eg its parent must be stsd)*/\n\n\t\tif (parent_type==GF_QT_SUBTYPE_RAW)\n\t\t\treturn i;\n\n\t\tstart_par_from = 0;\n\t\twhile (parent_type) {\n\t\t\t//locate parent registry\n\t\t\tu32 j = get_box_reg_idx(parent_type, 0, start_par_from);\n\t\t\tif (!j) break;\n\t\t\t//if parent registry has \"stsd\" as parent, this is a sample entry\n\t\t\tif (box_registry[j].parents_4cc && (strstr(box_registry[j].parents_4cc, \"stsd\") != NULL))\n\t\t\t\treturn i;\n\t\t\tstart_par_from = j+1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nGF_Box *gf_isom_box_new_ex(u32 boxType, u32 parentType, Bool skip_logs, Bool is_root_box)\n{\n\tGF_Box *a;\n\ts32 idx = get_box_reg_idx(boxType, parentType, 0);\n\tif (idx==0) {\n#ifndef GPAC_DISABLE_LOG\n\t\tif (!skip_logs && (boxType != GF_ISOM_BOX_TYPE_UNKNOWN) && (boxType != GF_ISOM_BOX_TYPE_UUID)) {\n\t\t\tswitch (parentType) {\n\t\t\tcase GF_ISOM_BOX_TYPE_ILST:\n\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tcase GF_ISOM_BOX_TYPE_iTunesSpecificInfo:\n\t\t\tcase GF_QT_BOX_TYPE_WAVE:\n\t\t\t\tbreak;\n\t\t\t//some sample descritions are handled as generic ones but we know them, don't warn\n\t\t\tcase GF_ISOM_BOX_TYPE_STSD:\n\t\t\t\t//fallthrough\n\t\t\tdefault:\n\t\t\t\tif (boxType==GF_ISOM_BOX_TYPE_GDAT) break;\n\n\t\t\t\tif (is_root_box) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown top-level box type %s\\n\", gf_4cc_to_str(boxType)));\n\t\t\t\t} else if (parentType) {\n\t\t\t\t\tchar szName[GF_4CC_MSIZE];\n\t\t\t\t\tstrcpy(szName, gf_4cc_to_str(parentType));\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown box type %s in parent %s\\n\", gf_4cc_to_str(boxType), szName));\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown box type %s\\n\", gf_4cc_to_str(boxType)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n        if (boxType==GF_ISOM_BOX_TYPE_UUID) {\n            a = uuid_box_new();\n            if (a) a->registry = &box_registry[1];\n        } else {\n            a = unkn_box_new();\n            if (a) {\n            \t((GF_UnknownBox *)a)->original_4cc = boxType;\n            \ta->registry = &box_registry[0];\n\t\t\t}\n        }\n\t\treturn a;\n\t}\n\ta = box_registry[idx].new_fn();\n\n\tif (a) {\n\t\tif (a->type!=GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t\t((GF_UnknownBox *)a)->original_4cc = boxType;\n\t\t\t} else {\n\t\t\t\ta->type = boxType;\n\t\t\t}\n\t\t}\n\t\ta->registry = &box_registry[idx];\n\n\t\tif ((a->type==GF_ISOM_BOX_TYPE_COLR) && (parentType==GF_ISOM_BOX_TYPE_JP2H)) {\n\t\t\t((GF_ColourInformationBox *)a)->is_jp2 = GF_TRUE;\n\t\t}\n\n\t}\n\treturn a;\n}\n\nGF_EXPORT\nGF_Box *gf_isom_box_new(u32 boxType)\n{\n\treturn gf_isom_box_new_ex(boxType, 0, 0, GF_FALSE);\n}\n\nGF_Err gf_isom_box_array_read(GF_Box *parent, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 parent_type = parent->type;\n\tGF_Box *a = NULL;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (parent->size>=8) {\n\t\te = gf_isom_box_parse_ex(&a, bs, parent_type, GF_FALSE, skip_logs ? 0 : parent->size);\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn (e==GF_SKIP_BOX) ? GF_OK : e;\n\t\t}\n\t\t//sub box parsing aborted with no error\n\t\tif (!a) return GF_OK;\n\n\t\tif (parent->size < a->size) {\n\t\t\tif (!skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is larger than container box\\n\", gf_4cc_to_str(a->type)));\n\t\t\t}\n\t\t\tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tparent->size = 0;\n\t\t} else {\n\t\t\tparent->size -= a->size;\n\t\t}\n\n\t\t//check container validity\n\t\tif (parent_type && strlen(a->registry->parents_4cc)) {\n\t\t\tBool parent_OK = GF_FALSE;\n\t\t\tconst char *parent_code = gf_4cc_to_str(parent->type);\n\t\t\tif (parent->type == GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\tparent_code = gf_4cc_to_str( ((GF_UnknownBox*)parent)->original_4cc );\n\t\t\tif (strstr(a->registry->parents_4cc, parent_code) != NULL) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else if (!strcmp(a->registry->parents_4cc, \"*\") || strstr(a->registry->parents_4cc, \"* \") || strstr(a->registry->parents_4cc, \" *\")) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else {\n\t\t\t\t//parent must be a sample entry\n\t\t\t\tif (strstr(a->registry->parents_4cc, \"sample_entry\") !=\tNULL) {\n\t\t\t\t\t//parent is in an stsd\n\t\t\t\t\tif (strstr(parent->registry->parents_4cc, \"stsd\") != NULL) {\n\t\t\t\t\t\tif (strstr(a->registry->parents_4cc, \"video_sample_entry\") !=\tNULL) {\n\t\t\t\t\t\t\tif (((GF_SampleEntryBox*)parent)->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//other types are sample formats, eg a 3GPP text sample, RTP hint sample or VTT cue. Not handled at this level\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) parent_OK = GF_TRUE;\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UUID) parent_OK = GF_TRUE;\n\t\t\t}\n\t\t\tif (! parent_OK && !skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is invalid in container %s\\n\", gf_4cc_to_str(a->type), parent_code));\n\t\t\t}\n\t\t}\n\n\t\t//always register boxes\n\t\tif (!parent->child_boxes) {\n\t\t\tparent->child_boxes = gf_list_new();\n\t\t\tif (!parent->child_boxes) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(parent->child_boxes, a);\n\t\tif (e) return e;\n\n\t\tif (parent->registry && parent->registry->add_rem_fn) {\n\t\t\te = parent->registry->add_rem_fn(parent, a, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\tif (e == GF_ISOM_INVALID_MEDIA) return GF_OK;\n\t\t\t\t//if the box is no longer present, consider it destroyed\n\t\t\t\tif (gf_list_find(parent->child_boxes, a) >=0) {\n\t\t\t\t\tgf_isom_box_del_parent(&parent->child_boxes, a);\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\n\n\nGF_Err gf_isom_box_read(GF_Box *a, GF_BitStream *bs)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn a->registry->read_fn(a, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gf_isom_box_write_listing(GF_Box *a, GF_BitStream *bs)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Write invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn a->registry->write_fn(a, bs);\n}\n\n\nvoid gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\n\t//happens when partially cloning boxes \n\tif (cur_pos < 0) return;\n\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;\n}\n\nvoid gf_isom_check_position_list(GF_Box *s, GF_List *childlist, u32 *pos)\n{\n\tu32 i, count;\n\tif (!s || (s->internal_flags & GF_ISOM_ORDER_FREEZE))\n\t\treturn;\n\tcount = gf_list_count(childlist);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *child = gf_list_get(childlist, i);\n\t\tgf_isom_check_position(s, child, pos);\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\t//box has been disabled, do not write\n\tif (!a->size) return GF_OK;\n\t\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;\n}\n\nstatic GF_Err gf_isom_box_size_listing(GF_Box *a)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Size invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\ta->size = 8;\n\n\tif (a->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\ta->size += 16;\n\t}\n\t//the large size is handled during write, cause at this stage we don't know the size\n\tif (a->registry->max_version_plus_one) {\n\t\ta->size += 4;\n\t}\n\treturn a->registry->size_fn(a);\n}\n\nGF_EXPORT\nGF_Err gf_isom_box_size(GF_Box *a)\n{\n\tGF_Err e;\n\tif (!a) return GF_BAD_PARAM;\n\tif (a->registry->disabled) {\n\t\ta->size = 0;\n\t\treturn GF_OK;\n\t}\n\te = gf_isom_box_size_listing(a);\n\tif (e) return e;\n\t//box size set to 0 (not even a header), abort traversal\n\tif (!a->size) return GF_OK;\n\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_size(a, a->child_boxes);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nstatic GF_Err gf_isom_full_box_read(GF_Box *ptr, GF_BitStream *bs)\n{\n\tif (ptr->registry->max_version_plus_one) {\n\t\tGF_FullBox *self = (GF_FullBox *) ptr;\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tself->version = gf_bs_read_u8(bs);\n\t\tself->flags = gf_bs_read_u24(bs);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_dump_supported_box(u32 idx, FILE * trace)\n{\n\tu32 i;\n\tu32 nb_versions=0;\n\tGF_Err e;\n\n\tif (box_registry[idx].max_version_plus_one) {\n\t\tnb_versions = box_registry[idx].max_version_plus_one - 1;\n\t}\n\tfor (i = 0; i <= nb_versions; i++) {\n\t\tGF_Box *a = box_registry[idx].new_fn();\n\t\tif (!a) return GF_OUT_OF_MEM;\n\n\t\ta->registry = &box_registry[idx];\n\n\t\tif (box_registry[idx].alt_4cc) {\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_REFT)\n\t\t\t\t((GF_TrackReferenceTypeBox*)a)->reference_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_REFI)\n\t\t\t\t((GF_ItemReferenceTypeBox*)a)->reference_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_TRGT)\n\t\t\t\t((GF_TrackGroupTypeBox*)a)->group_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_SGPD)\n\t\t\t\t((GF_SampleGroupDescriptionBox*)a)->grouping_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_GRPT)\n\t\t\t\t((GF_EntityToGroupTypeBox*)a)->grouping_type = box_registry[idx].alt_4cc;\n\t\t}\n\t\tif (box_registry[idx].max_version_plus_one) {\n\t\t\t((GF_FullBox *)a)->version = i;\n\t\t}\n\t\tif (box_registry[idx].flags) {\n\t\t\tu32 flag_mask=1;\n\t\t\tu32 flags = box_registry[idx].flags;\n\t\t\t((GF_FullBox *)a)->flags = 0;\n\t\t\te = gf_isom_box_dump(a, trace);\n\n\t\t\t//we dump all flags individually and this for all version, in order to simplify the XSLT processing\n\t\t\twhile (!e) {\n\t\t\t\tu32 flag = flags & flag_mask;\n\t\t\t\tflag_mask <<= 1;\n\t\t\t\tif (flag) {\n\t\t\t\t\t((GF_FullBox *)a)->flags = flag;\n\t\t\t\t\te = gf_isom_box_dump(a, trace);\n\t\t\t\t}\n\t\t\t\tif (flag_mask > flags) break;\n\t\t\t\tif (flag_mask == 0x80000000) break;\n\t\t\t}\n\n\t\t} else {\n\t\t\te = gf_isom_box_dump(a, trace);\n\t\t}\n\n\t\tgf_isom_box_del(a);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nu32 gf_isom_get_supported_box_type(u32 idx)\n{\n\treturn box_registry[idx].box_4cc;\n}\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\nGF_Err gf_isom_box_dump_start_ex(GF_Box *a, const char *name, FILE * trace, Bool force_version)\n{\n\tgf_fprintf(trace, \"<%s \", name);\n\tif (a->size > 0xFFFFFFFF) {\n\t\tgf_fprintf(trace, \"LargeSize=\\\"\"LLU\"\\\" \", a->size);\n\t} else {\n\t\tgf_fprintf(trace, \"Size=\\\"%u\\\" \", (u32) a->size);\n\t}\n\tif (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tgf_fprintf(trace, \"Type=\\\"%s\\\" \", gf_4cc_to_str(((GF_UnknownBox*)a)->original_4cc));\n\t} else {\n\t\tgf_fprintf(trace, \"Type=\\\"%s\\\" \", gf_4cc_to_str(a->type));\n\t}\n\n\tif (a->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\tu32 i;\n\t\tgf_fprintf(trace, \"UUID=\\\"{\");\n\t\tfor (i=0; i<16; i++) {\n\t\t\tgf_fprintf(trace, \"%02X\", (unsigned char) ((GF_UUIDBox*)a)->uuid[i]);\n\t\t\tif ((i<15) && (i%4)==3) gf_fprintf(trace, \"-\");\n\t\t}\n\t\tgf_fprintf(trace, \"}\\\" \");\n\t}\n\n\tif (a->registry->max_version_plus_one || force_version) {\n\t\tgf_fprintf(trace, \"Version=\\\"%d\\\" Flags=\\\"%d\\\" \", ((GF_FullBox*)a)->version,((GF_FullBox*)a)->flags);\n\t}\n\tgf_fprintf(trace, \"Specification=\\\"%s\\\" \", a->registry->spec);\n\n\t//don't write containers in test mode, that would require rewriting hashes whenever spec changes\n\tif (!gf_sys_is_test_mode()) {\n\t\tgf_fprintf(trace, \"Container=\\\"%s\\\" \", a->registry->parents_4cc);\n\t}\n\treturn GF_OK;\n}\nGF_Err gf_isom_box_dump_start(GF_Box *a, const char *name, FILE * trace)\n{\n\treturn gf_isom_box_dump_start_ex(a, name, trace, GF_FALSE);\n}\n\nGF_Err gf_isom_box_dump(void *ptr, FILE * trace)\n{\n\tGF_Box *a = (GF_Box *) ptr;\n\n\tif (!a) {\n\t\tgf_fprintf(trace, \"<!--ERROR: NULL Box Found-->\\n\");\n\t\treturn GF_OK;\n\t}\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] trying to dump box %s not registered\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\ta->registry->dump_fn(a, trace);\n\treturn GF_OK;\n}\n\nvoid gf_isom_box_dump_done(const char *name, GF_Box *ptr, FILE *trace)\n{\n\tif (ptr && ptr->child_boxes) {\n\t\tgf_isom_box_array_dump(ptr->child_boxes, trace);\n\t}\n\tif (name)\n\t\tgf_fprintf(trace, \"</%s>\\n\", name);\n}\n\nBool gf_isom_box_is_file_level(GF_Box *s)\n{\n\tif (!s || !s->registry) return GF_FALSE;\n\tif (strstr(s->registry->parents_4cc, \"file\")!= NULL) return GF_TRUE;\n\tif (strstr(s->registry->parents_4cc, \"*\")!= NULL) return GF_TRUE;\n\treturn GF_FALSE;\n}\n#endif\n\n\nGF_Box *gf_isom_box_find_child(GF_List *children, u32 code)\n{\n\tu32 i, count;\n\tif (!children) return NULL;\n\tcount = gf_list_count(children);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *c = gf_list_get(children, i);\n\t\tif (c->type==code) return c;\n\n\t\tif (c->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tif (((GF_UnknownBox*)c)->original_4cc==code)\n\t\t\t\treturn c;\n\t\t}\n\t\tif (c->type==GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (((GF_UUIDBox*)c)->internal_4cc==code)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nBool gf_isom_box_check_unique(GF_List *children, GF_Box *a)\n{\n\tu32 i, count;\n\tif (!children) return GF_TRUE;\n\tcount = gf_list_count(children);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *c = gf_list_get(children, i);\n\t\tif (c==a) continue;\n\t\tif (c->type==a->type) return GF_FALSE;\n\t}\n\treturn GF_TRUE;\n}\n\nvoid gf_isom_box_del_parent(GF_List **child_boxes, GF_Box*b)\n{\n\tif (child_boxes) {\n\t\tgf_list_del_item(*child_boxes, b);\n\t\tif (!gf_list_count(*child_boxes)) {\n\t\t\tgf_list_del(*child_boxes);\n\t\t\t*child_boxes = NULL;\n\t\t}\n\t}\n\tgf_isom_box_del(b);\n}\n\nvoid gf_isom_box_remove_from_parent(GF_Box *parent_box, GF_Box *box)\n{\n\tif (parent_box && parent_box->registry && parent_box->registry->add_rem_fn) {\n\t\tparent_box->registry->add_rem_fn(parent_box, box, GF_TRUE);\n\t}\n}\n\nGF_Box *gf_isom_box_new_parent(GF_List **parent, u32 code)\n{\n\tGF_Box *b = gf_isom_box_new(code);\n\tif (!b) return NULL;\n\tif (! (*parent) ) (*parent)  = gf_list_new();\n\tgf_list_add(*parent, b);\n\treturn b;\n}\n\nvoid gf_isom_box_freeze_order(GF_Box *box)\n{\n\tu32 i=0;\n\tGF_Box *child;\n\tif (!box) return;\n\tbox->internal_flags |= GF_ISOM_ORDER_FREEZE;\n\n\twhile ((child = gf_list_enum(box->child_boxes, &i))) {\n\t\tgf_isom_box_freeze_order(child);\n\t}\n\n}\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n//the only static var. Used to store any error happening while opening a movie\nstatic GF_Err MP4_API_IO_Err;\n\nvoid gf_isom_set_last_error(GF_ISOFile *movie, GF_Err error)\n{\n\tif (!movie) {\n\t\tMP4_API_IO_Err = error;\n\t} else {\n\t\tmovie->LastError = error;\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_last_error(GF_ISOFile *the_file)\n{\n\tif (!the_file) return MP4_API_IO_Err;\n\treturn the_file->LastError;\n}\n\nGF_EXPORT\nu8 gf_isom_get_mode(GF_ISOFile *the_file)\n{\n\tif (!the_file) return 0;\n\treturn the_file->openMode;\n}\n\n#if 0 //unused\n/*! gets file size of an ISO file\n\\param isom_file the target ISO file\n\\return the file size in bytes\n*/\nu64 gf_isom_get_file_size(GF_ISOFile *the_file)\n{\n\tif (!the_file) return 0;\n\tif (the_file->movieFileMap) return gf_bs_get_size(the_file->movieFileMap->bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (the_file->editFileMap) return gf_bs_get_size(the_file->editFileMap->bs);\n#endif\n\treturn 0;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_freeze_order(GF_ISOFile *file)\n{\n\tu32 i=0;\n\tGF_Box *box;\n\tif (!file) return GF_BAD_PARAM;\n\twhile ((box=gf_list_enum(file->TopBoxes, &i))) {\n\t\tgf_isom_box_freeze_order(box);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_inplace_padding(GF_ISOFile *file, u32 padding)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->padding = padding;\n\treturn GF_OK;\n}\n/**************************************************************\n\t\t\t\t\tSample Manip\n**************************************************************/\n\n//creates a new empty sample\nGF_EXPORT\nGF_ISOSample *gf_isom_sample_new()\n{\n\tGF_ISOSample *tmp;\n\tGF_SAFEALLOC(tmp, GF_ISOSample);\n\treturn tmp;\n}\n\n//delete a sample\nGF_EXPORT\nvoid gf_isom_sample_del(GF_ISOSample **samp)\n{\n\tif (!samp || ! *samp) return;\n\tif ((*samp)->data && (*samp)->dataLength) gf_free((*samp)->data);\n\tgf_free(*samp);\n\t*samp = NULL;\n}\n\nstatic u32 gf_isom_probe_type(u32 type)\n{\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_FTYP:\n\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\treturn 2;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tcase GF_ISOM_BOX_TYPE_MOOF:\n\tcase GF_ISOM_BOX_TYPE_STYP:\n\tcase GF_ISOM_BOX_TYPE_SIDX:\n\tcase GF_ISOM_BOX_TYPE_EMSG:\n\tcase GF_ISOM_BOX_TYPE_PRFT:\n    //we map free as segment when it is first in the file - a regular file shall start with ftyp or a file sig, not free\n    //since our route stack may patch boxes to free for incomplete segments, we must map this to free\n    case GF_ISOM_BOX_TYPE_FREE:\n\t\treturn 3;\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\t/*Adobe specific*/\n\tcase GF_ISOM_BOX_TYPE_AFRA:\n\tcase GF_ISOM_BOX_TYPE_ABST:\n#endif\n#endif\n\tcase GF_ISOM_BOX_TYPE_MDAT:\n\tcase GF_ISOM_BOX_TYPE_SKIP:\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\tcase GF_ISOM_BOX_TYPE_META:\n\tcase GF_ISOM_BOX_TYPE_VOID:\n\tcase GF_ISOM_BOX_TYPE_JP:\n\tcase GF_QT_BOX_TYPE_WIDE:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nGF_EXPORT\nu32 gf_isom_probe_file_range(const char *fileName, u64 start_range, u64 end_range)\n{\n\tu32 type = 0;\n\n\tif (!strncmp(fileName, \"gmem://\", 7)) {\n\t\tu32 size;\n\t\tu8 *mem_address;\n\t\tif (gf_blob_get(fileName, &mem_address, &size, NULL) != GF_OK) {\n\t\t\treturn 0;\n\t\t}\n        if (size && (size > start_range + 8)) {\n\t\t\ttype = GF_4CC(mem_address[start_range + 4], mem_address[start_range + 5], mem_address[start_range + 6], mem_address[start_range + 7]);\n        }\n        gf_blob_release(fileName);\n\t} else if (!strncmp(fileName, \"isobmff://\", 10)) {\n\t\treturn 2;\n\t} else {\n\t\tu32 nb_read;\n\t\tunsigned char data[4];\n\t\tFILE *f = gf_fopen(fileName, \"rb\");\n\t\tif (!f) return 0;\n\t\tif (start_range) gf_fseek(f, start_range, SEEK_SET);\n\t\ttype = 0;\n\t\tnb_read = (u32) gf_fread(data, 4, f);\n\t\tif (nb_read == 4) {\n\t\t\tif (gf_fread(data, 4, f) == 4) {\n\t\t\t\ttype = GF_4CC(data[0], data[1], data[2], data[3]);\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t\tif (!nb_read) return 0;\n\t}\n\treturn gf_isom_probe_type(type);\n}\n\nGF_EXPORT\nu32 gf_isom_probe_file(const char *fileName)\n{\n\treturn gf_isom_probe_file_range(fileName, 0, 0);\n}\n\nGF_EXPORT\nu32 gf_isom_probe_data(const u8*inBuf, u32 inSize)\n{\n\tu32 type;\n\tif (inSize < 8) return 0;\n\ttype = GF_4CC(inBuf[4], inBuf[5], inBuf[6], inBuf[7]);\n\treturn gf_isom_probe_type(type);\n}\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n#include <gpac/internal/media_dev.h>\n#endif\n\nstatic GF_Err isom_create_init_from_mem(const char *fileName, GF_ISOFile *file)\n{\n\tu32 sample_rate=0;\n\tu32 nb_channels=0;\n\tu32 bps=0;\n\t//u32 atag=0;\n\tu32 nal_len=4;\n\tu32 width = 0;\n\tu32 height = 0;\n\tu32 timescale = 10000000;\n\tu64 tfdt = 0;\n\tchar sz4cc[5];\n\tchar CodecParams[2048];\n\tu32 CodecParamLen=0;\n\tchar *sep, *val;\n\tGF_TrackBox *trak;\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleTableBox *stbl;\n\n\tsz4cc[0] = 0;\n\n\tval = (char*) ( fileName + strlen(\"isobmff://\") );\n\twhile (1)  {\n\t\tsep = strchr(val, ' ');\n\t\tif (sep) sep[0] = 0;\n\n\t\tif (!strncmp(val, \"4cc=\", 4)) strcpy(sz4cc, val+4);\n\t\telse if (!strncmp(val, \"init=\", 5)) {\n\t\t\tchar szH[3], *data = val+5;\n\t\t\tu32 i, len = (u32) strlen(data);\n\t\t\tfor (i=0; i<len; i+=2) {\n\t\t\t\tu32 v;\n\t\t\t\t//init is hex-encoded so 2 input bytes for one output char\n\t\t\t\tszH[0] = data[i];\n\t\t\t\tszH[1] = data[i+1];\n\t\t\t\tszH[2] = 0;\n\t\t\t\tsscanf(szH, \"%X\", &v);\n\t\t\t\tCodecParams[CodecParamLen] = (char) v;\n\t\t\t\tCodecParamLen++;\n\t\t\t}\n\t\t}\n\t\telse if (!strncmp(val, \"nal=\", 4)) nal_len = atoi(val+4);\n\t\telse if (!strncmp(val, \"bps=\", 4)) bps = atoi(val+4);\n\t\t//else if (!strncmp(val, \"atag=\", 5)) atag = atoi(val+5);\n\t\telse if (!strncmp(val, \"ch=\", 3)) nb_channels = atoi(val+3);\n\t\telse if (!strncmp(val, \"srate=\", 6)) sample_rate = atoi(val+6);\n\t\telse if (!strncmp(val, \"w=\", 2)) width = atoi(val+2);\n\t\telse if (!strncmp(val, \"h=\", 2)) height = atoi(val+2);\n\t\telse if (!strncmp(val, \"scale=\", 6)) timescale = atoi(val+6);\n\t\telse if (!strncmp(val, \"tfdt=\", 5)) {\n\t\t\tsscanf(val+5, LLX, &tfdt);\n\t\t}\n\t\tif (!sep) break;\n\t\tsep[0] = ' ';\n\t\tval = sep+1;\n\t}\n\tif (!stricmp(sz4cc, \"H264\") || !stricmp(sz4cc, \"AVC1\")) {\n\t}\n\telse if (!stricmp(sz4cc, \"AACL\")) {\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Cannot convert smooth media type %s to ISO init segment\\n\", sz4cc));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tfile->moov = (GF_MovieBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MOOV);\n\tif (!file->moov) return GF_OUT_OF_MEM;\n\tgf_list_add(file->TopBoxes, file->moov);\n\tfile->moov->mov = file;\n\tfile->is_smooth = GF_TRUE;\n\tfile->moov->mvhd = (GF_MovieHeaderBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVHD);\n\tif (!file->moov->mvhd) return GF_OUT_OF_MEM;\n\tfile->moov->mvhd->timeScale = timescale;\n\tfile->moov->mvex = (GF_MovieExtendsBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVEX);\n\tif (!file->moov->mvex) return GF_OUT_OF_MEM;\n\ttrex = (GF_TrackExtendsBox *) gf_isom_box_new_parent(&file->moov->mvex->child_boxes, GF_ISOM_BOX_TYPE_TREX);\n\tif (!trex) return GF_OUT_OF_MEM;\n\n\ttrex->def_sample_desc_index = 1;\n\ttrex->trackID = 1;\n\tgf_list_add(file->moov->mvex->TrackExList, trex);\n\n\ttrak = (GF_TrackBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_TRAK);\n\tif (!trak) return GF_OUT_OF_MEM;\n\ttrak->moov = file->moov;\n\tgf_list_add(file->moov->trackList, trak);\n\n\ttrak->Header = (GF_TrackHeaderBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TKHD);\n\tif (!trak->Header) return GF_OUT_OF_MEM;\n\ttrak->Header->trackID = 1;\n\ttrak->Header->flags |= 1;\n\ttrak->Header->width = width;\n\ttrak->Header->height = height;\n\n\ttrak->Media = (GF_MediaBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_MDIA);\n\tif (!trak->Media) return GF_OUT_OF_MEM;\n\ttrak->Media->mediaTrack = trak;\n\ttrak->Media->mediaHeader = (GF_MediaHeaderBox *) gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_MDHD);\n\tif (!trak->Media->mediaHeader) return GF_OUT_OF_MEM;\n\ttrak->Media->mediaHeader->timeScale = timescale;\n\n\ttrak->Media->handler = (GF_HandlerBox *) gf_isom_box_new_parent(&trak->Media->child_boxes,GF_ISOM_BOX_TYPE_HDLR);\n\tif (!trak->Media->handler) return GF_OUT_OF_MEM;\n    //we assume by default vide for handler type (only used for smooth streaming)\n\ttrak->Media->handler->handlerType = width ? GF_ISOM_MEDIA_VISUAL : GF_ISOM_MEDIA_AUDIO;\n\n\ttrak->Media->information = (GF_MediaInformationBox *) gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_MINF);\n\tif (!trak->Media->information) return GF_OUT_OF_MEM;\n\ttrak->Media->information->sampleTable = (GF_SampleTableBox *) gf_isom_box_new_parent(&trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_STBL);\n\tif (!trak->Media->information->sampleTable) return GF_OUT_OF_MEM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tstbl->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\tif (!stbl->SampleSize) return GF_OUT_OF_MEM;\n\tstbl->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\tif (!stbl->TimeToSample) return GF_OUT_OF_MEM;\n\tstbl->ChunkOffset = (GF_Box *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\tif (!stbl->ChunkOffset) return GF_OUT_OF_MEM;\n\tstbl->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\tif (!stbl->SampleToChunk) return GF_OUT_OF_MEM;\n\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\tif (!stbl->SampleDescription) return GF_OUT_OF_MEM;\n\n\ttrak->dts_at_seg_start = tfdt;\n\ttrak->dts_at_next_frag_start = tfdt;\n\n\n\tif (!stricmp(sz4cc, \"H264\") || !stricmp(sz4cc, \"AVC1\")) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tu32 pos = 0;\n\t\tu32 end, sc_size=0;\n#endif\n\t\tGF_MPEGVisualSampleEntryBox *avc =  (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stbl->SampleDescription->child_boxes, GF_ISOM_BOX_TYPE_AVC1);\n\t\tif (!avc) return GF_OUT_OF_MEM;\n\t\tavc->avc_config =  (GF_AVCConfigurationBox *) gf_isom_box_new_parent(&avc->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\t\tif (!avc->avc_config) return GF_OUT_OF_MEM;\n\n\t\tavc->Width = width;\n\t\tavc->Height = height;\n\n\t\tavc->avc_config->config = gf_odf_avc_cfg_new();\n\t\tavc->avc_config->config->nal_unit_size = nal_len;\n\t\tavc->avc_config->config->configurationVersion = 1;\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t//locate pps and sps\n\t\tgf_media_nalu_next_start_code((u8 *) CodecParams, CodecParamLen, &sc_size);\n\t\tpos += sc_size;\n\t\twhile (pos<CodecParamLen) {\n\t\t\tGF_NALUFFParam *slc;\n\t\t\tu8 nal_type;\n\t\t\tchar *nal = &CodecParams[pos];\n\t\t\tend = gf_media_nalu_next_start_code(nal, CodecParamLen-pos, &sc_size);\n\t\t\tif (!end) end = CodecParamLen;\n\n\t\t\tGF_SAFEALLOC(slc, GF_NALUFFParam);\n\t\t\tif (!slc) break;\n\t\t\tslc->size = end;\n\t\t\tslc->data = gf_malloc(sizeof(char)*slc->size);\n\t\t\tif (!slc->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(slc->data, nal, sizeof(char)*slc->size);\n\n\t\t\tnal_type = nal[0] & 0x1F;\n\t\t\tif (nal_type == GF_AVC_NALU_SEQ_PARAM) {\n/*\t\t\t\tAVCState avcc;\n\t\t\t\tu32 idx = gf_avc_read_sps(slc->data, slc->size, &avcc, 0, NULL);\n\t\t\t\tavc->avc_config->config->profile_compatibility = avcc.sps[idx].prof_compat;\n\t\t\t\tavc->avc_config->config->AVCProfileIndication = avcc.sps[idx].profile_idc;\n\t\t\t\tavc->avc_config->config->AVCLevelIndication = avcc.sps[idx].level_idc;\n\t\t\t\tavc->avc_config->config->chroma_format = avcc.sps[idx].chroma_format;\n\t\t\t\tavc->avc_config->config->luma_bit_depth = 8 + avcc.sps[idx].luma_bit_depth_m8;\n\t\t\t\tavc->avc_config->config->chroma_bit_depth = 8 + avcc.sps[idx].chroma_bit_depth_m8;\n*/\n\n\t\t\t\tgf_list_add(avc->avc_config->config->sequenceParameterSets, slc);\n\t\t\t} else {\n\t\t\t\tgf_list_add(avc->avc_config->config->pictureParameterSets, slc);\n\t\t\t}\n\t\t\tpos += slc->size + sc_size;\n\t\t}\n#endif\n\n\t\tAVC_RewriteESDescriptor(avc);\n\t}\n\telse if (!stricmp(sz4cc, \"AACL\")) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tGF_M4ADecSpecInfo aacinfo;\n#endif\n\n\t\tGF_MPEGAudioSampleEntryBox *aac =  (GF_MPEGAudioSampleEntryBox *) gf_isom_box_new_parent(&stbl->SampleDescription->child_boxes, GF_ISOM_BOX_TYPE_MP4A);\n\t\tif (!aac) return GF_OUT_OF_MEM;\n\t\taac->esd = (GF_ESDBox *) gf_isom_box_new_parent(&aac->child_boxes, GF_ISOM_BOX_TYPE_ESDS);\n\t\tif (!aac->esd) return GF_OUT_OF_MEM;\n\t\taac->esd->desc = gf_odf_desc_esd_new(2);\n\t\tif (!aac->esd->desc) return GF_OUT_OF_MEM;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tmemset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo));\n\t\taacinfo.nb_chan = nb_channels;\n\t\taacinfo.base_object_type = GF_M4A_AAC_LC;\n\t\taacinfo.base_sr = sample_rate;\n\t\tgf_m4a_write_config(&aacinfo, &aac->esd->desc->decoderConfig->decoderSpecificInfo->data, &aac->esd->desc->decoderConfig->decoderSpecificInfo->dataLength);\n#endif\n\t\taac->esd->desc->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\taac->esd->desc->decoderConfig->objectTypeIndication = GF_CODECID_AAC_MPEG4;\n\t\taac->bitspersample = bps;\n\t\taac->samplerate_hi = sample_rate;\n\t\taac->channel_count = nb_channels;\n\t}\n\n\treturn GF_OK;\n}\n\n/**************************************************************\n\t\t\t\t\tFile Opening in streaming mode\n\t\t\tthe file map is regular (through FILE handles)\n**************************************************************/\nGF_EXPORT\nGF_Err gf_isom_open_progressive_ex(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_bounds, GF_ISOFile **the_file, u64 *BytesMissing, u32 *outBoxType)\n{\n\tGF_Err e;\n\tGF_ISOFile *movie;\n\n\tif (!BytesMissing || !the_file)\n\t\treturn GF_BAD_PARAM;\n\t*BytesMissing = 0;\n\t*the_file = NULL;\n\n\tmovie = gf_isom_new_movie();\n\tif (!movie) return GF_OUT_OF_MEM;\n\n\tmovie->fileName = gf_strdup(fileName);\n\tmovie->openMode = GF_ISOM_OPEN_READ;\n\tmovie->signal_frag_bounds = enable_frag_bounds;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tmovie->editFileMap = NULL;\n\tmovie->finalName = NULL;\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\tif (!strncmp(fileName, \"isobmff://\", 10)) {\n\t\tmovie->movieFileMap = NULL;\n\t\te = isom_create_init_from_mem(fileName, movie);\n\t} else {\n\t\t//do NOT use FileMapping on incomplete files\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ, &movie->movieFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_delete_movie(movie);\n\t\t\treturn e;\n\t\t}\n\n\t\tif (start_range || end_range) {\n\t\t\tif (end_range>start_range) {\n\t\t\t\tgf_bs_seek(movie->movieFileMap->bs, end_range+1);\n\t\t\t\tgf_bs_truncate(movie->movieFileMap->bs);\n\t\t\t}\n\t\t\tgf_bs_seek(movie->movieFileMap->bs, start_range);\n\t\t}\n\t\te = gf_isom_parse_movie_boxes(movie, outBoxType, BytesMissing, GF_TRUE);\n\n\t}\n\tif (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\t//if we have a moov, we're fine\n\t\tif (movie->moov) {\n\t\t\t*the_file = (GF_ISOFile *)movie;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//if not, delete the movie\n\t\tgf_isom_delete_movie(movie);\n\t\treturn e;\n\t} else if (e) {\n\t\t//if not, delete the movie\n\t\tgf_isom_delete_movie(movie);\n\t\treturn e;\n\t}\n\n\t//OK, let's return\n\t*the_file = (GF_ISOFile *)movie;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_open_progressive(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_bounds, GF_ISOFile **the_file, u64 *BytesMissing)\n{\n\treturn gf_isom_open_progressive_ex(fileName, start_range, end_range, enable_frag_bounds, the_file, BytesMissing, NULL);\n}\n\n/**************************************************************\n\t\t\t\t\tFile Reading\n**************************************************************/\n\nGF_EXPORT\nGF_ISOFile *gf_isom_open(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir)\n{\n\tGF_ISOFile *movie;\n\tMP4_API_IO_Err = GF_OK;\n\n\tswitch (OpenMode & 0xFF) {\n\tcase GF_ISOM_OPEN_READ_DUMP:\n\tcase GF_ISOM_OPEN_READ:\n\t\tmovie = gf_isom_open_file(fileName, OpenMode, NULL);\n\t\tbreak;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\tcase GF_ISOM_OPEN_WRITE:\n\t\tmovie = gf_isom_create_movie(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\tcase GF_ISOM_OPEN_EDIT:\n\tcase GF_ISOM_OPEN_READ_EDIT:\n\tcase GF_ISOM_OPEN_KEEP_FRAGMENTS:\n\t\tmovie = gf_isom_open_file(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\tcase GF_ISOM_WRITE_EDIT:\n\t\tmovie = gf_isom_create_movie(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\treturn (GF_ISOFile *) movie;\n}\n\n\n#if 0\n/*! gets access to the data bitstream  - see \\ref gf_isom_open\n\\param isom_file the target ISO file\n\\param out_bs set to the file input bitstream - do NOT destroy\n\\return error if any\n*/\nGF_Err gf_isom_get_bs(GF_ISOFile *movie, GF_BitStream **out_bs)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (!movie || movie->openMode != GF_ISOM_OPEN_WRITE || !movie->editFileMap) //memory mode\n\t\treturn GF_NOT_SUPPORTED;\n\n\tif (movie->segment_bs)\n\t\t*out_bs = movie->segment_bs;\n\telse\n\t\t*out_bs = movie->editFileMap->bs;\n\n\tif (movie->moof)\n\t\tmovie->moof->fragment_offset = 0;\n\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_write(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\tif (movie == NULL) return GF_ISOM_INVALID_FILE;\n\te = GF_OK;\n\n\t//update duration of each track\n\tif (movie->moov) {\n\t\tu32 i, count = gf_list_count(movie->moov->trackList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrackBox *trak = gf_list_get(movie->moov->trackList, i);\n\t\t\te = SetTrackDuration(trak);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t//write our movie to the file\n\tif ((movie->openMode != GF_ISOM_OPEN_READ) && (movie->openMode != GF_ISOM_OPEN_READ_EDIT)) {\n\t\tgf_isom_get_duration(movie);\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t//movie fragment mode, just store the fragment\n\t\tif ( (movie->openMode == GF_ISOM_OPEN_WRITE) && (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) {\n\t\t\te = gf_isom_close_fragments(movie);\n\t\t\tif (e) return e;\n\t\t\t//in case of mfra box usage -> create mfro, calculate box sizes and write it out\n\t\t\tif (movie->mfra) {\n\t\t\t\tif (!movie->mfra->mfro) {\n\t\t\t\t\tmovie->mfra->mfro = (GF_MovieFragmentRandomAccessOffsetBox *)gf_isom_box_new_parent(&movie->mfra->child_boxes, GF_ISOM_BOX_TYPE_MFRO);\n\t\t\t\t\tif (!movie->mfra->mfro) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = gf_isom_box_size((GF_Box *)movie->mfra);\n\t\t\t\tif (e) return e;\n\t\t\t\tmovie->mfra->mfro->container_size = (u32) movie->mfra->size;\n\n\t\t\t\t//write mfra\n\t\t\t\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\") && movie->on_block_out) {\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new_cbk(movie->on_block_out, movie->on_block_out_usr_data, movie->on_block_out_block_size);\n\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->mfra, bs);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->mfra, movie->editFileMap->bs);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n#endif\n\t\t\te = WriteToFile(movie, GF_FALSE);\n\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->moov) {\n\t\tu32 i;\n\t\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\t\t/*delete any pending dataHandler of scalable enhancements*/\n\t\t\tif (trak->Media && trak->Media->information && trak->Media->information->scalableDataHandler && (trak->Media->information->scalableDataHandler != movie->movieFileMap))\n\t\t\t\tgf_isom_datamap_del(trak->Media->information->scalableDataHandler);\n\t\t}\n\t}\n#endif\n\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_close(GF_ISOFile *movie)\n{\n\tGF_Err e=GF_OK;\n\tif (movie == NULL) return GF_ISOM_INVALID_FILE;\n\te = gf_isom_write(movie);\n\t//free and return;\n\tgf_isom_delete_movie(movie);\n\treturn e;\n}\n\n\n#if 0 //unused\n/*! checks if files has root OD/IOD or not\n\\param isom_file the target ISO file\n\\return GF_TRUE if the file has a root OD or IOD */\nBool gf_isom_has_root_od(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->iods || !movie->moov->iods->descriptor) return GF_FALSE;\n\treturn GF_TRUE;\n}\n#endif\n\nGF_EXPORT\nvoid gf_isom_disable_odf_conversion(GF_ISOFile *movie, Bool disable)\n{\n\tif (movie) movie->disable_odf_translate = disable ? 1 : 0;\n}\n\n//this funct is used for exchange files, where the iods contains an OD\nGF_EXPORT\nGF_Descriptor *gf_isom_get_root_od(GF_ISOFile *movie)\n{\n\tGF_Descriptor *desc;\n\tGF_ObjectDescriptor *od;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_IsomInitialObjectDescriptor *isom_iod;\n\tGF_ESD *esd;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tu8 useIOD;\n\n\tif (!movie || !movie->moov) return NULL;\n\tif (!movie->moov->iods) return NULL;\n\n\tif (movie->disable_odf_translate) {\n\t\t//duplicate our descriptor\n\t\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\t\tif (movie->LastError) return NULL;\n\t\treturn desc;\n\t}\n\tod = NULL;\n\tiod = NULL;\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tod = (GF_ObjectDescriptor*)gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\tif (!od) return NULL;\n\n\t\tmemset(od, 0, sizeof(GF_ObjectDescriptor));\n\t\tod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 0;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tiod = (GF_InitialObjectDescriptor*)gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\tif (!iod) return NULL;\n\n\t\tmemset(iod, 0, sizeof(GF_InitialObjectDescriptor));\n\t\tiod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\t//duplicate our descriptor\n\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\tif (movie->LastError) {\n\t\tif (od) {\n\t\t\tgf_list_del(od->ESDescriptors);\n\t\t\tgf_free(od);\n\t\t}\n\t\tif (iod) {\n\t\t\tgf_list_del(iod->ESDescriptors);\n\t\t\tgf_free(iod);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (!useIOD) {\n\t\tisom_od = (GF_IsomObjectDescriptor *)desc;\n\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\tisom_od->extensionDescriptors = NULL;\n\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\tisom_od->IPMP_Descriptors = NULL;\n\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\tisom_od->OCIDescriptors = NULL;\n\t\tod->URLString = isom_od->URLString;\n\t\tisom_od->URLString = NULL;\n\t\tod->tag = GF_ODF_OD_TAG;\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_od->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(od->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) od);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)od;\n\t} else {\n\t\tisom_iod = (GF_IsomInitialObjectDescriptor *)desc;\n\t\tiod->objectDescriptorID = isom_iod->objectDescriptorID;\n\t\tiod->extensionDescriptors = isom_iod->extensionDescriptors;\n\t\tisom_iod->extensionDescriptors = NULL;\n\t\tiod->IPMP_Descriptors = isom_iod->IPMP_Descriptors;\n\t\tisom_iod->IPMP_Descriptors = NULL;\n\t\tiod->OCIDescriptors = isom_iod->OCIDescriptors;\n\t\tisom_iod->OCIDescriptors = NULL;\n\t\tiod->URLString = isom_iod->URLString;\n\t\tisom_iod->URLString = NULL;\n\t\tiod->tag = GF_ODF_IOD_TAG;\n\n\t\tiod->audio_profileAndLevel = isom_iod->audio_profileAndLevel;\n\t\tiod->graphics_profileAndLevel = isom_iod->graphics_profileAndLevel;\n\t\tiod->inlineProfileFlag = isom_iod->inlineProfileFlag;\n\t\tiod->OD_profileAndLevel = isom_iod->OD_profileAndLevel;\n\t\tiod->scene_profileAndLevel = isom_iod->scene_profileAndLevel;\n\t\tiod->visual_profileAndLevel = isom_iod->visual_profileAndLevel;\n\t\tiod->IPMPToolList = isom_iod->IPMPToolList;\n\t\tisom_iod->IPMPToolList = NULL;\n\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_iod->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(iod->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)iod;\n\t}\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_track_count(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov) return 0;\n\n\tif (!movie->moov->trackList) {\n\t\tmovie->LastError = GF_ISOM_INVALID_FILE;\n\t\treturn 0;\n\t}\n\treturn gf_list_count(movie->moov->trackList);\n}\n\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_track_id(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Header) return 0;\n\treturn trak->Header->trackID;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_track_by_id(GF_ISOFile *the_file, GF_ISOTrackID trackID)\n{\n\tu32 count;\n\tu32 i;\n\tif (the_file == NULL) return 0;\n\n\tcount = gf_isom_get_track_count(the_file);\n\tif (!count) return 0;\n\tfor (i = 0; i < count; i++) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, i+1);\n\t\tif (!trak || !trak->Header) return 0;\n\t\tif (trak->Header->trackID == trackID) return i+1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_track_original_id(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->originalID;\n}\n\n//return the timescale of the movie, 0 if error\nGF_EXPORT\nBool gf_isom_has_movie(GF_ISOFile *file)\n{\n\tif (file && file->moov) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\n#ifndef GPAC_DISABLE_ISOM\nGF_EXPORT\nBool gf_isom_has_segment(GF_ISOFile *file, u32 *brand, u32 *version)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tGF_Box *a;\n\ti = 0;\n\twhile (NULL != (a = (GF_Box*)gf_list_enum(file->TopBoxes, &i))) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (a->type == GF_ISOM_BOX_TYPE_STYP) {\n\t\t\tGF_FileTypeBox *styp = (GF_FileTypeBox *)a;\n\t\t\t*brand = styp->majorBrand;\n\t\t\t*version = styp->minorVersion;\n\t\t\treturn GF_TRUE;\n\t\t}\n#endif\n\t}\n#endif\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_segment_get_fragment_count(GF_ISOFile *file)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (file) {\n\t\tu32 i, count = 0;\n\t\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) count++;\n\t\t}\n\t\treturn count;\n\t}\n#endif\n\treturn 0;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_MovieFragmentBox *gf_isom_get_moof(GF_ISOFile *file, u32 moof_index)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\tmoof_index--;\n\t\t\tif (!moof_index) return (GF_MovieFragmentBox *) a;\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n\nGF_EXPORT\nu32 gf_isom_segment_get_track_fragment_count(GF_ISOFile *file, u32 moof_index)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_MovieFragmentBox *moof;\n\tif (!file) return 0;\n\tgf_list_count(file->TopBoxes);\n\tmoof = gf_isom_get_moof(file, moof_index);\n\treturn moof ? gf_list_count(moof->TrackList) : 0;\n#endif\n\treturn 0;\n}\n\nGF_EXPORT\nu32 gf_isom_segment_get_track_fragment_decode_time(GF_ISOFile *file, u32 moof_index, u32 traf_index, u64 *decode_time)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\tif (!file) return 0;\n\tgf_list_count(file->TopBoxes);\n\tmoof = gf_isom_get_moof(file, moof_index);\n\ttraf = moof ? (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, traf_index-1) : NULL;\n\tif (!traf) return 0;\n\tif (decode_time) {\n\t\t*decode_time = traf->tfdt ? traf->tfdt->baseMediaDecodeTime : 0;\n\t}\n\treturn traf->tfhd->trackID;\n#endif\n\treturn 0;\n}\n\nGF_EXPORT\nu64 gf_isom_segment_get_fragment_size(GF_ISOFile *file, u32 moof_index, u32 *moof_size)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!file) return 0;\n\tu32 moof_sn=0;\n\tBool moof_after_mdat = GF_FALSE;\n\tu64 size=0;\n\tu32 i, count = gf_list_count(file->TopBoxes);\n\tif (moof_size) *moof_size = 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(file->TopBoxes, i);\n\t\tsize += b->size;\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\tif (!moof_after_mdat && (moof_sn == moof_index))\n\t\t\t\treturn size - b->size;\n\n\t\t\tif (moof_size) *moof_size = (u32) b->size;\n\t\t\tmoof_sn++;\n\t\t\tif (moof_after_mdat && (moof_sn == moof_index))\n\t\t\t\treturn size;\n\t\t\tif (moof_after_mdat) size=0;\n\t\t\tif ((moof_sn>1) && !moof_after_mdat) size = b->size;\n\t\t}\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tif (!moof_sn) moof_after_mdat = GF_TRUE;\n\t\t}\n\t}\n\treturn size;\n#endif\n\treturn 0;\n}\n#endif\n\n//return the timescale of the movie, 0 if error\nGF_EXPORT\nu32 gf_isom_get_timescale(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->mvhd) return 0;\n\treturn movie->moov->mvhd->timeScale;\n}\n\n\n//return the duration of the movie, 0 if error\nGF_EXPORT\nu64 gf_isom_get_duration(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->mvhd) return 0;\n\n\t//if file was open in Write or Edit mode, recompute the duration\n\t//the duration of a movie is the MaxDuration of all the tracks...\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tgf_isom_update_duration(movie);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\treturn movie->moov->mvhd->duration;\n}\n//return the duration of the movie, 0 if error\nGF_EXPORT\nu64 gf_isom_get_original_duration(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov|| !movie->moov->mvhd) return 0;\n\treturn movie->moov->mvhd->original_duration;\n}\n\n//return the creation info of the movie\nGF_EXPORT\nGF_Err gf_isom_get_creation_time(GF_ISOFile *movie, u64 *creationTime, u64 *modificationTime)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tif (creationTime) *creationTime = movie->moov->mvhd->creationTime;\n\tif (creationTime) *modificationTime = movie->moov->mvhd->modificationTime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_creation_time(GF_ISOFile *movie, u32 trackNumber, u64 *creationTime, u64 *modificationTime)\n{\n\tGF_TrackBox *trak;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\tif (creationTime) *creationTime = trak->Media->mediaHeader->creationTime;\n\tif (creationTime) *modificationTime = trak->Media->mediaHeader->modificationTime;\n\treturn GF_OK;\n}\n\n//check the presence of a track in IOD. 0: NO, 1: YES, 2: ERROR\nGF_EXPORT\nu8 gf_isom_is_track_in_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tu32 i;\n\tGF_ISOTrackID trackID;\n\tGF_Descriptor *desc;\n\tGF_ES_ID_Inc *inc;\n\tGF_List *inc_list;\n\tif (!movie) return 2;\n\tif (!movie->moov || !movie->moov->iods) return 0;\n\n\tdesc = movie->moov->iods->descriptor;\n\tswitch (desc->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tinc_list = ((GF_IsomInitialObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tinc_list = ((GF_IsomObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\tbreak;\n\t//files without IOD are possible !\n\tdefault:\n\t\treturn 0;\n\t}\n\ttrackID = gf_isom_get_track_id(movie, trackNumber);\n\tif (!trackID) return 2;\n\ti=0;\n\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(inc_list, &i))) {\n\t\tif (inc->trackID == (u32) trackID) return 1;\n\t}\n\treturn 0;\n}\n\n\n\n//gets the enable flag of a track\n//0: NO, 1: YES, 2: ERROR\nGF_EXPORT\nu8 gf_isom_is_track_enabled(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\n\tif (!trak || !trak->Header) return 2;\n\treturn (trak->Header->flags & 1) ? 1 : 0;\n}\n\nGF_EXPORT\nu32 gf_isom_get_track_flags(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Header->flags;\n}\n\n\n//get the track duration\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_track_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*in all modes except dump recompute duration in case headers are wrong*/\n\tif (movie->openMode != GF_ISOM_OPEN_READ_DUMP) {\n\t\tSetTrackDuration(trak);\n\t}\n#endif\n\treturn trak->Header->duration;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_media_language(GF_ISOFile *the_file, u32 trackNumber, char **lang)\n{\n\tu32 count;\n\tBool elng_found = GF_FALSE;\n\tGF_TrackBox *trak;\n\tif (!lang) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t*lang = NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tcount = gf_list_count(trak->Media->child_boxes);\n\tif (count>0) {\n\t\tu32 i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tGF_Box *box = (GF_Box *)gf_list_get(trak->Media->child_boxes, i);\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_ELNG) {\n\t\t\t\t*lang = gf_strdup(((GF_ExtendedLanguageBox *)box)->extended_language);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (!elng_found) {\n\t\t*lang = gf_strdup(trak->Media->mediaHeader->packedLanguage);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_track_kind_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\t\tif (!trak) return 0;\n\t\tif (!trak->udta) {\n\t\t\treturn 0;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn 0;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (!map) return 0;\n\n\treturn gf_list_count(map->boxes);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_kind(GF_ISOFile *the_file, u32 trackNumber, u32 index, char **scheme, char **value)\n{\n\tGF_Err e;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tGF_KindBox *kindBox;\n\tif (!scheme || !value) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t*scheme = NULL;\n\t*value = NULL;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (!map) return GF_BAD_PARAM;\n\n\tkindBox = (GF_KindBox *)gf_list_get(map->boxes, index);\n\tif (!kindBox) return GF_BAD_PARAM;\n\n\t*scheme = gf_strdup(kindBox->schemeURI);\n\tif (kindBox->value) {\n\t\t*value = gf_strdup(kindBox->value);\n\t}\n\treturn GF_OK;\n}\n\n\n//Return the number of track references of a track for a given ReferenceType\n//return 0 if error\nGF_EXPORT\ns32 gf_isom_get_reference_count(GF_ISOFile *movie, u32 trackNumber, u32 referenceType)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return -1;\n\tif (!trak->References) return 0;\n\tif (movie->openMode == GF_ISOM_OPEN_WRITE) {\n\t\tmovie->LastError = GF_ISOM_INVALID_MODE;\n\t\treturn -1;\n\t}\n\n\tdpnd = NULL;\n\tif ( (movie->LastError = Track_FindRef(trak, referenceType, &dpnd)) ) return -1;\n\tif (!dpnd) return 0;\n\treturn dpnd->trackIDCount;\n}\n\n\n//Return the number of track references of a track for a given ReferenceType\n//return 0 if error\nGF_EXPORT\nconst GF_ISOTrackID *gf_isom_enum_track_references(GF_ISOFile *movie, u32 trackNumber, u32 idx, u32 *referenceType, u32 *referenceCount)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\tif (!trak->References) return NULL;\n\tdpnd = gf_list_get(trak->References->child_boxes, idx);\n\tif (!dpnd) return NULL;\n\t*referenceType = dpnd->reference_type;\n\t*referenceCount = dpnd->trackIDCount;\n\treturn dpnd->trackIDs;\n}\n\n\n//Return the referenced track number for a track and a given ReferenceType and Index\n//return -1 if error, 0 if the reference is a NULL one, or the trackNumber\nGF_EXPORT\nGF_Err gf_isom_get_reference(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, u32 referenceIndex, u32 *refTrack)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_ISOTrackID refTrackNum;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\n\t*refTrack = 0;\n\tif (!trak || !trak->References) return GF_BAD_PARAM;\n\n\tdpnd = NULL;\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) return GF_BAD_PARAM;\n\n\tif (!referenceIndex || (referenceIndex > dpnd->trackIDCount)) return GF_BAD_PARAM;\n\n\t//the spec allows a NULL reference\n\t//(ex, to force desync of a track, set a sync ref with ID = 0)\n\tif (dpnd->trackIDs[referenceIndex - 1] == 0) return GF_OK;\n\n\trefTrackNum = gf_isom_get_tracknum_from_id(movie->moov, dpnd->trackIDs[referenceIndex-1]);\n\n\t//if the track was not found, this means the file is broken !!!\n\tif (! refTrackNum) return GF_ISOM_INVALID_FILE;\n\t*refTrack = refTrackNum;\n\treturn GF_OK;\n}\n\n//Return the referenced track ID for a track and a given ReferenceType and Index\n//return -1 if error, 0 if the reference is a NULL one, or the trackNumber\nGF_EXPORT\nGF_Err gf_isom_get_reference_ID(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, u32 referenceIndex, GF_ISOTrackID *refTrackID)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\n\t*refTrackID = 0;\n\tif (!trak || !trak->References || !referenceIndex) return GF_BAD_PARAM;\n\n\tdpnd = NULL;\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) return GF_BAD_PARAM;\n\n\tif (referenceIndex > dpnd->trackIDCount) return GF_BAD_PARAM;\n\n\t*refTrackID = dpnd->trackIDs[referenceIndex-1];\n\n\treturn GF_OK;\n}\n\n//Return referenceIndex if the given track has a reference to the given TreckID of a given ReferenceType\n//return 0 if error\nGF_EXPORT\nu32 gf_isom_has_track_reference(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, GF_ISOTrackID refTrackID)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\tif (!trak->References) return 0;\n\n\tdpnd = NULL;\n\tif ( (movie->LastError = Track_FindRef(trak, referenceType, &dpnd)) ) return 0;\n\tif (!dpnd) return 0;\n\tfor (i=0; i<dpnd->trackIDCount; i++) {\n\t\tif (dpnd->trackIDs[i]==refTrackID) return i+1;\n\t}\n\treturn 0;\n}\n\n\n\n//Return the media time given the absolute time in the Movie\nGF_EXPORT\nGF_Err gf_isom_get_media_time(GF_ISOFile *the_file, u32 trackNumber, u32 movieTime, u64 *MediaTime)\n{\n\tGF_TrackBox *trak;\n\tu8 useEdit;\n\ts64 SegmentStartTime, mediaOffset;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !MediaTime) return GF_BAD_PARAM;\n\n\tSegmentStartTime = 0;\n\treturn GetMediaTime(trak, GF_FALSE, movieTime, MediaTime, &SegmentStartTime, &mediaOffset, &useEdit, NULL);\n}\n\n\n//Get the stream description index (eg, the ESD) for a given time IN MEDIA TIMESCALE\n//return 0 if error or if empty\nGF_EXPORT\nu32 gf_isom_get_sample_description_index(GF_ISOFile *movie, u32 trackNumber, u64 for_time)\n{\n\tu32 streamDescIndex;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\tif ( (movie->LastError = Media_GetSampleDescIndex(trak->Media, for_time, &streamDescIndex)) ) {\n\t\treturn 0;\n\t}\n\treturn streamDescIndex;\n}\n\n//Get the number of \"streams\" stored in the media - a media can have several stream descriptions...\nGF_EXPORT\nu32 gf_isom_get_sample_description_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\treturn gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n}\n\n\n//Get the GF_ESD given the StreamDescriptionIndex\n//THE DESCRIPTOR IS DUPLICATED, SO HAS TO BE DELETED BY THE APP\nGF_EXPORT\nGF_ESD *gf_isom_get_esd(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_ESD *esd;\n\tGF_Err e;\n\te = GetESD(movie->moov, gf_isom_get_track_id(movie, trackNumber), StreamDescriptionIndex, &esd);\n\tif (e && (e!= GF_ISOM_INVALID_MEDIA)) {\n\t\tmovie->LastError = e;\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\treturn NULL;\n\t}\n\n\treturn esd;\n}\n\n//Get the decoderConfigDescriptor given the SampleDescriptionIndex\n//THE DESCRIPTOR IS DUPLICATED, SO HAS TO BE DELETED BY THE APP\nGF_EXPORT\nGF_DecoderConfig *gf_isom_get_decoder_config(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ESD *esd;\n\tGF_Descriptor *decInfo;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\t//get the ESD (possibly emulated)\n\tMedia_GetESD(trak->Media, StreamDescriptionIndex, &esd, GF_FALSE);\n\tif (!esd) return NULL;\n\tdecInfo = (GF_Descriptor *) esd->decoderConfig;\n\tesd->decoderConfig = NULL;\n\tgf_odf_desc_del((GF_Descriptor *) esd);\n\treturn (GF_DecoderConfig *)decInfo;\n}\n\n\n//get the media duration (without edit)\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_media_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\t/*except in dump mode always recompute the duration*/\n\tif (movie->openMode != GF_ISOM_OPEN_READ_DUMP) {\n\t\tif ( (movie->LastError = Media_SetDuration(trak)) ) return 0;\n\t}\n\n#endif\n\n\treturn trak->Media->mediaHeader->duration;\n}\n\n//get the media duration (without edit)\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_media_original_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return 0;\n\n\treturn trak->Media->mediaHeader->original_duration;\n}\n\n//Get the timeScale of the media. All samples DTS/CTS are expressed in this timeScale\nGF_EXPORT\nu32 gf_isom_get_media_timescale(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return 0;\n\treturn trak->Media->mediaHeader->timeScale;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_copyright_count(GF_ISOFile *mov)\n{\n\tGF_UserDataMap *map;\n\tif (!mov || !mov->moov || !mov->moov->udta) return 0;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return 0;\n\treturn gf_list_count(map->boxes);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_copyright(GF_ISOFile *mov, u32 Index, const char **threeCharCode, const char **notice)\n{\n\tGF_UserDataMap *map;\n\tGF_CopyrightBox *cprt;\n\n\tif (!mov || !mov->moov || !Index) return GF_BAD_PARAM;\n\n\tif (!mov->moov->udta) return GF_OK;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return GF_OK;\n\n\tif (Index > gf_list_count(map->boxes)) return GF_BAD_PARAM;\n\n\tcprt = (GF_CopyrightBox*)gf_list_get(map->boxes, Index-1);\n\t(*threeCharCode) = cprt->packedLanguageCode;\n\t(*notice) = cprt->notice;\n\treturn GF_OK;\n}\n\n#if 0\nGF_Err gf_isom_get_watermark(GF_ISOFile *mov, bin128 UUID, u8** data, u32* length)\n{\n\tGF_UserDataMap *map;\n\tGF_UnknownUUIDBox *wm;\n\n\tif (!mov) return GF_BAD_PARAM;\n\tif (!mov->moov || !mov->moov->udta) return GF_NOT_SUPPORTED;\n\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_UUID, (bin128 *) & UUID);\n\tif (!map) return GF_NOT_SUPPORTED;\n\n\twm = (GF_UnknownUUIDBox*)gf_list_get(map->boxes, 0);\n\tif (!wm) return GF_NOT_SUPPORTED;\n\n\t*data = (u8 *) gf_malloc(sizeof(char)*wm->dataSize);\n\tif (! *data) return GF_OUT_OF_MEM;\n\tmemcpy(*data, wm->data, wm->dataSize);\n\t*length = wm->dataSize;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nu32 gf_isom_get_chapter_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_UserDataMap *map;\n\tGF_ChapterListBox *lst;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return 0;\n\n\tudta = NULL;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return 0;\n\tlst = (GF_ChapterListBox *)gf_list_get(map->boxes, 0);\n\tif (!lst) return 0;\n\treturn gf_list_count(lst->list);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chapter(GF_ISOFile *movie, u32 trackNumber, u32 Index, u64 *chapter_time, const char **name)\n{\n\tGF_UserDataMap *map;\n\tGF_ChapterListBox *lst;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tudta = NULL;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return GF_BAD_PARAM;\n\tlst = (GF_ChapterListBox *)gf_list_get(map->boxes, 0);\n\tif (!lst) return GF_BAD_PARAM;\n\n\tce = (GF_ChapterEntry *)gf_list_get(lst->list, Index-1);\n\tif (!ce) return GF_BAD_PARAM;\n\tif (chapter_time) {\n\t\t*chapter_time = ce->start_time;\n\t\t*chapter_time /= 10000L;\n\t}\n\tif (name) *name = ce->name;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_media_type(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\treturn (trak->Media && trak->Media->handler) ? trak->Media->handler->handlerType : 0;\n}\n\nBool IsMP4Description(u32 entryType)\n{\n\tswitch (entryType) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\tcase GF_ISOM_BOX_TYPE_LSR1:\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nBool gf_isom_is_encrypted_entry(u32 entryType)\n{\n\tswitch (entryType) {\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nBool gf_isom_is_track_encrypted(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tu32 i=0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 2;\n\twhile (1) {\n\t\tGF_Box *entry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!entry) break;\n\t\tif (gf_isom_is_encrypted_entry(entry->type)) return GF_TRUE;\n\n\t\tif (gf_isom_is_cenc_media(the_file, trackNumber, i+1))\n\t\t\treturn GF_TRUE;\n\n\t\ti++;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_media_subtype(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Box *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !DescriptionIndex || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return 0;\n\n\t//filter MPEG sub-types\n\tif (IsMP4Description(entry->type)) {\n\t\tif (gf_isom_is_encrypted_entry(entry->type)) return GF_ISOM_SUBTYPE_MPEG4_CRYP;\n\t\telse return GF_ISOM_SUBTYPE_MPEG4;\n\t}\n\tif (entry->type == GF_ISOM_BOX_TYPE_GNRV) {\n\t\treturn ((GF_GenericVisualSampleEntryBox *)entry)->EntryType;\n\t}\n\telse if (entry->type == GF_ISOM_BOX_TYPE_GNRA) {\n\t\treturn ((GF_GenericAudioSampleEntryBox *)entry)->EntryType;\n\t}\n\telse if (entry->type == GF_ISOM_BOX_TYPE_GNRM) {\n\t\treturn ((GF_GenericSampleEntryBox *)entry)->EntryType;\n\t}\n\treturn entry->type;\n}\n\nGF_EXPORT\nu32 gf_isom_get_mpeg4_subtype(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Box *entry=NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !DescriptionIndex) return 0;\n\n\tif (trak->Media\n\t\t&& trak->Media->information\n\t\t&& trak->Media->information->sampleTable\n\t\t&& trak->Media->information->sampleTable->SampleDescription\n\t) {\n\t\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\t}\n\tif (!entry) return 0;\n\n\t//filter MPEG sub-types\n\tif (!IsMP4Description(entry->type)) return 0;\n\treturn entry->type;\n}\n\n//Get the HandlerDescription name.\nGF_EXPORT\nGF_Err gf_isom_get_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char **outName)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !outName) return GF_BAD_PARAM;\n\t*outName = trak->Media->handler->nameUTF8;\n\treturn GF_OK;\n}\n\n//Check the DataReferences of this track\nGF_EXPORT\nGF_Err gf_isom_check_data_reference(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_Err e;\n\tu32 drefIndex;\n\tGF_TrackBox *trak;\n\n\tif (!StreamDescriptionIndex || !trackNumber) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex , NULL, &drefIndex);\n\tif (e) return e;\n\tif (!drefIndex) return GF_BAD_PARAM;\n\treturn Media_CheckDataEntry(trak->Media, drefIndex);\n}\n\n//get the location of the data. If URL && URN are NULL, the data is in this file\nGF_EXPORT\nGF_Err gf_isom_get_data_reference(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const char **outURL, const char **outURN)\n{\n\tGF_TrackBox *trak;\n\tGF_DataEntryURLBox *url=NULL;\n\tGF_DataEntryURNBox *urn;\n\tu32 drefIndex;\n\tGF_Err e;\n\n\t*outURL = *outURN = NULL;\n\n\tif (!StreamDescriptionIndex || !trackNumber) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex , NULL, &drefIndex);\n\tif (e) return e;\n\tif (!drefIndex) return GF_BAD_PARAM;\n\n\tif (trak->Media\n\t\t&& trak->Media->information\n\t\t&& trak->Media->information->dataInformation\n\t\t&& trak->Media->information->dataInformation->dref\n\t) {\n\t\turl = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\t}\n\tif (!url) return GF_ISOM_INVALID_FILE;\n\n\tif (url->type == GF_ISOM_BOX_TYPE_URL) {\n\t\t*outURL = url->location;\n\t\t*outURN = NULL;\n\t} else if (url->type == GF_ISOM_BOX_TYPE_URN) {\n\t\turn = (GF_DataEntryURNBox *) url;\n\t\t*outURN = urn->nameURN;\n\t\t*outURL = urn->location;\n\t} else {\n\t\t*outURN = NULL;\n\t\t*outURL = NULL;\n\t}\n\treturn GF_OK;\n}\n\n//Get the number of samples\n//return 0 if error or empty\nGF_EXPORT\nu32 gf_isom_get_sample_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\treturn trak->Media->information->sampleTable->SampleSize->sampleCount\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t       + trak->sample_count_at_seg_start\n#endif\n\t       ;\n}\n\nGF_EXPORT\nu32 gf_isom_get_constant_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n}\n\nGF_EXPORT\nu32 gf_isom_get_constant_sample_duration(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return 0;\n\tif (trak->Media->information->sampleTable->TimeToSample->nb_entries != 1) return 0;\n\treturn trak->Media->information->sampleTable->TimeToSample->entries[0].sampleDelta;\n}\n\nGF_EXPORT\nBool gf_isom_enable_raw_pack(GF_ISOFile *the_file, u32 trackNumber, u32 pack_num_samples)\n{\n\tu32 afmt, bps, nb_ch;\n\tBool from_qt=GF_FALSE;\n\tGF_TrackBox *trak;\n\tGF_MPEGAudioSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\ttrak->pack_num_samples = 0;\n\t//we only activate sample packing for raw audio\n\tif (!trak->Media || !trak->Media->handler) return GF_FALSE;\n\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_AUDIO) return GF_FALSE;\n\t//and sample duration of 1\n\tif (!trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return GF_FALSE;\n\tif (trak->Media->information->sampleTable->TimeToSample->nb_entries != 1) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->TimeToSample->entries) return GF_FALSE;\n\tif (trak->Media->information->sampleTable->TimeToSample->entries[0].sampleDelta != 1) return GF_FALSE;\n\t//and sample with constant size\n\tif (!trak->Media->information->sampleTable->SampleSize || !trak->Media->information->sampleTable->SampleSize->sampleSize) return GF_FALSE;\n\ttrak->pack_num_samples = pack_num_samples;\n\n\tif (!pack_num_samples) return GF_FALSE;\n\n\tentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\tif (!entry) return GF_FALSE;\n\n\tif (entry->internal_type!=GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_FALSE;\n\n\t//sanity check, some files have wrong stsz sampleSize for raw audio !\n\tafmt = gf_audio_fmt_from_isobmf(entry->type);\n\tbps = gf_audio_fmt_bit_depth(afmt) / 8;\n\tif (!bps) {\n\t\t//unknown format, try QTv2\n\t\tif (entry->qtff_mode && (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_AUDIO)) {\n\t\t\tbps = entry->extensions[8]<<24 | entry->extensions[9]<<16 | entry->extensions[10]<<8 | entry->extensions[11];\n\t\t\tfrom_qt = GF_TRUE;\n\t\t}\n\t}\n\tnb_ch = entry->channel_count;\n\tif (entry->qtff_mode && (entry->version==2)) {\n\t\t//QTFFv2 audio, channel count is 32 bit, after 32bit size of struct and 64 bit samplerate\n\t\t//hence start at 12 in extensions\n\t\tnb_ch = entry->extensions[11]<<24 | entry->extensions[12]<<16 | entry->extensions[13]<<8 | entry->extensions[14];\n\t}\n\n\tif (bps) {\n\t\tu32 res = trak->Media->information->sampleTable->SampleSize->sampleSize % bps;\n\t\tif (res) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ISOBMF: size mismatch for raw audio sample description: constant sample size %d but %d bytes per channel for %s%s!\\n\", trak->Media->information->sampleTable->SampleSize->sampleSize,\n\t\t\t\t\tbps,\n\t\t\t\t\tgf_4cc_to_str(entry->type),\n\t\t\t\t\tfrom_qt ? \" (as indicated in QT sample description)\" : \"\"\n\t\t\t\t));\n\t\t\ttrak->Media->information->sampleTable->SampleSize->sampleSize = bps * nb_ch;\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nBool gf_isom_has_time_offset_table(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nu32 gf_isom_has_time_offset(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return 0;\n\n\t//return true at the first offset found\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\tif (ctts->entries[i].decodingOffset && ctts->entries[i].sampleCount) return ctts->version ? 2 : 1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\ns64 gf_isom_get_cts_to_dts_shift(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionToDecode) return 0;\n\treturn trak->Media->information->sampleTable->CompositionToDecode->compositionToDTSShift;\n}\n\nGF_EXPORT\nBool gf_isom_has_sync_shadows(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->ShadowSync) return GF_FALSE;\n\tif (gf_list_count(trak->Media->information->sampleTable->ShadowSync->entries) ) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_isom_has_sample_dependency(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->SampleDep) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_flags(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *isLeading, u32 *dependsOn, u32 *dependedOn, u32 *redundant)\n{\n\tGF_TrackBox *trak;\n\t*isLeading = 0;\n\t*dependsOn = 0;\n\t*dependedOn = 0;\n\t*redundant = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->SampleDep) return GF_BAD_PARAM;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber <= trak->sample_count_at_seg_start)\n\t\treturn GF_BAD_PARAM;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\treturn stbl_GetSampleDepType(trak->Media->information->sampleTable->SampleDep, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n\n//return a sample give its number, and set the SampleDescIndex of this sample\n//this index allows to retrieve the stream description if needed (2 media in 1 track)\n//return NULL if error\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 descIndex;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t\tif (static_sample->dataLength && !static_sample->alloc_size)\n\t\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t}\n\tif (!samp) return NULL;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start)\n\t\treturn NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset);\n\tif (static_sample && !static_sample->alloc_size)\n\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample) gf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n\tif (sampleDescriptionIndex) *sampleDescriptionIndex = descIndex;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn samp;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex)\n{\n\treturn gf_isom_get_sample_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, NULL, NULL);\n}\n\nGF_EXPORT\nu32 gf_isom_get_sample_duration(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu32 dur;\n\tu64 dts;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\tstbl_GetSampleDTS_and_Duration(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts, &dur);\n\treturn dur;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_sample_size(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu32 size = 0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tstbl_GetSampleSize(trak->Media->information->sampleTable->SampleSize, sampleNumber, &size);\n\treturn size;\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\n\treturn trak->Media->information->sampleTable->SampleSize->max_size;\n}\n\nGF_EXPORT\nu32 gf_isom_get_avg_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\n\tif ( trak->Media->information->sampleTable->SampleSize->sampleSize)\n\t\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n\n\tif (!trak->Media->information->sampleTable->SampleSize->total_samples) return 0;\n\treturn (u32) (trak->Media->information->sampleTable->SampleSize->total_size / trak->Media->information->sampleTable->SampleSize->total_samples);\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_delta(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return 0;\n\n\treturn trak->Media->information->sampleTable->TimeToSample->max_ts_delta;\n}\n\nGF_EXPORT\nu32 gf_isom_get_avg_sample_delta(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return 0;\n\n\tGF_TimeToSampleBox *stts = trak->Media->information->sampleTable->TimeToSample;\n\tu32 i, nb_ent = 0, min = 0;\n\tfor (i=0; i<stts->nb_entries; i++) {\n\t\tif (!nb_ent || nb_ent < stts->entries[i].sampleCount) {\n\t\t\tmin = stts->entries[i].sampleDelta;\n\t\t\tnb_ent = stts->entries[i].sampleCount;\n\t\t}\n\t}\n\treturn min;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_cts_offset(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->CompositionOffset) return 0;\n\n\treturn trak->Media->information->sampleTable->CompositionOffset->max_cts_delta;\n}\n\n\nGF_EXPORT\nBool gf_isom_get_sample_sync(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tGF_ISOSAPType is_rap;\n\tGF_Err e;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return GF_FALSE;\n\n\tif (! trak->Media->information->sampleTable->SyncSample) return GF_TRUE;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return GF_FALSE;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\te = stbl_GetSampleRAP(trak->Media->information->sampleTable->SyncSample, sampleNumber, &is_rap, NULL, NULL);\n\tif (e) return GF_FALSE;\n\treturn is_rap ? GF_TRUE : GF_FALSE;\n}\n\n//same as gf_isom_get_sample but doesn't fetch media data\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_info_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset, GF_ISOSample *static_sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t\tif (!samp) return NULL;\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset);\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\treturn samp;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset)\n{\n\treturn gf_isom_get_sample_info_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, data_offset, NULL);\n}\n\n\n//get sample dts\nGF_EXPORT\nu64 gf_isom_get_sample_dts(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu64 dts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tif (!sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (stbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts) != GF_OK) return 0;\n\treturn dts;\n}\n\nGF_EXPORT\nBool gf_isom_is_self_contained(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\treturn Media_IsSelfContained(trak->Media, sampleDescriptionIndex);\n}\n\n/*retrieves given sample DTS*/\nGF_EXPORT\nu32 gf_isom_get_sample_from_dts(GF_ISOFile *the_file, u32 trackNumber, u64 dts)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber;\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tstbl = trak->Media->information->sampleTable;\n\n\te = stbl_findEntryForTime(stbl, dts, 1, &sampleNumber, &prevSampleNumber);\n\tif (e) return 0;\n\treturn sampleNumber;\n}\n\n\n//return a sample given a desired display time IN MEDIA TIME SCALE\n//and set the StreamDescIndex of this sample\n//this index allows to retrieve the stream description if needed (2 media in 1 track)\n//return NULL if error\n//WARNING: the sample may not be sync even though the sync was requested (depends on the media)\nGF_EXPORT\nGF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, syncNum, shadowSync;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *shadow;\n\tGF_SampleTableBox *stbl;\n\tBool static_sample = GF_FALSE;\n\tu8 useShadow, IsSync;\n\n\tif (SampleNum) *SampleNum = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (desiredTime < trak->dts_at_seg_start) {\n\t\tdesiredTime = 0;\n\t} else {\n\t\tdesiredTime -= trak->dts_at_seg_start;\n\t}\n#endif\n\n\te = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//if no shadow table, reset to sync only\n\tuseShadow = 0;\n\tif (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))\n\t\tSearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t//if no syncTable, disable syncSearching, as all samples ARE sync\n\tif (! trak->Media->information->sampleTable->SyncSample) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;\n\t}\n\n\t//not found, return EOF or browse backward\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {\n\t\t\tsampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t\tif (!sampleNumber) return GF_EOS;\n\t}\n\n\t//check in case we have the perfect sample\n\tIsSync = 0;\n\n\t//according to the direction adjust the sampleNum value\n\tswitch (SearchMode) {\n\tcase GF_ISOM_SEARCH_SYNC_FORWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_FORWARD:\n\t\t//not the exact one\n\t\tif (!sampleNumber) {\n\t\t\tif (prevSampleNumber != stbl->SampleSize->sampleCount) {\n\t\t\t\tsampleNumber = prevSampleNumber + 1;\n\t\t\t} else {\n\t\t\t\tsampleNumber = prevSampleNumber;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t//if dummy mode, reset to default browsing\n\tcase GF_ISOM_SEARCH_SYNC_BACKWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_SYNC_SHADOW:\n\tcase GF_ISOM_SEARCH_BACKWARD:\n\tdefault:\n\t\t//first case, not found....\n\t\tif (!sampleNumber && !prevSampleNumber) {\n\t\t\tsampleNumber = stbl->SampleSize->sampleCount;\n\t\t} else if (!sampleNumber) {\n\t\t\tsampleNumber = prevSampleNumber;\n\t\t}\n\t\tbreak;\n\t}\n\n\t//get the sync sample num\n\tif (IsSync) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, SearchMode);\n\t\tif (e) return e;\n\t\tif (syncNum) sampleNumber = syncNum;\n\t\tsyncNum = 0;\n\t}\n\t//if we are in shadow mode, get the previous sync sample\n\t//in case we can't find a good SyncShadow\n\telse if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);\n\t\tif (e) return e;\n\t}\n\n\n\t//OK sampleNumber is exactly the sample we need (except for shadow)\n\n\tif (sample) {\n\t\tif (*sample) {\n\t\t\tstatic_sample = GF_TRUE;\n\t\t} else {\n\t\t\t*sample = gf_isom_sample_new();\n\t\t\tif (*sample == NULL) return GF_OUT_OF_MEM;\n\t\t}\n\t}\n\t//we are in shadow mode, we need to browse both SyncSample and ShadowSyncSample to get\n\t//the desired sample...\n\tif (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the shadowing number\n\t\tstbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);\n\t\t//now sampleNumber is the closest previous shadowed sample.\n\t\t//1- If we have a closer sync sample, use it.\n\t\t//2- if the shadowSync is 0, we don't have any shadowing, use syncNum\n\t\tif ((sampleNumber < syncNum) || (!shadowSync)) {\n\t\t\tsampleNumber = syncNum;\n\t\t} else {\n\t\t\t//otherwise, we have a better alternate sample in the shadowSync for this sample\n\t\t\tuseShadow = 1;\n\t\t}\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);\n\tif (e) {\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(sample);\n\t\telse if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )\n\t\t \t(*sample)->alloc_size =  (*sample)->dataLength;\n\n\t\treturn e;\n\t}\n\tif (sample && ! (*sample)->IsRAP) {\n\t\tBool is_rap;\n\t\tGF_ISOSampleRollType roll_type;\n\t\te = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);\n\t\tif (e) return e;\n\t\tif (is_rap) (*sample)->IsRAP = SAP_TYPE_3;\n\t}\n\t//optionally get the sample number\n\tif (SampleNum) {\n\t\t*SampleNum = sampleNumber;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t*SampleNum += trak->sample_count_at_seg_start;\n#endif\n\t}\n\n\t//in shadow mode, we only get the data of the shadowing sample !\n\tif (sample && useShadow) {\n\t\t//we have to use StreamDescriptionIndex in case the sample data is in another desc\n\t\t//though this is unlikely as non optimized...\n\t\tshadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);\n\t\t//if no sample, the shadowSync is broken, return the sample\n\t\tif (!shadow) return GF_OK;\n\t\t(*sample)->IsRAP = RAP;\n\t\tgf_free((*sample)->data);\n\t\t(*sample)->dataLength = shadow->dataLength;\n\t\t(*sample)->data = shadow->data;\n\t\t//set data length to 0 to keep the buffer alive...\n\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\t\t \n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_for_movie_time(GF_ISOFile *the_file, u32 trackNumber, u64 movieTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *sampleNumber, u64 *data_offset)\n{\n\tDouble tsscale;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tu64 mediaTime, nextMediaTime;\n\ts64 segStartTime, mediaOffset;\n\tu32 sampNum;\n\tu8 useEdit;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//only check duration if initially set - do not check duration as updated after fragment merge since that duration does not take\n\t//into account tfdt\n\tif (trak->Header->initial_duration\n\t\t&& gf_timestamp_greater(movieTime, trak->Media->mediaHeader->timeScale, trak->Header->initial_duration, trak->moov->mvhd->timeScale)\n\t) {\n\t\tif (sampleNumber) *sampleNumber = 0;\n\t\t*StreamDescriptionIndex = 0;\n\t\treturn GF_EOS;\n\t}\n\n\t//get the media time for this movie time...\n\tmediaTime = segStartTime = 0;\n\t*StreamDescriptionIndex = 0;\n\tnextMediaTime = 0;\n\n\te = GetMediaTime(trak, (SearchMode==GF_ISOM_SEARCH_SYNC_FORWARD) ? GF_TRUE : GF_FALSE, movieTime, &mediaTime, &segStartTime, &mediaOffset, &useEdit, &nextMediaTime);\n\tif (e) return e;\n\n\t/*here we check if we were playing or not and return no sample in normal search modes*/\n\tif (useEdit && mediaOffset == -1) {\n\t\tif ((SearchMode==GF_ISOM_SEARCH_FORWARD) || (SearchMode==GF_ISOM_SEARCH_BACKWARD)) {\n\t\t\t/*get next sample time in MOVIE timescale*/\n\t\t\tif (SearchMode==GF_ISOM_SEARCH_FORWARD)\n\t\t\t\te = GetNextMediaTime(trak, movieTime, &mediaTime);\n\t\t\telse\n\t\t\t\te = GetPrevMediaTime(trak, movieTime, &mediaTime);\n\t\t\tif (e) return e;\n\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, (u32) mediaTime, StreamDescriptionIndex, GF_ISOM_SEARCH_SYNC_FORWARD, sample, sampleNumber, data_offset);\n\t\t}\n\t\tif (sampleNumber) *sampleNumber = 0;\n\t\tif (sample) {\n\t\t\tif (! (*sample)) {\n\t\t\t\t*sample = gf_isom_sample_new();\n\t\t\t\tif (! *sample) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\t(*sample)->DTS = movieTime;\n\t\t\t(*sample)->dataLength = 0;\n\t\t\t(*sample)->CTS_Offset = 0;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\t/*dwell edit in non-sync mode, fetch next/prev sample depending on mode.\n\tOtherwise return the dwell entry*/\n\tif (useEdit==2) {\n\t\tif ((SearchMode==GF_ISOM_SEARCH_FORWARD) || (SearchMode==GF_ISOM_SEARCH_BACKWARD)) {\n\t\t\t/*get next sample time in MOVIE timescale*/\n\t\t\tif (SearchMode==GF_ISOM_SEARCH_FORWARD)\n\t\t\t\te = GetNextMediaTime(trak, movieTime, &mediaTime);\n\t\t\telse\n\t\t\t\te = GetPrevMediaTime(trak, movieTime, &mediaTime);\n\t\t\tif (e) return e;\n\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, (u32) mediaTime, StreamDescriptionIndex, GF_ISOM_SEARCH_SYNC_FORWARD, sample, sampleNumber, data_offset);\n\t\t}\n\t}\n\n\ttsscale = trak->Media->mediaHeader->timeScale;\n\ttsscale /= trak->moov->mvhd->timeScale;\n\n\t//OK, we have a sample so fetch it\n\te = gf_isom_get_sample_for_media_time(the_file, trackNumber, mediaTime, StreamDescriptionIndex, SearchMode, sample, &sampNum, data_offset);\n\tif (e) {\n\t\tif (e==GF_EOS) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t//movie is fragmented and samples not yet received, return EOS\n\t\t\tif (the_file->moov->mvex && !trak->Media->information->sampleTable->SampleSize->sampleCount)\n\t\t\t\treturn e;\n#endif\n\n\t\t\tif ((SearchMode==GF_ISOM_SEARCH_SYNC_BACKWARD) || (SearchMode==GF_ISOM_SEARCH_BACKWARD)) {\n\t\t\t\tif (nextMediaTime && (nextMediaTime-1 < movieTime))\n\t\t\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, nextMediaTime-1, StreamDescriptionIndex, SearchMode, sample, sampleNumber, data_offset);\n\t\t\t} else {\n\t\t\t\tif (nextMediaTime && (nextMediaTime-1 > movieTime))\n\t\t\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, nextMediaTime-1, StreamDescriptionIndex, SearchMode, sample, sampleNumber, data_offset);\n\t\t\t}\n\t\t}\n\t\treturn e;\n\t}\n\n\t//OK, now the trick: we have to rebuild the time stamps, according\n\t//to the media time scale (used by SLConfig) - add the edit start time but stay in\n\t//the track TS\n\tif (sample && useEdit) {\n\t\tu64 _ts = (u64)(segStartTime * tsscale);\n\n\t\t(*sample)->DTS += _ts;\n\t\t/*watchout, the sample fetched may be before the first sample in the edit list (when seeking)*/\n\t\tif ( (*sample)->DTS > (u64) mediaOffset) {\n\t\t\t(*sample)->DTS -= (u64) mediaOffset;\n\t\t} else {\n\t\t\t(*sample)->DTS = 0;\n\t\t}\n\t}\n\tif (sampleNumber) *sampleNumber = sampNum;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sample && (*sample) ) (*sample)->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn GF_OK;\n}\n\n\n\nGF_EXPORT\nu64 gf_isom_get_missing_bytes(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\treturn trak->Media->BytesMissing;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_padding(GF_ISOFile *the_file, u32 trackNumber, u32 padding_bytes)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->padding_bytes = padding_bytes;\n\treturn GF_OK;\n\n}\n\n//get the number of edited segment\nGF_EXPORT\nBool gf_isom_get_edit_list_type(GF_ISOFile *the_file, u32 trackNumber, s64 *mediaOffset)\n{\n\tGF_EdtsEntry *ent;\n\tGF_TrackBox *trak;\n\tu32 count;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\t*mediaOffset = 0;\n\tif (!trak->editBox || !trak->editBox->editList) return GF_FALSE;\n\n\tcount = gf_list_count(trak->editBox->editList->entryList);\n\tent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 0);\n\tif (!ent) return GF_TRUE;\n\t/*mediaRate>0, the track playback shall start at media time>0 -> mediaOffset is < 0 */\n\tif ((count==1) && (ent->mediaRate == 0x10000) && (ent->mediaTime>=0)) {\n\t\t*mediaOffset = - ent->mediaTime;\n\t\treturn GF_FALSE;\n\t} else if (count==2) {\n\t\t/*mediaTime==-1, the track playback shall be empty for segmentDuration -> mediaOffset is > 0 */\n\t\tif ((ent->mediaRate == -0x10000) || (ent->mediaTime==-1)) {\n\t\t\tDouble time = (Double) ent->segmentDuration;\n\t\t\ttime /= trak->moov->mvhd->timeScale;\n\t\t\ttime *= trak->Media->mediaHeader->timeScale;\n\t\t\t*mediaOffset = (s64) time;\n\n\t\t\t//check next entry, if we start from mediaOffset > 0 this may still result in a skip\n\t\t\tent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 1);\n\t\t\t//next entry playback rate is not nominal, we need edit list handling\n\t\t\tif (ent->mediaRate != 0x10000)\n\t\t\t\treturn GF_TRUE;\n\n\t\t\tif (ent->mediaTime > 0) {\n\t\t\t\t*mediaOffset -= ent->mediaTime;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\n\n//get the number of edited segment\nGF_EXPORT\nu32 gf_isom_get_edits_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tif (!trak->editBox || !trak->editBox->editList) return 0;\n\treturn gf_list_count(trak->editBox->editList->entryList);\n}\n\n\n//Get the desired segment information\nGF_EXPORT\nGF_Err gf_isom_get_edit(GF_ISOFile *the_file, u32 trackNumber, u32 SegmentIndex, u64 *EditTime, u64 *SegmentDuration, u64 *MediaTime, GF_ISOEditType *EditMode)\n{\n\tu32 i;\n\tu64 startTime;\n\tGF_TrackBox *trak;\n\tGF_EditListBox *elst;\n\tGF_EdtsEntry *ent;\n\n\tent = NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->editBox ||\n\t        !trak->editBox->editList ||\n\t        (SegmentIndex > gf_list_count(trak->editBox->editList->entryList)) ||\n\t        !SegmentIndex)\n\t\treturn GF_BAD_PARAM;\n\n\telst = trak->editBox->editList;\n\tstartTime = 0;\n\n\tfor (i = 0; i < SegmentIndex; i++) {\n\t\tent = (GF_EdtsEntry*)gf_list_get(elst->entryList, i);\n\t\tif (i < SegmentIndex-1) startTime += ent->segmentDuration;\n\t}\n\t*EditTime = startTime;\n\t*SegmentDuration = ent->segmentDuration;\n\tif (ent->mediaTime < 0) {\n\t\t*MediaTime = 0;\n\t\t*EditMode = GF_ISOM_EDIT_EMPTY;\n\t\treturn GF_OK;\n\t}\n\tif (ent->mediaRate == 0) {\n\t\t*MediaTime = ent->mediaTime;\n\t\t*EditMode = GF_ISOM_EDIT_DWELL;\n\t\treturn GF_OK;\n\t}\n\t*MediaTime = ent->mediaTime;\n\t*EditMode = GF_ISOM_EDIT_NORMAL;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu8 gf_isom_has_sync_points(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\tif (!trak->Media->information->sampleTable->SyncSample->nb_entries) return 2;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*returns number of sync points*/\nGF_EXPORT\nu32 gf_isom_get_sync_point_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\treturn trak->Media->information->sampleTable->SyncSample->nb_entries;\n\t}\n\treturn 0;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_get_brand_info(GF_ISOFile *movie, u32 *brand, u32 *minorVersion, u32 *AlternateBrandsCount)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tif (!movie->brand) {\n\t\tif (brand) *brand = GF_ISOM_BRAND_ISOM;\n\t\tif (minorVersion) *minorVersion = 1;\n\t\tif (AlternateBrandsCount) *AlternateBrandsCount = 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (brand) *brand = movie->brand->majorBrand;\n\tif (minorVersion) *minorVersion = movie->brand->minorVersion;\n\tif (AlternateBrandsCount) *AlternateBrandsCount = movie->brand->altCount;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_alternate_brand(GF_ISOFile *movie, u32 BrandIndex, u32 *brand)\n{\n\tif (!movie || !movie->brand || !brand) return GF_BAD_PARAM;\n\tif (BrandIndex > movie->brand->altCount || !BrandIndex) return GF_BAD_PARAM;\n\t*brand = movie->brand->altBrand[BrandIndex-1];\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u32 *gf_isom_get_brands(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->brand) return NULL;\n\treturn movie->brand->altBrand;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_padding_bits(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u8 *NbBits)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\t//Padding info\n\treturn stbl_GetPaddingBits(trak->Media->information->sampleTable->PaddingBits,\n\t                           sampleNumber, NbBits);\n\n}\n\n\nGF_EXPORT\nBool gf_isom_has_padding_bits(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tif (trak->Media->information->sampleTable->PaddingBits) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_udta_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tif (!movie || !movie->moov) return 0;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (udta) return gf_list_count(udta->recordList);\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_udta_type(GF_ISOFile *movie, u32 trackNumber, u32 udta_idx, u32 *UserDataType, bin128 *UUID)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tif (!movie || !movie->moov || !udta_idx) return GF_BAD_PARAM;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_OK;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tif (udta_idx>gf_list_count(udta->recordList)) return GF_BAD_PARAM;\n\tmap = (GF_UserDataMap*)gf_list_get(udta->recordList, udta_idx - 1);\n\tif (UserDataType) *UserDataType = map->boxType;\n\tif (UUID) memcpy(*UUID, map->uuid, 16);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_user_data_count(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tbin128 t;\n\tu32 i, count;\n\n\tif (!movie || !movie->moov) return 0;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tcount = gf_list_count(map->boxes);\n\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) return count;\n\t\telse if (map->boxType == UserDataType) return count;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex, u8 **userData, u32 *userDataSize)\n{\n\tGF_UserDataMap *map;\n\tGF_UnknownBox *ptr;\n\tGF_BitStream *bs;\n\tu32 i;\n\tbin128 t;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (!userData || !userDataSize || *userData) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\n\t}\n\treturn GF_BAD_PARAM;\n\nfound:\n\tif (UserDataIndex) {\n\t\tif (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;\n\t\tptr = (GF_UnknownBox*)gf_list_get(map->boxes, UserDataIndex-1);\n\n\t\tif (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tif (!ptr->dataSize) {\n\t\t\t\t*userData = NULL;\n\t\t\t\t*userDataSize = 0;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\t*userData = (char *)gf_malloc(sizeof(char)*ptr->dataSize);\n\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(*userData, ptr->data, sizeof(char)*ptr->dataSize);\n\t\t\t*userDataSize = ptr->dataSize;\n\t\t\treturn GF_OK;\n\t\t} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tGF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;\n\t\t\tif (!p_uuid->dataSize) {\n\t\t\t\t*userData = NULL;\n\t\t\t\t*userDataSize = 0;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\t*userData = (char *)gf_malloc(sizeof(char)*p_uuid->dataSize);\n\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(*userData, p_uuid->data, sizeof(char)*p_uuid->dataSize);\n\t\t\t*userDataSize = p_uuid->dataSize;\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tchar *str = NULL;\n\t\t\tswitch (ptr->type) {\n\t\t\tcase GF_ISOM_BOX_TYPE_NAME:\n\t\t\t//case GF_QT_BOX_TYPE_NAME: same as above\n\t\t\t\tstr = ((GF_NameBox *)ptr)->string;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_BOX_TYPE_KIND:\n\t\t\t\tstr = ((GF_KindBox *)ptr)->value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (str) {\n\t\t\t\tu32 len = (u32) strlen(str) + 1;\n\t\t\t\t*userData = (char *)gf_malloc(sizeof(char) * len);\n\t\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(*userData, str, sizeof(char)*len);\n\t\t\t\t*userDataSize = len;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t}\n\n\t//serialize all boxes\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\ti=0;\n\twhile ( (ptr = (GF_UnknownBox*)gf_list_enum(map->boxes, &i))) {\n\t\tu32 type, s, data_size;\n\t\tchar *data=NULL;\n\t\tif (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\ttype = ptr->original_4cc;\n\t\t\tdata_size = ptr->dataSize;\n\t\t\tdata = ptr->data;\n\t\t} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tGF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;\n\t\t\ttype = p_uuid->type;\n\t\t\tdata_size = p_uuid->dataSize;\n\t\t\tdata = p_uuid->data;\n\t\t} else {\n\t\t\tgf_isom_box_write((GF_Box *)ptr, bs);\n\t\t\tcontinue;\n\t\t}\n\t\ts = data_size+8;\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_UUID) s += 16;\n\n\t\tgf_bs_write_u32(bs, s);\n\t\tgf_bs_write_u32(bs, type);\n\t\tif (type==GF_ISOM_BOX_TYPE_UUID) gf_bs_write_data(bs, (char *) map->uuid, 16);\n\t\tif (data) {\n\t\t\tgf_bs_write_data(bs, data, data_size);\n\t\t} else if (ptr->child_boxes) {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\tgf_isom_box_array_write((GF_Box *)ptr, ptr->child_boxes, bs);\n#else\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ISOBMF: udta is a box-list - cannot export in read-only version of libisom in GPAC\\n\" ));\n#endif\n\t\t}\n\t}\n\tgf_bs_get_content(bs, userData, userDataSize);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_delete(GF_ISOFile *movie)\n{\n\t//free and return;\n\tgf_isom_delete_movie(movie);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chunks_infos(GF_ISOFile *movie, u32 trackNumber, u32 *dur_min, u32 *dur_avg, u32 *dur_max, u32 *size_min, u32 *size_avg, u32 *size_max)\n{\n\tGF_TrackBox *trak;\n\tu32 i, k, sample_idx, dmin, dmax, smin, smax, tot_chunks;\n\tu64 davg, savg;\n\tGF_SampleToChunkBox *stsc;\n\tGF_TimeToSampleBox *stts;\n\tif (!movie || !trackNumber || !movie->moov) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsc = trak->Media->information->sampleTable->SampleToChunk;\n\tstts = trak->Media->information->sampleTable->TimeToSample;\n\tif (!stsc || !stts) return GF_ISOM_INVALID_FILE;\n\n\tdmin = smin = (u32) -1;\n\tdmax = smax = 0;\n\tdavg = savg = 0;\n\tsample_idx = 1;\n\ttot_chunks = 0;\n\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\tu32 nb_chunk = 0;\n\t\tif (stsc->entries[i].samplesPerChunk >  2*trak->Media->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] likely broken stco entry (%u samples per chunk but %u samples total)\\n\", stsc->entries[i].samplesPerChunk, trak->Media->information->sampleTable->SampleSize->sampleCount));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\twhile (1) {\n\t\t\tu32 chunk_dur = 0;\n\t\t\tu32 chunk_size = 0;\n\t\t\tfor (k=0; k<stsc->entries[i].samplesPerChunk; k++) {\n\t\t\t\tu64 dts;\n\t\t\t\tu32 dur;\n\t\t\t\tu32 size;\n\t\t\t\tstbl_GetSampleDTS_and_Duration(stts, k+sample_idx, &dts, &dur);\n\t\t\t\tchunk_dur += dur;\n\t\t\t\tstbl_GetSampleSize(trak->Media->information->sampleTable->SampleSize, k+sample_idx, &size);\n\t\t\t\tchunk_size += size;\n\n\t\t\t}\n\t\t\tif (dmin>chunk_dur) dmin = chunk_dur;\n\t\t\tif (dmax<chunk_dur) dmax = chunk_dur;\n\t\t\tdavg += chunk_dur;\n\t\t\tif (smin>chunk_size) smin = chunk_size;\n\t\t\tif (smax<chunk_size) smax = chunk_size;\n\t\t\tsavg += chunk_size;\n\n\t\t\ttot_chunks ++;\n\t\t\tsample_idx += stsc->entries[i].samplesPerChunk;\n\t\t\tif (i+1==stsc->nb_entries) break;\n\t\t\tnb_chunk ++;\n\t\t\tif (stsc->entries[i].firstChunk + nb_chunk == stsc->entries[i+1].firstChunk) break;\n\t\t}\n\t}\n\tif (tot_chunks) {\n\t\tdavg /= tot_chunks;\n\t\tsavg /= tot_chunks;\n\t}\n\tif (dur_min) *dur_min = dmin;\n\tif (dur_avg) *dur_avg = (u32) davg;\n\tif (dur_max) *dur_max = dmax;\n\n\tif (size_min) *size_min = smin;\n\tif (size_avg) *size_avg = (u32) savg;\n\tif (size_max) *size_max = smax;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_fragment_defaults(GF_ISOFile *the_file, u32 trackNumber,\n                                     u32 *defaultDuration, u32 *defaultSize, u32 *defaultDescriptionIndex,\n                                     u32 *defaultRandomAccess, u8 *defaultPadding, u16 *defaultDegradationPriority)\n{\n\tGF_TrackBox *trak;\n\tGF_StscEntry *sc_ent;\n\tu32 i, j, maxValue, value;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackExtendsBox *trex;\n#endif\n\tGF_SampleTableBox *stbl;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*if trex is already set, restore flags*/\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\ttrex = the_file->moov->mvex ? GetTrex(the_file->moov, gf_isom_get_track_id(the_file,trackNumber) ) : NULL;\n\tif (trex) {\n\t\ttrex->track = trak;\n\n\t\tif (defaultDuration) *defaultDuration = trex->def_sample_duration;\n\t\tif (defaultSize) *defaultSize = trex->def_sample_size;\n\t\tif (defaultDescriptionIndex) *defaultDescriptionIndex = trex->def_sample_desc_index;\n\t\tif (defaultRandomAccess) *defaultRandomAccess = GF_ISOM_GET_FRAG_SYNC(trex->def_sample_flags);\n\t\tif (defaultPadding) *defaultPadding = GF_ISOM_GET_FRAG_PAD(trex->def_sample_flags);\n\t\tif (defaultDegradationPriority) *defaultDegradationPriority = GF_ISOM_GET_FRAG_DEG(trex->def_sample_flags);\n\t\treturn GF_OK;\n\t}\n#endif\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->TimeToSample || !stbl->SampleSize || !stbl->SampleToChunk) return GF_ISOM_INVALID_FILE;\n\n\n\t//duration\n\tif (defaultDuration) {\n\t\tmaxValue = value = 0;\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tif (stbl->TimeToSample->entries[i].sampleCount>maxValue) {\n\t\t\t\tvalue = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\t\tmaxValue = stbl->TimeToSample->entries[i].sampleCount;\n\t\t\t}\n\t\t}\n\t\t*defaultDuration = value;\n\t}\n\t//size\n\tif (defaultSize) {\n\t\t*defaultSize = stbl->SampleSize->sampleSize;\n\t}\n\t//descIndex\n\tif (defaultDescriptionIndex) {\n\t\tGF_SampleToChunkBox *stsc= stbl->SampleToChunk;\n\t\tmaxValue = value = 0;\n\t\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\t\tsc_ent = &stsc->entries[i];\n\t\t\tif ((sc_ent->nextChunk - sc_ent->firstChunk) * sc_ent->samplesPerChunk > maxValue) {\n\t\t\t\tvalue = sc_ent->sampleDescriptionIndex;\n\t\t\t\tmaxValue = (sc_ent->nextChunk - sc_ent->firstChunk) * sc_ent->samplesPerChunk;\n\t\t\t}\n\t\t}\n\t\t*defaultDescriptionIndex = value ? value : 1;\n\t}\n\t//RAP\n\tif (defaultRandomAccess) {\n\t\t//no sync table is ALL RAP\n\t\t*defaultRandomAccess = stbl->SyncSample ? 0 : 1;\n\t\tif (stbl->SyncSample\n\t\t        && (stbl->SyncSample->nb_entries == stbl->SampleSize->sampleCount)) {\n\t\t\t*defaultRandomAccess = 1;\n\t\t}\n\t}\n\t//defaultPadding\n\tif (defaultPadding) {\n\t\t*defaultPadding = 0;\n\t\tif (stbl->PaddingBits) {\n\t\t\tmaxValue = 0;\n\t\t\tfor (i=0; i<stbl->PaddingBits->SampleCount; i++) {\n\t\t\t\tvalue = 0;\n\t\t\t\tfor (j=0; j<stbl->PaddingBits->SampleCount; j++) {\n\t\t\t\t\tif (stbl->PaddingBits->padbits[i]==stbl->PaddingBits->padbits[j]) {\n\t\t\t\t\t\tvalue ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value>maxValue) {\n\t\t\t\t\tmaxValue = value;\n\t\t\t\t\t*defaultPadding = stbl->PaddingBits->padbits[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//defaultDegradationPriority\n\tif (defaultDegradationPriority) {\n\t\t*defaultDegradationPriority = 0;\n\t\tif (stbl->DegradationPriority) {\n\t\t\tmaxValue = 0;\n\t\t\tfor (i=0; i<stbl->DegradationPriority->nb_entries; i++) {\n\t\t\t\tvalue = 0;\n\t\t\t\tfor (j=0; j<stbl->DegradationPriority->nb_entries; j++) {\n\t\t\t\t\tif (stbl->DegradationPriority->priorities[i]==stbl->DegradationPriority->priorities[j]) {\n\t\t\t\t\t\tvalue ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value>maxValue) {\n\t\t\t\t\tmaxValue = value;\n\t\t\t\t\t*defaultDegradationPriority = stbl->DegradationPriority->priorities[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_refresh_fragmented(GF_ISOFile *movie, u64 *MissingBytes, const char *new_location)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn GF_NOT_SUPPORTED;\n#else\n\tu64 prevsize, size;\n\tu32 i;\n\tif (!movie || !movie->movieFileMap || !movie->moov) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_READ) return GF_BAD_PARAM;\n\n\t/*refresh size*/\n\tsize = movie->movieFileMap ? gf_bs_get_size(movie->movieFileMap->bs) : 0;\n\n\tif (new_location) {\n\t\tBool delete_map;\n\t\tGF_DataMap *previous_movie_fileMap_address = movie->movieFileMap;\n\t\tGF_Err e;\n\n\t\te = gf_isom_datamap_new(new_location, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &movie->movieFileMap);\n\t\tif (e) {\n\t\t\tmovie->movieFileMap = previous_movie_fileMap_address;\n\t\t\treturn e;\n\t\t}\n\n\t\tdelete_map = (previous_movie_fileMap_address != NULL ? GF_TRUE: GF_FALSE);\n\t\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\t\t\tif (trak->Media->information->dataHandler == previous_movie_fileMap_address) {\n\t\t\t\t//reaasign for later destruction\n\t\t\t\ttrak->Media->information->scalableDataHandler = movie->movieFileMap;\n\t\t\t\t//reassign for Media_GetSample function\n\t\t\t\ttrak->Media->information->dataHandler = movie->movieFileMap;\n\t\t\t} else if (trak->Media->information->scalableDataHandler == previous_movie_fileMap_address) {\n\t\t\t\tdelete_map = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\tif (delete_map) {\n\t\t\tgf_isom_datamap_del(previous_movie_fileMap_address);\n\t\t}\n\t}\n\n\tprevsize = gf_bs_get_refreshed_size(movie->movieFileMap->bs);\n\tif (prevsize==size) return GF_OK;\n\n\tif (!movie->moov->mvex)\n\t\treturn GF_OK;\n\n\t//ok parse root boxes\n\treturn gf_isom_parse_movie_boxes(movie, NULL, MissingBytes, GF_TRUE);\n#endif\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_EXPORT\nvoid gf_isom_set_single_moof_mode(GF_ISOFile *movie, Bool mode)\n{\n\tmovie->single_moof_mode = mode;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_reset_data_offset(GF_ISOFile *movie, u64 *top_box_start)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, count;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tif (top_box_start) *top_box_start = movie->current_top_box_start;\n\tmovie->current_top_box_start = 0;\n\tmovie->NextMoofNumber = 0;\n\tif (movie->moov->mvex && movie->single_moof_mode) {\n\t\tmovie->single_moof_state = 0;\n\t}\n\tcount = gf_list_count(movie->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *tk = gf_list_get(movie->moov->trackList, i);\n\t\ttk->first_traf_merged = GF_FALSE;\n\t}\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_current_top_box_offset(GF_ISOFile *movie, u64 *current_top_box_offset)\n{\n\tif (!movie || !movie->moov || !current_top_box_offset) return GF_BAD_PARAM;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t*current_top_box_offset = movie->current_top_box_start;\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_removed_bytes(GF_ISOFile *movie, u64 bytes_removed)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tmovie->bytes_removed = bytes_removed;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_purge_samples(GF_ISOFile *the_file, u32 trackNumber, u32 nb_samples)\n{\n\tGF_TrackBox *trak;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Err e;\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleTableBox *stbl;\n#endif\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*if trex is already set, restore flags*/\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\ttrex = the_file->moov->mvex ? GetTrex(the_file->moov, gf_isom_get_track_id(the_file,trackNumber) ) : NULL;\n\tif (!trex) return GF_BAD_PARAM;\n\n\t//first unpack chunk offsets and CTS\n\te = stbl_UnpackOffsets(trak->Media->information->sampleTable);\n\tif (e) return e;\n\te = stbl_unpackCTS(trak->Media->information->sampleTable);\n\tif (e) return e;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->TimeToSample || !stbl->SampleSize || !stbl->SampleToChunk) return GF_ISOM_INVALID_FILE;\n\n\t//remove at once nb_samples in stts, ctts, stsz, stco, stsc and stdp (n-times removal is way too slow)\n\t//do NOT change the order DTS, CTS, size chunk\n\tstbl_RemoveDTS(stbl, 1, nb_samples, 0);\n\tstbl_RemoveCTS(stbl, 1, nb_samples);\n\tstbl_RemoveSize(stbl, 1, nb_samples);\n\tstbl_RemoveChunk(stbl, 1, nb_samples);\n\tstbl_RemoveRedundant(stbl, 1, nb_samples);\n\tstbl_RemoveRAPs(stbl, nb_samples);\n\n\t//then remove sample per sample for the rest, which is either\n\t//- sparse data\n\t//- allocated structure rather than memmove-able array\n\t//- not very frequent info (paddind bits)\n\twhile (nb_samples) {\n\t\tstbl_RemoveShadow(stbl, 1);\n\t\tstbl_RemoveSubSample(stbl, 1);\n\t\tstbl_RemovePaddingBits(stbl, 1);\n\t\tstbl_RemoveSampleGroup(stbl, 1);\n\t\tnb_samples--;\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n//reset SampleTable boxes, but do not destroy them if memory reuse is possible\n//this reduces free/alloc time when many fragments\nstatic void gf_isom_recreate_tables(GF_TrackBox *trak)\n{\n\tu32 j;\n\tGF_Box *a;\n\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\tif (stbl->ChunkOffset) {\n\t\tif (stbl->ChunkOffset->type==GF_ISOM_BOX_TYPE_CO64) {\n\t\t\tGF_ChunkLargeOffsetBox *co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\t\tco64->nb_entries = 0;\n\t\t} else {\n\t\t\tGF_ChunkOffsetBox *stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\t\tstco->nb_entries = 0;\n\t\t}\n\t}\n\n\tif (stbl->CompositionOffset) {\n\t\tstbl->CompositionOffset->nb_entries = 0;\n\t\tstbl->CompositionOffset->w_LastSampleNumber = 0;\n\t\tstbl->CompositionOffset->r_currentEntryIndex = 0;\n\t\tstbl->CompositionOffset->r_FirstSampleInEntry = 0;\n\t\tstbl->CompositionOffset->max_cts_delta = 0;\n\t}\n\n\tif (stbl->DegradationPriority) {\n\t\tstbl->DegradationPriority->nb_entries = 0;\n\t}\n\n\tif (stbl->PaddingBits) {\n\t\tstbl->PaddingBits->SampleCount = 0;\n\t}\n\n\tif (stbl->SampleDep) {\n\t\tstbl->SampleDep->sampleCount = 0;\n\t}\n\n\tif (stbl->SampleSize) {\n\t\tstbl->SampleSize->sampleSize = 0;\n\t\tstbl->SampleSize->sampleCount = 0;\n\t}\n\n\tif (stbl->SampleToChunk) {\n\t\tstbl->SampleToChunk->nb_entries = 0;\n\t\tstbl->SampleToChunk->currentIndex = 0;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk = 0;\n\t\tstbl->SampleToChunk->currentChunk = 0;\n\t\tstbl->SampleToChunk->ghostNumber = 0;\n\t\tstbl->SampleToChunk->w_lastSampleNumber = 0;\n\t\tstbl->SampleToChunk->w_lastChunkNumber = 0;\n\t}\n\n\tif (stbl->ShadowSync) {\n        gf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) stbl->ShadowSync);\n        stbl->ShadowSync = (GF_ShadowSyncBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSH);\n\t}\n\n\tif (stbl->SyncSample) {\n\t\tstbl->SyncSample->nb_entries = 0;\n\t\tstbl->SyncSample->r_LastSyncSample = 0;\n\t\tstbl->SyncSample->r_LastSampleIndex = 0;\n\t}\n\n\tif (stbl->TimeToSample) {\n\t\tstbl->TimeToSample->nb_entries = 0;\n\t\tstbl->TimeToSample->r_FirstSampleInEntry = 0;\n\t\tstbl->TimeToSample->r_currentEntryIndex = 0;\n\t\tstbl->TimeToSample->r_CurrentDTS = 0;\n\t}\n\n\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_offsets);\n\tstbl->sai_offsets = NULL;\n\n\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_sizes);\n\tstbl->sai_sizes = NULL;\n\n\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sampleGroups);\n\tstbl->sampleGroups = NULL;\n\n\tif (trak->sample_encryption) {\n\t\tif (trak->Media->information->sampleTable->child_boxes) {\n\t\t\tgf_list_del_item(trak->Media->information->sampleTable->child_boxes, trak->sample_encryption);\n\t\t}\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box*)trak->sample_encryption);\n\t\ttrak->sample_encryption = NULL;\n\t}\n\n\tj = stbl->nb_sgpd_in_stbl;\n\twhile ((a = (GF_Box *)gf_list_enum(stbl->sampleGroupsDescription, &j))) {\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\tj--;\n\t\tgf_list_rem(stbl->sampleGroupsDescription, j);\n\t}\n\n\tif (stbl->traf_map) {\n\t\tfor (j=0; j<stbl->traf_map->nb_entries; j++) {\n\t\t\tif (stbl->traf_map->frag_starts[j].moof_template)\n\t\t\t\tgf_free(stbl->traf_map->frag_starts[j].moof_template);\n\t\t}\n\t\tmemset(stbl->traf_map->frag_starts, 0, sizeof(GF_TrafMapEntry)*stbl->traf_map->nb_alloc);\n\t\tstbl->traf_map->nb_entries = 0;\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_reset_tables(GF_ISOFile *movie, Bool reset_sample_count)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\n\t\tu32 dur;\n\t\tu64 dts;\n\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\t\ttrak->sample_count_at_seg_start += stbl->SampleSize->sampleCount;\n\t\tif (trak->sample_count_at_seg_start) {\n\t\t\tGF_Err e;\n\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\tif (e == GF_OK) {\n\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t}\n\t\t}\n\n\t\t//recreate all boxes\n\t\tgf_isom_recreate_tables(trak);\n\n#if 0\n\t\tj = stbl->nb_stbl_boxes;\n\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\tj--;\n\t\t}\n#endif\n\n\t\tif (reset_sample_count) {\n\t\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t\t\ttrak->dts_at_seg_start = 0;\n\t\t\ttrak->first_traf_merged = GF_FALSE;\n#endif\n\t\t}\n\n\t}\n\tif (reset_sample_count) {\n\t\tmovie->NextMoofNumber = 0;\n\t}\n#endif\n\treturn GF_OK;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_release_segment(GF_ISOFile *movie, Bool reset_tables)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, j, base_track_sample_count;\n\tBool has_scalable;\n\tGF_Box *a;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\thas_scalable = gf_isom_needs_layer_reconstruction(movie);\n\tbase_track_sample_count = 0;\n\tmovie->moov->compressed_diff = 0;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->first_traf_merged = GF_FALSE;\n\t\tif (trak->Media->information->dataHandler == movie->movieFileMap) {\n\t\t\ttrak->Media->information->dataHandler = NULL;\n\t\t}\n\t\tif (trak->Media->information->scalableDataHandler == movie->movieFileMap) {\n\t\t\ttrak->Media->information->scalableDataHandler = NULL;\n\t\t} else {\n\t\t\tif (trak->Media->information->scalableDataHandler==trak->Media->information->dataHandler)\n\t\t\t\ttrak->Media->information->dataHandler = NULL;\n\n\t\t\tgf_isom_datamap_del(trak->Media->information->scalableDataHandler);\n\t\t\ttrak->Media->information->scalableDataHandler = NULL;\n\t\t}\n\n\n\t\tif (reset_tables) {\n\t\t\tu32 dur;\n\t\t\tu64 dts;\n\t\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\t\t\tif (has_scalable) {\n\t\t\t\t//check if the base reference is in the file - if not, do not consider the track is scalable.\n\t\t\t\tif (trak->nb_base_refs) {\n\t\t\t\t\tu32 on_track=0;\n\t\t\t\t\tGF_TrackBox *base;\n\t\t\t\t\tgf_isom_get_reference(movie, i+1, GF_ISOM_REF_BASE, 1, &on_track);\n\n\t\t\t\t\tbase = gf_isom_get_track_from_file(movie, on_track);\n\t\t\t\t\tif (!base) {\n\t\t\t\t\t\tbase_track_sample_count=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbase_track_sample_count = base->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttrak->sample_count_at_seg_start += base_track_sample_count ? base_track_sample_count : stbl->SampleSize->sampleCount;\n\n\t\t\tif (trak->sample_count_at_seg_start) {\n\t\t\t\tGF_Err e;\n\t\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgf_isom_recreate_tables(trak);\n\n\n#if 0 // TO CHECK\n\t\t\tj = ptr->nb_stbl_boxes;\n\t\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\t\tj--;\n\t\t\t}\n#endif\n\t\t}\n\n\n\t\tif (movie->has_pssh_moof) {\n\t\t\tj = 0;\n\t\t\twhile ((a = (GF_Box *)gf_list_enum(movie->moov->child_boxes, &j))) {\n\t\t\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\t\tGF_ProtectionSystemHeaderBox *pssh = (GF_ProtectionSystemHeaderBox *)a;\n\t\t\t\t\tif (pssh->moof_defined) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&movie->moov->child_boxes, a);\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmovie->has_pssh_moof = GF_FALSE;\n\t\t}\n\t}\n\n\tgf_isom_datamap_del(movie->movieFileMap);\n\tmovie->movieFileMap = NULL;\n\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_open_segment(GF_ISOFile *movie, const char *fileName, u64 start_range, u64 end_range, GF_ISOSegOpenMode flags)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn GF_NOT_SUPPORTED;\n#else\n\tu64 MissingBytes;\n\tGF_Err e;\n\tu32 i;\n\tBool segment_map_assigned = GF_FALSE;\n\tBool is_scalable_segment = (flags & GF_ISOM_SEGMENT_SCALABLE_FLAG) ? GF_TRUE : GF_FALSE;\n\tBool no_order_check = (flags & GF_ISOM_SEGMENT_NO_ORDER_FLAG) ? GF_TRUE: GF_FALSE;\n\tGF_DataMap *tmp = NULL;\n\tGF_DataMap *orig_file_map = NULL;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_READ) return GF_BAD_PARAM;\n\n\t/*this is a scalable segment - use a temp data map for the associated track(s) but do NOT touch the movie file map*/\n\tif (is_scalable_segment) {\n\t\ttmp = NULL;\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &tmp);\n\t\tif (e) return e;\n\n\t\torig_file_map = movie->movieFileMap;\n\t\tmovie->movieFileMap = tmp;\n\t} else {\n\t\tif (movie->movieFileMap)\n\t\t\tgf_isom_release_segment(movie, GF_FALSE);\n\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &movie->movieFileMap);\n\t\tif (e) return e;\n\t}\n\tmovie->moov->compressed_diff = 0;\n\tmovie->current_top_box_start = 0;\n\n\tif (start_range || end_range) {\n\t\tif (end_range > start_range) {\n\t\t\tgf_bs_seek(movie->movieFileMap->bs, end_range+1);\n\t\t\tgf_bs_truncate(movie->movieFileMap->bs);\n\t\t}\n\t\tgf_bs_seek(movie->movieFileMap->bs, start_range);\n\t\tmovie->current_top_box_start = start_range;\n\t}\n\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\n\t\tif (!is_scalable_segment) {\n\t\t\t/*reset data handler to new segment*/\n\t\t\tif (trak->Media->information->dataHandler == NULL) {\n\t\t\t\ttrak->Media->information->dataHandler = movie->movieFileMap;\n\t\t\t}\n\t\t} else {\n\t\t\ttrak->present_in_scalable_segment = GF_FALSE;\n\t\t}\n\t}\n\tif (no_order_check) movie->NextMoofNumber = 0;\n\n\t//ok parse root boxes\n\te = gf_isom_parse_movie_boxes(movie, NULL, &MissingBytes, GF_TRUE);\n\n\tif (!is_scalable_segment)\n\t\treturn e;\n\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\tif (trak->present_in_scalable_segment) {\n\t\t\t/*store the temp dataHandler into scalableDataHandler so that it will not be destroyed\n\t\t\tif we append another representation - destruction of this data handler is done in release_segment*/\n\t\t\ttrak->Media->information->scalableDataHandler = tmp;\n\t\t\tif (!segment_map_assigned) {\n\t\t\t\ttrak->Media->information->scalableDataHandler = tmp;\n\t\t\t\tsegment_map_assigned = GF_TRUE;\n\t\t\t}\n\t\t\t//and update the regular dataHandler for the Media_GetSample function\n\t\t\ttrak->Media->information->dataHandler = tmp;\n\t\t}\n\t}\n\tmovie->movieFileMap = \torig_file_map;\n\treturn e;\n#endif\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_highest_track_in_scalable_segment(GF_ISOFile *movie, u32 for_base_track)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\ts32 max_ref;\n\tu32 i, j;\n\tGF_ISOTrackID track_id;\n\n\tmax_ref = 0;\n\ttrack_id = 0;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\ts32 ref;\n\t\tu32 ref_type = GF_ISOM_REF_SCAL;\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\tif (! trak->present_in_scalable_segment) continue;\n\n\t\tref = gf_isom_get_reference_count(movie, i+1, ref_type);\n\t\tif (ref<=0) {\n\t\t\t//handle implicit reconstruction for LHE1/LHV1, check sbas track ref\n\t\t\tu32 subtype = gf_isom_get_media_subtype(movie, i+1, 1);\n\t\t\tswitch (subtype) {\n\t\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\t\tcase GF_ISOM_SUBTYPE_LHV1:\n\t\t\t\tref = gf_isom_get_reference_count(movie, i+1, GF_ISOM_REF_BASE);\n\t\t\t\tif (ref<=0) continue;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ref<=max_ref) continue;\n\n\t\tfor (j=0; j< (u32) ref; j++) {\n\t\t\tu32 on_track=0;\n\t\t\tgf_isom_get_reference(movie, i+1, GF_ISOM_REF_BASE, j+1, &on_track);\n\t\t\tif (on_track==for_base_track) {\n\t\t\t\tmax_ref = ref;\n\t\t\t\ttrack_id = trak->Header->trackID;\n\t\t\t}\n\t\t}\n\t}\n\treturn track_id;\n#endif\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_text_set_streaming_mode(GF_ISOFile *movie, Bool do_convert)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tmovie->convert_streaming_text = do_convert;\n\treturn GF_OK;\n}\n\nstatic void gf_isom_gen_desc_get_dsi(GF_GenericSampleDescription *udesc, GF_List *child_boxes)\n{\n\tif (!child_boxes) return;\n\tGF_UnknownBox *a=NULL;\n\tu32 i=0;\n\twhile ((a=gf_list_enum(child_boxes, &i))) {\n\t\tif (a->type == GF_ISOM_BOX_TYPE_UNKNOWN) break;\n\t\ta = NULL;\n\t}\n\tif (!a) return;\n\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * a->dataSize);\n\tif (udesc->extension_buf) {\n\t\tudesc->extension_buf_size = a->dataSize;\n\t\tmemcpy(udesc->extension_buf, a->data, a->dataSize);\n\t\tudesc->ext_box_wrap = a->original_4cc;\n\t}\n}\n\nGF_EXPORT\nGF_GenericSampleDescription *gf_isom_get_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_GenericVisualSampleEntryBox *entry;\n\tGF_GenericAudioSampleEntryBox *gena;\n\tGF_GenericSampleEntryBox *genm;\n\tGF_TrackBox *trak;\n\tGF_GenericSampleDescription *udesc;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !StreamDescriptionIndex || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\n\tentry = (GF_GenericVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\t//no entry or MPEG entry:\n\tif (!entry || IsMP4Description(entry->type) ) return NULL;\n\t//if we handle the description return false\n\tswitch (entry->type) {\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\treturn NULL;\n\tcase GF_ISOM_BOX_TYPE_GNRV:\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (entry->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)entry)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = entry->EntryType;\n\t\t}\n\t\tudesc->version = entry->version;\n\t\tudesc->revision = entry->revision;\n\t\tudesc->vendor_code = entry->vendor;\n\t\tudesc->temporal_quality = entry->temporal_quality;\n\t\tudesc->spatial_quality = entry->spatial_quality;\n\t\tudesc->width = entry->Width;\n\t\tudesc->height = entry->Height;\n\t\tudesc->h_res = entry->horiz_res;\n\t\tudesc->v_res = entry->vert_res;\n\t\tstrcpy(udesc->compressor_name, entry->compressor_name);\n\t\tudesc->depth = entry->bit_depth;\n\t\tudesc->color_table_index = entry->color_table_index;\n\t\tif (entry->data_size) {\n\t\t\tudesc->extension_buf_size = entry->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * entry->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, entry->data, entry->data_size);\n\t\t} else {\n\t\t\tgf_isom_gen_desc_get_dsi(udesc, entry->child_boxes);\n\t\t}\n\t\treturn udesc;\n\tcase GF_ISOM_BOX_TYPE_GNRA:\n\t\tgena = (GF_GenericAudioSampleEntryBox *)entry;\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (gena->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)gena)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = gena->EntryType;\n\t\t}\n\t\tudesc->version = gena->version;\n\t\tudesc->revision = gena->revision;\n\t\tudesc->vendor_code = gena->vendor;\n\t\tudesc->samplerate = gena->samplerate_hi;\n\t\tudesc->bits_per_sample = gena->bitspersample;\n\t\tudesc->nb_channels = gena->channel_count;\n\t\tif (gena->data_size) {\n\t\t\tudesc->extension_buf_size = gena->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * gena->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, gena->data, gena->data_size);\n\t\t} else {\n\t\t\tgf_isom_gen_desc_get_dsi(udesc, entry->child_boxes);\n\t\t}\n\t\treturn udesc;\n\tcase GF_ISOM_BOX_TYPE_GNRM:\n\t\tgenm = (GF_GenericSampleEntryBox *)entry;\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (genm->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)genm)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = genm->EntryType;\n\t\t}\n\t\tif (genm->data_size) {\n\t\t\tudesc->extension_buf_size = genm->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * genm->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, genm->data, genm->data_size);\n\t\t} else {\n\t\t\tgf_isom_gen_desc_get_dsi(udesc, entry->child_boxes);\n\t\t}\n\t\treturn udesc;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_visual_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *Width, u32 *Height)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t*Width = ((GF_VisualSampleEntryBox*)entry)->Width;\n\t\t*Height = ((GF_VisualSampleEntryBox*)entry)->Height;\n\t} else if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_SCENE) {\n\t\t*Width = trak->Header->width>>16;\n\t\t*Height = trak->Header->height>>16;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_visual_bit_depth(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, u16* bitDepth)\n{\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t*bitDepth = ((GF_VisualSampleEntryBox*)entry)->bit_depth;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_audio_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *SampleRate, u32 *Channels, u32 *bitsPerSample)\n{\n\tGF_TrackBox *trak;\n\tGF_AudioSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd = NULL;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media && trak->Media->information && trak->Media->information->sampleTable && trak->Media->information->sampleTable->SampleDescription)\n\t\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_AudioSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\n\tif (SampleRate) {\n\t\t(*SampleRate) = entry->samplerate_hi;\n\t\tif (entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tu32 sr = entry->samplerate_hi;\n\t\t\tsr <<= 16;\n\t\t\tsr |= entry->samplerate_lo;\n\t\t\t(*SampleRate) = sr;\n\t\t}\n\t}\n\tif (Channels) (*Channels) = entry->channel_count;\n\tif (bitsPerSample) (*bitsPerSample) = (u8) entry->bitspersample;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_audio_layout(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_AudioChannelLayout *layout)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ChannelLayoutBox *chnl;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !layout) return GF_BAD_PARAM;\n\tmemset(layout, 0, sizeof(GF_AudioChannelLayout));\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\tchnl = (GF_ChannelLayoutBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\tif (!chnl) return GF_NOT_FOUND;\n\n\tmemcpy(layout, &chnl->layout, sizeof(GF_AudioChannelLayout));\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_get_pixel_aspect_ratio(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *hSpacing, u32 *vSpacing)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !hSpacing || !vSpacing) return GF_BAD_PARAM;\n\t*hSpacing = 1;\n\t*vSpacing = 1;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_OK;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\tGF_PixelAspectRatioBox *pasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\t\tif (pasp) {\n\t\t\t*hSpacing = pasp->hSpacing;\n\t\t\t*vSpacing = pasp->vSpacing;\n\t\t}\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_color_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *colour_type, u16 *colour_primaries, u16 *transfer_characteristics, u16 *matrix_coefficients, Bool *full_range_flag)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_OK;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type!=GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tu32 i, count = gf_list_count(entry->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ColourInformationBox *clr = (GF_ColourInformationBox *) gf_list_get(entry->child_boxes, i);\n\t\tif (clr->type != GF_ISOM_BOX_TYPE_COLR) continue;\n\t\tif (clr->is_jp2) continue;\n\t\tif (clr->opaque_size) continue;\n\n\t\tif (colour_type) *colour_type = clr->colour_type;\n\t\tif (colour_primaries) *colour_primaries = clr->colour_primaries;\n\t\tif (transfer_characteristics) *transfer_characteristics = clr->transfer_characteristics;\n\t\tif (matrix_coefficients) *matrix_coefficients = clr->matrix_coefficients;\n\t\tif (full_range_flag) *full_range_flag = clr->full_range_flag;\n\t\treturn GF_OK;\n\t}\n\treturn GF_NOT_FOUND;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_icc_profile(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, Bool *icc_restricted, const u8 **icc, u32 *icc_size)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\tif (!icc || !icc_size) return GF_BAD_PARAM;\n\t*icc = NULL;\n\t*icc_size = 0;\n\tif (icc_restricted) *icc_restricted = GF_FALSE;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_OK;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type!=GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tu32 i, count = gf_list_count(entry->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ColourInformationBox *clr = (GF_ColourInformationBox *) gf_list_get(entry->child_boxes, i);\n\t\tif (clr->type != GF_ISOM_BOX_TYPE_COLR) continue;\n\t\tif (clr->is_jp2) continue;\n\t\tif (!clr->opaque_size) continue;\n\n\t\tif (clr->colour_type==GF_4CC('r', 'I', 'C', 'C')) {\n\t\t\tif (icc_restricted) *icc_restricted = GF_TRUE;\n\t\t\t*icc = clr->opaque;\n\t\t\t*icc_size = clr->opaque_size;\n\t\t}\n\t\telse if (clr->colour_type==GF_4CC('p', 'r', 'o', 'f')) {\n\t\t\t*icc = clr->opaque;\n\t\t\t*icc_size = clr->opaque_size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn GF_NOT_FOUND;\n}\n\nGF_EXPORT\nconst char *gf_isom_get_filename(GF_ISOFile *movie)\n{\n\tif (!movie) return NULL;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (movie->finalName && !movie->fileName) return movie->finalName;\n#endif\n\treturn movie->fileName;\n}\n\n\nGF_EXPORT\nu8 gf_isom_get_pl_indication(GF_ISOFile *movie, GF_ISOProfileLevelType PL_Code)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tif (!movie || !movie->moov) return 0xFF;\n\tif (!movie->moov->iods || !movie->moov->iods->descriptor) return 0xFF;\n\tif (movie->moov->iods->descriptor->tag != GF_ODF_ISOM_IOD_TAG) return 0xFF;\n\n\tiod = (GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor;\n\tswitch (PL_Code) {\n\tcase GF_ISOM_PL_AUDIO:\n\t\treturn iod->audio_profileAndLevel;\n\tcase GF_ISOM_PL_VISUAL:\n\t\treturn iod->visual_profileAndLevel;\n\tcase GF_ISOM_PL_GRAPHICS:\n\t\treturn iod->graphics_profileAndLevel;\n\tcase GF_ISOM_PL_SCENE:\n\t\treturn iod->scene_profileAndLevel;\n\tcase GF_ISOM_PL_OD:\n\t\treturn iod->OD_profileAndLevel;\n\tcase GF_ISOM_PL_INLINE:\n\t\treturn iod->inlineProfileFlag;\n\tcase GF_ISOM_PL_MPEGJ:\n\tdefault:\n\t\treturn 0xFF;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_matrix(GF_ISOFile *the_file, u32 trackNumber, u32 matrix[9])\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\tmemcpy(matrix, trak->Header->matrix, sizeof(trak->Header->matrix));\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_layout_info(GF_ISOFile *movie, u32 trackNumber, u32 *width, u32 *height, s32 *translation_x, s32 *translation_y, s16 *layer)\n{\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) return GF_BAD_PARAM;\n\tif (width) *width = tk->Header->width>>16;\n\tif (height) *height = tk->Header->height>>16;\n\tif (layer) *layer = tk->Header->layer;\n\tif (translation_x) *translation_x = tk->Header->matrix[6] >> 16;\n\tif (translation_y) *translation_y = tk->Header->matrix[7] >> 16;\n\treturn GF_OK;\n}\n\n\n/*returns total amount of media bytes in track*/\nGF_EXPORT\nu64 gf_isom_get_media_data_size(GF_ISOFile *movie, u32 trackNumber)\n{\n\tu32 i;\n\tu64 size;\n\tGF_SampleSizeBox *stsz;\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) return 0;\n\tstsz = tk->Media->information->sampleTable->SampleSize;\n\tif (!stsz) return 0;\n\tif (stsz->sampleSize) return stsz->sampleSize*stsz->sampleCount;\n\tsize = 0;\n\tfor (i=0; i<stsz->sampleCount; i++) size += stsz->sizes[i];\n\treturn size;\n}\n\nGF_EXPORT\nu64 gf_isom_get_first_mdat_start(GF_ISOFile *movie)\n{\n\tu64 offset;\n\tif (!movie) return 0;\n\toffset = movie->first_data_toplevel_offset + 8;\n\tif (movie->first_data_toplevel_size > 0xFFFFFFFFUL)\n\t\toffset += 8;\n\treturn offset;\n}\n\nstatic u64 box_unused_bytes(GF_Box *b)\n{\n\tu32 i, count;\n\tu64 size = 0;\n\tswitch (b->type) {\n\tcase GF_QT_BOX_TYPE_WIDE:\n\tcase GF_ISOM_BOX_TYPE_FREE:\n\tcase GF_ISOM_BOX_TYPE_SKIP:\n\t\tsize += b->size;\n\t\tbreak;\n\t}\n\tcount = gf_list_count(b->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *child = gf_list_get(b->child_boxes, i);\n\t\tsize += box_unused_bytes(child);\n\t}\n\treturn size;\n}\n\nextern u64 unused_bytes;\n\nGF_EXPORT\nu64 gf_isom_get_unused_box_bytes(GF_ISOFile *movie)\n{\n\tu64 size = unused_bytes;\n\tu32 i, count;\n\tif (!movie) return 0;\n\tcount = gf_list_count(movie->TopBoxes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(movie->TopBoxes, i);\n\t\tsize += box_unused_bytes(b);\n\t}\n\treturn size;\n}\n\nGF_EXPORT\nvoid gf_isom_set_default_sync_track(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) movie->es_id_default_sync = -1;\n\telse movie->es_id_default_sync = tk->Header->trackID;\n}\n\n\nGF_EXPORT\nBool gf_isom_is_single_av(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_a, nb_v, nb_auxv, nb_pict, nb_scene, nb_od, nb_text;\n\tnb_auxv = nb_pict = nb_a = nb_v = nb_any = nb_scene = nb_od = nb_text = 0;\n\n\tif (!file->moov) return GF_FALSE;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_any++;\n\t\t\telse nb_scene++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_any++;\n\t\t\telse nb_od++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\tnb_text++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tnb_a++;\n\t\t\tbreak;\n        case GF_ISOM_MEDIA_AUXV:\n            /*discard file with images*/\n            if (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n            else nb_auxv++;\n            break;\n        case GF_ISOM_MEDIA_PICT:\n            /*discard file with images*/\n            if (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n            else nb_pict++;\n            break;\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\t/*discard file with images*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n\t\t\telse nb_v++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnb_any++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nb_any) return GF_FALSE;\n\tif ((nb_scene<=1) && (nb_od<=1) && (nb_a<=1) && (nb_v+nb_pict+nb_auxv<=1) && (nb_text<=1) ) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_isom_is_JPEG2000(GF_ISOFile *mov)\n{\n\treturn (mov && mov->is_jp2) ? GF_TRUE : GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_guess_specification(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_m4s, nb_a, nb_v, nb_auxv,nb_scene, nb_od, nb_mp3, nb_aac, nb_m4v, nb_avc, nb_amr, nb_h263, nb_qcelp, nb_evrc, nb_smv, nb_text, nb_pict;\n\n\tnb_m4s = nb_a = nb_v = nb_auxv = nb_any = nb_scene = nb_od = nb_mp3 = nb_aac = nb_m4v = nb_avc = nb_amr = nb_h263 = nb_qcelp = nb_evrc = nb_smv = nb_text = nb_pict = 0;\n\n\tif (file->is_jp2) {\n\t\tif (file->moov) return GF_ISOM_BRAND_MJP2;\n\t\treturn GF_ISOM_BRAND_JP2;\n\t}\n\tif (!file->moov) {\n\t\tif (!file->meta || !file->meta->handler) return 0;\n\t\treturn file->meta->handler->handlerType;\n\t}\n\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tu32 mstype = gf_isom_get_media_subtype(file, i+1, 1);\n\n\t\tif (mtype==GF_ISOM_MEDIA_SCENE) {\n\t\t\tnb_scene++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t} else if (mtype==GF_ISOM_MEDIA_OD) {\n\t\t\tnb_od++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t}\n\t\telse if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT)) nb_text++;\n\t\telse if ((mtype==GF_ISOM_MEDIA_AUDIO) || gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tswitch (mstype) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tnb_amr++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tnb_h263++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tnb_evrc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tnb_qcelp++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tnb_smv++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\t{\n\t\t\t\tGF_DecoderConfig *dcd = gf_isom_get_decoder_config(file, i+1, 1);\n\t\t\t\tif (!dcd) break;\n\t\t\t\tswitch (dcd->streamType) {\n\t\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\t\tif (dcd->objectTypeIndication==GF_CODECID_MPEG4_PART2) nb_m4v++;\n\t\t\t\t\telse if ((dcd->objectTypeIndication==GF_CODECID_AVC) || (dcd->objectTypeIndication==GF_CODECID_SVC) || (dcd->objectTypeIndication==GF_CODECID_MVC)) nb_avc++;\n\t\t\t\t\telse nb_v++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\t\tswitch (dcd->objectTypeIndication) {\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t\t\t\t\tnb_aac++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_MPEG2_PART3:\n\t\t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n\t\t\t\t\tcase GF_CODECID_MPEG_AUDIO_L1:\n\t\t\t\t\t\tnb_mp3++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\t\t\tnb_evrc++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\t\tnb_smv++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\t\t\tnb_qcelp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tnb_a++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t/*SHOULD NEVER HAPPEN - IF SO, BROKEN MPEG4 FILE*/\n\t\t\t\tdefault:\n\t\t\t\t\tnb_any++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)dcd);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (mtype==GF_ISOM_MEDIA_VISUAL) nb_v++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_AUXV) nb_auxv++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_PICT) nb_pict++;\n\t\t\t\telse nb_a++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP)) nb_m4s++;\n\t\telse nb_any++;\n\t}\n\tif (nb_any) return GF_ISOM_BRAND_ISOM;\n\tif (nb_qcelp || nb_evrc || nb_smv) {\n\t\t/*non std mix of streams*/\n\t\tif (nb_m4s || nb_avc || nb_scene || nb_od || nb_mp3 || nb_a || nb_v) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_3G2A;\n\t}\n\t/*other a/v/s streams*/\n\tif (nb_v || nb_a || nb_m4s) return GF_ISOM_BRAND_MP42;\n\n\tnb_v = nb_m4v + nb_avc + nb_h263;\n\tnb_a = nb_mp3 + nb_aac + nb_amr;\n\n\t/*avc file: whatever has AVC and no systems*/\n\tif (nb_avc) {\n\t\tif (!nb_scene && !nb_od) return GF_ISOM_BRAND_AVC1;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP3: ISMA and MPEG4*/\n\tif (nb_mp3) {\n\t\tif (!nb_text && (nb_v<=1) && (nb_a<=1) && (nb_scene==1) && (nb_od==1))\n\t\t\treturn GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP4*/\n\tif (nb_scene || nb_od) {\n\t\t/*issue with AMR and H263 which don't have MPEG mapping: non compliant file*/\n\t\tif (nb_amr || nb_h263) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*use ISMA (3GP fine too)*/\n\tif (!nb_amr && !nb_h263 && !nb_text) {\n\t\tif ((nb_v<=1) && (nb_a<=1)) return GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\n\tif ((nb_v<=1) && (nb_a<=1) && (nb_text<=1)) return nb_text ? GF_ISOM_BRAND_3GP6 : GF_ISOM_BRAND_3GP5;\n\treturn GF_ISOM_BRAND_3GG6;\n}\n\nGF_ItemListBox *gf_isom_locate_box(GF_List *list, u32 boxType, bin128 UUID)\n{\n\tu32 i;\n\tGF_Box *box;\n\ti=0;\n\twhile ((box = (GF_Box *)gf_list_enum(list, &i))) {\n\t\tif (box->type == boxType) {\n\t\t\tGF_UUIDBox* box2 = (GF_UUIDBox* )box;\n\t\t\tif (boxType != GF_ISOM_BOX_TYPE_UUID) return (GF_ItemListBox *)box;\n\t\t\tif (!memcmp(box2->uuid, UUID, 16)) return (GF_ItemListBox *)box;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*Apple extensions*/\n\n\nGF_EXPORT\nGF_Err gf_isom_apple_get_tag(GF_ISOFile *mov, GF_ISOiTunesTag tag, const u8 **data, u32 *data_len)\n{\n\tu32 i;\n\tGF_ListItemBox *info;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\n\t*data = NULL;\n\t*data_len = 0;\n\n\tmeta = (GF_MetaBox *) gf_isom_get_meta_extensions(mov, 0);\n\tif (!meta) return GF_URL_ERROR;\n\n\tilst = gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) return GF_URL_ERROR;\n\n\tif (tag==GF_ISOM_ITUNE_PROBE) return gf_list_count(ilst->child_boxes) ? GF_OK : GF_URL_ERROR;\n\n\ti=0;\n\twhile ( (info=(GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tif (info->type==tag) break;\n\t\t/*special cases*/\n\t\tif ((tag==GF_ISOM_ITUNE_GENRE) && (info->type==(u32) GF_ISOM_ITUNE_GENRE_USER)) break;\n\t\tinfo = NULL;\n\t}\n\tif (!info || !info->data || !info->data->data) return GF_URL_ERROR;\n\n\tif ((tag == GF_ISOM_ITUNE_GENRE) && (info->data->flags == 0)) {\n\t\tif (info->data->dataSize && (info->data->dataSize>2) && (info->data->dataSize < 5)) {\n\t\t\tGF_BitStream* bs = gf_bs_new(info->data->data, info->data->dataSize, GF_BITSTREAM_READ);\n\t\t\t*data_len = gf_bs_read_int(bs, info->data->dataSize * 8);\n\t\t\tgf_bs_del(bs);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n//\tif (info->data->flags != 0x1) return GF_URL_ERROR;\n\t*data = info->data->data;\n\t*data_len = info->data->dataSize;\n\tif ((tag==GF_ISOM_ITUNE_COVER_ART) && (info->data->flags==14)) *data_len |= 0x80000000; //(1<<31);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_apple_enum_tag(GF_ISOFile *mov, u32 idx, GF_ISOiTunesTag *out_tag, const u8 **data, u32 *data_len, u64 *out_int_val, u32 *out_int_val2, u32 *out_flags)\n{\n\tu32 i, child_index;\n\tGF_ListItemBox *info;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\tGF_DataBox *dbox = NULL;\n\tBool found=GF_FALSE;\n\tu32 itype, tag_val;\n\ts32 tag_idx;\n\t*data = NULL;\n\t*data_len = 0;\n\t*out_int_val = 0;\n\t*out_int_val2 = 0;\n\t*out_flags = 0;\n\n\tmeta = (GF_MetaBox *) gf_isom_get_meta_extensions(mov, 0);\n\tif (!meta) return GF_URL_ERROR;\n\n\tilst = gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) return GF_URL_ERROR;\n\n\tchild_index = i = 0;\n\twhile ( (info=(GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tGF_DataBox *data_box = NULL;\n\t\tif (gf_itags_find_by_itag(info->type)<0) {\n\t\t\ttag_val = info->type;\n\t\t\tif (info->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t\tdata_box = (GF_DataBox *) gf_isom_box_find_child(info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\t\t\tif (!data_box) continue;\n\t\t\t\ttag_val = ((GF_UnknownBox *)info)->original_4cc;\n\t\t\t}\n\t\t} else {\n\t\t\tdata_box = info->data;\n\t\t\ttag_val = info->type;\n\t\t}\n\t\tif (child_index==idx) {\n\t\t\tdbox = data_box;\n\t\t\tfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tchild_index++;\n\t}\n\n\tif (!dbox) {\n\t\tif (found) {\n\t\t\t*data = NULL;\n\t\t\t*data_len = 1;\n\t\t\t*out_tag = tag_val;\n\t\t\treturn GF_OK;\n\t\t}\n\t\treturn GF_URL_ERROR;\n\t}\n\t*out_flags = dbox->flags;\n\t*out_tag = tag_val;\n\tif (!dbox->data) {\n\t\t*data = NULL;\n\t\t*data_len = 1;\n\t\treturn GF_OK;\n\t}\n\n\ttag_idx = gf_itags_find_by_itag(info->type);\n\tif (tag_idx<0) {\n\t\t*data = dbox->data;\n\t\t*data_len = dbox->dataSize;\n\t\treturn GF_OK;\n\t}\n\n\tif ((tag_val == GF_ISOM_ITUNE_GENRE) && (dbox->flags == 0) && (dbox->dataSize>=2)) {\n\t\tu32 int_val = dbox->data[0];\n\t\tint_val <<= 8;\n\t\tint_val |= dbox->data[1];\n\t\t*data = NULL;\n\t\t*data_len = 0;\n\t\t*out_int_val = int_val;\n\t\treturn GF_OK;\n\t}\n\n\titype = gf_itags_get_type((u32) tag_idx);\n\tswitch (itype) {\n\tcase GF_ITAG_BOOL:\n\tcase GF_ITAG_INT8:\n\t\tif (dbox->dataSize) *out_int_val = dbox->data[0];\n\t\tbreak;\n\tcase GF_ITAG_INT16:\n\t\tif (dbox->dataSize>1) {\n\t\t\tu16 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_INT32:\n\t\tif (dbox->dataSize>3) {\n\t\t\tu32 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_INT64:\n\t\tif (dbox->dataSize>7) {\n\t\t\tu64 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[4];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[5];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[6];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[7];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_FRAC6:\n\tcase GF_ITAG_FRAC8:\n\t\tif (dbox->dataSize>5) {\n\t\t\tu32 v = dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\t*out_int_val = v;\n\t\t\tv = dbox->data[4];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[5];\n\t\t\t*out_int_val2 = v;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t*data = dbox->data;\n\t\t*data_len = dbox->dataSize;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_enum_udta_keys(GF_ISOFile *mov, u32 idx, GF_QT_UDTAKey *okey)\n{\n\tu32 i, count;\n\n\tGF_MetaBox *meta = (GF_MetaBox *) gf_isom_get_meta_extensions(mov, 2);\n\tif (!meta || !meta->keys) return GF_URL_ERROR;\n\n\tGF_MetaKey *k = gf_list_get(meta->keys->keys, idx);\n\tif (!k) return GF_URL_ERROR;\n\tif (!okey) return GF_OK;\n\n\tmemset(okey, 0, sizeof(GF_QT_UDTAKey) );\n\tokey->name = k->data;\n\tokey->ns = k->ns;\n\n\tGF_ListItemBox *ilst = (GF_ListItemBox *) gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) return GF_OK;\n\n\tGF_DataBox *data_box = NULL;\n\tcount = gf_list_count(ilst->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_UnknownBox *u = gf_list_get(ilst->child_boxes, i);\n\t\tif (u->type!=GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\tif (u->original_4cc==idx+1) {\n\t\t\tdata_box = (GF_DataBox *) gf_isom_box_find_child(u->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\t}\n\t}\n\n\tokey->type=GF_QT_KEY_OPAQUE;\n\tif (!data_box || (data_box->version!=0)) {\n\t\tif (data_box) {\n\t\t\tokey->value.data.data = data_box->data;\n\t\t\tokey->value.data.data_len = data_box->dataSize;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tokey->type = data_box->flags;\n\n\tu32 nb_bits = 8 * data_box->dataSize;\n\tGF_BitStream *bs = gf_bs_new(data_box->data, data_box->dataSize, GF_BITSTREAM_READ);\n\tswitch (okey->type) {\n\tcase GF_QT_KEY_UTF8:\n\tcase GF_QT_KEY_UTF8_SORT:\n\t\tokey->value.string = data_box->data;\n\t\tbreak;\n\n\tcase GF_QT_KEY_SIGNED_VSIZE:\n\t{\n\t\tu32 val = gf_bs_read_int(bs, nb_bits);\n\t\tif (nb_bits==8) okey->value.sint = (s64) (s8) val;\n\t\telse if (nb_bits==16) okey->value.sint = (s64) (s16) val;\n\t\telse if (nb_bits==32) okey->value.sint = (s64) (s32) val;\n\t\telse if (nb_bits==64) okey->value.sint = (s64) val;\n\t}\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_VSIZE:\n\t\tokey->value.uint = (s32) gf_bs_read_int(bs, nb_bits);\n\t\tbreak;\n\tcase GF_QT_KEY_FLOAT:\n\t\tokey->value.number = gf_bs_read_float(bs);\n\t\tbreak;\n\tcase GF_QT_KEY_DOUBLE:\n\t\tokey->value.number = gf_bs_read_double(bs);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_8:\n\t\tokey->value.sint = (s64) (s8) gf_bs_read_int(bs, 8);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_16:\n\t\tokey->value.sint = (s64) (s16) gf_bs_read_int(bs, 16);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_32:\n\t\tokey->value.sint = (s64) (s32) gf_bs_read_int(bs, 32);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_64:\n\t\tokey->value.sint = (s64) gf_bs_read_long_int(bs, 64);\n\t\tbreak;\n\tcase GF_QT_KEY_POINTF:\n\tcase GF_QT_KEY_SIZEF:\n\t\tokey->value.pos_size.x = gf_bs_read_float(bs);\n\t\tokey->value.pos_size.y = gf_bs_read_float(bs);\n\t\tbreak;\n\tcase GF_QT_KEY_RECTF:\n\t\tokey->value.rect.x = gf_bs_read_float(bs);\n\t\tokey->value.rect.y = gf_bs_read_float(bs);\n\t\tokey->value.rect.w = gf_bs_read_float(bs);\n\t\tokey->value.rect.h = gf_bs_read_float(bs);\n\t\tbreak;\n\n\tcase GF_QT_KEY_UNSIGNED_8:\n\t\tokey->value.uint = gf_bs_read_int(bs, 8);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_16:\n\t\tokey->value.uint = gf_bs_read_int(bs, 16);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_32:\n\t\tokey->value.uint = gf_bs_read_int(bs, 32);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_64:\n\t\tokey->value.uint = gf_bs_read_int(bs, 64);\n\t\tbreak;\n\tcase GF_QT_KEY_MATRIXF:\n\t\tfor (i=0; i<9; i++)\n\t\t\tokey->value.matrix[i] = gf_bs_read_float(bs);\n\t\tbreak;\n\n\tcase GF_QT_KEY_OPAQUE:\n\tcase GF_QT_KEY_UTF16_BE:\n\tcase GF_QT_KEY_JIS:\n\tcase GF_QT_KEY_UTF16_SORT:\n\tcase GF_QT_KEY_JPEG:\n\tcase GF_QT_KEY_PNG:\n\tcase GF_QT_KEY_BMP:\n\tcase GF_QT_KEY_METABOX:\n\t\tokey->value.data.data = data_box->data;\n\t\tokey->value.data.data_len = data_box->dataSize;\n\t\tbreak;\n\tcase GF_QT_KEY_REMOVE:\n\t\tbreak;\n\t}\n\tGF_Err e = GF_OK;\n\tif (gf_bs_is_overflow(bs))\n\t\te = GF_ISOM_INVALID_FILE;\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_wma_enum_tag(GF_ISOFile *mov, u32 idx, char **out_tag, const u8 **data, u32 *data_len, u32 *version, u32 *data_type)\n{\n\tGF_XtraBox *xtra;\n\tGF_XtraTag *tag;\n\n\t*out_tag = NULL;\n\t*data = NULL;\n\t*data_len = 0;\n\t*version = 0;\n\t*data_type = 0;\n\n\txtra = (GF_XtraBox *) gf_isom_get_meta_extensions(mov, 1);\n\tif (!xtra) return GF_URL_ERROR;\n\n\ttag = gf_list_get(xtra->tags, idx);\n\tif (!tag) return GF_NOT_FOUND;\n\t*out_tag = tag->name;\n\t*data_len = tag->prop_size;\n\t*data = tag->prop_value;\n\t*version = tag->flags;\n\t*data_type = tag->prop_type;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_get_track_switch_group_count(GF_ISOFile *movie, u32 trackNumber, u32 *alternateGroupID, u32 *nb_groups)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\tif (alternateGroupID) *alternateGroupID = trak->Header->alternate_group;\n\tif (nb_groups) *nb_groups = 0;\n\tif (!trak->udta || !nb_groups) return GF_OK;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return GF_OK;\n\t*nb_groups = gf_list_count(map->boxes);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\t\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}\n\nGF_EXPORT\nu32 gf_isom_get_next_alternate_group_id(GF_ISOFile *movie)\n{\n\tu32 id = 0;\n\tu32 i=0;\n\n\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, i+1);\n\t\tif (trak->Header->alternate_group > id)\n\t\t\tid = trak->Header->alternate_group;\n\t\ti++;\n\t}\n\treturn id+1;\n}\n\nGF_EXPORT\nu8 *gf_isom_sample_get_subsamples_buffer(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 *osize)\n{\n\tu8 *data;\n\tu32 size;\n\tu32 i, count;\n\tGF_BitStream *bs = NULL;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak || !osize) return NULL;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return NULL;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, sub_count, last_sample = 0;\n\t\tGF_SubSampleInformationBox *sub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\n\t\tsub_count = gf_list_count(sub_samples->Samples);\n\t\tfor (j=0; j<sub_count; j++) {\n\t\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry *) gf_list_get(sub_samples->Samples, j);\n\t\t\tif (last_sample + pSamp->sample_delta == sampleNumber) {\n\t\t\t\tu32 scount = gf_list_count(pSamp->SubSamples);\n\t\t\t\tfor (j=0; j<scount; j++) {\n\t\t\t\t\tGF_SubSampleEntry *sent = gf_list_get(pSamp->SubSamples, j);\n\t\t\t\t\tif (!bs) bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\t\tgf_bs_write_u32(bs, sub_samples->flags);\n\t\t\t\t\tgf_bs_write_u32(bs, sent->subsample_size);\n\t\t\t\t\tgf_bs_write_u32(bs, sent->reserved);\n\t\t\t\t\tgf_bs_write_u8(bs, sent->subsample_priority);\n\t\t\t\t\tgf_bs_write_u8(bs, sent->discardable);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast_sample += pSamp->sample_delta;\n\t\t}\n\t}\n\tif (!bs) return NULL;\n\tgf_bs_get_content(bs, &data, &size);\n\tgf_bs_del(bs);\n\t*osize = size;\n\treturn data;\n}\n\nGF_EXPORT\nu32 gf_isom_sample_has_subsamples(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sub_samples) return 0;\n\tif (!sampleNumber) return 1;\n\treturn gf_isom_sample_get_subsample_entry(movie, track, sampleNumber, flags, NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_sample_get_subsample(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, u32 subSampleNumber, u32 *size, u8 *priority, u32 *reserved, Bool *discardable)\n{\n\tGF_SubSampleEntry *entry;\n\tGF_SubSampleInfoEntry *sub_sample;\n\tu32 count = gf_isom_sample_get_subsample_entry(movie, track, sampleNumber, flags, &sub_sample);\n\tif (!size || !priority || !discardable) return GF_BAD_PARAM;\n\n\tif (!subSampleNumber || (subSampleNumber>count)) return GF_BAD_PARAM;\n\tentry = (GF_SubSampleEntry*)gf_list_get(sub_sample->SubSamples, subSampleNumber-1);\n\t*size = entry->subsample_size;\n\t*priority = entry->subsample_priority;\n\t*reserved = entry->reserved;\n\t*discardable = entry->discardable ? GF_TRUE : GF_FALSE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_rvc_config(GF_ISOFile *movie, u32 track, u32 sampleDescriptionIndex, u16 *rvc_predefined, u8 **data, u32 *size, const char **mime)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_TrackBox *trak;\n\n\tif (!rvc_predefined || !data || !size) return GF_BAD_PARAM;\n\t*rvc_predefined = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!entry ) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_RVCConfigurationBox *rvcc = (GF_RVCConfigurationBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\tif (!rvcc) return GF_NOT_FOUND;\n\n\t*rvc_predefined = rvcc->predefined_rvc_config;\n\tif (rvcc->rvc_meta_idx) {\n\t\tif (!data || !size) return GF_OK;\n\t\treturn gf_isom_extract_meta_item_mem(movie, GF_FALSE, track, rvcc->rvc_meta_idx, data, size, NULL, mime, GF_FALSE);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_isom_moov_first(GF_ISOFile *movie)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(movie->TopBoxes); i++) {\n\t\tGF_Box *b = (GF_Box*)gf_list_get(movie->TopBoxes, i);\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MOOV) return GF_TRUE;\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MDAT) return GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nvoid gf_isom_reset_fragment_info(GF_ISOFile *movie, Bool keep_sample_count)\n{\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\t}\n#else\n\t\t//do not reset tfdt for LL-HLS case where parts do not contain a TFDT\n\t\t//trak->dts_at_seg_start = 0;\n\t\tif (!keep_sample_count)\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nvoid gf_isom_reset_seq_num(GF_ISOFile *movie)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nvoid gf_isom_reset_sample_count(GF_ISOFile *movie)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nBool gf_isom_has_cenc_sample_group(GF_ISOFile *the_file, u32 trackNumber, Bool *has_selective, Bool *has_roll)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\tGF_SampleGroupDescriptionBox *seig=NULL;\n\n\tif (has_selective) *has_selective = GF_FALSE;\n\tif (has_roll) *has_roll = GF_FALSE;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_FALSE;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_SEIG) {\n\t\t\tseig = sgdesc;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!seig)\n\t\treturn GF_FALSE;\n\n\tfor (i=0; i<gf_list_count(seig->group_descriptions); i++) {\n\t\tGF_CENCSampleEncryptionGroupEntry *se = gf_list_get(seig->group_descriptions, i);\n\t\tif (!se->IsProtected) {\n\t\t\tif (has_selective) *has_selective = GF_TRUE;\n\t\t} else {\n\t\t\tif (has_roll) *has_roll = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_rap_roll_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, Bool *is_rap, GF_ISOSampleRollType *roll_type, s32 *roll_distance)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\tif (is_rap) *is_rap = GF_FALSE;\n\tif (roll_type) *roll_type = 0;\n\tif (roll_distance) *roll_distance = 0;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_OK;\n\n\tif (!sample_number) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tswitch (sgdesc->grouping_type) {\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\t\tif (is_rap) *is_rap = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\t\tif (roll_type)\n\t\t\t\t\t*roll_type = (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_PROL) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL;\n\t\t\t\tif (roll_distance) {\n\t\t\t\t\ts32 max_roll = 0;\n\t\t\t\t\tu32 j;\n\t\t\t\t\tfor (j=0; j<gf_list_count(sgdesc->group_descriptions); j++) {\n\t\t\t\t\t\tGF_RollRecoveryEntry *roll_entry = (GF_RollRecoveryEntry*)gf_list_get(sgdesc->group_descriptions, j);\n\t\t\t\t\t\tif (max_roll < roll_entry->roll_distance)\n\t\t\t\t\t\t\tmax_roll = roll_entry->roll_distance;\n\t\t\t\t\t}\n\t\t\t\t\tif (*roll_distance < max_roll) *roll_distance = max_roll;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j, group_desc_index;\n\t\tGF_SampleGroupDescriptionBox *sgdesc;\n\t\tu32 first_sample_in_entry, last_sample_in_entry;\n\t\tfirst_sample_in_entry = 1;\n\t\tgroup_desc_index = 0;\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*we found our sample*/\n\t\t\tgroup_desc_index = sg->sample_entries[j].group_description_index;\n\t\t\tbreak;\n\t\t}\n\t\t/*no sampleGroup info associated*/\n\t\tif (!group_desc_index) continue;\n\n\t\tsgdesc = NULL;\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sg->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t\t/*no sampleGroup description found for this group (invalid file)*/\n\t\tif (!sgdesc) continue;\n\n\t\tswitch (sgdesc->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tif (is_rap) *is_rap = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\tif (roll_type)\n\t\t\t\t*roll_type = (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_PROL) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL;\n\n\t\t\tif (roll_distance) {\n\t\t\t\tGF_RollRecoveryEntry *roll_entry = (GF_RollRecoveryEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);\n\t\t\t\tif (roll_entry)\n\t\t\t\t\t*roll_distance = roll_entry->roll_distance;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_to_group_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 grouping_type, u32 grouping_type_param, u32 *sampleGroupDescIndex)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\tif (!grouping_type || !sampleGroupDescIndex) return GF_BAD_PARAM;\n\n\t*sampleGroupDescIndex = 0;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sample_number <= trak->sample_count_at_seg_start) return GF_BAD_PARAM;\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j;\n\t\tu32 first_sample_in_entry, last_sample_in_entry;\n\t\tfirst_sample_in_entry = 1;\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\tif (sg->grouping_type != grouping_type) continue;\n\t\tif (sg->grouping_type_parameter != grouping_type_param) continue;\n\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*we found our sample*/\n\t\t\t*sampleGroupDescIndex = sg->sample_entries[j].group_description_index;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_enum_sample_group(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 *sgrp_idx, u32 *sgrp_type, u32 *sgrp_parameter, const u8 **sgrp_data, u32 *sgrp_size)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\tif (!sgrp_idx || !sgrp_type) return GF_BAD_PARAM;\n\tif (sgrp_parameter) *sgrp_parameter = 0;\n\tif (sgrp_data) *sgrp_data = NULL;\n\tif (sgrp_size) *sgrp_size = 0;\n\t*sgrp_type = 0;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sample_number <= trak->sample_count_at_seg_start) return GF_BAD_PARAM;\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j;\n\t\tGF_SampleGroupDescriptionBox *sgd = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\n\t\tswitch (sgd->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (*sgrp_idx>i) continue;\n\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroups); j++) {\n\t\t\tsg = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, j);\n\t\t\tif (sg->grouping_type == sgd->grouping_type) break;\n\t\t\tsg = NULL;\n\t\t}\n\t\tu32 sgd_index = sgd->default_description_index;\n\t\tif (sg) {\n\t\t\tu32 snum=0;\n\t\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\t\tif (snum + sg->sample_entries[j].sample_count>= sample_number) {\n\t\t\t\t\tsgd_index = sg->sample_entries[j].group_description_index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsnum += sg->sample_entries[j].sample_count;\n\t\t\t}\n\t\t}\n\n\t\t*sgrp_type = sgd->grouping_type;\n\t\tif (sgrp_parameter && sg) *sgrp_parameter = sg->grouping_type_parameter;\n\n\t\tif (sgd_index) {\n\t\t\tGF_DefaultSampleGroupDescriptionEntry *entry = gf_list_get(sgd->group_descriptions, sgd_index-1);\n\t\t\tif (entry) {\n\t\t\t\tif (sgrp_data) *sgrp_data = entry->data;\n\t\t\t\tif (sgrp_size) *sgrp_size = entry->length;\n\t\t\t}\n\t\t}\n\n\t\t(*sgrp_idx)++;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_DefaultSampleGroupDescriptionEntry * gf_isom_get_sample_group_info_entry(GF_ISOFile *the_file, GF_TrackBox *trak, u32 grouping_type, u32 sample_group_description_index, u32 *default_index, GF_SampleGroupDescriptionBox **out_sgdp)\n{\n\tu32 i, count;\n\n\tif (!trak || !sample_group_description_index) return NULL;\n\tif (!trak->Media->information->sampleTable->sampleGroupsDescription) return NULL;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type != grouping_type) continue;\n\n\t\tif (sgdesc->default_description_index && !sample_group_description_index) sample_group_description_index = sgdesc->default_description_index;\n\n\t\tif (default_index) *default_index = sgdesc->default_description_index ;\n\t\tif (out_sgdp) *out_sgdp = sgdesc;\n\n\t\tif (!sample_group_description_index) return NULL;\n\t\treturn (GF_DefaultSampleGroupDescriptionEntry*)gf_list_get(sgdesc->group_descriptions, sample_group_description_index-1);\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nBool gf_isom_get_sample_group_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_description_index, u32 grouping_type, u32 *default_index, const u8 **data, u32 *size)\n{\n\tGF_DefaultSampleGroupDescriptionEntry *sg_entry;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\n\tif (default_index) *default_index = 0;\n\tif (size) *size = 0;\n\tif (data) *data = NULL;\n\n\tsg_entry = gf_isom_get_sample_group_info_entry(the_file, trak, grouping_type, sample_description_index, default_index, NULL);\n\tif (!sg_entry) return GF_FALSE;\n\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tif (sg_entry && data) *data = (char *) sg_entry->data;\n\t\tif (sg_entry && size) *size = sg_entry->length;\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n//return the duration of the movie+fragments if known, 0 if error\nGF_EXPORT\nu64 gf_isom_get_fragmented_duration(GF_ISOFile *movie)\n{\n\tif (movie->moov->mvex && movie->moov->mvex->mehd)\n\t\treturn movie->moov->mvex->mehd->fragment_duration;\n\n\treturn 0;\n}\n//return the duration of the movie+fragments if known, 0 if error\nGF_EXPORT\nu32 gf_isom_get_fragments_count(GF_ISOFile *movie, Bool segments_only)\n{\n\tu32 i=0;\n\tu32 nb_frags = 0;\n\tGF_Box *b;\n\twhile ((b=(GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tif (segments_only) {\n\t\t\tif (b->type==GF_ISOM_BOX_TYPE_SIDX)\n\t\t\t\tnb_frags++;\n\t\t} else {\n\t\t\tif (b->type==GF_ISOM_BOX_TYPE_MOOF)\n\t\t\t\tnb_frags++;\n\t\t}\n\t}\n\treturn nb_frags;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_fragmented_samples_info(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 *nb_samples, u64 *duration)\n{\n\tu32 i=0;\n\tu32 k, l;\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\n\t*nb_samples = 0;\n\t*duration = 0;\n\twhile ((moof=(GF_MovieFragmentBox*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tu32 j=0;\n\t\tif (moof->type!=GF_ISOM_BOX_TYPE_MOOF) continue;\n\n\t\twhile ((traf=(GF_TrackFragmentBox*)gf_list_enum( moof->TrackList, &j))) {\n\t\t\tu64 def_duration, samp_dur=0;\n\n\t\t\tif (traf->tfhd->trackID != trackID)\n\t\t\t\tcontinue;\n\n\t\t\tdef_duration = 0;\n\t\t\tif (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) def_duration = traf->tfhd->def_sample_duration;\n\t\t\telse if (traf->trex) def_duration = traf->trex->def_sample_duration;\n\n\t\t\tfor (k=0; k<gf_list_count(traf->TrackRuns); k++) {\n\t\t\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, k);\n\t\t\t\t*nb_samples += trun->sample_count;\n\n\t\t\t\tfor (l=0; l<trun->nb_samples; l++) {\n\t\t\t\t\tGF_TrunEntry *ent = &trun->samples[l];\n\n\t\t\t\t\tsamp_dur = def_duration;\n\t\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) samp_dur = ent->Duration;\n\t\t\t\t\tif (trun->nb_samples == trun->sample_count)\n\t\t\t\t\t\t*duration += samp_dur;\n\t\t\t\t}\n\t\t\t\tif (trun->nb_samples != trun->sample_count)\n\t\t\t\t\t*duration += samp_dur * trun->sample_count;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_nalu_extract_mode(GF_ISOFile *the_file, u32 trackNumber, GF_ISONaluExtractMode nalu_extract_mode)\n{\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->extractor_mode = nalu_extract_mode;\n\n\tif (!trak->References) return GF_OK;\n\n\t/*get base*/\n\tdpnd = NULL;\n\ttrak->has_base_layer = GF_FALSE;\n\tTrack_FindRef(trak, GF_ISOM_REF_SCAL, &dpnd);\n\tif (dpnd) trak->has_base_layer = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_ISONaluExtractMode gf_isom_get_nalu_extract_mode(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->extractor_mode;\n}\n\nGF_EXPORT\ns32 gf_isom_get_composition_offset_shift(GF_ISOFile *file, u32 track)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return 0;\n\tif (!trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->CompositionToDecode) return 0;\n\treturn trak->Media->information->sampleTable->CompositionToDecode->compositionToDTSShift;\n}\n\nGF_EXPORT\nBool gf_isom_needs_layer_reconstruction(GF_ISOFile *file)\n{\n\tu32 count, i;\n\tif (!file)\n\t\treturn GF_FALSE;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i = 0; i < count; i++) {\n\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_SCAL) > 0) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_SABT) > 0) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tswitch (gf_isom_get_media_subtype(file, i+1, 1)) {\n\t\tcase GF_ISOM_SUBTYPE_LHV1:\n\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_BASE) > 0) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nvoid gf_isom_keep_utc_times(GF_ISOFile *file, Bool keep_utc)\n{\n\tif (!file) return;\n\tfile->keep_utc = keep_utc;\n}\n\nGF_EXPORT\nBool gf_isom_has_keep_utc_times(GF_ISOFile *file)\n{\n\tif (!file) return GF_FALSE;\n\treturn file->keep_utc;\n}\n\n\n\nGF_EXPORT\nu32 gf_isom_get_pssh_count(GF_ISOFile *file)\n{\n\tu32 count=0;\n\tu32 i=0;\n\tGF_Box *a_box;\n\tif (file->moov) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (file->meta) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->meta->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n#if 0 //unused\n/*! gets serialized PSS\n\\param isom_file the target ISO file\n\\param pssh_index 1-based index of PSSH to query, see \\ref gf_isom_get_pssh_count\n\\param pssh_data set to a newly allocated buffer containing serialized PSSH - shall be freeed by caller\n\\param pssh_size set to the size of the allocated buffer\n\\return error if any\n*/\nGF_Err gf_isom_get_pssh(GF_ISOFile *file, u32 pssh_index, u8 **pssh_data, u32 *pssh_size)\n{\n\tGF_Err e;\n\tu32 i=0;\n\tGF_BitStream *bs;\n\tu32 count=1;\n\tGF_Box *pssh;\n\twhile ((pssh = (GF_Box *)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\tif (count == pssh_index) break;\n\t\tcount++;\n\t}\n\tif (!pssh) return GF_BAD_PARAM;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_write(pssh, bs);\n\tif (!e) {\n\t\tgf_bs_get_content(bs, pssh_data, pssh_size);\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_get_pssh_info(GF_ISOFile *file, u32 pssh_index, bin128 SystemID, u32 *version, u32 *KID_count, const bin128 **KIDs, const u8 **private_data, u32 *private_data_size)\n{\n\tu32 count=1;\n\tu32 i=0;\n\tGF_ProtectionSystemHeaderBox *pssh=NULL;\n\tif (file->moov) {\n\t\twhile ((pssh = (GF_ProtectionSystemHeaderBox *)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tif (count == pssh_index) break;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!pssh && file->meta) {\n\t\twhile ((pssh = (GF_ProtectionSystemHeaderBox *)gf_list_enum(file->meta->child_boxes, &i))) {\n\t\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tif (count == pssh_index) break;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!pssh) return GF_BAD_PARAM;\n\n\tif (SystemID) memcpy(SystemID, pssh->SystemID, 16);\n\tif (version) *version = pssh->version;\n\tif (KID_count) *KID_count = pssh->KID_count;\n\tif (KIDs) *KIDs = (const bin128 *) pssh->KIDs;\n\tif (private_data_size) *private_data_size = pssh->private_data_size;\n\tif (private_data) *private_data = pssh->private_data;\n\treturn GF_OK;\n}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#else\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#endif\n{\n\tGF_SampleGroupBox *sample_group;\n\tu32 j, group_desc_index;\n\tGF_SampleGroupDescriptionBox *sgdesc;\n\tu32 i, count;\n\tu32 descIndex, chunkNum;\n\tu64 offset;\n\tu32 first_sample_in_entry, last_sample_in_entry;\n\tGF_CENCSampleEncryptionGroupEntry *entry;\n\n\tif (IsEncrypted) *IsEncrypted = GF_FALSE;\n\tif (crypt_byte_block) *crypt_byte_block = 0;\n\tif (skip_byte_block) *skip_byte_block = 0;\n\tif (key_info) *key_info = NULL;\n\tif (key_info_size) *key_info_size = 0;\n\t\n\tif (!trak) return GF_BAD_PARAM;\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf)\n\t\treturn GF_NOT_SUPPORTED;\n#else\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\n\tif (trak->Media->information->sampleTable->SampleSize && trak->Media->information->sampleTable->SampleSize->sampleCount>=sample_number) {\n\t\tstbl_GetSampleInfos(trak->Media->information->sampleTable, sample_number, &offset, &chunkNum, &descIndex, NULL);\n\t} else {\n\t\t//this is dump mode of fragments, we haven't merged tables yet - use current stsd idx indicated in trak\n\t\tdescIndex = trak->current_traf_stsd_idx;\n\t\tif (!descIndex) descIndex = 1;\n\t}\n\n\tgf_isom_cenc_get_default_info_internal(trak, descIndex, NULL, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n\n\tsample_group = NULL;\n\tgroup_desc_index = 0;\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!group_desc_index && traf && traf->sampleGroups) {\n\t\tcount = gf_list_count(traf->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tgroup_desc_index = 0;\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(traf->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup info associated*/\n\tif (!group_desc_index) goto exit;\n\n\tsgdesc = NULL;\n\n\tif (group_desc_index<=0x10000) {\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\telse if (traf) {\n\t\tgroup_desc_index -= 0x10000;\n\t\tfor (j=0; j<gf_list_count(traf->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(traf->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup description found for this group (invalid file)*/\n\tif (!sgdesc) return GF_ISOM_INVALID_FILE;\n\n\tentry = (GF_CENCSampleEncryptionGroupEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\n\tif (IsEncrypted) *IsEncrypted = entry->IsProtected;\n\tif (crypt_byte_block) *crypt_byte_block = entry->crypt_byte_block;\n\tif (skip_byte_block) *skip_byte_block = entry->skip_byte_block;\n\n\tif (key_info) *key_info = entry->key_info;\n\tif (key_info_size) *key_info_size = entry->key_info_size;\n\nexit:\n\t//in PIFF we may have default values if no TENC is present: 8 bytes for IV size\n\tif (( (senc && senc->piff_type==1) || (trak->moov && trak->moov->mov->is_smooth) ) && key_info && ! (*key_info) ) {\n\t\tif (!senc) {\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = 8;\n\t\t} else {\n\t\t\tif (!senc->piff_type) {\n\t\t\t\tsenc->piff_type = 2;\n\t\t\t\tsenc->IV_size = 8;\n\t\t\t}\n\t\t\tassert(senc->IV_size);\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = senc->IV_size;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_cenc_info(GF_ISOFile *movie, u32 track, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tGF_SampleEncryptionBox *senc = trak->sample_encryption;\n\n\treturn gf_isom_get_sample_cenc_info_internal(trak, NULL, senc, sample_number, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n}\n\n\nGF_EXPORT\nBool gf_isom_get_last_producer_time_box(GF_ISOFile *file, GF_ISOTrackID *refTrackID, u64 *ntp, u64 *timestamp, Bool reset_info)\n{\n\tif (!file) return GF_FALSE;\n\tif (refTrackID) *refTrackID = 0;\n\tif (ntp) *ntp = 0;\n\tif (timestamp) *timestamp = 0;\n\n\tif (file->last_producer_ref_time) {\n\t\tif (refTrackID) *refTrackID = file->last_producer_ref_time->refTrackID;\n\t\tif (ntp) *ntp = file->last_producer_ref_time->ntp;\n\t\tif (timestamp) *timestamp = file->last_producer_ref_time->timestamp;\n\n\t\tif (reset_info) {\n\t\t\tfile->last_producer_ref_time = NULL;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu64 gf_isom_get_current_tfdt(GF_ISOFile *the_file, u32 trackNumber)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->dts_at_seg_start;\n#endif\n}\n\nGF_EXPORT\nu64 gf_isom_get_smooth_next_tfdt(GF_ISOFile *the_file, u32 trackNumber)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->dts_at_next_frag_start;\n#endif\n}\n\nGF_EXPORT\nBool gf_isom_is_smooth_streaming_moov(GF_ISOFile *the_file)\n{\n\treturn the_file ? the_file->is_smooth : GF_FALSE;\n}\n\n\nvoid gf_isom_parse_trif_info(const u8 *data, u32 size, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h)\n{\n\tGF_BitStream *bs;\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t*id = gf_bs_read_u16(bs);\n\tif (! gf_bs_read_int(bs, 1)) {\n\t\t*independent=0;\n\t\t*full_picture=0;\n\t\t*x = *y = *w = *h = 0;\n\t} else {\n\t\t*independent = gf_bs_read_int(bs, 2);\n\t\t*full_picture = (Bool)gf_bs_read_int(bs, 1);\n\t\t/*filter_disabled*/ gf_bs_read_int(bs, 1);\n\t\t/*has_dependency_list*/ gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 2);\n\t\t*x = *full_picture ? 0 : gf_bs_read_u16(bs);\n\t\t*y = *full_picture ? 0 : gf_bs_read_u16(bs);\n\t\t*w = gf_bs_read_u16(bs);\n\t\t*h = gf_bs_read_u16(bs);\n\t}\n\tgf_bs_del(bs);\n}\n\nGF_EXPORT\nBool gf_isom_get_tile_info(GF_ISOFile *file, u32 trackNumber, u32 sample_description_index, u32 *default_sample_group_index, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h)\n{\n\tconst u8 *data;\n\tu32 size;\n\n\tif (!gf_isom_get_sample_group_info(file, trackNumber, sample_description_index, GF_ISOM_SAMPLE_GROUP_TRIF, default_sample_group_index, &data, &size))\n\t\treturn GF_FALSE;\n\tgf_isom_parse_trif_info(data, size, id, independent, full_picture, x, y, w, h);\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_isom_get_oinf_info(GF_ISOFile *file, u32 trackNumber, GF_OperatingPointsInformation **ptr)\n{\n\tu32 oref_track, def_index=0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, trackNumber);\n\n\tif (!ptr) return GF_FALSE;\n\n\toref_track=0;\n\tgf_isom_get_reference(file, trackNumber, GF_ISOM_REF_OREF, 1, &oref_track);\n\tif (oref_track) {\n\t\ttrak = gf_isom_get_track_from_file(file, oref_track);\n\t\tif (!trak) return GF_FALSE;\n\t}\n\n\t*ptr = (GF_OperatingPointsInformation *) gf_isom_get_sample_group_info_entry(file, trak, GF_ISOM_SAMPLE_GROUP_OINF, 1, &def_index, NULL);\n\n\treturn *ptr ? GF_TRUE : GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_byte_offset(GF_ISOFile *file, s64 byte_offset)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->read_byte_offset = byte_offset;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) return ve->avc_config->config->nal_unit_size;\n\tif (ve->svc_config) return ve->svc_config->config->nal_unit_size;\n\tif (ve->hevc_config) return ve->hevc_config->config->nal_unit_size;\n\tif (ve->lhvc_config) return ve->lhvc_config->config->nal_unit_size;\n\tif (ve->vvc_config) return ve->vvc_config->config->nal_unit_size;\n\treturn 0;\n}\n\nGF_EXPORT\nBool gf_isom_is_video_handler_type(u32 mtype)\n{\n\tswitch (mtype) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n\tcase GF_ISOM_MEDIA_AUXV:\n\tcase GF_ISOM_MEDIA_PICT:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_bitrate(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 *average_bitrate, u32 *max_bitrate, u32 *decode_buffer_size)\n{\n\tGF_BitRateBox *a;\n\tu32 i, count, mrate, arate, dbsize, type;\n\tGF_SampleEntryBox *ent;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_TrackBox *trak;\n\tGF_ESDBox *esd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tmrate = arate = dbsize = 0;\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tif ((sampleDescIndex>0) && (i+1 != sampleDescIndex)) continue;\n\n\t\tent = (GF_SampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!ent) return GF_BAD_PARAM;\n\t\ta = gf_isom_sample_entry_get_bitrate(ent, GF_FALSE);\n\t\tif (a) {\n\t\t\tif (mrate<a->maxBitrate) mrate = a->maxBitrate;\n\t\t\tif (arate<a->avgBitrate) arate = a->avgBitrate;\n\t\t\tif (dbsize<a->bufferSizeDB) dbsize = a->bufferSizeDB;\n\t\t\tcontinue;\n\t\t}\n\t\ttype = ent->type;\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t\t\tbreak;\n\t\t}\n\t\tesd = NULL;\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\t\tesd = ((GF_MPEGVisualSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\t\tesd = ((GF_MPEGAudioSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\t\tesd = ((GF_MPEGSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\t}\n\t\tif (esd && esd->desc && esd->desc->decoderConfig) {\n\t\t\tif (mrate<esd->desc->decoderConfig->maxBitrate) mrate = esd->desc->decoderConfig->maxBitrate;\n\t\t\tif (arate<esd->desc->decoderConfig->avgBitrate) arate = esd->desc->decoderConfig->avgBitrate;\n\t\t\tif (dbsize<esd->desc->decoderConfig->bufferSizeDB) dbsize = esd->desc->decoderConfig->bufferSizeDB;\n\t\t}\n\t}\n\tif (average_bitrate) *average_bitrate = arate;\n\tif (max_bitrate) *max_bitrate = mrate;\n\tif (decode_buffer_size) *decode_buffer_size = dbsize;\n\treturn GF_OK;\n}\n\nvoid gf_isom_enable_traf_map_templates(GF_ISOFile *movie)\n{\n\tif (movie)\n\t\tmovie->signal_frag_bounds=GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_isom_sample_is_fragment_start(GF_ISOFile *movie, u32 trackNumber, u32 sampleNum, GF_ISOFragmentBoundaryInfo *frag_info)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\tGF_TrafToSampleMap *tmap;\n\n\tif (frag_info) memset(frag_info, 0, sizeof(GF_ISOFragmentBoundaryInfo));\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->traf_map) return GF_FALSE;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNum<=trak->sample_count_at_seg_start)\n\t\treturn GF_FALSE;\n\tsampleNum -= trak->sample_count_at_seg_start;\n#endif\n\n\ttmap = trak->Media->information->sampleTable->traf_map;\n\tif (!tmap) return GF_FALSE;\n\tfor (i=0; i<tmap->nb_entries; i++) {\n\t\tGF_TrafMapEntry *finfo = &tmap->frag_starts[i];\n\t\tif (finfo->sample_num == sampleNum) {\n\t\t\tif (frag_info) {\n\t\t\t\tfrag_info->frag_start = finfo->moof_start;\n\t\t\t\tfrag_info->mdat_end = finfo->mdat_end;\n\t\t\t\tfrag_info->moof_template = finfo->moof_template;\n\t\t\t\tfrag_info->moof_template_size = finfo->moof_template_size;\n\t\t\t\tfrag_info->seg_start_plus_one = finfo->seg_start_plus_one;\n\t\t\t\tfrag_info->sidx_start = finfo->sidx_start;\n\t\t\t\tfrag_info->sidx_end = finfo->sidx_end;\n\t\t\t}\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (tmap->frag_starts[i].sample_num > sampleNum) return GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_isom_get_root_sidx_offsets(GF_ISOFile *movie, u64 *start, u64 *end)\n{\n\tif (!movie || !start || !end) return GF_FALSE;\n\t*start = movie->root_sidx_start_offset;\n\t*end = movie->root_sidx_end_offset;\n\treturn GF_TRUE;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_get_jp2_config(GF_ISOFile *movie, u32 trackNumber, u32 sampleDesc, u8 **out_dsi, u32 *out_size)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_BitStream *bs;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription) return GF_ISOM_INVALID_FILE;\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDesc-1);\n\tif (!entry || !entry->jp2h) return GF_BAD_PARAM;\n\tif (!entry->jp2h->ihdr) return GF_ISOM_INVALID_FILE;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_array_write((GF_Box*)entry->jp2h, entry->jp2h->child_boxes, bs);\n\tgf_bs_get_content(bs, out_dsi, out_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\nBool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type)\n{\n\tBool res = GF_FALSE;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_BitStream *bs1, *bs2;\n\tu8 *buf1, *buf2;\n\tu32 len1, len2;\n\n\tif (!ptr1 || !ptr2)\n\t\treturn GF_FALSE;\n\n\tbs1 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr1, bs1);\n\t} else {\n\t\tgf_isom_box_size((GF_Box *)ptr1);\n\t\tgf_isom_box_write((GF_Box *)ptr1, bs1);\n\t}\n\tgf_bs_get_content(bs1, &buf1, &len1);\n\tgf_bs_del(bs1);\n\n\tbs2 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr2, bs2);\n\t} else {\n\t\tgf_isom_box_write((GF_Box *)ptr2, bs2);\n\t}\n\tgf_bs_get_content(bs2, &buf2, &len2);\n\tgf_bs_del(bs2);\n\n\n\tif ((len1==len2) && !memcmp(buf1, buf2, len1))\n\t\tres = GF_TRUE;\n\n\tgf_free(buf1);\n\tgf_free(buf2);\n#endif\n\treturn res;\n}\n\nGF_EXPORT\nu64 gf_isom_get_track_magic(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->magic;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_file_offset_for_time(GF_ISOFile *movie, Double start_time, u64 *max_offset)\n{\n\tu32 i;\n\tu64 start_ts, cur_start_time;\n\tu64 offset=0;\n\tif (!movie || !movie->moov)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\tstart_ts = (u64) (start_time * movie->main_sidx->timescale);\n\tcur_start_time = 0;\n\toffset = movie->main_sidx->first_offset + movie->main_sidx_end_pos;\n\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tif (cur_start_time >= start_ts) {\n\t\t\t*max_offset = offset;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tcur_start_time += movie->main_sidx->refs[i].subsegment_duration;\n\t\toffset += movie->main_sidx->refs[i].reference_size;\n\t}\n\n\treturn GF_EOS;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sidx_duration(GF_ISOFile *movie, u64 *sidx_dur, u32 *sidx_timescale)\n{\n\tu64 dur=0;\n\tu32 i;\n\tif (!movie || !movie->moov || !sidx_timescale || !sidx_dur)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\t*sidx_timescale = movie->main_sidx->timescale;\n\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tdur += movie->main_sidx->refs[i].subsegment_duration;\n\t}\n\t*sidx_dur = dur;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u8 *gf_isom_get_mpegh_compatible_profiles(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 *nb_compat_profiles)\n{\n\tGF_SampleEntryBox *ent;\n\tGF_MHACompatibleProfilesBox *mhap;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !nb_compat_profiles) return NULL;\n\t*nb_compat_profiles = 0;\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescIndex-1);\n\tif (!ent) return NULL;\n\tmhap = (GF_MHACompatibleProfilesBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_MHAP);\n\tif (!mhap) return NULL;\n\t*nb_compat_profiles = mhap->num_profiles;\n\treturn mhap->compat_profiles;\n}\n\nconst void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn NULL;\n#else\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\n\treturn trak->tfrf;\n#endif\n}\n\nGF_Err gf_isom_get_y3d_info(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info)\n{\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\tBool found = GF_FALSE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !info) return GF_BAD_PARAM;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tmemset(info, 0, sizeof(GF_ISOM_Y3D_Info));\n\n\tGF_Stereo3DBox *st3d = (GF_Stereo3DBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (st3d) {\n\t\tfound = GF_TRUE;\n\t\tinfo->stereo_type = st3d->stereo_type;\n\t}\n\n\tGF_Box *sv3d = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (!sv3d) {\n\t\treturn found ? GF_OK : GF_NOT_FOUND;\n\t}\n\tGF_SphericalVideoInfoBox *svhd = (GF_SphericalVideoInfoBox *) gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\tif (svhd && strlen(svhd->string)) info->meta_data = svhd->string;\n\n\tGF_Box *proj = gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\tif (!proj)\n\t\treturn found ? GF_OK : GF_NOT_FOUND;\n\n\tGF_ProjectionHeaderBox *projh = (GF_ProjectionHeaderBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\tif (projh) {\n\t\tinfo->yaw = projh->yaw;\n\t\tinfo->pitch = projh->pitch;\n\t\tinfo->roll = projh->roll;\n\t\tinfo->pose_present = GF_TRUE;\n\t}\n\n\tGF_ProjectionTypeBox *projt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_CBMP);\n\tif (projt) {\n\t\tinfo->layout = projt->layout;\n\t\tinfo->padding = projt->padding;\n\t\tinfo->projection_type = 1;\n\t} else {\n\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (projt) {\n\t\t\tinfo->top = projt->bounds_top;\n\t\t\tinfo->bottom = projt->bounds_bottom;\n\t\t\tinfo->left = projt->bounds_left;\n\t\t\tinfo->right = projt->bounds_right;\n\t\t\tinfo->projection_type = 2;\n\t\t} else {\n\t\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\t\tif (projt) {\n\t\t\t\tinfo->projection_type = 3;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_chunk_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_ChunkOffsetBox *stco;\n\tGF_TrackBox *trak;\n\tif (!movie || !movie->moov || !trackNumber) return 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->ChunkOffset ) return 0;\n\n\tstco = (GF_ChunkOffsetBox *) trak->Media->information->sampleTable->ChunkOffset;\n\tif (stco->type == GF_ISOM_BOX_TYPE_STCO)\n\t\treturn stco->nb_entries;\n\tif (stco->type == GF_ISOM_BOX_TYPE_CO64)\n\t\treturn ((GF_ChunkLargeOffsetBox *) stco)->nb_entries;\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chunk_info(GF_ISOFile *movie, u32 trackNumber, u32 chunk_num, u64 *chunk_offset, u32 *first_sample_num, u32 *sample_per_chunk, u32 *sample_desc_idx, u32 *cache_1, u32 *cache_2)\n{\n\tGF_ChunkOffsetBox *stco = NULL;\n\tGF_ChunkLargeOffsetBox *co64 = NULL;\n\tGF_SampleToChunkBox *stsc = NULL;\n\tGF_TrackBox *trak;\n\tu32 i, nb_entries, nb_samples, sample_desc_index;\n\tif (!movie || !movie->moov || !trackNumber || !chunk_num) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->ChunkOffset ) return GF_BAD_PARAM;\n\n\tstsc = (GF_SampleToChunkBox *) trak->Media->information->sampleTable->SampleToChunk;\n\tstco = (GF_ChunkOffsetBox *) trak->Media->information->sampleTable->ChunkOffset;\n\tif (stco->type == GF_ISOM_BOX_TYPE_CO64) {\n\t\tstco = NULL;\n\t\tco64 = (GF_ChunkLargeOffsetBox *) trak->Media->information->sampleTable->ChunkOffset;\n\t\tnb_entries = co64->nb_entries;\n\t} else {\n\t\tnb_entries = stco->nb_entries;\n\t}\n\tif (chunk_num>nb_entries) return GF_BAD_PARAM;\n\n\tsample_desc_index = 0;\n\tnb_samples = 1;\n\ti=0;\n\n\tif (cache_1 && cache_2) {\n\t\tif (chunk_num==1) {\n\t\t\t*cache_1 = 0;\n\t\t\t*cache_2 = 1;\n\t\t}\n\t\ti = *cache_1;\n\t\tnb_samples = *cache_2;\n\t}\n\n\tfor (; i<stsc->nb_entries; i++) {\n\t\tu32 nb_chunks_before;\n\n\t\tif (stsc->entries[i].firstChunk == chunk_num) {\n\t\t\tsample_desc_index = stsc->entries[i].sampleDescriptionIndex;\n\t\t\tif (sample_per_chunk)\n\t\t\t\t*sample_per_chunk = stsc->entries[i].samplesPerChunk;\n\t\t\tbreak;\n\t\t}\n\t\tassert(stsc->entries[i].firstChunk<chunk_num);\n\n\t\tif ((i+1 == stsc->nb_entries)\n\t\t\t|| (stsc->entries[i+1].firstChunk>chunk_num)\n\t\t) {\n\t\t\tnb_chunks_before = chunk_num - stsc->entries[i].firstChunk;\n\t\t\tnb_samples += stsc->entries[i].samplesPerChunk * nb_chunks_before;\n\t\t\tsample_desc_index = stsc->entries[i].sampleDescriptionIndex;\n\t\t\tif (sample_per_chunk)\n\t\t\t\t*sample_per_chunk = stsc->entries[i].samplesPerChunk;\n\t\t\tbreak;\n\t\t}\n\t\tassert(stsc->entries[i+1].firstChunk > stsc->entries[i].firstChunk);\n\n\t\tnb_chunks_before = stsc->entries[i+1].firstChunk - stsc->entries[i].firstChunk;\n\t\tnb_samples += stsc->entries[i].samplesPerChunk * nb_chunks_before;\n\n\t\tif (cache_1 && cache_2) {\n\t\t\t*cache_1 = i+1;\n\t\t\t*cache_2 = nb_samples;\n\t\t}\n\t}\n\n\tif (first_sample_num) *first_sample_num = nb_samples;\n\tif (sample_desc_idx) *sample_desc_idx = sample_desc_index;\n\tif (chunk_offset) {\n\t\tif (stco)\n\t\t\t*chunk_offset = stco->offsets[chunk_num-1];\n\t\telse\n\t\t\t*chunk_offset = co64->offsets[chunk_num-1];\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_clean_aperture(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *cleanApertureWidthN, u32 *cleanApertureWidthD, u32 *cleanApertureHeightN, u32 *cleanApertureHeightD, s32 *horizOffN, u32 *horizOffD, s32 *vertOffN, u32 *vertOffD)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_CleanApertureBox *clap = (GF_CleanApertureBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\n\tif (cleanApertureWidthN) *cleanApertureWidthN = clap ? clap->cleanApertureWidthN : 0;\n\tif (cleanApertureWidthD) *cleanApertureWidthD = clap ? clap->cleanApertureWidthD : 0;\n\tif (cleanApertureHeightN) *cleanApertureHeightN = clap ? clap->cleanApertureHeightN : 0;\n\tif (cleanApertureHeightD) *cleanApertureHeightD = clap ? clap->cleanApertureHeightD : 0;\n\tif (horizOffN) *horizOffN = clap ? clap->horizOffN : 0;\n\tif (horizOffD) *horizOffD = clap ? clap->horizOffD : 0;\n\tif (vertOffN) *vertOffN = clap ? clap->vertOffN : 0;\n\tif (vertOffD) *vertOffD = clap ? clap->vertOffD : 0;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_track_group(GF_ISOFile *file, u32 track_number, u32 track_group_type)\n{\n\tu32 i;\n\tGF_TrackGroupTypeBox *trgt;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(file, track_number);\n\tif (!trak) return 0;\n\tif (!trak->groups) return 0;\n\n\tfor (i=0; i<gf_list_count(trak->groups->groups); i++) {\n\t\ttrgt = gf_list_get(trak->groups->groups, i);\n\t\tif (trgt->group_type == track_group_type) {\n\t\t\treturn trgt->track_group_id;\n\t\t}\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nconst GF_MasteringDisplayColourVolumeInfo *gf_isom_get_mastering_display_colour_info(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return NULL;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn NULL;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (entry == NULL) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\n\tGF_MasteringDisplayColourVolumeBox *mdcvb = (GF_MasteringDisplayColourVolumeBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\tif (!mdcvb) return NULL;\n\n\treturn &mdcvb->mdcv;\n}\n\nGF_EXPORT\nconst GF_ContentLightLevelInfo *gf_isom_get_content_light_level_info(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return NULL;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn NULL;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (entry == NULL) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\n\tGF_ContentLightLevelBox *cllib = (GF_ContentLightLevelBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLLI);\n\tif (!cllib) return NULL;\n\treturn &cllib->clli;\n}\n\n\nGF_Err gf_isom_enum_sample_aux_data(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 *sai_idx, u32 *sai_type, u32 *sai_parameter, u8 **sai_data, u32 *sai_size)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\tif (!sai_type || !sai_idx || !sai_data || !sai_size) return GF_BAD_PARAM;\n\tif (sai_parameter) *sai_parameter = 0;\n\t*sai_type = 0;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sai_sizes) return GF_OK;\n\tif (!trak->Media->information->sampleTable->sai_offsets) return GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sample_number <= trak->sample_count_at_seg_start) return GF_BAD_PARAM;\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sai_sizes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Err e;\n\t\tGF_SampleAuxiliaryInfoSizeBox *saiz;\n\t\tGF_SampleAuxiliaryInfoOffsetBox *saio=NULL;\n\t\tu32 j;\n\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox*)gf_list_get(trak->Media->information->sampleTable->sai_sizes, i);\n\n\t\tswitch (saiz->aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (*sai_idx>i) continue;\n\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sai_offsets); j++) {\n\t\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox*)gf_list_get(trak->Media->information->sampleTable->sai_offsets, j);\n\t\t\tif ((saio->aux_info_type == saiz->aux_info_type) && (saio->aux_info_type_parameter == saiz->aux_info_type_parameter)) break;\n\t\t\tsaio = NULL;\n\t\t}\n\t\tif (!saio) continue;\n\t\tif (!saio->offsets && !saio->sai_data) continue;\n\n\t\tu64 offset = saio->offsets ? saio->offsets[0] : 0;\n\t\tu32 nb_saio = saio->entry_count;\n\t\tif ((nb_saio>1) && (saio->entry_count != saiz->sample_count)) continue;\n\n\t\t*sai_type = saiz->aux_info_type;\n\t\tif (sai_parameter) *sai_parameter = saiz->aux_info_type_parameter;\n\n\t\t(*sai_idx)++;\n\n\t\tif (nb_saio == 1) {\n\t\t\tfor (j=0; j < sample_number-1; j++) {\n\t\t\t\tu32 size = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\t\t\t\toffset += size;\n\t\t\t}\n\t\t} else {\n\t\t\toffset = saio->offsets[sample_number-1];\n\t\t}\n\n\t\t*sai_size = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\t\tif (*sai_size) {\n\t\t\t*sai_data = gf_malloc( *sai_size);\n\t\t\tif (! *sai_data) return GF_OUT_OF_MEM;\n\t\t}\n\n\t\te = GF_OK;\n\t\tif (saio->sai_data) {\n\t\t\tif (offset + *sai_size <= saio->sai_data->dataSize) {\n\t\t\t\tmemcpy(*sai_data, saio->sai_data->data + offset, *sai_size);\n\t\t\t} else {\n\t\t\t\te = GF_IO_ERR;\n\t\t\t}\n\t\t} else {\n\t\t\tu64 cur_position = gf_bs_get_position(the_file->movieFileMap->bs);\n\t\t\tgf_bs_seek(the_file->movieFileMap->bs, offset);\n\n\t\t\tu32 nb_read = gf_bs_read_data(the_file->movieFileMap->bs, *sai_data, *sai_size);\n\t\t\tif (nb_read != *sai_size) e = GF_IO_ERR;\n\t\t\tgf_bs_seek(the_file->movieFileMap->bs, cur_position);\n\t\t}\n\n\t\tif (e) {\n\t\t\tgf_free(*sai_data);\n\t\t\t*sai_data = NULL;\n\t\t\t*sai_size = 0;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] Failed to clone sai data: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\t\treturn e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_pop_emsg(GF_ISOFile *the_file, u8 **emsg_data, u32 *emsg_size)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Box *emsg = gf_list_pop_front(the_file->emsgs);\n\tif (!emsg) return GF_NOT_FOUND;\n\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t//write everything\n\tgf_isom_box_size(emsg);\n\tgf_isom_box_write(emsg, bs);\n\tgf_bs_get_content(bs, emsg_data, emsg_size);\n\tgf_isom_box_del(emsg);\n\treturn GF_OK;\n\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n\n\n#ifndef GPAC_DISABLE_ISOM\n\nvoid co64_box_del(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr;\n\tptr = (GF_ChunkLargeOffsetBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\nGF_Err co64_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\n\tif ((u64)ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in co64\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->offsets = (u64 *) gf_malloc(ptr->nb_entries * sizeof(u64) );\n\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\tptr->alloc_size = ptr->nb_entries;\n\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\tptr->offsets[entries] = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *co64_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkLargeOffsetBox, GF_ISOM_BOX_TYPE_CO64);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err co64_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u64(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err co64_box_size(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cprt_box_del(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->notice)\n\t\tgf_free(ptr->notice);\n\tgf_free(ptr);\n}\n\n\nGF_Box *chpl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChapterListBox, GF_ISOM_BOX_TYPE_CHPL);\n\ttmp->list = gf_list_new();\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid chpl_box_del(GF_Box *s)\n{\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\tif (ptr == NULL) return;\n\twhile (gf_list_count(ptr->list)) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, 0);\n\t\tif (ce->name) gf_free(ce->name);\n\t\tgf_free(ce);\n\t\tgf_list_rem(ptr->list, 0);\n\t}\n\tgf_list_del(ptr->list);\n\tgf_free(ptr);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err chpl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChapterEntry *ce;\n\tu32 nb_chaps, len, i, count;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5)\n\t/*reserved or ???*/\n\tgf_bs_read_u32(bs);\n\tnb_chaps = gf_bs_read_u8(bs);\n\n\tcount = 0;\n\twhile (nb_chaps) {\n\t\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\t\tif (!ce) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 9)\n\t\tce->start_time = gf_bs_read_u64(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\tif (ptr->size<len) return GF_ISOM_INVALID_FILE;\n\t\tif (len) {\n\t\t\tce->name = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\t\tif (!ce->name) return GF_OUT_OF_MEM;\n\t\t\tISOM_DECREASE_SIZE(ptr, len)\n\t\t\tgf_bs_read_data(bs, ce->name, len);\n\t\t\tce->name[len] = 0;\n\t\t} else {\n\t\t\tce->name = gf_strdup(\"\");\n\t\t}\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *) gf_list_get(ptr->list, i);\n\t\t\tif (ace->start_time >= ce->start_time) {\n\t\t\t\tgf_list_insert(ptr->list, ce, i);\n\t\t\t\tce = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ce) gf_list_add(ptr->list, ce);\n\t\tcount++;\n\t\tnb_chaps--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chpl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tcount = gf_list_count(ptr->list);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tu32 len;\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tgf_bs_write_u64(bs, ce->start_time);\n\t\tif (ce->name) {\n\t\t\tlen = (u32) strlen(ce->name);\n\t\t\tif (len>255) len = 255;\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ce->name, len);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err chpl_box_size(GF_Box *s)\n{\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\tptr->size += 5;\n\n\tcount = gf_list_count(ptr->list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tptr->size += 9; /*64bit time stamp + 8bit str len*/\n\t\tif (ce->name) ptr->size += strlen(ce->name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Err cprt_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguageCode[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[2] = gf_bs_read_int(bs, 5);\n\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguageCode[0] || ptr->packedLanguageCode[1] || ptr->packedLanguageCode[2]) {\n\t\tptr->packedLanguageCode[0] += 0x60;\n\t\tptr->packedLanguageCode[1] += 0x60;\n\t\tptr->packedLanguageCode[2] += 0x60;\n\t} else {\n\t\tptr->packedLanguageCode[0] = 'u';\n\t\tptr->packedLanguageCode[1] = 'n';\n\t\tptr->packedLanguageCode[2] = 'd';\n\t}\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tptr->notice = (char*)gf_malloc((bytesToRead+1) * sizeof(char));\n\t\tif (ptr->notice == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->notice, bytesToRead);\n\t\tptr->notice[bytesToRead] = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *cprt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CopyrightBox, GF_ISOM_BOX_TYPE_CPRT);\n\ttmp->packedLanguageCode[0] = 'u';\n\ttmp->packedLanguageCode[1] = 'n';\n\ttmp->packedLanguageCode[2] = 'd';\n\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cprt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 1);\n\tif (ptr->packedLanguageCode[0]) {\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[0] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[1] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[2] - 0x60, 5);\n\t} else {\n\t\tgf_bs_write_int(bs, 0, 15);\n\t}\n\tif (ptr->notice) {\n\t\tgf_bs_write_data(bs, ptr->notice, (u32) (strlen(ptr->notice) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err cprt_box_size(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tptr->size += 2;\n\tif (ptr->notice)\n\t\tptr->size += strlen(ptr->notice) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid kind_box_del(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->schemeURI) gf_free(ptr->schemeURI);\n\tif (ptr->value) gf_free(ptr->value);\n\tgf_free(ptr);\n}\n\nGF_Err kind_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tchar *data;\n\t\tu32 schemeURIlen;\n\t\tdata = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (!data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, data, bytesToRead);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (data[bytesToRead-1]) {\n\t\t\tdata = (char*)gf_realloc(data, sizeof(char)*(bytesToRead + 1));\n\t\t\tif (!data) return GF_OUT_OF_MEM;\n\t\t\tdata[bytesToRead] = 0;\n\t\t\tbytesToRead++;\n\t\t}\n\t\tptr->schemeURI = gf_strdup(data);\n\t\tif (!ptr->schemeURI) return GF_OUT_OF_MEM;\n\t\tschemeURIlen = (u32) strlen(data);\n\t\tif (bytesToRead > schemeURIlen+1) {\n\t\t\t/* read the value */\n\t\t\tchar *data_value = data + schemeURIlen +1;\n\t\t\tptr->value = gf_strdup(data_value);\n\t\t\tif (!ptr->value) return GF_OUT_OF_MEM;\n\t\t}\n\t\tgf_free(data);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *kind_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_KindBox, GF_ISOM_BOX_TYPE_KIND);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err kind_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n    if (ptr->schemeURI)\n        gf_bs_write_data(bs, ptr->schemeURI, (u32) (strlen(ptr->schemeURI) + 1 ));\n    else\n        gf_bs_write_u8(bs, 0);\n\n    if (ptr->value) {\n\t\tgf_bs_write_data(bs, ptr->value, (u32) (strlen(ptr->value) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err kind_box_size(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n    ptr->size += (ptr->schemeURI ? strlen(ptr->schemeURI) : 0) + 1;\n\tif (ptr->value) {\n\t\tptr->size += strlen(ptr->value) + 1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ctts_box_del(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err ctts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tu32 sampleCount;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_DttsEntry) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = (GF_DttsEntry *)gf_malloc(sizeof(GF_DttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\tsampleCount = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tif (ptr->version)\n\t\t\tptr->entries[i].decodingOffset = gf_bs_read_int(bs, 32);\n\t\telse\n\t\t\tptr->entries[i].decodingOffset = (s32) gf_bs_read_u32(bs);\n\n\t\tif (ptr->max_cts_delta <= ABS(ptr->entries[i].decodingOffset)) {\n\t\t\tptr->max_cts_delta = ABS(ptr->entries[i].decodingOffset);\n\t\t\t//ptr->sample_num_max_cts_delta = sampleCount;\n\t\t}\n\t\tsampleCount += ptr->entries[i].sampleCount;\n\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastSampleNumber = sampleCount;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *ctts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionOffsetBox, GF_ISOM_BOX_TYPE_CTTS);\n\treturn (GF_Box *) tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ctts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tif (ptr->version) {\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].decodingOffset, 32);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->entries[i].decodingOffset);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ctts_box_size(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cslg_box_del(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err cslg_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->compositionToDTSShift = gf_bs_read_int(bs, 32);\n\tptr->leastDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->greatestDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->compositionStartTime = gf_bs_read_int(bs, 32);\n\tptr->compositionEndTime = gf_bs_read_int(bs, 32);\n\treturn GF_OK;\n}\n\nGF_Box *cslg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionToDecodeBox, GF_ISOM_BOX_TYPE_CSLG);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cslg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->compositionToDTSShift, 32);\n\tgf_bs_write_int(bs, ptr->leastDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->greatestDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->compositionStartTime, 32);\n\tgf_bs_write_int(bs, ptr->compositionEndTime, 32);\n\treturn GF_OK;\n}\n\nGF_Err cslg_box_size(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tptr->size += 20;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ccst_box_del(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tif (ptr) gf_free(ptr);\n\treturn;\n}\n\nGF_Err ccst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->all_ref_pics_intra = gf_bs_read_int(bs, 1);\n\tptr->intra_pred_used = gf_bs_read_int(bs, 1);\n\tptr->max_ref_per_pic = gf_bs_read_int(bs, 4);\n\tptr->reserved = gf_bs_read_int(bs, 26);\n\treturn GF_OK;\n}\n\nGF_Box *ccst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CodingConstraintsBox, GF_ISOM_BOX_TYPE_CCST);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ccst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->all_ref_pics_intra, 1);\n\tgf_bs_write_int(bs, ptr->intra_pred_used, 1);\n\tgf_bs_write_int(bs, ptr->max_ref_per_pic, 4);\n\tgf_bs_write_int(bs, 0, 26);\n\treturn GF_OK;\n}\n\nGF_Err ccst_box_size(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid url_box_del(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif (ptr->size) {\n\t\tu32 location_size = (u32) ptr->size;\n\t\tif (location_size < 1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in svhd box\\n\", ptr->size));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->location = (char*)gf_malloc(location_size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, location_size);\n\t\tif (ptr->location[location_size-1]) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] url box location is not 0-terminated\\n\" ));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *url_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURLBox, GF_ISOM_BOX_TYPE_URL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err url_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err url_box_size(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid urn_box_del(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tif (ptr->nameURN) gf_free(ptr->nameURN);\n\tgf_free(ptr);\n}\n\n\nGF_Err urn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, to_read;\n\tchar *tmpName;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (! ptr->size ) return GF_OK;\n\n\t//here we have to handle that in a clever way\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\t//get the data\n\tgf_bs_read_data(bs, tmpName, to_read);\n\n\t//then get the break\n\ti = 0;\n\twhile ( (i < to_read) && (tmpName[i] != 0) ) {\n\t\ti++;\n\t}\n\t//check the data is consistent\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//no NULL char, URL is not specified\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;\n\t\tptr->location = NULL;\n\t\treturn GF_OK;\n\t}\n\t//OK, this has both URN and URL\n\tptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));\n\tif (!ptr->nameURN) {\n\t\tgf_free(tmpName);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(ptr->nameURN, tmpName, i + 1);\n\n\tif (tmpName[to_read - 1] != 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] urn box contains invalid location field\\n\" ));\n\t}\n\telse {\n\t\tptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));\n\t\tif (!ptr->location) {\n\t\t\tgf_free(tmpName);\n\t\t\tgf_free(ptr->nameURN);\n\t\t\tptr->nameURN = NULL;\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tmemcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));\n\t}\n\n\tgf_free(tmpName);\n\treturn GF_OK;\n}\n\nGF_Box *urn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURNBox, GF_ISOM_BOX_TYPE_URN);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err urn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\t//to check, the spec says: First name, then location\n\t\tif (ptr->nameURN) {\n\t\t\tgf_bs_write_data(bs, ptr->nameURN, (u32)strlen(ptr->nameURN) + 1);\n\t\t}\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err urn_box_size(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->nameURN) ptr->size += 1 + strlen(ptr->nameURN);\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid unkn_box_del(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err unkn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 bytesToRead, sub_size, sub_a;\n\tGF_BitStream *sub_bs;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (!bytesToRead) return GF_OK;\n\tif (bytesToRead>1000000) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unknown box %s (0x%08X) with payload larger than 1 MBytes, ignoring\\n\", gf_4cc_to_str(ptr->type), ptr->type ));\n\t\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\t\treturn GF_OK;\n\t}\n\n\tptr->data = (char*)gf_malloc(bytesToRead);\n\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\tptr->dataSize = bytesToRead;\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\n\t//try to parse container boxes, check if next 8 bytes match a subbox\n\tsub_bs = gf_bs_new(ptr->data, ptr->dataSize, GF_BITSTREAM_READ);\n\tsub_size = gf_bs_read_u32(sub_bs);\n\tsub_a = gf_bs_read_u8(sub_bs);\n\te = (sub_size && (sub_size <= ptr->dataSize)) ? GF_OK : GF_NOT_SUPPORTED;\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\n\tif (e == GF_OK) {\n\t\tgf_bs_seek(sub_bs, 0);\n\t\tgf_bs_set_cookie(sub_bs, GF_ISOM_BS_COOKIE_NO_LOGS);\n\t\te = gf_isom_box_array_read(s, sub_bs);\n\t}\n\tgf_bs_del(sub_bs);\n\tif (e==GF_OK) {\n\t\tgf_free(ptr->data);\n\t\tptr->data = NULL;\n\t\tptr->dataSize = 0;\n\t} else if (s->child_boxes) {\n\t\tgf_isom_box_array_del(s->child_boxes);\n\t\ts->child_boxes=NULL;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *unkn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownBox, GF_ISOM_BOX_TYPE_UNKNOWN);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err unkn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 type;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->original_4cc == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\ttype = s->type;\n\tptr->type = ptr->original_4cc;\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = type;\n\tif (e) return e;\n\n\tif (ptr->sai_type) {\n\t\tif (ptr->saio_box) {\n\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\tgf_bs_seek(bs, ptr->saio_box->offset_first_offset_field);\n\t\t\tif (ptr->saio_box->version)\n\t\t\t\tgf_bs_write_u64(bs, pos);\n\t\t\telse\n\t\t\t\tgf_bs_write_u32(bs, (u32) pos);\n\t\t\tgf_bs_seek(bs, pos);\n\t\t} else {\n\t\t\tptr->sai_offset = gf_bs_get_position(bs);\n\t\t}\n\t}\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err unkn_box_size(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tptr->size += ptr->dataSize;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid def_parent_box_del(GF_Box *s)\n{\n\tif (s) gf_free(s);\n}\n\n\nGF_Err def_parent_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *def_parent_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, 0);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITEHintSa\n\nGF_Err def_parent_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err def_parent_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid def_parent_full_box_del(GF_Box *s)\n{\n\tif (s) gf_free(s);\n}\n\n\nGF_Err def_parent_full_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *def_parent_full_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, 0);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITEHintSa\n\nGF_Err def_parent_full_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err def_parent_full_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid uuid_box_del(GF_Box *s)\n{\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err uuid_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead);\n\t\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\t\tptr->dataSize = bytesToRead;\n\t\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *uuid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownUUIDBox, GF_ISOM_BOX_TYPE_UUID);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err uuid_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox*)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err uuid_box_size(GF_Box *s)\n{\n\tGF_UnknownUUIDBox*ptr = (GF_UnknownUUIDBox*)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid dinf_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err dinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_DataInformationBox *ptr = (GF_DataInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_DREF:\n\t\tBOX_FIELD_ASSIGN(dref, GF_DataReferenceBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataInformationBox *dinf;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) {\n\t\treturn e;\n\t}\n\tdinf = (GF_DataInformationBox *)s;\n\tif (!dinf->dref) {\n\t\tif (! (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t}\n\t\tdinf->dref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&dinf->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *dinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataInformationBox, GF_ISOM_BOX_TYPE_DINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err dinf_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid dref_box_del(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *) s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err dref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tgf_bs_read_u32(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *dref_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataReferenceBox, GF_ISOM_BOX_TYPE_DREF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dref_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count;\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tcount = ptr->child_boxes ? gf_list_count(ptr->child_boxes) : 0;\n\tgf_bs_write_u32(bs, count);\n\treturn GF_OK;\n}\n\nGF_Err dref_box_size(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid edts_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err edts_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\tif (a->type == GF_ISOM_BOX_TYPE_ELST) {\n\t\tBOX_FIELD_ASSIGN(editList, GF_EditListBox)\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err edts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *edts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditBox, GF_ISOM_BOX_TYPE_EDTS);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err edts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (ptr->editList && gf_list_count(ptr->editList->entryList)) {\n\t\treturn gf_isom_box_write_header(s, bs);\n\t} else {\n\t\ts->size = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err edts_box_size(GF_Box *s)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (!ptr->editList || ! gf_list_count(ptr->editList->entryList)) {\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid elst_box_del(GF_Box *s)\n{\n\tGF_EditListBox *ptr;\n\tu32 nb_entries;\n\tu32 i;\n\n\tptr = (GF_EditListBox *)s;\n\tif (ptr == NULL) return;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tfor (i = 0; i < nb_entries; i++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (p) gf_free(p);\n\t}\n\tgf_list_del(ptr->entryList);\n\tgf_free(ptr);\n}\n\nGF_Err elst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\ts32 tr;\n\tu32 nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tnb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->version == 1) {\n\t\tif (nb_entries > ptr->size / 20) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (nb_entries > ptr->size / 12) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\n\tfor (entries = 0; entries < nb_entries; entries++) {\n\t\tGF_EdtsEntry *p;\n\t\tGF_SAFEALLOC(p, GF_EdtsEntry);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tif (ptr->version == 1) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\tp->segmentDuration = gf_bs_read_u64(bs);\n\t\t\tp->mediaTime = (s64) gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\t\tp->segmentDuration = gf_bs_read_u32(bs);\n\t\t\ttr = gf_bs_read_u32(bs);\n\t\t\tp->mediaTime = (s64) tr;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tp->mediaRate = gf_bs_read_u32(bs);\n\t\tgf_list_add(ptr->entryList, p);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditListBox, GF_ISOM_BOX_TYPE_ELST);\n\ttmp->entryList = gf_list_new();\n\tif (!tmp->entryList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tu32 nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\n\tnb_entries = gf_list_count(ptr->entryList);\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, nb_entries);\n\tfor (i = 0; i < nb_entries; i++ ) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (ptr->version == 1) {\n\t\t\tgf_bs_write_u64(bs, p->segmentDuration);\n\t\t\tgf_bs_write_u64(bs, p->mediaTime);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->segmentDuration);\n\t\t\tgf_bs_write_u32(bs, (s32) p->mediaTime);\n\t\t}\n\t\tgf_bs_write_u32(bs, p->mediaRate);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elst_box_size(GF_Box *s)\n{\n\tu32 durtimebytes;\n\tu32 i, nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\t//entry count\n\tptr->size += 4;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tptr->version = 0;\n\tfor (i=0; i<nb_entries; i++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif ((p->segmentDuration>0xFFFFFFFF) || (p->mediaTime>0xFFFFFFFF)) {\n\t\t\tptr->version = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdurtimebytes = (ptr->version == 1 ? 16 : 8) + 4;\n\tptr->size += (nb_entries * durtimebytes);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid esds_box_del(GF_Box *s)\n{\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\tif (ptr == NULL)\treturn;\n\tif (ptr->desc) gf_odf_desc_del((GF_Descriptor *)ptr->desc);\n\tgf_free(ptr);\n}\n\n\nGF_Err esds_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e=GF_OK;\n\tu32 descSize;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\n\tdescSize = (u32) (ptr->size);\n\n\tif (descSize) {\n\t\tchar *enc_desc = (char*)gf_malloc(sizeof(char) * descSize);\n\t\tif (!enc_desc) return GF_OUT_OF_MEM;\n\t\t//get the payload\n\t\tgf_bs_read_data(bs, enc_desc, descSize);\n\t\t//send it to the OD Codec\n\t\te = gf_odf_desc_read(enc_desc, descSize, (GF_Descriptor **) &ptr->desc);\n\t\t//OK, free our desc\n\t\tgf_free(enc_desc);\n\n\t\tif (ptr->desc && (ptr->desc->tag!=GF_ODF_ESD_TAG) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid descriptor tag 0x%x in esds\\n\", ptr->desc->tag));\n\t\t\tgf_odf_desc_del((GF_Descriptor*)ptr->desc);\n\t\t\tptr->desc=NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tif (e) {\n\t\t\tptr->desc = NULL;\n\t\t} else {\n\t\t\t/*fix broken files*/\n\t\t\tif (ptr->desc && !ptr->desc->URLString) {\n\t\t\t\tif (!ptr->desc->slConfig) {\n\t\t\t\t\tptr->desc->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t} else if (ptr->desc->slConfig->predefined != SLPredef_MP4) {\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t\tgf_odf_slc_set_pref(ptr->desc->slConfig);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *esds_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ESDBox, GF_ISOM_BOX_TYPE_ESDS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err esds_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu8 *enc_desc;\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\t//make sure we write with no ESID and no OCRESID\n    if (ptr->desc) {\n        ptr->desc->ESID = 0;\n        ptr->desc->OCRESID = 0;\n    }\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\te = gf_odf_desc_write((GF_Descriptor *)ptr->desc, &enc_desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, enc_desc, descSize);\n\t//free our buffer\n\tgf_free(enc_desc);\n\treturn GF_OK;\n}\n\nGF_Err esds_box_size(GF_Box *s)\n{\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\t//make sure we write with no ESID and no OCRESID\n    if (ptr->desc) {\n        ptr->desc->ESID = 0;\n        ptr->desc->OCRESID = 0;\n    }\n\tdescSize = gf_odf_desc_size((GF_Descriptor *)ptr->desc);\n\tptr->size += descSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid free_box_del(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err free_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\n\tif (ptr->size > 0xFFFFFFFF) return GF_IO_ERR;\n\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->data, bytesToRead);\n\t\tptr->dataSize = bytesToRead;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *free_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FreeSpaceBox, GF_ISOM_BOX_TYPE_FREE);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err free_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->original_4cc) {\n\t\tu32 t = s->type;\n\t\ts->type=ptr->original_4cc;\n\t\te = gf_isom_box_write_header(s, bs);\n\t\ts->type=t;\n\t} else {\n\t\te = gf_isom_box_write_header(s, bs);\n\t}\n\tif (e) return e;\n\tif (ptr->dataSize)\t{\n\t\tif (ptr->data) {\n\t\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t\t} else {\n\t\t\tu32 i = 0;\n\t\t\twhile (i<ptr->dataSize) {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err free_box_size(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ftyp_box_del(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\tif (ptr->altBrand) gf_free(ptr->altBrand);\n\tgf_free(ptr);\n}\n\nGF_Box *ftyp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FileTypeBox, GF_ISOM_BOX_TYPE_FTYP);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err ftyp_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->majorBrand = gf_bs_read_u32(bs);\n\tptr->minorVersion = gf_bs_read_u32(bs);\n\n\tif (ptr->size % 4) return GF_ISOM_INVALID_FILE;\n\tptr->altCount = ( (u32) (ptr->size)) / 4;\n\tif (!ptr->altCount) return GF_OK;\n\n\tptr->altBrand = (u32*)gf_malloc(sizeof(u32)*ptr->altCount);\n\tif (!ptr->altBrand) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i<ptr->altCount; i++) {\n\t\tptr->altBrand[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ftyp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->majorBrand);\n\tgf_bs_write_u32(bs, ptr->minorVersion);\n\tfor (i=0; i<ptr->altCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->altBrand[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ftyp_box_size(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tptr->size += 8 + ptr->altCount * 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnrm_box_del(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericSampleEntryBox, GF_ISOM_BOX_TYPE_GNRM);\n\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n//dummy\nGF_Err gnrm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tif (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRM;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrm_box_size(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRM;\n\tptr->size += 8+ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gnrv_box_del(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrv_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericVisualSampleEntryBox, GF_ISOM_BOX_TYPE_GNRV);\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnrv_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrv_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tif (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRV;\n\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)ptr, bs);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrv_box_size(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRV;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnra_box_del(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericAudioSampleEntryBox, GF_ISOM_BOX_TYPE_GNRA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err gnra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tif (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRA;\n\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox *)ptr, bs);\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gnra_box_size(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRA;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hdlr_box_del(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->nameUTF8) gf_free(ptr->nameUTF8);\n\tgf_free(ptr);\n}\n\n\nGF_Err hdlr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 cookie;\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->reserved1 = gf_bs_read_u32(bs);\n\tptr->handlerType = gf_bs_read_u32(bs);\n\tgf_bs_read_data(bs, (char*)ptr->reserved2, 12);\n\n\tcookie = gf_bs_get_cookie(bs);\n\tif (ptr->handlerType==GF_ISOM_MEDIA_VISUAL)\n\t\tcookie |= GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\telse\n\t\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\n\tif (ptr->size) {\n\t\tu32 name_size = (u32) ptr->size;\n\t\tif (name_size < 1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in hdlr\\n\", ptr->size));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->nameUTF8 = (char*)gf_malloc(name_size);\n\t\tif (!ptr->nameUTF8) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->nameUTF8, name_size);\n\n\t\t//patch for old QT files - we cannot rely on checking if str[0]==len(str+1) since we may have\n\t\t//cases where the first character of the string decimal value is indeed the same as the string length!!\n\t\t//we had this issue with encryption_import test\n\t\t//we therefore only check if last char is null, and if not so assume old QT style\n\t\tif (ptr->nameUTF8[name_size-1]) {\n\t\t\tif (name_size > 1)\n\t\t\t\tmemmove(ptr->nameUTF8, ptr->nameUTF8+1, sizeof(char) * (u32) (name_size-1) );\n\t\t\tptr->nameUTF8[name_size-1] = 0;\n\t\t\tptr->store_counted_string = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *hdlr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HandlerBox, GF_ISOM_BOX_TYPE_HDLR);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hdlr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->reserved1);\n\tgf_bs_write_u32(bs, ptr->handlerType);\n\tgf_bs_write_data(bs, (char*)ptr->reserved2, 12);\n\n\tif (ptr->nameUTF8) {\n\t\tu32 len = (u32)strlen(ptr->nameUTF8);\n\t\tif (ptr->store_counted_string) {\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err hdlr_box_size(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tptr->size += 20 + 1; //null term or counted string\n\tif (ptr->nameUTF8) {\n\t\tptr->size += strlen(ptr->nameUTF8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid hinf_box_del(GF_Box *s)\n{\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tgf_free(hinf);\n}\n\nGF_Box *hinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintInfoBox, GF_ISOM_BOX_TYPE_HINF);\n\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err hinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MAXR:\n\t\tif (!is_rem) {\n\t\t\tu32 i=0;\n\t\t\tGF_MAXRBox *maxR;\n\t\t\twhile ((maxR = (GF_MAXRBox *)gf_list_enum(hinf->child_boxes, &i))) {\n\t\t\t\tif ((maxR->type==GF_ISOM_BOX_TYPE_MAXR) && (maxR->granularity == ((GF_MAXRBox *)a)->granularity))\n\t\t\t\t\tERROR_ON_DUPLICATED_BOX(a, s)\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err hinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_HintInfoBox *ptr = (GF_HintInfoBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err hinf_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hmhd_box_del(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err hmhd_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 16);\n\tptr->maxPDUSize = gf_bs_read_u16(bs);\n\tptr->avgPDUSize = gf_bs_read_u16(bs);\n\tptr->maxBitrate = gf_bs_read_u32(bs);\n\tptr->avgBitrate = gf_bs_read_u32(bs);\n\tptr->slidingAverageBitrate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *hmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintMediaHeaderBox, GF_ISOM_BOX_TYPE_HMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->maxPDUSize);\n\tgf_bs_write_u16(bs, ptr->avgPDUSize);\n\tgf_bs_write_u32(bs, ptr->maxBitrate);\n\tgf_bs_write_u32(bs, ptr->avgBitrate);\n\tgf_bs_write_u32(bs, ptr->slidingAverageBitrate);\n\treturn GF_OK;\n}\n\nGF_Err hmhd_box_size(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tptr->size += 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hnti_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintTrackInfoBox, GF_ISOM_BOX_TYPE_HNTI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid hnti_box_del(GF_Box *a)\n{\n\tgf_free(a);\n}\n\nGF_Err hnti_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintTrackInfoBox *ptr = (GF_HintTrackInfoBox *)s;\n\tif (!ptr || !a) return GF_BAD_PARAM;\n\n\tswitch (a->type) {\n\t//this is the value for GF_RTPBox - same as HintSampleEntry for RTP !!!\n\tcase GF_ISOM_BOX_TYPE_RTP:\n\tcase GF_ISOM_BOX_TYPE_SDP:\n\t\tBOX_FIELD_ASSIGN(SDP, GF_Box)\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err hnti_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hnti_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\n\nGF_Err hnti_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tGF_SDPBox\n**********************************************************/\n\nvoid sdp_box_del(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err sdp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in sdp box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *sdp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SDPBox, GF_ISOM_BOX_TYPE_SDP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sdp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//don't write the NULL char!!!\n\tif (ptr->sdpText)\n\t\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\nGF_Err sdp_box_size(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\t//don't count the NULL char!!!\n\tif (ptr->sdpText)\n\t\tptr->size += strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid rtp_hnti_box_del(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err rtp_hnti_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->subType = gf_bs_read_u32(bs);\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in rtp_hnti box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\n\nGF_Box *rtp_hnti_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPBox, GF_ISOM_BOX_TYPE_RTP);\n\ttmp->subType = GF_ISOM_BOX_TYPE_SDP;\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtp_hnti_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->subType);\n\t//don't write the NULL char!!!\n\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\n\nGF_Err rtp_hnti_box_size(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tptr->size += 4 + strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTRPY GF_Box\n**********************************************************/\n\nvoid trpy_box_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err trpy_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *trpy_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TRPYBox, GF_ISOM_BOX_TYPE_TRPY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trpy_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err trpy_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTOTL GF_Box\n**********************************************************/\n\nvoid totl_box_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err totl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *totl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TOTLBox, GF_ISOM_BOX_TYPE_TOTL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err totl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err totl_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNUMP GF_Box\n**********************************************************/\n\nvoid nump_box_del(GF_Box *s)\n{\n\tgf_free((GF_NUMPBox *)s);\n}\nGF_Err nump_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbPackets = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *nump_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NUMPBox, GF_ISOM_BOX_TYPE_NUMP);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err nump_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err nump_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNPCK GF_Box\n**********************************************************/\n\nvoid npck_box_del(GF_Box *s)\n{\n\tgf_free((GF_NPCKBox *)s);\n}\nGF_Err npck_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbPackets = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *npck_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NPCKBox, GF_ISOM_BOX_TYPE_NPCK);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err npck_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err npck_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTPYL GF_Box\n**********************************************************/\n\nvoid tpyl_box_del(GF_Box *s)\n{\n\tgf_free((GF_NTYLBox *)s);\n}\nGF_Err tpyl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *tpyl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NTYLBox, GF_ISOM_BOX_TYPE_TPYL);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpyl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpyl_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTPAY GF_Box\n**********************************************************/\n\nvoid tpay_box_del(GF_Box *s)\n{\n\tgf_free((GF_TPAYBox *)s);\n}\nGF_Err tpay_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tpay_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TPAYBox, GF_ISOM_BOX_TYPE_TPAY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpay_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpay_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tMAXR GF_Box\n**********************************************************/\n\nvoid maxr_box_del(GF_Box *s)\n{\n\tgf_free((GF_MAXRBox *)s);\n}\nGF_Err maxr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->granularity = gf_bs_read_u32(bs);\n\tptr->maxDataRate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *maxr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MAXRBox, GF_ISOM_BOX_TYPE_MAXR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err maxr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->granularity);\n\tgf_bs_write_u32(bs, ptr->maxDataRate);\n\treturn GF_OK;\n}\nGF_Err maxr_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMED GF_Box\n**********************************************************/\n\nvoid dmed_box_del(GF_Box *s)\n{\n\tgf_free((GF_DMEDBox *)s);\n}\nGF_Err dmed_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dmed_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMEDBox, GF_ISOM_BOX_TYPE_DMED);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmed_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dmed_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDIMM GF_Box\n**********************************************************/\n\nvoid dimm_box_del(GF_Box *s)\n{\n\tgf_free((GF_DIMMBox *)s);\n}\nGF_Err dimm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dimm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMMBox, GF_ISOM_BOX_TYPE_DIMM);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dimm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dimm_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDREP GF_Box\n**********************************************************/\n\nvoid drep_box_del(GF_Box *s)\n{\n\tgf_free((GF_DREPBox *)s);\n}\nGF_Err drep_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *drep_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DREPBox, GF_ISOM_BOX_TYPE_DREP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err drep_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err drep_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n/**********************************************************\n\t\tTMIN GF_Box\n**********************************************************/\n\nvoid tmin_box_del(GF_Box *s)\n{\n\tgf_free((GF_TMINBox *)s);\n}\nGF_Err tmin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->minTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMINBox, GF_ISOM_BOX_TYPE_TMIN);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->minTime);\n\treturn GF_OK;\n}\nGF_Err tmin_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTMAX GF_Box\n**********************************************************/\n\nvoid tmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_TMAXBox *)s);\n}\nGF_Err tmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMAXBox, GF_ISOM_BOX_TYPE_TMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxTime);\n\treturn GF_OK;\n}\nGF_Err tmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPMAX GF_Box\n**********************************************************/\n\nvoid pmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_PMAXBox *)s);\n}\nGF_Err pmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxSize = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *pmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PMAXBox, GF_ISOM_BOX_TYPE_PMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err pmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxSize);\n\treturn GF_OK;\n}\nGF_Err pmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMAX GF_Box\n**********************************************************/\n\nvoid dmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_DMAXBox *)s);\n}\nGF_Err dmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxDur = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *dmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMAXBox, GF_ISOM_BOX_TYPE_DMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxDur);\n\treturn GF_OK;\n}\nGF_Err dmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid payt_box_del(GF_Box *s)\n{\n\tGF_PAYTBox *payt = (GF_PAYTBox *)s;\n\tif (payt->payloadString) gf_free(payt->payloadString);\n\tgf_free(payt);\n}\nGF_Err payt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5 );\n\tptr->payloadCode = gf_bs_read_u32(bs);\n\tlength = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, length);\n\tptr->payloadString = (char*)gf_malloc(sizeof(char) * (length+1) );\n\tif (! ptr->payloadString) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->payloadString, length);\n\tptr->payloadString[length] = 0;\n\n\treturn GF_OK;\n}\nGF_Box *payt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PAYTBox, GF_ISOM_BOX_TYPE_PAYT);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err payt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_Err e;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->payloadCode);\n    len = ptr->payloadString ? (u32) strlen(ptr->payloadString) : 0;\n\tgf_bs_write_u8(bs, len);\n\tif (len) gf_bs_write_data(bs, ptr->payloadString, len);\n\treturn GF_OK;\n}\nGF_Err payt_box_size(GF_Box *s)\n{\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\ts->size += 4 + 1;\n\tif (ptr->payloadString) ptr->size += strlen(ptr->payloadString);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid name_box_del(GF_Box *s)\n{\n\tGF_NameBox *name = (GF_NameBox *)s;\n\tif (name->string) gf_free(name->string);\n\tgf_free(name);\n}\nGF_Err name_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in name box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->string = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (! ptr->string) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->string, length);\n\tptr->string[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *name_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NameBox, GF_ISOM_BOX_TYPE_NAME);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err name_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->string) {\n\t\tgf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string) + 1);\n\t}\n\treturn GF_OK;\n}\nGF_Err name_box_size(GF_Box *s)\n{\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr->string) ptr->size += strlen(ptr->string) + 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tssy_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err tssy_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tgf_bs_read_int(bs, 6);\n\tptr->timestamp_sync = gf_bs_read_int(bs, 2);\n\treturn GF_OK;\n}\nGF_Box *tssy_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeStampSynchronyBox, GF_ISOM_BOX_TYPE_TSSY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tssy_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 6);\n\tgf_bs_write_int(bs, ptr->timestamp_sync, 2);\n\treturn GF_OK;\n}\nGF_Err tssy_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid srpp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err srpp_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_SCHI:\n\t\tBOX_FIELD_ASSIGN(info, GF_SchemeInformationBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SCHM:\n\t\tBOX_FIELD_ASSIGN(scheme_type, GF_SchemeTypeBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err srpp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 16)\n\tptr->encryption_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->encryption_algorithm_rtcp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtcp = gf_bs_read_u32(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\nGF_Box *srpp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SRTPProcessBox, GF_ISOM_BOX_TYPE_SRPP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err srpp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtcp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtcp);\n\n\treturn GF_OK;\n}\nGF_Err srpp_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\ts->size += 16;\n\tgf_isom_check_position(s, (GF_Box*)ptr->info, &pos);\n\tgf_isom_check_position(s, (GF_Box*)ptr->scheme_type, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid rssr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err rssr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->ssrc = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *rssr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ReceivedSsrcBox, GF_ISOM_BOX_TYPE_RSSR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rssr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->ssrc);\n\treturn GF_OK;\n}\nGF_Err rssr_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid iods_box_del(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->descriptor) gf_odf_desc_del(ptr->descriptor);\n\tgf_free(ptr);\n}\n\n\nGF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tchar *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\t//use the OD codec...\n\tdescSize = (u32) (ptr->size);\n\tdesc = (char*)gf_malloc(sizeof(char) * descSize);\n\tif (!desc) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, desc, descSize);\n\te = gf_odf_desc_read(desc, descSize, &ptr->descriptor);\n\t//OK, free our desc\n\tgf_free(desc);\n\n\tif (e) return e;\n\tswitch (ptr->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid descriptor in iods, tag %u found but only %u or %u allowed\\n\", ptr->descriptor->tag, GF_ODF_ISOM_IOD_TAG, GF_ODF_ISOM_OD_TAG ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *iods_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ObjectDescriptorBox, GF_ISOM_BOX_TYPE_IODS);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err iods_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tu8 *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//call our OD codec\n\te = gf_odf_desc_write(ptr->descriptor, &desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, desc, descSize);\n\t//and free our stuff maybe!!\n\tgf_free(desc);\n\treturn GF_OK;\n}\n\nGF_Err iods_box_size(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\tptr->size += gf_odf_desc_size(ptr->descriptor);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdat_box_del(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (!s) return;\n\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdat_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_IMDA) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_MDAT;\n\t\tptr->is_imda = 1;\n\t\tISOM_DECREASE_SIZE(s, 4)\n\t\tptr->imda_id = gf_bs_read_u32(bs);\n\t}\n\n\tptr->dataSize = s->size;\n\tptr->bsOffset = gf_bs_get_position(bs);\n\n\t//store idat for rewrite\n\tif (ptr->type==GF_ISOM_BOX_TYPE_IDAT) {\n\t\tptr->data = gf_malloc(sizeof(u8) * (size_t)ptr->dataSize);\n\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->data, (u32) ptr->dataSize);\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\t//then skip these bytes\n\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Box *mdat_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaDataBox, GF_ISOM_BOX_TYPE_MDAT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdat_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (ptr->is_imda) {\n\t\ts->type = GF_ISOM_BOX_TYPE_IMDA;\n\t\te = gf_isom_box_write_header(s, bs);\n\t\ts->type = GF_ISOM_BOX_TYPE_MDAT;\n\t\tif (e) return e;\n\t\tgf_bs_write_u32(bs, ptr->imda_id);\n\t} else {\n\t\te = gf_isom_box_write_header(s, bs);\n\t\tif (e) return e;\n\t}\n\n\t//make sure we have some data ...\n\t//if not, we handle that independently (edit files)\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, (u32) ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mdat_box_size(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tptr->size += ptr->dataSize;\n\tif (ptr->is_imda)\n\t\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdhd_box_del(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mdhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 28)\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Media header timescale is 0 - defaulting to 90000\\n\" ));\n\t\tptr->timeScale = 90000;\n\t}\n\n\tptr->original_duration = ptr->duration;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\t//our padding bit\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguage[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[2] = gf_bs_read_int(bs, 5);\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguage[0] || ptr->packedLanguage[1] || ptr->packedLanguage[2]) {\n\t\tptr->packedLanguage[0] += 0x60;\n\t\tptr->packedLanguage[1] += 0x60;\n\t\tptr->packedLanguage[2] += 0x60;\n\t} else {\n\t\tptr->packedLanguage[0] = 'u';\n\t\tptr->packedLanguage[1] = 'n';\n\t\tptr->packedLanguage[2] = 'd';\n\t}\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mdhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaHeaderBox, GF_ISOM_BOX_TYPE_MDHD);\n\n\ttmp->packedLanguage[0] = 'u';\n\ttmp->packedLanguage[1] = 'n';\n\ttmp->packedLanguage[2] = 'd';\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\t//SPECS: BIT(1) of padding\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_int(bs, ptr->packedLanguage[0] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[1] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[2] - 0x60, 5);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err mdhd_box_size(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += 4;\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mdia_box_del(GF_Box *s)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->nalu_parser) gf_bs_del(ptr->nalu_parser);\n\tif (ptr->nalu_out_bs) gf_bs_del(ptr->nalu_out_bs);\n\tif (ptr->nalu_ps_bs) gf_bs_del(ptr->nalu_ps_bs);\n\tif (ptr->extracted_bs) gf_bs_del(ptr->extracted_bs);\n\tif (ptr->extracted_samp) gf_isom_sample_del(&ptr->extracted_samp);\n\tif (ptr->in_sample_buffer) gf_free(ptr->in_sample_buffer);\n\tif (ptr->tmp_nal_copy_buffer) gf_free(ptr->tmp_nal_copy_buffer);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdia_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_MDHD:\n\t\tBOX_FIELD_ASSIGN(mediaHeader, GF_MediaHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_HDLR:\n\t\tBOX_FIELD_ASSIGN(handler, GF_HandlerBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MINF:\n\t\tBOX_FIELD_ASSIGN(information, GF_MediaInformationBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err mdia_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 cookie = gf_bs_get_cookie(bs);\n\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\te = gf_isom_box_array_read(s, bs);\n\tgf_bs_set_cookie(bs, cookie);\n\n\tif (e) return e;\n\tif (!((GF_MediaBox *)s)->information) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->handler) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing HandlerBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->mediaHeader) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mdia_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_MDIA);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdia_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mdia_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box*)ptr->mediaHeader, &pos);\n\t//then handler\n\tgf_isom_check_position(s, (GF_Box*)ptr->handler, &pos);\n\n#if 0\n\t//elng before info for CMAF info - we deactiveate for now, no specific errors raised and CMAF should not impose any order\n\tGF_Box *elng = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ELNG);\n\tif (elng)\n\t\tgf_isom_check_position(s, elng, &pos);\n#endif\n\n\t//then info\n\tgf_isom_check_position(s, (GF_Box*)ptr->information, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mfra_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->tfra_list);\n\tgf_free(ptr);\n}\n\nGF_Box *mfra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_MFRA);\n\ttmp->tfra_list = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfra_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFRA:\n\t\tBOX_FIELD_LIST_ASSIGN(tfra_list);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MFRO:\n\t\tBOX_FIELD_ASSIGN(mfro, GF_MovieFragmentRandomAccessOffsetBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mfra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mfra_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tgf_isom_check_position_list(s, ptr->tfra_list, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->mfro, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tfra_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Box *tfra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_TFRA);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err tfra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_RandomAccessEntry *p = 0;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\n\tptr->track_id = gf_bs_read_u32(bs);\n\tif (gf_bs_read_int(bs, 26) != 0)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->traf_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\tptr->trun_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\tptr->sample_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->version == 1) {\n\t\tif (ptr->nb_entries > ptr->size / (16+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (ptr->nb_entries > ptr->size / (8+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\tif (ptr->nb_entries) {\n\t\tif ((u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_RandomAccessEntry)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tp = (GF_RandomAccessEntry *) gf_malloc(sizeof(GF_RandomAccessEntry) * ptr->nb_entries);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t}\n\n\tptr->entries = p;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tmemset(p, 0, sizeof(GF_RandomAccessEntry));\n\n\t\tif (ptr->version == 1) {\n\t\t\tp->time = gf_bs_read_u64(bs);\n\t\t\tp->moof_offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tp->time = gf_bs_read_u32(bs);\n\t\t\tp->moof_offset = gf_bs_read_u32(bs);\n\t\t}\n\t\tp->traf_number = gf_bs_read_int(bs, ptr->traf_bits);\n\t\tp->trun_number = gf_bs_read_int(bs, ptr->trun_bits);\n\t\tp->sample_number = gf_bs_read_int(bs, ptr->sample_bits);\n\n\t\t++p;\n\t}\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, sap_nb_entries;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->track_id);\n\tgf_bs_write_int(bs, 0, 26);\n\n\tgf_bs_write_int(bs, ptr->traf_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->trun_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->sample_bits/8 - 1, 2);\n\n\tsap_nb_entries = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (p->trun_number) sap_nb_entries++;\n\t}\n\n\tgf_bs_write_u32(bs, sap_nb_entries);\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (!p->trun_number) continue;\n\t\tif (ptr->version==1) {\n\t\t\tgf_bs_write_u64(bs, p->time);\n\t\t\tgf_bs_write_u64(bs, p->moof_offset);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->time);\n\t\t\tgf_bs_write_u32(bs, (u32) p->moof_offset);\n\t\t}\n\t\tgf_bs_write_int(bs, p->traf_number, ptr->traf_bits);\n\t\tgf_bs_write_int(bs, p->trun_number, ptr->trun_bits);\n\t\tgf_bs_write_int(bs, p->sample_number, ptr->sample_bits);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfra_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\tptr->size += 12;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (!p->trun_number) continue;\n\t\tptr->size +=  ((ptr->version==1) ? 16 : 8 ) + ptr->traf_bits/8 + ptr->trun_bits/8 + ptr->sample_bits/8;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid mfro_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Box *mfro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessOffsetBox, GF_ISOM_BOX_TYPE_MFRO);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->container_size = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->container_size);\n\treturn GF_OK;\n}\n\nGF_Err mfro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid elng_box_del(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->extended_language) gf_free(ptr->extended_language);\n\tgf_free(ptr);\n}\n\nGF_Err elng_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->size) {\n\t\tptr->extended_language = (char*)gf_malloc((u32) ptr->size);\n\t\tif (ptr->extended_language == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->extended_language, (u32) ptr->size);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (ptr->extended_language[ptr->size-1]) {\n\t\t\tchar *str = (char*)gf_malloc((u32) ptr->size + 1);\n\t\t\tif (!str) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(str, ptr->extended_language, (u32) ptr->size);\n\t\t\tstr[ptr->size] = 0;\n\t\t\tgf_free(ptr->extended_language);\n\t\t\tptr->extended_language = str;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elng_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_ELNG);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elng_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->extended_language) {\n\t\tgf_bs_write_data(bs, ptr->extended_language, (u32)(strlen(ptr->extended_language)+1));\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elng_box_size(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->extended_language) {\n\t\tptr->size += strlen(ptr->extended_language)+1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mfhd_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mfhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->sequence_number = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mfhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentHeaderBox, GF_ISOM_BOX_TYPE_MFHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mfhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->sequence_number);\n\treturn GF_OK;\n}\n\nGF_Err mfhd_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid minf_box_del(GF_Box *s)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\t//if we have a Handler not self-contained, delete it (the self-contained belongs to the movie)\n\tif (ptr->dataHandler) {\n\t\tgf_isom_datamap_close(ptr);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err minf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_NMHD:\n\tcase GF_ISOM_BOX_TYPE_STHD:\n\tcase GF_ISOM_BOX_TYPE_VMHD:\n\tcase GF_ISOM_BOX_TYPE_SMHD:\n\tcase GF_ISOM_BOX_TYPE_HMHD:\n\tcase GF_ISOM_BOX_TYPE_GMHD:\n\t\tBOX_FIELD_ASSIGN(InfoHeader, GF_Box)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_DINF:\n\t\tBOX_FIELD_ASSIGN(dataInformation, GF_DataInformationBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_STBL:\n\t\tBOX_FIELD_ASSIGN(sampleTable, GF_SampleTableBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err minf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tGF_Err e;\n\n\te = gf_isom_box_array_read(s, bs);\n\n\tif (!e && ! ptr->dataInformation) {\n\t\tGF_Box *url;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing DataInformationBox\\n\"));\n\t\t//commented on purpose, we are still able to handle the file, we only throw an error but keep processing\n//\t\te = GF_ISOM_INVALID_FILE;\n\n\t\t//add a dinf box to avoid any access to a null dinf\n\t\tptr->dataInformation = (GF_DataInformationBox *) gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DINF);\n\t\tif (!ptr->dataInformation) return GF_OUT_OF_MEM;\n\n\t\tptr->dataInformation->dref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&ptr->dataInformation->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t\tif (!ptr->dataInformation->dref) return GF_OUT_OF_MEM;\n\n\t\turl = gf_isom_box_new_parent(&ptr->dataInformation->dref->child_boxes, GF_ISOM_BOX_TYPE_URL);\n\t\tif (!url) return GF_OUT_OF_MEM;\n\t\t((GF_FullBox*)url)->flags = 1;\n\t}\n\treturn e;\n}\n\nGF_Box *minf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaInformationBox, GF_ISOM_BOX_TYPE_MINF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err minf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err minf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box *)ptr->InfoHeader, &pos);\n\t//then dataInfo\n\tgf_isom_check_position(s, (GF_Box *)ptr->dataInformation, &pos);\n\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_MVCI), &pos);\n\t//then sampleTable\n\tgf_isom_check_position(s, (GF_Box *)ptr->sampleTable, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid moof_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tif (ptr == NULL) return;\n\n\tgf_list_del(ptr->TrackList);\n\tif (ptr->PSSHs) gf_list_del(ptr->PSSHs);\n\tif (ptr->mdat) gf_free(ptr->mdat);\n\t//happens if error while fragmenting, the emsg boxes are not part of the moof hierarchy !\n\tif (ptr->emsgs) {\n\t\twhile (1) {\n\t\t\tGF_Box *emsg = gf_list_pop_front(ptr->emsgs);\n\t\t\tif (!emsg) break;\n\t\t\tgf_isom_box_del(emsg);\n\t\t}\n\t\tgf_list_del(ptr->emsgs);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err moof_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MFHD:\n\t\tBOX_FIELD_ASSIGN(mfhd, GF_MovieFragmentHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRAF:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\tBOX_FIELD_LIST_ASSIGN(PSSHs)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err moof_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *moof_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentBox, GF_ISOM_BOX_TYPE_MOOF);\n\ttmp->TrackList = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err moof_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err moof_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\t//Header First\n\tgf_isom_check_position(s, (GF_Box *)ptr->mfhd, &pos);\n\t//then PSSH\n\tgf_isom_check_position_list(s, ptr->PSSHs, &pos);\n\t//then the track list\n\tgf_isom_check_position_list(s, ptr->TrackList, &pos);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\nvoid moov_box_del(GF_Box *s)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->trackList);\n\tgf_free(ptr);\n}\n\nGF_Err moov_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_IODS:\n\t\tBOX_FIELD_ASSIGN(iods, GF_ObjectDescriptorBox)\n\t\t//if no IOD, delete the box\n\t\tif (ptr->iods && !ptr->iods->descriptor) {\n\t\t\tptr->iods = NULL;\n\t\t\tgf_isom_box_del_parent(&s->child_boxes, a);\n\t\t}\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MVHD:\n\t\tBOX_FIELD_ASSIGN(mvhd, GF_MovieHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tBOX_FIELD_ASSIGN(udta, GF_UserDataBox)\n\t\treturn GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tcase GF_ISOM_BOX_TYPE_MVEX:\n\t\tBOX_FIELD_ASSIGN(mvex, GF_MovieExtendsBox)\n\t\tif (ptr->mvex)\n\t\t\tptr->mvex->mov = ptr->mov;\n\t\treturn GF_OK;\n#endif\n\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tBOX_FIELD_ASSIGN(meta, GF_MetaBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_TRAK:\n\t\tif (is_rem) {\n\t\t\tgf_list_del_item(ptr->trackList, a);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t{\n\t\t\tGF_TrackBox *tk = (GF_TrackBox *)a;\n\t\t\t//set our pointer to this obj\n\t\t\ttk->moov = ptr;\n\t\t\ttk->index = gf_list_count(ptr->trackList);\n\t\t\tif (tk->References) {\n\t\t\t\tGF_TrackReferenceTypeBox *dpnd=NULL;\n\t\t\t\tTrack_FindRef(tk, GF_ISOM_REF_BASE, &dpnd);\n\t\t\t\tif (dpnd)\n\t\t\t\t\ttk->nb_base_refs = dpnd->trackIDCount;\n\t\t\t}\n\t\t}\n\t\treturn gf_list_add(ptr->trackList, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err moov_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *moov_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieBox, GF_ISOM_BOX_TYPE_MOOV);\n\ttmp->trackList = gf_list_new();\n\tif (!tmp->trackList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err moov_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err moov_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *) ptr->mvhd, &pos);\n\tgf_isom_check_position(s, (GF_Box *) ptr->iods, &pos);\n\tgf_isom_check_position(s, (GF_Box *) ptr->meta, &pos);\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex && !ptr->mvex_after_traks) {\n\t\tgf_isom_check_position(s, (GF_Box *) ptr->mvex, &pos);\n\t}\n#endif\n\tgf_isom_check_position_list(s, ptr->trackList, &pos);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex && ptr->mvex_after_traks) {\n\t\tgf_isom_check_position(s, (GF_Box *) ptr->mvex, &pos);\n\t}\n#endif\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid audio_sample_entry_box_del(GF_Box *s)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err audio_sample_entry_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_UnknownBox *wave = NULL;\n\tBool drop_wave=GF_FALSE;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_DAMR:\n\tcase GF_ISOM_BOX_TYPE_DEVC:\n\tcase GF_ISOM_BOX_TYPE_DQCP:\n\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\tBOX_FIELD_ASSIGN(cfg_3gpp, GF_3GPPConfigBox)\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_DOPS:\n\t\tBOX_FIELD_ASSIGN(cfg_opus, GF_OpusSpecificBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAC3:\n\t\tBOX_FIELD_ASSIGN(cfg_ac3, GF_AC3ConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DEC3:\n\t\tBOX_FIELD_ASSIGN(cfg_ac3, GF_AC3ConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DMLP:\n\t\tBOX_FIELD_ASSIGN(cfg_mlp, GF_TrueHDConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MHAC:\n\t\tBOX_FIELD_ASSIGN(cfg_mha, GF_MHAConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DFLA:\n\t\tBOX_FIELD_ASSIGN(cfg_flac, GF_FLACConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\twave = (GF_UnknownBox *)a;\n\t\t/*HACK for QT files: get the esds box from the track*/\n\t\tif (s->type == GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\tif (is_rem) {\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\t//wave subboxes may have been properly parsed\n \t\t\tif ((wave->original_4cc == GF_QT_BOX_TYPE_WAVE) && gf_list_count(wave->child_boxes)) {\n \t\t\t\tu32 i;\n                for (i =0; i<gf_list_count(wave->child_boxes); i++) {\n                    GF_Box *inner_box = (GF_Box *)gf_list_get(wave->child_boxes, i);\n                    if (inner_box->type == GF_ISOM_BOX_TYPE_ESDS) {\n                        ptr->esd = (GF_ESDBox *)inner_box;\n \t\t\t\t\t\tif (ptr->qtff_mode & GF_ISOM_AUDIO_QTFF_CONVERT_FLAG) {\n                        \tgf_list_rem(a->child_boxes, i);\n                        \tdrop_wave=GF_TRUE;\n                        \tptr->compression_id = 0;\n                        \tgf_list_add(ptr->child_boxes, inner_box);\n\t\t\t\t\t\t}\n                    }\n                }\n\t\t\t\tif (drop_wave) {\n\t\t\t\t\tgf_isom_box_del_parent(&ptr->child_boxes, a);\n                \tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\t\t\t\tptr->version = 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n                ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n                return GF_OK;\n            }\n            gf_isom_box_del_parent(&ptr->child_boxes, a);\n            return GF_ISOM_INVALID_MEDIA;\n\n\t\t}\n \t\tptr->qtff_mode &= ~GF_ISOM_AUDIO_QTFF_CONVERT_FLAG;\n\n \t\tif ((wave->original_4cc == GF_QT_BOX_TYPE_WAVE) && gf_list_count(wave->child_boxes)) {\n\t\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\t\t}\n\t\treturn GF_OK;\n\tcase GF_QT_BOX_TYPE_WAVE:\n\t{\n\t\tu32 subtype = 0;\n\t\tGF_Box **cfg_ptr = NULL;\n\t\tif (s->type == GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->esd;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_ESDS;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_AC3) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_ac3;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DAC3;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_EC3) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_ac3;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DEC3;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_OPUS) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_opus;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DOPS;\n\t\t}\n\t\telse if ((s->type == GF_ISOM_BOX_TYPE_MHA1)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHA2)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHM1)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHM2)\n\t\t) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_mha;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_MHAC;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_mlp;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DMLP;\n\t\t}\n\n\t\tif (cfg_ptr) {\n\t\t\tif (is_rem) {\n\t\t\t\t*cfg_ptr = NULL;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (*cfg_ptr) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\t//wave subboxes may have been properly parsed\n \t\t\tif (gf_list_count(a->child_boxes)) {\n \t\t\t\tu32 i;\n                for (i =0; i<gf_list_count(a->child_boxes); i++) {\n                    GF_Box *inner_box = (GF_Box *)gf_list_get(a->child_boxes, i);\n                    if (inner_box->type == subtype) {\n                        *cfg_ptr = inner_box;\n \t\t\t\t\t\tif (ptr->qtff_mode & GF_ISOM_AUDIO_QTFF_CONVERT_FLAG) {\n                        \tgf_list_rem(a->child_boxes, i);\n                        \tdrop_wave=GF_TRUE;\n                        \tgf_list_add(ptr->child_boxes, inner_box);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n                    }\n                }\n\t\t\t\tif (drop_wave) {\n\t\t\t\t\tgf_isom_box_del_parent(&ptr->child_boxes, a);\n                \tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\t\t\t\tptr->compression_id = 0;\n\t\t\t\t\tptr->version = 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n                ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n                return GF_OK;\n            }\n\t\t}\n\t}\n \t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\nGF_Err audio_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_QT_CONV) {\n \t\tptr->qtff_mode |= GF_ISOM_AUDIO_QTFF_CONVERT_FLAG;\n \t}\n\n\te = gf_isom_box_array_read(s, bs);\n\tif (!e) {\n\t\tif (s->type==GF_ISOM_BOX_TYPE_ENCA) {\n\t\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\tif (sinf && sinf->original_format) {\n\t\t\t\tu32 type = sinf->original_format->data_format;\n\t\t\t\tswitch (type) {\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\t\tif (ptr->cfg_3gpp) ptr->cfg_3gpp->cfg.type = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tif (!data) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\tgf_bs_set_cookie(mybs, GF_ISOM_BS_COOKIE_NO_LOGS);\n\t\t\tif (ptr->esd) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *)ptr->esd);\n\t\t\tptr->esd = NULL;\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\t\t\tgf_bs_del(mybs);\n\n\t\t\tif ((e==GF_OK) && ptr->esd && (ptr->esd->type == GF_ISOM_BOX_TYPE_ESDS)) {\n\t\t\t\tif (!ptr->child_boxes) ptr->child_boxes = gf_list_new();\n\t\t\t\tgf_list_add(ptr->child_boxes, ptr->esd);\n\t\t\t} else if (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd = NULL;\n\t\t\t}\n\t\t\te = GF_OK;\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}\n\nGF_Box *audio_sample_entry_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_MP4A);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *enca_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_ENCA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err audio_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox*)s, bs);\n\treturn GF_OK;\n}\n\nGF_Err audio_sample_entry_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox*)s);\n\tif (ptr->qtff_mode)\n\t\treturn GF_OK;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_mha, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_opus, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_ac3, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_flac, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_mlp, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gen_sample_entry_box_del(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(ptr);\n}\n\n\nGF_Err gen_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)s, bs);\n\tif (e) return e;\n\tISOM_DECREASE_SIZE(s, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *gen_sample_entry_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleEntryBox, GF_QT_SUBTYPE_C608);//type will be overriten\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gen_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err gen_sample_entry_box_size(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mp4s_box_del(GF_Box *s)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err mp4s_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mp4s_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *encs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mp4s_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n    return GF_OK;\n}\n\nGF_Err mp4s_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n    return GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid video_sample_entry_box_del(GF_Box *s)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\t/*for publishing*/\n\tif (ptr->emul_esd) gf_odf_desc_del((GF_Descriptor *)ptr->emul_esd);\n\tgf_free(ptr);\n}\n\nGF_Err video_sample_entry_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RINF:\n\t\tBOX_FIELD_ASSIGN(rinf, GF_RestrictedSchemeInfoBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVCC:\n\t\tBOX_FIELD_ASSIGN(avc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVCC:\n\t\tBOX_FIELD_ASSIGN(hevc_config, GF_HEVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VVCC:\n\t\tBOX_FIELD_ASSIGN(vvc_config, GF_VVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVCC:\n\t\tBOX_FIELD_ASSIGN(svc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MVCC:\n\t\tBOX_FIELD_ASSIGN(mvc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHVC:\n\t\tBOX_FIELD_ASSIGN(lhvc_config, GF_HEVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV1C:\n\t\tBOX_FIELD_ASSIGN(av1_config, GF_AV1ConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VPCC:\n\t\tBOX_FIELD_ASSIGN(vp_config, GF_VPConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DVCC:\n\tcase GF_ISOM_BOX_TYPE_DVVC:\n\t\tBOX_FIELD_ASSIGN(dovi_config, GF_DOVIConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (! memcmp(((GF_UnknownUUIDBox*)a)->uuid, GF_ISOM_IPOD_EXT, 16)) {\n\t\t\tBOX_FIELD_ASSIGN(ipod_ext, GF_UnknownUUIDBox)\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_D263:\n\t\tBOX_FIELD_ASSIGN(cfg_3gpp, GF_3GPPConfigBox)\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tif (ptr->cfg_3gpp)\n\t\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_JP2H:\n\t\tBOX_FIELD_ASSIGN(jp2h, GF_J2KHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_PASP:\n\tcase GF_ISOM_BOX_TYPE_CLAP:\n\tcase GF_ISOM_BOX_TYPE_COLR:\n\tcase GF_ISOM_BOX_TYPE_MDCV:\n\tcase GF_ISOM_BOX_TYPE_CLLI:\n\tcase GF_ISOM_BOX_TYPE_CCST:\n\tcase GF_ISOM_BOX_TYPE_AUXI:\n\tcase GF_ISOM_BOX_TYPE_RVCC:\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tif (!is_rem && !gf_isom_box_check_unique(s->child_boxes, a)) {\n\t\t\tERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err video_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGVisualSampleEntryBox *mp4v = (GF_MPEGVisualSampleEntryBox*)s;\n\tGF_Err e;\n\te = gf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *)s, bs);\n\tif (e) return e;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\t/*this is an AVC sample desc*/\n\tif (mp4v->avc_config || mp4v->svc_config || mp4v->mvc_config)\n\t\tAVC_RewriteESDescriptor(mp4v);\n\t/*this is an HEVC sample desc*/\n\tif (mp4v->hevc_config || mp4v->lhvc_config || (mp4v->type==GF_ISOM_BOX_TYPE_HVT1))\n\t\tHEVC_RewriteESDescriptor(mp4v);\n\t/*this is an AV1 sample desc*/\n\tif (mp4v->av1_config)\n\t\tAV1_RewriteESDescriptor(mp4v);\n\t/*this is a VP8-9 sample desc*/\n\tif (mp4v->vp_config)\n\t\tVP9_RewriteESDescriptor(mp4v);\n\n\tif (s->type==GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\tif (sinf && sinf->original_format) {\n\t\t\tu32 type = sinf->original_format->data_format;\n\t\t\tswitch (type) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tif (mp4v->cfg_3gpp) mp4v->cfg_3gpp->cfg.type = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *video_sample_entry_box_new()\n{\n\tGF_MPEGVisualSampleEntryBox *tmp;\n\tGF_SAFEALLOC(tmp, GF_MPEGVisualSampleEntryBox);\n\tif (tmp == NULL) return NULL;\n\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox *)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err video_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)s, bs);\n\treturn GF_OK;\n}\n\nGF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\n\t/*make sure we write the config box first, we don't care about the rest*/\n\n\t/*mp4v*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\t/*avc / SVC + MVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\n\t/*HEVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t/*VVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\n\t/*AV1*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t/*VPx*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\n\t/*JP2H*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\n\t/*DolbyVision*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mvex_box_del(GF_Box *s)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->TrackExList);\n\tgf_list_del(ptr->TrackExPropList);\n\tgf_free(ptr);\n}\n\n\nGF_Err mvex_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TREX:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackExList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TREP:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackExPropList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MEHD:\n\t\tBOX_FIELD_ASSIGN(mehd, GF_MovieExtendsHeaderBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\n\nGF_Err mvex_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mvex_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsBox, GF_ISOM_BOX_TYPE_MVEX);\n\ttmp->TrackExList = gf_list_new();\n\tif (!tmp->TrackExList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\ttmp->TrackExPropList = gf_list_new();\n\tif (!tmp->TrackExPropList) {\n\t\tgf_list_del(tmp->TrackExList);\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mvex_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mvex_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *) s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->mehd, &pos);\n\tgf_isom_check_position_list(s, ptr->TrackExList, &pos);\n\tgf_isom_check_position_list(s, ptr->TrackExPropList, &pos);\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *mehd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsHeaderBox, GF_ISOM_BOX_TYPE_MEHD);\n\treturn (GF_Box *)tmp;\n}\nvoid mehd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err mehd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->fragment_duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->fragment_duration = (u64) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err mehd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->fragment_duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->fragment_duration);\n\t}\n\treturn GF_OK;\n}\nGF_Err mehd_box_size(GF_Box *s)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tptr->version = (ptr->fragment_duration>0xFFFFFFFF) ? 1 : 0;\n\ts->size += (ptr->version == 1) ? 8 : 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid mvhd_box_del(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err mvhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 28);\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie header timescale is invalid (0) - defaulting to 600\\n\" ));\n\t\tptr->timeScale = 600;\n\t}\n\tISOM_DECREASE_SIZE(ptr, 80);\n\tptr->preferredRate = gf_bs_read_u32(bs);\n\tptr->preferredVolume = gf_bs_read_u16(bs);\n\tgf_bs_read_data(bs, ptr->reserved, 10);\n\tptr->matrixA = gf_bs_read_u32(bs);\n\tptr->matrixB = gf_bs_read_u32(bs);\n\tptr->matrixU = gf_bs_read_u32(bs);\n\tptr->matrixC = gf_bs_read_u32(bs);\n\tptr->matrixD = gf_bs_read_u32(bs);\n\tptr->matrixV = gf_bs_read_u32(bs);\n\tptr->matrixX = gf_bs_read_u32(bs);\n\tptr->matrixY = gf_bs_read_u32(bs);\n\tptr->matrixW = gf_bs_read_u32(bs);\n\tptr->previewTime = gf_bs_read_u32(bs);\n\tptr->previewDuration = gf_bs_read_u32(bs);\n\tptr->posterTime = gf_bs_read_u32(bs);\n\tptr->selectionTime = gf_bs_read_u32(bs);\n\tptr->selectionDuration = gf_bs_read_u32(bs);\n\tptr->currentTime = gf_bs_read_u32(bs);\n\tptr->nextTrackID = gf_bs_read_u32(bs);\n\tptr->original_duration = ptr->duration;\n\treturn GF_OK;\n}\n\nGF_Box *mvhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieHeaderBox, GF_ISOM_BOX_TYPE_MVHD);\n\n\ttmp->preferredRate = (1<<16);\n\ttmp->preferredVolume = (1<<8);\n\n\ttmp->matrixA = (1<<16);\n\ttmp->matrixD = (1<<16);\n\ttmp->matrixW = (1<<30);\n\n\ttmp->nextTrackID = 1;\n\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mvhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->preferredRate);\n\tgf_bs_write_u16(bs, ptr->preferredVolume);\n\tgf_bs_write_data(bs, ptr->reserved, 10);\n\tgf_bs_write_u32(bs, ptr->matrixA);\n\tgf_bs_write_u32(bs, ptr->matrixB);\n\tgf_bs_write_u32(bs, ptr->matrixU);\n\tgf_bs_write_u32(bs, ptr->matrixC);\n\tgf_bs_write_u32(bs, ptr->matrixD);\n\tgf_bs_write_u32(bs, ptr->matrixV);\n\tgf_bs_write_u32(bs, ptr->matrixX);\n\tgf_bs_write_u32(bs, ptr->matrixY);\n\tgf_bs_write_u32(bs, ptr->matrixW);\n\tgf_bs_write_u32(bs, ptr->previewTime);\n\tgf_bs_write_u32(bs, ptr->previewDuration);\n\tgf_bs_write_u32(bs, ptr->posterTime);\n\tgf_bs_write_u32(bs, ptr->selectionTime);\n\tgf_bs_write_u32(bs, ptr->selectionDuration);\n\tgf_bs_write_u32(bs, ptr->currentTime);\n\tgf_bs_write_u32(bs, ptr->nextTrackID);\n\treturn GF_OK;\n}\n\nGF_Err mvhd_box_size(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\tptr->size += 80;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid nmhd_box_del(GF_Box *s)\n{\n\tGF_MPEGMediaHeaderBox *ptr = (GF_MPEGMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\n\nGF_Err nmhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\nGF_Box *nmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGMediaHeaderBox, GF_ISOM_BOX_TYPE_NMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err nmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err nmhd_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid padb_box_del(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->padbits) gf_free(ptr->padbits);\n\tgf_free(ptr);\n}\n\n\nGF_Err padb_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->SampleCount = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->SampleCount/2) //half byte per sample\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->padbits = (u8 *)gf_malloc(sizeof(u8)*ptr->SampleCount);\n\tif (!ptr->padbits) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_read_int(bs, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tptr->padbits[i+1] = gf_bs_read_int(bs, 3);\n\t\t} else {\n\t\t\tgf_bs_read_int(bs, 3);\n\t\t}\n\t\tgf_bs_read_int(bs, 1);\n\t\tptr->padbits[i] = gf_bs_read_int(bs, 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *padb_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PaddingBitsBox, GF_ISOM_BOX_TYPE_PADB);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err padb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->SampleCount, 32);\n\n\tfor (i=0 ; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tgf_bs_write_int(bs, ptr->padbits[i+1], 3);\n\t\t} else {\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t}\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tgf_bs_write_int(bs, ptr->padbits[i], 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err padb_box_size(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\tptr->size += 4;\n\tif (ptr->SampleCount) ptr->size += (ptr->SampleCount + 1) / 2;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rely_box_del(GF_Box *s)\n{\n\tGF_RelyHintBox *rely = (GF_RelyHintBox *)s;\n\tgf_free(rely);\n}\n\nGF_Err rely_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1);\n\tptr->reserved = gf_bs_read_int(bs, 6);\n\tptr->preferred = gf_bs_read_int(bs, 1);\n\tptr->required = gf_bs_read_int(bs, 1);\n\treturn GF_OK;\n}\n\nGF_Box *rely_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RelyHintBox, GF_ISOM_BOX_TYPE_RELY);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rely_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->reserved, 6);\n\tgf_bs_write_int(bs, ptr->preferred, 1);\n\tgf_bs_write_int(bs, ptr->required, 1);\n\treturn GF_OK;\n}\n\nGF_Err rely_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rtpo_box_del(GF_Box *s)\n{\n\tGF_RTPOBox *rtpo = (GF_RTPOBox *)s;\n\tgf_free(rtpo);\n}\n\nGF_Err rtpo_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->timeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *rtpo_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPOBox, GF_ISOM_BOX_TYPE_RTPO);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtpo_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//here we have no pb, just remembed that some entries will have to\n\t//be 4-bytes aligned ...\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeOffset);\n\treturn GF_OK;\n}\n\nGF_Err rtpo_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid smhd_box_del(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tif (ptr == NULL ) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err smhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->balance = gf_bs_read_u16(bs);\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *smhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SoundMediaHeaderBox, GF_ISOM_BOX_TYPE_SMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err smhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->balance);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err smhd_box_size(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\n\tptr->reserved = 0;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid snro_box_del(GF_Box *s)\n{\n\tGF_SeqOffHintEntryBox *snro = (GF_SeqOffHintEntryBox *)s;\n\tgf_free(snro);\n}\n\nGF_Err snro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->SeqOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *snro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SeqOffHintEntryBox, GF_ISOM_BOX_TYPE_SNRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err snro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->SeqOffset);\n\treturn GF_OK;\n}\n\nGF_Err snro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stbl_box_del(GF_Box *s)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->sub_samples) gf_list_del(ptr->sub_samples);\n\tif (ptr->sampleGroups) gf_list_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_list_del(ptr->sampleGroupsDescription);\n\tif (ptr->sai_sizes) gf_list_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_list_del(ptr->sai_offsets);\n\tif (ptr->traf_map) {\n\t\tif (ptr->traf_map->frag_starts) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->traf_map->nb_entries; i++) {\n\t\t\t\tif (ptr->traf_map->frag_starts[i].moof_template)\n\t\t\t\t\tgf_free(ptr->traf_map->frag_starts[i].moof_template);\n\t\t\t}\n\t\t\tgf_free(ptr->traf_map->frag_starts);\n\t\t}\n\t\tgf_free(ptr->traf_map);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err stbl_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STTS:\n\t\tBOX_FIELD_ASSIGN(TimeToSample, GF_TimeToSampleBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CTTS:\n\t\tBOX_FIELD_ASSIGN(CompositionOffset, GF_CompositionOffsetBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CSLG:\n\t\tBOX_FIELD_ASSIGN(CompositionToDecode, GF_CompositionToDecodeBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSS:\n\t\tBOX_FIELD_ASSIGN(SyncSample, GF_SyncSampleBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSD:\n\t\tBOX_FIELD_ASSIGN(SampleDescription, GF_SampleDescriptionBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STZ2:\n\tcase GF_ISOM_BOX_TYPE_STSZ:\n\t\tBOX_FIELD_ASSIGN(SampleSize, GF_SampleSizeBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSC:\n\t\tBOX_FIELD_ASSIGN(SampleToChunk, GF_SampleToChunkBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_PADB:\n\t\tBOX_FIELD_ASSIGN(PaddingBits, GF_PaddingBitsBox)\n\t\tbreak;\n\n\t//WARNING: AS THIS MAY CHANGE DYNAMICALLY DURING EDIT,\n\tcase GF_ISOM_BOX_TYPE_CO64:\n\tcase GF_ISOM_BOX_TYPE_STCO:\n\t\tBOX_FIELD_ASSIGN(ChunkOffset, GF_Box)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSH:\n\t\tBOX_FIELD_ASSIGN(ShadowSync, GF_ShadowSyncBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STDP:\n\t\tBOX_FIELD_ASSIGN(DegradationPriority, GF_DegradationPriorityBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tBOX_FIELD_ASSIGN(SampleDep, GF_SampleDependencyTypeBox)\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tBOX_FIELD_LIST_ASSIGN(sub_samples)\n\t\t//check subsample box\n\t\tif (!is_rem) {\n\t\t\tGF_SubSampleInformationBox *subs = (GF_SubSampleInformationBox *)a;\n\t\t\tGF_SubSampleInfoEntry *ent = gf_list_get(subs->Samples, 0);\n\t\t\tif (!ent) {\n\t\t\t\tgf_list_rem(subs->Samples, 0);\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] first entry in SubSample in track SampleTable is invalid\\n\"));\n\t\t\t}\n\t\t\telse if (ent->sample_delta==0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] first entry in SubSample in track SampleTable has sample_delta of 0, should be one. Fixing\\n\"));\n\t\t\t\tent->sample_delta = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\tcase GF_ISOM_BOX_TYPE_CSGP:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroups)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroupsDescription)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_sizes)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_offsets)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\n\n\nGF_Err stbl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\t//we need to parse DegPrior in a special way\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->SyncSample)\n\t\tptr->no_sync_found = 1;\n\n\tptr->nb_sgpd_in_stbl = gf_list_count(ptr->sampleGroupsDescription);\n\tptr->nb_stbl_boxes = gf_list_count(ptr->child_boxes);\n\n\tif (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_CLONE_TRACK)\n\t\treturn GF_OK;\n//\treturn GF_OK;\n\n#define CHECK_BOX(_name) \\\n\tif (!ptr->_name) {\\\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Mandatory box %s is missing\\n\", #_name)); \\\n\t\treturn GF_ISOM_INVALID_FILE; \\\n\t}\n\n\tCHECK_BOX(SampleToChunk)\n\tCHECK_BOX(SampleSize)\n\tCHECK_BOX(ChunkOffset)\n\tCHECK_BOX(TimeToSample)\n\n\t//sanity check\n\tif (ptr->SampleSize->sampleCount) {\n\t\tif (!ptr->TimeToSample->nb_entries || !ptr->SampleToChunk->nb_entries)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tu32 i, max_chunks=0;\n\tif (ptr->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tmax_chunks = ((GF_ChunkOffsetBox *)ptr->ChunkOffset)->nb_entries;\n\t}\n\telse if (ptr->ChunkOffset->type == GF_ISOM_BOX_TYPE_CO64) {\n\t\tmax_chunks = ((GF_ChunkOffsetBox *)ptr->ChunkOffset)->nb_entries;\n\t}\n\n\t//sanity check on stsc vs chunk offset tables\n\tfor (i=0; i<ptr->SampleToChunk->nb_entries; i++) {\n\t\tGF_StscEntry *ent = &ptr->SampleToChunk->entries[i];\n\t\tif (!i && (ent->firstChunk!=1)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk of first entry shall be 1 but is %u\\n\", ent->firstChunk));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (ptr->SampleToChunk->entries[i].firstChunk > max_chunks) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk is %u but number of chunks defined %u\\n\", ptr->SampleToChunk->entries[i].firstChunk, max_chunks));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (i+1 == ptr->SampleToChunk->nb_entries) break;\n\t\tGF_StscEntry *next_ent = &ptr->SampleToChunk->entries[i+1];\n\t\tif (next_ent->firstChunk < ent->firstChunk) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk (%u) for entry %u is greater than first_chunk (%u) for entry %u\\n\", i+1, ent->firstChunk, i+2, next_ent->firstChunk));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stbl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleTableBox, GF_ISOM_BOX_TYPE_STBL);\n\t//maxSamplePer chunk is 10 by default\n\ttmp->MaxSamplePerChunk = 10;\n\ttmp->groupID = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stbl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err stbl_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleDescription, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->TimeToSample, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->CompositionOffset, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->CompositionToDecode, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SyncSample, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->ShadowSync, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleToChunk, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleSize, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->ChunkOffset, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->DegradationPriority, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleDep, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->PaddingBits, &pos);\n\n\tif (ptr->sub_samples) {\n\t\tgf_isom_check_position_list(s, ptr->sub_samples, &pos);\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t}\n\tif (ptr->sampleGroups) {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t}\n\tif (ptr->sai_sizes) {\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t}\n\tif (ptr->sai_offsets) {\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stco_box_del(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\n\nGF_Err stco_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->nb_entries > ptr->size / 4 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stco\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (ptr->nb_entries) {\n\t\tptr->offsets = (u32 *) gf_malloc(ptr->nb_entries * sizeof(u32) );\n\t\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->nb_entries;\n\n\t\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\t\tptr->offsets[entries] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stco_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkOffsetBox, GF_ISOM_BOX_TYPE_STCO);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stco_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stco_box_size(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stdp_box_del(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\tif (ptr == NULL ) return;\n\tif (ptr->priorities) gf_free(ptr->priorities);\n\tgf_free(ptr);\n}\n\n//this is called through stbl_read...\nGF_Err stdp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\t/*out-of-order stdp, assume no padding at the end and take the entire remaining data for entries*/\n\tif (!ptr->nb_entries) ptr->nb_entries = (u32) ptr->size / 2;\n\telse if (ptr->nb_entries > ptr->size / 2) return GF_ISOM_INVALID_FILE;\n\n\tptr->priorities = (u16 *) gf_malloc(ptr->nb_entries * sizeof(u16));\n\tif (ptr->priorities == NULL) return GF_OUT_OF_MEM;\n\tfor (entry = 0; entry < ptr->nb_entries; entry++) {\n\t\tptr->priorities[entry] = gf_bs_read_u16(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, (2*ptr->nb_entries) );\n\treturn GF_OK;\n}\n\nGF_Box *stdp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DegradationPriorityBox, GF_ISOM_BOX_TYPE_STDP);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stdp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->priorities[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stdp_box_size(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\tptr->size += (2 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsc_box_del(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->nb_entries > ptr->size / 12 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_StscEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsc\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = NULL;\n\tif (ptr->nb_entries) {\n\t\tptr->entries = gf_malloc(sizeof(GF_StscEntry)*ptr->alloc_size);\n\t\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\t}\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].firstChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].samplesPerChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDescriptionIndex = gf_bs_read_u32(bs);\n\t\tptr->entries[i].isEdited = 0;\n\t\tptr->entries[i].nextChunk = 0;\n\t\tif (!ptr->entries[i].firstChunk) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] invalid first chunk 0 in stsc entry\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t//update the next chunk in the previous entry\n\t\tif (i) ptr->entries[i-1].nextChunk = ptr->entries[i].firstChunk;\n\t}\n\tptr->currentIndex = 0;\n\tptr->firstSampleInCurrentChunk = 0;\n\tptr->currentChunk = 0;\n\tptr->ghostNumber = 0;\n\treturn GF_OK;\n}\n\nGF_Box *stsc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleToChunkBox, GF_ISOM_BOX_TYPE_STSC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].firstChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].samplesPerChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDescriptionIndex);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsc_box_size(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tptr->size += 4 + (12 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsd_box_del(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err stsd_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_UnknownBox *def;\n\tif (!a) return GF_OK;\n\n\tif (is_rem || gf_box_valid_in_parent(a, \"stsd\")) {\n\t\treturn GF_OK;\n\t}\n\tswitch (a->type) {\n\t//unknown sample description: we need a specific box to handle the data ref index\n\t//rather than a default box ...\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\tdef = (GF_UnknownBox *)a;\n\t\t/*we need at least 8 bytes for unknown sample entries*/\n\t\tif (def->dataSize < 8) {\n\t\t\tgf_isom_box_del_parent(&s->child_boxes, a);\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t}\n\t\treturn GF_OK;\n\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Cannot process box of type %s\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n}\n\n\nGF_Err stsd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tISOM_DECREASE_SIZE(s, 4)\n\tgf_bs_read_u32(bs);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *stsd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDescriptionBox, GF_ISOM_BOX_TYPE_STSD);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 nb_entries;\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tnb_entries = gf_list_count(ptr->child_boxes);\n\tgf_bs_write_u32(bs, nb_entries);\n\treturn GF_OK;\n}\n\nGF_Err stsd_box_size(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsh_box_del(GF_Box *s)\n{\n\tu32 i = 0;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tif (ptr == NULL) return;\n\twhile ( (ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i)) ) {\n\t\tgf_free(ent);\n\t}\n\tgf_list_del(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err stsh_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 4)\n\tcount = gf_bs_read_u32(bs);\n\tif (ptr->size / 8 < count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i = 0; i < count; i++) {\n\t\tGF_StshEntry *ent = (GF_StshEntry *) gf_malloc(sizeof(GF_StshEntry));\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tent->shadowedSampleNumber = gf_bs_read_u32(bs);\n\t\tent->syncSampleNumber = gf_bs_read_u32(bs);\n\t\te = gf_list_add(ptr->entries, ent);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsh_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);\n\n\ttmp->entries = gf_list_new();\n\tif (!tmp->entries) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsh_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, gf_list_count(ptr->entries));\n\ti=0;\n\twhile ((ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i))) {\n\t\tgf_bs_write_u32(bs, ent->shadowedSampleNumber);\n\t\tgf_bs_write_u32(bs, ent->syncSampleNumber);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsh_box_size(GF_Box *s)\n{\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tptr->size += 4 + (8 * gf_list_count(ptr->entries));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stss_box_del(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sampleNumbers) gf_free(ptr->sampleNumbers);\n\tgf_free(ptr);\n}\n\nGF_Err stss_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->size / 4 <  ptr->nb_entries || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stss\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->sampleNumbers = (u32 *) gf_malloc( ptr->alloc_size * sizeof(u32));\n\tif (ptr->sampleNumbers == NULL) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->sampleNumbers[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stss_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SyncSampleBox, GF_ISOM_BOX_TYPE_STSS);\n\treturn (GF_Box*)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stss_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->sampleNumbers[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stss_box_size(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsz_box_del(GF_Box *s)\n{\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sizes) gf_free(ptr->sizes);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsz_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, estSize;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//support for CompactSizes\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->sampleSize = gf_bs_read_u32(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\t} else {\n\t\t//24-reserved\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tgf_bs_read_int(bs, 24);\n\t\ti = gf_bs_read_u8(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\t\tswitch (i) {\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tptr->sampleSize = i;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//try to fix the file\n\t\t\t//no samples, no parsing pb\n\t\t\tif (!ptr->sampleCount) {\n\t\t\t\tptr->sampleSize = 16;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\testSize = (u32) (ptr->size) / ptr->sampleCount;\n\t\t\tif (!estSize && ((ptr->sampleCount+1)/2 == (ptr->size)) ) {\n\t\t\t\tptr->sampleSize = 4;\n\t\t\t\tbreak;\n\t\t\t} else if (estSize == 1 || estSize == 2) {\n\t\t\t\tptr->sampleSize = 8 * estSize;\n\t\t\t} else {\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t}\n\tif (ptr->sampleCount && (u64)ptr->sampleCount > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (! ptr->sampleSize && ptr->sampleCount) {\n\t\t\tif (ptr->sampleCount > ptr->size / 4) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\t\tptr->alloc_size = ptr->sampleCount;\n\t\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\t\tptr->sizes[i] = gf_bs_read_u32(bs);\n\t\t\t\tif (ptr->max_size < ptr->sizes[i])\n\t\t\t\t\tptr->max_size = ptr->sizes[i];\n\t\t\t\tptr->total_size += ptr->sizes[i];\n\t\t\t\tptr->total_samples++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (ptr->sampleSize==4) {\n\t\t\tif (ptr->sampleCount / 2 > ptr->size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ptr->sampleCount > ptr->size / (ptr->sampleSize/8)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t\t//note we could optimize the mem usage by keeping the table compact\n\t\t//in memory. But that would complicate both caching and editing\n\t\t//we therefore keep all sizes as u32 and uncompress the table\n\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->sampleCount;\n\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tu32 s_size;\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\ts_size = ptr->sizes[i] = gf_bs_read_int(bs, 4);\n\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\tptr->total_size += s_size;\n\t\t\t\tptr->total_samples++;\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\ts_size = ptr->sizes[i+1] = gf_bs_read_int(bs, 4);\n\t\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\t\tptr->total_size += s_size;\n\t\t\t\t\tptr->total_samples++;\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_read_int(bs, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts_size = ptr->sizes[i] = gf_bs_read_int(bs, ptr->sampleSize);\n\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\tptr->total_size += s_size;\n\t\t\t\tptr->total_samples++;\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsz_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleSizeBox, 0);\n\n\t//type is unknown here, can be regular or compact table\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsz_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//in both versions this is still valid\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tgf_bs_write_u32(bs, ptr->sampleSize);\n\t} else {\n\t\tgf_bs_write_u24(bs, 0);\n\t\tgf_bs_write_u8(bs, ptr->sampleSize);\n\t}\n\tgf_bs_write_u32(bs, ptr->sampleCount);\n\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\tgf_bs_write_u32(bs, ptr->sizes ? ptr->sizes[i] : 0);\n\t\t}\n\t} else {\n\t\tif (!ptr->sizes) return GF_ISOM_INVALID_FILE;\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], 4);\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i+1], 4);\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], ptr->sampleSize);\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsz_box_size(GF_Box *s)\n{\n\tu32 i, fieldSize, size;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\tptr->size += 8;\n\tif (!ptr->sampleCount) return GF_OK;\n\n\t//regular table\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\tif (!ptr->sizes) return GF_ISOM_INVALID_FILE;\n\n\t//compact size table\n\tfieldSize = 4;\n\tsize = ptr->sizes[0];\n\n\tfor (i=0; i < ptr->sampleCount; i++) {\n\t\tif (ptr->sizes[i] <= 0xF) {\n\t\t}\n\t\t//switch to 8-bit table\n\t\telse if (ptr->sizes[i] <= 0xFF) {\n\t\t\tfieldSize = 8;\n\t\t}\n\t\t//switch to 16-bit table\n\t\telse if (ptr->sizes[i] <= 0xFFFF) {\n\t\t\tfieldSize = 16;\n\t\t}\n\t\t//switch to 32-bit table\n\t\telse {\n\t\t\tfieldSize = 32;\n\t\t}\n\n\t\t//check the size\n\t\tif (size != ptr->sizes[i]) size = 0;\n\t}\n\t//if all samples are of the same size, switch to regular (more compact)\n\tif (size) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->sampleSize = size;\n\t\tgf_free(ptr->sizes);\n\t\tptr->sizes = NULL;\n\t\treturn GF_OK;\n\t}\n\n\tif (fieldSize == 32) {\n\t\t//oops, doesn't fit in a compact table\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\n\t//make sure we are a compact table (no need to change the mem representation)\n\tptr->type = GF_ISOM_BOX_TYPE_STZ2;\n\tptr->sampleSize = fieldSize;\n\tif (fieldSize == 4) {\n\t\t//do not forget the 0 padding field for odd count\n\t\tptr->size += (ptr->sampleCount + 1) / 2;\n\t} else {\n\t\tptr->size += (ptr->sampleCount) * (fieldSize/8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stts_box_del(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tBool logged=GF_FALSE;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastDTS = 0;\n#endif\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->size / 8 < ptr->nb_entries || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_SttsEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = gf_malloc(sizeof(GF_SttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDelta = gf_bs_read_u32(bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tptr->w_currentSampleNum += ptr->entries[i].sampleCount;\n\t\tptr->w_LastDTS += (u64)ptr->entries[i].sampleCount * ptr->entries[i].sampleDelta;\n#endif\n\t\tif (ptr->max_ts_delta<ptr->entries[i].sampleDelta)\n\t\t\tptr->max_ts_delta = ptr->entries[i].sampleDelta;\n\n\t\tif (!ptr->entries[i].sampleDelta) {\n\t\t\tif ((i+1<ptr->nb_entries) ) {\n\t\t\t\tif (!logged) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Found stts entry with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\t\tlogged=GF_TRUE;\n\t\t\t\t}\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t} else if (ptr->entries[i].sampleCount>1) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] more than one stts entry at the end of the track with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t}\n\t\t}\n\t\t//cf issue 1644: some media streams may have sample duration > 2^31 (ttml mostly), we cannot patch this\n\t\t//for now we disable the check, one opt could be to have the check only for some media types, or only for the first entry\n#if 0\n\t\telse if ((s32) ptr->entries[i].sampleDelta < 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] stts entry %d has negative duration %d - forbidden ! Fixing to 1, sync may get lost (consider reimport raw media)\\n\", i, (s32) ptr->entries[i].sampleDelta ));\n\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t}\n#endif\n\n\t}\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries*8);\n\n\t//remove the last sample delta.\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (ptr->nb_entries) ptr->w_LastDTS -= ptr->entries[ptr->nb_entries-1].sampleDelta;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *stts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeToSampleBox, GF_ISOM_BOX_TYPE_STTS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDelta);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stts_box_size(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid tfhd_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err tfhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->base_data_offset = gf_bs_read_u64(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->sample_desc_index = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_size = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *tfhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentHeaderBox, GF_ISOM_BOX_TYPE_TFHD);\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err tfhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->trackID);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tgf_bs_write_u64(bs, ptr->base_data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tgf_bs_write_u32(bs, ptr->sample_desc_index);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfhd_box_size(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tptr->size += 4;\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) ptr->size += 8;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tims_box_del(GF_Box *s)\n{\n\tGF_TSHintEntryBox *tims = (GF_TSHintEntryBox *)s;\n\tgf_free(tims);\n}\n\nGF_Err tims_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->timeScale = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tims_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TSHintEntryBox, GF_ISOM_BOX_TYPE_TIMS);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tims_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeScale);\n\treturn GF_OK;\n}\n\nGF_Err tims_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tkhd_box_del(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err tkhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 32);\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tptr->initial_duration = ptr->duration;\n\n\tISOM_DECREASE_SIZE(ptr, 60);\n\tptr->reserved2[0] = gf_bs_read_u32(bs);\n\tptr->reserved2[1] = gf_bs_read_u32(bs);\n\tptr->layer = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->volume = gf_bs_read_u16(bs);\n\tptr->reserved3 = gf_bs_read_u16(bs);\n\tptr->matrix[0] = gf_bs_read_u32(bs);\n\tptr->matrix[1] = gf_bs_read_u32(bs);\n\tptr->matrix[2] = gf_bs_read_u32(bs);\n\tptr->matrix[3] = gf_bs_read_u32(bs);\n\tptr->matrix[4] = gf_bs_read_u32(bs);\n\tptr->matrix[5] = gf_bs_read_u32(bs);\n\tptr->matrix[6] = gf_bs_read_u32(bs);\n\tptr->matrix[7] = gf_bs_read_u32(bs);\n\tptr->matrix[8] = gf_bs_read_u32(bs);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->height = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tkhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackHeaderBox, GF_ISOM_BOX_TYPE_TKHD);\n\ttmp->matrix[0] = 0x00010000;\n\ttmp->matrix[4] = 0x00010000;\n\ttmp->matrix[8] = 0x40000000;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tkhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->reserved2[0]);\n\tgf_bs_write_u32(bs, ptr->reserved2[1]);\n\tgf_bs_write_u16(bs, ptr->layer);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u16(bs, ptr->volume);\n\tgf_bs_write_u16(bs, ptr->reserved3);\n\tgf_bs_write_u32(bs, ptr->matrix[0]);\n\tgf_bs_write_u32(bs, ptr->matrix[1]);\n\tgf_bs_write_u32(bs, ptr->matrix[2]);\n\tgf_bs_write_u32(bs, ptr->matrix[3]);\n\tgf_bs_write_u32(bs, ptr->matrix[4]);\n\tgf_bs_write_u32(bs, ptr->matrix[5]);\n\tgf_bs_write_u32(bs, ptr->matrix[6]);\n\tgf_bs_write_u32(bs, ptr->matrix[7]);\n\tgf_bs_write_u32(bs, ptr->matrix[8]);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u32(bs, ptr->height);\n\treturn GF_OK;\n}\n\nGF_Err tkhd_box_size(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\tptr->size += (ptr->version == 1) ? 32 : 20;\n\tptr->size += 60;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid traf_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sub_samples) gf_list_del(ptr->sub_samples);\n\tgf_list_del(ptr->TrackRuns);\n\tif (ptr->sampleGroups) gf_list_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_list_del(ptr->sampleGroupsDescription);\n\tif (ptr->sai_sizes) gf_list_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_list_del(ptr->sai_offsets);\n\tgf_free(ptr);\n}\n\nGF_Err traf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFHD:\n\t\tBOX_FIELD_ASSIGN(tfhd, GF_TrackFragmentHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRUN:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackRuns)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tBOX_FIELD_ASSIGN(sdtp, GF_SampleDependencyTypeBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TFDT:\n\t\tBOX_FIELD_ASSIGN(tfdt, GF_TFBaseMediaDecodeTimeBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tBOX_FIELD_LIST_ASSIGN(sub_samples)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\tcase GF_ISOM_BOX_TYPE_CSGP:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroups)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroupsDescription)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_sizes)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_offsets)\n\t\treturn GF_OK;\n\t//we will throw an error if both PIFF_PSEC and SENC are found. Not such files seen yet\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\t\tif (!is_rem)\n\t\t\t\tptr->sample_encryption->traf = ptr;\n\t\t\treturn GF_OK;\n\t\t} else if ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_TFXD) {\n\t\t\tBOX_FIELD_ASSIGN(tfxd, GF_MSSTimeExtBox)\n\t\t\treturn GF_OK;\n\t\t} else if ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_TFRF) {\n\t\t\tBOX_FIELD_ASSIGN(tfrf, GF_MSSTimeRefBox)\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\tif (!is_rem)\n\t\t\tptr->sample_encryption->traf = ptr;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err traf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->tfhd) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackFragmentHeaderBox \\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *traf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentBox, GF_ISOM_BOX_TYPE_TRAF);\n\ttmp->TrackRuns = gf_list_new();\n\n\tif (gf_sys_old_arch_compat())\n\t\ttmp->no_sdtp_first_flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err traf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err traf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *) s;\n\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box *)ptr->tfhd, &pos);\n\tgf_isom_check_position_list(s, ptr->sub_samples, &pos);\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->tfdt, &pos);\n\n\t//cmaf-like\n\tif (ptr->truns_first) {\n\t\tgf_isom_check_position_list(s, ptr->TrackRuns, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t\t//senc MUST be after saio in GPAC, as senc writing uses info from saio writing\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->sample_encryption, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t\t//subsamples will be last\n\t} else {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->sample_encryption, &pos);\n\t\tgf_isom_check_position_list(s, ptr->TrackRuns, &pos);\n\t}\n\n\t//when sdtp is present (smooth-like) write it after the trun box\n\tgf_isom_check_position(s, (GF_Box *)ptr->sdtp, &pos);\n\n\t//tfxd should be last ...\n\tif (ptr->tfxd)\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->tfxd, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *tfxd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MSSTimeExtBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TFXD;\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfxd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err tfxd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tif (ptr->version == 0x01) {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u64(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u32(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u32(bs);\n\t}\n\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfxd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, 0);\n\tif (ptr->version) {\n\t\tgf_bs_write_u64(bs, ptr->absolute_time_in_track_timescale);\n\t\tgf_bs_write_u64(bs, ptr->fragment_duration_in_track_timescale);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->absolute_time_in_track_timescale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->fragment_duration_in_track_timescale);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfxd_box_size(GF_Box *s)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)s;\n\ts->size += 4 + (ptr->version ? 16 : 8);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\n\nGF_Box *tfrf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MSSTimeRefBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TFRF;\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfrf_box_del(GF_Box *s)\n{\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox *)s;\n\tif (ptr->frags) gf_free(ptr->frags);\n\tgf_free(s);\n}\n\n\nGF_Err tfrf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 5);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\tptr->frags_count = gf_bs_read_u8(bs);\n\tptr->frags = gf_malloc(sizeof(GF_MSSTimeEntry) * ptr->frags_count);\n\tif (!ptr->frags) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->frags_count; i++) {\n\t\tif (ptr->version == 0x01) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\tptr->frags[i].absolute_time_in_track_timescale = gf_bs_read_u64(bs);\n\t\t\tptr->frags[i].fragment_duration_in_track_timescale = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\t\tptr->frags[i].absolute_time_in_track_timescale = gf_bs_read_u32(bs);\n\t\t\tptr->frags[i].fragment_duration_in_track_timescale = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfrf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, 0);\n\tgf_bs_write_u8(bs, ptr->frags_count);\n\tfor (i=0; i<ptr->frags_count; i++) {\n\t\tif (ptr->version==0x01) {\n\t\t\tgf_bs_write_u64(bs, ptr->frags[i].absolute_time_in_track_timescale);\n\t\t\tgf_bs_write_u64(bs, ptr->frags[i].fragment_duration_in_track_timescale);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->frags[i].absolute_time_in_track_timescale);\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->frags[i].fragment_duration_in_track_timescale);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfrf_box_size(GF_Box *s)\n{\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox*)s;\n\ts->size += 5;\n\tif (ptr->version) s->size += 16 * ptr->frags_count;\n\telse s->size += 8 * ptr->frags_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid trak_box_del(GF_Box *s)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->chunk_cache)\n\t\tgf_bs_del(ptr->chunk_cache);\n#endif\n\tgf_free(s);\n}\n\nstatic void stsd_switch_box(GF_BitStream *bs, GF_Box *box, GF_UnknownBox *a, u8 **data, u32 *data_size, u32 *EntryType, GF_SampleDescriptionBox *stsd, u32 stsd_idx)\n{\n\tif (gf_bs_available(bs)) {\n\t\tGF_Err e;\n\t\tu32 count_subb;\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_NO_LOGS);\n\t\te = gf_isom_box_array_read(box, bs);\n\t\tcount_subb = box->child_boxes ? gf_list_count(box->child_boxes) : 0;\n\t\tif (count_subb && !e) {\n\t\t\tu32 i;\n\t\t\tGF_BitStream *new_dsi = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t//serialize all unknown boxes\n\t\t\tfor (i=0; i<count_subb; i++) {\n\t\t\t\tGF_UnknownBox *priv = gf_list_get(box->child_boxes, i);\n\t\t\t\tif (priv->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\t\t\tgf_bs_write_u32(new_dsi, 8 + priv->dataSize);\n\t\t\t\tgf_bs_write_u32(new_dsi, priv->original_4cc);\n\t\t\t\tgf_bs_write_data(new_dsi, priv->data, priv->dataSize);\n\t\t\t\tgf_list_rem(box->child_boxes, i);\n\t\t\t\tgf_isom_box_del((GF_Box*)priv);\n\t\t\t\tcount_subb--;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tif (*data) gf_free(*data);\n\t\t\tgf_bs_get_content(new_dsi, data, data_size);\n\t\t\tgf_bs_del(new_dsi);\n\t\t} else {\n\t\t\t*data_size = 0;\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\tif (!*data_size && *data) {\n\t\tgf_free(*data);\n\t\t*data = NULL;\n\t}\n\tbox->size = 0;\n\t*EntryType = a->original_4cc;\n\tgf_list_rem(stsd->child_boxes, stsd_idx);\n\tgf_isom_box_del((GF_Box *)a);\n\tgf_list_insert(stsd->child_boxes, box, stsd_idx);\n}\n\n\nstatic GF_Err gf_isom_check_sample_desc(GF_TrackBox *trak)\n{\n\tGF_BitStream *bs;\n\tGF_UnknownBox *a;\n\tu32 i;\n\tGF_Err e;\n\tGF_SampleTableBox *stbl;\n\n\tif (!trak->Media || !trak->Media->information) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no media box !\\n\" ));\n\t\treturn GF_OK;\n\t}\n\tif (!trak->Media->information->sampleTable) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample table !\\n\" ));\n\t\ttrak->Media->information->sampleTable = (GF_SampleTableBox *) gf_isom_box_new_parent(&trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_STBL);\n\t}\n\tstbl = trak->Media->information->sampleTable;\n\n\tif (!stbl->SampleDescription) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample description box !\\n\" ));\n\t\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\t\treturn GF_OK;\n\t}\n\n\ti=0;\n\twhile ((a = (GF_UnknownBox*)gf_list_enum(stbl->SampleDescription->child_boxes, &i))) {\n\t\tGF_ProtectionSchemeInfoBox *sinf;\n\t\tu32 base_ent_type = 0;\n\t\tu32 type = a->type;\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (!sinf || !sinf->original_format) return GF_ISOM_INVALID_FILE;\n\t\t\ttype = sinf->original_format->data_format;\n\t\t\tbase_ent_type = ((GF_SampleEntryBox *)a)->internal_type;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_MP4S)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Protected sample entry %s uses incompatible sample description %s\\n\", gf_4cc_to_str(a->type), gf_4cc_to_str(type) ));\n\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tcontinue;\n\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tcase GF_ISOM_BOX_TYPE_MP3:\n\t\tcase GF_ISOM_BOX_TYPE_MHA1:\n\t\tcase GF_ISOM_BOX_TYPE_MHA2:\n\t\tcase GF_ISOM_BOX_TYPE_MHM1:\n\t\tcase GF_ISOM_BOX_TYPE_MHM2:\n\t\tcase GF_ISOM_BOX_TYPE_OPUS:\n\t\tcase GF_ISOM_BOX_TYPE_AC3:\n\t\tcase GF_ISOM_BOX_TYPE_EC3:\n\t\tcase GF_QT_SUBTYPE_RAW_AUD:\n\t\tcase GF_QT_SUBTYPE_TWOS:\n\t\tcase GF_QT_SUBTYPE_SOWT:\n\t\tcase GF_QT_SUBTYPE_FL32:\n\t\tcase GF_QT_SUBTYPE_FL64:\n\t\tcase GF_QT_SUBTYPE_IN24:\n\t\tcase GF_QT_SUBTYPE_IN32:\n\t\tcase GF_QT_SUBTYPE_ULAW:\n\t\tcase GF_QT_SUBTYPE_ALAW:\n\t\tcase GF_QT_SUBTYPE_ADPCM:\n\t\tcase GF_QT_SUBTYPE_IMA_ADPCM:\n\t\tcase GF_QT_SUBTYPE_DVCA:\n\t\tcase GF_QT_SUBTYPE_QDMC:\n\t\tcase GF_QT_SUBTYPE_QDMC2:\n\t\tcase GF_QT_SUBTYPE_QCELP:\n\t\tcase GF_QT_SUBTYPE_kMP3:\n\t\tcase GF_ISOM_BOX_TYPE_IPCM:\n\t\tcase GF_ISOM_BOX_TYPE_FPCM:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_AUDIO))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tcase GF_ISOM_BOX_TYPE_VP08:\n\t\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tcase GF_ISOM_BOX_TYPE_AV1C:\n\t\tcase GF_ISOM_BOX_TYPE_JPEG:\n\t\tcase GF_ISOM_BOX_TYPE_PNG:\n\t\tcase GF_ISOM_BOX_TYPE_JP2K:\n\t\tcase GF_ISOM_BOX_TYPE_MJP2:\n\t\tcase GF_QT_SUBTYPE_APCH:\n\t\tcase GF_QT_SUBTYPE_APCO:\n\t\tcase GF_QT_SUBTYPE_APCN:\n\t\tcase GF_QT_SUBTYPE_APCS:\n\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tcase GF_QT_SUBTYPE_RAW_VID:\n\t\tcase GF_QT_SUBTYPE_YUYV:\n\t\tcase GF_QT_SUBTYPE_UYVY:\n\t\tcase GF_QT_SUBTYPE_YUV444:\n\t\tcase GF_QT_SUBTYPE_YUVA444:\n\t\tcase GF_QT_SUBTYPE_YUV422_10:\n\t\tcase GF_QT_SUBTYPE_YUV444_10:\n\t\tcase GF_QT_SUBTYPE_YUV422_16:\n\t\tcase GF_QT_SUBTYPE_YUV420:\n\t\tcase GF_QT_SUBTYPE_I420:\n\t\tcase GF_QT_SUBTYPE_IYUV:\n\t\tcase GF_QT_SUBTYPE_YV12:\n\t\tcase GF_QT_SUBTYPE_YVYU:\n\t\tcase GF_QT_SUBTYPE_RGBA:\n\t\tcase GF_QT_SUBTYPE_ABGR:\n\t\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_VIDEO))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\n\t\tcase GF_ISOM_BOX_TYPE_METX:\n\t\tcase GF_ISOM_BOX_TYPE_METT:\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tcase GF_ISOM_BOX_TYPE_GHNT:\n\t\tcase GF_ISOM_BOX_TYPE_RTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_SRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_FDP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RTCP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_DIMS:\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_GENERIC))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (gf_box_valid_in_parent((GF_Box *) a, \"stsd\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unexpected box %s in stsd!\\n\", gf_4cc_to_str(a->type)));\n\t\t\tcontinue;\n\t\t}\n\t\t//we are sure to have an unknown box here\n\t\tassert(a->type==GF_ISOM_BOX_TYPE_UNKNOWN);\n\n\t\tif (!a->data || (a->dataSize<8) ) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Sample description %s does not have at least 8 bytes!\\n\", gf_4cc_to_str(a->original_4cc) ));\n\t\t\tcontinue;\n\t\t}\n\t\telse if (a->dataSize > a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Sample description %s has wrong data size %d!\\n\", gf_4cc_to_str(a->original_4cc), a->dataSize));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*only process visual or audio\n\t\tnote: no need for new_box_parent here since we always store sample descriptions in child_boxes*/\n\t\tswitch (trak->Media->handler->handlerType) {\n        case GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t{\n\t\t\tGF_GenericVisualSampleEntryBox *genv = (GF_GenericVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgenv->size = a->size-8;\n\t\t\tgf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *) genv, bs);\n\n\t\t\tstsd_switch_box(bs, (GF_Box *) genv, a, &genv->data, &genv->data_size, &genv->EntryType, trak->Media->information->sampleTable->SampleDescription, i-1);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t{\n\t\t\tGF_GenericAudioSampleEntryBox *gena = (GF_GenericAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\t\tgena->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox *) gena, bs);\n\n\t\t\tstsd_switch_box(bs, (GF_Box *) gena, a, &gena->data, &gena->data_size, &gena->EntryType, trak->Media->information->sampleTable->SampleDescription, i-1);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t{\n\t\t\tGF_GenericSampleEntryBox *genm = (GF_GenericSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\t\tgenm->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\n\t\t\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)genm, bs);\n\t\t\tif (e) return e;\n\n\t\t\tstsd_switch_box(bs, (GF_Box *) genm, a, &genm->data, &genm->data_size, &genm->EntryType, trak->Media->information->sampleTable->SampleDescription, i-1);\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err trak_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TKHD:\n\t\tBOX_FIELD_ASSIGN(Header, GF_TrackHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_EDTS:\n\t\tBOX_FIELD_ASSIGN(editBox, GF_EditBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tBOX_FIELD_ASSIGN(udta, GF_UserDataBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tBOX_FIELD_ASSIGN(meta, GF_MetaBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TREF:\n\t\tBOX_FIELD_ASSIGN(References, GF_TrackReferenceBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MDIA:\n\t\tBOX_FIELD_ASSIGN(Media, GF_MediaBox)\n\t\tif (!is_rem)\n\t\t\t((GF_MediaBox *)a)->mediaTrack = ptr;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRGR:\n\t\tBOX_FIELD_ASSIGN(groups, GF_TrackGroupBox)\n\t\treturn GF_OK;\n\tcase GF_QT_BOX_TYPE_TAPT:\n\t\tBOX_FIELD_ASSIGN(Aperture, GF_Box)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (((GF_UnknownUUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err trak_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\te = gf_isom_check_sample_desc(ptr);\n\tif (e) return e;\n\n\tif (!ptr->Header) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media->information || !ptr->Media->information->sampleTable) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid MediaBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media->information->sampleTable->SampleSize || (ptr->Media->information->sampleTable->SampleSize->sampleCount==0)) {\n\t\tif (ptr->Header->initial_duration) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Track with no samples but duration defined, ignoring duration\\n\"));\n\t\t\tptr->Header->initial_duration = 0;\n\t\t}\n\t}\n\n\tfor (i=0; i<gf_list_count(ptr->Media->information->sampleTable->child_boxes); i++) {\n\t\tGF_Box *a = gf_list_get(ptr->Media->information->sampleTable->child_boxes, i);\n\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *) a;\n\t\t\tbreak;\n\t\t}\n\t\telse if (a->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *)a;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *trak_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackBox, GF_ISOM_BOX_TYPE_TRAK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trak_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stri_box_del(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->attribute_list) gf_free(ptr->attribute_list);\n\tgf_free(ptr);\n}\n\nGF_Err stri_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tsize_t i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->switch_group = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->sub_track_id = gf_bs_read_u32(bs);\n\tptr->attribute_count = ptr->size / 4;\n\tif ((u64)ptr->attribute_count > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in stri\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tGF_SAFE_ALLOC_N(ptr->attribute_list, (size_t)ptr->attribute_count, u32);\n\tif (!ptr->attribute_list) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->attribute_list[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stri_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackInformationBox, GF_ISOM_BOX_TYPE_STRI);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stri_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->switch_group);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u32(bs, ptr->sub_track_id);\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->attribute_list[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stri_box_size(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\n\tptr->size += 8 + 4 * ptr->attribute_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsg_box_del(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->group_description_index) gf_free(ptr->group_description_index);\n\tgf_free(ptr);\n}\n\nGF_Err stsg_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tISOM_DECREASE_SIZE(s, 6);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tptr->nb_groups = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(s, ptr->nb_groups*4);\n\tGF_SAFE_ALLOC_N(ptr->group_description_index, ptr->nb_groups, u32);\n\tif (!ptr->group_description_index) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tptr->group_description_index[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackSampleGroupBox, GF_ISOM_BOX_TYPE_STSG);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->grouping_type);\n\tgf_bs_write_u16(bs, ptr->nb_groups);\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tgf_bs_write_u32(bs, ptr->group_description_index[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsg_box_size(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tptr->size += 6 + 4 * ptr->nb_groups;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid strk_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err strk_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STRI:\n\t\tBOX_FIELD_ASSIGN(info, GF_SubTrackInformationBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_STRD:\n\t\tBOX_FIELD_ASSIGN(strd, GF_Box)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err strk_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->info) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing SubTrackInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *strk_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackBox, GF_ISOM_BOX_TYPE_STRK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err strk_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err strk_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid tref_box_del(GF_Box *s)\n{\n\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err tref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *tref_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceBox, GF_ISOM_BOX_TYPE_TREF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tref_box_write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err tref_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid reftype_box_del(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (!ptr) return;\n\tif (ptr->trackIDs) gf_free(ptr->trackIDs);\n\tgf_free(ptr);\n}\n\n\nGF_Err reftype_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\n\tbytesToRead = (u32) (ptr->size);\n\tif (!bytesToRead) return GF_OK;\n\n\tptr->trackIDCount = (u32) (bytesToRead) / sizeof(u32);\n\tptr->trackIDs = (GF_ISOTrackID *) gf_malloc(ptr->trackIDCount * sizeof(GF_ISOTrackID));\n\tif (!ptr->trackIDs) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tptr->trackIDs[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *reftype_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceTypeBox, GF_ISOM_BOX_TYPE_REFT);\n\treturn (GF_Box *)tmp;\n}\n\n\nGF_Err reftype_AddRefTrack(GF_TrackReferenceTypeBox *ref, GF_ISOTrackID trackID, u16 *outRefIndex)\n{\n\tu32 i;\n\tif (!ref || !trackID) return GF_BAD_PARAM;\n\n\tif (outRefIndex) *outRefIndex = 0;\n\t//don't add a dep if already here !!\n\tfor (i = 0; i < ref->trackIDCount; i++) {\n\t\tif (ref->trackIDs[i] == trackID) {\n\t\t\tif (outRefIndex) *outRefIndex = i+1;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tref->trackIDs = (GF_ISOTrackID *) gf_realloc(ref->trackIDs, (ref->trackIDCount + 1) * sizeof(GF_ISOTrackID) );\n\tif (!ref->trackIDs) return GF_OUT_OF_MEM;\n\tref->trackIDs[ref->trackIDCount] = trackID;\n\tref->trackIDCount++;\n\tif (outRefIndex) *outRefIndex = ref->trackIDCount;\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err reftype_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (ptr->reference_type == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->reference_type;\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = GF_ISOM_BOX_TYPE_REFT;\n\tif (e) return e;\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->trackIDs[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err reftype_box_size(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (ptr->trackIDCount)\n\t\tptr->size += (ptr->trackIDCount * sizeof(u32));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trex_box_del(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trex_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->trackID = gf_bs_read_u32(bs);\n\tptr->def_sample_desc_index = gf_bs_read_u32(bs);\n\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\tptr->def_sample_size = gf_bs_read_u32(bs);\n\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *trex_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtendsBox, GF_ISOM_BOX_TYPE_TREX);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trex_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\t//we always write 1 in trex default sample desc as using 0 breaks chrome/opera/...\n\tgf_bs_write_u32(bs, ptr->def_sample_desc_index ? ptr->def_sample_desc_index : 1);\n\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\treturn GF_OK;\n}\n\nGF_Err trex_box_size(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tptr->size += 20;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid trep_box_del(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trep_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *trep_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtensionPropertiesBox, GF_ISOM_BOX_TYPE_TREP);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trep_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\treturn GF_OK;\n}\n\nGF_Err trep_box_size(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trun_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->samples) gf_free(ptr->samples);\n\tif (ptr->cache) gf_bs_del(ptr->cache);\n\tif (ptr->sample_order) gf_free(ptr->sample_order);\n\tgf_free(ptr);\n}\n\n#ifdef GF_ENABLE_CTRN\n\nstatic u32 ctrn_field_size(u32 field_idx)\n{\n\tif (field_idx==3) return 4;\n\treturn field_idx;\n}\n\nu32 gf_isom_ctrn_field_size_bits(u32 field_idx)\n{\n\tif (field_idx==3) return 32;\n\treturn field_idx*8;\n}\nstatic u32 ctrn_read_flags(GF_BitStream *bs, u32 nbbits)\n{\n\tu32 val = gf_bs_read_int(bs, nbbits);\n\tif (nbbits==16) val <<= 16;\n\telse if (nbbits==8) val <<= 24;\n\treturn val;\n}\n\nstatic GF_Err ctrn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count, flags, first_idx=0;\n\tBool inherit_dur, inherit_size, inherit_flags, inherit_ctso;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\tflags = ptr->flags;\n\tptr->ctrn_flags = flags;\n\tptr->flags = 0;\n\n\tptr->sample_count = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\n\tif (flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tif (flags & GF_ISOM_CTRN_DATAOFFSET_16) {\n\t\t\tptr->data_offset = gf_bs_read_u16(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\t} else {\n\t\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\t}\n\t\tptr->flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\t}\n\tif (flags & GF_ISOM_CTRN_CTSO_MULTIPLIER) {\n\t\tptr->ctso_multiplier = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t}\n\t/*no sample dur/sample_flag/size/ctso for first or following, create a pack sample */\n\tif (! (flags & 0x00FFFF00)) {\n\t\tGF_SAFEALLOC(ent, GF_TrunEntry);\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tent->nb_pack = ptr->sample_count;\n\t\tgf_list_add(ptr->entries, ent);\n\t\treturn GF_OK;\n\t}\n\t/*allocate all entries*/\n\tfor (i=0; i<ptr->sample_count; i++) {\n\t\tGF_SAFEALLOC(ent, GF_TrunEntry);\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tgf_list_add(ptr->entries, ent);\n\t}\n\t//unpack flags\n\tptr->ctrn_first_dur = (flags>>22) & 0x3;\n\tptr->ctrn_first_size = (flags>>20) & 0x3;\n\tptr->ctrn_first_sample_flags = (flags>>18) & 0x3;\n\tptr->ctrn_first_ctts = (flags>>16) & 0x3;\n\tptr->ctrn_dur = (flags>>14) & 0x3;\n\tptr->ctrn_size = (flags>>12) & 0x3;\n\tptr->ctrn_sample_flags = (flags>>10) & 0x3;\n\tptr->ctrn_ctts = (flags>>8) & 0x3;\n\n\tinherit_dur = flags & GF_ISOM_CTRN_INHERIT_DUR;\n\tinherit_size = flags & GF_ISOM_CTRN_INHERIT_SIZE;\n\tinherit_flags = flags & GF_ISOM_CTRN_INHERIT_FLAGS;\n\tinherit_ctso = flags & GF_ISOM_CTRN_INHERIT_CTSO;\n\n\tif (flags & GF_ISOM_CTRN_FIRST_SAMPLE) {\n\t\tent = gf_list_get(ptr->entries, 0);\n\t\tfirst_idx = 1;\n\t\tif (!inherit_dur && ptr->ctrn_first_dur) {\n\t\t\tent->Duration = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_dur) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_dur) );\n\t\t}\n\t\tif (!inherit_size && ptr->ctrn_first_size) {\n\t\t\tent->size = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_size) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_size) );\n\t\t}\n\t\tif (!inherit_flags && ptr->ctrn_first_sample_flags) {\n\t\t\tent->flags = ctrn_read_flags(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_sample_flags) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_sample_flags) );\n\t\t}\n\t\tif (!inherit_ctso && ptr->ctrn_first_ctts) {\n\t\t\tent->CTS_Offset = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_ctts) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_ctts) );\n\t\t\tif (ptr->ctso_multiplier)\n\t\t\t\tent->CTS_Offset *= (s32) ptr->ctso_multiplier;\n\t\t}\n\t}\n\tcount = ptr->sample_count - first_idx;\n\tif (!inherit_dur && ptr->ctrn_dur) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_dur);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->Duration = gf_bs_read_int(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_size && ptr->ctrn_size) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_size);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->size = gf_bs_read_int(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_flags && ptr->ctrn_sample_flags) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_sample_flags);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->flags = ctrn_read_flags(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_ctso && ptr->ctrn_ctts) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_ctts);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->CTS_Offset = gf_bs_read_int(bs, nbbits);\n\t\t\tif (ptr->ctso_multiplier)\n\t\t\t\tent->CTS_Offset *= (s32) ptr->ctso_multiplier;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->type == GF_ISOM_BOX_TYPE_CTRN) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_TRUN;\n\t\tptr->use_ctrn = GF_TRUE;\n\t\treturn ctrn_box_read(s, bs);\n\t}\n#endif\n\n\t//check this is a good file\n\tif ((ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) && (ptr->flags & GF_ISOM_TRUN_FLAGS))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->sample_count = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->first_sample_flags = gf_bs_read_u32(bs);\n\t}\n\tif (! (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) {\n\t\tptr->samples = gf_malloc(sizeof(GF_TrunEntry));\n\t\tif (!ptr->samples) return GF_OUT_OF_MEM;\n\t\t//memset to 0 !!\n\t\tmemset(ptr->samples, 0, sizeof(GF_TrunEntry));\n\t\tptr->sample_alloc = ptr->nb_samples = 1;\n\t\tptr->samples[0].nb_pack = ptr->sample_count;\n\t} else {\n\t\t//if we get here, at least one flag (so at least 4 bytes) is set, check size\n\t\tif (ptr->sample_count * 4 > ptr->size) {\n\t\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count*4);\n\t\t}\n\t\tif ((u64)ptr->sample_count > (u64)SIZE_MAX/sizeof(GF_TrunEntry)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of samples %d in trun\\n\", ptr->sample_count));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->samples = gf_malloc(sizeof(GF_TrunEntry) * ptr->sample_count);\n\t\tif (!ptr->samples) return GF_OUT_OF_MEM;\n\t\tptr->sample_alloc = ptr->nb_samples = ptr->sample_count;\n\t\t//memset to 0 upfront\n\t\tmemset(ptr->samples, 0, ptr->sample_count * sizeof(GF_TrunEntry));\n\n\t\t//read each entry (even though nothing may be written)\n\t\tfor (i=0; i<ptr->sample_count; i++) {\n\t\t\tu32 trun_size = 0;\n\t\t\tGF_TrunEntry *p = &ptr->samples[i];\n\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\t\tp->Duration = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\t\tp->size = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tp->flags = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tp->CTS_Offset = (u32) gf_bs_read_u32(bs);\n\t\t\t\t} else {\n\t\t\t\t\tp->CTS_Offset = (s32) gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tISOM_DECREASE_SIZE(ptr, trun_size);\n\t\t}\n\t}\n\t/*todo parse sample reorder*/\n\tif (ptr->size) {\n\t\tgf_bs_skip_bytes(bs, ptr->size);\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trun_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRunBox, GF_ISOM_BOX_TYPE_TRUN);\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#ifdef GF_ENABLE_CTRN\nstatic void ctrn_write_sample_flags(GF_BitStream *bs, u32 flags, u32 field_size)\n{\n\tif (!field_size) return;\n\n\tif (field_size==8) flags = flags>>24;\n\telse if (field_size==16) flags = flags>>16;\n\tgf_bs_write_int(bs, flags, field_size);\n}\n\n\nstatic void ctrn_write_ctso(GF_TrackFragmentRunBox *ctrn, GF_BitStream *bs, u32 ctso, u32 field_size)\n{\n\tif (!field_size) return;\n\n\tif (ctrn->ctso_multiplier) {\n\t\tgf_bs_write_int(bs, ctso / ctrn->ctso_multiplier, field_size);\n\t} else {\n\t\tgf_bs_write_int(bs, ctso, field_size);\n\t}\n}\n\nGF_Err ctrn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, count, flags;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *ctrn = (GF_TrackFragmentRunBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tflags = ctrn->flags;\n\tctrn->flags = ctrn->ctrn_flags;\n\tctrn->type = GF_ISOM_BOX_TYPE_CTRN;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tctrn->flags = flags;\n\tctrn->type = GF_ISOM_BOX_TYPE_TRUN;\n\n\tgf_bs_write_u16(bs, ctrn->sample_count);\n\tif (ctrn->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tif (ctrn->ctrn_flags & GF_ISOM_CTRN_DATAOFFSET_16) {\n\t\t\tgf_bs_write_u16(bs, ctrn->data_offset);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, ctrn->data_offset);\n\t\t}\n\t}\n\tif (ctrn->ctso_multiplier) {\n\t\tgf_bs_write_u16(bs, ctrn->ctso_multiplier);\n\t}\n\t/*we always write first sample using first flags*/\n\tent = gf_list_get(ctrn->entries, 0);\n\tgf_bs_write_int(bs, ent->Duration, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_dur) );\n\tgf_bs_write_int(bs, ent->size, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_size) );\n\tctrn_write_sample_flags(bs, ent->flags, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_sample_flags) );\n\tctrn_write_ctso(ctrn,bs, ent->CTS_Offset, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_ctts) );\n\n\tcount = gf_list_count(ctrn->entries);\n\tif (ctrn->ctrn_dur) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_dur);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tgf_bs_write_int(bs, a_ent->Duration, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_size) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_size);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tgf_bs_write_int(bs, a_ent->size, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_sample_flags) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_sample_flags);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tctrn_write_sample_flags(bs, a_ent->flags, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_ctts) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_ctts);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tctrn_write_ctso(ctrn, bs, a_ent->CTS_Offset, nbbits);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->use_ctrn)\n\t\treturn ctrn_box_write(s, bs);\n#endif\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tgf_bs_write_u32(bs, ptr->data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tgf_bs_write_u32(bs, ptr->first_sample_flags);\n\t}\n\n\tif (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) )  {\n\t\tfor (i=0; i<ptr->nb_samples; i++) {\n\t\t\tGF_TrunEntry *p = &ptr->samples[i];\n\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\t\tgf_bs_write_u32(bs, p->Duration);\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\t\tgf_bs_write_u32(bs, p->size);\n\t\t\t}\n\t\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tgf_bs_write_u32(bs, p->flags);\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tgf_bs_write_u32(bs, p->CTS_Offset);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) p->CTS_Offset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ptr->sample_order) {\n\t\tu32 nb_bits = 8;\n\t\tif (ptr->sample_count>0xFFFFFF) nb_bits = 32;\n\t\telse if (ptr->sample_count>0xFFFF) nb_bits = 24;\n\t\telse if (ptr->sample_count>0xFF) nb_bits = 16;\n\n\t\tfor (i=0; i<ptr->sample_count; i++) {\n\t\t\tgf_bs_write_int(bs, ptr->sample_order[i], nb_bits);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifdef GF_ENABLE_CTRN\nstatic u32 ctrn_sample_flags_to_index(u32 val)\n{\n\tif (!val) return 0;\n\tif (val & 0x0000FFFF)\n\t\treturn 3;\n\tif (val & 0x00FF0000)\n\t\treturn 2;\n\treturn 1;\n}\nstatic u32 ctrn_u32_to_index(u32 val)\n{\n\tif (!val) return 0;\n\tif (val<=255) return 1;\n\tif (val<=65535) return 2;\n\treturn 3;\n}\nstatic u32 ctrn_s32_to_index(s32 val)\n{\n\tif (!val) return 0;\n\tif (ABS(val)<=127) return 1;\n\tif (ABS(val)<=32767) return 2;\n\treturn 3;\n}\nstatic u32 ctrn_ctts_to_index(GF_TrackFragmentRunBox *ctrn, s32 ctts)\n{\n\tif (!(ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET))\n\t\treturn 0;\n\n\tif (!ctts) return 0;\n\n\tif (ctrn->version) {\n\t\tif (ctrn->ctso_multiplier) return ctrn_s32_to_index(ctts / ctrn->ctso_multiplier);\n\t\treturn ctrn_s32_to_index(ctts);\n\t}\n\tassert(ctts>0);\n\tif (ctrn->ctso_multiplier) return ctrn_u32_to_index((u32)ctts / ctrn->ctso_multiplier);\n\treturn ctrn_s32_to_index((u32)ctts);\n}\n\nstatic GF_Err ctrn_box_size(GF_TrackFragmentRunBox *ctrn)\n{\n\tBool use_ctso_multi = GF_TRUE;\n\tu32 i, count;\n\tGF_TrunEntry *ent;\n\n\tctrn->ctrn_flags = 0;\n\tctrn->ctrn_first_dur = ctrn->ctrn_first_size = ctrn->ctrn_first_sample_flags = ctrn->ctrn_first_ctts = 0;\n\tctrn->ctrn_dur = ctrn->ctrn_size = ctrn->ctrn_sample_flags = ctrn->ctrn_ctts = 0;\n\n\tctrn->size += 2; //16 bits for sample count\n\tif (ctrn->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tctrn->ctrn_flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\t\tif (ABS(ctrn->data_offset) < 32767) {\n\t\t\tctrn->size += 2;\n\t\t\tctrn->ctrn_flags |= GF_ISOM_CTRN_DATAOFFSET_16;\n\t\t} else\n\t\t\tctrn->size += 4;\n\t}\n\n\tcount = gf_list_count(ctrn->entries);\n\tif (ctrn->ctso_multiplier && (ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET) && (ctrn->ctso_multiplier<=0xFFFF) ) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tif (a_ent->CTS_Offset % ctrn->ctso_multiplier) {\n\t\t\t\tuse_ctso_multi = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tuse_ctso_multi = GF_FALSE;\n\t}\n\tif (ctrn->use_inherit) {\n\t\tuse_ctso_multi = GF_FALSE;\n\t\tctrn->ctrn_flags |= 0xB0; //duration=1,size=0,flags=1,cts=1 << 4\n\t}\n\n\tif (use_ctso_multi) {\n\t\tctrn->size += 2;\n\t\tctrn->ctrn_flags |= GF_ISOM_CTRN_CTSO_MULTIPLIER;\n\t} else {\n\t\tctrn->ctso_multiplier = 0;\n\t}\n\n\t/*we always write first sample using first flags*/\n\tent = gf_list_get(ctrn->entries, 0);\n\tctrn->ctrn_flags |= GF_ISOM_CTRN_FIRST_SAMPLE;\n\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_DURATION)) {\n\t\tctrn->ctrn_first_dur = ctrn_u32_to_index(ent->Duration);\n\t\tif (ctrn->ctrn_first_dur) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_dur);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_dur<<22;\n\t\t}\n\t}\n\n\tif (ctrn->flags & GF_ISOM_TRUN_SIZE) {\n\t\tctrn->ctrn_first_size = ctrn_u32_to_index(ent->size);\n\t\tif (ctrn->ctrn_first_size) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_size);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_size<<20;\n\t\t}\n\t}\n\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_FLAGS)) {\n\t\tctrn->ctrn_first_sample_flags = ctrn_sample_flags_to_index(ent->flags);\n\t\tif (ctrn->ctrn_first_sample_flags) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_sample_flags);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_sample_flags<<18;\n\t\t}\n\t}\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET)) {\n\t\tctrn->ctrn_first_ctts = ctrn_ctts_to_index(ctrn, ent->CTS_Offset);\n\t\tif (ctrn->ctrn_first_ctts) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_ctts);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_ctts<<16;\n\t\t}\n\t}\n\n\tfor (i=1; i<count; i++) {\n\t\tu8 field_idx;\n\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\n\t\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_DURATION)) {\n\t\t\tfield_idx = ctrn_u32_to_index(a_ent->Duration);\n\t\t\tif (ctrn->ctrn_dur < field_idx)\n\t\t\t\tctrn->ctrn_dur = field_idx;\n\t\t}\n\t\tif (ctrn->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\tfield_idx = ctrn_u32_to_index(a_ent->size);\n\t\t\tif (ctrn->ctrn_size < field_idx)\n\t\t\t\tctrn->ctrn_size = field_idx;\n\t\t}\n\t\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_FLAGS)) {\n\t\t\tfield_idx = ctrn_sample_flags_to_index(a_ent->flags);\n\t\t\tif (ctrn->ctrn_sample_flags < field_idx)\n\t\t\t\tctrn->ctrn_sample_flags = field_idx;\n\t\t}\n\t\tif (!ctrn->use_inherit) {\n\t\t\tfield_idx = ctrn_ctts_to_index(ctrn, a_ent->CTS_Offset);\n\t\t\tif (ctrn->ctrn_ctts < field_idx)\n\t\t\t\tctrn->ctrn_ctts = field_idx;\n\t\t}\n\t}\n\tcount-=1;\n\tif (ctrn->ctrn_dur) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_dur);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_dur<<14;\n\t}\n\tif (ctrn->ctrn_size) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_size);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_size<<12;\n\t}\n\tif (ctrn->ctrn_sample_flags) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_sample_flags);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_sample_flags<<10;\n\t}\n\tif (ctrn->ctrn_ctts) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_ctts);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_ctts<<8;\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_size(GF_Box *s)\n{\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->use_ctrn)\n\t\treturn ctrn_box_size(ptr);\n#endif\n\n\tptr->size += 4;\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) ptr->size += 4;\n\n\tif (ptr->sample_order) {\n\t\tu32 nb_bytes = 1;\n\t\tif (ptr->sample_count>0xFFFFFF) nb_bytes = 4;\n\t\telse if (ptr->sample_count>0xFFFF) nb_bytes = 3;\n\t\telse if (ptr->sample_count>0xFF) nb_bytes = 2;\n\t\tptr->size += ptr->sample_count*nb_bytes;\n\t}\n\n\tif (! (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) {\n\t\treturn GF_OK;\n\t}\n\n\t//if nothing to do, this will be skipped automatically\n\tif (ptr->flags & GF_ISOM_TRUN_DURATION) ptr->size += 4*ptr->nb_samples;\n\tif (ptr->flags & GF_ISOM_TRUN_SIZE) ptr->size += 4*ptr->nb_samples;\n\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) ptr->size += 4*ptr->nb_samples;\n\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) ptr->size += 4*ptr->nb_samples;\n\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tsro_box_del(GF_Box *s)\n{\n\tGF_TimeOffHintEntryBox *tsro = (GF_TimeOffHintEntryBox *)s;\n\tgf_free(tsro);\n}\n\nGF_Err tsro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->TimeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tsro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeOffHintEntryBox, GF_ISOM_BOX_TYPE_TSRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tsro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->TimeOffset);\n\treturn GF_OK;\n}\n\nGF_Err tsro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid udta_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (ptr == NULL) return;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\tgf_list_del(ptr->recordList);\n\tgf_free(ptr);\n}\n\nGF_UserDataMap *udta_getEntry(GF_UserDataBox *ptr, u32 box_type, bin128 *uuid)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tif (ptr == NULL) return NULL;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tif (map->boxType == box_type) {\n\t\t\tif ((box_type != GF_ISOM_BOX_TYPE_UUID) || !uuid) return map;\n\t\t\tif (!memcmp(map->uuid, *uuid, 16)) return map;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nGF_Err udta_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_Err e;\n\tu32 box_type;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\tif (!a) return GF_OK;\n\n\t//detach from parent list if any\n\tgf_list_del_item(ptr->child_boxes, a);\n\n\t/* for unknown udta boxes, we reference them by their original box type */\n\tbox_type = a->type;\n\tif (box_type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tGF_UnknownBox* unkn = (GF_UnknownBox *)a;\n\t\tbox_type = unkn->original_4cc;\n\t}\n\n\tmap = udta_getEntry(ptr, box_type, (a->type==GF_ISOM_BOX_TYPE_UUID) ? & ((GF_UUIDBox *)a)->uuid : NULL);\n\tif (map == NULL) {\n\t\tif (is_rem) return GF_OK;\n\n\t\tmap = (GF_UserDataMap *) gf_malloc(sizeof(GF_UserDataMap));\n\t\tif (map == NULL) return GF_OUT_OF_MEM;\n\t\tmemset(map, 0, sizeof(GF_UserDataMap));\n\n\t\tmap->boxType = box_type;\n\t\tif (a->type == GF_ISOM_BOX_TYPE_UUID)\n\t\t\tmemcpy(map->uuid, ((GF_UUIDBox *)a)->uuid, 16);\n\t\tmap->boxes = gf_list_new();\n\t\tif (!map->boxes) {\n\t\t\tgf_free(map);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(ptr->recordList, map);\n\t\tif (e) return e;\n\t}\n\tif (is_rem) {\n\t\tgf_list_del_item(map->boxes, a);\n\t\treturn GF_OK;\n\t}\n\tu32 i, count = gf_list_count(map->boxes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(map->boxes, i);\n\t\tu32 btype = b->type;\n\t\tif (b->type==GF_ISOM_BOX_TYPE_UNKNOWN) btype = ((GF_UnknownBox*)b)->original_4cc;\n\t\tif (btype != box_type) continue;\n\t\tif (box_type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (memcmp( ((GF_UUIDBox *)a)->uuid, ((GF_UUIDBox *)b)->uuid, 16)) continue;\n\t\t}\n\t\tgf_isom_box_del(b);\n\t\tgf_list_rem(map->boxes, i);\n\t\tbreak;\n\t}\n\treturn gf_list_add(map->boxes, a);\n}\n\n\nGF_Err udta_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\tif (s->size==4) {\n\t\tu32 val = gf_bs_read_u32(bs);\n\t\ts->size = 0;\n\t\tif (val) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] udta has 4 remaining bytes set to %08X but they should be 0\\n\", val));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *udta_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UserDataBox, GF_ISOM_BOX_TYPE_UDTA);\n\ttmp->recordList = gf_list_new();\n\tif (!tmp->recordList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err udta_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_write(s, map->boxes, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err udta_box_size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_size(s, map->boxes);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid vmhd_box_del(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err vmhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->reserved = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\n\nGF_Box *vmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_VideoMediaHeaderBox, GF_ISOM_BOX_TYPE_VMHD);\n\ttmp->flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err vmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err vmhd_box_size(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid void_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err void_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tif (s->size) return GF_ISOM_INVALID_FILE;\n\treturn GF_OK;\n}\n\nGF_Box *void_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, GF_ISOM_BOX_TYPE_VOID);\n\treturn tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err void_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err void_box_size(GF_Box *s)\n{\n\ts->size = 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *pdin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProgressiveDownloadBox, GF_ISOM_BOX_TYPE_PDIN);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pdin_box_del(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->rates) gf_free(ptr->rates);\n\tif (ptr->times) gf_free(ptr->times);\n\tgf_free(ptr);\n}\n\n\nGF_Err pdin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\n\tptr->count = (u32) (ptr->size) / 8;\n\tptr->rates = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tif (!ptr->rates) return GF_OUT_OF_MEM;\n\tptr->times = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tif (!ptr->times) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->count; i++) {\n\t\tptr->rates[i] = gf_bs_read_u32(bs);\n\t\tptr->times[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pdin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tfor (i=0; i<ptr->count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->rates[i]);\n\t\tgf_bs_write_u32(bs, ptr->times[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pdin_box_size(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\tptr->size += 8*ptr->count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *sdtp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDependencyTypeBox, GF_ISOM_BOX_TYPE_SDTP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid sdtp_box_del(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info) gf_free(ptr->sample_info);\n\tgf_free(ptr);\n}\n\n\nGF_Err sdtp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\n\t/*out-of-order sdtp, assume no padding at the end*/\n\tif (!ptr->sampleCount) ptr->sampleCount = (u32) ptr->size;\n\telse if (ptr->sampleCount > (u32) ptr->size) return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_info = (u8 *) gf_malloc(sizeof(u8)*ptr->sampleCount);\n\tif (!ptr->sample_info) return GF_OUT_OF_MEM;\n\tptr->sample_alloc = ptr->sampleCount;\n\tgf_bs_read_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\tISOM_DECREASE_SIZE(ptr, ptr->sampleCount);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sdtp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\treturn GF_OK;\n}\n\nGF_Err sdtp_box_size(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\tptr->size += ptr->sampleCount;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *pasp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PixelAspectRatioBox, GF_ISOM_BOX_TYPE_PASP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pasp_box_del(GF_Box *s)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err pasp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->hSpacing = gf_bs_read_u32(bs);\n\tptr->vSpacing = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pasp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->hSpacing);\n\tgf_bs_write_u32(bs, ptr->vSpacing);\n\treturn GF_OK;\n}\n\nGF_Err pasp_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *clap_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CleanApertureBox, GF_ISOM_BOX_TYPE_CLAP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid clap_box_del(GF_Box *s)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err clap_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 32);\n\tptr->cleanApertureWidthN = gf_bs_read_u32(bs);\n\tptr->cleanApertureWidthD = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightN = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightD = gf_bs_read_u32(bs);\n\tptr->horizOffN = (s32) gf_bs_read_u32(bs);\n\tptr->horizOffD = gf_bs_read_u32(bs);\n\tptr->vertOffN = (s32) gf_bs_read_u32(bs);\n\tptr->vertOffD = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err clap_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthD);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightD);\n\tgf_bs_write_u32(bs, (u32) ptr->horizOffN);\n\tgf_bs_write_u32(bs, ptr->horizOffD);\n\tgf_bs_write_u32(bs, (u32) ptr->vertOffN);\n\tgf_bs_write_u32(bs, ptr->vertOffD);\n\treturn GF_OK;\n}\n\nGF_Err clap_box_size(GF_Box *s)\n{\n\ts->size += 32;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *metx_box_new()\n{\n\t//type is overridden by the box constructor\n\tISOM_DECL_BOX_ALLOC(GF_MetaDataSampleEntryBox, GF_ISOM_BOX_TYPE_METX);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid metx_box_del(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tif (ptr->xml_namespace) gf_free(ptr->xml_namespace);\n\tif (ptr->xml_schema_loc) gf_free(ptr->xml_schema_loc);\n\tif (ptr->mime_type) gf_free(ptr->mime_type);\n\tgf_free(ptr);\n}\n\n\nGF_Err metx_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TXTC:\n\t\t//we allow the config box on metx\n\t\tBOX_FIELD_ASSIGN(config, GF_TextConfigBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err metx_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 size, i;\n\tGF_Err e;\n\tchar *str;\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\tif (ptr->size > (u64)SIZE_MAX) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size \"LLU\" in metx\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tsize = (u32) ptr->size;\n\tstr = gf_malloc(sizeof(char)*size);\n\tif (!str) return GF_OUT_OF_MEM;\n\ti=0;\n\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i]) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!size && i>1 && str[i-1]) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (i>1) {\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t} else {\n\t\t\tptr->content_encoding = gf_strdup(str);\n\t\t}\n\t}\n\n\ti=0;\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i]) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!size && i>1 && str[i-1]) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (i>1) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t\t}\n\t\t}\n\n\t\ti=0;\n\t\twhile (size) {\n\t\t\tstr[i] = gf_bs_read_u8(bs);\n\t\t\tsize--;\n\t\t\tif (!str[i]) {\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (!size && i>1 && str[i-1]) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\t\tgf_free(str);\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (i>1) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->mime_type = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t}\n\t\t}\n\t}\n\t//mett, sbtt, stxt, stpp\n\telse {\n\t\tif (i>1) ptr->mime_type = gf_strdup(str);\n\t}\n\tptr->size = size;\n\tgf_free(str);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err metx_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tgf_bs_write_data(bs, ptr->content_encoding, (u32) strlen(ptr->content_encoding));\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (ptr->xml_namespace)\n\t\t\tgf_bs_write_data(bs, ptr->xml_namespace, (u32) strlen(ptr->xml_namespace));\n\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tgf_bs_write_data(bs, ptr->xml_schema_loc, (u32) strlen(ptr->xml_schema_loc));\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err metx_box_size(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tptr->size += 8;\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tptr->size += strlen(ptr->content_encoding);\n\t\tptr->size++;\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\n\t\tif (ptr->xml_namespace)\n\t\t\tptr->size += strlen(ptr->xml_namespace);\n\t\tptr->size++;\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tptr->size += strlen(ptr->xml_schema_loc);\n\t\tptr->size++;\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tptr->size += strlen(ptr->mime_type);\n\t\t\tptr->size++;\n\t\t}\n\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tptr->size += strlen(ptr->mime_type);\n\t\tptr->size++;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* SimpleTextSampleEntry */\nGF_Box *txtc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextConfigBox, GF_ISOM_BOX_TYPE_TXTC);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid txtc_box_del(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->config) gf_free(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err txtc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\tif ((u32)ptr->size >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in txtc box\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->config = (char *)gf_malloc(sizeof(char)*((u32) ptr->size+1));\n\tif (!ptr->config) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->config, (u32) ptr->size);\n\tptr->config[ptr->size] = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err txtc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->config)\n\t\tgf_bs_write_data(bs, ptr->config, (u32) strlen(ptr->config));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err txtc_box_size(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tif (ptr->config)\n\t\tptr->size += strlen(ptr->config);\n\tptr->size++;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dac3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *dec3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\ttmp->cfg.is_ec3 = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dac3_box_del(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tgf_free(ptr);\n}\n\n\nGF_Err dac3_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tpos = gf_bs_get_position(bs);\n\te = gf_odf_ac3_config_parse_bs(bs, ptr->cfg.is_ec3, &ptr->cfg);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs) - pos;\n\tISOM_DECREASE_SIZE(ptr, pos);\n\n\tif (ptr->size>=2) {\n\t\tptr->size-=2;\n\t\tgf_bs_read_int(bs, 7);\n\t\tptr->cfg.atmos_ec3_ext = gf_bs_read_int(bs, 1);\n\t\tptr->cfg.complexity_index_type = gf_bs_read_u8(bs);\n\t}\n\t//the rest is reserved\n\tgf_bs_skip_bytes(bs, ptr->size);\n\tptr->size = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dac3_box_size(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) {\n\t\tu32 i;\n\t\ts->size += 2;\n\t\tfor (i=0; i<ptr->cfg.nb_streams; i++) {\n\t\t\ts->size += 3;\n\t\t\tif (ptr->cfg.streams[i].nb_dep_sub)\n\t\t\t\ts->size += 1;\n\t\t}\n\t} else {\n\t\ts->size += 3;\n\t}\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\ts->size += 2;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid lsrc_box_del(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->hdr) gf_free(ptr->hdr);\n\tgf_free(ptr);\n}\n\n\nGF_Err lsrc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->hdr_size = (u32) ptr->size;\n\tptr->hdr = gf_malloc(sizeof(char)*ptr->hdr_size);\n\tif (!ptr->hdr) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Box *lsrc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASERConfigurationBox, GF_ISOM_BOX_TYPE_LSRC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err lsrc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Err lsrc_box_size(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->size += ptr->hdr_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid lsr1_box_del(GF_Box *s)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err lsr1_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_LSRC:\n\t\tBOX_FIELD_ASSIGN(lsr_config, GF_LASERConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tBOX_FIELD_ASSIGN(descr, GF_MPEG4ExtensionDescriptorsBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *lsr1_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASeRSampleEntryBox, GF_ISOM_BOX_TYPE_LSR1);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err lsr1_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err lsr1_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *)ptr->lsr_config, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid sidx_box_del(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->refs) gf_free(ptr->refs);\n\tgf_free(ptr);\n}\n\nGF_Err sidx_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->reference_ID = gf_bs_read_u32(bs);\n\tptr->timescale = gf_bs_read_u32(bs);\n\n\tif (ptr->version==0) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->earliest_presentation_time = gf_bs_read_u32(bs);\n\t\tptr->first_offset = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->earliest_presentation_time = gf_bs_read_u64(bs);\n\t\tptr->first_offset = gf_bs_read_u64(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tgf_bs_read_u16(bs); /* reserved */\n\tptr->nb_refs = gf_bs_read_u16(bs);\n\n\tptr->refs = gf_malloc(sizeof(GF_SIDXReference)*ptr->nb_refs);\n\tif (!ptr->refs) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->nb_refs; i++) {\n\t\tptr->refs[i].reference_type = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].reference_size = gf_bs_read_int(bs, 31);\n\t\tptr->refs[i].subsegment_duration = gf_bs_read_u32(bs);\n\t\tptr->refs[i].starts_with_SAP = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].SAP_type = gf_bs_read_int(bs, 3);\n\t\tptr->refs[i].SAP_delta_time = gf_bs_read_int(bs, 28);\n\n\t\tISOM_DECREASE_SIZE(ptr, 12);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *sidx_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SegmentIndexBox, GF_ISOM_BOX_TYPE_SIDX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sidx_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->reference_ID);\n\tgf_bs_write_u32(bs, ptr->timescale);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->earliest_presentation_time);\n\t\tgf_bs_write_u32(bs, (u32) ptr->first_offset);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->earliest_presentation_time);\n\t\tgf_bs_write_u64(bs, ptr->first_offset);\n\t}\n\tgf_bs_write_u16(bs, 0);\n\tgf_bs_write_u16(bs, ptr->nb_refs);\n\tfor (i=0; i<ptr->nb_refs; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_type, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_size, 31);\n\t\tgf_bs_write_u32(bs, ptr->refs[i].subsegment_duration);\n\t\tgf_bs_write_int(bs, ptr->refs[i].starts_with_SAP, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_type, 3);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_delta_time, 28);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sidx_box_size(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tptr->size += 12;\n\tif (ptr->version==0) {\n\t\tptr->size += 8;\n\t} else {\n\t\tptr->size += 16;\n\t}\n\tptr->size += ptr->nb_refs * 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ssix_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->subsegments) {\n\t\tfor (i = 0; i < ptr->subsegment_alloc; i++) {\n\t\t\tGF_SubsegmentInfo *subsegment = &ptr->subsegments[i];\n\t\t\tif (subsegment->ranges) gf_free(subsegment->ranges);\n\t\t}\n\t\tgf_free(ptr->subsegments);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err ssix_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i,j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\t//each subseg has at least one range_count (4 bytes), abort if not enough bytes (broken box)\n\tif (ptr->size / 4 < ptr->subsegment_count || (u64)ptr->subsegment_count > (u64)SIZE_MAX/sizeof(GF_SubsegmentInfo))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->subsegment_alloc = ptr->subsegment_count;\n\tGF_SAFE_ALLOC_N(ptr->subsegments, ptr->subsegment_count, GF_SubsegmentInfo);\n\tif (!ptr->subsegments)\n\t    return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tGF_SubsegmentInfo *subseg = &ptr->subsegments[i];\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tsubseg->range_count = gf_bs_read_u32(bs);\n\t\t//each range is 4 bytes, abort if not enough bytes\n\t\tif (ptr->size / 4 < subseg->range_count || (u64)subseg->range_count > (u64)SIZE_MAX/sizeof(GF_SubsegmentRangeInfo))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tsubseg->ranges = (GF_SubsegmentRangeInfo*) gf_malloc(sizeof(GF_SubsegmentRangeInfo) * subseg->range_count);\n\t\tif (!subseg->ranges) return GF_OUT_OF_MEM;\n\t\tfor (j = 0; j < subseg->range_count; j++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tsubseg->ranges[j].level = gf_bs_read_u8(bs);\n\t\t\tsubseg->ranges[j].range_size = gf_bs_read_u24(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *ssix_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubsegmentIndexBox, GF_ISOM_BOX_TYPE_SSIX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ssix_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\tfor (i = 0; i<ptr->subsegment_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->subsegments[i].range_count);\n\t\tfor (j = 0; j < ptr->subsegments[i].range_count; j++) {\n\t\t\tgf_bs_write_u8(bs, ptr->subsegments[i].ranges[j].level);\n\t\t\tgf_bs_write_u24(bs, ptr->subsegments[i].ranges[j].range_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ssix_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tptr->size += 4;\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tptr->size += 4 + 4 * ptr->subsegments[i].range_count;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid leva_box_del(GF_Box *s)\n{\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->levels) gf_free(ptr->levels);\n\tgf_free(ptr);\n}\n\nGF_Err leva_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->level_count = gf_bs_read_u8(bs);\n\t//each level is at least 5 bytes\n\tif (ptr->size / 5 < ptr->level_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tGF_SAFE_ALLOC_N(ptr->levels, ptr->level_count, GF_LevelAssignment);\n\tif (!ptr->levels) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tGF_LevelAssignment *level = &ptr->levels[i];\n\t\tu8 tmp;\n\t\tif (!level || ptr->size < 5) return GF_BAD_PARAM;\n\t\tISOM_DECREASE_SIZE(ptr, 5)\n\n\t\tlevel->track_id = gf_bs_read_u32(bs);\n\t\ttmp = gf_bs_read_u8(bs);\n\t\tlevel->padding_flag = tmp >> 7;\n\t\tlevel->type = tmp & 0x7F;\n\t\tif (level->type == 0) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 1) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t\tlevel->grouping_type_parameter = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 4) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlevel->sub_track_id = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *leva_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LevelAssignmentBox, GF_ISOM_BOX_TYPE_LEVA);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err leva_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->level_count);\n\tfor (i = 0; i<ptr->level_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->levels[i].track_id);\n\t\tgf_bs_write_u8(bs, ptr->levels[i].padding_flag << 7 | (ptr->levels[i].type & 0x7F));\n\t\tif (ptr->levels[i].type == 0) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type_parameter);\n\t\t}\n\t\telse if (ptr->levels[i].type == 4) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].sub_track_id);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err leva_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tptr->size += 1;\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->levels[i].type == 0 || ptr->levels[i].type == 4) {\n\t\t\tptr->size += 4;\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tptr->size += 8;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *pcrb_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PcrInfoBox, GF_ISOM_BOX_TYPE_PCRB);\n\treturn (GF_Box *)tmp;\n}\n\nvoid pcrb_box_del(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->pcr_values) gf_free(ptr->pcr_values);\n\tgf_free(ptr);\n}\n\nGF_Err pcrb_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\n\tif ((u64)ptr->subsegment_count > ptr->size / 8 || (u64)ptr->subsegment_count > (u64)SIZE_MAX/sizeof(u64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of subsegment %d in pcrb\\n\", ptr->subsegment_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->pcr_values = gf_malloc(sizeof(u64)*ptr->subsegment_count);\n\tif (!ptr->pcr_values) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->subsegment_count; i++) {\n\t\tu64 data1 = gf_bs_read_u32(bs);\n\t\tu64 data2 = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 6);\n\t\tptr->pcr_values[i] = (data1 << 10) | (data2 >> 6);\n\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pcrb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\n\tfor (i=0; i<ptr->subsegment_count; i++ ) {\n\t\tu32 data1 = (u32) (ptr->pcr_values[i] >> 10);\n\t\tu16 data2 = (u16) (ptr->pcr_values[i] << 6);\n\n\t\tgf_bs_write_u32(bs, data1);\n\t\tgf_bs_write_u16(bs, data2);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pcrb_box_size(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tptr->size += 4;\n\tptr->size += ptr->subsegment_count * 6;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *subs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubSampleInformationBox, GF_ISOM_BOX_TYPE_SUBS);\n\ttmp->Samples = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid subs_box_del(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->Samples)) {\n\t\tGF_SubSampleInfoEntry *pSamp;\n\t\tpSamp = (GF_SubSampleInfoEntry*)gf_list_get(ptr->Samples, 0);\n\t\twhile (gf_list_count(pSamp->SubSamples)) {\n\t\t\tGF_SubSampleEntry *pSubSamp;\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, 0);\n\t\t\tgf_free(pSubSamp);\n\t\t\tgf_list_rem(pSamp->SubSamples, 0);\n\t\t}\n\t\tgf_list_del(pSamp->SubSamples);\n\t\tgf_free(pSamp);\n\t\tgf_list_rem(ptr->Samples, 0);\n\t}\n\tgf_list_del(ptr->Samples);\n\tgf_free(ptr);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err subs_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j, entry_count;\n\tu16 subsample_count;\n\tGF_SubSampleEntry *pSubSamp;\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tentry_count = gf_list_count(ptr->Samples);\n\tgf_bs_write_u32(bs, entry_count);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\tgf_bs_write_u32(bs, pSamp->sample_delta);\n\t\tgf_bs_write_u16(bs, subsample_count);\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, j);\n\t\t\tif (ptr->version == 1) {\n\t\t\t\tgf_bs_write_u32(bs, pSubSamp->subsample_size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u16(bs, pSubSamp->subsample_size);\n\t\t\t}\n\t\t\tgf_bs_write_u8(bs, pSubSamp->subsample_priority);\n\t\t\tgf_bs_write_u8(bs, pSubSamp->discardable);\n\t\t\tgf_bs_write_u32(bs, pSubSamp->reserved);\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Err subs_box_size(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\tu32 entry_count, i;\n\tu16 subsample_count;\n\n\t// add 4 byte for entry_count\n\tptr->size += 4;\n\tentry_count = gf_list_count(ptr->Samples);\n\tfor (i=0; i<entry_count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\t// 4 byte for sample_delta, 2 byte for subsample_count\n\t\t// and 6 + (4 or 2) bytes for each subsample\n\t\tptr->size += 4 + 2 + subsample_count * (6 + (ptr->version==1 ? 4 : 2));\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Err subs_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tu32 entry_count, i, j;\n\tu16 subsample_count;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tentry_count = gf_bs_read_u32(bs);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tu32 subs_size=0;\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_malloc(sizeof(GF_SubSampleInfoEntry));\n\t\tif (!pSamp) return GF_OUT_OF_MEM;\n\n\t\tmemset(pSamp, 0, sizeof(GF_SubSampleInfoEntry));\n\t\tpSamp->SubSamples = gf_list_new();\n\t\tpSamp->sample_delta = gf_bs_read_u32(bs);\n\t\tsubsample_count = gf_bs_read_u16(bs);\n\t\tsubs_size=6;\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tGF_SubSampleEntry *pSubSamp = (GF_SubSampleEntry*) gf_malloc(sizeof(GF_SubSampleEntry));\n\t\t\tif (!pSubSamp) return GF_OUT_OF_MEM;\n\n\t\t\tmemset(pSubSamp, 0, sizeof(GF_SubSampleEntry));\n\t\t\tif (ptr->version==1) {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u32(bs);\n\t\t\t\tsubs_size+=4;\n\t\t\t} else {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u16(bs);\n\t\t\t\tsubs_size+=2;\n\t\t\t}\n\t\t\tpSubSamp->subsample_priority = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->discardable = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->reserved = gf_bs_read_u32(bs);\n\t\t\tsubs_size+=6;\n\n\t\t\tgf_list_add(pSamp->SubSamples, pSubSamp);\n\t\t}\n\t\tgf_list_add(ptr->Samples, pSamp);\n\t\tISOM_DECREASE_SIZE(ptr, subs_size);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\nGF_Box *tfdt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TFBaseMediaDecodeTimeBox, GF_ISOM_BOX_TYPE_TFDT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfdt_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->baseMediaDecodeTime = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfdt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->version==1) {\n\t\tgf_bs_write_u64(bs, ptr->baseMediaDecodeTime);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->baseMediaDecodeTime);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfdt_box_size(GF_Box *s)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (!ptr->version && (ptr->baseMediaDecodeTime<=0xFFFFFFFF)) {\n\t\t//ptr->version = 0;\n\t\tptr->size += 4;\n\t} else {\n\t\tptr->version = 1;\n\t\tptr->size += 8;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nGF_Box *rvcc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RVCConfigurationBox, GF_ISOM_BOX_TYPE_RVCC);\n\treturn (GF_Box *)tmp;\n}\n\nvoid rvcc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err rvcc_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->predefined_rvc_config = gf_bs_read_u16(bs);\n\tif (!ptr->predefined_rvc_config) {\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\tptr->rvc_meta_idx = gf_bs_read_u16(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err rvcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->predefined_rvc_config);\n\tif (!ptr->predefined_rvc_config) {\n\t\tgf_bs_write_u16(bs, ptr->rvc_meta_idx);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err rvcc_box_size(GF_Box *s)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox *)s;\n\tptr->size += 2;\n\tif (! ptr->predefined_rvc_config) ptr->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *sbgp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupBox, GF_ISOM_BOX_TYPE_SBGP);\n\treturn (GF_Box *)tmp;\n}\nvoid sbgp_box_del(GF_Box *a)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox *)a;\n\tif (p->sample_entries) gf_free(p->sample_entries);\n\tgf_free(p);\n}\n\nGF_Err sbgp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleGroupBox *ptr = (GF_SampleGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tptr->entry_count = gf_bs_read_u32(bs);\n\n\tif (ptr->size < sizeof(GF_SampleGroupEntry)*ptr->entry_count || (u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(GF_SampleGroupEntry))\n\t    return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_entries = gf_malloc(sizeof(GF_SampleGroupEntry)*ptr->entry_count);\n\tif (!ptr->sample_entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->sample_entries[i].sample_count = gf_bs_read_u32(bs);\n\t\tptr->sample_entries[i].group_description_index = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sbgp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version==1)\n\t\tgf_bs_write_u32(bs, p->grouping_type_parameter);\n\n\tgf_bs_write_u32(bs, p->entry_count);\n\tfor (i = 0; i<p->entry_count; i++ ) {\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].sample_count);\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].group_description_index);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sbgp_box_size(GF_Box *s)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\tp->size += 8;\n\tif (p->grouping_type_parameter) p->version=1;\n\n\tif (p->version==1) p->size += 4;\n\tp->size += 8*p->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nstatic void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes)\n{\n\tBool null_size_ok = GF_FALSE;\n\tGF_DefaultSampleGroupDescriptionEntry *def_ptr;\n\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t{\n\t\tGF_RollRecoveryEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_RollRecoveryEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->roll_distance = gf_bs_read_int(bs, 16);\n\t\t*total_bytes = 2;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t{\n\t\tGF_VisualRandomAccessEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->num_leading_samples_known = gf_bs_read_int(bs, 1);\n\t\tptr->num_leading_samples = gf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t{\n\t\tGF_SAPEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SAPEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->dependent_flag = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 3);\n\t\tptr->SAP_type = gf_bs_read_int(bs, 4);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t{\n\t\tGF_SYNCEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SYNCEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_int(bs, 2);\n\t\tptr->NALU_type = gf_bs_read_int(bs, 6);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t{\n\t\tGF_TemporalLevelEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_TemporalLevelEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->level_independently_decodable = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *ptr;\n\t\tif (bytes_in_box<3) return NULL;\n\t\tGF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tBool use_mkey = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7); //reserved\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->IsProtected = gf_bs_read_u8(bs);\n\t\tbytes_in_box -= 3;\n\t\tif (use_mkey) {\n\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\tu32 i, count = gf_bs_read_u16(bs);\n\t\t\tbytes_in_box -= 2;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tu8 ivsize = gf_bs_read_u8(bs);\n\t\t\t\tgf_bs_skip_bytes(bs, 16);\n\t\t\t\tbytes_in_box -= 17;\n\t\t\t\tif (!ivsize) {\n\t\t\t\t\t//const IV\n\t\t\t\t\tivsize = gf_bs_read_u8(bs);\n\t\t\t\t\tgf_bs_skip_bytes(bs, ivsize);\n\t\t\t\t\tbytes_in_box -= 1 + ivsize;\n\t\t\t\t}\n\t\t\t\tif (bytes_in_box<0) {\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 1 + (u32) (gf_bs_get_position(bs) - pos);\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\tptr->key_info[0] = 1;\n\t\t\tgf_bs_read_data(bs, ptr->key_info + 1, ptr->key_info_size - 1);\n\t\t\t*total_bytes = 3 + ptr->key_info_size - 1;\n\n\t\t\tif (!gf_cenc_validate_key_info(ptr->key_info, ptr->key_info_size)) {\n\t\t\t\tgf_free(ptr->key_info);\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tbin128 kid;\n\t\t\tu8 const_iv_size = 0;\n\t\t\tu8 iv_size = gf_bs_read_u8(bs);\n\t\t\tgf_bs_read_data(bs, kid, 16);\n\t\t\tbytes_in_box -= 17;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t*total_bytes = 20;\n\t\t\tif ((ptr->IsProtected == 1) && !iv_size) {\n\t\t\t\tconst_iv_size = gf_bs_read_u8(bs);\n\t\t\t\tif ((const_iv_size != 8) && (const_iv_size != 16)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group have invalid constant_IV size\\n\"));\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 20;\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info_size += 1 + const_iv_size;\n\t\t\t}\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr->key_info[0] = 0;\n\t\t\tptr->key_info[1] = 0;\n\t\t\tptr->key_info[2] = 0;\n\t\t\tptr->key_info[3] = iv_size;\n\t\t\tmemcpy(ptr->key_info+4, kid, 16);\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info[20] = const_iv_size;\n\t\t\t\tgf_bs_read_data(bs, (char *)ptr->key_info+21, const_iv_size);\n\t\t\t\t*total_bytes += 1 + const_iv_size;\n\t\t\t}\n\t\t}\n\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t{\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_oinf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] oinf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t{\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_linf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] linf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tif (! entry_size) {\n\t\t\tu32 flags = gf_bs_peek_bits(bs, 24, 0);\n\t\t\tif (flags & 0x10000) entry_size=3;\n\t\t\telse {\n\t\t\t\tif (flags & 0x80000) entry_size=7;\n\t\t\t\telse entry_size=11;\n\t\t\t\t//have dependency list\n\t\t\t\tif (flags & 0x200000) {\n\t\t\t\t\tu32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);\n\t\t\t\t\tentry_size += 2 + 2*nb_entries;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] trif sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tif (! entry_size) {\n\t\t\tu64 start = gf_bs_get_position(bs);\n\t\t\tBool rle, large_size;\n\t\t\tu32 entry_count;\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tlarge_size = gf_bs_read_int(bs, 1);\n\t\t\trle = gf_bs_read_int(bs, 1);\n\t\t\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tgf_bs_seek(bs, start);\n\t\t\tentry_size = 1 + (large_size ? 2 : 1);\n\t\t\tentry_size += entry_count * 2;\n\t\t\tif (rle) entry_size += entry_count * (large_size ? 2 : 1);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] nalm sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\tnull_size_ok = GF_TRUE;\n\t\tbreak;\n\t//TODO, add support for these ones ?\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\tentry_size = 20;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\tentry_size = 2;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureOrderEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->subpic_id_info_flag = gf_bs_read_int(bs, 1);\n\t\tptr->num_subpic_ref_idx = gf_bs_read_int(bs, 15);\n\t\t*total_bytes = 2;\n\t\tptr->subp_track_ref_idx = gf_malloc(sizeof(u16) * ptr->num_subpic_ref_idx);\n\t\tif (!ptr->subp_track_ref_idx) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->num_subpic_ref_idx; i++) {\n\t\t\tptr->subp_track_ref_idx[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\tif (ptr->subpic_id_info_flag) {\n\t\t\tptr->spinfo.subpic_id_len_minus1 = gf_bs_read_int(bs, 4);\n\t\t\tptr->spinfo.subpic_id_bit_pos = gf_bs_read_int(bs, 12);\n\t\t\tptr->spinfo.start_code_emul_flag = gf_bs_read_int(bs, 1);\n\t\t\tptr->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (ptr->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 6);\n\t\t\t} else {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 4);\n\t\t\t\tgf_bs_read_int(bs, 2);\n\t\t\t}\n\t\t\t*total_bytes += 3;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureLayoutMapEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->groupID_info_4cc = gf_bs_read_u32(bs);\n\t\tptr->nb_entries = 1 + gf_bs_read_u16(bs);\n\t\t*total_bytes = 6;\n\t\tptr->groupIDs = gf_malloc(sizeof(u16) * ptr->nb_entries);\n\t\tif (!ptr->groupIDs) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tptr->groupIDs[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase 0:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] sgpd entry null grouping_type is invalid\\n\") );\n\t\treturn NULL;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!entry_size && !null_size_ok) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\\n\", gf_4cc_to_str( grouping_type) ));\n\t\treturn NULL;\n\t}\n\tGF_SAFEALLOC(def_ptr, GF_DefaultSampleGroupDescriptionEntry);\n\tif (!def_ptr) return NULL;\n\tif (entry_size) {\n\t\tdef_ptr->length = entry_size;\n\t\tdef_ptr->data = (u8 *) gf_malloc(sizeof(u8)*def_ptr->length);\n\t\tif (!def_ptr->data) {\n\t\t\tgf_free(def_ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tgf_bs_read_data(bs, (char *) def_ptr->data, def_ptr->length);\n\t\t*total_bytes = entry_size;\n\t}\n\treturn def_ptr;\n}\n\nvoid sgpd_del_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_free(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tif (seig->key_info) gf_free(seig->key_info);\n\t\tgf_free(entry);\n\t}\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_del_entry(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_del_entry(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *)entry;\n\t\tif (spor->subp_track_ref_idx) gf_free(spor->subp_track_ref_idx);\n\t\tgf_free(spor);\n\t}\n\t\treturn;\n\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\tif (sulm->groupIDs) gf_free(sulm->groupIDs);\n\t\tgf_free(sulm);\n\t\treturn;\n\t}\n\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->data) gf_free(ptr->data);\n\t\tgf_free(ptr);\n\t}\n\t}\n}\n\nvoid sgpd_write_entry(u32 grouping_type, void *entry, GF_BitStream *bs)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\tgf_bs_write_int(bs, ((GF_RollRecoveryEntry*)entry)->roll_distance, 16);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known, 1);\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->dependent_flag, 1);\n\t\tgf_bs_write_int(bs, 0, 3);\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->SAP_type, 4);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\tgf_bs_write_int(bs, 0, 2);\n\t\tgf_bs_write_int(bs, ((GF_SYNCEntry*)entry)->NALU_type, 6);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\tgf_bs_write_int(bs, ((GF_TemporalLevelEntry*)entry)->level_independently_decodable, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tBool use_mkey = seig->key_info[0];\n\t\tu32 nb_keys = 1;\n\t\tif (use_mkey) {\n\t\t\tnb_keys = seig->key_info[1];\n\t\t\tnb_keys<<=8;\n\t\t\tnb_keys |= seig->key_info[2];\n\t\t}\n\t\tgf_bs_write_int(bs, use_mkey ? 1 : 0, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, seig->crypt_byte_block, 4);\n\t\tgf_bs_write_int(bs, seig->skip_byte_block, 4);\n\t\tgf_bs_write_u8(bs, seig->IsProtected);\n\t\tif (nb_keys>1) {\n\t\t\tgf_bs_write_data(bs, seig->key_info+1, seig->key_info_size-1);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, seig->key_info+3, seig->key_info_size - 3);\n\t\t}\n\t}\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_write_entry(entry, bs);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_write_entry(entry, bs);\n\t\treturn;\n\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *) entry;\n\t\tgf_bs_write_int(bs, spor->subpic_id_info_flag, 1);\n\t\tgf_bs_write_int(bs, spor->num_subpic_ref_idx, 15);\n\t\tfor (i=0; i<spor->num_subpic_ref_idx; i++) {\n\t\t\tgf_bs_write_u16(bs, spor->subp_track_ref_idx[i]);\n\t\t}\n\t\tif (spor->subpic_id_info_flag) {\n\t\t\tgf_bs_write_int(bs, spor->spinfo.subpic_id_len_minus1, 4);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.subpic_id_bit_pos, 12);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.start_code_emul_flag, 1);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.pps_sps_subpic_id_flag, 1);\n\t\t\tif (spor->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tgf_bs_write_int(bs, spor->spinfo.xps_id, 6);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, spor->spinfo.xps_id, 4);\n\t\t\t\tgf_bs_write_int(bs, 0, 2);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\tgf_bs_write_u32(bs, sulm->groupID_info_4cc);\n\t\tgf_bs_write_u16(bs, sulm->nb_entries - 1);\n\t\tfor (i=0; i<sulm->nb_entries; i++) {\n\t\t\tgf_bs_write_u16(bs, sulm->groupIDs[i]);\n\t\t}\n\t\treturn;\n\t}\n\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->length)\n\t\t\tgf_bs_write_data(bs, (char *) ptr->data, ptr->length);\n\t}\n\t}\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nstatic u32 sgpd_size_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\treturn 1;\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\treturn 20;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\treturn 0;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tBool use_mkey = seig->key_info[0] ? GF_TRUE : GF_FALSE;\n\t\tif (use_mkey) {\n\t\t\treturn 3 + seig->key_info_size-1;\n\t\t}\n\t\treturn seig->key_info_size; //== 3 + (seig->key_info_size-3);\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\treturn gf_isom_oinf_size_entry(entry);\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\treturn gf_isom_linf_size_entry(entry);\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *)entry;\n\t\tu32 s = 2 + 2*spor->num_subpic_ref_idx;\n\t\tif (spor->subpic_id_info_flag) {\n\t\t\ts += 3;\n\t\t}\n\t\treturn s;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\treturn 6 + 2*sulm->nb_entries;\n\t}\n\n\tdefault:\n\t\treturn ((GF_DefaultSampleGroupDescriptionEntry *)entry)->length;\n\t}\n}\n#endif\n\nGF_Box *sgpd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupDescriptionBox, GF_ISOM_BOX_TYPE_SGPD);\n\t/*version 0 is deprecated, use v1 by default*/\n\ttmp->version = 1;\n\ttmp->group_descriptions = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid sgpd_box_del(GF_Box *a)\n{\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)a;\n\twhile (gf_list_count(p->group_descriptions)) {\n\t\tvoid *ptr = gf_list_last(p->group_descriptions);\n\t\tsgpd_del_entry(p->grouping_type, ptr);\n\t\tgf_list_rem_last(p->group_descriptions);\n\t}\n\tgf_list_del(p->group_descriptions);\n\tgf_free(p);\n}\n\nGF_Err sgpd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry_count;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tISOM_DECREASE_SIZE(p, 8);\n\tp->grouping_type = gf_bs_read_u32(bs);\n\n\tif (p->version>=1) {\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t\tp->default_length = gf_bs_read_u32(bs);\n\t}\n\tif (p->version>=2) {\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t\tp->default_description_index = gf_bs_read_u32(bs);\n\t}\n\tentry_count = gf_bs_read_u32(bs);\n\n\tif (entry_count>p->size)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\twhile (entry_count) {\n\t\tvoid *ptr;\n\t\tu32 parsed_bytes=0;\n\t\tu32 size = p->default_length;\n\t\tif ((p->version>=1) && !size) {\n\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(p, 4);\n\t\t}\n\t\tptr = sgpd_parse_entry(p->grouping_type, bs, (s32) p->size, size, &parsed_bytes);\n\t\t//don't return an error, just stop parsing so that we skip over the sgpd box\n\t\tif (!ptr) return GF_OK;\n\t\tgf_list_add(p->group_descriptions, ptr);\n\n\t\tISOM_DECREASE_SIZE(p, parsed_bytes);\n\t\tentry_count--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sgpd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, nb_descs;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\tGF_Err e;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version>=1) gf_bs_write_u32(bs, p->default_length);\n\tif (p->version>=2) gf_bs_write_u32(bs, p->default_description_index);\n\tnb_descs = gf_list_count(p->group_descriptions);\n\tgf_bs_write_u32(bs, nb_descs);\n\n\tfor (i=0; i<nb_descs; i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tif ((p->version >= 1) && !p->default_length) {\n\t\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\t\tgf_bs_write_u32(bs, size);\n\t\t}\n\t\tsgpd_write_entry(p->grouping_type, ptr, bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sgpd_box_size(GF_Box *s)\n{\n\tu32 i, nb_descs;\n\tBool use_def_size = GF_TRUE;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tp->size += 8;\n\n\t//we force all sample groups to version 1, v0 being deprecated\n\tif (!p->version)\n\t\tp->version = 1;\n\tp->size += 4;\n\n\tif (p->version>=2)\n\t\tp->size += 4;\n\tp->default_length = 0;\n\n\tnb_descs = gf_list_count(p->group_descriptions);\n\tfor (i=0; i<nb_descs; i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\tp->size += size;\n\t\tif (use_def_size && !p->default_length) {\n\t\t\tp->default_length = size;\n\t\t} else if (p->default_length != size) {\n\t\t\tuse_def_size = GF_FALSE;\n\t\t\tp->default_length = 0;\n\t\t}\n\t}\n\tif (p->version>=1) {\n\t\tif (!p->default_length) p->size += nb_descs * 4;\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid saiz_box_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info_size) gf_free(ptr->sample_info_size);\n\tgf_free(ptr);\n}\n\n\nGF_Err saiz_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 5);\n\tptr->default_sample_info_size = gf_bs_read_u8(bs);\n\tptr->sample_count = gf_bs_read_u32(bs);\n\n\tif (ptr->default_sample_info_size == 0) {\n\t\tif (ptr->size < ptr->sample_count)\n\t\t    return GF_ISOM_INVALID_FILE;\n\n\t\tptr->sample_info_size = gf_malloc(sizeof(u8)*ptr->sample_count);\n\t\tptr->sample_alloc = ptr->sample_count;\n\t\tif (!ptr->sample_info_size)\n\t\t    return GF_OUT_OF_MEM;\n\n\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count);\n\t\tgf_bs_read_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saiz_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoSizeBox, GF_ISOM_BOX_TYPE_SAIZ);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saiz_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\tgf_bs_write_u8(bs, ptr->default_sample_info_size);\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\tif (!ptr->default_sample_info_size) {\n\t\tif (!ptr->sample_info_size)\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\telse\n\t\t\tgf_bs_write_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saiz_box_size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox *ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 5;\n\tif (ptr->default_sample_info_size==0)  ptr->size += ptr->sample_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nvoid saio_box_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tif (ptr->cached_data) gf_free(ptr->cached_data);\n\tgf_free(ptr);\n}\n\n\nGF_Err saio_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *)s;\n\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->entry_count = gf_bs_read_u32(bs);\n\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\tif (ptr->size / (ptr->version == 0 ? 4 : 8) < ptr->entry_count || (u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(u64))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tptr->offsets = gf_malloc(sizeof(u64)*ptr->entry_count);\n\t\tif (!ptr->offsets)\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tptr->entry_alloc = ptr->entry_count;\n\t\tif (ptr->version==0) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets[i] = gf_bs_read_u32(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets[i] = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saio_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoOffsetBox, GF_ISOM_BOX_TYPE_SAIO);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saio_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\n\n\tgf_bs_write_u32(bs, ptr->entry_count);\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\tif (ptr->sai_data) {\n\t\t\tif (ptr->sai_data->sai_offset) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) ptr->sai_data->sai_offset);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_u64(bs, ptr->sai_data->sai_offset);\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tptr->sai_data->saio_box = ptr;\n\t\t}\n\n\t\t//store position in bitstream before writing data - offsets can be NULL if a single offset is rewritten later on (cf senc_box_write)\n\t\tptr->offset_first_offset_field = gf_bs_get_position(bs);\n\t\tif (ptr->version==0) {\n\t\t\tif (!ptr->offsets) {\n\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) ptr->offsets[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ptr->offsets) {\n\t\t\t\tgf_bs_write_u64(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u64(bs, ptr->offsets[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saio_box_size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 4;\n\t//a little optim here: in cenc, the saio always points to a single data block, only one entry is needed\n\tswitch (ptr->aux_info_type) {\n\tcase GF_ISOM_CENC_SCHEME:\n\tcase GF_ISOM_CBC_SCHEME:\n\tcase GF_ISOM_CENS_SCHEME:\n\tcase GF_ISOM_CBCS_SCHEME:\n\t\tif (ptr->offsets) gf_free(ptr->offsets);\n\t\tptr->offsets = NULL;\n\t\tptr->entry_alloc = 0;\n\t\tptr->entry_count = 1;\n\t\tbreak;\n\t}\n\n\tptr->size += ((ptr->version==1) ? 8 : 4) * ptr->entry_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nvoid prft_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err prft_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tptr->refTrackID = gf_bs_read_u32(bs);\n\tptr->ntp = gf_bs_read_u64(bs);\n\tif (ptr->version==0) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->timestamp = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->timestamp = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *prft_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProducerReferenceTimeBox, GF_ISOM_BOX_TYPE_PRFT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err prft_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->refTrackID);\n\tgf_bs_write_u64(bs, ptr->ntp);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->timestamp);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->timestamp);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err prft_box_size(GF_Box *s)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox*)s;\n\n\tptr->size += 4+8+ (ptr->version ? 8 : 4);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *trgr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupBox, GF_ISOM_BOX_TYPE_TRGR);\n\ttmp->groups = gf_list_new();\n\tif (!tmp->groups) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgr_box_del(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->groups);\n\tgf_free(ptr);\n}\n\n\nGF_Err trgr_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\n\tBOX_FIELD_LIST_ASSIGN(groups)\n\treturn gf_list_add(ptr->groups, a);\n}\n\n\nGF_Err trgr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trgr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err trgr_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *) s;\n\tgf_isom_check_position_list(s, ptr->groups, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *trgt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgt_box_del(GF_Box *s)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err trgt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->track_group_id = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trgt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->group_type == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\ts->type = ptr->group_type;\n\te = gf_isom_full_box_write(s, bs);\n\ts->type = GF_ISOM_BOX_TYPE_TRGT;\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->track_group_id);\n\treturn GF_OK;\n}\n\nGF_Err trgt_box_size(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\n\tptr->size+= 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *stvi_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_StereoVideoBox, GF_ISOM_BOX_TYPE_STVI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid stvi_box_del(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->stereo_indication_type) gf_free(ptr->stereo_indication_type);\n\tgf_free(ptr);\n}\n\nGF_Err stvi_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tgf_bs_read_int(bs, 30);\n\tptr->single_view_allowed = gf_bs_read_int(bs, 2);\n\tptr->stereo_scheme = gf_bs_read_u32(bs);\n\tptr->sit_len = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, ptr->sit_len);\n\n\tptr->stereo_indication_type = gf_malloc(sizeof(char)*ptr->sit_len);\n\tif (!ptr->stereo_indication_type) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stvi_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, 0, 30);\n\tgf_bs_write_int(bs, ptr->single_view_allowed, 2);\n\tgf_bs_write_u32(bs, ptr->stereo_scheme);\n\tgf_bs_write_u32(bs, ptr->sit_len);\n\tgf_bs_write_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\n\treturn GF_OK;\n}\n\nGF_Err stvi_box_size(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tptr->size+= 12 + ptr->sit_len;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fiin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDItemInformationBox, GF_ISOM_BOX_TYPE_FIIN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fiin_box_del(GF_Box *s)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->partition_entries) gf_list_del(ptr->partition_entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err fiin_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_PAEN:\n\t\tBOX_FIELD_LIST_ASSIGN(partition_entries)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SEGR:\n\t\tBOX_FIELD_ASSIGN(session_info, FDSessionGroupBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_GITN:\n\t\tBOX_FIELD_ASSIGN(group_id_to_name, GroupIdToNameBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fiin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_u16(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fiin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, gf_list_count(ptr->partition_entries) );\n\treturn GF_OK;\n}\n\nGF_Err fiin_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\ts->size+= 2;\n\tgf_isom_check_position_list(s, ptr->partition_entries, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *paen_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDPartitionEntryBox, GF_ISOM_BOX_TYPE_PAEN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid paen_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err paen_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FPAR:\n\t\tBOX_FIELD_ASSIGN(blocks_and_symbols, FilePartitionBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FECR:\n\t\tBOX_FIELD_ASSIGN(FEC_symbol_locations, FECReservoirBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FIRE:\n\t\tBOX_FIELD_ASSIGN(File_symbol_locations, FileReservoirBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err paen_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err paen_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tif (!s) return GF_BAD_PARAM;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err paen_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *fpar_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FilePartitionBox, GF_ISOM_BOX_TYPE_FPAR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fpar_box_del(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->scheme_specific_info) gf_free(ptr->scheme_specific_info);\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err gf_isom_read_null_terminated_string(GF_Box *s, GF_BitStream *bs, u64 size, char **out_str)\n{\n\tu32 len=10;\n\tu32 i=0;\n\n\t*out_str = gf_malloc(sizeof(char)*len);\n\tif (! *out_str) return GF_OUT_OF_MEM;\n\n\tif (!s->size) {\n\t\t*out_str[0] = 0;\n\t\treturn GF_OK;\n\t}\n\n\twhile (1) {\n\t\tISOM_DECREASE_SIZE(s, 1 );\n\t\t(*out_str)[i] = gf_bs_read_u8(bs);\n\t\tif (!(*out_str)[i]) break;\n\t\ti++;\n\t\tif (i==len) {\n\t\t\tlen += 10;\n\t\t\t*out_str = gf_realloc(*out_str, sizeof(char)*len);\n\t\t}\n\t\tif (gf_bs_available(bs) == 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] missing null character in null terminated string\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (i >= size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] string bigger than container, probably missing null character\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, ((ptr->version ? 4 : 2) + 12) );\n\tptr->itemID = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tptr->packet_payload_size = gf_bs_read_u16(bs);\n\tgf_bs_read_u8(bs);\n\tptr->FEC_encoding_ID = gf_bs_read_u8(bs);\n\tptr->FEC_instance_ID = gf_bs_read_u16(bs);\n\tptr->max_source_block_length = gf_bs_read_u16(bs);\n\tptr->encoding_symbol_length = gf_bs_read_u16(bs);\n\tptr->max_number_of_encoding_symbols = gf_bs_read_u16(bs);\n\n\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_specific_info);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tif (ptr->nb_entries > ptr->size / 6 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(FilePartitionEntry))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * 6 );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FilePartitionEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].block_count = gf_bs_read_u16(bs);\n\t\tptr->entries[i].block_size = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fpar_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFilePartitionBox *ptr = (FilePartitionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->itemID, ptr->version ? 32 : 16);\n\tgf_bs_write_u16(bs, ptr->packet_payload_size);\n\tgf_bs_write_u8(bs, 0);\n\tgf_bs_write_u8(bs, ptr->FEC_encoding_ID);\n\tgf_bs_write_u16(bs, ptr->FEC_instance_ID);\n\tgf_bs_write_u16(bs, ptr->max_source_block_length);\n\tgf_bs_write_u16(bs, ptr->encoding_symbol_length);\n\tgf_bs_write_u16(bs, ptr->max_number_of_encoding_symbols);\n\tif (ptr->scheme_specific_info) {\n\t\tgf_bs_write_data(bs, ptr->scheme_specific_info, (u32)strlen(ptr->scheme_specific_info) );\n\t}\n\t//null terminated string\n\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->entries[i].block_count);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].block_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_box_size(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tptr->size += 13 + (ptr->version ? 8 : 4);\n\tif (ptr->scheme_specific_info)\n\t\tptr->size += strlen(ptr->scheme_specific_info);\n\n\tptr->size+= ptr->nb_entries * 6;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *fecr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FECReservoirBox, GF_ISOM_BOX_TYPE_FECR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fecr_box_del(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err fecr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\n\tif (ptr->nb_entries > ptr->size / (ptr->version ? 8 : 6) || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(FECReservoirEntry) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in fecr\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * (ptr->version ? 8 : 6) );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FECReservoirEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].item_id = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\t\tptr->entries[i].symbol_count = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fecr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].item_id, ptr->version ? 32 : 16);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].symbol_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fecr_box_size(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tptr->size += (ptr->version ? 4 : 2) +  ptr->nb_entries * (ptr->version ? 8 : 6);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *segr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid segr_box_del(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tif (ptr->session_groups[i].group_ids) gf_free(ptr->session_groups[i].group_ids);\n\t\tif (ptr->session_groups[i].channels) gf_free(ptr->session_groups[i].channels);\n\t}\n\tif (ptr->session_groups) gf_free(ptr->session_groups);\n\tgf_free(ptr);\n}\n\nGF_Err segr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->num_session_groups = gf_bs_read_u16(bs);\n\tif (ptr->size < ptr->num_session_groups) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in segr\\n\", ptr->num_session_groups));\n\t\tptr->num_session_groups = 0;\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->session_groups, ptr->num_session_groups, SessionGroupEntry);\n\tif (!ptr->session_groups) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->session_groups[i].nb_groups = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\n\t\tISOM_DECREASE_SIZE(ptr, ptr->session_groups[i].nb_groups*4);\n\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].group_ids, ptr->session_groups[i].nb_groups, u32);\n\t\tif (!ptr->session_groups[i].group_ids) return GF_OUT_OF_MEM;\n\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tptr->session_groups[i].group_ids[k] = gf_bs_read_u32(bs);\n\t\t}\n\n\t\tptr->session_groups[i].nb_channels = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->session_groups[i].nb_channels*4);\n\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].channels, ptr->session_groups[i].nb_channels, u32);\n\t\tif (!ptr->session_groups[i].channels) return GF_OUT_OF_MEM;\n\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tptr->session_groups[i].channels[k] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err segr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tGF_Err e;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->num_session_groups);\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tgf_bs_write_u8(bs, ptr->session_groups[i].nb_groups);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].group_ids[k]);\n\t\t}\n\n\t\tgf_bs_write_u16(bs, ptr->session_groups[i].nb_channels);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].channels[k]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err segr_box_size(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->size += 1 + 4*ptr->session_groups[i].nb_groups;\n\t\tptr->size += 2 + 4*ptr->session_groups[i].nb_channels;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *gitn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GroupIdToNameBox, GF_ISOM_BOX_TYPE_GITN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) {\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t\t}\n\t\tgf_free(ptr->entries);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err gitn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->nb_entries = gf_bs_read_u16(bs);\n\tif (ptr->size / 4 < ptr->nb_entries)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, GroupIdNameEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->entries[i].group_id = gf_bs_read_u32(bs);\n\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->entries[i].name);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gitn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].group_id);\n\t\tif (ptr->entries[i].name) gf_bs_write_data(bs, ptr->entries[i].name, (u32)strlen(ptr->entries[i].name) );\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gitn_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->entries[i].name) ptr->size += strlen(ptr->entries[i].name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nGF_Box *fdpa_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FDpacketBox, GF_ISOM_BOX_TYPE_FDPA);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fdpa_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->headers) {\n\t\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\t\tif (ptr->headers[i].data) gf_free(ptr->headers[i].data);\n\t\t}\n\t\tgf_free(ptr->headers);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err fdpa_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tptr->info.sender_current_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.expected_residual_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.session_close_bit = gf_bs_read_int(bs, 1);\n\tptr->info.object_close_bit = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 4);\n\tptr->info.transport_object_identifier = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->header_ext_count = gf_bs_read_u16(bs);\n\tif (ptr->size / 2 < ptr->header_ext_count) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in fdpa\\n\", ptr->header_ext_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->headers, ptr->header_ext_count, GF_LCTheaderExtension);\n\tif (!ptr->headers) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->headers[i].header_extension_type = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 3);\n\t\t\tgf_bs_read_data(bs, (char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\t\tptr->headers[i].data_length = gf_bs_read_u8(bs);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tptr->headers[i].data_length = 4*ptr->headers[i].data_length - 2;\n\t\t\t\tif (ptr->size < sizeof(char) * ptr->headers[i].data_length)\n\t\t\t\t    return GF_ISOM_INVALID_FILE;\n\t\t\t\tptr->headers[i].data = gf_malloc(sizeof(char) * ptr->headers[i].data_length);\n\t\t\t\tif (!ptr->headers[i].data) return GF_OUT_OF_MEM;\n\n\t\t\t\tISOM_DECREASE_SIZE(ptr, ptr->headers[i].data_length);\n\t\t\t\tgf_bs_read_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdpa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->info.sender_current_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.expected_residual_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.session_close_bit, 1);\n\tgf_bs_write_int(bs, ptr->info.object_close_bit, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_u16(bs, ptr->info.transport_object_identifier);\n\tgf_bs_write_u16(bs, ptr->header_ext_count);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tgf_bs_write_u8(bs, ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_write_data(bs, (const char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, ptr->headers[i].data_length ? (ptr->headers[i].data_length+2)/4 : 0);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tgf_bs_write_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdpa_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tptr->size += 5;\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->size += 1;\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tptr->size += 3;\n\t\t} else {\n\t\t\tptr->size += 1 + ptr->headers[i].data_length;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *extr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ExtraDataBox, GF_ISOM_BOX_TYPE_EXTR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid extr_box_del(GF_Box *s)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->feci) gf_isom_box_del((GF_Box*)ptr->feci);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err extr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\n\te = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);\n\tif (e) return e;\n\tif (!ptr->feci || ptr->feci->size > ptr->size) return GF_ISOM_INVALID_MEDIA;\n\tptr->data_length = (u32) (ptr->size - ptr->feci->size);\n\tptr->data = gf_malloc(sizeof(char)*ptr->data_length);\n\tif (!ptr->data) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->data, ptr->data_length);\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err extr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tif (ptr->feci) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->feci, bs);\n\t\tif (e) return e;\n\t}\n\tgf_bs_write_data(bs, ptr->data, ptr->data_length);\n\treturn GF_OK;\n}\n\nGF_Err extr_box_size(GF_Box *s)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\tptr->size += ptr->data_length;\n\tif (ptr->feci) {\n\t\tGF_Err e = gf_isom_box_size((GF_Box*)ptr->feci);\n\t\tif (e) return e;\n\t\tptr->size += ptr->feci->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fdsa_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintSample, GF_ISOM_BOX_TYPE_FDSA);\n\tif (!tmp) return NULL;\n\ttmp->packetTable = gf_list_new();\n\ttmp->hint_subtype = GF_ISOM_BOX_TYPE_FDP_STSD;\n\treturn (GF_Box*)tmp;\n}\n\nvoid fdsa_box_del(GF_Box *s)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tgf_list_del(ptr->packetTable);\n\tgf_free(ptr);\n}\n\nGF_Err fdsa_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FDPA:\n\t\tBOX_FIELD_LIST_ASSIGN(packetTable)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_EXTR:\n\t\tBOX_FIELD_ASSIGN(extra_data, GF_ExtraDataBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\nGF_Err fdsa_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdsa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintSample *ptr = (GF_HintSample *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\te = gf_isom_box_array_write(s, ptr->packetTable, bs);\n\tif (e) return e;\n\tif (ptr->extra_data) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->extra_data, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdsa_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n\nvoid trik_box_del(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err trik_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->entry_count = (u32) ptr->size;\n\tif ((u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(GF_TrickPlayBoxEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in trik\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->entries = (GF_TrickPlayBoxEntry *) gf_malloc(ptr->entry_count * sizeof(GF_TrickPlayBoxEntry) );\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i< ptr->entry_count; i++) {\n\t\tptr->entries[i].pic_type = gf_bs_read_int(bs, 2);\n\t\tptr->entries[i].dependency_level = gf_bs_read_int(bs, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trik_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrickPlayBox, GF_ISOM_BOX_TYPE_TRIK);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trik_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i=0; i < ptr->entry_count; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].pic_type, 2);\n\t\tgf_bs_write_int(bs, ptr->entries[i].dependency_level, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err trik_box_size(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->size += 8 * ptr->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid bloc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err bloc_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->baseLocation, 256);\n\tptr->baseLocation[256]=0;\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->basePurlLocation, 256);\n\tISOM_DECREASE_SIZE(s, 512)\n\tptr->basePurlLocation[256]=0;\n\tgf_bs_skip_bytes(bs, 512);\n\treturn GF_OK;\n}\n\nGF_Box *bloc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_BaseLocationBox, GF_ISOM_BOX_TYPE_BLOC);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err bloc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (const char *) ptr->baseLocation, 256);\n\tgf_bs_write_data(bs, (const char *) ptr->basePurlLocation, 256);\n\tfor (i=0; i < 64; i++ ) {\n\t\tgf_bs_write_u64(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err bloc_box_size(GF_Box *s)\n{\n\ts->size += 1024;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ainf_box_del(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\tif (ptr->APID) gf_free(ptr->APID);\n\tgf_free(s);\n}\n\nGF_Err ainf_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 4)\n\tptr->profile_version = gf_bs_read_u32(bs);\n\treturn gf_isom_read_null_terminated_string(s, bs, s->size, &ptr->APID);\n}\n\nGF_Box *ainf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AssetInformationBox, GF_ISOM_BOX_TYPE_AINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ainf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->profile_version);\n    if (ptr->APID)\n        gf_bs_write_data(bs, ptr->APID, (u32) strlen(ptr->APID) );\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err ainf_box_size(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n    s->size += 4 + (ptr->APID ? strlen(ptr->APID) : 0 ) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mhac_box_del(GF_Box *s)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\tif (ptr->mha_config) gf_free(ptr->mha_config);\n\tgf_free(s);\n}\n\nGF_Err mhac_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 5)\n\tptr->configuration_version = gf_bs_read_u8(bs);\n\tptr->mha_pl_indication = gf_bs_read_u8(bs);\n\tptr->reference_channel_layout = gf_bs_read_u8(bs);\n\tptr->mha_config_size = gf_bs_read_u16(bs);\n\tif (ptr->mha_config_size) {\n\t\tISOM_DECREASE_SIZE(s, ptr->mha_config_size)\n\n\t\tptr->mha_config = gf_malloc(sizeof(char)*ptr->mha_config_size);\n\t\tif (!ptr->mha_config) return GF_OUT_OF_MEM;\n\n\t\tgf_bs_read_data(bs, ptr->mha_config, ptr->mha_config_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mhac_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MHAConfigBox, GF_ISOM_BOX_TYPE_MHAC);\n\ttmp->configuration_version = 1;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mhac_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->configuration_version);\n\tgf_bs_write_u8(bs, ptr->mha_pl_indication);\n\tgf_bs_write_u8(bs, ptr->reference_channel_layout);\n\tgf_bs_write_u16(bs, ptr->mha_config ? ptr->mha_config_size : 0);\n\tif (ptr->mha_config && ptr->mha_config_size)\n\t\tgf_bs_write_data(bs, ptr->mha_config, ptr->mha_config_size);\n\n\treturn GF_OK;\n}\n\nGF_Err mhac_box_size(GF_Box *s)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\ts->size += 5;\n\tif (ptr->mha_config_size && ptr->mha_config) s->size += ptr->mha_config_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mhap_box_del(GF_Box *s)\n{\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\tif (ptr->compat_profiles) gf_free(ptr->compat_profiles);\n\tgf_free(s);\n}\n\nGF_Err mhap_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->num_profiles = gf_bs_read_u8(bs);\n\tif (!ptr->num_profiles) return GF_OK;\n\n\tISOM_DECREASE_SIZE(s, ptr->num_profiles)\n\tptr->compat_profiles = gf_malloc(sizeof(u8) * ptr->num_profiles);\n\tif (!ptr->compat_profiles) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->num_profiles; i++) {\n\t\tptr->compat_profiles[i] = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mhap_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MHACompatibleProfilesBox, GF_ISOM_BOX_TYPE_MHAP);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mhap_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->num_profiles);\n\tfor (i=0; i<ptr->num_profiles; i++) {\n\t\tgf_bs_write_u8(bs, ptr->compat_profiles[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mhap_box_size(GF_Box *s)\n{\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\ts->size += 1 + ptr->num_profiles;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid jp2h_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err jp2h_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_J2KHeaderBox *ptr = (GF_J2KHeaderBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_IHDR:\n\t\tBOX_FIELD_ASSIGN(ihdr, GF_J2KImageHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_COLR:\n\t\tBOX_FIELD_ASSIGN(colr, GF_ColourInformationBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\nGF_Err jp2h_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *jp2h_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_J2KHeaderBox, GF_ISOM_BOX_TYPE_JP2H);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err jp2h_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err jp2h_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid ihdr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err ihdr_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_J2KImageHeaderBox *ptr = (GF_J2KImageHeaderBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 14)\n\n\tptr->height = gf_bs_read_u32(bs);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->nb_comp = gf_bs_read_u16(bs);\n\tptr->bpc = gf_bs_read_u8(bs);\n\tptr->Comp = gf_bs_read_u8(bs);\n\tptr->UnkC = gf_bs_read_u8(bs);\n\tptr->IPR = gf_bs_read_u8(bs);\n\n\treturn GF_OK;\n}\n\nGF_Box *ihdr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_J2KImageHeaderBox, GF_ISOM_BOX_TYPE_IHDR);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ihdr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_J2KImageHeaderBox *ptr = (GF_J2KImageHeaderBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->height);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u16(bs, ptr->nb_comp);\n\tgf_bs_write_u8(bs, ptr->bpc);\n\tgf_bs_write_u8(bs, ptr->Comp);\n\tgf_bs_write_u8(bs, ptr->UnkC);\n\tgf_bs_write_u8(bs, ptr->IPR);\n\treturn GF_OK;\n}\n\nGF_Err ihdr_box_size(GF_Box *s)\n{\n\ts->size += 14;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* Dolby Vision */\n\nGF_Box *dvcC_box_new()\n{\n\tGF_DOVIConfigurationBox *tmp = (GF_DOVIConfigurationBox *)gf_malloc(sizeof(GF_DOVIConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_DOVIConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_DVCC;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dvcC_box_del(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err dvcC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *)s;\n\n\t//GF_DOVIDecoderConfigurationRecord\n\tISOM_DECREASE_SIZE(ptr, 24)\n\tptr->DOVIConfig.dv_version_major = gf_bs_read_u8(bs);\n\tptr->DOVIConfig.dv_version_minor = gf_bs_read_u8(bs);\n\tptr->DOVIConfig.dv_profile = gf_bs_read_int(bs, 7);\n\tptr->DOVIConfig.dv_level = gf_bs_read_int(bs, 6);\n\tptr->DOVIConfig.rpu_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.el_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.bl_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.dv_bl_signal_compatibility_id = gf_bs_read_int(bs, 4);\n\tif (gf_bs_read_int(bs, 28) != 0)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC reserved bits are not zero\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (gf_bs_read_u32(bs) != 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC reserved bits are not zero\\n\"));\n\t\t}\n\t}\n\tswitch (ptr->DOVIConfig.dv_bl_signal_compatibility_id) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 6:\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC compatibility ID %d is not valid (only 0, 1, 2, 4 or 6 defined), patching to 0\\n\", ptr->DOVIConfig.dv_bl_signal_compatibility_id));\n\t\tptr->DOVIConfig.dv_bl_signal_compatibility_id = 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dvcC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t//GF_DOVIDecoderConfigurationRecord\n\tgf_bs_write_u8(bs,  ptr->DOVIConfig.dv_version_major);\n\tgf_bs_write_u8(bs,  ptr->DOVIConfig.dv_version_minor);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_profile, 7);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_level, 6);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.rpu_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.el_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.bl_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_bl_signal_compatibility_id, 4);\n\tgf_bs_write_int(bs, 0, 28);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\n\treturn GF_OK;\n}\n\nGF_Err dvcC_box_size(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *)s;\n\n\tptr->size += 24;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dvvC_box_new()\n{\n\tGF_DOVIConfigurationBox *tmp = (GF_DOVIConfigurationBox *)gf_malloc(sizeof(GF_DOVIConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_DOVIConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_DVVC;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dvvC_box_del(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err dvvC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn dvcC_box_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dvvC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn dvcC_box_write(s, bs);\n}\n\nGF_Err dvvC_box_size(GF_Box *s)\n{\n\treturn dvcC_box_size(s);\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *dOps_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OpusSpecificBox, GF_ISOM_BOX_TYPE_DOPS);\n\treturn (GF_Box *)tmp;\n}\n\nvoid dOps_box_del(GF_Box *s)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (ptr) gf_free(ptr);\n}\n\n//we don't use odf_opus_cfg read due to endianness\nGF_Err dOps_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tptr->opcfg.version = gf_bs_read_u8(bs);\n\tif (ptr->opcfg.version) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Opus config version not 0 !\\n\", ptr->size));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\t//force version to 1 as used in ogg/opus\n\tptr->opcfg.version = 1;\n\tptr->opcfg.OutputChannelCount = gf_bs_read_u8(bs);\n\tptr->opcfg.PreSkip = gf_bs_read_u16(bs);\n\tptr->opcfg.InputSampleRate = gf_bs_read_u32(bs);\n\tptr->opcfg.OutputGain = gf_bs_read_u16(bs);\n\tptr->opcfg.ChannelMappingFamily = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, 11)\n\tif (ptr->size) {\n\t\tISOM_DECREASE_SIZE(ptr, 2+ptr->opcfg.OutputChannelCount);\n\t\tptr->opcfg.StreamCount = gf_bs_read_u8(bs);\n\t\tptr->opcfg.CoupledCount = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *) ptr->opcfg.ChannelMapping, ptr->opcfg.OutputChannelCount);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n//we don't use odf_opus_cfg write due to endianness\nGF_Err dOps_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//we always write 0 - the version may also be set to 1 when fed from ffenc or opus+ogg\n\tgf_bs_write_u8(bs, /*ptr->opcfg.version*/ 0);\n\tgf_bs_write_u8(bs, ptr->opcfg.OutputChannelCount);\n\tgf_bs_write_u16(bs, ptr->opcfg.PreSkip);\n\tgf_bs_write_u32(bs, ptr->opcfg.InputSampleRate);\n\tgf_bs_write_u16(bs, ptr->opcfg.OutputGain);\n\tgf_bs_write_u8(bs, ptr->opcfg.ChannelMappingFamily);\n\tif (ptr->opcfg.ChannelMappingFamily) {\n\t\tgf_bs_write_u8(bs, ptr->opcfg.StreamCount);\n\t\tgf_bs_write_u8(bs, ptr->opcfg.CoupledCount);\n\t\tgf_bs_write_data(bs, (char *) ptr->opcfg.ChannelMapping, ptr->opcfg.OutputChannelCount);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dOps_box_size(GF_Box *s)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tptr->size += 11;\n\tif (ptr->opcfg.ChannelMappingFamily)\n\t\tptr->size += 2 + ptr->opcfg.OutputChannelCount;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid dfla_box_del(GF_Box *s)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err dfla_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->dataSize = (u32) ptr->size;\n\tptr->size=0;\n\tptr->data = gf_malloc(ptr->dataSize);\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Box *dfla_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FLACConfigBox, GF_ISOM_BOX_TYPE_DFLA);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dfla_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Err dfla_box_size(GF_Box *s)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid mvcg_box_del(GF_Box *s)\n{\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err mvcg_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tISOM_DECREASE_SIZE(s, 7)\n\tptr->multiview_group_id = gf_bs_read_u32(bs);\n\tptr->num_entries = gf_bs_read_u16(bs);\n\tgf_bs_read_u8(bs);\n\tptr->entries = gf_malloc(ptr->num_entries * sizeof(MVCIEntry));\n\tmemset(ptr->entries, 0, ptr->num_entries * sizeof(MVCIEntry));\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->entries[i].entry_type = gf_bs_read_u8(bs);\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tISOM_DECREASE_SIZE(s, 4)\n\t\t\tptr->entries[i].trackID = gf_bs_read_u32(bs);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tISOM_DECREASE_SIZE(s, 6)\n\t\t\tptr->entries[i].trackID = gf_bs_read_u32(bs);\n\t\t\tptr->entries[i].tierID = gf_bs_read_u16(bs);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tptr->entries[i].output_view_id = gf_bs_read_int(bs, 10);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tISOM_DECREASE_SIZE(s, 4)\n\t\t\tgf_bs_read_int(bs, 6)\t;\n\t\t\tptr->entries[i].start_view_id = gf_bs_read_int(bs, 10);\n\t\t\tptr->entries[i].view_count = gf_bs_read_u16(bs);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mvcg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MultiviewGroupBox, GF_ISOM_BOX_TYPE_MVCG);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mvcg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\n\tgf_bs_write_u32(bs, ptr->multiview_group_id);\n\tgf_bs_write_u16(bs, ptr->num_entries);\n\tgf_bs_write_u8(bs, 0);\n\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tgf_bs_write_u8(bs, ptr->entries[i].entry_type);\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tgf_bs_write_u32(bs, ptr->entries[i].trackID);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgf_bs_write_u32(bs, ptr->entries[i].trackID);\n\t\t\tgf_bs_write_u16(bs, ptr->entries[i].tierID);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgf_bs_write_int(bs, 0, 6);\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].output_view_id, 10);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgf_bs_write_int(bs, 0, 6)\t;\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].start_view_id, 10);\n\t\t\tgf_bs_write_u16(bs, ptr->entries[i].view_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mvcg_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\n\tptr->size += 7;\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tptr->size += 1 + 6;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tptr->size += 1 + 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid vwid_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tif (ptr->views) {\n\t\tfor (i=0; i<ptr->num_views; i++) {\n\t\t\tif (ptr->views[i].view_refs)\n\t\t\t\tgf_free(ptr->views[i].view_refs);\n\t\t}\n\t\tgf_free(ptr->views);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err vwid_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tISOM_DECREASE_SIZE(s, 3)\n\tgf_bs_read_int(bs, 2);\n\tptr->min_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->max_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->num_views = gf_bs_read_u16(bs);\n\tif (ptr->num_views > ptr->size / 6)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->views = gf_malloc(sizeof(ViewIDEntry)*ptr->num_views);\n\tmemset(ptr->views, 0, sizeof(ViewIDEntry)*ptr->num_views);\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tu32 j;\n\t\tISOM_DECREASE_SIZE(s, 6)\n\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_id = gf_bs_read_int(bs, 10);\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_order_index = gf_bs_read_int(bs, 10);\n\t\tptr->views[i].texture_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].texture_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].base_view_type = gf_bs_read_int(bs, 2);\n\t\tptr->views[i].num_ref_views = gf_bs_read_int(bs, 10);\n\n\t\tif (ptr->views[i].num_ref_views > ptr->size / 2)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\n\t\tptr->views[i].view_refs = gf_malloc(sizeof(ViewIDRefViewEntry)*ptr->views[i].num_ref_views);\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 4);\n\t\t\tptr->views[i].view_refs[j].dep_comp_idc = gf_bs_read_int(bs, 2);\n\t\t\tptr->views[i].view_refs[j].ref_view_id = gf_bs_read_int(bs, 10);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *vwid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ViewIdentifierBox, GF_ISOM_BOX_TYPE_VWID);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err vwid_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, 0, 2);\n\tgf_bs_write_int(bs, ptr->min_temporal_id, 3);\n\tgf_bs_write_int(bs, ptr->max_temporal_id, 3);\n\tgf_bs_write_u16(bs, ptr->num_views);\n\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tgf_bs_write_int(bs, 0, 6);\n\t\tgf_bs_write_int(bs, ptr->views[i].view_id, 10);\n\t\tgf_bs_write_int(bs, 0, 6);\n\t\tgf_bs_write_int(bs, ptr->views[i].view_order_index, 10);\n\n\t\tgf_bs_write_int(bs, ptr->views[i].texture_in_stream, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].texture_in_track, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].depth_in_stream, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].depth_in_track, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].base_view_type, 2);\n\t\tgf_bs_write_int(bs, ptr->views[i].num_ref_views, 10);\n\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\tgf_bs_write_int(bs, ptr->views[i].view_refs[j].dep_comp_idc, 2);\n\t\t\tgf_bs_write_int(bs, ptr->views[i].view_refs[j].ref_view_id, 10);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err vwid_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tptr->size += 3;\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tptr->size += 6 + 2 * ptr->views[i].num_ref_views;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid pcmC_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err pcmC_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 2)\n\tptr->format_flags = gf_bs_read_u8(bs);\n\tptr->PCM_sample_size = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\nGF_Box *pcmC_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PCMConfigBox, GF_ISOM_BOX_TYPE_PCMC);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pcmC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->format_flags);\n\tgf_bs_write_u8(bs, ptr->PCM_sample_size);\n\treturn GF_OK;\n}\n\nGF_Err pcmC_box_size(GF_Box *s)\n{\n\ts->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid chnl_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err chnl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->layout.stream_structure = gf_bs_read_u8(bs);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.definedLayout = gf_bs_read_u8(bs);\n\t\tif (ptr->layout.definedLayout) {\n\t\t\tu32 remain = (u32) ptr->size;\n\t\t\tif (ptr->layout.stream_structure & 2) remain--;\n\t\t\tptr->layout.channels_count = 0;\n\t\t\twhile (remain) {\n\t\t\t\tISOM_DECREASE_SIZE(s, 1)\n\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].position = gf_bs_read_u8(bs);\n\t\t\t\tremain--;\n\t\t\t\tif (ptr->layout.layouts[ptr->layout.channels_count].position == 126) {\n\t\t\t\t\tISOM_DECREASE_SIZE(s, 3)\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].azimuth = gf_bs_read_int(bs, 16);\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].elevation = gf_bs_read_int(bs, 8);\n\t\t\t\t\tremain-=3;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(s, 8)\n\t\t\tptr->layout.omittedChannelsMap = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.object_count = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *chnl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChannelLayoutBox, GF_ISOM_BOX_TYPE_CHNL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chnl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->layout.stream_structure);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tgf_bs_write_u8(bs, ptr->layout.definedLayout);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\tgf_bs_write_u8(bs, ptr->layout.layouts[i].position);\n\t\t\t\tif (ptr->layout.layouts[i].position==126) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].azimuth, 16);\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].elevation, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u64(bs, ptr->layout.omittedChannelsMap);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tgf_bs_write_u8(bs, ptr->layout.object_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err chnl_box_size(GF_Box *s)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\ts->size += 1;\n\tif (ptr->layout.stream_structure & 1) {\n\t\ts->size += 1;\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\ts->size+=1;\n\t\t\t\tif (ptr->layout.layouts[i].position==126)\n\t\t\t\t\ts->size+=3;\n\t\t\t}\n\t\t} else {\n\t\t\ts->size += 8;\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\ts->size += 1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *emsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EventMessageBox, GF_ISOM_BOX_TYPE_EMSG);\n\treturn (GF_Box *)tmp;\n}\n\nvoid emsg_box_del(GF_Box *s)\n{\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->scheme_id_uri) gf_free(ptr->scheme_id_uri);\n\tif (ptr->value) gf_free(ptr->value);\n\tif (ptr->message_data) gf_free(ptr->message_data);\n\tgf_free(ptr);\n}\n\nGF_Err emsg_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\tif (ptr->version==0) {\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_id_uri);\n\t\tif (e) return e;\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->value);\n\t\tif (e) return e;\n\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->timescale = gf_bs_read_u32(bs);\n\t\tptr->presentation_time_delta = gf_bs_read_u32(bs);\n\t\tptr->event_duration = gf_bs_read_u32(bs);\n\t\tptr->event_id = gf_bs_read_u32(bs);\n\t} else if (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->timescale = gf_bs_read_u32(bs);\n\t\tptr->presentation_time_delta = gf_bs_read_u64(bs);\n\t\tptr->event_duration = gf_bs_read_u32(bs);\n\t\tptr->event_id = gf_bs_read_u32(bs);\n\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_id_uri);\n\t\tif (e) return e;\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->value);\n\t\tif (e) return e;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\tif (ptr->size) {\n\t\tif (ptr->size>0xFFFFFFFUL) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] emsg message data size too big (\"LLU\") to be loaded\\n\", ptr->size));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tptr->message_data_size = (u32) ptr->size;\n\t\tptr->message_data = gf_malloc(ptr->message_data_size);\n\t\tif (!ptr->message_data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->message_data, ptr->message_data_size);\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err emsg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 len;\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->version==1) {\n\t\tgf_bs_write_u32(bs, ptr->timescale);\n\t\tgf_bs_write_u64(bs, ptr->presentation_time_delta);\n\t\tgf_bs_write_u32(bs, ptr->event_duration);\n\t\tgf_bs_write_u32(bs, ptr->event_id);\n\t}\n\n\tlen = ptr->scheme_id_uri ? (u32) strlen(ptr->scheme_id_uri) : 0;\n\tif (len) gf_bs_write_data(bs, ptr->scheme_id_uri, len);\n\tgf_bs_write_u8(bs, 0);\n\n\tlen = ptr->value ? (u32) strlen(ptr->value) : 0;\n\tif (len) gf_bs_write_data(bs, ptr->value, len);\n\tgf_bs_write_u8(bs, 0);\n\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, ptr->timescale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->presentation_time_delta);\n\t\tgf_bs_write_u32(bs, ptr->event_duration);\n\t\tgf_bs_write_u32(bs, ptr->event_id);\n\t}\n\tif (ptr->message_data)\n\t\tgf_bs_write_data(bs, ptr->message_data, ptr->message_data_size);\n\treturn GF_OK;\n}\n\nGF_Err emsg_box_size(GF_Box *s)\n{\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\tif (ptr->version) {\n\t\tptr->size += 20;\n\t} else {\n\t\tptr->size += 16;\n\t}\n\tptr->size+=2; //1 NULL-terminated strings\n\tif (ptr->scheme_id_uri) ptr->size += strlen(ptr->scheme_id_uri);\n\tif (ptr->value) ptr->size += strlen(ptr->value);\n\tif (ptr->message_data)\n\t\tptr->size += ptr->message_data_size;\n\n\treturn GF_OK;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\n\n\nGF_Box *csgp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompactSampleGroupBox, GF_ISOM_BOX_TYPE_CSGP);\n\treturn (GF_Box *)tmp;\n}\nvoid csgp_box_del(GF_Box *a)\n{\n\tGF_CompactSampleGroupBox *p = (GF_CompactSampleGroupBox *)a;\n\tif (p->patterns) {\n\t\tu32 i;\n\t\tfor (i=0; i<p->pattern_count; i++) {\n\t\t\tif (p->patterns[i].sample_group_description_indices)\n\t\t\t\tgf_free(p->patterns[i].sample_group_description_indices);\n\t\t}\n\t\tgf_free(p->patterns);\n\t}\n\tgf_free(p);\n}\n\nu32 get_size_by_code(u32 code)\n{\n\tif (code==0) return 4;\n\tif (code==1) return 8;\n\tif (code==2) return 16;\n\treturn 32;\n}\nGF_Err csgp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, bits, gidx_mask;\n\tBool index_msb_indicates_fragment_local_description, grouping_type_parameter_present;\n\tu32 pattern_size, scount_size, index_size;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tindex_msb_indicates_fragment_local_description = (ptr->flags & (1<<7)) ? GF_TRUE : GF_FALSE;\n\tgrouping_type_parameter_present = (ptr->flags & (1<<6)) ? GF_TRUE : GF_FALSE;\n\n\tpattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tscount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tindex_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\tif (((pattern_size==4) && (scount_size!=4)) || ((pattern_size!=4) && (scount_size==4))) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern_size and sample_count_size mare not both 4 bits\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tif (grouping_type_parameter_present) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->pattern_count = gf_bs_read_u32(bs);\n\n\n\tif ( (ptr->size / ( (pattern_size + scount_size) / 8 ) < ptr->pattern_count) || (u64)ptr->pattern_count > (u64)SIZE_MAX/sizeof(GF_CompactSampleGroupPattern) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern_count value (%lu) invalid\\n\", ptr->pattern_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->patterns = gf_malloc(sizeof(GF_CompactSampleGroupPattern) * ptr->pattern_count);\n\tif (!ptr->patterns) return GF_OUT_OF_MEM;\n\tmemset(ptr->patterns, 0, sizeof(GF_CompactSampleGroupPattern) * ptr->pattern_count);\n\n\tu64 patterns_sizes=0;\n\tbits = 0;\n\tfor (i=0; i<ptr->pattern_count; i++) {\n\t\tptr->patterns[i].length = gf_bs_read_int(bs, pattern_size);\n\t\tptr->patterns[i].sample_count = gf_bs_read_int(bs, scount_size);\n\t\tbits += pattern_size + scount_size;\n\t\tif (! (bits % 8)) {\n\t\t\tbits/=8;\n\t\t\tISOM_DECREASE_SIZE(ptr, bits);\n\t\t\tbits=0;\n\t\t}\n\t\tpatterns_sizes+=ptr->patterns[i].length;\n\t\tif (patterns_sizes * index_size > ptr->size*8) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern cumulated sizes \"LLU\" larger than box size \"LLU\"\\n\", patterns_sizes, ptr->size));\n\t\t\tptr->patterns[i].sample_group_description_indices = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tif ( (u64)ptr->patterns[i].length > (u64)SIZE_MAX/sizeof(u32) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern #%d value (%lu) invalid\\n\", i, ptr->patterns[i].length));\n\t\t\tptr->patterns[i].sample_group_description_indices = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->patterns[i].sample_group_description_indices = gf_malloc(sizeof(u32) * ptr->patterns[i].length);\n\t\tif (!ptr->patterns[i].sample_group_description_indices) return GF_OUT_OF_MEM;\n\t}\n\tbits = 0;\n\tgidx_mask = ((u32)1) << (index_size-1);\n\tfor (i=0; i<ptr->pattern_count; i++) {\n\t\tu32 j;\n\t\tfor (j=0; j<ptr->patterns[i].length; j++) {\n\t\t\tu32 idx = gf_bs_read_int(bs, index_size);\n\t\t\tif (index_msb_indicates_fragment_local_description) {\n\t\t\t\t//MSB set, this is a index of a group described in the fragment\n\t\t\t\tif (idx & gidx_mask) {\n\t\t\t\t\tidx += 0x10000;\n\t\t\t\t\tidx &= ~gidx_mask;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->patterns[i].sample_group_description_indices[j] = idx;\n\t\t\tbits += index_size;\n\n\t\t\tif (! (bits % 8)) {\n\t\t\t\tbits/=8;\n\t\t\t\tISOM_DECREASE_SIZE(ptr, bits);\n\t\t\t\tbits=0;\n\t\t\t}\n\t\t}\n\t}\n\tif (bits)\n\t\tgf_bs_align(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err csgp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox*)s;\n\tu32 pattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tu32 scount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tu32 index_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_int(bs, ptr->flags, 24);\n\tgf_bs_write_u32(bs, ptr->grouping_type);\n\n\tif (ptr->flags & (1<<6))\n\t\tgf_bs_write_u32(bs, ptr->grouping_type_parameter);\n\n\tgf_bs_write_u32(bs, ptr->pattern_count);\n\n\tfor (i = 0; i<ptr->pattern_count; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->patterns[i].length, pattern_size);\n\t\tgf_bs_write_int(bs, ptr->patterns[i].sample_count, scount_size);\n\t}\n\n\tfor (i = 0; i<ptr->pattern_count; i++ ) {\n\t\tu32 j;\n\t\tfor (j=0; j<ptr->patterns[i].length; j++) {\n\t\t\tu32 idx = ptr->patterns[i].sample_group_description_indices[j];\n\t\t\tif (idx > 0x10000) {\n\t\t\t\tidx -= 0x10000;\n\t\t\t\tgf_bs_write_int(bs, 1, 1);\n\t\t\t\tgf_bs_write_int(bs, idx, index_size-1);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, idx, index_size);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_align(bs);\n\treturn GF_OK;\n}\n\nGF_Err csgp_box_size(GF_Box *s)\n{\n\tu32 i, bits;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox*)s;\n\tu32 pattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tu32 scount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tu32 index_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\tptr->size += 12; //v, flags , grouping_type, pattern_length\n\tif (ptr->flags & (1<<6))\n\t\tptr->size+=4;\n\n\tptr->size += ptr->pattern_count * (pattern_size + scount_size) / 8;\n\tbits=0;\n\tfor (i=0; i<ptr->pattern_count; i++)\n\t\tbits += ptr->patterns[i].length * index_size;\n\tptr->size += bits/8;\n\tif (bits % 8) ptr->size++;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dmlp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrueHDConfigBox, GF_ISOM_BOX_TYPE_DMLP);\n\treturn (GF_Box *)tmp;\n}\n\nvoid dmlp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err dmlp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrueHDConfigBox *ptr = (GF_TrueHDConfigBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 10)\n\tptr->format_info = gf_bs_read_u32(bs);\n\tptr->peak_data_rate = gf_bs_read_int(bs, 15);\n\tgf_bs_read_int(bs, 1);\n\tgf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dmlp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrueHDConfigBox *ptr = (GF_TrueHDConfigBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->format_info);\n\tgf_bs_write_int(bs, ptr->peak_data_rate, 15);\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err dmlp_box_size(GF_Box *s)\n{\n\ts->size += 10;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *xtra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_XtraBox, GF_ISOM_BOX_TYPE_XTRA);\n\ttmp->tags = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid xtra_box_del(GF_Box *s)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (gf_list_count(ptr->tags)) {\n\t\tGF_XtraTag *tag = gf_list_pop_back(ptr->tags);\n\t\tif (tag->name) gf_free(tag->name);\n\t\tif (tag->prop_value) gf_free(tag->prop_value);\n\t\tgf_free(tag);\n\t}\n\tgf_list_del(ptr->tags);\n\tgf_free(s);\n}\n\nGF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (ptr->size) {\n\t\tGF_XtraTag *tag;\n\t\tu32 prop_type = 0;\n\n\t\tchar *data=NULL, *data2=NULL;\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 8)\n\t\ts32 tag_size = gf_bs_read_u32(bs);\n\t\tu32 name_size = gf_bs_read_u32(bs);\n\t\tif (tag_size < 8) return GF_ISOM_INVALID_FILE;\n\n\t\ttag_size -= 8;\n\t\tif ((tag_size>ptr->size) || (name_size>ptr->size)) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 10)\n\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)\n\t\tdata = gf_malloc(sizeof(char) * (name_size+1));\n\t\tgf_bs_read_data(bs, data, name_size);\n\t\tdata[name_size] = 0;\n\t\ttag_size-=name_size;\n\n\t\tu32 flags = gf_bs_read_u32(bs);\n\t\tu32 prop_size = gf_bs_read_u32(bs);\n\t\ttag_size-=8;\n\n\t\tif (prop_size>4) {\n\t\t\ttag_size-=2;\n\t\t\tprop_type = gf_bs_read_u16(bs);\n\t\t\tprop_size -= 6;\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)\n\t\t\t//add 3 extra bytes for UTF16 case string dump (3 because we need 0-aligned short value)\n\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+3));\n\t\t\tgf_bs_read_data(bs, data2, prop_size);\n\t\t\tdata2[prop_size] = 0;\n\t\t\tdata2[prop_size+1] = 0;\n\t\t\tdata2[prop_size+2] = 0;\n\t\t\ttag_size-=prop_size;\n\t\t} else {\n\t\t\tprop_size = 0;\n\t\t}\n\t\tGF_SAFEALLOC(tag, GF_XtraTag)\n\t\ttag->flags = flags;\n\t\ttag->name = data;\n\t\ttag->prop_size = prop_size;\n\t\ttag->prop_value = data2;\n\t\ttag->prop_type = prop_type;\n\t\tgf_list_add(ptr->tags, tag);\n\n\t\tif (tag_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isom] invalid tag size in Xtra !\\n\"));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err xtra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\tu32 i, count = gf_list_count(ptr->tags);\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_XtraTag *tag = gf_list_get(ptr->tags, i);\n\t\tu32 tag_size = 16;\n\t\tu32 name_len = tag->name ? (u32) strlen(tag->name) : 0;\n\t\ttag_size += name_len;\n\t\tif (tag->prop_value) {\n\t\t\ttag_size += 2 + tag->prop_size;\n\t\t}\n\t\tgf_bs_write_u32(bs, tag_size);\n\t\tgf_bs_write_u32(bs, name_len);\n\t\tgf_bs_write_data(bs, tag->name, name_len);\n\t\tgf_bs_write_u32(bs, tag->flags);\n\t\tgf_bs_write_u32(bs, 6 + tag->prop_size);\n\t\tgf_bs_write_u16(bs, tag->prop_type);\n\t\tgf_bs_write_data(bs, tag->prop_value, tag->prop_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err xtra_box_size(GF_Box *s)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\tu32 i, count = gf_list_count(ptr->tags);\n\tfor (i=0; i<count; i++) {\n\t\tGF_XtraTag *tag = gf_list_get(ptr->tags, i);\n\t\tptr->size += 18 + (u32) strlen(tag->name) + tag->prop_size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *st3d_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Stereo3DBox, GF_ISOM_BOX_TYPE_ST3D);\n\treturn (GF_Box *)tmp;\n}\n\nvoid st3d_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err st3d_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Stereo3DBox *ptr = (GF_Stereo3DBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->stereo_type = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err st3d_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_Stereo3DBox *ptr = (GF_Stereo3DBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->stereo_type);\n\treturn GF_OK;\n}\n\nGF_Err st3d_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *svhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SphericalVideoInfoBox, GF_ISOM_BOX_TYPE_SVHD);\n\treturn (GF_Box *)tmp;\n}\n\nvoid svhd_box_del(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string) gf_free(ptr->string);\n\tgf_free(s);\n}\n\n\nGF_Err svhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif ((u32)ptr->size >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in svhd box\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->string = gf_malloc(sizeof(char) * ((u32) ptr->size+1));\n\tif (!ptr->string) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->string, (u32) ptr->size);\n\tptr->string[ptr->size] = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err svhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->string)\n\t\tgf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err svhd_box_size(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string)\n\t\ts->size += (u32) strlen(ptr->string);\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *prhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProjectionHeaderBox, GF_ISOM_BOX_TYPE_PRHD);\n\treturn (GF_Box *)tmp;\n}\n\nvoid prhd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err prhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionHeaderBox *ptr = (GF_ProjectionHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 12)\n\tptr->yaw = (s32) gf_bs_read_u32(bs);\n\tptr->pitch = (s32) gf_bs_read_u32(bs);\n\tptr->roll = (s32) gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err prhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProjectionHeaderBox *ptr = (GF_ProjectionHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->yaw);\n\tgf_bs_write_u32(bs, ptr->pitch);\n\tgf_bs_write_u32(bs, ptr->roll);\n\treturn GF_OK;\n}\n\nGF_Err prhd_box_size(GF_Box *s)\n{\n\ts->size += 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *proj_type_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProjectionTypeBox, GF_ISOM_BOX_TYPE_EQUI); //will be overwritten\n\treturn (GF_Box *)tmp;\n}\n\nvoid proj_type_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err proj_type_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->layout = gf_bs_read_u32(bs);\n\t\tptr->padding = gf_bs_read_u32(bs);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->bounds_top = gf_bs_read_u32(bs);\n\t\tptr->bounds_bottom = gf_bs_read_u32(bs);\n\t\tptr->bounds_left = gf_bs_read_u32(bs);\n\t\tptr->bounds_right = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->crc = gf_bs_read_u32(bs);\n\t\tptr->encoding_4cc = gf_bs_read_u32(bs);\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err proj_type_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tgf_bs_write_u32(bs, ptr->layout);\n\t\tgf_bs_write_u32(bs, ptr->padding);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tgf_bs_write_u32(bs, ptr->bounds_top);\n\t\tgf_bs_write_u32(bs, ptr->bounds_bottom);\n\t\tgf_bs_write_u32(bs, ptr->bounds_left);\n\t\tgf_bs_write_u32(bs, ptr->bounds_right);\n\t} else {\n\t\tgf_bs_write_u32(bs, ptr->crc);\n\t\tgf_bs_write_u32(bs, ptr->encoding_4cc);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err proj_type_box_size(GF_Box *s)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP)\n\t\ts->size += 8;\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI)\n\t\ts->size += 16;\n\telse\n\t\ts->size += 8;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n//Add this funct to handle incomplete files...\n//bytesExpected is 0 most of the time. If the file is incomplete, bytesExpected\n//is the number of bytes missing to parse the box...\nGF_Err gf_isom_parse_root_box(GF_Box **outBox, GF_BitStream *bs, u32 *box_type, u64 *bytesExpected, Bool progressive_mode)\n{\n\tGF_Err ret;\n\tu64 start;\n\tstart = gf_bs_get_position(bs);\n\tret = gf_isom_box_parse_ex(outBox, bs, 0, GF_TRUE, 0);\n\tif (ret == GF_ISOM_INCOMPLETE_FILE) {\n\t\tif (!*outBox) {\n\t\t\t// We could not even read the box size, we at least need 8 bytes\n\t\t\t*bytesExpected = 8;\n\t\t\tif (box_type) *box_type = 0;\n\t\t\tGF_LOG(progressive_mode ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete box - start \"LLU\"\\n\", start));\n\t\t}\n\t\telse {\n\t\t\tu32 type = (*outBox)->type;\n\t\t\tif (type==GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\ttype = ((GF_UnknownBox *) (*outBox))->original_4cc;\n\n\t\t\t*bytesExpected = (*outBox)->size;\n\t\t\tif (box_type) *box_type = (*outBox)->type;\n\n\t\t\tGF_LOG(progressive_mode ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete box %s - start \"LLU\" size \"LLU\"\\n\", gf_4cc_to_str(type), start, (*outBox)->size));\n\t\t\tgf_isom_box_del(*outBox);\n\t\t\t*outBox = NULL;\n\t\t}\n\t\tgf_bs_seek(bs, start);\n\t}\n\treturn ret;\n}\n\nu32 gf_isom_solve_uuid_box(u8 *UUID)\n{\n\tu32 i;\n\tchar strUUID[33], strChar[3];\n\tstrUUID[0] = 0;\n\tstrUUID[32] = 0;\n\tfor (i=0; i<16; i++) {\n\t\tsnprintf(strChar, 3, \"%02X\", (unsigned char) UUID[i]);\n\t\tstrcat(strUUID, strChar);\n\t}\n\tif (!strnicmp(strUUID, \"8974dbce7be74c5184f97148f9882554\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TENC;\n\tif (!strnicmp(strUUID, \"A5D40B30E81411DDBA2F0800200C9A66\", 32))\n\t\treturn GF_ISOM_BOX_UUID_MSSM;\n\tif (!strnicmp(strUUID, \"D4807EF2CA3946958E5426CB9E46A79F\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TFRF;\n\tif (!strnicmp(strUUID, \"6D1D9B0542D544E680E2141DAFF757B2\", 32))\n\t\treturn GF_ISOM_BOX_UUID_TFXD;\n\tif (!strnicmp(strUUID, \"A2394F525A9B4F14A2446C427C648DF4\", 32))\n\t\treturn GF_ISOM_BOX_UUID_PSEC;\n\tif (!strnicmp(strUUID, \"D08A4F1810F34A82B6C832D8ABA183D3\", 32))\n\t\treturn GF_ISOM_BOX_UUID_PSSH;\n\n\treturn 0;\n}\n\nstatic GF_Err gf_isom_full_box_read(GF_Box *ptr, GF_BitStream *bs);\n\nu64 unused_bytes = 0;\n\n#define GF_SKIP_BOX 10\n\nGF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box, u64 parent_size)\n{\n\tu32 type, uuid_type, hdr_size, restore_type;\n\tu64 size, start, comp_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_BitStream *uncomp_bs = NULL;\n\tu8 *uncomp_data = NULL;\n\tu32 compressed_size=0;\n\tGF_Box *newBox;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tcomp_start = start = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t\treturn GF_SKIP_BOX;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tif (is_root_box && (size>=8)) {\n\t\t\tBool do_uncompress = GF_FALSE;\n\t\t\tu8 *compb = NULL;\n\t\t\tu32 osize = 0;\n\t\t\tu32 otype = type;\n\t\t\tif (type==GF_4CC('!', 'm', 'o', 'f')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOF;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 'm', 'o', 'v')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOV;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 'i', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SIDX;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 's', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SSIX;\n\t\t\t}\n\n\t\t\tif (do_uncompress) {\n\t\t\t\tcompb = gf_malloc((u32) (size-8));\n\t\t\t\tif (!compb) return GF_OUT_OF_MEM;\n\n\t\t\t\tcompressed_size = (u32) (size - 8);\n\t\t\t\tgf_bs_read_data(bs, compb, compressed_size);\n\t\t\t\te = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);\n\t\t\t\tif (e) {\n\t\t\t\t\tgf_free(compb);\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\t//keep size as complete box size for tests below\n\t\t\t\tsize = osize + 8;\n\t\t\t\tuncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);\n\t\t\t\tbs = uncomp_bs;\n\t\t\t\tstart = 0;\n\t\t\t\tgf_free(compb);\n\t\t\t}\n\t\t}\n\t}\n\n#define ERR_EXIT(_e) { \\\n\t\tif (uncomp_bs) {\\\n\t\t\tgf_free(uncomp_data);\\\n\t\t\tgf_bs_del(uncomp_bs); \\\n\t\t}\\\n\t\treturn _e;\\\n\t}\n\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tif (!skip_logs)\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), size,  start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLD\" less than box header size %d\\n\", gf_4cc_to_str(type), size, hdr_size));\n\t\tERR_EXIT(GF_ISOM_INVALID_FILE);\n\t}\n\t//if parent size is given, make sure box fits within parent\n\tif (parent_size && (parent_size<size)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLU\" is larger than remaining parent size \"LLU\"\\n\", gf_4cc_to_str(type), size, parent_size ));\n\t\tERR_EXIT(GF_ISOM_INVALID_FILE);\n\t}\n\trestore_type = 0;\n\tif ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {\n\t\tu64 cookie = gf_bs_get_cookie(bs);\n\t\trestore_type = type;\n\t\tif (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)\n\t\t\ttype = GF_QT_SUBTYPE_RAW_VID;\n\t\telse\n\t\t\ttype = GF_QT_SUBTYPE_RAW_AUD;\n\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tif (restore_type)\n\t\tnewBox->type = restore_type;\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tif (e) {\n\t\tif (gf_opts_get_bool(\"core\", \"no-check\"))\n\t\t\te = GF_OK;\n\t}\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (uncomp_bs) {\n\t\tgf_free(uncomp_data);\n\t\tgf_bs_del(uncomp_bs);\n\t\tif (e) {\n\t\t\tgf_isom_box_del(newBox);\n\t\t\t*outBox = NULL;\n\t\t\treturn e;\n\t\t}\n\t\t//move size to real bitstream offsets for tests below\n\t\tsize -= 8;\n\t\t//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset\n\t\tif (type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\t((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for moov in order to properly recompute chunk offset\n\t\telse if (type==GF_ISOM_BOX_TYPE_MOOV) {\n\t\t\t((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t\t((GF_MovieBox *)newBox)->file_offset = comp_start;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\tnewBox->internal_flags = GF_ISOM_BOX_COMPRESSED;\n\t}\n\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\t\tif (is_root_box && (e==GF_SKIP_BOX))\n\t\t\te = GF_ISOM_INVALID_FILE;\n\n\t\tif (!skip_logs && (e!=GF_SKIP_BOX)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), size, start, (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t\tunused_bytes += to_skip;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_box_parse(GF_Box **outBox, GF_BitStream *bs)\n{\n\treturn gf_isom_box_parse_ex(outBox, bs, 0, GF_FALSE, 0);\n}\n\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\n\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\n\nvoid gf_isom_box_array_reset_parent(GF_List **child_boxes, GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del_parent(child_boxes, a);\n\t}\n\tgf_list_reset(boxlist);\n}\nvoid gf_isom_box_array_del_parent(GF_List **child_boxes, GF_List *boxlist)\n{\n\tif (!boxlist) return;\n\tgf_isom_box_array_reset_parent(child_boxes, boxlist);\n\tgf_list_del(boxlist);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_EXPORT\nGF_Err gf_isom_box_write_header(GF_Box *ptr, GF_BitStream *bs)\n{\n\tu64 start;\n\tif (! bs || !ptr) return GF_BAD_PARAM;\n\tif (!ptr->size) return GF_ISOM_INVALID_FILE;\n\n\tstart = gf_bs_get_position(bs);\n\tif (ptr->size > 0xFFFFFFFF) {\n\t\tgf_bs_write_u32(bs, 1);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->size);\n\t}\n\tgf_bs_write_u32(bs, ptr->type);\n\tif (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\tu32 i;\n\t\tBool conv_uuid = GF_TRUE;\n\t\tGF_UUIDBox *uuidb = (GF_UUIDBox *)ptr;\n\t\tchar strUUID[32];\n\n\t\tswitch (uuidb->internal_4cc) {\n\t\tcase GF_ISOM_BOX_UUID_TENC:\n\t\t\tmemcpy(strUUID, \"8974dbce7be74c5184f97148f9882554\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_PSEC:\n\t\t\tmemcpy(strUUID, \"A2394F525A9B4F14A2446C427C648DF4\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_MSSM:\n\t\t\tmemcpy(strUUID, \"A5D40B30E81411DDBA2F0800200C9A66\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_PSSH:\n\t\t\tmemcpy(strUUID, \"D08A4F1810F34A82B6C832D8ABA183D3\", 32);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_UUID_TFXD:\n\t\t\tmemcpy(strUUID, \"6D1D9B0542D544E680E2141DAFF757B2\", 32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconv_uuid = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (conv_uuid) {\n\t\t\tchar uuid[16];\n\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\tchar t[3];\n\t\t\t\tt[2] = 0;\n\t\t\t\tt[0] = strUUID[2*i];\n\t\t\t\tt[1] = strUUID[2*i+1];\n\t\t\t\tuuid[i] = (u8) strtol(t, NULL, 16);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, uuid, 16);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, uuidb->uuid, 16);\n\t\t}\n\t}\n\tif (ptr->size > 0xFFFFFFFF)\n\t\tgf_bs_write_u64(bs, ptr->size);\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Written Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(ptr->type), ptr->size, start));\n\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_full_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FullBox *ptr = (GF_FullBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_box_array_write(GF_Box *parent, GF_List *list, GF_BitStream *bs)\n{\n\tu32 count, i;\n\tGF_Err e;\n\tif (!list) return GF_OK;\n\tcount = gf_list_count(list);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(list, i);\n\t\tif (a) {\n\t\t\te = gf_isom_box_write(a, bs);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Error %s writing box %s\\n\", gf_error_to_string(e), gf_4cc_to_str(a->type) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_box_array_size(GF_Box *parent, GF_List *list)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tif (! list) return GF_OK;\n\n\tcount = gf_list_count(list);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(list, i);\n\t\tif (a) {\n\t\t\te = gf_isom_box_size(a);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Error %s computing box %s size\\n\", gf_error_to_string(e), gf_4cc_to_str(a->type) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tparent->size += a->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box * unkn_box_new();\nvoid unkn_box_del(GF_Box *);\nGF_Err unkn_box_read(GF_Box *s, GF_BitStream *bs);\nGF_Err unkn_box_write(GF_Box *s, GF_BitStream *bs);\nGF_Err unkn_box_size(GF_Box *s);\nGF_Err unkn_box_dump(GF_Box *a, FILE * trace);\n\n//definition of boxes new/del/read/write/size. For now still exported since some files other than box_funcs.c call them\n//this should be fixed by only using gf_isom_box_new\n\n#define ISOM_BOX_IMPL_DECL(a_name) \\\n\t\tGF_Box * a_name##_box_new(); \\\n\t\tvoid a_name##_box_del(GF_Box *); \\\n\t\tGF_Err a_name##_box_read(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_write(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_size(GF_Box *s);\\\n\t\tGF_Err a_name##_box_dump(GF_Box *a, FILE * trace);\n\n#define ISOM_BOX_IMPL_DECL_CHILD(a_name) \\\n\t\tGF_Box * a_name##_box_new(); \\\n\t\tvoid a_name##_box_del(GF_Box *); \\\n\t\tGF_Err a_name##_box_read(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_write(GF_Box *s, GF_BitStream *bs); \\\n\t\tGF_Err a_name##_box_size(GF_Box *s);\\\n\t\tGF_Err a_name##_box_dump(GF_Box *a, FILE * trace);\\\n\t\tGF_Err a_name##_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem);\\\n\n\nISOM_BOX_IMPL_DECL(reftype)\nISOM_BOX_IMPL_DECL(ireftype)\nISOM_BOX_IMPL_DECL(free)\nISOM_BOX_IMPL_DECL(wide)\nISOM_BOX_IMPL_DECL(mdat)\nISOM_BOX_IMPL_DECL(imda)\nISOM_BOX_IMPL_DECL_CHILD(moov)\nISOM_BOX_IMPL_DECL(mvhd)\nISOM_BOX_IMPL_DECL(mdhd)\nISOM_BOX_IMPL_DECL(vmhd)\nISOM_BOX_IMPL_DECL(smhd)\nISOM_BOX_IMPL_DECL(hmhd)\nISOM_BOX_IMPL_DECL(nmhd)\nISOM_BOX_IMPL_DECL_CHILD(stbl)\nISOM_BOX_IMPL_DECL_CHILD(dinf)\nISOM_BOX_IMPL_DECL(url)\nISOM_BOX_IMPL_DECL(urn)\nISOM_BOX_IMPL_DECL(cprt)\nISOM_BOX_IMPL_DECL(kind)\nISOM_BOX_IMPL_DECL(chpl)\nISOM_BOX_IMPL_DECL(hdlr)\nISOM_BOX_IMPL_DECL(iods)\nISOM_BOX_IMPL_DECL_CHILD(trak)\nISOM_BOX_IMPL_DECL_CHILD(mp4s)\nISOM_BOX_IMPL_DECL_CHILD(audio_sample_entry)\nISOM_BOX_IMPL_DECL(gen_sample_entry)\nISOM_BOX_IMPL_DECL_CHILD(edts)\nISOM_BOX_IMPL_DECL_CHILD(udta)\nISOM_BOX_IMPL_DECL(dref)\nISOM_BOX_IMPL_DECL_CHILD(stsd)\nISOM_BOX_IMPL_DECL(stts)\nISOM_BOX_IMPL_DECL(ctts)\nISOM_BOX_IMPL_DECL(stsh)\nISOM_BOX_IMPL_DECL(elst)\nISOM_BOX_IMPL_DECL(stsc)\nISOM_BOX_IMPL_DECL(stsz)\nISOM_BOX_IMPL_DECL(stco)\nISOM_BOX_IMPL_DECL(stss)\nISOM_BOX_IMPL_DECL(stdp)\nISOM_BOX_IMPL_DECL(sdtp)\nISOM_BOX_IMPL_DECL(co64)\nISOM_BOX_IMPL_DECL(esds)\nISOM_BOX_IMPL_DECL_CHILD(minf)\nISOM_BOX_IMPL_DECL(tkhd)\nISOM_BOX_IMPL_DECL(tref)\nISOM_BOX_IMPL_DECL_CHILD(mdia)\nISOM_BOX_IMPL_DECL_CHILD(mfra)\nISOM_BOX_IMPL_DECL(tfra)\nISOM_BOX_IMPL_DECL(mfro)\nISOM_BOX_IMPL_DECL(uuid)\nISOM_BOX_IMPL_DECL(void)\nISOM_BOX_IMPL_DECL(gnrm)\nISOM_BOX_IMPL_DECL(gnrv)\nISOM_BOX_IMPL_DECL(gnra)\nISOM_BOX_IMPL_DECL(pdin)\nISOM_BOX_IMPL_DECL(def_parent)\nISOM_BOX_IMPL_DECL(def_parent_full)\nISOM_BOX_IMPL_DECL(csgp)\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nISOM_BOX_IMPL_DECL_CHILD(hinf)\nISOM_BOX_IMPL_DECL(trpy)\nISOM_BOX_IMPL_DECL(totl)\nISOM_BOX_IMPL_DECL(nump)\nISOM_BOX_IMPL_DECL(npck)\nISOM_BOX_IMPL_DECL(tpyl)\nISOM_BOX_IMPL_DECL(tpay)\nISOM_BOX_IMPL_DECL(maxr)\nISOM_BOX_IMPL_DECL(dmed)\nISOM_BOX_IMPL_DECL(dimm)\nISOM_BOX_IMPL_DECL(drep)\nISOM_BOX_IMPL_DECL(tmin)\nISOM_BOX_IMPL_DECL(tmax)\nISOM_BOX_IMPL_DECL(pmax)\nISOM_BOX_IMPL_DECL(dmax)\nISOM_BOX_IMPL_DECL(payt)\nISOM_BOX_IMPL_DECL(name)\nISOM_BOX_IMPL_DECL(rely)\nISOM_BOX_IMPL_DECL(snro)\nISOM_BOX_IMPL_DECL(tims)\nISOM_BOX_IMPL_DECL(tsro)\nISOM_BOX_IMPL_DECL(ghnt)\nISOM_BOX_IMPL_DECL_CHILD(hnti)\nISOM_BOX_IMPL_DECL(sdp)\nISOM_BOX_IMPL_DECL(rtpo)\nISOM_BOX_IMPL_DECL(tssy)\nISOM_BOX_IMPL_DECL(rssr)\nISOM_BOX_IMPL_DECL_CHILD(srpp)\nISOM_BOX_IMPL_DECL(rtp_hnti)\n\n#endif\n\nISOM_BOX_IMPL_DECL(ftyp)\nISOM_BOX_IMPL_DECL(padb)\nISOM_BOX_IMPL_DECL(gppc)\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nISOM_BOX_IMPL_DECL_CHILD(mvex)\nISOM_BOX_IMPL_DECL(trex)\nISOM_BOX_IMPL_DECL_CHILD(moof)\nISOM_BOX_IMPL_DECL(mfhd)\nISOM_BOX_IMPL_DECL_CHILD(traf)\nISOM_BOX_IMPL_DECL(tfhd)\nISOM_BOX_IMPL_DECL(trun)\nISOM_BOX_IMPL_DECL(styp)\nISOM_BOX_IMPL_DECL(mehd)\n/*smooth streaming timing*/\nISOM_BOX_IMPL_DECL(tfxd)\nISOM_BOX_IMPL_DECL(tfrf)\n\n#endif\n\n/*avc ext*/\nISOM_BOX_IMPL_DECL(avcc)\nISOM_BOX_IMPL_DECL_CHILD(video_sample_entry)\nISOM_BOX_IMPL_DECL(m4ds)\nISOM_BOX_IMPL_DECL(btrt)\nISOM_BOX_IMPL_DECL(mehd)\n\n/*3GPP streaming text*/\nISOM_BOX_IMPL_DECL(ftab)\nISOM_BOX_IMPL_DECL_CHILD(tx3g)\nISOM_BOX_IMPL_DECL(text)\nISOM_BOX_IMPL_DECL(styl)\nISOM_BOX_IMPL_DECL(hlit)\nISOM_BOX_IMPL_DECL(hclr)\nISOM_BOX_IMPL_DECL(krok)\nISOM_BOX_IMPL_DECL(dlay)\nISOM_BOX_IMPL_DECL(href)\nISOM_BOX_IMPL_DECL(tbox)\nISOM_BOX_IMPL_DECL(blnk)\nISOM_BOX_IMPL_DECL(twrp)\n\n\n#ifndef GPAC_DISABLE_VTT\n\n/*WebVTT boxes*/\nISOM_BOX_IMPL_DECL(boxstring);\nISOM_BOX_IMPL_DECL_CHILD(vtcu)\nISOM_BOX_IMPL_DECL(vtte)\nISOM_BOX_IMPL_DECL_CHILD(wvtt)\n\n#endif //GPAC_DISABLE_VTT\n\n/* Items functions */\nISOM_BOX_IMPL_DECL_CHILD(meta)\nISOM_BOX_IMPL_DECL(xml)\nISOM_BOX_IMPL_DECL(bxml)\nISOM_BOX_IMPL_DECL(iloc)\nISOM_BOX_IMPL_DECL(pitm)\nISOM_BOX_IMPL_DECL_CHILD(ipro)\nISOM_BOX_IMPL_DECL(infe)\nISOM_BOX_IMPL_DECL_CHILD(iinf)\nISOM_BOX_IMPL_DECL_CHILD(iref)\nISOM_BOX_IMPL_DECL_CHILD(sinf)\nISOM_BOX_IMPL_DECL(frma)\nISOM_BOX_IMPL_DECL(schm)\nISOM_BOX_IMPL_DECL_CHILD(schi)\nISOM_BOX_IMPL_DECL(enca)\nISOM_BOX_IMPL_DECL(encs)\nISOM_BOX_IMPL_DECL(encv)\nISOM_BOX_IMPL_DECL(resv)\n\n\n/** ISMACryp functions **/\nISOM_BOX_IMPL_DECL(iKMS)\nISOM_BOX_IMPL_DECL(iSFM)\nISOM_BOX_IMPL_DECL(iSLT)\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n/* Adobe extensions */\nISOM_BOX_IMPL_DECL(abst)\nISOM_BOX_IMPL_DECL(afra)\nISOM_BOX_IMPL_DECL(asrt)\nISOM_BOX_IMPL_DECL(afrt)\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n\n/* Apple extensions */\nISOM_BOX_IMPL_DECL(ilst)\nISOM_BOX_IMPL_DECL(ilst_item)\nISOM_BOX_IMPL_DECL(databox)\nISOM_BOX_IMPL_DECL(gmin)\nISOM_BOX_IMPL_DECL(alis)\nISOM_BOX_IMPL_DECL(clef)\n\n/*OMA extensions*/\nISOM_BOX_IMPL_DECL(ohdr)\nISOM_BOX_IMPL_DECL(grpi)\nISOM_BOX_IMPL_DECL(mdri)\nISOM_BOX_IMPL_DECL(odtt)\nISOM_BOX_IMPL_DECL(odrb)\nISOM_BOX_IMPL_DECL(odkm)\n\n\nISOM_BOX_IMPL_DECL(pasp)\nISOM_BOX_IMPL_DECL(clap)\nISOM_BOX_IMPL_DECL_CHILD(metx)\nISOM_BOX_IMPL_DECL(txtc)\nISOM_BOX_IMPL_DECL(tsel)\nISOM_BOX_IMPL_DECL(dimC)\nISOM_BOX_IMPL_DECL_CHILD(dims)\nISOM_BOX_IMPL_DECL(diST)\nISOM_BOX_IMPL_DECL(ac3)\nISOM_BOX_IMPL_DECL(ec3)\nISOM_BOX_IMPL_DECL(dac3)\nISOM_BOX_IMPL_DECL(dec3)\nISOM_BOX_IMPL_DECL(dmlp)\nISOM_BOX_IMPL_DECL(lsrc)\nISOM_BOX_IMPL_DECL_CHILD(lsr1)\nISOM_BOX_IMPL_DECL(mvcg)\nISOM_BOX_IMPL_DECL(vwid)\n\nISOM_BOX_IMPL_DECL(subs)\n\nISOM_BOX_IMPL_DECL(tmcd)\nISOM_BOX_IMPL_DECL(tcmi)\nISOM_BOX_IMPL_DECL(fiel)\nISOM_BOX_IMPL_DECL(gama)\nISOM_BOX_IMPL_DECL(chrm)\nISOM_BOX_IMPL_DECL(chan)\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nISOM_BOX_IMPL_DECL(sidx)\nISOM_BOX_IMPL_DECL(ssix)\nISOM_BOX_IMPL_DECL(leva)\nISOM_BOX_IMPL_DECL(pcrb)\nISOM_BOX_IMPL_DECL(tfdt)\nISOM_BOX_IMPL_DECL(emsg)\n\n#endif\n\nISOM_BOX_IMPL_DECL(rvcc)\nISOM_BOX_IMPL_DECL(sbgp)\nISOM_BOX_IMPL_DECL(sgpd)\nISOM_BOX_IMPL_DECL(saiz)\nISOM_BOX_IMPL_DECL(saio)\n\nISOM_BOX_IMPL_DECL(pssh)\n\nISOM_BOX_IMPL_DECL(tenc)\nISOM_BOX_IMPL_DECL(piff_tenc)\nISOM_BOX_IMPL_DECL(piff_psec)\nISOM_BOX_IMPL_DECL(piff_pssh)\nISOM_BOX_IMPL_DECL(senc)\nISOM_BOX_IMPL_DECL(cslg)\nISOM_BOX_IMPL_DECL(ccst)\nISOM_BOX_IMPL_DECL(auxi)\nISOM_BOX_IMPL_DECL(hvcc)\nISOM_BOX_IMPL_DECL(av1c)\nISOM_BOX_IMPL_DECL(dOps)\nISOM_BOX_IMPL_DECL(prft)\nISOM_BOX_IMPL_DECL(vvcc)\nISOM_BOX_IMPL_DECL(vvnc)\n\n//VPx\nISOM_BOX_IMPL_DECL(vpcc)\nISOM_BOX_IMPL_DECL(SmDm)\nISOM_BOX_IMPL_DECL(CoLL)\n\nISOM_BOX_IMPL_DECL(trep)\n\n//FEC\nISOM_BOX_IMPL_DECL_CHILD(fiin)\nISOM_BOX_IMPL_DECL_CHILD(paen)\nISOM_BOX_IMPL_DECL(fpar)\nISOM_BOX_IMPL_DECL(fecr)\nISOM_BOX_IMPL_DECL(segr)\nISOM_BOX_IMPL_DECL(gitn)\nISOM_BOX_IMPL_DECL_CHILD(fdsa)\nISOM_BOX_IMPL_DECL(fdpa)\nISOM_BOX_IMPL_DECL(extr)\n\n\n/*\n\tAdobe's protection boxes\n*/\nISOM_BOX_IMPL_DECL_CHILD(adkm)\nISOM_BOX_IMPL_DECL_CHILD(ahdr)\nISOM_BOX_IMPL_DECL_CHILD(aprm)\nISOM_BOX_IMPL_DECL(aeib)\nISOM_BOX_IMPL_DECL_CHILD(akey)\nISOM_BOX_IMPL_DECL(flxs)\nISOM_BOX_IMPL_DECL(adaf)\n\n/* Image File Format declarations */\nISOM_BOX_IMPL_DECL(ispe)\nISOM_BOX_IMPL_DECL(colr)\nISOM_BOX_IMPL_DECL(pixi)\nISOM_BOX_IMPL_DECL(rloc)\nISOM_BOX_IMPL_DECL(irot)\nISOM_BOX_IMPL_DECL(imir)\nISOM_BOX_IMPL_DECL(ipco)\nISOM_BOX_IMPL_DECL_CHILD(iprp)\nISOM_BOX_IMPL_DECL(ipma)\nISOM_BOX_IMPL_DECL_CHILD(trgr)\nISOM_BOX_IMPL_DECL(trgt)\nISOM_BOX_IMPL_DECL(ienc)\nISOM_BOX_IMPL_DECL(iaux)\n\n/* MIAF declarations */\nISOM_BOX_IMPL_DECL(clli)\nISOM_BOX_IMPL_DECL(mdcv)\n\n/* AVIF declarations */\nISOM_BOX_IMPL_DECL(a1lx)\nISOM_BOX_IMPL_DECL(a1op)\n\nISOM_BOX_IMPL_DECL(grpl)\n\nISOM_BOX_IMPL_DECL_CHILD(strk)\nISOM_BOX_IMPL_DECL(stri)\nISOM_BOX_IMPL_DECL(stsg)\nISOM_BOX_IMPL_DECL(elng)\nISOM_BOX_IMPL_DECL(stvi)\nISOM_BOX_IMPL_DECL(auxc)\nISOM_BOX_IMPL_DECL(oinf)\nISOM_BOX_IMPL_DECL(tols)\n\nISOM_BOX_IMPL_DECL(trik)\nISOM_BOX_IMPL_DECL(bloc)\nISOM_BOX_IMPL_DECL(ainf)\nISOM_BOX_IMPL_DECL(mhac)\nISOM_BOX_IMPL_DECL(mhap)\n\nISOM_BOX_IMPL_DECL(grptype)\n\nISOM_BOX_IMPL_DECL_CHILD(jp2h)\nISOM_BOX_IMPL_DECL(ihdr)\nISOM_BOX_IMPL_DECL(load)\n\n/* Dolby Vision */\nISOM_BOX_IMPL_DECL(dvcC)\nISOM_BOX_IMPL_DECL(dvvC)\nISOM_BOX_IMPL_DECL(dvhe)\nISOM_BOX_IMPL_DECL(dfla)\n\nISOM_BOX_IMPL_DECL(pcmC)\nISOM_BOX_IMPL_DECL(chnl)\n\nISOM_BOX_IMPL_DECL(xtra)\n\nISOM_BOX_IMPL_DECL(st3d)\nISOM_BOX_IMPL_DECL(svhd)\nISOM_BOX_IMPL_DECL(prhd)\nISOM_BOX_IMPL_DECL(proj_type)\n//ISOM_BOX_IMPL_DECL(mesh)\n\nISOM_BOX_IMPL_DECL(keys)\n\n#define BOX_DEFINE(__type, b_rad, __par) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, \"p12\", GF_FALSE}\n\n#define BOX_DEFINE_CHILD(__type, b_rad, __par) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, \"p12\", GF_FALSE, b_rad##_on_child_box}\n\n#define BOX_DEFINE_S(__type, b_rad, __par, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, __spec, GF_FALSE }\n\n#define BOX_DEFINE_S_CHILD(__type, b_rad, __par, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 0, 0, __par, __spec, GF_FALSE, b_rad##_on_child_box}\n\n#define FBOX_DEFINE(__type, b_rad, __par, __max_v) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, \"p12\", GF_FALSE }\n\n#define FBOX_DEFINE_CHILD(__type, b_rad, __par, __max_v) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, \"p12\", GF_FALSE, b_rad##_on_child_box}\n\n#define FBOX_DEFINE_FLAGS(__type, b_rad, __par, __max_v, flags) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, flags, __par, \"p12\", GF_FALSE }\n\n#define FBOX_DEFINE_FLAGS_S(__type, b_rad, __par, __max_v, flags, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, flags, __par, __spec, GF_FALSE }\n\n#define FBOX_DEFINE_S(__type, b_rad, __par, __max_v, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, __spec, GF_FALSE }\n\n#define FBOX_DEFINE_S_CHILD(__type, b_rad, __par, __max_v, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, 0, 1+__max_v, 0, __par, __spec, GF_FALSE, b_rad##_on_child_box}\n\n#define TREF_DEFINE(__type, b_rad, __par, __4cc, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 0, 0, __par, __spec, GF_FALSE }\n\n#define TRGT_DEFINE(__type, b_rad, __par, __4cc, max_version, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 1+max_version, 0, __par, __spec, GF_FALSE }\n\n#define SGPD_DEFINE(__type, b_rad, __par, __4cc, __spec) { __type, b_rad##_box_new, b_rad##_box_del, b_rad##_box_read, b_rad##_box_write, b_rad##_box_size, b_rad##_box_dump, __4cc, 1, 0, __par, __spec, GF_FALSE }\n\n#define ITUNES_TAG(_val) \\\n\tBOX_DEFINE_S( _val, ilst_item, \"ilst data\", \"apple\")\n\nstatic struct box_registry_entry {\n\tu32 box_4cc;\n\tGF_Box * (*new_fn)();\n\tvoid (*del_fn)(GF_Box *a);\n\tGF_Err (*read_fn)(GF_Box *s, GF_BitStream *bs);\n\tGF_Err (*write_fn)(GF_Box *s, GF_BitStream *bs);\n\tGF_Err (*size_fn)(GF_Box *a);\n\tGF_Err (*dump_fn)(GF_Box *a, FILE *trace);\n\tu32 alt_4cc;//used for sample grouping type and track / item reference types\n\tu8 max_version_plus_one;\n\tu32 flags;\n\tconst char *parents_4cc;\n\tconst char *spec;\n\tBool disabled;\n\tGF_Err (*add_rem_fn)(GF_Box *par, GF_Box *b, Bool is_remove);\n} box_registry [] =\n{\n\t//DO NOT MOVE THE FIRST ENTRY\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_UNKNOWN, unkn, \"unknown\", \"unknown\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_UUID, uuid, \"unknown\", \"unknown\"),\n\n\t//all track reference types\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_META, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_HINT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_FONT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_HIND, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_VDEP, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_VPLX, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SUBT, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_THUMB, \"p12\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OD, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_DECODE, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OCR, \"p14\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_IPI, \"p14\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_BASE, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SCAL, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_TBAS, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SABT, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_OREF, \"p15\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ADDA, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ADRC, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_ILOC, \"p12\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_AVCP, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SWTO, \"p15\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SWFR, \"p15\"),\n\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_CHAP, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_TMCD, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_CDEP, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SCPT, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_SSRC, \"apple\"),\n\tTREF_DEFINE(GF_ISOM_BOX_TYPE_REFT, reftype, \"tref\", GF_ISOM_REF_LYRA, \"apple\"),\n\n\t//all item reference types\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_TBAS, \"p12\"),\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_ILOC, \"p12\"),\n\tTREF_DEFINE( GF_ISOM_BOX_TYPE_REFI, ireftype, \"iref\", GF_ISOM_REF_FDEL, \"p12\"),\n\n\t//all sample group descriptions\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_ROLL, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_PROL, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_RAP, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SEIG, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_OINF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_LINF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TRIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_NALM, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TELE, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_RASH, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_ALST, \"p12\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SAP, \"p12\"),\n\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVLL, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVSS, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_DTRT, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_MVIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SCIF, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SCNM, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_STSA, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TSAS, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SYNC, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_TSCL, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_VIPR, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_LBLI, \"p15\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_SPOR, \"p15\"),\n\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_3GAG, \"3gpp\"),\n\tSGPD_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", GF_ISOM_SAMPLE_GROUP_AVCB, \"3gpp\"),\n\n\t//internal boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRM, gnrm, \"stsd\", \"unknown\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRV, gnrv, \"stsd\", \"unknown\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GNRA, gnra, \"stsd\", \"unknown\"),\n\n\t//all track group types\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_MSRC, 0, \"p12\" ),\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_STER, 0, \"p12\" ),\n\tTRGT_DEFINE( GF_ISOM_BOX_TYPE_TRGT, trgt, \"trgr\", GF_ISOM_BOX_TYPE_CSTG, 0, \"p15\" ),\n\n\t//part12 boxes\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FREE, free, \"*\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SKIP, free, \"*\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_MDAT, mdat, \"file\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_IDAT, mdat, \"meta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_IMDA, mdat, \"file\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MOOV, moov, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MVHD, mvhd, \"moov\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MDHD, mdhd, \"mdia\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_VMHD, vmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SMHD, smhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_HMHD, hmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_NMHD, nmhd, \"minf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STHD, nmhd, \"minf\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STBL, stbl, \"minf\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_DINF, dinf, \"minf meta\"),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_URL, url, \"dref\", 0, 1),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_URN, urn, \"dref\", 0, 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CPRT, cprt, \"udta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_KIND, kind, \"udta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_HDLR, hdlr, \"mdia meta minf\", 0),\t//minf container is OK in QT ...\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRAK, trak, \"moov\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_EDTS, edts, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_UDTA, udta, \"moov trak moof traf\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_DREF, dref, \"dinf\", 0),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STSD, stsd, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STTS, stts, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CTTS, ctts, \"stbl\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CSLG, cslg, \"stbl trep\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSH, stsh, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ELST, elst, \"edts\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSC, stsc, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSZ, stsz, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STZ2, stsz, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STCO, stco, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSS, stss, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STDP, stdp, \"stbl\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SDTP, sdtp, \"stbl traf\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CO64, co64, \"stbl\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MINF, minf, \"mdia\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TKHD, tkhd, \"trak\", 1, 0x000001 | 0x000002 | 0x000004 | 0x000008),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TREF, tref, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MDIA, mdia, \"trak\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MFRA, mfra, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MFRO, mfro, \"mfra\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TFRA, tfra, \"mfra\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ELNG, elng, \"mdia\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PDIN, pdin, \"file\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SBGP, sbgp, \"stbl traf\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SGPD, sgpd, \"stbl traf\", 2),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_CSGP, csgp, \"stbl traf\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIZ, saiz, \"stbl traf\", 0, 0),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIZ, saiz, \"stbl traf\", 0, 1),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIO, saio, \"stbl traf\", 1, 0),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SAIO, saio, \"stbl traf\", 1, 1),\n\tFBOX_DEFINE_FLAGS( GF_ISOM_BOX_TYPE_SUBS, subs, \"stbl traf\", 0, 7), //warning flags are not used as a bit mask but as an enum!!\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRGR, trgr, \"trak\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FTYP, ftyp, \"file otyp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_OTYP, def_parent, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PADB, padb, \"stbl\", 0),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_BTRT, btrt, \"sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PASP, pasp, \"video_sample_entry ipco\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_CLAP, clap, \"video_sample_entry ipco\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_META, meta, \"file moov trak moof traf udta\"),\t//apple uses meta in moov->udta\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_XML, xml, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_BXML, bxml, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_ILOC, iloc, \"meta\", 2),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PITM, pitm, \"meta\", 1),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IPRO, ipro, \"meta\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_INFE, infe, \"iinf\", 3),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IINF, iinf, \"meta\", 1),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_IREF, iref, \"meta\", 1),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SINF, sinf, \"ipro sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RINF, sinf, \"sample_entry\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FRMA, frma, \"sinf rinf\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_SCHM, schm, \"sinf rinf\", 0, 1),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SCHI, schi, \"sinf rinf\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCA, audio_sample_entry, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCV, video_sample_entry, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_RESV, video_sample_entry, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TSEL, tsel, \"udta\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STRK, strk, \"udta\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STRI, stri, \"strk\", 0),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_STRD, def_parent, \"strk\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STSG, stsg, \"strd\", 0),\n\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCS, mp4s, \"stsd\"),\n\t//THIS HAS TO BE FIXED, not extensible\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCT, mp4s, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCM, mp4s, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_ENCF, mp4s, \"stsd\"),\n\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_METX, metx, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_METT, metx, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_STVI, stvi, \"schi\", 0),\n\n\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_CHNL, chnl, \"audio_sample_entry\", 0),\n\n\t//FEC\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_FIIN, fiin, \"meta\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_PAEN, paen, \"fiin\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FPAR, fpar, \"paen\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FECR, fecr, \"paen\", 1),\n\t//fire uses the same box syntax as fecr\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_FIRE, fecr, \"paen\", 1),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SEGR, segr, \"fiin\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_GITN, gitn, \"fiin\", 0),\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_FDSA, fdsa, \"fdp_sample\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FDPA, fdpa, \"fdsa\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_EXTR, extr, \"fdsa\"),\n#endif\n\n\t//full boxes todo\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_ASSP, assp, 1),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_MERE, assp, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_SRAT, srat, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_CHNL, chnl, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_DMIX, dmix, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_TLOU, alou, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_ALOU, alou, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_URI, uri, 0),\n\t//FBOX_DEFINE( GF_ISOM_BOX_TYPE_URII, urii, 0),\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SRTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_FDP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RRTP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTCP_STSD, ghnt, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_HNTI, hnti, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SDP, sdp, \"hnti\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_HINF, hinf, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TRPY, trpy, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NUMP, nump, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TPYL, tpyl, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TOTL, totl, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NPCK, npck, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TPAY, tpay, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_MAXR, maxr, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DMED, dmed, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DIMM, dimm, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DREP, drep, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TMIN, tmin, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TMAX, tmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PMAX, pmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_DMAX, dmax, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_PAYT, payt, \"hinf\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTP, rtp_hnti, \"hnti\"),\n\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RTPO, rtpo, \"rtp_packet\"),\n\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RELY, rely, \"rtp srtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TIMS, tims, \"rtp srtp rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TSRO, tsro, \"rtp srtp rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_SNRO, snro, \"rtp srtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_NAME, name, \"udta\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_TSSY, tssy, \"rrtp\"),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_RSSR, rssr, \"rrtp\"),\n\tFBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SRPP, srpp, \"srtp\", 0),\n\n#endif\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MVEX, mvex, \"moov\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MEHD, mehd, \"mvex\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TREX, trex, \"mvex\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_LEVA, leva, \"mvex\", 0),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TREP, trep, \"mvex\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_MOOF, moof, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MFHD, mfhd, \"moof\", 0),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_TRAF, traf, \"moof\"),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TFHD, tfhd, \"traf\", 0, 0x000001|0x000002|0x000008|0x000010|0x000020|0x010000|0x020000),\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_TRUN, trun, \"traf\", 0, 0x000001|0x000004|0x000100|0x000200|0x000400|0x000800),\n#ifdef GF_ENABLE_CTRN\n\tFBOX_DEFINE_FLAGS(GF_ISOM_BOX_TYPE_CTRN, trun, \"traf\", 0, 0),\n#endif\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TFDT, tfdt, \"traf\", 1),\n\tBOX_DEFINE( GF_ISOM_BOX_TYPE_STYP, ftyp, \"file\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_PRFT, prft, \"file\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SIDX, sidx, \"file\", 1),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_SSIX, ssix, \"file\", 0),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PCRB, pcrb, \"file\", \"dash\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_EMSG, emsg, \"file\", 1, \"dash\"),\n#endif\n\n\n\t//part14 boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IODS, iods, \"moov\", 0, \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4S, mp4s, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4V, video_sample_entry, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP4A, audio_sample_entry, \"stsd\", \"p14\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_M4DS, m4ds, \"sample_entry\", \"p14\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ESDS, esds, \"mp4a mp4s mp4v encv enca encs resv wave\", 0, \"p14\"),\n\n\t//part 15 boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AVCC, avcc, \"avc1 avc2 avc3 avc4 encv resv ipco dva1 dvav\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SVCC, avcc, \"avc1 avc2 avc3 avc4 svc1 svc2 encv resv\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MVCC, avcc, \"avc1 avc2 avc3 avc4 mvc1 mvc2 encv resv\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HVCC, hvcc, \"hvc1 hev1 hvc2 hev2 encv resv ipco dvh1 dvhe\", \"p15\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_LHVC, hvcc, \"hvc1 hev1 hvc2 hev2 lhv1 lhe1 encv resv ipco\", \"p15\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VVCC, vvcc, \"vvc1 vvi1 encv resv ipco dvhe\", 0, \"p15\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VVNC, vvnc, \"vvs1 encv resv ipco dvhe\", 0, \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC3, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AVC4, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_SVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HEV1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVC2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HEV2, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LHV1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LHE1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_HVT1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVC1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVI1, video_sample_entry, \"stsd\", \"p15\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VVS1, video_sample_entry, \"stsd\", \"p15\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MVCI, def_parent_full, \"minf\", 0, \"p15\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MVCG, mvcg, \"mvci\", 0, \"p15\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VWID, vwid, \"video_sample_entry\", 0, \"p15\"),\n\n\t//mpegh 3D audio boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHA1, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHA2, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHM1, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MHM2, audio_sample_entry, \"stsd\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MHAC, mhac, \"mha1 mha2 mhm1 mhm2 wave\", \"mpegh3Daudio\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MHAP, mhap, \"mha1 mha2 mhm1 mhm2 wave\", \"mpegh3Daudio\"),\n\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_IPCM, audio_sample_entry, \"stsd\", \"23003_5\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_FPCM, audio_sample_entry, \"stsd\", \"23003_5\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PCMC, pcmC, \"ipcm fpcm\", 0, \"23003_5\"),\n\n\t//AV1 in ISOBMFF boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_AV01, video_sample_entry, \"stsd\", \"av1\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_AV1C, av1c, \"av01 encv resv ipco dav1\", \"av1\"),\n\n\t// VP8-9 boxes\n\tFBOX_DEFINE_FLAGS_S( GF_ISOM_BOX_TYPE_VPCC, vpcc, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VP08, video_sample_entry, \"stsd\", \"vp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VP09, video_sample_entry, \"stsd\", \"vp\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_SMDM, SmDm, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_COLL, CoLL, \"vp08 vp09 encv resv\", 1, 0, \"vp\"),\n\n\t//Opus in ISOBMFF boxes\n#ifndef GPAC_DISABLE_OGG\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_OPUS, audio_sample_entry, \"stsd\", \"Opus\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DOPS, dOps, \"Opus wave enca\", \"Opus\"),\n#endif\n\n\t//part20 boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_LSR1, lsr1, \"stsd\", \"p20\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_LSRC, lsrc, \"lsr1\", \"p20\"),\n\n\t//part30 boxes\n#ifndef GPAC_DISABLE_TTXT\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STXT, metx, \"stsd\"),\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_TXTC, txtc, \"stxt mett sbtt\", 0),\n\t//we allow mime in any sample entry, not restricted in the spec ...\n\tFBOX_DEFINE( GF_ISOM_BOX_TYPE_MIME, txtc, \"sample_entry\", 0),\n#ifndef GPAC_DISABLE_VTT\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_WVTT, wvtt, \"stsd\", \"p30\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_VTCC_CUE, vtcu, \"vtt_sample\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTE, vtte, \"vtt_sample\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTC_CONFIG, boxstring, \"wvtt\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CTIM, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IDEN, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_STTG, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PAYL, boxstring, \"vttc\", \"p30\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VTTA, boxstring, \"vttc\", \"p30\"),\n#endif\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_STPP, metx, \"stsd\"),\n\tBOX_DEFINE_CHILD( GF_ISOM_BOX_TYPE_SBTT, metx, \"stsd\"),\n#endif\n\n\t//Image File Format\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_IPRP, iprp, \"meta\", \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IPCO, ipco, \"iprp\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISPE, ispe, \"ipco\", 0, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_COLR, colr, \"video_sample_entry ipco encv resv\", \"iff\"),\n\t//defined as a secondary box for now to avoid conflicts with master hashes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_COLR, colr, \"jp2h\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PIXI, pixi, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_RLOC, rloc, \"ipco\", 0, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IROT, irot, \"ipco\", \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IMIR, imir, \"ipco\", \"iff\"),\n\tFBOX_DEFINE_FLAGS_S( GF_ISOM_BOX_TYPE_IPMA, ipma, \"iprp\", 1, 1, \"iff\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GRPL, grpl, \"meta\", \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CCST, ccst, \"sample_entry\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AUXI, auxi, \"sample_entry\", 0, \"iff\"),\n\tTRGT_DEFINE(GF_ISOM_BOX_TYPE_GRPT, grptype, \"grpl\", GF_ISOM_BOX_TYPE_ALTR, 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AUXC, auxc, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_OINF, oinf, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TOLS, tols, \"ipco\", 0, \"iff\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IENC, ienc, \"ipco\", 0, \"cenc\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IAUX, iaux, \"ipco\", 0, \"cenc\"),\n\n\t//MIAF\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_CLLI, clli, \"video_sample_entry ipco encv resv\", \"p12\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_MDCV, mdcv, \"video_sample_entry ipco encv resv\", \"p12\"),\n\n\t//AVIF\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_A1LX, a1lx, \"ipco\", \"avif\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_A1OP, a1op, \"ipco\", \"avif\"),\n\n\t//other MPEG boxes\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_RVCC, rvcc, \"avc1 avc2 avc3 avc4 svc1 svc2 hvc1 hev1 hvc2 hev2 lhv1 lhe1 encv resv\", \"rvc\"),\n\n\t//3GPP boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_AMR, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_AMR_WB, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_QCELP, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_EVRC, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_SMV, audio_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_SUBTYPE_3GP_H263, video_sample_entry, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DAMR, gppc, \"samr sawb enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DEVC, gppc, \"sevc enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DQCP, gppc, \"sqcp enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DSMV, gppc, \"ssmv enca\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_D263, gppc, \"s263 encv\", \"3gpp\"),\n\t//3gpp timed text\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_TX3G, tx3g, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TEXT, text, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_FTAB, ftab, \"tx3g text enct\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_STYL, styl, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HLIT, hlit, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HCLR, hclr, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_KROK, krok, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DLAY, dlay, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HREF, href, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TBOX, tbox, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_BLNK, blnk, \"text_sample\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TWRP, twrp, \"text_sample\", \"3gpp\"),\n\t//3GPP dims\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_DIMS, dims, \"stsd\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DIMC, dimC, \"dims encs\", \"3gpp\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DIST, diST, \"dims\", \"3gpp\"),\n\n\n\t//CENC boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PSSH, pssh, \"moov moof meta\", 0, \"cenc\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TENC, tenc, \"schi\", 1, \"cenc\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SENC, senc, \"trak traf\", \"cenc\"),\n\n\t// ISMA 1.1 boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_IKMS, iKMS, \"schi\", 0, \"isma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISFM, iSFM, \"schi\", 0, \"isma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ISLT, iSLT, \"schi\", 0, \"isma\"),\n\n\t//OMA boxes\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODKM, odkm, \"schi\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_OHDR, ohdr, \"odkm\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_GRPI, grpi, \"ohdr\", 0, \"oma\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MDRI, mdri, \"file\", \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODTT, odtt, \"mdri\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODRB, odrb, \"mdri\", 0, \"oma\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ODAF, iSFM, \"schi\", 0, \"oma\"),\n\n\t//apple boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MP3, audio_sample_entry, \"stsd\", \"apple\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CHPL, chpl, \"udta\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_VOID, void, \"\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_WIDE, wide, \"*\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ILST, ilst, \"meta\", \"apple\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DATA, databox, \"ilst *\", 0, \"apple\"),\n\n\tITUNES_TAG(GF_ISOM_ITUNE_NAME),\n\tITUNES_TAG(GF_ISOM_ITUNE_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_ALBUM_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_ALBUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_GROUP),\n\tITUNES_TAG(GF_ISOM_ITUNE_WRITER),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMMENT),\n\tITUNES_TAG(GF_ISOM_ITUNE_GENRE_USER),\n\tITUNES_TAG(GF_ISOM_ITUNE_GENRE),\n\tITUNES_TAG(GF_ISOM_ITUNE_CREATED),\n\tITUNES_TAG(GF_ISOM_ITUNE_TRACKNUMBER),\n\tITUNES_TAG(GF_ISOM_ITUNE_DISK),\n\tITUNES_TAG(GF_ISOM_ITUNE_TEMPO),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMPILATION),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_SHOW),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_EPISODE),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_SEASON),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_EPISODE_NUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_TV_NETWORK),\n\tITUNES_TAG(GF_ISOM_ITUNE_DESCRIPTION),\n\tITUNES_TAG(GF_ISOM_ITUNE_LONG_DESCRIPTION),\n\tITUNES_TAG(GF_ISOM_ITUNE_LYRICS),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_NAME),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ALB_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_ALBUM),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_COMPOSER),\n\tITUNES_TAG(GF_ISOM_ITUNE_SORT_SHOW),\n\tITUNES_TAG(GF_ISOM_ITUNE_COVER_ART),\n\tITUNES_TAG(GF_ISOM_ITUNE_COPYRIGHT),\n\tITUNES_TAG(GF_ISOM_ITUNE_TOOL),\n\tITUNES_TAG(GF_ISOM_ITUNE_ENCODER),\n\tITUNES_TAG(GF_ISOM_ITUNE_PURCHASE_DATE),\n\tITUNES_TAG(GF_ISOM_ITUNE_PODCAST),\n\tITUNES_TAG(GF_ISOM_ITUNE_PODCAST_URL),\n\tITUNES_TAG(GF_ISOM_ITUNE_KEYWORDS),\n\tITUNES_TAG(GF_ISOM_ITUNE_CATEGORY),\n\tITUNES_TAG(GF_ISOM_ITUNE_HD_VIDEO),\n\tITUNES_TAG(GF_ISOM_ITUNE_MEDIA_TYPE),\n\tITUNES_TAG(GF_ISOM_ITUNE_RATING),\n\tITUNES_TAG(GF_ISOM_ITUNE_GAPLESS),\n\tITUNES_TAG(GF_ISOM_ITUNE_COMPOSER),\n\tITUNES_TAG(GF_ISOM_ITUNE_TRACK),\n\tITUNES_TAG(GF_ISOM_ITUNE_CONDUCTOR),\n\tITUNES_TAG(GF_ISOM_ITUNE_ART_DIRECTOR),\n\tITUNES_TAG(GF_ISOM_ITUNE_ARRANGER),\n\tITUNES_TAG(GF_ISOM_ITUNE_LYRICIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_COPY_ACK),\n\tITUNES_TAG(GF_ISOM_ITUNE_SONG_DESC),\n\tITUNES_TAG(GF_ISOM_ITUNE_DIRECTOR),\n\tITUNES_TAG(GF_ISOM_ITUNE_EQ_PRESET),\n\tITUNES_TAG(GF_ISOM_ITUNE_LINER_NOTES),\n\tITUNES_TAG(GF_ISOM_ITUNE_REC_COMPANY),\n\tITUNES_TAG(GF_ISOM_ITUNE_ORIG_ARTIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_PHONO_RIGHTS),\n\tITUNES_TAG(GF_ISOM_ITUNE_PRODUCER),\n\tITUNES_TAG(GF_ISOM_ITUNE_PERFORMER),\n\tITUNES_TAG(GF_ISOM_ITUNE_PUBLISHER),\n\tITUNES_TAG(GF_ISOM_ITUNE_SOUND_ENG),\n\tITUNES_TAG(GF_ISOM_ITUNE_SOLOIST),\n\tITUNES_TAG(GF_ISOM_ITUNE_CREDITS),\n\tITUNES_TAG(GF_ISOM_ITUNE_THANKS),\n\tITUNES_TAG(GF_ISOM_ITUNE_ONLINE),\n\tITUNES_TAG(GF_ISOM_ITUNE_EXEC_PRODUCER),\n\tITUNES_TAG(GF_ISOM_ITUNE_LOCATION),\n\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_iTunesSpecificInfo, ilst_item, \"ilst data\", \"apple\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_GMHD, def_parent, \"minf\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_LOAD, load, \"trak\", \"apple\"),\n\tBOX_DEFINE_S(GF_QT_BOX_TYPE_TAPT, def_parent, \"trak\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_GMIN, gmin, \"gmhd\", 0, \"apple\"),\n\tFBOX_DEFINE_FLAGS_S( GF_QT_BOX_TYPE_ALIS, alis, \"dref\", 0, 1, \"apple\"),\n\tFBOX_DEFINE_FLAGS_S( GF_QT_BOX_TYPE_CIOS, alis, \"dref\", 0, 1, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_CLEF, clef, \"tapt\", 0, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_PROF, clef, \"tapt\", 0, \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_ENOF, clef, \"tapt\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_WAVE, def_parent, \"audio_sample_entry\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_CHAN, chan, \"audio_sample_entry\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_FRMA, frma, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TERMINATOR, unkn, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_ENDA, chrm, \"wave\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TMCD, def_parent, \"gmhd\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_NAME, unkn, \"tmcd\", \"apple\"),\n\tFBOX_DEFINE_S( GF_QT_BOX_TYPE_TCMI, tcmi, \"tmcd\", 0, \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_FIEL, fiel, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_GAMA, gama, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_CHRM, chrm, \"video_sample_entry\", \"apple\"),\n\tBOX_DEFINE_S( GF_ISOM_SUBTYPE_TEXT, unkn, \"gmhd\", \"apple\"),\n\n\t//QT and prores sample entry types\n\tBOX_DEFINE_S( GF_QT_BOX_TYPE_TMCD, tmcd, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S( GF_QT_SUBTYPE_C608, gen_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCH, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCO, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCS, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_APCN, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_AP4X, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_AP4H, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RAW_AUD, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_TWOS, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_SOWT, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_FL32, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_FL64, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IN24, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IN32, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ULAW, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ALAW, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ADPCM, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IMA_ADPCM, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_DVCA, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QDMC, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QDMC2, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_QCELP, audio_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_kMP3, audio_sample_entry, \"stsd\", \"apple\"),\n\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RAW_VID, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUYV, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_UYVY, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV444, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUVA444, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV422_10, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV444_10, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV422_16, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YUV420, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_I420, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_IYUV, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YV12, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YVYU, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RGBA, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ABGR, video_sample_entry, \"stsd\", \"apple\"),\n\n\tFBOX_DEFINE_S(GF_QT_BOX_TYPE_STPS, stss, \"stbl\", 0, \"apple\"),\n\n\t//dolby boxes\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AC3, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_EC3, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DAC3, dac3, \"ac-3 wave enca\", \"dolby\"),\n\t{GF_ISOM_BOX_TYPE_DEC3, dec3_box_new, dac3_box_del, dac3_box_read, dac3_box_write, dac3_box_size, dac3_box_dump, 0, 0, 0, \"ec-3 wave enca\", \"dolby\" },\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DVCC, dvcC, \"dvav dva1 dvhe dvh1 dav1 avc1 avc2 avc3 avc4 hev1 hvc1 av01 encv resv\", \"DolbyVision\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DVVC, dvvC, \"dvav dva1 dvhe dvh1 dav1 avc1 avc2 avc3 avc4 hev1 hvc1 av01 encv resv\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVHE, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVH1, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVA1, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DVAV, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_DAV1, video_sample_entry, \"stsd\", \"DolbyVision\"),\n\tBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_MLPA, audio_sample_entry, \"stsd\", \"dolby\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_DMLP, dmlp, \"mlpa enca\", \"dolby\"),\n\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_HVCE, hvcc, \"hvc1 hev1 hvc2 hev2 encv resv ipco dvh1 dvhe\", \"DolbyVision\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AVCE, avcc, \"avc1 avc2 avc3 avc4 encv resv ipco dva1 dvav\", \"DolbyVision\"),\n\n\n\t//Adobe boxes\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ABST, abst, \"file\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AFRA, afra, \"file\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ASRT, asrt, \"abst\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AFRT, afrt, \"abst\", 0, \"adobe\"),\n#endif\n\t/*Adobe's protection boxes*/\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_ADKM, adkm, \"schi\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AHDR, ahdr, \"adkm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ADAF, adaf, \"adkm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_APRM, aprm, \"ahdr\", 0, \"adobe\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_AEIB, aeib, \"aprm\", 0, \"adobe\"),\n\tFBOX_DEFINE_S_CHILD( GF_ISOM_BOX_TYPE_AKEY, akey, \"aprm\", 0, \"adobe\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_FLXS, flxs, \"akey\", \"adobe\"),\n\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_TRIK, trik, \"traf\", 0, \"dece\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_BLOC, bloc, \"file\", 0, \"dece\"),\n\tFBOX_DEFINE_FLAGS_S(GF_ISOM_BOX_TYPE_AINF, ainf, \"moov\", 0, 0x000001, \"dece\"),\n\n\n\t//internally handled UUID for smooth - the code points are only used during creation and assigned to UUIDBox->internal4CC\n\t//the box type is still \"uuid\", and the factory is used to read/write/size/dump the code\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TENC, piff_tenc, \"schi\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_PSEC, piff_psec, \"trak traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_PSSH, piff_pssh, \"moov moof\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFXD, tfxd, \"traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFRF, tfrf, \"traf\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_MSSM, uuid, \"file\", \"smooth\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_UUID_TFRF, uuid, \"traf\", \"smooth\"),\n\n\n\t//J2K boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_MJP2, video_sample_entry, \"stsd\", \"j2k\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JP2H, jp2h, \"mjp2 encv\", \"j2k\"),\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_IHDR, ihdr, \"jp2h\", \"j2k\"),\n\n\t/* Image tracks */\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JPEG, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_JP2K, video_sample_entry, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_PNG, video_sample_entry, \"stsd\", \"apple\"),\n\n\n\t//flac in ISOBMFF boxes\n\tBOX_DEFINE_S_CHILD(GF_ISOM_BOX_TYPE_FLAC, audio_sample_entry, \"stsd\", \"Flac\"),\n\tFBOX_DEFINE_S(GF_ISOM_BOX_TYPE_DFLA, dfla, \"fLaC enca\", 0, \"Flac\"),\n\n\tBOX_DEFINE_S(GF_ISOM_BOX_TYPE_XTRA, xtra, \"udta\", \"WMA\"),\n\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_ST3D, st3d, \"video_sample_entry\", 0, \"youtube\"),\n\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SV3D, def_parent, \"video_sample_entry\", \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_SVHD, svhd, \"sv3d\", 0, \"youtube\"),\n\tBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PROJ, def_parent, \"sv3d\", \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_PRHD, prhd, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_CBMP, proj_type, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_EQUI, proj_type, \"proj\", 0, \"youtube\"),\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_MESH, proj_type, \"proj\", 0, \"youtube\"),\n\n\tFBOX_DEFINE_S( GF_ISOM_BOX_TYPE_KEYS, keys, \"meta\", 0, \"apple\"),\n\n\tBOX_DEFINE_S(GF_QT_SUBTYPE_ALAC, unkn, \"stsd\", \"apple\"),\n\tBOX_DEFINE_S(GF_ISOM_SUBTYPE_FFV1, unkn, \"stsd\", \"ffmpeg\"),\n\n\tBOX_DEFINE_S(GF_4CC('v','c','-','1'), unkn, \"stsd\", \"smpte-RP2025\"),\n\tBOX_DEFINE_S(GF_4CC('d','v','c','1'), unkn, \"vc-1 ipco\", \"smpte-RP2025\"),\n\n\tBOX_DEFINE_S(GF_4CC('G','M','C','W'), unkn, \"stsd\", \"GPAC\"),\n\tBOX_DEFINE_S(GF_4CC('G','M','C','C'), unkn, \"GMCW\", \"GPAC\"),\n\n\t/* for now we don't parse these*/\n\tBOX_DEFINE_S(GF_4CC('u','n','c','C'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('c','m','p','d'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('c','p','a','l'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('c','p','a','t'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('c','l','e','v'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('s','p','l','z'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('s','n','u','c'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('s','b','p','m'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('c','l','o','c'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('f','p','c','k'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('d','i','s','i'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\tBOX_DEFINE_S(GF_4CC('d','e','p','i'), unkn, \"video_sample_entry ipco\", \"rawff\"),\n\n/*\n\tGF_ISOM_BOX_TYPE_CBMP\t= GF_4CC( 'c', 'b', 'm', 'p' ),\n\tGF_ISOM_BOX_TYPE_EQUI\t= GF_4CC( 'e', 'q', 'u', 'i' ),\n\tGF_ISOM_BOX_TYPE_MSHP\t= GF_4CC( 'm', 's', 'h', 'p' ),\n\tGF_ISOM_BOX_TYPE_MESH\t= GF_4CC( 'm', 'e', 's', 'h' ),\n*/\n\n};\n\nBool gf_box_valid_in_parent(GF_Box *a, const char *parent_4cc)\n{\n\tif (!a || !a->registry || !a->registry->parents_4cc) return GF_FALSE;\n\tif (strstr(a->registry->parents_4cc, parent_4cc) != NULL) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_num_supported_boxes()\n{\n\treturn sizeof(box_registry) / sizeof(struct box_registry_entry);\n}\n\nvoid gf_isom_registry_disable(u32 boxCode, Bool disable)\n{\n\tu32 i=0, count = gf_isom_get_num_supported_boxes();\n\tfor (i=1; i<count; i++) {\n\t\tif (box_registry[i].box_4cc==boxCode) {\n\t\t\tbox_registry[i].disabled = disable;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic u32 get_box_reg_idx(u32 boxCode, u32 parent_type, u32 start_from)\n{\n\tu32 i=0, count = gf_isom_get_num_supported_boxes();\n\tif (!start_from) start_from = 1;\n\n\tfor (i=start_from; i<count; i++) {\n\t\tu32 start_par_from;\n\t\tif (box_registry[i].box_4cc != boxCode)\n\t\t\tcontinue;\n\n\t\tif (!parent_type)\n\t\t\treturn i;\n\t\tif (strstr(box_registry[i].parents_4cc, gf_4cc_to_str(parent_type)) != NULL)\n\t\t\treturn i;\n\t\tif (strstr(box_registry[i].parents_4cc, \"*\") != NULL)\n\t\t\treturn i;\n\n\t\tif (strstr(box_registry[i].parents_4cc, \"sample_entry\") == NULL)\n\t\t\tcontinue;\n\n\t\t/*parent is a sample entry, check if the parent_type matches a sample entry box (eg its parent must be stsd)*/\n\n\t\tif (parent_type==GF_QT_SUBTYPE_RAW)\n\t\t\treturn i;\n\n\t\tstart_par_from = 0;\n\t\twhile (parent_type) {\n\t\t\t//locate parent registry\n\t\t\tu32 j = get_box_reg_idx(parent_type, 0, start_par_from);\n\t\t\tif (!j) break;\n\t\t\t//if parent registry has \"stsd\" as parent, this is a sample entry\n\t\t\tif (box_registry[j].parents_4cc && (strstr(box_registry[j].parents_4cc, \"stsd\") != NULL))\n\t\t\t\treturn i;\n\t\t\tstart_par_from = j+1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nGF_Box *gf_isom_box_new_ex(u32 boxType, u32 parentType, Bool skip_logs, Bool is_root_box)\n{\n\tGF_Box *a;\n\ts32 idx = get_box_reg_idx(boxType, parentType, 0);\n\tif (idx==0) {\n#ifndef GPAC_DISABLE_LOG\n\t\tif (!skip_logs && (boxType != GF_ISOM_BOX_TYPE_UNKNOWN) && (boxType != GF_ISOM_BOX_TYPE_UUID)) {\n\t\t\tswitch (parentType) {\n\t\t\tcase GF_ISOM_BOX_TYPE_ILST:\n\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tcase GF_ISOM_BOX_TYPE_iTunesSpecificInfo:\n\t\t\tcase GF_QT_BOX_TYPE_WAVE:\n\t\t\t\tbreak;\n\t\t\t//some sample descritions are handled as generic ones but we know them, don't warn\n\t\t\tcase GF_ISOM_BOX_TYPE_STSD:\n\t\t\t\t//fallthrough\n\t\t\tdefault:\n\t\t\t\tif (boxType==GF_ISOM_BOX_TYPE_GDAT) break;\n\n\t\t\t\tif (is_root_box) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown top-level box type %s\\n\", gf_4cc_to_str(boxType)));\n\t\t\t\t} else if (parentType) {\n\t\t\t\t\tchar szName[GF_4CC_MSIZE];\n\t\t\t\t\tstrcpy(szName, gf_4cc_to_str(parentType));\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown box type %s in parent %s\\n\", gf_4cc_to_str(boxType), szName));\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Unknown box type %s\\n\", gf_4cc_to_str(boxType)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n        if (boxType==GF_ISOM_BOX_TYPE_UUID) {\n            a = uuid_box_new();\n            if (a) a->registry = &box_registry[1];\n        } else {\n            a = unkn_box_new();\n            if (a) {\n            \t((GF_UnknownBox *)a)->original_4cc = boxType;\n            \ta->registry = &box_registry[0];\n\t\t\t}\n        }\n\t\treturn a;\n\t}\n\ta = box_registry[idx].new_fn();\n\n\tif (a) {\n\t\tif (a->type!=GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t\t((GF_UnknownBox *)a)->original_4cc = boxType;\n\t\t\t} else {\n\t\t\t\ta->type = boxType;\n\t\t\t}\n\t\t}\n\t\ta->registry = &box_registry[idx];\n\n\t\tif ((a->type==GF_ISOM_BOX_TYPE_COLR) && (parentType==GF_ISOM_BOX_TYPE_JP2H)) {\n\t\t\t((GF_ColourInformationBox *)a)->is_jp2 = GF_TRUE;\n\t\t}\n\n\t}\n\treturn a;\n}\n\nGF_EXPORT\nGF_Box *gf_isom_box_new(u32 boxType)\n{\n\treturn gf_isom_box_new_ex(boxType, 0, 0, GF_FALSE);\n}\n\nGF_Err gf_isom_box_array_read(GF_Box *parent, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 parent_type = parent->type;\n\tGF_Box *a = NULL;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (parent->size>=8) {\n\t\te = gf_isom_box_parse_ex(&a, bs, parent_type, GF_FALSE, skip_logs ? 0 : parent->size);\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn (e==GF_SKIP_BOX) ? GF_OK : e;\n\t\t}\n\t\t//sub box parsing aborted with no error\n\t\tif (!a) return GF_OK;\n\n\t\tif (parent->size < a->size) {\n\t\t\tif (!skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is larger than container box\\n\", gf_4cc_to_str(a->type)));\n\t\t\t}\n\t\t\tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tparent->size = 0;\n\t\t} else {\n\t\t\tparent->size -= a->size;\n\t\t}\n\n\t\t//check container validity\n\t\tif (parent_type && strlen(a->registry->parents_4cc)) {\n\t\t\tBool parent_OK = GF_FALSE;\n\t\t\tconst char *parent_code = gf_4cc_to_str(parent->type);\n\t\t\tif (parent->type == GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\tparent_code = gf_4cc_to_str( ((GF_UnknownBox*)parent)->original_4cc );\n\t\t\tif (strstr(a->registry->parents_4cc, parent_code) != NULL) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else if (!strcmp(a->registry->parents_4cc, \"*\") || strstr(a->registry->parents_4cc, \"* \") || strstr(a->registry->parents_4cc, \" *\")) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else {\n\t\t\t\t//parent must be a sample entry\n\t\t\t\tif (strstr(a->registry->parents_4cc, \"sample_entry\") !=\tNULL) {\n\t\t\t\t\t//parent is in an stsd\n\t\t\t\t\tif (strstr(parent->registry->parents_4cc, \"stsd\") != NULL) {\n\t\t\t\t\t\tif (strstr(a->registry->parents_4cc, \"video_sample_entry\") !=\tNULL) {\n\t\t\t\t\t\t\tif (((GF_SampleEntryBox*)parent)->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//other types are sample formats, eg a 3GPP text sample, RTP hint sample or VTT cue. Not handled at this level\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) parent_OK = GF_TRUE;\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UUID) parent_OK = GF_TRUE;\n\t\t\t}\n\t\t\tif (! parent_OK && !skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is invalid in container %s\\n\", gf_4cc_to_str(a->type), parent_code));\n\t\t\t}\n\t\t}\n\n\t\t//always register boxes\n\t\tif (!parent->child_boxes) {\n\t\t\tparent->child_boxes = gf_list_new();\n\t\t\tif (!parent->child_boxes) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(parent->child_boxes, a);\n\t\tif (e) return e;\n\n\t\tif (parent->registry && parent->registry->add_rem_fn) {\n\t\t\te = parent->registry->add_rem_fn(parent, a, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\tif (e == GF_ISOM_INVALID_MEDIA) return GF_OK;\n\t\t\t\t//if the box is no longer present, consider it destroyed\n\t\t\t\tif (gf_list_find(parent->child_boxes, a) >=0) {\n\t\t\t\t\tgf_isom_box_del_parent(&parent->child_boxes, a);\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\n\n\nGF_Err gf_isom_box_read(GF_Box *a, GF_BitStream *bs)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn a->registry->read_fn(a, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gf_isom_box_write_listing(GF_Box *a, GF_BitStream *bs)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Write invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn a->registry->write_fn(a, bs);\n}\n\n\nvoid gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\n\t//happens when partially cloning boxes\n\tif (cur_pos < 0) return;\n\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;\n}\n\nvoid gf_isom_check_position_list(GF_Box *s, GF_List *childlist, u32 *pos)\n{\n\tu32 i, count;\n\tif (!s || (s->internal_flags & GF_ISOM_ORDER_FREEZE))\n\t\treturn;\n\tcount = gf_list_count(childlist);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *child = gf_list_get(childlist, i);\n\t\tgf_isom_check_position(s, child, pos);\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\t//box has been disabled, do not write\n\tif (!a->size) return GF_OK;\n\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;\n}\n\nstatic GF_Err gf_isom_box_size_listing(GF_Box *a)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Size invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\ta->size = 8;\n\n\tif (a->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\ta->size += 16;\n\t}\n\t//the large size is handled during write, cause at this stage we don't know the size\n\tif (a->registry->max_version_plus_one) {\n\t\ta->size += 4;\n\t}\n\treturn a->registry->size_fn(a);\n}\n\nGF_EXPORT\nGF_Err gf_isom_box_size(GF_Box *a)\n{\n\tGF_Err e;\n\tif (!a) return GF_BAD_PARAM;\n\tif (a->registry->disabled) {\n\t\ta->size = 0;\n\t\treturn GF_OK;\n\t}\n\te = gf_isom_box_size_listing(a);\n\tif (e) return e;\n\t//box size set to 0 (not even a header), abort traversal\n\tif (!a->size) return GF_OK;\n\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_size(a, a->child_boxes);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nstatic GF_Err gf_isom_full_box_read(GF_Box *ptr, GF_BitStream *bs)\n{\n\tif (ptr->registry->max_version_plus_one) {\n\t\tGF_FullBox *self = (GF_FullBox *) ptr;\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tself->version = gf_bs_read_u8(bs);\n\t\tself->flags = gf_bs_read_u24(bs);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_dump_supported_box(u32 idx, FILE * trace)\n{\n\tu32 i;\n\tu32 nb_versions=0;\n\tGF_Err e;\n\n\tif (box_registry[idx].max_version_plus_one) {\n\t\tnb_versions = box_registry[idx].max_version_plus_one - 1;\n\t}\n\tfor (i = 0; i <= nb_versions; i++) {\n\t\tGF_Box *a = box_registry[idx].new_fn();\n\t\tif (!a) return GF_OUT_OF_MEM;\n\n\t\ta->registry = &box_registry[idx];\n\n\t\tif (box_registry[idx].alt_4cc) {\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_REFT)\n\t\t\t\t((GF_TrackReferenceTypeBox*)a)->reference_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_REFI)\n\t\t\t\t((GF_ItemReferenceTypeBox*)a)->reference_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_TRGT)\n\t\t\t\t((GF_TrackGroupTypeBox*)a)->group_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_SGPD)\n\t\t\t\t((GF_SampleGroupDescriptionBox*)a)->grouping_type = box_registry[idx].alt_4cc;\n\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_GRPT)\n\t\t\t\t((GF_EntityToGroupTypeBox*)a)->grouping_type = box_registry[idx].alt_4cc;\n\t\t}\n\t\tif (box_registry[idx].max_version_plus_one) {\n\t\t\t((GF_FullBox *)a)->version = i;\n\t\t}\n\t\tif (box_registry[idx].flags) {\n\t\t\tu32 flag_mask=1;\n\t\t\tu32 flags = box_registry[idx].flags;\n\t\t\t((GF_FullBox *)a)->flags = 0;\n\t\t\te = gf_isom_box_dump(a, trace);\n\n\t\t\t//we dump all flags individually and this for all version, in order to simplify the XSLT processing\n\t\t\twhile (!e) {\n\t\t\t\tu32 flag = flags & flag_mask;\n\t\t\t\tflag_mask <<= 1;\n\t\t\t\tif (flag) {\n\t\t\t\t\t((GF_FullBox *)a)->flags = flag;\n\t\t\t\t\te = gf_isom_box_dump(a, trace);\n\t\t\t\t}\n\t\t\t\tif (flag_mask > flags) break;\n\t\t\t\tif (flag_mask == 0x80000000) break;\n\t\t\t}\n\n\t\t} else {\n\t\t\te = gf_isom_box_dump(a, trace);\n\t\t}\n\n\t\tgf_isom_box_del(a);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nu32 gf_isom_get_supported_box_type(u32 idx)\n{\n\treturn box_registry[idx].box_4cc;\n}\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\nGF_Err gf_isom_box_dump_start_ex(GF_Box *a, const char *name, FILE * trace, Bool force_version)\n{\n\tgf_fprintf(trace, \"<%s \", name);\n\tif (a->size > 0xFFFFFFFF) {\n\t\tgf_fprintf(trace, \"LargeSize=\\\"\"LLU\"\\\" \", a->size);\n\t} else {\n\t\tgf_fprintf(trace, \"Size=\\\"%u\\\" \", (u32) a->size);\n\t}\n\tif (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tgf_fprintf(trace, \"Type=\\\"%s\\\" \", gf_4cc_to_str(((GF_UnknownBox*)a)->original_4cc));\n\t} else {\n\t\tgf_fprintf(trace, \"Type=\\\"%s\\\" \", gf_4cc_to_str(a->type));\n\t}\n\n\tif (a->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\tu32 i;\n\t\tgf_fprintf(trace, \"UUID=\\\"{\");\n\t\tfor (i=0; i<16; i++) {\n\t\t\tgf_fprintf(trace, \"%02X\", (unsigned char) ((GF_UUIDBox*)a)->uuid[i]);\n\t\t\tif ((i<15) && (i%4)==3) gf_fprintf(trace, \"-\");\n\t\t}\n\t\tgf_fprintf(trace, \"}\\\" \");\n\t}\n\n\tif (a->registry->max_version_plus_one || force_version) {\n\t\tgf_fprintf(trace, \"Version=\\\"%d\\\" Flags=\\\"%d\\\" \", ((GF_FullBox*)a)->version,((GF_FullBox*)a)->flags);\n\t}\n\tgf_fprintf(trace, \"Specification=\\\"%s\\\" \", a->registry->spec);\n\n\t//don't write containers in test mode, that would require rewriting hashes whenever spec changes\n\tif (!gf_sys_is_test_mode()) {\n\t\tgf_fprintf(trace, \"Container=\\\"%s\\\" \", a->registry->parents_4cc);\n\t}\n\treturn GF_OK;\n}\nGF_Err gf_isom_box_dump_start(GF_Box *a, const char *name, FILE * trace)\n{\n\treturn gf_isom_box_dump_start_ex(a, name, trace, GF_FALSE);\n}\n\nGF_Err gf_isom_box_dump(void *ptr, FILE * trace)\n{\n\tGF_Box *a = (GF_Box *) ptr;\n\n\tif (!a) {\n\t\tgf_fprintf(trace, \"<!--ERROR: NULL Box Found-->\\n\");\n\t\treturn GF_OK;\n\t}\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] trying to dump box %s not registered\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\ta->registry->dump_fn(a, trace);\n\treturn GF_OK;\n}\n\nvoid gf_isom_box_dump_done(const char *name, GF_Box *ptr, FILE *trace)\n{\n\tif (ptr && ptr->child_boxes) {\n\t\tgf_isom_box_array_dump(ptr->child_boxes, trace);\n\t}\n\tif (name)\n\t\tgf_fprintf(trace, \"</%s>\\n\", name);\n}\n\nBool gf_isom_box_is_file_level(GF_Box *s)\n{\n\tif (!s || !s->registry) return GF_FALSE;\n\tif (strstr(s->registry->parents_4cc, \"file\")!= NULL) return GF_TRUE;\n\tif (strstr(s->registry->parents_4cc, \"*\")!= NULL) return GF_TRUE;\n\treturn GF_FALSE;\n}\n#endif\n\n\nGF_Box *gf_isom_box_find_child(GF_List *children, u32 code)\n{\n\tu32 i, count;\n\tif (!children) return NULL;\n\tcount = gf_list_count(children);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *c = gf_list_get(children, i);\n\t\tif (c->type==code) return c;\n\n\t\tif (c->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tif (((GF_UnknownBox*)c)->original_4cc==code)\n\t\t\t\treturn c;\n\t\t}\n\t\tif (c->type==GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (((GF_UUIDBox*)c)->internal_4cc==code)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nBool gf_isom_box_check_unique(GF_List *children, GF_Box *a)\n{\n\tu32 i, count;\n\tif (!children) return GF_TRUE;\n\tcount = gf_list_count(children);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *c = gf_list_get(children, i);\n\t\tif (c==a) continue;\n\t\tif (c->type==a->type) return GF_FALSE;\n\t}\n\treturn GF_TRUE;\n}\n\nvoid gf_isom_box_del_parent(GF_List **child_boxes, GF_Box*b)\n{\n\tif (child_boxes) {\n\t\tgf_list_del_item(*child_boxes, b);\n\t\tif (!gf_list_count(*child_boxes)) {\n\t\t\tgf_list_del(*child_boxes);\n\t\t\t*child_boxes = NULL;\n\t\t}\n\t}\n\tgf_isom_box_del(b);\n}\n\nvoid gf_isom_box_remove_from_parent(GF_Box *parent_box, GF_Box *box)\n{\n\tif (parent_box && parent_box->registry && parent_box->registry->add_rem_fn) {\n\t\tparent_box->registry->add_rem_fn(parent_box, box, GF_TRUE);\n\t}\n}\n\nGF_Box *gf_isom_box_new_parent(GF_List **parent, u32 code)\n{\n\tGF_Box *b = gf_isom_box_new(code);\n\tif (!b) return NULL;\n\tif (! (*parent) ) (*parent)  = gf_list_new();\n\tgf_list_add(*parent, b);\n\treturn b;\n}\n\nvoid gf_isom_box_freeze_order(GF_Box *box)\n{\n\tu32 i=0;\n\tGF_Box *child;\n\tif (!box) return;\n\tbox->internal_flags |= GF_ISOM_ORDER_FREEZE;\n\n\twhile ((child = gf_list_enum(box->child_boxes, &i))) {\n\t\tgf_isom_box_freeze_order(child);\n\t}\n\n}\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n//the only static var. Used to store any error happening while opening a movie\nstatic GF_Err MP4_API_IO_Err;\n\nvoid gf_isom_set_last_error(GF_ISOFile *movie, GF_Err error)\n{\n\tif (!movie) {\n\t\tMP4_API_IO_Err = error;\n\t} else {\n\t\tmovie->LastError = error;\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_last_error(GF_ISOFile *the_file)\n{\n\tif (!the_file) return MP4_API_IO_Err;\n\treturn the_file->LastError;\n}\n\nGF_EXPORT\nu8 gf_isom_get_mode(GF_ISOFile *the_file)\n{\n\tif (!the_file) return 0;\n\treturn the_file->openMode;\n}\n\n#if 0 //unused\n/*! gets file size of an ISO file\n\\param isom_file the target ISO file\n\\return the file size in bytes\n*/\nu64 gf_isom_get_file_size(GF_ISOFile *the_file)\n{\n\tif (!the_file) return 0;\n\tif (the_file->movieFileMap) return gf_bs_get_size(the_file->movieFileMap->bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (the_file->editFileMap) return gf_bs_get_size(the_file->editFileMap->bs);\n#endif\n\treturn 0;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_freeze_order(GF_ISOFile *file)\n{\n\tu32 i=0;\n\tGF_Box *box;\n\tif (!file) return GF_BAD_PARAM;\n\twhile ((box=gf_list_enum(file->TopBoxes, &i))) {\n\t\tgf_isom_box_freeze_order(box);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_inplace_padding(GF_ISOFile *file, u32 padding)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->padding = padding;\n\treturn GF_OK;\n}\n/**************************************************************\n\t\t\t\t\tSample Manip\n**************************************************************/\n\n//creates a new empty sample\nGF_EXPORT\nGF_ISOSample *gf_isom_sample_new()\n{\n\tGF_ISOSample *tmp;\n\tGF_SAFEALLOC(tmp, GF_ISOSample);\n\treturn tmp;\n}\n\n//delete a sample\nGF_EXPORT\nvoid gf_isom_sample_del(GF_ISOSample **samp)\n{\n\tif (!samp || ! *samp) return;\n\tif ((*samp)->data && (*samp)->dataLength) gf_free((*samp)->data);\n\tgf_free(*samp);\n\t*samp = NULL;\n}\n\nstatic u32 gf_isom_probe_type(u32 type)\n{\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_FTYP:\n\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\treturn 2;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tcase GF_ISOM_BOX_TYPE_MOOF:\n\tcase GF_ISOM_BOX_TYPE_STYP:\n\tcase GF_ISOM_BOX_TYPE_SIDX:\n\tcase GF_ISOM_BOX_TYPE_EMSG:\n\tcase GF_ISOM_BOX_TYPE_PRFT:\n    //we map free as segment when it is first in the file - a regular file shall start with ftyp or a file sig, not free\n    //since our route stack may patch boxes to free for incomplete segments, we must map this to free\n    case GF_ISOM_BOX_TYPE_FREE:\n\t\treturn 3;\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\t/*Adobe specific*/\n\tcase GF_ISOM_BOX_TYPE_AFRA:\n\tcase GF_ISOM_BOX_TYPE_ABST:\n#endif\n#endif\n\tcase GF_ISOM_BOX_TYPE_MDAT:\n\tcase GF_ISOM_BOX_TYPE_SKIP:\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\tcase GF_ISOM_BOX_TYPE_META:\n\tcase GF_ISOM_BOX_TYPE_VOID:\n\tcase GF_ISOM_BOX_TYPE_JP:\n\tcase GF_QT_BOX_TYPE_WIDE:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nGF_EXPORT\nu32 gf_isom_probe_file_range(const char *fileName, u64 start_range, u64 end_range)\n{\n\tu32 type = 0;\n\n\tif (!strncmp(fileName, \"gmem://\", 7)) {\n\t\tu32 size;\n\t\tu8 *mem_address;\n\t\tif (gf_blob_get(fileName, &mem_address, &size, NULL) != GF_OK) {\n\t\t\treturn 0;\n\t\t}\n        if (size && (size > start_range + 8)) {\n\t\t\ttype = GF_4CC(mem_address[start_range + 4], mem_address[start_range + 5], mem_address[start_range + 6], mem_address[start_range + 7]);\n        }\n        gf_blob_release(fileName);\n\t} else if (!strncmp(fileName, \"isobmff://\", 10)) {\n\t\treturn 2;\n\t} else {\n\t\tu32 nb_read;\n\t\tunsigned char data[4];\n\t\tFILE *f = gf_fopen(fileName, \"rb\");\n\t\tif (!f) return 0;\n\t\tif (start_range) gf_fseek(f, start_range, SEEK_SET);\n\t\ttype = 0;\n\t\tnb_read = (u32) gf_fread(data, 4, f);\n\t\tif (nb_read == 4) {\n\t\t\tif (gf_fread(data, 4, f) == 4) {\n\t\t\t\ttype = GF_4CC(data[0], data[1], data[2], data[3]);\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t\tif (!nb_read) return 0;\n\t}\n\treturn gf_isom_probe_type(type);\n}\n\nGF_EXPORT\nu32 gf_isom_probe_file(const char *fileName)\n{\n\treturn gf_isom_probe_file_range(fileName, 0, 0);\n}\n\nGF_EXPORT\nu32 gf_isom_probe_data(const u8*inBuf, u32 inSize)\n{\n\tu32 type;\n\tif (inSize < 8) return 0;\n\ttype = GF_4CC(inBuf[4], inBuf[5], inBuf[6], inBuf[7]);\n\treturn gf_isom_probe_type(type);\n}\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n#include <gpac/internal/media_dev.h>\n#endif\n\nstatic GF_Err isom_create_init_from_mem(const char *fileName, GF_ISOFile *file)\n{\n\tu32 sample_rate=0;\n\tu32 nb_channels=0;\n\tu32 bps=0;\n\t//u32 atag=0;\n\tu32 nal_len=4;\n\tu32 width = 0;\n\tu32 height = 0;\n\tu32 timescale = 10000000;\n\tu64 tfdt = 0;\n\tchar sz4cc[5];\n\tchar CodecParams[2048];\n\tu32 CodecParamLen=0;\n\tchar *sep, *val;\n\tGF_TrackBox *trak;\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleTableBox *stbl;\n\n\tsz4cc[0] = 0;\n\n\tval = (char*) ( fileName + strlen(\"isobmff://\") );\n\twhile (1)  {\n\t\tsep = strchr(val, ' ');\n\t\tif (sep) sep[0] = 0;\n\n\t\tif (!strncmp(val, \"4cc=\", 4)) strcpy(sz4cc, val+4);\n\t\telse if (!strncmp(val, \"init=\", 5)) {\n\t\t\tchar szH[3], *data = val+5;\n\t\t\tu32 i, len = (u32) strlen(data);\n\t\t\tfor (i=0; i<len; i+=2) {\n\t\t\t\tu32 v;\n\t\t\t\t//init is hex-encoded so 2 input bytes for one output char\n\t\t\t\tszH[0] = data[i];\n\t\t\t\tszH[1] = data[i+1];\n\t\t\t\tszH[2] = 0;\n\t\t\t\tsscanf(szH, \"%X\", &v);\n\t\t\t\tCodecParams[CodecParamLen] = (char) v;\n\t\t\t\tCodecParamLen++;\n\t\t\t}\n\t\t}\n\t\telse if (!strncmp(val, \"nal=\", 4)) nal_len = atoi(val+4);\n\t\telse if (!strncmp(val, \"bps=\", 4)) bps = atoi(val+4);\n\t\t//else if (!strncmp(val, \"atag=\", 5)) atag = atoi(val+5);\n\t\telse if (!strncmp(val, \"ch=\", 3)) nb_channels = atoi(val+3);\n\t\telse if (!strncmp(val, \"srate=\", 6)) sample_rate = atoi(val+6);\n\t\telse if (!strncmp(val, \"w=\", 2)) width = atoi(val+2);\n\t\telse if (!strncmp(val, \"h=\", 2)) height = atoi(val+2);\n\t\telse if (!strncmp(val, \"scale=\", 6)) timescale = atoi(val+6);\n\t\telse if (!strncmp(val, \"tfdt=\", 5)) {\n\t\t\tsscanf(val+5, LLX, &tfdt);\n\t\t}\n\t\tif (!sep) break;\n\t\tsep[0] = ' ';\n\t\tval = sep+1;\n\t}\n\tif (!stricmp(sz4cc, \"H264\") || !stricmp(sz4cc, \"AVC1\")) {\n\t}\n\telse if (!stricmp(sz4cc, \"AACL\")) {\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Cannot convert smooth media type %s to ISO init segment\\n\", sz4cc));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tfile->moov = (GF_MovieBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MOOV);\n\tif (!file->moov) return GF_OUT_OF_MEM;\n\tgf_list_add(file->TopBoxes, file->moov);\n\tfile->moov->mov = file;\n\tfile->is_smooth = GF_TRUE;\n\tfile->moov->mvhd = (GF_MovieHeaderBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVHD);\n\tif (!file->moov->mvhd) return GF_OUT_OF_MEM;\n\tfile->moov->mvhd->timeScale = timescale;\n\tfile->moov->mvex = (GF_MovieExtendsBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVEX);\n\tif (!file->moov->mvex) return GF_OUT_OF_MEM;\n\ttrex = (GF_TrackExtendsBox *) gf_isom_box_new_parent(&file->moov->mvex->child_boxes, GF_ISOM_BOX_TYPE_TREX);\n\tif (!trex) return GF_OUT_OF_MEM;\n\n\ttrex->def_sample_desc_index = 1;\n\ttrex->trackID = 1;\n\tgf_list_add(file->moov->mvex->TrackExList, trex);\n\n\ttrak = (GF_TrackBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_TRAK);\n\tif (!trak) return GF_OUT_OF_MEM;\n\ttrak->moov = file->moov;\n\tgf_list_add(file->moov->trackList, trak);\n\n\ttrak->Header = (GF_TrackHeaderBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TKHD);\n\tif (!trak->Header) return GF_OUT_OF_MEM;\n\ttrak->Header->trackID = 1;\n\ttrak->Header->flags |= 1;\n\ttrak->Header->width = width;\n\ttrak->Header->height = height;\n\n\ttrak->Media = (GF_MediaBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_MDIA);\n\tif (!trak->Media) return GF_OUT_OF_MEM;\n\ttrak->Media->mediaTrack = trak;\n\ttrak->Media->mediaHeader = (GF_MediaHeaderBox *) gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_MDHD);\n\tif (!trak->Media->mediaHeader) return GF_OUT_OF_MEM;\n\ttrak->Media->mediaHeader->timeScale = timescale;\n\n\ttrak->Media->handler = (GF_HandlerBox *) gf_isom_box_new_parent(&trak->Media->child_boxes,GF_ISOM_BOX_TYPE_HDLR);\n\tif (!trak->Media->handler) return GF_OUT_OF_MEM;\n    //we assume by default vide for handler type (only used for smooth streaming)\n\ttrak->Media->handler->handlerType = width ? GF_ISOM_MEDIA_VISUAL : GF_ISOM_MEDIA_AUDIO;\n\n\ttrak->Media->information = (GF_MediaInformationBox *) gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_MINF);\n\tif (!trak->Media->information) return GF_OUT_OF_MEM;\n\ttrak->Media->information->sampleTable = (GF_SampleTableBox *) gf_isom_box_new_parent(&trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_STBL);\n\tif (!trak->Media->information->sampleTable) return GF_OUT_OF_MEM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tstbl->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\tif (!stbl->SampleSize) return GF_OUT_OF_MEM;\n\tstbl->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\tif (!stbl->TimeToSample) return GF_OUT_OF_MEM;\n\tstbl->ChunkOffset = (GF_Box *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\tif (!stbl->ChunkOffset) return GF_OUT_OF_MEM;\n\tstbl->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\tif (!stbl->SampleToChunk) return GF_OUT_OF_MEM;\n\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\tif (!stbl->SampleDescription) return GF_OUT_OF_MEM;\n\n\ttrak->dts_at_seg_start = tfdt;\n\ttrak->dts_at_next_frag_start = tfdt;\n\n\n\tif (!stricmp(sz4cc, \"H264\") || !stricmp(sz4cc, \"AVC1\")) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tu32 pos = 0;\n\t\tu32 end, sc_size=0;\n#endif\n\t\tGF_MPEGVisualSampleEntryBox *avc =  (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stbl->SampleDescription->child_boxes, GF_ISOM_BOX_TYPE_AVC1);\n\t\tif (!avc) return GF_OUT_OF_MEM;\n\t\tavc->avc_config =  (GF_AVCConfigurationBox *) gf_isom_box_new_parent(&avc->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\t\tif (!avc->avc_config) return GF_OUT_OF_MEM;\n\n\t\tavc->Width = width;\n\t\tavc->Height = height;\n\n\t\tavc->avc_config->config = gf_odf_avc_cfg_new();\n\t\tavc->avc_config->config->nal_unit_size = nal_len;\n\t\tavc->avc_config->config->configurationVersion = 1;\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t//locate pps and sps\n\t\tgf_media_nalu_next_start_code((u8 *) CodecParams, CodecParamLen, &sc_size);\n\t\tpos += sc_size;\n\t\twhile (pos<CodecParamLen) {\n\t\t\tGF_NALUFFParam *slc;\n\t\t\tu8 nal_type;\n\t\t\tchar *nal = &CodecParams[pos];\n\t\t\tend = gf_media_nalu_next_start_code(nal, CodecParamLen-pos, &sc_size);\n\t\t\tif (!end) end = CodecParamLen;\n\n\t\t\tGF_SAFEALLOC(slc, GF_NALUFFParam);\n\t\t\tif (!slc) break;\n\t\t\tslc->size = end;\n\t\t\tslc->data = gf_malloc(sizeof(char)*slc->size);\n\t\t\tif (!slc->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(slc->data, nal, sizeof(char)*slc->size);\n\n\t\t\tnal_type = nal[0] & 0x1F;\n\t\t\tif (nal_type == GF_AVC_NALU_SEQ_PARAM) {\n/*\t\t\t\tAVCState avcc;\n\t\t\t\tu32 idx = gf_avc_read_sps(slc->data, slc->size, &avcc, 0, NULL);\n\t\t\t\tavc->avc_config->config->profile_compatibility = avcc.sps[idx].prof_compat;\n\t\t\t\tavc->avc_config->config->AVCProfileIndication = avcc.sps[idx].profile_idc;\n\t\t\t\tavc->avc_config->config->AVCLevelIndication = avcc.sps[idx].level_idc;\n\t\t\t\tavc->avc_config->config->chroma_format = avcc.sps[idx].chroma_format;\n\t\t\t\tavc->avc_config->config->luma_bit_depth = 8 + avcc.sps[idx].luma_bit_depth_m8;\n\t\t\t\tavc->avc_config->config->chroma_bit_depth = 8 + avcc.sps[idx].chroma_bit_depth_m8;\n*/\n\n\t\t\t\tgf_list_add(avc->avc_config->config->sequenceParameterSets, slc);\n\t\t\t} else {\n\t\t\t\tgf_list_add(avc->avc_config->config->pictureParameterSets, slc);\n\t\t\t}\n\t\t\tpos += slc->size + sc_size;\n\t\t}\n#endif\n\n\t\tAVC_RewriteESDescriptor(avc);\n\t}\n\telse if (!stricmp(sz4cc, \"AACL\")) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tGF_M4ADecSpecInfo aacinfo;\n#endif\n\n\t\tGF_MPEGAudioSampleEntryBox *aac =  (GF_MPEGAudioSampleEntryBox *) gf_isom_box_new_parent(&stbl->SampleDescription->child_boxes, GF_ISOM_BOX_TYPE_MP4A);\n\t\tif (!aac) return GF_OUT_OF_MEM;\n\t\taac->esd = (GF_ESDBox *) gf_isom_box_new_parent(&aac->child_boxes, GF_ISOM_BOX_TYPE_ESDS);\n\t\tif (!aac->esd) return GF_OUT_OF_MEM;\n\t\taac->esd->desc = gf_odf_desc_esd_new(2);\n\t\tif (!aac->esd->desc) return GF_OUT_OF_MEM;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tmemset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo));\n\t\taacinfo.nb_chan = nb_channels;\n\t\taacinfo.base_object_type = GF_M4A_AAC_LC;\n\t\taacinfo.base_sr = sample_rate;\n\t\tgf_m4a_write_config(&aacinfo, &aac->esd->desc->decoderConfig->decoderSpecificInfo->data, &aac->esd->desc->decoderConfig->decoderSpecificInfo->dataLength);\n#endif\n\t\taac->esd->desc->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\taac->esd->desc->decoderConfig->objectTypeIndication = GF_CODECID_AAC_MPEG4;\n\t\taac->bitspersample = bps;\n\t\taac->samplerate_hi = sample_rate;\n\t\taac->channel_count = nb_channels;\n\t}\n\n\treturn GF_OK;\n}\n\n/**************************************************************\n\t\t\t\t\tFile Opening in streaming mode\n\t\t\tthe file map is regular (through FILE handles)\n**************************************************************/\nGF_EXPORT\nGF_Err gf_isom_open_progressive_ex(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_bounds, GF_ISOFile **the_file, u64 *BytesMissing, u32 *outBoxType)\n{\n\tGF_Err e;\n\tGF_ISOFile *movie;\n\n\tif (!BytesMissing || !the_file)\n\t\treturn GF_BAD_PARAM;\n\t*BytesMissing = 0;\n\t*the_file = NULL;\n\n\tmovie = gf_isom_new_movie();\n\tif (!movie) return GF_OUT_OF_MEM;\n\n\tmovie->fileName = gf_strdup(fileName);\n\tmovie->openMode = GF_ISOM_OPEN_READ;\n\tmovie->signal_frag_bounds = enable_frag_bounds;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tmovie->editFileMap = NULL;\n\tmovie->finalName = NULL;\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\tif (!strncmp(fileName, \"isobmff://\", 10)) {\n\t\tmovie->movieFileMap = NULL;\n\t\te = isom_create_init_from_mem(fileName, movie);\n\t} else {\n\t\t//do NOT use FileMapping on incomplete files\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ, &movie->movieFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_delete_movie(movie);\n\t\t\treturn e;\n\t\t}\n\n\t\tif (start_range || end_range) {\n\t\t\tif (end_range>start_range) {\n\t\t\t\tgf_bs_seek(movie->movieFileMap->bs, end_range+1);\n\t\t\t\tgf_bs_truncate(movie->movieFileMap->bs);\n\t\t\t}\n\t\t\tgf_bs_seek(movie->movieFileMap->bs, start_range);\n\t\t}\n\t\te = gf_isom_parse_movie_boxes(movie, outBoxType, BytesMissing, GF_TRUE);\n\n\t}\n\tif (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\t//if we have a moov, we're fine\n\t\tif (movie->moov) {\n\t\t\t*the_file = (GF_ISOFile *)movie;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//if not, delete the movie\n\t\tgf_isom_delete_movie(movie);\n\t\treturn e;\n\t} else if (e) {\n\t\t//if not, delete the movie\n\t\tgf_isom_delete_movie(movie);\n\t\treturn e;\n\t}\n\n\t//OK, let's return\n\t*the_file = (GF_ISOFile *)movie;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_open_progressive(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_bounds, GF_ISOFile **the_file, u64 *BytesMissing)\n{\n\treturn gf_isom_open_progressive_ex(fileName, start_range, end_range, enable_frag_bounds, the_file, BytesMissing, NULL);\n}\n\n/**************************************************************\n\t\t\t\t\tFile Reading\n**************************************************************/\n\nGF_EXPORT\nGF_ISOFile *gf_isom_open(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir)\n{\n\tGF_ISOFile *movie;\n\tMP4_API_IO_Err = GF_OK;\n\n\tswitch (OpenMode & 0xFF) {\n\tcase GF_ISOM_OPEN_READ_DUMP:\n\tcase GF_ISOM_OPEN_READ:\n\t\tmovie = gf_isom_open_file(fileName, OpenMode, NULL);\n\t\tbreak;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\tcase GF_ISOM_OPEN_WRITE:\n\t\tmovie = gf_isom_create_movie(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\tcase GF_ISOM_OPEN_EDIT:\n\tcase GF_ISOM_OPEN_READ_EDIT:\n\tcase GF_ISOM_OPEN_KEEP_FRAGMENTS:\n\t\tmovie = gf_isom_open_file(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\tcase GF_ISOM_WRITE_EDIT:\n\t\tmovie = gf_isom_create_movie(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\treturn (GF_ISOFile *) movie;\n}\n\n\n#if 0\n/*! gets access to the data bitstream  - see \\ref gf_isom_open\n\\param isom_file the target ISO file\n\\param out_bs set to the file input bitstream - do NOT destroy\n\\return error if any\n*/\nGF_Err gf_isom_get_bs(GF_ISOFile *movie, GF_BitStream **out_bs)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (!movie || movie->openMode != GF_ISOM_OPEN_WRITE || !movie->editFileMap) //memory mode\n\t\treturn GF_NOT_SUPPORTED;\n\n\tif (movie->segment_bs)\n\t\t*out_bs = movie->segment_bs;\n\telse\n\t\t*out_bs = movie->editFileMap->bs;\n\n\tif (movie->moof)\n\t\tmovie->moof->fragment_offset = 0;\n\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_write(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\tif (movie == NULL) return GF_ISOM_INVALID_FILE;\n\te = GF_OK;\n\n\t//update duration of each track\n\tif (movie->moov) {\n\t\tu32 i, count = gf_list_count(movie->moov->trackList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrackBox *trak = gf_list_get(movie->moov->trackList, i);\n\t\t\te = SetTrackDuration(trak);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t//write our movie to the file\n\tif ((movie->openMode != GF_ISOM_OPEN_READ) && (movie->openMode != GF_ISOM_OPEN_READ_EDIT)) {\n\t\tgf_isom_get_duration(movie);\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t//movie fragment mode, just store the fragment\n\t\tif ( (movie->openMode == GF_ISOM_OPEN_WRITE) && (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) {\n\t\t\te = gf_isom_close_fragments(movie);\n\t\t\tif (e) return e;\n\t\t\t//in case of mfra box usage -> create mfro, calculate box sizes and write it out\n\t\t\tif (movie->mfra) {\n\t\t\t\tif (!movie->mfra->mfro) {\n\t\t\t\t\tmovie->mfra->mfro = (GF_MovieFragmentRandomAccessOffsetBox *)gf_isom_box_new_parent(&movie->mfra->child_boxes, GF_ISOM_BOX_TYPE_MFRO);\n\t\t\t\t\tif (!movie->mfra->mfro) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = gf_isom_box_size((GF_Box *)movie->mfra);\n\t\t\t\tif (e) return e;\n\t\t\t\tmovie->mfra->mfro->container_size = (u32) movie->mfra->size;\n\n\t\t\t\t//write mfra\n\t\t\t\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\") && movie->on_block_out) {\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new_cbk(movie->on_block_out, movie->on_block_out_usr_data, movie->on_block_out_block_size);\n\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->mfra, bs);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->mfra, movie->editFileMap->bs);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n#endif\n\t\t\te = WriteToFile(movie, GF_FALSE);\n\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->moov) {\n\t\tu32 i;\n\t\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\t\t/*delete any pending dataHandler of scalable enhancements*/\n\t\t\tif (trak->Media && trak->Media->information && trak->Media->information->scalableDataHandler && (trak->Media->information->scalableDataHandler != movie->movieFileMap))\n\t\t\t\tgf_isom_datamap_del(trak->Media->information->scalableDataHandler);\n\t\t}\n\t}\n#endif\n\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_close(GF_ISOFile *movie)\n{\n\tGF_Err e=GF_OK;\n\tif (movie == NULL) return GF_ISOM_INVALID_FILE;\n\te = gf_isom_write(movie);\n\t//free and return;\n\tgf_isom_delete_movie(movie);\n\treturn e;\n}\n\n\n#if 0 //unused\n/*! checks if files has root OD/IOD or not\n\\param isom_file the target ISO file\n\\return GF_TRUE if the file has a root OD or IOD */\nBool gf_isom_has_root_od(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->iods || !movie->moov->iods->descriptor) return GF_FALSE;\n\treturn GF_TRUE;\n}\n#endif\n\nGF_EXPORT\nvoid gf_isom_disable_odf_conversion(GF_ISOFile *movie, Bool disable)\n{\n\tif (movie) movie->disable_odf_translate = disable ? 1 : 0;\n}\n\n//this funct is used for exchange files, where the iods contains an OD\nGF_EXPORT\nGF_Descriptor *gf_isom_get_root_od(GF_ISOFile *movie)\n{\n\tGF_Descriptor *desc;\n\tGF_ObjectDescriptor *od;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_IsomInitialObjectDescriptor *isom_iod;\n\tGF_ESD *esd;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tu8 useIOD;\n\n\tif (!movie || !movie->moov) return NULL;\n\tif (!movie->moov->iods) return NULL;\n\n\tif (movie->disable_odf_translate) {\n\t\t//duplicate our descriptor\n\t\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\t\tif (movie->LastError) return NULL;\n\t\treturn desc;\n\t}\n\tod = NULL;\n\tiod = NULL;\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tod = (GF_ObjectDescriptor*)gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\tif (!od) return NULL;\n\n\t\tmemset(od, 0, sizeof(GF_ObjectDescriptor));\n\t\tod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 0;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tiod = (GF_InitialObjectDescriptor*)gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\tif (!iod) return NULL;\n\n\t\tmemset(iod, 0, sizeof(GF_InitialObjectDescriptor));\n\t\tiod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\t//duplicate our descriptor\n\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\tif (movie->LastError) {\n\t\tif (od) {\n\t\t\tgf_list_del(od->ESDescriptors);\n\t\t\tgf_free(od);\n\t\t}\n\t\tif (iod) {\n\t\t\tgf_list_del(iod->ESDescriptors);\n\t\t\tgf_free(iod);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (!useIOD) {\n\t\tisom_od = (GF_IsomObjectDescriptor *)desc;\n\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\tisom_od->extensionDescriptors = NULL;\n\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\tisom_od->IPMP_Descriptors = NULL;\n\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\tisom_od->OCIDescriptors = NULL;\n\t\tod->URLString = isom_od->URLString;\n\t\tisom_od->URLString = NULL;\n\t\tod->tag = GF_ODF_OD_TAG;\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_od->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(od->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) od);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)od;\n\t} else {\n\t\tisom_iod = (GF_IsomInitialObjectDescriptor *)desc;\n\t\tiod->objectDescriptorID = isom_iod->objectDescriptorID;\n\t\tiod->extensionDescriptors = isom_iod->extensionDescriptors;\n\t\tisom_iod->extensionDescriptors = NULL;\n\t\tiod->IPMP_Descriptors = isom_iod->IPMP_Descriptors;\n\t\tisom_iod->IPMP_Descriptors = NULL;\n\t\tiod->OCIDescriptors = isom_iod->OCIDescriptors;\n\t\tisom_iod->OCIDescriptors = NULL;\n\t\tiod->URLString = isom_iod->URLString;\n\t\tisom_iod->URLString = NULL;\n\t\tiod->tag = GF_ODF_IOD_TAG;\n\n\t\tiod->audio_profileAndLevel = isom_iod->audio_profileAndLevel;\n\t\tiod->graphics_profileAndLevel = isom_iod->graphics_profileAndLevel;\n\t\tiod->inlineProfileFlag = isom_iod->inlineProfileFlag;\n\t\tiod->OD_profileAndLevel = isom_iod->OD_profileAndLevel;\n\t\tiod->scene_profileAndLevel = isom_iod->scene_profileAndLevel;\n\t\tiod->visual_profileAndLevel = isom_iod->visual_profileAndLevel;\n\t\tiod->IPMPToolList = isom_iod->IPMPToolList;\n\t\tisom_iod->IPMPToolList = NULL;\n\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_iod->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(iod->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)iod;\n\t}\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_track_count(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov) return 0;\n\n\tif (!movie->moov->trackList) {\n\t\tmovie->LastError = GF_ISOM_INVALID_FILE;\n\t\treturn 0;\n\t}\n\treturn gf_list_count(movie->moov->trackList);\n}\n\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_track_id(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Header) return 0;\n\treturn trak->Header->trackID;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_track_by_id(GF_ISOFile *the_file, GF_ISOTrackID trackID)\n{\n\tu32 count;\n\tu32 i;\n\tif (the_file == NULL) return 0;\n\n\tcount = gf_isom_get_track_count(the_file);\n\tif (!count) return 0;\n\tfor (i = 0; i < count; i++) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, i+1);\n\t\tif (!trak || !trak->Header) return 0;\n\t\tif (trak->Header->trackID == trackID) return i+1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_track_original_id(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->originalID;\n}\n\n//return the timescale of the movie, 0 if error\nGF_EXPORT\nBool gf_isom_has_movie(GF_ISOFile *file)\n{\n\tif (file && file->moov) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\n#ifndef GPAC_DISABLE_ISOM\nGF_EXPORT\nBool gf_isom_has_segment(GF_ISOFile *file, u32 *brand, u32 *version)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tGF_Box *a;\n\ti = 0;\n\twhile (NULL != (a = (GF_Box*)gf_list_enum(file->TopBoxes, &i))) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (a->type == GF_ISOM_BOX_TYPE_STYP) {\n\t\t\tGF_FileTypeBox *styp = (GF_FileTypeBox *)a;\n\t\t\t*brand = styp->majorBrand;\n\t\t\t*version = styp->minorVersion;\n\t\t\treturn GF_TRUE;\n\t\t}\n#endif\n\t}\n#endif\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_segment_get_fragment_count(GF_ISOFile *file)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (file) {\n\t\tu32 i, count = 0;\n\t\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) count++;\n\t\t}\n\t\treturn count;\n\t}\n#endif\n\treturn 0;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_MovieFragmentBox *gf_isom_get_moof(GF_ISOFile *file, u32 moof_index)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\tmoof_index--;\n\t\t\tif (!moof_index) return (GF_MovieFragmentBox *) a;\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n\nGF_EXPORT\nu32 gf_isom_segment_get_track_fragment_count(GF_ISOFile *file, u32 moof_index)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_MovieFragmentBox *moof;\n\tif (!file) return 0;\n\tgf_list_count(file->TopBoxes);\n\tmoof = gf_isom_get_moof(file, moof_index);\n\treturn moof ? gf_list_count(moof->TrackList) : 0;\n#endif\n\treturn 0;\n}\n\nGF_EXPORT\nu32 gf_isom_segment_get_track_fragment_decode_time(GF_ISOFile *file, u32 moof_index, u32 traf_index, u64 *decode_time)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\tif (!file) return 0;\n\tgf_list_count(file->TopBoxes);\n\tmoof = gf_isom_get_moof(file, moof_index);\n\ttraf = moof ? (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, traf_index-1) : NULL;\n\tif (!traf) return 0;\n\tif (decode_time) {\n\t\t*decode_time = traf->tfdt ? traf->tfdt->baseMediaDecodeTime : 0;\n\t}\n\treturn traf->tfhd->trackID;\n#endif\n\treturn 0;\n}\n\nGF_EXPORT\nu64 gf_isom_segment_get_fragment_size(GF_ISOFile *file, u32 moof_index, u32 *moof_size)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!file) return 0;\n\tu32 moof_sn=0;\n\tBool moof_after_mdat = GF_FALSE;\n\tu64 size=0;\n\tu32 i, count = gf_list_count(file->TopBoxes);\n\tif (moof_size) *moof_size = 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(file->TopBoxes, i);\n\t\tsize += b->size;\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\tif (!moof_after_mdat && (moof_sn == moof_index))\n\t\t\t\treturn size - b->size;\n\n\t\t\tif (moof_size) *moof_size = (u32) b->size;\n\t\t\tmoof_sn++;\n\t\t\tif (moof_after_mdat && (moof_sn == moof_index))\n\t\t\t\treturn size;\n\t\t\tif (moof_after_mdat) size=0;\n\t\t\tif ((moof_sn>1) && !moof_after_mdat) size = b->size;\n\t\t}\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tif (!moof_sn) moof_after_mdat = GF_TRUE;\n\t\t}\n\t}\n\treturn size;\n#endif\n\treturn 0;\n}\n#endif\n\n//return the timescale of the movie, 0 if error\nGF_EXPORT\nu32 gf_isom_get_timescale(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->mvhd) return 0;\n\treturn movie->moov->mvhd->timeScale;\n}\n\n\n//return the duration of the movie, 0 if error\nGF_EXPORT\nu64 gf_isom_get_duration(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->mvhd) return 0;\n\n\t//if file was open in Write or Edit mode, recompute the duration\n\t//the duration of a movie is the MaxDuration of all the tracks...\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tgf_isom_update_duration(movie);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\treturn movie->moov->mvhd->duration;\n}\n//return the duration of the movie, 0 if error\nGF_EXPORT\nu64 gf_isom_get_original_duration(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov|| !movie->moov->mvhd) return 0;\n\treturn movie->moov->mvhd->original_duration;\n}\n\n//return the creation info of the movie\nGF_EXPORT\nGF_Err gf_isom_get_creation_time(GF_ISOFile *movie, u64 *creationTime, u64 *modificationTime)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tif (creationTime) *creationTime = movie->moov->mvhd->creationTime;\n\tif (creationTime) *modificationTime = movie->moov->mvhd->modificationTime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_creation_time(GF_ISOFile *movie, u32 trackNumber, u64 *creationTime, u64 *modificationTime)\n{\n\tGF_TrackBox *trak;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\tif (creationTime) *creationTime = trak->Media->mediaHeader->creationTime;\n\tif (creationTime) *modificationTime = trak->Media->mediaHeader->modificationTime;\n\treturn GF_OK;\n}\n\n//check the presence of a track in IOD. 0: NO, 1: YES, 2: ERROR\nGF_EXPORT\nu8 gf_isom_is_track_in_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tu32 i;\n\tGF_ISOTrackID trackID;\n\tGF_Descriptor *desc;\n\tGF_ES_ID_Inc *inc;\n\tGF_List *inc_list;\n\tif (!movie) return 2;\n\tif (!movie->moov || !movie->moov->iods) return 0;\n\n\tdesc = movie->moov->iods->descriptor;\n\tswitch (desc->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tinc_list = ((GF_IsomInitialObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tinc_list = ((GF_IsomObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\tbreak;\n\t//files without IOD are possible !\n\tdefault:\n\t\treturn 0;\n\t}\n\ttrackID = gf_isom_get_track_id(movie, trackNumber);\n\tif (!trackID) return 2;\n\ti=0;\n\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(inc_list, &i))) {\n\t\tif (inc->trackID == (u32) trackID) return 1;\n\t}\n\treturn 0;\n}\n\n\n\n//gets the enable flag of a track\n//0: NO, 1: YES, 2: ERROR\nGF_EXPORT\nu8 gf_isom_is_track_enabled(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\n\tif (!trak || !trak->Header) return 2;\n\treturn (trak->Header->flags & 1) ? 1 : 0;\n}\n\nGF_EXPORT\nu32 gf_isom_get_track_flags(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Header->flags;\n}\n\n\n//get the track duration\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_track_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*in all modes except dump recompute duration in case headers are wrong*/\n\tif (movie->openMode != GF_ISOM_OPEN_READ_DUMP) {\n\t\tSetTrackDuration(trak);\n\t}\n#endif\n\treturn trak->Header->duration;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_media_language(GF_ISOFile *the_file, u32 trackNumber, char **lang)\n{\n\tu32 count;\n\tBool elng_found = GF_FALSE;\n\tGF_TrackBox *trak;\n\tif (!lang) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t*lang = NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tcount = gf_list_count(trak->Media->child_boxes);\n\tif (count>0) {\n\t\tu32 i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tGF_Box *box = (GF_Box *)gf_list_get(trak->Media->child_boxes, i);\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_ELNG) {\n\t\t\t\t*lang = gf_strdup(((GF_ExtendedLanguageBox *)box)->extended_language);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (!elng_found) {\n\t\t*lang = gf_strdup(trak->Media->mediaHeader->packedLanguage);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_track_kind_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\t\tif (!trak) return 0;\n\t\tif (!trak->udta) {\n\t\t\treturn 0;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn 0;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (!map) return 0;\n\n\treturn gf_list_count(map->boxes);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_kind(GF_ISOFile *the_file, u32 trackNumber, u32 index, char **scheme, char **value)\n{\n\tGF_Err e;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tGF_KindBox *kindBox;\n\tif (!scheme || !value) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t*scheme = NULL;\n\t*value = NULL;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (!map) return GF_BAD_PARAM;\n\n\tkindBox = (GF_KindBox *)gf_list_get(map->boxes, index);\n\tif (!kindBox) return GF_BAD_PARAM;\n\n\t*scheme = gf_strdup(kindBox->schemeURI);\n\tif (kindBox->value) {\n\t\t*value = gf_strdup(kindBox->value);\n\t}\n\treturn GF_OK;\n}\n\n\n//Return the number of track references of a track for a given ReferenceType\n//return 0 if error\nGF_EXPORT\ns32 gf_isom_get_reference_count(GF_ISOFile *movie, u32 trackNumber, u32 referenceType)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return -1;\n\tif (!trak->References) return 0;\n\tif (movie->openMode == GF_ISOM_OPEN_WRITE) {\n\t\tmovie->LastError = GF_ISOM_INVALID_MODE;\n\t\treturn -1;\n\t}\n\n\tdpnd = NULL;\n\tif ( (movie->LastError = Track_FindRef(trak, referenceType, &dpnd)) ) return -1;\n\tif (!dpnd) return 0;\n\treturn dpnd->trackIDCount;\n}\n\n\n//Return the number of track references of a track for a given ReferenceType\n//return 0 if error\nGF_EXPORT\nconst GF_ISOTrackID *gf_isom_enum_track_references(GF_ISOFile *movie, u32 trackNumber, u32 idx, u32 *referenceType, u32 *referenceCount)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\tif (!trak->References) return NULL;\n\tdpnd = gf_list_get(trak->References->child_boxes, idx);\n\tif (!dpnd) return NULL;\n\t*referenceType = dpnd->reference_type;\n\t*referenceCount = dpnd->trackIDCount;\n\treturn dpnd->trackIDs;\n}\n\n\n//Return the referenced track number for a track and a given ReferenceType and Index\n//return -1 if error, 0 if the reference is a NULL one, or the trackNumber\nGF_EXPORT\nGF_Err gf_isom_get_reference(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, u32 referenceIndex, u32 *refTrack)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_ISOTrackID refTrackNum;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\n\t*refTrack = 0;\n\tif (!trak || !trak->References) return GF_BAD_PARAM;\n\n\tdpnd = NULL;\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) return GF_BAD_PARAM;\n\n\tif (!referenceIndex || (referenceIndex > dpnd->trackIDCount)) return GF_BAD_PARAM;\n\n\t//the spec allows a NULL reference\n\t//(ex, to force desync of a track, set a sync ref with ID = 0)\n\tif (dpnd->trackIDs[referenceIndex - 1] == 0) return GF_OK;\n\n\trefTrackNum = gf_isom_get_tracknum_from_id(movie->moov, dpnd->trackIDs[referenceIndex-1]);\n\n\t//if the track was not found, this means the file is broken !!!\n\tif (! refTrackNum) return GF_ISOM_INVALID_FILE;\n\t*refTrack = refTrackNum;\n\treturn GF_OK;\n}\n\n//Return the referenced track ID for a track and a given ReferenceType and Index\n//return -1 if error, 0 if the reference is a NULL one, or the trackNumber\nGF_EXPORT\nGF_Err gf_isom_get_reference_ID(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, u32 referenceIndex, GF_ISOTrackID *refTrackID)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\n\t*refTrackID = 0;\n\tif (!trak || !trak->References || !referenceIndex) return GF_BAD_PARAM;\n\n\tdpnd = NULL;\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) return GF_BAD_PARAM;\n\n\tif (referenceIndex > dpnd->trackIDCount) return GF_BAD_PARAM;\n\n\t*refTrackID = dpnd->trackIDs[referenceIndex-1];\n\n\treturn GF_OK;\n}\n\n//Return referenceIndex if the given track has a reference to the given TreckID of a given ReferenceType\n//return 0 if error\nGF_EXPORT\nu32 gf_isom_has_track_reference(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, GF_ISOTrackID refTrackID)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\tif (!trak->References) return 0;\n\n\tdpnd = NULL;\n\tif ( (movie->LastError = Track_FindRef(trak, referenceType, &dpnd)) ) return 0;\n\tif (!dpnd) return 0;\n\tfor (i=0; i<dpnd->trackIDCount; i++) {\n\t\tif (dpnd->trackIDs[i]==refTrackID) return i+1;\n\t}\n\treturn 0;\n}\n\n\n\n//Return the media time given the absolute time in the Movie\nGF_EXPORT\nGF_Err gf_isom_get_media_time(GF_ISOFile *the_file, u32 trackNumber, u32 movieTime, u64 *MediaTime)\n{\n\tGF_TrackBox *trak;\n\tu8 useEdit;\n\ts64 SegmentStartTime, mediaOffset;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !MediaTime) return GF_BAD_PARAM;\n\n\tSegmentStartTime = 0;\n\treturn GetMediaTime(trak, GF_FALSE, movieTime, MediaTime, &SegmentStartTime, &mediaOffset, &useEdit, NULL);\n}\n\n\n//Get the stream description index (eg, the ESD) for a given time IN MEDIA TIMESCALE\n//return 0 if error or if empty\nGF_EXPORT\nu32 gf_isom_get_sample_description_index(GF_ISOFile *movie, u32 trackNumber, u64 for_time)\n{\n\tu32 streamDescIndex;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\tif ( (movie->LastError = Media_GetSampleDescIndex(trak->Media, for_time, &streamDescIndex)) ) {\n\t\treturn 0;\n\t}\n\treturn streamDescIndex;\n}\n\n//Get the number of \"streams\" stored in the media - a media can have several stream descriptions...\nGF_EXPORT\nu32 gf_isom_get_sample_description_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\treturn gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n}\n\n\n//Get the GF_ESD given the StreamDescriptionIndex\n//THE DESCRIPTOR IS DUPLICATED, SO HAS TO BE DELETED BY THE APP\nGF_EXPORT\nGF_ESD *gf_isom_get_esd(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_ESD *esd;\n\tGF_Err e;\n\te = GetESD(movie->moov, gf_isom_get_track_id(movie, trackNumber), StreamDescriptionIndex, &esd);\n\tif (e && (e!= GF_ISOM_INVALID_MEDIA)) {\n\t\tmovie->LastError = e;\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\treturn NULL;\n\t}\n\n\treturn esd;\n}\n\n//Get the decoderConfigDescriptor given the SampleDescriptionIndex\n//THE DESCRIPTOR IS DUPLICATED, SO HAS TO BE DELETED BY THE APP\nGF_EXPORT\nGF_DecoderConfig *gf_isom_get_decoder_config(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ESD *esd;\n\tGF_Descriptor *decInfo;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\t//get the ESD (possibly emulated)\n\tMedia_GetESD(trak->Media, StreamDescriptionIndex, &esd, GF_FALSE);\n\tif (!esd) return NULL;\n\tdecInfo = (GF_Descriptor *) esd->decoderConfig;\n\tesd->decoderConfig = NULL;\n\tgf_odf_desc_del((GF_Descriptor *) esd);\n\treturn (GF_DecoderConfig *)decInfo;\n}\n\n\n//get the media duration (without edit)\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_media_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\t/*except in dump mode always recompute the duration*/\n\tif (movie->openMode != GF_ISOM_OPEN_READ_DUMP) {\n\t\tif ( (movie->LastError = Media_SetDuration(trak)) ) return 0;\n\t}\n\n#endif\n\n\treturn trak->Media->mediaHeader->duration;\n}\n\n//get the media duration (without edit)\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_media_original_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return 0;\n\n\treturn trak->Media->mediaHeader->original_duration;\n}\n\n//Get the timeScale of the media. All samples DTS/CTS are expressed in this timeScale\nGF_EXPORT\nu32 gf_isom_get_media_timescale(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return 0;\n\treturn trak->Media->mediaHeader->timeScale;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_copyright_count(GF_ISOFile *mov)\n{\n\tGF_UserDataMap *map;\n\tif (!mov || !mov->moov || !mov->moov->udta) return 0;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return 0;\n\treturn gf_list_count(map->boxes);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_copyright(GF_ISOFile *mov, u32 Index, const char **threeCharCode, const char **notice)\n{\n\tGF_UserDataMap *map;\n\tGF_CopyrightBox *cprt;\n\n\tif (!mov || !mov->moov || !Index) return GF_BAD_PARAM;\n\n\tif (!mov->moov->udta) return GF_OK;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return GF_OK;\n\n\tif (Index > gf_list_count(map->boxes)) return GF_BAD_PARAM;\n\n\tcprt = (GF_CopyrightBox*)gf_list_get(map->boxes, Index-1);\n\t(*threeCharCode) = cprt->packedLanguageCode;\n\t(*notice) = cprt->notice;\n\treturn GF_OK;\n}\n\n#if 0\nGF_Err gf_isom_get_watermark(GF_ISOFile *mov, bin128 UUID, u8** data, u32* length)\n{\n\tGF_UserDataMap *map;\n\tGF_UnknownUUIDBox *wm;\n\n\tif (!mov) return GF_BAD_PARAM;\n\tif (!mov->moov || !mov->moov->udta) return GF_NOT_SUPPORTED;\n\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_UUID, (bin128 *) & UUID);\n\tif (!map) return GF_NOT_SUPPORTED;\n\n\twm = (GF_UnknownUUIDBox*)gf_list_get(map->boxes, 0);\n\tif (!wm) return GF_NOT_SUPPORTED;\n\n\t*data = (u8 *) gf_malloc(sizeof(char)*wm->dataSize);\n\tif (! *data) return GF_OUT_OF_MEM;\n\tmemcpy(*data, wm->data, wm->dataSize);\n\t*length = wm->dataSize;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nu32 gf_isom_get_chapter_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_UserDataMap *map;\n\tGF_ChapterListBox *lst;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return 0;\n\n\tudta = NULL;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return 0;\n\tlst = (GF_ChapterListBox *)gf_list_get(map->boxes, 0);\n\tif (!lst) return 0;\n\treturn gf_list_count(lst->list);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chapter(GF_ISOFile *movie, u32 trackNumber, u32 Index, u64 *chapter_time, const char **name)\n{\n\tGF_UserDataMap *map;\n\tGF_ChapterListBox *lst;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tudta = NULL;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return GF_BAD_PARAM;\n\tlst = (GF_ChapterListBox *)gf_list_get(map->boxes, 0);\n\tif (!lst) return GF_BAD_PARAM;\n\n\tce = (GF_ChapterEntry *)gf_list_get(lst->list, Index-1);\n\tif (!ce) return GF_BAD_PARAM;\n\tif (chapter_time) {\n\t\t*chapter_time = ce->start_time;\n\t\t*chapter_time /= 10000L;\n\t}\n\tif (name) *name = ce->name;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_media_type(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\treturn (trak->Media && trak->Media->handler) ? trak->Media->handler->handlerType : 0;\n}\n\nBool IsMP4Description(u32 entryType)\n{\n\tswitch (entryType) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\tcase GF_ISOM_BOX_TYPE_LSR1:\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nBool gf_isom_is_encrypted_entry(u32 entryType)\n{\n\tswitch (entryType) {\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nBool gf_isom_is_track_encrypted(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tu32 i=0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 2;\n\twhile (1) {\n\t\tGF_Box *entry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!entry) break;\n\t\tif (gf_isom_is_encrypted_entry(entry->type)) return GF_TRUE;\n\n\t\tif (gf_isom_is_cenc_media(the_file, trackNumber, i+1))\n\t\t\treturn GF_TRUE;\n\n\t\ti++;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_media_subtype(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Box *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !DescriptionIndex || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return 0;\n\n\t//filter MPEG sub-types\n\tif (IsMP4Description(entry->type)) {\n\t\tif (gf_isom_is_encrypted_entry(entry->type)) return GF_ISOM_SUBTYPE_MPEG4_CRYP;\n\t\telse return GF_ISOM_SUBTYPE_MPEG4;\n\t}\n\tif (entry->type == GF_ISOM_BOX_TYPE_GNRV) {\n\t\treturn ((GF_GenericVisualSampleEntryBox *)entry)->EntryType;\n\t}\n\telse if (entry->type == GF_ISOM_BOX_TYPE_GNRA) {\n\t\treturn ((GF_GenericAudioSampleEntryBox *)entry)->EntryType;\n\t}\n\telse if (entry->type == GF_ISOM_BOX_TYPE_GNRM) {\n\t\treturn ((GF_GenericSampleEntryBox *)entry)->EntryType;\n\t}\n\treturn entry->type;\n}\n\nGF_EXPORT\nu32 gf_isom_get_mpeg4_subtype(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Box *entry=NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !DescriptionIndex) return 0;\n\n\tif (trak->Media\n\t\t&& trak->Media->information\n\t\t&& trak->Media->information->sampleTable\n\t\t&& trak->Media->information->sampleTable->SampleDescription\n\t) {\n\t\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\t}\n\tif (!entry) return 0;\n\n\t//filter MPEG sub-types\n\tif (!IsMP4Description(entry->type)) return 0;\n\treturn entry->type;\n}\n\n//Get the HandlerDescription name.\nGF_EXPORT\nGF_Err gf_isom_get_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char **outName)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !outName) return GF_BAD_PARAM;\n\t*outName = trak->Media->handler->nameUTF8;\n\treturn GF_OK;\n}\n\n//Check the DataReferences of this track\nGF_EXPORT\nGF_Err gf_isom_check_data_reference(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_Err e;\n\tu32 drefIndex;\n\tGF_TrackBox *trak;\n\n\tif (!StreamDescriptionIndex || !trackNumber) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex , NULL, &drefIndex);\n\tif (e) return e;\n\tif (!drefIndex) return GF_BAD_PARAM;\n\treturn Media_CheckDataEntry(trak->Media, drefIndex);\n}\n\n//get the location of the data. If URL && URN are NULL, the data is in this file\nGF_EXPORT\nGF_Err gf_isom_get_data_reference(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const char **outURL, const char **outURN)\n{\n\tGF_TrackBox *trak;\n\tGF_DataEntryURLBox *url=NULL;\n\tGF_DataEntryURNBox *urn;\n\tu32 drefIndex;\n\tGF_Err e;\n\n\t*outURL = *outURN = NULL;\n\n\tif (!StreamDescriptionIndex || !trackNumber) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex , NULL, &drefIndex);\n\tif (e) return e;\n\tif (!drefIndex) return GF_BAD_PARAM;\n\n\tif (trak->Media\n\t\t&& trak->Media->information\n\t\t&& trak->Media->information->dataInformation\n\t\t&& trak->Media->information->dataInformation->dref\n\t) {\n\t\turl = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\t}\n\tif (!url) return GF_ISOM_INVALID_FILE;\n\n\tif (url->type == GF_ISOM_BOX_TYPE_URL) {\n\t\t*outURL = url->location;\n\t\t*outURN = NULL;\n\t} else if (url->type == GF_ISOM_BOX_TYPE_URN) {\n\t\turn = (GF_DataEntryURNBox *) url;\n\t\t*outURN = urn->nameURN;\n\t\t*outURL = urn->location;\n\t} else {\n\t\t*outURN = NULL;\n\t\t*outURL = NULL;\n\t}\n\treturn GF_OK;\n}\n\n//Get the number of samples\n//return 0 if error or empty\nGF_EXPORT\nu32 gf_isom_get_sample_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\treturn trak->Media->information->sampleTable->SampleSize->sampleCount\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t       + trak->sample_count_at_seg_start\n#endif\n\t       ;\n}\n\nGF_EXPORT\nu32 gf_isom_get_constant_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n}\n\nGF_EXPORT\nu32 gf_isom_get_constant_sample_duration(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return 0;\n\tif (trak->Media->information->sampleTable->TimeToSample->nb_entries != 1) return 0;\n\treturn trak->Media->information->sampleTable->TimeToSample->entries[0].sampleDelta;\n}\n\nGF_EXPORT\nBool gf_isom_enable_raw_pack(GF_ISOFile *the_file, u32 trackNumber, u32 pack_num_samples)\n{\n\tu32 afmt, bps, nb_ch;\n\tBool from_qt=GF_FALSE;\n\tGF_TrackBox *trak;\n\tGF_MPEGAudioSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\ttrak->pack_num_samples = 0;\n\t//we only activate sample packing for raw audio\n\tif (!trak->Media || !trak->Media->handler) return GF_FALSE;\n\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_AUDIO) return GF_FALSE;\n\t//and sample duration of 1\n\tif (!trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return GF_FALSE;\n\tif (trak->Media->information->sampleTable->TimeToSample->nb_entries != 1) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->TimeToSample->entries) return GF_FALSE;\n\tif (trak->Media->information->sampleTable->TimeToSample->entries[0].sampleDelta != 1) return GF_FALSE;\n\t//and sample with constant size\n\tif (!trak->Media->information->sampleTable->SampleSize || !trak->Media->information->sampleTable->SampleSize->sampleSize) return GF_FALSE;\n\ttrak->pack_num_samples = pack_num_samples;\n\n\tif (!pack_num_samples) return GF_FALSE;\n\n\tentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\tif (!entry) return GF_FALSE;\n\n\tif (entry->internal_type!=GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_FALSE;\n\n\t//sanity check, some files have wrong stsz sampleSize for raw audio !\n\tafmt = gf_audio_fmt_from_isobmf(entry->type);\n\tbps = gf_audio_fmt_bit_depth(afmt) / 8;\n\tif (!bps) {\n\t\t//unknown format, try QTv2\n\t\tif (entry->qtff_mode && (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_AUDIO)) {\n\t\t\tbps = entry->extensions[8]<<24 | entry->extensions[9]<<16 | entry->extensions[10]<<8 | entry->extensions[11];\n\t\t\tfrom_qt = GF_TRUE;\n\t\t}\n\t}\n\tnb_ch = entry->channel_count;\n\tif (entry->qtff_mode && (entry->version==2)) {\n\t\t//QTFFv2 audio, channel count is 32 bit, after 32bit size of struct and 64 bit samplerate\n\t\t//hence start at 12 in extensions\n\t\tnb_ch = entry->extensions[11]<<24 | entry->extensions[12]<<16 | entry->extensions[13]<<8 | entry->extensions[14];\n\t}\n\n\tif (bps) {\n\t\tu32 res = trak->Media->information->sampleTable->SampleSize->sampleSize % bps;\n\t\tif (res) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ISOBMF: size mismatch for raw audio sample description: constant sample size %d but %d bytes per channel for %s%s!\\n\", trak->Media->information->sampleTable->SampleSize->sampleSize,\n\t\t\t\t\tbps,\n\t\t\t\t\tgf_4cc_to_str(entry->type),\n\t\t\t\t\tfrom_qt ? \" (as indicated in QT sample description)\" : \"\"\n\t\t\t\t));\n\t\t\ttrak->Media->information->sampleTable->SampleSize->sampleSize = bps * nb_ch;\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nBool gf_isom_has_time_offset_table(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nu32 gf_isom_has_time_offset(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return 0;\n\n\t//return true at the first offset found\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\tif (ctts->entries[i].decodingOffset && ctts->entries[i].sampleCount) return ctts->version ? 2 : 1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\ns64 gf_isom_get_cts_to_dts_shift(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionToDecode) return 0;\n\treturn trak->Media->information->sampleTable->CompositionToDecode->compositionToDTSShift;\n}\n\nGF_EXPORT\nBool gf_isom_has_sync_shadows(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->ShadowSync) return GF_FALSE;\n\tif (gf_list_count(trak->Media->information->sampleTable->ShadowSync->entries) ) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_isom_has_sample_dependency(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->SampleDep) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_flags(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *isLeading, u32 *dependsOn, u32 *dependedOn, u32 *redundant)\n{\n\tGF_TrackBox *trak;\n\t*isLeading = 0;\n\t*dependsOn = 0;\n\t*dependedOn = 0;\n\t*redundant = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->SampleDep) return GF_BAD_PARAM;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber <= trak->sample_count_at_seg_start)\n\t\treturn GF_BAD_PARAM;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\treturn stbl_GetSampleDepType(trak->Media->information->sampleTable->SampleDep, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n\n//return a sample give its number, and set the SampleDescIndex of this sample\n//this index allows to retrieve the stream description if needed (2 media in 1 track)\n//return NULL if error\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 descIndex;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t\tif (static_sample->dataLength && !static_sample->alloc_size)\n\t\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t}\n\tif (!samp) return NULL;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start)\n\t\treturn NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset);\n\tif (static_sample && !static_sample->alloc_size)\n\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample) gf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n\tif (sampleDescriptionIndex) *sampleDescriptionIndex = descIndex;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn samp;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex)\n{\n\treturn gf_isom_get_sample_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, NULL, NULL);\n}\n\nGF_EXPORT\nu32 gf_isom_get_sample_duration(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu32 dur;\n\tu64 dts;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\tstbl_GetSampleDTS_and_Duration(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts, &dur);\n\treturn dur;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_sample_size(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu32 size = 0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tstbl_GetSampleSize(trak->Media->information->sampleTable->SampleSize, sampleNumber, &size);\n\treturn size;\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\n\treturn trak->Media->information->sampleTable->SampleSize->max_size;\n}\n\nGF_EXPORT\nu32 gf_isom_get_avg_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\n\tif ( trak->Media->information->sampleTable->SampleSize->sampleSize)\n\t\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n\n\tif (!trak->Media->information->sampleTable->SampleSize->total_samples) return 0;\n\treturn (u32) (trak->Media->information->sampleTable->SampleSize->total_size / trak->Media->information->sampleTable->SampleSize->total_samples);\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_delta(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return 0;\n\n\treturn trak->Media->information->sampleTable->TimeToSample->max_ts_delta;\n}\n\nGF_EXPORT\nu32 gf_isom_get_avg_sample_delta(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return 0;\n\n\tGF_TimeToSampleBox *stts = trak->Media->information->sampleTable->TimeToSample;\n\tu32 i, nb_ent = 0, min = 0;\n\tfor (i=0; i<stts->nb_entries; i++) {\n\t\tif (!nb_ent || nb_ent < stts->entries[i].sampleCount) {\n\t\t\tmin = stts->entries[i].sampleDelta;\n\t\t\tnb_ent = stts->entries[i].sampleCount;\n\t\t}\n\t}\n\treturn min;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_cts_offset(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->CompositionOffset) return 0;\n\n\treturn trak->Media->information->sampleTable->CompositionOffset->max_cts_delta;\n}\n\n\nGF_EXPORT\nBool gf_isom_get_sample_sync(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tGF_ISOSAPType is_rap;\n\tGF_Err e;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return GF_FALSE;\n\n\tif (! trak->Media->information->sampleTable->SyncSample) return GF_TRUE;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return GF_FALSE;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\te = stbl_GetSampleRAP(trak->Media->information->sampleTable->SyncSample, sampleNumber, &is_rap, NULL, NULL);\n\tif (e) return GF_FALSE;\n\treturn is_rap ? GF_TRUE : GF_FALSE;\n}\n\n//same as gf_isom_get_sample but doesn't fetch media data\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_info_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset, GF_ISOSample *static_sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t\tif (!samp) return NULL;\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset);\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\treturn samp;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset)\n{\n\treturn gf_isom_get_sample_info_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, data_offset, NULL);\n}\n\n\n//get sample dts\nGF_EXPORT\nu64 gf_isom_get_sample_dts(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu64 dts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tif (!sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (stbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts) != GF_OK) return 0;\n\treturn dts;\n}\n\nGF_EXPORT\nBool gf_isom_is_self_contained(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\treturn Media_IsSelfContained(trak->Media, sampleDescriptionIndex);\n}\n\n/*retrieves given sample DTS*/\nGF_EXPORT\nu32 gf_isom_get_sample_from_dts(GF_ISOFile *the_file, u32 trackNumber, u64 dts)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber;\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tstbl = trak->Media->information->sampleTable;\n\n\te = stbl_findEntryForTime(stbl, dts, 1, &sampleNumber, &prevSampleNumber);\n\tif (e) return 0;\n\treturn sampleNumber;\n}\n\n\n//return a sample given a desired display time IN MEDIA TIME SCALE\n//and set the StreamDescIndex of this sample\n//this index allows to retrieve the stream description if needed (2 media in 1 track)\n//return NULL if error\n//WARNING: the sample may not be sync even though the sync was requested (depends on the media)\nGF_EXPORT\nGF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, syncNum, shadowSync;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *shadow;\n\tGF_SampleTableBox *stbl;\n\tBool static_sample = GF_FALSE;\n\tu8 useShadow, IsSync;\n\n\tif (SampleNum) *SampleNum = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (desiredTime < trak->dts_at_seg_start) {\n\t\tdesiredTime = 0;\n\t} else {\n\t\tdesiredTime -= trak->dts_at_seg_start;\n\t}\n#endif\n\n\te = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//if no shadow table, reset to sync only\n\tuseShadow = 0;\n\tif (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))\n\t\tSearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t//if no syncTable, disable syncSearching, as all samples ARE sync\n\tif (! trak->Media->information->sampleTable->SyncSample) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;\n\t}\n\n\t//not found, return EOF or browse backward\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {\n\t\t\tsampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t\tif (!sampleNumber) return GF_EOS;\n\t}\n\n\t//check in case we have the perfect sample\n\tIsSync = 0;\n\n\t//according to the direction adjust the sampleNum value\n\tswitch (SearchMode) {\n\tcase GF_ISOM_SEARCH_SYNC_FORWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_FORWARD:\n\t\t//not the exact one\n\t\tif (!sampleNumber) {\n\t\t\tif (prevSampleNumber != stbl->SampleSize->sampleCount) {\n\t\t\t\tsampleNumber = prevSampleNumber + 1;\n\t\t\t} else {\n\t\t\t\tsampleNumber = prevSampleNumber;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t//if dummy mode, reset to default browsing\n\tcase GF_ISOM_SEARCH_SYNC_BACKWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_SYNC_SHADOW:\n\tcase GF_ISOM_SEARCH_BACKWARD:\n\tdefault:\n\t\t//first case, not found....\n\t\tif (!sampleNumber && !prevSampleNumber) {\n\t\t\tsampleNumber = stbl->SampleSize->sampleCount;\n\t\t} else if (!sampleNumber) {\n\t\t\tsampleNumber = prevSampleNumber;\n\t\t}\n\t\tbreak;\n\t}\n\n\t//get the sync sample num\n\tif (IsSync) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, SearchMode);\n\t\tif (e) return e;\n\t\tif (syncNum) sampleNumber = syncNum;\n\t\tsyncNum = 0;\n\t}\n\t//if we are in shadow mode, get the previous sync sample\n\t//in case we can't find a good SyncShadow\n\telse if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);\n\t\tif (e) return e;\n\t}\n\n\n\t//OK sampleNumber is exactly the sample we need (except for shadow)\n\n\tif (sample) {\n\t\tif (*sample) {\n\t\t\tstatic_sample = GF_TRUE;\n\t\t} else {\n\t\t\t*sample = gf_isom_sample_new();\n\t\t\tif (*sample == NULL) return GF_OUT_OF_MEM;\n\t\t}\n\t}\n\t//we are in shadow mode, we need to browse both SyncSample and ShadowSyncSample to get\n\t//the desired sample...\n\tif (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the shadowing number\n\t\tstbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);\n\t\t//now sampleNumber is the closest previous shadowed sample.\n\t\t//1- If we have a closer sync sample, use it.\n\t\t//2- if the shadowSync is 0, we don't have any shadowing, use syncNum\n\t\tif ((sampleNumber < syncNum) || (!shadowSync)) {\n\t\t\tsampleNumber = syncNum;\n\t\t} else {\n\t\t\t//otherwise, we have a better alternate sample in the shadowSync for this sample\n\t\t\tuseShadow = 1;\n\t\t}\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);\n\tif (e) {\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(sample);\n\t\telse if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )\n\t\t \t(*sample)->alloc_size =  (*sample)->dataLength;\n\n\t\treturn e;\n\t}\n\tif (sample && ! (*sample)->IsRAP) {\n\t\tBool is_rap;\n\t\tGF_ISOSampleRollType roll_type;\n\t\te = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);\n\t\tif (e) return e;\n\t\tif (is_rap) (*sample)->IsRAP = SAP_TYPE_3;\n\t}\n\t//optionally get the sample number\n\tif (SampleNum) {\n\t\t*SampleNum = sampleNumber;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t*SampleNum += trak->sample_count_at_seg_start;\n#endif\n\t}\n\n\t//in shadow mode, we only get the data of the shadowing sample !\n\tif (sample && useShadow) {\n\t\t//we have to use StreamDescriptionIndex in case the sample data is in another desc\n\t\t//though this is unlikely as non optimized...\n\t\tshadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);\n\t\t//if no sample, the shadowSync is broken, return the sample\n\t\tif (!shadow) return GF_OK;\n\t\t(*sample)->IsRAP = RAP;\n\t\tgf_free((*sample)->data);\n\t\t(*sample)->dataLength = shadow->dataLength;\n\t\t(*sample)->data = shadow->data;\n\t\t//set data length to 0 to keep the buffer alive...\n\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_for_movie_time(GF_ISOFile *the_file, u32 trackNumber, u64 movieTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *sampleNumber, u64 *data_offset)\n{\n\tDouble tsscale;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tu64 mediaTime, nextMediaTime;\n\ts64 segStartTime, mediaOffset;\n\tu32 sampNum;\n\tu8 useEdit;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//only check duration if initially set - do not check duration as updated after fragment merge since that duration does not take\n\t//into account tfdt\n\tif (trak->Header->initial_duration\n\t\t&& gf_timestamp_greater(movieTime, trak->Media->mediaHeader->timeScale, trak->Header->initial_duration, trak->moov->mvhd->timeScale)\n\t) {\n\t\tif (sampleNumber) *sampleNumber = 0;\n\t\t*StreamDescriptionIndex = 0;\n\t\treturn GF_EOS;\n\t}\n\n\t//get the media time for this movie time...\n\tmediaTime = segStartTime = 0;\n\t*StreamDescriptionIndex = 0;\n\tnextMediaTime = 0;\n\n\te = GetMediaTime(trak, (SearchMode==GF_ISOM_SEARCH_SYNC_FORWARD) ? GF_TRUE : GF_FALSE, movieTime, &mediaTime, &segStartTime, &mediaOffset, &useEdit, &nextMediaTime);\n\tif (e) return e;\n\n\t/*here we check if we were playing or not and return no sample in normal search modes*/\n\tif (useEdit && mediaOffset == -1) {\n\t\tif ((SearchMode==GF_ISOM_SEARCH_FORWARD) || (SearchMode==GF_ISOM_SEARCH_BACKWARD)) {\n\t\t\t/*get next sample time in MOVIE timescale*/\n\t\t\tif (SearchMode==GF_ISOM_SEARCH_FORWARD)\n\t\t\t\te = GetNextMediaTime(trak, movieTime, &mediaTime);\n\t\t\telse\n\t\t\t\te = GetPrevMediaTime(trak, movieTime, &mediaTime);\n\t\t\tif (e) return e;\n\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, (u32) mediaTime, StreamDescriptionIndex, GF_ISOM_SEARCH_SYNC_FORWARD, sample, sampleNumber, data_offset);\n\t\t}\n\t\tif (sampleNumber) *sampleNumber = 0;\n\t\tif (sample) {\n\t\t\tif (! (*sample)) {\n\t\t\t\t*sample = gf_isom_sample_new();\n\t\t\t\tif (! *sample) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\t(*sample)->DTS = movieTime;\n\t\t\t(*sample)->dataLength = 0;\n\t\t\t(*sample)->CTS_Offset = 0;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\t/*dwell edit in non-sync mode, fetch next/prev sample depending on mode.\n\tOtherwise return the dwell entry*/\n\tif (useEdit==2) {\n\t\tif ((SearchMode==GF_ISOM_SEARCH_FORWARD) || (SearchMode==GF_ISOM_SEARCH_BACKWARD)) {\n\t\t\t/*get next sample time in MOVIE timescale*/\n\t\t\tif (SearchMode==GF_ISOM_SEARCH_FORWARD)\n\t\t\t\te = GetNextMediaTime(trak, movieTime, &mediaTime);\n\t\t\telse\n\t\t\t\te = GetPrevMediaTime(trak, movieTime, &mediaTime);\n\t\t\tif (e) return e;\n\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, (u32) mediaTime, StreamDescriptionIndex, GF_ISOM_SEARCH_SYNC_FORWARD, sample, sampleNumber, data_offset);\n\t\t}\n\t}\n\n\ttsscale = trak->Media->mediaHeader->timeScale;\n\ttsscale /= trak->moov->mvhd->timeScale;\n\n\t//OK, we have a sample so fetch it\n\te = gf_isom_get_sample_for_media_time(the_file, trackNumber, mediaTime, StreamDescriptionIndex, SearchMode, sample, &sampNum, data_offset);\n\tif (e) {\n\t\tif (e==GF_EOS) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t//movie is fragmented and samples not yet received, return EOS\n\t\t\tif (the_file->moov->mvex && !trak->Media->information->sampleTable->SampleSize->sampleCount)\n\t\t\t\treturn e;\n#endif\n\n\t\t\tif ((SearchMode==GF_ISOM_SEARCH_SYNC_BACKWARD) || (SearchMode==GF_ISOM_SEARCH_BACKWARD)) {\n\t\t\t\tif (nextMediaTime && (nextMediaTime-1 < movieTime))\n\t\t\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, nextMediaTime-1, StreamDescriptionIndex, SearchMode, sample, sampleNumber, data_offset);\n\t\t\t} else {\n\t\t\t\tif (nextMediaTime && (nextMediaTime-1 > movieTime))\n\t\t\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, nextMediaTime-1, StreamDescriptionIndex, SearchMode, sample, sampleNumber, data_offset);\n\t\t\t}\n\t\t}\n\t\treturn e;\n\t}\n\n\t//OK, now the trick: we have to rebuild the time stamps, according\n\t//to the media time scale (used by SLConfig) - add the edit start time but stay in\n\t//the track TS\n\tif (sample && useEdit) {\n\t\tu64 _ts = (u64)(segStartTime * tsscale);\n\n\t\t(*sample)->DTS += _ts;\n\t\t/*watchout, the sample fetched may be before the first sample in the edit list (when seeking)*/\n\t\tif ( (*sample)->DTS > (u64) mediaOffset) {\n\t\t\t(*sample)->DTS -= (u64) mediaOffset;\n\t\t} else {\n\t\t\t(*sample)->DTS = 0;\n\t\t}\n\t}\n\tif (sampleNumber) *sampleNumber = sampNum;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sample && (*sample) ) (*sample)->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn GF_OK;\n}\n\n\n\nGF_EXPORT\nu64 gf_isom_get_missing_bytes(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\treturn trak->Media->BytesMissing;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_padding(GF_ISOFile *the_file, u32 trackNumber, u32 padding_bytes)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->padding_bytes = padding_bytes;\n\treturn GF_OK;\n\n}\n\n//get the number of edited segment\nGF_EXPORT\nBool gf_isom_get_edit_list_type(GF_ISOFile *the_file, u32 trackNumber, s64 *mediaOffset)\n{\n\tGF_EdtsEntry *ent;\n\tGF_TrackBox *trak;\n\tu32 count;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\t*mediaOffset = 0;\n\tif (!trak->editBox || !trak->editBox->editList) return GF_FALSE;\n\n\tcount = gf_list_count(trak->editBox->editList->entryList);\n\tent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 0);\n\tif (!ent) return GF_TRUE;\n\t/*mediaRate>0, the track playback shall start at media time>0 -> mediaOffset is < 0 */\n\tif ((count==1) && (ent->mediaRate == 0x10000) && (ent->mediaTime>=0)) {\n\t\t*mediaOffset = - ent->mediaTime;\n\t\treturn GF_FALSE;\n\t} else if (count==2) {\n\t\t/*mediaTime==-1, the track playback shall be empty for segmentDuration -> mediaOffset is > 0 */\n\t\tif ((ent->mediaRate == -0x10000) || (ent->mediaTime==-1)) {\n\t\t\tDouble time = (Double) ent->segmentDuration;\n\t\t\ttime /= trak->moov->mvhd->timeScale;\n\t\t\ttime *= trak->Media->mediaHeader->timeScale;\n\t\t\t*mediaOffset = (s64) time;\n\n\t\t\t//check next entry, if we start from mediaOffset > 0 this may still result in a skip\n\t\t\tent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 1);\n\t\t\t//next entry playback rate is not nominal, we need edit list handling\n\t\t\tif (ent->mediaRate != 0x10000)\n\t\t\t\treturn GF_TRUE;\n\n\t\t\tif (ent->mediaTime > 0) {\n\t\t\t\t*mediaOffset -= ent->mediaTime;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\n\n//get the number of edited segment\nGF_EXPORT\nu32 gf_isom_get_edits_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tif (!trak->editBox || !trak->editBox->editList) return 0;\n\treturn gf_list_count(trak->editBox->editList->entryList);\n}\n\n\n//Get the desired segment information\nGF_EXPORT\nGF_Err gf_isom_get_edit(GF_ISOFile *the_file, u32 trackNumber, u32 SegmentIndex, u64 *EditTime, u64 *SegmentDuration, u64 *MediaTime, GF_ISOEditType *EditMode)\n{\n\tu32 i;\n\tu64 startTime;\n\tGF_TrackBox *trak;\n\tGF_EditListBox *elst;\n\tGF_EdtsEntry *ent;\n\n\tent = NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->editBox ||\n\t        !trak->editBox->editList ||\n\t        (SegmentIndex > gf_list_count(trak->editBox->editList->entryList)) ||\n\t        !SegmentIndex)\n\t\treturn GF_BAD_PARAM;\n\n\telst = trak->editBox->editList;\n\tstartTime = 0;\n\n\tfor (i = 0; i < SegmentIndex; i++) {\n\t\tent = (GF_EdtsEntry*)gf_list_get(elst->entryList, i);\n\t\tif (i < SegmentIndex-1) startTime += ent->segmentDuration;\n\t}\n\t*EditTime = startTime;\n\t*SegmentDuration = ent->segmentDuration;\n\tif (ent->mediaTime < 0) {\n\t\t*MediaTime = 0;\n\t\t*EditMode = GF_ISOM_EDIT_EMPTY;\n\t\treturn GF_OK;\n\t}\n\tif (ent->mediaRate == 0) {\n\t\t*MediaTime = ent->mediaTime;\n\t\t*EditMode = GF_ISOM_EDIT_DWELL;\n\t\treturn GF_OK;\n\t}\n\t*MediaTime = ent->mediaTime;\n\t*EditMode = GF_ISOM_EDIT_NORMAL;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu8 gf_isom_has_sync_points(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\tif (!trak->Media->information->sampleTable->SyncSample->nb_entries) return 2;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*returns number of sync points*/\nGF_EXPORT\nu32 gf_isom_get_sync_point_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\treturn trak->Media->information->sampleTable->SyncSample->nb_entries;\n\t}\n\treturn 0;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_get_brand_info(GF_ISOFile *movie, u32 *brand, u32 *minorVersion, u32 *AlternateBrandsCount)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tif (!movie->brand) {\n\t\tif (brand) *brand = GF_ISOM_BRAND_ISOM;\n\t\tif (minorVersion) *minorVersion = 1;\n\t\tif (AlternateBrandsCount) *AlternateBrandsCount = 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (brand) *brand = movie->brand->majorBrand;\n\tif (minorVersion) *minorVersion = movie->brand->minorVersion;\n\tif (AlternateBrandsCount) *AlternateBrandsCount = movie->brand->altCount;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_alternate_brand(GF_ISOFile *movie, u32 BrandIndex, u32 *brand)\n{\n\tif (!movie || !movie->brand || !brand) return GF_BAD_PARAM;\n\tif (BrandIndex > movie->brand->altCount || !BrandIndex) return GF_BAD_PARAM;\n\t*brand = movie->brand->altBrand[BrandIndex-1];\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u32 *gf_isom_get_brands(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->brand) return NULL;\n\treturn movie->brand->altBrand;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_padding_bits(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u8 *NbBits)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\t//Padding info\n\treturn stbl_GetPaddingBits(trak->Media->information->sampleTable->PaddingBits,\n\t                           sampleNumber, NbBits);\n\n}\n\n\nGF_EXPORT\nBool gf_isom_has_padding_bits(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tif (trak->Media->information->sampleTable->PaddingBits) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_udta_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tif (!movie || !movie->moov) return 0;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (udta) return gf_list_count(udta->recordList);\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_udta_type(GF_ISOFile *movie, u32 trackNumber, u32 udta_idx, u32 *UserDataType, bin128 *UUID)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tif (!movie || !movie->moov || !udta_idx) return GF_BAD_PARAM;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_OK;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tif (udta_idx>gf_list_count(udta->recordList)) return GF_BAD_PARAM;\n\tmap = (GF_UserDataMap*)gf_list_get(udta->recordList, udta_idx - 1);\n\tif (UserDataType) *UserDataType = map->boxType;\n\tif (UUID) memcpy(*UUID, map->uuid, 16);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_user_data_count(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tbin128 t;\n\tu32 i, count;\n\n\tif (!movie || !movie->moov) return 0;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tcount = gf_list_count(map->boxes);\n\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) return count;\n\t\telse if (map->boxType == UserDataType) return count;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex, u8 **userData, u32 *userDataSize)\n{\n\tGF_UserDataMap *map;\n\tGF_UnknownBox *ptr;\n\tGF_BitStream *bs;\n\tu32 i;\n\tbin128 t;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (!userData || !userDataSize || *userData) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\n\t}\n\treturn GF_BAD_PARAM;\n\nfound:\n\tif (UserDataIndex) {\n\t\tif (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;\n\t\tptr = (GF_UnknownBox*)gf_list_get(map->boxes, UserDataIndex-1);\n\n\t\tif (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tif (!ptr->dataSize) {\n\t\t\t\t*userData = NULL;\n\t\t\t\t*userDataSize = 0;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\t*userData = (char *)gf_malloc(sizeof(char)*ptr->dataSize);\n\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(*userData, ptr->data, sizeof(char)*ptr->dataSize);\n\t\t\t*userDataSize = ptr->dataSize;\n\t\t\treturn GF_OK;\n\t\t} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tGF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;\n\t\t\tif (!p_uuid->dataSize) {\n\t\t\t\t*userData = NULL;\n\t\t\t\t*userDataSize = 0;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\t*userData = (char *)gf_malloc(sizeof(char)*p_uuid->dataSize);\n\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(*userData, p_uuid->data, sizeof(char)*p_uuid->dataSize);\n\t\t\t*userDataSize = p_uuid->dataSize;\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tchar *str = NULL;\n\t\t\tswitch (ptr->type) {\n\t\t\tcase GF_ISOM_BOX_TYPE_NAME:\n\t\t\t//case GF_QT_BOX_TYPE_NAME: same as above\n\t\t\t\tstr = ((GF_NameBox *)ptr)->string;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_BOX_TYPE_KIND:\n\t\t\t\tstr = ((GF_KindBox *)ptr)->value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (str) {\n\t\t\t\tu32 len = (u32) strlen(str) + 1;\n\t\t\t\t*userData = (char *)gf_malloc(sizeof(char) * len);\n\t\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(*userData, str, sizeof(char)*len);\n\t\t\t\t*userDataSize = len;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t}\n\n\t//serialize all boxes\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\ti=0;\n\twhile ( (ptr = (GF_UnknownBox*)gf_list_enum(map->boxes, &i))) {\n\t\tu32 type, s, data_size;\n\t\tchar *data=NULL;\n\t\tif (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\ttype = ptr->original_4cc;\n\t\t\tdata_size = ptr->dataSize;\n\t\t\tdata = ptr->data;\n\t\t} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tGF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;\n\t\t\ttype = p_uuid->type;\n\t\t\tdata_size = p_uuid->dataSize;\n\t\t\tdata = p_uuid->data;\n\t\t} else {\n\t\t\tgf_isom_box_write((GF_Box *)ptr, bs);\n\t\t\tcontinue;\n\t\t}\n\t\ts = data_size+8;\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_UUID) s += 16;\n\n\t\tgf_bs_write_u32(bs, s);\n\t\tgf_bs_write_u32(bs, type);\n\t\tif (type==GF_ISOM_BOX_TYPE_UUID) gf_bs_write_data(bs, (char *) map->uuid, 16);\n\t\tif (data) {\n\t\t\tgf_bs_write_data(bs, data, data_size);\n\t\t} else if (ptr->child_boxes) {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\tgf_isom_box_array_write((GF_Box *)ptr, ptr->child_boxes, bs);\n#else\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ISOBMF: udta is a box-list - cannot export in read-only version of libisom in GPAC\\n\" ));\n#endif\n\t\t}\n\t}\n\tgf_bs_get_content(bs, userData, userDataSize);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_delete(GF_ISOFile *movie)\n{\n\t//free and return;\n\tgf_isom_delete_movie(movie);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chunks_infos(GF_ISOFile *movie, u32 trackNumber, u32 *dur_min, u32 *dur_avg, u32 *dur_max, u32 *size_min, u32 *size_avg, u32 *size_max)\n{\n\tGF_TrackBox *trak;\n\tu32 i, k, sample_idx, dmin, dmax, smin, smax, tot_chunks;\n\tu64 davg, savg;\n\tGF_SampleToChunkBox *stsc;\n\tGF_TimeToSampleBox *stts;\n\tif (!movie || !trackNumber || !movie->moov) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsc = trak->Media->information->sampleTable->SampleToChunk;\n\tstts = trak->Media->information->sampleTable->TimeToSample;\n\tif (!stsc || !stts) return GF_ISOM_INVALID_FILE;\n\n\tdmin = smin = (u32) -1;\n\tdmax = smax = 0;\n\tdavg = savg = 0;\n\tsample_idx = 1;\n\ttot_chunks = 0;\n\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\tu32 nb_chunk = 0;\n\t\tif (stsc->entries[i].samplesPerChunk >  2*trak->Media->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] likely broken stco entry (%u samples per chunk but %u samples total)\\n\", stsc->entries[i].samplesPerChunk, trak->Media->information->sampleTable->SampleSize->sampleCount));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\twhile (1) {\n\t\t\tu32 chunk_dur = 0;\n\t\t\tu32 chunk_size = 0;\n\t\t\tfor (k=0; k<stsc->entries[i].samplesPerChunk; k++) {\n\t\t\t\tu64 dts;\n\t\t\t\tu32 dur;\n\t\t\t\tu32 size;\n\t\t\t\tstbl_GetSampleDTS_and_Duration(stts, k+sample_idx, &dts, &dur);\n\t\t\t\tchunk_dur += dur;\n\t\t\t\tstbl_GetSampleSize(trak->Media->information->sampleTable->SampleSize, k+sample_idx, &size);\n\t\t\t\tchunk_size += size;\n\n\t\t\t}\n\t\t\tif (dmin>chunk_dur) dmin = chunk_dur;\n\t\t\tif (dmax<chunk_dur) dmax = chunk_dur;\n\t\t\tdavg += chunk_dur;\n\t\t\tif (smin>chunk_size) smin = chunk_size;\n\t\t\tif (smax<chunk_size) smax = chunk_size;\n\t\t\tsavg += chunk_size;\n\n\t\t\ttot_chunks ++;\n\t\t\tsample_idx += stsc->entries[i].samplesPerChunk;\n\t\t\tif (i+1==stsc->nb_entries) break;\n\t\t\tnb_chunk ++;\n\t\t\tif (stsc->entries[i].firstChunk + nb_chunk == stsc->entries[i+1].firstChunk) break;\n\t\t}\n\t}\n\tif (tot_chunks) {\n\t\tdavg /= tot_chunks;\n\t\tsavg /= tot_chunks;\n\t}\n\tif (dur_min) *dur_min = dmin;\n\tif (dur_avg) *dur_avg = (u32) davg;\n\tif (dur_max) *dur_max = dmax;\n\n\tif (size_min) *size_min = smin;\n\tif (size_avg) *size_avg = (u32) savg;\n\tif (size_max) *size_max = smax;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_fragment_defaults(GF_ISOFile *the_file, u32 trackNumber,\n                                     u32 *defaultDuration, u32 *defaultSize, u32 *defaultDescriptionIndex,\n                                     u32 *defaultRandomAccess, u8 *defaultPadding, u16 *defaultDegradationPriority)\n{\n\tGF_TrackBox *trak;\n\tGF_StscEntry *sc_ent;\n\tu32 i, j, maxValue, value;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackExtendsBox *trex;\n#endif\n\tGF_SampleTableBox *stbl;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*if trex is already set, restore flags*/\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\ttrex = the_file->moov->mvex ? GetTrex(the_file->moov, gf_isom_get_track_id(the_file,trackNumber) ) : NULL;\n\tif (trex) {\n\t\ttrex->track = trak;\n\n\t\tif (defaultDuration) *defaultDuration = trex->def_sample_duration;\n\t\tif (defaultSize) *defaultSize = trex->def_sample_size;\n\t\tif (defaultDescriptionIndex) *defaultDescriptionIndex = trex->def_sample_desc_index;\n\t\tif (defaultRandomAccess) *defaultRandomAccess = GF_ISOM_GET_FRAG_SYNC(trex->def_sample_flags);\n\t\tif (defaultPadding) *defaultPadding = GF_ISOM_GET_FRAG_PAD(trex->def_sample_flags);\n\t\tif (defaultDegradationPriority) *defaultDegradationPriority = GF_ISOM_GET_FRAG_DEG(trex->def_sample_flags);\n\t\treturn GF_OK;\n\t}\n#endif\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->TimeToSample || !stbl->SampleSize || !stbl->SampleToChunk) return GF_ISOM_INVALID_FILE;\n\n\n\t//duration\n\tif (defaultDuration) {\n\t\tmaxValue = value = 0;\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tif (stbl->TimeToSample->entries[i].sampleCount>maxValue) {\n\t\t\t\tvalue = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\t\tmaxValue = stbl->TimeToSample->entries[i].sampleCount;\n\t\t\t}\n\t\t}\n\t\t*defaultDuration = value;\n\t}\n\t//size\n\tif (defaultSize) {\n\t\t*defaultSize = stbl->SampleSize->sampleSize;\n\t}\n\t//descIndex\n\tif (defaultDescriptionIndex) {\n\t\tGF_SampleToChunkBox *stsc= stbl->SampleToChunk;\n\t\tmaxValue = value = 0;\n\t\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\t\tsc_ent = &stsc->entries[i];\n\t\t\tif ((sc_ent->nextChunk - sc_ent->firstChunk) * sc_ent->samplesPerChunk > maxValue) {\n\t\t\t\tvalue = sc_ent->sampleDescriptionIndex;\n\t\t\t\tmaxValue = (sc_ent->nextChunk - sc_ent->firstChunk) * sc_ent->samplesPerChunk;\n\t\t\t}\n\t\t}\n\t\t*defaultDescriptionIndex = value ? value : 1;\n\t}\n\t//RAP\n\tif (defaultRandomAccess) {\n\t\t//no sync table is ALL RAP\n\t\t*defaultRandomAccess = stbl->SyncSample ? 0 : 1;\n\t\tif (stbl->SyncSample\n\t\t        && (stbl->SyncSample->nb_entries == stbl->SampleSize->sampleCount)) {\n\t\t\t*defaultRandomAccess = 1;\n\t\t}\n\t}\n\t//defaultPadding\n\tif (defaultPadding) {\n\t\t*defaultPadding = 0;\n\t\tif (stbl->PaddingBits) {\n\t\t\tmaxValue = 0;\n\t\t\tfor (i=0; i<stbl->PaddingBits->SampleCount; i++) {\n\t\t\t\tvalue = 0;\n\t\t\t\tfor (j=0; j<stbl->PaddingBits->SampleCount; j++) {\n\t\t\t\t\tif (stbl->PaddingBits->padbits[i]==stbl->PaddingBits->padbits[j]) {\n\t\t\t\t\t\tvalue ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value>maxValue) {\n\t\t\t\t\tmaxValue = value;\n\t\t\t\t\t*defaultPadding = stbl->PaddingBits->padbits[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//defaultDegradationPriority\n\tif (defaultDegradationPriority) {\n\t\t*defaultDegradationPriority = 0;\n\t\tif (stbl->DegradationPriority) {\n\t\t\tmaxValue = 0;\n\t\t\tfor (i=0; i<stbl->DegradationPriority->nb_entries; i++) {\n\t\t\t\tvalue = 0;\n\t\t\t\tfor (j=0; j<stbl->DegradationPriority->nb_entries; j++) {\n\t\t\t\t\tif (stbl->DegradationPriority->priorities[i]==stbl->DegradationPriority->priorities[j]) {\n\t\t\t\t\t\tvalue ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value>maxValue) {\n\t\t\t\t\tmaxValue = value;\n\t\t\t\t\t*defaultDegradationPriority = stbl->DegradationPriority->priorities[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_refresh_fragmented(GF_ISOFile *movie, u64 *MissingBytes, const char *new_location)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn GF_NOT_SUPPORTED;\n#else\n\tu64 prevsize, size;\n\tu32 i;\n\tif (!movie || !movie->movieFileMap || !movie->moov) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_READ) return GF_BAD_PARAM;\n\n\t/*refresh size*/\n\tsize = movie->movieFileMap ? gf_bs_get_size(movie->movieFileMap->bs) : 0;\n\n\tif (new_location) {\n\t\tBool delete_map;\n\t\tGF_DataMap *previous_movie_fileMap_address = movie->movieFileMap;\n\t\tGF_Err e;\n\n\t\te = gf_isom_datamap_new(new_location, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &movie->movieFileMap);\n\t\tif (e) {\n\t\t\tmovie->movieFileMap = previous_movie_fileMap_address;\n\t\t\treturn e;\n\t\t}\n\n\t\tdelete_map = (previous_movie_fileMap_address != NULL ? GF_TRUE: GF_FALSE);\n\t\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\t\t\tif (trak->Media->information->dataHandler == previous_movie_fileMap_address) {\n\t\t\t\t//reaasign for later destruction\n\t\t\t\ttrak->Media->information->scalableDataHandler = movie->movieFileMap;\n\t\t\t\t//reassign for Media_GetSample function\n\t\t\t\ttrak->Media->information->dataHandler = movie->movieFileMap;\n\t\t\t} else if (trak->Media->information->scalableDataHandler == previous_movie_fileMap_address) {\n\t\t\t\tdelete_map = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\tif (delete_map) {\n\t\t\tgf_isom_datamap_del(previous_movie_fileMap_address);\n\t\t}\n\t}\n\n\tprevsize = gf_bs_get_refreshed_size(movie->movieFileMap->bs);\n\tif (prevsize==size) return GF_OK;\n\n\tif (!movie->moov->mvex)\n\t\treturn GF_OK;\n\n\t//ok parse root boxes\n\treturn gf_isom_parse_movie_boxes(movie, NULL, MissingBytes, GF_TRUE);\n#endif\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_EXPORT\nvoid gf_isom_set_single_moof_mode(GF_ISOFile *movie, Bool mode)\n{\n\tmovie->single_moof_mode = mode;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_reset_data_offset(GF_ISOFile *movie, u64 *top_box_start)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, count;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tif (top_box_start) *top_box_start = movie->current_top_box_start;\n\tmovie->current_top_box_start = 0;\n\tmovie->NextMoofNumber = 0;\n\tif (movie->moov->mvex && movie->single_moof_mode) {\n\t\tmovie->single_moof_state = 0;\n\t}\n\tcount = gf_list_count(movie->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *tk = gf_list_get(movie->moov->trackList, i);\n\t\ttk->first_traf_merged = GF_FALSE;\n\t}\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_current_top_box_offset(GF_ISOFile *movie, u64 *current_top_box_offset)\n{\n\tif (!movie || !movie->moov || !current_top_box_offset) return GF_BAD_PARAM;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t*current_top_box_offset = movie->current_top_box_start;\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_removed_bytes(GF_ISOFile *movie, u64 bytes_removed)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tmovie->bytes_removed = bytes_removed;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_purge_samples(GF_ISOFile *the_file, u32 trackNumber, u32 nb_samples)\n{\n\tGF_TrackBox *trak;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Err e;\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleTableBox *stbl;\n#endif\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*if trex is already set, restore flags*/\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\ttrex = the_file->moov->mvex ? GetTrex(the_file->moov, gf_isom_get_track_id(the_file,trackNumber) ) : NULL;\n\tif (!trex) return GF_BAD_PARAM;\n\n\t//first unpack chunk offsets and CTS\n\te = stbl_UnpackOffsets(trak->Media->information->sampleTable);\n\tif (e) return e;\n\te = stbl_unpackCTS(trak->Media->information->sampleTable);\n\tif (e) return e;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->TimeToSample || !stbl->SampleSize || !stbl->SampleToChunk) return GF_ISOM_INVALID_FILE;\n\n\t//remove at once nb_samples in stts, ctts, stsz, stco, stsc and stdp (n-times removal is way too slow)\n\t//do NOT change the order DTS, CTS, size chunk\n\tstbl_RemoveDTS(stbl, 1, nb_samples, 0);\n\tstbl_RemoveCTS(stbl, 1, nb_samples);\n\tstbl_RemoveSize(stbl, 1, nb_samples);\n\tstbl_RemoveChunk(stbl, 1, nb_samples);\n\tstbl_RemoveRedundant(stbl, 1, nb_samples);\n\tstbl_RemoveRAPs(stbl, nb_samples);\n\n\t//then remove sample per sample for the rest, which is either\n\t//- sparse data\n\t//- allocated structure rather than memmove-able array\n\t//- not very frequent info (paddind bits)\n\twhile (nb_samples) {\n\t\tstbl_RemoveShadow(stbl, 1);\n\t\tstbl_RemoveSubSample(stbl, 1);\n\t\tstbl_RemovePaddingBits(stbl, 1);\n\t\tstbl_RemoveSampleGroup(stbl, 1);\n\t\tnb_samples--;\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n//reset SampleTable boxes, but do not destroy them if memory reuse is possible\n//this reduces free/alloc time when many fragments\nstatic void gf_isom_recreate_tables(GF_TrackBox *trak)\n{\n\tu32 j;\n\tGF_Box *a;\n\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\tif (stbl->ChunkOffset) {\n\t\tif (stbl->ChunkOffset->type==GF_ISOM_BOX_TYPE_CO64) {\n\t\t\tGF_ChunkLargeOffsetBox *co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\t\tco64->nb_entries = 0;\n\t\t} else {\n\t\t\tGF_ChunkOffsetBox *stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\t\tstco->nb_entries = 0;\n\t\t}\n\t}\n\n\tif (stbl->CompositionOffset) {\n\t\tstbl->CompositionOffset->nb_entries = 0;\n\t\tstbl->CompositionOffset->w_LastSampleNumber = 0;\n\t\tstbl->CompositionOffset->r_currentEntryIndex = 0;\n\t\tstbl->CompositionOffset->r_FirstSampleInEntry = 0;\n\t\tstbl->CompositionOffset->max_cts_delta = 0;\n\t}\n\n\tif (stbl->DegradationPriority) {\n\t\tstbl->DegradationPriority->nb_entries = 0;\n\t}\n\n\tif (stbl->PaddingBits) {\n\t\tstbl->PaddingBits->SampleCount = 0;\n\t}\n\n\tif (stbl->SampleDep) {\n\t\tstbl->SampleDep->sampleCount = 0;\n\t}\n\n\tif (stbl->SampleSize) {\n\t\tstbl->SampleSize->sampleSize = 0;\n\t\tstbl->SampleSize->sampleCount = 0;\n\t}\n\n\tif (stbl->SampleToChunk) {\n\t\tstbl->SampleToChunk->nb_entries = 0;\n\t\tstbl->SampleToChunk->currentIndex = 0;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk = 0;\n\t\tstbl->SampleToChunk->currentChunk = 0;\n\t\tstbl->SampleToChunk->ghostNumber = 0;\n\t\tstbl->SampleToChunk->w_lastSampleNumber = 0;\n\t\tstbl->SampleToChunk->w_lastChunkNumber = 0;\n\t}\n\n\tif (stbl->ShadowSync) {\n        gf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) stbl->ShadowSync);\n        stbl->ShadowSync = (GF_ShadowSyncBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSH);\n\t}\n\n\tif (stbl->SyncSample) {\n\t\tstbl->SyncSample->nb_entries = 0;\n\t\tstbl->SyncSample->r_LastSyncSample = 0;\n\t\tstbl->SyncSample->r_LastSampleIndex = 0;\n\t}\n\n\tif (stbl->TimeToSample) {\n\t\tstbl->TimeToSample->nb_entries = 0;\n\t\tstbl->TimeToSample->r_FirstSampleInEntry = 0;\n\t\tstbl->TimeToSample->r_currentEntryIndex = 0;\n\t\tstbl->TimeToSample->r_CurrentDTS = 0;\n\t}\n\n\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_offsets);\n\tstbl->sai_offsets = NULL;\n\n\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_sizes);\n\tstbl->sai_sizes = NULL;\n\n\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sampleGroups);\n\tstbl->sampleGroups = NULL;\n\n\tif (trak->sample_encryption) {\n\t\tif (trak->Media->information->sampleTable->child_boxes) {\n\t\t\tgf_list_del_item(trak->Media->information->sampleTable->child_boxes, trak->sample_encryption);\n\t\t}\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box*)trak->sample_encryption);\n\t\ttrak->sample_encryption = NULL;\n\t}\n\n\tj = stbl->nb_sgpd_in_stbl;\n\twhile ((a = (GF_Box *)gf_list_enum(stbl->sampleGroupsDescription, &j))) {\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\tj--;\n\t\tgf_list_rem(stbl->sampleGroupsDescription, j);\n\t}\n\n\tif (stbl->traf_map) {\n\t\tfor (j=0; j<stbl->traf_map->nb_entries; j++) {\n\t\t\tif (stbl->traf_map->frag_starts[j].moof_template)\n\t\t\t\tgf_free(stbl->traf_map->frag_starts[j].moof_template);\n\t\t}\n\t\tmemset(stbl->traf_map->frag_starts, 0, sizeof(GF_TrafMapEntry)*stbl->traf_map->nb_alloc);\n\t\tstbl->traf_map->nb_entries = 0;\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_reset_tables(GF_ISOFile *movie, Bool reset_sample_count)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\n\t\tu32 dur;\n\t\tu64 dts;\n\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\t\ttrak->sample_count_at_seg_start += stbl->SampleSize->sampleCount;\n\t\tif (trak->sample_count_at_seg_start) {\n\t\t\tGF_Err e;\n\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\tif (e == GF_OK) {\n\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t}\n\t\t}\n\n\t\t//recreate all boxes\n\t\tgf_isom_recreate_tables(trak);\n\n#if 0\n\t\tj = stbl->nb_stbl_boxes;\n\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\tj--;\n\t\t}\n#endif\n\n\t\tif (reset_sample_count) {\n\t\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t\t\ttrak->dts_at_seg_start = 0;\n\t\t\ttrak->first_traf_merged = GF_FALSE;\n#endif\n\t\t}\n\n\t}\n\tif (reset_sample_count) {\n\t\tmovie->NextMoofNumber = 0;\n\t}\n#endif\n\treturn GF_OK;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_release_segment(GF_ISOFile *movie, Bool reset_tables)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, j, base_track_sample_count;\n\tBool has_scalable;\n\tGF_Box *a;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\thas_scalable = gf_isom_needs_layer_reconstruction(movie);\n\tbase_track_sample_count = 0;\n\tmovie->moov->compressed_diff = 0;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->first_traf_merged = GF_FALSE;\n\t\tif (trak->Media->information->dataHandler == movie->movieFileMap) {\n\t\t\ttrak->Media->information->dataHandler = NULL;\n\t\t}\n\t\tif (trak->Media->information->scalableDataHandler == movie->movieFileMap) {\n\t\t\ttrak->Media->information->scalableDataHandler = NULL;\n\t\t} else {\n\t\t\tif (trak->Media->information->scalableDataHandler==trak->Media->information->dataHandler)\n\t\t\t\ttrak->Media->information->dataHandler = NULL;\n\n\t\t\tgf_isom_datamap_del(trak->Media->information->scalableDataHandler);\n\t\t\ttrak->Media->information->scalableDataHandler = NULL;\n\t\t}\n\n\n\t\tif (reset_tables) {\n\t\t\tu32 dur;\n\t\t\tu64 dts;\n\t\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\t\t\tif (has_scalable) {\n\t\t\t\t//check if the base reference is in the file - if not, do not consider the track is scalable.\n\t\t\t\tif (trak->nb_base_refs) {\n\t\t\t\t\tu32 on_track=0;\n\t\t\t\t\tGF_TrackBox *base;\n\t\t\t\t\tgf_isom_get_reference(movie, i+1, GF_ISOM_REF_BASE, 1, &on_track);\n\n\t\t\t\t\tbase = gf_isom_get_track_from_file(movie, on_track);\n\t\t\t\t\tif (!base) {\n\t\t\t\t\t\tbase_track_sample_count=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbase_track_sample_count = base->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttrak->sample_count_at_seg_start += base_track_sample_count ? base_track_sample_count : stbl->SampleSize->sampleCount;\n\n\t\t\tif (trak->sample_count_at_seg_start) {\n\t\t\t\tGF_Err e;\n\t\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgf_isom_recreate_tables(trak);\n\n\n#if 0 // TO CHECK\n\t\t\tj = ptr->nb_stbl_boxes;\n\t\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\t\tj--;\n\t\t\t}\n#endif\n\t\t}\n\n\n\t\tif (movie->has_pssh_moof) {\n\t\t\tj = 0;\n\t\t\twhile ((a = (GF_Box *)gf_list_enum(movie->moov->child_boxes, &j))) {\n\t\t\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\t\tGF_ProtectionSystemHeaderBox *pssh = (GF_ProtectionSystemHeaderBox *)a;\n\t\t\t\t\tif (pssh->moof_defined) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&movie->moov->child_boxes, a);\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmovie->has_pssh_moof = GF_FALSE;\n\t\t}\n\t}\n\n\tgf_isom_datamap_del(movie->movieFileMap);\n\tmovie->movieFileMap = NULL;\n\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_open_segment(GF_ISOFile *movie, const char *fileName, u64 start_range, u64 end_range, GF_ISOSegOpenMode flags)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn GF_NOT_SUPPORTED;\n#else\n\tu64 MissingBytes;\n\tGF_Err e;\n\tu32 i;\n\tBool segment_map_assigned = GF_FALSE;\n\tBool is_scalable_segment = (flags & GF_ISOM_SEGMENT_SCALABLE_FLAG) ? GF_TRUE : GF_FALSE;\n\tBool no_order_check = (flags & GF_ISOM_SEGMENT_NO_ORDER_FLAG) ? GF_TRUE: GF_FALSE;\n\tGF_DataMap *tmp = NULL;\n\tGF_DataMap *orig_file_map = NULL;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_READ) return GF_BAD_PARAM;\n\n\t/*this is a scalable segment - use a temp data map for the associated track(s) but do NOT touch the movie file map*/\n\tif (is_scalable_segment) {\n\t\ttmp = NULL;\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &tmp);\n\t\tif (e) return e;\n\n\t\torig_file_map = movie->movieFileMap;\n\t\tmovie->movieFileMap = tmp;\n\t} else {\n\t\tif (movie->movieFileMap)\n\t\t\tgf_isom_release_segment(movie, GF_FALSE);\n\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &movie->movieFileMap);\n\t\tif (e) return e;\n\t}\n\tmovie->moov->compressed_diff = 0;\n\tmovie->current_top_box_start = 0;\n\n\tif (start_range || end_range) {\n\t\tif (end_range > start_range) {\n\t\t\tgf_bs_seek(movie->movieFileMap->bs, end_range+1);\n\t\t\tgf_bs_truncate(movie->movieFileMap->bs);\n\t\t}\n\t\tgf_bs_seek(movie->movieFileMap->bs, start_range);\n\t\tmovie->current_top_box_start = start_range;\n\t}\n\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\n\t\tif (!is_scalable_segment) {\n\t\t\t/*reset data handler to new segment*/\n\t\t\tif (trak->Media->information->dataHandler == NULL) {\n\t\t\t\ttrak->Media->information->dataHandler = movie->movieFileMap;\n\t\t\t}\n\t\t} else {\n\t\t\ttrak->present_in_scalable_segment = GF_FALSE;\n\t\t}\n\t}\n\tif (no_order_check) movie->NextMoofNumber = 0;\n\n\t//ok parse root boxes\n\te = gf_isom_parse_movie_boxes(movie, NULL, &MissingBytes, GF_TRUE);\n\n\tif (!is_scalable_segment)\n\t\treturn e;\n\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\tif (trak->present_in_scalable_segment) {\n\t\t\t/*store the temp dataHandler into scalableDataHandler so that it will not be destroyed\n\t\t\tif we append another representation - destruction of this data handler is done in release_segment*/\n\t\t\ttrak->Media->information->scalableDataHandler = tmp;\n\t\t\tif (!segment_map_assigned) {\n\t\t\t\ttrak->Media->information->scalableDataHandler = tmp;\n\t\t\t\tsegment_map_assigned = GF_TRUE;\n\t\t\t}\n\t\t\t//and update the regular dataHandler for the Media_GetSample function\n\t\t\ttrak->Media->information->dataHandler = tmp;\n\t\t}\n\t}\n\tmovie->movieFileMap = \torig_file_map;\n\treturn e;\n#endif\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_highest_track_in_scalable_segment(GF_ISOFile *movie, u32 for_base_track)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\ts32 max_ref;\n\tu32 i, j;\n\tGF_ISOTrackID track_id;\n\n\tmax_ref = 0;\n\ttrack_id = 0;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\ts32 ref;\n\t\tu32 ref_type = GF_ISOM_REF_SCAL;\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\tif (! trak->present_in_scalable_segment) continue;\n\n\t\tref = gf_isom_get_reference_count(movie, i+1, ref_type);\n\t\tif (ref<=0) {\n\t\t\t//handle implicit reconstruction for LHE1/LHV1, check sbas track ref\n\t\t\tu32 subtype = gf_isom_get_media_subtype(movie, i+1, 1);\n\t\t\tswitch (subtype) {\n\t\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\t\tcase GF_ISOM_SUBTYPE_LHV1:\n\t\t\t\tref = gf_isom_get_reference_count(movie, i+1, GF_ISOM_REF_BASE);\n\t\t\t\tif (ref<=0) continue;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ref<=max_ref) continue;\n\n\t\tfor (j=0; j< (u32) ref; j++) {\n\t\t\tu32 on_track=0;\n\t\t\tgf_isom_get_reference(movie, i+1, GF_ISOM_REF_BASE, j+1, &on_track);\n\t\t\tif (on_track==for_base_track) {\n\t\t\t\tmax_ref = ref;\n\t\t\t\ttrack_id = trak->Header->trackID;\n\t\t\t}\n\t\t}\n\t}\n\treturn track_id;\n#endif\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_text_set_streaming_mode(GF_ISOFile *movie, Bool do_convert)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tmovie->convert_streaming_text = do_convert;\n\treturn GF_OK;\n}\n\nstatic void gf_isom_gen_desc_get_dsi(GF_GenericSampleDescription *udesc, GF_List *child_boxes)\n{\n\tif (!child_boxes) return;\n\tGF_UnknownBox *a=NULL;\n\tu32 i=0;\n\twhile ((a=gf_list_enum(child_boxes, &i))) {\n\t\tif (a->type == GF_ISOM_BOX_TYPE_UNKNOWN) break;\n\t\ta = NULL;\n\t}\n\tif (!a) return;\n\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * a->dataSize);\n\tif (udesc->extension_buf) {\n\t\tudesc->extension_buf_size = a->dataSize;\n\t\tmemcpy(udesc->extension_buf, a->data, a->dataSize);\n\t\tudesc->ext_box_wrap = a->original_4cc;\n\t}\n}\n\nGF_EXPORT\nGF_GenericSampleDescription *gf_isom_get_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_GenericVisualSampleEntryBox *entry;\n\tGF_GenericAudioSampleEntryBox *gena;\n\tGF_GenericSampleEntryBox *genm;\n\tGF_TrackBox *trak;\n\tGF_GenericSampleDescription *udesc;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !StreamDescriptionIndex || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\n\tentry = (GF_GenericVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\t//no entry or MPEG entry:\n\tif (!entry || IsMP4Description(entry->type) ) return NULL;\n\t//if we handle the description return false\n\tswitch (entry->type) {\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\treturn NULL;\n\tcase GF_ISOM_BOX_TYPE_GNRV:\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (entry->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)entry)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = entry->EntryType;\n\t\t}\n\t\tudesc->version = entry->version;\n\t\tudesc->revision = entry->revision;\n\t\tudesc->vendor_code = entry->vendor;\n\t\tudesc->temporal_quality = entry->temporal_quality;\n\t\tudesc->spatial_quality = entry->spatial_quality;\n\t\tudesc->width = entry->Width;\n\t\tudesc->height = entry->Height;\n\t\tudesc->h_res = entry->horiz_res;\n\t\tudesc->v_res = entry->vert_res;\n\t\tstrcpy(udesc->compressor_name, entry->compressor_name);\n\t\tudesc->depth = entry->bit_depth;\n\t\tudesc->color_table_index = entry->color_table_index;\n\t\tif (entry->data_size) {\n\t\t\tudesc->extension_buf_size = entry->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * entry->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, entry->data, entry->data_size);\n\t\t} else {\n\t\t\tgf_isom_gen_desc_get_dsi(udesc, entry->child_boxes);\n\t\t}\n\t\treturn udesc;\n\tcase GF_ISOM_BOX_TYPE_GNRA:\n\t\tgena = (GF_GenericAudioSampleEntryBox *)entry;\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (gena->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)gena)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = gena->EntryType;\n\t\t}\n\t\tudesc->version = gena->version;\n\t\tudesc->revision = gena->revision;\n\t\tudesc->vendor_code = gena->vendor;\n\t\tudesc->samplerate = gena->samplerate_hi;\n\t\tudesc->bits_per_sample = gena->bitspersample;\n\t\tudesc->nb_channels = gena->channel_count;\n\t\tif (gena->data_size) {\n\t\t\tudesc->extension_buf_size = gena->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * gena->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, gena->data, gena->data_size);\n\t\t} else {\n\t\t\tgf_isom_gen_desc_get_dsi(udesc, entry->child_boxes);\n\t\t}\n\t\treturn udesc;\n\tcase GF_ISOM_BOX_TYPE_GNRM:\n\t\tgenm = (GF_GenericSampleEntryBox *)entry;\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (genm->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)genm)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = genm->EntryType;\n\t\t}\n\t\tif (genm->data_size) {\n\t\t\tudesc->extension_buf_size = genm->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * genm->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, genm->data, genm->data_size);\n\t\t} else {\n\t\t\tgf_isom_gen_desc_get_dsi(udesc, entry->child_boxes);\n\t\t}\n\t\treturn udesc;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_visual_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *Width, u32 *Height)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t*Width = ((GF_VisualSampleEntryBox*)entry)->Width;\n\t\t*Height = ((GF_VisualSampleEntryBox*)entry)->Height;\n\t} else if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_SCENE) {\n\t\t*Width = trak->Header->width>>16;\n\t\t*Height = trak->Header->height>>16;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_visual_bit_depth(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, u16* bitDepth)\n{\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t*bitDepth = ((GF_VisualSampleEntryBox*)entry)->bit_depth;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_audio_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *SampleRate, u32 *Channels, u32 *bitsPerSample)\n{\n\tGF_TrackBox *trak;\n\tGF_AudioSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd = NULL;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media && trak->Media->information && trak->Media->information->sampleTable && trak->Media->information->sampleTable->SampleDescription)\n\t\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_AudioSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\n\tif (SampleRate) {\n\t\t(*SampleRate) = entry->samplerate_hi;\n\t\tif (entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tu32 sr = entry->samplerate_hi;\n\t\t\tsr <<= 16;\n\t\t\tsr |= entry->samplerate_lo;\n\t\t\t(*SampleRate) = sr;\n\t\t}\n\t}\n\tif (Channels) (*Channels) = entry->channel_count;\n\tif (bitsPerSample) (*bitsPerSample) = (u8) entry->bitspersample;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_audio_layout(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_AudioChannelLayout *layout)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ChannelLayoutBox *chnl;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !layout) return GF_BAD_PARAM;\n\tmemset(layout, 0, sizeof(GF_AudioChannelLayout));\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\tchnl = (GF_ChannelLayoutBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\tif (!chnl) return GF_NOT_FOUND;\n\n\tmemcpy(layout, &chnl->layout, sizeof(GF_AudioChannelLayout));\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_get_pixel_aspect_ratio(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *hSpacing, u32 *vSpacing)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !hSpacing || !vSpacing) return GF_BAD_PARAM;\n\t*hSpacing = 1;\n\t*vSpacing = 1;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_OK;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\tGF_PixelAspectRatioBox *pasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\t\tif (pasp) {\n\t\t\t*hSpacing = pasp->hSpacing;\n\t\t\t*vSpacing = pasp->vSpacing;\n\t\t}\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_color_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *colour_type, u16 *colour_primaries, u16 *transfer_characteristics, u16 *matrix_coefficients, Bool *full_range_flag)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_OK;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type!=GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tu32 i, count = gf_list_count(entry->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ColourInformationBox *clr = (GF_ColourInformationBox *) gf_list_get(entry->child_boxes, i);\n\t\tif (clr->type != GF_ISOM_BOX_TYPE_COLR) continue;\n\t\tif (clr->is_jp2) continue;\n\t\tif (clr->opaque_size) continue;\n\n\t\tif (colour_type) *colour_type = clr->colour_type;\n\t\tif (colour_primaries) *colour_primaries = clr->colour_primaries;\n\t\tif (transfer_characteristics) *transfer_characteristics = clr->transfer_characteristics;\n\t\tif (matrix_coefficients) *matrix_coefficients = clr->matrix_coefficients;\n\t\tif (full_range_flag) *full_range_flag = clr->full_range_flag;\n\t\treturn GF_OK;\n\t}\n\treturn GF_NOT_FOUND;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_icc_profile(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, Bool *icc_restricted, const u8 **icc, u32 *icc_size)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\tif (!icc || !icc_size) return GF_BAD_PARAM;\n\t*icc = NULL;\n\t*icc_size = 0;\n\tif (icc_restricted) *icc_restricted = GF_FALSE;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_OK;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type!=GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tu32 i, count = gf_list_count(entry->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ColourInformationBox *clr = (GF_ColourInformationBox *) gf_list_get(entry->child_boxes, i);\n\t\tif (clr->type != GF_ISOM_BOX_TYPE_COLR) continue;\n\t\tif (clr->is_jp2) continue;\n\t\tif (!clr->opaque_size) continue;\n\n\t\tif (clr->colour_type==GF_4CC('r', 'I', 'C', 'C')) {\n\t\t\tif (icc_restricted) *icc_restricted = GF_TRUE;\n\t\t\t*icc = clr->opaque;\n\t\t\t*icc_size = clr->opaque_size;\n\t\t}\n\t\telse if (clr->colour_type==GF_4CC('p', 'r', 'o', 'f')) {\n\t\t\t*icc = clr->opaque;\n\t\t\t*icc_size = clr->opaque_size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn GF_NOT_FOUND;\n}\n\nGF_EXPORT\nconst char *gf_isom_get_filename(GF_ISOFile *movie)\n{\n\tif (!movie) return NULL;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (movie->finalName && !movie->fileName) return movie->finalName;\n#endif\n\treturn movie->fileName;\n}\n\n\nGF_EXPORT\nu8 gf_isom_get_pl_indication(GF_ISOFile *movie, GF_ISOProfileLevelType PL_Code)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tif (!movie || !movie->moov) return 0xFF;\n\tif (!movie->moov->iods || !movie->moov->iods->descriptor) return 0xFF;\n\tif (movie->moov->iods->descriptor->tag != GF_ODF_ISOM_IOD_TAG) return 0xFF;\n\n\tiod = (GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor;\n\tswitch (PL_Code) {\n\tcase GF_ISOM_PL_AUDIO:\n\t\treturn iod->audio_profileAndLevel;\n\tcase GF_ISOM_PL_VISUAL:\n\t\treturn iod->visual_profileAndLevel;\n\tcase GF_ISOM_PL_GRAPHICS:\n\t\treturn iod->graphics_profileAndLevel;\n\tcase GF_ISOM_PL_SCENE:\n\t\treturn iod->scene_profileAndLevel;\n\tcase GF_ISOM_PL_OD:\n\t\treturn iod->OD_profileAndLevel;\n\tcase GF_ISOM_PL_INLINE:\n\t\treturn iod->inlineProfileFlag;\n\tcase GF_ISOM_PL_MPEGJ:\n\tdefault:\n\t\treturn 0xFF;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_matrix(GF_ISOFile *the_file, u32 trackNumber, u32 matrix[9])\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\tmemcpy(matrix, trak->Header->matrix, sizeof(trak->Header->matrix));\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_layout_info(GF_ISOFile *movie, u32 trackNumber, u32 *width, u32 *height, s32 *translation_x, s32 *translation_y, s16 *layer)\n{\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) return GF_BAD_PARAM;\n\tif (width) *width = tk->Header->width>>16;\n\tif (height) *height = tk->Header->height>>16;\n\tif (layer) *layer = tk->Header->layer;\n\tif (translation_x) *translation_x = tk->Header->matrix[6] >> 16;\n\tif (translation_y) *translation_y = tk->Header->matrix[7] >> 16;\n\treturn GF_OK;\n}\n\n\n/*returns total amount of media bytes in track*/\nGF_EXPORT\nu64 gf_isom_get_media_data_size(GF_ISOFile *movie, u32 trackNumber)\n{\n\tu32 i;\n\tu64 size;\n\tGF_SampleSizeBox *stsz;\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) return 0;\n\tstsz = tk->Media->information->sampleTable->SampleSize;\n\tif (!stsz) return 0;\n\tif (stsz->sampleSize) return stsz->sampleSize*stsz->sampleCount;\n\tsize = 0;\n\tfor (i=0; i<stsz->sampleCount; i++) size += stsz->sizes[i];\n\treturn size;\n}\n\nGF_EXPORT\nu64 gf_isom_get_first_mdat_start(GF_ISOFile *movie)\n{\n\tu64 offset;\n\tif (!movie) return 0;\n\toffset = movie->first_data_toplevel_offset + 8;\n\tif (movie->first_data_toplevel_size > 0xFFFFFFFFUL)\n\t\toffset += 8;\n\treturn offset;\n}\n\nstatic u64 box_unused_bytes(GF_Box *b)\n{\n\tu32 i, count;\n\tu64 size = 0;\n\tswitch (b->type) {\n\tcase GF_QT_BOX_TYPE_WIDE:\n\tcase GF_ISOM_BOX_TYPE_FREE:\n\tcase GF_ISOM_BOX_TYPE_SKIP:\n\t\tsize += b->size;\n\t\tbreak;\n\t}\n\tcount = gf_list_count(b->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *child = gf_list_get(b->child_boxes, i);\n\t\tsize += box_unused_bytes(child);\n\t}\n\treturn size;\n}\n\nextern u64 unused_bytes;\n\nGF_EXPORT\nu64 gf_isom_get_unused_box_bytes(GF_ISOFile *movie)\n{\n\tu64 size = unused_bytes;\n\tu32 i, count;\n\tif (!movie) return 0;\n\tcount = gf_list_count(movie->TopBoxes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(movie->TopBoxes, i);\n\t\tsize += box_unused_bytes(b);\n\t}\n\treturn size;\n}\n\nGF_EXPORT\nvoid gf_isom_set_default_sync_track(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) movie->es_id_default_sync = -1;\n\telse movie->es_id_default_sync = tk->Header->trackID;\n}\n\n\nGF_EXPORT\nBool gf_isom_is_single_av(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_a, nb_v, nb_auxv, nb_pict, nb_scene, nb_od, nb_text;\n\tnb_auxv = nb_pict = nb_a = nb_v = nb_any = nb_scene = nb_od = nb_text = 0;\n\n\tif (!file->moov) return GF_FALSE;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_any++;\n\t\t\telse nb_scene++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_any++;\n\t\t\telse nb_od++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\tnb_text++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tnb_a++;\n\t\t\tbreak;\n        case GF_ISOM_MEDIA_AUXV:\n            /*discard file with images*/\n            if (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n            else nb_auxv++;\n            break;\n        case GF_ISOM_MEDIA_PICT:\n            /*discard file with images*/\n            if (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n            else nb_pict++;\n            break;\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\t/*discard file with images*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n\t\t\telse nb_v++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnb_any++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nb_any) return GF_FALSE;\n\tif ((nb_scene<=1) && (nb_od<=1) && (nb_a<=1) && (nb_v+nb_pict+nb_auxv<=1) && (nb_text<=1) ) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_isom_is_JPEG2000(GF_ISOFile *mov)\n{\n\treturn (mov && mov->is_jp2) ? GF_TRUE : GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_guess_specification(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_m4s, nb_a, nb_v, nb_auxv,nb_scene, nb_od, nb_mp3, nb_aac, nb_m4v, nb_avc, nb_amr, nb_h263, nb_qcelp, nb_evrc, nb_smv, nb_text, nb_pict;\n\n\tnb_m4s = nb_a = nb_v = nb_auxv = nb_any = nb_scene = nb_od = nb_mp3 = nb_aac = nb_m4v = nb_avc = nb_amr = nb_h263 = nb_qcelp = nb_evrc = nb_smv = nb_text = nb_pict = 0;\n\n\tif (file->is_jp2) {\n\t\tif (file->moov) return GF_ISOM_BRAND_MJP2;\n\t\treturn GF_ISOM_BRAND_JP2;\n\t}\n\tif (!file->moov) {\n\t\tif (!file->meta || !file->meta->handler) return 0;\n\t\treturn file->meta->handler->handlerType;\n\t}\n\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tu32 mstype = gf_isom_get_media_subtype(file, i+1, 1);\n\n\t\tif (mtype==GF_ISOM_MEDIA_SCENE) {\n\t\t\tnb_scene++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t} else if (mtype==GF_ISOM_MEDIA_OD) {\n\t\t\tnb_od++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t}\n\t\telse if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT)) nb_text++;\n\t\telse if ((mtype==GF_ISOM_MEDIA_AUDIO) || gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tswitch (mstype) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tnb_amr++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tnb_h263++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tnb_evrc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tnb_qcelp++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tnb_smv++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\t{\n\t\t\t\tGF_DecoderConfig *dcd = gf_isom_get_decoder_config(file, i+1, 1);\n\t\t\t\tif (!dcd) break;\n\t\t\t\tswitch (dcd->streamType) {\n\t\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\t\tif (dcd->objectTypeIndication==GF_CODECID_MPEG4_PART2) nb_m4v++;\n\t\t\t\t\telse if ((dcd->objectTypeIndication==GF_CODECID_AVC) || (dcd->objectTypeIndication==GF_CODECID_SVC) || (dcd->objectTypeIndication==GF_CODECID_MVC)) nb_avc++;\n\t\t\t\t\telse nb_v++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\t\tswitch (dcd->objectTypeIndication) {\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t\t\t\t\tnb_aac++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_MPEG2_PART3:\n\t\t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n\t\t\t\t\tcase GF_CODECID_MPEG_AUDIO_L1:\n\t\t\t\t\t\tnb_mp3++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\t\t\tnb_evrc++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\t\tnb_smv++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\t\t\tnb_qcelp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tnb_a++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t/*SHOULD NEVER HAPPEN - IF SO, BROKEN MPEG4 FILE*/\n\t\t\t\tdefault:\n\t\t\t\t\tnb_any++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)dcd);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (mtype==GF_ISOM_MEDIA_VISUAL) nb_v++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_AUXV) nb_auxv++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_PICT) nb_pict++;\n\t\t\t\telse nb_a++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP)) nb_m4s++;\n\t\telse nb_any++;\n\t}\n\tif (nb_any) return GF_ISOM_BRAND_ISOM;\n\tif (nb_qcelp || nb_evrc || nb_smv) {\n\t\t/*non std mix of streams*/\n\t\tif (nb_m4s || nb_avc || nb_scene || nb_od || nb_mp3 || nb_a || nb_v) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_3G2A;\n\t}\n\t/*other a/v/s streams*/\n\tif (nb_v || nb_a || nb_m4s) return GF_ISOM_BRAND_MP42;\n\n\tnb_v = nb_m4v + nb_avc + nb_h263;\n\tnb_a = nb_mp3 + nb_aac + nb_amr;\n\n\t/*avc file: whatever has AVC and no systems*/\n\tif (nb_avc) {\n\t\tif (!nb_scene && !nb_od) return GF_ISOM_BRAND_AVC1;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP3: ISMA and MPEG4*/\n\tif (nb_mp3) {\n\t\tif (!nb_text && (nb_v<=1) && (nb_a<=1) && (nb_scene==1) && (nb_od==1))\n\t\t\treturn GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP4*/\n\tif (nb_scene || nb_od) {\n\t\t/*issue with AMR and H263 which don't have MPEG mapping: non compliant file*/\n\t\tif (nb_amr || nb_h263) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*use ISMA (3GP fine too)*/\n\tif (!nb_amr && !nb_h263 && !nb_text) {\n\t\tif ((nb_v<=1) && (nb_a<=1)) return GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\n\tif ((nb_v<=1) && (nb_a<=1) && (nb_text<=1)) return nb_text ? GF_ISOM_BRAND_3GP6 : GF_ISOM_BRAND_3GP5;\n\treturn GF_ISOM_BRAND_3GG6;\n}\n\nGF_ItemListBox *gf_isom_locate_box(GF_List *list, u32 boxType, bin128 UUID)\n{\n\tu32 i;\n\tGF_Box *box;\n\ti=0;\n\twhile ((box = (GF_Box *)gf_list_enum(list, &i))) {\n\t\tif (box->type == boxType) {\n\t\t\tGF_UUIDBox* box2 = (GF_UUIDBox* )box;\n\t\t\tif (boxType != GF_ISOM_BOX_TYPE_UUID) return (GF_ItemListBox *)box;\n\t\t\tif (!memcmp(box2->uuid, UUID, 16)) return (GF_ItemListBox *)box;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*Apple extensions*/\n\n\nGF_EXPORT\nGF_Err gf_isom_apple_get_tag(GF_ISOFile *mov, GF_ISOiTunesTag tag, const u8 **data, u32 *data_len)\n{\n\tu32 i;\n\tGF_ListItemBox *info;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\n\t*data = NULL;\n\t*data_len = 0;\n\n\tmeta = (GF_MetaBox *) gf_isom_get_meta_extensions(mov, 0);\n\tif (!meta) return GF_URL_ERROR;\n\n\tilst = gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) return GF_URL_ERROR;\n\n\tif (tag==GF_ISOM_ITUNE_PROBE) return gf_list_count(ilst->child_boxes) ? GF_OK : GF_URL_ERROR;\n\n\ti=0;\n\twhile ( (info=(GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tif (info->type==tag) break;\n\t\t/*special cases*/\n\t\tif ((tag==GF_ISOM_ITUNE_GENRE) && (info->type==(u32) GF_ISOM_ITUNE_GENRE_USER)) break;\n\t\tinfo = NULL;\n\t}\n\tif (!info || !info->data || !info->data->data) return GF_URL_ERROR;\n\n\tif ((tag == GF_ISOM_ITUNE_GENRE) && (info->data->flags == 0)) {\n\t\tif (info->data->dataSize && (info->data->dataSize>2) && (info->data->dataSize < 5)) {\n\t\t\tGF_BitStream* bs = gf_bs_new(info->data->data, info->data->dataSize, GF_BITSTREAM_READ);\n\t\t\t*data_len = gf_bs_read_int(bs, info->data->dataSize * 8);\n\t\t\tgf_bs_del(bs);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n//\tif (info->data->flags != 0x1) return GF_URL_ERROR;\n\t*data = info->data->data;\n\t*data_len = info->data->dataSize;\n\tif ((tag==GF_ISOM_ITUNE_COVER_ART) && (info->data->flags==14)) *data_len |= 0x80000000; //(1<<31);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_apple_enum_tag(GF_ISOFile *mov, u32 idx, GF_ISOiTunesTag *out_tag, const u8 **data, u32 *data_len, u64 *out_int_val, u32 *out_int_val2, u32 *out_flags)\n{\n\tu32 i, child_index;\n\tGF_ListItemBox *info;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\tGF_DataBox *dbox = NULL;\n\tBool found=GF_FALSE;\n\tu32 itype, tag_val;\n\ts32 tag_idx;\n\t*data = NULL;\n\t*data_len = 0;\n\t*out_int_val = 0;\n\t*out_int_val2 = 0;\n\t*out_flags = 0;\n\n\tmeta = (GF_MetaBox *) gf_isom_get_meta_extensions(mov, 0);\n\tif (!meta) return GF_URL_ERROR;\n\n\tilst = gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) return GF_URL_ERROR;\n\n\tchild_index = i = 0;\n\twhile ( (info=(GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tGF_DataBox *data_box = NULL;\n\t\tif (gf_itags_find_by_itag(info->type)<0) {\n\t\t\ttag_val = info->type;\n\t\t\tif (info->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t\tdata_box = (GF_DataBox *) gf_isom_box_find_child(info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\t\t\tif (!data_box) continue;\n\t\t\t\ttag_val = ((GF_UnknownBox *)info)->original_4cc;\n\t\t\t}\n\t\t} else {\n\t\t\tdata_box = info->data;\n\t\t\ttag_val = info->type;\n\t\t}\n\t\tif (child_index==idx) {\n\t\t\tdbox = data_box;\n\t\t\tfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tchild_index++;\n\t}\n\n\tif (!dbox) {\n\t\tif (found) {\n\t\t\t*data = NULL;\n\t\t\t*data_len = 1;\n\t\t\t*out_tag = tag_val;\n\t\t\treturn GF_OK;\n\t\t}\n\t\treturn GF_URL_ERROR;\n\t}\n\t*out_flags = dbox->flags;\n\t*out_tag = tag_val;\n\tif (!dbox->data) {\n\t\t*data = NULL;\n\t\t*data_len = 1;\n\t\treturn GF_OK;\n\t}\n\n\ttag_idx = gf_itags_find_by_itag(info->type);\n\tif (tag_idx<0) {\n\t\t*data = dbox->data;\n\t\t*data_len = dbox->dataSize;\n\t\treturn GF_OK;\n\t}\n\n\tif ((tag_val == GF_ISOM_ITUNE_GENRE) && (dbox->flags == 0) && (dbox->dataSize>=2)) {\n\t\tu32 int_val = dbox->data[0];\n\t\tint_val <<= 8;\n\t\tint_val |= dbox->data[1];\n\t\t*data = NULL;\n\t\t*data_len = 0;\n\t\t*out_int_val = int_val;\n\t\treturn GF_OK;\n\t}\n\n\titype = gf_itags_get_type((u32) tag_idx);\n\tswitch (itype) {\n\tcase GF_ITAG_BOOL:\n\tcase GF_ITAG_INT8:\n\t\tif (dbox->dataSize) *out_int_val = dbox->data[0];\n\t\tbreak;\n\tcase GF_ITAG_INT16:\n\t\tif (dbox->dataSize>1) {\n\t\t\tu16 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_INT32:\n\t\tif (dbox->dataSize>3) {\n\t\t\tu32 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_INT64:\n\t\tif (dbox->dataSize>7) {\n\t\t\tu64 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[4];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[5];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[6];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[7];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_FRAC6:\n\tcase GF_ITAG_FRAC8:\n\t\tif (dbox->dataSize>5) {\n\t\t\tu32 v = dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\t*out_int_val = v;\n\t\t\tv = dbox->data[4];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[5];\n\t\t\t*out_int_val2 = v;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t*data = dbox->data;\n\t\t*data_len = dbox->dataSize;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_enum_udta_keys(GF_ISOFile *mov, u32 idx, GF_QT_UDTAKey *okey)\n{\n\tu32 i, count;\n\n\tGF_MetaBox *meta = (GF_MetaBox *) gf_isom_get_meta_extensions(mov, 2);\n\tif (!meta || !meta->keys) return GF_URL_ERROR;\n\n\tGF_MetaKey *k = gf_list_get(meta->keys->keys, idx);\n\tif (!k) return GF_URL_ERROR;\n\tif (!okey) return GF_OK;\n\n\tmemset(okey, 0, sizeof(GF_QT_UDTAKey) );\n\tokey->name = k->data;\n\tokey->ns = k->ns;\n\n\tGF_ListItemBox *ilst = (GF_ListItemBox *) gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) return GF_OK;\n\n\tGF_DataBox *data_box = NULL;\n\tcount = gf_list_count(ilst->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_UnknownBox *u = gf_list_get(ilst->child_boxes, i);\n\t\tif (u->type!=GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\tif (u->original_4cc==idx+1) {\n\t\t\tdata_box = (GF_DataBox *) gf_isom_box_find_child(u->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\t}\n\t}\n\n\tokey->type=GF_QT_KEY_OPAQUE;\n\tif (!data_box || (data_box->version!=0)) {\n\t\tif (data_box) {\n\t\t\tokey->value.data.data = data_box->data;\n\t\t\tokey->value.data.data_len = data_box->dataSize;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tokey->type = data_box->flags;\n\n\tu32 nb_bits = 8 * data_box->dataSize;\n\tGF_BitStream *bs = gf_bs_new(data_box->data, data_box->dataSize, GF_BITSTREAM_READ);\n\tswitch (okey->type) {\n\tcase GF_QT_KEY_UTF8:\n\tcase GF_QT_KEY_UTF8_SORT:\n\t\tokey->value.string = data_box->data;\n\t\tbreak;\n\n\tcase GF_QT_KEY_SIGNED_VSIZE:\n\t{\n\t\tu32 val = gf_bs_read_int(bs, nb_bits);\n\t\tif (nb_bits==8) okey->value.sint = (s64) (s8) val;\n\t\telse if (nb_bits==16) okey->value.sint = (s64) (s16) val;\n\t\telse if (nb_bits==32) okey->value.sint = (s64) (s32) val;\n\t\telse if (nb_bits==64) okey->value.sint = (s64) val;\n\t}\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_VSIZE:\n\t\tokey->value.uint = (s32) gf_bs_read_int(bs, nb_bits);\n\t\tbreak;\n\tcase GF_QT_KEY_FLOAT:\n\t\tokey->value.number = gf_bs_read_float(bs);\n\t\tbreak;\n\tcase GF_QT_KEY_DOUBLE:\n\t\tokey->value.number = gf_bs_read_double(bs);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_8:\n\t\tokey->value.sint = (s64) (s8) gf_bs_read_int(bs, 8);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_16:\n\t\tokey->value.sint = (s64) (s16) gf_bs_read_int(bs, 16);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_32:\n\t\tokey->value.sint = (s64) (s32) gf_bs_read_int(bs, 32);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_64:\n\t\tokey->value.sint = (s64) gf_bs_read_long_int(bs, 64);\n\t\tbreak;\n\tcase GF_QT_KEY_POINTF:\n\tcase GF_QT_KEY_SIZEF:\n\t\tokey->value.pos_size.x = gf_bs_read_float(bs);\n\t\tokey->value.pos_size.y = gf_bs_read_float(bs);\n\t\tbreak;\n\tcase GF_QT_KEY_RECTF:\n\t\tokey->value.rect.x = gf_bs_read_float(bs);\n\t\tokey->value.rect.y = gf_bs_read_float(bs);\n\t\tokey->value.rect.w = gf_bs_read_float(bs);\n\t\tokey->value.rect.h = gf_bs_read_float(bs);\n\t\tbreak;\n\n\tcase GF_QT_KEY_UNSIGNED_8:\n\t\tokey->value.uint = gf_bs_read_int(bs, 8);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_16:\n\t\tokey->value.uint = gf_bs_read_int(bs, 16);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_32:\n\t\tokey->value.uint = gf_bs_read_int(bs, 32);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_64:\n\t\tokey->value.uint = gf_bs_read_int(bs, 64);\n\t\tbreak;\n\tcase GF_QT_KEY_MATRIXF:\n\t\tfor (i=0; i<9; i++)\n\t\t\tokey->value.matrix[i] = gf_bs_read_float(bs);\n\t\tbreak;\n\n\tcase GF_QT_KEY_OPAQUE:\n\tcase GF_QT_KEY_UTF16_BE:\n\tcase GF_QT_KEY_JIS:\n\tcase GF_QT_KEY_UTF16_SORT:\n\tcase GF_QT_KEY_JPEG:\n\tcase GF_QT_KEY_PNG:\n\tcase GF_QT_KEY_BMP:\n\tcase GF_QT_KEY_METABOX:\n\t\tokey->value.data.data = data_box->data;\n\t\tokey->value.data.data_len = data_box->dataSize;\n\t\tbreak;\n\tcase GF_QT_KEY_REMOVE:\n\t\tbreak;\n\t}\n\tGF_Err e = GF_OK;\n\tif (gf_bs_is_overflow(bs))\n\t\te = GF_ISOM_INVALID_FILE;\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_wma_enum_tag(GF_ISOFile *mov, u32 idx, char **out_tag, const u8 **data, u32 *data_len, u32 *version, u32 *data_type)\n{\n\tGF_XtraBox *xtra;\n\tGF_XtraTag *tag;\n\n\t*out_tag = NULL;\n\t*data = NULL;\n\t*data_len = 0;\n\t*version = 0;\n\t*data_type = 0;\n\n\txtra = (GF_XtraBox *) gf_isom_get_meta_extensions(mov, 1);\n\tif (!xtra) return GF_URL_ERROR;\n\n\ttag = gf_list_get(xtra->tags, idx);\n\tif (!tag) return GF_NOT_FOUND;\n\t*out_tag = tag->name;\n\t*data_len = tag->prop_size;\n\t*data = tag->prop_value;\n\t*version = tag->flags;\n\t*data_type = tag->prop_type;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_get_track_switch_group_count(GF_ISOFile *movie, u32 trackNumber, u32 *alternateGroupID, u32 *nb_groups)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\tif (alternateGroupID) *alternateGroupID = trak->Header->alternate_group;\n\tif (nb_groups) *nb_groups = 0;\n\tif (!trak->udta || !nb_groups) return GF_OK;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return GF_OK;\n\t*nb_groups = gf_list_count(map->boxes);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}\n\nGF_EXPORT\nu32 gf_isom_get_next_alternate_group_id(GF_ISOFile *movie)\n{\n\tu32 id = 0;\n\tu32 i=0;\n\n\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, i+1);\n\t\tif (trak->Header->alternate_group > id)\n\t\t\tid = trak->Header->alternate_group;\n\t\ti++;\n\t}\n\treturn id+1;\n}\n\nGF_EXPORT\nu8 *gf_isom_sample_get_subsamples_buffer(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 *osize)\n{\n\tu8 *data;\n\tu32 size;\n\tu32 i, count;\n\tGF_BitStream *bs = NULL;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak || !osize) return NULL;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return NULL;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, sub_count, last_sample = 0;\n\t\tGF_SubSampleInformationBox *sub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\n\t\tsub_count = gf_list_count(sub_samples->Samples);\n\t\tfor (j=0; j<sub_count; j++) {\n\t\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry *) gf_list_get(sub_samples->Samples, j);\n\t\t\tif (last_sample + pSamp->sample_delta == sampleNumber) {\n\t\t\t\tu32 scount = gf_list_count(pSamp->SubSamples);\n\t\t\t\tfor (j=0; j<scount; j++) {\n\t\t\t\t\tGF_SubSampleEntry *sent = gf_list_get(pSamp->SubSamples, j);\n\t\t\t\t\tif (!bs) bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\t\tgf_bs_write_u32(bs, sub_samples->flags);\n\t\t\t\t\tgf_bs_write_u32(bs, sent->subsample_size);\n\t\t\t\t\tgf_bs_write_u32(bs, sent->reserved);\n\t\t\t\t\tgf_bs_write_u8(bs, sent->subsample_priority);\n\t\t\t\t\tgf_bs_write_u8(bs, sent->discardable);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast_sample += pSamp->sample_delta;\n\t\t}\n\t}\n\tif (!bs) return NULL;\n\tgf_bs_get_content(bs, &data, &size);\n\tgf_bs_del(bs);\n\t*osize = size;\n\treturn data;\n}\n\nGF_EXPORT\nu32 gf_isom_sample_has_subsamples(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sub_samples) return 0;\n\tif (!sampleNumber) return 1;\n\treturn gf_isom_sample_get_subsample_entry(movie, track, sampleNumber, flags, NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_sample_get_subsample(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, u32 subSampleNumber, u32 *size, u8 *priority, u32 *reserved, Bool *discardable)\n{\n\tGF_SubSampleEntry *entry;\n\tGF_SubSampleInfoEntry *sub_sample;\n\tu32 count = gf_isom_sample_get_subsample_entry(movie, track, sampleNumber, flags, &sub_sample);\n\tif (!size || !priority || !discardable) return GF_BAD_PARAM;\n\n\tif (!subSampleNumber || (subSampleNumber>count)) return GF_BAD_PARAM;\n\tentry = (GF_SubSampleEntry*)gf_list_get(sub_sample->SubSamples, subSampleNumber-1);\n\t*size = entry->subsample_size;\n\t*priority = entry->subsample_priority;\n\t*reserved = entry->reserved;\n\t*discardable = entry->discardable ? GF_TRUE : GF_FALSE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_rvc_config(GF_ISOFile *movie, u32 track, u32 sampleDescriptionIndex, u16 *rvc_predefined, u8 **data, u32 *size, const char **mime)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_TrackBox *trak;\n\n\tif (!rvc_predefined || !data || !size) return GF_BAD_PARAM;\n\t*rvc_predefined = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!entry ) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_RVCConfigurationBox *rvcc = (GF_RVCConfigurationBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\tif (!rvcc) return GF_NOT_FOUND;\n\n\t*rvc_predefined = rvcc->predefined_rvc_config;\n\tif (rvcc->rvc_meta_idx) {\n\t\tif (!data || !size) return GF_OK;\n\t\treturn gf_isom_extract_meta_item_mem(movie, GF_FALSE, track, rvcc->rvc_meta_idx, data, size, NULL, mime, GF_FALSE);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_isom_moov_first(GF_ISOFile *movie)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(movie->TopBoxes); i++) {\n\t\tGF_Box *b = (GF_Box*)gf_list_get(movie->TopBoxes, i);\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MOOV) return GF_TRUE;\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MDAT) return GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nvoid gf_isom_reset_fragment_info(GF_ISOFile *movie, Bool keep_sample_count)\n{\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\t}\n#else\n\t\t//do not reset tfdt for LL-HLS case where parts do not contain a TFDT\n\t\t//trak->dts_at_seg_start = 0;\n\t\tif (!keep_sample_count)\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nvoid gf_isom_reset_seq_num(GF_ISOFile *movie)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nvoid gf_isom_reset_sample_count(GF_ISOFile *movie)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nBool gf_isom_has_cenc_sample_group(GF_ISOFile *the_file, u32 trackNumber, Bool *has_selective, Bool *has_roll)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\tGF_SampleGroupDescriptionBox *seig=NULL;\n\n\tif (has_selective) *has_selective = GF_FALSE;\n\tif (has_roll) *has_roll = GF_FALSE;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_FALSE;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_SEIG) {\n\t\t\tseig = sgdesc;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!seig)\n\t\treturn GF_FALSE;\n\n\tfor (i=0; i<gf_list_count(seig->group_descriptions); i++) {\n\t\tGF_CENCSampleEncryptionGroupEntry *se = gf_list_get(seig->group_descriptions, i);\n\t\tif (!se->IsProtected) {\n\t\t\tif (has_selective) *has_selective = GF_TRUE;\n\t\t} else {\n\t\t\tif (has_roll) *has_roll = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_rap_roll_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, Bool *is_rap, GF_ISOSampleRollType *roll_type, s32 *roll_distance)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\tif (is_rap) *is_rap = GF_FALSE;\n\tif (roll_type) *roll_type = 0;\n\tif (roll_distance) *roll_distance = 0;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_OK;\n\n\tif (!sample_number) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tswitch (sgdesc->grouping_type) {\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\t\tif (is_rap) *is_rap = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\t\tif (roll_type)\n\t\t\t\t\t*roll_type = (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_PROL) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL;\n\t\t\t\tif (roll_distance) {\n\t\t\t\t\ts32 max_roll = 0;\n\t\t\t\t\tu32 j;\n\t\t\t\t\tfor (j=0; j<gf_list_count(sgdesc->group_descriptions); j++) {\n\t\t\t\t\t\tGF_RollRecoveryEntry *roll_entry = (GF_RollRecoveryEntry*)gf_list_get(sgdesc->group_descriptions, j);\n\t\t\t\t\t\tif (max_roll < roll_entry->roll_distance)\n\t\t\t\t\t\t\tmax_roll = roll_entry->roll_distance;\n\t\t\t\t\t}\n\t\t\t\t\tif (*roll_distance < max_roll) *roll_distance = max_roll;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j, group_desc_index;\n\t\tGF_SampleGroupDescriptionBox *sgdesc;\n\t\tu32 first_sample_in_entry, last_sample_in_entry;\n\t\tfirst_sample_in_entry = 1;\n\t\tgroup_desc_index = 0;\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*we found our sample*/\n\t\t\tgroup_desc_index = sg->sample_entries[j].group_description_index;\n\t\t\tbreak;\n\t\t}\n\t\t/*no sampleGroup info associated*/\n\t\tif (!group_desc_index) continue;\n\n\t\tsgdesc = NULL;\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sg->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t\t/*no sampleGroup description found for this group (invalid file)*/\n\t\tif (!sgdesc) continue;\n\n\t\tswitch (sgdesc->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tif (is_rap) *is_rap = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\tif (roll_type)\n\t\t\t\t*roll_type = (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_PROL) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL;\n\n\t\t\tif (roll_distance) {\n\t\t\t\tGF_RollRecoveryEntry *roll_entry = (GF_RollRecoveryEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);\n\t\t\t\tif (roll_entry)\n\t\t\t\t\t*roll_distance = roll_entry->roll_distance;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_to_group_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 grouping_type, u32 grouping_type_param, u32 *sampleGroupDescIndex)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\tif (!grouping_type || !sampleGroupDescIndex) return GF_BAD_PARAM;\n\n\t*sampleGroupDescIndex = 0;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sample_number <= trak->sample_count_at_seg_start) return GF_BAD_PARAM;\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j;\n\t\tu32 first_sample_in_entry, last_sample_in_entry;\n\t\tfirst_sample_in_entry = 1;\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\tif (sg->grouping_type != grouping_type) continue;\n\t\tif (sg->grouping_type_parameter != grouping_type_param) continue;\n\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*we found our sample*/\n\t\t\t*sampleGroupDescIndex = sg->sample_entries[j].group_description_index;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_enum_sample_group(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 *sgrp_idx, u32 *sgrp_type, u32 *sgrp_parameter, const u8 **sgrp_data, u32 *sgrp_size)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\tif (!sgrp_idx || !sgrp_type) return GF_BAD_PARAM;\n\tif (sgrp_parameter) *sgrp_parameter = 0;\n\tif (sgrp_data) *sgrp_data = NULL;\n\tif (sgrp_size) *sgrp_size = 0;\n\t*sgrp_type = 0;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sample_number <= trak->sample_count_at_seg_start) return GF_BAD_PARAM;\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j;\n\t\tGF_SampleGroupDescriptionBox *sgd = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\n\t\tswitch (sgd->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (*sgrp_idx>i) continue;\n\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroups); j++) {\n\t\t\tsg = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, j);\n\t\t\tif (sg->grouping_type == sgd->grouping_type) break;\n\t\t\tsg = NULL;\n\t\t}\n\t\tu32 sgd_index = sgd->default_description_index;\n\t\tif (sg) {\n\t\t\tu32 snum=0;\n\t\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\t\tif (snum + sg->sample_entries[j].sample_count>= sample_number) {\n\t\t\t\t\tsgd_index = sg->sample_entries[j].group_description_index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsnum += sg->sample_entries[j].sample_count;\n\t\t\t}\n\t\t}\n\n\t\t*sgrp_type = sgd->grouping_type;\n\t\tif (sgrp_parameter && sg) *sgrp_parameter = sg->grouping_type_parameter;\n\n\t\tif (sgd_index) {\n\t\t\tGF_DefaultSampleGroupDescriptionEntry *entry = gf_list_get(sgd->group_descriptions, sgd_index-1);\n\t\t\tif (entry) {\n\t\t\t\tif (sgrp_data) *sgrp_data = entry->data;\n\t\t\t\tif (sgrp_size) *sgrp_size = entry->length;\n\t\t\t}\n\t\t}\n\n\t\t(*sgrp_idx)++;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_DefaultSampleGroupDescriptionEntry * gf_isom_get_sample_group_info_entry(GF_ISOFile *the_file, GF_TrackBox *trak, u32 grouping_type, u32 sample_group_description_index, u32 *default_index, GF_SampleGroupDescriptionBox **out_sgdp)\n{\n\tu32 i, count;\n\n\tif (!trak || !sample_group_description_index) return NULL;\n\tif (!trak->Media->information->sampleTable->sampleGroupsDescription) return NULL;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type != grouping_type) continue;\n\n\t\tif (sgdesc->default_description_index && !sample_group_description_index) sample_group_description_index = sgdesc->default_description_index;\n\n\t\tif (default_index) *default_index = sgdesc->default_description_index ;\n\t\tif (out_sgdp) *out_sgdp = sgdesc;\n\n\t\tif (!sample_group_description_index) return NULL;\n\t\treturn (GF_DefaultSampleGroupDescriptionEntry*)gf_list_get(sgdesc->group_descriptions, sample_group_description_index-1);\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nBool gf_isom_get_sample_group_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_description_index, u32 grouping_type, u32 *default_index, const u8 **data, u32 *size)\n{\n\tGF_DefaultSampleGroupDescriptionEntry *sg_entry;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\n\tif (default_index) *default_index = 0;\n\tif (size) *size = 0;\n\tif (data) *data = NULL;\n\n\tsg_entry = gf_isom_get_sample_group_info_entry(the_file, trak, grouping_type, sample_description_index, default_index, NULL);\n\tif (!sg_entry) return GF_FALSE;\n\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tif (sg_entry && data) *data = (char *) sg_entry->data;\n\t\tif (sg_entry && size) *size = sg_entry->length;\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n//return the duration of the movie+fragments if known, 0 if error\nGF_EXPORT\nu64 gf_isom_get_fragmented_duration(GF_ISOFile *movie)\n{\n\tif (movie->moov->mvex && movie->moov->mvex->mehd)\n\t\treturn movie->moov->mvex->mehd->fragment_duration;\n\n\treturn 0;\n}\n//return the duration of the movie+fragments if known, 0 if error\nGF_EXPORT\nu32 gf_isom_get_fragments_count(GF_ISOFile *movie, Bool segments_only)\n{\n\tu32 i=0;\n\tu32 nb_frags = 0;\n\tGF_Box *b;\n\twhile ((b=(GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tif (segments_only) {\n\t\t\tif (b->type==GF_ISOM_BOX_TYPE_SIDX)\n\t\t\t\tnb_frags++;\n\t\t} else {\n\t\t\tif (b->type==GF_ISOM_BOX_TYPE_MOOF)\n\t\t\t\tnb_frags++;\n\t\t}\n\t}\n\treturn nb_frags;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_fragmented_samples_info(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 *nb_samples, u64 *duration)\n{\n\tu32 i=0;\n\tu32 k, l;\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\n\t*nb_samples = 0;\n\t*duration = 0;\n\twhile ((moof=(GF_MovieFragmentBox*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tu32 j=0;\n\t\tif (moof->type!=GF_ISOM_BOX_TYPE_MOOF) continue;\n\n\t\twhile ((traf=(GF_TrackFragmentBox*)gf_list_enum( moof->TrackList, &j))) {\n\t\t\tu64 def_duration, samp_dur=0;\n\n\t\t\tif (traf->tfhd->trackID != trackID)\n\t\t\t\tcontinue;\n\n\t\t\tdef_duration = 0;\n\t\t\tif (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) def_duration = traf->tfhd->def_sample_duration;\n\t\t\telse if (traf->trex) def_duration = traf->trex->def_sample_duration;\n\n\t\t\tfor (k=0; k<gf_list_count(traf->TrackRuns); k++) {\n\t\t\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, k);\n\t\t\t\t*nb_samples += trun->sample_count;\n\n\t\t\t\tfor (l=0; l<trun->nb_samples; l++) {\n\t\t\t\t\tGF_TrunEntry *ent = &trun->samples[l];\n\n\t\t\t\t\tsamp_dur = def_duration;\n\t\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) samp_dur = ent->Duration;\n\t\t\t\t\tif (trun->nb_samples == trun->sample_count)\n\t\t\t\t\t\t*duration += samp_dur;\n\t\t\t\t}\n\t\t\t\tif (trun->nb_samples != trun->sample_count)\n\t\t\t\t\t*duration += samp_dur * trun->sample_count;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_nalu_extract_mode(GF_ISOFile *the_file, u32 trackNumber, GF_ISONaluExtractMode nalu_extract_mode)\n{\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->extractor_mode = nalu_extract_mode;\n\n\tif (!trak->References) return GF_OK;\n\n\t/*get base*/\n\tdpnd = NULL;\n\ttrak->has_base_layer = GF_FALSE;\n\tTrack_FindRef(trak, GF_ISOM_REF_SCAL, &dpnd);\n\tif (dpnd) trak->has_base_layer = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_ISONaluExtractMode gf_isom_get_nalu_extract_mode(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->extractor_mode;\n}\n\nGF_EXPORT\ns32 gf_isom_get_composition_offset_shift(GF_ISOFile *file, u32 track)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return 0;\n\tif (!trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->CompositionToDecode) return 0;\n\treturn trak->Media->information->sampleTable->CompositionToDecode->compositionToDTSShift;\n}\n\nGF_EXPORT\nBool gf_isom_needs_layer_reconstruction(GF_ISOFile *file)\n{\n\tu32 count, i;\n\tif (!file)\n\t\treturn GF_FALSE;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i = 0; i < count; i++) {\n\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_SCAL) > 0) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_SABT) > 0) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tswitch (gf_isom_get_media_subtype(file, i+1, 1)) {\n\t\tcase GF_ISOM_SUBTYPE_LHV1:\n\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_BASE) > 0) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nvoid gf_isom_keep_utc_times(GF_ISOFile *file, Bool keep_utc)\n{\n\tif (!file) return;\n\tfile->keep_utc = keep_utc;\n}\n\nGF_EXPORT\nBool gf_isom_has_keep_utc_times(GF_ISOFile *file)\n{\n\tif (!file) return GF_FALSE;\n\treturn file->keep_utc;\n}\n\n\n\nGF_EXPORT\nu32 gf_isom_get_pssh_count(GF_ISOFile *file)\n{\n\tu32 count=0;\n\tu32 i=0;\n\tGF_Box *a_box;\n\tif (file->moov) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (file->meta) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->meta->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n#if 0 //unused\n/*! gets serialized PSS\n\\param isom_file the target ISO file\n\\param pssh_index 1-based index of PSSH to query, see \\ref gf_isom_get_pssh_count\n\\param pssh_data set to a newly allocated buffer containing serialized PSSH - shall be freeed by caller\n\\param pssh_size set to the size of the allocated buffer\n\\return error if any\n*/\nGF_Err gf_isom_get_pssh(GF_ISOFile *file, u32 pssh_index, u8 **pssh_data, u32 *pssh_size)\n{\n\tGF_Err e;\n\tu32 i=0;\n\tGF_BitStream *bs;\n\tu32 count=1;\n\tGF_Box *pssh;\n\twhile ((pssh = (GF_Box *)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\tif (count == pssh_index) break;\n\t\tcount++;\n\t}\n\tif (!pssh) return GF_BAD_PARAM;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_write(pssh, bs);\n\tif (!e) {\n\t\tgf_bs_get_content(bs, pssh_data, pssh_size);\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_get_pssh_info(GF_ISOFile *file, u32 pssh_index, bin128 SystemID, u32 *version, u32 *KID_count, const bin128 **KIDs, const u8 **private_data, u32 *private_data_size)\n{\n\tu32 count=1;\n\tu32 i=0;\n\tGF_ProtectionSystemHeaderBox *pssh=NULL;\n\tif (file->moov) {\n\t\twhile ((pssh = (GF_ProtectionSystemHeaderBox *)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tif (count == pssh_index) break;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!pssh && file->meta) {\n\t\twhile ((pssh = (GF_ProtectionSystemHeaderBox *)gf_list_enum(file->meta->child_boxes, &i))) {\n\t\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tif (count == pssh_index) break;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!pssh) return GF_BAD_PARAM;\n\n\tif (SystemID) memcpy(SystemID, pssh->SystemID, 16);\n\tif (version) *version = pssh->version;\n\tif (KID_count) *KID_count = pssh->KID_count;\n\tif (KIDs) *KIDs = (const bin128 *) pssh->KIDs;\n\tif (private_data_size) *private_data_size = pssh->private_data_size;\n\tif (private_data) *private_data = pssh->private_data;\n\treturn GF_OK;\n}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#else\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#endif\n{\n\tGF_SampleGroupBox *sample_group;\n\tu32 j, group_desc_index;\n\tGF_SampleGroupDescriptionBox *sgdesc;\n\tu32 i, count;\n\tu32 descIndex, chunkNum;\n\tu64 offset;\n\tu32 first_sample_in_entry, last_sample_in_entry;\n\tGF_CENCSampleEncryptionGroupEntry *entry;\n\n\tif (IsEncrypted) *IsEncrypted = GF_FALSE;\n\tif (crypt_byte_block) *crypt_byte_block = 0;\n\tif (skip_byte_block) *skip_byte_block = 0;\n\tif (key_info) *key_info = NULL;\n\tif (key_info_size) *key_info_size = 0;\n\n\tif (!trak) return GF_BAD_PARAM;\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf)\n\t\treturn GF_NOT_SUPPORTED;\n#else\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\n\tif (trak->Media->information->sampleTable->SampleSize && trak->Media->information->sampleTable->SampleSize->sampleCount>=sample_number) {\n\t\tstbl_GetSampleInfos(trak->Media->information->sampleTable, sample_number, &offset, &chunkNum, &descIndex, NULL);\n\t} else {\n\t\t//this is dump mode of fragments, we haven't merged tables yet - use current stsd idx indicated in trak\n\t\tdescIndex = trak->current_traf_stsd_idx;\n\t\tif (!descIndex) descIndex = 1;\n\t}\n\n\tgf_isom_cenc_get_default_info_internal(trak, descIndex, NULL, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n\n\tsample_group = NULL;\n\tgroup_desc_index = 0;\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!group_desc_index && traf && traf->sampleGroups) {\n\t\tcount = gf_list_count(traf->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tgroup_desc_index = 0;\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(traf->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup info associated*/\n\tif (!group_desc_index) goto exit;\n\n\tsgdesc = NULL;\n\n\tif (group_desc_index<=0x10000) {\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\telse if (traf) {\n\t\tgroup_desc_index -= 0x10000;\n\t\tfor (j=0; j<gf_list_count(traf->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(traf->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup description found for this group (invalid file)*/\n\tif (!sgdesc) return GF_ISOM_INVALID_FILE;\n\n\tentry = (GF_CENCSampleEncryptionGroupEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\n\tif (IsEncrypted) *IsEncrypted = entry->IsProtected;\n\tif (crypt_byte_block) *crypt_byte_block = entry->crypt_byte_block;\n\tif (skip_byte_block) *skip_byte_block = entry->skip_byte_block;\n\n\tif (key_info) *key_info = entry->key_info;\n\tif (key_info_size) *key_info_size = entry->key_info_size;\n\nexit:\n\t//in PIFF we may have default values if no TENC is present: 8 bytes for IV size\n\tif (( (senc && senc->piff_type==1) || (trak->moov && trak->moov->mov->is_smooth) ) && key_info && ! (*key_info) ) {\n\t\tif (!senc) {\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = 8;\n\t\t} else {\n\t\t\tif (!senc->piff_type) {\n\t\t\t\tsenc->piff_type = 2;\n\t\t\t\tsenc->IV_size = 8;\n\t\t\t}\n\t\t\tassert(senc->IV_size);\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = senc->IV_size;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_cenc_info(GF_ISOFile *movie, u32 track, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tGF_SampleEncryptionBox *senc = trak->sample_encryption;\n\n\treturn gf_isom_get_sample_cenc_info_internal(trak, NULL, senc, sample_number, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n}\n\n\nGF_EXPORT\nBool gf_isom_get_last_producer_time_box(GF_ISOFile *file, GF_ISOTrackID *refTrackID, u64 *ntp, u64 *timestamp, Bool reset_info)\n{\n\tif (!file) return GF_FALSE;\n\tif (refTrackID) *refTrackID = 0;\n\tif (ntp) *ntp = 0;\n\tif (timestamp) *timestamp = 0;\n\n\tif (file->last_producer_ref_time) {\n\t\tif (refTrackID) *refTrackID = file->last_producer_ref_time->refTrackID;\n\t\tif (ntp) *ntp = file->last_producer_ref_time->ntp;\n\t\tif (timestamp) *timestamp = file->last_producer_ref_time->timestamp;\n\n\t\tif (reset_info) {\n\t\t\tfile->last_producer_ref_time = NULL;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu64 gf_isom_get_current_tfdt(GF_ISOFile *the_file, u32 trackNumber)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->dts_at_seg_start;\n#endif\n}\n\nGF_EXPORT\nu64 gf_isom_get_smooth_next_tfdt(GF_ISOFile *the_file, u32 trackNumber)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->dts_at_next_frag_start;\n#endif\n}\n\nGF_EXPORT\nBool gf_isom_is_smooth_streaming_moov(GF_ISOFile *the_file)\n{\n\treturn the_file ? the_file->is_smooth : GF_FALSE;\n}\n\n\nvoid gf_isom_parse_trif_info(const u8 *data, u32 size, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h)\n{\n\tGF_BitStream *bs;\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t*id = gf_bs_read_u16(bs);\n\tif (! gf_bs_read_int(bs, 1)) {\n\t\t*independent=0;\n\t\t*full_picture=0;\n\t\t*x = *y = *w = *h = 0;\n\t} else {\n\t\t*independent = gf_bs_read_int(bs, 2);\n\t\t*full_picture = (Bool)gf_bs_read_int(bs, 1);\n\t\t/*filter_disabled*/ gf_bs_read_int(bs, 1);\n\t\t/*has_dependency_list*/ gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 2);\n\t\t*x = *full_picture ? 0 : gf_bs_read_u16(bs);\n\t\t*y = *full_picture ? 0 : gf_bs_read_u16(bs);\n\t\t*w = gf_bs_read_u16(bs);\n\t\t*h = gf_bs_read_u16(bs);\n\t}\n\tgf_bs_del(bs);\n}\n\nGF_EXPORT\nBool gf_isom_get_tile_info(GF_ISOFile *file, u32 trackNumber, u32 sample_description_index, u32 *default_sample_group_index, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h)\n{\n\tconst u8 *data;\n\tu32 size;\n\n\tif (!gf_isom_get_sample_group_info(file, trackNumber, sample_description_index, GF_ISOM_SAMPLE_GROUP_TRIF, default_sample_group_index, &data, &size))\n\t\treturn GF_FALSE;\n\tgf_isom_parse_trif_info(data, size, id, independent, full_picture, x, y, w, h);\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_isom_get_oinf_info(GF_ISOFile *file, u32 trackNumber, GF_OperatingPointsInformation **ptr)\n{\n\tu32 oref_track, def_index=0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, trackNumber);\n\n\tif (!ptr) return GF_FALSE;\n\n\toref_track=0;\n\tgf_isom_get_reference(file, trackNumber, GF_ISOM_REF_OREF, 1, &oref_track);\n\tif (oref_track) {\n\t\ttrak = gf_isom_get_track_from_file(file, oref_track);\n\t\tif (!trak) return GF_FALSE;\n\t}\n\n\t*ptr = (GF_OperatingPointsInformation *) gf_isom_get_sample_group_info_entry(file, trak, GF_ISOM_SAMPLE_GROUP_OINF, 1, &def_index, NULL);\n\n\treturn *ptr ? GF_TRUE : GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_byte_offset(GF_ISOFile *file, s64 byte_offset)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->read_byte_offset = byte_offset;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) return ve->avc_config->config->nal_unit_size;\n\tif (ve->svc_config) return ve->svc_config->config->nal_unit_size;\n\tif (ve->hevc_config) return ve->hevc_config->config->nal_unit_size;\n\tif (ve->lhvc_config) return ve->lhvc_config->config->nal_unit_size;\n\tif (ve->vvc_config) return ve->vvc_config->config->nal_unit_size;\n\treturn 0;\n}\n\nGF_EXPORT\nBool gf_isom_is_video_handler_type(u32 mtype)\n{\n\tswitch (mtype) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n\tcase GF_ISOM_MEDIA_AUXV:\n\tcase GF_ISOM_MEDIA_PICT:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_bitrate(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 *average_bitrate, u32 *max_bitrate, u32 *decode_buffer_size)\n{\n\tGF_BitRateBox *a;\n\tu32 i, count, mrate, arate, dbsize, type;\n\tGF_SampleEntryBox *ent;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_TrackBox *trak;\n\tGF_ESDBox *esd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tmrate = arate = dbsize = 0;\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tif ((sampleDescIndex>0) && (i+1 != sampleDescIndex)) continue;\n\n\t\tent = (GF_SampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!ent) return GF_BAD_PARAM;\n\t\ta = gf_isom_sample_entry_get_bitrate(ent, GF_FALSE);\n\t\tif (a) {\n\t\t\tif (mrate<a->maxBitrate) mrate = a->maxBitrate;\n\t\t\tif (arate<a->avgBitrate) arate = a->avgBitrate;\n\t\t\tif (dbsize<a->bufferSizeDB) dbsize = a->bufferSizeDB;\n\t\t\tcontinue;\n\t\t}\n\t\ttype = ent->type;\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t\t\tbreak;\n\t\t}\n\t\tesd = NULL;\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\t\tesd = ((GF_MPEGVisualSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\t\tesd = ((GF_MPEGAudioSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\t\tesd = ((GF_MPEGSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\t}\n\t\tif (esd && esd->desc && esd->desc->decoderConfig) {\n\t\t\tif (mrate<esd->desc->decoderConfig->maxBitrate) mrate = esd->desc->decoderConfig->maxBitrate;\n\t\t\tif (arate<esd->desc->decoderConfig->avgBitrate) arate = esd->desc->decoderConfig->avgBitrate;\n\t\t\tif (dbsize<esd->desc->decoderConfig->bufferSizeDB) dbsize = esd->desc->decoderConfig->bufferSizeDB;\n\t\t}\n\t}\n\tif (average_bitrate) *average_bitrate = arate;\n\tif (max_bitrate) *max_bitrate = mrate;\n\tif (decode_buffer_size) *decode_buffer_size = dbsize;\n\treturn GF_OK;\n}\n\nvoid gf_isom_enable_traf_map_templates(GF_ISOFile *movie)\n{\n\tif (movie)\n\t\tmovie->signal_frag_bounds=GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_isom_sample_is_fragment_start(GF_ISOFile *movie, u32 trackNumber, u32 sampleNum, GF_ISOFragmentBoundaryInfo *frag_info)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\tGF_TrafToSampleMap *tmap;\n\n\tif (frag_info) memset(frag_info, 0, sizeof(GF_ISOFragmentBoundaryInfo));\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->traf_map) return GF_FALSE;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNum<=trak->sample_count_at_seg_start)\n\t\treturn GF_FALSE;\n\tsampleNum -= trak->sample_count_at_seg_start;\n#endif\n\n\ttmap = trak->Media->information->sampleTable->traf_map;\n\tif (!tmap) return GF_FALSE;\n\tfor (i=0; i<tmap->nb_entries; i++) {\n\t\tGF_TrafMapEntry *finfo = &tmap->frag_starts[i];\n\t\tif (finfo->sample_num == sampleNum) {\n\t\t\tif (frag_info) {\n\t\t\t\tfrag_info->frag_start = finfo->moof_start;\n\t\t\t\tfrag_info->mdat_end = finfo->mdat_end;\n\t\t\t\tfrag_info->moof_template = finfo->moof_template;\n\t\t\t\tfrag_info->moof_template_size = finfo->moof_template_size;\n\t\t\t\tfrag_info->seg_start_plus_one = finfo->seg_start_plus_one;\n\t\t\t\tfrag_info->sidx_start = finfo->sidx_start;\n\t\t\t\tfrag_info->sidx_end = finfo->sidx_end;\n\t\t\t}\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (tmap->frag_starts[i].sample_num > sampleNum) return GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_isom_get_root_sidx_offsets(GF_ISOFile *movie, u64 *start, u64 *end)\n{\n\tif (!movie || !start || !end) return GF_FALSE;\n\t*start = movie->root_sidx_start_offset;\n\t*end = movie->root_sidx_end_offset;\n\treturn GF_TRUE;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_get_jp2_config(GF_ISOFile *movie, u32 trackNumber, u32 sampleDesc, u8 **out_dsi, u32 *out_size)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_BitStream *bs;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription) return GF_ISOM_INVALID_FILE;\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDesc-1);\n\tif (!entry || !entry->jp2h) return GF_BAD_PARAM;\n\tif (!entry->jp2h->ihdr) return GF_ISOM_INVALID_FILE;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_array_write((GF_Box*)entry->jp2h, entry->jp2h->child_boxes, bs);\n\tgf_bs_get_content(bs, out_dsi, out_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\nBool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type)\n{\n\tBool res = GF_FALSE;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_BitStream *bs1, *bs2;\n\tu8 *buf1, *buf2;\n\tu32 len1, len2;\n\n\tif (!ptr1 || !ptr2)\n\t\treturn GF_FALSE;\n\n\tbs1 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr1, bs1);\n\t} else {\n\t\tgf_isom_box_size((GF_Box *)ptr1);\n\t\tgf_isom_box_write((GF_Box *)ptr1, bs1);\n\t}\n\tgf_bs_get_content(bs1, &buf1, &len1);\n\tgf_bs_del(bs1);\n\n\tbs2 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr2, bs2);\n\t} else {\n\t\tgf_isom_box_write((GF_Box *)ptr2, bs2);\n\t}\n\tgf_bs_get_content(bs2, &buf2, &len2);\n\tgf_bs_del(bs2);\n\n\n\tif ((len1==len2) && !memcmp(buf1, buf2, len1))\n\t\tres = GF_TRUE;\n\n\tgf_free(buf1);\n\tgf_free(buf2);\n#endif\n\treturn res;\n}\n\nGF_EXPORT\nu64 gf_isom_get_track_magic(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->magic;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_file_offset_for_time(GF_ISOFile *movie, Double start_time, u64 *max_offset)\n{\n\tu32 i;\n\tu64 start_ts, cur_start_time;\n\tu64 offset=0;\n\tif (!movie || !movie->moov)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\tstart_ts = (u64) (start_time * movie->main_sidx->timescale);\n\tcur_start_time = 0;\n\toffset = movie->main_sidx->first_offset + movie->main_sidx_end_pos;\n\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tif (cur_start_time >= start_ts) {\n\t\t\t*max_offset = offset;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tcur_start_time += movie->main_sidx->refs[i].subsegment_duration;\n\t\toffset += movie->main_sidx->refs[i].reference_size;\n\t}\n\n\treturn GF_EOS;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sidx_duration(GF_ISOFile *movie, u64 *sidx_dur, u32 *sidx_timescale)\n{\n\tu64 dur=0;\n\tu32 i;\n\tif (!movie || !movie->moov || !sidx_timescale || !sidx_dur)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\t*sidx_timescale = movie->main_sidx->timescale;\n\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tdur += movie->main_sidx->refs[i].subsegment_duration;\n\t}\n\t*sidx_dur = dur;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u8 *gf_isom_get_mpegh_compatible_profiles(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 *nb_compat_profiles)\n{\n\tGF_SampleEntryBox *ent;\n\tGF_MHACompatibleProfilesBox *mhap;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !nb_compat_profiles) return NULL;\n\t*nb_compat_profiles = 0;\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescIndex-1);\n\tif (!ent) return NULL;\n\tmhap = (GF_MHACompatibleProfilesBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_MHAP);\n\tif (!mhap) return NULL;\n\t*nb_compat_profiles = mhap->num_profiles;\n\treturn mhap->compat_profiles;\n}\n\nconst void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn NULL;\n#else\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\n\treturn trak->tfrf;\n#endif\n}\n\nGF_Err gf_isom_get_y3d_info(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info)\n{\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\tBool found = GF_FALSE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !info) return GF_BAD_PARAM;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tmemset(info, 0, sizeof(GF_ISOM_Y3D_Info));\n\n\tGF_Stereo3DBox *st3d = (GF_Stereo3DBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (st3d) {\n\t\tfound = GF_TRUE;\n\t\tinfo->stereo_type = st3d->stereo_type;\n\t}\n\n\tGF_Box *sv3d = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (!sv3d) {\n\t\treturn found ? GF_OK : GF_NOT_FOUND;\n\t}\n\tGF_SphericalVideoInfoBox *svhd = (GF_SphericalVideoInfoBox *) gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\tif (svhd && strlen(svhd->string)) info->meta_data = svhd->string;\n\n\tGF_Box *proj = gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\tif (!proj)\n\t\treturn found ? GF_OK : GF_NOT_FOUND;\n\n\tGF_ProjectionHeaderBox *projh = (GF_ProjectionHeaderBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\tif (projh) {\n\t\tinfo->yaw = projh->yaw;\n\t\tinfo->pitch = projh->pitch;\n\t\tinfo->roll = projh->roll;\n\t\tinfo->pose_present = GF_TRUE;\n\t}\n\n\tGF_ProjectionTypeBox *projt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_CBMP);\n\tif (projt) {\n\t\tinfo->layout = projt->layout;\n\t\tinfo->padding = projt->padding;\n\t\tinfo->projection_type = 1;\n\t} else {\n\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (projt) {\n\t\t\tinfo->top = projt->bounds_top;\n\t\t\tinfo->bottom = projt->bounds_bottom;\n\t\t\tinfo->left = projt->bounds_left;\n\t\t\tinfo->right = projt->bounds_right;\n\t\t\tinfo->projection_type = 2;\n\t\t} else {\n\t\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\t\tif (projt) {\n\t\t\t\tinfo->projection_type = 3;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_chunk_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_ChunkOffsetBox *stco;\n\tGF_TrackBox *trak;\n\tif (!movie || !movie->moov || !trackNumber) return 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->ChunkOffset ) return 0;\n\n\tstco = (GF_ChunkOffsetBox *) trak->Media->information->sampleTable->ChunkOffset;\n\tif (stco->type == GF_ISOM_BOX_TYPE_STCO)\n\t\treturn stco->nb_entries;\n\tif (stco->type == GF_ISOM_BOX_TYPE_CO64)\n\t\treturn ((GF_ChunkLargeOffsetBox *) stco)->nb_entries;\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chunk_info(GF_ISOFile *movie, u32 trackNumber, u32 chunk_num, u64 *chunk_offset, u32 *first_sample_num, u32 *sample_per_chunk, u32 *sample_desc_idx, u32 *cache_1, u32 *cache_2)\n{\n\tGF_ChunkOffsetBox *stco = NULL;\n\tGF_ChunkLargeOffsetBox *co64 = NULL;\n\tGF_SampleToChunkBox *stsc = NULL;\n\tGF_TrackBox *trak;\n\tu32 i, nb_entries, nb_samples, sample_desc_index;\n\tif (!movie || !movie->moov || !trackNumber || !chunk_num) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->ChunkOffset ) return GF_BAD_PARAM;\n\n\tstsc = (GF_SampleToChunkBox *) trak->Media->information->sampleTable->SampleToChunk;\n\tstco = (GF_ChunkOffsetBox *) trak->Media->information->sampleTable->ChunkOffset;\n\tif (stco->type == GF_ISOM_BOX_TYPE_CO64) {\n\t\tstco = NULL;\n\t\tco64 = (GF_ChunkLargeOffsetBox *) trak->Media->information->sampleTable->ChunkOffset;\n\t\tnb_entries = co64->nb_entries;\n\t} else {\n\t\tnb_entries = stco->nb_entries;\n\t}\n\tif (chunk_num>nb_entries) return GF_BAD_PARAM;\n\n\tsample_desc_index = 0;\n\tnb_samples = 1;\n\ti=0;\n\n\tif (cache_1 && cache_2) {\n\t\tif (chunk_num==1) {\n\t\t\t*cache_1 = 0;\n\t\t\t*cache_2 = 1;\n\t\t}\n\t\ti = *cache_1;\n\t\tnb_samples = *cache_2;\n\t}\n\n\tfor (; i<stsc->nb_entries; i++) {\n\t\tu32 nb_chunks_before;\n\n\t\tif (stsc->entries[i].firstChunk == chunk_num) {\n\t\t\tsample_desc_index = stsc->entries[i].sampleDescriptionIndex;\n\t\t\tif (sample_per_chunk)\n\t\t\t\t*sample_per_chunk = stsc->entries[i].samplesPerChunk;\n\t\t\tbreak;\n\t\t}\n\t\tassert(stsc->entries[i].firstChunk<chunk_num);\n\n\t\tif ((i+1 == stsc->nb_entries)\n\t\t\t|| (stsc->entries[i+1].firstChunk>chunk_num)\n\t\t) {\n\t\t\tnb_chunks_before = chunk_num - stsc->entries[i].firstChunk;\n\t\t\tnb_samples += stsc->entries[i].samplesPerChunk * nb_chunks_before;\n\t\t\tsample_desc_index = stsc->entries[i].sampleDescriptionIndex;\n\t\t\tif (sample_per_chunk)\n\t\t\t\t*sample_per_chunk = stsc->entries[i].samplesPerChunk;\n\t\t\tbreak;\n\t\t}\n\t\tassert(stsc->entries[i+1].firstChunk > stsc->entries[i].firstChunk);\n\n\t\tnb_chunks_before = stsc->entries[i+1].firstChunk - stsc->entries[i].firstChunk;\n\t\tnb_samples += stsc->entries[i].samplesPerChunk * nb_chunks_before;\n\n\t\tif (cache_1 && cache_2) {\n\t\t\t*cache_1 = i+1;\n\t\t\t*cache_2 = nb_samples;\n\t\t}\n\t}\n\n\tif (first_sample_num) *first_sample_num = nb_samples;\n\tif (sample_desc_idx) *sample_desc_idx = sample_desc_index;\n\tif (chunk_offset) {\n\t\tif (stco)\n\t\t\t*chunk_offset = stco->offsets[chunk_num-1];\n\t\telse\n\t\t\t*chunk_offset = co64->offsets[chunk_num-1];\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_clean_aperture(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *cleanApertureWidthN, u32 *cleanApertureWidthD, u32 *cleanApertureHeightN, u32 *cleanApertureHeightD, s32 *horizOffN, u32 *horizOffD, s32 *vertOffN, u32 *vertOffD)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_CleanApertureBox *clap = (GF_CleanApertureBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\n\tif (cleanApertureWidthN) *cleanApertureWidthN = clap ? clap->cleanApertureWidthN : 0;\n\tif (cleanApertureWidthD) *cleanApertureWidthD = clap ? clap->cleanApertureWidthD : 0;\n\tif (cleanApertureHeightN) *cleanApertureHeightN = clap ? clap->cleanApertureHeightN : 0;\n\tif (cleanApertureHeightD) *cleanApertureHeightD = clap ? clap->cleanApertureHeightD : 0;\n\tif (horizOffN) *horizOffN = clap ? clap->horizOffN : 0;\n\tif (horizOffD) *horizOffD = clap ? clap->horizOffD : 0;\n\tif (vertOffN) *vertOffN = clap ? clap->vertOffN : 0;\n\tif (vertOffD) *vertOffD = clap ? clap->vertOffD : 0;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_track_group(GF_ISOFile *file, u32 track_number, u32 track_group_type)\n{\n\tu32 i;\n\tGF_TrackGroupTypeBox *trgt;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(file, track_number);\n\tif (!trak) return 0;\n\tif (!trak->groups) return 0;\n\n\tfor (i=0; i<gf_list_count(trak->groups->groups); i++) {\n\t\ttrgt = gf_list_get(trak->groups->groups, i);\n\t\tif (trgt->group_type == track_group_type) {\n\t\t\treturn trgt->track_group_id;\n\t\t}\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nconst GF_MasteringDisplayColourVolumeInfo *gf_isom_get_mastering_display_colour_info(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return NULL;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn NULL;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (entry == NULL) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\n\tGF_MasteringDisplayColourVolumeBox *mdcvb = (GF_MasteringDisplayColourVolumeBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\tif (!mdcvb) return NULL;\n\n\treturn &mdcvb->mdcv;\n}\n\nGF_EXPORT\nconst GF_ContentLightLevelInfo *gf_isom_get_content_light_level_info(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return NULL;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn NULL;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (entry == NULL) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\n\tGF_ContentLightLevelBox *cllib = (GF_ContentLightLevelBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLLI);\n\tif (!cllib) return NULL;\n\treturn &cllib->clli;\n}\n\n\nGF_Err gf_isom_enum_sample_aux_data(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 *sai_idx, u32 *sai_type, u32 *sai_parameter, u8 **sai_data, u32 *sai_size)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\tif (!sai_type || !sai_idx || !sai_data || !sai_size) return GF_BAD_PARAM;\n\tif (sai_parameter) *sai_parameter = 0;\n\t*sai_type = 0;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sai_sizes) return GF_OK;\n\tif (!trak->Media->information->sampleTable->sai_offsets) return GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sample_number <= trak->sample_count_at_seg_start) return GF_BAD_PARAM;\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sai_sizes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Err e;\n\t\tGF_SampleAuxiliaryInfoSizeBox *saiz;\n\t\tGF_SampleAuxiliaryInfoOffsetBox *saio=NULL;\n\t\tu32 j;\n\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox*)gf_list_get(trak->Media->information->sampleTable->sai_sizes, i);\n\n\t\tswitch (saiz->aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (*sai_idx>i) continue;\n\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sai_offsets); j++) {\n\t\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox*)gf_list_get(trak->Media->information->sampleTable->sai_offsets, j);\n\t\t\tif ((saio->aux_info_type == saiz->aux_info_type) && (saio->aux_info_type_parameter == saiz->aux_info_type_parameter)) break;\n\t\t\tsaio = NULL;\n\t\t}\n\t\tif (!saio) continue;\n\t\tif (!saio->offsets && !saio->sai_data) continue;\n\n\t\tu64 offset = saio->offsets ? saio->offsets[0] : 0;\n\t\tu32 nb_saio = saio->entry_count;\n\t\tif ((nb_saio>1) && (saio->entry_count != saiz->sample_count)) continue;\n\n\t\t*sai_type = saiz->aux_info_type;\n\t\tif (sai_parameter) *sai_parameter = saiz->aux_info_type_parameter;\n\n\t\t(*sai_idx)++;\n\n\t\tif (nb_saio == 1) {\n\t\t\tfor (j=0; j < sample_number-1; j++) {\n\t\t\t\tu32 size = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\t\t\t\toffset += size;\n\t\t\t}\n\t\t} else {\n\t\t\toffset = saio->offsets[sample_number-1];\n\t\t}\n\n\t\t*sai_size = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\t\tif (*sai_size) {\n\t\t\t*sai_data = gf_malloc( *sai_size);\n\t\t\tif (! *sai_data) return GF_OUT_OF_MEM;\n\t\t}\n\n\t\te = GF_OK;\n\t\tif (saio->sai_data) {\n\t\t\tif (offset + *sai_size <= saio->sai_data->dataSize) {\n\t\t\t\tmemcpy(*sai_data, saio->sai_data->data + offset, *sai_size);\n\t\t\t} else {\n\t\t\t\te = GF_IO_ERR;\n\t\t\t}\n\t\t} else {\n\t\t\tu64 cur_position = gf_bs_get_position(the_file->movieFileMap->bs);\n\t\t\tgf_bs_seek(the_file->movieFileMap->bs, offset);\n\n\t\t\tu32 nb_read = gf_bs_read_data(the_file->movieFileMap->bs, *sai_data, *sai_size);\n\t\t\tif (nb_read != *sai_size) e = GF_IO_ERR;\n\t\t\tgf_bs_seek(the_file->movieFileMap->bs, cur_position);\n\t\t}\n\n\t\tif (e) {\n\t\t\tgf_free(*sai_data);\n\t\t\t*sai_data = NULL;\n\t\t\t*sai_size = 0;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] Failed to clone sai data: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\t\treturn e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_pop_emsg(GF_ISOFile *the_file, u8 **emsg_data, u32 *emsg_size)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Box *emsg = gf_list_pop_front(the_file->emsgs);\n\tif (!emsg) return GF_NOT_FOUND;\n\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t//write everything\n\tgf_isom_box_size(emsg);\n\tgf_isom_box_write(emsg, bs);\n\tgf_bs_get_content(bs, emsg_data, emsg_size);\n\tgf_isom_box_del(emsg);\n\treturn GF_OK;\n\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/box_code_base.c", "src/isomedia/box_funcs.c", "src/isomedia/isom_read.c"], "buggy_code_start_loc": [4432, 107, 2307], "buggy_code_end_loc": [9985, 1953, 5413], "fixing_code_start_loc": [4432, 107, 2307], "fixing_code_end_loc": [9989, 1953, 5413], "type": "CWE-787", "message": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.", "other": {"cve": {"id": "CVE-2023-0760", "sourceIdentifier": "security@huntr.dev", "published": "2023-02-09T14:15:24.597", "lastModified": "2023-05-05T19:45:48.030", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.0", "matchCriteriaId": "B4D3D58A-C3C9-4441-A84A-FB91FD19985C"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe", "source": "security@huntr.dev", "tags": ["Exploit", "Patch"]}, {"url": "https://huntr.dev/bounties/d06223df-a473-4c82-96d0-23726b844b21", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe"}}