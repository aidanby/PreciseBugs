{"buggy_code": ["/**\n * Copyright (c) 2020 Gitpod GmbH. All rights reserved.\n * Licensed under the GNU Affero General Public License (AGPL).\n * See License-AGPL.txt in the project root for license information.\n */\n\nimport { inject, injectable } from \"inversify\";\nimport { UserDB } from '@gitpod/gitpod-db/lib/user-db';\nimport * as express from 'express';\nimport { Authenticator } from \"../auth/authenticator\";\nimport { Env } from \"../env\";\nimport { WorkspaceDB } from \"@gitpod/gitpod-db/lib/workspace-db\";\nimport { log, LogContext } from '@gitpod/gitpod-protocol/lib/util/logging';\nimport { GitpodCookie } from \"../auth/gitpod-cookie\";\nimport { AuthorizationService } from \"./authorization-service\";\nimport { Permission } from \"@gitpod/gitpod-protocol/lib/permission\";\nimport { UserService } from \"./user-service\";\nimport { WorkspacePortAuthorizationService } from \"./workspace-port-auth-service\";\nimport { parseWorkspaceIdFromHostname } from \"@gitpod/gitpod-protocol/lib/util/parse-workspace-id\";\nimport { SessionHandlerProvider } from \"../session-handler\";\nimport { URL } from 'url';\nimport { saveSession, getRequestingClientInfo, destroySession } from \"../express-util\";\nimport { User } from \"@gitpod/gitpod-protocol\";\nimport { HostContextProvider } from \"../auth/host-context-provider\";\nimport { AuthFlow } from \"../auth/auth-provider\";\nimport { LoginCompletionHandler } from \"../auth/login-completion-handler\";\nimport { TosCookie } from \"./tos-cookie\";\nimport { TosFlow } from \"../terms/tos-flow\";\n\n@injectable()\nexport class UserController {\n    @inject(WorkspaceDB) protected readonly workspaceDB: WorkspaceDB;\n    @inject(UserDB) protected readonly userDb: UserDB;\n    @inject(Authenticator) protected readonly authenticator: Authenticator;\n    @inject(Env) protected readonly env: Env;\n    @inject(GitpodCookie) protected readonly gitpodCookie: GitpodCookie;\n    @inject(TosCookie) protected readonly tosCookie: TosCookie;\n    @inject(AuthorizationService) protected readonly authService: AuthorizationService;\n    @inject(UserService) protected readonly userService: UserService;\n    @inject(WorkspacePortAuthorizationService) protected readonly workspacePortAuthService: WorkspacePortAuthorizationService;\n    @inject(HostContextProvider) protected readonly hostContextProvider: HostContextProvider;\n    @inject(SessionHandlerProvider) protected readonly sessionHandlerProvider: SessionHandlerProvider;\n    @inject(LoginCompletionHandler) protected readonly loginCompletionHandler: LoginCompletionHandler;\n\n    get apiRouter(): express.Router {\n        const router = express.Router();\n\n        router.get(\"/login\", async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            // Clean up\n            this.tosCookie.unset(res);\n\n            if (req.isAuthenticated()) {\n                log.info({ sessionId: req.sessionID }, \"(Auth) User is already authenticated.\", { 'login-flow': true });\n                // redirect immediately\n                const redirectTo = this.getSafeReturnToParam(req) || this.env.hostUrl.asDashboard().toString();\n                res.redirect(redirectTo);\n                return;\n            }\n            const clientInfo = getRequestingClientInfo(req);\n            log.info({ sessionId: req.sessionID }, \"(Auth) User started the login process\", { 'login-flow': true, clientInfo });\n\n            // Try to guess auth host from request\n            await this.augmentLoginRequest(req);\n\n            // If there is no known auth host, we need to ask the user\n            const redirectToLoginPage = !req.query.host;\n            if (redirectToLoginPage) {\n                const returnTo = this.getSafeReturnToParam(req);\n                const search = returnTo ? `returnTo=${returnTo}` : '';\n                const loginPageUrl = this.env.hostUrl.asLogin().with({ search }).toString();\n                res.redirect(loginPageUrl);\n                return;\n            }\n\n            // Make sure, the session is stored before we initialize the OAuth flow\n            try {\n                await saveSession(req);\n            } catch (error) {\n                log.error(`Login failed due to session save error; redirecting to /sorry`, { req, error, clientInfo });\n                res.redirect(this.getSorryUrl(\"Login failed \ud83e\udd84 Please try again\"));\n            }\n\n            // Proceed with login\n            await this.authenticator.authenticate(req, res, next);\n        });\n        router.get(\"/authorize\", (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            if (!User.is(req.user)) {\n                res.sendStatus(401);\n                return;\n            }\n            this.authenticator.authorize(req, res, next);\n        });\n        const branding = this.env.brandingConfig;\n        router.get(\"/logout\", async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            const logContext = LogContext.from({ user: req.user, request: req });\n            const clientInfo = getRequestingClientInfo(req);\n            const logPayload = { session: req.session, clientInfo };\n\n            let redirectToUrl = this.getSafeReturnToParam(req) || branding.redirectUrlAfterLogout || this.env.hostUrl.toString();\n\n            if (req.isAuthenticated()) {\n                req.logout();\n            }\n            try {\n                if (req.session) {\n                    await destroySession(req.session);\n                }\n            } catch (error) {\n                log.warn(logContext, \"(Logout) Error on Logout.\", { error, req, ...logPayload });\n            }\n\n            // clear cookies\n            this.gitpodCookie.unsetCookie(res);\n            this.sessionHandlerProvider.clearSessionCookie(res, this.env);\n\n            // then redirect\n            log.info(logContext, \"(Logout) Redirecting...\", { redirectToUrl, ...logPayload });\n            res.redirect(redirectToUrl);\n        });\n        router.get(\"/refresh-login\", async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            if (!req.isAuthenticated() || !User.is(req.user)) {\n                res.sendStatus(401);\n                return;\n            }\n\n            // Clean up\n            this.tosCookie.unset(res);\n\n            // This endpoint is necessary as calls over ws (our way of communicating with /api) do not update the browsers cookie\n            req.session!.touch(console.error);  // Update session explicitly, just to be sure\n            // Update `gitpod-user=loggedIn` as well\n            this.gitpodCookie.setCookie(res);\n            res.sendStatus(200);                // Carries up-to-date cookie in 'Set-Cookie' header\n        });\n        router.get(\"/auth/workspace-cookie/:instanceID\", async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            if (!req.isAuthenticated() || !User.is(req.user)) {\n                res.sendStatus(401);\n                log.warn(\"unauthenticated workspace cookie fetch\", { instanceId: req.params.instanceID });\n                return;\n            }\n\n            const user = req.user as User;\n            if (user.blocked) {\n                res.sendStatus(403);\n                log.warn(\"blocked user attempted to fetch workspace cookie\", { instanceId: req.params.instanceID, userId: user.id });\n                return;\n            }\n\n            const instanceID = req.params.instanceID;\n            if (!instanceID) {\n                res.sendStatus(400);\n                log.warn(\"attempted to fetch workspace cookie without instance ID\", { instanceId: req.params.instanceID, userId: user.id });\n                return;\n            }\n\n            const [workspace, instance] = await Promise.all([\n                this.workspaceDB.findByInstanceId(instanceID),\n                this.workspaceDB.findInstanceById(instanceID)\n            ]);\n            if (!workspace || !instance) {\n                res.sendStatus(404);\n                log.warn(\"attempted to fetch workspace cookie for non-existent workspace instance\", { instanceId: req.params.instanceID, userId: user.id });\n                return;\n            }\n            if (workspace && user.id != workspace.ownerId) {\n                // [cw] The user is not the workspace owner, which means they don't get the owner cookie.\n                // [cw] In the future, when we introduce per-user tokens we can set the user-specific token here.\n\n                if (workspace.shareable) {\n                    // workspace is shared and hence can be accessed without the cookie.\n                    res.sendStatus(200);\n                    return;\n                }\n\n                res.sendStatus(403);\n                log.warn(\"unauthorized attempted to fetch workspace cookie\", { instanceId: req.params.instanceID, userId: user.id });\n                return;\n            }\n\n\n            const token = instance.status.ownerToken;\n            if (!token) {\n                // no token, no problem. The dashboard will try again later.\n                res.sendStatus(200);\n                log.debug(\"attempted to fetch workspace cookie, but instance has no owner token\", { instanceId: req.params.instanceID, userId: user.id });\n                return;\n            }\n\n            if (res.headersSent) {\n                return;\n            }\n\n            let cookiePrefix: string = this.env.hostUrl.url.host;\n            cookiePrefix = cookiePrefix.replace(/^https?/, '');\n            [\" \", \"-\", \".\"].forEach(c => cookiePrefix = cookiePrefix.split(c).join(\"_\"));\n\n            const name = `_${cookiePrefix}_ws_${instanceID}_owner_`;\n            res.cookie(name, token, {\n                path: \"/\",\n                httpOnly: false,\n                secure: false,\n                maxAge: 1000 * 60 * 60 * 24 * 1,    // 1 day\n                sameSite: \"lax\",                    // default: true. \"Lax\" needed for cookie to work in the workspace domain.\n                domain: `.${this.env.hostUrl.url.host}`\n            });\n            res.sendStatus(200);\n        });\n        router.get(\"/auth/workspace\", async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            if (!req.isAuthenticated() || !User.is(req.user)) {\n                res.sendStatus(401);\n                return;\n            }\n\n            const user = req.user as User;\n            if (user.blocked) {\n                res.sendStatus(403);\n                return;\n            }\n\n            const workspaceId = parseWorkspaceIdFromHostname(req.hostname);\n            if (workspaceId) {\n                const workspace = await this.workspaceDB.findById(workspaceId);\n                if (workspace && user.id != workspace.ownerId && !workspace.shareable) {\n                    log.info({ userId: user.id, workspaceId }, 'User does not own private workspace. Denied');\n                    res.sendStatus(403);\n                    return;\n                }\n            }\n\n            res.sendStatus(200);\n        });\n        router.get(\"/auth/workspace-port/:port\", async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            const authenticatedUser = req.isAuthenticated() && User.is(req.user) && req.user || undefined;\n            const access = await this.workspacePortAuthService.authorizeWorkspacePortAccess(req.params.port, req.hostname, authenticatedUser, req.header(\"x-gitpod-port-auth\"));\n            res.sendStatus(access ? 200 : 403);\n        });\n        router.get(\"/auth/monitor\", async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            if (!req.isAuthenticated() || !User.is(req.user)) {\n                // Pretend there's nothing to see\n                res.sendStatus(403);\n                return;\n            }\n\n            const user = req.user as User;\n            if (this.authService.hasPermission(user, Permission.MONITOR)) {\n                res.sendStatus(200);\n                return;\n            }\n\n            res.sendStatus(403);\n        });\n        router.get(\"/tos\", async (req: express.Request, res: express.Response) => {\n            const mode = req.query[\"mode\"] as \"login\" | \"update\" | unknown;\n            const clientInfo = getRequestingClientInfo(req);\n            let tosFlowInfo = TosFlow.get(req.session);\n            const authFlow = AuthFlow.get(req.session);\n\n            const logContext = LogContext.from({ user: req.user, request: req });\n            const logPayload = { session: req.session, clientInfo, tosFlowInfo, authFlow, mode };\n\n            const redirectOnInvalidRequest = async () => {\n                // just don't forget\n                this.tosCookie.unset(res);\n                await AuthFlow.clear(req.session);\n                await TosFlow.clear(req.session);\n\n                log.info(logContext, '(TOS) Invalid request. (/tos)', logPayload);\n                res.redirect(this.getSorryUrl(\"Oops! Something went wrong. (invalid request)\"));\n            }\n\n            if (mode !== \"login\" && mode !== \"update\") {\n                await redirectOnInvalidRequest();\n                return;\n            }\n\n            if (mode === \"login\") {\n                if (!authFlow || !TosFlow.is(tosFlowInfo)) {\n                    await redirectOnInvalidRequest();\n                    return;\n                }\n\n                // in a special case of the signup process, we're redirecting to /tos even if not required.\n                if (TosFlow.WithIdentity.is(tosFlowInfo) && tosFlowInfo.termsAcceptanceRequired === false) {\n                    log.info(logContext, '(TOS) Not required.', logPayload);\n                    await this.handleTosProceedForNewUser(req, res, authFlow, tosFlowInfo);\n                    return;\n                }\n            } else { // we are in tos update process\n\n                const user = User.is(req.user) ? req.user : undefined;\n                if (!user) {\n                    await redirectOnInvalidRequest();\n                    return;\n                }\n\n                // initializing flow here!\n                tosFlowInfo = <TosFlow.WithUser>{\n                    user: User.censor(user),\n                    returnToUrl: req.query.returnTo\n                };\n                await TosFlow.attach(req.session!, tosFlowInfo);\n            }\n\n            const isUpdate = !TosFlow.WithIdentity.is(tosFlowInfo);\n            const userInfo = tosFlowUserInfo(tosFlowInfo);\n            const tosHints = {\n                isUpdate,   // indicate whether to show the \"we've updated ...\" message\n                userInfo    // let us render the avatar on the dashboard page\n            };\n            this.tosCookie.set(res, tosHints);\n\n            log.info(logContext, \"(TOS) Redirecting to /tos.\", { tosHints, ...logPayload });\n            res.redirect(this.env.hostUrl.with(() => ({ pathname: '/tos/' })).toString());\n        });\n        const tosFlowUserInfo = (tosFlowInfo: TosFlow) => {\n            if (TosFlow.WithIdentity.is(tosFlowInfo)) {\n                return {\n                    name: tosFlowInfo.authUser.name || tosFlowInfo.authUser.authName,\n                    avatarUrl: tosFlowInfo.authUser.avatarUrl\n                }\n            }\n            if (TosFlow.WithUser.is(tosFlowInfo)) {\n                return {\n                    name: tosFlowInfo.user.name,\n                    avatarUrl: tosFlowInfo.user.avatarUrl\n                }\n            }\n        }\n        router.post(\"/tos/proceed\", async (req: express.Request, res: express.Response) => {\n\n            // just don't forget\n            this.tosCookie.unset(res);\n\n            const clientInfo = getRequestingClientInfo(req);\n            const tosFlowInfo = TosFlow.get(req.session);\n            const authFlow = AuthFlow.get(req.session);\n            const isInLoginProcess = !!authFlow;\n\n            const logContext = LogContext.from({ user: req.user, request: req });\n            const logPayload = { session: req.session, clientInfo, tosFlowInfo, authFlow };\n\n            const redirectOnInvalidSession = async () => {\n                await AuthFlow.clear(req.session);\n                await TosFlow.clear(req.session);\n\n                log.info(logContext, '(TOS) Invalid session. (/tos/proceed)', logPayload);\n                res.redirect(this.getSorryUrl(\"Oops! Something went wrong. (invalid session)\"));\n            }\n\n            if (!TosFlow.is(tosFlowInfo)) {\n                await redirectOnInvalidSession();\n                return;\n            }\n\n            const agreeTOS = req.body.agreeTOS;\n            if (!agreeTOS) {\n                // The user did not accept the terms.\n                // A redirect to /logout will wipe the session, which in case of a signup will ensure\n                // that no user data remains in the system.\n                log.info(logContext, '(TOS) User did NOT agree. Redirecting to /logout.', logPayload);\n\n                res.redirect(this.env.hostUrl.withApi({ pathname: \"/logout\" }).toString());\n                // todo@alex: consider redirecting to a description pages afterwards (returnTo param)\n\n                return;\n            }\n\n            // The user has accepted the terms.\n            log.info(logContext, '(TOS) User did agree.', logPayload);\n\n            if (TosFlow.WithIdentity.is(tosFlowInfo)) {\n                if (!authFlow) {\n                    await redirectOnInvalidSession();\n                    return;\n                }\n                await this.handleTosProceedForNewUser(req, res, authFlow, tosFlowInfo, req.body);\n            } else if (TosFlow.WithUser.is(tosFlowInfo)) {\n                const { user, returnToUrl } = tosFlowInfo;\n\n                await this.userService.acceptCurrentTerms(user);\n\n                if (isInLoginProcess) {\n                    await this.loginCompletionHandler.complete(req, res, { ...tosFlowInfo });\n                } else {\n\n                    let returnTo = returnToUrl || this.env.hostUrl.asDashboard().toString();\n                    res.redirect(returnTo);\n                }\n            }\n\n        });\n\n        return router;\n    }\n\n    protected async handleTosProceedForNewUser(req: express.Request, res: express.Response, authFlow: AuthFlow, tosFlowInfo: TosFlow.WithIdentity, tosProceedParams?: any) {\n        const { candidate, token } = tosFlowInfo;\n        const { returnTo, host } = authFlow;\n        const user = await this.userService.createUser({\n            identity: candidate,\n            token,\n            userUpdate: (user) => this.updateNewUserAfterTos(user, tosFlowInfo, tosProceedParams)\n        });\n\n        const { additionalIdentity, additionalToken, envVars } = tosFlowInfo;\n        if (additionalIdentity && additionalToken) {\n            await this.userService.updateUserIdentity(user, additionalIdentity, additionalToken);\n        }\n\n        // const { isBlocked } = tosFlowInfo; // todo@alex: this setting is in conflict with the env var\n\n        await this.userService.updateUserEnvVarsOnLogin(user, envVars);\n        await this.userService.acceptCurrentTerms(user);\n        await this.loginCompletionHandler.complete(req, res, { user, returnToUrl: returnTo, authHost: host });\n    }\n\n    protected updateNewUserAfterTos(newUser: User, tosFlowInfo: TosFlow.WithIdentity, tosProceedParams?: any) {\n        const { authUser } = tosFlowInfo;\n        newUser.name = authUser.authName;\n        newUser.fullName = authUser.name || undefined;\n        newUser.avatarUrl = authUser.avatarUrl;\n    }\n\n    protected getSorryUrl(message: string) {\n        return this.env.hostUrl.asSorry(message).toString();\n    }\n\n    protected async augmentLoginRequest(req: express.Request) {\n        const returnToURL = this.getSafeReturnToParam(req);\n        if (req.query.host) {\n            // This login request points already to an auth host\n            return;\n        }\n\n        // read current auth provider configs\n        const authProviderConfigs = this.hostContextProvider.getAll().map(hc => hc.authProvider.config);\n\n        // Special Context exception\n        if (returnToURL) {\n            const authProviderForSpecialContext = authProviderConfigs.find(c => {\n                if (c.loginContextMatcher) {\n                    try {\n                        const matcher = new RegExp(c.loginContextMatcher);\n                        return matcher.test(returnToURL)\n                    } catch { /* */ }\n                }\n                return false;\n            });\n            if (authProviderForSpecialContext) {\n                // the `host` param will be used by the authenticator to delegate to the auth provider\n                req.query.host = authProviderForSpecialContext.host;\n\n                log.debug({ sessionId: req.sessionID }, `Using \"${authProviderForSpecialContext.type}\" for login ...`, { 'login-flow': true, query: req.query, authProviderForSpecialContext });\n                return;\n            }\n        }\n\n        // Use the single available auth provider\n        const authProvidersOnDashboard = authProviderConfigs.filter(c => !c.hiddenOnDashboard && !c.disallowLogin).map(a => a.host);\n        if (authProvidersOnDashboard.length === 1) {\n            req.query.host = authProvidersOnDashboard[0];\n            return;\n        }\n\n        // If the context URL contains a known auth host, just use this\n        if (returnToURL) {\n            // returnToURL \u2013> https://gitpod.io/#https://github.com/theia-ide/theia\"\n            const hash = decodeURIComponent(new URL(decodeURIComponent(returnToURL)).hash);\n            const value = hash.substr(1); // to remove the leading #\n            let contextUrlHost: string | undefined;\n            try {\n                const contextURL = new URL(value);\n                contextUrlHost = contextURL.hostname;\n            } catch {\n                // ignore parse errors\n            }\n\n            if (!!contextUrlHost && authProvidersOnDashboard.find(a => a === contextUrlHost)) {\n                req.query.host = contextUrlHost;\n                log.debug({ sessionId: req.sessionID }, \"Guessed auth provider from returnTo URL: \" + contextUrlHost, { 'login-flow': true, query: req.query });\n                return;\n            }\n        }\n    }\n\n    protected getSafeReturnToParam(req: express.Request) {\n        const returnToURL: string | undefined = req.query.redirect || req.query.returnTo;\n        if (returnToURL) {\n            const hostUrl = this.env.hostUrl.url as URL;\n            if (returnToURL.toLowerCase().startsWith(`${hostUrl.protocol}//${hostUrl.host}`.toLowerCase())) {\n                return returnToURL;\n            }\n            if (returnToURL.toLowerCase().startsWith(this.env.brandingConfig.homepage.toLowerCase())) {\n                return returnToURL;\n            }\n        }\n    }\n}\n"], "fixing_code": ["/**\n * Copyright (c) 2020 Gitpod GmbH. All rights reserved.\n * Licensed under the GNU Affero General Public License (AGPL).\n * See License-AGPL.txt in the project root for license information.\n */\n\nimport { inject, injectable } from \"inversify\";\nimport { UserDB } from '@gitpod/gitpod-db/lib/user-db';\nimport * as express from 'express';\nimport { Authenticator } from \"../auth/authenticator\";\nimport { Env } from \"../env\";\nimport { WorkspaceDB } from \"@gitpod/gitpod-db/lib/workspace-db\";\nimport { log, LogContext } from '@gitpod/gitpod-protocol/lib/util/logging';\nimport { GitpodCookie } from \"../auth/gitpod-cookie\";\nimport { AuthorizationService } from \"./authorization-service\";\nimport { Permission } from \"@gitpod/gitpod-protocol/lib/permission\";\nimport { UserService } from \"./user-service\";\nimport { WorkspacePortAuthorizationService } from \"./workspace-port-auth-service\";\nimport { parseWorkspaceIdFromHostname } from \"@gitpod/gitpod-protocol/lib/util/parse-workspace-id\";\nimport { SessionHandlerProvider } from \"../session-handler\";\nimport { URL } from 'url';\nimport { saveSession, getRequestingClientInfo, destroySession } from \"../express-util\";\nimport { User } from \"@gitpod/gitpod-protocol\";\nimport { HostContextProvider } from \"../auth/host-context-provider\";\nimport { AuthFlow } from \"../auth/auth-provider\";\nimport { LoginCompletionHandler } from \"../auth/login-completion-handler\";\nimport { TosCookie } from \"./tos-cookie\";\nimport { TosFlow } from \"../terms/tos-flow\";\n\n@injectable()\nexport class UserController {\n    @inject(WorkspaceDB) protected readonly workspaceDB: WorkspaceDB;\n    @inject(UserDB) protected readonly userDb: UserDB;\n    @inject(Authenticator) protected readonly authenticator: Authenticator;\n    @inject(Env) protected readonly env: Env;\n    @inject(GitpodCookie) protected readonly gitpodCookie: GitpodCookie;\n    @inject(TosCookie) protected readonly tosCookie: TosCookie;\n    @inject(AuthorizationService) protected readonly authService: AuthorizationService;\n    @inject(UserService) protected readonly userService: UserService;\n    @inject(WorkspacePortAuthorizationService) protected readonly workspacePortAuthService: WorkspacePortAuthorizationService;\n    @inject(HostContextProvider) protected readonly hostContextProvider: HostContextProvider;\n    @inject(SessionHandlerProvider) protected readonly sessionHandlerProvider: SessionHandlerProvider;\n    @inject(LoginCompletionHandler) protected readonly loginCompletionHandler: LoginCompletionHandler;\n\n    get apiRouter(): express.Router {\n        const router = express.Router();\n\n        router.get(\"/login\", async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            // Clean up\n            this.tosCookie.unset(res);\n\n            if (req.isAuthenticated()) {\n                log.info({ sessionId: req.sessionID }, \"(Auth) User is already authenticated.\", { 'login-flow': true });\n                // redirect immediately\n                const redirectTo = this.getSafeReturnToParam(req) || this.env.hostUrl.asDashboard().toString();\n                res.redirect(redirectTo);\n                return;\n            }\n            const clientInfo = getRequestingClientInfo(req);\n            log.info({ sessionId: req.sessionID }, \"(Auth) User started the login process\", { 'login-flow': true, clientInfo });\n\n            // Try to guess auth host from request\n            await this.augmentLoginRequest(req);\n\n            // If there is no known auth host, we need to ask the user\n            const redirectToLoginPage = !req.query.host;\n            if (redirectToLoginPage) {\n                const returnTo = this.getSafeReturnToParam(req);\n                const search = returnTo ? `returnTo=${returnTo}` : '';\n                const loginPageUrl = this.env.hostUrl.asLogin().with({ search }).toString();\n                res.redirect(loginPageUrl);\n                return;\n            }\n\n            // Make sure, the session is stored before we initialize the OAuth flow\n            try {\n                await saveSession(req);\n            } catch (error) {\n                log.error(`Login failed due to session save error; redirecting to /sorry`, { req, error, clientInfo });\n                res.redirect(this.getSorryUrl(\"Login failed \ud83e\udd84 Please try again\"));\n            }\n\n            // Proceed with login\n            this.ensureSafeReturnToParam(req);\n            await this.authenticator.authenticate(req, res, next);\n        });\n        router.get(\"/authorize\", (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            if (!User.is(req.user)) {\n                res.sendStatus(401);\n                return;\n            }\n            this.ensureSafeReturnToParam(req);\n            this.authenticator.authorize(req, res, next);\n        });\n        const branding = this.env.brandingConfig;\n        router.get(\"/logout\", async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            const logContext = LogContext.from({ user: req.user, request: req });\n            const clientInfo = getRequestingClientInfo(req);\n            const logPayload = { session: req.session, clientInfo };\n\n            let redirectToUrl = this.getSafeReturnToParam(req) || branding.redirectUrlAfterLogout || this.env.hostUrl.toString();\n\n            if (req.isAuthenticated()) {\n                req.logout();\n            }\n            try {\n                if (req.session) {\n                    await destroySession(req.session);\n                }\n            } catch (error) {\n                log.warn(logContext, \"(Logout) Error on Logout.\", { error, req, ...logPayload });\n            }\n\n            // clear cookies\n            this.gitpodCookie.unsetCookie(res);\n            this.sessionHandlerProvider.clearSessionCookie(res, this.env);\n\n            // then redirect\n            log.info(logContext, \"(Logout) Redirecting...\", { redirectToUrl, ...logPayload });\n            res.redirect(redirectToUrl);\n        });\n        router.get(\"/refresh-login\", async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            if (!req.isAuthenticated() || !User.is(req.user)) {\n                res.sendStatus(401);\n                return;\n            }\n\n            // Clean up\n            this.tosCookie.unset(res);\n\n            // This endpoint is necessary as calls over ws (our way of communicating with /api) do not update the browsers cookie\n            req.session!.touch(console.error);  // Update session explicitly, just to be sure\n            // Update `gitpod-user=loggedIn` as well\n            this.gitpodCookie.setCookie(res);\n            res.sendStatus(200);                // Carries up-to-date cookie in 'Set-Cookie' header\n        });\n        router.get(\"/auth/workspace-cookie/:instanceID\", async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            if (!req.isAuthenticated() || !User.is(req.user)) {\n                res.sendStatus(401);\n                log.warn(\"unauthenticated workspace cookie fetch\", { instanceId: req.params.instanceID });\n                return;\n            }\n\n            const user = req.user as User;\n            if (user.blocked) {\n                res.sendStatus(403);\n                log.warn(\"blocked user attempted to fetch workspace cookie\", { instanceId: req.params.instanceID, userId: user.id });\n                return;\n            }\n\n            const instanceID = req.params.instanceID;\n            if (!instanceID) {\n                res.sendStatus(400);\n                log.warn(\"attempted to fetch workspace cookie without instance ID\", { instanceId: req.params.instanceID, userId: user.id });\n                return;\n            }\n\n            const [workspace, instance] = await Promise.all([\n                this.workspaceDB.findByInstanceId(instanceID),\n                this.workspaceDB.findInstanceById(instanceID)\n            ]);\n            if (!workspace || !instance) {\n                res.sendStatus(404);\n                log.warn(\"attempted to fetch workspace cookie for non-existent workspace instance\", { instanceId: req.params.instanceID, userId: user.id });\n                return;\n            }\n            if (workspace && user.id != workspace.ownerId) {\n                // [cw] The user is not the workspace owner, which means they don't get the owner cookie.\n                // [cw] In the future, when we introduce per-user tokens we can set the user-specific token here.\n\n                if (workspace.shareable) {\n                    // workspace is shared and hence can be accessed without the cookie.\n                    res.sendStatus(200);\n                    return;\n                }\n\n                res.sendStatus(403);\n                log.warn(\"unauthorized attempted to fetch workspace cookie\", { instanceId: req.params.instanceID, userId: user.id });\n                return;\n            }\n\n\n            const token = instance.status.ownerToken;\n            if (!token) {\n                // no token, no problem. The dashboard will try again later.\n                res.sendStatus(200);\n                log.debug(\"attempted to fetch workspace cookie, but instance has no owner token\", { instanceId: req.params.instanceID, userId: user.id });\n                return;\n            }\n\n            if (res.headersSent) {\n                return;\n            }\n\n            let cookiePrefix: string = this.env.hostUrl.url.host;\n            cookiePrefix = cookiePrefix.replace(/^https?/, '');\n            [\" \", \"-\", \".\"].forEach(c => cookiePrefix = cookiePrefix.split(c).join(\"_\"));\n\n            const name = `_${cookiePrefix}_ws_${instanceID}_owner_`;\n            res.cookie(name, token, {\n                path: \"/\",\n                httpOnly: false,\n                secure: false,\n                maxAge: 1000 * 60 * 60 * 24 * 1,    // 1 day\n                sameSite: \"lax\",                    // default: true. \"Lax\" needed for cookie to work in the workspace domain.\n                domain: `.${this.env.hostUrl.url.host}`\n            });\n            res.sendStatus(200);\n        });\n        router.get(\"/auth/workspace\", async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            if (!req.isAuthenticated() || !User.is(req.user)) {\n                res.sendStatus(401);\n                return;\n            }\n\n            const user = req.user as User;\n            if (user.blocked) {\n                res.sendStatus(403);\n                return;\n            }\n\n            const workspaceId = parseWorkspaceIdFromHostname(req.hostname);\n            if (workspaceId) {\n                const workspace = await this.workspaceDB.findById(workspaceId);\n                if (workspace && user.id != workspace.ownerId && !workspace.shareable) {\n                    log.info({ userId: user.id, workspaceId }, 'User does not own private workspace. Denied');\n                    res.sendStatus(403);\n                    return;\n                }\n            }\n\n            res.sendStatus(200);\n        });\n        router.get(\"/auth/workspace-port/:port\", async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            const authenticatedUser = req.isAuthenticated() && User.is(req.user) && req.user || undefined;\n            const access = await this.workspacePortAuthService.authorizeWorkspacePortAccess(req.params.port, req.hostname, authenticatedUser, req.header(\"x-gitpod-port-auth\"));\n            res.sendStatus(access ? 200 : 403);\n        });\n        router.get(\"/auth/monitor\", async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            if (!req.isAuthenticated() || !User.is(req.user)) {\n                // Pretend there's nothing to see\n                res.sendStatus(403);\n                return;\n            }\n\n            const user = req.user as User;\n            if (this.authService.hasPermission(user, Permission.MONITOR)) {\n                res.sendStatus(200);\n                return;\n            }\n\n            res.sendStatus(403);\n        });\n        router.get(\"/tos\", async (req: express.Request, res: express.Response) => {\n            const mode = req.query[\"mode\"] as \"login\" | \"update\" | unknown;\n            const clientInfo = getRequestingClientInfo(req);\n            let tosFlowInfo = TosFlow.get(req.session);\n            const authFlow = AuthFlow.get(req.session);\n\n            const logContext = LogContext.from({ user: req.user, request: req });\n            const logPayload = { session: req.session, clientInfo, tosFlowInfo, authFlow, mode };\n\n            const redirectOnInvalidRequest = async () => {\n                // just don't forget\n                this.tosCookie.unset(res);\n                await AuthFlow.clear(req.session);\n                await TosFlow.clear(req.session);\n\n                log.info(logContext, '(TOS) Invalid request. (/tos)', logPayload);\n                res.redirect(this.getSorryUrl(\"Oops! Something went wrong. (invalid request)\"));\n            }\n\n            if (mode !== \"login\" && mode !== \"update\") {\n                await redirectOnInvalidRequest();\n                return;\n            }\n\n            if (mode === \"login\") {\n                if (!authFlow || !TosFlow.is(tosFlowInfo)) {\n                    await redirectOnInvalidRequest();\n                    return;\n                }\n\n                // in a special case of the signup process, we're redirecting to /tos even if not required.\n                if (TosFlow.WithIdentity.is(tosFlowInfo) && tosFlowInfo.termsAcceptanceRequired === false) {\n                    log.info(logContext, '(TOS) Not required.', logPayload);\n                    await this.handleTosProceedForNewUser(req, res, authFlow, tosFlowInfo);\n                    return;\n                }\n            } else { // we are in tos update process\n\n                const user = User.is(req.user) ? req.user : undefined;\n                if (!user) {\n                    await redirectOnInvalidRequest();\n                    return;\n                }\n\n                // initializing flow here!\n                tosFlowInfo = <TosFlow.WithUser>{\n                    user: User.censor(user),\n                    returnToUrl: req.query.returnTo\n                };\n                await TosFlow.attach(req.session!, tosFlowInfo);\n            }\n\n            const isUpdate = !TosFlow.WithIdentity.is(tosFlowInfo);\n            const userInfo = tosFlowUserInfo(tosFlowInfo);\n            const tosHints = {\n                isUpdate,   // indicate whether to show the \"we've updated ...\" message\n                userInfo    // let us render the avatar on the dashboard page\n            };\n            this.tosCookie.set(res, tosHints);\n\n            log.info(logContext, \"(TOS) Redirecting to /tos.\", { tosHints, ...logPayload });\n            res.redirect(this.env.hostUrl.with(() => ({ pathname: '/tos/' })).toString());\n        });\n        const tosFlowUserInfo = (tosFlowInfo: TosFlow) => {\n            if (TosFlow.WithIdentity.is(tosFlowInfo)) {\n                return {\n                    name: tosFlowInfo.authUser.name || tosFlowInfo.authUser.authName,\n                    avatarUrl: tosFlowInfo.authUser.avatarUrl\n                }\n            }\n            if (TosFlow.WithUser.is(tosFlowInfo)) {\n                return {\n                    name: tosFlowInfo.user.name,\n                    avatarUrl: tosFlowInfo.user.avatarUrl\n                }\n            }\n        }\n        router.post(\"/tos/proceed\", async (req: express.Request, res: express.Response) => {\n\n            // just don't forget\n            this.tosCookie.unset(res);\n\n            const clientInfo = getRequestingClientInfo(req);\n            const tosFlowInfo = TosFlow.get(req.session);\n            const authFlow = AuthFlow.get(req.session);\n            const isInLoginProcess = !!authFlow;\n\n            const logContext = LogContext.from({ user: req.user, request: req });\n            const logPayload = { session: req.session, clientInfo, tosFlowInfo, authFlow };\n\n            const redirectOnInvalidSession = async () => {\n                await AuthFlow.clear(req.session);\n                await TosFlow.clear(req.session);\n\n                log.info(logContext, '(TOS) Invalid session. (/tos/proceed)', logPayload);\n                res.redirect(this.getSorryUrl(\"Oops! Something went wrong. (invalid session)\"));\n            }\n\n            if (!TosFlow.is(tosFlowInfo)) {\n                await redirectOnInvalidSession();\n                return;\n            }\n\n            const agreeTOS = req.body.agreeTOS;\n            if (!agreeTOS) {\n                // The user did not accept the terms.\n                // A redirect to /logout will wipe the session, which in case of a signup will ensure\n                // that no user data remains in the system.\n                log.info(logContext, '(TOS) User did NOT agree. Redirecting to /logout.', logPayload);\n\n                res.redirect(this.env.hostUrl.withApi({ pathname: \"/logout\" }).toString());\n                // todo@alex: consider redirecting to a description pages afterwards (returnTo param)\n\n                return;\n            }\n\n            // The user has accepted the terms.\n            log.info(logContext, '(TOS) User did agree.', logPayload);\n\n            if (TosFlow.WithIdentity.is(tosFlowInfo)) {\n                if (!authFlow) {\n                    await redirectOnInvalidSession();\n                    return;\n                }\n                await this.handleTosProceedForNewUser(req, res, authFlow, tosFlowInfo, req.body);\n            } else if (TosFlow.WithUser.is(tosFlowInfo)) {\n                const { user, returnToUrl } = tosFlowInfo;\n\n                await this.userService.acceptCurrentTerms(user);\n\n                if (isInLoginProcess) {\n                    await this.loginCompletionHandler.complete(req, res, { ...tosFlowInfo });\n                } else {\n\n                    let returnTo = returnToUrl || this.env.hostUrl.asDashboard().toString();\n                    res.redirect(returnTo);\n                }\n            }\n\n        });\n\n        return router;\n    }\n\n    protected async handleTosProceedForNewUser(req: express.Request, res: express.Response, authFlow: AuthFlow, tosFlowInfo: TosFlow.WithIdentity, tosProceedParams?: any) {\n        const { candidate, token } = tosFlowInfo;\n        const { returnTo, host } = authFlow;\n        const user = await this.userService.createUser({\n            identity: candidate,\n            token,\n            userUpdate: (user) => this.updateNewUserAfterTos(user, tosFlowInfo, tosProceedParams)\n        });\n\n        const { additionalIdentity, additionalToken, envVars } = tosFlowInfo;\n        if (additionalIdentity && additionalToken) {\n            await this.userService.updateUserIdentity(user, additionalIdentity, additionalToken);\n        }\n\n        // const { isBlocked } = tosFlowInfo; // todo@alex: this setting is in conflict with the env var\n\n        await this.userService.updateUserEnvVarsOnLogin(user, envVars);\n        await this.userService.acceptCurrentTerms(user);\n        await this.loginCompletionHandler.complete(req, res, { user, returnToUrl: returnTo, authHost: host });\n    }\n\n    protected updateNewUserAfterTos(newUser: User, tosFlowInfo: TosFlow.WithIdentity, tosProceedParams?: any) {\n        const { authUser } = tosFlowInfo;\n        newUser.name = authUser.authName;\n        newUser.fullName = authUser.name || undefined;\n        newUser.avatarUrl = authUser.avatarUrl;\n    }\n\n    protected getSorryUrl(message: string) {\n        return this.env.hostUrl.asSorry(message).toString();\n    }\n\n    protected async augmentLoginRequest(req: express.Request) {\n        const returnToURL = this.getSafeReturnToParam(req);\n        if (req.query.host) {\n            // This login request points already to an auth host\n            return;\n        }\n\n        // read current auth provider configs\n        const authProviderConfigs = this.hostContextProvider.getAll().map(hc => hc.authProvider.config);\n\n        // Special Context exception\n        if (returnToURL) {\n            const authProviderForSpecialContext = authProviderConfigs.find(c => {\n                if (c.loginContextMatcher) {\n                    try {\n                        const matcher = new RegExp(c.loginContextMatcher);\n                        return matcher.test(returnToURL)\n                    } catch { /* */ }\n                }\n                return false;\n            });\n            if (authProviderForSpecialContext) {\n                // the `host` param will be used by the authenticator to delegate to the auth provider\n                req.query.host = authProviderForSpecialContext.host;\n\n                log.debug({ sessionId: req.sessionID }, `Using \"${authProviderForSpecialContext.type}\" for login ...`, { 'login-flow': true, query: req.query, authProviderForSpecialContext });\n                return;\n            }\n        }\n\n        // Use the single available auth provider\n        const authProvidersOnDashboard = authProviderConfigs.filter(c => !c.hiddenOnDashboard && !c.disallowLogin).map(a => a.host);\n        if (authProvidersOnDashboard.length === 1) {\n            req.query.host = authProvidersOnDashboard[0];\n            return;\n        }\n\n        // If the context URL contains a known auth host, just use this\n        if (returnToURL) {\n            // returnToURL \u2013> https://gitpod.io/#https://github.com/theia-ide/theia\"\n            const hash = decodeURIComponent(new URL(decodeURIComponent(returnToURL)).hash);\n            const value = hash.substr(1); // to remove the leading #\n            let contextUrlHost: string | undefined;\n            try {\n                const contextURL = new URL(value);\n                contextUrlHost = contextURL.hostname;\n            } catch {\n                // ignore parse errors\n            }\n\n            if (!!contextUrlHost && authProvidersOnDashboard.find(a => a === contextUrlHost)) {\n                req.query.host = contextUrlHost;\n                log.debug({ sessionId: req.sessionID }, \"Guessed auth provider from returnTo URL: \" + contextUrlHost, { 'login-flow': true, query: req.query });\n                return;\n            }\n        }\n    }\n\n    protected ensureSafeReturnToParam(req: express.Request) {\n        req.query.returnTo = this.getSafeReturnToParam(req);\n    }\n\n    protected getSafeReturnToParam(req: express.Request) {\n        const returnToURL: string | undefined = req.query.redirect || req.query.returnTo;\n        if (returnToURL) {\n            const hostUrl = this.env.hostUrl.url as URL;\n            if (returnToURL.toLowerCase().startsWith(`${hostUrl.protocol}//${hostUrl.host}`.toLowerCase())) {\n                return returnToURL;\n            }\n            if (returnToURL.toLowerCase().startsWith(this.env.brandingConfig.homepage.toLowerCase())) {\n                return returnToURL;\n            }\n        }\n    }\n}\n"], "filenames": ["components/server/src/user/user-controller.ts"], "buggy_code_start_loc": [83], "buggy_code_end_loc": [485], "fixing_code_start_loc": [84], "fixing_code_end_loc": [492], "type": "CWE-601", "message": "Gitpod before 0.6.0 allows unvalidated redirects.", "other": {"cve": {"id": "CVE-2021-35206", "sourceIdentifier": "cve@mitre.org", "published": "2021-06-22T14:15:09.057", "lastModified": "2021-06-24T13:21:54.147", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Gitpod before 0.6.0 allows unvalidated redirects."}, {"lang": "es", "value": "Gitpod versiones anteriores a 0.6.0 permite redireccionamientos no validados"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gitpod:gitpod:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.0", "matchCriteriaId": "B61DBCDC-355B-4580-91B4-8D95E1124CE7"}]}]}], "references": [{"url": "https://github.com/gitpod-io/gitpod/blob/main/CHANGELOG.md", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/gitpod-io/gitpod/commit/8ca431f86ae3a6f9a17afcfed51cdd065fcff1a5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gitpod-io/gitpod/compare/0.6.0-beta5...0.6.0", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/gitpod-io/gitpod/pull/2879", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/gitpod-io/gitpod/pull/2879#issuecomment-865662372", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gitpod-io/gitpod/pull/4567", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/gitpod-io/gitpod/pull/4567/commits/f78b7d18e509e28e71b65bbd4dfd52c16ca57c18", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.gitpod.io/changelog", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/gitpod-io/gitpod/commit/8ca431f86ae3a6f9a17afcfed51cdd065fcff1a5"}}