{"buggy_code": ["v1.9.2 - February 23, 2017 \n\nThanks to @hannob for finding some Out-of-bound exceptions in memory handline.\n* [SECURITY] An invalid memory access (heap overrun) in handling LONG datatypes\n* [SECURITY] Missing a check for fields of size 0\n\nThis version  & the previous 1.9.1 resolves the following CVEs:\n* CVE-2017-6306\n* CVE-2017-6305\n* CVE-2017-6304\n* CVE-2017-6303\n* CVE-2017-6302\n* CVE-2017-6301\n* CVE-2017-6300\n* CVE-2017-6299\n* CVE-2017-6298\n\nv1.9.1 - Feb 14, 2017\n* BugFix for path handling- label both / and \\ as invalid characters inattachments\n* Remove lots of exit(-1)'s from the code that would crash calling programs\n* [SECURITY] Thanks to EricSesterhennX41 for a patch to fix lots of invalid\nmemory allocation around corrupted files.\n\nv1.9 - January 2, 2017\n* Unify libytnef and ytnef tools into a single build & package (Thanks @jmallach)\n* Fix applied for CVE-2010-5109\n* Various fixes for errors found via Static Analysis (cppcheck)\n* Various memory leaks plugged (Thanks @slonik-v-domene)\n* Bugfix for a broken \"uniqueness\" checker\n* Lots of formatting & documentation cleanups\n\nNow that the two packages are unified into a single install & build, I've had\nto choose a unifier of Version Numbers.  I chose 1.9 .\n\n\n\n\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv2.7\nMark Paulus -- Better processing of filenames, to eliminate problem-causing characters.\nHilmar - Update to the autoconf scripts to check for a valid ytneflib install during the configuration.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv2.6\nMinor Documentation changes.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv2.5\nImplemented Recurrence support, using patches & information from Viraj Alankar\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv2.4\nRearranged the ATTENDEE field adding the RSVP & PARTSTAT entries.\nRemoved the opening & trailing curly braces from the description.\nMade the UID uppercase.\nAdded both CN & MAILTO to ORGANIZER field.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv2.3\nThanks to Jason for pointing me toward jtnef, with which I was finally able to\nfinish compressed RTF support.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv2.2\nNeed to start updating this file more often. Sorry guys.\nThis release adds support for Contact cards with no name field.  So now if you\nhave contact cards with no name, but just a Company, those will work.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.15\nMade a change to fill spaces in filenames with underscores.\nSplit the vcard/vcal/vtask code into separate files for better readability.\nConverted to automake (Autoconf, etc)\nRemoved the run-time \"endian\" detection, in favor of WORD_BIGENDIAN\nPlaced version information to be automatically generated into config.h\nAdded an abstraction layer on IO\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.14\nMade a change to save vCard entries with a .vcard extension instead of a .vcf\nextension.  This way I can detect it in ytnefprocess.pl and mark it as a type\ntext/x-vcard instead of text/vcalendar.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.13\nFixed a problem in the checking of existence.  Should have been\n(variableLength*)-1 instead of NULL.. Made MAPI_UNDEFINED to keep this\nfrom happening again.  This fixed an issue with segfaulting on certain task\nrequests when a start/due date wasn't specified.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.12\nFixed a problem with recurring calendar entries, occasionally have incorrect\nstart dates.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.11\nFixed a problem with vCalendar entries using C-Style strings instead of\nquoted-printable strings.\nFixed a mis-spelled field name in vCalendar entries (DCREATED vs CREATED)\nAdded support for Start/Due date on Task entries.\nAdded support for a UID to task entries (untested).\nAdded support for Private/Public on Task Entries (untested).\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.10\nAdded attendee & organizer fields to Task Entries.\nAdded support for meeting cancellations.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.09\nMade the Notes field of vCard's & the summary field of vCalendar entries\nquoted-printable.\nAdded a : to the end of meeting attendees.\nFixed a problem with meeting requests that didn't separate required & optional\nparticipants.\nAdded code to use C-style \\n's instead of quoted-printable encoding in task\nrequests.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.08\nCode refactoring in the vCard section to improve readability.\nMade the addresses in vCards quoted printable to better support user input.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.07\nAdded the -L option for tnefclean.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.06\nFix for the CN & ROLE being reversed in required participants of meetings.\nAdded the -l option for tnefclean.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.05 \nAdded the -F option to enable/disable the RTF attachments.\nIntegrated patch #666566: Unicode to UTF8 conversion.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.04 1-11-2003\nAdded code to use the PR_SENDER_SEARCH_KEY as the organizer\n        of vcalendar objects.\nFixed glitch with the From handler & the Message Class handler both\n        storing in the same namespace.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.03 1-5-2003\nMore endian fixes, now finally works on PowerPC.\nModified the main.c to place the printing in a separate file.\nAdded support for embedded TNEF streams.\nMoved the vCalendar to a separate procedure (for readability)\nAdded the vCard 2.1 code, with the special X-EVOLUTION extensions\n        for the extra properties.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.02 12-27-2002\nMore fixes for the Endian problem, additions to the file-reading routines.\nFixed warnings.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.01 12-27-2002\nMakefile cleanup - Removed references to openGL, Glut, & X libraries.\nAdditions to help (-h).\nFixes to make it run on Alpha architecture.\nFirst attempt at fixing the Big Endian/Little Endian issue.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.0 12-26-2002\nInitial Release\n", "/*\n*    Yerase's TNEF Stream Reader Library\n*    Copyright (C) 2003  Randall E. Hand\n*\n*    This program is free software; you can redistribute it and/or modify\n*    it under the terms of the GNU General Public License as published by\n*    the Free Software Foundation; either version 2 of the License, or\n*    (at your option) any later version.\n*\n*    This program is distributed in the hope that it will be useful,\n*    but WITHOUT ANY WARRANTY; without even the implied warranty of\n*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n*    GNU General Public License for more details.\n*\n*    You should have received a copy of the GNU General Public License\n*    along with this program; if not, write to the Free Software\n*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*\n*    You can contact me at randall.hand@gmail.com for questions or assistance\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"ytnef.h\"\n#include \"tnef-errors.h\"\n#include \"mapi.h\"\n#include \"mapidefs.h\"\n#include \"mapitags.h\"\n#include \"config.h\"\n\n#define RTF_PREBUF \"{\\\\rtf1\\\\ansi\\\\mac\\\\deff0\\\\deftab720{\\\\fonttbl;}{\\\\f0\\\\fnil \\\\froman \\\\fswiss \\\\fmodern \\\\fscript \\\\fdecor MS Sans SerifSymbolArialTimes New RomanCourier{\\\\colortbl\\\\red0\\\\green0\\\\blue0\\n\\r\\\\par \\\\pard\\\\plain\\\\f0\\\\fs20\\\\b\\\\i\\\\u\\\\tab\\\\tx\"\n#define DEBUG(lvl, curlvl, msg) \\\n        if ((lvl) >= (curlvl)) \\\n            printf(\"DEBUG(%i/%i): %s\\n\", curlvl, lvl,  msg);\n#define DEBUG1(lvl, curlvl, msg, var1) \\\n        if ((lvl) >= (curlvl)) { \\\n            printf(\"DEBUG(%i/%i):\", curlvl, lvl); \\\n            printf(msg, var1); \\\n            printf(\"\\n\"); \\\n        }\n#define DEBUG2(lvl, curlvl, msg, var1, var2) \\\n        if ((lvl) >= (curlvl)) { \\\n            printf(\"DEBUG(%i/%i):\", curlvl, lvl); \\\n            printf(msg, var1, var2); \\\n            printf(\"\\n\"); \\\n        }\n#define DEBUG3(lvl, curlvl, msg, var1, var2, var3) \\\n        if ((lvl) >= (curlvl)) { \\\n            printf(\"DEBUG(%i/%i):\", curlvl, lvl); \\\n            printf(msg, var1, var2,var3); \\\n            printf(\"\\n\"); \\\n        }\n\n#define MIN(x,y) (((x)<(y))?(x):(y))\n\n#define ALLOCCHECK(x) { if(!x) { printf(\"Out of Memory at %s : %i\\n\", __FILE__, __LINE__); return(-1); } }\n#define ALLOCCHECK_CHAR(x) { if(!x) { printf(\"Out of Memory at %s : %i\\n\", __FILE__, __LINE__); return(NULL); } }\n#define SIZECHECK(x) { if ((((char *)d - (char *)data) + x) > size) {  printf(\"Corrupted file detected at %s : %i\\n\", __FILE__, __LINE__); return(-1); } }\n\nint TNEFFillMapi(TNEFStruct *TNEF, BYTE *data, DWORD size, MAPIProps *p);\nvoid SetFlip(void);\n\nint TNEFDefaultHandler STD_ARGLIST;\nint TNEFAttachmentFilename STD_ARGLIST;\nint TNEFAttachmentSave STD_ARGLIST;\nint TNEFDetailedPrint STD_ARGLIST;\nint TNEFHexBreakdown STD_ARGLIST;\nint TNEFBody STD_ARGLIST;\nint TNEFRendData STD_ARGLIST;\nint TNEFDateHandler STD_ARGLIST;\nint TNEFPriority  STD_ARGLIST;\nint TNEFVersion  STD_ARGLIST;\nint TNEFMapiProperties STD_ARGLIST;\nint TNEFIcon STD_ARGLIST;\nint TNEFSubjectHandler STD_ARGLIST;\nint TNEFFromHandler STD_ARGLIST;\nint TNEFRecipTable STD_ARGLIST;\nint TNEFAttachmentMAPI STD_ARGLIST;\nint TNEFSentFor STD_ARGLIST;\nint TNEFMessageClass STD_ARGLIST;\nint TNEFMessageID STD_ARGLIST;\nint TNEFParentID STD_ARGLIST;\nint TNEFOriginalMsgClass STD_ARGLIST;\nint TNEFCodePage STD_ARGLIST;\n\n\nBYTE *TNEFFileContents = NULL;\nDWORD TNEFFileContentsSize;\nBYTE *TNEFFileIcon = NULL;\nDWORD TNEFFileIconSize;\n\nint IsCompressedRTF(variableLength *p);\n\nTNEFHandler TNEFList[] = {\n  {attNull,                    \"Null\",                        TNEFDefaultHandler},\n  {attFrom,                    \"From\",                        TNEFFromHandler},\n  {attSubject,                 \"Subject\",                     TNEFSubjectHandler},\n  {attDateSent,                \"Date Sent\",                   TNEFDateHandler},\n  {attDateRecd,                \"Date Received\",               TNEFDateHandler},\n  {attMessageStatus,           \"Message Status\",              TNEFDefaultHandler},\n  {attMessageClass,            \"Message Class\",               TNEFMessageClass},\n  {attMessageID,               \"Message ID\",                  TNEFMessageID},\n  {attParentID,                \"Parent ID\",                   TNEFParentID},\n  {attConversationID,          \"Conversation ID\",             TNEFDefaultHandler},\n  {attBody,                    \"Body\",                        TNEFBody},\n  {attPriority,                \"Priority\",                    TNEFPriority},\n  {attAttachData,              \"Attach Data\",                 TNEFAttachmentSave},\n  {attAttachTitle,             \"Attach Title\",                TNEFAttachmentFilename},\n  {attAttachMetaFile,          \"Attach Meta-File\",            TNEFIcon},\n  {attAttachCreateDate,        \"Attachment Create Date\",      TNEFDateHandler},\n  {attAttachModifyDate,        \"Attachment Modify Date\",      TNEFDateHandler},\n  {attDateModified,            \"Date Modified\",               TNEFDateHandler},\n  {attAttachTransportFilename, \"Attachment Transport name\",   TNEFDefaultHandler},\n  {attAttachRenddata,          \"Attachment Display info\",     TNEFRendData},\n  {attMAPIProps,               \"MAPI Properties\",             TNEFMapiProperties},\n  {attRecipTable,              \"Recip Table\",                 TNEFRecipTable},\n  {attAttachment,              \"Attachment\",                  TNEFAttachmentMAPI},\n  {attTnefVersion,             \"TNEF Version\",                TNEFVersion},\n  {attOemCodepage,             \"OEM CodePage\",                TNEFCodePage},\n  {attOriginalMessageClass,    \"Original Message Class\",      TNEFOriginalMsgClass},\n  {attOwner,                   \"Owner\",                       TNEFDefaultHandler},\n  {attSentFor,                 \"Sent For\",                    TNEFSentFor},\n  {attDelegate,                \"Delegate\",                    TNEFDefaultHandler},\n  {attDateStart,               \"Date Start\",                  TNEFDateHandler},\n  {attDateEnd,                 \"Date End\",                    TNEFDateHandler},\n  {attAidOwner,                \"Aid Owner\",                   TNEFDefaultHandler},\n  {attRequestRes,              \"Request Response\",            TNEFDefaultHandler}\n};\n\n\nWORD SwapWord(BYTE *p, int size) {\n  union BYTES2WORD\n  {\n      WORD word;\n      BYTE bytes[sizeof(WORD)];\n  };\n  \n  union BYTES2WORD converter;  \n  converter.word = 0;\n  int i = 0;\n  int correct = size > sizeof(WORD) ? sizeof(WORD) : size;\n\n#ifdef WORDS_BIGENDIAN\n  for (i = 0; i < correct; ++i)\n  {\n      converter.bytes[i] = p[correct - i];\n  }\n#else\n  for (i = 0; i < correct; ++i)\n  {\n      converter.bytes[i] = p[i];\n  }\n#endif\n  \n  return converter.word;\n}\n\nDWORD SwapDWord(BYTE *p, int size) {\n  union BYTES2DWORD\n  {\n      DWORD dword;\n      BYTE  bytes[sizeof(DWORD)];\n  };\n  \n  union BYTES2DWORD converter;\n  converter.dword = 0;\n  int i = 0;  \n  int correct = size > sizeof(DWORD) ? sizeof(DWORD) : size;\n  \n#ifdef WORDS_BIGENDIAN\n  for (i = 0; i < correct; ++i)\n  {\n      converter.bytes[i] = p[correct - i];\n  }\n#else\n  for (i = 0; i < correct; ++i)\n  {\n      converter.bytes[i] = p[i];\n  }\n#endif\n  \n  return converter.dword;\n}\n\n\n\nDDWORD SwapDDWord(BYTE *p, int size) {\n  union BYTES2DDWORD\n  {\n      DDWORD ddword;\n      BYTE   bytes[sizeof(DDWORD)];\n  };\n  \n  union BYTES2DDWORD converter;\n  converter.ddword = 0;\n  int i = 0;  \n  int correct = size > sizeof(DDWORD) ? sizeof(DDWORD) : size;\n  \n#ifdef WORDS_BIGENDIAN\n  for (i = 0; i < correct; ++i)\n  {\n      converter.bytes[i] = p[correct - i];\n  }\n#else\n  for (i = 0; i < correct; ++i)\n  {\n      converter.bytes[i] = p[i];\n  }\n#endif\n  \n  return converter.ddword;\n}\n\n/* convert 16-bit unicode to UTF8 unicode */\nchar *to_utf8(size_t len, char *buf) {\n  int i, j = 0;\n  /* worst case length */\n  if (len > 10000) {\t// deal with this by adding an arbitrary limit\n     printf(\"suspecting a corrupt file in UTF8 conversion\\n\");\n     exit(-1);\n  }\n  char *utf8 = malloc(3 * len / 2 + 1);\n\n  for (i = 0; i < len - 1; i += 2) {\n    unsigned int c = SwapWord((BYTE *)buf + i, 2);\n    if (c <= 0x007f) {\n      utf8[j++] = 0x00 | ((c & 0x007f) >> 0);\n    } else if (c < 0x07ff) {\n      utf8[j++] = 0xc0 | ((c & 0x07c0) >> 6);\n      utf8[j++] = 0x80 | ((c & 0x003f) >> 0);\n    } else {\n      utf8[j++] = 0xe0 | ((c & 0xf000) >> 12);\n      utf8[j++] = 0x80 | ((c & 0x0fc0) >> 6);\n      utf8[j++] = 0x80 | ((c & 0x003f) >> 0);\n    }\n  }\n\n  /* just in case the original was not null terminated */\n  utf8[j++] = '\\0';\n\n  return utf8;\n}\n\n\n// -----------------------------------------------------------------------------\nint TNEFDefaultHandler STD_ARGLIST {\n  if (TNEF->Debug >= 1)\n    printf(\"%s: [%i] %s\\n\", TNEFList[id].name, size, data);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFCodePage STD_ARGLIST {\n  TNEF->CodePage.size = size;\n  TNEF->CodePage.data = calloc(size, sizeof(BYTE));\n  ALLOCCHECK(TNEF->CodePage.data);\n  memcpy(TNEF->CodePage.data, data, size);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFParentID STD_ARGLIST {\n  memcpy(TNEF->parentID, data, MIN(size, sizeof(TNEF->parentID)));\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFMessageID STD_ARGLIST {\n  memcpy(TNEF->messageID, data, MIN(size, sizeof(TNEF->messageID)));\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFBody STD_ARGLIST {\n  TNEF->body.size = size;\n  TNEF->body.data = calloc(size, sizeof(BYTE));\n  ALLOCCHECK(TNEF->body.data);\n  memcpy(TNEF->body.data, data, size);\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFOriginalMsgClass STD_ARGLIST {\n  TNEF->OriginalMessageClass.size = size;\n  TNEF->OriginalMessageClass.data = calloc(size, sizeof(BYTE));\n  ALLOCCHECK(TNEF->OriginalMessageClass.data);\n  memcpy(TNEF->OriginalMessageClass.data, data, size);\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFMessageClass STD_ARGLIST {\n  memcpy(TNEF->messageClass, data, MIN(size, sizeof(TNEF->messageClass)));\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFFromHandler STD_ARGLIST {\n  TNEF->from.data = calloc(size, sizeof(BYTE));\n  ALLOCCHECK(TNEF->from.data);\n  TNEF->from.size = size;\n  memcpy(TNEF->from.data, data, size);\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFSubjectHandler STD_ARGLIST {\n  if (TNEF->subject.data)\n    free(TNEF->subject.data);\n\n  TNEF->subject.data = calloc(size, sizeof(BYTE));\n  ALLOCCHECK(TNEF->subject.data);\n  TNEF->subject.size = size;\n  memcpy(TNEF->subject.data, data, size);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFRendData STD_ARGLIST {\n  Attachment *p;\n  // Find the last attachment.\n  p = &(TNEF->starting_attach);\n  while (p->next != NULL) p = p->next;\n\n  // Add a new one\n  p->next = calloc(1, sizeof(Attachment));\n  ALLOCCHECK(p->next);\n  p = p->next;\n\n  TNEFInitAttachment(p);\n\n int correct = (size >= sizeof(renddata)) ? sizeof(renddata) : size;\n  memcpy(&(p->RenderData), data, correct);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFVersion STD_ARGLIST {\n  WORD major;\n  WORD minor;\n  minor = SwapWord((BYTE*)data, size);\n  major = SwapWord((BYTE*)data + 2, size - 2);\n\n  snprintf(TNEF->version, sizeof(TNEF->version), \"TNEF%i.%i\", major, minor);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFIcon STD_ARGLIST {\n  Attachment *p;\n  // Find the last attachment.\n  p = &(TNEF->starting_attach);\n  while (p->next != NULL) p = p->next;\n\n  p->IconData.size = size;\n  p->IconData.data = calloc(size, sizeof(BYTE));\n  ALLOCCHECK(p->IconData.data);\n  memcpy(p->IconData.data, data, size);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFRecipTable STD_ARGLIST {\n  DWORD count;\n  BYTE *d;\n  int current_row;\n  int propcount;\n  int current_prop;\n\n  d = (BYTE*)data;\n  count = SwapDWord((BYTE*)d, 4);\n  d += 4;\n//    printf(\"Recipient Table containing %u rows\\n\", count);\n\n  return 0;\n\n  for (current_row = 0; current_row < count; current_row++) {\n    propcount = SwapDWord((BYTE*)d, 4);\n    if (TNEF->Debug >= 1)\n      printf(\"> Row %i contains %i properties\\n\", current_row, propcount);\n    d += 4;\n    for (current_prop = 0; current_prop < propcount; current_prop++) {\n\n\n    }\n  }\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFAttachmentMAPI STD_ARGLIST {\n  Attachment *p;\n  // Find the last attachment.\n  //\n  p = &(TNEF->starting_attach);\n  while (p->next != NULL) p = p->next;\n  return TNEFFillMapi(TNEF, (BYTE*)data, size, &(p->MAPI));\n}\n// -----------------------------------------------------------------------------\nint TNEFMapiProperties STD_ARGLIST {\n  if (TNEFFillMapi(TNEF, (BYTE*)data, size, &(TNEF->MapiProperties)) < 0) {\n    printf(\"ERROR Parsing MAPI block\\n\");\n    return -1;\n  };\n  if (TNEF->Debug >= 3) {\n    MAPIPrint(&(TNEF->MapiProperties));\n  }\n  return 0;\n}\n\nint TNEFFillMapi(TNEFStruct *TNEF, BYTE *data, DWORD size, MAPIProps *p) {\n  int i, j;\n  DWORD num;\n  BYTE *d;\n  MAPIProperty *mp;\n  DWORD type;\n  DWORD length;\n  variableLength *vl;\n\n  WORD temp_word;\n  DWORD temp_dword;\n  DDWORD temp_ddword;\n  int count = -1;\n  int offset;\n\n  d = data;\n  p->count = SwapDWord((BYTE*)data, 4);\n  d += 4;\n  p->properties = calloc(p->count, sizeof(MAPIProperty));\n  ALLOCCHECK(p->properties);\n  mp = p->properties;\n\n  for (i = 0; i < p->count; i++) {\n    if (count == -1) {\n      mp->id = SwapDWord((BYTE*)d, 4);\n      d += 4;\n      mp->custom = 0;\n      mp->count = 1;\n      mp->namedproperty = 0;\n      length = -1;\n      if (PROP_ID(mp->id) >= 0x8000) {\n        // Read the GUID\n        SIZECHECK(16);\n        memcpy(&(mp->guid[0]), d, 16);\n        d += 16;\n\n        SIZECHECK(4);\n        length = SwapDWord((BYTE*)d, 4);\n        d += sizeof(DWORD);\n        if (length > 0) {\n          mp->namedproperty = length;\n          mp->propnames = calloc(length, sizeof(variableLength));\n          ALLOCCHECK(mp->propnames);\n          while (length > 0) {\n            SIZECHECK(4);\n            type = SwapDWord((BYTE*)d, 4);\n            mp->propnames[length - 1].data = calloc(type, sizeof(BYTE));\n            ALLOCCHECK(mp->propnames[length - 1].data);\n            mp->propnames[length - 1].size = type;\n            d += 4;\n            for (j = 0; j < (type >> 1); j++) {\n              SIZECHECK(j*2);\n              mp->propnames[length - 1].data[j] = d[j * 2];\n            }\n            d += type + ((type % 4) ? (4 - type % 4) : 0);\n            length--;\n          }\n        } else {\n          // READ the type\n          SIZECHECK(sizeof(DWORD));\n          type = SwapDWord((BYTE*)d, sizeof(DWORD));\n          d += sizeof(DWORD);\n          mp->id = PROP_TAG(PROP_TYPE(mp->id), type);\n        }\n        mp->custom = 1;\n      }\n\n      DEBUG2(TNEF->Debug, 3, \"Type id = %04x, Prop id = %04x\", PROP_TYPE(mp->id),\n             PROP_ID(mp->id));\n      if (PROP_TYPE(mp->id) & MV_FLAG) {\n        mp->id = PROP_TAG(PROP_TYPE(mp->id) - MV_FLAG, PROP_ID(mp->id));\n        SIZECHECK(4);\n        mp->count = SwapDWord((BYTE*)d, 4);\n        d += 4;\n        count = 0;\n      }\n      mp->data = calloc(mp->count, sizeof(variableLength));\n      ALLOCCHECK(mp->data);\n      vl = mp->data;\n    } else {\n      i--;\n      count++;\n      vl = &(mp->data[count]);\n    }\n\n    switch (PROP_TYPE(mp->id)) {\n      case PT_BINARY:\n      case PT_OBJECT:\n      case PT_STRING8:\n      case PT_UNICODE:\n        // First number of objects (assume 1 for now)\n        if (count == -1) {\n          SIZECHECK(4);\n          vl->size = SwapDWord((BYTE*)d, 4);\n          d += 4;\n        }\n        // now size of object\n        SIZECHECK(4);\n        vl->size = SwapDWord((BYTE*)d, 4);\n        d += 4;\n\n        // now actual object\n        if (vl->size != 0) {    \n         SIZECHECK(vl->size);\n         if (PROP_TYPE(mp->id) == PT_UNICODE) {\n                vl->data =(BYTE*) to_utf8(vl->size, (char*)d);\n            } else {\n              vl->data = calloc(vl->size, sizeof(BYTE));\n              ALLOCCHECK(vl->data);\n              memcpy(vl->data, d, vl->size);\n            }\n        } else {\n          vl->data = NULL;\n        }\n\n        // Make sure to read in a multiple of 4\n        num = vl->size;\n        offset = ((num % 4) ? (4 - num % 4) : 0);\n        d += num + ((num % 4) ? (4 - num % 4) : 0);\n        break;\n\n      case PT_I2:\n        // Read in 2 bytes, but proceed by 4 bytes\n        vl->size = 2;\n        vl->data = calloc(vl->size, sizeof(WORD));\n        ALLOCCHECK(vl->data);\n        SIZECHECK(sizeof(WORD))\n        temp_word = SwapWord((BYTE*)d, sizeof(WORD));\n        memcpy(vl->data, &temp_word, vl->size);\n        d += 4;\n        break;\n      case PT_BOOLEAN:\n      case PT_LONG:\n      case PT_R4:\n      case PT_CURRENCY:\n      case PT_APPTIME:\n      case PT_ERROR:\n        vl->size = 4;\n        vl->data = calloc(vl->size, sizeof(BYTE));\n        ALLOCCHECK(vl->data);\n        SIZECHECK(4);\n        temp_dword = SwapDWord((BYTE*)d, 4);\n        memcpy(vl->data, &temp_dword, vl->size);\n        d += 4;\n        break;\n      case PT_DOUBLE:\n      case PT_I8:\n      case PT_SYSTIME:\n        vl->size = 8;\n        vl->data = calloc(vl->size, sizeof(BYTE));\n        ALLOCCHECK(vl->data);\n        SIZECHECK(8);\n        temp_ddword = SwapDDWord(d, 8);\n        memcpy(vl->data, &temp_ddword, vl->size);\n        d += 8;\n        break;\n      case PT_CLSID:\n        vl->size = 16;\n        vl->data = calloc(vl->size, sizeof(BYTE));\n        ALLOCCHECK(vl->data);\n        SIZECHECK(vl->size);\n        memcpy(vl->data, d, vl->size);\n        d+=16;\n        break;\n      default:\n        printf(\"Bad file\\n\");\n        exit(-1);\n    }\n\n    switch (PROP_ID(mp->id)) {\n      case PR_SUBJECT:\n      case PR_SUBJECT_IPM:\n      case PR_ORIGINAL_SUBJECT:\n      case PR_NORMALIZED_SUBJECT:\n      case PR_CONVERSATION_TOPIC:\n        DEBUG(TNEF->Debug, 3, \"Got a Subject\");\n        if (TNEF->subject.size == 0) {\n          int i;\n          DEBUG(TNEF->Debug, 3, \"Assigning a Subject\");\n          TNEF->subject.data = calloc(size, sizeof(BYTE));\n          ALLOCCHECK(TNEF->subject.data);\n          TNEF->subject.size = vl->size;\n          memcpy(TNEF->subject.data, vl->data, vl->size);\n          //  Unfortunately, we have to normalize out some invalid\n          //  characters, or else the file won't write\n          for (i = 0; i != TNEF->subject.size; i++) {\n            switch (TNEF->subject.data[i]) {\n              case '\\\\':\n              case '/':\n              case '\\0':\n                TNEF->subject.data[i] = '_';\n                break;\n            }\n          }\n        }\n        break;\n    }\n\n    if (count == (mp->count - 1)) {\n      count = -1;\n    }\n    if (count == -1) {\n      mp++;\n    }\n\n  }\n  if ((d - data) < size) {\n    if (TNEF->Debug >= 1)  {\n      printf(\"ERROR DURING MAPI READ\\n\");\n      printf(\"Read %td bytes, Expected %u bytes\\n\", (d - data), size);\n      printf(\"%td bytes missing\\n\", size - (d - data));\n    }\n  } else if ((d - data) > size) {\n    if (TNEF->Debug >= 1)  {\n      printf(\"ERROR DURING MAPI READ\\n\");\n      printf(\"Read %td bytes, Expected %u bytes\\n\", (d - data), size);\n      printf(\"%li bytes extra\\n\", (d - data) - size);\n    }\n  }\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFSentFor STD_ARGLIST {\n  WORD name_length, addr_length;\n  BYTE *d;\n\n  d = (BYTE*)data;\n\n  while ((d - (BYTE*)data) < size) {\n    SIZECHECK(sizeof(WORD));\n    name_length = SwapWord((BYTE*)d, sizeof(WORD));\n    d += sizeof(WORD);\n    if (TNEF->Debug >= 1)\n      printf(\"Sent For : %s\", d);\n    d += name_length;\n\n    SIZECHECK(sizeof(WORD));\n    addr_length = SwapWord((BYTE*)d, sizeof(WORD));\n    d += sizeof(WORD);\n    if (TNEF->Debug >= 1)\n      printf(\"<%s>\\n\", d);\n    d += addr_length;\n  }\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFDateHandler STD_ARGLIST {\n  dtr *Date;\n  Attachment *p;\n  WORD * tmp_src, *tmp_dst;\n  int i;\n\n  p = &(TNEF->starting_attach);\n  switch (TNEFList[id].id) {\n    case attDateSent: Date = &(TNEF->dateSent); break;\n    case attDateRecd: Date = &(TNEF->dateReceived); break;\n    case attDateModified: Date = &(TNEF->dateModified); break;\n    case attDateStart: Date = &(TNEF->DateStart); break;\n    case attDateEnd:  Date = &(TNEF->DateEnd); break;\n    case attAttachCreateDate:\n      while (p->next != NULL) p = p->next;\n      Date = &(p->CreateDate);\n      break;\n    case attAttachModifyDate:\n      while (p->next != NULL) p = p->next;\n      Date = &(p->ModifyDate);\n      break;\n    default:\n      if (TNEF->Debug >= 1)\n        printf(\"MISSING CASE\\n\");\n      return YTNEF_UNKNOWN_PROPERTY;\n  }\n\n  tmp_src = (WORD *)data;\n  tmp_dst = (WORD *)Date;\n  for (i = 0; i < sizeof(dtr) / sizeof(WORD); i++) {\n    *tmp_dst++ = SwapWord((BYTE *)tmp_src++, sizeof(WORD));\n  }\n  return 0;\n}\n\nvoid TNEFPrintDate(dtr Date) {\n  char days[7][15] = {\"Sunday\", \"Monday\", \"Tuesday\",\n                      \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"\n                     };\n  char months[12][15] = {\"January\", \"February\", \"March\", \"April\", \"May\",\n                         \"June\", \"July\", \"August\", \"September\", \"October\", \"November\",\n                         \"December\"\n                        };\n\n  if (Date.wDayOfWeek < 7)\n    printf(\"%s \", days[Date.wDayOfWeek]);\n\n  if ((Date.wMonth < 13) && (Date.wMonth > 0))\n    printf(\"%s \", months[Date.wMonth - 1]);\n\n  printf(\"%hu, %hu \", Date.wDay, Date.wYear);\n\n  if (Date.wHour > 12)\n    printf(\"%i:%02hu:%02hu pm\", (Date.wHour - 12),\n           Date.wMinute, Date.wSecond);\n  else if (Date.wHour == 12)\n    printf(\"%hu:%02hu:%02hu pm\", (Date.wHour),\n           Date.wMinute, Date.wSecond);\n  else\n    printf(\"%hu:%02hu:%02hu am\", Date.wHour,\n           Date.wMinute, Date.wSecond);\n}\n// -----------------------------------------------------------------------------\nint TNEFHexBreakdown STD_ARGLIST {\n  int i;\n  if (TNEF->Debug == 0)\n    return 0;\n\n  printf(\"%s: [%i bytes] \\n\", TNEFList[id].name, size);\n\n  for (i = 0; i < size; i++) {\n    printf(\"%02x \", data[i]);\n    if ((i + 1) % 16 == 0) printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFDetailedPrint STD_ARGLIST {\n  int i;\n  if (TNEF->Debug == 0)\n    return 0;\n\n  printf(\"%s: [%i bytes] \\n\", TNEFList[id].name, size);\n\n  for (i = 0; i < size; i++) {\n    printf(\"%c\", data[i]);\n  }\n  printf(\"\\n\");\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFAttachmentFilename STD_ARGLIST {\n  Attachment *p;\n  p = &(TNEF->starting_attach);\n  while (p->next != NULL) p = p->next;\n\n  p->Title.size = size;\n  p->Title.data = calloc(size, sizeof(BYTE));\n  ALLOCCHECK(p->Title.data);\n  memcpy(p->Title.data, data, size);\n\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFAttachmentSave STD_ARGLIST {\n  Attachment *p;\n  p = &(TNEF->starting_attach);\n  while (p->next != NULL) p = p->next;\n\n  p->FileData.data = calloc(sizeof(char), size);\n  ALLOCCHECK(p->FileData.data);\n  p->FileData.size = size;\n\n  memcpy(p->FileData.data, data, size);\n\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFPriority STD_ARGLIST {\n  DWORD value;\n\n  value = SwapDWord((BYTE*)data, size);\n  switch (value) {\n    case 3:\n      sprintf((TNEF->priority), \"high\");\n      break;\n    case 2:\n      sprintf((TNEF->priority), \"normal\");\n      break;\n    case 1:\n      sprintf((TNEF->priority), \"low\");\n      break;\n    default:\n      sprintf((TNEF->priority), \"N/A\");\n      break;\n  }\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFCheckForSignature(DWORD sig) {\n  DWORD signature = 0x223E9F78;\n\n  sig = SwapDWord((BYTE *)&sig, sizeof(DWORD));\n\n  if (signature == sig) {\n    return 0;\n  } else {\n    return YTNEF_NOT_TNEF_STREAM;\n  }\n}\n\n// -----------------------------------------------------------------------------\nint TNEFGetKey(TNEFStruct *TNEF, WORD *key) {\n  if (TNEF->IO.ReadProc(&(TNEF->IO), sizeof(WORD), 1, key) < 1) {\n    if (TNEF->Debug >= 1)\n      printf(\"Error reading Key\\n\");\n    return YTNEF_ERROR_READING_DATA;\n  }\n  *key = SwapWord((BYTE *)key, sizeof(WORD));\n\n  DEBUG1(TNEF->Debug, 2, \"Key = 0x%X\", *key);\n  DEBUG1(TNEF->Debug, 2, \"Key = %i\", *key);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFGetHeader(TNEFStruct *TNEF, DWORD *type, DWORD *size) {\n  BYTE component;\n\n  DEBUG(TNEF->Debug, 2, \"About to read Component\");\n  if (TNEF->IO.ReadProc(&(TNEF->IO), sizeof(BYTE), 1, &component) < 1) {\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n\n  DEBUG(TNEF->Debug, 2, \"About to read type\");\n  if (TNEF->IO.ReadProc(&(TNEF->IO), sizeof(DWORD), 1, type)  < 1) {\n    if (TNEF->Debug >= 1)\n      printf(\"ERROR: Error reading type\\n\");\n    return YTNEF_ERROR_READING_DATA;\n  }\n  DEBUG1(TNEF->Debug, 2, \"Type = 0x%X\", *type);\n  DEBUG1(TNEF->Debug, 2, \"Type = %u\", *type);\n\n\n  DEBUG(TNEF->Debug, 2, \"About to read size\");\n  if (TNEF->IO.ReadProc(&(TNEF->IO), sizeof(DWORD), 1, size) < 1) {\n    if (TNEF->Debug >= 1)\n      printf(\"ERROR: Error reading size\\n\");\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n\n  DEBUG1(TNEF->Debug, 2, \"Size = %u\", *size);\n\n  *type = SwapDWord((BYTE *)type, sizeof(DWORD));\n  *size = SwapDWord((BYTE *)size, sizeof(DWORD));\n\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFRawRead(TNEFStruct *TNEF, BYTE *data, DWORD size, WORD *checksum) {\n  WORD temp;\n  int i;\n\n  if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(BYTE), size, data) < size) {\n    if (TNEF->Debug >= 1)\n      printf(\"ERROR: Error reading data\\n\");\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n\n  if (checksum != NULL) {\n    *checksum = 0;\n    for (i = 0; i < size; i++) {\n      temp = data[i];\n      *checksum = (*checksum + temp);\n    }\n  }\n  return 0;\n}\n\n#define INITVARLENGTH(x) (x).data = NULL; (x).size = 0;\n#define INITDTR(x) (x).wYear=0; (x).wMonth=0; (x).wDay=0; \\\n                   (x).wHour=0; (x).wMinute=0; (x).wSecond=0; \\\n                   (x).wDayOfWeek=0;\n#define INITSTR(x) memset((x), 0, sizeof(x));\nvoid TNEFInitMapi(MAPIProps *p) {\n  p->count = 0;\n  p->properties = NULL;\n}\n\nvoid TNEFInitAttachment(Attachment *p) {\n  INITDTR(p->Date);\n  INITVARLENGTH(p->Title);\n  INITVARLENGTH(p->MetaFile);\n  INITDTR(p->CreateDate);\n  INITDTR(p->ModifyDate);\n  INITVARLENGTH(p->TransportFilename);\n  INITVARLENGTH(p->FileData);\n  INITVARLENGTH(p->IconData);\n  memset(&(p->RenderData), 0, sizeof(renddata));\n  TNEFInitMapi(&(p->MAPI));\n  p->next = NULL;\n}\n\nvoid TNEFInitialize(TNEFStruct *TNEF) {\n  INITSTR(TNEF->version);\n  INITVARLENGTH(TNEF->from);\n  INITVARLENGTH(TNEF->subject);\n  INITDTR(TNEF->dateSent);\n  INITDTR(TNEF->dateReceived);\n\n  INITSTR(TNEF->messageStatus);\n  INITSTR(TNEF->messageClass);\n  INITSTR(TNEF->messageID);\n  INITSTR(TNEF->parentID);\n  INITSTR(TNEF->conversationID);\n  INITVARLENGTH(TNEF->body);\n  INITSTR(TNEF->priority);\n  TNEFInitAttachment(&(TNEF->starting_attach));\n  INITDTR(TNEF->dateModified);\n  TNEFInitMapi(&(TNEF->MapiProperties));\n  INITVARLENGTH(TNEF->CodePage);\n  INITVARLENGTH(TNEF->OriginalMessageClass);\n  INITVARLENGTH(TNEF->Owner);\n  INITVARLENGTH(TNEF->SentFor);\n  INITVARLENGTH(TNEF->Delegate);\n  INITDTR(TNEF->DateStart);\n  INITDTR(TNEF->DateEnd);\n  INITVARLENGTH(TNEF->AidOwner);\n  TNEF->RequestRes = 0;\n  TNEF->IO.data = NULL;\n  TNEF->IO.InitProc = NULL;\n  TNEF->IO.ReadProc = NULL;\n  TNEF->IO.CloseProc = NULL;\n}\n#undef INITVARLENGTH\n#undef INITDTR\n#undef INITSTR\n\n#define FREEVARLENGTH(x) if ((x).size > 0) { \\\n                            free((x).data); (x).size =0; }\nvoid TNEFFree(TNEFStruct *TNEF) {\n  Attachment *p, *store;\n\n  FREEVARLENGTH(TNEF->from);\n  FREEVARLENGTH(TNEF->subject);\n  FREEVARLENGTH(TNEF->body);\n  FREEVARLENGTH(TNEF->CodePage);\n  FREEVARLENGTH(TNEF->OriginalMessageClass);\n  FREEVARLENGTH(TNEF->Owner);\n  FREEVARLENGTH(TNEF->SentFor);\n  FREEVARLENGTH(TNEF->Delegate);\n  FREEVARLENGTH(TNEF->AidOwner);\n  TNEFFreeMapiProps(&(TNEF->MapiProperties));\n\n  p = TNEF->starting_attach.next;\n  while (p != NULL) {\n    TNEFFreeAttachment(p);\n    store = p->next;\n    free(p);\n    p = store;\n  }\n}\n\nvoid TNEFFreeAttachment(Attachment *p) {\n  FREEVARLENGTH(p->Title);\n  FREEVARLENGTH(p->MetaFile);\n  FREEVARLENGTH(p->TransportFilename);\n  FREEVARLENGTH(p->FileData);\n  FREEVARLENGTH(p->IconData);\n  TNEFFreeMapiProps(&(p->MAPI));\n}\n\nvoid TNEFFreeMapiProps(MAPIProps *p) {\n  int i, j;\n  for (i = 0; i < p->count; i++) {\n    for (j = 0; j < p->properties[i].count; j++) {\n      FREEVARLENGTH(p->properties[i].data[j]);\n    }\n    free(p->properties[i].data);\n    for (j = 0; j < p->properties[i].namedproperty; j++) {\n      FREEVARLENGTH(p->properties[i].propnames[j]);\n    }\n    free(p->properties[i].propnames);\n  }\n  free(p->properties);\n  p->count = 0;\n}\n#undef FREEVARLENGTH\n\n// Procedures to handle File IO\nint TNEFFile_Open(TNEFIOStruct *IO) {\n  TNEFFileInfo *finfo;\n  finfo = (TNEFFileInfo *)IO->data;\n\n  DEBUG1(finfo->Debug, 3, \"Opening %s\", finfo->filename);\n  if ((finfo->fptr = fopen(finfo->filename, \"rb\")) == NULL) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nint TNEFFile_Read(TNEFIOStruct *IO, int size, int count, void *dest) {\n  TNEFFileInfo *finfo;\n  finfo = (TNEFFileInfo *)IO->data;\n\n  DEBUG2(finfo->Debug, 3, \"Reading %i blocks of %i size\", count, size);\n  if (finfo->fptr != NULL) {\n    return fread((BYTE *)dest, size, count, finfo->fptr);\n  } else {\n    return -1;\n  }\n}\n\nint TNEFFile_Close(TNEFIOStruct *IO) {\n  TNEFFileInfo *finfo;\n  finfo = (TNEFFileInfo *)IO->data;\n\n  DEBUG1(finfo->Debug, 3, \"Closing file %s\", finfo->filename);\n  if (finfo->fptr != NULL) {\n    fclose(finfo->fptr);\n    finfo->fptr = NULL;\n  }\n  return 0;\n}\n\nint TNEFParseFile(char *filename, TNEFStruct *TNEF) {\n  TNEFFileInfo finfo;\n\n  if (TNEF->Debug >= 1)\n    printf(\"Attempting to parse %s...\\n\", filename);\n\n\n  finfo.filename = filename;\n  finfo.fptr = NULL;\n  finfo.Debug = TNEF->Debug;\n  TNEF->IO.data = (void *)&finfo;\n  TNEF->IO.InitProc = TNEFFile_Open;\n  TNEF->IO.ReadProc = TNEFFile_Read;\n  TNEF->IO.CloseProc = TNEFFile_Close;\n  return TNEFParse(TNEF);\n}\n//-------------------------------------------------------------\n// Procedures to handle Memory IO\nint TNEFMemory_Open(TNEFIOStruct *IO) {\n  TNEFMemInfo *minfo;\n  minfo = (TNEFMemInfo *)IO->data;\n\n  minfo->ptr = minfo->dataStart;\n  return 0;\n}\n\nint TNEFMemory_Read(TNEFIOStruct *IO, int size, int count, void *dest) {\n  TNEFMemInfo *minfo;\n  int length;\n  long max;\n  minfo = (TNEFMemInfo *)IO->data;\n\n  length = count * size;\n  max = (minfo->dataStart + minfo->size) - (minfo->ptr);\n  if (length > max) {\n    return -1;\n  }\n\n  DEBUG1(minfo->Debug, 3, \"Copying %i bytes\", length);\n\n  memcpy(dest, minfo->ptr, length);\n  minfo->ptr += length;\n  return count;\n}\n\nint TNEFMemory_Close(TNEFIOStruct *IO) {\n  // Do nothing, really...\n  return 0;\n}\n\nint TNEFParseMemory(BYTE *memory, long size, TNEFStruct *TNEF) {\n  TNEFMemInfo minfo;\n\n  DEBUG(TNEF->Debug, 1, \"Attempting to parse memory block...\\n\");\n\n  minfo.dataStart = memory;\n  minfo.ptr = memory;\n  minfo.size = size;\n  minfo.Debug = TNEF->Debug;\n  TNEF->IO.data = (void *)&minfo;\n  TNEF->IO.InitProc = TNEFMemory_Open;\n  TNEF->IO.ReadProc = TNEFMemory_Read;\n  TNEF->IO.CloseProc = TNEFMemory_Close;\n  return TNEFParse(TNEF);\n}\n\n\nint TNEFParse(TNEFStruct *TNEF) {\n  WORD key;\n  DWORD type;\n  DWORD size;\n  DWORD signature;\n  BYTE *data;\n  WORD checksum, header_checksum;\n  int i;\n\n  if (TNEF->IO.ReadProc == NULL) {\n    printf(\"ERROR: Setup incorrectly: No ReadProc\\n\");\n    return YTNEF_INCORRECT_SETUP;\n  }\n\n  if (TNEF->IO.InitProc != NULL) {\n    DEBUG(TNEF->Debug, 2, \"About to initialize\");\n    if (TNEF->IO.InitProc(&TNEF->IO) != 0) {\n      return YTNEF_CANNOT_INIT_DATA;\n    }\n    DEBUG(TNEF->Debug, 2, \"Initialization finished\");\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Signature\");\n  if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(DWORD), 1, &signature) < 1) {\n    printf(\"ERROR: Error reading signature\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Checking Signature\");\n  if (TNEFCheckForSignature(signature) < 0) {\n    printf(\"ERROR: Signature does not match. Not TNEF.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NOT_TNEF_STREAM;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Key.\");\n\n  if (TNEFGetKey(TNEF, &key) < 0) {\n    printf(\"ERROR: Unable to retrieve key.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NO_KEY;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Starting Full Processing.\");\n\n  while (TNEFGetHeader(TNEF, &type, &size) == 0) {\n    DEBUG2(TNEF->Debug, 2, \"Header says type=0x%X, size=%u\", type, size);\n    DEBUG2(TNEF->Debug, 2, \"Header says type=%u, size=%u\", type, size);\n    if(size == 0) {\n      printf(\"ERROR: Field with size of 0\\n\");\n      return YTNEF_ERROR_READING_DATA;\n    }\n    data = calloc(size, sizeof(BYTE));\n    ALLOCCHECK(data);\n    if (TNEFRawRead(TNEF, data, size, &header_checksum) < 0) {\n      printf(\"ERROR: Unable to read data.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    if (TNEFRawRead(TNEF, (BYTE *)&checksum, 2, NULL) < 0) {\n      printf(\"ERROR: Unable to read checksum.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    checksum = SwapWord((BYTE *)&checksum, sizeof(WORD));\n    if (checksum != header_checksum) {\n      printf(\"ERROR: Checksum mismatch. Data corruption?:\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_BAD_CHECKSUM;\n    }\n    for (i = 0; i < (sizeof(TNEFList) / sizeof(TNEFHandler)); i++) {\n      if (TNEFList[i].id == type) {\n        if (TNEFList[i].handler != NULL) {\n          if (TNEFList[i].handler(TNEF, i, (char*)data, size) < 0) {\n            free(data);\n            if (TNEF->IO.CloseProc != NULL) {\n              TNEF->IO.CloseProc(&TNEF->IO);\n            }\n            return YTNEF_ERROR_IN_HANDLER;\n          } else {\n            //  Found our handler and processed it.  now time to get out\n            break;\n          }\n        } else {\n          DEBUG2(TNEF->Debug, 1, \"No handler for %s: %u bytes\",\n                 TNEFList[i].name, size);\n        }\n      }\n    }\n\n    free(data);\n  }\n\n  if (TNEF->IO.CloseProc != NULL) {\n    TNEF->IO.CloseProc(&TNEF->IO);\n  }\n  return 0;\n\n}\n\n// ----------------------------------------------------------------------------\n\nvariableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {\n  int i;\n  if (p != NULL) {\n    for (i = 0; i < p->count; i++) {\n      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {\n        return (p->properties[i].data);\n      }\n    }\n  }\n  return MAPI_UNDEFINED;\n}\n\nvariableLength *MAPIFindProperty(MAPIProps *p, unsigned int ID) {\n  int i;\n  if (p != NULL) {\n    for (i = 0; i < p->count; i++) {\n      if ((p->properties[i].id == ID) && (p->properties[i].custom == 0)) {\n        return (p->properties[i].data);\n      }\n    }\n  }\n  return MAPI_UNDEFINED;\n}\n\nint MAPISysTimetoDTR(BYTE *data, dtr *thedate) {\n  DDWORD ddword_tmp;\n  int startingdate = 0;\n  int tmp_date;\n  int days_in_year = 365;\n  unsigned int months[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n  ddword_tmp = *((DDWORD *)data);\n  ddword_tmp = ddword_tmp / 10; // micro-s\n  ddword_tmp /= 1000; // ms\n  ddword_tmp /= 1000; // s\n\n  thedate->wSecond = (ddword_tmp % 60);\n\n  ddword_tmp /= 60; // seconds to minutes\n  thedate->wMinute = (ddword_tmp % 60);\n\n  ddword_tmp /= 60; //minutes to hours\n  thedate->wHour = (ddword_tmp % 24);\n\n  ddword_tmp /= 24; // Hours to days\n\n  // Now calculate the year based on # of days\n  thedate->wYear = 1601;\n  startingdate = 1;\n  while (ddword_tmp >= days_in_year) {\n    ddword_tmp -= days_in_year;\n    thedate->wYear++;\n    days_in_year = 365;\n    startingdate++;\n    if ((thedate->wYear % 4) == 0) {\n      if ((thedate->wYear % 100) == 0) {\n        // if the year is 1700,1800,1900, etc, then it is only\n        // a leap year if exactly divisible by 400, not 4.\n        if ((thedate->wYear % 400) == 0) {\n          startingdate++;\n          days_in_year = 366;\n        }\n      }  else {\n        startingdate++;\n        days_in_year = 366;\n      }\n    }\n    startingdate %= 7;\n  }\n\n  // the remaining number is the day # in this year\n  // So now calculate the Month, & Day of month\n  if ((thedate->wYear % 4) == 0) {\n    // 29 days in february in a leap year\n    months[1] = 29;\n  }\n\n  tmp_date = (int)ddword_tmp;\n  thedate->wDayOfWeek = (tmp_date + startingdate) % 7;\n  thedate->wMonth = 0;\n\n  while (tmp_date > months[thedate->wMonth]) {\n    tmp_date -= months[thedate->wMonth];\n    thedate->wMonth++;\n  }\n  thedate->wMonth++;\n  thedate->wDay = tmp_date + 1;\n  return 0;\n}\n\nvoid MAPIPrint(MAPIProps *p) {\n  int j, i, index, h, x;\n  DDWORD *ddword_ptr;\n  DDWORD ddword_tmp;\n  dtr thedate;\n  MAPIProperty *mapi;\n  variableLength *mapidata;\n  variableLength vlTemp;\n  int found;\n\n  for (j = 0; j < p->count; j++) {\n    mapi = &(p->properties[j]);\n    printf(\"   #%i: Type: [\", j);\n    switch (PROP_TYPE(mapi->id)) {\n      case PT_UNSPECIFIED:\n        printf(\"  NONE   \"); break;\n      case PT_NULL:\n        printf(\"  NULL   \"); break;\n      case PT_I2:\n        printf(\"   I2    \"); break;\n      case PT_LONG:\n        printf(\"  LONG   \"); break;\n      case PT_R4:\n        printf(\"   R4    \"); break;\n      case PT_DOUBLE:\n        printf(\" DOUBLE  \"); break;\n      case PT_CURRENCY:\n        printf(\"CURRENCY \"); break;\n      case PT_APPTIME:\n        printf(\"APP TIME \"); break;\n      case PT_ERROR:\n        printf(\"  ERROR  \"); break;\n      case PT_BOOLEAN:\n        printf(\" BOOLEAN \"); break;\n      case PT_OBJECT:\n        printf(\" OBJECT  \"); break;\n      case PT_I8:\n        printf(\"   I8    \"); break;\n      case PT_STRING8:\n        printf(\" STRING8 \"); break;\n      case PT_UNICODE:\n        printf(\" UNICODE \"); break;\n      case PT_SYSTIME:\n        printf(\"SYS TIME \"); break;\n      case PT_CLSID:\n        printf(\"OLE GUID \"); break;\n      case PT_BINARY:\n        printf(\" BINARY  \"); break;\n      default:\n        printf(\"<%x>\", PROP_TYPE(mapi->id)); break;\n    }\n\n    printf(\"]  Code: [\");\n    if (mapi->custom == 1) {\n      printf(\"UD:x%04x\", PROP_ID(mapi->id));\n    } else {\n      found = 0;\n      for (index = 0; index < sizeof(MPList) / sizeof(MAPIPropertyTagList); index++) {\n        if ((MPList[index].id == PROP_ID(mapi->id)) && (found == 0)) {\n          printf(\"%s\", MPList[index].name);\n          found = 1;\n        }\n      }\n      if (found == 0) {\n        printf(\"0x%04x\", PROP_ID(mapi->id));\n      }\n    }\n    printf(\"]\\n\");\n    if (mapi->namedproperty > 0) {\n      for (i = 0; i < mapi->namedproperty; i++) {\n        printf(\"    Name: %s\\n\", mapi->propnames[i].data);\n      }\n    }\n    for (i = 0; i < mapi->count; i++) {\n      mapidata = &(mapi->data[i]);\n      if (mapi->count > 1) {\n        printf(\"    [%i/%u] \", i, mapi->count);\n      } else {\n        printf(\"    \");\n      }\n      printf(\"Size: %i\", mapidata->size);\n      switch (PROP_TYPE(mapi->id)) {\n        case PT_SYSTIME:\n          MAPISysTimetoDTR(mapidata->data, &thedate);\n          printf(\"    Value: \");\n          ddword_tmp = *((DDWORD *)mapidata->data);\n          TNEFPrintDate(thedate);\n          printf(\" [HEX: \");\n          for (x = 0; x < sizeof(ddword_tmp); x++) {\n            printf(\" %02x\", (BYTE)mapidata->data[x]);\n          }\n          printf(\"] (%llu)\\n\", ddword_tmp);\n          break;\n        case PT_LONG:\n          printf(\"    Value: %i\\n\", *((int*)mapidata->data));\n          break;\n        case PT_I2:\n          printf(\"    Value: %hi\\n\", *((short int*)mapidata->data));\n          break;\n        case PT_BOOLEAN:\n          if (mapi->data->data[0] != 0) {\n            printf(\"    Value: True\\n\");\n          } else {\n            printf(\"    Value: False\\n\");\n          }\n          break;\n        case PT_OBJECT:\n          printf(\"\\n\");\n          break;\n        case PT_BINARY:\n          if (IsCompressedRTF(mapidata) == 1) {\n            printf(\"    Detected Compressed RTF. \");\n            printf(\"Decompressed text follows\\n\");\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n            if ((vlTemp.data = (BYTE*)DecompressRTF(mapidata, &(vlTemp.size))) != NULL) {\n              printf(\"%s\\n\", vlTemp.data);\n              free(vlTemp.data);\n            }\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n          } else {\n            printf(\"    Value: [\");\n            for (h = 0; h < mapidata->size; h++) {\n              if (isprint(mapidata->data[h])) {\n                printf(\"%c\", mapidata->data[h]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case PT_STRING8:\n          printf(\"    Value: [%s]\\n\", mapidata->data);\n          if (strlen((char*)mapidata->data) != mapidata->size - 1) {\n            printf(\"Detected Hidden data: [\");\n            for (h = 0; h < mapidata->size; h++) {\n              if (isprint(mapidata->data[h])) {\n                printf(\"%c\", mapidata->data[h]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case PT_CLSID:\n          printf(\"    Value: \");\n          printf(\"[HEX: \");\n          for(x=0; x< 16; x++) {\n            printf(\" %02x\", (BYTE)mapidata->data[x]);\n          }\n          printf(\"]\\n\");\n          break;\n        default:\n          printf(\"    Value: [%s]\\n\", mapidata->data);\n      }\n    }\n  }\n}\n\n\nint IsCompressedRTF(variableLength *p) {\n  unsigned int in;\n  BYTE *src;\n  ULONG magic;\n\n  if (p->size < 4)\n    return 0;\n\n  src = p->data;\n  in = 0;\n\n  in += 4;\n  in += 4;\n  magic = SwapDWord((BYTE*)src + in, 4);\n\n  if (magic == 0x414c454d) {\n    return 1;\n  } else if (magic == 0x75465a4c) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nBYTE *DecompressRTF(variableLength *p, int *size) {\n  BYTE *dst; // destination for uncompressed bytes\n  BYTE *src;\n  unsigned int in;\n  unsigned int out;\n  variableLength comp_Prebuf;\n  ULONG compressedSize, uncompressedSize, magic;\n\n  comp_Prebuf.size = strlen(RTF_PREBUF);\n  comp_Prebuf.data = calloc(comp_Prebuf.size+1, 1);\n  ALLOCCHECK_CHAR(comp_Prebuf.data);\n  memcpy(comp_Prebuf.data, RTF_PREBUF, comp_Prebuf.size);\n\n  src = p->data;\n  in = 0;\n\n  if (p->size < 20) {\n    printf(\"File too small\\n\");\n    return(NULL);\n  }\n  compressedSize = (ULONG)SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  uncompressedSize = (ULONG)SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  magic = SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  in += 4;\n\n  // check size excluding the size field itself\n  if (compressedSize != p->size - 4) {\n    printf(\" Size Mismatch: %u != %i\\n\", compressedSize, p->size - 4);\n    free(comp_Prebuf.data);\n    return NULL;\n  }\n\n  // process the data\n  if (magic == 0x414c454d) {\n    // magic number that identifies the stream as a uncompressed stream\n    dst = calloc(uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, src + 4, uncompressedSize);\n  } else if (magic == 0x75465a4c) {\n    // magic number that identifies the stream as a compressed stream\n    int flagCount = 0;\n    int flags = 0;\n    // Prevent overflow on 32 Bit Systems\n    if (comp_Prebuf.size >= INT_MAX - uncompressedSize) {\n       printf(\"Corrupted file\\n\");\n       exit(-1);\n    }\n    dst = calloc(comp_Prebuf.size + uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, comp_Prebuf.data, comp_Prebuf.size);\n    out = comp_Prebuf.size;\n    while (out < (comp_Prebuf.size + uncompressedSize)) {\n      // each flag byte flags 8 literals/references, 1 per bit\n      flags = (flagCount++ % 8 == 0) ? src[in++] : flags >> 1;\n      if ((flags & 1) == 1) { // each flag bit is 1 for reference, 0 for literal\n        unsigned int offset = src[in++];\n        unsigned int length = src[in++];\n        unsigned int end;\n        offset = (offset << 4) | (length >> 4); // the offset relative to block start\n        length = (length & 0xF) + 2; // the number of bytes to copy\n        // the decompression buffer is supposed to wrap around back\n        // to the beginning when the end is reached. we save the\n        // need for such a buffer by pointing straight into the data\n        // buffer, and simulating this behaviour by modifying the\n        // pointers appropriately.\n        offset = (out / 4096) * 4096 + offset;\n        if (offset >= out) // take from previous block\n          offset -= 4096;\n        // note: can't use System.arraycopy, because the referenced\n        // bytes can cross through the current out position.\n        end = offset + length;\n        while ((offset < end) && (out < (comp_Prebuf.size + uncompressedSize))\n             && (offset < (comp_Prebuf.size + uncompressedSize)))\n          dst[out++] = dst[offset++];\n      } else { // literal\n        if ((out >= (comp_Prebuf.size + uncompressedSize)) ||\n            (in >= p->size)) {\n          printf(\"Corrupted stream\\n\");\n          exit(-1);\n        }\n        dst[out++] = src[in++];\n      }\n    }\n    // copy it back without the prebuffered data\n    src = dst;\n    dst = calloc(uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, src + comp_Prebuf.size, uncompressedSize);\n    free(src);\n    *size = uncompressedSize;\n    free(comp_Prebuf.data);\n    return dst;\n  } else { // unknown magic number\n    printf(\"Unknown compression type (magic number %x)\\n\", magic);\n  }\n  free(comp_Prebuf.data);\n  return NULL;\n}\n"], "fixing_code": ["v1.9.2 - February 23, 2017 \n\nThanks to @hannob for finding some Out-of-bound exceptions in memory handline.\n* [SECURITY] An invalid memory access (heap overrun) in handling LONG datatypes\n* [SECURITY] Missing a check for fields of size 0\n* [SECURITY] Potential buffer overrun on incoming Compressed RTF Streams\n\nThis version  & the previous 1.9.1 resolves the following CVEs:\n* CVE-2017-6306\n* CVE-2017-6305\n* CVE-2017-6304\n* CVE-2017-6303\n* CVE-2017-6302\n* CVE-2017-6301\n* CVE-2017-6300\n* CVE-2017-6299\n* CVE-2017-6298\n\nv1.9.1 - Feb 14, 2017\n* BugFix for path handling- label both / and \\ as invalid characters inattachments\n* Remove lots of exit(-1)'s from the code that would crash calling programs\n* [SECURITY] Thanks to EricSesterhennX41 for a patch to fix lots of invalid\nmemory allocation around corrupted files.\n\nv1.9 - January 2, 2017\n* Unify libytnef and ytnef tools into a single build & package (Thanks @jmallach)\n* Fix applied for CVE-2010-5109\n* Various fixes for errors found via Static Analysis (cppcheck)\n* Various memory leaks plugged (Thanks @slonik-v-domene)\n* Bugfix for a broken \"uniqueness\" checker\n* Lots of formatting & documentation cleanups\n\nNow that the two packages are unified into a single install & build, I've had\nto choose a unifier of Version Numbers.  I chose 1.9 .\n\n\n\n\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv2.7\nMark Paulus -- Better processing of filenames, to eliminate problem-causing characters.\nHilmar - Update to the autoconf scripts to check for a valid ytneflib install during the configuration.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv2.6\nMinor Documentation changes.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv2.5\nImplemented Recurrence support, using patches & information from Viraj Alankar\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv2.4\nRearranged the ATTENDEE field adding the RSVP & PARTSTAT entries.\nRemoved the opening & trailing curly braces from the description.\nMade the UID uppercase.\nAdded both CN & MAILTO to ORGANIZER field.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv2.3\nThanks to Jason for pointing me toward jtnef, with which I was finally able to\nfinish compressed RTF support.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv2.2\nNeed to start updating this file more often. Sorry guys.\nThis release adds support for Contact cards with no name field.  So now if you\nhave contact cards with no name, but just a Company, those will work.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.15\nMade a change to fill spaces in filenames with underscores.\nSplit the vcard/vcal/vtask code into separate files for better readability.\nConverted to automake (Autoconf, etc)\nRemoved the run-time \"endian\" detection, in favor of WORD_BIGENDIAN\nPlaced version information to be automatically generated into config.h\nAdded an abstraction layer on IO\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.14\nMade a change to save vCard entries with a .vcard extension instead of a .vcf\nextension.  This way I can detect it in ytnefprocess.pl and mark it as a type\ntext/x-vcard instead of text/vcalendar.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.13\nFixed a problem in the checking of existence.  Should have been\n(variableLength*)-1 instead of NULL.. Made MAPI_UNDEFINED to keep this\nfrom happening again.  This fixed an issue with segfaulting on certain task\nrequests when a start/due date wasn't specified.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.12\nFixed a problem with recurring calendar entries, occasionally have incorrect\nstart dates.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.11\nFixed a problem with vCalendar entries using C-Style strings instead of\nquoted-printable strings.\nFixed a mis-spelled field name in vCalendar entries (DCREATED vs CREATED)\nAdded support for Start/Due date on Task entries.\nAdded support for a UID to task entries (untested).\nAdded support for Private/Public on Task Entries (untested).\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.10\nAdded attendee & organizer fields to Task Entries.\nAdded support for meeting cancellations.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.09\nMade the Notes field of vCard's & the summary field of vCalendar entries\nquoted-printable.\nAdded a : to the end of meeting attendees.\nFixed a problem with meeting requests that didn't separate required & optional\nparticipants.\nAdded code to use C-style \\n's instead of quoted-printable encoding in task\nrequests.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.08\nCode refactoring in the vCard section to improve readability.\nMade the addresses in vCards quoted printable to better support user input.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.07\nAdded the -L option for tnefclean.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.06\nFix for the CN & ROLE being reversed in required participants of meetings.\nAdded the -l option for tnefclean.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.05 \nAdded the -F option to enable/disable the RTF attachments.\nIntegrated patch #666566: Unicode to UTF8 conversion.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.04 1-11-2003\nAdded code to use the PR_SENDER_SEARCH_KEY as the organizer\n        of vcalendar objects.\nFixed glitch with the From handler & the Message Class handler both\n        storing in the same namespace.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.03 1-5-2003\nMore endian fixes, now finally works on PowerPC.\nModified the main.c to place the printing in a separate file.\nAdded support for embedded TNEF streams.\nMoved the vCalendar to a separate procedure (for readability)\nAdded the vCard 2.1 code, with the special X-EVOLUTION extensions\n        for the extra properties.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.02 12-27-2002\nMore fixes for the Endian problem, additions to the file-reading routines.\nFixed warnings.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.01 12-27-2002\nMakefile cleanup - Removed references to openGL, Glut, & X libraries.\nAdditions to help (-h).\nFixes to make it run on Alpha architecture.\nFirst attempt at fixing the Big Endian/Little Endian issue.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nv1.0 12-26-2002\nInitial Release\n", "/*\n*    Yerase's TNEF Stream Reader Library\n*    Copyright (C) 2003  Randall E. Hand\n*\n*    This program is free software; you can redistribute it and/or modify\n*    it under the terms of the GNU General Public License as published by\n*    the Free Software Foundation; either version 2 of the License, or\n*    (at your option) any later version.\n*\n*    This program is distributed in the hope that it will be useful,\n*    but WITHOUT ANY WARRANTY; without even the implied warranty of\n*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n*    GNU General Public License for more details.\n*\n*    You should have received a copy of the GNU General Public License\n*    along with this program; if not, write to the Free Software\n*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*\n*    You can contact me at randall.hand@gmail.com for questions or assistance\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <limits.h>\n#include \"ytnef.h\"\n#include \"tnef-errors.h\"\n#include \"mapi.h\"\n#include \"mapidefs.h\"\n#include \"mapitags.h\"\n#include \"config.h\"\n\n#define RTF_PREBUF \"{\\\\rtf1\\\\ansi\\\\mac\\\\deff0\\\\deftab720{\\\\fonttbl;}{\\\\f0\\\\fnil \\\\froman \\\\fswiss \\\\fmodern \\\\fscript \\\\fdecor MS Sans SerifSymbolArialTimes New RomanCourier{\\\\colortbl\\\\red0\\\\green0\\\\blue0\\n\\r\\\\par \\\\pard\\\\plain\\\\f0\\\\fs20\\\\b\\\\i\\\\u\\\\tab\\\\tx\"\n#define DEBUG(lvl, curlvl, msg) \\\n        if ((lvl) >= (curlvl)) \\\n            printf(\"DEBUG(%i/%i): %s\\n\", curlvl, lvl,  msg);\n#define DEBUG1(lvl, curlvl, msg, var1) \\\n        if ((lvl) >= (curlvl)) { \\\n            printf(\"DEBUG(%i/%i):\", curlvl, lvl); \\\n            printf(msg, var1); \\\n            printf(\"\\n\"); \\\n        }\n#define DEBUG2(lvl, curlvl, msg, var1, var2) \\\n        if ((lvl) >= (curlvl)) { \\\n            printf(\"DEBUG(%i/%i):\", curlvl, lvl); \\\n            printf(msg, var1, var2); \\\n            printf(\"\\n\"); \\\n        }\n#define DEBUG3(lvl, curlvl, msg, var1, var2, var3) \\\n        if ((lvl) >= (curlvl)) { \\\n            printf(\"DEBUG(%i/%i):\", curlvl, lvl); \\\n            printf(msg, var1, var2,var3); \\\n            printf(\"\\n\"); \\\n        }\n\n#define MIN(x,y) (((x)<(y))?(x):(y))\n\n#define ALLOCCHECK(x) { if(!x) { printf(\"Out of Memory at %s : %i\\n\", __FILE__, __LINE__); return(-1); } }\n#define ALLOCCHECK_CHAR(x) { if(!x) { printf(\"Out of Memory at %s : %i\\n\", __FILE__, __LINE__); return(NULL); } }\n#define SIZECHECK(x) { if ((((char *)d - (char *)data) + x) > size) {  printf(\"Corrupted file detected at %s : %i\\n\", __FILE__, __LINE__); return(-1); } }\n\nint TNEFFillMapi(TNEFStruct *TNEF, BYTE *data, DWORD size, MAPIProps *p);\nvoid SetFlip(void);\n\nint TNEFDefaultHandler STD_ARGLIST;\nint TNEFAttachmentFilename STD_ARGLIST;\nint TNEFAttachmentSave STD_ARGLIST;\nint TNEFDetailedPrint STD_ARGLIST;\nint TNEFHexBreakdown STD_ARGLIST;\nint TNEFBody STD_ARGLIST;\nint TNEFRendData STD_ARGLIST;\nint TNEFDateHandler STD_ARGLIST;\nint TNEFPriority  STD_ARGLIST;\nint TNEFVersion  STD_ARGLIST;\nint TNEFMapiProperties STD_ARGLIST;\nint TNEFIcon STD_ARGLIST;\nint TNEFSubjectHandler STD_ARGLIST;\nint TNEFFromHandler STD_ARGLIST;\nint TNEFRecipTable STD_ARGLIST;\nint TNEFAttachmentMAPI STD_ARGLIST;\nint TNEFSentFor STD_ARGLIST;\nint TNEFMessageClass STD_ARGLIST;\nint TNEFMessageID STD_ARGLIST;\nint TNEFParentID STD_ARGLIST;\nint TNEFOriginalMsgClass STD_ARGLIST;\nint TNEFCodePage STD_ARGLIST;\n\n\nBYTE *TNEFFileContents = NULL;\nDWORD TNEFFileContentsSize;\nBYTE *TNEFFileIcon = NULL;\nDWORD TNEFFileIconSize;\n\nint IsCompressedRTF(variableLength *p);\n\nTNEFHandler TNEFList[] = {\n  {attNull,                    \"Null\",                        TNEFDefaultHandler},\n  {attFrom,                    \"From\",                        TNEFFromHandler},\n  {attSubject,                 \"Subject\",                     TNEFSubjectHandler},\n  {attDateSent,                \"Date Sent\",                   TNEFDateHandler},\n  {attDateRecd,                \"Date Received\",               TNEFDateHandler},\n  {attMessageStatus,           \"Message Status\",              TNEFDefaultHandler},\n  {attMessageClass,            \"Message Class\",               TNEFMessageClass},\n  {attMessageID,               \"Message ID\",                  TNEFMessageID},\n  {attParentID,                \"Parent ID\",                   TNEFParentID},\n  {attConversationID,          \"Conversation ID\",             TNEFDefaultHandler},\n  {attBody,                    \"Body\",                        TNEFBody},\n  {attPriority,                \"Priority\",                    TNEFPriority},\n  {attAttachData,              \"Attach Data\",                 TNEFAttachmentSave},\n  {attAttachTitle,             \"Attach Title\",                TNEFAttachmentFilename},\n  {attAttachMetaFile,          \"Attach Meta-File\",            TNEFIcon},\n  {attAttachCreateDate,        \"Attachment Create Date\",      TNEFDateHandler},\n  {attAttachModifyDate,        \"Attachment Modify Date\",      TNEFDateHandler},\n  {attDateModified,            \"Date Modified\",               TNEFDateHandler},\n  {attAttachTransportFilename, \"Attachment Transport name\",   TNEFDefaultHandler},\n  {attAttachRenddata,          \"Attachment Display info\",     TNEFRendData},\n  {attMAPIProps,               \"MAPI Properties\",             TNEFMapiProperties},\n  {attRecipTable,              \"Recip Table\",                 TNEFRecipTable},\n  {attAttachment,              \"Attachment\",                  TNEFAttachmentMAPI},\n  {attTnefVersion,             \"TNEF Version\",                TNEFVersion},\n  {attOemCodepage,             \"OEM CodePage\",                TNEFCodePage},\n  {attOriginalMessageClass,    \"Original Message Class\",      TNEFOriginalMsgClass},\n  {attOwner,                   \"Owner\",                       TNEFDefaultHandler},\n  {attSentFor,                 \"Sent For\",                    TNEFSentFor},\n  {attDelegate,                \"Delegate\",                    TNEFDefaultHandler},\n  {attDateStart,               \"Date Start\",                  TNEFDateHandler},\n  {attDateEnd,                 \"Date End\",                    TNEFDateHandler},\n  {attAidOwner,                \"Aid Owner\",                   TNEFDefaultHandler},\n  {attRequestRes,              \"Request Response\",            TNEFDefaultHandler}\n};\n\n\nWORD SwapWord(BYTE *p, int size) {\n  union BYTES2WORD\n  {\n      WORD word;\n      BYTE bytes[sizeof(WORD)];\n  };\n  \n  union BYTES2WORD converter;  \n  converter.word = 0;\n  int i = 0;\n  int correct = size > sizeof(WORD) ? sizeof(WORD) : size;\n\n#ifdef WORDS_BIGENDIAN\n  for (i = 0; i < correct; ++i)\n  {\n      converter.bytes[i] = p[correct - i];\n  }\n#else\n  for (i = 0; i < correct; ++i)\n  {\n      converter.bytes[i] = p[i];\n  }\n#endif\n  \n  return converter.word;\n}\n\nDWORD SwapDWord(BYTE *p, int size) {\n  union BYTES2DWORD\n  {\n      DWORD dword;\n      BYTE  bytes[sizeof(DWORD)];\n  };\n  \n  union BYTES2DWORD converter;\n  converter.dword = 0;\n  int i = 0;  \n  int correct = size > sizeof(DWORD) ? sizeof(DWORD) : size;\n  \n#ifdef WORDS_BIGENDIAN\n  for (i = 0; i < correct; ++i)\n  {\n      converter.bytes[i] = p[correct - i];\n  }\n#else\n  for (i = 0; i < correct; ++i)\n  {\n      converter.bytes[i] = p[i];\n  }\n#endif\n  \n  return converter.dword;\n}\n\n\n\nDDWORD SwapDDWord(BYTE *p, int size) {\n  union BYTES2DDWORD\n  {\n      DDWORD ddword;\n      BYTE   bytes[sizeof(DDWORD)];\n  };\n  \n  union BYTES2DDWORD converter;\n  converter.ddword = 0;\n  int i = 0;  \n  int correct = size > sizeof(DDWORD) ? sizeof(DDWORD) : size;\n  \n#ifdef WORDS_BIGENDIAN\n  for (i = 0; i < correct; ++i)\n  {\n      converter.bytes[i] = p[correct - i];\n  }\n#else\n  for (i = 0; i < correct; ++i)\n  {\n      converter.bytes[i] = p[i];\n  }\n#endif\n  \n  return converter.ddword;\n}\n\n/* convert 16-bit unicode to UTF8 unicode */\nchar *to_utf8(size_t len, char *buf) {\n  int i, j = 0;\n  /* worst case length */\n  if (len > 10000) {\t// deal with this by adding an arbitrary limit\n     printf(\"suspecting a corrupt file in UTF8 conversion\\n\");\n     exit(-1);\n  }\n  char *utf8 = malloc(3 * len / 2 + 1);\n\n  for (i = 0; i < len - 1; i += 2) {\n    unsigned int c = SwapWord((BYTE *)buf + i, 2);\n    if (c <= 0x007f) {\n      utf8[j++] = 0x00 | ((c & 0x007f) >> 0);\n    } else if (c < 0x07ff) {\n      utf8[j++] = 0xc0 | ((c & 0x07c0) >> 6);\n      utf8[j++] = 0x80 | ((c & 0x003f) >> 0);\n    } else {\n      utf8[j++] = 0xe0 | ((c & 0xf000) >> 12);\n      utf8[j++] = 0x80 | ((c & 0x0fc0) >> 6);\n      utf8[j++] = 0x80 | ((c & 0x003f) >> 0);\n    }\n  }\n\n  /* just in case the original was not null terminated */\n  utf8[j++] = '\\0';\n\n  return utf8;\n}\n\n\n// -----------------------------------------------------------------------------\nint TNEFDefaultHandler STD_ARGLIST {\n  if (TNEF->Debug >= 1)\n    printf(\"%s: [%i] %s\\n\", TNEFList[id].name, size, data);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFCodePage STD_ARGLIST {\n  TNEF->CodePage.size = size;\n  TNEF->CodePage.data = calloc(size, sizeof(BYTE));\n  ALLOCCHECK(TNEF->CodePage.data);\n  memcpy(TNEF->CodePage.data, data, size);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFParentID STD_ARGLIST {\n  memcpy(TNEF->parentID, data, MIN(size, sizeof(TNEF->parentID)));\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFMessageID STD_ARGLIST {\n  memcpy(TNEF->messageID, data, MIN(size, sizeof(TNEF->messageID)));\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFBody STD_ARGLIST {\n  TNEF->body.size = size;\n  TNEF->body.data = calloc(size, sizeof(BYTE));\n  ALLOCCHECK(TNEF->body.data);\n  memcpy(TNEF->body.data, data, size);\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFOriginalMsgClass STD_ARGLIST {\n  TNEF->OriginalMessageClass.size = size;\n  TNEF->OriginalMessageClass.data = calloc(size, sizeof(BYTE));\n  ALLOCCHECK(TNEF->OriginalMessageClass.data);\n  memcpy(TNEF->OriginalMessageClass.data, data, size);\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFMessageClass STD_ARGLIST {\n  memcpy(TNEF->messageClass, data, MIN(size, sizeof(TNEF->messageClass)));\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFFromHandler STD_ARGLIST {\n  TNEF->from.data = calloc(size, sizeof(BYTE));\n  ALLOCCHECK(TNEF->from.data);\n  TNEF->from.size = size;\n  memcpy(TNEF->from.data, data, size);\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFSubjectHandler STD_ARGLIST {\n  if (TNEF->subject.data)\n    free(TNEF->subject.data);\n\n  TNEF->subject.data = calloc(size, sizeof(BYTE));\n  ALLOCCHECK(TNEF->subject.data);\n  TNEF->subject.size = size;\n  memcpy(TNEF->subject.data, data, size);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFRendData STD_ARGLIST {\n  Attachment *p;\n  // Find the last attachment.\n  p = &(TNEF->starting_attach);\n  while (p->next != NULL) p = p->next;\n\n  // Add a new one\n  p->next = calloc(1, sizeof(Attachment));\n  ALLOCCHECK(p->next);\n  p = p->next;\n\n  TNEFInitAttachment(p);\n\n int correct = (size >= sizeof(renddata)) ? sizeof(renddata) : size;\n  memcpy(&(p->RenderData), data, correct);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFVersion STD_ARGLIST {\n  WORD major;\n  WORD minor;\n  minor = SwapWord((BYTE*)data, size);\n  major = SwapWord((BYTE*)data + 2, size - 2);\n\n  snprintf(TNEF->version, sizeof(TNEF->version), \"TNEF%i.%i\", major, minor);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFIcon STD_ARGLIST {\n  Attachment *p;\n  // Find the last attachment.\n  p = &(TNEF->starting_attach);\n  while (p->next != NULL) p = p->next;\n\n  p->IconData.size = size;\n  p->IconData.data = calloc(size, sizeof(BYTE));\n  ALLOCCHECK(p->IconData.data);\n  memcpy(p->IconData.data, data, size);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFRecipTable STD_ARGLIST {\n  DWORD count;\n  BYTE *d;\n  int current_row;\n  int propcount;\n  int current_prop;\n\n  d = (BYTE*)data;\n  count = SwapDWord((BYTE*)d, 4);\n  d += 4;\n//    printf(\"Recipient Table containing %u rows\\n\", count);\n\n  return 0;\n\n  for (current_row = 0; current_row < count; current_row++) {\n    propcount = SwapDWord((BYTE*)d, 4);\n    if (TNEF->Debug >= 1)\n      printf(\"> Row %i contains %i properties\\n\", current_row, propcount);\n    d += 4;\n    for (current_prop = 0; current_prop < propcount; current_prop++) {\n\n\n    }\n  }\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFAttachmentMAPI STD_ARGLIST {\n  Attachment *p;\n  // Find the last attachment.\n  //\n  p = &(TNEF->starting_attach);\n  while (p->next != NULL) p = p->next;\n  return TNEFFillMapi(TNEF, (BYTE*)data, size, &(p->MAPI));\n}\n// -----------------------------------------------------------------------------\nint TNEFMapiProperties STD_ARGLIST {\n  if (TNEFFillMapi(TNEF, (BYTE*)data, size, &(TNEF->MapiProperties)) < 0) {\n    printf(\"ERROR Parsing MAPI block\\n\");\n    return -1;\n  };\n  if (TNEF->Debug >= 3) {\n    MAPIPrint(&(TNEF->MapiProperties));\n  }\n  return 0;\n}\n\nint TNEFFillMapi(TNEFStruct *TNEF, BYTE *data, DWORD size, MAPIProps *p) {\n  int i, j;\n  DWORD num;\n  BYTE *d;\n  MAPIProperty *mp;\n  DWORD type;\n  DWORD length;\n  variableLength *vl;\n\n  WORD temp_word;\n  DWORD temp_dword;\n  DDWORD temp_ddword;\n  int count = -1;\n  int offset;\n\n  d = data;\n  p->count = SwapDWord((BYTE*)data, 4);\n  d += 4;\n  p->properties = calloc(p->count, sizeof(MAPIProperty));\n  ALLOCCHECK(p->properties);\n  mp = p->properties;\n\n  for (i = 0; i < p->count; i++) {\n    if (count == -1) {\n      mp->id = SwapDWord((BYTE*)d, 4);\n      d += 4;\n      mp->custom = 0;\n      mp->count = 1;\n      mp->namedproperty = 0;\n      length = -1;\n      if (PROP_ID(mp->id) >= 0x8000) {\n        // Read the GUID\n        SIZECHECK(16);\n        memcpy(&(mp->guid[0]), d, 16);\n        d += 16;\n\n        SIZECHECK(4);\n        length = SwapDWord((BYTE*)d, 4);\n        d += sizeof(DWORD);\n        if (length > 0) {\n          mp->namedproperty = length;\n          mp->propnames = calloc(length, sizeof(variableLength));\n          ALLOCCHECK(mp->propnames);\n          while (length > 0) {\n            SIZECHECK(4);\n            type = SwapDWord((BYTE*)d, 4);\n            mp->propnames[length - 1].data = calloc(type, sizeof(BYTE));\n            ALLOCCHECK(mp->propnames[length - 1].data);\n            mp->propnames[length - 1].size = type;\n            d += 4;\n            for (j = 0; j < (type >> 1); j++) {\n              SIZECHECK(j*2);\n              mp->propnames[length - 1].data[j] = d[j * 2];\n            }\n            d += type + ((type % 4) ? (4 - type % 4) : 0);\n            length--;\n          }\n        } else {\n          // READ the type\n          SIZECHECK(sizeof(DWORD));\n          type = SwapDWord((BYTE*)d, sizeof(DWORD));\n          d += sizeof(DWORD);\n          mp->id = PROP_TAG(PROP_TYPE(mp->id), type);\n        }\n        mp->custom = 1;\n      }\n\n      DEBUG2(TNEF->Debug, 3, \"Type id = %04x, Prop id = %04x\", PROP_TYPE(mp->id),\n             PROP_ID(mp->id));\n      if (PROP_TYPE(mp->id) & MV_FLAG) {\n        mp->id = PROP_TAG(PROP_TYPE(mp->id) - MV_FLAG, PROP_ID(mp->id));\n        SIZECHECK(4);\n        mp->count = SwapDWord((BYTE*)d, 4);\n        d += 4;\n        count = 0;\n      }\n      mp->data = calloc(mp->count, sizeof(variableLength));\n      ALLOCCHECK(mp->data);\n      vl = mp->data;\n    } else {\n      i--;\n      count++;\n      vl = &(mp->data[count]);\n    }\n\n    switch (PROP_TYPE(mp->id)) {\n      case PT_BINARY:\n      case PT_OBJECT:\n      case PT_STRING8:\n      case PT_UNICODE:\n        // First number of objects (assume 1 for now)\n        if (count == -1) {\n          SIZECHECK(4);\n          vl->size = SwapDWord((BYTE*)d, 4);\n          d += 4;\n        }\n        // now size of object\n        SIZECHECK(4);\n        vl->size = SwapDWord((BYTE*)d, 4);\n        d += 4;\n\n        // now actual object\n        if (vl->size != 0) {    \n         SIZECHECK(vl->size);\n         if (PROP_TYPE(mp->id) == PT_UNICODE) {\n                vl->data =(BYTE*) to_utf8(vl->size, (char*)d);\n            } else {\n              vl->data = calloc(vl->size, sizeof(BYTE));\n              ALLOCCHECK(vl->data);\n              memcpy(vl->data, d, vl->size);\n            }\n        } else {\n          vl->data = NULL;\n        }\n\n        // Make sure to read in a multiple of 4\n        num = vl->size;\n        offset = ((num % 4) ? (4 - num % 4) : 0);\n        d += num + ((num % 4) ? (4 - num % 4) : 0);\n        break;\n\n      case PT_I2:\n        // Read in 2 bytes, but proceed by 4 bytes\n        vl->size = 2;\n        vl->data = calloc(vl->size, sizeof(WORD));\n        ALLOCCHECK(vl->data);\n        SIZECHECK(sizeof(WORD))\n        temp_word = SwapWord((BYTE*)d, sizeof(WORD));\n        memcpy(vl->data, &temp_word, vl->size);\n        d += 4;\n        break;\n      case PT_BOOLEAN:\n      case PT_LONG:\n      case PT_R4:\n      case PT_CURRENCY:\n      case PT_APPTIME:\n      case PT_ERROR:\n        vl->size = 4;\n        vl->data = calloc(vl->size, sizeof(BYTE));\n        ALLOCCHECK(vl->data);\n        SIZECHECK(4);\n        temp_dword = SwapDWord((BYTE*)d, 4);\n        memcpy(vl->data, &temp_dword, vl->size);\n        d += 4;\n        break;\n      case PT_DOUBLE:\n      case PT_I8:\n      case PT_SYSTIME:\n        vl->size = 8;\n        vl->data = calloc(vl->size, sizeof(BYTE));\n        ALLOCCHECK(vl->data);\n        SIZECHECK(8);\n        temp_ddword = SwapDDWord(d, 8);\n        memcpy(vl->data, &temp_ddword, vl->size);\n        d += 8;\n        break;\n      case PT_CLSID:\n        vl->size = 16;\n        vl->data = calloc(vl->size, sizeof(BYTE));\n        ALLOCCHECK(vl->data);\n        SIZECHECK(vl->size);\n        memcpy(vl->data, d, vl->size);\n        d+=16;\n        break;\n      default:\n        printf(\"Bad file\\n\");\n        exit(-1);\n    }\n\n    switch (PROP_ID(mp->id)) {\n      case PR_SUBJECT:\n      case PR_SUBJECT_IPM:\n      case PR_ORIGINAL_SUBJECT:\n      case PR_NORMALIZED_SUBJECT:\n      case PR_CONVERSATION_TOPIC:\n        DEBUG(TNEF->Debug, 3, \"Got a Subject\");\n        if (TNEF->subject.size == 0) {\n          int i;\n          DEBUG(TNEF->Debug, 3, \"Assigning a Subject\");\n          TNEF->subject.data = calloc(size, sizeof(BYTE));\n          ALLOCCHECK(TNEF->subject.data);\n          TNEF->subject.size = vl->size;\n          memcpy(TNEF->subject.data, vl->data, vl->size);\n          //  Unfortunately, we have to normalize out some invalid\n          //  characters, or else the file won't write\n          for (i = 0; i != TNEF->subject.size; i++) {\n            switch (TNEF->subject.data[i]) {\n              case '\\\\':\n              case '/':\n              case '\\0':\n                TNEF->subject.data[i] = '_';\n                break;\n            }\n          }\n        }\n        break;\n    }\n\n    if (count == (mp->count - 1)) {\n      count = -1;\n    }\n    if (count == -1) {\n      mp++;\n    }\n\n  }\n  if ((d - data) < size) {\n    if (TNEF->Debug >= 1)  {\n      printf(\"ERROR DURING MAPI READ\\n\");\n      printf(\"Read %td bytes, Expected %u bytes\\n\", (d - data), size);\n      printf(\"%td bytes missing\\n\", size - (d - data));\n    }\n  } else if ((d - data) > size) {\n    if (TNEF->Debug >= 1)  {\n      printf(\"ERROR DURING MAPI READ\\n\");\n      printf(\"Read %td bytes, Expected %u bytes\\n\", (d - data), size);\n      printf(\"%li bytes extra\\n\", (d - data) - size);\n    }\n  }\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFSentFor STD_ARGLIST {\n  WORD name_length, addr_length;\n  BYTE *d;\n\n  d = (BYTE*)data;\n\n  while ((d - (BYTE*)data) < size) {\n    SIZECHECK(sizeof(WORD));\n    name_length = SwapWord((BYTE*)d, sizeof(WORD));\n    d += sizeof(WORD);\n    if (TNEF->Debug >= 1)\n      printf(\"Sent For : %s\", d);\n    d += name_length;\n\n    SIZECHECK(sizeof(WORD));\n    addr_length = SwapWord((BYTE*)d, sizeof(WORD));\n    d += sizeof(WORD);\n    if (TNEF->Debug >= 1)\n      printf(\"<%s>\\n\", d);\n    d += addr_length;\n  }\n  return 0;\n}\n// -----------------------------------------------------------------------------\nint TNEFDateHandler STD_ARGLIST {\n  dtr *Date;\n  Attachment *p;\n  WORD * tmp_src, *tmp_dst;\n  int i;\n\n  p = &(TNEF->starting_attach);\n  switch (TNEFList[id].id) {\n    case attDateSent: Date = &(TNEF->dateSent); break;\n    case attDateRecd: Date = &(TNEF->dateReceived); break;\n    case attDateModified: Date = &(TNEF->dateModified); break;\n    case attDateStart: Date = &(TNEF->DateStart); break;\n    case attDateEnd:  Date = &(TNEF->DateEnd); break;\n    case attAttachCreateDate:\n      while (p->next != NULL) p = p->next;\n      Date = &(p->CreateDate);\n      break;\n    case attAttachModifyDate:\n      while (p->next != NULL) p = p->next;\n      Date = &(p->ModifyDate);\n      break;\n    default:\n      if (TNEF->Debug >= 1)\n        printf(\"MISSING CASE\\n\");\n      return YTNEF_UNKNOWN_PROPERTY;\n  }\n\n  tmp_src = (WORD *)data;\n  tmp_dst = (WORD *)Date;\n  for (i = 0; i < sizeof(dtr) / sizeof(WORD); i++) {\n    *tmp_dst++ = SwapWord((BYTE *)tmp_src++, sizeof(WORD));\n  }\n  return 0;\n}\n\nvoid TNEFPrintDate(dtr Date) {\n  char days[7][15] = {\"Sunday\", \"Monday\", \"Tuesday\",\n                      \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"\n                     };\n  char months[12][15] = {\"January\", \"February\", \"March\", \"April\", \"May\",\n                         \"June\", \"July\", \"August\", \"September\", \"October\", \"November\",\n                         \"December\"\n                        };\n\n  if (Date.wDayOfWeek < 7)\n    printf(\"%s \", days[Date.wDayOfWeek]);\n\n  if ((Date.wMonth < 13) && (Date.wMonth > 0))\n    printf(\"%s \", months[Date.wMonth - 1]);\n\n  printf(\"%hu, %hu \", Date.wDay, Date.wYear);\n\n  if (Date.wHour > 12)\n    printf(\"%i:%02hu:%02hu pm\", (Date.wHour - 12),\n           Date.wMinute, Date.wSecond);\n  else if (Date.wHour == 12)\n    printf(\"%hu:%02hu:%02hu pm\", (Date.wHour),\n           Date.wMinute, Date.wSecond);\n  else\n    printf(\"%hu:%02hu:%02hu am\", Date.wHour,\n           Date.wMinute, Date.wSecond);\n}\n// -----------------------------------------------------------------------------\nint TNEFHexBreakdown STD_ARGLIST {\n  int i;\n  if (TNEF->Debug == 0)\n    return 0;\n\n  printf(\"%s: [%i bytes] \\n\", TNEFList[id].name, size);\n\n  for (i = 0; i < size; i++) {\n    printf(\"%02x \", data[i]);\n    if ((i + 1) % 16 == 0) printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFDetailedPrint STD_ARGLIST {\n  int i;\n  if (TNEF->Debug == 0)\n    return 0;\n\n  printf(\"%s: [%i bytes] \\n\", TNEFList[id].name, size);\n\n  for (i = 0; i < size; i++) {\n    printf(\"%c\", data[i]);\n  }\n  printf(\"\\n\");\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFAttachmentFilename STD_ARGLIST {\n  Attachment *p;\n  p = &(TNEF->starting_attach);\n  while (p->next != NULL) p = p->next;\n\n  p->Title.size = size;\n  p->Title.data = calloc(size, sizeof(BYTE));\n  ALLOCCHECK(p->Title.data);\n  memcpy(p->Title.data, data, size);\n\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFAttachmentSave STD_ARGLIST {\n  Attachment *p;\n  p = &(TNEF->starting_attach);\n  while (p->next != NULL) p = p->next;\n\n  p->FileData.data = calloc(sizeof(char), size);\n  ALLOCCHECK(p->FileData.data);\n  p->FileData.size = size;\n\n  memcpy(p->FileData.data, data, size);\n\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFPriority STD_ARGLIST {\n  DWORD value;\n\n  value = SwapDWord((BYTE*)data, size);\n  switch (value) {\n    case 3:\n      sprintf((TNEF->priority), \"high\");\n      break;\n    case 2:\n      sprintf((TNEF->priority), \"normal\");\n      break;\n    case 1:\n      sprintf((TNEF->priority), \"low\");\n      break;\n    default:\n      sprintf((TNEF->priority), \"N/A\");\n      break;\n  }\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFCheckForSignature(DWORD sig) {\n  DWORD signature = 0x223E9F78;\n\n  sig = SwapDWord((BYTE *)&sig, sizeof(DWORD));\n\n  if (signature == sig) {\n    return 0;\n  } else {\n    return YTNEF_NOT_TNEF_STREAM;\n  }\n}\n\n// -----------------------------------------------------------------------------\nint TNEFGetKey(TNEFStruct *TNEF, WORD *key) {\n  if (TNEF->IO.ReadProc(&(TNEF->IO), sizeof(WORD), 1, key) < 1) {\n    if (TNEF->Debug >= 1)\n      printf(\"Error reading Key\\n\");\n    return YTNEF_ERROR_READING_DATA;\n  }\n  *key = SwapWord((BYTE *)key, sizeof(WORD));\n\n  DEBUG1(TNEF->Debug, 2, \"Key = 0x%X\", *key);\n  DEBUG1(TNEF->Debug, 2, \"Key = %i\", *key);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFGetHeader(TNEFStruct *TNEF, DWORD *type, DWORD *size) {\n  BYTE component;\n\n  DEBUG(TNEF->Debug, 2, \"About to read Component\");\n  if (TNEF->IO.ReadProc(&(TNEF->IO), sizeof(BYTE), 1, &component) < 1) {\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n\n  DEBUG(TNEF->Debug, 2, \"About to read type\");\n  if (TNEF->IO.ReadProc(&(TNEF->IO), sizeof(DWORD), 1, type)  < 1) {\n    if (TNEF->Debug >= 1)\n      printf(\"ERROR: Error reading type\\n\");\n    return YTNEF_ERROR_READING_DATA;\n  }\n  DEBUG1(TNEF->Debug, 2, \"Type = 0x%X\", *type);\n  DEBUG1(TNEF->Debug, 2, \"Type = %u\", *type);\n\n\n  DEBUG(TNEF->Debug, 2, \"About to read size\");\n  if (TNEF->IO.ReadProc(&(TNEF->IO), sizeof(DWORD), 1, size) < 1) {\n    if (TNEF->Debug >= 1)\n      printf(\"ERROR: Error reading size\\n\");\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n\n  DEBUG1(TNEF->Debug, 2, \"Size = %u\", *size);\n\n  *type = SwapDWord((BYTE *)type, sizeof(DWORD));\n  *size = SwapDWord((BYTE *)size, sizeof(DWORD));\n\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\nint TNEFRawRead(TNEFStruct *TNEF, BYTE *data, DWORD size, WORD *checksum) {\n  WORD temp;\n  int i;\n\n  if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(BYTE), size, data) < size) {\n    if (TNEF->Debug >= 1)\n      printf(\"ERROR: Error reading data\\n\");\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n\n  if (checksum != NULL) {\n    *checksum = 0;\n    for (i = 0; i < size; i++) {\n      temp = data[i];\n      *checksum = (*checksum + temp);\n    }\n  }\n  return 0;\n}\n\n#define INITVARLENGTH(x) (x).data = NULL; (x).size = 0;\n#define INITDTR(x) (x).wYear=0; (x).wMonth=0; (x).wDay=0; \\\n                   (x).wHour=0; (x).wMinute=0; (x).wSecond=0; \\\n                   (x).wDayOfWeek=0;\n#define INITSTR(x) memset((x), 0, sizeof(x));\nvoid TNEFInitMapi(MAPIProps *p) {\n  p->count = 0;\n  p->properties = NULL;\n}\n\nvoid TNEFInitAttachment(Attachment *p) {\n  INITDTR(p->Date);\n  INITVARLENGTH(p->Title);\n  INITVARLENGTH(p->MetaFile);\n  INITDTR(p->CreateDate);\n  INITDTR(p->ModifyDate);\n  INITVARLENGTH(p->TransportFilename);\n  INITVARLENGTH(p->FileData);\n  INITVARLENGTH(p->IconData);\n  memset(&(p->RenderData), 0, sizeof(renddata));\n  TNEFInitMapi(&(p->MAPI));\n  p->next = NULL;\n}\n\nvoid TNEFInitialize(TNEFStruct *TNEF) {\n  INITSTR(TNEF->version);\n  INITVARLENGTH(TNEF->from);\n  INITVARLENGTH(TNEF->subject);\n  INITDTR(TNEF->dateSent);\n  INITDTR(TNEF->dateReceived);\n\n  INITSTR(TNEF->messageStatus);\n  INITSTR(TNEF->messageClass);\n  INITSTR(TNEF->messageID);\n  INITSTR(TNEF->parentID);\n  INITSTR(TNEF->conversationID);\n  INITVARLENGTH(TNEF->body);\n  INITSTR(TNEF->priority);\n  TNEFInitAttachment(&(TNEF->starting_attach));\n  INITDTR(TNEF->dateModified);\n  TNEFInitMapi(&(TNEF->MapiProperties));\n  INITVARLENGTH(TNEF->CodePage);\n  INITVARLENGTH(TNEF->OriginalMessageClass);\n  INITVARLENGTH(TNEF->Owner);\n  INITVARLENGTH(TNEF->SentFor);\n  INITVARLENGTH(TNEF->Delegate);\n  INITDTR(TNEF->DateStart);\n  INITDTR(TNEF->DateEnd);\n  INITVARLENGTH(TNEF->AidOwner);\n  TNEF->RequestRes = 0;\n  TNEF->IO.data = NULL;\n  TNEF->IO.InitProc = NULL;\n  TNEF->IO.ReadProc = NULL;\n  TNEF->IO.CloseProc = NULL;\n}\n#undef INITVARLENGTH\n#undef INITDTR\n#undef INITSTR\n\n#define FREEVARLENGTH(x) if ((x).size > 0) { \\\n                            free((x).data); (x).size =0; }\nvoid TNEFFree(TNEFStruct *TNEF) {\n  Attachment *p, *store;\n\n  FREEVARLENGTH(TNEF->from);\n  FREEVARLENGTH(TNEF->subject);\n  FREEVARLENGTH(TNEF->body);\n  FREEVARLENGTH(TNEF->CodePage);\n  FREEVARLENGTH(TNEF->OriginalMessageClass);\n  FREEVARLENGTH(TNEF->Owner);\n  FREEVARLENGTH(TNEF->SentFor);\n  FREEVARLENGTH(TNEF->Delegate);\n  FREEVARLENGTH(TNEF->AidOwner);\n  TNEFFreeMapiProps(&(TNEF->MapiProperties));\n\n  p = TNEF->starting_attach.next;\n  while (p != NULL) {\n    TNEFFreeAttachment(p);\n    store = p->next;\n    free(p);\n    p = store;\n  }\n}\n\nvoid TNEFFreeAttachment(Attachment *p) {\n  FREEVARLENGTH(p->Title);\n  FREEVARLENGTH(p->MetaFile);\n  FREEVARLENGTH(p->TransportFilename);\n  FREEVARLENGTH(p->FileData);\n  FREEVARLENGTH(p->IconData);\n  TNEFFreeMapiProps(&(p->MAPI));\n}\n\nvoid TNEFFreeMapiProps(MAPIProps *p) {\n  int i, j;\n  for (i = 0; i < p->count; i++) {\n    for (j = 0; j < p->properties[i].count; j++) {\n      FREEVARLENGTH(p->properties[i].data[j]);\n    }\n    free(p->properties[i].data);\n    for (j = 0; j < p->properties[i].namedproperty; j++) {\n      FREEVARLENGTH(p->properties[i].propnames[j]);\n    }\n    free(p->properties[i].propnames);\n  }\n  free(p->properties);\n  p->count = 0;\n}\n#undef FREEVARLENGTH\n\n// Procedures to handle File IO\nint TNEFFile_Open(TNEFIOStruct *IO) {\n  TNEFFileInfo *finfo;\n  finfo = (TNEFFileInfo *)IO->data;\n\n  DEBUG1(finfo->Debug, 3, \"Opening %s\", finfo->filename);\n  if ((finfo->fptr = fopen(finfo->filename, \"rb\")) == NULL) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nint TNEFFile_Read(TNEFIOStruct *IO, int size, int count, void *dest) {\n  TNEFFileInfo *finfo;\n  finfo = (TNEFFileInfo *)IO->data;\n\n  DEBUG2(finfo->Debug, 3, \"Reading %i blocks of %i size\", count, size);\n  if (finfo->fptr != NULL) {\n    return fread((BYTE *)dest, size, count, finfo->fptr);\n  } else {\n    return -1;\n  }\n}\n\nint TNEFFile_Close(TNEFIOStruct *IO) {\n  TNEFFileInfo *finfo;\n  finfo = (TNEFFileInfo *)IO->data;\n\n  DEBUG1(finfo->Debug, 3, \"Closing file %s\", finfo->filename);\n  if (finfo->fptr != NULL) {\n    fclose(finfo->fptr);\n    finfo->fptr = NULL;\n  }\n  return 0;\n}\n\nint TNEFParseFile(char *filename, TNEFStruct *TNEF) {\n  TNEFFileInfo finfo;\n\n  if (TNEF->Debug >= 1)\n    printf(\"Attempting to parse %s...\\n\", filename);\n\n\n  finfo.filename = filename;\n  finfo.fptr = NULL;\n  finfo.Debug = TNEF->Debug;\n  TNEF->IO.data = (void *)&finfo;\n  TNEF->IO.InitProc = TNEFFile_Open;\n  TNEF->IO.ReadProc = TNEFFile_Read;\n  TNEF->IO.CloseProc = TNEFFile_Close;\n  return TNEFParse(TNEF);\n}\n//-------------------------------------------------------------\n// Procedures to handle Memory IO\nint TNEFMemory_Open(TNEFIOStruct *IO) {\n  TNEFMemInfo *minfo;\n  minfo = (TNEFMemInfo *)IO->data;\n\n  minfo->ptr = minfo->dataStart;\n  return 0;\n}\n\nint TNEFMemory_Read(TNEFIOStruct *IO, int size, int count, void *dest) {\n  TNEFMemInfo *minfo;\n  int length;\n  long max;\n  minfo = (TNEFMemInfo *)IO->data;\n\n  length = count * size;\n  max = (minfo->dataStart + minfo->size) - (minfo->ptr);\n  if (length > max) {\n    return -1;\n  }\n\n  DEBUG1(minfo->Debug, 3, \"Copying %i bytes\", length);\n\n  memcpy(dest, minfo->ptr, length);\n  minfo->ptr += length;\n  return count;\n}\n\nint TNEFMemory_Close(TNEFIOStruct *IO) {\n  // Do nothing, really...\n  return 0;\n}\n\nint TNEFParseMemory(BYTE *memory, long size, TNEFStruct *TNEF) {\n  TNEFMemInfo minfo;\n\n  DEBUG(TNEF->Debug, 1, \"Attempting to parse memory block...\\n\");\n\n  minfo.dataStart = memory;\n  minfo.ptr = memory;\n  minfo.size = size;\n  minfo.Debug = TNEF->Debug;\n  TNEF->IO.data = (void *)&minfo;\n  TNEF->IO.InitProc = TNEFMemory_Open;\n  TNEF->IO.ReadProc = TNEFMemory_Read;\n  TNEF->IO.CloseProc = TNEFMemory_Close;\n  return TNEFParse(TNEF);\n}\n\n\nint TNEFParse(TNEFStruct *TNEF) {\n  WORD key;\n  DWORD type;\n  DWORD size;\n  DWORD signature;\n  BYTE *data;\n  WORD checksum, header_checksum;\n  int i;\n\n  if (TNEF->IO.ReadProc == NULL) {\n    printf(\"ERROR: Setup incorrectly: No ReadProc\\n\");\n    return YTNEF_INCORRECT_SETUP;\n  }\n\n  if (TNEF->IO.InitProc != NULL) {\n    DEBUG(TNEF->Debug, 2, \"About to initialize\");\n    if (TNEF->IO.InitProc(&TNEF->IO) != 0) {\n      return YTNEF_CANNOT_INIT_DATA;\n    }\n    DEBUG(TNEF->Debug, 2, \"Initialization finished\");\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Signature\");\n  if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(DWORD), 1, &signature) < 1) {\n    printf(\"ERROR: Error reading signature\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Checking Signature\");\n  if (TNEFCheckForSignature(signature) < 0) {\n    printf(\"ERROR: Signature does not match. Not TNEF.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NOT_TNEF_STREAM;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Key.\");\n\n  if (TNEFGetKey(TNEF, &key) < 0) {\n    printf(\"ERROR: Unable to retrieve key.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NO_KEY;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Starting Full Processing.\");\n\n  while (TNEFGetHeader(TNEF, &type, &size) == 0) {\n    DEBUG2(TNEF->Debug, 2, \"Header says type=0x%X, size=%u\", type, size);\n    DEBUG2(TNEF->Debug, 2, \"Header says type=%u, size=%u\", type, size);\n    if(size == 0) {\n      printf(\"ERROR: Field with size of 0\\n\");\n      return YTNEF_ERROR_READING_DATA;\n    }\n    data = calloc(size, sizeof(BYTE));\n    ALLOCCHECK(data);\n    if (TNEFRawRead(TNEF, data, size, &header_checksum) < 0) {\n      printf(\"ERROR: Unable to read data.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    if (TNEFRawRead(TNEF, (BYTE *)&checksum, 2, NULL) < 0) {\n      printf(\"ERROR: Unable to read checksum.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    checksum = SwapWord((BYTE *)&checksum, sizeof(WORD));\n    if (checksum != header_checksum) {\n      printf(\"ERROR: Checksum mismatch. Data corruption?:\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_BAD_CHECKSUM;\n    }\n    for (i = 0; i < (sizeof(TNEFList) / sizeof(TNEFHandler)); i++) {\n      if (TNEFList[i].id == type) {\n        if (TNEFList[i].handler != NULL) {\n          if (TNEFList[i].handler(TNEF, i, (char*)data, size) < 0) {\n            free(data);\n            if (TNEF->IO.CloseProc != NULL) {\n              TNEF->IO.CloseProc(&TNEF->IO);\n            }\n            return YTNEF_ERROR_IN_HANDLER;\n          } else {\n            //  Found our handler and processed it.  now time to get out\n            break;\n          }\n        } else {\n          DEBUG2(TNEF->Debug, 1, \"No handler for %s: %u bytes\",\n                 TNEFList[i].name, size);\n        }\n      }\n    }\n\n    free(data);\n  }\n\n  if (TNEF->IO.CloseProc != NULL) {\n    TNEF->IO.CloseProc(&TNEF->IO);\n  }\n  return 0;\n\n}\n\n// ----------------------------------------------------------------------------\n\nvariableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {\n  int i;\n  if (p != NULL) {\n    for (i = 0; i < p->count; i++) {\n      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {\n        return (p->properties[i].data);\n      }\n    }\n  }\n  return MAPI_UNDEFINED;\n}\n\nvariableLength *MAPIFindProperty(MAPIProps *p, unsigned int ID) {\n  int i;\n  if (p != NULL) {\n    for (i = 0; i < p->count; i++) {\n      if ((p->properties[i].id == ID) && (p->properties[i].custom == 0)) {\n        return (p->properties[i].data);\n      }\n    }\n  }\n  return MAPI_UNDEFINED;\n}\n\nint MAPISysTimetoDTR(BYTE *data, dtr *thedate) {\n  DDWORD ddword_tmp;\n  int startingdate = 0;\n  int tmp_date;\n  int days_in_year = 365;\n  unsigned int months[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n  ddword_tmp = *((DDWORD *)data);\n  ddword_tmp = ddword_tmp / 10; // micro-s\n  ddword_tmp /= 1000; // ms\n  ddword_tmp /= 1000; // s\n\n  thedate->wSecond = (ddword_tmp % 60);\n\n  ddword_tmp /= 60; // seconds to minutes\n  thedate->wMinute = (ddword_tmp % 60);\n\n  ddword_tmp /= 60; //minutes to hours\n  thedate->wHour = (ddword_tmp % 24);\n\n  ddword_tmp /= 24; // Hours to days\n\n  // Now calculate the year based on # of days\n  thedate->wYear = 1601;\n  startingdate = 1;\n  while (ddword_tmp >= days_in_year) {\n    ddword_tmp -= days_in_year;\n    thedate->wYear++;\n    days_in_year = 365;\n    startingdate++;\n    if ((thedate->wYear % 4) == 0) {\n      if ((thedate->wYear % 100) == 0) {\n        // if the year is 1700,1800,1900, etc, then it is only\n        // a leap year if exactly divisible by 400, not 4.\n        if ((thedate->wYear % 400) == 0) {\n          startingdate++;\n          days_in_year = 366;\n        }\n      }  else {\n        startingdate++;\n        days_in_year = 366;\n      }\n    }\n    startingdate %= 7;\n  }\n\n  // the remaining number is the day # in this year\n  // So now calculate the Month, & Day of month\n  if ((thedate->wYear % 4) == 0) {\n    // 29 days in february in a leap year\n    months[1] = 29;\n  }\n\n  tmp_date = (int)ddword_tmp;\n  thedate->wDayOfWeek = (tmp_date + startingdate) % 7;\n  thedate->wMonth = 0;\n\n  while (tmp_date > months[thedate->wMonth]) {\n    tmp_date -= months[thedate->wMonth];\n    thedate->wMonth++;\n  }\n  thedate->wMonth++;\n  thedate->wDay = tmp_date + 1;\n  return 0;\n}\n\nvoid MAPIPrint(MAPIProps *p) {\n  int j, i, index, h, x;\n  DDWORD *ddword_ptr;\n  DDWORD ddword_tmp;\n  dtr thedate;\n  MAPIProperty *mapi;\n  variableLength *mapidata;\n  variableLength vlTemp;\n  int found;\n\n  for (j = 0; j < p->count; j++) {\n    mapi = &(p->properties[j]);\n    printf(\"   #%i: Type: [\", j);\n    switch (PROP_TYPE(mapi->id)) {\n      case PT_UNSPECIFIED:\n        printf(\"  NONE   \"); break;\n      case PT_NULL:\n        printf(\"  NULL   \"); break;\n      case PT_I2:\n        printf(\"   I2    \"); break;\n      case PT_LONG:\n        printf(\"  LONG   \"); break;\n      case PT_R4:\n        printf(\"   R4    \"); break;\n      case PT_DOUBLE:\n        printf(\" DOUBLE  \"); break;\n      case PT_CURRENCY:\n        printf(\"CURRENCY \"); break;\n      case PT_APPTIME:\n        printf(\"APP TIME \"); break;\n      case PT_ERROR:\n        printf(\"  ERROR  \"); break;\n      case PT_BOOLEAN:\n        printf(\" BOOLEAN \"); break;\n      case PT_OBJECT:\n        printf(\" OBJECT  \"); break;\n      case PT_I8:\n        printf(\"   I8    \"); break;\n      case PT_STRING8:\n        printf(\" STRING8 \"); break;\n      case PT_UNICODE:\n        printf(\" UNICODE \"); break;\n      case PT_SYSTIME:\n        printf(\"SYS TIME \"); break;\n      case PT_CLSID:\n        printf(\"OLE GUID \"); break;\n      case PT_BINARY:\n        printf(\" BINARY  \"); break;\n      default:\n        printf(\"<%x>\", PROP_TYPE(mapi->id)); break;\n    }\n\n    printf(\"]  Code: [\");\n    if (mapi->custom == 1) {\n      printf(\"UD:x%04x\", PROP_ID(mapi->id));\n    } else {\n      found = 0;\n      for (index = 0; index < sizeof(MPList) / sizeof(MAPIPropertyTagList); index++) {\n        if ((MPList[index].id == PROP_ID(mapi->id)) && (found == 0)) {\n          printf(\"%s\", MPList[index].name);\n          found = 1;\n        }\n      }\n      if (found == 0) {\n        printf(\"0x%04x\", PROP_ID(mapi->id));\n      }\n    }\n    printf(\"]\\n\");\n    if (mapi->namedproperty > 0) {\n      for (i = 0; i < mapi->namedproperty; i++) {\n        printf(\"    Name: %s\\n\", mapi->propnames[i].data);\n      }\n    }\n    for (i = 0; i < mapi->count; i++) {\n      mapidata = &(mapi->data[i]);\n      if (mapi->count > 1) {\n        printf(\"    [%i/%u] \", i, mapi->count);\n      } else {\n        printf(\"    \");\n      }\n      printf(\"Size: %i\", mapidata->size);\n      switch (PROP_TYPE(mapi->id)) {\n        case PT_SYSTIME:\n          MAPISysTimetoDTR(mapidata->data, &thedate);\n          printf(\"    Value: \");\n          ddword_tmp = *((DDWORD *)mapidata->data);\n          TNEFPrintDate(thedate);\n          printf(\" [HEX: \");\n          for (x = 0; x < sizeof(ddword_tmp); x++) {\n            printf(\" %02x\", (BYTE)mapidata->data[x]);\n          }\n          printf(\"] (%llu)\\n\", ddword_tmp);\n          break;\n        case PT_LONG:\n          printf(\"    Value: %i\\n\", *((int*)mapidata->data));\n          break;\n        case PT_I2:\n          printf(\"    Value: %hi\\n\", *((short int*)mapidata->data));\n          break;\n        case PT_BOOLEAN:\n          if (mapi->data->data[0] != 0) {\n            printf(\"    Value: True\\n\");\n          } else {\n            printf(\"    Value: False\\n\");\n          }\n          break;\n        case PT_OBJECT:\n          printf(\"\\n\");\n          break;\n        case PT_BINARY:\n          if (IsCompressedRTF(mapidata) == 1) {\n            printf(\"    Detected Compressed RTF. \");\n            printf(\"Decompressed text follows\\n\");\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n            if ((vlTemp.data = (BYTE*)DecompressRTF(mapidata, &(vlTemp.size))) != NULL) {\n              printf(\"%s\\n\", vlTemp.data);\n              free(vlTemp.data);\n            }\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n          } else {\n            printf(\"    Value: [\");\n            for (h = 0; h < mapidata->size; h++) {\n              if (isprint(mapidata->data[h])) {\n                printf(\"%c\", mapidata->data[h]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case PT_STRING8:\n          printf(\"    Value: [%s]\\n\", mapidata->data);\n          if (strlen((char*)mapidata->data) != mapidata->size - 1) {\n            printf(\"Detected Hidden data: [\");\n            for (h = 0; h < mapidata->size; h++) {\n              if (isprint(mapidata->data[h])) {\n                printf(\"%c\", mapidata->data[h]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case PT_CLSID:\n          printf(\"    Value: \");\n          printf(\"[HEX: \");\n          for(x=0; x< 16; x++) {\n            printf(\" %02x\", (BYTE)mapidata->data[x]);\n          }\n          printf(\"]\\n\");\n          break;\n        default:\n          printf(\"    Value: [%s]\\n\", mapidata->data);\n      }\n    }\n  }\n}\n\n\nint IsCompressedRTF(variableLength *p) {\n  unsigned int in;\n  BYTE *src;\n  ULONG magic;\n\n  if (p->size < 4)\n    return 0;\n\n  src = p->data;\n  in = 0;\n\n  in += 4;\n  in += 4;\n  magic = SwapDWord((BYTE*)src + in, 4);\n\n  if (magic == 0x414c454d) {\n    return 1;\n  } else if (magic == 0x75465a4c) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nBYTE *DecompressRTF(variableLength *p, int *size) {\n  BYTE *dst; // destination for uncompressed bytes\n  BYTE *src;\n  unsigned int in;\n  unsigned int out;\n  variableLength comp_Prebuf;\n  ULONG compressedSize, uncompressedSize, magic;\n\n  comp_Prebuf.size = strlen(RTF_PREBUF);\n  comp_Prebuf.data = calloc(comp_Prebuf.size+1, 1);\n  ALLOCCHECK_CHAR(comp_Prebuf.data);\n  memcpy(comp_Prebuf.data, RTF_PREBUF, comp_Prebuf.size);\n\n  src = p->data;\n  in = 0;\n\n  if (p->size < 20) {\n    printf(\"File too small\\n\");\n    return(NULL);\n  }\n  compressedSize = (ULONG)SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  uncompressedSize = (ULONG)SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  magic = SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  in += 4;\n\n  // check size excluding the size field itself\n  if (compressedSize != p->size - 4) {\n    printf(\" Size Mismatch: %u != %i\\n\", compressedSize, p->size - 4);\n    free(comp_Prebuf.data);\n    return NULL;\n  }\n\n  // process the data\n  if (magic == 0x414c454d) {\n    // magic number that identifies the stream as a uncompressed stream\n    dst = calloc(uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, src + 4, uncompressedSize);\n  } else if (magic == 0x75465a4c) {\n    // magic number that identifies the stream as a compressed stream\n    int flagCount = 0;\n    int flags = 0;\n    // Prevent overflow on 32 Bit Systems\n    if (comp_Prebuf.size >= INT_MAX - uncompressedSize) {\n       printf(\"Corrupted file\\n\");\n       exit(-1);\n    }\n    dst = calloc(comp_Prebuf.size + uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, comp_Prebuf.data, comp_Prebuf.size);\n    out = comp_Prebuf.size;\n    while ((out < (comp_Prebuf.size + uncompressedSize)) && (in < p->size)) {\n      // each flag byte flags 8 literals/references, 1 per bit\n      flags = (flagCount++ % 8 == 0) ? src[in++] : flags >> 1;\n      if ((flags & 1) == 1) { // each flag bit is 1 for reference, 0 for literal\n        unsigned int offset = src[in++];\n        unsigned int length = src[in++];\n        unsigned int end;\n        offset = (offset << 4) | (length >> 4); // the offset relative to block start\n        length = (length & 0xF) + 2; // the number of bytes to copy\n        // the decompression buffer is supposed to wrap around back\n        // to the beginning when the end is reached. we save the\n        // need for such a buffer by pointing straight into the data\n        // buffer, and simulating this behaviour by modifying the\n        // pointers appropriately.\n        offset = (out / 4096) * 4096 + offset;\n        if (offset >= out) // take from previous block\n          offset -= 4096;\n        // note: can't use System.arraycopy, because the referenced\n        // bytes can cross through the current out position.\n        end = offset + length;\n        while ((offset < end) && (out < (comp_Prebuf.size + uncompressedSize))\n             && (offset < (comp_Prebuf.size + uncompressedSize)))\n          dst[out++] = dst[offset++];\n      } else { // literal\n        if ((out >= (comp_Prebuf.size + uncompressedSize)) ||\n            (in >= p->size)) {\n          printf(\"Corrupted stream\\n\");\n          exit(-1);\n        }\n        dst[out++] = src[in++];\n      }\n    }\n    // copy it back without the prebuffered data\n    src = dst;\n    dst = calloc(uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, src + comp_Prebuf.size, uncompressedSize);\n    free(src);\n    *size = uncompressedSize;\n    free(comp_Prebuf.data);\n    return dst;\n  } else { // unknown magic number\n    printf(\"Unknown compression type (magic number %x)\\n\", magic);\n  }\n  free(comp_Prebuf.data);\n  return NULL;\n}\n"], "filenames": ["ChangeLog", "lib/ytnef.c"], "buggy_code_start_loc": [5, 1544], "buggy_code_end_loc": [5, 1545], "fixing_code_start_loc": [6, 1544], "fixing_code_end_loc": [7, 1545], "type": "CWE-125", "message": "An issue was discovered in ytnef before 1.9.2. There is a potential heap-based buffer over-read on incoming Compressed RTF Streams, related to DecompressRTF() in libytnef.", "other": {"cve": {"id": "CVE-2017-6802", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-10T10:59:00.577", "lastModified": "2019-05-18T03:29:03.583", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in ytnef before 1.9.2. There is a potential heap-based buffer over-read on incoming Compressed RTF Streams, related to DecompressRTF() in libytnef."}, {"lang": "es", "value": "Se ha descubierto un problema en ytnef en versiones anteriores a 1.9.2. Hay una potencial sobre lectura de b\u00fafer basado en memoria din\u00e1mica en el entrante Compressed RTF Streams, relacionado con DecompressRTF() en libytnef."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ytnef_project:ytnef:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.9.1", "matchCriteriaId": "B61A10E7-D7FA-4AEE-843B-F37741B83385"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3846", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Yeraze/ytnef/commit/22f8346c8d4f0020a40d9f258fdb3bfc097359cc", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/Yeraze/ytnef/issues/34", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LFJWMUEUC4ILH2HEOCYVVLQT654ZMCGQ/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/Yeraze/ytnef/commit/22f8346c8d4f0020a40d9f258fdb3bfc097359cc"}}