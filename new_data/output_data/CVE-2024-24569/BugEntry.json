{"buggy_code": ["[![Actions Status](https://github.com/pixeeworks/java-security-toolkit/workflows/Java%20CI/badge.svg)](https://github.com/pixeeworks/java-security-toolkit/actions)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n# Java Code Security Toolkit\n\nThis utility hosts a number of code security controls for various application security vulnerability categories. It can \nbe used directly by programmers, but you may have been introduced to it by being having it directly added to you code by \nautomation.\n\nMany of the APIs provided are meant to be drop-in replacements that either offer more secure defaults, harden against common attacks, or at least surface the security questions developers should answer when using risky APIs. Here are a few examples:\n\n### Example 1: Safely accessing URLs\n\nFetching [URLs](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/URL.html) is potentially unsafe because of the wide universe of hosts, protocols, and capabilities this may expose. We offer an API that makes it considerably higher assurance, allowing the developer to dictate their expectations about the result, causing a `SecurityException` to be thrown if they're not met:\n\n```diff\n-  URL u = new URL(str); // dangerous -- can be to ftp://evil.com/ for all we know\n+  URL u = Urls.create(str, Set.of(UrlsProtocols.HTTPS), HostValidator.fromAllowedHostPattern(Pattern.compile(\"good\\\\.com\"));\n```\n\n### Example 2: Hardening Java deserialization\n\nDeserializing using [ObjectInputStream](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/ObjectInputStream.html) is [extremely dangerous](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#java) (here's a [from-zero-to-exploit talk](https://www.youtube.com/watch?v=kpuEtsGXKR8) we gave about it).  We offer an API to offer a strong, 1-line, zero-tradeoff protection against this attack.\n\n```diff\n   ObjectInputStream ois = ...;\n+  ObjectInputFilters.enableObjectFilterIfUnprotected(ois); // now protected against all publicly known gadgets\n   Acme acme = (Acme)ois.readObject();\n```\n\n## Adding to your project \n\nIn Maven:\n```xml\n<dependency>\n  <groupId>io.github.pixee</groupId>\n  <artifactId>java-security-toolkit</artifactId>\n  <version>1.1.1</version>\n</dependency>\n```\nIn Gradle:\n```kotlin\nimplementation(\"io.github.pixee:java-security-toolkit:1.1.1\")\n```\n\n## Contributing \nWe'd love to get contributions! See [CONTRIBUTING.md](CONTRIBUTING.md).\n\n### Building\nBuilding is meant for Java 11 and Maven 3:\n\n```\nmvn clean package\n```\n\n## FAQ\n\n### How does this compare to OWASP ESAPI?\n\nWe actually contributed to OWASP ESAPI and other OWASP projects in the past and remain fans today! \n\nThere is some limited overlap, but ESAPI is much more broad in its ambitions, and as a result is considerably more \"heavyweight\". It also is not focused on hardening or sandboxing solutions, instead preferring to offer concrete solutions for problems that require business context to implement. Our library also has very few dependencies, no configuration, and is generally designed to offer much less friction to \"drop in\" to a codebase.\n", "import org.javamodularity.moduleplugin.extensions.ModularityExtension\n\nplugins {\n    `java-library`\n    `maven-publish`\n    signing\n    jacoco\n    `jvm-test-suite`\n    id(\"com.netflix.nebula.contacts\") version \"7.0.1\"\n    id(\"com.netflix.nebula.source-jar\") version \"20.3.0\"\n    id(\"com.netflix.nebula.javadoc-jar\") version \"20.3.0\"\n    id(\"com.netflix.nebula.maven-publish\") version \"20.3.0\"\n    id(\"com.netflix.nebula.publish-verification\") version \"20.3.0\"\n    id(\"io.github.gradle-nexus.publish-plugin\") version \"1.3.0\"\n    id(\"org.javamodularity.moduleplugin\") version \"1.8.12\"\n}\n\ntasks.named<Jar>(\"javadocJar\") {\n    exclude(\"module-info.class\")\n}\n\ntasks.named<Jar>(\"sourcesJar\") {\n    dependsOn(\"compileModuleInfoJava\")\n    exclude(\"module-info.class\")\n}\n\ntasks.named<JavaCompile>(\"compileJava\") {\n    options.release.set(null as Int?)\n}\n\nconfigure<ModularityExtension> {\n    mixedJavaRelease(8)\n}\n\ntasks.named<JavaCompile>(\"compileModuleInfoJava\") {\n    options.release.set(null as Int?)\n}\n\nrepositories {\n   mavenCentral()\n}\n\nval java11SourceSet = sourceSets.create(\"java11\") {\n    java.srcDir(\"src/java11/main\")\n    compileClasspath += sourceSets.main.get().output\n}\n\njava {\n    withSourcesJar()\n    withJavadocJar()\n    toolchain {\n        languageVersion.set(JavaLanguageVersion.of(11))\n    }\n\n    registerFeature(\"java11\") {\n        capability(\"io.github.pixee\", \"java11-support\", version.toString())\n        usingSourceSet(java11SourceSet)\n    }\n}\n\ndependencies {\n    api(\"com.martiansoftware:jsap:2.1\")\n    api(\"commons-io:commons-io:2.11.0\")\n    java11SourceSet.apiConfigurationName(\"commons-io:commons-io:2.11.0\")\n    testImplementation(\"org.junit.jupiter:junit-jupiter:5.8.1\")\n    testImplementation(\"org.junit.jupiter:junit-jupiter-params\")\n    testImplementation(\"commons-fileupload:commons-fileupload:1.3.3\")\n    testRuntimeOnly(\"org.junit.platform:junit-platform-launcher\")\n    testImplementation(\"org.hamcrest:hamcrest-all:1.3\")\n    testImplementation(\"org.mockito:mockito-core:4.0.0\")\n}\n\ntasks.named<JavaCompile>(java11SourceSet.compileJavaTaskName) {\n    options.release.set(9)\n}\n\ntasks.jar {\n    into(\"META-INF/versions/11\") {\n        from(java11SourceSet.output)\n    }\n    manifest.attributes(\n        Pair(\"Multi-Release\", \"true\")\n    )\n\n    inputs.files(tasks.named(java11SourceSet.compileJavaTaskName).map { it.outputs.files })\n}\n\ntasks.named(java11SourceSet.jarTaskName) {\n    // disabled because we don't want to publish this separately\n    enabled = false\n}\n\ngroup = \"io.github.pixee\"\nversion = \"1.1.1\"\ndescription = \"java-security-toolkit\"\n\n\nextensions.getByType<nebula.plugin.contacts.ContactsExtension>().run {\n    addPerson(\n        \"support@pixee.ai\",\n        delegateClosureOf<nebula.plugin.contacts.Contact> {\n            moniker(\"Pixee\")\n            github(\"pixee\")\n        },\n    )\n}\n\nval publicationName = \"nebula\"\nsigning {\n    if (providers.environmentVariable(\"CI\").isPresent) {\n        val signingKey: String? by project\n        val signingPassword: String? by project\n        useInMemoryPgpKeys(signingKey, signingPassword)\n    }\n    sign(extensions.getByType<PublishingExtension>().publications.getByName(publicationName))\n}\n\nnexusPublishing {\n    repositories {\n        sonatype {\n            nexusUrl.set(uri(\"https://s01.oss.sonatype.org/service/local/\"))\n            snapshotRepositoryUrl.set(uri(\"https://s01.oss.sonatype.org/content/repositories/snapshots/\"))\n        }\n    }\n}\n\npublishing {\n    publications {\n        named<MavenPublication>(publicationName) {\n            pom {\n                licenses {\n                    license {\n                        name.set(\"MIT License\")\n                        url.set(\"http://www.opensource.org/licenses/mit-license.php\")\n                    }\n                }\n                val scmHost = \"github.com\"\n                val scmProject = \"pixee/java-security-toolkit\"\n                val projectUrl = \"https://$scmHost/$scmProject\"\n                url.set(projectUrl)\n                scm {\n                    url.set(projectUrl)\n                    connection.set(\"scm:git:git@$scmHost:$scmProject\")\n                    developerConnection.set(connection)\n                }\n            }\n        }\n    }\n}\n\ntasks.jacocoTestReport {\n    dependsOn(tasks.test)\n    reports {\n        csv.required.set(true)\n    }\n}\n\ntasks.test {\n    useJUnitPlatform()\n    finalizedBy(tasks.jacocoTestReport)\n    extensions.configure(org.javamodularity.moduleplugin.extensions.TestModuleOptions::class) {\n        // Avoid modules in tests so we can test against Java/JDK 8.\n        setRunOnClasspath(true)\n    }\n\n    javaLauncher.set(javaToolchains.launcherFor {\n        languageVersion.set(JavaLanguageVersion.of(8))\n    })\n}\n\ntesting {\n    suites {\n        @Suppress(\"UnstableApiUsage\")\n        register<JvmTestSuite>(\"java11Test\") {\n            useJUnitJupiter()\n            dependencies {\n                runtimeOnly(project())\n                implementation(project()) {\n                    capabilities {\n                        requireCapabilities(\"io.github.pixee:java11-support\")\n                    }\n                }\n                implementation(\"org.hamcrest:hamcrest-all:1.3\")\n                implementation(\"org.mockito:mockito-core:4.0.0\")\n                implementation(\"commons-fileupload:commons-fileupload:1.3.3\")\n            }\n        }\n\n        register<JvmTestSuite>(\"integrationTest\") {\n            useJUnitJupiter()\n            dependencies {\n                implementation(\"org.junit.jupiter:junit-jupiter-params\")\n                implementation(\"org.testcontainers:testcontainers:1.19.0\")\n                implementation(\"ch.qos.logback:logback-classic:1.2.6\")\n            }\n        }\n    }\n}\n\ntasks.named<Test>(\"java11Test\") {\n    systemProperty(\"org.apache.commons.fileupload.disk.DiskFileItem.serializable\", \"true\")\n}\n\nval java11Test = tasks.register<Test>(\"testOn11\") {\n    useJUnitPlatform()\n    javaLauncher.set(javaToolchains.launcherFor {\n        languageVersion.set(JavaLanguageVersion.of(11))\n    })\n}\n\nval java17Test = tasks.register<Test>(\"testOn17\") {\n    useJUnitPlatform()\n    javaLauncher.set(javaToolchains.launcherFor {\n        languageVersion.set(JavaLanguageVersion.of(17))\n    })\n}\n\ntasks.named<Test>(\"integrationTest\") {\n    this.inputs.file(tasks.jar.map { it.archiveFile} )\n    dependsOn(\":test-apps:hello-world:jibDockerBuild\")\n    dependsOn(\":test-apps:hello-world-modules:jibDockerBuild\")\n    systemProperty(\"securityToolkitJarPath\", tasks.jar.get().archiveFile.get().asFile.relativeTo(projectDir).path)\n}\n\ntasks.check {\n    @Suppress(\"UnstableApiUsage\")\n    dependsOn(java11Test, java17Test, testing.suites.named(\"java11Test\"), testing.suites.named(\"integrationTest\"))\n}\n\ntasks.compileTestJava {\n    extensions.configure(org.javamodularity.moduleplugin.extensions.CompileTestModuleOptions::class) {\n        // Avoid modules in tests so we can test against Java/JDK 8.\n        setCompileOnClasspath(true)\n    }\n    options.release.set(8)\n}\n", "package io.github.pixee.security;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.Charset;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\n/**\n * This type exposes helper methods to deal with attacks related to Zipping operations, most notably\n * the \"zip slip\" attack.\n */\npublic final class ZipSecurity {\n\n  private ZipSecurity() {}\n\n  /**\n   * Returns a {@link ZipInputStream} that will check to make sure that paths encountered in the zip\n   * aren't absolute and don't contain escapes (\"..\") towards directories outside the zip's root.\n   */\n  public static ZipInputStream createHardenedInputStream(\n      final InputStream stream, final Charset charset) {\n    return new HardenedZipInputStream(stream, charset);\n  }\n\n  /**\n   * Returns a {@link ZipInputStream} that will check to make sure that paths encountered in the zip\n   * aren't absolute and don't contain escapes (\"..\") towards directories beyond the root of the\n   * zip.\n   */\n  public static ZipInputStream createHardenedInputStream(final InputStream stream) {\n    return new HardenedZipInputStream(stream);\n  }\n\n  private static class HardenedZipInputStream extends ZipInputStream {\n\n    private HardenedZipInputStream(final InputStream in) {\n      super(in);\n    }\n\n    private HardenedZipInputStream(final InputStream in, final Charset charset) {\n      super(in, charset);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>Also checks to see that the path isn't absolute (starts with a root path), doesn't contain\n     * escapes that lead above the root of the zip.\n     */\n    @Override\n    public ZipEntry getNextEntry() throws IOException {\n      final ZipEntry entry = super.getNextEntry();\n      final String name = entry.getName();\n\n      if (!\"\".equals(name.trim())) {\n        if (isRootFileEntry(name)) {\n          throw new SecurityException(\"encountered zip file path that is absolute: \" + name);\n        }\n        if (containsEscapesAndTargetsBelowRoot(name)) {\n          throw new SecurityException(\"path to sensitive locations contained escapes: \" + name);\n        }\n      }\n      return entry;\n    }\n\n    private boolean containsEscapesAndTargetsBelowRoot(final String name) {\n      if (name.contains(\"../\") || name.contains(\"..\\\\\")) {\n        final File fileWithEscapes = new File(name);\n        try {\n          if (isBelowCurrentDirectory(fileWithEscapes)) {\n            return true;\n          }\n        } catch (IOException e) {\n          // we suppose this may happen in normal operation so best not to do anything\n        }\n      }\n      return false;\n    }\n\n    boolean isBelowCurrentDirectory(final File fileWithEscapes) throws IOException {\n      final File currentDirectory = new File(\"\");\n      String canonicalizedTargetPath = fileWithEscapes.getCanonicalPath();\n      String canonicalizedCurrentPath = currentDirectory.getCanonicalPath();\n      return !canonicalizedTargetPath.startsWith(canonicalizedCurrentPath);\n    }\n\n    private boolean isRootFileEntry(final String name) {\n      return name.startsWith(\"/\");\n    }\n  }\n}\n", "package io.github.pixee.security;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\nfinal class ZipSecurityTest {\n\n  @Test\n  void it_doesnt_prevent_normal_zip_file_reads() throws IOException {\n    ZipEntry entry = new ZipEntry(\"normal.txt\");\n    InputStream is = createZipFrom(entry);\n\n    ZipInputStream hardenedStream =\n        ZipSecurity.createHardenedInputStream(is, StandardCharsets.UTF_8);\n    ZipEntry retrievedEntry = hardenedStream.getNextEntry();\n    assertThat(retrievedEntry.getName(), equalTo(\"normal.txt\"));\n  }\n\n  @ParameterizedTest\n  @ValueSource(strings = {\"dir1/dir2/../normal.txt\", \"dir1/../normal.txt\"})\n  void it_doesnt_prevent_normal_zip_files_with_safe_escapes(String path) throws IOException {\n    ZipEntry entry = new ZipEntry(path);\n    InputStream is = createZipFrom(entry);\n\n    ZipInputStream hardenedStream = ZipSecurity.createHardenedInputStream(is);\n    ZipEntry retrievedEntry = hardenedStream.getNextEntry();\n    assertThat(retrievedEntry.getName(), equalTo(path));\n  }\n\n  @ParameterizedTest\n  @ValueSource(strings = {\"../etc/whatever\", \"/foo/bar/../../../proc/whatever\"})\n  void it_prevents_escapes(String path) throws IOException {\n    ZipEntry entry = new ZipEntry(path);\n    InputStream is = createZipFrom(entry);\n\n    ZipInputStream hardenedStream = ZipSecurity.createHardenedInputStream(is);\n    assertThrows(SecurityException.class, hardenedStream::getNextEntry);\n  }\n\n  @Test\n  void it_prevents_absolute_paths_in_zip_entries() throws IOException {\n    ZipEntry entry = new ZipEntry(\"/foo.txt\");\n    InputStream is = createZipFrom(entry);\n\n    ZipInputStream hardenedStream = ZipSecurity.createHardenedInputStream(is);\n    assertThrows(SecurityException.class, hardenedStream::getNextEntry);\n  }\n\n  private InputStream createZipFrom(final ZipEntry entry) throws IOException {\n    ByteArrayOutputStream os = new ByteArrayOutputStream();\n    ZipOutputStream zos = new ZipOutputStream(os);\n    zos.putNextEntry(entry);\n    zos.closeEntry();\n    zos.close();\n\n    return new ByteArrayInputStream(os.toByteArray());\n  }\n}\n"], "fixing_code": ["[![Actions Status](https://github.com/pixeeworks/java-security-toolkit/workflows/Java%20CI/badge.svg)](https://github.com/pixeeworks/java-security-toolkit/actions)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n# Java Code Security Toolkit\n\nThis utility hosts a number of code security controls for various application security vulnerability categories. It can \nbe used directly by programmers, but you may have been introduced to it by being having it directly added to you code by \nautomation.\n\nMany of the APIs provided are meant to be drop-in replacements that either offer more secure defaults, harden against common attacks, or at least surface the security questions developers should answer when using risky APIs. Here are a few examples:\n\n### Example 1: Safely accessing URLs\n\nFetching [URLs](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/URL.html) is potentially unsafe because of the wide universe of hosts, protocols, and capabilities this may expose. We offer an API that makes it considerably higher assurance, allowing the developer to dictate their expectations about the result, causing a `SecurityException` to be thrown if they're not met:\n\n```diff\n-  URL u = new URL(str); // dangerous -- can be to ftp://evil.com/ for all we know\n+  URL u = Urls.create(str, Set.of(UrlsProtocols.HTTPS), HostValidator.fromAllowedHostPattern(Pattern.compile(\"good\\\\.com\"));\n```\n\n### Example 2: Hardening Java deserialization\n\nDeserializing using [ObjectInputStream](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/ObjectInputStream.html) is [extremely dangerous](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#java) (here's a [from-zero-to-exploit talk](https://www.youtube.com/watch?v=kpuEtsGXKR8) we gave about it).  We offer an API to offer a strong, 1-line, zero-tradeoff protection against this attack.\n\n```diff\n   ObjectInputStream ois = ...;\n+  ObjectInputFilters.enableObjectFilterIfUnprotected(ois); // now protected against all publicly known gadgets\n   Acme acme = (Acme)ois.readObject();\n```\n\n## Adding to your project \n\nIn Maven:\n```xml\n<dependency>\n  <groupId>io.github.pixee</groupId>\n  <artifactId>java-security-toolkit</artifactId>\n  <version>1.1.2</version>\n</dependency>\n```\nIn Gradle:\n```kotlin\nimplementation(\"io.github.pixee:java-security-toolkit:1.1.2\")\n```\n\n## Contributing \nWe'd love to get contributions! See [CONTRIBUTING.md](CONTRIBUTING.md).\n\n### Building\nBuilding is meant for Java 11:\n\n```\n./gradlew check\n```\n\n## FAQ\n\n### How does this compare to OWASP ESAPI?\n\nWe actually contributed to OWASP ESAPI and other OWASP projects in the past and remain fans today! \n\nThere is some limited overlap, but ESAPI is much more broad in its ambitions, and as a result is considerably more \"heavyweight\". It also is not focused on hardening or sandboxing solutions, instead preferring to offer concrete solutions for problems that require business context to implement. Our library also has very few dependencies, no configuration, and is generally designed to offer much less friction to \"drop in\" to a codebase.\n", "import org.javamodularity.moduleplugin.extensions.ModularityExtension\n\nplugins {\n    `java-library`\n    `maven-publish`\n    signing\n    jacoco\n    `jvm-test-suite`\n    id(\"com.netflix.nebula.contacts\") version \"7.0.1\"\n    id(\"com.netflix.nebula.source-jar\") version \"20.3.0\"\n    id(\"com.netflix.nebula.javadoc-jar\") version \"20.3.0\"\n    id(\"com.netflix.nebula.maven-publish\") version \"20.3.0\"\n    id(\"com.netflix.nebula.publish-verification\") version \"20.3.0\"\n    id(\"io.github.gradle-nexus.publish-plugin\") version \"1.3.0\"\n    id(\"org.javamodularity.moduleplugin\") version \"1.8.12\"\n}\n\ntasks.named<Jar>(\"javadocJar\") {\n    exclude(\"module-info.class\")\n}\n\ntasks.named<Jar>(\"sourcesJar\") {\n    dependsOn(\"compileModuleInfoJava\")\n    exclude(\"module-info.class\")\n}\n\ntasks.named<JavaCompile>(\"compileJava\") {\n    options.release.set(null as Int?)\n}\n\nconfigure<ModularityExtension> {\n    mixedJavaRelease(8)\n}\n\ntasks.named<JavaCompile>(\"compileModuleInfoJava\") {\n    options.release.set(null as Int?)\n}\n\nrepositories {\n   mavenCentral()\n}\n\nval java11SourceSet = sourceSets.create(\"java11\") {\n    java.srcDir(\"src/java11/main\")\n    compileClasspath += sourceSets.main.get().output\n}\n\njava {\n    withSourcesJar()\n    withJavadocJar()\n    toolchain {\n        languageVersion.set(JavaLanguageVersion.of(11))\n    }\n\n    registerFeature(\"java11\") {\n        capability(\"io.github.pixee\", \"java11-support\", version.toString())\n        usingSourceSet(java11SourceSet)\n    }\n}\n\ndependencies {\n    api(\"com.martiansoftware:jsap:2.1\")\n    api(\"commons-io:commons-io:2.11.0\")\n    java11SourceSet.apiConfigurationName(\"commons-io:commons-io:2.11.0\")\n    testImplementation(\"org.junit.jupiter:junit-jupiter:5.8.1\")\n    testImplementation(\"org.junit.jupiter:junit-jupiter-params\")\n    testImplementation(\"commons-fileupload:commons-fileupload:1.3.3\")\n    testRuntimeOnly(\"org.junit.platform:junit-platform-launcher\")\n    testImplementation(\"org.hamcrest:hamcrest-all:1.3\")\n    testImplementation(\"org.mockito:mockito-core:4.0.0\")\n}\n\ntasks.named<JavaCompile>(java11SourceSet.compileJavaTaskName) {\n    options.release.set(9)\n}\n\ntasks.jar {\n    into(\"META-INF/versions/11\") {\n        from(java11SourceSet.output)\n    }\n    manifest.attributes(\n        Pair(\"Multi-Release\", \"true\")\n    )\n\n    inputs.files(tasks.named(java11SourceSet.compileJavaTaskName).map { it.outputs.files })\n}\n\ntasks.named(java11SourceSet.jarTaskName) {\n    // disabled because we don't want to publish this separately\n    enabled = false\n}\n\ngroup = \"io.github.pixee\"\nversion = \"1.1.2\"\ndescription = \"java-security-toolkit\"\n\n\nextensions.getByType<nebula.plugin.contacts.ContactsExtension>().run {\n    addPerson(\n        \"support@pixee.ai\",\n        delegateClosureOf<nebula.plugin.contacts.Contact> {\n            moniker(\"Pixee\")\n            github(\"pixee\")\n        },\n    )\n}\n\nval publicationName = \"nebula\"\nsigning {\n    if (providers.environmentVariable(\"CI\").isPresent) {\n        val signingKey: String? by project\n        val signingPassword: String? by project\n        useInMemoryPgpKeys(signingKey, signingPassword)\n    }\n    sign(extensions.getByType<PublishingExtension>().publications.getByName(publicationName))\n}\n\nnexusPublishing {\n    repositories {\n        sonatype {\n            nexusUrl.set(uri(\"https://s01.oss.sonatype.org/service/local/\"))\n            snapshotRepositoryUrl.set(uri(\"https://s01.oss.sonatype.org/content/repositories/snapshots/\"))\n        }\n    }\n}\n\npublishing {\n    publications {\n        named<MavenPublication>(publicationName) {\n            pom {\n                licenses {\n                    license {\n                        name.set(\"MIT License\")\n                        url.set(\"http://www.opensource.org/licenses/mit-license.php\")\n                    }\n                }\n                val scmHost = \"github.com\"\n                val scmProject = \"pixee/java-security-toolkit\"\n                val projectUrl = \"https://$scmHost/$scmProject\"\n                url.set(projectUrl)\n                scm {\n                    url.set(projectUrl)\n                    connection.set(\"scm:git:git@$scmHost:$scmProject\")\n                    developerConnection.set(connection)\n                }\n            }\n        }\n    }\n}\n\ntasks.jacocoTestReport {\n    dependsOn(tasks.test)\n    reports {\n        csv.required.set(true)\n    }\n}\n\ntasks.test {\n    useJUnitPlatform()\n    finalizedBy(tasks.jacocoTestReport)\n    extensions.configure(org.javamodularity.moduleplugin.extensions.TestModuleOptions::class) {\n        // Avoid modules in tests so we can test against Java/JDK 8.\n        setRunOnClasspath(true)\n    }\n\n    javaLauncher.set(javaToolchains.launcherFor {\n        languageVersion.set(JavaLanguageVersion.of(8))\n    })\n}\n\ntesting {\n    suites {\n        @Suppress(\"UnstableApiUsage\")\n        register<JvmTestSuite>(\"java11Test\") {\n            useJUnitJupiter()\n            dependencies {\n                runtimeOnly(project())\n                implementation(project()) {\n                    capabilities {\n                        requireCapabilities(\"io.github.pixee:java11-support\")\n                    }\n                }\n                implementation(\"org.hamcrest:hamcrest-all:1.3\")\n                implementation(\"org.mockito:mockito-core:4.0.0\")\n                implementation(\"commons-fileupload:commons-fileupload:1.3.3\")\n            }\n        }\n\n        register<JvmTestSuite>(\"integrationTest\") {\n            useJUnitJupiter()\n            dependencies {\n                implementation(\"org.junit.jupiter:junit-jupiter-params\")\n                implementation(\"org.testcontainers:testcontainers:1.19.0\")\n                implementation(\"ch.qos.logback:logback-classic:1.2.6\")\n            }\n        }\n    }\n}\n\ntasks.named<Test>(\"java11Test\") {\n    systemProperty(\"org.apache.commons.fileupload.disk.DiskFileItem.serializable\", \"true\")\n}\n\nval java11Test = tasks.register<Test>(\"testOn11\") {\n    useJUnitPlatform()\n    javaLauncher.set(javaToolchains.launcherFor {\n        languageVersion.set(JavaLanguageVersion.of(11))\n    })\n}\n\nval java17Test = tasks.register<Test>(\"testOn17\") {\n    useJUnitPlatform()\n    javaLauncher.set(javaToolchains.launcherFor {\n        languageVersion.set(JavaLanguageVersion.of(17))\n    })\n}\n\ntasks.named<Test>(\"integrationTest\") {\n    this.inputs.file(tasks.jar.map { it.archiveFile} )\n    dependsOn(\":test-apps:hello-world:jibDockerBuild\")\n    dependsOn(\":test-apps:hello-world-modules:jibDockerBuild\")\n    systemProperty(\"securityToolkitJarPath\", tasks.jar.get().archiveFile.get().asFile.relativeTo(projectDir).path)\n}\n\ntasks.check {\n    @Suppress(\"UnstableApiUsage\")\n    dependsOn(java11Test, java17Test, testing.suites.named(\"java11Test\"), testing.suites.named(\"integrationTest\"))\n}\n\ntasks.compileTestJava {\n    extensions.configure(org.javamodularity.moduleplugin.extensions.CompileTestModuleOptions::class) {\n        // Avoid modules in tests so we can test against Java/JDK 8.\n        setCompileOnClasspath(true)\n    }\n    options.release.set(8)\n}\n", "package io.github.pixee.security;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.Charset;\nimport java.nio.file.Path;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\n/**\n * This type exposes helper methods to deal with attacks related to Zipping operations, most notably\n * the \"zip slip\" attack.\n */\npublic final class ZipSecurity {\n\n  private ZipSecurity() {}\n\n  /**\n   * Returns a {@link ZipInputStream} that will check to make sure that paths encountered in the zip\n   * aren't absolute and don't contain escapes (\"..\") towards directories outside the zip's root.\n   */\n  public static ZipInputStream createHardenedInputStream(\n      final InputStream stream, final Charset charset) {\n    return new HardenedZipInputStream(stream, charset);\n  }\n\n  /**\n   * Returns a {@link ZipInputStream} that will check to make sure that paths encountered in the zip\n   * aren't absolute and don't contain escapes (\"..\") towards directories beyond the root of the\n   * zip.\n   */\n  public static ZipInputStream createHardenedInputStream(final InputStream stream) {\n    return new HardenedZipInputStream(stream);\n  }\n\n  private static class HardenedZipInputStream extends ZipInputStream {\n\n    private HardenedZipInputStream(final InputStream in) {\n      super(in);\n    }\n\n    private HardenedZipInputStream(final InputStream in, final Charset charset) {\n      super(in, charset);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>Also checks to see that the path isn't absolute (starts with a root path), doesn't contain\n     * escapes that lead above the root of the zip.\n     */\n    @Override\n    public ZipEntry getNextEntry() throws IOException {\n      final ZipEntry entry = super.getNextEntry();\n      final String name = entry.getName();\n\n      if (!\"\".equals(name.trim())) {\n        if (isRootFileEntry(name)) {\n          throw new SecurityException(\"encountered zip file path that is absolute: \" + name);\n        }\n        if (containsEscapesAndTargetsBelowRoot(name)) {\n          throw new SecurityException(\"path to sensitive locations contained escapes: \" + name);\n        }\n      }\n      return entry;\n    }\n\n    private boolean containsEscapesAndTargetsBelowRoot(final String name) {\n      if (name.contains(\"../\") || name.contains(\"..\\\\\")) {\n        try {\n          if (isBelowOrSisterToCurrentDirectory(name)) {\n            return true;\n          }\n        } catch (IOException e) {\n          // we suppose this may happen in normal operation so best not to do anything\n        }\n      }\n      return false;\n    }\n\n    private boolean isBelowOrSisterToCurrentDirectory(final String untrustedFileWithEscapes) throws IOException {\n      // Get the absolute path of the current directory\n      final File currentDirectory = new File(\"\").getCanonicalFile();\n      final Path currentPathRoot = currentDirectory.toPath();\n      // Get the absolute path of the untrusted file\n      final File untrustedFile = new File(currentDirectory, untrustedFileWithEscapes);\n      final Path pathWithEscapes = untrustedFile.getCanonicalFile().toPath();\n      return !pathWithEscapes.startsWith(currentPathRoot);\n    }\n\n    private boolean isRootFileEntry(final String name) {\n      return name.startsWith(\"/\");\n    }\n  }\n}\n", "package io.github.pixee.security;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.*;\nimport java.nio.charset.StandardCharsets;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\nfinal class ZipSecurityTest {\n\n  @Test\n  void it_doesnt_prevent_normal_zip_file_reads() throws IOException {\n    ZipEntry entry = new ZipEntry(\"normal.txt\");\n    InputStream is = createZipFrom(entry);\n\n    ZipInputStream hardenedStream =\n        ZipSecurity.createHardenedInputStream(is, StandardCharsets.UTF_8);\n    ZipEntry retrievedEntry = hardenedStream.getNextEntry();\n    assertThat(retrievedEntry.getName(), equalTo(\"normal.txt\"));\n  }\n\n  @ParameterizedTest\n  @ValueSource(strings = {\"dir1/dir2/../normal.txt\", \"dir1/../normal.txt\"})\n  void it_doesnt_prevent_normal_zip_files_with_safe_escapes(String path) throws IOException {\n    ZipEntry entry = new ZipEntry(path);\n    InputStream is = createZipFrom(entry);\n\n    ZipInputStream hardenedStream = ZipSecurity.createHardenedInputStream(is);\n    ZipEntry retrievedEntry = hardenedStream.getNextEntry();\n    assertThat(retrievedEntry.getName(), equalTo(path));\n  }\n\n  @ParameterizedTest\n  @ValueSource(strings = {\"../etc/whatever\", \"/foo/bar/../../../proc/whatever\"})\n  void it_prevents_escapes(String path) throws IOException {\n    ZipEntry entry = new ZipEntry(path);\n    InputStream is = createZipFrom(entry);\n\n    ZipInputStream hardenedStream = ZipSecurity.createHardenedInputStream(is);\n    assertThrows(SecurityException.class, hardenedStream::getNextEntry);\n  }\n\n  /**\n   * This tests that there is no regression of CVE-2024-24569, which was a partial path traversal bypass that allowed access to the current working directory's sibling directories.\n   */\n  @Test\n  void it_prevents_sister_directory_escape() throws IOException {\n    String currentDir = new File(\"\").getCanonicalFile().getName();\n    ZipEntry entry = new ZipEntry(\"foo/../../\" + currentDir + \"-other-sister-dir\");\n    InputStream is = createZipFrom(entry);\n\n    ZipInputStream hardenedStream = ZipSecurity.createHardenedInputStream(is);\n    assertThrows(SecurityException.class, hardenedStream::getNextEntry);\n  }\n\n  @Test\n  void it_prevents_absolute_paths_in_zip_entries() throws IOException {\n    ZipEntry entry = new ZipEntry(\"/foo.txt\");\n    InputStream is = createZipFrom(entry);\n\n    ZipInputStream hardenedStream = ZipSecurity.createHardenedInputStream(is);\n    assertThrows(SecurityException.class, hardenedStream::getNextEntry);\n  }\n\n  private InputStream createZipFrom(final ZipEntry entry) throws IOException {\n    ByteArrayOutputStream os = new ByteArrayOutputStream();\n    ZipOutputStream zos = new ZipOutputStream(os);\n    zos.putNextEntry(entry);\n    zos.closeEntry();\n    zos.close();\n\n    return new ByteArrayInputStream(os.toByteArray());\n  }\n}\n"], "filenames": ["README.md", "build.gradle.kts", "src/main/java/io/github/pixee/security/ZipSecurity.java", "src/test/java/io/github/pixee/security/ZipSecurityTest.java"], "buggy_code_start_loc": [38, 94, 6, 7], "buggy_code_end_loc": [54, 95, 87, 52], "fixing_code_start_loc": [38, 94, 7, 7], "fixing_code_end_loc": [54, 95, 90, 63], "type": "CWE-22", "message": "The Pixee Java Code Security Toolkit is a set of security APIs meant to help secure Java code. `ZipSecurity#isBelowCurrentDirectory` is vulnerable to a partial-path traversal bypass. To be vulnerable to the bypass, the application must use toolkit version <=1.1.1, use ZipSecurity as a guard against path traversal, and have an exploit path. Although the control still protects attackers from escaping the application path into higher level directories (e.g., /etc/), it will allow \"escaping\" into sibling paths. For example, if your running path is /my/app/path you an attacker could navigate into /my/app/path-something-else. This vulnerability is patched in 1.1.2.\n\n", "other": {"cve": {"id": "CVE-2024-24569", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-01T19:15:08.360", "lastModified": "2024-02-09T20:15:06.707", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Pixee Java Code Security Toolkit is a set of security APIs meant to help secure Java code. `ZipSecurity#isBelowCurrentDirectory` is vulnerable to a partial-path traversal bypass. To be vulnerable to the bypass, the application must use toolkit version <=1.1.1, use ZipSecurity as a guard against path traversal, and have an exploit path. Although the control still protects attackers from escaping the application path into higher level directories (e.g., /etc/), it will allow \"escaping\" into sibling paths. For example, if your running path is /my/app/path you an attacker could navigate into /my/app/path-something-else. This vulnerability is patched in 1.1.2.\n\n"}, {"lang": "es", "value": "Pixee Java Code Security Toolkit es un conjunto de API de seguridad destinadas a ayudar a proteger el c\u00f3digo Java. `ZipSecurity#isBelowCurrentDirectory` es vulnerable a una omisi\u00f3n de partial-path traversal. Para ser vulnerable a la omisi\u00f3n, la aplicaci\u00f3n debe utilizar la versi\u00f3n del kit de herramientas &lt;=1.1.1, utilizar ZipSecurity como protecci\u00f3n contra el path traversal y tener una ruta de explotaci\u00f3n. Aunque el control todav\u00eda protege a los atacantes de escapar de la ruta de la aplicaci\u00f3n a directorios de nivel superior (por ejemplo, /etc/), permitir\u00e1 \"escapar\" a rutas hermanas. Por ejemplo, si su ruta de ejecuci\u00f3n es /my/app/path, un atacante podr\u00eda navegar hasta /my/app/path-something-else. Esta vulnerabilidad est\u00e1 parcheada en 1.1.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 2.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pixee:java_code_security_toolkit:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.2", "matchCriteriaId": "52A0BFC8-27EE-4122-8AFC-B652D0B6F11B"}]}]}], "references": [{"url": "https://github.com/pixee/java-security-toolkit/blob/7c8e93e6fb2420fb6003c54a741e267c4f883bab/src/main/java/io/github/pixee/security/ZipSecurity.java#L82-L87", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/pixee/java-security-toolkit/commit/b885b03c9cfae53d62d239037f9654d973dd54d9", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pixee/java-security-toolkit/security/advisories/GHSA-qh4g-4m4w-jgv2", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/pixee/java-security-toolkit/commit/b885b03c9cfae53d62d239037f9654d973dd54d9"}}