{"buggy_code": ["# Authors:\n#     Endi S. Dewata <edewata@redhat.com>\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the Lesser GNU General Public License as published by\n# the Free Software Foundation; either version 3 of the License or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n#\n# Copyright (C) 2013 Red Hat, Inc.\n# All rights reserved.\n#\n\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n\nimport functools\nimport inspect\nimport logging\nimport ssl\nimport warnings\n\nimport requests\nfrom requests import adapters\ntry:\n    from requests.packages.urllib3.exceptions import InsecureRequestWarning\nexcept ImportError:\n    from urllib3.exceptions import InsecureRequestWarning\n\nlogger = logging.getLogger(__name__)\n\n\ndef catch_insecure_warning(func):\n    \"\"\"Temporary silence InsecureRequestWarning\n\n    PKIConnection is not able to verify HTTPS connections yet. This decorator\n    catches the warning.\n\n    :see: https://fedorahosted.org/pki/ticket/1253\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore', InsecureRequestWarning)\n            return func(self, *args, **kwargs)\n    return wrapper\n\n\nclass SSLContextAdapter(adapters.HTTPAdapter):\n    \"\"\"Custom SSLContext Adapter for requests\n    \"\"\"\n    def init_poolmanager(self, connections, maxsize,\n                         block=adapters.DEFAULT_POOLBLOCK, **pool_kwargs):\n        context = ssl.SSLContext(\n            ssl.PROTOCOL_TLS  # pylint: disable=no-member\n        )\n\n        # Enable post handshake authentication for TLS 1.3\n        if getattr(context, \"post_handshake_auth\", None) is not None:\n            context.post_handshake_auth = True\n\n        pool_kwargs['ssl_context'] = context\n        return super().init_poolmanager(\n            connections, maxsize, block, **pool_kwargs\n        )\n\n\nclass PKIConnection:\n    \"\"\"\n    Class to encapsulate the connection between the client and a Dogtag\n    subsystem.\n    \"\"\"\n\n    def __init__(self, protocol='http', hostname='localhost', port='8080',\n                 subsystem=None, accept='application/json',\n                 trust_env=None, verify=False):\n        \"\"\"\n        Set the parameters for a python-requests based connection to a\n        Dogtag subsystem.\n        :param protocol: http or https\n        :type protocol: str\n        :param hostname: hostname of server\n        :type hostname: str\n        :param port: port of server\n        :type port: str\n        :param subsystem: Subsystem name: ca, kra, ocsp, tks, tps.\n           DEPRECATED: https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes\n        :type subsystem: str\n        :param accept: value of accept header.  Supported values are usually\n           'application/json' or 'application/xml'\n        :type accept: str\n        :param trust_env: use environment variables for http proxy and other\n           requests settings (default: yes)\n        :type trust_env: bool, None\n        :param verify: verify TLS/SSL connections and configure CA certs\n           (default: no)\n        :type verify: None, bool, str\n        :return: PKIConnection object.\n        \"\"\"\n\n        self.protocol = protocol\n        self.hostname = hostname\n        self.port = port\n        self.subsystem = subsystem\n\n        self.rootURI = self.protocol + '://' + self.hostname + ':' + self.port\n\n        if subsystem is not None:\n            logger.warning(\n                '%s:%s: The subsystem in PKIConnection.__init__() has been deprecated '\n                '(https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes).',\n                inspect.stack()[1].filename, inspect.stack()[1].lineno)\n            self.serverURI = self.rootURI + '/' + subsystem\n        else:\n            self.serverURI = self.rootURI\n\n        self.session = requests.Session()\n        self.session.mount(\"https://\", SSLContextAdapter())\n        self.session.trust_env = trust_env\n        self.session.verify = verify\n\n        if accept:\n            self.session.headers.update({'Accept': accept})\n\n    def authenticate(self, username=None, password=None):\n        \"\"\"\n        Set the parameters used for authentication if username/password is to\n        be used.  Both username and password must not be None.\n        Note that this method only sets the parameters.  Actual authentication\n        occurs when the connection is attempted,\n\n        :param username: username to authenticate connection\n        :param password: password to authenticate connection\n        :return: None\n        \"\"\"\n        if username is not None and password is not None:\n            self.session.auth = (username, password)\n\n    def set_authentication_cert(self, pem_cert_path, pem_key_path=None):\n        \"\"\"\n        Set the path to the PEM file containing the certificate and private key\n        for the client certificate to be used for authentication to the server,\n        when client certificate authentication is required. The private key may\n        optionally be stored in a different path.\n\n        :param pem_cert_path: path to the PEM file\n        :type pem_cert_path: str\n        :param pem_key_path: path to the PEM-formatted private key file\n        :type pem_key_path: str\n        :return: None\n        :raises: Exception if path is empty or None.\n        \"\"\"\n        if pem_cert_path is None:\n            raise Exception(\"No path for the certificate specified.\")\n        if len(str(pem_cert_path)) == 0:\n            raise Exception(\"No path for the certificate specified.\")\n        if pem_key_path is not None:\n            self.session.cert = (pem_cert_path, pem_key_path)\n        else:\n            self.session.cert = pem_cert_path\n\n    @catch_insecure_warning\n    def get(self, path, headers=None, params=None, payload=None,\n            use_root_uri=False, timeout=None):\n        \"\"\"\n        Uses python-requests to issue a GET request to the server.\n\n        :param path: path URI for the GET request\n        :type path: str\n        :param headers: headers for the GET request\n        :type headers: dict\n        :param params: Query parameters for the GET request\n        :type params: dict or bytes\n        :param payload: data to be sent in the body of the request\n        :type payload: dict, bytes, file-like object\n        :param use_root_uri: use root URI instead of subsystem URI as base\n        :type use_root_uri: boolean\n        :returns: request.response -- response from the server\n        :raises: Exception from python-requests in case the GET was not\n            successful, or returns an error code.\n        \"\"\"\n        if use_root_uri:\n            logger.warning(\n                '%s:%s: The use_root_uri in PKIConnection.get() has been deprecated '\n                '(https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes).',\n                inspect.stack()[1].filename, inspect.stack()[1].lineno)\n            target_path = self.rootURI + path\n        else:\n            target_path = self.serverURI + path\n\n        r = self.session.get(\n            target_path,\n            headers=headers,\n            params=params,\n            data=payload,\n            timeout=timeout,\n        )\n        r.raise_for_status()\n        return r\n\n    @catch_insecure_warning\n    def post(self, path, payload, headers=None, params=None,\n             use_root_uri=False):\n        \"\"\"\n        Uses python-requests to issue a POST request to the server.\n\n        :param path: path URI for the POST request\n        :type path: str\n        :param payload: data to be sent in the body of the request\n        :type payload: dict, bytes, file-like object\n        :param headers: headers for the POST request\n        :type headers: dict\n        :param params: Query parameters for the POST request\n        :type params: dict or bytes\n        :param use_root_uri: use root URI instead of subsystem URI as base\n        :type use_root_uri: boolean\n        :returns: request.response -- response from the server\n        :raises: Exception from python-requests in case the POST was not\n            successful, or returns an error code.\n        \"\"\"\n        if use_root_uri:\n            logger.warning(\n                '%s:%s: The use_root_uri in PKIConnection.post() has been deprecated '\n                '(https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes).',\n                inspect.stack()[1].filename, inspect.stack()[1].lineno)\n            target_path = self.rootURI + path\n        else:\n            target_path = self.serverURI + path\n\n        r = self.session.post(\n            target_path,\n            data=payload,\n            headers=headers,\n            params=params)\n        r.raise_for_status()\n        return r\n\n    @catch_insecure_warning\n    def put(self, path, payload, headers=None, use_root_uri=False):\n        \"\"\"\n        Uses python-requests to issue a PUT request to the server.\n\n        :param path: path URI for the PUT request\n        :type path: str\n        :param payload: data to be sent in the body of the request\n        :type payload: dict, bytes, file-like object\n        :param headers: headers for the PUT request\n        :type headers: dict\n        :param use_root_uri: use root URI instead of subsystem URI as base\n        :type use_root_uri: boolean\n        :returns: request.response -- response from the server\n        :raises: Exception from python-requests in case the PUT was not\n            successful, or returns an error code.\n        \"\"\"\n        if use_root_uri:\n            logger.warning(\n                '%s:%s: The use_root_uri in PKIConnection.put() has been deprecated '\n                '(https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes).',\n                inspect.stack()[1].filename, inspect.stack()[1].lineno)\n            target_path = self.rootURI + path\n        else:\n            target_path = self.serverURI + path\n\n        r = self.session.put(target_path, payload, headers=headers)\n        r.raise_for_status()\n        return r\n\n    @catch_insecure_warning\n    def delete(self, path, headers=None, use_root_uri=False):\n        \"\"\"\n        Uses python-requests to issue a DEL request to the server.\n\n        :param path: path URI for the DEL request\n        :type path: str\n        :param headers: headers for the DEL request\n        :type headers: dict\n        :param use_root_uri: use root URI instead of subsystem URI as base\n        :type use_root_uri: boolean\n        :returns: request.response -- response from the server\n        :raises: Exception from python-requests in case the DEL was not\n            successful, or returns an error code.\n        \"\"\"\n        if use_root_uri:\n            logger.warning(\n                '%s:%s: The use_root_uri in PKIConnection.delete() has been deprecated '\n                '(https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes).',\n                inspect.stack()[1].filename, inspect.stack()[1].lineno)\n            target_path = self.rootURI + path\n        else:\n            target_path = self.serverURI + path\n\n        r = self.session.delete(target_path, headers=headers)\n        r.raise_for_status()\n        return r\n\n\ndef main():\n    \"\"\"\n    Test code for the PKIConnection class.\n    :return: None\n    \"\"\"\n    conn = PKIConnection()\n    headers = {'Content-type': 'application/json',\n               'Accept': 'application/json'}\n    conn.set_authentication_cert('/root/temp4.pem')\n    print(conn.get(\"\", headers).json())\n\n\nif __name__ == \"__main__\":\n    main()\n"], "fixing_code": ["# Authors:\n#     Endi S. Dewata <edewata@redhat.com>\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the Lesser GNU General Public License as published by\n# the Free Software Foundation; either version 3 of the License or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n#\n# Copyright (C) 2013 Red Hat, Inc.\n# All rights reserved.\n#\n\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n\nimport functools\nimport inspect\nimport logging\nimport os\nimport ssl\nimport warnings\n\nimport requests\nfrom requests import adapters\nfrom requests.adapters import DEFAULT_POOLBLOCK, DEFAULT_POOLSIZE, DEFAULT_RETRIES\ntry:\n    from requests.packages.urllib3.exceptions import InsecureRequestWarning\nexcept ImportError:\n    from urllib3.exceptions import InsecureRequestWarning\n\nlogger = logging.getLogger(__name__)\n\n\ndef catch_insecure_warning(func):\n    \"\"\"Temporary silence InsecureRequestWarning\n\n    PKIConnection is not able to verify HTTPS connections yet. This decorator\n    catches the warning.\n\n    :see: https://fedorahosted.org/pki/ticket/1253\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore', InsecureRequestWarning)\n            return func(self, *args, **kwargs)\n    return wrapper\n\n\nclass SSLContextAdapter(adapters.HTTPAdapter):\n    \"\"\"\n    Custom SSLContext Adapter for requests\n    \"\"\"\n\n    def __init__(self, pool_connections=DEFAULT_POOLSIZE,\n                 pool_maxsize=DEFAULT_POOLSIZE, max_retries=DEFAULT_RETRIES,\n                 pool_block=DEFAULT_POOLBLOCK, verify=True,\n                 cert_paths=None):\n        self.verify = verify\n        self.cafiles = []\n        self.capaths = []\n\n        cert_paths = cert_paths or []\n\n        if isinstance(cert_paths, str):\n            cert_paths = [cert_paths]\n\n        for path in cert_paths:\n            path = path and os.path.expanduser(path)\n\n            if os.path.isdir(path):\n                self.capaths.append(path)\n            elif os.path.exists(path):\n                self.cafiles.append(path)\n            else:\n                logger.warning(\"cert_path missing; not used for validation: %s\",\n                               path)\n\n        # adapters.HTTPAdapter.__init__ calls our init_poolmanager, which needs\n        # our cafiles/capaths variables we set up above.\n        super(SSLContextAdapter, self).__init__(pool_connections=pool_connections,\n                                                pool_maxsize=pool_maxsize,\n                                                max_retries=max_retries,\n                                                pool_block=pool_block)\n\n    def init_poolmanager(self, connections, maxsize,\n                         block=adapters.DEFAULT_POOLBLOCK, **pool_kwargs):\n        context = ssl.SSLContext(\n            ssl.PROTOCOL_TLS  # pylint: disable=no-member\n        )\n\n        # Enable post handshake authentication for TLS 1.3\n        if getattr(context, \"post_handshake_auth\", None) is not None:\n            context.post_handshake_auth = True\n\n        # Load from the system trust store when possible; per documentation\n        # this call could silently fail and refuse to configure any\n        # certificates. In this instance, the user should provide a\n        # certificate manually.\n        context.set_default_verify_paths()\n\n        # Load any specific certificate paths that have been specified during\n        # adapter initialization.\n        for cafile in self.cafiles:\n            context.load_verify_locations(cafile=cafile)\n        for capath in self.capaths:\n            context.load_verify_locations(capath=capath)\n\n        if self.verify:\n            # Enable certificate verification\n            context.verify_mode = ssl.VerifyMode.CERT_REQUIRED  # pylint: disable=no-member\n\n        pool_kwargs['ssl_context'] = context\n        return super().init_poolmanager(\n            connections, maxsize, block, **pool_kwargs\n        )\n\n\nclass PKIConnection:\n    \"\"\"\n    Class to encapsulate the connection between the client and a Dogtag\n    subsystem.\n    \"\"\"\n\n    def __init__(self, protocol='http', hostname='localhost', port='8080',\n                 subsystem=None, accept='application/json',\n                 trust_env=None, verify=True, cert_paths=None):\n        \"\"\"\n        Set the parameters for a python-requests based connection to a\n        Dogtag subsystem.\n        :param protocol: http or https\n        :type protocol: str\n        :param hostname: hostname of server\n        :type hostname: str\n        :param port: port of server\n        :type port: str\n        :param subsystem: Subsystem name: ca, kra, ocsp, tks, tps.\n           DEPRECATED: https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes\n        :type subsystem: str\n        :param accept: value of accept header.  Supported values are usually\n           'application/json' or 'application/xml'\n        :type accept: str\n        :param trust_env: use environment variables for http proxy and other\n           requests settings (default: yes)\n        :type trust_env: bool, None\n        :param verify: verify TLS/SSL connections and configure CA certs\n           (default: no)\n        :type verify: None, bool, str\n        :param cert_paths: paths to CA certificates / directories in OpenSSL\n          format. (default: None)\n        :type cert_paths: None, str, list\n        :return: PKIConnection object.\n        \"\"\"\n\n        self.protocol = protocol\n        self.hostname = hostname\n        self.port = port\n        self.subsystem = subsystem\n\n        self.rootURI = self.protocol + '://' + self.hostname + ':' + self.port\n\n        if subsystem is not None:\n            logger.warning(\n                '%s:%s: The subsystem in PKIConnection.__init__() has been deprecated '\n                '(https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes).',\n                inspect.stack()[1].filename, inspect.stack()[1].lineno)\n            self.serverURI = self.rootURI + '/' + subsystem\n        else:\n            self.serverURI = self.rootURI\n\n        self.session = requests.Session()\n        self.session.mount(\"https://\", SSLContextAdapter(verify=verify, cert_paths=cert_paths))\n        self.session.trust_env = trust_env\n        self.session.verify = verify\n\n        if accept:\n            self.session.headers.update({'Accept': accept})\n\n    def authenticate(self, username=None, password=None):\n        \"\"\"\n        Set the parameters used for authentication if username/password is to\n        be used.  Both username and password must not be None.\n        Note that this method only sets the parameters.  Actual authentication\n        occurs when the connection is attempted,\n\n        :param username: username to authenticate connection\n        :param password: password to authenticate connection\n        :return: None\n        \"\"\"\n        if username is not None and password is not None:\n            self.session.auth = (username, password)\n\n    def set_authentication_cert(self, pem_cert_path, pem_key_path=None):\n        \"\"\"\n        Set the path to the PEM file containing the certificate and private key\n        for the client certificate to be used for authentication to the server,\n        when client certificate authentication is required. The private key may\n        optionally be stored in a different path.\n\n        :param pem_cert_path: path to the PEM file\n        :type pem_cert_path: str\n        :param pem_key_path: path to the PEM-formatted private key file\n        :type pem_key_path: str\n        :return: None\n        :raises: Exception if path is empty or None.\n        \"\"\"\n        if pem_cert_path is None:\n            raise Exception(\"No path for the certificate specified.\")\n        if len(str(pem_cert_path)) == 0:\n            raise Exception(\"No path for the certificate specified.\")\n        if pem_key_path is not None:\n            self.session.cert = (pem_cert_path, pem_key_path)\n        else:\n            self.session.cert = pem_cert_path\n\n    @catch_insecure_warning\n    def get(self, path, headers=None, params=None, payload=None,\n            use_root_uri=False, timeout=None):\n        \"\"\"\n        Uses python-requests to issue a GET request to the server.\n\n        :param path: path URI for the GET request\n        :type path: str\n        :param headers: headers for the GET request\n        :type headers: dict\n        :param params: Query parameters for the GET request\n        :type params: dict or bytes\n        :param payload: data to be sent in the body of the request\n        :type payload: dict, bytes, file-like object\n        :param use_root_uri: use root URI instead of subsystem URI as base\n        :type use_root_uri: boolean\n        :returns: request.response -- response from the server\n        :raises: Exception from python-requests in case the GET was not\n            successful, or returns an error code.\n        \"\"\"\n        if use_root_uri:\n            logger.warning(\n                '%s:%s: The use_root_uri in PKIConnection.get() has been deprecated '\n                '(https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes).',\n                inspect.stack()[1].filename, inspect.stack()[1].lineno)\n            target_path = self.rootURI + path\n        else:\n            target_path = self.serverURI + path\n\n        r = self.session.get(\n            target_path,\n            headers=headers,\n            params=params,\n            data=payload,\n            timeout=timeout,\n        )\n        r.raise_for_status()\n        return r\n\n    @catch_insecure_warning\n    def post(self, path, payload, headers=None, params=None,\n             use_root_uri=False):\n        \"\"\"\n        Uses python-requests to issue a POST request to the server.\n\n        :param path: path URI for the POST request\n        :type path: str\n        :param payload: data to be sent in the body of the request\n        :type payload: dict, bytes, file-like object\n        :param headers: headers for the POST request\n        :type headers: dict\n        :param params: Query parameters for the POST request\n        :type params: dict or bytes\n        :param use_root_uri: use root URI instead of subsystem URI as base\n        :type use_root_uri: boolean\n        :returns: request.response -- response from the server\n        :raises: Exception from python-requests in case the POST was not\n            successful, or returns an error code.\n        \"\"\"\n        if use_root_uri:\n            logger.warning(\n                '%s:%s: The use_root_uri in PKIConnection.post() has been deprecated '\n                '(https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes).',\n                inspect.stack()[1].filename, inspect.stack()[1].lineno)\n            target_path = self.rootURI + path\n        else:\n            target_path = self.serverURI + path\n\n        r = self.session.post(\n            target_path,\n            data=payload,\n            headers=headers,\n            params=params)\n        r.raise_for_status()\n        return r\n\n    @catch_insecure_warning\n    def put(self, path, payload, headers=None, use_root_uri=False):\n        \"\"\"\n        Uses python-requests to issue a PUT request to the server.\n\n        :param path: path URI for the PUT request\n        :type path: str\n        :param payload: data to be sent in the body of the request\n        :type payload: dict, bytes, file-like object\n        :param headers: headers for the PUT request\n        :type headers: dict\n        :param use_root_uri: use root URI instead of subsystem URI as base\n        :type use_root_uri: boolean\n        :returns: request.response -- response from the server\n        :raises: Exception from python-requests in case the PUT was not\n            successful, or returns an error code.\n        \"\"\"\n        if use_root_uri:\n            logger.warning(\n                '%s:%s: The use_root_uri in PKIConnection.put() has been deprecated '\n                '(https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes).',\n                inspect.stack()[1].filename, inspect.stack()[1].lineno)\n            target_path = self.rootURI + path\n        else:\n            target_path = self.serverURI + path\n\n        r = self.session.put(target_path, payload, headers=headers)\n        r.raise_for_status()\n        return r\n\n    @catch_insecure_warning\n    def delete(self, path, headers=None, use_root_uri=False):\n        \"\"\"\n        Uses python-requests to issue a DEL request to the server.\n\n        :param path: path URI for the DEL request\n        :type path: str\n        :param headers: headers for the DEL request\n        :type headers: dict\n        :param use_root_uri: use root URI instead of subsystem URI as base\n        :type use_root_uri: boolean\n        :returns: request.response -- response from the server\n        :raises: Exception from python-requests in case the DEL was not\n            successful, or returns an error code.\n        \"\"\"\n        if use_root_uri:\n            logger.warning(\n                '%s:%s: The use_root_uri in PKIConnection.delete() has been deprecated '\n                '(https://www.dogtagpki.org/wiki/PKI_10.8_Python_Changes).',\n                inspect.stack()[1].filename, inspect.stack()[1].lineno)\n            target_path = self.rootURI + path\n        else:\n            target_path = self.serverURI + path\n\n        r = self.session.delete(target_path, headers=headers)\n        r.raise_for_status()\n        return r\n\n\ndef main():\n    \"\"\"\n    Test code for the PKIConnection class.\n    :return: None\n    \"\"\"\n    conn = PKIConnection()\n    headers = {'Content-type': 'application/json',\n               'Accept': 'application/json'}\n    conn.set_authentication_cert('/root/temp4.pem')\n    print(conn.get(\"\", headers).json())\n\n\nif __name__ == \"__main__\":\n    main()\n"], "filenames": ["base/common/python/pki/client.py"], "buggy_code_start_loc": [27], "buggy_code_end_loc": [127], "fixing_code_start_loc": [28], "fixing_code_end_loc": [182], "type": "CWE-295", "message": "In Dogtag PKI through 10.8.3, the pki.client.PKIConnection class did not enable python-requests certificate validation. Since the verify parameter was hard-coded in all request functions, it was not possible to override the setting. As a result, tools making use of this class, such as the pki-server command, may have been vulnerable to Person-in-the-Middle attacks in certain non-localhost use cases. This is fixed in 10.9.0-b1.", "other": {"cve": {"id": "CVE-2020-15720", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-14T14:15:17.713", "lastModified": "2020-07-23T16:33:46.347", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Dogtag PKI through 10.8.3, the pki.client.PKIConnection class did not enable python-requests certificate validation. Since the verify parameter was hard-coded in all request functions, it was not possible to override the setting. As a result, tools making use of this class, such as the pki-server command, may have been vulnerable to Person-in-the-Middle attacks in certain non-localhost use cases. This is fixed in 10.9.0-b1."}, {"lang": "es", "value": "En Dogtag PKI versiones hasta 10.8.3, la clase pki.client.PKIConnection no habilit\u00f3 la comprobaci\u00f3n de certificados de peticiones de python. Como el par\u00e1metro de verificaci\u00f3n estaba embebido en todas las funciones de petici\u00f3n, no fue posible anular la configuraci\u00f3n. Como resultado, las herramientas que utilizan esta clase, tal y como el comando pki-server, pueden haber sido vulnerables a ataques de tipo Person-in-the-Middle en determinados casos de uso de un no localhost. Esto es corregido en la versi\u00f3n 10.9.0-b1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dogtagpki:dogtagpki:*:*:*:*:*:*:*:*", "versionEndIncluding": "10.8.3", "matchCriteriaId": "5287DE9F-F5F5-49E5-A1DF-CEED5D0255FA"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1855273", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/dogtagpki/pki/commit/50c23ec146ee9abf28c9de87a5f7787d495f0b72", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dogtagpki/pki/compare/v10.9.0-a2...v10.9.0-b1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dogtagpki/pki/commit/50c23ec146ee9abf28c9de87a5f7787d495f0b72"}}