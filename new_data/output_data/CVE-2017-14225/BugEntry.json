{"buggy_code": ["/*\n * Copyright (c) 2007-2010 Stefano Sabatini\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * simple media prober based on the FFmpeg libraries\n */\n\n#include \"config.h\"\n#include \"libavutil/ffversion.h\"\n\n#include <string.h>\n\n#include \"libavformat/avformat.h\"\n#include \"libavcodec/avcodec.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/bprint.h\"\n#include \"libavutil/display.h\"\n#include \"libavutil/hash.h\"\n#include \"libavutil/mastering_display_metadata.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"libavutil/spherical.h\"\n#include \"libavutil/stereo3d.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/libm.h\"\n#include \"libavutil/parseutils.h\"\n#include \"libavutil/timecode.h\"\n#include \"libavutil/timestamp.h\"\n#include \"libavdevice/avdevice.h\"\n#include \"libswscale/swscale.h\"\n#include \"libswresample/swresample.h\"\n#include \"libpostproc/postprocess.h\"\n#include \"cmdutils.h\"\n\n#include \"libavutil/thread.h\"\n\n#if !HAVE_THREADS\n#  ifdef pthread_mutex_lock\n#    undef pthread_mutex_lock\n#  endif\n#  define pthread_mutex_lock(a) do{}while(0)\n#  ifdef pthread_mutex_unlock\n#    undef pthread_mutex_unlock\n#  endif\n#  define pthread_mutex_unlock(a) do{}while(0)\n#endif\n\ntypedef struct InputStream {\n    AVStream *st;\n\n    AVCodecContext *dec_ctx;\n} InputStream;\n\ntypedef struct InputFile {\n    AVFormatContext *fmt_ctx;\n\n    InputStream *streams;\n    int       nb_streams;\n} InputFile;\n\nconst char program_name[] = \"ffprobe\";\nconst int program_birth_year = 2007;\n\nstatic int do_bitexact = 0;\nstatic int do_count_frames = 0;\nstatic int do_count_packets = 0;\nstatic int do_read_frames  = 0;\nstatic int do_read_packets = 0;\nstatic int do_show_chapters = 0;\nstatic int do_show_error   = 0;\nstatic int do_show_format  = 0;\nstatic int do_show_frames  = 0;\nstatic int do_show_packets = 0;\nstatic int do_show_programs = 0;\nstatic int do_show_streams = 0;\nstatic int do_show_stream_disposition = 0;\nstatic int do_show_data    = 0;\nstatic int do_show_program_version  = 0;\nstatic int do_show_library_versions = 0;\nstatic int do_show_pixel_formats = 0;\nstatic int do_show_pixel_format_flags = 0;\nstatic int do_show_pixel_format_components = 0;\nstatic int do_show_log = 0;\n\nstatic int do_show_chapter_tags = 0;\nstatic int do_show_format_tags = 0;\nstatic int do_show_frame_tags = 0;\nstatic int do_show_program_tags = 0;\nstatic int do_show_stream_tags = 0;\nstatic int do_show_packet_tags = 0;\n\nstatic int show_value_unit              = 0;\nstatic int use_value_prefix             = 0;\nstatic int use_byte_value_binary_prefix = 0;\nstatic int use_value_sexagesimal_format = 0;\nstatic int show_private_data            = 1;\n\nstatic char *print_format;\nstatic char *stream_specifier;\nstatic char *show_data_hash;\n\ntypedef struct ReadInterval {\n    int id;             ///< identifier\n    int64_t start, end; ///< start, end in second/AV_TIME_BASE units\n    int has_start, has_end;\n    int start_is_offset, end_is_offset;\n    int duration_frames;\n} ReadInterval;\n\nstatic ReadInterval *read_intervals;\nstatic int read_intervals_nb = 0;\n\nstatic int find_stream_info  = 1;\n\n/* section structure definition */\n\n#define SECTION_MAX_NB_CHILDREN 10\n\nstruct section {\n    int id;             ///< unique id identifying a section\n    const char *name;\n\n#define SECTION_FLAG_IS_WRAPPER      1 ///< the section only contains other sections, but has no data at its own level\n#define SECTION_FLAG_IS_ARRAY        2 ///< the section contains an array of elements of the same type\n#define SECTION_FLAG_HAS_VARIABLE_FIELDS 4 ///< the section may contain a variable number of fields with variable keys.\n                                           ///  For these sections the element_name field is mandatory.\n    int flags;\n    int children_ids[SECTION_MAX_NB_CHILDREN+1]; ///< list of children section IDS, terminated by -1\n    const char *element_name; ///< name of the contained element, if provided\n    const char *unique_name;  ///< unique section name, in case the name is ambiguous\n    AVDictionary *entries_to_show;\n    int show_all_entries;\n};\n\ntypedef enum {\n    SECTION_ID_NONE = -1,\n    SECTION_ID_CHAPTER,\n    SECTION_ID_CHAPTER_TAGS,\n    SECTION_ID_CHAPTERS,\n    SECTION_ID_ERROR,\n    SECTION_ID_FORMAT,\n    SECTION_ID_FORMAT_TAGS,\n    SECTION_ID_FRAME,\n    SECTION_ID_FRAMES,\n    SECTION_ID_FRAME_TAGS,\n    SECTION_ID_FRAME_SIDE_DATA_LIST,\n    SECTION_ID_FRAME_SIDE_DATA,\n    SECTION_ID_FRAME_LOG,\n    SECTION_ID_FRAME_LOGS,\n    SECTION_ID_LIBRARY_VERSION,\n    SECTION_ID_LIBRARY_VERSIONS,\n    SECTION_ID_PACKET,\n    SECTION_ID_PACKET_TAGS,\n    SECTION_ID_PACKETS,\n    SECTION_ID_PACKETS_AND_FRAMES,\n    SECTION_ID_PACKET_SIDE_DATA_LIST,\n    SECTION_ID_PACKET_SIDE_DATA,\n    SECTION_ID_PIXEL_FORMAT,\n    SECTION_ID_PIXEL_FORMAT_FLAGS,\n    SECTION_ID_PIXEL_FORMAT_COMPONENT,\n    SECTION_ID_PIXEL_FORMAT_COMPONENTS,\n    SECTION_ID_PIXEL_FORMATS,\n    SECTION_ID_PROGRAM_STREAM_DISPOSITION,\n    SECTION_ID_PROGRAM_STREAM_TAGS,\n    SECTION_ID_PROGRAM,\n    SECTION_ID_PROGRAM_STREAMS,\n    SECTION_ID_PROGRAM_STREAM,\n    SECTION_ID_PROGRAM_TAGS,\n    SECTION_ID_PROGRAM_VERSION,\n    SECTION_ID_PROGRAMS,\n    SECTION_ID_ROOT,\n    SECTION_ID_STREAM,\n    SECTION_ID_STREAM_DISPOSITION,\n    SECTION_ID_STREAMS,\n    SECTION_ID_STREAM_TAGS,\n    SECTION_ID_STREAM_SIDE_DATA_LIST,\n    SECTION_ID_STREAM_SIDE_DATA,\n    SECTION_ID_SUBTITLE,\n} SectionID;\n\nstatic struct section sections[] = {\n    [SECTION_ID_CHAPTERS] =           { SECTION_ID_CHAPTERS, \"chapters\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_CHAPTER, -1 } },\n    [SECTION_ID_CHAPTER] =            { SECTION_ID_CHAPTER, \"chapter\", 0, { SECTION_ID_CHAPTER_TAGS, -1 } },\n    [SECTION_ID_CHAPTER_TAGS] =       { SECTION_ID_CHAPTER_TAGS, \"tags\", SECTION_FLAG_HAS_VARIABLE_FIELDS, { -1 }, .element_name = \"tag\", .unique_name = \"chapter_tags\" },\n    [SECTION_ID_ERROR] =              { SECTION_ID_ERROR, \"error\", 0, { -1 } },\n    [SECTION_ID_FORMAT] =             { SECTION_ID_FORMAT, \"format\", 0, { SECTION_ID_FORMAT_TAGS, -1 } },\n    [SECTION_ID_FORMAT_TAGS] =        { SECTION_ID_FORMAT_TAGS, \"tags\", SECTION_FLAG_HAS_VARIABLE_FIELDS, { -1 }, .element_name = \"tag\", .unique_name = \"format_tags\" },\n    [SECTION_ID_FRAMES] =             { SECTION_ID_FRAMES, \"frames\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_FRAME, SECTION_ID_SUBTITLE, -1 } },\n    [SECTION_ID_FRAME] =              { SECTION_ID_FRAME, \"frame\", 0, { SECTION_ID_FRAME_TAGS, SECTION_ID_FRAME_SIDE_DATA_LIST, SECTION_ID_FRAME_LOGS, -1 } },\n    [SECTION_ID_FRAME_TAGS] =         { SECTION_ID_FRAME_TAGS, \"tags\", SECTION_FLAG_HAS_VARIABLE_FIELDS, { -1 }, .element_name = \"tag\", .unique_name = \"frame_tags\" },\n    [SECTION_ID_FRAME_SIDE_DATA_LIST] ={ SECTION_ID_FRAME_SIDE_DATA_LIST, \"side_data_list\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_FRAME_SIDE_DATA, -1 }, .element_name = \"side_data\", .unique_name = \"frame_side_data_list\" },\n    [SECTION_ID_FRAME_SIDE_DATA] =     { SECTION_ID_FRAME_SIDE_DATA, \"side_data\", 0, { -1 } },\n    [SECTION_ID_FRAME_LOGS] =         { SECTION_ID_FRAME_LOGS, \"logs\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_FRAME_LOG, -1 } },\n    [SECTION_ID_FRAME_LOG] =          { SECTION_ID_FRAME_LOG, \"log\", 0, { -1 },  },\n    [SECTION_ID_LIBRARY_VERSIONS] =   { SECTION_ID_LIBRARY_VERSIONS, \"library_versions\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_LIBRARY_VERSION, -1 } },\n    [SECTION_ID_LIBRARY_VERSION] =    { SECTION_ID_LIBRARY_VERSION, \"library_version\", 0, { -1 } },\n    [SECTION_ID_PACKETS] =            { SECTION_ID_PACKETS, \"packets\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_PACKET, -1} },\n    [SECTION_ID_PACKETS_AND_FRAMES] = { SECTION_ID_PACKETS_AND_FRAMES, \"packets_and_frames\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_PACKET, -1} },\n    [SECTION_ID_PACKET] =             { SECTION_ID_PACKET, \"packet\", 0, { SECTION_ID_PACKET_TAGS, SECTION_ID_PACKET_SIDE_DATA_LIST, -1 } },\n    [SECTION_ID_PACKET_TAGS] =        { SECTION_ID_PACKET_TAGS, \"tags\", SECTION_FLAG_HAS_VARIABLE_FIELDS, { -1 }, .element_name = \"tag\", .unique_name = \"packet_tags\" },\n    [SECTION_ID_PACKET_SIDE_DATA_LIST] ={ SECTION_ID_PACKET_SIDE_DATA_LIST, \"side_data_list\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_PACKET_SIDE_DATA, -1 }, .element_name = \"side_data\", .unique_name = \"packet_side_data_list\" },\n    [SECTION_ID_PACKET_SIDE_DATA] =     { SECTION_ID_PACKET_SIDE_DATA, \"side_data\", 0, { -1 } },\n    [SECTION_ID_PIXEL_FORMATS] =      { SECTION_ID_PIXEL_FORMATS, \"pixel_formats\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_PIXEL_FORMAT, -1 } },\n    [SECTION_ID_PIXEL_FORMAT] =       { SECTION_ID_PIXEL_FORMAT, \"pixel_format\", 0, { SECTION_ID_PIXEL_FORMAT_FLAGS, SECTION_ID_PIXEL_FORMAT_COMPONENTS, -1 } },\n    [SECTION_ID_PIXEL_FORMAT_FLAGS] = { SECTION_ID_PIXEL_FORMAT_FLAGS, \"flags\", 0, { -1 }, .unique_name = \"pixel_format_flags\" },\n    [SECTION_ID_PIXEL_FORMAT_COMPONENTS] = { SECTION_ID_PIXEL_FORMAT_COMPONENTS, \"components\", SECTION_FLAG_IS_ARRAY, {SECTION_ID_PIXEL_FORMAT_COMPONENT, -1 }, .unique_name = \"pixel_format_components\" },\n    [SECTION_ID_PIXEL_FORMAT_COMPONENT]  = { SECTION_ID_PIXEL_FORMAT_COMPONENT, \"component\", 0, { -1 } },\n    [SECTION_ID_PROGRAM_STREAM_DISPOSITION] = { SECTION_ID_PROGRAM_STREAM_DISPOSITION, \"disposition\", 0, { -1 }, .unique_name = \"program_stream_disposition\" },\n    [SECTION_ID_PROGRAM_STREAM_TAGS] =        { SECTION_ID_PROGRAM_STREAM_TAGS, \"tags\", SECTION_FLAG_HAS_VARIABLE_FIELDS, { -1 }, .element_name = \"tag\", .unique_name = \"program_stream_tags\" },\n    [SECTION_ID_PROGRAM] =                    { SECTION_ID_PROGRAM, \"program\", 0, { SECTION_ID_PROGRAM_TAGS, SECTION_ID_PROGRAM_STREAMS, -1 } },\n    [SECTION_ID_PROGRAM_STREAMS] =            { SECTION_ID_PROGRAM_STREAMS, \"streams\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_PROGRAM_STREAM, -1 }, .unique_name = \"program_streams\" },\n    [SECTION_ID_PROGRAM_STREAM] =             { SECTION_ID_PROGRAM_STREAM, \"stream\", 0, { SECTION_ID_PROGRAM_STREAM_DISPOSITION, SECTION_ID_PROGRAM_STREAM_TAGS, -1 }, .unique_name = \"program_stream\" },\n    [SECTION_ID_PROGRAM_TAGS] =               { SECTION_ID_PROGRAM_TAGS, \"tags\", SECTION_FLAG_HAS_VARIABLE_FIELDS, { -1 }, .element_name = \"tag\", .unique_name = \"program_tags\" },\n    [SECTION_ID_PROGRAM_VERSION] =    { SECTION_ID_PROGRAM_VERSION, \"program_version\", 0, { -1 } },\n    [SECTION_ID_PROGRAMS] =                   { SECTION_ID_PROGRAMS, \"programs\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_PROGRAM, -1 } },\n    [SECTION_ID_ROOT] =               { SECTION_ID_ROOT, \"root\", SECTION_FLAG_IS_WRAPPER,\n                                        { SECTION_ID_CHAPTERS, SECTION_ID_FORMAT, SECTION_ID_FRAMES, SECTION_ID_PROGRAMS, SECTION_ID_STREAMS,\n                                          SECTION_ID_PACKETS, SECTION_ID_ERROR, SECTION_ID_PROGRAM_VERSION, SECTION_ID_LIBRARY_VERSIONS,\n                                          SECTION_ID_PIXEL_FORMATS, -1} },\n    [SECTION_ID_STREAMS] =            { SECTION_ID_STREAMS, \"streams\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_STREAM, -1 } },\n    [SECTION_ID_STREAM] =             { SECTION_ID_STREAM, \"stream\", 0, { SECTION_ID_STREAM_DISPOSITION, SECTION_ID_STREAM_TAGS, SECTION_ID_STREAM_SIDE_DATA_LIST, -1 } },\n    [SECTION_ID_STREAM_DISPOSITION] = { SECTION_ID_STREAM_DISPOSITION, \"disposition\", 0, { -1 }, .unique_name = \"stream_disposition\" },\n    [SECTION_ID_STREAM_TAGS] =        { SECTION_ID_STREAM_TAGS, \"tags\", SECTION_FLAG_HAS_VARIABLE_FIELDS, { -1 }, .element_name = \"tag\", .unique_name = \"stream_tags\" },\n    [SECTION_ID_STREAM_SIDE_DATA_LIST] ={ SECTION_ID_STREAM_SIDE_DATA_LIST, \"side_data_list\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_STREAM_SIDE_DATA, -1 }, .element_name = \"side_data\", .unique_name = \"stream_side_data_list\" },\n    [SECTION_ID_STREAM_SIDE_DATA] =     { SECTION_ID_STREAM_SIDE_DATA, \"side_data\", 0, { -1 } },\n    [SECTION_ID_SUBTITLE] =           { SECTION_ID_SUBTITLE, \"subtitle\", 0, { -1 } },\n};\n\nstatic const OptionDef *options;\n\n/* FFprobe context */\nstatic const char *input_filename;\nstatic AVInputFormat *iformat = NULL;\n\nstatic struct AVHashContext *hash;\n\nstatic const struct {\n    double bin_val;\n    double dec_val;\n    const char *bin_str;\n    const char *dec_str;\n} si_prefixes[] = {\n    { 1.0, 1.0, \"\", \"\" },\n    { 1.024e3, 1e3, \"Ki\", \"K\" },\n    { 1.048576e6, 1e6, \"Mi\", \"M\" },\n    { 1.073741824e9, 1e9, \"Gi\", \"G\" },\n    { 1.099511627776e12, 1e12, \"Ti\", \"T\" },\n    { 1.125899906842624e15, 1e15, \"Pi\", \"P\" },\n};\n\nstatic const char unit_second_str[]         = \"s\"    ;\nstatic const char unit_hertz_str[]          = \"Hz\"   ;\nstatic const char unit_byte_str[]           = \"byte\" ;\nstatic const char unit_bit_per_second_str[] = \"bit/s\";\n\nstatic int nb_streams;\nstatic uint64_t *nb_streams_packets;\nstatic uint64_t *nb_streams_frames;\nstatic int *selected_streams;\n\n#if HAVE_THREADS\npthread_mutex_t log_mutex;\n#endif\ntypedef struct LogBuffer {\n    char *context_name;\n    int log_level;\n    char *log_message;\n    AVClassCategory category;\n    char *parent_name;\n    AVClassCategory parent_category;\n}LogBuffer;\n\nstatic LogBuffer *log_buffer;\nstatic int log_buffer_size;\n\nstatic void log_callback(void *ptr, int level, const char *fmt, va_list vl)\n{\n    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;\n    va_list vl2;\n    char line[1024];\n    static int print_prefix = 1;\n    void *new_log_buffer;\n\n    va_copy(vl2, vl);\n    av_log_default_callback(ptr, level, fmt, vl);\n    av_log_format_line(ptr, level, fmt, vl2, line, sizeof(line), &print_prefix);\n    va_end(vl2);\n\n#if HAVE_THREADS\n    pthread_mutex_lock(&log_mutex);\n\n    new_log_buffer = av_realloc_array(log_buffer, log_buffer_size + 1, sizeof(*log_buffer));\n    if (new_log_buffer) {\n        char *msg;\n        int i;\n\n        log_buffer = new_log_buffer;\n        memset(&log_buffer[log_buffer_size], 0, sizeof(log_buffer[log_buffer_size]));\n        log_buffer[log_buffer_size].context_name= avc ? av_strdup(avc->item_name(ptr)) : NULL;\n        if (avc) {\n            if (avc->get_category) log_buffer[log_buffer_size].category = avc->get_category(ptr);\n            else                   log_buffer[log_buffer_size].category = avc->category;\n        }\n        log_buffer[log_buffer_size].log_level   = level;\n        msg = log_buffer[log_buffer_size].log_message = av_strdup(line);\n        for (i=strlen(msg) - 1; i>=0 && msg[i] == '\\n'; i--) {\n            msg[i] = 0;\n        }\n        if (avc && avc->parent_log_context_offset) {\n            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +\n                                   avc->parent_log_context_offset);\n            if (parent && *parent) {\n                log_buffer[log_buffer_size].parent_name = av_strdup((*parent)->item_name(parent));\n                log_buffer[log_buffer_size].parent_category =\n                    (*parent)->get_category ? (*parent)->get_category(parent) :(*parent)->category;\n            }\n        }\n        log_buffer_size ++;\n    }\n\n    pthread_mutex_unlock(&log_mutex);\n#endif\n}\n\nstatic void ffprobe_cleanup(int ret)\n{\n    int i;\n    for (i = 0; i < FF_ARRAY_ELEMS(sections); i++)\n        av_dict_free(&(sections[i].entries_to_show));\n\n#if HAVE_THREADS\n    pthread_mutex_destroy(&log_mutex);\n#endif\n}\n\nstruct unit_value {\n    union { double d; long long int i; } val;\n    const char *unit;\n};\n\nstatic char *value_string(char *buf, int buf_size, struct unit_value uv)\n{\n    double vald;\n    long long int vali;\n    int show_float = 0;\n\n    if (uv.unit == unit_second_str) {\n        vald = uv.val.d;\n        show_float = 1;\n    } else {\n        vald = vali = uv.val.i;\n    }\n\n    if (uv.unit == unit_second_str && use_value_sexagesimal_format) {\n        double secs;\n        int hours, mins;\n        secs  = vald;\n        mins  = (int)secs / 60;\n        secs  = secs - mins * 60;\n        hours = mins / 60;\n        mins %= 60;\n        snprintf(buf, buf_size, \"%d:%02d:%09.6f\", hours, mins, secs);\n    } else {\n        const char *prefix_string = \"\";\n\n        if (use_value_prefix && vald > 1) {\n            long long int index;\n\n            if (uv.unit == unit_byte_str && use_byte_value_binary_prefix) {\n                index = (long long int) (log2(vald)) / 10;\n                index = av_clip(index, 0, FF_ARRAY_ELEMS(si_prefixes) - 1);\n                vald /= si_prefixes[index].bin_val;\n                prefix_string = si_prefixes[index].bin_str;\n            } else {\n                index = (long long int) (log10(vald)) / 3;\n                index = av_clip(index, 0, FF_ARRAY_ELEMS(si_prefixes) - 1);\n                vald /= si_prefixes[index].dec_val;\n                prefix_string = si_prefixes[index].dec_str;\n            }\n            vali = vald;\n        }\n\n        if (show_float || (use_value_prefix && vald != (long long int)vald))\n            snprintf(buf, buf_size, \"%f\", vald);\n        else\n            snprintf(buf, buf_size, \"%lld\", vali);\n        av_strlcatf(buf, buf_size, \"%s%s%s\", *prefix_string || show_value_unit ? \" \" : \"\",\n                 prefix_string, show_value_unit ? uv.unit : \"\");\n    }\n\n    return buf;\n}\n\n/* WRITERS API */\n\ntypedef struct WriterContext WriterContext;\n\n#define WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS 1\n#define WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER 2\n\ntypedef enum {\n    WRITER_STRING_VALIDATION_FAIL,\n    WRITER_STRING_VALIDATION_REPLACE,\n    WRITER_STRING_VALIDATION_IGNORE,\n    WRITER_STRING_VALIDATION_NB\n} StringValidation;\n\ntypedef struct Writer {\n    const AVClass *priv_class;      ///< private class of the writer, if any\n    int priv_size;                  ///< private size for the writer context\n    const char *name;\n\n    int  (*init)  (WriterContext *wctx);\n    void (*uninit)(WriterContext *wctx);\n\n    void (*print_section_header)(WriterContext *wctx);\n    void (*print_section_footer)(WriterContext *wctx);\n    void (*print_integer)       (WriterContext *wctx, const char *, long long int);\n    void (*print_rational)      (WriterContext *wctx, AVRational *q, char *sep);\n    void (*print_string)        (WriterContext *wctx, const char *, const char *);\n    int flags;                  ///< a combination or WRITER_FLAG_*\n} Writer;\n\n#define SECTION_MAX_NB_LEVELS 10\n\nstruct WriterContext {\n    const AVClass *class;           ///< class of the writer\n    const Writer *writer;           ///< the Writer of which this is an instance\n    char *name;                     ///< name of this writer instance\n    void *priv;                     ///< private data for use by the filter\n\n    const struct section *sections; ///< array containing all sections\n    int nb_sections;                ///< number of sections\n\n    int level;                      ///< current level, starting from 0\n\n    /** number of the item printed in the given section, starting from 0 */\n    unsigned int nb_item[SECTION_MAX_NB_LEVELS];\n\n    /** section per each level */\n    const struct section *section[SECTION_MAX_NB_LEVELS];\n    AVBPrint section_pbuf[SECTION_MAX_NB_LEVELS]; ///< generic print buffer dedicated to each section,\n                                                  ///  used by various writers\n\n    unsigned int nb_section_packet; ///< number of the packet section in case we are in \"packets_and_frames\" section\n    unsigned int nb_section_frame;  ///< number of the frame  section in case we are in \"packets_and_frames\" section\n    unsigned int nb_section_packet_frame; ///< nb_section_packet or nb_section_frame according if is_packets_and_frames\n\n    int string_validation;\n    char *string_validation_replacement;\n    unsigned int string_validation_utf8_flags;\n};\n\nstatic const char *writer_get_name(void *p)\n{\n    WriterContext *wctx = p;\n    return wctx->writer->name;\n}\n\n#define OFFSET(x) offsetof(WriterContext, x)\n\nstatic const AVOption writer_options[] = {\n    { \"string_validation\", \"set string validation mode\",\n      OFFSET(string_validation), AV_OPT_TYPE_INT, {.i64=WRITER_STRING_VALIDATION_REPLACE}, 0, WRITER_STRING_VALIDATION_NB-1, .unit = \"sv\" },\n    { \"sv\", \"set string validation mode\",\n      OFFSET(string_validation), AV_OPT_TYPE_INT, {.i64=WRITER_STRING_VALIDATION_REPLACE}, 0, WRITER_STRING_VALIDATION_NB-1, .unit = \"sv\" },\n    { \"ignore\",  NULL, 0, AV_OPT_TYPE_CONST, {.i64 = WRITER_STRING_VALIDATION_IGNORE},  .unit = \"sv\" },\n    { \"replace\", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = WRITER_STRING_VALIDATION_REPLACE}, .unit = \"sv\" },\n    { \"fail\",    NULL, 0, AV_OPT_TYPE_CONST, {.i64 = WRITER_STRING_VALIDATION_FAIL},    .unit = \"sv\" },\n    { \"string_validation_replacement\", \"set string validation replacement string\", OFFSET(string_validation_replacement), AV_OPT_TYPE_STRING, {.str=\"\"}},\n    { \"svr\", \"set string validation replacement string\", OFFSET(string_validation_replacement), AV_OPT_TYPE_STRING, {.str=\"\\xEF\\xBF\\xBD\"}},\n    { NULL }\n};\n\nstatic void *writer_child_next(void *obj, void *prev)\n{\n    WriterContext *ctx = obj;\n    if (!prev && ctx->writer && ctx->writer->priv_class && ctx->priv)\n        return ctx->priv;\n    return NULL;\n}\n\nstatic const AVClass writer_class = {\n    .class_name = \"Writer\",\n    .item_name  = writer_get_name,\n    .option     = writer_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n    .child_next = writer_child_next,\n};\n\nstatic void writer_close(WriterContext **wctx)\n{\n    int i;\n\n    if (!*wctx)\n        return;\n\n    if ((*wctx)->writer->uninit)\n        (*wctx)->writer->uninit(*wctx);\n    for (i = 0; i < SECTION_MAX_NB_LEVELS; i++)\n        av_bprint_finalize(&(*wctx)->section_pbuf[i], NULL);\n    if ((*wctx)->writer->priv_class)\n        av_opt_free((*wctx)->priv);\n    av_freep(&((*wctx)->priv));\n    av_opt_free(*wctx);\n    av_freep(wctx);\n}\n\nstatic void bprint_bytes(AVBPrint *bp, const uint8_t *ubuf, size_t ubuf_size)\n{\n    int i;\n    av_bprintf(bp, \"0X\");\n    for (i = 0; i < ubuf_size; i++)\n        av_bprintf(bp, \"%02X\", ubuf[i]);\n}\n\n\nstatic int writer_open(WriterContext **wctx, const Writer *writer, const char *args,\n                       const struct section *sections, int nb_sections)\n{\n    int i, ret = 0;\n\n    if (!(*wctx = av_mallocz(sizeof(WriterContext)))) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    if (!((*wctx)->priv = av_mallocz(writer->priv_size))) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    (*wctx)->class = &writer_class;\n    (*wctx)->writer = writer;\n    (*wctx)->level = -1;\n    (*wctx)->sections = sections;\n    (*wctx)->nb_sections = nb_sections;\n\n    av_opt_set_defaults(*wctx);\n\n    if (writer->priv_class) {\n        void *priv_ctx = (*wctx)->priv;\n        *((const AVClass **)priv_ctx) = writer->priv_class;\n        av_opt_set_defaults(priv_ctx);\n    }\n\n    /* convert options to dictionary */\n    if (args) {\n        AVDictionary *opts = NULL;\n        AVDictionaryEntry *opt = NULL;\n\n        if ((ret = av_dict_parse_string(&opts, args, \"=\", \":\", 0)) < 0) {\n            av_log(*wctx, AV_LOG_ERROR, \"Failed to parse option string '%s' provided to writer context\\n\", args);\n            av_dict_free(&opts);\n            goto fail;\n        }\n\n        while ((opt = av_dict_get(opts, \"\", opt, AV_DICT_IGNORE_SUFFIX))) {\n            if ((ret = av_opt_set(*wctx, opt->key, opt->value, AV_OPT_SEARCH_CHILDREN)) < 0) {\n                av_log(*wctx, AV_LOG_ERROR, \"Failed to set option '%s' with value '%s' provided to writer context\\n\",\n                       opt->key, opt->value);\n                av_dict_free(&opts);\n                goto fail;\n            }\n        }\n\n        av_dict_free(&opts);\n    }\n\n    /* validate replace string */\n    {\n        const uint8_t *p = (*wctx)->string_validation_replacement;\n        const uint8_t *endp = p + strlen(p);\n        while (*p) {\n            const uint8_t *p0 = p;\n            int32_t code;\n            ret = av_utf8_decode(&code, &p, endp, (*wctx)->string_validation_utf8_flags);\n            if (ret < 0) {\n                AVBPrint bp;\n                av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC);\n                bprint_bytes(&bp, p0, p-p0),\n                    av_log(wctx, AV_LOG_ERROR,\n                           \"Invalid UTF8 sequence %s found in string validation replace '%s'\\n\",\n                           bp.str, (*wctx)->string_validation_replacement);\n                return ret;\n            }\n        }\n    }\n\n    for (i = 0; i < SECTION_MAX_NB_LEVELS; i++)\n        av_bprint_init(&(*wctx)->section_pbuf[i], 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    if ((*wctx)->writer->init)\n        ret = (*wctx)->writer->init(*wctx);\n    if (ret < 0)\n        goto fail;\n\n    return 0;\n\nfail:\n    writer_close(wctx);\n    return ret;\n}\n\nstatic inline void writer_print_section_header(WriterContext *wctx,\n                                               int section_id)\n{\n    int parent_section_id;\n    wctx->level++;\n    av_assert0(wctx->level < SECTION_MAX_NB_LEVELS);\n    parent_section_id = wctx->level ?\n        (wctx->section[wctx->level-1])->id : SECTION_ID_NONE;\n\n    wctx->nb_item[wctx->level] = 0;\n    wctx->section[wctx->level] = &wctx->sections[section_id];\n\n    if (section_id == SECTION_ID_PACKETS_AND_FRAMES) {\n        wctx->nb_section_packet = wctx->nb_section_frame =\n        wctx->nb_section_packet_frame = 0;\n    } else if (parent_section_id == SECTION_ID_PACKETS_AND_FRAMES) {\n        wctx->nb_section_packet_frame = section_id == SECTION_ID_PACKET ?\n            wctx->nb_section_packet : wctx->nb_section_frame;\n    }\n\n    if (wctx->writer->print_section_header)\n        wctx->writer->print_section_header(wctx);\n}\n\nstatic inline void writer_print_section_footer(WriterContext *wctx)\n{\n    int section_id = wctx->section[wctx->level]->id;\n    int parent_section_id = wctx->level ?\n        wctx->section[wctx->level-1]->id : SECTION_ID_NONE;\n\n    if (parent_section_id != SECTION_ID_NONE)\n        wctx->nb_item[wctx->level-1]++;\n    if (parent_section_id == SECTION_ID_PACKETS_AND_FRAMES) {\n        if (section_id == SECTION_ID_PACKET) wctx->nb_section_packet++;\n        else                                     wctx->nb_section_frame++;\n    }\n    if (wctx->writer->print_section_footer)\n        wctx->writer->print_section_footer(wctx);\n    wctx->level--;\n}\n\nstatic inline void writer_print_integer(WriterContext *wctx,\n                                        const char *key, long long int val)\n{\n    const struct section *section = wctx->section[wctx->level];\n\n    if (section->show_all_entries || av_dict_get(section->entries_to_show, key, NULL, 0)) {\n        wctx->writer->print_integer(wctx, key, val);\n        wctx->nb_item[wctx->level]++;\n    }\n}\n\nstatic inline int validate_string(WriterContext *wctx, char **dstp, const char *src)\n{\n    const uint8_t *p, *endp;\n    AVBPrint dstbuf;\n    int invalid_chars_nb = 0, ret = 0;\n\n    av_bprint_init(&dstbuf, 0, AV_BPRINT_SIZE_UNLIMITED);\n\n    endp = src + strlen(src);\n    for (p = (uint8_t *)src; *p;) {\n        uint32_t code;\n        int invalid = 0;\n        const uint8_t *p0 = p;\n\n        if (av_utf8_decode(&code, &p, endp, wctx->string_validation_utf8_flags) < 0) {\n            AVBPrint bp;\n            av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC);\n            bprint_bytes(&bp, p0, p-p0);\n            av_log(wctx, AV_LOG_DEBUG,\n                   \"Invalid UTF-8 sequence %s found in string '%s'\\n\", bp.str, src);\n            invalid = 1;\n        }\n\n        if (invalid) {\n            invalid_chars_nb++;\n\n            switch (wctx->string_validation) {\n            case WRITER_STRING_VALIDATION_FAIL:\n                av_log(wctx, AV_LOG_ERROR,\n                       \"Invalid UTF-8 sequence found in string '%s'\\n\", src);\n                ret = AVERROR_INVALIDDATA;\n                goto end;\n                break;\n\n            case WRITER_STRING_VALIDATION_REPLACE:\n                av_bprintf(&dstbuf, \"%s\", wctx->string_validation_replacement);\n                break;\n            }\n        }\n\n        if (!invalid || wctx->string_validation == WRITER_STRING_VALIDATION_IGNORE)\n            av_bprint_append_data(&dstbuf, p0, p-p0);\n    }\n\n    if (invalid_chars_nb && wctx->string_validation == WRITER_STRING_VALIDATION_REPLACE) {\n        av_log(wctx, AV_LOG_WARNING,\n               \"%d invalid UTF-8 sequence(s) found in string '%s', replaced with '%s'\\n\",\n               invalid_chars_nb, src, wctx->string_validation_replacement);\n    }\n\nend:\n    av_bprint_finalize(&dstbuf, dstp);\n    return ret;\n}\n\n#define PRINT_STRING_OPT      1\n#define PRINT_STRING_VALIDATE 2\n\nstatic inline int writer_print_string(WriterContext *wctx,\n                                      const char *key, const char *val, int flags)\n{\n    const struct section *section = wctx->section[wctx->level];\n    int ret = 0;\n\n    if ((flags & PRINT_STRING_OPT)\n        && !(wctx->writer->flags & WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS))\n        return 0;\n\n    if (section->show_all_entries || av_dict_get(section->entries_to_show, key, NULL, 0)) {\n        if (flags & PRINT_STRING_VALIDATE) {\n            char *key1 = NULL, *val1 = NULL;\n            ret = validate_string(wctx, &key1, key);\n            if (ret < 0) goto end;\n            ret = validate_string(wctx, &val1, val);\n            if (ret < 0) goto end;\n            wctx->writer->print_string(wctx, key1, val1);\n        end:\n            if (ret < 0) {\n                av_log(wctx, AV_LOG_ERROR,\n                       \"Invalid key=value string combination %s=%s in section %s\\n\",\n                       key, val, section->unique_name);\n            }\n            av_free(key1);\n            av_free(val1);\n        } else {\n            wctx->writer->print_string(wctx, key, val);\n        }\n\n        wctx->nb_item[wctx->level]++;\n    }\n\n    return ret;\n}\n\nstatic inline void writer_print_rational(WriterContext *wctx,\n                                         const char *key, AVRational q, char sep)\n{\n    AVBPrint buf;\n    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_AUTOMATIC);\n    av_bprintf(&buf, \"%d%c%d\", q.num, sep, q.den);\n    writer_print_string(wctx, key, buf.str, 0);\n}\n\nstatic void writer_print_time(WriterContext *wctx, const char *key,\n                              int64_t ts, const AVRational *time_base, int is_duration)\n{\n    char buf[128];\n\n    if ((!is_duration && ts == AV_NOPTS_VALUE) || (is_duration && ts == 0)) {\n        writer_print_string(wctx, key, \"N/A\", PRINT_STRING_OPT);\n    } else {\n        double d = ts * av_q2d(*time_base);\n        struct unit_value uv;\n        uv.val.d = d;\n        uv.unit = unit_second_str;\n        value_string(buf, sizeof(buf), uv);\n        writer_print_string(wctx, key, buf, 0);\n    }\n}\n\nstatic void writer_print_ts(WriterContext *wctx, const char *key, int64_t ts, int is_duration)\n{\n    if ((!is_duration && ts == AV_NOPTS_VALUE) || (is_duration && ts == 0)) {\n        writer_print_string(wctx, key, \"N/A\", PRINT_STRING_OPT);\n    } else {\n        writer_print_integer(wctx, key, ts);\n    }\n}\n\nstatic void writer_print_data(WriterContext *wctx, const char *name,\n                              uint8_t *data, int size)\n{\n    AVBPrint bp;\n    int offset = 0, l, i;\n\n    av_bprint_init(&bp, 0, AV_BPRINT_SIZE_UNLIMITED);\n    av_bprintf(&bp, \"\\n\");\n    while (size) {\n        av_bprintf(&bp, \"%08x: \", offset);\n        l = FFMIN(size, 16);\n        for (i = 0; i < l; i++) {\n            av_bprintf(&bp, \"%02x\", data[i]);\n            if (i & 1)\n                av_bprintf(&bp, \" \");\n        }\n        av_bprint_chars(&bp, ' ', 41 - 2 * i - i / 2);\n        for (i = 0; i < l; i++)\n            av_bprint_chars(&bp, data[i] - 32U < 95 ? data[i] : '.', 1);\n        av_bprintf(&bp, \"\\n\");\n        offset += l;\n        data   += l;\n        size   -= l;\n    }\n    writer_print_string(wctx, name, bp.str, 0);\n    av_bprint_finalize(&bp, NULL);\n}\n\nstatic void writer_print_data_hash(WriterContext *wctx, const char *name,\n                                   uint8_t *data, int size)\n{\n    char *p, buf[AV_HASH_MAX_SIZE * 2 + 64] = { 0 };\n\n    if (!hash)\n        return;\n    av_hash_init(hash);\n    av_hash_update(hash, data, size);\n    snprintf(buf, sizeof(buf), \"%s:\", av_hash_get_name(hash));\n    p = buf + strlen(buf);\n    av_hash_final_hex(hash, p, buf + sizeof(buf) - p);\n    writer_print_string(wctx, name, buf, 0);\n}\n\nstatic void writer_print_integers(WriterContext *wctx, const char *name,\n                                  uint8_t *data, int size, const char *format,\n                                  int columns, int bytes, int offset_add)\n{\n    AVBPrint bp;\n    int offset = 0, l, i;\n\n    av_bprint_init(&bp, 0, AV_BPRINT_SIZE_UNLIMITED);\n    av_bprintf(&bp, \"\\n\");\n    while (size) {\n        av_bprintf(&bp, \"%08x: \", offset);\n        l = FFMIN(size, columns);\n        for (i = 0; i < l; i++) {\n            if      (bytes == 1) av_bprintf(&bp, format, *data);\n            else if (bytes == 2) av_bprintf(&bp, format, AV_RN16(data));\n            else if (bytes == 4) av_bprintf(&bp, format, AV_RN32(data));\n            data += bytes;\n            size --;\n        }\n        av_bprintf(&bp, \"\\n\");\n        offset += offset_add;\n    }\n    writer_print_string(wctx, name, bp.str, 0);\n    av_bprint_finalize(&bp, NULL);\n}\n\n#define MAX_REGISTERED_WRITERS_NB 64\n\nstatic const Writer *registered_writers[MAX_REGISTERED_WRITERS_NB + 1];\n\nstatic int writer_register(const Writer *writer)\n{\n    static int next_registered_writer_idx = 0;\n\n    if (next_registered_writer_idx == MAX_REGISTERED_WRITERS_NB)\n        return AVERROR(ENOMEM);\n\n    registered_writers[next_registered_writer_idx++] = writer;\n    return 0;\n}\n\nstatic const Writer *writer_get_by_name(const char *name)\n{\n    int i;\n\n    for (i = 0; registered_writers[i]; i++)\n        if (!strcmp(registered_writers[i]->name, name))\n            return registered_writers[i];\n\n    return NULL;\n}\n\n\n/* WRITERS */\n\n#define DEFINE_WRITER_CLASS(name)                   \\\nstatic const char *name##_get_name(void *ctx)       \\\n{                                                   \\\n    return #name ;                                  \\\n}                                                   \\\nstatic const AVClass name##_class = {               \\\n    .class_name = #name,                            \\\n    .item_name  = name##_get_name,                  \\\n    .option     = name##_options                    \\\n}\n\n/* Default output */\n\ntypedef struct DefaultContext {\n    const AVClass *class;\n    int nokey;\n    int noprint_wrappers;\n    int nested_section[SECTION_MAX_NB_LEVELS];\n} DefaultContext;\n\n#undef OFFSET\n#define OFFSET(x) offsetof(DefaultContext, x)\n\nstatic const AVOption default_options[] = {\n    { \"noprint_wrappers\", \"do not print headers and footers\", OFFSET(noprint_wrappers), AV_OPT_TYPE_BOOL, {.i64=0}, 0, 1 },\n    { \"nw\",               \"do not print headers and footers\", OFFSET(noprint_wrappers), AV_OPT_TYPE_BOOL, {.i64=0}, 0, 1 },\n    { \"nokey\",          \"force no key printing\",     OFFSET(nokey),          AV_OPT_TYPE_BOOL, {.i64=0}, 0, 1 },\n    { \"nk\",             \"force no key printing\",     OFFSET(nokey),          AV_OPT_TYPE_BOOL, {.i64=0}, 0, 1 },\n    {NULL},\n};\n\nDEFINE_WRITER_CLASS(default);\n\n/* lame uppercasing routine, assumes the string is lower case ASCII */\nstatic inline char *upcase_string(char *dst, size_t dst_size, const char *src)\n{\n    int i;\n    for (i = 0; src[i] && i < dst_size-1; i++)\n        dst[i] = av_toupper(src[i]);\n    dst[i] = 0;\n    return dst;\n}\n\nstatic void default_print_section_header(WriterContext *wctx)\n{\n    DefaultContext *def = wctx->priv;\n    char buf[32];\n    const struct section *section = wctx->section[wctx->level];\n    const struct section *parent_section = wctx->level ?\n        wctx->section[wctx->level-1] : NULL;\n\n    av_bprint_clear(&wctx->section_pbuf[wctx->level]);\n    if (parent_section &&\n        !(parent_section->flags & (SECTION_FLAG_IS_WRAPPER|SECTION_FLAG_IS_ARRAY))) {\n        def->nested_section[wctx->level] = 1;\n        av_bprintf(&wctx->section_pbuf[wctx->level], \"%s%s:\",\n                   wctx->section_pbuf[wctx->level-1].str,\n                   upcase_string(buf, sizeof(buf),\n                                 av_x_if_null(section->element_name, section->name)));\n    }\n\n    if (def->noprint_wrappers || def->nested_section[wctx->level])\n        return;\n\n    if (!(section->flags & (SECTION_FLAG_IS_WRAPPER|SECTION_FLAG_IS_ARRAY)))\n        printf(\"[%s]\\n\", upcase_string(buf, sizeof(buf), section->name));\n}\n\nstatic void default_print_section_footer(WriterContext *wctx)\n{\n    DefaultContext *def = wctx->priv;\n    const struct section *section = wctx->section[wctx->level];\n    char buf[32];\n\n    if (def->noprint_wrappers || def->nested_section[wctx->level])\n        return;\n\n    if (!(section->flags & (SECTION_FLAG_IS_WRAPPER|SECTION_FLAG_IS_ARRAY)))\n        printf(\"[/%s]\\n\", upcase_string(buf, sizeof(buf), section->name));\n}\n\nstatic void default_print_str(WriterContext *wctx, const char *key, const char *value)\n{\n    DefaultContext *def = wctx->priv;\n\n    if (!def->nokey)\n        printf(\"%s%s=\", wctx->section_pbuf[wctx->level].str, key);\n    printf(\"%s\\n\", value);\n}\n\nstatic void default_print_int(WriterContext *wctx, const char *key, long long int value)\n{\n    DefaultContext *def = wctx->priv;\n\n    if (!def->nokey)\n        printf(\"%s%s=\", wctx->section_pbuf[wctx->level].str, key);\n    printf(\"%lld\\n\", value);\n}\n\nstatic const Writer default_writer = {\n    .name                  = \"default\",\n    .priv_size             = sizeof(DefaultContext),\n    .print_section_header  = default_print_section_header,\n    .print_section_footer  = default_print_section_footer,\n    .print_integer         = default_print_int,\n    .print_string          = default_print_str,\n    .flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS,\n    .priv_class            = &default_class,\n};\n\n/* Compact output */\n\n/**\n * Apply C-language-like string escaping.\n */\nstatic const char *c_escape_str(AVBPrint *dst, const char *src, const char sep, void *log_ctx)\n{\n    const char *p;\n\n    for (p = src; *p; p++) {\n        switch (*p) {\n        case '\\b': av_bprintf(dst, \"%s\", \"\\\\b\");  break;\n        case '\\f': av_bprintf(dst, \"%s\", \"\\\\f\");  break;\n        case '\\n': av_bprintf(dst, \"%s\", \"\\\\n\");  break;\n        case '\\r': av_bprintf(dst, \"%s\", \"\\\\r\");  break;\n        case '\\\\': av_bprintf(dst, \"%s\", \"\\\\\\\\\"); break;\n        default:\n            if (*p == sep)\n                av_bprint_chars(dst, '\\\\', 1);\n            av_bprint_chars(dst, *p, 1);\n        }\n    }\n    return dst->str;\n}\n\n/**\n * Quote fields containing special characters, check RFC4180.\n */\nstatic const char *csv_escape_str(AVBPrint *dst, const char *src, const char sep, void *log_ctx)\n{\n    char meta_chars[] = { sep, '\"', '\\n', '\\r', '\\0' };\n    int needs_quoting = !!src[strcspn(src, meta_chars)];\n\n    if (needs_quoting)\n        av_bprint_chars(dst, '\"', 1);\n\n    for (; *src; src++) {\n        if (*src == '\"')\n            av_bprint_chars(dst, '\"', 1);\n        av_bprint_chars(dst, *src, 1);\n    }\n    if (needs_quoting)\n        av_bprint_chars(dst, '\"', 1);\n    return dst->str;\n}\n\nstatic const char *none_escape_str(AVBPrint *dst, const char *src, const char sep, void *log_ctx)\n{\n    return src;\n}\n\ntypedef struct CompactContext {\n    const AVClass *class;\n    char *item_sep_str;\n    char item_sep;\n    int nokey;\n    int print_section;\n    char *escape_mode_str;\n    const char * (*escape_str)(AVBPrint *dst, const char *src, const char sep, void *log_ctx);\n    int nested_section[SECTION_MAX_NB_LEVELS];\n    int has_nested_elems[SECTION_MAX_NB_LEVELS];\n    int terminate_line[SECTION_MAX_NB_LEVELS];\n} CompactContext;\n\n#undef OFFSET\n#define OFFSET(x) offsetof(CompactContext, x)\n\nstatic const AVOption compact_options[]= {\n    {\"item_sep\", \"set item separator\",    OFFSET(item_sep_str),    AV_OPT_TYPE_STRING, {.str=\"|\"},  CHAR_MIN, CHAR_MAX },\n    {\"s\",        \"set item separator\",    OFFSET(item_sep_str),    AV_OPT_TYPE_STRING, {.str=\"|\"},  CHAR_MIN, CHAR_MAX },\n    {\"nokey\",    \"force no key printing\", OFFSET(nokey),           AV_OPT_TYPE_BOOL,   {.i64=0},    0,        1        },\n    {\"nk\",       \"force no key printing\", OFFSET(nokey),           AV_OPT_TYPE_BOOL,   {.i64=0},    0,        1        },\n    {\"escape\",   \"set escape mode\",       OFFSET(escape_mode_str), AV_OPT_TYPE_STRING, {.str=\"c\"},  CHAR_MIN, CHAR_MAX },\n    {\"e\",        \"set escape mode\",       OFFSET(escape_mode_str), AV_OPT_TYPE_STRING, {.str=\"c\"},  CHAR_MIN, CHAR_MAX },\n    {\"print_section\", \"print section name\", OFFSET(print_section), AV_OPT_TYPE_BOOL,   {.i64=1},    0,        1        },\n    {\"p\",             \"print section name\", OFFSET(print_section), AV_OPT_TYPE_BOOL,   {.i64=1},    0,        1        },\n    {NULL},\n};\n\nDEFINE_WRITER_CLASS(compact);\n\nstatic av_cold int compact_init(WriterContext *wctx)\n{\n    CompactContext *compact = wctx->priv;\n\n    if (strlen(compact->item_sep_str) != 1) {\n        av_log(wctx, AV_LOG_ERROR, \"Item separator '%s' specified, but must contain a single character\\n\",\n               compact->item_sep_str);\n        return AVERROR(EINVAL);\n    }\n    compact->item_sep = compact->item_sep_str[0];\n\n    if      (!strcmp(compact->escape_mode_str, \"none\")) compact->escape_str = none_escape_str;\n    else if (!strcmp(compact->escape_mode_str, \"c\"   )) compact->escape_str = c_escape_str;\n    else if (!strcmp(compact->escape_mode_str, \"csv\" )) compact->escape_str = csv_escape_str;\n    else {\n        av_log(wctx, AV_LOG_ERROR, \"Unknown escape mode '%s'\\n\", compact->escape_mode_str);\n        return AVERROR(EINVAL);\n    }\n\n    return 0;\n}\n\nstatic void compact_print_section_header(WriterContext *wctx)\n{\n    CompactContext *compact = wctx->priv;\n    const struct section *section = wctx->section[wctx->level];\n    const struct section *parent_section = wctx->level ?\n        wctx->section[wctx->level-1] : NULL;\n    compact->terminate_line[wctx->level] = 1;\n    compact->has_nested_elems[wctx->level] = 0;\n\n    av_bprint_clear(&wctx->section_pbuf[wctx->level]);\n    if (!(section->flags & SECTION_FLAG_IS_ARRAY) && parent_section &&\n        !(parent_section->flags & (SECTION_FLAG_IS_WRAPPER|SECTION_FLAG_IS_ARRAY))) {\n        compact->nested_section[wctx->level] = 1;\n        compact->has_nested_elems[wctx->level-1] = 1;\n        av_bprintf(&wctx->section_pbuf[wctx->level], \"%s%s:\",\n                   wctx->section_pbuf[wctx->level-1].str,\n                   (char *)av_x_if_null(section->element_name, section->name));\n        wctx->nb_item[wctx->level] = wctx->nb_item[wctx->level-1];\n    } else {\n        if (parent_section && compact->has_nested_elems[wctx->level-1] &&\n            (section->flags & SECTION_FLAG_IS_ARRAY)) {\n            compact->terminate_line[wctx->level-1] = 0;\n            printf(\"\\n\");\n        }\n        if (compact->print_section &&\n            !(section->flags & (SECTION_FLAG_IS_WRAPPER|SECTION_FLAG_IS_ARRAY)))\n            printf(\"%s%c\", section->name, compact->item_sep);\n    }\n}\n\nstatic void compact_print_section_footer(WriterContext *wctx)\n{\n    CompactContext *compact = wctx->priv;\n\n    if (!compact->nested_section[wctx->level] &&\n        compact->terminate_line[wctx->level] &&\n        !(wctx->section[wctx->level]->flags & (SECTION_FLAG_IS_WRAPPER|SECTION_FLAG_IS_ARRAY)))\n        printf(\"\\n\");\n}\n\nstatic void compact_print_str(WriterContext *wctx, const char *key, const char *value)\n{\n    CompactContext *compact = wctx->priv;\n    AVBPrint buf;\n\n    if (wctx->nb_item[wctx->level]) printf(\"%c\", compact->item_sep);\n    if (!compact->nokey)\n        printf(\"%s%s=\", wctx->section_pbuf[wctx->level].str, key);\n    av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n    printf(\"%s\", compact->escape_str(&buf, value, compact->item_sep, wctx));\n    av_bprint_finalize(&buf, NULL);\n}\n\nstatic void compact_print_int(WriterContext *wctx, const char *key, long long int value)\n{\n    CompactContext *compact = wctx->priv;\n\n    if (wctx->nb_item[wctx->level]) printf(\"%c\", compact->item_sep);\n    if (!compact->nokey)\n        printf(\"%s%s=\", wctx->section_pbuf[wctx->level].str, key);\n    printf(\"%lld\", value);\n}\n\nstatic const Writer compact_writer = {\n    .name                 = \"compact\",\n    .priv_size            = sizeof(CompactContext),\n    .init                 = compact_init,\n    .print_section_header = compact_print_section_header,\n    .print_section_footer = compact_print_section_footer,\n    .print_integer        = compact_print_int,\n    .print_string         = compact_print_str,\n    .flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS,\n    .priv_class           = &compact_class,\n};\n\n/* CSV output */\n\n#undef OFFSET\n#define OFFSET(x) offsetof(CompactContext, x)\n\nstatic const AVOption csv_options[] = {\n    {\"item_sep\", \"set item separator\",    OFFSET(item_sep_str),    AV_OPT_TYPE_STRING, {.str=\",\"},  CHAR_MIN, CHAR_MAX },\n    {\"s\",        \"set item separator\",    OFFSET(item_sep_str),    AV_OPT_TYPE_STRING, {.str=\",\"},  CHAR_MIN, CHAR_MAX },\n    {\"nokey\",    \"force no key printing\", OFFSET(nokey),           AV_OPT_TYPE_BOOL,   {.i64=1},    0,        1        },\n    {\"nk\",       \"force no key printing\", OFFSET(nokey),           AV_OPT_TYPE_BOOL,   {.i64=1},    0,        1        },\n    {\"escape\",   \"set escape mode\",       OFFSET(escape_mode_str), AV_OPT_TYPE_STRING, {.str=\"csv\"}, CHAR_MIN, CHAR_MAX },\n    {\"e\",        \"set escape mode\",       OFFSET(escape_mode_str), AV_OPT_TYPE_STRING, {.str=\"csv\"}, CHAR_MIN, CHAR_MAX },\n    {\"print_section\", \"print section name\", OFFSET(print_section), AV_OPT_TYPE_BOOL,   {.i64=1},    0,        1        },\n    {\"p\",             \"print section name\", OFFSET(print_section), AV_OPT_TYPE_BOOL,   {.i64=1},    0,        1        },\n    {NULL},\n};\n\nDEFINE_WRITER_CLASS(csv);\n\nstatic const Writer csv_writer = {\n    .name                 = \"csv\",\n    .priv_size            = sizeof(CompactContext),\n    .init                 = compact_init,\n    .print_section_header = compact_print_section_header,\n    .print_section_footer = compact_print_section_footer,\n    .print_integer        = compact_print_int,\n    .print_string         = compact_print_str,\n    .flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS,\n    .priv_class           = &csv_class,\n};\n\n/* Flat output */\n\ntypedef struct FlatContext {\n    const AVClass *class;\n    const char *sep_str;\n    char sep;\n    int hierarchical;\n} FlatContext;\n\n#undef OFFSET\n#define OFFSET(x) offsetof(FlatContext, x)\n\nstatic const AVOption flat_options[]= {\n    {\"sep_char\", \"set separator\",    OFFSET(sep_str),    AV_OPT_TYPE_STRING, {.str=\".\"},  CHAR_MIN, CHAR_MAX },\n    {\"s\",        \"set separator\",    OFFSET(sep_str),    AV_OPT_TYPE_STRING, {.str=\".\"},  CHAR_MIN, CHAR_MAX },\n    {\"hierarchical\", \"specify if the section specification should be hierarchical\", OFFSET(hierarchical), AV_OPT_TYPE_BOOL, {.i64=1}, 0, 1 },\n    {\"h\",            \"specify if the section specification should be hierarchical\", OFFSET(hierarchical), AV_OPT_TYPE_BOOL, {.i64=1}, 0, 1 },\n    {NULL},\n};\n\nDEFINE_WRITER_CLASS(flat);\n\nstatic av_cold int flat_init(WriterContext *wctx)\n{\n    FlatContext *flat = wctx->priv;\n\n    if (strlen(flat->sep_str) != 1) {\n        av_log(wctx, AV_LOG_ERROR, \"Item separator '%s' specified, but must contain a single character\\n\",\n               flat->sep_str);\n        return AVERROR(EINVAL);\n    }\n    flat->sep = flat->sep_str[0];\n\n    return 0;\n}\n\nstatic const char *flat_escape_key_str(AVBPrint *dst, const char *src, const char sep)\n{\n    const char *p;\n\n    for (p = src; *p; p++) {\n        if (!((*p >= '0' && *p <= '9') ||\n              (*p >= 'a' && *p <= 'z') ||\n              (*p >= 'A' && *p <= 'Z')))\n            av_bprint_chars(dst, '_', 1);\n        else\n            av_bprint_chars(dst, *p, 1);\n    }\n    return dst->str;\n}\n\nstatic const char *flat_escape_value_str(AVBPrint *dst, const char *src)\n{\n    const char *p;\n\n    for (p = src; *p; p++) {\n        switch (*p) {\n        case '\\n': av_bprintf(dst, \"%s\", \"\\\\n\");  break;\n        case '\\r': av_bprintf(dst, \"%s\", \"\\\\r\");  break;\n        case '\\\\': av_bprintf(dst, \"%s\", \"\\\\\\\\\"); break;\n        case '\"':  av_bprintf(dst, \"%s\", \"\\\\\\\"\"); break;\n        case '`':  av_bprintf(dst, \"%s\", \"\\\\`\");  break;\n        case '$':  av_bprintf(dst, \"%s\", \"\\\\$\");  break;\n        default:   av_bprint_chars(dst, *p, 1);   break;\n        }\n    }\n    return dst->str;\n}\n\nstatic void flat_print_section_header(WriterContext *wctx)\n{\n    FlatContext *flat = wctx->priv;\n    AVBPrint *buf = &wctx->section_pbuf[wctx->level];\n    const struct section *section = wctx->section[wctx->level];\n    const struct section *parent_section = wctx->level ?\n        wctx->section[wctx->level-1] : NULL;\n\n    /* build section header */\n    av_bprint_clear(buf);\n    if (!parent_section)\n        return;\n    av_bprintf(buf, \"%s\", wctx->section_pbuf[wctx->level-1].str);\n\n    if (flat->hierarchical ||\n        !(section->flags & (SECTION_FLAG_IS_ARRAY|SECTION_FLAG_IS_WRAPPER))) {\n        av_bprintf(buf, \"%s%s\", wctx->section[wctx->level]->name, flat->sep_str);\n\n        if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {\n            int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?\n                wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];\n            av_bprintf(buf, \"%d%s\", n, flat->sep_str);\n        }\n    }\n}\n\nstatic void flat_print_int(WriterContext *wctx, const char *key, long long int value)\n{\n    printf(\"%s%s=%lld\\n\", wctx->section_pbuf[wctx->level].str, key, value);\n}\n\nstatic void flat_print_str(WriterContext *wctx, const char *key, const char *value)\n{\n    FlatContext *flat = wctx->priv;\n    AVBPrint buf;\n\n    printf(\"%s\", wctx->section_pbuf[wctx->level].str);\n    av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n    printf(\"%s=\", flat_escape_key_str(&buf, key, flat->sep));\n    av_bprint_clear(&buf);\n    printf(\"\\\"%s\\\"\\n\", flat_escape_value_str(&buf, value));\n    av_bprint_finalize(&buf, NULL);\n}\n\nstatic const Writer flat_writer = {\n    .name                  = \"flat\",\n    .priv_size             = sizeof(FlatContext),\n    .init                  = flat_init,\n    .print_section_header  = flat_print_section_header,\n    .print_integer         = flat_print_int,\n    .print_string          = flat_print_str,\n    .flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS|WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER,\n    .priv_class            = &flat_class,\n};\n\n/* INI format output */\n\ntypedef struct INIContext {\n    const AVClass *class;\n    int hierarchical;\n} INIContext;\n\n#undef OFFSET\n#define OFFSET(x) offsetof(INIContext, x)\n\nstatic const AVOption ini_options[] = {\n    {\"hierarchical\", \"specify if the section specification should be hierarchical\", OFFSET(hierarchical), AV_OPT_TYPE_BOOL, {.i64=1}, 0, 1 },\n    {\"h\",            \"specify if the section specification should be hierarchical\", OFFSET(hierarchical), AV_OPT_TYPE_BOOL, {.i64=1}, 0, 1 },\n    {NULL},\n};\n\nDEFINE_WRITER_CLASS(ini);\n\nstatic char *ini_escape_str(AVBPrint *dst, const char *src)\n{\n    int i = 0;\n    char c = 0;\n\n    while (c = src[i++]) {\n        switch (c) {\n        case '\\b': av_bprintf(dst, \"%s\", \"\\\\b\"); break;\n        case '\\f': av_bprintf(dst, \"%s\", \"\\\\f\"); break;\n        case '\\n': av_bprintf(dst, \"%s\", \"\\\\n\"); break;\n        case '\\r': av_bprintf(dst, \"%s\", \"\\\\r\"); break;\n        case '\\t': av_bprintf(dst, \"%s\", \"\\\\t\"); break;\n        case '\\\\':\n        case '#' :\n        case '=' :\n        case ':' : av_bprint_chars(dst, '\\\\', 1);\n        default:\n            if ((unsigned char)c < 32)\n                av_bprintf(dst, \"\\\\x00%02x\", c & 0xff);\n            else\n                av_bprint_chars(dst, c, 1);\n            break;\n        }\n    }\n    return dst->str;\n}\n\nstatic void ini_print_section_header(WriterContext *wctx)\n{\n    INIContext *ini = wctx->priv;\n    AVBPrint *buf = &wctx->section_pbuf[wctx->level];\n    const struct section *section = wctx->section[wctx->level];\n    const struct section *parent_section = wctx->level ?\n        wctx->section[wctx->level-1] : NULL;\n\n    av_bprint_clear(buf);\n    if (!parent_section) {\n        printf(\"# ffprobe output\\n\\n\");\n        return;\n    }\n\n    if (wctx->nb_item[wctx->level-1])\n        printf(\"\\n\");\n\n    av_bprintf(buf, \"%s\", wctx->section_pbuf[wctx->level-1].str);\n    if (ini->hierarchical ||\n        !(section->flags & (SECTION_FLAG_IS_ARRAY|SECTION_FLAG_IS_WRAPPER))) {\n        av_bprintf(buf, \"%s%s\", buf->str[0] ? \".\" : \"\", wctx->section[wctx->level]->name);\n\n        if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {\n            int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?\n                wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];\n            av_bprintf(buf, \".%d\", n);\n        }\n    }\n\n    if (!(section->flags & (SECTION_FLAG_IS_ARRAY|SECTION_FLAG_IS_WRAPPER)))\n        printf(\"[%s]\\n\", buf->str);\n}\n\nstatic void ini_print_str(WriterContext *wctx, const char *key, const char *value)\n{\n    AVBPrint buf;\n\n    av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n    printf(\"%s=\", ini_escape_str(&buf, key));\n    av_bprint_clear(&buf);\n    printf(\"%s\\n\", ini_escape_str(&buf, value));\n    av_bprint_finalize(&buf, NULL);\n}\n\nstatic void ini_print_int(WriterContext *wctx, const char *key, long long int value)\n{\n    printf(\"%s=%lld\\n\", key, value);\n}\n\nstatic const Writer ini_writer = {\n    .name                  = \"ini\",\n    .priv_size             = sizeof(INIContext),\n    .print_section_header  = ini_print_section_header,\n    .print_integer         = ini_print_int,\n    .print_string          = ini_print_str,\n    .flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS|WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER,\n    .priv_class            = &ini_class,\n};\n\n/* JSON output */\n\ntypedef struct JSONContext {\n    const AVClass *class;\n    int indent_level;\n    int compact;\n    const char *item_sep, *item_start_end;\n} JSONContext;\n\n#undef OFFSET\n#define OFFSET(x) offsetof(JSONContext, x)\n\nstatic const AVOption json_options[]= {\n    { \"compact\", \"enable compact output\", OFFSET(compact), AV_OPT_TYPE_BOOL, {.i64=0}, 0, 1 },\n    { \"c\",       \"enable compact output\", OFFSET(compact), AV_OPT_TYPE_BOOL, {.i64=0}, 0, 1 },\n    { NULL }\n};\n\nDEFINE_WRITER_CLASS(json);\n\nstatic av_cold int json_init(WriterContext *wctx)\n{\n    JSONContext *json = wctx->priv;\n\n    json->item_sep       = json->compact ? \", \" : \",\\n\";\n    json->item_start_end = json->compact ? \" \"  : \"\\n\";\n\n    return 0;\n}\n\nstatic const char *json_escape_str(AVBPrint *dst, const char *src, void *log_ctx)\n{\n    static const char json_escape[] = {'\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t', 0};\n    static const char json_subst[]  = {'\"', '\\\\',  'b',  'f',  'n',  'r',  't', 0};\n    const char *p;\n\n    for (p = src; *p; p++) {\n        char *s = strchr(json_escape, *p);\n        if (s) {\n            av_bprint_chars(dst, '\\\\', 1);\n            av_bprint_chars(dst, json_subst[s - json_escape], 1);\n        } else if ((unsigned char)*p < 32) {\n            av_bprintf(dst, \"\\\\u00%02x\", *p & 0xff);\n        } else {\n            av_bprint_chars(dst, *p, 1);\n        }\n    }\n    return dst->str;\n}\n\n#define JSON_INDENT() printf(\"%*c\", json->indent_level * 4, ' ')\n\nstatic void json_print_section_header(WriterContext *wctx)\n{\n    JSONContext *json = wctx->priv;\n    AVBPrint buf;\n    const struct section *section = wctx->section[wctx->level];\n    const struct section *parent_section = wctx->level ?\n        wctx->section[wctx->level-1] : NULL;\n\n    if (wctx->level && wctx->nb_item[wctx->level-1])\n        printf(\",\\n\");\n\n    if (section->flags & SECTION_FLAG_IS_WRAPPER) {\n        printf(\"{\\n\");\n        json->indent_level++;\n    } else {\n        av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n        json_escape_str(&buf, section->name, wctx);\n        JSON_INDENT();\n\n        json->indent_level++;\n        if (section->flags & SECTION_FLAG_IS_ARRAY) {\n            printf(\"\\\"%s\\\": [\\n\", buf.str);\n        } else if (parent_section && !(parent_section->flags & SECTION_FLAG_IS_ARRAY)) {\n            printf(\"\\\"%s\\\": {%s\", buf.str, json->item_start_end);\n        } else {\n            printf(\"{%s\", json->item_start_end);\n\n            /* this is required so the parser can distinguish between packets and frames */\n            if (parent_section && parent_section->id == SECTION_ID_PACKETS_AND_FRAMES) {\n                if (!json->compact)\n                    JSON_INDENT();\n                printf(\"\\\"type\\\": \\\"%s\\\"%s\", section->name, json->item_sep);\n            }\n        }\n        av_bprint_finalize(&buf, NULL);\n    }\n}\n\nstatic void json_print_section_footer(WriterContext *wctx)\n{\n    JSONContext *json = wctx->priv;\n    const struct section *section = wctx->section[wctx->level];\n\n    if (wctx->level == 0) {\n        json->indent_level--;\n        printf(\"\\n}\\n\");\n    } else if (section->flags & SECTION_FLAG_IS_ARRAY) {\n        printf(\"\\n\");\n        json->indent_level--;\n        JSON_INDENT();\n        printf(\"]\");\n    } else {\n        printf(\"%s\", json->item_start_end);\n        json->indent_level--;\n        if (!json->compact)\n            JSON_INDENT();\n        printf(\"}\");\n    }\n}\n\nstatic inline void json_print_item_str(WriterContext *wctx,\n                                       const char *key, const char *value)\n{\n    AVBPrint buf;\n\n    av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n    printf(\"\\\"%s\\\":\", json_escape_str(&buf, key,   wctx));\n    av_bprint_clear(&buf);\n    printf(\" \\\"%s\\\"\", json_escape_str(&buf, value, wctx));\n    av_bprint_finalize(&buf, NULL);\n}\n\nstatic void json_print_str(WriterContext *wctx, const char *key, const char *value)\n{\n    JSONContext *json = wctx->priv;\n\n    if (wctx->nb_item[wctx->level])\n        printf(\"%s\", json->item_sep);\n    if (!json->compact)\n        JSON_INDENT();\n    json_print_item_str(wctx, key, value);\n}\n\nstatic void json_print_int(WriterContext *wctx, const char *key, long long int value)\n{\n    JSONContext *json = wctx->priv;\n    AVBPrint buf;\n\n    if (wctx->nb_item[wctx->level])\n        printf(\"%s\", json->item_sep);\n    if (!json->compact)\n        JSON_INDENT();\n\n    av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n    printf(\"\\\"%s\\\": %lld\", json_escape_str(&buf, key, wctx), value);\n    av_bprint_finalize(&buf, NULL);\n}\n\nstatic const Writer json_writer = {\n    .name                 = \"json\",\n    .priv_size            = sizeof(JSONContext),\n    .init                 = json_init,\n    .print_section_header = json_print_section_header,\n    .print_section_footer = json_print_section_footer,\n    .print_integer        = json_print_int,\n    .print_string         = json_print_str,\n    .flags = WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER,\n    .priv_class           = &json_class,\n};\n\n/* XML output */\n\ntypedef struct XMLContext {\n    const AVClass *class;\n    int within_tag;\n    int indent_level;\n    int fully_qualified;\n    int xsd_strict;\n} XMLContext;\n\n#undef OFFSET\n#define OFFSET(x) offsetof(XMLContext, x)\n\nstatic const AVOption xml_options[] = {\n    {\"fully_qualified\", \"specify if the output should be fully qualified\", OFFSET(fully_qualified), AV_OPT_TYPE_BOOL, {.i64=0},  0, 1 },\n    {\"q\",               \"specify if the output should be fully qualified\", OFFSET(fully_qualified), AV_OPT_TYPE_BOOL, {.i64=0},  0, 1 },\n    {\"xsd_strict\",      \"ensure that the output is XSD compliant\",         OFFSET(xsd_strict),      AV_OPT_TYPE_BOOL, {.i64=0},  0, 1 },\n    {\"x\",               \"ensure that the output is XSD compliant\",         OFFSET(xsd_strict),      AV_OPT_TYPE_BOOL, {.i64=0},  0, 1 },\n    {NULL},\n};\n\nDEFINE_WRITER_CLASS(xml);\n\nstatic av_cold int xml_init(WriterContext *wctx)\n{\n    XMLContext *xml = wctx->priv;\n\n    if (xml->xsd_strict) {\n        xml->fully_qualified = 1;\n#define CHECK_COMPLIANCE(opt, opt_name)                                 \\\n        if (opt) {                                                      \\\n            av_log(wctx, AV_LOG_ERROR,                                  \\\n                   \"XSD-compliant output selected but option '%s' was selected, XML output may be non-compliant.\\n\" \\\n                   \"You need to disable such option with '-no%s'\\n\", opt_name, opt_name); \\\n            return AVERROR(EINVAL);                                     \\\n        }\n        CHECK_COMPLIANCE(show_private_data, \"private\");\n        CHECK_COMPLIANCE(show_value_unit,   \"unit\");\n        CHECK_COMPLIANCE(use_value_prefix,  \"prefix\");\n\n        if (do_show_frames && do_show_packets) {\n            av_log(wctx, AV_LOG_ERROR,\n                   \"Interleaved frames and packets are not allowed in XSD. \"\n                   \"Select only one between the -show_frames and the -show_packets options.\\n\");\n            return AVERROR(EINVAL);\n        }\n    }\n\n    return 0;\n}\n\nstatic const char *xml_escape_str(AVBPrint *dst, const char *src, void *log_ctx)\n{\n    const char *p;\n\n    for (p = src; *p; p++) {\n        switch (*p) {\n        case '&' : av_bprintf(dst, \"%s\", \"&amp;\");  break;\n        case '<' : av_bprintf(dst, \"%s\", \"&lt;\");   break;\n        case '>' : av_bprintf(dst, \"%s\", \"&gt;\");   break;\n        case '\"' : av_bprintf(dst, \"%s\", \"&quot;\"); break;\n        case '\\'': av_bprintf(dst, \"%s\", \"&apos;\"); break;\n        default: av_bprint_chars(dst, *p, 1);\n        }\n    }\n\n    return dst->str;\n}\n\n#define XML_INDENT() printf(\"%*c\", xml->indent_level * 4, ' ')\n\nstatic void xml_print_section_header(WriterContext *wctx)\n{\n    XMLContext *xml = wctx->priv;\n    const struct section *section = wctx->section[wctx->level];\n    const struct section *parent_section = wctx->level ?\n        wctx->section[wctx->level-1] : NULL;\n\n    if (wctx->level == 0) {\n        const char *qual = \" xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' \"\n            \"xmlns:ffprobe='http://www.ffmpeg.org/schema/ffprobe' \"\n            \"xsi:schemaLocation='http://www.ffmpeg.org/schema/ffprobe ffprobe.xsd'\";\n\n        printf(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n        printf(\"<%sffprobe%s>\\n\",\n               xml->fully_qualified ? \"ffprobe:\" : \"\",\n               xml->fully_qualified ? qual : \"\");\n        return;\n    }\n\n    if (xml->within_tag) {\n        xml->within_tag = 0;\n        printf(\">\\n\");\n    }\n    if (section->flags & SECTION_FLAG_HAS_VARIABLE_FIELDS) {\n        xml->indent_level++;\n    } else {\n        if (parent_section && (parent_section->flags & SECTION_FLAG_IS_WRAPPER) &&\n            wctx->level && wctx->nb_item[wctx->level-1])\n            printf(\"\\n\");\n        xml->indent_level++;\n\n        if (section->flags & SECTION_FLAG_IS_ARRAY) {\n            XML_INDENT(); printf(\"<%s>\\n\", section->name);\n        } else {\n            XML_INDENT(); printf(\"<%s \", section->name);\n            xml->within_tag = 1;\n        }\n    }\n}\n\nstatic void xml_print_section_footer(WriterContext *wctx)\n{\n    XMLContext *xml = wctx->priv;\n    const struct section *section = wctx->section[wctx->level];\n\n    if (wctx->level == 0) {\n        printf(\"</%sffprobe>\\n\", xml->fully_qualified ? \"ffprobe:\" : \"\");\n    } else if (xml->within_tag) {\n        xml->within_tag = 0;\n        printf(\"/>\\n\");\n        xml->indent_level--;\n    } else if (section->flags & SECTION_FLAG_HAS_VARIABLE_FIELDS) {\n        xml->indent_level--;\n    } else {\n        XML_INDENT(); printf(\"</%s>\\n\", section->name);\n        xml->indent_level--;\n    }\n}\n\nstatic void xml_print_str(WriterContext *wctx, const char *key, const char *value)\n{\n    AVBPrint buf;\n    XMLContext *xml = wctx->priv;\n    const struct section *section = wctx->section[wctx->level];\n\n    av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    if (section->flags & SECTION_FLAG_HAS_VARIABLE_FIELDS) {\n        XML_INDENT();\n        printf(\"<%s key=\\\"%s\\\"\",\n               section->element_name, xml_escape_str(&buf, key, wctx));\n        av_bprint_clear(&buf);\n        printf(\" value=\\\"%s\\\"/>\\n\", xml_escape_str(&buf, value, wctx));\n    } else {\n        if (wctx->nb_item[wctx->level])\n            printf(\" \");\n        printf(\"%s=\\\"%s\\\"\", key, xml_escape_str(&buf, value, wctx));\n    }\n\n    av_bprint_finalize(&buf, NULL);\n}\n\nstatic void xml_print_int(WriterContext *wctx, const char *key, long long int value)\n{\n    if (wctx->nb_item[wctx->level])\n        printf(\" \");\n    printf(\"%s=\\\"%lld\\\"\", key, value);\n}\n\nstatic Writer xml_writer = {\n    .name                 = \"xml\",\n    .priv_size            = sizeof(XMLContext),\n    .init                 = xml_init,\n    .print_section_header = xml_print_section_header,\n    .print_section_footer = xml_print_section_footer,\n    .print_integer        = xml_print_int,\n    .print_string         = xml_print_str,\n    .flags = WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER,\n    .priv_class           = &xml_class,\n};\n\nstatic void writer_register_all(void)\n{\n    static int initialized;\n\n    if (initialized)\n        return;\n    initialized = 1;\n\n    writer_register(&default_writer);\n    writer_register(&compact_writer);\n    writer_register(&csv_writer);\n    writer_register(&flat_writer);\n    writer_register(&ini_writer);\n    writer_register(&json_writer);\n    writer_register(&xml_writer);\n}\n\n#define print_fmt(k, f, ...) do {              \\\n    av_bprint_clear(&pbuf);                    \\\n    av_bprintf(&pbuf, f, __VA_ARGS__);         \\\n    writer_print_string(w, k, pbuf.str, 0);    \\\n} while (0)\n\n#define print_int(k, v)         writer_print_integer(w, k, v)\n#define print_q(k, v, s)        writer_print_rational(w, k, v, s)\n#define print_str(k, v)         writer_print_string(w, k, v, 0)\n#define print_str_opt(k, v)     writer_print_string(w, k, v, PRINT_STRING_OPT)\n#define print_str_validate(k, v) writer_print_string(w, k, v, PRINT_STRING_VALIDATE)\n#define print_time(k, v, tb)    writer_print_time(w, k, v, tb, 0)\n#define print_ts(k, v)          writer_print_ts(w, k, v, 0)\n#define print_duration_time(k, v, tb) writer_print_time(w, k, v, tb, 1)\n#define print_duration_ts(k, v)       writer_print_ts(w, k, v, 1)\n#define print_val(k, v, u) do {                                     \\\n    struct unit_value uv;                                           \\\n    uv.val.i = v;                                                   \\\n    uv.unit = u;                                                    \\\n    writer_print_string(w, k, value_string(val_str, sizeof(val_str), uv), 0); \\\n} while (0)\n\n#define print_section_header(s) writer_print_section_header(w, s)\n#define print_section_footer(s) writer_print_section_footer(w, s)\n\n#define REALLOCZ_ARRAY_STREAM(ptr, cur_n, new_n)                        \\\n{                                                                       \\\n    ret = av_reallocp_array(&(ptr), (new_n), sizeof(*(ptr)));           \\\n    if (ret < 0)                                                        \\\n        goto end;                                                       \\\n    memset( (ptr) + (cur_n), 0, ((new_n) - (cur_n)) * sizeof(*(ptr)) ); \\\n}\n\nstatic inline int show_tags(WriterContext *w, AVDictionary *tags, int section_id)\n{\n    AVDictionaryEntry *tag = NULL;\n    int ret = 0;\n\n    if (!tags)\n        return 0;\n    writer_print_section_header(w, section_id);\n\n    while ((tag = av_dict_get(tags, \"\", tag, AV_DICT_IGNORE_SUFFIX))) {\n        if ((ret = print_str_validate(tag->key, tag->value)) < 0)\n            break;\n    }\n    writer_print_section_footer(w);\n\n    return ret;\n}\n\nstatic void print_pkt_side_data(WriterContext *w,\n                                AVCodecParameters *par,\n                                const AVPacketSideData *side_data,\n                                int nb_side_data,\n                                SectionID id_data_list,\n                                SectionID id_data)\n{\n    int i;\n\n    writer_print_section_header(w, id_data_list);\n    for (i = 0; i < nb_side_data; i++) {\n        const AVPacketSideData *sd = &side_data[i];\n        const char *name = av_packet_side_data_name(sd->type);\n\n        writer_print_section_header(w, id_data);\n        print_str(\"side_data_type\", name ? name : \"unknown\");\n        if (sd->type == AV_PKT_DATA_DISPLAYMATRIX && sd->size >= 9*4) {\n            writer_print_integers(w, \"displaymatrix\", sd->data, 9, \" %11d\", 3, 4, 1);\n            print_int(\"rotation\", av_display_rotation_get((int32_t *)sd->data));\n        } else if (sd->type == AV_PKT_DATA_STEREO3D) {\n            const AVStereo3D *stereo = (AVStereo3D *)sd->data;\n            print_str(\"type\", av_stereo3d_type_name(stereo->type));\n            print_int(\"inverted\", !!(stereo->flags & AV_STEREO3D_FLAG_INVERT));\n        } else if (sd->type == AV_PKT_DATA_SPHERICAL) {\n            const AVSphericalMapping *spherical = (AVSphericalMapping *)sd->data;\n            print_str(\"projection\", av_spherical_projection_name(spherical->projection));\n            if (spherical->projection == AV_SPHERICAL_CUBEMAP) {\n                print_int(\"padding\", spherical->padding);\n            } else if (spherical->projection == AV_SPHERICAL_EQUIRECTANGULAR_TILE) {\n                size_t l, t, r, b;\n                av_spherical_tile_bounds(spherical, par->width, par->height,\n                                         &l, &t, &r, &b);\n                print_int(\"bound_left\", l);\n                print_int(\"bound_top\", t);\n                print_int(\"bound_right\", r);\n                print_int(\"bound_bottom\", b);\n            }\n\n            print_int(\"yaw\", (double) spherical->yaw / (1 << 16));\n            print_int(\"pitch\", (double) spherical->pitch / (1 << 16));\n            print_int(\"roll\", (double) spherical->roll / (1 << 16));\n        } else if (sd->type == AV_PKT_DATA_SKIP_SAMPLES && sd->size == 10) {\n            print_int(\"skip_samples\",    AV_RL32(sd->data));\n            print_int(\"discard_padding\", AV_RL32(sd->data + 4));\n            print_int(\"skip_reason\",     AV_RL8(sd->data + 8));\n            print_int(\"discard_reason\",  AV_RL8(sd->data + 9));\n        } else if (sd->type == AV_PKT_DATA_MASTERING_DISPLAY_METADATA) {\n            AVMasteringDisplayMetadata *metadata = (AVMasteringDisplayMetadata *)sd->data;\n\n            if (metadata->has_primaries) {\n                print_q(\"red_x\", metadata->display_primaries[0][0], '/');\n                print_q(\"red_y\", metadata->display_primaries[0][1], '/');\n                print_q(\"green_x\", metadata->display_primaries[1][0], '/');\n                print_q(\"green_y\", metadata->display_primaries[1][1], '/');\n                print_q(\"blue_x\", metadata->display_primaries[2][0], '/');\n                print_q(\"blue_y\", metadata->display_primaries[2][1], '/');\n\n                print_q(\"white_point_x\", metadata->white_point[0], '/');\n                print_q(\"white_point_y\", metadata->white_point[1], '/');\n            }\n\n            if (metadata->has_luminance) {\n                print_q(\"min_luminance\", metadata->min_luminance, '/');\n                print_q(\"max_luminance\", metadata->max_luminance, '/');\n            }\n        } else if (sd->type == AV_PKT_DATA_CONTENT_LIGHT_LEVEL) {\n            AVContentLightMetadata *metadata = (AVContentLightMetadata *)sd->data;\n            print_int(\"max_content\", metadata->MaxCLL);\n            print_int(\"max_average\", metadata->MaxFALL);\n        }\n        writer_print_section_footer(w);\n    }\n    writer_print_section_footer(w);\n}\n\nstatic void clear_log(int need_lock)\n{\n    int i;\n\n    if (need_lock)\n        pthread_mutex_lock(&log_mutex);\n    for (i=0; i<log_buffer_size; i++) {\n        av_freep(&log_buffer[i].context_name);\n        av_freep(&log_buffer[i].parent_name);\n        av_freep(&log_buffer[i].log_message);\n    }\n    log_buffer_size = 0;\n    if(need_lock)\n        pthread_mutex_unlock(&log_mutex);\n}\n\nstatic int show_log(WriterContext *w, int section_ids, int section_id, int log_level)\n{\n    int i;\n    pthread_mutex_lock(&log_mutex);\n    if (!log_buffer_size) {\n        pthread_mutex_unlock(&log_mutex);\n        return 0;\n    }\n    writer_print_section_header(w, section_ids);\n\n    for (i=0; i<log_buffer_size; i++) {\n        if (log_buffer[i].log_level <= log_level) {\n            writer_print_section_header(w, section_id);\n            print_str(\"context\", log_buffer[i].context_name);\n            print_int(\"level\", log_buffer[i].log_level);\n            print_int(\"category\", log_buffer[i].category);\n            if (log_buffer[i].parent_name) {\n                print_str(\"parent_context\", log_buffer[i].parent_name);\n                print_int(\"parent_category\", log_buffer[i].parent_category);\n            } else {\n                print_str_opt(\"parent_context\", \"N/A\");\n                print_str_opt(\"parent_category\", \"N/A\");\n            }\n            print_str(\"message\", log_buffer[i].log_message);\n            writer_print_section_footer(w);\n        }\n    }\n    clear_log(0);\n    pthread_mutex_unlock(&log_mutex);\n\n    writer_print_section_footer(w);\n\n    return 0;\n}\n\nstatic void show_packet(WriterContext *w, InputFile *ifile, AVPacket *pkt, int packet_idx)\n{\n    char val_str[128];\n    AVStream *st = ifile->streams[pkt->stream_index].st;\n    AVBPrint pbuf;\n    const char *s;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, SECTION_ID_PACKET);\n\n    s = av_get_media_type_string(st->codecpar->codec_type);\n    if (s) print_str    (\"codec_type\", s);\n    else   print_str_opt(\"codec_type\", \"unknown\");\n    print_int(\"stream_index\",     pkt->stream_index);\n    print_ts  (\"pts\",             pkt->pts);\n    print_time(\"pts_time\",        pkt->pts, &st->time_base);\n    print_ts  (\"dts\",             pkt->dts);\n    print_time(\"dts_time\",        pkt->dts, &st->time_base);\n    print_duration_ts(\"duration\",        pkt->duration);\n    print_duration_time(\"duration_time\", pkt->duration, &st->time_base);\n    print_duration_ts(\"convergence_duration\", pkt->convergence_duration);\n    print_duration_time(\"convergence_duration_time\", pkt->convergence_duration, &st->time_base);\n    print_val(\"size\",             pkt->size, unit_byte_str);\n    if (pkt->pos != -1) print_fmt    (\"pos\", \"%\"PRId64, pkt->pos);\n    else                print_str_opt(\"pos\", \"N/A\");\n    print_fmt(\"flags\", \"%c%c\",      pkt->flags & AV_PKT_FLAG_KEY ? 'K' : '_',\n              pkt->flags & AV_PKT_FLAG_DISCARD ? 'D' : '_');\n\n    if (pkt->side_data_elems) {\n        int size;\n        const uint8_t *side_metadata;\n\n        side_metadata = av_packet_get_side_data(pkt, AV_PKT_DATA_STRINGS_METADATA, &size);\n        if (side_metadata && size && do_show_packet_tags) {\n            AVDictionary *dict = NULL;\n            if (av_packet_unpack_dictionary(side_metadata, size, &dict) >= 0)\n                show_tags(w, dict, SECTION_ID_PACKET_TAGS);\n            av_dict_free(&dict);\n        }\n\n        print_pkt_side_data(w, st->codecpar, pkt->side_data, pkt->side_data_elems,\n                            SECTION_ID_PACKET_SIDE_DATA_LIST,\n                            SECTION_ID_PACKET_SIDE_DATA);\n    }\n\n    if (do_show_data)\n        writer_print_data(w, \"data\", pkt->data, pkt->size);\n    writer_print_data_hash(w, \"data_hash\", pkt->data, pkt->size);\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n}\n\nstatic void show_subtitle(WriterContext *w, AVSubtitle *sub, AVStream *stream,\n                          AVFormatContext *fmt_ctx)\n{\n    AVBPrint pbuf;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, SECTION_ID_SUBTITLE);\n\n    print_str (\"media_type\",         \"subtitle\");\n    print_ts  (\"pts\",                 sub->pts);\n    print_time(\"pts_time\",            sub->pts, &AV_TIME_BASE_Q);\n    print_int (\"format\",              sub->format);\n    print_int (\"start_display_time\",  sub->start_display_time);\n    print_int (\"end_display_time\",    sub->end_display_time);\n    print_int (\"num_rects\",           sub->num_rects);\n\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n}\n\nstatic void show_frame(WriterContext *w, AVFrame *frame, AVStream *stream,\n                       AVFormatContext *fmt_ctx)\n{\n    AVBPrint pbuf;\n    char val_str[128];\n    const char *s;\n    int i;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, SECTION_ID_FRAME);\n\n    s = av_get_media_type_string(stream->codecpar->codec_type);\n    if (s) print_str    (\"media_type\", s);\n    else   print_str_opt(\"media_type\", \"unknown\");\n    print_int(\"stream_index\",           stream->index);\n    print_int(\"key_frame\",              frame->key_frame);\n    print_ts  (\"pkt_pts\",               frame->pts);\n    print_time(\"pkt_pts_time\",          frame->pts, &stream->time_base);\n    print_ts  (\"pkt_dts\",               frame->pkt_dts);\n    print_time(\"pkt_dts_time\",          frame->pkt_dts, &stream->time_base);\n    print_ts  (\"best_effort_timestamp\", frame->best_effort_timestamp);\n    print_time(\"best_effort_timestamp_time\", frame->best_effort_timestamp, &stream->time_base);\n    print_duration_ts  (\"pkt_duration\",      frame->pkt_duration);\n    print_duration_time(\"pkt_duration_time\", frame->pkt_duration, &stream->time_base);\n    if (frame->pkt_pos != -1) print_fmt    (\"pkt_pos\", \"%\"PRId64, frame->pkt_pos);\n    else                      print_str_opt(\"pkt_pos\", \"N/A\");\n    if (frame->pkt_size != -1) print_val    (\"pkt_size\", frame->pkt_size, unit_byte_str);\n    else                       print_str_opt(\"pkt_size\", \"N/A\");\n\n    switch (stream->codecpar->codec_type) {\n        AVRational sar;\n\n    case AVMEDIA_TYPE_VIDEO:\n        print_int(\"width\",                  frame->width);\n        print_int(\"height\",                 frame->height);\n        s = av_get_pix_fmt_name(frame->format);\n        if (s) print_str    (\"pix_fmt\", s);\n        else   print_str_opt(\"pix_fmt\", \"unknown\");\n        sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, frame);\n        if (sar.num) {\n            print_q(\"sample_aspect_ratio\", sar, ':');\n        } else {\n            print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n        }\n        print_fmt(\"pict_type\",              \"%c\", av_get_picture_type_char(frame->pict_type));\n        print_int(\"coded_picture_number\",   frame->coded_picture_number);\n        print_int(\"display_picture_number\", frame->display_picture_number);\n        print_int(\"interlaced_frame\",       frame->interlaced_frame);\n        print_int(\"top_field_first\",        frame->top_field_first);\n        print_int(\"repeat_pict\",            frame->repeat_pict);\n\n        if (frame->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str(\"color_range\", av_color_range_name(frame->color_range));\n        else\n            print_str_opt(\"color_range\", av_color_range_name(frame->color_range));\n\n        if (frame->colorspace != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(frame->colorspace));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(frame->colorspace));\n\n        if (frame->color_primaries != AVCOL_PRI_UNSPECIFIED)\n            print_str(\"color_primaries\", av_color_primaries_name(frame->color_primaries));\n        else\n            print_str_opt(\"color_primaries\", av_color_primaries_name(frame->color_primaries));\n\n        if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n\n        if (frame->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n        s = av_get_sample_fmt_name(frame->format);\n        if (s) print_str    (\"sample_fmt\", s);\n        else   print_str_opt(\"sample_fmt\", \"unknown\");\n        print_int(\"nb_samples\",         frame->nb_samples);\n        print_int(\"channels\", frame->channels);\n        if (frame->channel_layout) {\n            av_bprint_clear(&pbuf);\n            av_bprint_channel_layout(&pbuf, frame->channels,\n                                     frame->channel_layout);\n            print_str    (\"channel_layout\", pbuf.str);\n        } else\n            print_str_opt(\"channel_layout\", \"unknown\");\n        break;\n    }\n    if (do_show_frame_tags)\n        show_tags(w, frame->metadata, SECTION_ID_FRAME_TAGS);\n    if (do_show_log)\n        show_log(w, SECTION_ID_FRAME_LOGS, SECTION_ID_FRAME_LOG, do_show_log);\n    if (frame->nb_side_data) {\n        writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA_LIST);\n        for (i = 0; i < frame->nb_side_data; i++) {\n            AVFrameSideData *sd = frame->side_data[i];\n            const char *name;\n\n            writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA);\n            name = av_frame_side_data_name(sd->type);\n            print_str(\"side_data_type\", name ? name : \"unknown\");\n            if (sd->type == AV_FRAME_DATA_DISPLAYMATRIX && sd->size >= 9*4) {\n                writer_print_integers(w, \"displaymatrix\", sd->data, 9, \" %11d\", 3, 4, 1);\n                print_int(\"rotation\", av_display_rotation_get((int32_t *)sd->data));\n            } else if (sd->type == AV_FRAME_DATA_GOP_TIMECODE && sd->size >= 8) {\n                char tcbuf[AV_TIMECODE_STR_SIZE];\n                av_timecode_make_mpeg_tc_string(tcbuf, *(int64_t *)(sd->data));\n                print_str(\"timecode\", tcbuf);\n            } else if (sd->type == AV_FRAME_DATA_MASTERING_DISPLAY_METADATA) {\n                AVMasteringDisplayMetadata *metadata = (AVMasteringDisplayMetadata *)sd->data;\n\n                if (metadata->has_primaries) {\n                    print_q(\"red_x\", metadata->display_primaries[0][0], '/');\n                    print_q(\"red_y\", metadata->display_primaries[0][1], '/');\n                    print_q(\"green_x\", metadata->display_primaries[1][0], '/');\n                    print_q(\"green_y\", metadata->display_primaries[1][1], '/');\n                    print_q(\"blue_x\", metadata->display_primaries[2][0], '/');\n                    print_q(\"blue_y\", metadata->display_primaries[2][1], '/');\n\n                    print_q(\"white_point_x\", metadata->white_point[0], '/');\n                    print_q(\"white_point_y\", metadata->white_point[1], '/');\n                }\n\n                if (metadata->has_luminance) {\n                    print_q(\"min_luminance\", metadata->min_luminance, '/');\n                    print_q(\"max_luminance\", metadata->max_luminance, '/');\n                }\n            } else if (sd->type == AV_FRAME_DATA_CONTENT_LIGHT_LEVEL) {\n                AVContentLightMetadata *metadata = (AVContentLightMetadata *)sd->data;\n                print_int(\"max_content\", metadata->MaxCLL);\n                print_int(\"max_average\", metadata->MaxFALL);\n            } else if (sd->type == AV_FRAME_DATA_ICC_PROFILE) {\n                AVDictionaryEntry *tag = av_dict_get(sd->metadata, \"name\", NULL, AV_DICT_MATCH_CASE);\n                if (tag)\n                    print_str(tag->key, tag->value);\n                print_int(\"size\", sd->size);\n            }\n            writer_print_section_footer(w);\n        }\n        writer_print_section_footer(w);\n    }\n\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n}\n\nstatic av_always_inline int process_frame(WriterContext *w,\n                                          InputFile *ifile,\n                                          AVFrame *frame, AVPacket *pkt,\n                                          int *packet_new)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    AVCodecContext *dec_ctx = ifile->streams[pkt->stream_index].dec_ctx;\n    AVCodecParameters *par = ifile->streams[pkt->stream_index].st->codecpar;\n    AVSubtitle sub;\n    int ret = 0, got_frame = 0;\n\n    clear_log(1);\n    if (dec_ctx && dec_ctx->codec) {\n        switch (par->codec_type) {\n        case AVMEDIA_TYPE_VIDEO:\n        case AVMEDIA_TYPE_AUDIO:\n            if (*packet_new) {\n                ret = avcodec_send_packet(dec_ctx, pkt);\n                if (ret == AVERROR(EAGAIN)) {\n                    ret = 0;\n                } else if (ret >= 0 || ret == AVERROR_EOF) {\n                    ret = 0;\n                    *packet_new = 0;\n                }\n            }\n            if (ret >= 0) {\n                ret = avcodec_receive_frame(dec_ctx, frame);\n                if (ret >= 0) {\n                    got_frame = 1;\n                } else if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {\n                    ret = 0;\n                }\n            }\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n            ret = avcodec_decode_subtitle2(dec_ctx, &sub, &got_frame, pkt);\n            *packet_new = 0;\n            break;\n        default:\n            *packet_new = 0;\n        }\n    } else {\n        *packet_new = 0;\n    }\n\n    if (ret < 0)\n        return ret;\n    if (got_frame) {\n        int is_sub = (par->codec_type == AVMEDIA_TYPE_SUBTITLE);\n        nb_streams_frames[pkt->stream_index]++;\n        if (do_show_frames)\n            if (is_sub)\n                show_subtitle(w, &sub, ifile->streams[pkt->stream_index].st, fmt_ctx);\n            else\n                show_frame(w, frame, ifile->streams[pkt->stream_index].st, fmt_ctx);\n        if (is_sub)\n            avsubtitle_free(&sub);\n    }\n    return got_frame || *packet_new;\n}\n\nstatic void log_read_interval(const ReadInterval *interval, void *log_ctx, int log_level)\n{\n    av_log(log_ctx, log_level, \"id:%d\", interval->id);\n\n    if (interval->has_start) {\n        av_log(log_ctx, log_level, \" start:%s%s\", interval->start_is_offset ? \"+\" : \"\",\n               av_ts2timestr(interval->start, &AV_TIME_BASE_Q));\n    } else {\n        av_log(log_ctx, log_level, \" start:N/A\");\n    }\n\n    if (interval->has_end) {\n        av_log(log_ctx, log_level, \" end:%s\", interval->end_is_offset ? \"+\" : \"\");\n        if (interval->duration_frames)\n            av_log(log_ctx, log_level, \"#%\"PRId64, interval->end);\n        else\n            av_log(log_ctx, log_level, \"%s\", av_ts2timestr(interval->end, &AV_TIME_BASE_Q));\n    } else {\n        av_log(log_ctx, log_level, \" end:N/A\");\n    }\n\n    av_log(log_ctx, log_level, \"\\n\");\n}\n\nstatic int read_interval_packets(WriterContext *w, InputFile *ifile,\n                                 const ReadInterval *interval, int64_t *cur_ts)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    AVPacket pkt;\n    AVFrame *frame = NULL;\n    int ret = 0, i = 0, frame_count = 0;\n    int64_t start = -INT64_MAX, end = interval->end;\n    int has_start = 0, has_end = interval->has_end && !interval->end_is_offset;\n\n    av_init_packet(&pkt);\n\n    av_log(NULL, AV_LOG_VERBOSE, \"Processing read interval \");\n    log_read_interval(interval, NULL, AV_LOG_VERBOSE);\n\n    if (interval->has_start) {\n        int64_t target;\n        if (interval->start_is_offset) {\n            if (*cur_ts == AV_NOPTS_VALUE) {\n                av_log(NULL, AV_LOG_ERROR,\n                       \"Could not seek to relative position since current \"\n                       \"timestamp is not defined\\n\");\n                ret = AVERROR(EINVAL);\n                goto end;\n            }\n            target = *cur_ts + interval->start;\n        } else {\n            target = interval->start;\n        }\n\n        av_log(NULL, AV_LOG_VERBOSE, \"Seeking to read interval start point %s\\n\",\n               av_ts2timestr(target, &AV_TIME_BASE_Q));\n        if ((ret = avformat_seek_file(fmt_ctx, -1, -INT64_MAX, target, INT64_MAX, 0)) < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Could not seek to position %\"PRId64\": %s\\n\",\n                   interval->start, av_err2str(ret));\n            goto end;\n        }\n    }\n\n    frame = av_frame_alloc();\n    if (!frame) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n    while (!av_read_frame(fmt_ctx, &pkt)) {\n        if (ifile->nb_streams > nb_streams) {\n            REALLOCZ_ARRAY_STREAM(nb_streams_frames,  nb_streams, fmt_ctx->nb_streams);\n            REALLOCZ_ARRAY_STREAM(nb_streams_packets, nb_streams, fmt_ctx->nb_streams);\n            REALLOCZ_ARRAY_STREAM(selected_streams,   nb_streams, fmt_ctx->nb_streams);\n            nb_streams = ifile->nb_streams;\n        }\n        if (selected_streams[pkt.stream_index]) {\n            AVRational tb = ifile->streams[pkt.stream_index].st->time_base;\n\n            if (pkt.pts != AV_NOPTS_VALUE)\n                *cur_ts = av_rescale_q(pkt.pts, tb, AV_TIME_BASE_Q);\n\n            if (!has_start && *cur_ts != AV_NOPTS_VALUE) {\n                start = *cur_ts;\n                has_start = 1;\n            }\n\n            if (has_start && !has_end && interval->end_is_offset) {\n                end = start + interval->end;\n                has_end = 1;\n            }\n\n            if (interval->end_is_offset && interval->duration_frames) {\n                if (frame_count >= interval->end)\n                    break;\n            } else if (has_end && *cur_ts != AV_NOPTS_VALUE && *cur_ts >= end) {\n                break;\n            }\n\n            frame_count++;\n            if (do_read_packets) {\n                if (do_show_packets)\n                    show_packet(w, ifile, &pkt, i++);\n                nb_streams_packets[pkt.stream_index]++;\n            }\n            if (do_read_frames) {\n                int packet_new = 1;\n                while (process_frame(w, ifile, frame, &pkt, &packet_new) > 0);\n            }\n        }\n        av_packet_unref(&pkt);\n    }\n    av_init_packet(&pkt);\n    pkt.data = NULL;\n    pkt.size = 0;\n    //Flush remaining frames that are cached in the decoder\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n        pkt.stream_index = i;\n        if (do_read_frames)\n            while (process_frame(w, ifile, frame, &pkt, &(int){1}) > 0);\n    }\n\nend:\n    av_frame_free(&frame);\n    if (ret < 0) {\n        av_log(NULL, AV_LOG_ERROR, \"Could not read packets in interval \");\n        log_read_interval(interval, NULL, AV_LOG_ERROR);\n    }\n    return ret;\n}\n\nstatic int read_packets(WriterContext *w, InputFile *ifile)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    int i, ret = 0;\n    int64_t cur_ts = fmt_ctx->start_time;\n\n    if (read_intervals_nb == 0) {\n        ReadInterval interval = (ReadInterval) { .has_start = 0, .has_end = 0 };\n        ret = read_interval_packets(w, ifile, &interval, &cur_ts);\n    } else {\n        for (i = 0; i < read_intervals_nb; i++) {\n            ret = read_interval_packets(w, ifile, &read_intervals[i], &cur_ts);\n            if (ret < 0)\n                break;\n        }\n    }\n\n    return ret;\n}\n\nstatic int show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, InputStream *ist, int in_program)\n{\n    AVStream *stream = ist->st;\n    AVCodecParameters *par;\n    AVCodecContext *dec_ctx;\n    char val_str[128];\n    const char *s;\n    AVRational sar, dar;\n    AVBPrint pbuf;\n    const AVCodecDescriptor *cd;\n    int ret = 0;\n    const char *profile = NULL;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);\n\n    print_int(\"index\", stream->index);\n\n    par     = stream->codecpar;\n    dec_ctx = ist->dec_ctx;\n    if (cd = avcodec_descriptor_get(par->codec_id)) {\n        print_str(\"codec_name\", cd->name);\n        if (!do_bitexact) {\n            print_str(\"codec_long_name\",\n                      cd->long_name ? cd->long_name : \"unknown\");\n        }\n    } else {\n        print_str_opt(\"codec_name\", \"unknown\");\n        if (!do_bitexact) {\n            print_str_opt(\"codec_long_name\", \"unknown\");\n        }\n    }\n\n    if (!do_bitexact && (profile = avcodec_profile_name(par->codec_id, par->profile)))\n        print_str(\"profile\", profile);\n    else {\n        if (par->profile != FF_PROFILE_UNKNOWN) {\n            char profile_num[12];\n            snprintf(profile_num, sizeof(profile_num), \"%d\", par->profile);\n            print_str(\"profile\", profile_num);\n        } else\n            print_str_opt(\"profile\", \"unknown\");\n    }\n\n    s = av_get_media_type_string(par->codec_type);\n    if (s) print_str    (\"codec_type\", s);\n    else   print_str_opt(\"codec_type\", \"unknown\");\n#if FF_API_LAVF_AVCTX\n    if (dec_ctx)\n        print_q(\"codec_time_base\", dec_ctx->time_base, '/');\n#endif\n\n    /* print AVI/FourCC tag */\n    print_str(\"codec_tag_string\",    av_fourcc2str(par->codec_tag));\n    print_fmt(\"codec_tag\", \"0x%04\"PRIx32, par->codec_tag);\n\n    switch (par->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        print_int(\"width\",        par->width);\n        print_int(\"height\",       par->height);\n        if (dec_ctx) {\n            print_int(\"coded_width\",  dec_ctx->coded_width);\n            print_int(\"coded_height\", dec_ctx->coded_height);\n        }\n        print_int(\"has_b_frames\", par->video_delay);\n        sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL);\n        if (sar.den) {\n            print_q(\"sample_aspect_ratio\", sar, ':');\n            av_reduce(&dar.num, &dar.den,\n                      par->width  * sar.num,\n                      par->height * sar.den,\n                      1024*1024);\n            print_q(\"display_aspect_ratio\", dar, ':');\n        } else {\n            print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n            print_str_opt(\"display_aspect_ratio\", \"N/A\");\n        }\n        s = av_get_pix_fmt_name(par->format);\n        if (s) print_str    (\"pix_fmt\", s);\n        else   print_str_opt(\"pix_fmt\", \"unknown\");\n        print_int(\"level\",   par->level);\n        if (par->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str    (\"color_range\", av_color_range_name(par->color_range));\n        else\n            print_str_opt(\"color_range\", \"N/A\");\n\n        if (par->color_space != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(par->color_space));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(par->color_space));\n\n        if (par->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(par->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(par->color_trc));\n\n        if (par->color_primaries != AVCOL_PRI_UNSPECIFIED)\n            print_str(\"color_primaries\", av_color_primaries_name(par->color_primaries));\n        else\n            print_str_opt(\"color_primaries\", av_color_primaries_name(par->color_primaries));\n\n        if (par->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(par->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(par->chroma_location));\n\n        if (par->field_order == AV_FIELD_PROGRESSIVE)\n            print_str(\"field_order\", \"progressive\");\n        else if (par->field_order == AV_FIELD_TT)\n            print_str(\"field_order\", \"tt\");\n        else if (par->field_order == AV_FIELD_BB)\n            print_str(\"field_order\", \"bb\");\n        else if (par->field_order == AV_FIELD_TB)\n            print_str(\"field_order\", \"tb\");\n        else if (par->field_order == AV_FIELD_BT)\n            print_str(\"field_order\", \"bt\");\n        else\n            print_str_opt(\"field_order\", \"unknown\");\n\n#if FF_API_PRIVATE_OPT\n        if (dec_ctx && dec_ctx->timecode_frame_start >= 0) {\n            char tcbuf[AV_TIMECODE_STR_SIZE];\n            av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start);\n            print_str(\"timecode\", tcbuf);\n        } else {\n            print_str_opt(\"timecode\", \"N/A\");\n        }\n#endif\n        if (dec_ctx)\n            print_int(\"refs\", dec_ctx->refs);\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n        s = av_get_sample_fmt_name(par->format);\n        if (s) print_str    (\"sample_fmt\", s);\n        else   print_str_opt(\"sample_fmt\", \"unknown\");\n        print_val(\"sample_rate\",     par->sample_rate, unit_hertz_str);\n        print_int(\"channels\",        par->channels);\n\n        if (par->channel_layout) {\n            av_bprint_clear(&pbuf);\n            av_bprint_channel_layout(&pbuf, par->channels, par->channel_layout);\n            print_str    (\"channel_layout\", pbuf.str);\n        } else {\n            print_str_opt(\"channel_layout\", \"unknown\");\n        }\n\n        print_int(\"bits_per_sample\", av_get_bits_per_sample(par->codec_id));\n        break;\n\n    case AVMEDIA_TYPE_SUBTITLE:\n        if (par->width)\n            print_int(\"width\",       par->width);\n        else\n            print_str_opt(\"width\",   \"N/A\");\n        if (par->height)\n            print_int(\"height\",      par->height);\n        else\n            print_str_opt(\"height\",  \"N/A\");\n        break;\n    }\n\n    if (dec_ctx && dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) {\n        const AVOption *opt = NULL;\n        while (opt = av_opt_next(dec_ctx->priv_data,opt)) {\n            uint8_t *str;\n            if (opt->flags) continue;\n            if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {\n                print_str(opt->name, str);\n                av_free(str);\n            }\n        }\n    }\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt    (\"id\", \"0x%x\", stream->id);\n    else                                          print_str_opt(\"id\", \"N/A\");\n    print_q(\"r_frame_rate\",   stream->r_frame_rate,   '/');\n    print_q(\"avg_frame_rate\", stream->avg_frame_rate, '/');\n    print_q(\"time_base\",      stream->time_base,      '/');\n    print_ts  (\"start_pts\",   stream->start_time);\n    print_time(\"start_time\",  stream->start_time, &stream->time_base);\n    print_ts  (\"duration_ts\", stream->duration);\n    print_time(\"duration\",    stream->duration, &stream->time_base);\n    if (par->bit_rate > 0)     print_val    (\"bit_rate\", par->bit_rate, unit_bit_per_second_str);\n    else                       print_str_opt(\"bit_rate\", \"N/A\");\n#if FF_API_LAVF_AVCTX\n    if (stream->codec->rc_max_rate > 0) print_val (\"max_bit_rate\", stream->codec->rc_max_rate, unit_bit_per_second_str);\n    else                                print_str_opt(\"max_bit_rate\", \"N/A\");\n#endif\n    if (dec_ctx && dec_ctx->bits_per_raw_sample > 0) print_fmt(\"bits_per_raw_sample\", \"%d\", dec_ctx->bits_per_raw_sample);\n    else                                             print_str_opt(\"bits_per_raw_sample\", \"N/A\");\n    if (stream->nb_frames) print_fmt    (\"nb_frames\", \"%\"PRId64, stream->nb_frames);\n    else                   print_str_opt(\"nb_frames\", \"N/A\");\n    if (nb_streams_frames[stream_idx])  print_fmt    (\"nb_read_frames\", \"%\"PRIu64, nb_streams_frames[stream_idx]);\n    else                                print_str_opt(\"nb_read_frames\", \"N/A\");\n    if (nb_streams_packets[stream_idx]) print_fmt    (\"nb_read_packets\", \"%\"PRIu64, nb_streams_packets[stream_idx]);\n    else                                print_str_opt(\"nb_read_packets\", \"N/A\");\n    if (do_show_data)\n        writer_print_data(w, \"extradata\", par->extradata,\n                                          par->extradata_size);\n    writer_print_data_hash(w, \"extradata_hash\", par->extradata,\n                                                par->extradata_size);\n\n    /* Print disposition information */\n#define PRINT_DISPOSITION(flagname, name) do {                                \\\n        print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \\\n    } while (0)\n\n    if (do_show_stream_disposition) {\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION);\n    PRINT_DISPOSITION(DEFAULT,          \"default\");\n    PRINT_DISPOSITION(DUB,              \"dub\");\n    PRINT_DISPOSITION(ORIGINAL,         \"original\");\n    PRINT_DISPOSITION(COMMENT,          \"comment\");\n    PRINT_DISPOSITION(LYRICS,           \"lyrics\");\n    PRINT_DISPOSITION(KARAOKE,          \"karaoke\");\n    PRINT_DISPOSITION(FORCED,           \"forced\");\n    PRINT_DISPOSITION(HEARING_IMPAIRED, \"hearing_impaired\");\n    PRINT_DISPOSITION(VISUAL_IMPAIRED,  \"visual_impaired\");\n    PRINT_DISPOSITION(CLEAN_EFFECTS,    \"clean_effects\");\n    PRINT_DISPOSITION(ATTACHED_PIC,     \"attached_pic\");\n    PRINT_DISPOSITION(TIMED_THUMBNAILS, \"timed_thumbnails\");\n    writer_print_section_footer(w);\n    }\n\n    if (do_show_stream_tags)\n        ret = show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS);\n\n    if (stream->nb_side_data) {\n        print_pkt_side_data(w, stream->codecpar, stream->side_data, stream->nb_side_data,\n                            SECTION_ID_STREAM_SIDE_DATA_LIST,\n                            SECTION_ID_STREAM_SIDE_DATA);\n    }\n\n    writer_print_section_footer(w);\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n\n    return ret;\n}\n\nstatic int show_streams(WriterContext *w, InputFile *ifile)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    int i, ret = 0;\n\n    writer_print_section_header(w, SECTION_ID_STREAMS);\n    for (i = 0; i < ifile->nb_streams; i++)\n        if (selected_streams[i]) {\n            ret = show_stream(w, fmt_ctx, i, &ifile->streams[i], 0);\n            if (ret < 0)\n                break;\n        }\n    writer_print_section_footer(w);\n\n    return ret;\n}\n\nstatic int show_program(WriterContext *w, InputFile *ifile, AVProgram *program)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    int i, ret = 0;\n\n    writer_print_section_header(w, SECTION_ID_PROGRAM);\n    print_int(\"program_id\", program->id);\n    print_int(\"program_num\", program->program_num);\n    print_int(\"nb_streams\", program->nb_stream_indexes);\n    print_int(\"pmt_pid\", program->pmt_pid);\n    print_int(\"pcr_pid\", program->pcr_pid);\n    print_ts(\"start_pts\", program->start_time);\n    print_time(\"start_time\", program->start_time, &AV_TIME_BASE_Q);\n    print_ts(\"end_pts\", program->end_time);\n    print_time(\"end_time\", program->end_time, &AV_TIME_BASE_Q);\n    if (do_show_program_tags)\n        ret = show_tags(w, program->metadata, SECTION_ID_PROGRAM_TAGS);\n    if (ret < 0)\n        goto end;\n\n    writer_print_section_header(w, SECTION_ID_PROGRAM_STREAMS);\n    for (i = 0; i < program->nb_stream_indexes; i++) {\n        if (selected_streams[program->stream_index[i]]) {\n            ret = show_stream(w, fmt_ctx, program->stream_index[i], &ifile->streams[program->stream_index[i]], 1);\n            if (ret < 0)\n                break;\n        }\n    }\n    writer_print_section_footer(w);\n\nend:\n    writer_print_section_footer(w);\n    return ret;\n}\n\nstatic int show_programs(WriterContext *w, InputFile *ifile)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    int i, ret = 0;\n\n    writer_print_section_header(w, SECTION_ID_PROGRAMS);\n    for (i = 0; i < fmt_ctx->nb_programs; i++) {\n        AVProgram *program = fmt_ctx->programs[i];\n        if (!program)\n            continue;\n        ret = show_program(w, ifile, program);\n        if (ret < 0)\n            break;\n    }\n    writer_print_section_footer(w);\n    return ret;\n}\n\nstatic int show_chapters(WriterContext *w, InputFile *ifile)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    int i, ret = 0;\n\n    writer_print_section_header(w, SECTION_ID_CHAPTERS);\n    for (i = 0; i < fmt_ctx->nb_chapters; i++) {\n        AVChapter *chapter = fmt_ctx->chapters[i];\n\n        writer_print_section_header(w, SECTION_ID_CHAPTER);\n        print_int(\"id\", chapter->id);\n        print_q  (\"time_base\", chapter->time_base, '/');\n        print_int(\"start\", chapter->start);\n        print_time(\"start_time\", chapter->start, &chapter->time_base);\n        print_int(\"end\", chapter->end);\n        print_time(\"end_time\", chapter->end, &chapter->time_base);\n        if (do_show_chapter_tags)\n            ret = show_tags(w, chapter->metadata, SECTION_ID_CHAPTER_TAGS);\n        writer_print_section_footer(w);\n    }\n    writer_print_section_footer(w);\n\n    return ret;\n}\n\nstatic int show_format(WriterContext *w, InputFile *ifile)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    char val_str[128];\n    int64_t size = fmt_ctx->pb ? avio_size(fmt_ctx->pb) : -1;\n    int ret = 0;\n\n    writer_print_section_header(w, SECTION_ID_FORMAT);\n    print_str_validate(\"filename\", fmt_ctx->filename);\n    print_int(\"nb_streams\",       fmt_ctx->nb_streams);\n    print_int(\"nb_programs\",      fmt_ctx->nb_programs);\n    print_str(\"format_name\",      fmt_ctx->iformat->name);\n    if (!do_bitexact) {\n        if (fmt_ctx->iformat->long_name) print_str    (\"format_long_name\", fmt_ctx->iformat->long_name);\n        else                             print_str_opt(\"format_long_name\", \"unknown\");\n    }\n    print_time(\"start_time\",      fmt_ctx->start_time, &AV_TIME_BASE_Q);\n    print_time(\"duration\",        fmt_ctx->duration,   &AV_TIME_BASE_Q);\n    if (size >= 0) print_val    (\"size\", size, unit_byte_str);\n    else           print_str_opt(\"size\", \"N/A\");\n    if (fmt_ctx->bit_rate > 0) print_val    (\"bit_rate\", fmt_ctx->bit_rate, unit_bit_per_second_str);\n    else                       print_str_opt(\"bit_rate\", \"N/A\");\n    print_int(\"probe_score\", av_format_get_probe_score(fmt_ctx));\n    if (do_show_format_tags)\n        ret = show_tags(w, fmt_ctx->metadata, SECTION_ID_FORMAT_TAGS);\n\n    writer_print_section_footer(w);\n    fflush(stdout);\n    return ret;\n}\n\nstatic void show_error(WriterContext *w, int err)\n{\n    char errbuf[128];\n    const char *errbuf_ptr = errbuf;\n\n    if (av_strerror(err, errbuf, sizeof(errbuf)) < 0)\n        errbuf_ptr = strerror(AVUNERROR(err));\n\n    writer_print_section_header(w, SECTION_ID_ERROR);\n    print_int(\"code\", err);\n    print_str(\"string\", errbuf_ptr);\n    writer_print_section_footer(w);\n}\n\nstatic int open_input_file(InputFile *ifile, const char *filename)\n{\n    int err, i;\n    AVFormatContext *fmt_ctx = NULL;\n    AVDictionaryEntry *t;\n    int scan_all_pmts_set = 0;\n\n    fmt_ctx = avformat_alloc_context();\n    if (!fmt_ctx) {\n        print_error(filename, AVERROR(ENOMEM));\n        exit_program(1);\n    }\n\n    fmt_ctx->flags |= AVFMT_FLAG_KEEP_SIDE_DATA;\n\n    if (!av_dict_get(format_opts, \"scan_all_pmts\", NULL, AV_DICT_MATCH_CASE)) {\n        av_dict_set(&format_opts, \"scan_all_pmts\", \"1\", AV_DICT_DONT_OVERWRITE);\n        scan_all_pmts_set = 1;\n    }\n    if ((err = avformat_open_input(&fmt_ctx, filename,\n                                   iformat, &format_opts)) < 0) {\n        print_error(filename, err);\n        return err;\n    }\n    ifile->fmt_ctx = fmt_ctx;\n    if (scan_all_pmts_set)\n        av_dict_set(&format_opts, \"scan_all_pmts\", NULL, AV_DICT_MATCH_CASE);\n    if ((t = av_dict_get(format_opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n        av_log(NULL, AV_LOG_ERROR, \"Option %s not found.\\n\", t->key);\n        return AVERROR_OPTION_NOT_FOUND;\n    }\n\n    if (find_stream_info) {\n        AVDictionary **opts = setup_find_stream_info_opts(fmt_ctx, codec_opts);\n        int orig_nb_streams = fmt_ctx->nb_streams;\n\n        err = avformat_find_stream_info(fmt_ctx, opts);\n\n        for (i = 0; i < orig_nb_streams; i++)\n            av_dict_free(&opts[i]);\n        av_freep(&opts);\n\n        if (err < 0) {\n            print_error(filename, err);\n            return err;\n        }\n    }\n\n    av_dump_format(fmt_ctx, 0, filename, 0);\n\n    ifile->streams = av_mallocz_array(fmt_ctx->nb_streams,\n                                      sizeof(*ifile->streams));\n    if (!ifile->streams)\n        exit(1);\n    ifile->nb_streams = fmt_ctx->nb_streams;\n\n    /* bind a decoder to each input stream */\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n        InputStream *ist = &ifile->streams[i];\n        AVStream *stream = fmt_ctx->streams[i];\n        AVCodec *codec;\n\n        ist->st = stream;\n\n        if (stream->codecpar->codec_id == AV_CODEC_ID_PROBE) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"Failed to probe codec for input stream %d\\n\",\n                    stream->index);\n            continue;\n        }\n\n        codec = avcodec_find_decoder(stream->codecpar->codec_id);\n        if (!codec) {\n            av_log(NULL, AV_LOG_WARNING,\n                    \"Unsupported codec with id %d for input stream %d\\n\",\n                    stream->codecpar->codec_id, stream->index);\n            continue;\n        }\n        {\n            AVDictionary *opts = filter_codec_opts(codec_opts, stream->codecpar->codec_id,\n                                                   fmt_ctx, stream, codec);\n\n            ist->dec_ctx = avcodec_alloc_context3(codec);\n            if (!ist->dec_ctx)\n                exit(1);\n\n            err = avcodec_parameters_to_context(ist->dec_ctx, stream->codecpar);\n            if (err < 0)\n                exit(1);\n\n            if (do_show_log) {\n                // For loging it is needed to disable at least frame threads as otherwise\n                // the log information would need to be reordered and matches up to contexts and frames\n                // That is in fact possible but not trivial\n                av_dict_set(&codec_opts, \"threads\", \"1\", 0);\n            }\n\n            av_codec_set_pkt_timebase(ist->dec_ctx, stream->time_base);\n            ist->dec_ctx->framerate = stream->avg_frame_rate;\n\n            if (avcodec_open2(ist->dec_ctx, codec, &opts) < 0) {\n                av_log(NULL, AV_LOG_WARNING, \"Could not open codec for input stream %d\\n\",\n                       stream->index);\n                exit(1);\n            }\n\n            if ((t = av_dict_get(opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n                av_log(NULL, AV_LOG_ERROR, \"Option %s for input stream %d not found\\n\",\n                       t->key, stream->index);\n                return AVERROR_OPTION_NOT_FOUND;\n            }\n        }\n    }\n\n    ifile->fmt_ctx = fmt_ctx;\n    return 0;\n}\n\nstatic void close_input_file(InputFile *ifile)\n{\n    int i;\n\n    /* close decoder for each stream */\n    for (i = 0; i < ifile->nb_streams; i++)\n        if (ifile->streams[i].st->codecpar->codec_id != AV_CODEC_ID_NONE)\n            avcodec_free_context(&ifile->streams[i].dec_ctx);\n\n    av_freep(&ifile->streams);\n    ifile->nb_streams = 0;\n\n    avformat_close_input(&ifile->fmt_ctx);\n}\n\nstatic int probe_file(WriterContext *wctx, const char *filename)\n{\n    InputFile ifile = { 0 };\n    int ret, i;\n    int section_id;\n\n    do_read_frames = do_show_frames || do_count_frames;\n    do_read_packets = do_show_packets || do_count_packets;\n\n    ret = open_input_file(&ifile, filename);\n    if (ret < 0)\n        goto end;\n\n#define CHECK_END if (ret < 0) goto end\n\n    nb_streams = ifile.fmt_ctx->nb_streams;\n    REALLOCZ_ARRAY_STREAM(nb_streams_frames,0,ifile.fmt_ctx->nb_streams);\n    REALLOCZ_ARRAY_STREAM(nb_streams_packets,0,ifile.fmt_ctx->nb_streams);\n    REALLOCZ_ARRAY_STREAM(selected_streams,0,ifile.fmt_ctx->nb_streams);\n\n    for (i = 0; i < ifile.fmt_ctx->nb_streams; i++) {\n        if (stream_specifier) {\n            ret = avformat_match_stream_specifier(ifile.fmt_ctx,\n                                                  ifile.fmt_ctx->streams[i],\n                                                  stream_specifier);\n            CHECK_END;\n            else\n                selected_streams[i] = ret;\n            ret = 0;\n        } else {\n            selected_streams[i] = 1;\n        }\n        if (!selected_streams[i])\n            ifile.fmt_ctx->streams[i]->discard = AVDISCARD_ALL;\n    }\n\n    if (do_read_frames || do_read_packets) {\n        if (do_show_frames && do_show_packets &&\n            wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER)\n            section_id = SECTION_ID_PACKETS_AND_FRAMES;\n        else if (do_show_packets && !do_show_frames)\n            section_id = SECTION_ID_PACKETS;\n        else // (!do_show_packets && do_show_frames)\n            section_id = SECTION_ID_FRAMES;\n        if (do_show_frames || do_show_packets)\n            writer_print_section_header(wctx, section_id);\n        ret = read_packets(wctx, &ifile);\n        if (do_show_frames || do_show_packets)\n            writer_print_section_footer(wctx);\n        CHECK_END;\n    }\n\n    if (do_show_programs) {\n        ret = show_programs(wctx, &ifile);\n        CHECK_END;\n    }\n\n    if (do_show_streams) {\n        ret = show_streams(wctx, &ifile);\n        CHECK_END;\n    }\n    if (do_show_chapters) {\n        ret = show_chapters(wctx, &ifile);\n        CHECK_END;\n    }\n    if (do_show_format) {\n        ret = show_format(wctx, &ifile);\n        CHECK_END;\n    }\n\nend:\n    if (ifile.fmt_ctx)\n        close_input_file(&ifile);\n    av_freep(&nb_streams_frames);\n    av_freep(&nb_streams_packets);\n    av_freep(&selected_streams);\n\n    return ret;\n}\n\nstatic void show_usage(void)\n{\n    av_log(NULL, AV_LOG_INFO, \"Simple multimedia streams analyzer\\n\");\n    av_log(NULL, AV_LOG_INFO, \"usage: %s [OPTIONS] [INPUT_FILE]\\n\", program_name);\n    av_log(NULL, AV_LOG_INFO, \"\\n\");\n}\n\nstatic void ffprobe_show_program_version(WriterContext *w)\n{\n    AVBPrint pbuf;\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, SECTION_ID_PROGRAM_VERSION);\n    print_str(\"version\", FFMPEG_VERSION);\n    print_fmt(\"copyright\", \"Copyright (c) %d-%d the FFmpeg developers\",\n              program_birth_year, CONFIG_THIS_YEAR);\n    print_str(\"compiler_ident\", CC_IDENT);\n    print_str(\"configuration\", FFMPEG_CONFIGURATION);\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n}\n\n#define SHOW_LIB_VERSION(libname, LIBNAME)                              \\\n    do {                                                                \\\n        if (CONFIG_##LIBNAME) {                                         \\\n            unsigned int version = libname##_version();                 \\\n            writer_print_section_header(w, SECTION_ID_LIBRARY_VERSION); \\\n            print_str(\"name\",    \"lib\" #libname);                       \\\n            print_int(\"major\",   LIB##LIBNAME##_VERSION_MAJOR);         \\\n            print_int(\"minor\",   LIB##LIBNAME##_VERSION_MINOR);         \\\n            print_int(\"micro\",   LIB##LIBNAME##_VERSION_MICRO);         \\\n            print_int(\"version\", version);                              \\\n            print_str(\"ident\",   LIB##LIBNAME##_IDENT);                 \\\n            writer_print_section_footer(w);                             \\\n        }                                                               \\\n    } while (0)\n\nstatic void ffprobe_show_library_versions(WriterContext *w)\n{\n    writer_print_section_header(w, SECTION_ID_LIBRARY_VERSIONS);\n    SHOW_LIB_VERSION(avutil,     AVUTIL);\n    SHOW_LIB_VERSION(avcodec,    AVCODEC);\n    SHOW_LIB_VERSION(avformat,   AVFORMAT);\n    SHOW_LIB_VERSION(avdevice,   AVDEVICE);\n    SHOW_LIB_VERSION(avfilter,   AVFILTER);\n    SHOW_LIB_VERSION(swscale,    SWSCALE);\n    SHOW_LIB_VERSION(swresample, SWRESAMPLE);\n    SHOW_LIB_VERSION(postproc,   POSTPROC);\n    writer_print_section_footer(w);\n}\n\n#define PRINT_PIX_FMT_FLAG(flagname, name)                                \\\n    do {                                                                  \\\n        print_int(name, !!(pixdesc->flags & AV_PIX_FMT_FLAG_##flagname)); \\\n    } while (0)\n\nstatic void ffprobe_show_pixel_formats(WriterContext *w)\n{\n    const AVPixFmtDescriptor *pixdesc = NULL;\n    int i, n;\n\n    writer_print_section_header(w, SECTION_ID_PIXEL_FORMATS);\n    while (pixdesc = av_pix_fmt_desc_next(pixdesc)) {\n        writer_print_section_header(w, SECTION_ID_PIXEL_FORMAT);\n        print_str(\"name\", pixdesc->name);\n        print_int(\"nb_components\", pixdesc->nb_components);\n        if ((pixdesc->nb_components >= 3) && !(pixdesc->flags & AV_PIX_FMT_FLAG_RGB)) {\n            print_int    (\"log2_chroma_w\", pixdesc->log2_chroma_w);\n            print_int    (\"log2_chroma_h\", pixdesc->log2_chroma_h);\n        } else {\n            print_str_opt(\"log2_chroma_w\", \"N/A\");\n            print_str_opt(\"log2_chroma_h\", \"N/A\");\n        }\n        n = av_get_bits_per_pixel(pixdesc);\n        if (n) print_int    (\"bits_per_pixel\", n);\n        else   print_str_opt(\"bits_per_pixel\", \"N/A\");\n        if (do_show_pixel_format_flags) {\n            writer_print_section_header(w, SECTION_ID_PIXEL_FORMAT_FLAGS);\n            PRINT_PIX_FMT_FLAG(BE,        \"big_endian\");\n            PRINT_PIX_FMT_FLAG(PAL,       \"palette\");\n            PRINT_PIX_FMT_FLAG(BITSTREAM, \"bitstream\");\n            PRINT_PIX_FMT_FLAG(HWACCEL,   \"hwaccel\");\n            PRINT_PIX_FMT_FLAG(PLANAR,    \"planar\");\n            PRINT_PIX_FMT_FLAG(RGB,       \"rgb\");\n            PRINT_PIX_FMT_FLAG(PSEUDOPAL, \"pseudopal\");\n            PRINT_PIX_FMT_FLAG(ALPHA,     \"alpha\");\n            writer_print_section_footer(w);\n        }\n        if (do_show_pixel_format_components && (pixdesc->nb_components > 0)) {\n            writer_print_section_header(w, SECTION_ID_PIXEL_FORMAT_COMPONENTS);\n            for (i = 0; i < pixdesc->nb_components; i++) {\n                writer_print_section_header(w, SECTION_ID_PIXEL_FORMAT_COMPONENT);\n                print_int(\"index\", i + 1);\n                print_int(\"bit_depth\", pixdesc->comp[i].depth);\n                writer_print_section_footer(w);\n            }\n            writer_print_section_footer(w);\n        }\n        writer_print_section_footer(w);\n    }\n    writer_print_section_footer(w);\n}\n\nstatic int opt_format(void *optctx, const char *opt, const char *arg)\n{\n    iformat = av_find_input_format(arg);\n    if (!iformat) {\n        av_log(NULL, AV_LOG_ERROR, \"Unknown input format: %s\\n\", arg);\n        return AVERROR(EINVAL);\n    }\n    return 0;\n}\n\nstatic inline void mark_section_show_entries(SectionID section_id,\n                                             int show_all_entries, AVDictionary *entries)\n{\n    struct section *section = &sections[section_id];\n\n    section->show_all_entries = show_all_entries;\n    if (show_all_entries) {\n        SectionID *id;\n        for (id = section->children_ids; *id != -1; id++)\n            mark_section_show_entries(*id, show_all_entries, entries);\n    } else {\n        av_dict_copy(&section->entries_to_show, entries, 0);\n    }\n}\n\nstatic int match_section(const char *section_name,\n                         int show_all_entries, AVDictionary *entries)\n{\n    int i, ret = 0;\n\n    for (i = 0; i < FF_ARRAY_ELEMS(sections); i++) {\n        const struct section *section = &sections[i];\n        if (!strcmp(section_name, section->name) ||\n            (section->unique_name && !strcmp(section_name, section->unique_name))) {\n            av_log(NULL, AV_LOG_DEBUG,\n                   \"'%s' matches section with unique name '%s'\\n\", section_name,\n                   (char *)av_x_if_null(section->unique_name, section->name));\n            ret++;\n            mark_section_show_entries(section->id, show_all_entries, entries);\n        }\n    }\n    return ret;\n}\n\nstatic int opt_show_entries(void *optctx, const char *opt, const char *arg)\n{\n    const char *p = arg;\n    int ret = 0;\n\n    while (*p) {\n        AVDictionary *entries = NULL;\n        char *section_name = av_get_token(&p, \"=:\");\n        int show_all_entries = 0;\n\n        if (!section_name) {\n            av_log(NULL, AV_LOG_ERROR,\n                   \"Missing section name for option '%s'\\n\", opt);\n            return AVERROR(EINVAL);\n        }\n\n        if (*p == '=') {\n            p++;\n            while (*p && *p != ':') {\n                char *entry = av_get_token(&p, \",:\");\n                if (!entry)\n                    break;\n                av_log(NULL, AV_LOG_VERBOSE,\n                       \"Adding '%s' to the entries to show in section '%s'\\n\",\n                       entry, section_name);\n                av_dict_set(&entries, entry, \"\", AV_DICT_DONT_STRDUP_KEY);\n                if (*p == ',')\n                    p++;\n            }\n        } else {\n            show_all_entries = 1;\n        }\n\n        ret = match_section(section_name, show_all_entries, entries);\n        if (ret == 0) {\n            av_log(NULL, AV_LOG_ERROR, \"No match for section '%s'\\n\", section_name);\n            ret = AVERROR(EINVAL);\n        }\n        av_dict_free(&entries);\n        av_free(section_name);\n\n        if (ret <= 0)\n            break;\n        if (*p)\n            p++;\n    }\n\n    return ret;\n}\n\nstatic int opt_show_format_entry(void *optctx, const char *opt, const char *arg)\n{\n    char *buf = av_asprintf(\"format=%s\", arg);\n    int ret;\n\n    if (!buf)\n        return AVERROR(ENOMEM);\n\n    av_log(NULL, AV_LOG_WARNING,\n           \"Option '%s' is deprecated, use '-show_entries format=%s' instead\\n\",\n           opt, arg);\n    ret = opt_show_entries(optctx, opt, buf);\n    av_free(buf);\n    return ret;\n}\n\nstatic void opt_input_file(void *optctx, const char *arg)\n{\n    if (input_filename) {\n        av_log(NULL, AV_LOG_ERROR,\n                \"Argument '%s' provided as input filename, but '%s' was already specified.\\n\",\n                arg, input_filename);\n        exit_program(1);\n    }\n    if (!strcmp(arg, \"-\"))\n        arg = \"pipe:\";\n    input_filename = arg;\n}\n\nstatic int opt_input_file_i(void *optctx, const char *opt, const char *arg)\n{\n    opt_input_file(optctx, arg);\n    return 0;\n}\n\nvoid show_help_default(const char *opt, const char *arg)\n{\n    av_log_set_callback(log_callback_help);\n    show_usage();\n    show_help_options(options, \"Main options:\", 0, 0, 0);\n    printf(\"\\n\");\n\n    show_help_children(avformat_get_class(), AV_OPT_FLAG_DECODING_PARAM);\n    show_help_children(avcodec_get_class(), AV_OPT_FLAG_DECODING_PARAM);\n}\n\n/**\n * Parse interval specification, according to the format:\n * INTERVAL ::= [START|+START_OFFSET][%[END|+END_OFFSET]]\n * INTERVALS ::= INTERVAL[,INTERVALS]\n*/\nstatic int parse_read_interval(const char *interval_spec,\n                               ReadInterval *interval)\n{\n    int ret = 0;\n    char *next, *p, *spec = av_strdup(interval_spec);\n    if (!spec)\n        return AVERROR(ENOMEM);\n\n    if (!*spec) {\n        av_log(NULL, AV_LOG_ERROR, \"Invalid empty interval specification\\n\");\n        ret = AVERROR(EINVAL);\n        goto end;\n    }\n\n    p = spec;\n    next = strchr(spec, '%');\n    if (next)\n        *next++ = 0;\n\n    /* parse first part */\n    if (*p) {\n        interval->has_start = 1;\n\n        if (*p == '+') {\n            interval->start_is_offset = 1;\n            p++;\n        } else {\n            interval->start_is_offset = 0;\n        }\n\n        ret = av_parse_time(&interval->start, p, 1);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Invalid interval start specification '%s'\\n\", p);\n            goto end;\n        }\n    } else {\n        interval->has_start = 0;\n    }\n\n    /* parse second part */\n    p = next;\n    if (p && *p) {\n        int64_t us;\n        interval->has_end = 1;\n\n        if (*p == '+') {\n            interval->end_is_offset = 1;\n            p++;\n        } else {\n            interval->end_is_offset = 0;\n        }\n\n        if (interval->end_is_offset && *p == '#') {\n            long long int lli;\n            char *tail;\n            interval->duration_frames = 1;\n            p++;\n            lli = strtoll(p, &tail, 10);\n            if (*tail || lli < 0) {\n                av_log(NULL, AV_LOG_ERROR,\n                       \"Invalid or negative value '%s' for duration number of frames\\n\", p);\n                goto end;\n            }\n            interval->end = lli;\n        } else {\n            interval->duration_frames = 0;\n            ret = av_parse_time(&us, p, 1);\n            if (ret < 0) {\n                av_log(NULL, AV_LOG_ERROR, \"Invalid interval end/duration specification '%s'\\n\", p);\n                goto end;\n            }\n            interval->end = us;\n        }\n    } else {\n        interval->has_end = 0;\n    }\n\nend:\n    av_free(spec);\n    return ret;\n}\n\nstatic int parse_read_intervals(const char *intervals_spec)\n{\n    int ret, n, i;\n    char *p, *spec = av_strdup(intervals_spec);\n    if (!spec)\n        return AVERROR(ENOMEM);\n\n    /* preparse specification, get number of intervals */\n    for (n = 0, p = spec; *p; p++)\n        if (*p == ',')\n            n++;\n    n++;\n\n    read_intervals = av_malloc_array(n, sizeof(*read_intervals));\n    if (!read_intervals) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n    read_intervals_nb = n;\n\n    /* parse intervals */\n    p = spec;\n    for (i = 0; p; i++) {\n        char *next;\n\n        av_assert0(i < read_intervals_nb);\n        next = strchr(p, ',');\n        if (next)\n            *next++ = 0;\n\n        read_intervals[i].id = i;\n        ret = parse_read_interval(p, &read_intervals[i]);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Error parsing read interval #%d '%s'\\n\",\n                   i, p);\n            goto end;\n        }\n        av_log(NULL, AV_LOG_VERBOSE, \"Parsed log interval \");\n        log_read_interval(&read_intervals[i], NULL, AV_LOG_VERBOSE);\n        p = next;\n    }\n    av_assert0(i == read_intervals_nb);\n\nend:\n    av_free(spec);\n    return ret;\n}\n\nstatic int opt_read_intervals(void *optctx, const char *opt, const char *arg)\n{\n    return parse_read_intervals(arg);\n}\n\nstatic int opt_pretty(void *optctx, const char *opt, const char *arg)\n{\n    show_value_unit              = 1;\n    use_value_prefix             = 1;\n    use_byte_value_binary_prefix = 1;\n    use_value_sexagesimal_format = 1;\n    return 0;\n}\n\nstatic void print_section(SectionID id, int level)\n{\n    const SectionID *pid;\n    const struct section *section = &sections[id];\n    printf(\"%c%c%c\",\n           section->flags & SECTION_FLAG_IS_WRAPPER           ? 'W' : '.',\n           section->flags & SECTION_FLAG_IS_ARRAY             ? 'A' : '.',\n           section->flags & SECTION_FLAG_HAS_VARIABLE_FIELDS  ? 'V' : '.');\n    printf(\"%*c  %s\", level * 4, ' ', section->name);\n    if (section->unique_name)\n        printf(\"/%s\", section->unique_name);\n    printf(\"\\n\");\n\n    for (pid = section->children_ids; *pid != -1; pid++)\n        print_section(*pid, level+1);\n}\n\nstatic int opt_sections(void *optctx, const char *opt, const char *arg)\n{\n    printf(\"Sections:\\n\"\n           \"W.. = Section is a wrapper (contains other sections, no local entries)\\n\"\n           \".A. = Section contains an array of elements of the same type\\n\"\n           \"..V = Section may contain a variable number of fields with variable keys\\n\"\n           \"FLAGS NAME/UNIQUE_NAME\\n\"\n           \"---\\n\");\n    print_section(SECTION_ID_ROOT, 0);\n    return 0;\n}\n\nstatic int opt_show_versions(const char *opt, const char *arg)\n{\n    mark_section_show_entries(SECTION_ID_PROGRAM_VERSION, 1, NULL);\n    mark_section_show_entries(SECTION_ID_LIBRARY_VERSION, 1, NULL);\n    return 0;\n}\n\n#define DEFINE_OPT_SHOW_SECTION(section, target_section_id)             \\\n    static int opt_show_##section(const char *opt, const char *arg)     \\\n    {                                                                   \\\n        mark_section_show_entries(SECTION_ID_##target_section_id, 1, NULL); \\\n        return 0;                                                       \\\n    }\n\nDEFINE_OPT_SHOW_SECTION(chapters,         CHAPTERS)\nDEFINE_OPT_SHOW_SECTION(error,            ERROR)\nDEFINE_OPT_SHOW_SECTION(format,           FORMAT)\nDEFINE_OPT_SHOW_SECTION(frames,           FRAMES)\nDEFINE_OPT_SHOW_SECTION(library_versions, LIBRARY_VERSIONS)\nDEFINE_OPT_SHOW_SECTION(packets,          PACKETS)\nDEFINE_OPT_SHOW_SECTION(pixel_formats,    PIXEL_FORMATS)\nDEFINE_OPT_SHOW_SECTION(program_version,  PROGRAM_VERSION)\nDEFINE_OPT_SHOW_SECTION(streams,          STREAMS)\nDEFINE_OPT_SHOW_SECTION(programs,         PROGRAMS)\n\nstatic const OptionDef real_options[] = {\n    CMDUTILS_COMMON_OPTIONS\n    { \"f\", HAS_ARG, {.func_arg = opt_format}, \"force format\", \"format\" },\n    { \"unit\", OPT_BOOL, {&show_value_unit}, \"show unit of the displayed values\" },\n    { \"prefix\", OPT_BOOL, {&use_value_prefix}, \"use SI prefixes for the displayed values\" },\n    { \"byte_binary_prefix\", OPT_BOOL, {&use_byte_value_binary_prefix},\n      \"use binary prefixes for byte units\" },\n    { \"sexagesimal\", OPT_BOOL,  {&use_value_sexagesimal_format},\n      \"use sexagesimal format HOURS:MM:SS.MICROSECONDS for time units\" },\n    { \"pretty\", 0, {.func_arg = opt_pretty},\n      \"prettify the format of displayed values, make it more human readable\" },\n    { \"print_format\", OPT_STRING | HAS_ARG, {(void*)&print_format},\n      \"set the output printing format (available formats are: default, compact, csv, flat, ini, json, xml)\", \"format\" },\n    { \"of\", OPT_STRING | HAS_ARG, {(void*)&print_format}, \"alias for -print_format\", \"format\" },\n    { \"select_streams\", OPT_STRING | HAS_ARG, {(void*)&stream_specifier}, \"select the specified streams\", \"stream_specifier\" },\n    { \"sections\", OPT_EXIT, {.func_arg = opt_sections}, \"print sections structure and section information, and exit\" },\n    { \"show_data\",    OPT_BOOL, {(void*)&do_show_data}, \"show packets data\" },\n    { \"show_data_hash\", OPT_STRING | HAS_ARG, {(void*)&show_data_hash}, \"show packets data hash\" },\n    { \"show_error\",   0, {(void*)&opt_show_error},  \"show probing error\" },\n    { \"show_format\",  0, {(void*)&opt_show_format}, \"show format/container info\" },\n    { \"show_frames\",  0, {(void*)&opt_show_frames}, \"show frames info\" },\n    { \"show_format_entry\", HAS_ARG, {.func_arg = opt_show_format_entry},\n      \"show a particular entry from the format/container info\", \"entry\" },\n    { \"show_entries\", HAS_ARG, {.func_arg = opt_show_entries},\n      \"show a set of specified entries\", \"entry_list\" },\n#if HAVE_THREADS\n    { \"show_log\", OPT_INT|HAS_ARG, {(void*)&do_show_log}, \"show log\" },\n#endif\n    { \"show_packets\", 0, {(void*)&opt_show_packets}, \"show packets info\" },\n    { \"show_programs\", 0, {(void*)&opt_show_programs}, \"show programs info\" },\n    { \"show_streams\", 0, {(void*)&opt_show_streams}, \"show streams info\" },\n    { \"show_chapters\", 0, {(void*)&opt_show_chapters}, \"show chapters info\" },\n    { \"count_frames\", OPT_BOOL, {(void*)&do_count_frames}, \"count the number of frames per stream\" },\n    { \"count_packets\", OPT_BOOL, {(void*)&do_count_packets}, \"count the number of packets per stream\" },\n    { \"show_program_version\",  0, {(void*)&opt_show_program_version},  \"show ffprobe version\" },\n    { \"show_library_versions\", 0, {(void*)&opt_show_library_versions}, \"show library versions\" },\n    { \"show_versions\",         0, {(void*)&opt_show_versions}, \"show program and library versions\" },\n    { \"show_pixel_formats\", 0, {(void*)&opt_show_pixel_formats}, \"show pixel format descriptions\" },\n    { \"show_private_data\", OPT_BOOL, {(void*)&show_private_data}, \"show private data\" },\n    { \"private\",           OPT_BOOL, {(void*)&show_private_data}, \"same as show_private_data\" },\n    { \"bitexact\", OPT_BOOL, {&do_bitexact}, \"force bitexact output\" },\n    { \"read_intervals\", HAS_ARG, {.func_arg = opt_read_intervals}, \"set read intervals\", \"read_intervals\" },\n    { \"default\", HAS_ARG | OPT_AUDIO | OPT_VIDEO | OPT_EXPERT, {.func_arg = opt_default}, \"generic catch all option\", \"\" },\n    { \"i\", HAS_ARG, {.func_arg = opt_input_file_i}, \"read specified file\", \"input_file\"},\n    { \"find_stream_info\", OPT_BOOL | OPT_INPUT | OPT_EXPERT, { &find_stream_info },\n        \"read and decode the streams to fill missing information with heuristics\" },\n    { NULL, },\n};\n\nstatic inline int check_section_show_entries(int section_id)\n{\n    int *id;\n    struct section *section = &sections[section_id];\n    if (sections[section_id].show_all_entries || sections[section_id].entries_to_show)\n        return 1;\n    for (id = section->children_ids; *id != -1; id++)\n        if (check_section_show_entries(*id))\n            return 1;\n    return 0;\n}\n\n#define SET_DO_SHOW(id, varname) do {                                   \\\n        if (check_section_show_entries(SECTION_ID_##id))                \\\n            do_show_##varname = 1;                                      \\\n    } while (0)\n\nint main(int argc, char **argv)\n{\n    const Writer *w;\n    WriterContext *wctx;\n    char *buf;\n    char *w_name = NULL, *w_args = NULL;\n    int ret, i;\n\n    init_dynload();\n\n#if HAVE_THREADS\n    ret = pthread_mutex_init(&log_mutex, NULL);\n    if (ret != 0) {\n        goto end;\n    }\n#endif\n    av_log_set_flags(AV_LOG_SKIP_REPEATED);\n    register_exit(ffprobe_cleanup);\n\n    options = real_options;\n    parse_loglevel(argc, argv, options);\n    av_register_all();\n    avformat_network_init();\n    init_opts();\n#if CONFIG_AVDEVICE\n    avdevice_register_all();\n#endif\n\n    show_banner(argc, argv, options);\n    parse_options(NULL, argc, argv, options, opt_input_file);\n\n    if (do_show_log)\n        av_log_set_callback(log_callback);\n\n    /* mark things to show, based on -show_entries */\n    SET_DO_SHOW(CHAPTERS, chapters);\n    SET_DO_SHOW(ERROR, error);\n    SET_DO_SHOW(FORMAT, format);\n    SET_DO_SHOW(FRAMES, frames);\n    SET_DO_SHOW(LIBRARY_VERSIONS, library_versions);\n    SET_DO_SHOW(PACKETS, packets);\n    SET_DO_SHOW(PIXEL_FORMATS, pixel_formats);\n    SET_DO_SHOW(PIXEL_FORMAT_FLAGS, pixel_format_flags);\n    SET_DO_SHOW(PIXEL_FORMAT_COMPONENTS, pixel_format_components);\n    SET_DO_SHOW(PROGRAM_VERSION, program_version);\n    SET_DO_SHOW(PROGRAMS, programs);\n    SET_DO_SHOW(STREAMS, streams);\n    SET_DO_SHOW(STREAM_DISPOSITION, stream_disposition);\n    SET_DO_SHOW(PROGRAM_STREAM_DISPOSITION, stream_disposition);\n\n    SET_DO_SHOW(CHAPTER_TAGS, chapter_tags);\n    SET_DO_SHOW(FORMAT_TAGS, format_tags);\n    SET_DO_SHOW(FRAME_TAGS, frame_tags);\n    SET_DO_SHOW(PROGRAM_TAGS, program_tags);\n    SET_DO_SHOW(STREAM_TAGS, stream_tags);\n    SET_DO_SHOW(PROGRAM_STREAM_TAGS, stream_tags);\n    SET_DO_SHOW(PACKET_TAGS, packet_tags);\n\n    if (do_bitexact && (do_show_program_version || do_show_library_versions)) {\n        av_log(NULL, AV_LOG_ERROR,\n               \"-bitexact and -show_program_version or -show_library_versions \"\n               \"options are incompatible\\n\");\n        ret = AVERROR(EINVAL);\n        goto end;\n    }\n\n    writer_register_all();\n\n    if (!print_format)\n        print_format = av_strdup(\"default\");\n    if (!print_format) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n    w_name = av_strtok(print_format, \"=\", &buf);\n    if (!w_name) {\n        av_log(NULL, AV_LOG_ERROR,\n               \"No name specified for the output format\\n\");\n        ret = AVERROR(EINVAL);\n        goto end;\n    }\n    w_args = buf;\n\n    if (show_data_hash) {\n        if ((ret = av_hash_alloc(&hash, show_data_hash)) < 0) {\n            if (ret == AVERROR(EINVAL)) {\n                const char *n;\n                av_log(NULL, AV_LOG_ERROR,\n                       \"Unknown hash algorithm '%s'\\nKnown algorithms:\",\n                       show_data_hash);\n                for (i = 0; (n = av_hash_names(i)); i++)\n                    av_log(NULL, AV_LOG_ERROR, \" %s\", n);\n                av_log(NULL, AV_LOG_ERROR, \"\\n\");\n            }\n            goto end;\n        }\n    }\n\n    w = writer_get_by_name(w_name);\n    if (!w) {\n        av_log(NULL, AV_LOG_ERROR, \"Unknown output format with name '%s'\\n\", w_name);\n        ret = AVERROR(EINVAL);\n        goto end;\n    }\n\n    if ((ret = writer_open(&wctx, w, w_args,\n                           sections, FF_ARRAY_ELEMS(sections))) >= 0) {\n        if (w == &xml_writer)\n            wctx->string_validation_utf8_flags |= AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES;\n\n        writer_print_section_header(wctx, SECTION_ID_ROOT);\n\n        if (do_show_program_version)\n            ffprobe_show_program_version(wctx);\n        if (do_show_library_versions)\n            ffprobe_show_library_versions(wctx);\n        if (do_show_pixel_formats)\n            ffprobe_show_pixel_formats(wctx);\n\n        if (!input_filename &&\n            ((do_show_format || do_show_programs || do_show_streams || do_show_chapters || do_show_packets || do_show_error) ||\n             (!do_show_program_version && !do_show_library_versions && !do_show_pixel_formats))) {\n            show_usage();\n            av_log(NULL, AV_LOG_ERROR, \"You have to specify one input file.\\n\");\n            av_log(NULL, AV_LOG_ERROR, \"Use -h to get full help or, even better, run 'man %s'.\\n\", program_name);\n            ret = AVERROR(EINVAL);\n        } else if (input_filename) {\n            ret = probe_file(wctx, input_filename);\n            if (ret < 0 && do_show_error)\n                show_error(wctx, ret);\n        }\n\n        writer_print_section_footer(wctx);\n        writer_close(&wctx);\n    }\n\nend:\n    av_freep(&print_format);\n    av_freep(&read_intervals);\n    av_hash_freep(&hash);\n\n    uninit_opts();\n    for (i = 0; i < FF_ARRAY_ELEMS(sections); i++)\n        av_dict_free(&(sections[i].entries_to_show));\n\n    avformat_network_deinit();\n\n    return ret < 0;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2007-2010 Stefano Sabatini\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * simple media prober based on the FFmpeg libraries\n */\n\n#include \"config.h\"\n#include \"libavutil/ffversion.h\"\n\n#include <string.h>\n\n#include \"libavformat/avformat.h\"\n#include \"libavcodec/avcodec.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/bprint.h\"\n#include \"libavutil/display.h\"\n#include \"libavutil/hash.h\"\n#include \"libavutil/mastering_display_metadata.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"libavutil/spherical.h\"\n#include \"libavutil/stereo3d.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/libm.h\"\n#include \"libavutil/parseutils.h\"\n#include \"libavutil/timecode.h\"\n#include \"libavutil/timestamp.h\"\n#include \"libavdevice/avdevice.h\"\n#include \"libswscale/swscale.h\"\n#include \"libswresample/swresample.h\"\n#include \"libpostproc/postprocess.h\"\n#include \"cmdutils.h\"\n\n#include \"libavutil/thread.h\"\n\n#if !HAVE_THREADS\n#  ifdef pthread_mutex_lock\n#    undef pthread_mutex_lock\n#  endif\n#  define pthread_mutex_lock(a) do{}while(0)\n#  ifdef pthread_mutex_unlock\n#    undef pthread_mutex_unlock\n#  endif\n#  define pthread_mutex_unlock(a) do{}while(0)\n#endif\n\ntypedef struct InputStream {\n    AVStream *st;\n\n    AVCodecContext *dec_ctx;\n} InputStream;\n\ntypedef struct InputFile {\n    AVFormatContext *fmt_ctx;\n\n    InputStream *streams;\n    int       nb_streams;\n} InputFile;\n\nconst char program_name[] = \"ffprobe\";\nconst int program_birth_year = 2007;\n\nstatic int do_bitexact = 0;\nstatic int do_count_frames = 0;\nstatic int do_count_packets = 0;\nstatic int do_read_frames  = 0;\nstatic int do_read_packets = 0;\nstatic int do_show_chapters = 0;\nstatic int do_show_error   = 0;\nstatic int do_show_format  = 0;\nstatic int do_show_frames  = 0;\nstatic int do_show_packets = 0;\nstatic int do_show_programs = 0;\nstatic int do_show_streams = 0;\nstatic int do_show_stream_disposition = 0;\nstatic int do_show_data    = 0;\nstatic int do_show_program_version  = 0;\nstatic int do_show_library_versions = 0;\nstatic int do_show_pixel_formats = 0;\nstatic int do_show_pixel_format_flags = 0;\nstatic int do_show_pixel_format_components = 0;\nstatic int do_show_log = 0;\n\nstatic int do_show_chapter_tags = 0;\nstatic int do_show_format_tags = 0;\nstatic int do_show_frame_tags = 0;\nstatic int do_show_program_tags = 0;\nstatic int do_show_stream_tags = 0;\nstatic int do_show_packet_tags = 0;\n\nstatic int show_value_unit              = 0;\nstatic int use_value_prefix             = 0;\nstatic int use_byte_value_binary_prefix = 0;\nstatic int use_value_sexagesimal_format = 0;\nstatic int show_private_data            = 1;\n\nstatic char *print_format;\nstatic char *stream_specifier;\nstatic char *show_data_hash;\n\ntypedef struct ReadInterval {\n    int id;             ///< identifier\n    int64_t start, end; ///< start, end in second/AV_TIME_BASE units\n    int has_start, has_end;\n    int start_is_offset, end_is_offset;\n    int duration_frames;\n} ReadInterval;\n\nstatic ReadInterval *read_intervals;\nstatic int read_intervals_nb = 0;\n\nstatic int find_stream_info  = 1;\n\n/* section structure definition */\n\n#define SECTION_MAX_NB_CHILDREN 10\n\nstruct section {\n    int id;             ///< unique id identifying a section\n    const char *name;\n\n#define SECTION_FLAG_IS_WRAPPER      1 ///< the section only contains other sections, but has no data at its own level\n#define SECTION_FLAG_IS_ARRAY        2 ///< the section contains an array of elements of the same type\n#define SECTION_FLAG_HAS_VARIABLE_FIELDS 4 ///< the section may contain a variable number of fields with variable keys.\n                                           ///  For these sections the element_name field is mandatory.\n    int flags;\n    int children_ids[SECTION_MAX_NB_CHILDREN+1]; ///< list of children section IDS, terminated by -1\n    const char *element_name; ///< name of the contained element, if provided\n    const char *unique_name;  ///< unique section name, in case the name is ambiguous\n    AVDictionary *entries_to_show;\n    int show_all_entries;\n};\n\ntypedef enum {\n    SECTION_ID_NONE = -1,\n    SECTION_ID_CHAPTER,\n    SECTION_ID_CHAPTER_TAGS,\n    SECTION_ID_CHAPTERS,\n    SECTION_ID_ERROR,\n    SECTION_ID_FORMAT,\n    SECTION_ID_FORMAT_TAGS,\n    SECTION_ID_FRAME,\n    SECTION_ID_FRAMES,\n    SECTION_ID_FRAME_TAGS,\n    SECTION_ID_FRAME_SIDE_DATA_LIST,\n    SECTION_ID_FRAME_SIDE_DATA,\n    SECTION_ID_FRAME_LOG,\n    SECTION_ID_FRAME_LOGS,\n    SECTION_ID_LIBRARY_VERSION,\n    SECTION_ID_LIBRARY_VERSIONS,\n    SECTION_ID_PACKET,\n    SECTION_ID_PACKET_TAGS,\n    SECTION_ID_PACKETS,\n    SECTION_ID_PACKETS_AND_FRAMES,\n    SECTION_ID_PACKET_SIDE_DATA_LIST,\n    SECTION_ID_PACKET_SIDE_DATA,\n    SECTION_ID_PIXEL_FORMAT,\n    SECTION_ID_PIXEL_FORMAT_FLAGS,\n    SECTION_ID_PIXEL_FORMAT_COMPONENT,\n    SECTION_ID_PIXEL_FORMAT_COMPONENTS,\n    SECTION_ID_PIXEL_FORMATS,\n    SECTION_ID_PROGRAM_STREAM_DISPOSITION,\n    SECTION_ID_PROGRAM_STREAM_TAGS,\n    SECTION_ID_PROGRAM,\n    SECTION_ID_PROGRAM_STREAMS,\n    SECTION_ID_PROGRAM_STREAM,\n    SECTION_ID_PROGRAM_TAGS,\n    SECTION_ID_PROGRAM_VERSION,\n    SECTION_ID_PROGRAMS,\n    SECTION_ID_ROOT,\n    SECTION_ID_STREAM,\n    SECTION_ID_STREAM_DISPOSITION,\n    SECTION_ID_STREAMS,\n    SECTION_ID_STREAM_TAGS,\n    SECTION_ID_STREAM_SIDE_DATA_LIST,\n    SECTION_ID_STREAM_SIDE_DATA,\n    SECTION_ID_SUBTITLE,\n} SectionID;\n\nstatic struct section sections[] = {\n    [SECTION_ID_CHAPTERS] =           { SECTION_ID_CHAPTERS, \"chapters\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_CHAPTER, -1 } },\n    [SECTION_ID_CHAPTER] =            { SECTION_ID_CHAPTER, \"chapter\", 0, { SECTION_ID_CHAPTER_TAGS, -1 } },\n    [SECTION_ID_CHAPTER_TAGS] =       { SECTION_ID_CHAPTER_TAGS, \"tags\", SECTION_FLAG_HAS_VARIABLE_FIELDS, { -1 }, .element_name = \"tag\", .unique_name = \"chapter_tags\" },\n    [SECTION_ID_ERROR] =              { SECTION_ID_ERROR, \"error\", 0, { -1 } },\n    [SECTION_ID_FORMAT] =             { SECTION_ID_FORMAT, \"format\", 0, { SECTION_ID_FORMAT_TAGS, -1 } },\n    [SECTION_ID_FORMAT_TAGS] =        { SECTION_ID_FORMAT_TAGS, \"tags\", SECTION_FLAG_HAS_VARIABLE_FIELDS, { -1 }, .element_name = \"tag\", .unique_name = \"format_tags\" },\n    [SECTION_ID_FRAMES] =             { SECTION_ID_FRAMES, \"frames\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_FRAME, SECTION_ID_SUBTITLE, -1 } },\n    [SECTION_ID_FRAME] =              { SECTION_ID_FRAME, \"frame\", 0, { SECTION_ID_FRAME_TAGS, SECTION_ID_FRAME_SIDE_DATA_LIST, SECTION_ID_FRAME_LOGS, -1 } },\n    [SECTION_ID_FRAME_TAGS] =         { SECTION_ID_FRAME_TAGS, \"tags\", SECTION_FLAG_HAS_VARIABLE_FIELDS, { -1 }, .element_name = \"tag\", .unique_name = \"frame_tags\" },\n    [SECTION_ID_FRAME_SIDE_DATA_LIST] ={ SECTION_ID_FRAME_SIDE_DATA_LIST, \"side_data_list\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_FRAME_SIDE_DATA, -1 }, .element_name = \"side_data\", .unique_name = \"frame_side_data_list\" },\n    [SECTION_ID_FRAME_SIDE_DATA] =     { SECTION_ID_FRAME_SIDE_DATA, \"side_data\", 0, { -1 } },\n    [SECTION_ID_FRAME_LOGS] =         { SECTION_ID_FRAME_LOGS, \"logs\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_FRAME_LOG, -1 } },\n    [SECTION_ID_FRAME_LOG] =          { SECTION_ID_FRAME_LOG, \"log\", 0, { -1 },  },\n    [SECTION_ID_LIBRARY_VERSIONS] =   { SECTION_ID_LIBRARY_VERSIONS, \"library_versions\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_LIBRARY_VERSION, -1 } },\n    [SECTION_ID_LIBRARY_VERSION] =    { SECTION_ID_LIBRARY_VERSION, \"library_version\", 0, { -1 } },\n    [SECTION_ID_PACKETS] =            { SECTION_ID_PACKETS, \"packets\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_PACKET, -1} },\n    [SECTION_ID_PACKETS_AND_FRAMES] = { SECTION_ID_PACKETS_AND_FRAMES, \"packets_and_frames\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_PACKET, -1} },\n    [SECTION_ID_PACKET] =             { SECTION_ID_PACKET, \"packet\", 0, { SECTION_ID_PACKET_TAGS, SECTION_ID_PACKET_SIDE_DATA_LIST, -1 } },\n    [SECTION_ID_PACKET_TAGS] =        { SECTION_ID_PACKET_TAGS, \"tags\", SECTION_FLAG_HAS_VARIABLE_FIELDS, { -1 }, .element_name = \"tag\", .unique_name = \"packet_tags\" },\n    [SECTION_ID_PACKET_SIDE_DATA_LIST] ={ SECTION_ID_PACKET_SIDE_DATA_LIST, \"side_data_list\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_PACKET_SIDE_DATA, -1 }, .element_name = \"side_data\", .unique_name = \"packet_side_data_list\" },\n    [SECTION_ID_PACKET_SIDE_DATA] =     { SECTION_ID_PACKET_SIDE_DATA, \"side_data\", 0, { -1 } },\n    [SECTION_ID_PIXEL_FORMATS] =      { SECTION_ID_PIXEL_FORMATS, \"pixel_formats\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_PIXEL_FORMAT, -1 } },\n    [SECTION_ID_PIXEL_FORMAT] =       { SECTION_ID_PIXEL_FORMAT, \"pixel_format\", 0, { SECTION_ID_PIXEL_FORMAT_FLAGS, SECTION_ID_PIXEL_FORMAT_COMPONENTS, -1 } },\n    [SECTION_ID_PIXEL_FORMAT_FLAGS] = { SECTION_ID_PIXEL_FORMAT_FLAGS, \"flags\", 0, { -1 }, .unique_name = \"pixel_format_flags\" },\n    [SECTION_ID_PIXEL_FORMAT_COMPONENTS] = { SECTION_ID_PIXEL_FORMAT_COMPONENTS, \"components\", SECTION_FLAG_IS_ARRAY, {SECTION_ID_PIXEL_FORMAT_COMPONENT, -1 }, .unique_name = \"pixel_format_components\" },\n    [SECTION_ID_PIXEL_FORMAT_COMPONENT]  = { SECTION_ID_PIXEL_FORMAT_COMPONENT, \"component\", 0, { -1 } },\n    [SECTION_ID_PROGRAM_STREAM_DISPOSITION] = { SECTION_ID_PROGRAM_STREAM_DISPOSITION, \"disposition\", 0, { -1 }, .unique_name = \"program_stream_disposition\" },\n    [SECTION_ID_PROGRAM_STREAM_TAGS] =        { SECTION_ID_PROGRAM_STREAM_TAGS, \"tags\", SECTION_FLAG_HAS_VARIABLE_FIELDS, { -1 }, .element_name = \"tag\", .unique_name = \"program_stream_tags\" },\n    [SECTION_ID_PROGRAM] =                    { SECTION_ID_PROGRAM, \"program\", 0, { SECTION_ID_PROGRAM_TAGS, SECTION_ID_PROGRAM_STREAMS, -1 } },\n    [SECTION_ID_PROGRAM_STREAMS] =            { SECTION_ID_PROGRAM_STREAMS, \"streams\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_PROGRAM_STREAM, -1 }, .unique_name = \"program_streams\" },\n    [SECTION_ID_PROGRAM_STREAM] =             { SECTION_ID_PROGRAM_STREAM, \"stream\", 0, { SECTION_ID_PROGRAM_STREAM_DISPOSITION, SECTION_ID_PROGRAM_STREAM_TAGS, -1 }, .unique_name = \"program_stream\" },\n    [SECTION_ID_PROGRAM_TAGS] =               { SECTION_ID_PROGRAM_TAGS, \"tags\", SECTION_FLAG_HAS_VARIABLE_FIELDS, { -1 }, .element_name = \"tag\", .unique_name = \"program_tags\" },\n    [SECTION_ID_PROGRAM_VERSION] =    { SECTION_ID_PROGRAM_VERSION, \"program_version\", 0, { -1 } },\n    [SECTION_ID_PROGRAMS] =                   { SECTION_ID_PROGRAMS, \"programs\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_PROGRAM, -1 } },\n    [SECTION_ID_ROOT] =               { SECTION_ID_ROOT, \"root\", SECTION_FLAG_IS_WRAPPER,\n                                        { SECTION_ID_CHAPTERS, SECTION_ID_FORMAT, SECTION_ID_FRAMES, SECTION_ID_PROGRAMS, SECTION_ID_STREAMS,\n                                          SECTION_ID_PACKETS, SECTION_ID_ERROR, SECTION_ID_PROGRAM_VERSION, SECTION_ID_LIBRARY_VERSIONS,\n                                          SECTION_ID_PIXEL_FORMATS, -1} },\n    [SECTION_ID_STREAMS] =            { SECTION_ID_STREAMS, \"streams\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_STREAM, -1 } },\n    [SECTION_ID_STREAM] =             { SECTION_ID_STREAM, \"stream\", 0, { SECTION_ID_STREAM_DISPOSITION, SECTION_ID_STREAM_TAGS, SECTION_ID_STREAM_SIDE_DATA_LIST, -1 } },\n    [SECTION_ID_STREAM_DISPOSITION] = { SECTION_ID_STREAM_DISPOSITION, \"disposition\", 0, { -1 }, .unique_name = \"stream_disposition\" },\n    [SECTION_ID_STREAM_TAGS] =        { SECTION_ID_STREAM_TAGS, \"tags\", SECTION_FLAG_HAS_VARIABLE_FIELDS, { -1 }, .element_name = \"tag\", .unique_name = \"stream_tags\" },\n    [SECTION_ID_STREAM_SIDE_DATA_LIST] ={ SECTION_ID_STREAM_SIDE_DATA_LIST, \"side_data_list\", SECTION_FLAG_IS_ARRAY, { SECTION_ID_STREAM_SIDE_DATA, -1 }, .element_name = \"side_data\", .unique_name = \"stream_side_data_list\" },\n    [SECTION_ID_STREAM_SIDE_DATA] =     { SECTION_ID_STREAM_SIDE_DATA, \"side_data\", 0, { -1 } },\n    [SECTION_ID_SUBTITLE] =           { SECTION_ID_SUBTITLE, \"subtitle\", 0, { -1 } },\n};\n\nstatic const OptionDef *options;\n\n/* FFprobe context */\nstatic const char *input_filename;\nstatic AVInputFormat *iformat = NULL;\n\nstatic struct AVHashContext *hash;\n\nstatic const struct {\n    double bin_val;\n    double dec_val;\n    const char *bin_str;\n    const char *dec_str;\n} si_prefixes[] = {\n    { 1.0, 1.0, \"\", \"\" },\n    { 1.024e3, 1e3, \"Ki\", \"K\" },\n    { 1.048576e6, 1e6, \"Mi\", \"M\" },\n    { 1.073741824e9, 1e9, \"Gi\", \"G\" },\n    { 1.099511627776e12, 1e12, \"Ti\", \"T\" },\n    { 1.125899906842624e15, 1e15, \"Pi\", \"P\" },\n};\n\nstatic const char unit_second_str[]         = \"s\"    ;\nstatic const char unit_hertz_str[]          = \"Hz\"   ;\nstatic const char unit_byte_str[]           = \"byte\" ;\nstatic const char unit_bit_per_second_str[] = \"bit/s\";\n\nstatic int nb_streams;\nstatic uint64_t *nb_streams_packets;\nstatic uint64_t *nb_streams_frames;\nstatic int *selected_streams;\n\n#if HAVE_THREADS\npthread_mutex_t log_mutex;\n#endif\ntypedef struct LogBuffer {\n    char *context_name;\n    int log_level;\n    char *log_message;\n    AVClassCategory category;\n    char *parent_name;\n    AVClassCategory parent_category;\n}LogBuffer;\n\nstatic LogBuffer *log_buffer;\nstatic int log_buffer_size;\n\nstatic void log_callback(void *ptr, int level, const char *fmt, va_list vl)\n{\n    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;\n    va_list vl2;\n    char line[1024];\n    static int print_prefix = 1;\n    void *new_log_buffer;\n\n    va_copy(vl2, vl);\n    av_log_default_callback(ptr, level, fmt, vl);\n    av_log_format_line(ptr, level, fmt, vl2, line, sizeof(line), &print_prefix);\n    va_end(vl2);\n\n#if HAVE_THREADS\n    pthread_mutex_lock(&log_mutex);\n\n    new_log_buffer = av_realloc_array(log_buffer, log_buffer_size + 1, sizeof(*log_buffer));\n    if (new_log_buffer) {\n        char *msg;\n        int i;\n\n        log_buffer = new_log_buffer;\n        memset(&log_buffer[log_buffer_size], 0, sizeof(log_buffer[log_buffer_size]));\n        log_buffer[log_buffer_size].context_name= avc ? av_strdup(avc->item_name(ptr)) : NULL;\n        if (avc) {\n            if (avc->get_category) log_buffer[log_buffer_size].category = avc->get_category(ptr);\n            else                   log_buffer[log_buffer_size].category = avc->category;\n        }\n        log_buffer[log_buffer_size].log_level   = level;\n        msg = log_buffer[log_buffer_size].log_message = av_strdup(line);\n        for (i=strlen(msg) - 1; i>=0 && msg[i] == '\\n'; i--) {\n            msg[i] = 0;\n        }\n        if (avc && avc->parent_log_context_offset) {\n            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +\n                                   avc->parent_log_context_offset);\n            if (parent && *parent) {\n                log_buffer[log_buffer_size].parent_name = av_strdup((*parent)->item_name(parent));\n                log_buffer[log_buffer_size].parent_category =\n                    (*parent)->get_category ? (*parent)->get_category(parent) :(*parent)->category;\n            }\n        }\n        log_buffer_size ++;\n    }\n\n    pthread_mutex_unlock(&log_mutex);\n#endif\n}\n\nstatic void ffprobe_cleanup(int ret)\n{\n    int i;\n    for (i = 0; i < FF_ARRAY_ELEMS(sections); i++)\n        av_dict_free(&(sections[i].entries_to_show));\n\n#if HAVE_THREADS\n    pthread_mutex_destroy(&log_mutex);\n#endif\n}\n\nstruct unit_value {\n    union { double d; long long int i; } val;\n    const char *unit;\n};\n\nstatic char *value_string(char *buf, int buf_size, struct unit_value uv)\n{\n    double vald;\n    long long int vali;\n    int show_float = 0;\n\n    if (uv.unit == unit_second_str) {\n        vald = uv.val.d;\n        show_float = 1;\n    } else {\n        vald = vali = uv.val.i;\n    }\n\n    if (uv.unit == unit_second_str && use_value_sexagesimal_format) {\n        double secs;\n        int hours, mins;\n        secs  = vald;\n        mins  = (int)secs / 60;\n        secs  = secs - mins * 60;\n        hours = mins / 60;\n        mins %= 60;\n        snprintf(buf, buf_size, \"%d:%02d:%09.6f\", hours, mins, secs);\n    } else {\n        const char *prefix_string = \"\";\n\n        if (use_value_prefix && vald > 1) {\n            long long int index;\n\n            if (uv.unit == unit_byte_str && use_byte_value_binary_prefix) {\n                index = (long long int) (log2(vald)) / 10;\n                index = av_clip(index, 0, FF_ARRAY_ELEMS(si_prefixes) - 1);\n                vald /= si_prefixes[index].bin_val;\n                prefix_string = si_prefixes[index].bin_str;\n            } else {\n                index = (long long int) (log10(vald)) / 3;\n                index = av_clip(index, 0, FF_ARRAY_ELEMS(si_prefixes) - 1);\n                vald /= si_prefixes[index].dec_val;\n                prefix_string = si_prefixes[index].dec_str;\n            }\n            vali = vald;\n        }\n\n        if (show_float || (use_value_prefix && vald != (long long int)vald))\n            snprintf(buf, buf_size, \"%f\", vald);\n        else\n            snprintf(buf, buf_size, \"%lld\", vali);\n        av_strlcatf(buf, buf_size, \"%s%s%s\", *prefix_string || show_value_unit ? \" \" : \"\",\n                 prefix_string, show_value_unit ? uv.unit : \"\");\n    }\n\n    return buf;\n}\n\n/* WRITERS API */\n\ntypedef struct WriterContext WriterContext;\n\n#define WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS 1\n#define WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER 2\n\ntypedef enum {\n    WRITER_STRING_VALIDATION_FAIL,\n    WRITER_STRING_VALIDATION_REPLACE,\n    WRITER_STRING_VALIDATION_IGNORE,\n    WRITER_STRING_VALIDATION_NB\n} StringValidation;\n\ntypedef struct Writer {\n    const AVClass *priv_class;      ///< private class of the writer, if any\n    int priv_size;                  ///< private size for the writer context\n    const char *name;\n\n    int  (*init)  (WriterContext *wctx);\n    void (*uninit)(WriterContext *wctx);\n\n    void (*print_section_header)(WriterContext *wctx);\n    void (*print_section_footer)(WriterContext *wctx);\n    void (*print_integer)       (WriterContext *wctx, const char *, long long int);\n    void (*print_rational)      (WriterContext *wctx, AVRational *q, char *sep);\n    void (*print_string)        (WriterContext *wctx, const char *, const char *);\n    int flags;                  ///< a combination or WRITER_FLAG_*\n} Writer;\n\n#define SECTION_MAX_NB_LEVELS 10\n\nstruct WriterContext {\n    const AVClass *class;           ///< class of the writer\n    const Writer *writer;           ///< the Writer of which this is an instance\n    char *name;                     ///< name of this writer instance\n    void *priv;                     ///< private data for use by the filter\n\n    const struct section *sections; ///< array containing all sections\n    int nb_sections;                ///< number of sections\n\n    int level;                      ///< current level, starting from 0\n\n    /** number of the item printed in the given section, starting from 0 */\n    unsigned int nb_item[SECTION_MAX_NB_LEVELS];\n\n    /** section per each level */\n    const struct section *section[SECTION_MAX_NB_LEVELS];\n    AVBPrint section_pbuf[SECTION_MAX_NB_LEVELS]; ///< generic print buffer dedicated to each section,\n                                                  ///  used by various writers\n\n    unsigned int nb_section_packet; ///< number of the packet section in case we are in \"packets_and_frames\" section\n    unsigned int nb_section_frame;  ///< number of the frame  section in case we are in \"packets_and_frames\" section\n    unsigned int nb_section_packet_frame; ///< nb_section_packet or nb_section_frame according if is_packets_and_frames\n\n    int string_validation;\n    char *string_validation_replacement;\n    unsigned int string_validation_utf8_flags;\n};\n\nstatic const char *writer_get_name(void *p)\n{\n    WriterContext *wctx = p;\n    return wctx->writer->name;\n}\n\n#define OFFSET(x) offsetof(WriterContext, x)\n\nstatic const AVOption writer_options[] = {\n    { \"string_validation\", \"set string validation mode\",\n      OFFSET(string_validation), AV_OPT_TYPE_INT, {.i64=WRITER_STRING_VALIDATION_REPLACE}, 0, WRITER_STRING_VALIDATION_NB-1, .unit = \"sv\" },\n    { \"sv\", \"set string validation mode\",\n      OFFSET(string_validation), AV_OPT_TYPE_INT, {.i64=WRITER_STRING_VALIDATION_REPLACE}, 0, WRITER_STRING_VALIDATION_NB-1, .unit = \"sv\" },\n    { \"ignore\",  NULL, 0, AV_OPT_TYPE_CONST, {.i64 = WRITER_STRING_VALIDATION_IGNORE},  .unit = \"sv\" },\n    { \"replace\", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = WRITER_STRING_VALIDATION_REPLACE}, .unit = \"sv\" },\n    { \"fail\",    NULL, 0, AV_OPT_TYPE_CONST, {.i64 = WRITER_STRING_VALIDATION_FAIL},    .unit = \"sv\" },\n    { \"string_validation_replacement\", \"set string validation replacement string\", OFFSET(string_validation_replacement), AV_OPT_TYPE_STRING, {.str=\"\"}},\n    { \"svr\", \"set string validation replacement string\", OFFSET(string_validation_replacement), AV_OPT_TYPE_STRING, {.str=\"\\xEF\\xBF\\xBD\"}},\n    { NULL }\n};\n\nstatic void *writer_child_next(void *obj, void *prev)\n{\n    WriterContext *ctx = obj;\n    if (!prev && ctx->writer && ctx->writer->priv_class && ctx->priv)\n        return ctx->priv;\n    return NULL;\n}\n\nstatic const AVClass writer_class = {\n    .class_name = \"Writer\",\n    .item_name  = writer_get_name,\n    .option     = writer_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n    .child_next = writer_child_next,\n};\n\nstatic void writer_close(WriterContext **wctx)\n{\n    int i;\n\n    if (!*wctx)\n        return;\n\n    if ((*wctx)->writer->uninit)\n        (*wctx)->writer->uninit(*wctx);\n    for (i = 0; i < SECTION_MAX_NB_LEVELS; i++)\n        av_bprint_finalize(&(*wctx)->section_pbuf[i], NULL);\n    if ((*wctx)->writer->priv_class)\n        av_opt_free((*wctx)->priv);\n    av_freep(&((*wctx)->priv));\n    av_opt_free(*wctx);\n    av_freep(wctx);\n}\n\nstatic void bprint_bytes(AVBPrint *bp, const uint8_t *ubuf, size_t ubuf_size)\n{\n    int i;\n    av_bprintf(bp, \"0X\");\n    for (i = 0; i < ubuf_size; i++)\n        av_bprintf(bp, \"%02X\", ubuf[i]);\n}\n\n\nstatic int writer_open(WriterContext **wctx, const Writer *writer, const char *args,\n                       const struct section *sections, int nb_sections)\n{\n    int i, ret = 0;\n\n    if (!(*wctx = av_mallocz(sizeof(WriterContext)))) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    if (!((*wctx)->priv = av_mallocz(writer->priv_size))) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    (*wctx)->class = &writer_class;\n    (*wctx)->writer = writer;\n    (*wctx)->level = -1;\n    (*wctx)->sections = sections;\n    (*wctx)->nb_sections = nb_sections;\n\n    av_opt_set_defaults(*wctx);\n\n    if (writer->priv_class) {\n        void *priv_ctx = (*wctx)->priv;\n        *((const AVClass **)priv_ctx) = writer->priv_class;\n        av_opt_set_defaults(priv_ctx);\n    }\n\n    /* convert options to dictionary */\n    if (args) {\n        AVDictionary *opts = NULL;\n        AVDictionaryEntry *opt = NULL;\n\n        if ((ret = av_dict_parse_string(&opts, args, \"=\", \":\", 0)) < 0) {\n            av_log(*wctx, AV_LOG_ERROR, \"Failed to parse option string '%s' provided to writer context\\n\", args);\n            av_dict_free(&opts);\n            goto fail;\n        }\n\n        while ((opt = av_dict_get(opts, \"\", opt, AV_DICT_IGNORE_SUFFIX))) {\n            if ((ret = av_opt_set(*wctx, opt->key, opt->value, AV_OPT_SEARCH_CHILDREN)) < 0) {\n                av_log(*wctx, AV_LOG_ERROR, \"Failed to set option '%s' with value '%s' provided to writer context\\n\",\n                       opt->key, opt->value);\n                av_dict_free(&opts);\n                goto fail;\n            }\n        }\n\n        av_dict_free(&opts);\n    }\n\n    /* validate replace string */\n    {\n        const uint8_t *p = (*wctx)->string_validation_replacement;\n        const uint8_t *endp = p + strlen(p);\n        while (*p) {\n            const uint8_t *p0 = p;\n            int32_t code;\n            ret = av_utf8_decode(&code, &p, endp, (*wctx)->string_validation_utf8_flags);\n            if (ret < 0) {\n                AVBPrint bp;\n                av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC);\n                bprint_bytes(&bp, p0, p-p0),\n                    av_log(wctx, AV_LOG_ERROR,\n                           \"Invalid UTF8 sequence %s found in string validation replace '%s'\\n\",\n                           bp.str, (*wctx)->string_validation_replacement);\n                return ret;\n            }\n        }\n    }\n\n    for (i = 0; i < SECTION_MAX_NB_LEVELS; i++)\n        av_bprint_init(&(*wctx)->section_pbuf[i], 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    if ((*wctx)->writer->init)\n        ret = (*wctx)->writer->init(*wctx);\n    if (ret < 0)\n        goto fail;\n\n    return 0;\n\nfail:\n    writer_close(wctx);\n    return ret;\n}\n\nstatic inline void writer_print_section_header(WriterContext *wctx,\n                                               int section_id)\n{\n    int parent_section_id;\n    wctx->level++;\n    av_assert0(wctx->level < SECTION_MAX_NB_LEVELS);\n    parent_section_id = wctx->level ?\n        (wctx->section[wctx->level-1])->id : SECTION_ID_NONE;\n\n    wctx->nb_item[wctx->level] = 0;\n    wctx->section[wctx->level] = &wctx->sections[section_id];\n\n    if (section_id == SECTION_ID_PACKETS_AND_FRAMES) {\n        wctx->nb_section_packet = wctx->nb_section_frame =\n        wctx->nb_section_packet_frame = 0;\n    } else if (parent_section_id == SECTION_ID_PACKETS_AND_FRAMES) {\n        wctx->nb_section_packet_frame = section_id == SECTION_ID_PACKET ?\n            wctx->nb_section_packet : wctx->nb_section_frame;\n    }\n\n    if (wctx->writer->print_section_header)\n        wctx->writer->print_section_header(wctx);\n}\n\nstatic inline void writer_print_section_footer(WriterContext *wctx)\n{\n    int section_id = wctx->section[wctx->level]->id;\n    int parent_section_id = wctx->level ?\n        wctx->section[wctx->level-1]->id : SECTION_ID_NONE;\n\n    if (parent_section_id != SECTION_ID_NONE)\n        wctx->nb_item[wctx->level-1]++;\n    if (parent_section_id == SECTION_ID_PACKETS_AND_FRAMES) {\n        if (section_id == SECTION_ID_PACKET) wctx->nb_section_packet++;\n        else                                     wctx->nb_section_frame++;\n    }\n    if (wctx->writer->print_section_footer)\n        wctx->writer->print_section_footer(wctx);\n    wctx->level--;\n}\n\nstatic inline void writer_print_integer(WriterContext *wctx,\n                                        const char *key, long long int val)\n{\n    const struct section *section = wctx->section[wctx->level];\n\n    if (section->show_all_entries || av_dict_get(section->entries_to_show, key, NULL, 0)) {\n        wctx->writer->print_integer(wctx, key, val);\n        wctx->nb_item[wctx->level]++;\n    }\n}\n\nstatic inline int validate_string(WriterContext *wctx, char **dstp, const char *src)\n{\n    const uint8_t *p, *endp;\n    AVBPrint dstbuf;\n    int invalid_chars_nb = 0, ret = 0;\n\n    av_bprint_init(&dstbuf, 0, AV_BPRINT_SIZE_UNLIMITED);\n\n    endp = src + strlen(src);\n    for (p = (uint8_t *)src; *p;) {\n        uint32_t code;\n        int invalid = 0;\n        const uint8_t *p0 = p;\n\n        if (av_utf8_decode(&code, &p, endp, wctx->string_validation_utf8_flags) < 0) {\n            AVBPrint bp;\n            av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC);\n            bprint_bytes(&bp, p0, p-p0);\n            av_log(wctx, AV_LOG_DEBUG,\n                   \"Invalid UTF-8 sequence %s found in string '%s'\\n\", bp.str, src);\n            invalid = 1;\n        }\n\n        if (invalid) {\n            invalid_chars_nb++;\n\n            switch (wctx->string_validation) {\n            case WRITER_STRING_VALIDATION_FAIL:\n                av_log(wctx, AV_LOG_ERROR,\n                       \"Invalid UTF-8 sequence found in string '%s'\\n\", src);\n                ret = AVERROR_INVALIDDATA;\n                goto end;\n                break;\n\n            case WRITER_STRING_VALIDATION_REPLACE:\n                av_bprintf(&dstbuf, \"%s\", wctx->string_validation_replacement);\n                break;\n            }\n        }\n\n        if (!invalid || wctx->string_validation == WRITER_STRING_VALIDATION_IGNORE)\n            av_bprint_append_data(&dstbuf, p0, p-p0);\n    }\n\n    if (invalid_chars_nb && wctx->string_validation == WRITER_STRING_VALIDATION_REPLACE) {\n        av_log(wctx, AV_LOG_WARNING,\n               \"%d invalid UTF-8 sequence(s) found in string '%s', replaced with '%s'\\n\",\n               invalid_chars_nb, src, wctx->string_validation_replacement);\n    }\n\nend:\n    av_bprint_finalize(&dstbuf, dstp);\n    return ret;\n}\n\n#define PRINT_STRING_OPT      1\n#define PRINT_STRING_VALIDATE 2\n\nstatic inline int writer_print_string(WriterContext *wctx,\n                                      const char *key, const char *val, int flags)\n{\n    const struct section *section = wctx->section[wctx->level];\n    int ret = 0;\n\n    if ((flags & PRINT_STRING_OPT)\n        && !(wctx->writer->flags & WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS))\n        return 0;\n\n    if (section->show_all_entries || av_dict_get(section->entries_to_show, key, NULL, 0)) {\n        if (flags & PRINT_STRING_VALIDATE) {\n            char *key1 = NULL, *val1 = NULL;\n            ret = validate_string(wctx, &key1, key);\n            if (ret < 0) goto end;\n            ret = validate_string(wctx, &val1, val);\n            if (ret < 0) goto end;\n            wctx->writer->print_string(wctx, key1, val1);\n        end:\n            if (ret < 0) {\n                av_log(wctx, AV_LOG_ERROR,\n                       \"Invalid key=value string combination %s=%s in section %s\\n\",\n                       key, val, section->unique_name);\n            }\n            av_free(key1);\n            av_free(val1);\n        } else {\n            wctx->writer->print_string(wctx, key, val);\n        }\n\n        wctx->nb_item[wctx->level]++;\n    }\n\n    return ret;\n}\n\nstatic inline void writer_print_rational(WriterContext *wctx,\n                                         const char *key, AVRational q, char sep)\n{\n    AVBPrint buf;\n    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_AUTOMATIC);\n    av_bprintf(&buf, \"%d%c%d\", q.num, sep, q.den);\n    writer_print_string(wctx, key, buf.str, 0);\n}\n\nstatic void writer_print_time(WriterContext *wctx, const char *key,\n                              int64_t ts, const AVRational *time_base, int is_duration)\n{\n    char buf[128];\n\n    if ((!is_duration && ts == AV_NOPTS_VALUE) || (is_duration && ts == 0)) {\n        writer_print_string(wctx, key, \"N/A\", PRINT_STRING_OPT);\n    } else {\n        double d = ts * av_q2d(*time_base);\n        struct unit_value uv;\n        uv.val.d = d;\n        uv.unit = unit_second_str;\n        value_string(buf, sizeof(buf), uv);\n        writer_print_string(wctx, key, buf, 0);\n    }\n}\n\nstatic void writer_print_ts(WriterContext *wctx, const char *key, int64_t ts, int is_duration)\n{\n    if ((!is_duration && ts == AV_NOPTS_VALUE) || (is_duration && ts == 0)) {\n        writer_print_string(wctx, key, \"N/A\", PRINT_STRING_OPT);\n    } else {\n        writer_print_integer(wctx, key, ts);\n    }\n}\n\nstatic void writer_print_data(WriterContext *wctx, const char *name,\n                              uint8_t *data, int size)\n{\n    AVBPrint bp;\n    int offset = 0, l, i;\n\n    av_bprint_init(&bp, 0, AV_BPRINT_SIZE_UNLIMITED);\n    av_bprintf(&bp, \"\\n\");\n    while (size) {\n        av_bprintf(&bp, \"%08x: \", offset);\n        l = FFMIN(size, 16);\n        for (i = 0; i < l; i++) {\n            av_bprintf(&bp, \"%02x\", data[i]);\n            if (i & 1)\n                av_bprintf(&bp, \" \");\n        }\n        av_bprint_chars(&bp, ' ', 41 - 2 * i - i / 2);\n        for (i = 0; i < l; i++)\n            av_bprint_chars(&bp, data[i] - 32U < 95 ? data[i] : '.', 1);\n        av_bprintf(&bp, \"\\n\");\n        offset += l;\n        data   += l;\n        size   -= l;\n    }\n    writer_print_string(wctx, name, bp.str, 0);\n    av_bprint_finalize(&bp, NULL);\n}\n\nstatic void writer_print_data_hash(WriterContext *wctx, const char *name,\n                                   uint8_t *data, int size)\n{\n    char *p, buf[AV_HASH_MAX_SIZE * 2 + 64] = { 0 };\n\n    if (!hash)\n        return;\n    av_hash_init(hash);\n    av_hash_update(hash, data, size);\n    snprintf(buf, sizeof(buf), \"%s:\", av_hash_get_name(hash));\n    p = buf + strlen(buf);\n    av_hash_final_hex(hash, p, buf + sizeof(buf) - p);\n    writer_print_string(wctx, name, buf, 0);\n}\n\nstatic void writer_print_integers(WriterContext *wctx, const char *name,\n                                  uint8_t *data, int size, const char *format,\n                                  int columns, int bytes, int offset_add)\n{\n    AVBPrint bp;\n    int offset = 0, l, i;\n\n    av_bprint_init(&bp, 0, AV_BPRINT_SIZE_UNLIMITED);\n    av_bprintf(&bp, \"\\n\");\n    while (size) {\n        av_bprintf(&bp, \"%08x: \", offset);\n        l = FFMIN(size, columns);\n        for (i = 0; i < l; i++) {\n            if      (bytes == 1) av_bprintf(&bp, format, *data);\n            else if (bytes == 2) av_bprintf(&bp, format, AV_RN16(data));\n            else if (bytes == 4) av_bprintf(&bp, format, AV_RN32(data));\n            data += bytes;\n            size --;\n        }\n        av_bprintf(&bp, \"\\n\");\n        offset += offset_add;\n    }\n    writer_print_string(wctx, name, bp.str, 0);\n    av_bprint_finalize(&bp, NULL);\n}\n\n#define MAX_REGISTERED_WRITERS_NB 64\n\nstatic const Writer *registered_writers[MAX_REGISTERED_WRITERS_NB + 1];\n\nstatic int writer_register(const Writer *writer)\n{\n    static int next_registered_writer_idx = 0;\n\n    if (next_registered_writer_idx == MAX_REGISTERED_WRITERS_NB)\n        return AVERROR(ENOMEM);\n\n    registered_writers[next_registered_writer_idx++] = writer;\n    return 0;\n}\n\nstatic const Writer *writer_get_by_name(const char *name)\n{\n    int i;\n\n    for (i = 0; registered_writers[i]; i++)\n        if (!strcmp(registered_writers[i]->name, name))\n            return registered_writers[i];\n\n    return NULL;\n}\n\n\n/* WRITERS */\n\n#define DEFINE_WRITER_CLASS(name)                   \\\nstatic const char *name##_get_name(void *ctx)       \\\n{                                                   \\\n    return #name ;                                  \\\n}                                                   \\\nstatic const AVClass name##_class = {               \\\n    .class_name = #name,                            \\\n    .item_name  = name##_get_name,                  \\\n    .option     = name##_options                    \\\n}\n\n/* Default output */\n\ntypedef struct DefaultContext {\n    const AVClass *class;\n    int nokey;\n    int noprint_wrappers;\n    int nested_section[SECTION_MAX_NB_LEVELS];\n} DefaultContext;\n\n#undef OFFSET\n#define OFFSET(x) offsetof(DefaultContext, x)\n\nstatic const AVOption default_options[] = {\n    { \"noprint_wrappers\", \"do not print headers and footers\", OFFSET(noprint_wrappers), AV_OPT_TYPE_BOOL, {.i64=0}, 0, 1 },\n    { \"nw\",               \"do not print headers and footers\", OFFSET(noprint_wrappers), AV_OPT_TYPE_BOOL, {.i64=0}, 0, 1 },\n    { \"nokey\",          \"force no key printing\",     OFFSET(nokey),          AV_OPT_TYPE_BOOL, {.i64=0}, 0, 1 },\n    { \"nk\",             \"force no key printing\",     OFFSET(nokey),          AV_OPT_TYPE_BOOL, {.i64=0}, 0, 1 },\n    {NULL},\n};\n\nDEFINE_WRITER_CLASS(default);\n\n/* lame uppercasing routine, assumes the string is lower case ASCII */\nstatic inline char *upcase_string(char *dst, size_t dst_size, const char *src)\n{\n    int i;\n    for (i = 0; src[i] && i < dst_size-1; i++)\n        dst[i] = av_toupper(src[i]);\n    dst[i] = 0;\n    return dst;\n}\n\nstatic void default_print_section_header(WriterContext *wctx)\n{\n    DefaultContext *def = wctx->priv;\n    char buf[32];\n    const struct section *section = wctx->section[wctx->level];\n    const struct section *parent_section = wctx->level ?\n        wctx->section[wctx->level-1] : NULL;\n\n    av_bprint_clear(&wctx->section_pbuf[wctx->level]);\n    if (parent_section &&\n        !(parent_section->flags & (SECTION_FLAG_IS_WRAPPER|SECTION_FLAG_IS_ARRAY))) {\n        def->nested_section[wctx->level] = 1;\n        av_bprintf(&wctx->section_pbuf[wctx->level], \"%s%s:\",\n                   wctx->section_pbuf[wctx->level-1].str,\n                   upcase_string(buf, sizeof(buf),\n                                 av_x_if_null(section->element_name, section->name)));\n    }\n\n    if (def->noprint_wrappers || def->nested_section[wctx->level])\n        return;\n\n    if (!(section->flags & (SECTION_FLAG_IS_WRAPPER|SECTION_FLAG_IS_ARRAY)))\n        printf(\"[%s]\\n\", upcase_string(buf, sizeof(buf), section->name));\n}\n\nstatic void default_print_section_footer(WriterContext *wctx)\n{\n    DefaultContext *def = wctx->priv;\n    const struct section *section = wctx->section[wctx->level];\n    char buf[32];\n\n    if (def->noprint_wrappers || def->nested_section[wctx->level])\n        return;\n\n    if (!(section->flags & (SECTION_FLAG_IS_WRAPPER|SECTION_FLAG_IS_ARRAY)))\n        printf(\"[/%s]\\n\", upcase_string(buf, sizeof(buf), section->name));\n}\n\nstatic void default_print_str(WriterContext *wctx, const char *key, const char *value)\n{\n    DefaultContext *def = wctx->priv;\n\n    if (!def->nokey)\n        printf(\"%s%s=\", wctx->section_pbuf[wctx->level].str, key);\n    printf(\"%s\\n\", value);\n}\n\nstatic void default_print_int(WriterContext *wctx, const char *key, long long int value)\n{\n    DefaultContext *def = wctx->priv;\n\n    if (!def->nokey)\n        printf(\"%s%s=\", wctx->section_pbuf[wctx->level].str, key);\n    printf(\"%lld\\n\", value);\n}\n\nstatic const Writer default_writer = {\n    .name                  = \"default\",\n    .priv_size             = sizeof(DefaultContext),\n    .print_section_header  = default_print_section_header,\n    .print_section_footer  = default_print_section_footer,\n    .print_integer         = default_print_int,\n    .print_string          = default_print_str,\n    .flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS,\n    .priv_class            = &default_class,\n};\n\n/* Compact output */\n\n/**\n * Apply C-language-like string escaping.\n */\nstatic const char *c_escape_str(AVBPrint *dst, const char *src, const char sep, void *log_ctx)\n{\n    const char *p;\n\n    for (p = src; *p; p++) {\n        switch (*p) {\n        case '\\b': av_bprintf(dst, \"%s\", \"\\\\b\");  break;\n        case '\\f': av_bprintf(dst, \"%s\", \"\\\\f\");  break;\n        case '\\n': av_bprintf(dst, \"%s\", \"\\\\n\");  break;\n        case '\\r': av_bprintf(dst, \"%s\", \"\\\\r\");  break;\n        case '\\\\': av_bprintf(dst, \"%s\", \"\\\\\\\\\"); break;\n        default:\n            if (*p == sep)\n                av_bprint_chars(dst, '\\\\', 1);\n            av_bprint_chars(dst, *p, 1);\n        }\n    }\n    return dst->str;\n}\n\n/**\n * Quote fields containing special characters, check RFC4180.\n */\nstatic const char *csv_escape_str(AVBPrint *dst, const char *src, const char sep, void *log_ctx)\n{\n    char meta_chars[] = { sep, '\"', '\\n', '\\r', '\\0' };\n    int needs_quoting = !!src[strcspn(src, meta_chars)];\n\n    if (needs_quoting)\n        av_bprint_chars(dst, '\"', 1);\n\n    for (; *src; src++) {\n        if (*src == '\"')\n            av_bprint_chars(dst, '\"', 1);\n        av_bprint_chars(dst, *src, 1);\n    }\n    if (needs_quoting)\n        av_bprint_chars(dst, '\"', 1);\n    return dst->str;\n}\n\nstatic const char *none_escape_str(AVBPrint *dst, const char *src, const char sep, void *log_ctx)\n{\n    return src;\n}\n\ntypedef struct CompactContext {\n    const AVClass *class;\n    char *item_sep_str;\n    char item_sep;\n    int nokey;\n    int print_section;\n    char *escape_mode_str;\n    const char * (*escape_str)(AVBPrint *dst, const char *src, const char sep, void *log_ctx);\n    int nested_section[SECTION_MAX_NB_LEVELS];\n    int has_nested_elems[SECTION_MAX_NB_LEVELS];\n    int terminate_line[SECTION_MAX_NB_LEVELS];\n} CompactContext;\n\n#undef OFFSET\n#define OFFSET(x) offsetof(CompactContext, x)\n\nstatic const AVOption compact_options[]= {\n    {\"item_sep\", \"set item separator\",    OFFSET(item_sep_str),    AV_OPT_TYPE_STRING, {.str=\"|\"},  CHAR_MIN, CHAR_MAX },\n    {\"s\",        \"set item separator\",    OFFSET(item_sep_str),    AV_OPT_TYPE_STRING, {.str=\"|\"},  CHAR_MIN, CHAR_MAX },\n    {\"nokey\",    \"force no key printing\", OFFSET(nokey),           AV_OPT_TYPE_BOOL,   {.i64=0},    0,        1        },\n    {\"nk\",       \"force no key printing\", OFFSET(nokey),           AV_OPT_TYPE_BOOL,   {.i64=0},    0,        1        },\n    {\"escape\",   \"set escape mode\",       OFFSET(escape_mode_str), AV_OPT_TYPE_STRING, {.str=\"c\"},  CHAR_MIN, CHAR_MAX },\n    {\"e\",        \"set escape mode\",       OFFSET(escape_mode_str), AV_OPT_TYPE_STRING, {.str=\"c\"},  CHAR_MIN, CHAR_MAX },\n    {\"print_section\", \"print section name\", OFFSET(print_section), AV_OPT_TYPE_BOOL,   {.i64=1},    0,        1        },\n    {\"p\",             \"print section name\", OFFSET(print_section), AV_OPT_TYPE_BOOL,   {.i64=1},    0,        1        },\n    {NULL},\n};\n\nDEFINE_WRITER_CLASS(compact);\n\nstatic av_cold int compact_init(WriterContext *wctx)\n{\n    CompactContext *compact = wctx->priv;\n\n    if (strlen(compact->item_sep_str) != 1) {\n        av_log(wctx, AV_LOG_ERROR, \"Item separator '%s' specified, but must contain a single character\\n\",\n               compact->item_sep_str);\n        return AVERROR(EINVAL);\n    }\n    compact->item_sep = compact->item_sep_str[0];\n\n    if      (!strcmp(compact->escape_mode_str, \"none\")) compact->escape_str = none_escape_str;\n    else if (!strcmp(compact->escape_mode_str, \"c\"   )) compact->escape_str = c_escape_str;\n    else if (!strcmp(compact->escape_mode_str, \"csv\" )) compact->escape_str = csv_escape_str;\n    else {\n        av_log(wctx, AV_LOG_ERROR, \"Unknown escape mode '%s'\\n\", compact->escape_mode_str);\n        return AVERROR(EINVAL);\n    }\n\n    return 0;\n}\n\nstatic void compact_print_section_header(WriterContext *wctx)\n{\n    CompactContext *compact = wctx->priv;\n    const struct section *section = wctx->section[wctx->level];\n    const struct section *parent_section = wctx->level ?\n        wctx->section[wctx->level-1] : NULL;\n    compact->terminate_line[wctx->level] = 1;\n    compact->has_nested_elems[wctx->level] = 0;\n\n    av_bprint_clear(&wctx->section_pbuf[wctx->level]);\n    if (!(section->flags & SECTION_FLAG_IS_ARRAY) && parent_section &&\n        !(parent_section->flags & (SECTION_FLAG_IS_WRAPPER|SECTION_FLAG_IS_ARRAY))) {\n        compact->nested_section[wctx->level] = 1;\n        compact->has_nested_elems[wctx->level-1] = 1;\n        av_bprintf(&wctx->section_pbuf[wctx->level], \"%s%s:\",\n                   wctx->section_pbuf[wctx->level-1].str,\n                   (char *)av_x_if_null(section->element_name, section->name));\n        wctx->nb_item[wctx->level] = wctx->nb_item[wctx->level-1];\n    } else {\n        if (parent_section && compact->has_nested_elems[wctx->level-1] &&\n            (section->flags & SECTION_FLAG_IS_ARRAY)) {\n            compact->terminate_line[wctx->level-1] = 0;\n            printf(\"\\n\");\n        }\n        if (compact->print_section &&\n            !(section->flags & (SECTION_FLAG_IS_WRAPPER|SECTION_FLAG_IS_ARRAY)))\n            printf(\"%s%c\", section->name, compact->item_sep);\n    }\n}\n\nstatic void compact_print_section_footer(WriterContext *wctx)\n{\n    CompactContext *compact = wctx->priv;\n\n    if (!compact->nested_section[wctx->level] &&\n        compact->terminate_line[wctx->level] &&\n        !(wctx->section[wctx->level]->flags & (SECTION_FLAG_IS_WRAPPER|SECTION_FLAG_IS_ARRAY)))\n        printf(\"\\n\");\n}\n\nstatic void compact_print_str(WriterContext *wctx, const char *key, const char *value)\n{\n    CompactContext *compact = wctx->priv;\n    AVBPrint buf;\n\n    if (wctx->nb_item[wctx->level]) printf(\"%c\", compact->item_sep);\n    if (!compact->nokey)\n        printf(\"%s%s=\", wctx->section_pbuf[wctx->level].str, key);\n    av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n    printf(\"%s\", compact->escape_str(&buf, value, compact->item_sep, wctx));\n    av_bprint_finalize(&buf, NULL);\n}\n\nstatic void compact_print_int(WriterContext *wctx, const char *key, long long int value)\n{\n    CompactContext *compact = wctx->priv;\n\n    if (wctx->nb_item[wctx->level]) printf(\"%c\", compact->item_sep);\n    if (!compact->nokey)\n        printf(\"%s%s=\", wctx->section_pbuf[wctx->level].str, key);\n    printf(\"%lld\", value);\n}\n\nstatic const Writer compact_writer = {\n    .name                 = \"compact\",\n    .priv_size            = sizeof(CompactContext),\n    .init                 = compact_init,\n    .print_section_header = compact_print_section_header,\n    .print_section_footer = compact_print_section_footer,\n    .print_integer        = compact_print_int,\n    .print_string         = compact_print_str,\n    .flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS,\n    .priv_class           = &compact_class,\n};\n\n/* CSV output */\n\n#undef OFFSET\n#define OFFSET(x) offsetof(CompactContext, x)\n\nstatic const AVOption csv_options[] = {\n    {\"item_sep\", \"set item separator\",    OFFSET(item_sep_str),    AV_OPT_TYPE_STRING, {.str=\",\"},  CHAR_MIN, CHAR_MAX },\n    {\"s\",        \"set item separator\",    OFFSET(item_sep_str),    AV_OPT_TYPE_STRING, {.str=\",\"},  CHAR_MIN, CHAR_MAX },\n    {\"nokey\",    \"force no key printing\", OFFSET(nokey),           AV_OPT_TYPE_BOOL,   {.i64=1},    0,        1        },\n    {\"nk\",       \"force no key printing\", OFFSET(nokey),           AV_OPT_TYPE_BOOL,   {.i64=1},    0,        1        },\n    {\"escape\",   \"set escape mode\",       OFFSET(escape_mode_str), AV_OPT_TYPE_STRING, {.str=\"csv\"}, CHAR_MIN, CHAR_MAX },\n    {\"e\",        \"set escape mode\",       OFFSET(escape_mode_str), AV_OPT_TYPE_STRING, {.str=\"csv\"}, CHAR_MIN, CHAR_MAX },\n    {\"print_section\", \"print section name\", OFFSET(print_section), AV_OPT_TYPE_BOOL,   {.i64=1},    0,        1        },\n    {\"p\",             \"print section name\", OFFSET(print_section), AV_OPT_TYPE_BOOL,   {.i64=1},    0,        1        },\n    {NULL},\n};\n\nDEFINE_WRITER_CLASS(csv);\n\nstatic const Writer csv_writer = {\n    .name                 = \"csv\",\n    .priv_size            = sizeof(CompactContext),\n    .init                 = compact_init,\n    .print_section_header = compact_print_section_header,\n    .print_section_footer = compact_print_section_footer,\n    .print_integer        = compact_print_int,\n    .print_string         = compact_print_str,\n    .flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS,\n    .priv_class           = &csv_class,\n};\n\n/* Flat output */\n\ntypedef struct FlatContext {\n    const AVClass *class;\n    const char *sep_str;\n    char sep;\n    int hierarchical;\n} FlatContext;\n\n#undef OFFSET\n#define OFFSET(x) offsetof(FlatContext, x)\n\nstatic const AVOption flat_options[]= {\n    {\"sep_char\", \"set separator\",    OFFSET(sep_str),    AV_OPT_TYPE_STRING, {.str=\".\"},  CHAR_MIN, CHAR_MAX },\n    {\"s\",        \"set separator\",    OFFSET(sep_str),    AV_OPT_TYPE_STRING, {.str=\".\"},  CHAR_MIN, CHAR_MAX },\n    {\"hierarchical\", \"specify if the section specification should be hierarchical\", OFFSET(hierarchical), AV_OPT_TYPE_BOOL, {.i64=1}, 0, 1 },\n    {\"h\",            \"specify if the section specification should be hierarchical\", OFFSET(hierarchical), AV_OPT_TYPE_BOOL, {.i64=1}, 0, 1 },\n    {NULL},\n};\n\nDEFINE_WRITER_CLASS(flat);\n\nstatic av_cold int flat_init(WriterContext *wctx)\n{\n    FlatContext *flat = wctx->priv;\n\n    if (strlen(flat->sep_str) != 1) {\n        av_log(wctx, AV_LOG_ERROR, \"Item separator '%s' specified, but must contain a single character\\n\",\n               flat->sep_str);\n        return AVERROR(EINVAL);\n    }\n    flat->sep = flat->sep_str[0];\n\n    return 0;\n}\n\nstatic const char *flat_escape_key_str(AVBPrint *dst, const char *src, const char sep)\n{\n    const char *p;\n\n    for (p = src; *p; p++) {\n        if (!((*p >= '0' && *p <= '9') ||\n              (*p >= 'a' && *p <= 'z') ||\n              (*p >= 'A' && *p <= 'Z')))\n            av_bprint_chars(dst, '_', 1);\n        else\n            av_bprint_chars(dst, *p, 1);\n    }\n    return dst->str;\n}\n\nstatic const char *flat_escape_value_str(AVBPrint *dst, const char *src)\n{\n    const char *p;\n\n    for (p = src; *p; p++) {\n        switch (*p) {\n        case '\\n': av_bprintf(dst, \"%s\", \"\\\\n\");  break;\n        case '\\r': av_bprintf(dst, \"%s\", \"\\\\r\");  break;\n        case '\\\\': av_bprintf(dst, \"%s\", \"\\\\\\\\\"); break;\n        case '\"':  av_bprintf(dst, \"%s\", \"\\\\\\\"\"); break;\n        case '`':  av_bprintf(dst, \"%s\", \"\\\\`\");  break;\n        case '$':  av_bprintf(dst, \"%s\", \"\\\\$\");  break;\n        default:   av_bprint_chars(dst, *p, 1);   break;\n        }\n    }\n    return dst->str;\n}\n\nstatic void flat_print_section_header(WriterContext *wctx)\n{\n    FlatContext *flat = wctx->priv;\n    AVBPrint *buf = &wctx->section_pbuf[wctx->level];\n    const struct section *section = wctx->section[wctx->level];\n    const struct section *parent_section = wctx->level ?\n        wctx->section[wctx->level-1] : NULL;\n\n    /* build section header */\n    av_bprint_clear(buf);\n    if (!parent_section)\n        return;\n    av_bprintf(buf, \"%s\", wctx->section_pbuf[wctx->level-1].str);\n\n    if (flat->hierarchical ||\n        !(section->flags & (SECTION_FLAG_IS_ARRAY|SECTION_FLAG_IS_WRAPPER))) {\n        av_bprintf(buf, \"%s%s\", wctx->section[wctx->level]->name, flat->sep_str);\n\n        if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {\n            int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?\n                wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];\n            av_bprintf(buf, \"%d%s\", n, flat->sep_str);\n        }\n    }\n}\n\nstatic void flat_print_int(WriterContext *wctx, const char *key, long long int value)\n{\n    printf(\"%s%s=%lld\\n\", wctx->section_pbuf[wctx->level].str, key, value);\n}\n\nstatic void flat_print_str(WriterContext *wctx, const char *key, const char *value)\n{\n    FlatContext *flat = wctx->priv;\n    AVBPrint buf;\n\n    printf(\"%s\", wctx->section_pbuf[wctx->level].str);\n    av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n    printf(\"%s=\", flat_escape_key_str(&buf, key, flat->sep));\n    av_bprint_clear(&buf);\n    printf(\"\\\"%s\\\"\\n\", flat_escape_value_str(&buf, value));\n    av_bprint_finalize(&buf, NULL);\n}\n\nstatic const Writer flat_writer = {\n    .name                  = \"flat\",\n    .priv_size             = sizeof(FlatContext),\n    .init                  = flat_init,\n    .print_section_header  = flat_print_section_header,\n    .print_integer         = flat_print_int,\n    .print_string          = flat_print_str,\n    .flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS|WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER,\n    .priv_class            = &flat_class,\n};\n\n/* INI format output */\n\ntypedef struct INIContext {\n    const AVClass *class;\n    int hierarchical;\n} INIContext;\n\n#undef OFFSET\n#define OFFSET(x) offsetof(INIContext, x)\n\nstatic const AVOption ini_options[] = {\n    {\"hierarchical\", \"specify if the section specification should be hierarchical\", OFFSET(hierarchical), AV_OPT_TYPE_BOOL, {.i64=1}, 0, 1 },\n    {\"h\",            \"specify if the section specification should be hierarchical\", OFFSET(hierarchical), AV_OPT_TYPE_BOOL, {.i64=1}, 0, 1 },\n    {NULL},\n};\n\nDEFINE_WRITER_CLASS(ini);\n\nstatic char *ini_escape_str(AVBPrint *dst, const char *src)\n{\n    int i = 0;\n    char c = 0;\n\n    while (c = src[i++]) {\n        switch (c) {\n        case '\\b': av_bprintf(dst, \"%s\", \"\\\\b\"); break;\n        case '\\f': av_bprintf(dst, \"%s\", \"\\\\f\"); break;\n        case '\\n': av_bprintf(dst, \"%s\", \"\\\\n\"); break;\n        case '\\r': av_bprintf(dst, \"%s\", \"\\\\r\"); break;\n        case '\\t': av_bprintf(dst, \"%s\", \"\\\\t\"); break;\n        case '\\\\':\n        case '#' :\n        case '=' :\n        case ':' : av_bprint_chars(dst, '\\\\', 1);\n        default:\n            if ((unsigned char)c < 32)\n                av_bprintf(dst, \"\\\\x00%02x\", c & 0xff);\n            else\n                av_bprint_chars(dst, c, 1);\n            break;\n        }\n    }\n    return dst->str;\n}\n\nstatic void ini_print_section_header(WriterContext *wctx)\n{\n    INIContext *ini = wctx->priv;\n    AVBPrint *buf = &wctx->section_pbuf[wctx->level];\n    const struct section *section = wctx->section[wctx->level];\n    const struct section *parent_section = wctx->level ?\n        wctx->section[wctx->level-1] : NULL;\n\n    av_bprint_clear(buf);\n    if (!parent_section) {\n        printf(\"# ffprobe output\\n\\n\");\n        return;\n    }\n\n    if (wctx->nb_item[wctx->level-1])\n        printf(\"\\n\");\n\n    av_bprintf(buf, \"%s\", wctx->section_pbuf[wctx->level-1].str);\n    if (ini->hierarchical ||\n        !(section->flags & (SECTION_FLAG_IS_ARRAY|SECTION_FLAG_IS_WRAPPER))) {\n        av_bprintf(buf, \"%s%s\", buf->str[0] ? \".\" : \"\", wctx->section[wctx->level]->name);\n\n        if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {\n            int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?\n                wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];\n            av_bprintf(buf, \".%d\", n);\n        }\n    }\n\n    if (!(section->flags & (SECTION_FLAG_IS_ARRAY|SECTION_FLAG_IS_WRAPPER)))\n        printf(\"[%s]\\n\", buf->str);\n}\n\nstatic void ini_print_str(WriterContext *wctx, const char *key, const char *value)\n{\n    AVBPrint buf;\n\n    av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n    printf(\"%s=\", ini_escape_str(&buf, key));\n    av_bprint_clear(&buf);\n    printf(\"%s\\n\", ini_escape_str(&buf, value));\n    av_bprint_finalize(&buf, NULL);\n}\n\nstatic void ini_print_int(WriterContext *wctx, const char *key, long long int value)\n{\n    printf(\"%s=%lld\\n\", key, value);\n}\n\nstatic const Writer ini_writer = {\n    .name                  = \"ini\",\n    .priv_size             = sizeof(INIContext),\n    .print_section_header  = ini_print_section_header,\n    .print_integer         = ini_print_int,\n    .print_string          = ini_print_str,\n    .flags = WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS|WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER,\n    .priv_class            = &ini_class,\n};\n\n/* JSON output */\n\ntypedef struct JSONContext {\n    const AVClass *class;\n    int indent_level;\n    int compact;\n    const char *item_sep, *item_start_end;\n} JSONContext;\n\n#undef OFFSET\n#define OFFSET(x) offsetof(JSONContext, x)\n\nstatic const AVOption json_options[]= {\n    { \"compact\", \"enable compact output\", OFFSET(compact), AV_OPT_TYPE_BOOL, {.i64=0}, 0, 1 },\n    { \"c\",       \"enable compact output\", OFFSET(compact), AV_OPT_TYPE_BOOL, {.i64=0}, 0, 1 },\n    { NULL }\n};\n\nDEFINE_WRITER_CLASS(json);\n\nstatic av_cold int json_init(WriterContext *wctx)\n{\n    JSONContext *json = wctx->priv;\n\n    json->item_sep       = json->compact ? \", \" : \",\\n\";\n    json->item_start_end = json->compact ? \" \"  : \"\\n\";\n\n    return 0;\n}\n\nstatic const char *json_escape_str(AVBPrint *dst, const char *src, void *log_ctx)\n{\n    static const char json_escape[] = {'\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t', 0};\n    static const char json_subst[]  = {'\"', '\\\\',  'b',  'f',  'n',  'r',  't', 0};\n    const char *p;\n\n    for (p = src; *p; p++) {\n        char *s = strchr(json_escape, *p);\n        if (s) {\n            av_bprint_chars(dst, '\\\\', 1);\n            av_bprint_chars(dst, json_subst[s - json_escape], 1);\n        } else if ((unsigned char)*p < 32) {\n            av_bprintf(dst, \"\\\\u00%02x\", *p & 0xff);\n        } else {\n            av_bprint_chars(dst, *p, 1);\n        }\n    }\n    return dst->str;\n}\n\n#define JSON_INDENT() printf(\"%*c\", json->indent_level * 4, ' ')\n\nstatic void json_print_section_header(WriterContext *wctx)\n{\n    JSONContext *json = wctx->priv;\n    AVBPrint buf;\n    const struct section *section = wctx->section[wctx->level];\n    const struct section *parent_section = wctx->level ?\n        wctx->section[wctx->level-1] : NULL;\n\n    if (wctx->level && wctx->nb_item[wctx->level-1])\n        printf(\",\\n\");\n\n    if (section->flags & SECTION_FLAG_IS_WRAPPER) {\n        printf(\"{\\n\");\n        json->indent_level++;\n    } else {\n        av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n        json_escape_str(&buf, section->name, wctx);\n        JSON_INDENT();\n\n        json->indent_level++;\n        if (section->flags & SECTION_FLAG_IS_ARRAY) {\n            printf(\"\\\"%s\\\": [\\n\", buf.str);\n        } else if (parent_section && !(parent_section->flags & SECTION_FLAG_IS_ARRAY)) {\n            printf(\"\\\"%s\\\": {%s\", buf.str, json->item_start_end);\n        } else {\n            printf(\"{%s\", json->item_start_end);\n\n            /* this is required so the parser can distinguish between packets and frames */\n            if (parent_section && parent_section->id == SECTION_ID_PACKETS_AND_FRAMES) {\n                if (!json->compact)\n                    JSON_INDENT();\n                printf(\"\\\"type\\\": \\\"%s\\\"%s\", section->name, json->item_sep);\n            }\n        }\n        av_bprint_finalize(&buf, NULL);\n    }\n}\n\nstatic void json_print_section_footer(WriterContext *wctx)\n{\n    JSONContext *json = wctx->priv;\n    const struct section *section = wctx->section[wctx->level];\n\n    if (wctx->level == 0) {\n        json->indent_level--;\n        printf(\"\\n}\\n\");\n    } else if (section->flags & SECTION_FLAG_IS_ARRAY) {\n        printf(\"\\n\");\n        json->indent_level--;\n        JSON_INDENT();\n        printf(\"]\");\n    } else {\n        printf(\"%s\", json->item_start_end);\n        json->indent_level--;\n        if (!json->compact)\n            JSON_INDENT();\n        printf(\"}\");\n    }\n}\n\nstatic inline void json_print_item_str(WriterContext *wctx,\n                                       const char *key, const char *value)\n{\n    AVBPrint buf;\n\n    av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n    printf(\"\\\"%s\\\":\", json_escape_str(&buf, key,   wctx));\n    av_bprint_clear(&buf);\n    printf(\" \\\"%s\\\"\", json_escape_str(&buf, value, wctx));\n    av_bprint_finalize(&buf, NULL);\n}\n\nstatic void json_print_str(WriterContext *wctx, const char *key, const char *value)\n{\n    JSONContext *json = wctx->priv;\n\n    if (wctx->nb_item[wctx->level])\n        printf(\"%s\", json->item_sep);\n    if (!json->compact)\n        JSON_INDENT();\n    json_print_item_str(wctx, key, value);\n}\n\nstatic void json_print_int(WriterContext *wctx, const char *key, long long int value)\n{\n    JSONContext *json = wctx->priv;\n    AVBPrint buf;\n\n    if (wctx->nb_item[wctx->level])\n        printf(\"%s\", json->item_sep);\n    if (!json->compact)\n        JSON_INDENT();\n\n    av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n    printf(\"\\\"%s\\\": %lld\", json_escape_str(&buf, key, wctx), value);\n    av_bprint_finalize(&buf, NULL);\n}\n\nstatic const Writer json_writer = {\n    .name                 = \"json\",\n    .priv_size            = sizeof(JSONContext),\n    .init                 = json_init,\n    .print_section_header = json_print_section_header,\n    .print_section_footer = json_print_section_footer,\n    .print_integer        = json_print_int,\n    .print_string         = json_print_str,\n    .flags = WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER,\n    .priv_class           = &json_class,\n};\n\n/* XML output */\n\ntypedef struct XMLContext {\n    const AVClass *class;\n    int within_tag;\n    int indent_level;\n    int fully_qualified;\n    int xsd_strict;\n} XMLContext;\n\n#undef OFFSET\n#define OFFSET(x) offsetof(XMLContext, x)\n\nstatic const AVOption xml_options[] = {\n    {\"fully_qualified\", \"specify if the output should be fully qualified\", OFFSET(fully_qualified), AV_OPT_TYPE_BOOL, {.i64=0},  0, 1 },\n    {\"q\",               \"specify if the output should be fully qualified\", OFFSET(fully_qualified), AV_OPT_TYPE_BOOL, {.i64=0},  0, 1 },\n    {\"xsd_strict\",      \"ensure that the output is XSD compliant\",         OFFSET(xsd_strict),      AV_OPT_TYPE_BOOL, {.i64=0},  0, 1 },\n    {\"x\",               \"ensure that the output is XSD compliant\",         OFFSET(xsd_strict),      AV_OPT_TYPE_BOOL, {.i64=0},  0, 1 },\n    {NULL},\n};\n\nDEFINE_WRITER_CLASS(xml);\n\nstatic av_cold int xml_init(WriterContext *wctx)\n{\n    XMLContext *xml = wctx->priv;\n\n    if (xml->xsd_strict) {\n        xml->fully_qualified = 1;\n#define CHECK_COMPLIANCE(opt, opt_name)                                 \\\n        if (opt) {                                                      \\\n            av_log(wctx, AV_LOG_ERROR,                                  \\\n                   \"XSD-compliant output selected but option '%s' was selected, XML output may be non-compliant.\\n\" \\\n                   \"You need to disable such option with '-no%s'\\n\", opt_name, opt_name); \\\n            return AVERROR(EINVAL);                                     \\\n        }\n        CHECK_COMPLIANCE(show_private_data, \"private\");\n        CHECK_COMPLIANCE(show_value_unit,   \"unit\");\n        CHECK_COMPLIANCE(use_value_prefix,  \"prefix\");\n\n        if (do_show_frames && do_show_packets) {\n            av_log(wctx, AV_LOG_ERROR,\n                   \"Interleaved frames and packets are not allowed in XSD. \"\n                   \"Select only one between the -show_frames and the -show_packets options.\\n\");\n            return AVERROR(EINVAL);\n        }\n    }\n\n    return 0;\n}\n\nstatic const char *xml_escape_str(AVBPrint *dst, const char *src, void *log_ctx)\n{\n    const char *p;\n\n    for (p = src; *p; p++) {\n        switch (*p) {\n        case '&' : av_bprintf(dst, \"%s\", \"&amp;\");  break;\n        case '<' : av_bprintf(dst, \"%s\", \"&lt;\");   break;\n        case '>' : av_bprintf(dst, \"%s\", \"&gt;\");   break;\n        case '\"' : av_bprintf(dst, \"%s\", \"&quot;\"); break;\n        case '\\'': av_bprintf(dst, \"%s\", \"&apos;\"); break;\n        default: av_bprint_chars(dst, *p, 1);\n        }\n    }\n\n    return dst->str;\n}\n\n#define XML_INDENT() printf(\"%*c\", xml->indent_level * 4, ' ')\n\nstatic void xml_print_section_header(WriterContext *wctx)\n{\n    XMLContext *xml = wctx->priv;\n    const struct section *section = wctx->section[wctx->level];\n    const struct section *parent_section = wctx->level ?\n        wctx->section[wctx->level-1] : NULL;\n\n    if (wctx->level == 0) {\n        const char *qual = \" xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' \"\n            \"xmlns:ffprobe='http://www.ffmpeg.org/schema/ffprobe' \"\n            \"xsi:schemaLocation='http://www.ffmpeg.org/schema/ffprobe ffprobe.xsd'\";\n\n        printf(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n        printf(\"<%sffprobe%s>\\n\",\n               xml->fully_qualified ? \"ffprobe:\" : \"\",\n               xml->fully_qualified ? qual : \"\");\n        return;\n    }\n\n    if (xml->within_tag) {\n        xml->within_tag = 0;\n        printf(\">\\n\");\n    }\n    if (section->flags & SECTION_FLAG_HAS_VARIABLE_FIELDS) {\n        xml->indent_level++;\n    } else {\n        if (parent_section && (parent_section->flags & SECTION_FLAG_IS_WRAPPER) &&\n            wctx->level && wctx->nb_item[wctx->level-1])\n            printf(\"\\n\");\n        xml->indent_level++;\n\n        if (section->flags & SECTION_FLAG_IS_ARRAY) {\n            XML_INDENT(); printf(\"<%s>\\n\", section->name);\n        } else {\n            XML_INDENT(); printf(\"<%s \", section->name);\n            xml->within_tag = 1;\n        }\n    }\n}\n\nstatic void xml_print_section_footer(WriterContext *wctx)\n{\n    XMLContext *xml = wctx->priv;\n    const struct section *section = wctx->section[wctx->level];\n\n    if (wctx->level == 0) {\n        printf(\"</%sffprobe>\\n\", xml->fully_qualified ? \"ffprobe:\" : \"\");\n    } else if (xml->within_tag) {\n        xml->within_tag = 0;\n        printf(\"/>\\n\");\n        xml->indent_level--;\n    } else if (section->flags & SECTION_FLAG_HAS_VARIABLE_FIELDS) {\n        xml->indent_level--;\n    } else {\n        XML_INDENT(); printf(\"</%s>\\n\", section->name);\n        xml->indent_level--;\n    }\n}\n\nstatic void xml_print_str(WriterContext *wctx, const char *key, const char *value)\n{\n    AVBPrint buf;\n    XMLContext *xml = wctx->priv;\n    const struct section *section = wctx->section[wctx->level];\n\n    av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    if (section->flags & SECTION_FLAG_HAS_VARIABLE_FIELDS) {\n        XML_INDENT();\n        printf(\"<%s key=\\\"%s\\\"\",\n               section->element_name, xml_escape_str(&buf, key, wctx));\n        av_bprint_clear(&buf);\n        printf(\" value=\\\"%s\\\"/>\\n\", xml_escape_str(&buf, value, wctx));\n    } else {\n        if (wctx->nb_item[wctx->level])\n            printf(\" \");\n        printf(\"%s=\\\"%s\\\"\", key, xml_escape_str(&buf, value, wctx));\n    }\n\n    av_bprint_finalize(&buf, NULL);\n}\n\nstatic void xml_print_int(WriterContext *wctx, const char *key, long long int value)\n{\n    if (wctx->nb_item[wctx->level])\n        printf(\" \");\n    printf(\"%s=\\\"%lld\\\"\", key, value);\n}\n\nstatic Writer xml_writer = {\n    .name                 = \"xml\",\n    .priv_size            = sizeof(XMLContext),\n    .init                 = xml_init,\n    .print_section_header = xml_print_section_header,\n    .print_section_footer = xml_print_section_footer,\n    .print_integer        = xml_print_int,\n    .print_string         = xml_print_str,\n    .flags = WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER,\n    .priv_class           = &xml_class,\n};\n\nstatic void writer_register_all(void)\n{\n    static int initialized;\n\n    if (initialized)\n        return;\n    initialized = 1;\n\n    writer_register(&default_writer);\n    writer_register(&compact_writer);\n    writer_register(&csv_writer);\n    writer_register(&flat_writer);\n    writer_register(&ini_writer);\n    writer_register(&json_writer);\n    writer_register(&xml_writer);\n}\n\n#define print_fmt(k, f, ...) do {              \\\n    av_bprint_clear(&pbuf);                    \\\n    av_bprintf(&pbuf, f, __VA_ARGS__);         \\\n    writer_print_string(w, k, pbuf.str, 0);    \\\n} while (0)\n\n#define print_int(k, v)         writer_print_integer(w, k, v)\n#define print_q(k, v, s)        writer_print_rational(w, k, v, s)\n#define print_str(k, v)         writer_print_string(w, k, v, 0)\n#define print_str_opt(k, v)     writer_print_string(w, k, v, PRINT_STRING_OPT)\n#define print_str_validate(k, v) writer_print_string(w, k, v, PRINT_STRING_VALIDATE)\n#define print_time(k, v, tb)    writer_print_time(w, k, v, tb, 0)\n#define print_ts(k, v)          writer_print_ts(w, k, v, 0)\n#define print_duration_time(k, v, tb) writer_print_time(w, k, v, tb, 1)\n#define print_duration_ts(k, v)       writer_print_ts(w, k, v, 1)\n#define print_val(k, v, u) do {                                     \\\n    struct unit_value uv;                                           \\\n    uv.val.i = v;                                                   \\\n    uv.unit = u;                                                    \\\n    writer_print_string(w, k, value_string(val_str, sizeof(val_str), uv), 0); \\\n} while (0)\n\n#define print_section_header(s) writer_print_section_header(w, s)\n#define print_section_footer(s) writer_print_section_footer(w, s)\n\n#define REALLOCZ_ARRAY_STREAM(ptr, cur_n, new_n)                        \\\n{                                                                       \\\n    ret = av_reallocp_array(&(ptr), (new_n), sizeof(*(ptr)));           \\\n    if (ret < 0)                                                        \\\n        goto end;                                                       \\\n    memset( (ptr) + (cur_n), 0, ((new_n) - (cur_n)) * sizeof(*(ptr)) ); \\\n}\n\nstatic inline int show_tags(WriterContext *w, AVDictionary *tags, int section_id)\n{\n    AVDictionaryEntry *tag = NULL;\n    int ret = 0;\n\n    if (!tags)\n        return 0;\n    writer_print_section_header(w, section_id);\n\n    while ((tag = av_dict_get(tags, \"\", tag, AV_DICT_IGNORE_SUFFIX))) {\n        if ((ret = print_str_validate(tag->key, tag->value)) < 0)\n            break;\n    }\n    writer_print_section_footer(w);\n\n    return ret;\n}\n\nstatic void print_pkt_side_data(WriterContext *w,\n                                AVCodecParameters *par,\n                                const AVPacketSideData *side_data,\n                                int nb_side_data,\n                                SectionID id_data_list,\n                                SectionID id_data)\n{\n    int i;\n\n    writer_print_section_header(w, id_data_list);\n    for (i = 0; i < nb_side_data; i++) {\n        const AVPacketSideData *sd = &side_data[i];\n        const char *name = av_packet_side_data_name(sd->type);\n\n        writer_print_section_header(w, id_data);\n        print_str(\"side_data_type\", name ? name : \"unknown\");\n        if (sd->type == AV_PKT_DATA_DISPLAYMATRIX && sd->size >= 9*4) {\n            writer_print_integers(w, \"displaymatrix\", sd->data, 9, \" %11d\", 3, 4, 1);\n            print_int(\"rotation\", av_display_rotation_get((int32_t *)sd->data));\n        } else if (sd->type == AV_PKT_DATA_STEREO3D) {\n            const AVStereo3D *stereo = (AVStereo3D *)sd->data;\n            print_str(\"type\", av_stereo3d_type_name(stereo->type));\n            print_int(\"inverted\", !!(stereo->flags & AV_STEREO3D_FLAG_INVERT));\n        } else if (sd->type == AV_PKT_DATA_SPHERICAL) {\n            const AVSphericalMapping *spherical = (AVSphericalMapping *)sd->data;\n            print_str(\"projection\", av_spherical_projection_name(spherical->projection));\n            if (spherical->projection == AV_SPHERICAL_CUBEMAP) {\n                print_int(\"padding\", spherical->padding);\n            } else if (spherical->projection == AV_SPHERICAL_EQUIRECTANGULAR_TILE) {\n                size_t l, t, r, b;\n                av_spherical_tile_bounds(spherical, par->width, par->height,\n                                         &l, &t, &r, &b);\n                print_int(\"bound_left\", l);\n                print_int(\"bound_top\", t);\n                print_int(\"bound_right\", r);\n                print_int(\"bound_bottom\", b);\n            }\n\n            print_int(\"yaw\", (double) spherical->yaw / (1 << 16));\n            print_int(\"pitch\", (double) spherical->pitch / (1 << 16));\n            print_int(\"roll\", (double) spherical->roll / (1 << 16));\n        } else if (sd->type == AV_PKT_DATA_SKIP_SAMPLES && sd->size == 10) {\n            print_int(\"skip_samples\",    AV_RL32(sd->data));\n            print_int(\"discard_padding\", AV_RL32(sd->data + 4));\n            print_int(\"skip_reason\",     AV_RL8(sd->data + 8));\n            print_int(\"discard_reason\",  AV_RL8(sd->data + 9));\n        } else if (sd->type == AV_PKT_DATA_MASTERING_DISPLAY_METADATA) {\n            AVMasteringDisplayMetadata *metadata = (AVMasteringDisplayMetadata *)sd->data;\n\n            if (metadata->has_primaries) {\n                print_q(\"red_x\", metadata->display_primaries[0][0], '/');\n                print_q(\"red_y\", metadata->display_primaries[0][1], '/');\n                print_q(\"green_x\", metadata->display_primaries[1][0], '/');\n                print_q(\"green_y\", metadata->display_primaries[1][1], '/');\n                print_q(\"blue_x\", metadata->display_primaries[2][0], '/');\n                print_q(\"blue_y\", metadata->display_primaries[2][1], '/');\n\n                print_q(\"white_point_x\", metadata->white_point[0], '/');\n                print_q(\"white_point_y\", metadata->white_point[1], '/');\n            }\n\n            if (metadata->has_luminance) {\n                print_q(\"min_luminance\", metadata->min_luminance, '/');\n                print_q(\"max_luminance\", metadata->max_luminance, '/');\n            }\n        } else if (sd->type == AV_PKT_DATA_CONTENT_LIGHT_LEVEL) {\n            AVContentLightMetadata *metadata = (AVContentLightMetadata *)sd->data;\n            print_int(\"max_content\", metadata->MaxCLL);\n            print_int(\"max_average\", metadata->MaxFALL);\n        }\n        writer_print_section_footer(w);\n    }\n    writer_print_section_footer(w);\n}\n\nstatic void print_primaries(WriterContext *w, enum AVColorPrimaries color_primaries)\n{\n    const char *val = av_color_primaries_name(color_primaries);\n    if (!val || color_primaries == AVCOL_PRI_UNSPECIFIED) {\n        print_str_opt(\"color_primaries\", \"unknown\");\n    } else {\n        print_str(\"color_primaries\", val);\n    }\n}\n\nstatic void clear_log(int need_lock)\n{\n    int i;\n\n    if (need_lock)\n        pthread_mutex_lock(&log_mutex);\n    for (i=0; i<log_buffer_size; i++) {\n        av_freep(&log_buffer[i].context_name);\n        av_freep(&log_buffer[i].parent_name);\n        av_freep(&log_buffer[i].log_message);\n    }\n    log_buffer_size = 0;\n    if(need_lock)\n        pthread_mutex_unlock(&log_mutex);\n}\n\nstatic int show_log(WriterContext *w, int section_ids, int section_id, int log_level)\n{\n    int i;\n    pthread_mutex_lock(&log_mutex);\n    if (!log_buffer_size) {\n        pthread_mutex_unlock(&log_mutex);\n        return 0;\n    }\n    writer_print_section_header(w, section_ids);\n\n    for (i=0; i<log_buffer_size; i++) {\n        if (log_buffer[i].log_level <= log_level) {\n            writer_print_section_header(w, section_id);\n            print_str(\"context\", log_buffer[i].context_name);\n            print_int(\"level\", log_buffer[i].log_level);\n            print_int(\"category\", log_buffer[i].category);\n            if (log_buffer[i].parent_name) {\n                print_str(\"parent_context\", log_buffer[i].parent_name);\n                print_int(\"parent_category\", log_buffer[i].parent_category);\n            } else {\n                print_str_opt(\"parent_context\", \"N/A\");\n                print_str_opt(\"parent_category\", \"N/A\");\n            }\n            print_str(\"message\", log_buffer[i].log_message);\n            writer_print_section_footer(w);\n        }\n    }\n    clear_log(0);\n    pthread_mutex_unlock(&log_mutex);\n\n    writer_print_section_footer(w);\n\n    return 0;\n}\n\nstatic void show_packet(WriterContext *w, InputFile *ifile, AVPacket *pkt, int packet_idx)\n{\n    char val_str[128];\n    AVStream *st = ifile->streams[pkt->stream_index].st;\n    AVBPrint pbuf;\n    const char *s;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, SECTION_ID_PACKET);\n\n    s = av_get_media_type_string(st->codecpar->codec_type);\n    if (s) print_str    (\"codec_type\", s);\n    else   print_str_opt(\"codec_type\", \"unknown\");\n    print_int(\"stream_index\",     pkt->stream_index);\n    print_ts  (\"pts\",             pkt->pts);\n    print_time(\"pts_time\",        pkt->pts, &st->time_base);\n    print_ts  (\"dts\",             pkt->dts);\n    print_time(\"dts_time\",        pkt->dts, &st->time_base);\n    print_duration_ts(\"duration\",        pkt->duration);\n    print_duration_time(\"duration_time\", pkt->duration, &st->time_base);\n    print_duration_ts(\"convergence_duration\", pkt->convergence_duration);\n    print_duration_time(\"convergence_duration_time\", pkt->convergence_duration, &st->time_base);\n    print_val(\"size\",             pkt->size, unit_byte_str);\n    if (pkt->pos != -1) print_fmt    (\"pos\", \"%\"PRId64, pkt->pos);\n    else                print_str_opt(\"pos\", \"N/A\");\n    print_fmt(\"flags\", \"%c%c\",      pkt->flags & AV_PKT_FLAG_KEY ? 'K' : '_',\n              pkt->flags & AV_PKT_FLAG_DISCARD ? 'D' : '_');\n\n    if (pkt->side_data_elems) {\n        int size;\n        const uint8_t *side_metadata;\n\n        side_metadata = av_packet_get_side_data(pkt, AV_PKT_DATA_STRINGS_METADATA, &size);\n        if (side_metadata && size && do_show_packet_tags) {\n            AVDictionary *dict = NULL;\n            if (av_packet_unpack_dictionary(side_metadata, size, &dict) >= 0)\n                show_tags(w, dict, SECTION_ID_PACKET_TAGS);\n            av_dict_free(&dict);\n        }\n\n        print_pkt_side_data(w, st->codecpar, pkt->side_data, pkt->side_data_elems,\n                            SECTION_ID_PACKET_SIDE_DATA_LIST,\n                            SECTION_ID_PACKET_SIDE_DATA);\n    }\n\n    if (do_show_data)\n        writer_print_data(w, \"data\", pkt->data, pkt->size);\n    writer_print_data_hash(w, \"data_hash\", pkt->data, pkt->size);\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n}\n\nstatic void show_subtitle(WriterContext *w, AVSubtitle *sub, AVStream *stream,\n                          AVFormatContext *fmt_ctx)\n{\n    AVBPrint pbuf;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, SECTION_ID_SUBTITLE);\n\n    print_str (\"media_type\",         \"subtitle\");\n    print_ts  (\"pts\",                 sub->pts);\n    print_time(\"pts_time\",            sub->pts, &AV_TIME_BASE_Q);\n    print_int (\"format\",              sub->format);\n    print_int (\"start_display_time\",  sub->start_display_time);\n    print_int (\"end_display_time\",    sub->end_display_time);\n    print_int (\"num_rects\",           sub->num_rects);\n\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n}\n\nstatic void show_frame(WriterContext *w, AVFrame *frame, AVStream *stream,\n                       AVFormatContext *fmt_ctx)\n{\n    AVBPrint pbuf;\n    char val_str[128];\n    const char *s;\n    int i;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, SECTION_ID_FRAME);\n\n    s = av_get_media_type_string(stream->codecpar->codec_type);\n    if (s) print_str    (\"media_type\", s);\n    else   print_str_opt(\"media_type\", \"unknown\");\n    print_int(\"stream_index\",           stream->index);\n    print_int(\"key_frame\",              frame->key_frame);\n    print_ts  (\"pkt_pts\",               frame->pts);\n    print_time(\"pkt_pts_time\",          frame->pts, &stream->time_base);\n    print_ts  (\"pkt_dts\",               frame->pkt_dts);\n    print_time(\"pkt_dts_time\",          frame->pkt_dts, &stream->time_base);\n    print_ts  (\"best_effort_timestamp\", frame->best_effort_timestamp);\n    print_time(\"best_effort_timestamp_time\", frame->best_effort_timestamp, &stream->time_base);\n    print_duration_ts  (\"pkt_duration\",      frame->pkt_duration);\n    print_duration_time(\"pkt_duration_time\", frame->pkt_duration, &stream->time_base);\n    if (frame->pkt_pos != -1) print_fmt    (\"pkt_pos\", \"%\"PRId64, frame->pkt_pos);\n    else                      print_str_opt(\"pkt_pos\", \"N/A\");\n    if (frame->pkt_size != -1) print_val    (\"pkt_size\", frame->pkt_size, unit_byte_str);\n    else                       print_str_opt(\"pkt_size\", \"N/A\");\n\n    switch (stream->codecpar->codec_type) {\n        AVRational sar;\n\n    case AVMEDIA_TYPE_VIDEO:\n        print_int(\"width\",                  frame->width);\n        print_int(\"height\",                 frame->height);\n        s = av_get_pix_fmt_name(frame->format);\n        if (s) print_str    (\"pix_fmt\", s);\n        else   print_str_opt(\"pix_fmt\", \"unknown\");\n        sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, frame);\n        if (sar.num) {\n            print_q(\"sample_aspect_ratio\", sar, ':');\n        } else {\n            print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n        }\n        print_fmt(\"pict_type\",              \"%c\", av_get_picture_type_char(frame->pict_type));\n        print_int(\"coded_picture_number\",   frame->coded_picture_number);\n        print_int(\"display_picture_number\", frame->display_picture_number);\n        print_int(\"interlaced_frame\",       frame->interlaced_frame);\n        print_int(\"top_field_first\",        frame->top_field_first);\n        print_int(\"repeat_pict\",            frame->repeat_pict);\n\n        if (frame->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str(\"color_range\", av_color_range_name(frame->color_range));\n        else\n            print_str_opt(\"color_range\", av_color_range_name(frame->color_range));\n\n        if (frame->colorspace != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(frame->colorspace));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(frame->colorspace));\n\n        print_primaries(w, frame->color_primaries);\n\n        if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n\n        if (frame->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n        s = av_get_sample_fmt_name(frame->format);\n        if (s) print_str    (\"sample_fmt\", s);\n        else   print_str_opt(\"sample_fmt\", \"unknown\");\n        print_int(\"nb_samples\",         frame->nb_samples);\n        print_int(\"channels\", frame->channels);\n        if (frame->channel_layout) {\n            av_bprint_clear(&pbuf);\n            av_bprint_channel_layout(&pbuf, frame->channels,\n                                     frame->channel_layout);\n            print_str    (\"channel_layout\", pbuf.str);\n        } else\n            print_str_opt(\"channel_layout\", \"unknown\");\n        break;\n    }\n    if (do_show_frame_tags)\n        show_tags(w, frame->metadata, SECTION_ID_FRAME_TAGS);\n    if (do_show_log)\n        show_log(w, SECTION_ID_FRAME_LOGS, SECTION_ID_FRAME_LOG, do_show_log);\n    if (frame->nb_side_data) {\n        writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA_LIST);\n        for (i = 0; i < frame->nb_side_data; i++) {\n            AVFrameSideData *sd = frame->side_data[i];\n            const char *name;\n\n            writer_print_section_header(w, SECTION_ID_FRAME_SIDE_DATA);\n            name = av_frame_side_data_name(sd->type);\n            print_str(\"side_data_type\", name ? name : \"unknown\");\n            if (sd->type == AV_FRAME_DATA_DISPLAYMATRIX && sd->size >= 9*4) {\n                writer_print_integers(w, \"displaymatrix\", sd->data, 9, \" %11d\", 3, 4, 1);\n                print_int(\"rotation\", av_display_rotation_get((int32_t *)sd->data));\n            } else if (sd->type == AV_FRAME_DATA_GOP_TIMECODE && sd->size >= 8) {\n                char tcbuf[AV_TIMECODE_STR_SIZE];\n                av_timecode_make_mpeg_tc_string(tcbuf, *(int64_t *)(sd->data));\n                print_str(\"timecode\", tcbuf);\n            } else if (sd->type == AV_FRAME_DATA_MASTERING_DISPLAY_METADATA) {\n                AVMasteringDisplayMetadata *metadata = (AVMasteringDisplayMetadata *)sd->data;\n\n                if (metadata->has_primaries) {\n                    print_q(\"red_x\", metadata->display_primaries[0][0], '/');\n                    print_q(\"red_y\", metadata->display_primaries[0][1], '/');\n                    print_q(\"green_x\", metadata->display_primaries[1][0], '/');\n                    print_q(\"green_y\", metadata->display_primaries[1][1], '/');\n                    print_q(\"blue_x\", metadata->display_primaries[2][0], '/');\n                    print_q(\"blue_y\", metadata->display_primaries[2][1], '/');\n\n                    print_q(\"white_point_x\", metadata->white_point[0], '/');\n                    print_q(\"white_point_y\", metadata->white_point[1], '/');\n                }\n\n                if (metadata->has_luminance) {\n                    print_q(\"min_luminance\", metadata->min_luminance, '/');\n                    print_q(\"max_luminance\", metadata->max_luminance, '/');\n                }\n            } else if (sd->type == AV_FRAME_DATA_CONTENT_LIGHT_LEVEL) {\n                AVContentLightMetadata *metadata = (AVContentLightMetadata *)sd->data;\n                print_int(\"max_content\", metadata->MaxCLL);\n                print_int(\"max_average\", metadata->MaxFALL);\n            } else if (sd->type == AV_FRAME_DATA_ICC_PROFILE) {\n                AVDictionaryEntry *tag = av_dict_get(sd->metadata, \"name\", NULL, AV_DICT_MATCH_CASE);\n                if (tag)\n                    print_str(tag->key, tag->value);\n                print_int(\"size\", sd->size);\n            }\n            writer_print_section_footer(w);\n        }\n        writer_print_section_footer(w);\n    }\n\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n}\n\nstatic av_always_inline int process_frame(WriterContext *w,\n                                          InputFile *ifile,\n                                          AVFrame *frame, AVPacket *pkt,\n                                          int *packet_new)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    AVCodecContext *dec_ctx = ifile->streams[pkt->stream_index].dec_ctx;\n    AVCodecParameters *par = ifile->streams[pkt->stream_index].st->codecpar;\n    AVSubtitle sub;\n    int ret = 0, got_frame = 0;\n\n    clear_log(1);\n    if (dec_ctx && dec_ctx->codec) {\n        switch (par->codec_type) {\n        case AVMEDIA_TYPE_VIDEO:\n        case AVMEDIA_TYPE_AUDIO:\n            if (*packet_new) {\n                ret = avcodec_send_packet(dec_ctx, pkt);\n                if (ret == AVERROR(EAGAIN)) {\n                    ret = 0;\n                } else if (ret >= 0 || ret == AVERROR_EOF) {\n                    ret = 0;\n                    *packet_new = 0;\n                }\n            }\n            if (ret >= 0) {\n                ret = avcodec_receive_frame(dec_ctx, frame);\n                if (ret >= 0) {\n                    got_frame = 1;\n                } else if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {\n                    ret = 0;\n                }\n            }\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n            ret = avcodec_decode_subtitle2(dec_ctx, &sub, &got_frame, pkt);\n            *packet_new = 0;\n            break;\n        default:\n            *packet_new = 0;\n        }\n    } else {\n        *packet_new = 0;\n    }\n\n    if (ret < 0)\n        return ret;\n    if (got_frame) {\n        int is_sub = (par->codec_type == AVMEDIA_TYPE_SUBTITLE);\n        nb_streams_frames[pkt->stream_index]++;\n        if (do_show_frames)\n            if (is_sub)\n                show_subtitle(w, &sub, ifile->streams[pkt->stream_index].st, fmt_ctx);\n            else\n                show_frame(w, frame, ifile->streams[pkt->stream_index].st, fmt_ctx);\n        if (is_sub)\n            avsubtitle_free(&sub);\n    }\n    return got_frame || *packet_new;\n}\n\nstatic void log_read_interval(const ReadInterval *interval, void *log_ctx, int log_level)\n{\n    av_log(log_ctx, log_level, \"id:%d\", interval->id);\n\n    if (interval->has_start) {\n        av_log(log_ctx, log_level, \" start:%s%s\", interval->start_is_offset ? \"+\" : \"\",\n               av_ts2timestr(interval->start, &AV_TIME_BASE_Q));\n    } else {\n        av_log(log_ctx, log_level, \" start:N/A\");\n    }\n\n    if (interval->has_end) {\n        av_log(log_ctx, log_level, \" end:%s\", interval->end_is_offset ? \"+\" : \"\");\n        if (interval->duration_frames)\n            av_log(log_ctx, log_level, \"#%\"PRId64, interval->end);\n        else\n            av_log(log_ctx, log_level, \"%s\", av_ts2timestr(interval->end, &AV_TIME_BASE_Q));\n    } else {\n        av_log(log_ctx, log_level, \" end:N/A\");\n    }\n\n    av_log(log_ctx, log_level, \"\\n\");\n}\n\nstatic int read_interval_packets(WriterContext *w, InputFile *ifile,\n                                 const ReadInterval *interval, int64_t *cur_ts)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    AVPacket pkt;\n    AVFrame *frame = NULL;\n    int ret = 0, i = 0, frame_count = 0;\n    int64_t start = -INT64_MAX, end = interval->end;\n    int has_start = 0, has_end = interval->has_end && !interval->end_is_offset;\n\n    av_init_packet(&pkt);\n\n    av_log(NULL, AV_LOG_VERBOSE, \"Processing read interval \");\n    log_read_interval(interval, NULL, AV_LOG_VERBOSE);\n\n    if (interval->has_start) {\n        int64_t target;\n        if (interval->start_is_offset) {\n            if (*cur_ts == AV_NOPTS_VALUE) {\n                av_log(NULL, AV_LOG_ERROR,\n                       \"Could not seek to relative position since current \"\n                       \"timestamp is not defined\\n\");\n                ret = AVERROR(EINVAL);\n                goto end;\n            }\n            target = *cur_ts + interval->start;\n        } else {\n            target = interval->start;\n        }\n\n        av_log(NULL, AV_LOG_VERBOSE, \"Seeking to read interval start point %s\\n\",\n               av_ts2timestr(target, &AV_TIME_BASE_Q));\n        if ((ret = avformat_seek_file(fmt_ctx, -1, -INT64_MAX, target, INT64_MAX, 0)) < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Could not seek to position %\"PRId64\": %s\\n\",\n                   interval->start, av_err2str(ret));\n            goto end;\n        }\n    }\n\n    frame = av_frame_alloc();\n    if (!frame) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n    while (!av_read_frame(fmt_ctx, &pkt)) {\n        if (ifile->nb_streams > nb_streams) {\n            REALLOCZ_ARRAY_STREAM(nb_streams_frames,  nb_streams, fmt_ctx->nb_streams);\n            REALLOCZ_ARRAY_STREAM(nb_streams_packets, nb_streams, fmt_ctx->nb_streams);\n            REALLOCZ_ARRAY_STREAM(selected_streams,   nb_streams, fmt_ctx->nb_streams);\n            nb_streams = ifile->nb_streams;\n        }\n        if (selected_streams[pkt.stream_index]) {\n            AVRational tb = ifile->streams[pkt.stream_index].st->time_base;\n\n            if (pkt.pts != AV_NOPTS_VALUE)\n                *cur_ts = av_rescale_q(pkt.pts, tb, AV_TIME_BASE_Q);\n\n            if (!has_start && *cur_ts != AV_NOPTS_VALUE) {\n                start = *cur_ts;\n                has_start = 1;\n            }\n\n            if (has_start && !has_end && interval->end_is_offset) {\n                end = start + interval->end;\n                has_end = 1;\n            }\n\n            if (interval->end_is_offset && interval->duration_frames) {\n                if (frame_count >= interval->end)\n                    break;\n            } else if (has_end && *cur_ts != AV_NOPTS_VALUE && *cur_ts >= end) {\n                break;\n            }\n\n            frame_count++;\n            if (do_read_packets) {\n                if (do_show_packets)\n                    show_packet(w, ifile, &pkt, i++);\n                nb_streams_packets[pkt.stream_index]++;\n            }\n            if (do_read_frames) {\n                int packet_new = 1;\n                while (process_frame(w, ifile, frame, &pkt, &packet_new) > 0);\n            }\n        }\n        av_packet_unref(&pkt);\n    }\n    av_init_packet(&pkt);\n    pkt.data = NULL;\n    pkt.size = 0;\n    //Flush remaining frames that are cached in the decoder\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n        pkt.stream_index = i;\n        if (do_read_frames)\n            while (process_frame(w, ifile, frame, &pkt, &(int){1}) > 0);\n    }\n\nend:\n    av_frame_free(&frame);\n    if (ret < 0) {\n        av_log(NULL, AV_LOG_ERROR, \"Could not read packets in interval \");\n        log_read_interval(interval, NULL, AV_LOG_ERROR);\n    }\n    return ret;\n}\n\nstatic int read_packets(WriterContext *w, InputFile *ifile)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    int i, ret = 0;\n    int64_t cur_ts = fmt_ctx->start_time;\n\n    if (read_intervals_nb == 0) {\n        ReadInterval interval = (ReadInterval) { .has_start = 0, .has_end = 0 };\n        ret = read_interval_packets(w, ifile, &interval, &cur_ts);\n    } else {\n        for (i = 0; i < read_intervals_nb; i++) {\n            ret = read_interval_packets(w, ifile, &read_intervals[i], &cur_ts);\n            if (ret < 0)\n                break;\n        }\n    }\n\n    return ret;\n}\n\nstatic int show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, InputStream *ist, int in_program)\n{\n    AVStream *stream = ist->st;\n    AVCodecParameters *par;\n    AVCodecContext *dec_ctx;\n    char val_str[128];\n    const char *s;\n    AVRational sar, dar;\n    AVBPrint pbuf;\n    const AVCodecDescriptor *cd;\n    int ret = 0;\n    const char *profile = NULL;\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);\n\n    print_int(\"index\", stream->index);\n\n    par     = stream->codecpar;\n    dec_ctx = ist->dec_ctx;\n    if (cd = avcodec_descriptor_get(par->codec_id)) {\n        print_str(\"codec_name\", cd->name);\n        if (!do_bitexact) {\n            print_str(\"codec_long_name\",\n                      cd->long_name ? cd->long_name : \"unknown\");\n        }\n    } else {\n        print_str_opt(\"codec_name\", \"unknown\");\n        if (!do_bitexact) {\n            print_str_opt(\"codec_long_name\", \"unknown\");\n        }\n    }\n\n    if (!do_bitexact && (profile = avcodec_profile_name(par->codec_id, par->profile)))\n        print_str(\"profile\", profile);\n    else {\n        if (par->profile != FF_PROFILE_UNKNOWN) {\n            char profile_num[12];\n            snprintf(profile_num, sizeof(profile_num), \"%d\", par->profile);\n            print_str(\"profile\", profile_num);\n        } else\n            print_str_opt(\"profile\", \"unknown\");\n    }\n\n    s = av_get_media_type_string(par->codec_type);\n    if (s) print_str    (\"codec_type\", s);\n    else   print_str_opt(\"codec_type\", \"unknown\");\n#if FF_API_LAVF_AVCTX\n    if (dec_ctx)\n        print_q(\"codec_time_base\", dec_ctx->time_base, '/');\n#endif\n\n    /* print AVI/FourCC tag */\n    print_str(\"codec_tag_string\",    av_fourcc2str(par->codec_tag));\n    print_fmt(\"codec_tag\", \"0x%04\"PRIx32, par->codec_tag);\n\n    switch (par->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        print_int(\"width\",        par->width);\n        print_int(\"height\",       par->height);\n        if (dec_ctx) {\n            print_int(\"coded_width\",  dec_ctx->coded_width);\n            print_int(\"coded_height\", dec_ctx->coded_height);\n        }\n        print_int(\"has_b_frames\", par->video_delay);\n        sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL);\n        if (sar.den) {\n            print_q(\"sample_aspect_ratio\", sar, ':');\n            av_reduce(&dar.num, &dar.den,\n                      par->width  * sar.num,\n                      par->height * sar.den,\n                      1024*1024);\n            print_q(\"display_aspect_ratio\", dar, ':');\n        } else {\n            print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n            print_str_opt(\"display_aspect_ratio\", \"N/A\");\n        }\n        s = av_get_pix_fmt_name(par->format);\n        if (s) print_str    (\"pix_fmt\", s);\n        else   print_str_opt(\"pix_fmt\", \"unknown\");\n        print_int(\"level\",   par->level);\n        if (par->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str    (\"color_range\", av_color_range_name(par->color_range));\n        else\n            print_str_opt(\"color_range\", \"N/A\");\n\n        if (par->color_space != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(par->color_space));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(par->color_space));\n\n        if (par->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(par->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(par->color_trc));\n\n        print_primaries(w, par->color_primaries);\n\n        if (par->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(par->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(par->chroma_location));\n\n        if (par->field_order == AV_FIELD_PROGRESSIVE)\n            print_str(\"field_order\", \"progressive\");\n        else if (par->field_order == AV_FIELD_TT)\n            print_str(\"field_order\", \"tt\");\n        else if (par->field_order == AV_FIELD_BB)\n            print_str(\"field_order\", \"bb\");\n        else if (par->field_order == AV_FIELD_TB)\n            print_str(\"field_order\", \"tb\");\n        else if (par->field_order == AV_FIELD_BT)\n            print_str(\"field_order\", \"bt\");\n        else\n            print_str_opt(\"field_order\", \"unknown\");\n\n#if FF_API_PRIVATE_OPT\n        if (dec_ctx && dec_ctx->timecode_frame_start >= 0) {\n            char tcbuf[AV_TIMECODE_STR_SIZE];\n            av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start);\n            print_str(\"timecode\", tcbuf);\n        } else {\n            print_str_opt(\"timecode\", \"N/A\");\n        }\n#endif\n        if (dec_ctx)\n            print_int(\"refs\", dec_ctx->refs);\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n        s = av_get_sample_fmt_name(par->format);\n        if (s) print_str    (\"sample_fmt\", s);\n        else   print_str_opt(\"sample_fmt\", \"unknown\");\n        print_val(\"sample_rate\",     par->sample_rate, unit_hertz_str);\n        print_int(\"channels\",        par->channels);\n\n        if (par->channel_layout) {\n            av_bprint_clear(&pbuf);\n            av_bprint_channel_layout(&pbuf, par->channels, par->channel_layout);\n            print_str    (\"channel_layout\", pbuf.str);\n        } else {\n            print_str_opt(\"channel_layout\", \"unknown\");\n        }\n\n        print_int(\"bits_per_sample\", av_get_bits_per_sample(par->codec_id));\n        break;\n\n    case AVMEDIA_TYPE_SUBTITLE:\n        if (par->width)\n            print_int(\"width\",       par->width);\n        else\n            print_str_opt(\"width\",   \"N/A\");\n        if (par->height)\n            print_int(\"height\",      par->height);\n        else\n            print_str_opt(\"height\",  \"N/A\");\n        break;\n    }\n\n    if (dec_ctx && dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) {\n        const AVOption *opt = NULL;\n        while (opt = av_opt_next(dec_ctx->priv_data,opt)) {\n            uint8_t *str;\n            if (opt->flags) continue;\n            if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {\n                print_str(opt->name, str);\n                av_free(str);\n            }\n        }\n    }\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt    (\"id\", \"0x%x\", stream->id);\n    else                                          print_str_opt(\"id\", \"N/A\");\n    print_q(\"r_frame_rate\",   stream->r_frame_rate,   '/');\n    print_q(\"avg_frame_rate\", stream->avg_frame_rate, '/');\n    print_q(\"time_base\",      stream->time_base,      '/');\n    print_ts  (\"start_pts\",   stream->start_time);\n    print_time(\"start_time\",  stream->start_time, &stream->time_base);\n    print_ts  (\"duration_ts\", stream->duration);\n    print_time(\"duration\",    stream->duration, &stream->time_base);\n    if (par->bit_rate > 0)     print_val    (\"bit_rate\", par->bit_rate, unit_bit_per_second_str);\n    else                       print_str_opt(\"bit_rate\", \"N/A\");\n#if FF_API_LAVF_AVCTX\n    if (stream->codec->rc_max_rate > 0) print_val (\"max_bit_rate\", stream->codec->rc_max_rate, unit_bit_per_second_str);\n    else                                print_str_opt(\"max_bit_rate\", \"N/A\");\n#endif\n    if (dec_ctx && dec_ctx->bits_per_raw_sample > 0) print_fmt(\"bits_per_raw_sample\", \"%d\", dec_ctx->bits_per_raw_sample);\n    else                                             print_str_opt(\"bits_per_raw_sample\", \"N/A\");\n    if (stream->nb_frames) print_fmt    (\"nb_frames\", \"%\"PRId64, stream->nb_frames);\n    else                   print_str_opt(\"nb_frames\", \"N/A\");\n    if (nb_streams_frames[stream_idx])  print_fmt    (\"nb_read_frames\", \"%\"PRIu64, nb_streams_frames[stream_idx]);\n    else                                print_str_opt(\"nb_read_frames\", \"N/A\");\n    if (nb_streams_packets[stream_idx]) print_fmt    (\"nb_read_packets\", \"%\"PRIu64, nb_streams_packets[stream_idx]);\n    else                                print_str_opt(\"nb_read_packets\", \"N/A\");\n    if (do_show_data)\n        writer_print_data(w, \"extradata\", par->extradata,\n                                          par->extradata_size);\n    writer_print_data_hash(w, \"extradata_hash\", par->extradata,\n                                                par->extradata_size);\n\n    /* Print disposition information */\n#define PRINT_DISPOSITION(flagname, name) do {                                \\\n        print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \\\n    } while (0)\n\n    if (do_show_stream_disposition) {\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION);\n    PRINT_DISPOSITION(DEFAULT,          \"default\");\n    PRINT_DISPOSITION(DUB,              \"dub\");\n    PRINT_DISPOSITION(ORIGINAL,         \"original\");\n    PRINT_DISPOSITION(COMMENT,          \"comment\");\n    PRINT_DISPOSITION(LYRICS,           \"lyrics\");\n    PRINT_DISPOSITION(KARAOKE,          \"karaoke\");\n    PRINT_DISPOSITION(FORCED,           \"forced\");\n    PRINT_DISPOSITION(HEARING_IMPAIRED, \"hearing_impaired\");\n    PRINT_DISPOSITION(VISUAL_IMPAIRED,  \"visual_impaired\");\n    PRINT_DISPOSITION(CLEAN_EFFECTS,    \"clean_effects\");\n    PRINT_DISPOSITION(ATTACHED_PIC,     \"attached_pic\");\n    PRINT_DISPOSITION(TIMED_THUMBNAILS, \"timed_thumbnails\");\n    writer_print_section_footer(w);\n    }\n\n    if (do_show_stream_tags)\n        ret = show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS);\n\n    if (stream->nb_side_data) {\n        print_pkt_side_data(w, stream->codecpar, stream->side_data, stream->nb_side_data,\n                            SECTION_ID_STREAM_SIDE_DATA_LIST,\n                            SECTION_ID_STREAM_SIDE_DATA);\n    }\n\n    writer_print_section_footer(w);\n    av_bprint_finalize(&pbuf, NULL);\n    fflush(stdout);\n\n    return ret;\n}\n\nstatic int show_streams(WriterContext *w, InputFile *ifile)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    int i, ret = 0;\n\n    writer_print_section_header(w, SECTION_ID_STREAMS);\n    for (i = 0; i < ifile->nb_streams; i++)\n        if (selected_streams[i]) {\n            ret = show_stream(w, fmt_ctx, i, &ifile->streams[i], 0);\n            if (ret < 0)\n                break;\n        }\n    writer_print_section_footer(w);\n\n    return ret;\n}\n\nstatic int show_program(WriterContext *w, InputFile *ifile, AVProgram *program)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    int i, ret = 0;\n\n    writer_print_section_header(w, SECTION_ID_PROGRAM);\n    print_int(\"program_id\", program->id);\n    print_int(\"program_num\", program->program_num);\n    print_int(\"nb_streams\", program->nb_stream_indexes);\n    print_int(\"pmt_pid\", program->pmt_pid);\n    print_int(\"pcr_pid\", program->pcr_pid);\n    print_ts(\"start_pts\", program->start_time);\n    print_time(\"start_time\", program->start_time, &AV_TIME_BASE_Q);\n    print_ts(\"end_pts\", program->end_time);\n    print_time(\"end_time\", program->end_time, &AV_TIME_BASE_Q);\n    if (do_show_program_tags)\n        ret = show_tags(w, program->metadata, SECTION_ID_PROGRAM_TAGS);\n    if (ret < 0)\n        goto end;\n\n    writer_print_section_header(w, SECTION_ID_PROGRAM_STREAMS);\n    for (i = 0; i < program->nb_stream_indexes; i++) {\n        if (selected_streams[program->stream_index[i]]) {\n            ret = show_stream(w, fmt_ctx, program->stream_index[i], &ifile->streams[program->stream_index[i]], 1);\n            if (ret < 0)\n                break;\n        }\n    }\n    writer_print_section_footer(w);\n\nend:\n    writer_print_section_footer(w);\n    return ret;\n}\n\nstatic int show_programs(WriterContext *w, InputFile *ifile)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    int i, ret = 0;\n\n    writer_print_section_header(w, SECTION_ID_PROGRAMS);\n    for (i = 0; i < fmt_ctx->nb_programs; i++) {\n        AVProgram *program = fmt_ctx->programs[i];\n        if (!program)\n            continue;\n        ret = show_program(w, ifile, program);\n        if (ret < 0)\n            break;\n    }\n    writer_print_section_footer(w);\n    return ret;\n}\n\nstatic int show_chapters(WriterContext *w, InputFile *ifile)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    int i, ret = 0;\n\n    writer_print_section_header(w, SECTION_ID_CHAPTERS);\n    for (i = 0; i < fmt_ctx->nb_chapters; i++) {\n        AVChapter *chapter = fmt_ctx->chapters[i];\n\n        writer_print_section_header(w, SECTION_ID_CHAPTER);\n        print_int(\"id\", chapter->id);\n        print_q  (\"time_base\", chapter->time_base, '/');\n        print_int(\"start\", chapter->start);\n        print_time(\"start_time\", chapter->start, &chapter->time_base);\n        print_int(\"end\", chapter->end);\n        print_time(\"end_time\", chapter->end, &chapter->time_base);\n        if (do_show_chapter_tags)\n            ret = show_tags(w, chapter->metadata, SECTION_ID_CHAPTER_TAGS);\n        writer_print_section_footer(w);\n    }\n    writer_print_section_footer(w);\n\n    return ret;\n}\n\nstatic int show_format(WriterContext *w, InputFile *ifile)\n{\n    AVFormatContext *fmt_ctx = ifile->fmt_ctx;\n    char val_str[128];\n    int64_t size = fmt_ctx->pb ? avio_size(fmt_ctx->pb) : -1;\n    int ret = 0;\n\n    writer_print_section_header(w, SECTION_ID_FORMAT);\n    print_str_validate(\"filename\", fmt_ctx->filename);\n    print_int(\"nb_streams\",       fmt_ctx->nb_streams);\n    print_int(\"nb_programs\",      fmt_ctx->nb_programs);\n    print_str(\"format_name\",      fmt_ctx->iformat->name);\n    if (!do_bitexact) {\n        if (fmt_ctx->iformat->long_name) print_str    (\"format_long_name\", fmt_ctx->iformat->long_name);\n        else                             print_str_opt(\"format_long_name\", \"unknown\");\n    }\n    print_time(\"start_time\",      fmt_ctx->start_time, &AV_TIME_BASE_Q);\n    print_time(\"duration\",        fmt_ctx->duration,   &AV_TIME_BASE_Q);\n    if (size >= 0) print_val    (\"size\", size, unit_byte_str);\n    else           print_str_opt(\"size\", \"N/A\");\n    if (fmt_ctx->bit_rate > 0) print_val    (\"bit_rate\", fmt_ctx->bit_rate, unit_bit_per_second_str);\n    else                       print_str_opt(\"bit_rate\", \"N/A\");\n    print_int(\"probe_score\", av_format_get_probe_score(fmt_ctx));\n    if (do_show_format_tags)\n        ret = show_tags(w, fmt_ctx->metadata, SECTION_ID_FORMAT_TAGS);\n\n    writer_print_section_footer(w);\n    fflush(stdout);\n    return ret;\n}\n\nstatic void show_error(WriterContext *w, int err)\n{\n    char errbuf[128];\n    const char *errbuf_ptr = errbuf;\n\n    if (av_strerror(err, errbuf, sizeof(errbuf)) < 0)\n        errbuf_ptr = strerror(AVUNERROR(err));\n\n    writer_print_section_header(w, SECTION_ID_ERROR);\n    print_int(\"code\", err);\n    print_str(\"string\", errbuf_ptr);\n    writer_print_section_footer(w);\n}\n\nstatic int open_input_file(InputFile *ifile, const char *filename)\n{\n    int err, i;\n    AVFormatContext *fmt_ctx = NULL;\n    AVDictionaryEntry *t;\n    int scan_all_pmts_set = 0;\n\n    fmt_ctx = avformat_alloc_context();\n    if (!fmt_ctx) {\n        print_error(filename, AVERROR(ENOMEM));\n        exit_program(1);\n    }\n\n    fmt_ctx->flags |= AVFMT_FLAG_KEEP_SIDE_DATA;\n\n    if (!av_dict_get(format_opts, \"scan_all_pmts\", NULL, AV_DICT_MATCH_CASE)) {\n        av_dict_set(&format_opts, \"scan_all_pmts\", \"1\", AV_DICT_DONT_OVERWRITE);\n        scan_all_pmts_set = 1;\n    }\n    if ((err = avformat_open_input(&fmt_ctx, filename,\n                                   iformat, &format_opts)) < 0) {\n        print_error(filename, err);\n        return err;\n    }\n    ifile->fmt_ctx = fmt_ctx;\n    if (scan_all_pmts_set)\n        av_dict_set(&format_opts, \"scan_all_pmts\", NULL, AV_DICT_MATCH_CASE);\n    if ((t = av_dict_get(format_opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n        av_log(NULL, AV_LOG_ERROR, \"Option %s not found.\\n\", t->key);\n        return AVERROR_OPTION_NOT_FOUND;\n    }\n\n    if (find_stream_info) {\n        AVDictionary **opts = setup_find_stream_info_opts(fmt_ctx, codec_opts);\n        int orig_nb_streams = fmt_ctx->nb_streams;\n\n        err = avformat_find_stream_info(fmt_ctx, opts);\n\n        for (i = 0; i < orig_nb_streams; i++)\n            av_dict_free(&opts[i]);\n        av_freep(&opts);\n\n        if (err < 0) {\n            print_error(filename, err);\n            return err;\n        }\n    }\n\n    av_dump_format(fmt_ctx, 0, filename, 0);\n\n    ifile->streams = av_mallocz_array(fmt_ctx->nb_streams,\n                                      sizeof(*ifile->streams));\n    if (!ifile->streams)\n        exit(1);\n    ifile->nb_streams = fmt_ctx->nb_streams;\n\n    /* bind a decoder to each input stream */\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n        InputStream *ist = &ifile->streams[i];\n        AVStream *stream = fmt_ctx->streams[i];\n        AVCodec *codec;\n\n        ist->st = stream;\n\n        if (stream->codecpar->codec_id == AV_CODEC_ID_PROBE) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"Failed to probe codec for input stream %d\\n\",\n                    stream->index);\n            continue;\n        }\n\n        codec = avcodec_find_decoder(stream->codecpar->codec_id);\n        if (!codec) {\n            av_log(NULL, AV_LOG_WARNING,\n                    \"Unsupported codec with id %d for input stream %d\\n\",\n                    stream->codecpar->codec_id, stream->index);\n            continue;\n        }\n        {\n            AVDictionary *opts = filter_codec_opts(codec_opts, stream->codecpar->codec_id,\n                                                   fmt_ctx, stream, codec);\n\n            ist->dec_ctx = avcodec_alloc_context3(codec);\n            if (!ist->dec_ctx)\n                exit(1);\n\n            err = avcodec_parameters_to_context(ist->dec_ctx, stream->codecpar);\n            if (err < 0)\n                exit(1);\n\n            if (do_show_log) {\n                // For loging it is needed to disable at least frame threads as otherwise\n                // the log information would need to be reordered and matches up to contexts and frames\n                // That is in fact possible but not trivial\n                av_dict_set(&codec_opts, \"threads\", \"1\", 0);\n            }\n\n            av_codec_set_pkt_timebase(ist->dec_ctx, stream->time_base);\n            ist->dec_ctx->framerate = stream->avg_frame_rate;\n\n            if (avcodec_open2(ist->dec_ctx, codec, &opts) < 0) {\n                av_log(NULL, AV_LOG_WARNING, \"Could not open codec for input stream %d\\n\",\n                       stream->index);\n                exit(1);\n            }\n\n            if ((t = av_dict_get(opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n                av_log(NULL, AV_LOG_ERROR, \"Option %s for input stream %d not found\\n\",\n                       t->key, stream->index);\n                return AVERROR_OPTION_NOT_FOUND;\n            }\n        }\n    }\n\n    ifile->fmt_ctx = fmt_ctx;\n    return 0;\n}\n\nstatic void close_input_file(InputFile *ifile)\n{\n    int i;\n\n    /* close decoder for each stream */\n    for (i = 0; i < ifile->nb_streams; i++)\n        if (ifile->streams[i].st->codecpar->codec_id != AV_CODEC_ID_NONE)\n            avcodec_free_context(&ifile->streams[i].dec_ctx);\n\n    av_freep(&ifile->streams);\n    ifile->nb_streams = 0;\n\n    avformat_close_input(&ifile->fmt_ctx);\n}\n\nstatic int probe_file(WriterContext *wctx, const char *filename)\n{\n    InputFile ifile = { 0 };\n    int ret, i;\n    int section_id;\n\n    do_read_frames = do_show_frames || do_count_frames;\n    do_read_packets = do_show_packets || do_count_packets;\n\n    ret = open_input_file(&ifile, filename);\n    if (ret < 0)\n        goto end;\n\n#define CHECK_END if (ret < 0) goto end\n\n    nb_streams = ifile.fmt_ctx->nb_streams;\n    REALLOCZ_ARRAY_STREAM(nb_streams_frames,0,ifile.fmt_ctx->nb_streams);\n    REALLOCZ_ARRAY_STREAM(nb_streams_packets,0,ifile.fmt_ctx->nb_streams);\n    REALLOCZ_ARRAY_STREAM(selected_streams,0,ifile.fmt_ctx->nb_streams);\n\n    for (i = 0; i < ifile.fmt_ctx->nb_streams; i++) {\n        if (stream_specifier) {\n            ret = avformat_match_stream_specifier(ifile.fmt_ctx,\n                                                  ifile.fmt_ctx->streams[i],\n                                                  stream_specifier);\n            CHECK_END;\n            else\n                selected_streams[i] = ret;\n            ret = 0;\n        } else {\n            selected_streams[i] = 1;\n        }\n        if (!selected_streams[i])\n            ifile.fmt_ctx->streams[i]->discard = AVDISCARD_ALL;\n    }\n\n    if (do_read_frames || do_read_packets) {\n        if (do_show_frames && do_show_packets &&\n            wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER)\n            section_id = SECTION_ID_PACKETS_AND_FRAMES;\n        else if (do_show_packets && !do_show_frames)\n            section_id = SECTION_ID_PACKETS;\n        else // (!do_show_packets && do_show_frames)\n            section_id = SECTION_ID_FRAMES;\n        if (do_show_frames || do_show_packets)\n            writer_print_section_header(wctx, section_id);\n        ret = read_packets(wctx, &ifile);\n        if (do_show_frames || do_show_packets)\n            writer_print_section_footer(wctx);\n        CHECK_END;\n    }\n\n    if (do_show_programs) {\n        ret = show_programs(wctx, &ifile);\n        CHECK_END;\n    }\n\n    if (do_show_streams) {\n        ret = show_streams(wctx, &ifile);\n        CHECK_END;\n    }\n    if (do_show_chapters) {\n        ret = show_chapters(wctx, &ifile);\n        CHECK_END;\n    }\n    if (do_show_format) {\n        ret = show_format(wctx, &ifile);\n        CHECK_END;\n    }\n\nend:\n    if (ifile.fmt_ctx)\n        close_input_file(&ifile);\n    av_freep(&nb_streams_frames);\n    av_freep(&nb_streams_packets);\n    av_freep(&selected_streams);\n\n    return ret;\n}\n\nstatic void show_usage(void)\n{\n    av_log(NULL, AV_LOG_INFO, \"Simple multimedia streams analyzer\\n\");\n    av_log(NULL, AV_LOG_INFO, \"usage: %s [OPTIONS] [INPUT_FILE]\\n\", program_name);\n    av_log(NULL, AV_LOG_INFO, \"\\n\");\n}\n\nstatic void ffprobe_show_program_version(WriterContext *w)\n{\n    AVBPrint pbuf;\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n    writer_print_section_header(w, SECTION_ID_PROGRAM_VERSION);\n    print_str(\"version\", FFMPEG_VERSION);\n    print_fmt(\"copyright\", \"Copyright (c) %d-%d the FFmpeg developers\",\n              program_birth_year, CONFIG_THIS_YEAR);\n    print_str(\"compiler_ident\", CC_IDENT);\n    print_str(\"configuration\", FFMPEG_CONFIGURATION);\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n}\n\n#define SHOW_LIB_VERSION(libname, LIBNAME)                              \\\n    do {                                                                \\\n        if (CONFIG_##LIBNAME) {                                         \\\n            unsigned int version = libname##_version();                 \\\n            writer_print_section_header(w, SECTION_ID_LIBRARY_VERSION); \\\n            print_str(\"name\",    \"lib\" #libname);                       \\\n            print_int(\"major\",   LIB##LIBNAME##_VERSION_MAJOR);         \\\n            print_int(\"minor\",   LIB##LIBNAME##_VERSION_MINOR);         \\\n            print_int(\"micro\",   LIB##LIBNAME##_VERSION_MICRO);         \\\n            print_int(\"version\", version);                              \\\n            print_str(\"ident\",   LIB##LIBNAME##_IDENT);                 \\\n            writer_print_section_footer(w);                             \\\n        }                                                               \\\n    } while (0)\n\nstatic void ffprobe_show_library_versions(WriterContext *w)\n{\n    writer_print_section_header(w, SECTION_ID_LIBRARY_VERSIONS);\n    SHOW_LIB_VERSION(avutil,     AVUTIL);\n    SHOW_LIB_VERSION(avcodec,    AVCODEC);\n    SHOW_LIB_VERSION(avformat,   AVFORMAT);\n    SHOW_LIB_VERSION(avdevice,   AVDEVICE);\n    SHOW_LIB_VERSION(avfilter,   AVFILTER);\n    SHOW_LIB_VERSION(swscale,    SWSCALE);\n    SHOW_LIB_VERSION(swresample, SWRESAMPLE);\n    SHOW_LIB_VERSION(postproc,   POSTPROC);\n    writer_print_section_footer(w);\n}\n\n#define PRINT_PIX_FMT_FLAG(flagname, name)                                \\\n    do {                                                                  \\\n        print_int(name, !!(pixdesc->flags & AV_PIX_FMT_FLAG_##flagname)); \\\n    } while (0)\n\nstatic void ffprobe_show_pixel_formats(WriterContext *w)\n{\n    const AVPixFmtDescriptor *pixdesc = NULL;\n    int i, n;\n\n    writer_print_section_header(w, SECTION_ID_PIXEL_FORMATS);\n    while (pixdesc = av_pix_fmt_desc_next(pixdesc)) {\n        writer_print_section_header(w, SECTION_ID_PIXEL_FORMAT);\n        print_str(\"name\", pixdesc->name);\n        print_int(\"nb_components\", pixdesc->nb_components);\n        if ((pixdesc->nb_components >= 3) && !(pixdesc->flags & AV_PIX_FMT_FLAG_RGB)) {\n            print_int    (\"log2_chroma_w\", pixdesc->log2_chroma_w);\n            print_int    (\"log2_chroma_h\", pixdesc->log2_chroma_h);\n        } else {\n            print_str_opt(\"log2_chroma_w\", \"N/A\");\n            print_str_opt(\"log2_chroma_h\", \"N/A\");\n        }\n        n = av_get_bits_per_pixel(pixdesc);\n        if (n) print_int    (\"bits_per_pixel\", n);\n        else   print_str_opt(\"bits_per_pixel\", \"N/A\");\n        if (do_show_pixel_format_flags) {\n            writer_print_section_header(w, SECTION_ID_PIXEL_FORMAT_FLAGS);\n            PRINT_PIX_FMT_FLAG(BE,        \"big_endian\");\n            PRINT_PIX_FMT_FLAG(PAL,       \"palette\");\n            PRINT_PIX_FMT_FLAG(BITSTREAM, \"bitstream\");\n            PRINT_PIX_FMT_FLAG(HWACCEL,   \"hwaccel\");\n            PRINT_PIX_FMT_FLAG(PLANAR,    \"planar\");\n            PRINT_PIX_FMT_FLAG(RGB,       \"rgb\");\n            PRINT_PIX_FMT_FLAG(PSEUDOPAL, \"pseudopal\");\n            PRINT_PIX_FMT_FLAG(ALPHA,     \"alpha\");\n            writer_print_section_footer(w);\n        }\n        if (do_show_pixel_format_components && (pixdesc->nb_components > 0)) {\n            writer_print_section_header(w, SECTION_ID_PIXEL_FORMAT_COMPONENTS);\n            for (i = 0; i < pixdesc->nb_components; i++) {\n                writer_print_section_header(w, SECTION_ID_PIXEL_FORMAT_COMPONENT);\n                print_int(\"index\", i + 1);\n                print_int(\"bit_depth\", pixdesc->comp[i].depth);\n                writer_print_section_footer(w);\n            }\n            writer_print_section_footer(w);\n        }\n        writer_print_section_footer(w);\n    }\n    writer_print_section_footer(w);\n}\n\nstatic int opt_format(void *optctx, const char *opt, const char *arg)\n{\n    iformat = av_find_input_format(arg);\n    if (!iformat) {\n        av_log(NULL, AV_LOG_ERROR, \"Unknown input format: %s\\n\", arg);\n        return AVERROR(EINVAL);\n    }\n    return 0;\n}\n\nstatic inline void mark_section_show_entries(SectionID section_id,\n                                             int show_all_entries, AVDictionary *entries)\n{\n    struct section *section = &sections[section_id];\n\n    section->show_all_entries = show_all_entries;\n    if (show_all_entries) {\n        SectionID *id;\n        for (id = section->children_ids; *id != -1; id++)\n            mark_section_show_entries(*id, show_all_entries, entries);\n    } else {\n        av_dict_copy(&section->entries_to_show, entries, 0);\n    }\n}\n\nstatic int match_section(const char *section_name,\n                         int show_all_entries, AVDictionary *entries)\n{\n    int i, ret = 0;\n\n    for (i = 0; i < FF_ARRAY_ELEMS(sections); i++) {\n        const struct section *section = &sections[i];\n        if (!strcmp(section_name, section->name) ||\n            (section->unique_name && !strcmp(section_name, section->unique_name))) {\n            av_log(NULL, AV_LOG_DEBUG,\n                   \"'%s' matches section with unique name '%s'\\n\", section_name,\n                   (char *)av_x_if_null(section->unique_name, section->name));\n            ret++;\n            mark_section_show_entries(section->id, show_all_entries, entries);\n        }\n    }\n    return ret;\n}\n\nstatic int opt_show_entries(void *optctx, const char *opt, const char *arg)\n{\n    const char *p = arg;\n    int ret = 0;\n\n    while (*p) {\n        AVDictionary *entries = NULL;\n        char *section_name = av_get_token(&p, \"=:\");\n        int show_all_entries = 0;\n\n        if (!section_name) {\n            av_log(NULL, AV_LOG_ERROR,\n                   \"Missing section name for option '%s'\\n\", opt);\n            return AVERROR(EINVAL);\n        }\n\n        if (*p == '=') {\n            p++;\n            while (*p && *p != ':') {\n                char *entry = av_get_token(&p, \",:\");\n                if (!entry)\n                    break;\n                av_log(NULL, AV_LOG_VERBOSE,\n                       \"Adding '%s' to the entries to show in section '%s'\\n\",\n                       entry, section_name);\n                av_dict_set(&entries, entry, \"\", AV_DICT_DONT_STRDUP_KEY);\n                if (*p == ',')\n                    p++;\n            }\n        } else {\n            show_all_entries = 1;\n        }\n\n        ret = match_section(section_name, show_all_entries, entries);\n        if (ret == 0) {\n            av_log(NULL, AV_LOG_ERROR, \"No match for section '%s'\\n\", section_name);\n            ret = AVERROR(EINVAL);\n        }\n        av_dict_free(&entries);\n        av_free(section_name);\n\n        if (ret <= 0)\n            break;\n        if (*p)\n            p++;\n    }\n\n    return ret;\n}\n\nstatic int opt_show_format_entry(void *optctx, const char *opt, const char *arg)\n{\n    char *buf = av_asprintf(\"format=%s\", arg);\n    int ret;\n\n    if (!buf)\n        return AVERROR(ENOMEM);\n\n    av_log(NULL, AV_LOG_WARNING,\n           \"Option '%s' is deprecated, use '-show_entries format=%s' instead\\n\",\n           opt, arg);\n    ret = opt_show_entries(optctx, opt, buf);\n    av_free(buf);\n    return ret;\n}\n\nstatic void opt_input_file(void *optctx, const char *arg)\n{\n    if (input_filename) {\n        av_log(NULL, AV_LOG_ERROR,\n                \"Argument '%s' provided as input filename, but '%s' was already specified.\\n\",\n                arg, input_filename);\n        exit_program(1);\n    }\n    if (!strcmp(arg, \"-\"))\n        arg = \"pipe:\";\n    input_filename = arg;\n}\n\nstatic int opt_input_file_i(void *optctx, const char *opt, const char *arg)\n{\n    opt_input_file(optctx, arg);\n    return 0;\n}\n\nvoid show_help_default(const char *opt, const char *arg)\n{\n    av_log_set_callback(log_callback_help);\n    show_usage();\n    show_help_options(options, \"Main options:\", 0, 0, 0);\n    printf(\"\\n\");\n\n    show_help_children(avformat_get_class(), AV_OPT_FLAG_DECODING_PARAM);\n    show_help_children(avcodec_get_class(), AV_OPT_FLAG_DECODING_PARAM);\n}\n\n/**\n * Parse interval specification, according to the format:\n * INTERVAL ::= [START|+START_OFFSET][%[END|+END_OFFSET]]\n * INTERVALS ::= INTERVAL[,INTERVALS]\n*/\nstatic int parse_read_interval(const char *interval_spec,\n                               ReadInterval *interval)\n{\n    int ret = 0;\n    char *next, *p, *spec = av_strdup(interval_spec);\n    if (!spec)\n        return AVERROR(ENOMEM);\n\n    if (!*spec) {\n        av_log(NULL, AV_LOG_ERROR, \"Invalid empty interval specification\\n\");\n        ret = AVERROR(EINVAL);\n        goto end;\n    }\n\n    p = spec;\n    next = strchr(spec, '%');\n    if (next)\n        *next++ = 0;\n\n    /* parse first part */\n    if (*p) {\n        interval->has_start = 1;\n\n        if (*p == '+') {\n            interval->start_is_offset = 1;\n            p++;\n        } else {\n            interval->start_is_offset = 0;\n        }\n\n        ret = av_parse_time(&interval->start, p, 1);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Invalid interval start specification '%s'\\n\", p);\n            goto end;\n        }\n    } else {\n        interval->has_start = 0;\n    }\n\n    /* parse second part */\n    p = next;\n    if (p && *p) {\n        int64_t us;\n        interval->has_end = 1;\n\n        if (*p == '+') {\n            interval->end_is_offset = 1;\n            p++;\n        } else {\n            interval->end_is_offset = 0;\n        }\n\n        if (interval->end_is_offset && *p == '#') {\n            long long int lli;\n            char *tail;\n            interval->duration_frames = 1;\n            p++;\n            lli = strtoll(p, &tail, 10);\n            if (*tail || lli < 0) {\n                av_log(NULL, AV_LOG_ERROR,\n                       \"Invalid or negative value '%s' for duration number of frames\\n\", p);\n                goto end;\n            }\n            interval->end = lli;\n        } else {\n            interval->duration_frames = 0;\n            ret = av_parse_time(&us, p, 1);\n            if (ret < 0) {\n                av_log(NULL, AV_LOG_ERROR, \"Invalid interval end/duration specification '%s'\\n\", p);\n                goto end;\n            }\n            interval->end = us;\n        }\n    } else {\n        interval->has_end = 0;\n    }\n\nend:\n    av_free(spec);\n    return ret;\n}\n\nstatic int parse_read_intervals(const char *intervals_spec)\n{\n    int ret, n, i;\n    char *p, *spec = av_strdup(intervals_spec);\n    if (!spec)\n        return AVERROR(ENOMEM);\n\n    /* preparse specification, get number of intervals */\n    for (n = 0, p = spec; *p; p++)\n        if (*p == ',')\n            n++;\n    n++;\n\n    read_intervals = av_malloc_array(n, sizeof(*read_intervals));\n    if (!read_intervals) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n    read_intervals_nb = n;\n\n    /* parse intervals */\n    p = spec;\n    for (i = 0; p; i++) {\n        char *next;\n\n        av_assert0(i < read_intervals_nb);\n        next = strchr(p, ',');\n        if (next)\n            *next++ = 0;\n\n        read_intervals[i].id = i;\n        ret = parse_read_interval(p, &read_intervals[i]);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Error parsing read interval #%d '%s'\\n\",\n                   i, p);\n            goto end;\n        }\n        av_log(NULL, AV_LOG_VERBOSE, \"Parsed log interval \");\n        log_read_interval(&read_intervals[i], NULL, AV_LOG_VERBOSE);\n        p = next;\n    }\n    av_assert0(i == read_intervals_nb);\n\nend:\n    av_free(spec);\n    return ret;\n}\n\nstatic int opt_read_intervals(void *optctx, const char *opt, const char *arg)\n{\n    return parse_read_intervals(arg);\n}\n\nstatic int opt_pretty(void *optctx, const char *opt, const char *arg)\n{\n    show_value_unit              = 1;\n    use_value_prefix             = 1;\n    use_byte_value_binary_prefix = 1;\n    use_value_sexagesimal_format = 1;\n    return 0;\n}\n\nstatic void print_section(SectionID id, int level)\n{\n    const SectionID *pid;\n    const struct section *section = &sections[id];\n    printf(\"%c%c%c\",\n           section->flags & SECTION_FLAG_IS_WRAPPER           ? 'W' : '.',\n           section->flags & SECTION_FLAG_IS_ARRAY             ? 'A' : '.',\n           section->flags & SECTION_FLAG_HAS_VARIABLE_FIELDS  ? 'V' : '.');\n    printf(\"%*c  %s\", level * 4, ' ', section->name);\n    if (section->unique_name)\n        printf(\"/%s\", section->unique_name);\n    printf(\"\\n\");\n\n    for (pid = section->children_ids; *pid != -1; pid++)\n        print_section(*pid, level+1);\n}\n\nstatic int opt_sections(void *optctx, const char *opt, const char *arg)\n{\n    printf(\"Sections:\\n\"\n           \"W.. = Section is a wrapper (contains other sections, no local entries)\\n\"\n           \".A. = Section contains an array of elements of the same type\\n\"\n           \"..V = Section may contain a variable number of fields with variable keys\\n\"\n           \"FLAGS NAME/UNIQUE_NAME\\n\"\n           \"---\\n\");\n    print_section(SECTION_ID_ROOT, 0);\n    return 0;\n}\n\nstatic int opt_show_versions(const char *opt, const char *arg)\n{\n    mark_section_show_entries(SECTION_ID_PROGRAM_VERSION, 1, NULL);\n    mark_section_show_entries(SECTION_ID_LIBRARY_VERSION, 1, NULL);\n    return 0;\n}\n\n#define DEFINE_OPT_SHOW_SECTION(section, target_section_id)             \\\n    static int opt_show_##section(const char *opt, const char *arg)     \\\n    {                                                                   \\\n        mark_section_show_entries(SECTION_ID_##target_section_id, 1, NULL); \\\n        return 0;                                                       \\\n    }\n\nDEFINE_OPT_SHOW_SECTION(chapters,         CHAPTERS)\nDEFINE_OPT_SHOW_SECTION(error,            ERROR)\nDEFINE_OPT_SHOW_SECTION(format,           FORMAT)\nDEFINE_OPT_SHOW_SECTION(frames,           FRAMES)\nDEFINE_OPT_SHOW_SECTION(library_versions, LIBRARY_VERSIONS)\nDEFINE_OPT_SHOW_SECTION(packets,          PACKETS)\nDEFINE_OPT_SHOW_SECTION(pixel_formats,    PIXEL_FORMATS)\nDEFINE_OPT_SHOW_SECTION(program_version,  PROGRAM_VERSION)\nDEFINE_OPT_SHOW_SECTION(streams,          STREAMS)\nDEFINE_OPT_SHOW_SECTION(programs,         PROGRAMS)\n\nstatic const OptionDef real_options[] = {\n    CMDUTILS_COMMON_OPTIONS\n    { \"f\", HAS_ARG, {.func_arg = opt_format}, \"force format\", \"format\" },\n    { \"unit\", OPT_BOOL, {&show_value_unit}, \"show unit of the displayed values\" },\n    { \"prefix\", OPT_BOOL, {&use_value_prefix}, \"use SI prefixes for the displayed values\" },\n    { \"byte_binary_prefix\", OPT_BOOL, {&use_byte_value_binary_prefix},\n      \"use binary prefixes for byte units\" },\n    { \"sexagesimal\", OPT_BOOL,  {&use_value_sexagesimal_format},\n      \"use sexagesimal format HOURS:MM:SS.MICROSECONDS for time units\" },\n    { \"pretty\", 0, {.func_arg = opt_pretty},\n      \"prettify the format of displayed values, make it more human readable\" },\n    { \"print_format\", OPT_STRING | HAS_ARG, {(void*)&print_format},\n      \"set the output printing format (available formats are: default, compact, csv, flat, ini, json, xml)\", \"format\" },\n    { \"of\", OPT_STRING | HAS_ARG, {(void*)&print_format}, \"alias for -print_format\", \"format\" },\n    { \"select_streams\", OPT_STRING | HAS_ARG, {(void*)&stream_specifier}, \"select the specified streams\", \"stream_specifier\" },\n    { \"sections\", OPT_EXIT, {.func_arg = opt_sections}, \"print sections structure and section information, and exit\" },\n    { \"show_data\",    OPT_BOOL, {(void*)&do_show_data}, \"show packets data\" },\n    { \"show_data_hash\", OPT_STRING | HAS_ARG, {(void*)&show_data_hash}, \"show packets data hash\" },\n    { \"show_error\",   0, {(void*)&opt_show_error},  \"show probing error\" },\n    { \"show_format\",  0, {(void*)&opt_show_format}, \"show format/container info\" },\n    { \"show_frames\",  0, {(void*)&opt_show_frames}, \"show frames info\" },\n    { \"show_format_entry\", HAS_ARG, {.func_arg = opt_show_format_entry},\n      \"show a particular entry from the format/container info\", \"entry\" },\n    { \"show_entries\", HAS_ARG, {.func_arg = opt_show_entries},\n      \"show a set of specified entries\", \"entry_list\" },\n#if HAVE_THREADS\n    { \"show_log\", OPT_INT|HAS_ARG, {(void*)&do_show_log}, \"show log\" },\n#endif\n    { \"show_packets\", 0, {(void*)&opt_show_packets}, \"show packets info\" },\n    { \"show_programs\", 0, {(void*)&opt_show_programs}, \"show programs info\" },\n    { \"show_streams\", 0, {(void*)&opt_show_streams}, \"show streams info\" },\n    { \"show_chapters\", 0, {(void*)&opt_show_chapters}, \"show chapters info\" },\n    { \"count_frames\", OPT_BOOL, {(void*)&do_count_frames}, \"count the number of frames per stream\" },\n    { \"count_packets\", OPT_BOOL, {(void*)&do_count_packets}, \"count the number of packets per stream\" },\n    { \"show_program_version\",  0, {(void*)&opt_show_program_version},  \"show ffprobe version\" },\n    { \"show_library_versions\", 0, {(void*)&opt_show_library_versions}, \"show library versions\" },\n    { \"show_versions\",         0, {(void*)&opt_show_versions}, \"show program and library versions\" },\n    { \"show_pixel_formats\", 0, {(void*)&opt_show_pixel_formats}, \"show pixel format descriptions\" },\n    { \"show_private_data\", OPT_BOOL, {(void*)&show_private_data}, \"show private data\" },\n    { \"private\",           OPT_BOOL, {(void*)&show_private_data}, \"same as show_private_data\" },\n    { \"bitexact\", OPT_BOOL, {&do_bitexact}, \"force bitexact output\" },\n    { \"read_intervals\", HAS_ARG, {.func_arg = opt_read_intervals}, \"set read intervals\", \"read_intervals\" },\n    { \"default\", HAS_ARG | OPT_AUDIO | OPT_VIDEO | OPT_EXPERT, {.func_arg = opt_default}, \"generic catch all option\", \"\" },\n    { \"i\", HAS_ARG, {.func_arg = opt_input_file_i}, \"read specified file\", \"input_file\"},\n    { \"find_stream_info\", OPT_BOOL | OPT_INPUT | OPT_EXPERT, { &find_stream_info },\n        \"read and decode the streams to fill missing information with heuristics\" },\n    { NULL, },\n};\n\nstatic inline int check_section_show_entries(int section_id)\n{\n    int *id;\n    struct section *section = &sections[section_id];\n    if (sections[section_id].show_all_entries || sections[section_id].entries_to_show)\n        return 1;\n    for (id = section->children_ids; *id != -1; id++)\n        if (check_section_show_entries(*id))\n            return 1;\n    return 0;\n}\n\n#define SET_DO_SHOW(id, varname) do {                                   \\\n        if (check_section_show_entries(SECTION_ID_##id))                \\\n            do_show_##varname = 1;                                      \\\n    } while (0)\n\nint main(int argc, char **argv)\n{\n    const Writer *w;\n    WriterContext *wctx;\n    char *buf;\n    char *w_name = NULL, *w_args = NULL;\n    int ret, i;\n\n    init_dynload();\n\n#if HAVE_THREADS\n    ret = pthread_mutex_init(&log_mutex, NULL);\n    if (ret != 0) {\n        goto end;\n    }\n#endif\n    av_log_set_flags(AV_LOG_SKIP_REPEATED);\n    register_exit(ffprobe_cleanup);\n\n    options = real_options;\n    parse_loglevel(argc, argv, options);\n    av_register_all();\n    avformat_network_init();\n    init_opts();\n#if CONFIG_AVDEVICE\n    avdevice_register_all();\n#endif\n\n    show_banner(argc, argv, options);\n    parse_options(NULL, argc, argv, options, opt_input_file);\n\n    if (do_show_log)\n        av_log_set_callback(log_callback);\n\n    /* mark things to show, based on -show_entries */\n    SET_DO_SHOW(CHAPTERS, chapters);\n    SET_DO_SHOW(ERROR, error);\n    SET_DO_SHOW(FORMAT, format);\n    SET_DO_SHOW(FRAMES, frames);\n    SET_DO_SHOW(LIBRARY_VERSIONS, library_versions);\n    SET_DO_SHOW(PACKETS, packets);\n    SET_DO_SHOW(PIXEL_FORMATS, pixel_formats);\n    SET_DO_SHOW(PIXEL_FORMAT_FLAGS, pixel_format_flags);\n    SET_DO_SHOW(PIXEL_FORMAT_COMPONENTS, pixel_format_components);\n    SET_DO_SHOW(PROGRAM_VERSION, program_version);\n    SET_DO_SHOW(PROGRAMS, programs);\n    SET_DO_SHOW(STREAMS, streams);\n    SET_DO_SHOW(STREAM_DISPOSITION, stream_disposition);\n    SET_DO_SHOW(PROGRAM_STREAM_DISPOSITION, stream_disposition);\n\n    SET_DO_SHOW(CHAPTER_TAGS, chapter_tags);\n    SET_DO_SHOW(FORMAT_TAGS, format_tags);\n    SET_DO_SHOW(FRAME_TAGS, frame_tags);\n    SET_DO_SHOW(PROGRAM_TAGS, program_tags);\n    SET_DO_SHOW(STREAM_TAGS, stream_tags);\n    SET_DO_SHOW(PROGRAM_STREAM_TAGS, stream_tags);\n    SET_DO_SHOW(PACKET_TAGS, packet_tags);\n\n    if (do_bitexact && (do_show_program_version || do_show_library_versions)) {\n        av_log(NULL, AV_LOG_ERROR,\n               \"-bitexact and -show_program_version or -show_library_versions \"\n               \"options are incompatible\\n\");\n        ret = AVERROR(EINVAL);\n        goto end;\n    }\n\n    writer_register_all();\n\n    if (!print_format)\n        print_format = av_strdup(\"default\");\n    if (!print_format) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n    w_name = av_strtok(print_format, \"=\", &buf);\n    if (!w_name) {\n        av_log(NULL, AV_LOG_ERROR,\n               \"No name specified for the output format\\n\");\n        ret = AVERROR(EINVAL);\n        goto end;\n    }\n    w_args = buf;\n\n    if (show_data_hash) {\n        if ((ret = av_hash_alloc(&hash, show_data_hash)) < 0) {\n            if (ret == AVERROR(EINVAL)) {\n                const char *n;\n                av_log(NULL, AV_LOG_ERROR,\n                       \"Unknown hash algorithm '%s'\\nKnown algorithms:\",\n                       show_data_hash);\n                for (i = 0; (n = av_hash_names(i)); i++)\n                    av_log(NULL, AV_LOG_ERROR, \" %s\", n);\n                av_log(NULL, AV_LOG_ERROR, \"\\n\");\n            }\n            goto end;\n        }\n    }\n\n    w = writer_get_by_name(w_name);\n    if (!w) {\n        av_log(NULL, AV_LOG_ERROR, \"Unknown output format with name '%s'\\n\", w_name);\n        ret = AVERROR(EINVAL);\n        goto end;\n    }\n\n    if ((ret = writer_open(&wctx, w, w_args,\n                           sections, FF_ARRAY_ELEMS(sections))) >= 0) {\n        if (w == &xml_writer)\n            wctx->string_validation_utf8_flags |= AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES;\n\n        writer_print_section_header(wctx, SECTION_ID_ROOT);\n\n        if (do_show_program_version)\n            ffprobe_show_program_version(wctx);\n        if (do_show_library_versions)\n            ffprobe_show_library_versions(wctx);\n        if (do_show_pixel_formats)\n            ffprobe_show_pixel_formats(wctx);\n\n        if (!input_filename &&\n            ((do_show_format || do_show_programs || do_show_streams || do_show_chapters || do_show_packets || do_show_error) ||\n             (!do_show_program_version && !do_show_library_versions && !do_show_pixel_formats))) {\n            show_usage();\n            av_log(NULL, AV_LOG_ERROR, \"You have to specify one input file.\\n\");\n            av_log(NULL, AV_LOG_ERROR, \"Use -h to get full help or, even better, run 'man %s'.\\n\", program_name);\n            ret = AVERROR(EINVAL);\n        } else if (input_filename) {\n            ret = probe_file(wctx, input_filename);\n            if (ret < 0 && do_show_error)\n                show_error(wctx, ret);\n        }\n\n        writer_print_section_footer(wctx);\n        writer_close(&wctx);\n    }\n\nend:\n    av_freep(&print_format);\n    av_freep(&read_intervals);\n    av_hash_freep(&hash);\n\n    uninit_opts();\n    for (i = 0; i < FF_ARRAY_ELEMS(sections); i++)\n        av_dict_free(&(sections[i].entries_to_show));\n\n    avformat_network_deinit();\n\n    return ret < 0;\n}\n"], "filenames": ["ffprobe.c"], "buggy_code_start_loc": [1927], "buggy_code_end_loc": [2523], "fixing_code_start_loc": [1928], "fixing_code_end_loc": [2527], "type": "CWE-476", "message": "The av_color_primaries_name function in libavutil/pixdesc.c in FFmpeg 3.3.3 may return a NULL pointer depending on a value contained in a file, but callers do not anticipate this, as demonstrated by the avcodec_string function in libavcodec/utils.c, leading to a NULL pointer dereference. (It is also conceivable that there is security relevance for a NULL pointer dereference in av_color_primaries_name calls within the ffprobe command-line program.)", "other": {"cve": {"id": "CVE-2017-14225", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-09T08:29:00.193", "lastModified": "2017-11-04T01:29:35.943", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The av_color_primaries_name function in libavutil/pixdesc.c in FFmpeg 3.3.3 may return a NULL pointer depending on a value contained in a file, but callers do not anticipate this, as demonstrated by the avcodec_string function in libavcodec/utils.c, leading to a NULL pointer dereference. (It is also conceivable that there is security relevance for a NULL pointer dereference in av_color_primaries_name calls within the ffprobe command-line program.)"}, {"lang": "es", "value": "La funci\u00f3n av_color_primaries_name en libavutil/pixdesc.c en FFmpeg 3.3.3 podr\u00eda devolver un puntero NULL dependiendo de un valor contenido en un archivo, se anticipa en las llamadas, tal y como demuestra la funci\u00f3n avcodec_string en libavcodec/utils.c, lo que conduce a una desreferencia de puntero NULL. (Tambi\u00e9n es posible que haya relevancia de seguridad para una desreferencia de puntero NULL en llamadas av_color_primaries_name en el programa de l\u00ednea de comandos ffprobe)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "A97A44A7-DFB8-4DA8-8A4A-DBC1FF255D9A"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3996", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/100704", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/837cb4325b712ff1aab531bf41668933f61d75d2", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.ffmpeg.org/pipermail/ffmpeg-devel/2017-August/215198.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/837cb4325b712ff1aab531bf41668933f61d75d2"}}