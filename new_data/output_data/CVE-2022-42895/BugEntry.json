{"buggy_code": ["/*\n   BlueZ - Bluetooth protocol stack for Linux\n   Copyright (C) 2000-2001 Qualcomm Incorporated\n   Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>\n   Copyright (C) 2010 Google Inc.\n   Copyright (C) 2011 ProFUSION Embedded Systems\n   Copyright (c) 2012 Code Aurora Forum.  All rights reserved.\n\n   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n/* Bluetooth L2CAP core. */\n\n#include <linux/module.h>\n\n#include <linux/debugfs.h>\n#include <linux/crc16.h>\n#include <linux/filter.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#include \"smp.h\"\n#include \"a2mp.h\"\n#include \"amp.h\"\n\n#define LE_FLOWCTL_MAX_CREDITS 65535\n\nbool disable_ertm;\nbool enable_ecred;\n\nstatic u32 l2cap_feat_mask = L2CAP_FEAT_FIXED_CHAN | L2CAP_FEAT_UCD;\n\nstatic LIST_HEAD(chan_list);\nstatic DEFINE_RWLOCK(chan_list_lock);\n\nstatic struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,\n\t\t\t\t       u8 code, u8 ident, u16 dlen, void *data);\nstatic void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,\n\t\t\t   void *data);\nstatic int l2cap_build_conf_req(struct l2cap_chan *chan, void *data, size_t data_size);\nstatic void l2cap_send_disconn_req(struct l2cap_chan *chan, int err);\n\nstatic void l2cap_tx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\n\t\t     struct sk_buff_head *skbs, u8 event);\nstatic void l2cap_retrans_timeout(struct work_struct *work);\nstatic void l2cap_monitor_timeout(struct work_struct *work);\nstatic void l2cap_ack_timeout(struct work_struct *work);\n\nstatic inline u8 bdaddr_type(u8 link_type, u8 bdaddr_type)\n{\n\tif (link_type == LE_LINK) {\n\t\tif (bdaddr_type == ADDR_LE_DEV_PUBLIC)\n\t\t\treturn BDADDR_LE_PUBLIC;\n\t\telse\n\t\t\treturn BDADDR_LE_RANDOM;\n\t}\n\n\treturn BDADDR_BREDR;\n}\n\nstatic inline u8 bdaddr_src_type(struct hci_conn *hcon)\n{\n\treturn bdaddr_type(hcon->type, hcon->src_type);\n}\n\nstatic inline u8 bdaddr_dst_type(struct hci_conn *hcon)\n{\n\treturn bdaddr_type(hcon->type, hcon->dst_type);\n}\n\n/* ---- L2CAP channels ---- */\n\nstatic struct l2cap_chan *__l2cap_get_chan_by_dcid(struct l2cap_conn *conn,\n\t\t\t\t\t\t   u16 cid)\n{\n\tstruct l2cap_chan *c;\n\n\tlist_for_each_entry(c, &conn->chan_l, list) {\n\t\tif (c->dcid == cid)\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\nstatic struct l2cap_chan *__l2cap_get_chan_by_scid(struct l2cap_conn *conn,\n\t\t\t\t\t\t   u16 cid)\n{\n\tstruct l2cap_chan *c;\n\n\tlist_for_each_entry(c, &conn->chan_l, list) {\n\t\tif (c->scid == cid)\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\n/* Find channel with given SCID.\n * Returns a reference locked channel.\n */\nstatic struct l2cap_chan *l2cap_get_chan_by_scid(struct l2cap_conn *conn,\n\t\t\t\t\t\t u16 cid)\n{\n\tstruct l2cap_chan *c;\n\n\tmutex_lock(&conn->chan_lock);\n\tc = __l2cap_get_chan_by_scid(conn, cid);\n\tif (c) {\n\t\t/* Only lock if chan reference is not 0 */\n\t\tc = l2cap_chan_hold_unless_zero(c);\n\t\tif (c)\n\t\t\tl2cap_chan_lock(c);\n\t}\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn c;\n}\n\n/* Find channel with given DCID.\n * Returns a reference locked channel.\n */\nstatic struct l2cap_chan *l2cap_get_chan_by_dcid(struct l2cap_conn *conn,\n\t\t\t\t\t\t u16 cid)\n{\n\tstruct l2cap_chan *c;\n\n\tmutex_lock(&conn->chan_lock);\n\tc = __l2cap_get_chan_by_dcid(conn, cid);\n\tif (c) {\n\t\t/* Only lock if chan reference is not 0 */\n\t\tc = l2cap_chan_hold_unless_zero(c);\n\t\tif (c)\n\t\t\tl2cap_chan_lock(c);\n\t}\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn c;\n}\n\nstatic struct l2cap_chan *__l2cap_get_chan_by_ident(struct l2cap_conn *conn,\n\t\t\t\t\t\t    u8 ident)\n{\n\tstruct l2cap_chan *c;\n\n\tlist_for_each_entry(c, &conn->chan_l, list) {\n\t\tif (c->ident == ident)\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\nstatic struct l2cap_chan *l2cap_get_chan_by_ident(struct l2cap_conn *conn,\n\t\t\t\t\t\t  u8 ident)\n{\n\tstruct l2cap_chan *c;\n\n\tmutex_lock(&conn->chan_lock);\n\tc = __l2cap_get_chan_by_ident(conn, ident);\n\tif (c) {\n\t\t/* Only lock if chan reference is not 0 */\n\t\tc = l2cap_chan_hold_unless_zero(c);\n\t\tif (c)\n\t\t\tl2cap_chan_lock(c);\n\t}\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn c;\n}\n\nstatic struct l2cap_chan *__l2cap_global_chan_by_addr(__le16 psm, bdaddr_t *src,\n\t\t\t\t\t\t      u8 src_type)\n{\n\tstruct l2cap_chan *c;\n\n\tlist_for_each_entry(c, &chan_list, global_l) {\n\t\tif (src_type == BDADDR_BREDR && c->src_type != BDADDR_BREDR)\n\t\t\tcontinue;\n\n\t\tif (src_type != BDADDR_BREDR && c->src_type == BDADDR_BREDR)\n\t\t\tcontinue;\n\n\t\tif (c->sport == psm && !bacmp(&c->src, src))\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\nint l2cap_add_psm(struct l2cap_chan *chan, bdaddr_t *src, __le16 psm)\n{\n\tint err;\n\n\twrite_lock(&chan_list_lock);\n\n\tif (psm && __l2cap_global_chan_by_addr(psm, src, chan->src_type)) {\n\t\terr = -EADDRINUSE;\n\t\tgoto done;\n\t}\n\n\tif (psm) {\n\t\tchan->psm = psm;\n\t\tchan->sport = psm;\n\t\terr = 0;\n\t} else {\n\t\tu16 p, start, end, incr;\n\n\t\tif (chan->src_type == BDADDR_BREDR) {\n\t\t\tstart = L2CAP_PSM_DYN_START;\n\t\t\tend = L2CAP_PSM_AUTO_END;\n\t\t\tincr = 2;\n\t\t} else {\n\t\t\tstart = L2CAP_PSM_LE_DYN_START;\n\t\t\tend = L2CAP_PSM_LE_DYN_END;\n\t\t\tincr = 1;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tfor (p = start; p <= end; p += incr)\n\t\t\tif (!__l2cap_global_chan_by_addr(cpu_to_le16(p), src,\n\t\t\t\t\t\t\t chan->src_type)) {\n\t\t\t\tchan->psm   = cpu_to_le16(p);\n\t\t\t\tchan->sport = cpu_to_le16(p);\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\ndone:\n\twrite_unlock(&chan_list_lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(l2cap_add_psm);\n\nint l2cap_add_scid(struct l2cap_chan *chan,  __u16 scid)\n{\n\twrite_lock(&chan_list_lock);\n\n\t/* Override the defaults (which are for conn-oriented) */\n\tchan->omtu = L2CAP_DEFAULT_MTU;\n\tchan->chan_type = L2CAP_CHAN_FIXED;\n\n\tchan->scid = scid;\n\n\twrite_unlock(&chan_list_lock);\n\n\treturn 0;\n}\n\nstatic u16 l2cap_alloc_cid(struct l2cap_conn *conn)\n{\n\tu16 cid, dyn_end;\n\n\tif (conn->hcon->type == LE_LINK)\n\t\tdyn_end = L2CAP_CID_LE_DYN_END;\n\telse\n\t\tdyn_end = L2CAP_CID_DYN_END;\n\n\tfor (cid = L2CAP_CID_DYN_START; cid <= dyn_end; cid++) {\n\t\tif (!__l2cap_get_chan_by_scid(conn, cid))\n\t\t\treturn cid;\n\t}\n\n\treturn 0;\n}\n\nstatic void l2cap_state_change(struct l2cap_chan *chan, int state)\n{\n\tBT_DBG(\"chan %p %s -> %s\", chan, state_to_string(chan->state),\n\t       state_to_string(state));\n\n\tchan->state = state;\n\tchan->ops->state_change(chan, state, 0);\n}\n\nstatic inline void l2cap_state_change_and_error(struct l2cap_chan *chan,\n\t\t\t\t\t\tint state, int err)\n{\n\tchan->state = state;\n\tchan->ops->state_change(chan, chan->state, err);\n}\n\nstatic inline void l2cap_chan_set_err(struct l2cap_chan *chan, int err)\n{\n\tchan->ops->state_change(chan, chan->state, err);\n}\n\nstatic void __set_retrans_timer(struct l2cap_chan *chan)\n{\n\tif (!delayed_work_pending(&chan->monitor_timer) &&\n\t    chan->retrans_timeout) {\n\t\tl2cap_set_timer(chan, &chan->retrans_timer,\n\t\t\t\tmsecs_to_jiffies(chan->retrans_timeout));\n\t}\n}\n\nstatic void __set_monitor_timer(struct l2cap_chan *chan)\n{\n\t__clear_retrans_timer(chan);\n\tif (chan->monitor_timeout) {\n\t\tl2cap_set_timer(chan, &chan->monitor_timer,\n\t\t\t\tmsecs_to_jiffies(chan->monitor_timeout));\n\t}\n}\n\nstatic struct sk_buff *l2cap_ertm_seq_in_queue(struct sk_buff_head *head,\n\t\t\t\t\t       u16 seq)\n{\n\tstruct sk_buff *skb;\n\n\tskb_queue_walk(head, skb) {\n\t\tif (bt_cb(skb)->l2cap.txseq == seq)\n\t\t\treturn skb;\n\t}\n\n\treturn NULL;\n}\n\n/* ---- L2CAP sequence number lists ---- */\n\n/* For ERTM, ordered lists of sequence numbers must be tracked for\n * SREJ requests that are received and for frames that are to be\n * retransmitted. These seq_list functions implement a singly-linked\n * list in an array, where membership in the list can also be checked\n * in constant time. Items can also be added to the tail of the list\n * and removed from the head in constant time, without further memory\n * allocs or frees.\n */\n\nstatic int l2cap_seq_list_init(struct l2cap_seq_list *seq_list, u16 size)\n{\n\tsize_t alloc_size, i;\n\n\t/* Allocated size is a power of 2 to map sequence numbers\n\t * (which may be up to 14 bits) in to a smaller array that is\n\t * sized for the negotiated ERTM transmit windows.\n\t */\n\talloc_size = roundup_pow_of_two(size);\n\n\tseq_list->list = kmalloc_array(alloc_size, sizeof(u16), GFP_KERNEL);\n\tif (!seq_list->list)\n\t\treturn -ENOMEM;\n\n\tseq_list->mask = alloc_size - 1;\n\tseq_list->head = L2CAP_SEQ_LIST_CLEAR;\n\tseq_list->tail = L2CAP_SEQ_LIST_CLEAR;\n\tfor (i = 0; i < alloc_size; i++)\n\t\tseq_list->list[i] = L2CAP_SEQ_LIST_CLEAR;\n\n\treturn 0;\n}\n\nstatic inline void l2cap_seq_list_free(struct l2cap_seq_list *seq_list)\n{\n\tkfree(seq_list->list);\n}\n\nstatic inline bool l2cap_seq_list_contains(struct l2cap_seq_list *seq_list,\n\t\t\t\t\t   u16 seq)\n{\n\t/* Constant-time check for list membership */\n\treturn seq_list->list[seq & seq_list->mask] != L2CAP_SEQ_LIST_CLEAR;\n}\n\nstatic inline u16 l2cap_seq_list_pop(struct l2cap_seq_list *seq_list)\n{\n\tu16 seq = seq_list->head;\n\tu16 mask = seq_list->mask;\n\n\tseq_list->head = seq_list->list[seq & mask];\n\tseq_list->list[seq & mask] = L2CAP_SEQ_LIST_CLEAR;\n\n\tif (seq_list->head == L2CAP_SEQ_LIST_TAIL) {\n\t\tseq_list->head = L2CAP_SEQ_LIST_CLEAR;\n\t\tseq_list->tail = L2CAP_SEQ_LIST_CLEAR;\n\t}\n\n\treturn seq;\n}\n\nstatic void l2cap_seq_list_clear(struct l2cap_seq_list *seq_list)\n{\n\tu16 i;\n\n\tif (seq_list->head == L2CAP_SEQ_LIST_CLEAR)\n\t\treturn;\n\n\tfor (i = 0; i <= seq_list->mask; i++)\n\t\tseq_list->list[i] = L2CAP_SEQ_LIST_CLEAR;\n\n\tseq_list->head = L2CAP_SEQ_LIST_CLEAR;\n\tseq_list->tail = L2CAP_SEQ_LIST_CLEAR;\n}\n\nstatic void l2cap_seq_list_append(struct l2cap_seq_list *seq_list, u16 seq)\n{\n\tu16 mask = seq_list->mask;\n\n\t/* All appends happen in constant time */\n\n\tif (seq_list->list[seq & mask] != L2CAP_SEQ_LIST_CLEAR)\n\t\treturn;\n\n\tif (seq_list->tail == L2CAP_SEQ_LIST_CLEAR)\n\t\tseq_list->head = seq;\n\telse\n\t\tseq_list->list[seq_list->tail & mask] = seq;\n\n\tseq_list->tail = seq;\n\tseq_list->list[seq & mask] = L2CAP_SEQ_LIST_TAIL;\n}\n\nstatic void l2cap_chan_timeout(struct work_struct *work)\n{\n\tstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\n\t\t\t\t\t       chan_timer.work);\n\tstruct l2cap_conn *conn = chan->conn;\n\tint reason;\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\tmutex_lock(&conn->chan_lock);\n\t/* __set_chan_timer() calls l2cap_chan_hold(chan) while scheduling\n\t * this work. No need to call l2cap_chan_hold(chan) here again.\n\t */\n\tl2cap_chan_lock(chan);\n\n\tif (chan->state == BT_CONNECTED || chan->state == BT_CONFIG)\n\t\treason = ECONNREFUSED;\n\telse if (chan->state == BT_CONNECT &&\n\t\t chan->sec_level != BT_SECURITY_SDP)\n\t\treason = ECONNREFUSED;\n\telse\n\t\treason = ETIMEDOUT;\n\n\tl2cap_chan_close(chan, reason);\n\n\tchan->ops->close(chan);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\nstruct l2cap_chan *l2cap_chan_create(void)\n{\n\tstruct l2cap_chan *chan;\n\n\tchan = kzalloc(sizeof(*chan), GFP_ATOMIC);\n\tif (!chan)\n\t\treturn NULL;\n\n\tskb_queue_head_init(&chan->tx_q);\n\tskb_queue_head_init(&chan->srej_q);\n\tmutex_init(&chan->lock);\n\n\t/* Set default lock nesting level */\n\tatomic_set(&chan->nesting, L2CAP_NESTING_NORMAL);\n\n\twrite_lock(&chan_list_lock);\n\tlist_add(&chan->global_l, &chan_list);\n\twrite_unlock(&chan_list_lock);\n\n\tINIT_DELAYED_WORK(&chan->chan_timer, l2cap_chan_timeout);\n\tINIT_DELAYED_WORK(&chan->retrans_timer, l2cap_retrans_timeout);\n\tINIT_DELAYED_WORK(&chan->monitor_timer, l2cap_monitor_timeout);\n\tINIT_DELAYED_WORK(&chan->ack_timer, l2cap_ack_timeout);\n\n\tchan->state = BT_OPEN;\n\n\tkref_init(&chan->kref);\n\n\t/* This flag is cleared in l2cap_chan_ready() */\n\tset_bit(CONF_NOT_COMPLETE, &chan->conf_state);\n\n\tBT_DBG(\"chan %p\", chan);\n\n\treturn chan;\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_create);\n\nstatic void l2cap_chan_destroy(struct kref *kref)\n{\n\tstruct l2cap_chan *chan = container_of(kref, struct l2cap_chan, kref);\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twrite_lock(&chan_list_lock);\n\tlist_del(&chan->global_l);\n\twrite_unlock(&chan_list_lock);\n\n\tkfree(chan);\n}\n\nvoid l2cap_chan_hold(struct l2cap_chan *c)\n{\n\tBT_DBG(\"chan %p orig refcnt %u\", c, kref_read(&c->kref));\n\n\tkref_get(&c->kref);\n}\n\nstruct l2cap_chan *l2cap_chan_hold_unless_zero(struct l2cap_chan *c)\n{\n\tBT_DBG(\"chan %p orig refcnt %u\", c, kref_read(&c->kref));\n\n\tif (!kref_get_unless_zero(&c->kref))\n\t\treturn NULL;\n\n\treturn c;\n}\n\nvoid l2cap_chan_put(struct l2cap_chan *c)\n{\n\tBT_DBG(\"chan %p orig refcnt %u\", c, kref_read(&c->kref));\n\n\tkref_put(&c->kref, l2cap_chan_destroy);\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_put);\n\nvoid l2cap_chan_set_defaults(struct l2cap_chan *chan)\n{\n\tchan->fcs  = L2CAP_FCS_CRC16;\n\tchan->max_tx = L2CAP_DEFAULT_MAX_TX;\n\tchan->tx_win = L2CAP_DEFAULT_TX_WINDOW;\n\tchan->tx_win_max = L2CAP_DEFAULT_TX_WINDOW;\n\tchan->remote_max_tx = chan->max_tx;\n\tchan->remote_tx_win = chan->tx_win;\n\tchan->ack_win = L2CAP_DEFAULT_TX_WINDOW;\n\tchan->sec_level = BT_SECURITY_LOW;\n\tchan->flush_to = L2CAP_DEFAULT_FLUSH_TO;\n\tchan->retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;\n\tchan->monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;\n\n\tchan->conf_state = 0;\n\tset_bit(CONF_NOT_COMPLETE, &chan->conf_state);\n\n\tset_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_set_defaults);\n\nstatic void l2cap_le_flowctl_init(struct l2cap_chan *chan, u16 tx_credits)\n{\n\tchan->sdu = NULL;\n\tchan->sdu_last_frag = NULL;\n\tchan->sdu_len = 0;\n\tchan->tx_credits = tx_credits;\n\t/* Derive MPS from connection MTU to stop HCI fragmentation */\n\tchan->mps = min_t(u16, chan->imtu, chan->conn->mtu - L2CAP_HDR_SIZE);\n\t/* Give enough credits for a full packet */\n\tchan->rx_credits = (chan->imtu / chan->mps) + 1;\n\n\tskb_queue_head_init(&chan->tx_q);\n}\n\nstatic void l2cap_ecred_init(struct l2cap_chan *chan, u16 tx_credits)\n{\n\tl2cap_le_flowctl_init(chan, tx_credits);\n\n\t/* L2CAP implementations shall support a minimum MPS of 64 octets */\n\tif (chan->mps < L2CAP_ECRED_MIN_MPS) {\n\t\tchan->mps = L2CAP_ECRED_MIN_MPS;\n\t\tchan->rx_credits = (chan->imtu / chan->mps) + 1;\n\t}\n}\n\nvoid __l2cap_chan_add(struct l2cap_conn *conn, struct l2cap_chan *chan)\n{\n\tBT_DBG(\"conn %p, psm 0x%2.2x, dcid 0x%4.4x\", conn,\n\t       __le16_to_cpu(chan->psm), chan->dcid);\n\n\tconn->disc_reason = HCI_ERROR_REMOTE_USER_TERM;\n\n\tchan->conn = conn;\n\n\tswitch (chan->chan_type) {\n\tcase L2CAP_CHAN_CONN_ORIENTED:\n\t\t/* Alloc CID for connection-oriented socket */\n\t\tchan->scid = l2cap_alloc_cid(conn);\n\t\tif (conn->hcon->type == ACL_LINK)\n\t\t\tchan->omtu = L2CAP_DEFAULT_MTU;\n\t\tbreak;\n\n\tcase L2CAP_CHAN_CONN_LESS:\n\t\t/* Connectionless socket */\n\t\tchan->scid = L2CAP_CID_CONN_LESS;\n\t\tchan->dcid = L2CAP_CID_CONN_LESS;\n\t\tchan->omtu = L2CAP_DEFAULT_MTU;\n\t\tbreak;\n\n\tcase L2CAP_CHAN_FIXED:\n\t\t/* Caller will set CID and CID specific MTU values */\n\t\tbreak;\n\n\tdefault:\n\t\t/* Raw socket can send/recv signalling messages only */\n\t\tchan->scid = L2CAP_CID_SIGNALING;\n\t\tchan->dcid = L2CAP_CID_SIGNALING;\n\t\tchan->omtu = L2CAP_DEFAULT_MTU;\n\t}\n\n\tchan->local_id\t\t= L2CAP_BESTEFFORT_ID;\n\tchan->local_stype\t= L2CAP_SERV_BESTEFFORT;\n\tchan->local_msdu\t= L2CAP_DEFAULT_MAX_SDU_SIZE;\n\tchan->local_sdu_itime\t= L2CAP_DEFAULT_SDU_ITIME;\n\tchan->local_acc_lat\t= L2CAP_DEFAULT_ACC_LAT;\n\tchan->local_flush_to\t= L2CAP_EFS_DEFAULT_FLUSH_TO;\n\n\tl2cap_chan_hold(chan);\n\n\t/* Only keep a reference for fixed channels if they requested it */\n\tif (chan->chan_type != L2CAP_CHAN_FIXED ||\n\t    test_bit(FLAG_HOLD_HCI_CONN, &chan->flags))\n\t\thci_conn_hold(conn->hcon);\n\n\tlist_add(&chan->list, &conn->chan_l);\n}\n\nvoid l2cap_chan_add(struct l2cap_conn *conn, struct l2cap_chan *chan)\n{\n\tmutex_lock(&conn->chan_lock);\n\t__l2cap_chan_add(conn, chan);\n\tmutex_unlock(&conn->chan_lock);\n}\n\nvoid l2cap_chan_del(struct l2cap_chan *chan, int err)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\t__clear_chan_timer(chan);\n\n\tBT_DBG(\"chan %p, conn %p, err %d, state %s\", chan, conn, err,\n\t       state_to_string(chan->state));\n\n\tchan->ops->teardown(chan, err);\n\n\tif (conn) {\n\t\tstruct amp_mgr *mgr = conn->hcon->amp_mgr;\n\t\t/* Delete from channel list */\n\t\tlist_del(&chan->list);\n\n\t\tl2cap_chan_put(chan);\n\n\t\tchan->conn = NULL;\n\n\t\t/* Reference was only held for non-fixed channels or\n\t\t * fixed channels that explicitly requested it using the\n\t\t * FLAG_HOLD_HCI_CONN flag.\n\t\t */\n\t\tif (chan->chan_type != L2CAP_CHAN_FIXED ||\n\t\t    test_bit(FLAG_HOLD_HCI_CONN, &chan->flags))\n\t\t\thci_conn_drop(conn->hcon);\n\n\t\tif (mgr && mgr->bredr_chan == chan)\n\t\t\tmgr->bredr_chan = NULL;\n\t}\n\n\tif (chan->hs_hchan) {\n\t\tstruct hci_chan *hs_hchan = chan->hs_hchan;\n\n\t\tBT_DBG(\"chan %p disconnect hs_hchan %p\", chan, hs_hchan);\n\t\tamp_disconnect_logical_link(hs_hchan);\n\t}\n\n\tif (test_bit(CONF_NOT_COMPLETE, &chan->conf_state))\n\t\treturn;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tskb_queue_purge(&chan->tx_q);\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\t\t__clear_retrans_timer(chan);\n\t\t__clear_monitor_timer(chan);\n\t\t__clear_ack_timer(chan);\n\n\t\tskb_queue_purge(&chan->srej_q);\n\n\t\tl2cap_seq_list_free(&chan->srej_list);\n\t\tl2cap_seq_list_free(&chan->retrans_list);\n\t\tfallthrough;\n\n\tcase L2CAP_MODE_STREAMING:\n\t\tskb_queue_purge(&chan->tx_q);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_del);\n\nstatic void __l2cap_chan_list(struct l2cap_conn *conn, l2cap_chan_func_t func,\n\t\t\t      void *data)\n{\n\tstruct l2cap_chan *chan;\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tfunc(chan, data);\n\t}\n}\n\nvoid l2cap_chan_list(struct l2cap_conn *conn, l2cap_chan_func_t func,\n\t\t     void *data)\n{\n\tif (!conn)\n\t\treturn;\n\n\tmutex_lock(&conn->chan_lock);\n\t__l2cap_chan_list(conn, func, data);\n\tmutex_unlock(&conn->chan_lock);\n}\n\nEXPORT_SYMBOL_GPL(l2cap_chan_list);\n\nstatic void l2cap_conn_update_id_addr(struct work_struct *work)\n{\n\tstruct l2cap_conn *conn = container_of(work, struct l2cap_conn,\n\t\t\t\t\t       id_addr_update_work);\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_chan *chan;\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tl2cap_chan_lock(chan);\n\t\tbacpy(&chan->dst, &hcon->dst);\n\t\tchan->dst_type = bdaddr_dst_type(hcon);\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\nstatic void l2cap_chan_le_connect_reject(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_le_conn_rsp rsp;\n\tu16 result;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\tresult = L2CAP_CR_LE_AUTHORIZATION;\n\telse\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\n\tl2cap_state_change(chan, BT_DISCONN);\n\n\trsp.dcid    = cpu_to_le16(chan->scid);\n\trsp.mtu     = cpu_to_le16(chan->imtu);\n\trsp.mps     = cpu_to_le16(chan->mps);\n\trsp.credits = cpu_to_le16(chan->rx_credits);\n\trsp.result  = cpu_to_le16(result);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_RSP, sizeof(rsp),\n\t\t       &rsp);\n}\n\nstatic void l2cap_chan_ecred_connect_reject(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_ecred_conn_rsp rsp;\n\tu16 result;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\tresult = L2CAP_CR_LE_AUTHORIZATION;\n\telse\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\n\tl2cap_state_change(chan, BT_DISCONN);\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\trsp.result  = cpu_to_le16(result);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_RSP, sizeof(rsp),\n\t\t       &rsp);\n}\n\nstatic void l2cap_chan_connect_reject(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_conn_rsp rsp;\n\tu16 result;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\tresult = L2CAP_CR_SEC_BLOCK;\n\telse\n\t\tresult = L2CAP_CR_BAD_PSM;\n\n\tl2cap_state_change(chan, BT_DISCONN);\n\n\trsp.scid   = cpu_to_le16(chan->dcid);\n\trsp.dcid   = cpu_to_le16(chan->scid);\n\trsp.result = cpu_to_le16(result);\n\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP, sizeof(rsp), &rsp);\n}\n\nvoid l2cap_chan_close(struct l2cap_chan *chan, int reason)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\tswitch (chan->state) {\n\tcase BT_LISTEN:\n\t\tchan->ops->teardown(chan, 0);\n\t\tbreak;\n\n\tcase BT_CONNECTED:\n\tcase BT_CONFIG:\n\t\tif (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\t\t\tl2cap_send_disconn_req(chan, reason);\n\t\t} else\n\t\t\tl2cap_chan_del(chan, reason);\n\t\tbreak;\n\n\tcase BT_CONNECT2:\n\t\tif (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\tif (conn->hcon->type == ACL_LINK)\n\t\t\t\tl2cap_chan_connect_reject(chan);\n\t\t\telse if (conn->hcon->type == LE_LINK) {\n\t\t\t\tswitch (chan->mode) {\n\t\t\t\tcase L2CAP_MODE_LE_FLOWCTL:\n\t\t\t\t\tl2cap_chan_le_connect_reject(chan);\n\t\t\t\t\tbreak;\n\t\t\t\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\t\t\t\tl2cap_chan_ecred_connect_reject(chan);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tl2cap_chan_del(chan, reason);\n\t\tbreak;\n\n\tcase BT_CONNECT:\n\tcase BT_DISCONN:\n\t\tl2cap_chan_del(chan, reason);\n\t\tbreak;\n\n\tdefault:\n\t\tchan->ops->teardown(chan, 0);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(l2cap_chan_close);\n\nstatic inline u8 l2cap_get_auth_type(struct l2cap_chan *chan)\n{\n\tswitch (chan->chan_type) {\n\tcase L2CAP_CHAN_RAW:\n\t\tswitch (chan->sec_level) {\n\t\tcase BT_SECURITY_HIGH:\n\t\tcase BT_SECURITY_FIPS:\n\t\t\treturn HCI_AT_DEDICATED_BONDING_MITM;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\treturn HCI_AT_DEDICATED_BONDING;\n\t\tdefault:\n\t\t\treturn HCI_AT_NO_BONDING;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_CHAN_CONN_LESS:\n\t\tif (chan->psm == cpu_to_le16(L2CAP_PSM_3DSP)) {\n\t\t\tif (chan->sec_level == BT_SECURITY_LOW)\n\t\t\t\tchan->sec_level = BT_SECURITY_SDP;\n\t\t}\n\t\tif (chan->sec_level == BT_SECURITY_HIGH ||\n\t\t    chan->sec_level == BT_SECURITY_FIPS)\n\t\t\treturn HCI_AT_NO_BONDING_MITM;\n\t\telse\n\t\t\treturn HCI_AT_NO_BONDING;\n\t\tbreak;\n\tcase L2CAP_CHAN_CONN_ORIENTED:\n\t\tif (chan->psm == cpu_to_le16(L2CAP_PSM_SDP)) {\n\t\t\tif (chan->sec_level == BT_SECURITY_LOW)\n\t\t\t\tchan->sec_level = BT_SECURITY_SDP;\n\n\t\t\tif (chan->sec_level == BT_SECURITY_HIGH ||\n\t\t\t    chan->sec_level == BT_SECURITY_FIPS)\n\t\t\t\treturn HCI_AT_NO_BONDING_MITM;\n\t\t\telse\n\t\t\t\treturn HCI_AT_NO_BONDING;\n\t\t}\n\t\tfallthrough;\n\n\tdefault:\n\t\tswitch (chan->sec_level) {\n\t\tcase BT_SECURITY_HIGH:\n\t\tcase BT_SECURITY_FIPS:\n\t\t\treturn HCI_AT_GENERAL_BONDING_MITM;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\treturn HCI_AT_GENERAL_BONDING;\n\t\tdefault:\n\t\t\treturn HCI_AT_NO_BONDING;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n/* Service level security */\nint l2cap_chan_check_security(struct l2cap_chan *chan, bool initiator)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\t__u8 auth_type;\n\n\tif (conn->hcon->type == LE_LINK)\n\t\treturn smp_conn_security(conn->hcon, chan->sec_level);\n\n\tauth_type = l2cap_get_auth_type(chan);\n\n\treturn hci_conn_security(conn->hcon, chan->sec_level, auth_type,\n\t\t\t\t initiator);\n}\n\nstatic u8 l2cap_get_ident(struct l2cap_conn *conn)\n{\n\tu8 id;\n\n\t/* Get next available identificator.\n\t *    1 - 128 are used by kernel.\n\t *  129 - 199 are reserved.\n\t *  200 - 254 are used by utilities like l2ping, etc.\n\t */\n\n\tmutex_lock(&conn->ident_lock);\n\n\tif (++conn->tx_ident > 128)\n\t\tconn->tx_ident = 1;\n\n\tid = conn->tx_ident;\n\n\tmutex_unlock(&conn->ident_lock);\n\n\treturn id;\n}\n\nstatic void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,\n\t\t\t   void *data)\n{\n\tstruct sk_buff *skb = l2cap_build_cmd(conn, code, ident, len, data);\n\tu8 flags;\n\n\tBT_DBG(\"code 0x%2.2x\", code);\n\n\tif (!skb)\n\t\treturn;\n\n\t/* Use NO_FLUSH if supported or we have an LE link (which does\n\t * not support auto-flushing packets) */\n\tif (lmp_no_flush_capable(conn->hcon->hdev) ||\n\t    conn->hcon->type == LE_LINK)\n\t\tflags = ACL_START_NO_FLUSH;\n\telse\n\t\tflags = ACL_START;\n\n\tbt_cb(skb)->force_active = BT_POWER_FORCE_ACTIVE_ON;\n\tskb->priority = HCI_PRIO_MAX;\n\n\thci_send_acl(conn->hchan, skb, flags);\n}\n\nstatic bool __chan_is_moving(struct l2cap_chan *chan)\n{\n\treturn chan->move_state != L2CAP_MOVE_STABLE &&\n\t       chan->move_state != L2CAP_MOVE_WAIT_PREPARE;\n}\n\nstatic void l2cap_do_send(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct hci_conn *hcon = chan->conn->hcon;\n\tu16 flags;\n\n\tBT_DBG(\"chan %p, skb %p len %d priority %u\", chan, skb, skb->len,\n\t       skb->priority);\n\n\tif (chan->hs_hcon && !__chan_is_moving(chan)) {\n\t\tif (chan->hs_hchan)\n\t\t\thci_send_acl(chan->hs_hchan, skb, ACL_COMPLETE);\n\t\telse\n\t\t\tkfree_skb(skb);\n\n\t\treturn;\n\t}\n\n\t/* Use NO_FLUSH for LE links (where this is the only option) or\n\t * if the BR/EDR link supports it and flushing has not been\n\t * explicitly requested (through FLAG_FLUSHABLE).\n\t */\n\tif (hcon->type == LE_LINK ||\n\t    (!test_bit(FLAG_FLUSHABLE, &chan->flags) &&\n\t     lmp_no_flush_capable(hcon->hdev)))\n\t\tflags = ACL_START_NO_FLUSH;\n\telse\n\t\tflags = ACL_START;\n\n\tbt_cb(skb)->force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n\thci_send_acl(chan->conn->hchan, skb, flags);\n}\n\nstatic void __unpack_enhanced_control(u16 enh, struct l2cap_ctrl *control)\n{\n\tcontrol->reqseq = (enh & L2CAP_CTRL_REQSEQ) >> L2CAP_CTRL_REQSEQ_SHIFT;\n\tcontrol->final = (enh & L2CAP_CTRL_FINAL) >> L2CAP_CTRL_FINAL_SHIFT;\n\n\tif (enh & L2CAP_CTRL_FRAME_TYPE) {\n\t\t/* S-Frame */\n\t\tcontrol->sframe = 1;\n\t\tcontrol->poll = (enh & L2CAP_CTRL_POLL) >> L2CAP_CTRL_POLL_SHIFT;\n\t\tcontrol->super = (enh & L2CAP_CTRL_SUPERVISE) >> L2CAP_CTRL_SUPER_SHIFT;\n\n\t\tcontrol->sar = 0;\n\t\tcontrol->txseq = 0;\n\t} else {\n\t\t/* I-Frame */\n\t\tcontrol->sframe = 0;\n\t\tcontrol->sar = (enh & L2CAP_CTRL_SAR) >> L2CAP_CTRL_SAR_SHIFT;\n\t\tcontrol->txseq = (enh & L2CAP_CTRL_TXSEQ) >> L2CAP_CTRL_TXSEQ_SHIFT;\n\n\t\tcontrol->poll = 0;\n\t\tcontrol->super = 0;\n\t}\n}\n\nstatic void __unpack_extended_control(u32 ext, struct l2cap_ctrl *control)\n{\n\tcontrol->reqseq = (ext & L2CAP_EXT_CTRL_REQSEQ) >> L2CAP_EXT_CTRL_REQSEQ_SHIFT;\n\tcontrol->final = (ext & L2CAP_EXT_CTRL_FINAL) >> L2CAP_EXT_CTRL_FINAL_SHIFT;\n\n\tif (ext & L2CAP_EXT_CTRL_FRAME_TYPE) {\n\t\t/* S-Frame */\n\t\tcontrol->sframe = 1;\n\t\tcontrol->poll = (ext & L2CAP_EXT_CTRL_POLL) >> L2CAP_EXT_CTRL_POLL_SHIFT;\n\t\tcontrol->super = (ext & L2CAP_EXT_CTRL_SUPERVISE) >> L2CAP_EXT_CTRL_SUPER_SHIFT;\n\n\t\tcontrol->sar = 0;\n\t\tcontrol->txseq = 0;\n\t} else {\n\t\t/* I-Frame */\n\t\tcontrol->sframe = 0;\n\t\tcontrol->sar = (ext & L2CAP_EXT_CTRL_SAR) >> L2CAP_EXT_CTRL_SAR_SHIFT;\n\t\tcontrol->txseq = (ext & L2CAP_EXT_CTRL_TXSEQ) >> L2CAP_EXT_CTRL_TXSEQ_SHIFT;\n\n\t\tcontrol->poll = 0;\n\t\tcontrol->super = 0;\n\t}\n}\n\nstatic inline void __unpack_control(struct l2cap_chan *chan,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags)) {\n\t\t__unpack_extended_control(get_unaligned_le32(skb->data),\n\t\t\t\t\t  &bt_cb(skb)->l2cap);\n\t\tskb_pull(skb, L2CAP_EXT_CTRL_SIZE);\n\t} else {\n\t\t__unpack_enhanced_control(get_unaligned_le16(skb->data),\n\t\t\t\t\t  &bt_cb(skb)->l2cap);\n\t\tskb_pull(skb, L2CAP_ENH_CTRL_SIZE);\n\t}\n}\n\nstatic u32 __pack_extended_control(struct l2cap_ctrl *control)\n{\n\tu32 packed;\n\n\tpacked = control->reqseq << L2CAP_EXT_CTRL_REQSEQ_SHIFT;\n\tpacked |= control->final << L2CAP_EXT_CTRL_FINAL_SHIFT;\n\n\tif (control->sframe) {\n\t\tpacked |= control->poll << L2CAP_EXT_CTRL_POLL_SHIFT;\n\t\tpacked |= control->super << L2CAP_EXT_CTRL_SUPER_SHIFT;\n\t\tpacked |= L2CAP_EXT_CTRL_FRAME_TYPE;\n\t} else {\n\t\tpacked |= control->sar << L2CAP_EXT_CTRL_SAR_SHIFT;\n\t\tpacked |= control->txseq << L2CAP_EXT_CTRL_TXSEQ_SHIFT;\n\t}\n\n\treturn packed;\n}\n\nstatic u16 __pack_enhanced_control(struct l2cap_ctrl *control)\n{\n\tu16 packed;\n\n\tpacked = control->reqseq << L2CAP_CTRL_REQSEQ_SHIFT;\n\tpacked |= control->final << L2CAP_CTRL_FINAL_SHIFT;\n\n\tif (control->sframe) {\n\t\tpacked |= control->poll << L2CAP_CTRL_POLL_SHIFT;\n\t\tpacked |= control->super << L2CAP_CTRL_SUPER_SHIFT;\n\t\tpacked |= L2CAP_CTRL_FRAME_TYPE;\n\t} else {\n\t\tpacked |= control->sar << L2CAP_CTRL_SAR_SHIFT;\n\t\tpacked |= control->txseq << L2CAP_CTRL_TXSEQ_SHIFT;\n\t}\n\n\treturn packed;\n}\n\nstatic inline void __pack_control(struct l2cap_chan *chan,\n\t\t\t\t  struct l2cap_ctrl *control,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags)) {\n\t\tput_unaligned_le32(__pack_extended_control(control),\n\t\t\t\t   skb->data + L2CAP_HDR_SIZE);\n\t} else {\n\t\tput_unaligned_le16(__pack_enhanced_control(control),\n\t\t\t\t   skb->data + L2CAP_HDR_SIZE);\n\t}\n}\n\nstatic inline unsigned int __ertm_hdr_size(struct l2cap_chan *chan)\n{\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\treturn L2CAP_EXT_HDR_SIZE;\n\telse\n\t\treturn L2CAP_ENH_HDR_SIZE;\n}\n\nstatic struct sk_buff *l2cap_create_sframe_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t       u32 control)\n{\n\tstruct sk_buff *skb;\n\tstruct l2cap_hdr *lh;\n\tint hlen = __ertm_hdr_size(chan);\n\n\tif (chan->fcs == L2CAP_FCS_CRC16)\n\t\thlen += L2CAP_FCS_SIZE;\n\n\tskb = bt_skb_alloc(hlen, GFP_KERNEL);\n\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->len = cpu_to_le16(hlen - L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\tput_unaligned_le32(control, skb_put(skb, L2CAP_EXT_CTRL_SIZE));\n\telse\n\t\tput_unaligned_le16(control, skb_put(skb, L2CAP_ENH_CTRL_SIZE));\n\n\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\tu16 fcs = crc16(0, (u8 *)skb->data, skb->len);\n\t\tput_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));\n\t}\n\n\tskb->priority = HCI_PRIO_MAX;\n\treturn skb;\n}\n\nstatic void l2cap_send_sframe(struct l2cap_chan *chan,\n\t\t\t      struct l2cap_ctrl *control)\n{\n\tstruct sk_buff *skb;\n\tu32 control_field;\n\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tif (!control->sframe)\n\t\treturn;\n\n\tif (__chan_is_moving(chan))\n\t\treturn;\n\n\tif (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state) &&\n\t    !control->poll)\n\t\tcontrol->final = 1;\n\n\tif (control->super == L2CAP_SUPER_RR)\n\t\tclear_bit(CONN_RNR_SENT, &chan->conn_state);\n\telse if (control->super == L2CAP_SUPER_RNR)\n\t\tset_bit(CONN_RNR_SENT, &chan->conn_state);\n\n\tif (control->super != L2CAP_SUPER_SREJ) {\n\t\tchan->last_acked_seq = control->reqseq;\n\t\t__clear_ack_timer(chan);\n\t}\n\n\tBT_DBG(\"reqseq %d, final %d, poll %d, super %d\", control->reqseq,\n\t       control->final, control->poll, control->super);\n\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\tcontrol_field = __pack_extended_control(control);\n\telse\n\t\tcontrol_field = __pack_enhanced_control(control);\n\n\tskb = l2cap_create_sframe_pdu(chan, control_field);\n\tif (!IS_ERR(skb))\n\t\tl2cap_do_send(chan, skb);\n}\n\nstatic void l2cap_send_rr_or_rnr(struct l2cap_chan *chan, bool poll)\n{\n\tstruct l2cap_ctrl control;\n\n\tBT_DBG(\"chan %p, poll %d\", chan, poll);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.poll = poll;\n\n\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state))\n\t\tcontrol.super = L2CAP_SUPER_RNR;\n\telse\n\t\tcontrol.super = L2CAP_SUPER_RR;\n\n\tcontrol.reqseq = chan->buffer_seq;\n\tl2cap_send_sframe(chan, &control);\n}\n\nstatic inline int __l2cap_no_conn_pending(struct l2cap_chan *chan)\n{\n\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED)\n\t\treturn true;\n\n\treturn !test_bit(CONF_CONNECT_PEND, &chan->conf_state);\n}\n\nstatic bool __amp_capable(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct hci_dev *hdev;\n\tbool amp_available = false;\n\n\tif (!(conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\treturn false;\n\n\tif (!(conn->remote_fixed_chan & L2CAP_FC_A2MP))\n\t\treturn false;\n\n\tread_lock(&hci_dev_list_lock);\n\tlist_for_each_entry(hdev, &hci_dev_list, list) {\n\t\tif (hdev->amp_type != AMP_TYPE_BREDR &&\n\t\t    test_bit(HCI_UP, &hdev->flags)) {\n\t\t\tamp_available = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&hci_dev_list_lock);\n\n\tif (chan->chan_policy == BT_CHANNEL_POLICY_AMP_PREFERRED)\n\t\treturn amp_available;\n\n\treturn false;\n}\n\nstatic bool l2cap_check_efs(struct l2cap_chan *chan)\n{\n\t/* Check EFS parameters */\n\treturn true;\n}\n\nvoid l2cap_send_conn_req(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_conn_req req;\n\n\treq.scid = cpu_to_le16(chan->scid);\n\treq.psm  = chan->psm;\n\n\tchan->ident = l2cap_get_ident(conn);\n\n\tset_bit(CONF_CONNECT_PEND, &chan->conf_state);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_REQ, sizeof(req), &req);\n}\n\nstatic void l2cap_send_create_chan_req(struct l2cap_chan *chan, u8 amp_id)\n{\n\tstruct l2cap_create_chan_req req;\n\treq.scid = cpu_to_le16(chan->scid);\n\treq.psm  = chan->psm;\n\treq.amp_id = amp_id;\n\n\tchan->ident = l2cap_get_ident(chan->conn);\n\n\tl2cap_send_cmd(chan->conn, chan->ident, L2CAP_CREATE_CHAN_REQ,\n\t\t       sizeof(req), &req);\n}\n\nstatic void l2cap_move_setup(struct l2cap_chan *chan)\n{\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->mode != L2CAP_MODE_ERTM)\n\t\treturn;\n\n\t__clear_retrans_timer(chan);\n\t__clear_monitor_timer(chan);\n\t__clear_ack_timer(chan);\n\n\tchan->retry_count = 0;\n\tskb_queue_walk(&chan->tx_q, skb) {\n\t\tif (bt_cb(skb)->l2cap.retries)\n\t\t\tbt_cb(skb)->l2cap.retries = 1;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tchan->expected_tx_seq = chan->buffer_seq;\n\n\tclear_bit(CONN_REJ_ACT, &chan->conn_state);\n\tclear_bit(CONN_SREJ_ACT, &chan->conn_state);\n\tl2cap_seq_list_clear(&chan->retrans_list);\n\tl2cap_seq_list_clear(&chan->srej_list);\n\tskb_queue_purge(&chan->srej_q);\n\n\tchan->tx_state = L2CAP_TX_STATE_XMIT;\n\tchan->rx_state = L2CAP_RX_STATE_MOVE;\n\n\tset_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n}\n\nstatic void l2cap_move_done(struct l2cap_chan *chan)\n{\n\tu8 move_role = chan->move_role;\n\tBT_DBG(\"chan %p\", chan);\n\n\tchan->move_state = L2CAP_MOVE_STABLE;\n\tchan->move_role = L2CAP_MOVE_ROLE_NONE;\n\n\tif (chan->mode != L2CAP_MODE_ERTM)\n\t\treturn;\n\n\tswitch (move_role) {\n\tcase L2CAP_MOVE_ROLE_INITIATOR:\n\t\tl2cap_tx(chan, NULL, NULL, L2CAP_EV_EXPLICIT_POLL);\n\t\tchan->rx_state = L2CAP_RX_STATE_WAIT_F;\n\t\tbreak;\n\tcase L2CAP_MOVE_ROLE_RESPONDER:\n\t\tchan->rx_state = L2CAP_RX_STATE_WAIT_P;\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_chan_ready(struct l2cap_chan *chan)\n{\n\t/* The channel may have already been flagged as connected in\n\t * case of receiving data before the L2CAP info req/rsp\n\t * procedure is complete.\n\t */\n\tif (chan->state == BT_CONNECTED)\n\t\treturn;\n\n\t/* This clears all conf flags, including CONF_NOT_COMPLETE */\n\tchan->conf_state = 0;\n\t__clear_chan_timer(chan);\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tif (!chan->tx_credits)\n\t\t\tchan->ops->suspend(chan);\n\t\tbreak;\n\t}\n\n\tchan->state = BT_CONNECTED;\n\n\tchan->ops->ready(chan);\n}\n\nstatic void l2cap_le_connect(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_le_conn_req req;\n\n\tif (test_and_set_bit(FLAG_LE_CONN_REQ_SENT, &chan->flags))\n\t\treturn;\n\n\tif (!chan->imtu)\n\t\tchan->imtu = chan->conn->mtu;\n\n\tl2cap_le_flowctl_init(chan, 0);\n\n\tmemset(&req, 0, sizeof(req));\n\treq.psm     = chan->psm;\n\treq.scid    = cpu_to_le16(chan->scid);\n\treq.mtu     = cpu_to_le16(chan->imtu);\n\treq.mps     = cpu_to_le16(chan->mps);\n\treq.credits = cpu_to_le16(chan->rx_credits);\n\n\tchan->ident = l2cap_get_ident(conn);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_REQ,\n\t\t       sizeof(req), &req);\n}\n\nstruct l2cap_ecred_conn_data {\n\tstruct {\n\t\tstruct l2cap_ecred_conn_req req;\n\t\t__le16 scid[5];\n\t} __packed pdu;\n\tstruct l2cap_chan *chan;\n\tstruct pid *pid;\n\tint count;\n};\n\nstatic void l2cap_ecred_defer_connect(struct l2cap_chan *chan, void *data)\n{\n\tstruct l2cap_ecred_conn_data *conn = data;\n\tstruct pid *pid;\n\n\tif (chan == conn->chan)\n\t\treturn;\n\n\tif (!test_and_clear_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\treturn;\n\n\tpid = chan->ops->get_peer_pid(chan);\n\n\t/* Only add deferred channels with the same PID/PSM */\n\tif (conn->pid != pid || chan->psm != conn->chan->psm || chan->ident ||\n\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL || chan->state != BT_CONNECT)\n\t\treturn;\n\n\tif (test_and_set_bit(FLAG_ECRED_CONN_REQ_SENT, &chan->flags))\n\t\treturn;\n\n\tl2cap_ecred_init(chan, 0);\n\n\t/* Set the same ident so we can match on the rsp */\n\tchan->ident = conn->chan->ident;\n\n\t/* Include all channels deferred */\n\tconn->pdu.scid[conn->count] = cpu_to_le16(chan->scid);\n\n\tconn->count++;\n}\n\nstatic void l2cap_ecred_connect(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_ecred_conn_data data;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\treturn;\n\n\tif (test_and_set_bit(FLAG_ECRED_CONN_REQ_SENT, &chan->flags))\n\t\treturn;\n\n\tl2cap_ecred_init(chan, 0);\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.pdu.req.psm     = chan->psm;\n\tdata.pdu.req.mtu     = cpu_to_le16(chan->imtu);\n\tdata.pdu.req.mps     = cpu_to_le16(chan->mps);\n\tdata.pdu.req.credits = cpu_to_le16(chan->rx_credits);\n\tdata.pdu.scid[0]     = cpu_to_le16(chan->scid);\n\n\tchan->ident = l2cap_get_ident(conn);\n\n\tdata.count = 1;\n\tdata.chan = chan;\n\tdata.pid = chan->ops->get_peer_pid(chan);\n\n\t__l2cap_chan_list(conn, l2cap_ecred_defer_connect, &data);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_ECRED_CONN_REQ,\n\t\t       sizeof(data.pdu.req) + data.count * sizeof(__le16),\n\t\t       &data.pdu);\n}\n\nstatic void l2cap_le_start(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tif (!smp_conn_security(conn->hcon, chan->sec_level))\n\t\treturn;\n\n\tif (!chan->psm) {\n\t\tl2cap_chan_ready(chan);\n\t\treturn;\n\t}\n\n\tif (chan->state == BT_CONNECT) {\n\t\tif (chan->mode == L2CAP_MODE_EXT_FLOWCTL)\n\t\t\tl2cap_ecred_connect(chan);\n\t\telse\n\t\t\tl2cap_le_connect(chan);\n\t}\n}\n\nstatic void l2cap_start_connection(struct l2cap_chan *chan)\n{\n\tif (__amp_capable(chan)) {\n\t\tBT_DBG(\"chan %p AMP capable: discover AMPs\", chan);\n\t\ta2mp_discover_amp(chan);\n\t} else if (chan->conn->hcon->type == LE_LINK) {\n\t\tl2cap_le_start(chan);\n\t} else {\n\t\tl2cap_send_conn_req(chan);\n\t}\n}\n\nstatic void l2cap_request_info(struct l2cap_conn *conn)\n{\n\tstruct l2cap_info_req req;\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)\n\t\treturn;\n\n\treq.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\n\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;\n\tconn->info_ident = l2cap_get_ident(conn);\n\n\tschedule_delayed_work(&conn->info_timer, L2CAP_INFO_TIMEOUT);\n\n\tl2cap_send_cmd(conn, conn->info_ident, L2CAP_INFO_REQ,\n\t\t       sizeof(req), &req);\n}\n\nstatic bool l2cap_check_enc_key_size(struct hci_conn *hcon)\n{\n\t/* The minimum encryption key size needs to be enforced by the\n\t * host stack before establishing any L2CAP connections. The\n\t * specification in theory allows a minimum of 1, but to align\n\t * BR/EDR and LE transports, a minimum of 7 is chosen.\n\t *\n\t * This check might also be called for unencrypted connections\n\t * that have no key size requirements. Ensure that the link is\n\t * actually encrypted before enforcing a key size.\n\t */\n\tint min_key_size = hcon->hdev->min_enc_key_size;\n\n\t/* On FIPS security level, key size must be 16 bytes */\n\tif (hcon->sec_level == BT_SECURITY_FIPS)\n\t\tmin_key_size = 16;\n\n\treturn (!test_bit(HCI_CONN_ENCRYPT, &hcon->flags) ||\n\t\thcon->enc_key_size >= min_key_size);\n}\n\nstatic void l2cap_do_start(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tif (conn->hcon->type == LE_LINK) {\n\t\tl2cap_le_start(chan);\n\t\treturn;\n\t}\n\n\tif (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)) {\n\t\tl2cap_request_info(conn);\n\t\treturn;\n\t}\n\n\tif (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))\n\t\treturn;\n\n\tif (!l2cap_chan_check_security(chan, true) ||\n\t    !__l2cap_no_conn_pending(chan))\n\t\treturn;\n\n\tif (l2cap_check_enc_key_size(conn->hcon))\n\t\tl2cap_start_connection(chan);\n\telse\n\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n}\n\nstatic inline int l2cap_mode_supported(__u8 mode, __u32 feat_mask)\n{\n\tu32 local_feat_mask = l2cap_feat_mask;\n\tif (!disable_ertm)\n\t\tlocal_feat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING;\n\n\tswitch (mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\treturn L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;\n\tdefault:\n\t\treturn 0x00;\n\t}\n}\n\nstatic void l2cap_send_disconn_req(struct l2cap_chan *chan, int err)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_disconn_req req;\n\n\tif (!conn)\n\t\treturn;\n\n\tif (chan->mode == L2CAP_MODE_ERTM && chan->state == BT_CONNECTED) {\n\t\t__clear_retrans_timer(chan);\n\t\t__clear_monitor_timer(chan);\n\t\t__clear_ack_timer(chan);\n\t}\n\n\tif (chan->scid == L2CAP_CID_A2MP) {\n\t\tl2cap_state_change(chan, BT_DISCONN);\n\t\treturn;\n\t}\n\n\treq.dcid = cpu_to_le16(chan->dcid);\n\treq.scid = cpu_to_le16(chan->scid);\n\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_DISCONN_REQ,\n\t\t       sizeof(req), &req);\n\n\tl2cap_state_change_and_error(chan, BT_DISCONN, err);\n}\n\n/* ---- L2CAP connections ---- */\nstatic void l2cap_conn_start(struct l2cap_conn *conn)\n{\n\tstruct l2cap_chan *chan, *tmp;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry_safe(chan, tmp, &conn->chan_l, list) {\n\t\tl2cap_chan_lock(chan);\n\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\tl2cap_chan_ready(chan);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chan->state == BT_CONNECT) {\n\t\t\tif (!l2cap_chan_check_security(chan, true) ||\n\t\t\t    !__l2cap_no_conn_pending(chan)) {\n\t\t\t\tl2cap_chan_unlock(chan);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!l2cap_mode_supported(chan->mode, conn->feat_mask)\n\t\t\t    && test_bit(CONF_STATE2_DEVICE,\n\t\t\t\t\t&chan->conf_state)) {\n\t\t\t\tl2cap_chan_close(chan, ECONNRESET);\n\t\t\t\tl2cap_chan_unlock(chan);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (l2cap_check_enc_key_size(conn->hcon))\n\t\t\t\tl2cap_start_connection(chan);\n\t\t\telse\n\t\t\t\tl2cap_chan_close(chan, ECONNREFUSED);\n\n\t\t} else if (chan->state == BT_CONNECT2) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\tchar buf[128];\n\t\t\trsp.scid = cpu_to_le16(chan->dcid);\n\t\t\trsp.dcid = cpu_to_le16(chan->scid);\n\n\t\t\tif (l2cap_chan_check_security(chan, false)) {\n\t\t\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_PEND);\n\t\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_AUTHOR_PEND);\n\t\t\t\t\tchan->ops->defer(chan);\n\n\t\t\t\t} else {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\t\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_PEND);\n\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_AUTHEN_PEND);\n\t\t\t}\n\n\t\t\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,\n\t\t\t\t       sizeof(rsp), &rsp);\n\n\t\t\tif (test_bit(CONF_REQ_SENT, &chan->conf_state) ||\n\t\t\t    rsp.result != L2CAP_CR_SUCCESS) {\n\t\t\t\tl2cap_chan_unlock(chan);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\t\t\tchan->num_conf_req++;\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\nstatic void l2cap_le_conn_ready(struct l2cap_conn *conn)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct hci_dev *hdev = hcon->hdev;\n\n\tBT_DBG(\"%s conn %p\", hdev->name, conn);\n\n\t/* For outgoing pairing which doesn't necessarily have an\n\t * associated socket (e.g. mgmt_pair_device).\n\t */\n\tif (hcon->out)\n\t\tsmp_conn_security(hcon, hcon->pending_sec_level);\n\n\t/* For LE peripheral connections, make sure the connection interval\n\t * is in the range of the minimum and maximum interval that has\n\t * been configured for this connection. If not, then trigger\n\t * the connection update procedure.\n\t */\n\tif (hcon->role == HCI_ROLE_SLAVE &&\n\t    (hcon->le_conn_interval < hcon->le_conn_min_interval ||\n\t     hcon->le_conn_interval > hcon->le_conn_max_interval)) {\n\t\tstruct l2cap_conn_param_update_req req;\n\n\t\treq.min = cpu_to_le16(hcon->le_conn_min_interval);\n\t\treq.max = cpu_to_le16(hcon->le_conn_max_interval);\n\t\treq.latency = cpu_to_le16(hcon->le_conn_latency);\n\t\treq.to_multiplier = cpu_to_le16(hcon->le_supv_timeout);\n\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t       L2CAP_CONN_PARAM_UPDATE_REQ, sizeof(req), &req);\n\t}\n}\n\nstatic void l2cap_conn_ready(struct l2cap_conn *conn)\n{\n\tstruct l2cap_chan *chan;\n\tstruct hci_conn *hcon = conn->hcon;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tif (hcon->type == ACL_LINK)\n\t\tl2cap_request_info(conn);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\n\t\tl2cap_chan_lock(chan);\n\n\t\tif (chan->scid == L2CAP_CID_A2MP) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hcon->type == LE_LINK) {\n\t\t\tl2cap_le_start(chan);\n\t\t} else if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)\n\t\t\t\tl2cap_chan_ready(chan);\n\t\t} else if (chan->state == BT_CONNECT) {\n\t\t\tl2cap_do_start(chan);\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n\n\tif (hcon->type == LE_LINK)\n\t\tl2cap_le_conn_ready(conn);\n\n\tqueue_work(hcon->hdev->workqueue, &conn->pending_rx_work);\n}\n\n/* Notify sockets that we cannot guaranty reliability anymore */\nstatic void l2cap_conn_unreliable(struct l2cap_conn *conn, int err)\n{\n\tstruct l2cap_chan *chan;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tif (test_bit(FLAG_FORCE_RELIABLE, &chan->flags))\n\t\t\tl2cap_chan_set_err(chan, err);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\nstatic void l2cap_info_timeout(struct work_struct *work)\n{\n\tstruct l2cap_conn *conn = container_of(work, struct l2cap_conn,\n\t\t\t\t\t       info_timer.work);\n\n\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\tconn->info_ident = 0;\n\n\tl2cap_conn_start(conn);\n}\n\n/*\n * l2cap_user\n * External modules can register l2cap_user objects on l2cap_conn. The ->probe\n * callback is called during registration. The ->remove callback is called\n * during unregistration.\n * An l2cap_user object can either be explicitly unregistered or when the\n * underlying l2cap_conn object is deleted. This guarantees that l2cap->hcon,\n * l2cap->hchan, .. are valid as long as the remove callback hasn't been called.\n * External modules must own a reference to the l2cap_conn object if they intend\n * to call l2cap_unregister_user(). The l2cap_conn object might get destroyed at\n * any time if they don't.\n */\n\nint l2cap_register_user(struct l2cap_conn *conn, struct l2cap_user *user)\n{\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\tint ret;\n\n\t/* We need to check whether l2cap_conn is registered. If it is not, we\n\t * must not register the l2cap_user. l2cap_conn_del() is unregisters\n\t * l2cap_conn objects, but doesn't provide its own locking. Instead, it\n\t * relies on the parent hci_conn object to be locked. This itself relies\n\t * on the hci_dev object to be locked. So we must lock the hci device\n\t * here, too. */\n\n\thci_dev_lock(hdev);\n\n\tif (!list_empty(&user->list)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* conn->hchan is NULL after l2cap_conn_del() was called */\n\tif (!conn->hchan) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tret = user->probe(conn, user);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tlist_add(&user->list, &conn->users);\n\tret = 0;\n\nout_unlock:\n\thci_dev_unlock(hdev);\n\treturn ret;\n}\nEXPORT_SYMBOL(l2cap_register_user);\n\nvoid l2cap_unregister_user(struct l2cap_conn *conn, struct l2cap_user *user)\n{\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\n\thci_dev_lock(hdev);\n\n\tif (list_empty(&user->list))\n\t\tgoto out_unlock;\n\n\tlist_del_init(&user->list);\n\tuser->remove(conn, user);\n\nout_unlock:\n\thci_dev_unlock(hdev);\n}\nEXPORT_SYMBOL(l2cap_unregister_user);\n\nstatic void l2cap_unregister_all_users(struct l2cap_conn *conn)\n{\n\tstruct l2cap_user *user;\n\n\twhile (!list_empty(&conn->users)) {\n\t\tuser = list_first_entry(&conn->users, struct l2cap_user, list);\n\t\tlist_del_init(&user->list);\n\t\tuser->remove(conn, user);\n\t}\n}\n\nstatic void l2cap_conn_del(struct hci_conn *hcon, int err)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct l2cap_chan *chan, *l;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p conn %p, err %d\", hcon, conn, err);\n\n\tkfree_skb(conn->rx_skb);\n\n\tskb_queue_purge(&conn->pending_rx);\n\n\t/* We can not call flush_work(&conn->pending_rx_work) here since we\n\t * might block if we are running on a worker from the same workqueue\n\t * pending_rx_work is waiting on.\n\t */\n\tif (work_pending(&conn->pending_rx_work))\n\t\tcancel_work_sync(&conn->pending_rx_work);\n\n\tif (work_pending(&conn->id_addr_update_work))\n\t\tcancel_work_sync(&conn->id_addr_update_work);\n\n\tl2cap_unregister_all_users(conn);\n\n\t/* Force the connection to be immediately dropped */\n\thcon->disc_timeout = 0;\n\n\tmutex_lock(&conn->chan_lock);\n\n\t/* Kill channels */\n\tlist_for_each_entry_safe(chan, l, &conn->chan_l, list) {\n\t\tl2cap_chan_hold(chan);\n\t\tl2cap_chan_lock(chan);\n\n\t\tl2cap_chan_del(chan, err);\n\n\t\tchan->ops->close(chan);\n\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n\n\thci_chan_del(conn->hchan);\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)\n\t\tcancel_delayed_work_sync(&conn->info_timer);\n\n\thcon->l2cap_data = NULL;\n\tconn->hchan = NULL;\n\tl2cap_conn_put(conn);\n}\n\nstatic void l2cap_conn_free(struct kref *ref)\n{\n\tstruct l2cap_conn *conn = container_of(ref, struct l2cap_conn, ref);\n\n\thci_conn_put(conn->hcon);\n\tkfree(conn);\n}\n\nstruct l2cap_conn *l2cap_conn_get(struct l2cap_conn *conn)\n{\n\tkref_get(&conn->ref);\n\treturn conn;\n}\nEXPORT_SYMBOL(l2cap_conn_get);\n\nvoid l2cap_conn_put(struct l2cap_conn *conn)\n{\n\tkref_put(&conn->ref, l2cap_conn_free);\n}\nEXPORT_SYMBOL(l2cap_conn_put);\n\n/* ---- Socket interface ---- */\n\n/* Find socket with psm and source / destination bdaddr.\n * Returns closest match.\n */\nstatic struct l2cap_chan *l2cap_global_chan_by_psm(int state, __le16 psm,\n\t\t\t\t\t\t   bdaddr_t *src,\n\t\t\t\t\t\t   bdaddr_t *dst,\n\t\t\t\t\t\t   u8 link_type)\n{\n\tstruct l2cap_chan *c, *tmp, *c1 = NULL;\n\n\tread_lock(&chan_list_lock);\n\n\tlist_for_each_entry_safe(c, tmp, &chan_list, global_l) {\n\t\tif (state && c->state != state)\n\t\t\tcontinue;\n\n\t\tif (link_type == ACL_LINK && c->src_type != BDADDR_BREDR)\n\t\t\tcontinue;\n\n\t\tif (link_type == LE_LINK && c->src_type == BDADDR_BREDR)\n\t\t\tcontinue;\n\n\t\tif (c->chan_type != L2CAP_CHAN_FIXED && c->psm == psm) {\n\t\t\tint src_match, dst_match;\n\t\t\tint src_any, dst_any;\n\n\t\t\t/* Exact match. */\n\t\t\tsrc_match = !bacmp(&c->src, src);\n\t\t\tdst_match = !bacmp(&c->dst, dst);\n\t\t\tif (src_match && dst_match) {\n\t\t\t\tif (!l2cap_chan_hold_unless_zero(c))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tread_unlock(&chan_list_lock);\n\t\t\t\treturn c;\n\t\t\t}\n\n\t\t\t/* Closest match */\n\t\t\tsrc_any = !bacmp(&c->src, BDADDR_ANY);\n\t\t\tdst_any = !bacmp(&c->dst, BDADDR_ANY);\n\t\t\tif ((src_match && dst_any) || (src_any && dst_match) ||\n\t\t\t    (src_any && dst_any))\n\t\t\t\tc1 = c;\n\t\t}\n\t}\n\n\tif (c1)\n\t\tc1 = l2cap_chan_hold_unless_zero(c1);\n\n\tread_unlock(&chan_list_lock);\n\n\treturn c1;\n}\n\nstatic void l2cap_monitor_timeout(struct work_struct *work)\n{\n\tstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\n\t\t\t\t\t       monitor_timer.work);\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tl2cap_chan_lock(chan);\n\n\tif (!chan->conn) {\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t\treturn;\n\t}\n\n\tl2cap_tx(chan, NULL, NULL, L2CAP_EV_MONITOR_TO);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nstatic void l2cap_retrans_timeout(struct work_struct *work)\n{\n\tstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\n\t\t\t\t\t       retrans_timer.work);\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tl2cap_chan_lock(chan);\n\n\tif (!chan->conn) {\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t\treturn;\n\t}\n\n\tl2cap_tx(chan, NULL, NULL, L2CAP_EV_RETRANS_TO);\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nstatic void l2cap_streaming_send(struct l2cap_chan *chan,\n\t\t\t\t struct sk_buff_head *skbs)\n{\n\tstruct sk_buff *skb;\n\tstruct l2cap_ctrl *control;\n\n\tBT_DBG(\"chan %p, skbs %p\", chan, skbs);\n\n\tif (__chan_is_moving(chan))\n\t\treturn;\n\n\tskb_queue_splice_tail_init(skbs, &chan->tx_q);\n\n\twhile (!skb_queue_empty(&chan->tx_q)) {\n\n\t\tskb = skb_dequeue(&chan->tx_q);\n\n\t\tbt_cb(skb)->l2cap.retries = 1;\n\t\tcontrol = &bt_cb(skb)->l2cap;\n\n\t\tcontrol->reqseq = 0;\n\t\tcontrol->txseq = chan->next_tx_seq;\n\n\t\t__pack_control(chan, control, skb);\n\n\t\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\t\tu16 fcs = crc16(0, (u8 *) skb->data, skb->len);\n\t\t\tput_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));\n\t\t}\n\n\t\tl2cap_do_send(chan, skb);\n\n\t\tBT_DBG(\"Sent txseq %u\", control->txseq);\n\n\t\tchan->next_tx_seq = __next_seq(chan, chan->next_tx_seq);\n\t\tchan->frames_sent++;\n\t}\n}\n\nstatic int l2cap_ertm_send(struct l2cap_chan *chan)\n{\n\tstruct sk_buff *skb, *tx_skb;\n\tstruct l2cap_ctrl *control;\n\tint sent = 0;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->state != BT_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\tif (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))\n\t\treturn 0;\n\n\tif (__chan_is_moving(chan))\n\t\treturn 0;\n\n\twhile (chan->tx_send_head &&\n\t       chan->unacked_frames < chan->remote_tx_win &&\n\t       chan->tx_state == L2CAP_TX_STATE_XMIT) {\n\n\t\tskb = chan->tx_send_head;\n\n\t\tbt_cb(skb)->l2cap.retries = 1;\n\t\tcontrol = &bt_cb(skb)->l2cap;\n\n\t\tif (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))\n\t\t\tcontrol->final = 1;\n\n\t\tcontrol->reqseq = chan->buffer_seq;\n\t\tchan->last_acked_seq = chan->buffer_seq;\n\t\tcontrol->txseq = chan->next_tx_seq;\n\n\t\t__pack_control(chan, control, skb);\n\n\t\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\t\tu16 fcs = crc16(0, (u8 *) skb->data, skb->len);\n\t\t\tput_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));\n\t\t}\n\n\t\t/* Clone after data has been modified. Data is assumed to be\n\t\t   read-only (for locking purposes) on cloned sk_buffs.\n\t\t */\n\t\ttx_skb = skb_clone(skb, GFP_KERNEL);\n\n\t\tif (!tx_skb)\n\t\t\tbreak;\n\n\t\t__set_retrans_timer(chan);\n\n\t\tchan->next_tx_seq = __next_seq(chan, chan->next_tx_seq);\n\t\tchan->unacked_frames++;\n\t\tchan->frames_sent++;\n\t\tsent++;\n\n\t\tif (skb_queue_is_last(&chan->tx_q, skb))\n\t\t\tchan->tx_send_head = NULL;\n\t\telse\n\t\t\tchan->tx_send_head = skb_queue_next(&chan->tx_q, skb);\n\n\t\tl2cap_do_send(chan, tx_skb);\n\t\tBT_DBG(\"Sent txseq %u\", control->txseq);\n\t}\n\n\tBT_DBG(\"Sent %d, %u unacked, %u in ERTM queue\", sent,\n\t       chan->unacked_frames, skb_queue_len(&chan->tx_q));\n\n\treturn sent;\n}\n\nstatic void l2cap_ertm_resend(struct l2cap_chan *chan)\n{\n\tstruct l2cap_ctrl control;\n\tstruct sk_buff *skb;\n\tstruct sk_buff *tx_skb;\n\tu16 seq;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))\n\t\treturn;\n\n\tif (__chan_is_moving(chan))\n\t\treturn;\n\n\twhile (chan->retrans_list.head != L2CAP_SEQ_LIST_CLEAR) {\n\t\tseq = l2cap_seq_list_pop(&chan->retrans_list);\n\n\t\tskb = l2cap_ertm_seq_in_queue(&chan->tx_q, seq);\n\t\tif (!skb) {\n\t\t\tBT_DBG(\"Error: Can't retransmit seq %d, frame missing\",\n\t\t\t       seq);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbt_cb(skb)->l2cap.retries++;\n\t\tcontrol = bt_cb(skb)->l2cap;\n\n\t\tif (chan->max_tx != 0 &&\n\t\t    bt_cb(skb)->l2cap.retries > chan->max_tx) {\n\t\t\tBT_DBG(\"Retry limit exceeded (%d)\", chan->max_tx);\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tl2cap_seq_list_clear(&chan->retrans_list);\n\t\t\tbreak;\n\t\t}\n\n\t\tcontrol.reqseq = chan->buffer_seq;\n\t\tif (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))\n\t\t\tcontrol.final = 1;\n\t\telse\n\t\t\tcontrol.final = 0;\n\n\t\tif (skb_cloned(skb)) {\n\t\t\t/* Cloned sk_buffs are read-only, so we need a\n\t\t\t * writeable copy\n\t\t\t */\n\t\t\ttx_skb = skb_copy(skb, GFP_KERNEL);\n\t\t} else {\n\t\t\ttx_skb = skb_clone(skb, GFP_KERNEL);\n\t\t}\n\n\t\tif (!tx_skb) {\n\t\t\tl2cap_seq_list_clear(&chan->retrans_list);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Update skb contents */\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags)) {\n\t\t\tput_unaligned_le32(__pack_extended_control(&control),\n\t\t\t\t\t   tx_skb->data + L2CAP_HDR_SIZE);\n\t\t} else {\n\t\t\tput_unaligned_le16(__pack_enhanced_control(&control),\n\t\t\t\t\t   tx_skb->data + L2CAP_HDR_SIZE);\n\t\t}\n\n\t\t/* Update FCS */\n\t\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\t\tu16 fcs = crc16(0, (u8 *) tx_skb->data,\n\t\t\t\t\ttx_skb->len - L2CAP_FCS_SIZE);\n\t\t\tput_unaligned_le16(fcs, skb_tail_pointer(tx_skb) -\n\t\t\t\t\t\tL2CAP_FCS_SIZE);\n\t\t}\n\n\t\tl2cap_do_send(chan, tx_skb);\n\n\t\tBT_DBG(\"Resent txseq %d\", control.txseq);\n\n\t\tchan->last_acked_seq = chan->buffer_seq;\n\t}\n}\n\nstatic void l2cap_retransmit(struct l2cap_chan *chan,\n\t\t\t     struct l2cap_ctrl *control)\n{\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tl2cap_seq_list_append(&chan->retrans_list, control->reqseq);\n\tl2cap_ertm_resend(chan);\n}\n\nstatic void l2cap_retransmit_all(struct l2cap_chan *chan,\n\t\t\t\t struct l2cap_ctrl *control)\n{\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tif (control->poll)\n\t\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\n\tl2cap_seq_list_clear(&chan->retrans_list);\n\n\tif (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))\n\t\treturn;\n\n\tif (chan->unacked_frames) {\n\t\tskb_queue_walk(&chan->tx_q, skb) {\n\t\t\tif (bt_cb(skb)->l2cap.txseq == control->reqseq ||\n\t\t\t    skb == chan->tx_send_head)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tskb_queue_walk_from(&chan->tx_q, skb) {\n\t\t\tif (skb == chan->tx_send_head)\n\t\t\t\tbreak;\n\n\t\t\tl2cap_seq_list_append(&chan->retrans_list,\n\t\t\t\t\t      bt_cb(skb)->l2cap.txseq);\n\t\t}\n\n\t\tl2cap_ertm_resend(chan);\n\t}\n}\n\nstatic void l2cap_send_ack(struct l2cap_chan *chan)\n{\n\tstruct l2cap_ctrl control;\n\tu16 frames_to_ack = __seq_offset(chan, chan->buffer_seq,\n\t\t\t\t\t chan->last_acked_seq);\n\tint threshold;\n\n\tBT_DBG(\"chan %p last_acked_seq %d buffer_seq %d\",\n\t       chan, chan->last_acked_seq, chan->buffer_seq);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\n\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state) &&\n\t    chan->rx_state == L2CAP_RX_STATE_RECV) {\n\t\t__clear_ack_timer(chan);\n\t\tcontrol.super = L2CAP_SUPER_RNR;\n\t\tcontrol.reqseq = chan->buffer_seq;\n\t\tl2cap_send_sframe(chan, &control);\n\t} else {\n\t\tif (!test_bit(CONN_REMOTE_BUSY, &chan->conn_state)) {\n\t\t\tl2cap_ertm_send(chan);\n\t\t\t/* If any i-frames were sent, they included an ack */\n\t\t\tif (chan->buffer_seq == chan->last_acked_seq)\n\t\t\t\tframes_to_ack = 0;\n\t\t}\n\n\t\t/* Ack now if the window is 3/4ths full.\n\t\t * Calculate without mul or div\n\t\t */\n\t\tthreshold = chan->ack_win;\n\t\tthreshold += threshold << 1;\n\t\tthreshold >>= 2;\n\n\t\tBT_DBG(\"frames_to_ack %u, threshold %d\", frames_to_ack,\n\t\t       threshold);\n\n\t\tif (frames_to_ack >= threshold) {\n\t\t\t__clear_ack_timer(chan);\n\t\t\tcontrol.super = L2CAP_SUPER_RR;\n\t\t\tcontrol.reqseq = chan->buffer_seq;\n\t\t\tl2cap_send_sframe(chan, &control);\n\t\t\tframes_to_ack = 0;\n\t\t}\n\n\t\tif (frames_to_ack)\n\t\t\t__set_ack_timer(chan);\n\t}\n}\n\nstatic inline int l2cap_skbuff_fromiovec(struct l2cap_chan *chan,\n\t\t\t\t\t struct msghdr *msg, int len,\n\t\t\t\t\t int count, struct sk_buff *skb)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff **frag;\n\tint sent = 0;\n\n\tif (!copy_from_iter_full(skb_put(skb, count), count, &msg->msg_iter))\n\t\treturn -EFAULT;\n\n\tsent += count;\n\tlen  -= count;\n\n\t/* Continuation fragments (no L2CAP header) */\n\tfrag = &skb_shinfo(skb)->frag_list;\n\twhile (len) {\n\t\tstruct sk_buff *tmp;\n\n\t\tcount = min_t(unsigned int, conn->mtu, len);\n\n\t\ttmp = chan->ops->alloc_skb(chan, 0, count,\n\t\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn PTR_ERR(tmp);\n\n\t\t*frag = tmp;\n\n\t\tif (!copy_from_iter_full(skb_put(*frag, count), count,\n\t\t\t\t   &msg->msg_iter))\n\t\t\treturn -EFAULT;\n\n\t\tsent += count;\n\t\tlen  -= count;\n\n\t\tskb->len += (*frag)->len;\n\t\tskb->data_len += (*frag)->len;\n\n\t\tfrag = &(*frag)->next;\n\t}\n\n\treturn sent;\n}\n\nstatic struct sk_buff *l2cap_create_connless_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t\t struct msghdr *msg, size_t len)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff *skb;\n\tint err, count, hlen = L2CAP_HDR_SIZE + L2CAP_PSMLEN_SIZE;\n\tstruct l2cap_hdr *lh;\n\n\tBT_DBG(\"chan %p psm 0x%2.2x len %zu\", chan,\n\t       __le16_to_cpu(chan->psm), len);\n\n\tcount = min_t(unsigned int, (conn->mtu - hlen), len);\n\n\tskb = chan->ops->alloc_skb(chan, hlen, count,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\t/* Create L2CAP header */\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\tlh->len = cpu_to_le16(len + L2CAP_PSMLEN_SIZE);\n\tput_unaligned(chan->psm, (__le16 *) skb_put(skb, L2CAP_PSMLEN_SIZE));\n\n\terr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\n\tif (unlikely(err < 0)) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn skb;\n}\n\nstatic struct sk_buff *l2cap_create_basic_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t      struct msghdr *msg, size_t len)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff *skb;\n\tint err, count;\n\tstruct l2cap_hdr *lh;\n\n\tBT_DBG(\"chan %p len %zu\", chan, len);\n\n\tcount = min_t(unsigned int, (conn->mtu - L2CAP_HDR_SIZE), len);\n\n\tskb = chan->ops->alloc_skb(chan, L2CAP_HDR_SIZE, count,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\t/* Create L2CAP header */\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\tlh->len = cpu_to_le16(len);\n\n\terr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\n\tif (unlikely(err < 0)) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn skb;\n}\n\nstatic struct sk_buff *l2cap_create_iframe_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t       struct msghdr *msg, size_t len,\n\t\t\t\t\t       u16 sdulen)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff *skb;\n\tint err, count, hlen;\n\tstruct l2cap_hdr *lh;\n\n\tBT_DBG(\"chan %p len %zu\", chan, len);\n\n\tif (!conn)\n\t\treturn ERR_PTR(-ENOTCONN);\n\n\thlen = __ertm_hdr_size(chan);\n\n\tif (sdulen)\n\t\thlen += L2CAP_SDULEN_SIZE;\n\n\tif (chan->fcs == L2CAP_FCS_CRC16)\n\t\thlen += L2CAP_FCS_SIZE;\n\n\tcount = min_t(unsigned int, (conn->mtu - hlen), len);\n\n\tskb = chan->ops->alloc_skb(chan, hlen, count,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\t/* Create L2CAP header */\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\tlh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));\n\n\t/* Control header is populated later */\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\tput_unaligned_le32(0, skb_put(skb, L2CAP_EXT_CTRL_SIZE));\n\telse\n\t\tput_unaligned_le16(0, skb_put(skb, L2CAP_ENH_CTRL_SIZE));\n\n\tif (sdulen)\n\t\tput_unaligned_le16(sdulen, skb_put(skb, L2CAP_SDULEN_SIZE));\n\n\terr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\n\tif (unlikely(err < 0)) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tbt_cb(skb)->l2cap.fcs = chan->fcs;\n\tbt_cb(skb)->l2cap.retries = 0;\n\treturn skb;\n}\n\nstatic int l2cap_segment_sdu(struct l2cap_chan *chan,\n\t\t\t     struct sk_buff_head *seg_queue,\n\t\t\t     struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tu16 sdu_len;\n\tsize_t pdu_len;\n\tu8 sar;\n\n\tBT_DBG(\"chan %p, msg %p, len %zu\", chan, msg, len);\n\n\t/* It is critical that ERTM PDUs fit in a single HCI fragment,\n\t * so fragmented skbs are not used.  The HCI layer's handling\n\t * of fragmented skbs is not compatible with ERTM's queueing.\n\t */\n\n\t/* PDU size is derived from the HCI MTU */\n\tpdu_len = chan->conn->mtu;\n\n\t/* Constrain PDU size for BR/EDR connections */\n\tif (!chan->hs_hcon)\n\t\tpdu_len = min_t(size_t, pdu_len, L2CAP_BREDR_MAX_PAYLOAD);\n\n\t/* Adjust for largest possible L2CAP overhead. */\n\tif (chan->fcs)\n\t\tpdu_len -= L2CAP_FCS_SIZE;\n\n\tpdu_len -= __ertm_hdr_size(chan);\n\n\t/* Remote device may have requested smaller PDUs */\n\tpdu_len = min_t(size_t, pdu_len, chan->remote_mps);\n\n\tif (len <= pdu_len) {\n\t\tsar = L2CAP_SAR_UNSEGMENTED;\n\t\tsdu_len = 0;\n\t\tpdu_len = len;\n\t} else {\n\t\tsar = L2CAP_SAR_START;\n\t\tsdu_len = len;\n\t}\n\n\twhile (len > 0) {\n\t\tskb = l2cap_create_iframe_pdu(chan, msg, pdu_len, sdu_len);\n\n\t\tif (IS_ERR(skb)) {\n\t\t\t__skb_queue_purge(seg_queue);\n\t\t\treturn PTR_ERR(skb);\n\t\t}\n\n\t\tbt_cb(skb)->l2cap.sar = sar;\n\t\t__skb_queue_tail(seg_queue, skb);\n\n\t\tlen -= pdu_len;\n\t\tif (sdu_len)\n\t\t\tsdu_len = 0;\n\n\t\tif (len <= pdu_len) {\n\t\t\tsar = L2CAP_SAR_END;\n\t\t\tpdu_len = len;\n\t\t} else {\n\t\t\tsar = L2CAP_SAR_CONTINUE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct sk_buff *l2cap_create_le_flowctl_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t\t   struct msghdr *msg,\n\t\t\t\t\t\t   size_t len, u16 sdulen)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff *skb;\n\tint err, count, hlen;\n\tstruct l2cap_hdr *lh;\n\n\tBT_DBG(\"chan %p len %zu\", chan, len);\n\n\tif (!conn)\n\t\treturn ERR_PTR(-ENOTCONN);\n\n\thlen = L2CAP_HDR_SIZE;\n\n\tif (sdulen)\n\t\thlen += L2CAP_SDULEN_SIZE;\n\n\tcount = min_t(unsigned int, (conn->mtu - hlen), len);\n\n\tskb = chan->ops->alloc_skb(chan, hlen, count,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\t/* Create L2CAP header */\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\tlh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));\n\n\tif (sdulen)\n\t\tput_unaligned_le16(sdulen, skb_put(skb, L2CAP_SDULEN_SIZE));\n\n\terr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\n\tif (unlikely(err < 0)) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic int l2cap_segment_le_sdu(struct l2cap_chan *chan,\n\t\t\t\tstruct sk_buff_head *seg_queue,\n\t\t\t\tstruct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tsize_t pdu_len;\n\tu16 sdu_len;\n\n\tBT_DBG(\"chan %p, msg %p, len %zu\", chan, msg, len);\n\n\tsdu_len = len;\n\tpdu_len = chan->remote_mps - L2CAP_SDULEN_SIZE;\n\n\twhile (len > 0) {\n\t\tif (len <= pdu_len)\n\t\t\tpdu_len = len;\n\n\t\tskb = l2cap_create_le_flowctl_pdu(chan, msg, pdu_len, sdu_len);\n\t\tif (IS_ERR(skb)) {\n\t\t\t__skb_queue_purge(seg_queue);\n\t\t\treturn PTR_ERR(skb);\n\t\t}\n\n\t\t__skb_queue_tail(seg_queue, skb);\n\n\t\tlen -= pdu_len;\n\n\t\tif (sdu_len) {\n\t\t\tsdu_len = 0;\n\t\t\tpdu_len += L2CAP_SDULEN_SIZE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void l2cap_le_flowctl_send(struct l2cap_chan *chan)\n{\n\tint sent = 0;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twhile (chan->tx_credits && !skb_queue_empty(&chan->tx_q)) {\n\t\tl2cap_do_send(chan, skb_dequeue(&chan->tx_q));\n\t\tchan->tx_credits--;\n\t\tsent++;\n\t}\n\n\tBT_DBG(\"Sent %d credits %u queued %u\", sent, chan->tx_credits,\n\t       skb_queue_len(&chan->tx_q));\n}\n\nint l2cap_chan_send(struct l2cap_chan *chan, struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct sk_buff_head seg_queue;\n\n\tif (!chan->conn)\n\t\treturn -ENOTCONN;\n\n\t/* Connectionless channel */\n\tif (chan->chan_type == L2CAP_CHAN_CONN_LESS) {\n\t\tskb = l2cap_create_connless_pdu(chan, msg, len);\n\t\tif (IS_ERR(skb))\n\t\t\treturn PTR_ERR(skb);\n\n\t\t/* Channel lock is released before requesting new skb and then\n\t\t * reacquired thus we need to recheck channel state.\n\t\t */\n\t\tif (chan->state != BT_CONNECTED) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\n\t\tl2cap_do_send(chan, skb);\n\t\treturn len;\n\t}\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\t/* Check outgoing MTU */\n\t\tif (len > chan->omtu)\n\t\t\treturn -EMSGSIZE;\n\n\t\t__skb_queue_head_init(&seg_queue);\n\n\t\terr = l2cap_segment_le_sdu(chan, &seg_queue, msg, len);\n\n\t\tif (chan->state != BT_CONNECTED) {\n\t\t\t__skb_queue_purge(&seg_queue);\n\t\t\terr = -ENOTCONN;\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tskb_queue_splice_tail_init(&seg_queue, &chan->tx_q);\n\n\t\tl2cap_le_flowctl_send(chan);\n\n\t\tif (!chan->tx_credits)\n\t\t\tchan->ops->suspend(chan);\n\n\t\terr = len;\n\n\t\tbreak;\n\n\tcase L2CAP_MODE_BASIC:\n\t\t/* Check outgoing MTU */\n\t\tif (len > chan->omtu)\n\t\t\treturn -EMSGSIZE;\n\n\t\t/* Create a basic PDU */\n\t\tskb = l2cap_create_basic_pdu(chan, msg, len);\n\t\tif (IS_ERR(skb))\n\t\t\treturn PTR_ERR(skb);\n\n\t\t/* Channel lock is released before requesting new skb and then\n\t\t * reacquired thus we need to recheck channel state.\n\t\t */\n\t\tif (chan->state != BT_CONNECTED) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\n\t\tl2cap_do_send(chan, skb);\n\t\terr = len;\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\t/* Check outgoing MTU */\n\t\tif (len > chan->omtu) {\n\t\t\terr = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\n\t\t__skb_queue_head_init(&seg_queue);\n\n\t\t/* Do segmentation before calling in to the state machine,\n\t\t * since it's possible to block while waiting for memory\n\t\t * allocation.\n\t\t */\n\t\terr = l2cap_segment_sdu(chan, &seg_queue, msg, len);\n\n\t\t/* The channel could have been closed while segmenting,\n\t\t * check that it is still connected.\n\t\t */\n\t\tif (chan->state != BT_CONNECTED) {\n\t\t\t__skb_queue_purge(&seg_queue);\n\t\t\terr = -ENOTCONN;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (chan->mode == L2CAP_MODE_ERTM)\n\t\t\tl2cap_tx(chan, NULL, &seg_queue, L2CAP_EV_DATA_REQUEST);\n\t\telse\n\t\t\tl2cap_streaming_send(chan, &seg_queue);\n\n\t\terr = len;\n\n\t\t/* If the skbs were not queued for sending, they'll still be in\n\t\t * seg_queue and need to be purged.\n\t\t */\n\t\t__skb_queue_purge(&seg_queue);\n\t\tbreak;\n\n\tdefault:\n\t\tBT_DBG(\"bad state %1.1x\", chan->mode);\n\t\terr = -EBADFD;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_send);\n\nstatic void l2cap_send_srej(struct l2cap_chan *chan, u16 txseq)\n{\n\tstruct l2cap_ctrl control;\n\tu16 seq;\n\n\tBT_DBG(\"chan %p, txseq %u\", chan, txseq);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.super = L2CAP_SUPER_SREJ;\n\n\tfor (seq = chan->expected_tx_seq; seq != txseq;\n\t     seq = __next_seq(chan, seq)) {\n\t\tif (!l2cap_ertm_seq_in_queue(&chan->srej_q, seq)) {\n\t\t\tcontrol.reqseq = seq;\n\t\t\tl2cap_send_sframe(chan, &control);\n\t\t\tl2cap_seq_list_append(&chan->srej_list, seq);\n\t\t}\n\t}\n\n\tchan->expected_tx_seq = __next_seq(chan, txseq);\n}\n\nstatic void l2cap_send_srej_tail(struct l2cap_chan *chan)\n{\n\tstruct l2cap_ctrl control;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->srej_list.tail == L2CAP_SEQ_LIST_CLEAR)\n\t\treturn;\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.super = L2CAP_SUPER_SREJ;\n\tcontrol.reqseq = chan->srej_list.tail;\n\tl2cap_send_sframe(chan, &control);\n}\n\nstatic void l2cap_send_srej_list(struct l2cap_chan *chan, u16 txseq)\n{\n\tstruct l2cap_ctrl control;\n\tu16 initial_head;\n\tu16 seq;\n\n\tBT_DBG(\"chan %p, txseq %u\", chan, txseq);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.super = L2CAP_SUPER_SREJ;\n\n\t/* Capture initial list head to allow only one pass through the list. */\n\tinitial_head = chan->srej_list.head;\n\n\tdo {\n\t\tseq = l2cap_seq_list_pop(&chan->srej_list);\n\t\tif (seq == txseq || seq == L2CAP_SEQ_LIST_CLEAR)\n\t\t\tbreak;\n\n\t\tcontrol.reqseq = seq;\n\t\tl2cap_send_sframe(chan, &control);\n\t\tl2cap_seq_list_append(&chan->srej_list, seq);\n\t} while (chan->srej_list.head != initial_head);\n}\n\nstatic void l2cap_process_reqseq(struct l2cap_chan *chan, u16 reqseq)\n{\n\tstruct sk_buff *acked_skb;\n\tu16 ackseq;\n\n\tBT_DBG(\"chan %p, reqseq %u\", chan, reqseq);\n\n\tif (chan->unacked_frames == 0 || reqseq == chan->expected_ack_seq)\n\t\treturn;\n\n\tBT_DBG(\"expected_ack_seq %u, unacked_frames %u\",\n\t       chan->expected_ack_seq, chan->unacked_frames);\n\n\tfor (ackseq = chan->expected_ack_seq; ackseq != reqseq;\n\t     ackseq = __next_seq(chan, ackseq)) {\n\n\t\tacked_skb = l2cap_ertm_seq_in_queue(&chan->tx_q, ackseq);\n\t\tif (acked_skb) {\n\t\t\tskb_unlink(acked_skb, &chan->tx_q);\n\t\t\tkfree_skb(acked_skb);\n\t\t\tchan->unacked_frames--;\n\t\t}\n\t}\n\n\tchan->expected_ack_seq = reqseq;\n\n\tif (chan->unacked_frames == 0)\n\t\t__clear_retrans_timer(chan);\n\n\tBT_DBG(\"unacked_frames %u\", chan->unacked_frames);\n}\n\nstatic void l2cap_abort_rx_srej_sent(struct l2cap_chan *chan)\n{\n\tBT_DBG(\"chan %p\", chan);\n\n\tchan->expected_tx_seq = chan->buffer_seq;\n\tl2cap_seq_list_clear(&chan->srej_list);\n\tskb_queue_purge(&chan->srej_q);\n\tchan->rx_state = L2CAP_RX_STATE_RECV;\n}\n\nstatic void l2cap_tx_state_xmit(struct l2cap_chan *chan,\n\t\t\t\tstruct l2cap_ctrl *control,\n\t\t\t\tstruct sk_buff_head *skbs, u8 event)\n{\n\tBT_DBG(\"chan %p, control %p, skbs %p, event %d\", chan, control, skbs,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_DATA_REQUEST:\n\t\tif (chan->tx_send_head == NULL)\n\t\t\tchan->tx_send_head = skb_peek(skbs);\n\n\t\tskb_queue_splice_tail_init(skbs, &chan->tx_q);\n\t\tl2cap_ertm_send(chan);\n\t\tbreak;\n\tcase L2CAP_EV_LOCAL_BUSY_DETECTED:\n\t\tBT_DBG(\"Enter LOCAL_BUSY\");\n\t\tset_bit(CONN_LOCAL_BUSY, &chan->conn_state);\n\n\t\tif (chan->rx_state == L2CAP_RX_STATE_SREJ_SENT) {\n\t\t\t/* The SREJ_SENT state must be aborted if we are to\n\t\t\t * enter the LOCAL_BUSY state.\n\t\t\t */\n\t\t\tl2cap_abort_rx_srej_sent(chan);\n\t\t}\n\n\t\tl2cap_send_ack(chan);\n\n\t\tbreak;\n\tcase L2CAP_EV_LOCAL_BUSY_CLEAR:\n\t\tBT_DBG(\"Exit LOCAL_BUSY\");\n\t\tclear_bit(CONN_LOCAL_BUSY, &chan->conn_state);\n\n\t\tif (test_bit(CONN_RNR_SENT, &chan->conn_state)) {\n\t\t\tstruct l2cap_ctrl local_control;\n\n\t\t\tmemset(&local_control, 0, sizeof(local_control));\n\t\t\tlocal_control.sframe = 1;\n\t\t\tlocal_control.super = L2CAP_SUPER_RR;\n\t\t\tlocal_control.poll = 1;\n\t\t\tlocal_control.reqseq = chan->buffer_seq;\n\t\t\tl2cap_send_sframe(chan, &local_control);\n\n\t\t\tchan->retry_count = 1;\n\t\t\t__set_monitor_timer(chan);\n\t\t\tchan->tx_state = L2CAP_TX_STATE_WAIT_F;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_REQSEQ_AND_FBIT:\n\t\tl2cap_process_reqseq(chan, control->reqseq);\n\t\tbreak;\n\tcase L2CAP_EV_EXPLICIT_POLL:\n\t\tl2cap_send_rr_or_rnr(chan, 1);\n\t\tchan->retry_count = 1;\n\t\t__set_monitor_timer(chan);\n\t\t__clear_ack_timer(chan);\n\t\tchan->tx_state = L2CAP_TX_STATE_WAIT_F;\n\t\tbreak;\n\tcase L2CAP_EV_RETRANS_TO:\n\t\tl2cap_send_rr_or_rnr(chan, 1);\n\t\tchan->retry_count = 1;\n\t\t__set_monitor_timer(chan);\n\t\tchan->tx_state = L2CAP_TX_STATE_WAIT_F;\n\t\tbreak;\n\tcase L2CAP_EV_RECV_FBIT:\n\t\t/* Nothing to process */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_tx_state_wait_f(struct l2cap_chan *chan,\n\t\t\t\t  struct l2cap_ctrl *control,\n\t\t\t\t  struct sk_buff_head *skbs, u8 event)\n{\n\tBT_DBG(\"chan %p, control %p, skbs %p, event %d\", chan, control, skbs,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_DATA_REQUEST:\n\t\tif (chan->tx_send_head == NULL)\n\t\t\tchan->tx_send_head = skb_peek(skbs);\n\t\t/* Queue data, but don't send. */\n\t\tskb_queue_splice_tail_init(skbs, &chan->tx_q);\n\t\tbreak;\n\tcase L2CAP_EV_LOCAL_BUSY_DETECTED:\n\t\tBT_DBG(\"Enter LOCAL_BUSY\");\n\t\tset_bit(CONN_LOCAL_BUSY, &chan->conn_state);\n\n\t\tif (chan->rx_state == L2CAP_RX_STATE_SREJ_SENT) {\n\t\t\t/* The SREJ_SENT state must be aborted if we are to\n\t\t\t * enter the LOCAL_BUSY state.\n\t\t\t */\n\t\t\tl2cap_abort_rx_srej_sent(chan);\n\t\t}\n\n\t\tl2cap_send_ack(chan);\n\n\t\tbreak;\n\tcase L2CAP_EV_LOCAL_BUSY_CLEAR:\n\t\tBT_DBG(\"Exit LOCAL_BUSY\");\n\t\tclear_bit(CONN_LOCAL_BUSY, &chan->conn_state);\n\n\t\tif (test_bit(CONN_RNR_SENT, &chan->conn_state)) {\n\t\t\tstruct l2cap_ctrl local_control;\n\t\t\tmemset(&local_control, 0, sizeof(local_control));\n\t\t\tlocal_control.sframe = 1;\n\t\t\tlocal_control.super = L2CAP_SUPER_RR;\n\t\t\tlocal_control.poll = 1;\n\t\t\tlocal_control.reqseq = chan->buffer_seq;\n\t\t\tl2cap_send_sframe(chan, &local_control);\n\n\t\t\tchan->retry_count = 1;\n\t\t\t__set_monitor_timer(chan);\n\t\t\tchan->tx_state = L2CAP_TX_STATE_WAIT_F;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_REQSEQ_AND_FBIT:\n\t\tl2cap_process_reqseq(chan, control->reqseq);\n\t\tfallthrough;\n\n\tcase L2CAP_EV_RECV_FBIT:\n\t\tif (control && control->final) {\n\t\t\t__clear_monitor_timer(chan);\n\t\t\tif (chan->unacked_frames > 0)\n\t\t\t\t__set_retrans_timer(chan);\n\t\t\tchan->retry_count = 0;\n\t\t\tchan->tx_state = L2CAP_TX_STATE_XMIT;\n\t\t\tBT_DBG(\"recv fbit tx_state 0x2.2%x\", chan->tx_state);\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_EXPLICIT_POLL:\n\t\t/* Ignore */\n\t\tbreak;\n\tcase L2CAP_EV_MONITOR_TO:\n\t\tif (chan->max_tx == 0 || chan->retry_count < chan->max_tx) {\n\t\t\tl2cap_send_rr_or_rnr(chan, 1);\n\t\t\t__set_monitor_timer(chan);\n\t\t\tchan->retry_count++;\n\t\t} else {\n\t\t\tl2cap_send_disconn_req(chan, ECONNABORTED);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_tx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\n\t\t     struct sk_buff_head *skbs, u8 event)\n{\n\tBT_DBG(\"chan %p, control %p, skbs %p, event %d, state %d\",\n\t       chan, control, skbs, event, chan->tx_state);\n\n\tswitch (chan->tx_state) {\n\tcase L2CAP_TX_STATE_XMIT:\n\t\tl2cap_tx_state_xmit(chan, control, skbs, event);\n\t\tbreak;\n\tcase L2CAP_TX_STATE_WAIT_F:\n\t\tl2cap_tx_state_wait_f(chan, control, skbs, event);\n\t\tbreak;\n\tdefault:\n\t\t/* Ignore event */\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_pass_to_tx(struct l2cap_chan *chan,\n\t\t\t     struct l2cap_ctrl *control)\n{\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\tl2cap_tx(chan, control, NULL, L2CAP_EV_RECV_REQSEQ_AND_FBIT);\n}\n\nstatic void l2cap_pass_to_tx_fbit(struct l2cap_chan *chan,\n\t\t\t\t  struct l2cap_ctrl *control)\n{\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\tl2cap_tx(chan, control, NULL, L2CAP_EV_RECV_FBIT);\n}\n\n/* Copy frame to all raw sockets on that connection */\nstatic void l2cap_raw_recv(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct sk_buff *nskb;\n\tstruct l2cap_chan *chan;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tif (chan->chan_type != L2CAP_CHAN_RAW)\n\t\t\tcontinue;\n\n\t\t/* Don't send frame to the channel it came from */\n\t\tif (bt_cb(skb)->l2cap.chan == chan)\n\t\t\tcontinue;\n\n\t\tnskb = skb_clone(skb, GFP_KERNEL);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\t\tif (chan->ops->recv(chan, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\n/* ---- L2CAP signalling commands ---- */\nstatic struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn, u8 code,\n\t\t\t\t       u8 ident, u16 dlen, void *data)\n{\n\tstruct sk_buff *skb, **frag;\n\tstruct l2cap_cmd_hdr *cmd;\n\tstruct l2cap_hdr *lh;\n\tint len, count;\n\n\tBT_DBG(\"conn %p, code 0x%2.2x, ident 0x%2.2x, len %u\",\n\t       conn, code, ident, dlen);\n\n\tif (conn->mtu < L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE)\n\t\treturn NULL;\n\n\tlen = L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE + dlen;\n\tcount = min_t(unsigned int, conn->mtu, len);\n\n\tskb = bt_skb_alloc(count, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->len = cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);\n\n\tif (conn->hcon->type == LE_LINK)\n\t\tlh->cid = cpu_to_le16(L2CAP_CID_LE_SIGNALING);\n\telse\n\t\tlh->cid = cpu_to_le16(L2CAP_CID_SIGNALING);\n\n\tcmd = skb_put(skb, L2CAP_CMD_HDR_SIZE);\n\tcmd->code  = code;\n\tcmd->ident = ident;\n\tcmd->len   = cpu_to_le16(dlen);\n\n\tif (dlen) {\n\t\tcount -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;\n\t\tskb_put_data(skb, data, count);\n\t\tdata += count;\n\t}\n\n\tlen -= skb->len;\n\n\t/* Continuation fragments (no L2CAP header) */\n\tfrag = &skb_shinfo(skb)->frag_list;\n\twhile (len) {\n\t\tcount = min_t(unsigned int, conn->mtu, len);\n\n\t\t*frag = bt_skb_alloc(count, GFP_KERNEL);\n\t\tif (!*frag)\n\t\t\tgoto fail;\n\n\t\tskb_put_data(*frag, data, count);\n\n\t\tlen  -= count;\n\t\tdata += count;\n\n\t\tfrag = &(*frag)->next;\n\t}\n\n\treturn skb;\n\nfail:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstatic inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen,\n\t\t\t\t     unsigned long *val)\n{\n\tstruct l2cap_conf_opt *opt = *ptr;\n\tint len;\n\n\tlen = L2CAP_CONF_OPT_SIZE + opt->len;\n\t*ptr += len;\n\n\t*type = opt->type;\n\t*olen = opt->len;\n\n\tswitch (opt->len) {\n\tcase 1:\n\t\t*val = *((u8 *) opt->val);\n\t\tbreak;\n\n\tcase 2:\n\t\t*val = get_unaligned_le16(opt->val);\n\t\tbreak;\n\n\tcase 4:\n\t\t*val = get_unaligned_le32(opt->val);\n\t\tbreak;\n\n\tdefault:\n\t\t*val = (unsigned long) opt->val;\n\t\tbreak;\n\t}\n\n\tBT_DBG(\"type 0x%2.2x len %u val 0x%lx\", *type, opt->len, *val);\n\treturn len;\n}\n\nstatic void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val, size_t size)\n{\n\tstruct l2cap_conf_opt *opt = *ptr;\n\n\tBT_DBG(\"type 0x%2.2x len %u val 0x%lx\", type, len, val);\n\n\tif (size < L2CAP_CONF_OPT_SIZE + len)\n\t\treturn;\n\n\topt->type = type;\n\topt->len  = len;\n\n\tswitch (len) {\n\tcase 1:\n\t\t*((u8 *) opt->val)  = val;\n\t\tbreak;\n\n\tcase 2:\n\t\tput_unaligned_le16(val, opt->val);\n\t\tbreak;\n\n\tcase 4:\n\t\tput_unaligned_le32(val, opt->val);\n\t\tbreak;\n\n\tdefault:\n\t\tmemcpy(opt->val, (void *) val, len);\n\t\tbreak;\n\t}\n\n\t*ptr += L2CAP_CONF_OPT_SIZE + len;\n}\n\nstatic void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan, size_t size)\n{\n\tstruct l2cap_conf_efs efs;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tefs.id\t\t= chan->local_id;\n\t\tefs.stype\t= chan->local_stype;\n\t\tefs.msdu\t= cpu_to_le16(chan->local_msdu);\n\t\tefs.sdu_itime\t= cpu_to_le32(chan->local_sdu_itime);\n\t\tefs.acc_lat\t= cpu_to_le32(L2CAP_DEFAULT_ACC_LAT);\n\t\tefs.flush_to\t= cpu_to_le32(L2CAP_EFS_DEFAULT_FLUSH_TO);\n\t\tbreak;\n\n\tcase L2CAP_MODE_STREAMING:\n\t\tefs.id\t\t= 1;\n\t\tefs.stype\t= L2CAP_SERV_BESTEFFORT;\n\t\tefs.msdu\t= cpu_to_le16(chan->local_msdu);\n\t\tefs.sdu_itime\t= cpu_to_le32(chan->local_sdu_itime);\n\t\tefs.acc_lat\t= 0;\n\t\tefs.flush_to\t= 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tl2cap_add_conf_opt(ptr, L2CAP_CONF_EFS, sizeof(efs),\n\t\t\t   (unsigned long) &efs, size);\n}\n\nstatic void l2cap_ack_timeout(struct work_struct *work)\n{\n\tstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\n\t\t\t\t\t       ack_timer.work);\n\tu16 frames_to_ack;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tl2cap_chan_lock(chan);\n\n\tframes_to_ack = __seq_offset(chan, chan->buffer_seq,\n\t\t\t\t     chan->last_acked_seq);\n\n\tif (frames_to_ack)\n\t\tl2cap_send_rr_or_rnr(chan, 0);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nint l2cap_ertm_init(struct l2cap_chan *chan)\n{\n\tint err;\n\n\tchan->next_tx_seq = 0;\n\tchan->expected_tx_seq = 0;\n\tchan->expected_ack_seq = 0;\n\tchan->unacked_frames = 0;\n\tchan->buffer_seq = 0;\n\tchan->frames_sent = 0;\n\tchan->last_acked_seq = 0;\n\tchan->sdu = NULL;\n\tchan->sdu_last_frag = NULL;\n\tchan->sdu_len = 0;\n\n\tskb_queue_head_init(&chan->tx_q);\n\n\tchan->local_amp_id = AMP_ID_BREDR;\n\tchan->move_id = AMP_ID_BREDR;\n\tchan->move_state = L2CAP_MOVE_STABLE;\n\tchan->move_role = L2CAP_MOVE_ROLE_NONE;\n\n\tif (chan->mode != L2CAP_MODE_ERTM)\n\t\treturn 0;\n\n\tchan->rx_state = L2CAP_RX_STATE_RECV;\n\tchan->tx_state = L2CAP_TX_STATE_XMIT;\n\n\tskb_queue_head_init(&chan->srej_q);\n\n\terr = l2cap_seq_list_init(&chan->srej_list, chan->tx_win);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = l2cap_seq_list_init(&chan->retrans_list, chan->remote_tx_win);\n\tif (err < 0)\n\t\tl2cap_seq_list_free(&chan->srej_list);\n\n\treturn err;\n}\n\nstatic inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)\n{\n\tswitch (mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (l2cap_mode_supported(mode, remote_feat_mask))\n\t\t\treturn mode;\n\t\tfallthrough;\n\tdefault:\n\t\treturn L2CAP_MODE_BASIC;\n\t}\n}\n\nstatic inline bool __l2cap_ews_supported(struct l2cap_conn *conn)\n{\n\treturn ((conn->local_fixed_chan & L2CAP_FC_A2MP) &&\n\t\t(conn->feat_mask & L2CAP_FEAT_EXT_WINDOW));\n}\n\nstatic inline bool __l2cap_efs_supported(struct l2cap_conn *conn)\n{\n\treturn ((conn->local_fixed_chan & L2CAP_FC_A2MP) &&\n\t\t(conn->feat_mask & L2CAP_FEAT_EXT_FLOW));\n}\n\nstatic void __l2cap_set_ertm_timeouts(struct l2cap_chan *chan,\n\t\t\t\t      struct l2cap_conf_rfc *rfc)\n{\n\tif (chan->local_amp_id != AMP_ID_BREDR && chan->hs_hcon) {\n\t\tu64 ertm_to = chan->hs_hcon->hdev->amp_be_flush_to;\n\n\t\t/* Class 1 devices have must have ERTM timeouts\n\t\t * exceeding the Link Supervision Timeout.  The\n\t\t * default Link Supervision Timeout for AMP\n\t\t * controllers is 10 seconds.\n\t\t *\n\t\t * Class 1 devices use 0xffffffff for their\n\t\t * best-effort flush timeout, so the clamping logic\n\t\t * will result in a timeout that meets the above\n\t\t * requirement.  ERTM timeouts are 16-bit values, so\n\t\t * the maximum timeout is 65.535 seconds.\n\t\t */\n\n\t\t/* Convert timeout to milliseconds and round */\n\t\tertm_to = DIV_ROUND_UP_ULL(ertm_to, 1000);\n\n\t\t/* This is the recommended formula for class 2 devices\n\t\t * that start ERTM timers when packets are sent to the\n\t\t * controller.\n\t\t */\n\t\tertm_to = 3 * ertm_to + 500;\n\n\t\tif (ertm_to > 0xffff)\n\t\t\tertm_to = 0xffff;\n\n\t\trfc->retrans_timeout = cpu_to_le16((u16) ertm_to);\n\t\trfc->monitor_timeout = rfc->retrans_timeout;\n\t} else {\n\t\trfc->retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);\n\t\trfc->monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);\n\t}\n}\n\nstatic inline void l2cap_txwin_setup(struct l2cap_chan *chan)\n{\n\tif (chan->tx_win > L2CAP_DEFAULT_TX_WINDOW &&\n\t    __l2cap_ews_supported(chan->conn)) {\n\t\t/* use extended control field */\n\t\tset_bit(FLAG_EXT_CTRL, &chan->flags);\n\t\tchan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;\n\t} else {\n\t\tchan->tx_win = min_t(u16, chan->tx_win,\n\t\t\t\t     L2CAP_DEFAULT_TX_WINDOW);\n\t\tchan->tx_win_max = L2CAP_DEFAULT_TX_WINDOW;\n\t}\n\tchan->ack_win = chan->tx_win;\n}\n\nstatic void l2cap_mtu_auto(struct l2cap_chan *chan)\n{\n\tstruct hci_conn *conn = chan->conn->hcon;\n\n\tchan->imtu = L2CAP_DEFAULT_MIN_MTU;\n\n\t/* The 2-DH1 packet has between 2 and 56 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_2DH1))\n\t\tchan->imtu = 54;\n\n\t/* The 3-DH1 packet has between 2 and 85 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_3DH1))\n\t\tchan->imtu = 83;\n\n\t/* The 2-DH3 packet has between 2 and 369 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_2DH3))\n\t\tchan->imtu = 367;\n\n\t/* The 3-DH3 packet has between 2 and 554 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_3DH3))\n\t\tchan->imtu = 552;\n\n\t/* The 2-DH5 packet has between 2 and 681 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_2DH5))\n\t\tchan->imtu = 679;\n\n\t/* The 3-DH5 packet has between 2 and 1023 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_3DH5))\n\t\tchan->imtu = 1021;\n}\n\nstatic int l2cap_build_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)\n{\n\tstruct l2cap_conf_req *req = data;\n\tstruct l2cap_conf_rfc rfc = { .mode = chan->mode };\n\tvoid *ptr = req->data;\n\tvoid *endptr = data + data_size;\n\tu16 size;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->num_conf_req || chan->num_conf_rsp)\n\t\tgoto done;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (test_bit(CONF_STATE2_DEVICE, &chan->conf_state))\n\t\t\tbreak;\n\n\t\tif (__l2cap_efs_supported(chan->conn))\n\t\t\tset_bit(FLAG_EFS_ENABLE, &chan->flags);\n\n\t\tfallthrough;\n\tdefault:\n\t\tchan->mode = l2cap_select_mode(rfc.mode, chan->conn->feat_mask);\n\t\tbreak;\n\t}\n\ndone:\n\tif (chan->imtu != L2CAP_DEFAULT_MTU) {\n\t\tif (!chan->imtu)\n\t\t\tl2cap_mtu_auto(chan);\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu,\n\t\t\t\t   endptr - ptr);\n\t}\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tif (disable_ertm)\n\t\t\tbreak;\n\n\t\tif (!(chan->conn->feat_mask & L2CAP_FEAT_ERTM) &&\n\t\t    !(chan->conn->feat_mask & L2CAP_FEAT_STREAMING))\n\t\t\tbreak;\n\n\t\trfc.mode            = L2CAP_MODE_BASIC;\n\t\trfc.txwin_size      = 0;\n\t\trfc.max_transmit    = 0;\n\t\trfc.retrans_timeout = 0;\n\t\trfc.monitor_timeout = 0;\n\t\trfc.max_pdu_size    = 0;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\t\trfc.mode            = L2CAP_MODE_ERTM;\n\t\trfc.max_transmit    = chan->max_tx;\n\n\t\t__l2cap_set_ertm_timeouts(chan, &rfc);\n\n\t\tsize = min_t(u16, L2CAP_DEFAULT_MAX_PDU_SIZE, chan->conn->mtu -\n\t\t\t     L2CAP_EXT_HDR_SIZE - L2CAP_SDULEN_SIZE -\n\t\t\t     L2CAP_FCS_SIZE);\n\t\trfc.max_pdu_size = cpu_to_le16(size);\n\n\t\tl2cap_txwin_setup(chan);\n\n\t\trfc.txwin_size = min_t(u16, chan->tx_win,\n\t\t\t\t       L2CAP_DEFAULT_TX_WINDOW);\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\n\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags))\n\t\t\tl2cap_add_opt_efs(&ptr, chan, endptr - ptr);\n\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,\n\t\t\t\t\t   chan->tx_win, endptr - ptr);\n\n\t\tif (chan->conn->feat_mask & L2CAP_FEAT_FCS)\n\t\t\tif (chan->fcs == L2CAP_FCS_NONE ||\n\t\t\t    test_bit(CONF_RECV_NO_FCS, &chan->conf_state)) {\n\t\t\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1,\n\t\t\t\t\t\t   chan->fcs, endptr - ptr);\n\t\t\t}\n\t\tbreak;\n\n\tcase L2CAP_MODE_STREAMING:\n\t\tl2cap_txwin_setup(chan);\n\t\trfc.mode            = L2CAP_MODE_STREAMING;\n\t\trfc.txwin_size      = 0;\n\t\trfc.max_transmit    = 0;\n\t\trfc.retrans_timeout = 0;\n\t\trfc.monitor_timeout = 0;\n\n\t\tsize = min_t(u16, L2CAP_DEFAULT_MAX_PDU_SIZE, chan->conn->mtu -\n\t\t\t     L2CAP_EXT_HDR_SIZE - L2CAP_SDULEN_SIZE -\n\t\t\t     L2CAP_FCS_SIZE);\n\t\trfc.max_pdu_size = cpu_to_le16(size);\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\n\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags))\n\t\t\tl2cap_add_opt_efs(&ptr, chan, endptr - ptr);\n\n\t\tif (chan->conn->feat_mask & L2CAP_FEAT_FCS)\n\t\t\tif (chan->fcs == L2CAP_FCS_NONE ||\n\t\t\t    test_bit(CONF_RECV_NO_FCS, &chan->conf_state)) {\n\t\t\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1,\n\t\t\t\t\t\t   chan->fcs, endptr - ptr);\n\t\t\t}\n\t\tbreak;\n\t}\n\n\treq->dcid  = cpu_to_le16(chan->dcid);\n\treq->flags = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n\nstatic int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)\n{\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\tvoid *endptr = data + data_size;\n\tvoid *req = chan->conf_req;\n\tint len = chan->conf_len;\n\tint type, hint, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\tu8 remote_efs = 0;\n\tu16 mtu = L2CAP_DEFAULT_MTU;\n\tu16 result = L2CAP_CONF_SUCCESS;\n\tu16 size;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&req, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\thint  = type & L2CAP_CONF_HINT;\n\t\ttype &= L2CAP_CONF_MASK;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tmtu = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_QOS:\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\tset_bit(CONF_RECV_NO_FCS, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tremote_efs = 1;\n\t\t\tmemcpy(&efs, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (!(chan->conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tset_bit(FLAG_EXT_CTRL, &chan->flags);\n\t\t\tset_bit(CONF_EWS_RECV, &chan->conf_state);\n\t\t\tchan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;\n\t\t\tchan->remote_tx_win = val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\tl2cap_add_conf_opt(&ptr, (u8)type, sizeof(u8), type, endptr - ptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->num_conf_rsp || chan->num_conf_req > 1)\n\t\tgoto done;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) {\n\t\t\tchan->mode = l2cap_select_mode(rfc.mode,\n\t\t\t\t\t\t       chan->conn->feat_mask);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (remote_efs) {\n\t\t\tif (__l2cap_efs_supported(chan->conn))\n\t\t\t\tset_bit(FLAG_EFS_ENABLE, &chan->flags);\n\t\t\telse\n\t\t\t\treturn -ECONNREFUSED;\n\t\t}\n\n\t\tif (chan->mode != rfc.mode)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tbreak;\n\t}\n\ndone:\n\tif (chan->mode != rfc.mode) {\n\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\trfc.mode = chan->mode;\n\n\t\tif (chan->num_conf_rsp == 1)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t}\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\telse {\n\t\t\tchan->omtu = mtu;\n\t\t\tset_bit(CONF_MTU_DONE, &chan->conf_state);\n\t\t}\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu, endptr - ptr);\n\n\t\tif (remote_efs) {\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype) {\n\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\t\tif (chan->num_conf_req >= 1)\n\t\t\t\t\treturn -ECONNREFUSED;\n\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t} else {\n\t\t\t\t/* Send PENDING Conf Rsp */\n\t\t\t\tresult = L2CAP_CONF_PENDING;\n\t\t\t\tset_bit(CONF_LOC_CONF_PEND, &chan->conf_state);\n\t\t\t}\n\t\t}\n\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tif (!test_bit(CONF_EWS_RECV, &chan->conf_state))\n\t\t\t\tchan->remote_tx_win = rfc.txwin_size;\n\t\t\telse\n\t\t\t\trfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW;\n\n\t\t\tchan->remote_max_tx = rfc.max_transmit;\n\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\t__l2cap_set_ertm_timeouts(chan, &rfc);\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\t   sizeof(rfc), (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->remote_id = efs.id;\n\t\t\t\tchan->remote_stype = efs.stype;\n\t\t\t\tchan->remote_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->remote_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t\tchan->remote_acc_lat =\n\t\t\t\t\tle32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->remote_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = chan->mode;\n\t\t}\n\n\t\tif (result == L2CAP_CONF_SUCCESS)\n\t\t\tset_bit(CONF_OUTPUT_DONE, &chan->conf_state);\n\t}\n\trsp->scid   = cpu_to_le16(chan->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n\nstatic int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,\n\t\t\t\tvoid *data, size_t size, u16 *result)\n{\n\tstruct l2cap_conf_req *req = data;\n\tvoid *ptr = req->data;\n\tvoid *endptr = data + size;\n\tint type, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\n\tBT_DBG(\"chan %p, rsp %p, len %d, req %p\", chan, rsp, len, data);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (val < L2CAP_DEFAULT_MIN_MTU) {\n\t\t\t\t*result = L2CAP_CONF_UNACCEPT;\n\t\t\t\tchan->imtu = L2CAP_DEFAULT_MIN_MTU;\n\t\t\t} else\n\t\t\t\tchan->imtu = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu,\n\t\t\t\t\t   endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO, 2,\n\t\t\t\t\t   chan->flush_to, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tif (test_bit(CONF_STATE2_DEVICE, &chan->conf_state) &&\n\t\t\t    rfc.mode != chan->mode)\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tchan->fcs = 0;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->ack_win = min_t(u16, val, chan->ack_win);\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,\n\t\t\t\t\t   chan->tx_win, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&efs, (void *)val, olen);\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype)\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs),\n\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (*result == L2CAP_CONF_PENDING)\n\t\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\t\tset_bit(CONF_RECV_NO_FCS,\n\t\t\t\t\t\t&chan->conf_state);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->mode == L2CAP_MODE_BASIC && chan->mode != rfc.mode)\n\t\treturn -ECONNREFUSED;\n\n\tchan->mode = rfc.mode;\n\n\tif (*result == L2CAP_CONF_SUCCESS || *result == L2CAP_CONF_PENDING) {\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t\t\tif (!test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t\t      rfc.txwin_size);\n\n\t\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->local_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->local_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tchan->local_acc_lat = le32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->local_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t\t}\n\t}\n\n\treq->dcid   = cpu_to_le16(chan->dcid);\n\treq->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n\nstatic int l2cap_build_conf_rsp(struct l2cap_chan *chan, void *data,\n\t\t\t\tu16 result, u16 flags)\n{\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\trsp->scid   = cpu_to_le16(chan->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(flags);\n\n\treturn ptr - data;\n}\n\nvoid __l2cap_le_connect_rsp_defer(struct l2cap_chan *chan)\n{\n\tstruct l2cap_le_conn_rsp rsp;\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\trsp.dcid    = cpu_to_le16(chan->scid);\n\trsp.mtu     = cpu_to_le16(chan->imtu);\n\trsp.mps     = cpu_to_le16(chan->mps);\n\trsp.credits = cpu_to_le16(chan->rx_credits);\n\trsp.result  = cpu_to_le16(L2CAP_CR_LE_SUCCESS);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_RSP, sizeof(rsp),\n\t\t       &rsp);\n}\n\nvoid __l2cap_ecred_conn_rsp_defer(struct l2cap_chan *chan)\n{\n\tstruct {\n\t\tstruct l2cap_ecred_conn_rsp rsp;\n\t\t__le16 dcid[5];\n\t} __packed pdu;\n\tstruct l2cap_conn *conn = chan->conn;\n\tu16 ident = chan->ident;\n\tint i = 0;\n\n\tif (!ident)\n\t\treturn;\n\n\tBT_DBG(\"chan %p ident %d\", chan, ident);\n\n\tpdu.rsp.mtu     = cpu_to_le16(chan->imtu);\n\tpdu.rsp.mps     = cpu_to_le16(chan->mps);\n\tpdu.rsp.credits = cpu_to_le16(chan->rx_credits);\n\tpdu.rsp.result  = cpu_to_le16(L2CAP_CR_LE_SUCCESS);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tif (chan->ident != ident)\n\t\t\tcontinue;\n\n\t\t/* Reset ident so only one response is sent */\n\t\tchan->ident = 0;\n\n\t\t/* Include all channels pending with the same ident */\n\t\tpdu.dcid[i++] = cpu_to_le16(chan->scid);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n\n\tl2cap_send_cmd(conn, ident, L2CAP_ECRED_CONN_RSP,\n\t\t\tsizeof(pdu.rsp) + i * sizeof(__le16), &pdu);\n}\n\nvoid __l2cap_connect_rsp_defer(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn_rsp rsp;\n\tstruct l2cap_conn *conn = chan->conn;\n\tu8 buf[128];\n\tu8 rsp_code;\n\n\trsp.scid   = cpu_to_le16(chan->dcid);\n\trsp.dcid   = cpu_to_le16(chan->scid);\n\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\n\tif (chan->hs_hcon)\n\t\trsp_code = L2CAP_CREATE_CHAN_RSP;\n\telse\n\t\trsp_code = L2CAP_CONN_RSP;\n\n\tBT_DBG(\"chan %p rsp_code %u\", chan, rsp_code);\n\n\tl2cap_send_cmd(conn, chan->ident, rsp_code, sizeof(rsp), &rsp);\n\n\tif (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))\n\t\treturn;\n\n\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\tchan->num_conf_req++;\n}\n\nstatic void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}\n\nstatic inline int l2cap_command_rej(struct l2cap_conn *conn,\n\t\t\t\t    struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t    u8 *data)\n{\n\tstruct l2cap_cmd_rej_unk *rej = (struct l2cap_cmd_rej_unk *) data;\n\n\tif (cmd_len < sizeof(*rej))\n\t\treturn -EPROTO;\n\n\tif (rej->reason != L2CAP_REJ_NOT_UNDERSTOOD)\n\t\treturn 0;\n\n\tif ((conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) &&\n\t    cmd->ident == conn->info_ident) {\n\t\tcancel_delayed_work(&conn->info_timer);\n\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\tconn->info_ident = 0;\n\n\t\tl2cap_conn_start(conn);\n\t}\n\n\treturn 0;\n}\n\nstatic struct l2cap_chan *l2cap_connect(struct l2cap_conn *conn,\n\t\t\t\t\tstruct l2cap_cmd_hdr *cmd,\n\t\t\t\t\tu8 *data, u8 rsp_code, u8 amp_id)\n{\n\tstruct l2cap_conn_req *req = (struct l2cap_conn_req *) data;\n\tstruct l2cap_conn_rsp rsp;\n\tstruct l2cap_chan *chan = NULL, *pchan;\n\tint result, status = L2CAP_CS_NO_INFO;\n\n\tu16 dcid = 0, scid = __le16_to_cpu(req->scid);\n\t__le16 psm = req->psm;\n\n\tBT_DBG(\"psm 0x%2.2x scid 0x%4.4x\", __le16_to_cpu(psm), scid);\n\n\t/* Check if we have socket listening on psm */\n\tpchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, &conn->hcon->src,\n\t\t\t\t\t &conn->hcon->dst, ACL_LINK);\n\tif (!pchan) {\n\t\tresult = L2CAP_CR_BAD_PSM;\n\t\tgoto sendresp;\n\t}\n\n\tmutex_lock(&conn->chan_lock);\n\tl2cap_chan_lock(pchan);\n\n\t/* Check if the ACL is secure enough (if not SDP) */\n\tif (psm != cpu_to_le16(L2CAP_PSM_SDP) &&\n\t    !hci_conn_check_link_mode(conn->hcon)) {\n\t\tconn->disc_reason = HCI_ERROR_AUTH_FAILURE;\n\t\tresult = L2CAP_CR_SEC_BLOCK;\n\t\tgoto response;\n\t}\n\n\tresult = L2CAP_CR_NO_MEM;\n\n\t/* Check for valid dynamic CID range (as per Erratum 3253) */\n\tif (scid < L2CAP_CID_DYN_START || scid > L2CAP_CID_DYN_END) {\n\t\tresult = L2CAP_CR_INVALID_SCID;\n\t\tgoto response;\n\t}\n\n\t/* Check if we already have channel with that dcid */\n\tif (__l2cap_get_chan_by_dcid(conn, scid)) {\n\t\tresult = L2CAP_CR_SCID_IN_USE;\n\t\tgoto response;\n\t}\n\n\tchan = pchan->ops->new_connection(pchan);\n\tif (!chan)\n\t\tgoto response;\n\n\t/* For certain devices (ex: HID mouse), support for authentication,\n\t * pairing and bonding is optional. For such devices, inorder to avoid\n\t * the ACL alive for too long after L2CAP disconnection, reset the ACL\n\t * disc_timeout back to HCI_DISCONN_TIMEOUT during L2CAP connect.\n\t */\n\tconn->hcon->disc_timeout = HCI_DISCONN_TIMEOUT;\n\n\tbacpy(&chan->src, &conn->hcon->src);\n\tbacpy(&chan->dst, &conn->hcon->dst);\n\tchan->src_type = bdaddr_src_type(conn->hcon);\n\tchan->dst_type = bdaddr_dst_type(conn->hcon);\n\tchan->psm  = psm;\n\tchan->dcid = scid;\n\tchan->local_amp_id = amp_id;\n\n\t__l2cap_chan_add(conn, chan);\n\n\tdcid = chan->scid;\n\n\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\n\tchan->ident = cmd->ident;\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {\n\t\tif (l2cap_chan_check_security(chan, false)) {\n\t\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t\t\tresult = L2CAP_CR_PEND;\n\t\t\t\tstatus = L2CAP_CS_AUTHOR_PEND;\n\t\t\t\tchan->ops->defer(chan);\n\t\t\t} else {\n\t\t\t\t/* Force pending result for AMP controllers.\n\t\t\t\t * The connection will succeed after the\n\t\t\t\t * physical link is up.\n\t\t\t\t */\n\t\t\t\tif (amp_id == AMP_ID_BREDR) {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\t\t\tresult = L2CAP_CR_SUCCESS;\n\t\t\t\t} else {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t\t\t\tresult = L2CAP_CR_PEND;\n\t\t\t\t}\n\t\t\t\tstatus = L2CAP_CS_NO_INFO;\n\t\t\t}\n\t\t} else {\n\t\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t\tresult = L2CAP_CR_PEND;\n\t\t\tstatus = L2CAP_CS_AUTHEN_PEND;\n\t\t}\n\t} else {\n\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\tresult = L2CAP_CR_PEND;\n\t\tstatus = L2CAP_CS_NO_INFO;\n\t}\n\nresponse:\n\tl2cap_chan_unlock(pchan);\n\tmutex_unlock(&conn->chan_lock);\n\tl2cap_chan_put(pchan);\n\nsendresp:\n\trsp.scid   = cpu_to_le16(scid);\n\trsp.dcid   = cpu_to_le16(dcid);\n\trsp.result = cpu_to_le16(result);\n\trsp.status = cpu_to_le16(status);\n\tl2cap_send_cmd(conn, cmd->ident, rsp_code, sizeof(rsp), &rsp);\n\n\tif (result == L2CAP_CR_PEND && status == L2CAP_CS_NO_INFO) {\n\t\tstruct l2cap_info_req info;\n\t\tinfo.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;\n\t\tconn->info_ident = l2cap_get_ident(conn);\n\n\t\tschedule_delayed_work(&conn->info_timer, L2CAP_INFO_TIMEOUT);\n\n\t\tl2cap_send_cmd(conn, conn->info_ident, L2CAP_INFO_REQ,\n\t\t\t       sizeof(info), &info);\n\t}\n\n\tif (chan && !test_bit(CONF_REQ_SENT, &chan->conf_state) &&\n\t    result == L2CAP_CR_SUCCESS) {\n\t\tu8 buf[128];\n\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\t\tchan->num_conf_req++;\n\t}\n\n\treturn chan;\n}\n\nstatic int l2cap_connect_req(struct l2cap_conn *conn,\n\t\t\t     struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)\n{\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\tstruct hci_conn *hcon = conn->hcon;\n\n\tif (cmd_len < sizeof(struct l2cap_conn_req))\n\t\treturn -EPROTO;\n\n\thci_dev_lock(hdev);\n\tif (hci_dev_test_flag(hdev, HCI_MGMT) &&\n\t    !test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &hcon->flags))\n\t\tmgmt_device_connected(hdev, hcon, NULL, 0);\n\thci_dev_unlock(hdev);\n\n\tl2cap_connect(conn, cmd, data, L2CAP_CONN_RSP, 0);\n\treturn 0;\n}\n\nstatic int l2cap_connect_create_rsp(struct l2cap_conn *conn,\n\t\t\t\t    struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t    u8 *data)\n{\n\tstruct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;\n\tu16 scid, dcid, result, status;\n\tstruct l2cap_chan *chan;\n\tu8 req[128];\n\tint err;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tscid   = __le16_to_cpu(rsp->scid);\n\tdcid   = __le16_to_cpu(rsp->dcid);\n\tresult = __le16_to_cpu(rsp->result);\n\tstatus = __le16_to_cpu(rsp->status);\n\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x\",\n\t       dcid, scid, result, status);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tif (scid) {\n\t\tchan = __l2cap_get_chan_by_scid(conn, scid);\n\t\tif (!chan) {\n\t\t\terr = -EBADSLT;\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tchan = __l2cap_get_chan_by_ident(conn, cmd->ident);\n\t\tif (!chan) {\n\t\t\terr = -EBADSLT;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tchan = l2cap_chan_hold_unless_zero(chan);\n\tif (!chan) {\n\t\terr = -EBADSLT;\n\t\tgoto unlock;\n\t}\n\n\terr = 0;\n\n\tl2cap_chan_lock(chan);\n\n\tswitch (result) {\n\tcase L2CAP_CR_SUCCESS:\n\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\tchan->ident = 0;\n\t\tchan->dcid = dcid;\n\t\tclear_bit(CONF_CONNECT_PEND, &chan->conf_state);\n\n\t\tif (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))\n\t\t\tbreak;\n\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, req, sizeof(req)), req);\n\t\tchan->num_conf_req++;\n\t\tbreak;\n\n\tcase L2CAP_CR_PEND:\n\t\tset_bit(CONF_CONNECT_PEND, &chan->conf_state);\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\tbreak;\n\t}\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\nunlock:\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn err;\n}\n\nstatic inline void set_default_fcs(struct l2cap_chan *chan)\n{\n\t/* FCS is enabled only in ERTM or streaming mode, if one or both\n\t * sides request it.\n\t */\n\tif (chan->mode != L2CAP_MODE_ERTM && chan->mode != L2CAP_MODE_STREAMING)\n\t\tchan->fcs = L2CAP_FCS_NONE;\n\telse if (!test_bit(CONF_RECV_NO_FCS, &chan->conf_state))\n\t\tchan->fcs = L2CAP_FCS_CRC16;\n}\n\nstatic void l2cap_send_efs_conf_rsp(struct l2cap_chan *chan, void *data,\n\t\t\t\t    u8 ident, u16 flags)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tBT_DBG(\"conn %p chan %p ident %d flags 0x%4.4x\", conn, chan, ident,\n\t       flags);\n\n\tclear_bit(CONF_LOC_CONF_PEND, &chan->conf_state);\n\tset_bit(CONF_OUTPUT_DONE, &chan->conf_state);\n\n\tl2cap_send_cmd(conn, ident, L2CAP_CONF_RSP,\n\t\t       l2cap_build_conf_rsp(chan, data,\n\t\t\t\t\t    L2CAP_CONF_SUCCESS, flags), data);\n}\n\nstatic void cmd_reject_invalid_cid(struct l2cap_conn *conn, u8 ident,\n\t\t\t\t   u16 scid, u16 dcid)\n{\n\tstruct l2cap_cmd_rej_cid rej;\n\n\trej.reason = cpu_to_le16(L2CAP_REJ_INVALID_CID);\n\trej.scid = __cpu_to_le16(scid);\n\trej.dcid = __cpu_to_le16(dcid);\n\n\tl2cap_send_cmd(conn, ident, L2CAP_COMMAND_REJ, sizeof(rej), &rej);\n}\n\nstatic inline int l2cap_config_req(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tstruct l2cap_conf_req *req = (struct l2cap_conf_req *) data;\n\tu16 dcid, flags;\n\tu8 rsp[64];\n\tstruct l2cap_chan *chan;\n\tint len, err = 0;\n\n\tif (cmd_len < sizeof(*req))\n\t\treturn -EPROTO;\n\n\tdcid  = __le16_to_cpu(req->dcid);\n\tflags = __le16_to_cpu(req->flags);\n\n\tBT_DBG(\"dcid 0x%4.4x flags 0x%2.2x\", dcid, flags);\n\n\tchan = l2cap_get_chan_by_scid(conn, dcid);\n\tif (!chan) {\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, dcid, 0);\n\t\treturn 0;\n\t}\n\n\tif (chan->state != BT_CONFIG && chan->state != BT_CONNECT2 &&\n\t    chan->state != BT_CONNECTED) {\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, chan->scid,\n\t\t\t\t       chan->dcid);\n\t\tgoto unlock;\n\t}\n\n\t/* Reject if config buffer is too small. */\n\tlen = cmd_len - sizeof(*req);\n\tif (chan->conf_len + len > sizeof(chan->conf_req)) {\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t       l2cap_build_conf_rsp(chan, rsp,\n\t\t\t       L2CAP_CONF_REJECT, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Store config. */\n\tmemcpy(chan->conf_req + chan->conf_len, req->data, len);\n\tchan->conf_len += len;\n\n\tif (flags & L2CAP_CONF_FLAG_CONTINUATION) {\n\t\t/* Incomplete config. Send empty response. */\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t       l2cap_build_conf_rsp(chan, rsp,\n\t\t\t       L2CAP_CONF_SUCCESS, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Complete config. */\n\tlen = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));\n\tif (len < 0) {\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\tgoto unlock;\n\t}\n\n\tchan->ident = cmd->ident;\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\n\tchan->num_conf_rsp++;\n\n\t/* Reset config buffer. */\n\tchan->conf_len = 0;\n\n\tif (!test_bit(CONF_OUTPUT_DONE, &chan->conf_state))\n\t\tgoto unlock;\n\n\tif (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {\n\t\tset_default_fcs(chan);\n\n\t\tif (chan->mode == L2CAP_MODE_ERTM ||\n\t\t    chan->mode == L2CAP_MODE_STREAMING)\n\t\t\terr = l2cap_ertm_init(chan);\n\n\t\tif (err < 0)\n\t\t\tl2cap_send_disconn_req(chan, -err);\n\t\telse\n\t\t\tl2cap_chan_ready(chan);\n\n\t\tgoto unlock;\n\t}\n\n\tif (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {\n\t\tu8 buf[64];\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\t\tchan->num_conf_req++;\n\t}\n\n\t/* Got Conf Rsp PENDING from remote side and assume we sent\n\t   Conf Rsp PENDING in the code above */\n\tif (test_bit(CONF_REM_CONF_PEND, &chan->conf_state) &&\n\t    test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {\n\n\t\t/* check compatibility */\n\n\t\t/* Send rsp for BR/EDR channel */\n\t\tif (!chan->hs_hcon)\n\t\t\tl2cap_send_efs_conf_rsp(chan, rsp, cmd->ident, flags);\n\t\telse\n\t\t\tchan->ident = cmd->ident;\n\t}\n\nunlock:\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\treturn err;\n}\n\nstatic inline int l2cap_config_rsp(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tstruct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;\n\tu16 scid, flags, result;\n\tstruct l2cap_chan *chan;\n\tint len = cmd_len - sizeof(*rsp);\n\tint err = 0;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tscid   = __le16_to_cpu(rsp->scid);\n\tflags  = __le16_to_cpu(rsp->flags);\n\tresult = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x len %d\", scid, flags,\n\t       result, len);\n\n\tchan = l2cap_get_chan_by_scid(conn, scid);\n\tif (!chan)\n\t\treturn 0;\n\n\tswitch (result) {\n\tcase L2CAP_CONF_SUCCESS:\n\t\tl2cap_conf_rfc_get(chan, rsp->data, len);\n\t\tclear_bit(CONF_REM_CONF_PEND, &chan->conf_state);\n\t\tbreak;\n\n\tcase L2CAP_CONF_PENDING:\n\t\tset_bit(CONF_REM_CONF_PEND, &chan->conf_state);\n\n\t\tif (test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {\n\t\t\tchar buf[64];\n\n\t\t\tlen = l2cap_parse_conf_rsp(chan, rsp->data, len,\n\t\t\t\t\t\t   buf, sizeof(buf), &result);\n\t\t\tif (len < 0) {\n\t\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!chan->hs_hcon) {\n\t\t\t\tl2cap_send_efs_conf_rsp(chan, buf, cmd->ident,\n\t\t\t\t\t\t\t0);\n\t\t\t} else {\n\t\t\t\tif (l2cap_check_efs(chan)) {\n\t\t\t\t\tamp_create_logical_link(chan);\n\t\t\t\t\tchan->ident = cmd->ident;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\n\tcase L2CAP_CONF_UNKNOWN:\n\tcase L2CAP_CONF_UNACCEPT:\n\t\tif (chan->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {\n\t\t\tchar req[64];\n\n\t\t\tif (len > sizeof(req) - sizeof(struct l2cap_conf_req)) {\n\t\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* throw out any old stored conf requests */\n\t\t\tresult = L2CAP_CONF_SUCCESS;\n\t\t\tlen = l2cap_parse_conf_rsp(chan, rsp->data, len,\n\t\t\t\t\t\t   req, sizeof(req), &result);\n\t\t\tif (len < 0) {\n\t\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t       L2CAP_CONF_REQ, len, req);\n\t\t\tchan->num_conf_req++;\n\t\t\tif (result != L2CAP_CONF_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tdefault:\n\t\tl2cap_chan_set_err(chan, ECONNRESET);\n\n\t\t__set_chan_timer(chan, L2CAP_DISC_REJ_TIMEOUT);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\tgoto done;\n\t}\n\n\tif (flags & L2CAP_CONF_FLAG_CONTINUATION)\n\t\tgoto done;\n\n\tset_bit(CONF_INPUT_DONE, &chan->conf_state);\n\n\tif (test_bit(CONF_OUTPUT_DONE, &chan->conf_state)) {\n\t\tset_default_fcs(chan);\n\n\t\tif (chan->mode == L2CAP_MODE_ERTM ||\n\t\t    chan->mode == L2CAP_MODE_STREAMING)\n\t\t\terr = l2cap_ertm_init(chan);\n\n\t\tif (err < 0)\n\t\t\tl2cap_send_disconn_req(chan, -err);\n\t\telse\n\t\t\tl2cap_chan_ready(chan);\n\t}\n\ndone:\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\treturn err;\n}\n\nstatic inline int l2cap_disconnect_req(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_disconn_req *req = (struct l2cap_disconn_req *) data;\n\tstruct l2cap_disconn_rsp rsp;\n\tu16 dcid, scid;\n\tstruct l2cap_chan *chan;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\tscid = __le16_to_cpu(req->scid);\n\tdcid = __le16_to_cpu(req->dcid);\n\n\tBT_DBG(\"scid 0x%4.4x dcid 0x%4.4x\", scid, dcid);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tchan = __l2cap_get_chan_by_scid(conn, dcid);\n\tif (!chan) {\n\t\tmutex_unlock(&conn->chan_lock);\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, dcid, scid);\n\t\treturn 0;\n\t}\n\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\n\trsp.dcid = cpu_to_le16(chan->scid);\n\trsp.scid = cpu_to_le16(chan->dcid);\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_DISCONN_RSP, sizeof(rsp), &rsp);\n\n\tchan->ops->set_shutdown(chan);\n\n\tl2cap_chan_del(chan, ECONNRESET);\n\n\tchan->ops->close(chan);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_disconnect_rsp(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_disconn_rsp *rsp = (struct l2cap_disconn_rsp *) data;\n\tu16 dcid, scid;\n\tstruct l2cap_chan *chan;\n\n\tif (cmd_len != sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tscid = __le16_to_cpu(rsp->scid);\n\tdcid = __le16_to_cpu(rsp->dcid);\n\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x\", dcid, scid);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tchan = __l2cap_get_chan_by_scid(conn, scid);\n\tif (!chan) {\n\t\tmutex_unlock(&conn->chan_lock);\n\t\treturn 0;\n\t}\n\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\n\tif (chan->state != BT_DISCONN) {\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t\tmutex_unlock(&conn->chan_lock);\n\t\treturn 0;\n\t}\n\n\tl2cap_chan_del(chan, 0);\n\n\tchan->ops->close(chan);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_information_req(struct l2cap_conn *conn,\n\t\t\t\t\tstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t\tu8 *data)\n{\n\tstruct l2cap_info_req *req = (struct l2cap_info_req *) data;\n\tu16 type;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\ttype = __le16_to_cpu(req->type);\n\n\tBT_DBG(\"type 0x%4.4x\", type);\n\n\tif (type == L2CAP_IT_FEAT_MASK) {\n\t\tu8 buf[8];\n\t\tu32 feat_mask = l2cap_feat_mask;\n\t\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;\n\t\trsp->type   = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\t\trsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);\n\t\tif (!disable_ertm)\n\t\t\tfeat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING\n\t\t\t\t| L2CAP_FEAT_FCS;\n\t\tif (conn->local_fixed_chan & L2CAP_FC_A2MP)\n\t\t\tfeat_mask |= L2CAP_FEAT_EXT_FLOW\n\t\t\t\t| L2CAP_FEAT_EXT_WINDOW;\n\n\t\tput_unaligned_le32(feat_mask, rsp->data);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_INFO_RSP, sizeof(buf),\n\t\t\t       buf);\n\t} else if (type == L2CAP_IT_FIXED_CHAN) {\n\t\tu8 buf[12];\n\t\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;\n\n\t\trsp->type   = cpu_to_le16(L2CAP_IT_FIXED_CHAN);\n\t\trsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);\n\t\trsp->data[0] = conn->local_fixed_chan;\n\t\tmemset(rsp->data + 1, 0, 7);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_INFO_RSP, sizeof(buf),\n\t\t\t       buf);\n\t} else {\n\t\tstruct l2cap_info_rsp rsp;\n\t\trsp.type   = cpu_to_le16(type);\n\t\trsp.result = cpu_to_le16(L2CAP_IR_NOTSUPP);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_INFO_RSP, sizeof(rsp),\n\t\t\t       &rsp);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int l2cap_information_rsp(struct l2cap_conn *conn,\n\t\t\t\t\tstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t\tu8 *data)\n{\n\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) data;\n\tu16 type, result;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\ttype   = __le16_to_cpu(rsp->type);\n\tresult = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"type 0x%4.4x result 0x%2.2x\", type, result);\n\n\t/* L2CAP Info req/rsp are unbound to channels, add extra checks */\n\tif (cmd->ident != conn->info_ident ||\n\t    conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)\n\t\treturn 0;\n\n\tcancel_delayed_work(&conn->info_timer);\n\n\tif (result != L2CAP_IR_SUCCESS) {\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\tconn->info_ident = 0;\n\n\t\tl2cap_conn_start(conn);\n\n\t\treturn 0;\n\t}\n\n\tswitch (type) {\n\tcase L2CAP_IT_FEAT_MASK:\n\t\tconn->feat_mask = get_unaligned_le32(rsp->data);\n\n\t\tif (conn->feat_mask & L2CAP_FEAT_FIXED_CHAN) {\n\t\t\tstruct l2cap_info_req req;\n\t\t\treq.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);\n\n\t\t\tconn->info_ident = l2cap_get_ident(conn);\n\n\t\t\tl2cap_send_cmd(conn, conn->info_ident,\n\t\t\t\t       L2CAP_INFO_REQ, sizeof(req), &req);\n\t\t} else {\n\t\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\t\tconn->info_ident = 0;\n\n\t\t\tl2cap_conn_start(conn);\n\t\t}\n\t\tbreak;\n\n\tcase L2CAP_IT_FIXED_CHAN:\n\t\tconn->remote_fixed_chan = rsp->data[0];\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\tconn->info_ident = 0;\n\n\t\tl2cap_conn_start(conn);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int l2cap_create_channel_req(struct l2cap_conn *conn,\n\t\t\t\t    struct l2cap_cmd_hdr *cmd,\n\t\t\t\t    u16 cmd_len, void *data)\n{\n\tstruct l2cap_create_chan_req *req = data;\n\tstruct l2cap_create_chan_rsp rsp;\n\tstruct l2cap_chan *chan;\n\tstruct hci_dev *hdev;\n\tu16 psm, scid;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\tif (!(conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\treturn -EINVAL;\n\n\tpsm = le16_to_cpu(req->psm);\n\tscid = le16_to_cpu(req->scid);\n\n\tBT_DBG(\"psm 0x%2.2x, scid 0x%4.4x, amp_id %d\", psm, scid, req->amp_id);\n\n\t/* For controller id 0 make BR/EDR connection */\n\tif (req->amp_id == AMP_ID_BREDR) {\n\t\tl2cap_connect(conn, cmd, data, L2CAP_CREATE_CHAN_RSP,\n\t\t\t      req->amp_id);\n\t\treturn 0;\n\t}\n\n\t/* Validate AMP controller id */\n\thdev = hci_dev_get(req->amp_id);\n\tif (!hdev)\n\t\tgoto error;\n\n\tif (hdev->dev_type != HCI_AMP || !test_bit(HCI_UP, &hdev->flags)) {\n\t\thci_dev_put(hdev);\n\t\tgoto error;\n\t}\n\n\tchan = l2cap_connect(conn, cmd, data, L2CAP_CREATE_CHAN_RSP,\n\t\t\t     req->amp_id);\n\tif (chan) {\n\t\tstruct amp_mgr *mgr = conn->hcon->amp_mgr;\n\t\tstruct hci_conn *hs_hcon;\n\n\t\ths_hcon = hci_conn_hash_lookup_ba(hdev, AMP_LINK,\n\t\t\t\t\t\t  &conn->hcon->dst);\n\t\tif (!hs_hcon) {\n\t\t\thci_dev_put(hdev);\n\t\t\tcmd_reject_invalid_cid(conn, cmd->ident, chan->scid,\n\t\t\t\t\t       chan->dcid);\n\t\t\treturn 0;\n\t\t}\n\n\t\tBT_DBG(\"mgr %p bredr_chan %p hs_hcon %p\", mgr, chan, hs_hcon);\n\n\t\tmgr->bredr_chan = chan;\n\t\tchan->hs_hcon = hs_hcon;\n\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\tconn->mtu = hdev->block_mtu;\n\t}\n\n\thci_dev_put(hdev);\n\n\treturn 0;\n\nerror:\n\trsp.dcid = 0;\n\trsp.scid = cpu_to_le16(scid);\n\trsp.result = cpu_to_le16(L2CAP_CR_BAD_AMP);\n\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CREATE_CHAN_RSP,\n\t\t       sizeof(rsp), &rsp);\n\n\treturn 0;\n}\n\nstatic void l2cap_send_move_chan_req(struct l2cap_chan *chan, u8 dest_amp_id)\n{\n\tstruct l2cap_move_chan_req req;\n\tu8 ident;\n\n\tBT_DBG(\"chan %p, dest_amp_id %d\", chan, dest_amp_id);\n\n\tident = l2cap_get_ident(chan->conn);\n\tchan->ident = ident;\n\n\treq.icid = cpu_to_le16(chan->scid);\n\treq.dest_amp_id = dest_amp_id;\n\n\tl2cap_send_cmd(chan->conn, ident, L2CAP_MOVE_CHAN_REQ, sizeof(req),\n\t\t       &req);\n\n\t__set_chan_timer(chan, L2CAP_MOVE_TIMEOUT);\n}\n\nstatic void l2cap_send_move_chan_rsp(struct l2cap_chan *chan, u16 result)\n{\n\tstruct l2cap_move_chan_rsp rsp;\n\n\tBT_DBG(\"chan %p, result 0x%4.4x\", chan, result);\n\n\trsp.icid = cpu_to_le16(chan->dcid);\n\trsp.result = cpu_to_le16(result);\n\n\tl2cap_send_cmd(chan->conn, chan->ident, L2CAP_MOVE_CHAN_RSP,\n\t\t       sizeof(rsp), &rsp);\n}\n\nstatic void l2cap_send_move_chan_cfm(struct l2cap_chan *chan, u16 result)\n{\n\tstruct l2cap_move_chan_cfm cfm;\n\n\tBT_DBG(\"chan %p, result 0x%4.4x\", chan, result);\n\n\tchan->ident = l2cap_get_ident(chan->conn);\n\n\tcfm.icid = cpu_to_le16(chan->scid);\n\tcfm.result = cpu_to_le16(result);\n\n\tl2cap_send_cmd(chan->conn, chan->ident, L2CAP_MOVE_CHAN_CFM,\n\t\t       sizeof(cfm), &cfm);\n\n\t__set_chan_timer(chan, L2CAP_MOVE_TIMEOUT);\n}\n\nstatic void l2cap_send_move_chan_cfm_icid(struct l2cap_conn *conn, u16 icid)\n{\n\tstruct l2cap_move_chan_cfm cfm;\n\n\tBT_DBG(\"conn %p, icid 0x%4.4x\", conn, icid);\n\n\tcfm.icid = cpu_to_le16(icid);\n\tcfm.result = cpu_to_le16(L2CAP_MC_UNCONFIRMED);\n\n\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_MOVE_CHAN_CFM,\n\t\t       sizeof(cfm), &cfm);\n}\n\nstatic void l2cap_send_move_chan_cfm_rsp(struct l2cap_conn *conn, u8 ident,\n\t\t\t\t\t u16 icid)\n{\n\tstruct l2cap_move_chan_cfm_rsp rsp;\n\n\tBT_DBG(\"icid 0x%4.4x\", icid);\n\n\trsp.icid = cpu_to_le16(icid);\n\tl2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM_RSP, sizeof(rsp), &rsp);\n}\n\nstatic void __release_logical_link(struct l2cap_chan *chan)\n{\n\tchan->hs_hchan = NULL;\n\tchan->hs_hcon = NULL;\n\n\t/* Placeholder - release the logical link */\n}\n\nstatic void l2cap_logical_fail(struct l2cap_chan *chan)\n{\n\t/* Logical link setup failed */\n\tif (chan->state != BT_CONNECTED) {\n\t\t/* Create channel failure, disconnect */\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tswitch (chan->move_role) {\n\tcase L2CAP_MOVE_ROLE_RESPONDER:\n\t\tl2cap_move_done(chan);\n\t\tl2cap_send_move_chan_rsp(chan, L2CAP_MR_NOT_SUPP);\n\t\tbreak;\n\tcase L2CAP_MOVE_ROLE_INITIATOR:\n\t\tif (chan->move_state == L2CAP_MOVE_WAIT_LOGICAL_COMP ||\n\t\t    chan->move_state == L2CAP_MOVE_WAIT_LOGICAL_CFM) {\n\t\t\t/* Remote has only sent pending or\n\t\t\t * success responses, clean up\n\t\t\t */\n\t\t\tl2cap_move_done(chan);\n\t\t}\n\n\t\t/* Other amp move states imply that the move\n\t\t * has already aborted\n\t\t */\n\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_logical_finish_create(struct l2cap_chan *chan,\n\t\t\t\t\tstruct hci_chan *hchan)\n{\n\tstruct l2cap_conf_rsp rsp;\n\n\tchan->hs_hchan = hchan;\n\tchan->hs_hcon->l2cap_data = chan->conn;\n\n\tl2cap_send_efs_conf_rsp(chan, &rsp, chan->ident, 0);\n\n\tif (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {\n\t\tint err;\n\n\t\tset_default_fcs(chan);\n\n\t\terr = l2cap_ertm_init(chan);\n\t\tif (err < 0)\n\t\t\tl2cap_send_disconn_req(chan, -err);\n\t\telse\n\t\t\tl2cap_chan_ready(chan);\n\t}\n}\n\nstatic void l2cap_logical_finish_move(struct l2cap_chan *chan,\n\t\t\t\t      struct hci_chan *hchan)\n{\n\tchan->hs_hcon = hchan->conn;\n\tchan->hs_hcon->l2cap_data = chan->conn;\n\n\tBT_DBG(\"move_state %d\", chan->move_state);\n\n\tswitch (chan->move_state) {\n\tcase L2CAP_MOVE_WAIT_LOGICAL_COMP:\n\t\t/* Move confirm will be sent after a success\n\t\t * response is received\n\t\t */\n\t\tchan->move_state = L2CAP_MOVE_WAIT_RSP_SUCCESS;\n\t\tbreak;\n\tcase L2CAP_MOVE_WAIT_LOGICAL_CFM:\n\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOCAL_BUSY;\n\t\t} else if (chan->move_role == L2CAP_MOVE_ROLE_INITIATOR) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM_RSP;\n\t\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_CONFIRMED);\n\t\t} else if (chan->move_role == L2CAP_MOVE_ROLE_RESPONDER) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM;\n\t\t\tl2cap_send_move_chan_rsp(chan, L2CAP_MR_SUCCESS);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* Move was not in expected state, free the channel */\n\t\t__release_logical_link(chan);\n\n\t\tchan->move_state = L2CAP_MOVE_STABLE;\n\t}\n}\n\n/* Call with chan locked */\nvoid l2cap_logical_cfm(struct l2cap_chan *chan, struct hci_chan *hchan,\n\t\t       u8 status)\n{\n\tBT_DBG(\"chan %p, hchan %p, status %d\", chan, hchan, status);\n\n\tif (status) {\n\t\tl2cap_logical_fail(chan);\n\t\t__release_logical_link(chan);\n\t\treturn;\n\t}\n\n\tif (chan->state != BT_CONNECTED) {\n\t\t/* Ignore logical link if channel is on BR/EDR */\n\t\tif (chan->local_amp_id != AMP_ID_BREDR)\n\t\t\tl2cap_logical_finish_create(chan, hchan);\n\t} else {\n\t\tl2cap_logical_finish_move(chan, hchan);\n\t}\n}\n\nvoid l2cap_move_start(struct l2cap_chan *chan)\n{\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->local_amp_id == AMP_ID_BREDR) {\n\t\tif (chan->chan_policy != BT_CHANNEL_POLICY_AMP_PREFERRED)\n\t\t\treturn;\n\t\tchan->move_role = L2CAP_MOVE_ROLE_INITIATOR;\n\t\tchan->move_state = L2CAP_MOVE_WAIT_PREPARE;\n\t\t/* Placeholder - start physical link setup */\n\t} else {\n\t\tchan->move_role = L2CAP_MOVE_ROLE_INITIATOR;\n\t\tchan->move_state = L2CAP_MOVE_WAIT_RSP_SUCCESS;\n\t\tchan->move_id = 0;\n\t\tl2cap_move_setup(chan);\n\t\tl2cap_send_move_chan_req(chan, 0);\n\t}\n}\n\nstatic void l2cap_do_create(struct l2cap_chan *chan, int result,\n\t\t\t    u8 local_amp_id, u8 remote_amp_id)\n{\n\tBT_DBG(\"chan %p state %s %u -> %u\", chan, state_to_string(chan->state),\n\t       local_amp_id, remote_amp_id);\n\n\tchan->fcs = L2CAP_FCS_NONE;\n\n\t/* Outgoing channel on AMP */\n\tif (chan->state == BT_CONNECT) {\n\t\tif (result == L2CAP_CR_SUCCESS) {\n\t\t\tchan->local_amp_id = local_amp_id;\n\t\t\tl2cap_send_create_chan_req(chan, remote_amp_id);\n\t\t} else {\n\t\t\t/* Revert to BR/EDR connect */\n\t\t\tl2cap_send_conn_req(chan);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t/* Incoming channel on AMP */\n\tif (__l2cap_no_conn_pending(chan)) {\n\t\tstruct l2cap_conn_rsp rsp;\n\t\tchar buf[128];\n\t\trsp.scid = cpu_to_le16(chan->dcid);\n\t\trsp.dcid = cpu_to_le16(chan->scid);\n\n\t\tif (result == L2CAP_CR_SUCCESS) {\n\t\t\t/* Send successful response */\n\t\t\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t} else {\n\t\t\t/* Send negative response */\n\t\t\trsp.result = cpu_to_le16(L2CAP_CR_NO_MEM);\n\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t}\n\n\t\tl2cap_send_cmd(chan->conn, chan->ident, L2CAP_CREATE_CHAN_RSP,\n\t\t\t       sizeof(rsp), &rsp);\n\n\t\tif (result == L2CAP_CR_SUCCESS) {\n\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\t\tl2cap_send_cmd(chan->conn, l2cap_get_ident(chan->conn),\n\t\t\t\t       L2CAP_CONF_REQ,\n\t\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\t\t\tchan->num_conf_req++;\n\t\t}\n\t}\n}\n\nstatic void l2cap_do_move_initiate(struct l2cap_chan *chan, u8 local_amp_id,\n\t\t\t\t   u8 remote_amp_id)\n{\n\tl2cap_move_setup(chan);\n\tchan->move_id = local_amp_id;\n\tchan->move_state = L2CAP_MOVE_WAIT_RSP;\n\n\tl2cap_send_move_chan_req(chan, remote_amp_id);\n}\n\nstatic void l2cap_do_move_respond(struct l2cap_chan *chan, int result)\n{\n\tstruct hci_chan *hchan = NULL;\n\n\t/* Placeholder - get hci_chan for logical link */\n\n\tif (hchan) {\n\t\tif (hchan->state == BT_CONNECTED) {\n\t\t\t/* Logical link is ready to go */\n\t\t\tchan->hs_hcon = hchan->conn;\n\t\t\tchan->hs_hcon->l2cap_data = chan->conn;\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM;\n\t\t\tl2cap_send_move_chan_rsp(chan, L2CAP_MR_SUCCESS);\n\n\t\t\tl2cap_logical_cfm(chan, hchan, L2CAP_MR_SUCCESS);\n\t\t} else {\n\t\t\t/* Wait for logical link to be ready */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_CFM;\n\t\t}\n\t} else {\n\t\t/* Logical link not available */\n\t\tl2cap_send_move_chan_rsp(chan, L2CAP_MR_NOT_ALLOWED);\n\t}\n}\n\nstatic void l2cap_do_move_cancel(struct l2cap_chan *chan, int result)\n{\n\tif (chan->move_role == L2CAP_MOVE_ROLE_RESPONDER) {\n\t\tu8 rsp_result;\n\t\tif (result == -EINVAL)\n\t\t\trsp_result = L2CAP_MR_BAD_ID;\n\t\telse\n\t\t\trsp_result = L2CAP_MR_NOT_ALLOWED;\n\n\t\tl2cap_send_move_chan_rsp(chan, rsp_result);\n\t}\n\n\tchan->move_role = L2CAP_MOVE_ROLE_NONE;\n\tchan->move_state = L2CAP_MOVE_STABLE;\n\n\t/* Restart data transmission */\n\tl2cap_ertm_send(chan);\n}\n\n/* Invoke with locked chan */\nvoid __l2cap_physical_cfm(struct l2cap_chan *chan, int result)\n{\n\tu8 local_amp_id = chan->local_amp_id;\n\tu8 remote_amp_id = chan->remote_amp_id;\n\n\tBT_DBG(\"chan %p, result %d, local_amp_id %d, remote_amp_id %d\",\n\t       chan, result, local_amp_id, remote_amp_id);\n\n\tif (chan->state == BT_DISCONN || chan->state == BT_CLOSED)\n\t\treturn;\n\n\tif (chan->state != BT_CONNECTED) {\n\t\tl2cap_do_create(chan, result, local_amp_id, remote_amp_id);\n\t} else if (result != L2CAP_MR_SUCCESS) {\n\t\tl2cap_do_move_cancel(chan, result);\n\t} else {\n\t\tswitch (chan->move_role) {\n\t\tcase L2CAP_MOVE_ROLE_INITIATOR:\n\t\t\tl2cap_do_move_initiate(chan, local_amp_id,\n\t\t\t\t\t       remote_amp_id);\n\t\t\tbreak;\n\t\tcase L2CAP_MOVE_ROLE_RESPONDER:\n\t\t\tl2cap_do_move_respond(chan, result);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tl2cap_do_move_cancel(chan, result);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic inline int l2cap_move_channel_req(struct l2cap_conn *conn,\n\t\t\t\t\t struct l2cap_cmd_hdr *cmd,\n\t\t\t\t\t u16 cmd_len, void *data)\n{\n\tstruct l2cap_move_chan_req *req = data;\n\tstruct l2cap_move_chan_rsp rsp;\n\tstruct l2cap_chan *chan;\n\tu16 icid = 0;\n\tu16 result = L2CAP_MR_NOT_ALLOWED;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\ticid = le16_to_cpu(req->icid);\n\n\tBT_DBG(\"icid 0x%4.4x, dest_amp_id %d\", icid, req->dest_amp_id);\n\n\tif (!(conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\treturn -EINVAL;\n\n\tchan = l2cap_get_chan_by_dcid(conn, icid);\n\tif (!chan) {\n\t\trsp.icid = cpu_to_le16(icid);\n\t\trsp.result = cpu_to_le16(L2CAP_MR_NOT_ALLOWED);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_MOVE_CHAN_RSP,\n\t\t\t       sizeof(rsp), &rsp);\n\t\treturn 0;\n\t}\n\n\tchan->ident = cmd->ident;\n\n\tif (chan->scid < L2CAP_CID_DYN_START ||\n\t    chan->chan_policy == BT_CHANNEL_POLICY_BREDR_ONLY ||\n\t    (chan->mode != L2CAP_MODE_ERTM &&\n\t     chan->mode != L2CAP_MODE_STREAMING)) {\n\t\tresult = L2CAP_MR_NOT_ALLOWED;\n\t\tgoto send_move_response;\n\t}\n\n\tif (chan->local_amp_id == req->dest_amp_id) {\n\t\tresult = L2CAP_MR_SAME_ID;\n\t\tgoto send_move_response;\n\t}\n\n\tif (req->dest_amp_id != AMP_ID_BREDR) {\n\t\tstruct hci_dev *hdev;\n\t\thdev = hci_dev_get(req->dest_amp_id);\n\t\tif (!hdev || hdev->dev_type != HCI_AMP ||\n\t\t    !test_bit(HCI_UP, &hdev->flags)) {\n\t\t\tif (hdev)\n\t\t\t\thci_dev_put(hdev);\n\n\t\t\tresult = L2CAP_MR_BAD_ID;\n\t\t\tgoto send_move_response;\n\t\t}\n\t\thci_dev_put(hdev);\n\t}\n\n\t/* Detect a move collision.  Only send a collision response\n\t * if this side has \"lost\", otherwise proceed with the move.\n\t * The winner has the larger bd_addr.\n\t */\n\tif ((__chan_is_moving(chan) ||\n\t     chan->move_role != L2CAP_MOVE_ROLE_NONE) &&\n\t    bacmp(&conn->hcon->src, &conn->hcon->dst) > 0) {\n\t\tresult = L2CAP_MR_COLLISION;\n\t\tgoto send_move_response;\n\t}\n\n\tchan->move_role = L2CAP_MOVE_ROLE_RESPONDER;\n\tl2cap_move_setup(chan);\n\tchan->move_id = req->dest_amp_id;\n\n\tif (req->dest_amp_id == AMP_ID_BREDR) {\n\t\t/* Moving to BR/EDR */\n\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOCAL_BUSY;\n\t\t\tresult = L2CAP_MR_PEND;\n\t\t} else {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM;\n\t\t\tresult = L2CAP_MR_SUCCESS;\n\t\t}\n\t} else {\n\t\tchan->move_state = L2CAP_MOVE_WAIT_PREPARE;\n\t\t/* Placeholder - uncomment when amp functions are available */\n\t\t/*amp_accept_physical(chan, req->dest_amp_id);*/\n\t\tresult = L2CAP_MR_PEND;\n\t}\n\nsend_move_response:\n\tl2cap_send_move_chan_rsp(chan, result);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\treturn 0;\n}\n\nstatic void l2cap_move_continue(struct l2cap_conn *conn, u16 icid, u16 result)\n{\n\tstruct l2cap_chan *chan;\n\tstruct hci_chan *hchan = NULL;\n\n\tchan = l2cap_get_chan_by_scid(conn, icid);\n\tif (!chan) {\n\t\tl2cap_send_move_chan_cfm_icid(conn, icid);\n\t\treturn;\n\t}\n\n\t__clear_chan_timer(chan);\n\tif (result == L2CAP_MR_PEND)\n\t\t__set_chan_timer(chan, L2CAP_MOVE_ERTX_TIMEOUT);\n\n\tswitch (chan->move_state) {\n\tcase L2CAP_MOVE_WAIT_LOGICAL_COMP:\n\t\t/* Move confirm will be sent when logical link\n\t\t * is complete.\n\t\t */\n\t\tchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_CFM;\n\t\tbreak;\n\tcase L2CAP_MOVE_WAIT_RSP_SUCCESS:\n\t\tif (result == L2CAP_MR_PEND) {\n\t\t\tbreak;\n\t\t} else if (test_bit(CONN_LOCAL_BUSY,\n\t\t\t\t    &chan->conn_state)) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOCAL_BUSY;\n\t\t} else {\n\t\t\t/* Logical link is up or moving to BR/EDR,\n\t\t\t * proceed with move\n\t\t\t */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM_RSP;\n\t\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_CONFIRMED);\n\t\t}\n\t\tbreak;\n\tcase L2CAP_MOVE_WAIT_RSP:\n\t\t/* Moving to AMP */\n\t\tif (result == L2CAP_MR_SUCCESS) {\n\t\t\t/* Remote is ready, send confirm immediately\n\t\t\t * after logical link is ready\n\t\t\t */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_CFM;\n\t\t} else {\n\t\t\t/* Both logical link and move success\n\t\t\t * are required to confirm\n\t\t\t */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_COMP;\n\t\t}\n\n\t\t/* Placeholder - get hci_chan for logical link */\n\t\tif (!hchan) {\n\t\t\t/* Logical link not available */\n\t\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If the logical link is not yet connected, do not\n\t\t * send confirmation.\n\t\t */\n\t\tif (hchan->state != BT_CONNECTED)\n\t\t\tbreak;\n\n\t\t/* Logical link is already ready to go */\n\n\t\tchan->hs_hcon = hchan->conn;\n\t\tchan->hs_hcon->l2cap_data = chan->conn;\n\n\t\tif (result == L2CAP_MR_SUCCESS) {\n\t\t\t/* Can confirm now */\n\t\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_CONFIRMED);\n\t\t} else {\n\t\t\t/* Now only need move success\n\t\t\t * to confirm\n\t\t\t */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_RSP_SUCCESS;\n\t\t}\n\n\t\tl2cap_logical_cfm(chan, hchan, L2CAP_MR_SUCCESS);\n\t\tbreak;\n\tdefault:\n\t\t/* Any other amp move state means the move failed. */\n\t\tchan->move_id = chan->local_amp_id;\n\t\tl2cap_move_done(chan);\n\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\n\t}\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nstatic void l2cap_move_fail(struct l2cap_conn *conn, u8 ident, u16 icid,\n\t\t\t    u16 result)\n{\n\tstruct l2cap_chan *chan;\n\n\tchan = l2cap_get_chan_by_ident(conn, ident);\n\tif (!chan) {\n\t\t/* Could not locate channel, icid is best guess */\n\t\tl2cap_send_move_chan_cfm_icid(conn, icid);\n\t\treturn;\n\t}\n\n\t__clear_chan_timer(chan);\n\n\tif (chan->move_role == L2CAP_MOVE_ROLE_INITIATOR) {\n\t\tif (result == L2CAP_MR_COLLISION) {\n\t\t\tchan->move_role = L2CAP_MOVE_ROLE_RESPONDER;\n\t\t} else {\n\t\t\t/* Cleanup - cancel move */\n\t\t\tchan->move_id = chan->local_amp_id;\n\t\t\tl2cap_move_done(chan);\n\t\t}\n\t}\n\n\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nstatic int l2cap_move_channel_rsp(struct l2cap_conn *conn,\n\t\t\t\t  struct l2cap_cmd_hdr *cmd,\n\t\t\t\t  u16 cmd_len, void *data)\n{\n\tstruct l2cap_move_chan_rsp *rsp = data;\n\tu16 icid, result;\n\n\tif (cmd_len != sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\ticid = le16_to_cpu(rsp->icid);\n\tresult = le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"icid 0x%4.4x, result 0x%4.4x\", icid, result);\n\n\tif (result == L2CAP_MR_SUCCESS || result == L2CAP_MR_PEND)\n\t\tl2cap_move_continue(conn, icid, result);\n\telse\n\t\tl2cap_move_fail(conn, cmd->ident, icid, result);\n\n\treturn 0;\n}\n\nstatic int l2cap_move_channel_confirm(struct l2cap_conn *conn,\n\t\t\t\t      struct l2cap_cmd_hdr *cmd,\n\t\t\t\t      u16 cmd_len, void *data)\n{\n\tstruct l2cap_move_chan_cfm *cfm = data;\n\tstruct l2cap_chan *chan;\n\tu16 icid, result;\n\n\tif (cmd_len != sizeof(*cfm))\n\t\treturn -EPROTO;\n\n\ticid = le16_to_cpu(cfm->icid);\n\tresult = le16_to_cpu(cfm->result);\n\n\tBT_DBG(\"icid 0x%4.4x, result 0x%4.4x\", icid, result);\n\n\tchan = l2cap_get_chan_by_dcid(conn, icid);\n\tif (!chan) {\n\t\t/* Spec requires a response even if the icid was not found */\n\t\tl2cap_send_move_chan_cfm_rsp(conn, cmd->ident, icid);\n\t\treturn 0;\n\t}\n\n\tif (chan->move_state == L2CAP_MOVE_WAIT_CONFIRM) {\n\t\tif (result == L2CAP_MC_CONFIRMED) {\n\t\t\tchan->local_amp_id = chan->move_id;\n\t\t\tif (chan->local_amp_id == AMP_ID_BREDR)\n\t\t\t\t__release_logical_link(chan);\n\t\t} else {\n\t\t\tchan->move_id = chan->local_amp_id;\n\t\t}\n\n\t\tl2cap_move_done(chan);\n\t}\n\n\tl2cap_send_move_chan_cfm_rsp(conn, cmd->ident, icid);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_move_channel_confirm_rsp(struct l2cap_conn *conn,\n\t\t\t\t\t\t struct l2cap_cmd_hdr *cmd,\n\t\t\t\t\t\t u16 cmd_len, void *data)\n{\n\tstruct l2cap_move_chan_cfm_rsp *rsp = data;\n\tstruct l2cap_chan *chan;\n\tu16 icid;\n\n\tif (cmd_len != sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\ticid = le16_to_cpu(rsp->icid);\n\n\tBT_DBG(\"icid 0x%4.4x\", icid);\n\n\tchan = l2cap_get_chan_by_scid(conn, icid);\n\tif (!chan)\n\t\treturn 0;\n\n\t__clear_chan_timer(chan);\n\n\tif (chan->move_state == L2CAP_MOVE_WAIT_CONFIRM_RSP) {\n\t\tchan->local_amp_id = chan->move_id;\n\n\t\tif (chan->local_amp_id == AMP_ID_BREDR && chan->hs_hchan)\n\t\t\t__release_logical_link(chan);\n\n\t\tl2cap_move_done(chan);\n\t}\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_conn_param_update_req(struct l2cap_conn *conn,\n\t\t\t\t\t      struct l2cap_cmd_hdr *cmd,\n\t\t\t\t\t      u16 cmd_len, u8 *data)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_conn_param_update_req *req;\n\tstruct l2cap_conn_param_update_rsp rsp;\n\tu16 min, max, latency, to_multiplier;\n\tint err;\n\n\tif (hcon->role != HCI_ROLE_MASTER)\n\t\treturn -EINVAL;\n\n\tif (cmd_len != sizeof(struct l2cap_conn_param_update_req))\n\t\treturn -EPROTO;\n\n\treq = (struct l2cap_conn_param_update_req *) data;\n\tmin\t\t= __le16_to_cpu(req->min);\n\tmax\t\t= __le16_to_cpu(req->max);\n\tlatency\t\t= __le16_to_cpu(req->latency);\n\tto_multiplier\t= __le16_to_cpu(req->to_multiplier);\n\n\tBT_DBG(\"min 0x%4.4x max 0x%4.4x latency: 0x%4.4x Timeout: 0x%4.4x\",\n\t       min, max, latency, to_multiplier);\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\terr = hci_check_conn_params(min, max, latency, to_multiplier);\n\tif (err)\n\t\trsp.result = cpu_to_le16(L2CAP_CONN_PARAM_REJECTED);\n\telse\n\t\trsp.result = cpu_to_le16(L2CAP_CONN_PARAM_ACCEPTED);\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_PARAM_UPDATE_RSP,\n\t\t       sizeof(rsp), &rsp);\n\n\tif (!err) {\n\t\tu8 store_hint;\n\n\t\tstore_hint = hci_le_conn_update(hcon, min, max, latency,\n\t\t\t\t\t\tto_multiplier);\n\t\tmgmt_new_conn_param(hcon->hdev, &hcon->dst, hcon->dst_type,\n\t\t\t\t    store_hint, min, max, latency,\n\t\t\t\t    to_multiplier);\n\n\t}\n\n\treturn 0;\n}\n\nstatic int l2cap_le_connect_rsp(struct l2cap_conn *conn,\n\t\t\t\tstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\tu8 *data)\n{\n\tstruct l2cap_le_conn_rsp *rsp = (struct l2cap_le_conn_rsp *) data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tu16 dcid, mtu, mps, credits, result;\n\tstruct l2cap_chan *chan;\n\tint err, sec_level;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tdcid    = __le16_to_cpu(rsp->dcid);\n\tmtu     = __le16_to_cpu(rsp->mtu);\n\tmps     = __le16_to_cpu(rsp->mps);\n\tcredits = __le16_to_cpu(rsp->credits);\n\tresult  = __le16_to_cpu(rsp->result);\n\n\tif (result == L2CAP_CR_LE_SUCCESS && (mtu < 23 || mps < 23 ||\n\t\t\t\t\t   dcid < L2CAP_CID_DYN_START ||\n\t\t\t\t\t   dcid > L2CAP_CID_LE_DYN_END))\n\t\treturn -EPROTO;\n\n\tBT_DBG(\"dcid 0x%4.4x mtu %u mps %u credits %u result 0x%2.2x\",\n\t       dcid, mtu, mps, credits, result);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tchan = __l2cap_get_chan_by_ident(conn, cmd->ident);\n\tif (!chan) {\n\t\terr = -EBADSLT;\n\t\tgoto unlock;\n\t}\n\n\terr = 0;\n\n\tl2cap_chan_lock(chan);\n\n\tswitch (result) {\n\tcase L2CAP_CR_LE_SUCCESS:\n\t\tif (__l2cap_get_chan_by_dcid(conn, dcid)) {\n\t\t\terr = -EBADSLT;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->ident = 0;\n\t\tchan->dcid = dcid;\n\t\tchan->omtu = mtu;\n\t\tchan->remote_mps = mps;\n\t\tchan->tx_credits = credits;\n\t\tl2cap_chan_ready(chan);\n\t\tbreak;\n\n\tcase L2CAP_CR_LE_AUTHENTICATION:\n\tcase L2CAP_CR_LE_ENCRYPTION:\n\t\t/* If we already have MITM protection we can't do\n\t\t * anything.\n\t\t */\n\t\tif (hcon->sec_level > BT_SECURITY_MEDIUM) {\n\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\tbreak;\n\t\t}\n\n\t\tsec_level = hcon->sec_level + 1;\n\t\tif (chan->sec_level < sec_level)\n\t\t\tchan->sec_level = sec_level;\n\n\t\t/* We'll need to send a new Connect Request */\n\t\tclear_bit(FLAG_LE_CONN_REQ_SENT, &chan->flags);\n\n\t\tsmp_conn_security(hcon, chan->sec_level);\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\tbreak;\n\t}\n\n\tl2cap_chan_unlock(chan);\n\nunlock:\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn err;\n}\n\nstatic inline int l2cap_bredr_sig_cmd(struct l2cap_conn *conn,\n\t\t\t\t      struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t      u8 *data)\n{\n\tint err = 0;\n\n\tswitch (cmd->code) {\n\tcase L2CAP_COMMAND_REJ:\n\t\tl2cap_command_rej(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONN_REQ:\n\t\terr = l2cap_connect_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONN_RSP:\n\tcase L2CAP_CREATE_CHAN_RSP:\n\t\tl2cap_connect_create_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONF_REQ:\n\t\terr = l2cap_config_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONF_RSP:\n\t\tl2cap_config_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_DISCONN_REQ:\n\t\terr = l2cap_disconnect_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_DISCONN_RSP:\n\t\tl2cap_disconnect_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECHO_REQ:\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_ECHO_RSP, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECHO_RSP:\n\t\tbreak;\n\n\tcase L2CAP_INFO_REQ:\n\t\terr = l2cap_information_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_INFO_RSP:\n\t\tl2cap_information_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CREATE_CHAN_REQ:\n\t\terr = l2cap_create_channel_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_MOVE_CHAN_REQ:\n\t\terr = l2cap_move_channel_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_MOVE_CHAN_RSP:\n\t\tl2cap_move_channel_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_MOVE_CHAN_CFM:\n\t\terr = l2cap_move_channel_confirm(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_MOVE_CHAN_CFM_RSP:\n\t\tl2cap_move_channel_confirm_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Unknown BR/EDR signaling command 0x%2.2x\", cmd->code);\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_le_connect_req(struct l2cap_conn *conn,\n\t\t\t\tstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\tu8 *data)\n{\n\tstruct l2cap_le_conn_req *req = (struct l2cap_le_conn_req *) data;\n\tstruct l2cap_le_conn_rsp rsp;\n\tstruct l2cap_chan *chan, *pchan;\n\tu16 dcid, scid, credits, mtu, mps;\n\t__le16 psm;\n\tu8 result;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\tscid = __le16_to_cpu(req->scid);\n\tmtu  = __le16_to_cpu(req->mtu);\n\tmps  = __le16_to_cpu(req->mps);\n\tpsm  = req->psm;\n\tdcid = 0;\n\tcredits = 0;\n\n\tif (mtu < 23 || mps < 23)\n\t\treturn -EPROTO;\n\n\tBT_DBG(\"psm 0x%2.2x scid 0x%4.4x mtu %u mps %u\", __le16_to_cpu(psm),\n\t       scid, mtu, mps);\n\n\t/* BLUETOOTH CORE SPECIFICATION Version 5.3 | Vol 3, Part A\n\t * page 1059:\n\t *\n\t * Valid range: 0x0001-0x00ff\n\t *\n\t * Table 4.15: L2CAP_LE_CREDIT_BASED_CONNECTION_REQ SPSM ranges\n\t */\n\tif (!psm || __le16_to_cpu(psm) > L2CAP_PSM_LE_DYN_END) {\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\t\tchan = NULL;\n\t\tgoto response;\n\t}\n\n\t/* Check if we have socket listening on psm */\n\tpchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, &conn->hcon->src,\n\t\t\t\t\t &conn->hcon->dst, LE_LINK);\n\tif (!pchan) {\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\t\tchan = NULL;\n\t\tgoto response;\n\t}\n\n\tmutex_lock(&conn->chan_lock);\n\tl2cap_chan_lock(pchan);\n\n\tif (!smp_sufficient_security(conn->hcon, pchan->sec_level,\n\t\t\t\t     SMP_ALLOW_STK)) {\n\t\tresult = L2CAP_CR_LE_AUTHENTICATION;\n\t\tchan = NULL;\n\t\tgoto response_unlock;\n\t}\n\n\t/* Check for valid dynamic CID range */\n\tif (scid < L2CAP_CID_DYN_START || scid > L2CAP_CID_LE_DYN_END) {\n\t\tresult = L2CAP_CR_LE_INVALID_SCID;\n\t\tchan = NULL;\n\t\tgoto response_unlock;\n\t}\n\n\t/* Check if we already have channel with that dcid */\n\tif (__l2cap_get_chan_by_dcid(conn, scid)) {\n\t\tresult = L2CAP_CR_LE_SCID_IN_USE;\n\t\tchan = NULL;\n\t\tgoto response_unlock;\n\t}\n\n\tchan = pchan->ops->new_connection(pchan);\n\tif (!chan) {\n\t\tresult = L2CAP_CR_LE_NO_MEM;\n\t\tgoto response_unlock;\n\t}\n\n\tbacpy(&chan->src, &conn->hcon->src);\n\tbacpy(&chan->dst, &conn->hcon->dst);\n\tchan->src_type = bdaddr_src_type(conn->hcon);\n\tchan->dst_type = bdaddr_dst_type(conn->hcon);\n\tchan->psm  = psm;\n\tchan->dcid = scid;\n\tchan->omtu = mtu;\n\tchan->remote_mps = mps;\n\n\t__l2cap_chan_add(conn, chan);\n\n\tl2cap_le_flowctl_init(chan, __le16_to_cpu(req->credits));\n\n\tdcid = chan->scid;\n\tcredits = chan->rx_credits;\n\n\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\n\tchan->ident = cmd->ident;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t/* The following result value is actually not defined\n\t\t * for LE CoC but we use it to let the function know\n\t\t * that it should bail out after doing its cleanup\n\t\t * instead of sending a response.\n\t\t */\n\t\tresult = L2CAP_CR_PEND;\n\t\tchan->ops->defer(chan);\n\t} else {\n\t\tl2cap_chan_ready(chan);\n\t\tresult = L2CAP_CR_LE_SUCCESS;\n\t}\n\nresponse_unlock:\n\tl2cap_chan_unlock(pchan);\n\tmutex_unlock(&conn->chan_lock);\n\tl2cap_chan_put(pchan);\n\n\tif (result == L2CAP_CR_PEND)\n\t\treturn 0;\n\nresponse:\n\tif (chan) {\n\t\trsp.mtu = cpu_to_le16(chan->imtu);\n\t\trsp.mps = cpu_to_le16(chan->mps);\n\t} else {\n\t\trsp.mtu = 0;\n\t\trsp.mps = 0;\n\t}\n\n\trsp.dcid    = cpu_to_le16(dcid);\n\trsp.credits = cpu_to_le16(credits);\n\trsp.result  = cpu_to_le16(result);\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_LE_CONN_RSP, sizeof(rsp), &rsp);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_le_credits(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tstruct l2cap_le_credits *pkt;\n\tstruct l2cap_chan *chan;\n\tu16 cid, credits, max_credits;\n\n\tif (cmd_len != sizeof(*pkt))\n\t\treturn -EPROTO;\n\n\tpkt = (struct l2cap_le_credits *) data;\n\tcid\t= __le16_to_cpu(pkt->cid);\n\tcredits\t= __le16_to_cpu(pkt->credits);\n\n\tBT_DBG(\"cid 0x%4.4x credits 0x%4.4x\", cid, credits);\n\n\tchan = l2cap_get_chan_by_dcid(conn, cid);\n\tif (!chan)\n\t\treturn -EBADSLT;\n\n\tmax_credits = LE_FLOWCTL_MAX_CREDITS - chan->tx_credits;\n\tif (credits > max_credits) {\n\t\tBT_ERR(\"LE credits overflow\");\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\n\t\t/* Return 0 so that we don't trigger an unnecessary\n\t\t * command reject packet.\n\t\t */\n\t\tgoto unlock;\n\t}\n\n\tchan->tx_credits += credits;\n\n\t/* Resume sending */\n\tl2cap_le_flowctl_send(chan);\n\n\tif (chan->tx_credits)\n\t\tchan->ops->resume(chan);\n\nunlock:\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_ecred_conn_req(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_ecred_conn_req *req = (void *) data;\n\tstruct {\n\t\tstruct l2cap_ecred_conn_rsp rsp;\n\t\t__le16 dcid[L2CAP_ECRED_MAX_CID];\n\t} __packed pdu;\n\tstruct l2cap_chan *chan, *pchan;\n\tu16 mtu, mps;\n\t__le16 psm;\n\tu8 result, len = 0;\n\tint i, num_scid;\n\tbool defer = false;\n\n\tif (!enable_ecred)\n\t\treturn -EINVAL;\n\n\tif (cmd_len < sizeof(*req) || (cmd_len - sizeof(*req)) % sizeof(u16)) {\n\t\tresult = L2CAP_CR_LE_INVALID_PARAMS;\n\t\tgoto response;\n\t}\n\n\tcmd_len -= sizeof(*req);\n\tnum_scid = cmd_len / sizeof(u16);\n\n\tif (num_scid > ARRAY_SIZE(pdu.dcid)) {\n\t\tresult = L2CAP_CR_LE_INVALID_PARAMS;\n\t\tgoto response;\n\t}\n\n\tmtu  = __le16_to_cpu(req->mtu);\n\tmps  = __le16_to_cpu(req->mps);\n\n\tif (mtu < L2CAP_ECRED_MIN_MTU || mps < L2CAP_ECRED_MIN_MPS) {\n\t\tresult = L2CAP_CR_LE_UNACCEPT_PARAMS;\n\t\tgoto response;\n\t}\n\n\tpsm  = req->psm;\n\n\t/* BLUETOOTH CORE SPECIFICATION Version 5.3 | Vol 3, Part A\n\t * page 1059:\n\t *\n\t * Valid range: 0x0001-0x00ff\n\t *\n\t * Table 4.15: L2CAP_LE_CREDIT_BASED_CONNECTION_REQ SPSM ranges\n\t */\n\tif (!psm || __le16_to_cpu(psm) > L2CAP_PSM_LE_DYN_END) {\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\t\tgoto response;\n\t}\n\n\tBT_DBG(\"psm 0x%2.2x mtu %u mps %u\", __le16_to_cpu(psm), mtu, mps);\n\n\tmemset(&pdu, 0, sizeof(pdu));\n\n\t/* Check if we have socket listening on psm */\n\tpchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, &conn->hcon->src,\n\t\t\t\t\t &conn->hcon->dst, LE_LINK);\n\tif (!pchan) {\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\t\tgoto response;\n\t}\n\n\tmutex_lock(&conn->chan_lock);\n\tl2cap_chan_lock(pchan);\n\n\tif (!smp_sufficient_security(conn->hcon, pchan->sec_level,\n\t\t\t\t     SMP_ALLOW_STK)) {\n\t\tresult = L2CAP_CR_LE_AUTHENTICATION;\n\t\tgoto unlock;\n\t}\n\n\tresult = L2CAP_CR_LE_SUCCESS;\n\n\tfor (i = 0; i < num_scid; i++) {\n\t\tu16 scid = __le16_to_cpu(req->scid[i]);\n\n\t\tBT_DBG(\"scid[%d] 0x%4.4x\", i, scid);\n\n\t\tpdu.dcid[i] = 0x0000;\n\t\tlen += sizeof(*pdu.dcid);\n\n\t\t/* Check for valid dynamic CID range */\n\t\tif (scid < L2CAP_CID_DYN_START || scid > L2CAP_CID_LE_DYN_END) {\n\t\t\tresult = L2CAP_CR_LE_INVALID_SCID;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check if we already have channel with that dcid */\n\t\tif (__l2cap_get_chan_by_dcid(conn, scid)) {\n\t\t\tresult = L2CAP_CR_LE_SCID_IN_USE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tchan = pchan->ops->new_connection(pchan);\n\t\tif (!chan) {\n\t\t\tresult = L2CAP_CR_LE_NO_MEM;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbacpy(&chan->src, &conn->hcon->src);\n\t\tbacpy(&chan->dst, &conn->hcon->dst);\n\t\tchan->src_type = bdaddr_src_type(conn->hcon);\n\t\tchan->dst_type = bdaddr_dst_type(conn->hcon);\n\t\tchan->psm  = psm;\n\t\tchan->dcid = scid;\n\t\tchan->omtu = mtu;\n\t\tchan->remote_mps = mps;\n\n\t\t__l2cap_chan_add(conn, chan);\n\n\t\tl2cap_ecred_init(chan, __le16_to_cpu(req->credits));\n\n\t\t/* Init response */\n\t\tif (!pdu.rsp.credits) {\n\t\t\tpdu.rsp.mtu = cpu_to_le16(chan->imtu);\n\t\t\tpdu.rsp.mps = cpu_to_le16(chan->mps);\n\t\t\tpdu.rsp.credits = cpu_to_le16(chan->rx_credits);\n\t\t}\n\n\t\tpdu.dcid[i] = cpu_to_le16(chan->scid);\n\n\t\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\n\t\tchan->ident = cmd->ident;\n\n\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t\tdefer = true;\n\t\t\tchan->ops->defer(chan);\n\t\t} else {\n\t\t\tl2cap_chan_ready(chan);\n\t\t}\n\t}\n\nunlock:\n\tl2cap_chan_unlock(pchan);\n\tmutex_unlock(&conn->chan_lock);\n\tl2cap_chan_put(pchan);\n\nresponse:\n\tpdu.rsp.result = cpu_to_le16(result);\n\n\tif (defer)\n\t\treturn 0;\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_ECRED_CONN_RSP,\n\t\t       sizeof(pdu.rsp) + len, &pdu);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_ecred_conn_rsp(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_ecred_conn_rsp *rsp = (void *) data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tu16 mtu, mps, credits, result;\n\tstruct l2cap_chan *chan, *tmp;\n\tint err = 0, sec_level;\n\tint i = 0;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tmtu     = __le16_to_cpu(rsp->mtu);\n\tmps     = __le16_to_cpu(rsp->mps);\n\tcredits = __le16_to_cpu(rsp->credits);\n\tresult  = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"mtu %u mps %u credits %u result 0x%4.4x\", mtu, mps, credits,\n\t       result);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tcmd_len -= sizeof(*rsp);\n\n\tlist_for_each_entry_safe(chan, tmp, &conn->chan_l, list) {\n\t\tu16 dcid;\n\n\t\tif (chan->ident != cmd->ident ||\n\t\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL ||\n\t\t    chan->state == BT_CONNECTED)\n\t\t\tcontinue;\n\n\t\tl2cap_chan_lock(chan);\n\n\t\t/* Check that there is a dcid for each pending channel */\n\t\tif (cmd_len < sizeof(dcid)) {\n\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdcid = __le16_to_cpu(rsp->dcid[i++]);\n\t\tcmd_len -= sizeof(u16);\n\n\t\tBT_DBG(\"dcid[%d] 0x%4.4x\", i, dcid);\n\n\t\t/* Check if dcid is already in use */\n\t\tif (dcid && __l2cap_get_chan_by_dcid(conn, dcid)) {\n\t\t\t/* If a device receives a\n\t\t\t * L2CAP_CREDIT_BASED_CONNECTION_RSP packet with an\n\t\t\t * already-assigned Destination CID, then both the\n\t\t\t * original channel and the new channel shall be\n\t\t\t * immediately discarded and not used.\n\t\t\t */\n\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tchan = __l2cap_get_chan_by_dcid(conn, dcid);\n\t\t\tl2cap_chan_lock(chan);\n\t\t\tl2cap_chan_del(chan, ECONNRESET);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (result) {\n\t\tcase L2CAP_CR_LE_AUTHENTICATION:\n\t\tcase L2CAP_CR_LE_ENCRYPTION:\n\t\t\t/* If we already have MITM protection we can't do\n\t\t\t * anything.\n\t\t\t */\n\t\t\tif (hcon->sec_level > BT_SECURITY_MEDIUM) {\n\t\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsec_level = hcon->sec_level + 1;\n\t\t\tif (chan->sec_level < sec_level)\n\t\t\t\tchan->sec_level = sec_level;\n\n\t\t\t/* We'll need to send a new Connect Request */\n\t\t\tclear_bit(FLAG_ECRED_CONN_REQ_SENT, &chan->flags);\n\n\t\t\tsmp_conn_security(hcon, chan->sec_level);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CR_LE_BAD_PSM:\n\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* If dcid was not set it means channels was refused */\n\t\t\tif (!dcid) {\n\t\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchan->ident = 0;\n\t\t\tchan->dcid = dcid;\n\t\t\tchan->omtu = mtu;\n\t\t\tchan->remote_mps = mps;\n\t\t\tchan->tx_credits = credits;\n\t\t\tl2cap_chan_ready(chan);\n\t\t\tbreak;\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn err;\n}\n\nstatic inline int l2cap_ecred_reconf_req(struct l2cap_conn *conn,\n\t\t\t\t\t struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t\t u8 *data)\n{\n\tstruct l2cap_ecred_reconf_req *req = (void *) data;\n\tstruct l2cap_ecred_reconf_rsp rsp;\n\tu16 mtu, mps, result;\n\tstruct l2cap_chan *chan;\n\tint i, num_scid;\n\n\tif (!enable_ecred)\n\t\treturn -EINVAL;\n\n\tif (cmd_len < sizeof(*req) || cmd_len - sizeof(*req) % sizeof(u16)) {\n\t\tresult = L2CAP_CR_LE_INVALID_PARAMS;\n\t\tgoto respond;\n\t}\n\n\tmtu = __le16_to_cpu(req->mtu);\n\tmps = __le16_to_cpu(req->mps);\n\n\tBT_DBG(\"mtu %u mps %u\", mtu, mps);\n\n\tif (mtu < L2CAP_ECRED_MIN_MTU) {\n\t\tresult = L2CAP_RECONF_INVALID_MTU;\n\t\tgoto respond;\n\t}\n\n\tif (mps < L2CAP_ECRED_MIN_MPS) {\n\t\tresult = L2CAP_RECONF_INVALID_MPS;\n\t\tgoto respond;\n\t}\n\n\tcmd_len -= sizeof(*req);\n\tnum_scid = cmd_len / sizeof(u16);\n\tresult = L2CAP_RECONF_SUCCESS;\n\n\tfor (i = 0; i < num_scid; i++) {\n\t\tu16 scid;\n\n\t\tscid = __le16_to_cpu(req->scid[i]);\n\t\tif (!scid)\n\t\t\treturn -EPROTO;\n\n\t\tchan = __l2cap_get_chan_by_dcid(conn, scid);\n\t\tif (!chan)\n\t\t\tcontinue;\n\n\t\t/* If the MTU value is decreased for any of the included\n\t\t * channels, then the receiver shall disconnect all\n\t\t * included channels.\n\t\t */\n\t\tif (chan->omtu > mtu) {\n\t\t\tBT_ERR(\"chan %p decreased MTU %u -> %u\", chan,\n\t\t\t       chan->omtu, mtu);\n\t\t\tresult = L2CAP_RECONF_INVALID_MTU;\n\t\t}\n\n\t\tchan->omtu = mtu;\n\t\tchan->remote_mps = mps;\n\t}\n\nrespond:\n\trsp.result = cpu_to_le16(result);\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_ECRED_RECONF_RSP, sizeof(rsp),\n\t\t       &rsp);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_ecred_reconf_rsp(struct l2cap_conn *conn,\n\t\t\t\t\t struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t\t u8 *data)\n{\n\tstruct l2cap_chan *chan, *tmp;\n\tstruct l2cap_ecred_conn_rsp *rsp = (void *) data;\n\tu16 result;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tresult = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"result 0x%4.4x\", rsp->result);\n\n\tif (!result)\n\t\treturn 0;\n\n\tlist_for_each_entry_safe(chan, tmp, &conn->chan_l, list) {\n\t\tif (chan->ident != cmd->ident)\n\t\t\tcontinue;\n\n\t\tl2cap_chan_del(chan, ECONNRESET);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int l2cap_le_command_rej(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_cmd_rej_unk *rej = (struct l2cap_cmd_rej_unk *) data;\n\tstruct l2cap_chan *chan;\n\n\tif (cmd_len < sizeof(*rej))\n\t\treturn -EPROTO;\n\n\tmutex_lock(&conn->chan_lock);\n\n\tchan = __l2cap_get_chan_by_ident(conn, cmd->ident);\n\tif (!chan)\n\t\tgoto done;\n\n\tl2cap_chan_lock(chan);\n\tl2cap_chan_del(chan, ECONNREFUSED);\n\tl2cap_chan_unlock(chan);\n\ndone:\n\tmutex_unlock(&conn->chan_lock);\n\treturn 0;\n}\n\nstatic inline int l2cap_le_sig_cmd(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tint err = 0;\n\n\tswitch (cmd->code) {\n\tcase L2CAP_COMMAND_REJ:\n\t\tl2cap_le_command_rej(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONN_PARAM_UPDATE_REQ:\n\t\terr = l2cap_conn_param_update_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONN_PARAM_UPDATE_RSP:\n\t\tbreak;\n\n\tcase L2CAP_LE_CONN_RSP:\n\t\tl2cap_le_connect_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_LE_CONN_REQ:\n\t\terr = l2cap_le_connect_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_LE_CREDITS:\n\t\terr = l2cap_le_credits(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECRED_CONN_REQ:\n\t\terr = l2cap_ecred_conn_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECRED_CONN_RSP:\n\t\terr = l2cap_ecred_conn_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECRED_RECONF_REQ:\n\t\terr = l2cap_ecred_reconf_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECRED_RECONF_RSP:\n\t\terr = l2cap_ecred_reconf_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_DISCONN_REQ:\n\t\terr = l2cap_disconnect_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_DISCONN_RSP:\n\t\tl2cap_disconnect_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Unknown LE signaling command 0x%2.2x\", cmd->code);\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic inline void l2cap_le_sig_channel(struct l2cap_conn *conn,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_cmd_hdr *cmd;\n\tu16 len;\n\tint err;\n\n\tif (hcon->type != LE_LINK)\n\t\tgoto drop;\n\n\tif (skb->len < L2CAP_CMD_HDR_SIZE)\n\t\tgoto drop;\n\n\tcmd = (void *) skb->data;\n\tskb_pull(skb, L2CAP_CMD_HDR_SIZE);\n\n\tlen = le16_to_cpu(cmd->len);\n\n\tBT_DBG(\"code 0x%2.2x len %d id 0x%2.2x\", cmd->code, len, cmd->ident);\n\n\tif (len != skb->len || !cmd->ident) {\n\t\tBT_DBG(\"corrupted command\");\n\t\tgoto drop;\n\t}\n\n\terr = l2cap_le_sig_cmd(conn, cmd, len, skb->data);\n\tif (err) {\n\t\tstruct l2cap_cmd_rej_unk rej;\n\n\t\tBT_ERR(\"Wrong link type (%d)\", err);\n\n\t\trej.reason = cpu_to_le16(L2CAP_REJ_NOT_UNDERSTOOD);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,\n\t\t\t       sizeof(rej), &rej);\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}\n\nstatic inline void l2cap_sig_channel(struct l2cap_conn *conn,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_cmd_hdr *cmd;\n\tint err;\n\n\tl2cap_raw_recv(conn, skb);\n\n\tif (hcon->type != ACL_LINK)\n\t\tgoto drop;\n\n\twhile (skb->len >= L2CAP_CMD_HDR_SIZE) {\n\t\tu16 len;\n\n\t\tcmd = (void *) skb->data;\n\t\tskb_pull(skb, L2CAP_CMD_HDR_SIZE);\n\n\t\tlen = le16_to_cpu(cmd->len);\n\n\t\tBT_DBG(\"code 0x%2.2x len %d id 0x%2.2x\", cmd->code, len,\n\t\t       cmd->ident);\n\n\t\tif (len > skb->len || !cmd->ident) {\n\t\t\tBT_DBG(\"corrupted command\");\n\t\t\tbreak;\n\t\t}\n\n\t\terr = l2cap_bredr_sig_cmd(conn, cmd, len, skb->data);\n\t\tif (err) {\n\t\t\tstruct l2cap_cmd_rej_unk rej;\n\n\t\t\tBT_ERR(\"Wrong link type (%d)\", err);\n\n\t\t\trej.reason = cpu_to_le16(L2CAP_REJ_NOT_UNDERSTOOD);\n\t\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,\n\t\t\t\t       sizeof(rej), &rej);\n\t\t}\n\n\t\tskb_pull(skb, len);\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}\n\nstatic int l2cap_check_fcs(struct l2cap_chan *chan,  struct sk_buff *skb)\n{\n\tu16 our_fcs, rcv_fcs;\n\tint hdr_size;\n\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\thdr_size = L2CAP_EXT_HDR_SIZE;\n\telse\n\t\thdr_size = L2CAP_ENH_HDR_SIZE;\n\n\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\tskb_trim(skb, skb->len - L2CAP_FCS_SIZE);\n\t\trcv_fcs = get_unaligned_le16(skb->data + skb->len);\n\t\tour_fcs = crc16(0, skb->data - hdr_size, skb->len + hdr_size);\n\n\t\tif (our_fcs != rcv_fcs)\n\t\t\treturn -EBADMSG;\n\t}\n\treturn 0;\n}\n\nstatic void l2cap_send_i_or_rr_or_rnr(struct l2cap_chan *chan)\n{\n\tstruct l2cap_ctrl control;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.final = 1;\n\tcontrol.reqseq = chan->buffer_seq;\n\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\n\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\tcontrol.super = L2CAP_SUPER_RNR;\n\t\tl2cap_send_sframe(chan, &control);\n\t}\n\n\tif (test_and_clear_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&\n\t    chan->unacked_frames > 0)\n\t\t__set_retrans_timer(chan);\n\n\t/* Send pending iframes */\n\tl2cap_ertm_send(chan);\n\n\tif (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state) &&\n\t    test_bit(CONN_SEND_FBIT, &chan->conn_state)) {\n\t\t/* F-bit wasn't sent in an s-frame or i-frame yet, so\n\t\t * send it now.\n\t\t */\n\t\tcontrol.super = L2CAP_SUPER_RR;\n\t\tl2cap_send_sframe(chan, &control);\n\t}\n}\n\nstatic void append_skb_frag(struct sk_buff *skb, struct sk_buff *new_frag,\n\t\t\t    struct sk_buff **last_frag)\n{\n\t/* skb->len reflects data in skb as well as all fragments\n\t * skb->data_len reflects only data in fragments\n\t */\n\tif (!skb_has_frag_list(skb))\n\t\tskb_shinfo(skb)->frag_list = new_frag;\n\n\tnew_frag->next = NULL;\n\n\t(*last_frag)->next = new_frag;\n\t*last_frag = new_frag;\n\n\tskb->len += new_frag->len;\n\tskb->data_len += new_frag->len;\n\tskb->truesize += new_frag->truesize;\n}\n\nstatic int l2cap_reassemble_sdu(struct l2cap_chan *chan, struct sk_buff *skb,\n\t\t\t\tstruct l2cap_ctrl *control)\n{\n\tint err = -EINVAL;\n\n\tswitch (control->sar) {\n\tcase L2CAP_SAR_UNSEGMENTED:\n\t\tif (chan->sdu)\n\t\t\tbreak;\n\n\t\terr = chan->ops->recv(chan, skb);\n\t\tbreak;\n\n\tcase L2CAP_SAR_START:\n\t\tif (chan->sdu)\n\t\t\tbreak;\n\n\t\tif (!pskb_may_pull(skb, L2CAP_SDULEN_SIZE))\n\t\t\tbreak;\n\n\t\tchan->sdu_len = get_unaligned_le16(skb->data);\n\t\tskb_pull(skb, L2CAP_SDULEN_SIZE);\n\n\t\tif (chan->sdu_len > chan->imtu) {\n\t\t\terr = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (skb->len >= chan->sdu_len)\n\t\t\tbreak;\n\n\t\tchan->sdu = skb;\n\t\tchan->sdu_last_frag = skb;\n\n\t\tskb = NULL;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase L2CAP_SAR_CONTINUE:\n\t\tif (!chan->sdu)\n\t\t\tbreak;\n\n\t\tappend_skb_frag(chan->sdu, skb,\n\t\t\t\t&chan->sdu_last_frag);\n\t\tskb = NULL;\n\n\t\tif (chan->sdu->len >= chan->sdu_len)\n\t\t\tbreak;\n\n\t\terr = 0;\n\t\tbreak;\n\n\tcase L2CAP_SAR_END:\n\t\tif (!chan->sdu)\n\t\t\tbreak;\n\n\t\tappend_skb_frag(chan->sdu, skb,\n\t\t\t\t&chan->sdu_last_frag);\n\t\tskb = NULL;\n\n\t\tif (chan->sdu->len != chan->sdu_len)\n\t\t\tbreak;\n\n\t\terr = chan->ops->recv(chan, chan->sdu);\n\n\t\tif (!err) {\n\t\t\t/* Reassembly complete */\n\t\t\tchan->sdu = NULL;\n\t\t\tchan->sdu_last_frag = NULL;\n\t\t\tchan->sdu_len = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tkfree_skb(chan->sdu);\n\t\tchan->sdu = NULL;\n\t\tchan->sdu_last_frag = NULL;\n\t\tchan->sdu_len = 0;\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_resegment(struct l2cap_chan *chan)\n{\n\t/* Placeholder */\n\treturn 0;\n}\n\nvoid l2cap_chan_busy(struct l2cap_chan *chan, int busy)\n{\n\tu8 event;\n\n\tif (chan->mode != L2CAP_MODE_ERTM)\n\t\treturn;\n\n\tevent = busy ? L2CAP_EV_LOCAL_BUSY_DETECTED : L2CAP_EV_LOCAL_BUSY_CLEAR;\n\tl2cap_tx(chan, NULL, NULL, event);\n}\n\nstatic int l2cap_rx_queued_iframes(struct l2cap_chan *chan)\n{\n\tint err = 0;\n\t/* Pass sequential frames to l2cap_reassemble_sdu()\n\t * until a gap is encountered.\n\t */\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twhile (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\tstruct sk_buff *skb;\n\t\tBT_DBG(\"Searching for skb with txseq %d (queue len %d)\",\n\t\t       chan->buffer_seq, skb_queue_len(&chan->srej_q));\n\n\t\tskb = l2cap_ertm_seq_in_queue(&chan->srej_q, chan->buffer_seq);\n\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tskb_unlink(skb, &chan->srej_q);\n\t\tchan->buffer_seq = __next_seq(chan, chan->buffer_seq);\n\t\terr = l2cap_reassemble_sdu(chan, skb, &bt_cb(skb)->l2cap);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (skb_queue_empty(&chan->srej_q)) {\n\t\tchan->rx_state = L2CAP_RX_STATE_RECV;\n\t\tl2cap_send_ack(chan);\n\t}\n\n\treturn err;\n}\n\nstatic void l2cap_handle_srej(struct l2cap_chan *chan,\n\t\t\t      struct l2cap_ctrl *control)\n{\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tif (control->reqseq == chan->next_tx_seq) {\n\t\tBT_DBG(\"Invalid reqseq %d, disconnecting\", control->reqseq);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tskb = l2cap_ertm_seq_in_queue(&chan->tx_q, control->reqseq);\n\n\tif (skb == NULL) {\n\t\tBT_DBG(\"Seq %d not available for retransmission\",\n\t\t       control->reqseq);\n\t\treturn;\n\t}\n\n\tif (chan->max_tx != 0 && bt_cb(skb)->l2cap.retries >= chan->max_tx) {\n\t\tBT_DBG(\"Retry limit exceeded (%d)\", chan->max_tx);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\tif (control->poll) {\n\t\tl2cap_pass_to_tx(chan, control);\n\n\t\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\t\tl2cap_retransmit(chan, control);\n\t\tl2cap_ertm_send(chan);\n\n\t\tif (chan->tx_state == L2CAP_TX_STATE_WAIT_F) {\n\t\t\tset_bit(CONN_SREJ_ACT, &chan->conn_state);\n\t\t\tchan->srej_save_reqseq = control->reqseq;\n\t\t}\n\t} else {\n\t\tl2cap_pass_to_tx_fbit(chan, control);\n\n\t\tif (control->final) {\n\t\t\tif (chan->srej_save_reqseq != control->reqseq ||\n\t\t\t    !test_and_clear_bit(CONN_SREJ_ACT,\n\t\t\t\t\t\t&chan->conn_state))\n\t\t\t\tl2cap_retransmit(chan, control);\n\t\t} else {\n\t\t\tl2cap_retransmit(chan, control);\n\t\t\tif (chan->tx_state == L2CAP_TX_STATE_WAIT_F) {\n\t\t\t\tset_bit(CONN_SREJ_ACT, &chan->conn_state);\n\t\t\t\tchan->srej_save_reqseq = control->reqseq;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void l2cap_handle_rej(struct l2cap_chan *chan,\n\t\t\t     struct l2cap_ctrl *control)\n{\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tif (control->reqseq == chan->next_tx_seq) {\n\t\tBT_DBG(\"Invalid reqseq %d, disconnecting\", control->reqseq);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tskb = l2cap_ertm_seq_in_queue(&chan->tx_q, control->reqseq);\n\n\tif (chan->max_tx && skb &&\n\t    bt_cb(skb)->l2cap.retries >= chan->max_tx) {\n\t\tBT_DBG(\"Retry limit exceeded (%d)\", chan->max_tx);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\tl2cap_pass_to_tx(chan, control);\n\n\tif (control->final) {\n\t\tif (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))\n\t\t\tl2cap_retransmit_all(chan, control);\n\t} else {\n\t\tl2cap_retransmit_all(chan, control);\n\t\tl2cap_ertm_send(chan);\n\t\tif (chan->tx_state == L2CAP_TX_STATE_WAIT_F)\n\t\t\tset_bit(CONN_REJ_ACT, &chan->conn_state);\n\t}\n}\n\nstatic u8 l2cap_classify_txseq(struct l2cap_chan *chan, u16 txseq)\n{\n\tBT_DBG(\"chan %p, txseq %d\", chan, txseq);\n\n\tBT_DBG(\"last_acked_seq %d, expected_tx_seq %d\", chan->last_acked_seq,\n\t       chan->expected_tx_seq);\n\n\tif (chan->rx_state == L2CAP_RX_STATE_SREJ_SENT) {\n\t\tif (__seq_offset(chan, txseq, chan->last_acked_seq) >=\n\t\t    chan->tx_win) {\n\t\t\t/* See notes below regarding \"double poll\" and\n\t\t\t * invalid packets.\n\t\t\t */\n\t\t\tif (chan->tx_win <= ((chan->tx_win_max + 1) >> 1)) {\n\t\t\t\tBT_DBG(\"Invalid/Ignore - after SREJ\");\n\t\t\t\treturn L2CAP_TXSEQ_INVALID_IGNORE;\n\t\t\t} else {\n\t\t\t\tBT_DBG(\"Invalid - in window after SREJ sent\");\n\t\t\t\treturn L2CAP_TXSEQ_INVALID;\n\t\t\t}\n\t\t}\n\n\t\tif (chan->srej_list.head == txseq) {\n\t\t\tBT_DBG(\"Expected SREJ\");\n\t\t\treturn L2CAP_TXSEQ_EXPECTED_SREJ;\n\t\t}\n\n\t\tif (l2cap_ertm_seq_in_queue(&chan->srej_q, txseq)) {\n\t\t\tBT_DBG(\"Duplicate SREJ - txseq already stored\");\n\t\t\treturn L2CAP_TXSEQ_DUPLICATE_SREJ;\n\t\t}\n\n\t\tif (l2cap_seq_list_contains(&chan->srej_list, txseq)) {\n\t\t\tBT_DBG(\"Unexpected SREJ - not requested\");\n\t\t\treturn L2CAP_TXSEQ_UNEXPECTED_SREJ;\n\t\t}\n\t}\n\n\tif (chan->expected_tx_seq == txseq) {\n\t\tif (__seq_offset(chan, txseq, chan->last_acked_seq) >=\n\t\t    chan->tx_win) {\n\t\t\tBT_DBG(\"Invalid - txseq outside tx window\");\n\t\t\treturn L2CAP_TXSEQ_INVALID;\n\t\t} else {\n\t\t\tBT_DBG(\"Expected\");\n\t\t\treturn L2CAP_TXSEQ_EXPECTED;\n\t\t}\n\t}\n\n\tif (__seq_offset(chan, txseq, chan->last_acked_seq) <\n\t    __seq_offset(chan, chan->expected_tx_seq, chan->last_acked_seq)) {\n\t\tBT_DBG(\"Duplicate - expected_tx_seq later than txseq\");\n\t\treturn L2CAP_TXSEQ_DUPLICATE;\n\t}\n\n\tif (__seq_offset(chan, txseq, chan->last_acked_seq) >= chan->tx_win) {\n\t\t/* A source of invalid packets is a \"double poll\" condition,\n\t\t * where delays cause us to send multiple poll packets.  If\n\t\t * the remote stack receives and processes both polls,\n\t\t * sequence numbers can wrap around in such a way that a\n\t\t * resent frame has a sequence number that looks like new data\n\t\t * with a sequence gap.  This would trigger an erroneous SREJ\n\t\t * request.\n\t\t *\n\t\t * Fortunately, this is impossible with a tx window that's\n\t\t * less than half of the maximum sequence number, which allows\n\t\t * invalid frames to be safely ignored.\n\t\t *\n\t\t * With tx window sizes greater than half of the tx window\n\t\t * maximum, the frame is invalid and cannot be ignored.  This\n\t\t * causes a disconnect.\n\t\t */\n\n\t\tif (chan->tx_win <= ((chan->tx_win_max + 1) >> 1)) {\n\t\t\tBT_DBG(\"Invalid/Ignore - txseq outside tx window\");\n\t\t\treturn L2CAP_TXSEQ_INVALID_IGNORE;\n\t\t} else {\n\t\t\tBT_DBG(\"Invalid - txseq outside tx window\");\n\t\t\treturn L2CAP_TXSEQ_INVALID;\n\t\t}\n\t} else {\n\t\tBT_DBG(\"Unexpected - txseq indicates missing frames\");\n\t\treturn L2CAP_TXSEQ_UNEXPECTED;\n\t}\n}\n\nstatic int l2cap_rx_state_recv(struct l2cap_chan *chan,\n\t\t\t       struct l2cap_ctrl *control,\n\t\t\t       struct sk_buff *skb, u8 event)\n{\n\tstruct l2cap_ctrl local_control;\n\tint err = 0;\n\tbool skb_in_use = false;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, event %d\", chan, control, skb,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_RECV_IFRAME:\n\t\tswitch (l2cap_classify_txseq(chan, control->txseq)) {\n\t\tcase L2CAP_TXSEQ_EXPECTED:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\n\t\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\t\tBT_DBG(\"Busy, discarding expected seq %d\",\n\t\t\t\t       control->txseq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchan->expected_tx_seq = __next_seq(chan,\n\t\t\t\t\t\t\t   control->txseq);\n\n\t\t\tchan->buffer_seq = chan->expected_tx_seq;\n\t\t\tskb_in_use = true;\n\n\t\t\t/* l2cap_reassemble_sdu may free skb, hence invalidate\n\t\t\t * control, so make a copy in advance to use it after\n\t\t\t * l2cap_reassemble_sdu returns and to avoid the race\n\t\t\t * condition, for example:\n\t\t\t *\n\t\t\t * The current thread calls:\n\t\t\t *   l2cap_reassemble_sdu\n\t\t\t *     chan->ops->recv == l2cap_sock_recv_cb\n\t\t\t *       __sock_queue_rcv_skb\n\t\t\t * Another thread calls:\n\t\t\t *   bt_sock_recvmsg\n\t\t\t *     skb_recv_datagram\n\t\t\t *     skb_free_datagram\n\t\t\t * Then the current thread tries to access control, but\n\t\t\t * it was freed by skb_free_datagram.\n\t\t\t */\n\t\t\tlocal_control = *control;\n\t\t\terr = l2cap_reassemble_sdu(chan, skb, control);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tif (local_control.final) {\n\t\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT,\n\t\t\t\t\t\t\t&chan->conn_state)) {\n\t\t\t\t\tlocal_control.final = 0;\n\t\t\t\t\tl2cap_retransmit_all(chan, &local_control);\n\t\t\t\t\tl2cap_ertm_send(chan);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state))\n\t\t\t\tl2cap_send_ack(chan);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_UNEXPECTED:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\n\t\t\t/* Can't issue SREJ frames in the local busy state.\n\t\t\t * Drop this frame, it will be seen as missing\n\t\t\t * when local busy is exited.\n\t\t\t */\n\t\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\t\tBT_DBG(\"Busy, discarding unexpected seq %d\",\n\t\t\t\t       control->txseq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* There was a gap in the sequence, so an SREJ\n\t\t\t * must be sent for each missing frame.  The\n\t\t\t * current frame is stored for later use.\n\t\t\t */\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tclear_bit(CONN_SREJ_ACT, &chan->conn_state);\n\t\t\tl2cap_seq_list_clear(&chan->srej_list);\n\t\t\tl2cap_send_srej(chan, control->txseq);\n\n\t\t\tchan->rx_state = L2CAP_RX_STATE_SREJ_SENT;\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_DUPLICATE:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID_IGNORE:\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID:\n\t\tdefault:\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RR:\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control->final) {\n\t\t\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state) &&\n\t\t\t    !__chan_is_moving(chan)) {\n\t\t\t\tcontrol->final = 0;\n\t\t\t\tl2cap_retransmit_all(chan, control);\n\t\t\t}\n\n\t\t\tl2cap_ertm_send(chan);\n\t\t} else if (control->poll) {\n\t\t\tl2cap_send_i_or_rr_or_rnr(chan);\n\t\t} else {\n\t\t\tif (test_and_clear_bit(CONN_REMOTE_BUSY,\n\t\t\t\t\t       &chan->conn_state) &&\n\t\t\t    chan->unacked_frames)\n\t\t\t\t__set_retrans_timer(chan);\n\n\t\t\tl2cap_ertm_send(chan);\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RNR:\n\t\tset_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control && control->poll) {\n\t\t\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\t\t\tl2cap_send_rr_or_rnr(chan, 0);\n\t\t}\n\t\t__clear_retrans_timer(chan);\n\t\tl2cap_seq_list_clear(&chan->retrans_list);\n\t\tbreak;\n\tcase L2CAP_EV_RECV_REJ:\n\t\tl2cap_handle_rej(chan, control);\n\t\tbreak;\n\tcase L2CAP_EV_RECV_SREJ:\n\t\tl2cap_handle_srej(chan, control);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (skb && !skb_in_use) {\n\t\tBT_DBG(\"Freeing %p\", skb);\n\t\tkfree_skb(skb);\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_rx_state_srej_sent(struct l2cap_chan *chan,\n\t\t\t\t    struct l2cap_ctrl *control,\n\t\t\t\t    struct sk_buff *skb, u8 event)\n{\n\tint err = 0;\n\tu16 txseq = control->txseq;\n\tbool skb_in_use = false;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, event %d\", chan, control, skb,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_RECV_IFRAME:\n\t\tswitch (l2cap_classify_txseq(chan, txseq)) {\n\t\tcase L2CAP_TXSEQ_EXPECTED:\n\t\t\t/* Keep frame for reassembly later */\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tchan->expected_tx_seq = __next_seq(chan, txseq);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_EXPECTED_SREJ:\n\t\t\tl2cap_seq_list_pop(&chan->srej_list);\n\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\terr = l2cap_rx_queued_iframes(chan);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_UNEXPECTED:\n\t\t\t/* Got a frame that can't be reassembled yet.\n\t\t\t * Save it for later, and send SREJs to cover\n\t\t\t * the missing frames.\n\t\t\t */\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tl2cap_send_srej(chan, control->txseq);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_UNEXPECTED_SREJ:\n\t\t\t/* This frame was requested with an SREJ, but\n\t\t\t * some expected retransmitted frames are\n\t\t\t * missing.  Request retransmission of missing\n\t\t\t * SREJ'd frames.\n\t\t\t */\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tl2cap_send_srej_list(chan, control->txseq);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_DUPLICATE_SREJ:\n\t\t\t/* We've already queued this frame.  Drop this copy. */\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_DUPLICATE:\n\t\t\t/* Expecting a later sequence number, so this frame\n\t\t\t * was already received.  Ignore it completely.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID_IGNORE:\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID:\n\t\tdefault:\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RR:\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control->final) {\n\t\t\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT,\n\t\t\t\t\t\t&chan->conn_state)) {\n\t\t\t\tcontrol->final = 0;\n\t\t\t\tl2cap_retransmit_all(chan, control);\n\t\t\t}\n\n\t\t\tl2cap_ertm_send(chan);\n\t\t} else if (control->poll) {\n\t\t\tif (test_and_clear_bit(CONN_REMOTE_BUSY,\n\t\t\t\t\t       &chan->conn_state) &&\n\t\t\t    chan->unacked_frames) {\n\t\t\t\t__set_retrans_timer(chan);\n\t\t\t}\n\n\t\t\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\t\t\tl2cap_send_srej_tail(chan);\n\t\t} else {\n\t\t\tif (test_and_clear_bit(CONN_REMOTE_BUSY,\n\t\t\t\t\t       &chan->conn_state) &&\n\t\t\t    chan->unacked_frames)\n\t\t\t\t__set_retrans_timer(chan);\n\n\t\t\tl2cap_send_ack(chan);\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RNR:\n\t\tset_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control->poll) {\n\t\t\tl2cap_send_srej_tail(chan);\n\t\t} else {\n\t\t\tstruct l2cap_ctrl rr_control;\n\t\t\tmemset(&rr_control, 0, sizeof(rr_control));\n\t\t\trr_control.sframe = 1;\n\t\t\trr_control.super = L2CAP_SUPER_RR;\n\t\t\trr_control.reqseq = chan->buffer_seq;\n\t\t\tl2cap_send_sframe(chan, &rr_control);\n\t\t}\n\n\t\tbreak;\n\tcase L2CAP_EV_RECV_REJ:\n\t\tl2cap_handle_rej(chan, control);\n\t\tbreak;\n\tcase L2CAP_EV_RECV_SREJ:\n\t\tl2cap_handle_srej(chan, control);\n\t\tbreak;\n\t}\n\n\tif (skb && !skb_in_use) {\n\t\tBT_DBG(\"Freeing %p\", skb);\n\t\tkfree_skb(skb);\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_finish_move(struct l2cap_chan *chan)\n{\n\tBT_DBG(\"chan %p\", chan);\n\n\tchan->rx_state = L2CAP_RX_STATE_RECV;\n\n\tif (chan->hs_hcon)\n\t\tchan->conn->mtu = chan->hs_hcon->hdev->block_mtu;\n\telse\n\t\tchan->conn->mtu = chan->conn->hcon->hdev->acl_mtu;\n\n\treturn l2cap_resegment(chan);\n}\n\nstatic int l2cap_rx_state_wait_p(struct l2cap_chan *chan,\n\t\t\t\t struct l2cap_ctrl *control,\n\t\t\t\t struct sk_buff *skb, u8 event)\n{\n\tint err;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, event %d\", chan, control, skb,\n\t       event);\n\n\tif (!control->poll)\n\t\treturn -EPROTO;\n\n\tl2cap_process_reqseq(chan, control->reqseq);\n\n\tif (!skb_queue_empty(&chan->tx_q))\n\t\tchan->tx_send_head = skb_peek(&chan->tx_q);\n\telse\n\t\tchan->tx_send_head = NULL;\n\n\t/* Rewind next_tx_seq to the point expected\n\t * by the receiver.\n\t */\n\tchan->next_tx_seq = control->reqseq;\n\tchan->unacked_frames = 0;\n\n\terr = l2cap_finish_move(chan);\n\tif (err)\n\t\treturn err;\n\n\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\tl2cap_send_i_or_rr_or_rnr(chan);\n\n\tif (event == L2CAP_EV_RECV_IFRAME)\n\t\treturn -EPROTO;\n\n\treturn l2cap_rx_state_recv(chan, control, NULL, event);\n}\n\nstatic int l2cap_rx_state_wait_f(struct l2cap_chan *chan,\n\t\t\t\t struct l2cap_ctrl *control,\n\t\t\t\t struct sk_buff *skb, u8 event)\n{\n\tint err;\n\n\tif (!control->final)\n\t\treturn -EPROTO;\n\n\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\tchan->rx_state = L2CAP_RX_STATE_RECV;\n\tl2cap_process_reqseq(chan, control->reqseq);\n\n\tif (!skb_queue_empty(&chan->tx_q))\n\t\tchan->tx_send_head = skb_peek(&chan->tx_q);\n\telse\n\t\tchan->tx_send_head = NULL;\n\n\t/* Rewind next_tx_seq to the point expected\n\t * by the receiver.\n\t */\n\tchan->next_tx_seq = control->reqseq;\n\tchan->unacked_frames = 0;\n\n\tif (chan->hs_hcon)\n\t\tchan->conn->mtu = chan->hs_hcon->hdev->block_mtu;\n\telse\n\t\tchan->conn->mtu = chan->conn->hcon->hdev->acl_mtu;\n\n\terr = l2cap_resegment(chan);\n\n\tif (!err)\n\t\terr = l2cap_rx_state_recv(chan, control, skb, event);\n\n\treturn err;\n}\n\nstatic bool __valid_reqseq(struct l2cap_chan *chan, u16 reqseq)\n{\n\t/* Make sure reqseq is for a packet that has been sent but not acked */\n\tu16 unacked;\n\n\tunacked = __seq_offset(chan, chan->next_tx_seq, chan->expected_ack_seq);\n\treturn __seq_offset(chan, chan->next_tx_seq, reqseq) <= unacked;\n}\n\nstatic int l2cap_rx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\n\t\t    struct sk_buff *skb, u8 event)\n{\n\tint err = 0;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, event %d, state %d\", chan,\n\t       control, skb, event, chan->rx_state);\n\n\tif (__valid_reqseq(chan, control->reqseq)) {\n\t\tswitch (chan->rx_state) {\n\t\tcase L2CAP_RX_STATE_RECV:\n\t\t\terr = l2cap_rx_state_recv(chan, control, skb, event);\n\t\t\tbreak;\n\t\tcase L2CAP_RX_STATE_SREJ_SENT:\n\t\t\terr = l2cap_rx_state_srej_sent(chan, control, skb,\n\t\t\t\t\t\t       event);\n\t\t\tbreak;\n\t\tcase L2CAP_RX_STATE_WAIT_P:\n\t\t\terr = l2cap_rx_state_wait_p(chan, control, skb, event);\n\t\t\tbreak;\n\t\tcase L2CAP_RX_STATE_WAIT_F:\n\t\t\terr = l2cap_rx_state_wait_f(chan, control, skb, event);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* shut it down */\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tBT_DBG(\"Invalid reqseq %d (next_tx_seq %d, expected_ack_seq %d\",\n\t\t       control->reqseq, chan->next_tx_seq,\n\t\t       chan->expected_ack_seq);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_stream_rx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\n\t\t\t   struct sk_buff *skb)\n{\n\t/* l2cap_reassemble_sdu may free skb, hence invalidate control, so store\n\t * the txseq field in advance to use it after l2cap_reassemble_sdu\n\t * returns and to avoid the race condition, for example:\n\t *\n\t * The current thread calls:\n\t *   l2cap_reassemble_sdu\n\t *     chan->ops->recv == l2cap_sock_recv_cb\n\t *       __sock_queue_rcv_skb\n\t * Another thread calls:\n\t *   bt_sock_recvmsg\n\t *     skb_recv_datagram\n\t *     skb_free_datagram\n\t * Then the current thread tries to access control, but it was freed by\n\t * skb_free_datagram.\n\t */\n\tu16 txseq = control->txseq;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, state %d\", chan, control, skb,\n\t       chan->rx_state);\n\n\tif (l2cap_classify_txseq(chan, txseq) == L2CAP_TXSEQ_EXPECTED) {\n\t\tl2cap_pass_to_tx(chan, control);\n\n\t\tBT_DBG(\"buffer_seq %u->%u\", chan->buffer_seq,\n\t\t       __next_seq(chan, chan->buffer_seq));\n\n\t\tchan->buffer_seq = __next_seq(chan, chan->buffer_seq);\n\n\t\tl2cap_reassemble_sdu(chan, skb, control);\n\t} else {\n\t\tif (chan->sdu) {\n\t\t\tkfree_skb(chan->sdu);\n\t\t\tchan->sdu = NULL;\n\t\t}\n\t\tchan->sdu_last_frag = NULL;\n\t\tchan->sdu_len = 0;\n\n\t\tif (skb) {\n\t\t\tBT_DBG(\"Freeing %p\", skb);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\tchan->last_acked_seq = txseq;\n\tchan->expected_tx_seq = __next_seq(chan, txseq);\n\n\treturn 0;\n}\n\nstatic int l2cap_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct l2cap_ctrl *control = &bt_cb(skb)->l2cap;\n\tu16 len;\n\tu8 event;\n\n\t__unpack_control(chan, skb);\n\n\tlen = skb->len;\n\n\t/*\n\t * We can just drop the corrupted I-frame here.\n\t * Receiver will miss it and start proper recovery\n\t * procedures and ask for retransmission.\n\t */\n\tif (l2cap_check_fcs(chan, skb))\n\t\tgoto drop;\n\n\tif (!control->sframe && control->sar == L2CAP_SAR_START)\n\t\tlen -= L2CAP_SDULEN_SIZE;\n\n\tif (chan->fcs == L2CAP_FCS_CRC16)\n\t\tlen -= L2CAP_FCS_SIZE;\n\n\tif (len > chan->mps) {\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\tgoto drop;\n\t}\n\n\tif (chan->ops->filter) {\n\t\tif (chan->ops->filter(chan, skb))\n\t\t\tgoto drop;\n\t}\n\n\tif (!control->sframe) {\n\t\tint err;\n\n\t\tBT_DBG(\"iframe sar %d, reqseq %d, final %d, txseq %d\",\n\t\t       control->sar, control->reqseq, control->final,\n\t\t       control->txseq);\n\n\t\t/* Validate F-bit - F=0 always valid, F=1 only\n\t\t * valid in TX WAIT_F\n\t\t */\n\t\tif (control->final && chan->tx_state != L2CAP_TX_STATE_WAIT_F)\n\t\t\tgoto drop;\n\n\t\tif (chan->mode != L2CAP_MODE_STREAMING) {\n\t\t\tevent = L2CAP_EV_RECV_IFRAME;\n\t\t\terr = l2cap_rx(chan, control, skb, event);\n\t\t} else {\n\t\t\terr = l2cap_stream_rx(chan, control, skb);\n\t\t}\n\n\t\tif (err)\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t} else {\n\t\tconst u8 rx_func_to_event[4] = {\n\t\t\tL2CAP_EV_RECV_RR, L2CAP_EV_RECV_REJ,\n\t\t\tL2CAP_EV_RECV_RNR, L2CAP_EV_RECV_SREJ\n\t\t};\n\n\t\t/* Only I-frames are expected in streaming mode */\n\t\tif (chan->mode == L2CAP_MODE_STREAMING)\n\t\t\tgoto drop;\n\n\t\tBT_DBG(\"sframe reqseq %d, final %d, poll %d, super %d\",\n\t\t       control->reqseq, control->final, control->poll,\n\t\t       control->super);\n\n\t\tif (len != 0) {\n\t\t\tBT_ERR(\"Trailing bytes: %d in sframe\", len);\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Validate F and P bits */\n\t\tif (control->final && (control->poll ||\n\t\t\t\t       chan->tx_state != L2CAP_TX_STATE_WAIT_F))\n\t\t\tgoto drop;\n\n\t\tevent = rx_func_to_event[control->super];\n\t\tif (l2cap_rx(chan, control, skb, event))\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t}\n\n\treturn 0;\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic void l2cap_chan_le_send_credits(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_le_credits pkt;\n\tu16 return_credits;\n\n\treturn_credits = (chan->imtu / chan->mps) + 1;\n\n\tif (chan->rx_credits >= return_credits)\n\t\treturn;\n\n\treturn_credits -= chan->rx_credits;\n\n\tBT_DBG(\"chan %p returning %u credits to sender\", chan, return_credits);\n\n\tchan->rx_credits += return_credits;\n\n\tpkt.cid     = cpu_to_le16(chan->scid);\n\tpkt.credits = cpu_to_le16(return_credits);\n\n\tchan->ident = l2cap_get_ident(conn);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CREDITS, sizeof(pkt), &pkt);\n}\n\nstatic int l2cap_ecred_recv(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tint err;\n\n\tBT_DBG(\"SDU reassemble complete: chan %p skb->len %u\", chan, skb->len);\n\n\t/* Wait recv to confirm reception before updating the credits */\n\terr = chan->ops->recv(chan, skb);\n\n\t/* Update credits whenever an SDU is received */\n\tl2cap_chan_le_send_credits(chan);\n\n\treturn err;\n}\n\nstatic int l2cap_ecred_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tint err;\n\n\tif (!chan->rx_credits) {\n\t\tBT_ERR(\"No credits to receive LE L2CAP data\");\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (chan->imtu < skb->len) {\n\t\tBT_ERR(\"Too big LE L2CAP PDU\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tchan->rx_credits--;\n\tBT_DBG(\"rx_credits %u -> %u\", chan->rx_credits + 1, chan->rx_credits);\n\n\t/* Update if remote had run out of credits, this should only happens\n\t * if the remote is not using the entire MPS.\n\t */\n\tif (!chan->rx_credits)\n\t\tl2cap_chan_le_send_credits(chan);\n\n\terr = 0;\n\n\tif (!chan->sdu) {\n\t\tu16 sdu_len;\n\n\t\tsdu_len = get_unaligned_le16(skb->data);\n\t\tskb_pull(skb, L2CAP_SDULEN_SIZE);\n\n\t\tBT_DBG(\"Start of new SDU. sdu_len %u skb->len %u imtu %u\",\n\t\t       sdu_len, skb->len, chan->imtu);\n\n\t\tif (sdu_len > chan->imtu) {\n\t\t\tBT_ERR(\"Too big LE L2CAP SDU length received\");\n\t\t\terr = -EMSGSIZE;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (skb->len > sdu_len) {\n\t\t\tBT_ERR(\"Too much LE L2CAP data received\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (skb->len == sdu_len)\n\t\t\treturn l2cap_ecred_recv(chan, skb);\n\n\t\tchan->sdu = skb;\n\t\tchan->sdu_len = sdu_len;\n\t\tchan->sdu_last_frag = skb;\n\n\t\t/* Detect if remote is not able to use the selected MPS */\n\t\tif (skb->len + L2CAP_SDULEN_SIZE < chan->mps) {\n\t\t\tu16 mps_len = skb->len + L2CAP_SDULEN_SIZE;\n\n\t\t\t/* Adjust the number of credits */\n\t\t\tBT_DBG(\"chan->mps %u -> %u\", chan->mps, mps_len);\n\t\t\tchan->mps = mps_len;\n\t\t\tl2cap_chan_le_send_credits(chan);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tBT_DBG(\"SDU fragment. chan->sdu->len %u skb->len %u chan->sdu_len %u\",\n\t       chan->sdu->len, skb->len, chan->sdu_len);\n\n\tif (chan->sdu->len + skb->len > chan->sdu_len) {\n\t\tBT_ERR(\"Too much LE L2CAP data received\");\n\t\terr = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\tappend_skb_frag(chan->sdu, skb, &chan->sdu_last_frag);\n\tskb = NULL;\n\n\tif (chan->sdu->len == chan->sdu_len) {\n\t\terr = l2cap_ecred_recv(chan, chan->sdu);\n\t\tif (!err) {\n\t\t\tchan->sdu = NULL;\n\t\t\tchan->sdu_last_frag = NULL;\n\t\t\tchan->sdu_len = 0;\n\t\t}\n\t}\n\nfailed:\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tkfree_skb(chan->sdu);\n\t\tchan->sdu = NULL;\n\t\tchan->sdu_last_frag = NULL;\n\t\tchan->sdu_len = 0;\n\t}\n\n\t/* We can't return an error here since we took care of the skb\n\t * freeing internally. An error return would cause the caller to\n\t * do a double-free of the skb.\n\t */\n\treturn 0;\n}\n\nstatic void l2cap_data_channel(struct l2cap_conn *conn, u16 cid,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct l2cap_chan *chan;\n\n\tchan = l2cap_get_chan_by_scid(conn, cid);\n\tif (!chan) {\n\t\tif (cid == L2CAP_CID_A2MP) {\n\t\t\tchan = a2mp_channel_create(conn, skb);\n\t\t\tif (!chan) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tl2cap_chan_hold(chan);\n\t\t\tl2cap_chan_lock(chan);\n\t\t} else {\n\t\t\tBT_DBG(\"unknown cid 0x%4.4x\", cid);\n\t\t\t/* Drop packet and return */\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tBT_DBG(\"chan %p, len %d\", chan, skb->len);\n\n\t/* If we receive data on a fixed channel before the info req/rsp\n\t * procedure is done simply assume that the channel is supported\n\t * and mark it as ready.\n\t */\n\tif (chan->chan_type == L2CAP_CHAN_FIXED)\n\t\tl2cap_chan_ready(chan);\n\n\tif (chan->state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tif (l2cap_ecred_data_rcv(chan, skb) < 0)\n\t\t\tgoto drop;\n\n\t\tgoto done;\n\n\tcase L2CAP_MODE_BASIC:\n\t\t/* If socket recv buffers overflows we drop data here\n\t\t * which is *bad* because L2CAP has to be reliable.\n\t\t * But we don't have any other choice. L2CAP doesn't\n\t\t * provide flow control mechanism. */\n\n\t\tif (chan->imtu < skb->len) {\n\t\t\tBT_ERR(\"Dropping L2CAP data: receive buffer overflow\");\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (!chan->ops->recv(chan, skb))\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tl2cap_data_rcv(chan, skb);\n\t\tgoto done;\n\n\tdefault:\n\t\tBT_DBG(\"chan %p: bad mode 0x%2.2x\", chan, chan->mode);\n\t\tbreak;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n\ndone:\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nstatic void l2cap_conless_channel(struct l2cap_conn *conn, __le16 psm,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_chan *chan;\n\n\tif (hcon->type != ACL_LINK)\n\t\tgoto free_skb;\n\n\tchan = l2cap_global_chan_by_psm(0, psm, &hcon->src, &hcon->dst,\n\t\t\t\t\tACL_LINK);\n\tif (!chan)\n\t\tgoto free_skb;\n\n\tBT_DBG(\"chan %p, len %d\", chan, skb->len);\n\n\tif (chan->state != BT_BOUND && chan->state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tif (chan->imtu < skb->len)\n\t\tgoto drop;\n\n\t/* Store remote BD_ADDR and PSM for msg_name */\n\tbacpy(&bt_cb(skb)->l2cap.bdaddr, &hcon->dst);\n\tbt_cb(skb)->l2cap.psm = psm;\n\n\tif (!chan->ops->recv(chan, skb)) {\n\t\tl2cap_chan_put(chan);\n\t\treturn;\n\t}\n\ndrop:\n\tl2cap_chan_put(chan);\nfree_skb:\n\tkfree_skb(skb);\n}\n\nstatic void l2cap_recv_frame(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct l2cap_hdr *lh = (void *) skb->data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tu16 cid, len;\n\t__le16 psm;\n\n\tif (hcon->state != BT_CONNECTED) {\n\t\tBT_DBG(\"queueing pending rx skb\");\n\t\tskb_queue_tail(&conn->pending_rx, skb);\n\t\treturn;\n\t}\n\n\tskb_pull(skb, L2CAP_HDR_SIZE);\n\tcid = __le16_to_cpu(lh->cid);\n\tlen = __le16_to_cpu(lh->len);\n\n\tif (len != skb->len) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* Since we can't actively block incoming LE connections we must\n\t * at least ensure that we ignore incoming data from them.\n\t */\n\tif (hcon->type == LE_LINK &&\n\t    hci_bdaddr_list_lookup(&hcon->hdev->reject_list, &hcon->dst,\n\t\t\t\t   bdaddr_dst_type(hcon))) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tBT_DBG(\"len %d, cid 0x%4.4x\", len, cid);\n\n\tswitch (cid) {\n\tcase L2CAP_CID_SIGNALING:\n\t\tl2cap_sig_channel(conn, skb);\n\t\tbreak;\n\n\tcase L2CAP_CID_CONN_LESS:\n\t\tpsm = get_unaligned((__le16 *) skb->data);\n\t\tskb_pull(skb, L2CAP_PSMLEN_SIZE);\n\t\tl2cap_conless_channel(conn, psm, skb);\n\t\tbreak;\n\n\tcase L2CAP_CID_LE_SIGNALING:\n\t\tl2cap_le_sig_channel(conn, skb);\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_data_channel(conn, cid, skb);\n\t\tbreak;\n\t}\n}\n\nstatic void process_pending_rx(struct work_struct *work)\n{\n\tstruct l2cap_conn *conn = container_of(work, struct l2cap_conn,\n\t\t\t\t\t       pending_rx_work);\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"\");\n\n\twhile ((skb = skb_dequeue(&conn->pending_rx)))\n\t\tl2cap_recv_frame(conn, skb);\n}\n\nstatic struct l2cap_conn *l2cap_conn_add(struct hci_conn *hcon)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct hci_chan *hchan;\n\n\tif (conn)\n\t\treturn conn;\n\n\thchan = hci_chan_create(hcon);\n\tif (!hchan)\n\t\treturn NULL;\n\n\tconn = kzalloc(sizeof(*conn), GFP_KERNEL);\n\tif (!conn) {\n\t\thci_chan_del(hchan);\n\t\treturn NULL;\n\t}\n\n\tkref_init(&conn->ref);\n\thcon->l2cap_data = conn;\n\tconn->hcon = hci_conn_get(hcon);\n\tconn->hchan = hchan;\n\n\tBT_DBG(\"hcon %p conn %p hchan %p\", hcon, conn, hchan);\n\n\tswitch (hcon->type) {\n\tcase LE_LINK:\n\t\tif (hcon->hdev->le_mtu) {\n\t\t\tconn->mtu = hcon->hdev->le_mtu;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tconn->mtu = hcon->hdev->acl_mtu;\n\t\tbreak;\n\t}\n\n\tconn->feat_mask = 0;\n\n\tconn->local_fixed_chan = L2CAP_FC_SIG_BREDR | L2CAP_FC_CONNLESS;\n\n\tif (hcon->type == ACL_LINK &&\n\t    hci_dev_test_flag(hcon->hdev, HCI_HS_ENABLED))\n\t\tconn->local_fixed_chan |= L2CAP_FC_A2MP;\n\n\tif (hci_dev_test_flag(hcon->hdev, HCI_LE_ENABLED) &&\n\t    (bredr_sc_enabled(hcon->hdev) ||\n\t     hci_dev_test_flag(hcon->hdev, HCI_FORCE_BREDR_SMP)))\n\t\tconn->local_fixed_chan |= L2CAP_FC_SMP_BREDR;\n\n\tmutex_init(&conn->ident_lock);\n\tmutex_init(&conn->chan_lock);\n\n\tINIT_LIST_HEAD(&conn->chan_l);\n\tINIT_LIST_HEAD(&conn->users);\n\n\tINIT_DELAYED_WORK(&conn->info_timer, l2cap_info_timeout);\n\n\tskb_queue_head_init(&conn->pending_rx);\n\tINIT_WORK(&conn->pending_rx_work, process_pending_rx);\n\tINIT_WORK(&conn->id_addr_update_work, l2cap_conn_update_id_addr);\n\n\tconn->disc_reason = HCI_ERROR_REMOTE_USER_TERM;\n\n\treturn conn;\n}\n\nstatic bool is_valid_psm(u16 psm, u8 dst_type)\n{\n\tif (!psm)\n\t\treturn false;\n\n\tif (bdaddr_type_is_le(dst_type))\n\t\treturn (psm <= 0x00ff);\n\n\t/* PSM must be odd and lsb of upper byte must be 0 */\n\treturn ((psm & 0x0101) == 0x0001);\n}\n\nstruct l2cap_chan_data {\n\tstruct l2cap_chan *chan;\n\tstruct pid *pid;\n\tint count;\n};\n\nstatic void l2cap_chan_by_pid(struct l2cap_chan *chan, void *data)\n{\n\tstruct l2cap_chan_data *d = data;\n\tstruct pid *pid;\n\n\tif (chan == d->chan)\n\t\treturn;\n\n\tif (!test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\treturn;\n\n\tpid = chan->ops->get_peer_pid(chan);\n\n\t/* Only count deferred channels with the same PID/PSM */\n\tif (d->pid != pid || chan->psm != d->chan->psm || chan->ident ||\n\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL || chan->state != BT_CONNECT)\n\t\treturn;\n\n\td->count++;\n}\n\nint l2cap_chan_connect(struct l2cap_chan *chan, __le16 psm, u16 cid,\n\t\t       bdaddr_t *dst, u8 dst_type)\n{\n\tstruct l2cap_conn *conn;\n\tstruct hci_conn *hcon;\n\tstruct hci_dev *hdev;\n\tint err;\n\n\tBT_DBG(\"%pMR -> %pMR (type %u) psm 0x%4.4x mode 0x%2.2x\", &chan->src,\n\t       dst, dst_type, __le16_to_cpu(psm), chan->mode);\n\n\thdev = hci_get_route(dst, &chan->src, chan->src_type);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\n\thci_dev_lock(hdev);\n\n\tif (!is_valid_psm(__le16_to_cpu(psm), dst_type) && !cid &&\n\t    chan->chan_type != L2CAP_CHAN_RAW) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED && !psm) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (chan->chan_type == L2CAP_CHAN_FIXED && !cid) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\t\tbreak;\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tif (!enable_ecred) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (!disable_ertm)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n\n\tswitch (chan->state) {\n\tcase BT_CONNECT:\n\tcase BT_CONNECT2:\n\tcase BT_CONFIG:\n\t\t/* Already connecting */\n\t\terr = 0;\n\t\tgoto done;\n\n\tcase BT_CONNECTED:\n\t\t/* Already connected */\n\t\terr = -EISCONN;\n\t\tgoto done;\n\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\t\t/* Can connect */\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\t/* Set destination address and psm */\n\tbacpy(&chan->dst, dst);\n\tchan->dst_type = dst_type;\n\n\tchan->psm = psm;\n\tchan->dcid = cid;\n\n\tif (bdaddr_type_is_le(dst_type)) {\n\t\t/* Convert from L2CAP channel address type to HCI address type\n\t\t */\n\t\tif (dst_type == BDADDR_LE_PUBLIC)\n\t\t\tdst_type = ADDR_LE_DEV_PUBLIC;\n\t\telse\n\t\t\tdst_type = ADDR_LE_DEV_RANDOM;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\t\thcon = hci_connect_le(hdev, dst, dst_type, false,\n\t\t\t\t\t      chan->sec_level,\n\t\t\t\t\t      HCI_LE_CONN_TIMEOUT,\n\t\t\t\t\t      HCI_ROLE_SLAVE);\n\t\telse\n\t\t\thcon = hci_connect_le_scan(hdev, dst, dst_type,\n\t\t\t\t\t\t   chan->sec_level,\n\t\t\t\t\t\t   HCI_LE_CONN_TIMEOUT,\n\t\t\t\t\t\t   CONN_REASON_L2CAP_CHAN);\n\n\t} else {\n\t\tu8 auth_type = l2cap_get_auth_type(chan);\n\t\thcon = hci_connect_acl(hdev, dst, chan->sec_level, auth_type,\n\t\t\t\t       CONN_REASON_L2CAP_CHAN);\n\t}\n\n\tif (IS_ERR(hcon)) {\n\t\terr = PTR_ERR(hcon);\n\t\tgoto done;\n\t}\n\n\tconn = l2cap_conn_add(hcon);\n\tif (!conn) {\n\t\thci_conn_drop(hcon);\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tif (chan->mode == L2CAP_MODE_EXT_FLOWCTL) {\n\t\tstruct l2cap_chan_data data;\n\n\t\tdata.chan = chan;\n\t\tdata.pid = chan->ops->get_peer_pid(chan);\n\t\tdata.count = 1;\n\n\t\tl2cap_chan_list(conn, l2cap_chan_by_pid, &data);\n\n\t\t/* Check if there isn't too many channels being connected */\n\t\tif (data.count > L2CAP_ECRED_CONN_SCID_MAX) {\n\t\t\thci_conn_drop(hcon);\n\t\t\terr = -EPROTO;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tmutex_lock(&conn->chan_lock);\n\tl2cap_chan_lock(chan);\n\n\tif (cid && __l2cap_get_chan_by_dcid(conn, cid)) {\n\t\thci_conn_drop(hcon);\n\t\terr = -EBUSY;\n\t\tgoto chan_unlock;\n\t}\n\n\t/* Update source addr of the socket */\n\tbacpy(&chan->src, &hcon->src);\n\tchan->src_type = bdaddr_src_type(hcon);\n\n\t__l2cap_chan_add(conn, chan);\n\n\t/* l2cap_chan_add takes its own ref so we can drop this one */\n\thci_conn_drop(hcon);\n\n\tl2cap_state_change(chan, BT_CONNECT);\n\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\n\t/* Release chan->sport so that it can be reused by other\n\t * sockets (as it's only used for listening sockets).\n\t */\n\twrite_lock(&chan_list_lock);\n\tchan->sport = 0;\n\twrite_unlock(&chan_list_lock);\n\n\tif (hcon->state == BT_CONNECTED) {\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\t__clear_chan_timer(chan);\n\t\t\tif (l2cap_chan_check_security(chan, true))\n\t\t\t\tl2cap_state_change(chan, BT_CONNECTED);\n\t\t} else\n\t\t\tl2cap_do_start(chan);\n\t}\n\n\terr = 0;\n\nchan_unlock:\n\tl2cap_chan_unlock(chan);\n\tmutex_unlock(&conn->chan_lock);\ndone:\n\thci_dev_unlock(hdev);\n\thci_dev_put(hdev);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_connect);\n\nstatic void l2cap_ecred_reconfigure(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct {\n\t\tstruct l2cap_ecred_reconf_req req;\n\t\t__le16 scid;\n\t} pdu;\n\n\tpdu.req.mtu = cpu_to_le16(chan->imtu);\n\tpdu.req.mps = cpu_to_le16(chan->mps);\n\tpdu.scid    = cpu_to_le16(chan->scid);\n\n\tchan->ident = l2cap_get_ident(conn);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_ECRED_RECONF_REQ,\n\t\t       sizeof(pdu), &pdu);\n}\n\nint l2cap_chan_reconfigure(struct l2cap_chan *chan, __u16 mtu)\n{\n\tif (chan->imtu > mtu)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"chan %p mtu 0x%4.4x\", chan, mtu);\n\n\tchan->imtu = mtu;\n\n\tl2cap_ecred_reconfigure(chan);\n\n\treturn 0;\n}\n\n/* ---- L2CAP interface with lower layer (HCI) ---- */\n\nint l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr)\n{\n\tint exact = 0, lm1 = 0, lm2 = 0;\n\tstruct l2cap_chan *c;\n\n\tBT_DBG(\"hdev %s, bdaddr %pMR\", hdev->name, bdaddr);\n\n\t/* Find listening sockets and check their link_mode */\n\tread_lock(&chan_list_lock);\n\tlist_for_each_entry(c, &chan_list, global_l) {\n\t\tif (c->state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (!bacmp(&c->src, &hdev->bdaddr)) {\n\t\t\tlm1 |= HCI_LM_ACCEPT;\n\t\t\tif (test_bit(FLAG_ROLE_SWITCH, &c->flags))\n\t\t\t\tlm1 |= HCI_LM_MASTER;\n\t\t\texact++;\n\t\t} else if (!bacmp(&c->src, BDADDR_ANY)) {\n\t\t\tlm2 |= HCI_LM_ACCEPT;\n\t\t\tif (test_bit(FLAG_ROLE_SWITCH, &c->flags))\n\t\t\t\tlm2 |= HCI_LM_MASTER;\n\t\t}\n\t}\n\tread_unlock(&chan_list_lock);\n\n\treturn exact ? lm1 : lm2;\n}\n\n/* Find the next fixed channel in BT_LISTEN state, continue iteration\n * from an existing channel in the list or from the beginning of the\n * global list (by passing NULL as first parameter).\n */\nstatic struct l2cap_chan *l2cap_global_fixed_chan(struct l2cap_chan *c,\n\t\t\t\t\t\t  struct hci_conn *hcon)\n{\n\tu8 src_type = bdaddr_src_type(hcon);\n\n\tread_lock(&chan_list_lock);\n\n\tif (c)\n\t\tc = list_next_entry(c, global_l);\n\telse\n\t\tc = list_entry(chan_list.next, typeof(*c), global_l);\n\n\tlist_for_each_entry_from(c, &chan_list, global_l) {\n\t\tif (c->chan_type != L2CAP_CHAN_FIXED)\n\t\t\tcontinue;\n\t\tif (c->state != BT_LISTEN)\n\t\t\tcontinue;\n\t\tif (bacmp(&c->src, &hcon->src) && bacmp(&c->src, BDADDR_ANY))\n\t\t\tcontinue;\n\t\tif (src_type != c->src_type)\n\t\t\tcontinue;\n\n\t\tc = l2cap_chan_hold_unless_zero(c);\n\t\tread_unlock(&chan_list_lock);\n\t\treturn c;\n\t}\n\n\tread_unlock(&chan_list_lock);\n\n\treturn NULL;\n}\n\nstatic void l2cap_connect_cfm(struct hci_conn *hcon, u8 status)\n{\n\tstruct hci_dev *hdev = hcon->hdev;\n\tstruct l2cap_conn *conn;\n\tstruct l2cap_chan *pchan;\n\tu8 dst_type;\n\n\tif (hcon->type != ACL_LINK && hcon->type != LE_LINK)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p bdaddr %pMR status %d\", hcon, &hcon->dst, status);\n\n\tif (status) {\n\t\tl2cap_conn_del(hcon, bt_to_errno(status));\n\t\treturn;\n\t}\n\n\tconn = l2cap_conn_add(hcon);\n\tif (!conn)\n\t\treturn;\n\n\tdst_type = bdaddr_dst_type(hcon);\n\n\t/* If device is blocked, do not create channels for it */\n\tif (hci_bdaddr_list_lookup(&hdev->reject_list, &hcon->dst, dst_type))\n\t\treturn;\n\n\t/* Find fixed channels and notify them of the new connection. We\n\t * use multiple individual lookups, continuing each time where\n\t * we left off, because the list lock would prevent calling the\n\t * potentially sleeping l2cap_chan_lock() function.\n\t */\n\tpchan = l2cap_global_fixed_chan(NULL, hcon);\n\twhile (pchan) {\n\t\tstruct l2cap_chan *chan, *next;\n\n\t\t/* Client fixed channels should override server ones */\n\t\tif (__l2cap_get_chan_by_dcid(conn, pchan->scid))\n\t\t\tgoto next;\n\n\t\tl2cap_chan_lock(pchan);\n\t\tchan = pchan->ops->new_connection(pchan);\n\t\tif (chan) {\n\t\t\tbacpy(&chan->src, &hcon->src);\n\t\t\tbacpy(&chan->dst, &hcon->dst);\n\t\t\tchan->src_type = bdaddr_src_type(hcon);\n\t\t\tchan->dst_type = dst_type;\n\n\t\t\t__l2cap_chan_add(conn, chan);\n\t\t}\n\n\t\tl2cap_chan_unlock(pchan);\nnext:\n\t\tnext = l2cap_global_fixed_chan(pchan, hcon);\n\t\tl2cap_chan_put(pchan);\n\t\tpchan = next;\n\t}\n\n\tl2cap_conn_ready(conn);\n}\n\nint l2cap_disconn_ind(struct hci_conn *hcon)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\n\tBT_DBG(\"hcon %p\", hcon);\n\n\tif (!conn)\n\t\treturn HCI_ERROR_REMOTE_USER_TERM;\n\treturn conn->disc_reason;\n}\n\nstatic void l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason)\n{\n\tif (hcon->type != ACL_LINK && hcon->type != LE_LINK)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p reason %d\", hcon, reason);\n\n\tl2cap_conn_del(hcon, bt_to_errno(reason));\n}\n\nstatic inline void l2cap_check_encryption(struct l2cap_chan *chan, u8 encrypt)\n{\n\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED)\n\t\treturn;\n\n\tif (encrypt == 0x00) {\n\t\tif (chan->sec_level == BT_SECURITY_MEDIUM) {\n\t\t\t__set_chan_timer(chan, L2CAP_ENC_TIMEOUT);\n\t\t} else if (chan->sec_level == BT_SECURITY_HIGH ||\n\t\t\t   chan->sec_level == BT_SECURITY_FIPS)\n\t\t\tl2cap_chan_close(chan, ECONNREFUSED);\n\t} else {\n\t\tif (chan->sec_level == BT_SECURITY_MEDIUM)\n\t\t\t__clear_chan_timer(chan);\n\t}\n}\n\nstatic void l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct l2cap_chan *chan;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"conn %p status 0x%2.2x encrypt %u\", conn, status, encrypt);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tl2cap_chan_lock(chan);\n\n\t\tBT_DBG(\"chan %p scid 0x%4.4x state %s\", chan, chan->scid,\n\t\t       state_to_string(chan->state));\n\n\t\tif (chan->scid == L2CAP_CID_A2MP) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!status && encrypt)\n\t\t\tchan->sec_level = hcon->sec_level;\n\n\t\tif (!__l2cap_no_conn_pending(chan)) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!status && (chan->state == BT_CONNECTED ||\n\t\t\t\tchan->state == BT_CONFIG)) {\n\t\t\tchan->ops->resume(chan);\n\t\t\tl2cap_check_encryption(chan, encrypt);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chan->state == BT_CONNECT) {\n\t\t\tif (!status && l2cap_check_enc_key_size(hcon))\n\t\t\t\tl2cap_start_connection(chan);\n\t\t\telse\n\t\t\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n\t\t} else if (chan->state == BT_CONNECT2 &&\n\t\t\t   !(chan->mode == L2CAP_MODE_EXT_FLOWCTL ||\n\t\t\t     chan->mode == L2CAP_MODE_LE_FLOWCTL)) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\t__u16 res, stat;\n\n\t\t\tif (!status && l2cap_check_enc_key_size(hcon)) {\n\t\t\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\t\t\tres = L2CAP_CR_PEND;\n\t\t\t\t\tstat = L2CAP_CS_AUTHOR_PEND;\n\t\t\t\t\tchan->ops->defer(chan);\n\t\t\t\t} else {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\t\t\tres = L2CAP_CR_SUCCESS;\n\t\t\t\t\tstat = L2CAP_CS_NO_INFO;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tl2cap_state_change(chan, BT_DISCONN);\n\t\t\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n\t\t\t\tres = L2CAP_CR_SEC_BLOCK;\n\t\t\t\tstat = L2CAP_CS_NO_INFO;\n\t\t\t}\n\n\t\t\trsp.scid   = cpu_to_le16(chan->dcid);\n\t\t\trsp.dcid   = cpu_to_le16(chan->scid);\n\t\t\trsp.result = cpu_to_le16(res);\n\t\t\trsp.status = cpu_to_le16(stat);\n\t\t\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,\n\t\t\t\t       sizeof(rsp), &rsp);\n\n\t\t\tif (!test_bit(CONF_REQ_SENT, &chan->conf_state) &&\n\t\t\t    res == L2CAP_CR_SUCCESS) {\n\t\t\t\tchar buf[128];\n\t\t\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\t       L2CAP_CONF_REQ,\n\t\t\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)),\n\t\t\t\t\t       buf);\n\t\t\t\tchan->num_conf_req++;\n\t\t\t}\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\n/* Append fragment into frame respecting the maximum len of rx_skb */\nstatic int l2cap_recv_frag(struct l2cap_conn *conn, struct sk_buff *skb,\n\t\t\t   u16 len)\n{\n\tif (!conn->rx_skb) {\n\t\t/* Allocate skb for the complete frame (with header) */\n\t\tconn->rx_skb = bt_skb_alloc(len, GFP_KERNEL);\n\t\tif (!conn->rx_skb)\n\t\t\treturn -ENOMEM;\n\t\t/* Init rx_len */\n\t\tconn->rx_len = len;\n\t}\n\n\t/* Copy as much as the rx_skb can hold */\n\tlen = min_t(u16, len, skb->len);\n\tskb_copy_from_linear_data(skb, skb_put(conn->rx_skb, len), len);\n\tskb_pull(skb, len);\n\tconn->rx_len -= len;\n\n\treturn len;\n}\n\nstatic int l2cap_recv_len(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct sk_buff *rx_skb;\n\tint len;\n\n\t/* Append just enough to complete the header */\n\tlen = l2cap_recv_frag(conn, skb, L2CAP_LEN_SIZE - conn->rx_skb->len);\n\n\t/* If header could not be read just continue */\n\tif (len < 0 || conn->rx_skb->len < L2CAP_LEN_SIZE)\n\t\treturn len;\n\n\trx_skb = conn->rx_skb;\n\tlen = get_unaligned_le16(rx_skb->data);\n\n\t/* Check if rx_skb has enough space to received all fragments */\n\tif (len + (L2CAP_HDR_SIZE - L2CAP_LEN_SIZE) <= skb_tailroom(rx_skb)) {\n\t\t/* Update expected len */\n\t\tconn->rx_len = len + (L2CAP_HDR_SIZE - L2CAP_LEN_SIZE);\n\t\treturn L2CAP_LEN_SIZE;\n\t}\n\n\t/* Reset conn->rx_skb since it will need to be reallocated in order to\n\t * fit all fragments.\n\t */\n\tconn->rx_skb = NULL;\n\n\t/* Reallocates rx_skb using the exact expected length */\n\tlen = l2cap_recv_frag(conn, rx_skb,\n\t\t\t      len + (L2CAP_HDR_SIZE - L2CAP_LEN_SIZE));\n\tkfree_skb(rx_skb);\n\n\treturn len;\n}\n\nstatic void l2cap_recv_reset(struct l2cap_conn *conn)\n{\n\tkfree_skb(conn->rx_skb);\n\tconn->rx_skb = NULL;\n\tconn->rx_len = 0;\n}\n\nvoid l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tint len;\n\n\t/* For AMP controller do not create l2cap conn */\n\tif (!conn && hcon->hdev->dev_type != HCI_PRIMARY)\n\t\tgoto drop;\n\n\tif (!conn)\n\t\tconn = l2cap_conn_add(hcon);\n\n\tif (!conn)\n\t\tgoto drop;\n\n\tBT_DBG(\"conn %p len %u flags 0x%x\", conn, skb->len, flags);\n\n\tswitch (flags) {\n\tcase ACL_START:\n\tcase ACL_START_NO_FLUSH:\n\tcase ACL_COMPLETE:\n\t\tif (conn->rx_skb) {\n\t\t\tBT_ERR(\"Unexpected start frame (len %d)\", skb->len);\n\t\t\tl2cap_recv_reset(conn);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t}\n\n\t\t/* Start fragment may not contain the L2CAP length so just\n\t\t * copy the initial byte when that happens and use conn->mtu as\n\t\t * expected length.\n\t\t */\n\t\tif (skb->len < L2CAP_LEN_SIZE) {\n\t\t\tl2cap_recv_frag(conn, skb, conn->mtu);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = get_unaligned_le16(skb->data) + L2CAP_HDR_SIZE;\n\n\t\tif (len == skb->len) {\n\t\t\t/* Complete frame received */\n\t\t\tl2cap_recv_frame(conn, skb);\n\t\t\treturn;\n\t\t}\n\n\t\tBT_DBG(\"Start: total len %d, frag len %u\", len, skb->len);\n\n\t\tif (skb->len > len) {\n\t\t\tBT_ERR(\"Frame is too long (len %u, expected len %d)\",\n\t\t\t       skb->len, len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Append fragment into frame (with header) */\n\t\tif (l2cap_recv_frag(conn, skb, len) < 0)\n\t\t\tgoto drop;\n\n\t\tbreak;\n\n\tcase ACL_CONT:\n\t\tBT_DBG(\"Cont: frag len %u (expecting %u)\", skb->len, conn->rx_len);\n\n\t\tif (!conn->rx_skb) {\n\t\t\tBT_ERR(\"Unexpected continuation frame (len %d)\", skb->len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Complete the L2CAP length if it has not been read */\n\t\tif (conn->rx_skb->len < L2CAP_LEN_SIZE) {\n\t\t\tif (l2cap_recv_len(conn, skb) < 0) {\n\t\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\t/* Header still could not be read just continue */\n\t\t\tif (conn->rx_skb->len < L2CAP_LEN_SIZE)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (skb->len > conn->rx_len) {\n\t\t\tBT_ERR(\"Fragment is too long (len %u, expected %u)\",\n\t\t\t       skb->len, conn->rx_len);\n\t\t\tl2cap_recv_reset(conn);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Append fragment into frame (with header) */\n\t\tl2cap_recv_frag(conn, skb, skb->len);\n\n\t\tif (!conn->rx_len) {\n\t\t\t/* Complete frame received. l2cap_recv_frame\n\t\t\t * takes ownership of the skb so set the global\n\t\t\t * rx_skb pointer to NULL first.\n\t\t\t */\n\t\t\tstruct sk_buff *rx_skb = conn->rx_skb;\n\t\t\tconn->rx_skb = NULL;\n\t\t\tl2cap_recv_frame(conn, rx_skb);\n\t\t}\n\t\tbreak;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}\n\nstatic struct hci_cb l2cap_cb = {\n\t.name\t\t= \"L2CAP\",\n\t.connect_cfm\t= l2cap_connect_cfm,\n\t.disconn_cfm\t= l2cap_disconn_cfm,\n\t.security_cfm\t= l2cap_security_cfm,\n};\n\nstatic int l2cap_debugfs_show(struct seq_file *f, void *p)\n{\n\tstruct l2cap_chan *c;\n\n\tread_lock(&chan_list_lock);\n\n\tlist_for_each_entry(c, &chan_list, global_l) {\n\t\tseq_printf(f, \"%pMR (%u) %pMR (%u) %d %d 0x%4.4x 0x%4.4x %d %d %d %d\\n\",\n\t\t\t   &c->src, c->src_type, &c->dst, c->dst_type,\n\t\t\t   c->state, __le16_to_cpu(c->psm),\n\t\t\t   c->scid, c->dcid, c->imtu, c->omtu,\n\t\t\t   c->sec_level, c->mode);\n\t}\n\n\tread_unlock(&chan_list_lock);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(l2cap_debugfs);\n\nstatic struct dentry *l2cap_debugfs;\n\nint __init l2cap_init(void)\n{\n\tint err;\n\n\terr = l2cap_init_sockets();\n\tif (err < 0)\n\t\treturn err;\n\n\thci_register_cb(&l2cap_cb);\n\n\tif (IS_ERR_OR_NULL(bt_debugfs))\n\t\treturn 0;\n\n\tl2cap_debugfs = debugfs_create_file(\"l2cap\", 0444, bt_debugfs,\n\t\t\t\t\t    NULL, &l2cap_debugfs_fops);\n\n\treturn 0;\n}\n\nvoid l2cap_exit(void)\n{\n\tdebugfs_remove(l2cap_debugfs);\n\thci_unregister_cb(&l2cap_cb);\n\tl2cap_cleanup_sockets();\n}\n\nmodule_param(disable_ertm, bool, 0644);\nMODULE_PARM_DESC(disable_ertm, \"Disable enhanced retransmission mode\");\n\nmodule_param(enable_ecred, bool, 0644);\nMODULE_PARM_DESC(enable_ecred, \"Enable enhanced credit flow control mode\");\n"], "fixing_code": ["/*\n   BlueZ - Bluetooth protocol stack for Linux\n   Copyright (C) 2000-2001 Qualcomm Incorporated\n   Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>\n   Copyright (C) 2010 Google Inc.\n   Copyright (C) 2011 ProFUSION Embedded Systems\n   Copyright (c) 2012 Code Aurora Forum.  All rights reserved.\n\n   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n/* Bluetooth L2CAP core. */\n\n#include <linux/module.h>\n\n#include <linux/debugfs.h>\n#include <linux/crc16.h>\n#include <linux/filter.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#include \"smp.h\"\n#include \"a2mp.h\"\n#include \"amp.h\"\n\n#define LE_FLOWCTL_MAX_CREDITS 65535\n\nbool disable_ertm;\nbool enable_ecred;\n\nstatic u32 l2cap_feat_mask = L2CAP_FEAT_FIXED_CHAN | L2CAP_FEAT_UCD;\n\nstatic LIST_HEAD(chan_list);\nstatic DEFINE_RWLOCK(chan_list_lock);\n\nstatic struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,\n\t\t\t\t       u8 code, u8 ident, u16 dlen, void *data);\nstatic void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,\n\t\t\t   void *data);\nstatic int l2cap_build_conf_req(struct l2cap_chan *chan, void *data, size_t data_size);\nstatic void l2cap_send_disconn_req(struct l2cap_chan *chan, int err);\n\nstatic void l2cap_tx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\n\t\t     struct sk_buff_head *skbs, u8 event);\nstatic void l2cap_retrans_timeout(struct work_struct *work);\nstatic void l2cap_monitor_timeout(struct work_struct *work);\nstatic void l2cap_ack_timeout(struct work_struct *work);\n\nstatic inline u8 bdaddr_type(u8 link_type, u8 bdaddr_type)\n{\n\tif (link_type == LE_LINK) {\n\t\tif (bdaddr_type == ADDR_LE_DEV_PUBLIC)\n\t\t\treturn BDADDR_LE_PUBLIC;\n\t\telse\n\t\t\treturn BDADDR_LE_RANDOM;\n\t}\n\n\treturn BDADDR_BREDR;\n}\n\nstatic inline u8 bdaddr_src_type(struct hci_conn *hcon)\n{\n\treturn bdaddr_type(hcon->type, hcon->src_type);\n}\n\nstatic inline u8 bdaddr_dst_type(struct hci_conn *hcon)\n{\n\treturn bdaddr_type(hcon->type, hcon->dst_type);\n}\n\n/* ---- L2CAP channels ---- */\n\nstatic struct l2cap_chan *__l2cap_get_chan_by_dcid(struct l2cap_conn *conn,\n\t\t\t\t\t\t   u16 cid)\n{\n\tstruct l2cap_chan *c;\n\n\tlist_for_each_entry(c, &conn->chan_l, list) {\n\t\tif (c->dcid == cid)\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\nstatic struct l2cap_chan *__l2cap_get_chan_by_scid(struct l2cap_conn *conn,\n\t\t\t\t\t\t   u16 cid)\n{\n\tstruct l2cap_chan *c;\n\n\tlist_for_each_entry(c, &conn->chan_l, list) {\n\t\tif (c->scid == cid)\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\n/* Find channel with given SCID.\n * Returns a reference locked channel.\n */\nstatic struct l2cap_chan *l2cap_get_chan_by_scid(struct l2cap_conn *conn,\n\t\t\t\t\t\t u16 cid)\n{\n\tstruct l2cap_chan *c;\n\n\tmutex_lock(&conn->chan_lock);\n\tc = __l2cap_get_chan_by_scid(conn, cid);\n\tif (c) {\n\t\t/* Only lock if chan reference is not 0 */\n\t\tc = l2cap_chan_hold_unless_zero(c);\n\t\tif (c)\n\t\t\tl2cap_chan_lock(c);\n\t}\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn c;\n}\n\n/* Find channel with given DCID.\n * Returns a reference locked channel.\n */\nstatic struct l2cap_chan *l2cap_get_chan_by_dcid(struct l2cap_conn *conn,\n\t\t\t\t\t\t u16 cid)\n{\n\tstruct l2cap_chan *c;\n\n\tmutex_lock(&conn->chan_lock);\n\tc = __l2cap_get_chan_by_dcid(conn, cid);\n\tif (c) {\n\t\t/* Only lock if chan reference is not 0 */\n\t\tc = l2cap_chan_hold_unless_zero(c);\n\t\tif (c)\n\t\t\tl2cap_chan_lock(c);\n\t}\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn c;\n}\n\nstatic struct l2cap_chan *__l2cap_get_chan_by_ident(struct l2cap_conn *conn,\n\t\t\t\t\t\t    u8 ident)\n{\n\tstruct l2cap_chan *c;\n\n\tlist_for_each_entry(c, &conn->chan_l, list) {\n\t\tif (c->ident == ident)\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\nstatic struct l2cap_chan *l2cap_get_chan_by_ident(struct l2cap_conn *conn,\n\t\t\t\t\t\t  u8 ident)\n{\n\tstruct l2cap_chan *c;\n\n\tmutex_lock(&conn->chan_lock);\n\tc = __l2cap_get_chan_by_ident(conn, ident);\n\tif (c) {\n\t\t/* Only lock if chan reference is not 0 */\n\t\tc = l2cap_chan_hold_unless_zero(c);\n\t\tif (c)\n\t\t\tl2cap_chan_lock(c);\n\t}\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn c;\n}\n\nstatic struct l2cap_chan *__l2cap_global_chan_by_addr(__le16 psm, bdaddr_t *src,\n\t\t\t\t\t\t      u8 src_type)\n{\n\tstruct l2cap_chan *c;\n\n\tlist_for_each_entry(c, &chan_list, global_l) {\n\t\tif (src_type == BDADDR_BREDR && c->src_type != BDADDR_BREDR)\n\t\t\tcontinue;\n\n\t\tif (src_type != BDADDR_BREDR && c->src_type == BDADDR_BREDR)\n\t\t\tcontinue;\n\n\t\tif (c->sport == psm && !bacmp(&c->src, src))\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\nint l2cap_add_psm(struct l2cap_chan *chan, bdaddr_t *src, __le16 psm)\n{\n\tint err;\n\n\twrite_lock(&chan_list_lock);\n\n\tif (psm && __l2cap_global_chan_by_addr(psm, src, chan->src_type)) {\n\t\terr = -EADDRINUSE;\n\t\tgoto done;\n\t}\n\n\tif (psm) {\n\t\tchan->psm = psm;\n\t\tchan->sport = psm;\n\t\terr = 0;\n\t} else {\n\t\tu16 p, start, end, incr;\n\n\t\tif (chan->src_type == BDADDR_BREDR) {\n\t\t\tstart = L2CAP_PSM_DYN_START;\n\t\t\tend = L2CAP_PSM_AUTO_END;\n\t\t\tincr = 2;\n\t\t} else {\n\t\t\tstart = L2CAP_PSM_LE_DYN_START;\n\t\t\tend = L2CAP_PSM_LE_DYN_END;\n\t\t\tincr = 1;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tfor (p = start; p <= end; p += incr)\n\t\t\tif (!__l2cap_global_chan_by_addr(cpu_to_le16(p), src,\n\t\t\t\t\t\t\t chan->src_type)) {\n\t\t\t\tchan->psm   = cpu_to_le16(p);\n\t\t\t\tchan->sport = cpu_to_le16(p);\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\ndone:\n\twrite_unlock(&chan_list_lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(l2cap_add_psm);\n\nint l2cap_add_scid(struct l2cap_chan *chan,  __u16 scid)\n{\n\twrite_lock(&chan_list_lock);\n\n\t/* Override the defaults (which are for conn-oriented) */\n\tchan->omtu = L2CAP_DEFAULT_MTU;\n\tchan->chan_type = L2CAP_CHAN_FIXED;\n\n\tchan->scid = scid;\n\n\twrite_unlock(&chan_list_lock);\n\n\treturn 0;\n}\n\nstatic u16 l2cap_alloc_cid(struct l2cap_conn *conn)\n{\n\tu16 cid, dyn_end;\n\n\tif (conn->hcon->type == LE_LINK)\n\t\tdyn_end = L2CAP_CID_LE_DYN_END;\n\telse\n\t\tdyn_end = L2CAP_CID_DYN_END;\n\n\tfor (cid = L2CAP_CID_DYN_START; cid <= dyn_end; cid++) {\n\t\tif (!__l2cap_get_chan_by_scid(conn, cid))\n\t\t\treturn cid;\n\t}\n\n\treturn 0;\n}\n\nstatic void l2cap_state_change(struct l2cap_chan *chan, int state)\n{\n\tBT_DBG(\"chan %p %s -> %s\", chan, state_to_string(chan->state),\n\t       state_to_string(state));\n\n\tchan->state = state;\n\tchan->ops->state_change(chan, state, 0);\n}\n\nstatic inline void l2cap_state_change_and_error(struct l2cap_chan *chan,\n\t\t\t\t\t\tint state, int err)\n{\n\tchan->state = state;\n\tchan->ops->state_change(chan, chan->state, err);\n}\n\nstatic inline void l2cap_chan_set_err(struct l2cap_chan *chan, int err)\n{\n\tchan->ops->state_change(chan, chan->state, err);\n}\n\nstatic void __set_retrans_timer(struct l2cap_chan *chan)\n{\n\tif (!delayed_work_pending(&chan->monitor_timer) &&\n\t    chan->retrans_timeout) {\n\t\tl2cap_set_timer(chan, &chan->retrans_timer,\n\t\t\t\tmsecs_to_jiffies(chan->retrans_timeout));\n\t}\n}\n\nstatic void __set_monitor_timer(struct l2cap_chan *chan)\n{\n\t__clear_retrans_timer(chan);\n\tif (chan->monitor_timeout) {\n\t\tl2cap_set_timer(chan, &chan->monitor_timer,\n\t\t\t\tmsecs_to_jiffies(chan->monitor_timeout));\n\t}\n}\n\nstatic struct sk_buff *l2cap_ertm_seq_in_queue(struct sk_buff_head *head,\n\t\t\t\t\t       u16 seq)\n{\n\tstruct sk_buff *skb;\n\n\tskb_queue_walk(head, skb) {\n\t\tif (bt_cb(skb)->l2cap.txseq == seq)\n\t\t\treturn skb;\n\t}\n\n\treturn NULL;\n}\n\n/* ---- L2CAP sequence number lists ---- */\n\n/* For ERTM, ordered lists of sequence numbers must be tracked for\n * SREJ requests that are received and for frames that are to be\n * retransmitted. These seq_list functions implement a singly-linked\n * list in an array, where membership in the list can also be checked\n * in constant time. Items can also be added to the tail of the list\n * and removed from the head in constant time, without further memory\n * allocs or frees.\n */\n\nstatic int l2cap_seq_list_init(struct l2cap_seq_list *seq_list, u16 size)\n{\n\tsize_t alloc_size, i;\n\n\t/* Allocated size is a power of 2 to map sequence numbers\n\t * (which may be up to 14 bits) in to a smaller array that is\n\t * sized for the negotiated ERTM transmit windows.\n\t */\n\talloc_size = roundup_pow_of_two(size);\n\n\tseq_list->list = kmalloc_array(alloc_size, sizeof(u16), GFP_KERNEL);\n\tif (!seq_list->list)\n\t\treturn -ENOMEM;\n\n\tseq_list->mask = alloc_size - 1;\n\tseq_list->head = L2CAP_SEQ_LIST_CLEAR;\n\tseq_list->tail = L2CAP_SEQ_LIST_CLEAR;\n\tfor (i = 0; i < alloc_size; i++)\n\t\tseq_list->list[i] = L2CAP_SEQ_LIST_CLEAR;\n\n\treturn 0;\n}\n\nstatic inline void l2cap_seq_list_free(struct l2cap_seq_list *seq_list)\n{\n\tkfree(seq_list->list);\n}\n\nstatic inline bool l2cap_seq_list_contains(struct l2cap_seq_list *seq_list,\n\t\t\t\t\t   u16 seq)\n{\n\t/* Constant-time check for list membership */\n\treturn seq_list->list[seq & seq_list->mask] != L2CAP_SEQ_LIST_CLEAR;\n}\n\nstatic inline u16 l2cap_seq_list_pop(struct l2cap_seq_list *seq_list)\n{\n\tu16 seq = seq_list->head;\n\tu16 mask = seq_list->mask;\n\n\tseq_list->head = seq_list->list[seq & mask];\n\tseq_list->list[seq & mask] = L2CAP_SEQ_LIST_CLEAR;\n\n\tif (seq_list->head == L2CAP_SEQ_LIST_TAIL) {\n\t\tseq_list->head = L2CAP_SEQ_LIST_CLEAR;\n\t\tseq_list->tail = L2CAP_SEQ_LIST_CLEAR;\n\t}\n\n\treturn seq;\n}\n\nstatic void l2cap_seq_list_clear(struct l2cap_seq_list *seq_list)\n{\n\tu16 i;\n\n\tif (seq_list->head == L2CAP_SEQ_LIST_CLEAR)\n\t\treturn;\n\n\tfor (i = 0; i <= seq_list->mask; i++)\n\t\tseq_list->list[i] = L2CAP_SEQ_LIST_CLEAR;\n\n\tseq_list->head = L2CAP_SEQ_LIST_CLEAR;\n\tseq_list->tail = L2CAP_SEQ_LIST_CLEAR;\n}\n\nstatic void l2cap_seq_list_append(struct l2cap_seq_list *seq_list, u16 seq)\n{\n\tu16 mask = seq_list->mask;\n\n\t/* All appends happen in constant time */\n\n\tif (seq_list->list[seq & mask] != L2CAP_SEQ_LIST_CLEAR)\n\t\treturn;\n\n\tif (seq_list->tail == L2CAP_SEQ_LIST_CLEAR)\n\t\tseq_list->head = seq;\n\telse\n\t\tseq_list->list[seq_list->tail & mask] = seq;\n\n\tseq_list->tail = seq;\n\tseq_list->list[seq & mask] = L2CAP_SEQ_LIST_TAIL;\n}\n\nstatic void l2cap_chan_timeout(struct work_struct *work)\n{\n\tstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\n\t\t\t\t\t       chan_timer.work);\n\tstruct l2cap_conn *conn = chan->conn;\n\tint reason;\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\tmutex_lock(&conn->chan_lock);\n\t/* __set_chan_timer() calls l2cap_chan_hold(chan) while scheduling\n\t * this work. No need to call l2cap_chan_hold(chan) here again.\n\t */\n\tl2cap_chan_lock(chan);\n\n\tif (chan->state == BT_CONNECTED || chan->state == BT_CONFIG)\n\t\treason = ECONNREFUSED;\n\telse if (chan->state == BT_CONNECT &&\n\t\t chan->sec_level != BT_SECURITY_SDP)\n\t\treason = ECONNREFUSED;\n\telse\n\t\treason = ETIMEDOUT;\n\n\tl2cap_chan_close(chan, reason);\n\n\tchan->ops->close(chan);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\nstruct l2cap_chan *l2cap_chan_create(void)\n{\n\tstruct l2cap_chan *chan;\n\n\tchan = kzalloc(sizeof(*chan), GFP_ATOMIC);\n\tif (!chan)\n\t\treturn NULL;\n\n\tskb_queue_head_init(&chan->tx_q);\n\tskb_queue_head_init(&chan->srej_q);\n\tmutex_init(&chan->lock);\n\n\t/* Set default lock nesting level */\n\tatomic_set(&chan->nesting, L2CAP_NESTING_NORMAL);\n\n\twrite_lock(&chan_list_lock);\n\tlist_add(&chan->global_l, &chan_list);\n\twrite_unlock(&chan_list_lock);\n\n\tINIT_DELAYED_WORK(&chan->chan_timer, l2cap_chan_timeout);\n\tINIT_DELAYED_WORK(&chan->retrans_timer, l2cap_retrans_timeout);\n\tINIT_DELAYED_WORK(&chan->monitor_timer, l2cap_monitor_timeout);\n\tINIT_DELAYED_WORK(&chan->ack_timer, l2cap_ack_timeout);\n\n\tchan->state = BT_OPEN;\n\n\tkref_init(&chan->kref);\n\n\t/* This flag is cleared in l2cap_chan_ready() */\n\tset_bit(CONF_NOT_COMPLETE, &chan->conf_state);\n\n\tBT_DBG(\"chan %p\", chan);\n\n\treturn chan;\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_create);\n\nstatic void l2cap_chan_destroy(struct kref *kref)\n{\n\tstruct l2cap_chan *chan = container_of(kref, struct l2cap_chan, kref);\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twrite_lock(&chan_list_lock);\n\tlist_del(&chan->global_l);\n\twrite_unlock(&chan_list_lock);\n\n\tkfree(chan);\n}\n\nvoid l2cap_chan_hold(struct l2cap_chan *c)\n{\n\tBT_DBG(\"chan %p orig refcnt %u\", c, kref_read(&c->kref));\n\n\tkref_get(&c->kref);\n}\n\nstruct l2cap_chan *l2cap_chan_hold_unless_zero(struct l2cap_chan *c)\n{\n\tBT_DBG(\"chan %p orig refcnt %u\", c, kref_read(&c->kref));\n\n\tif (!kref_get_unless_zero(&c->kref))\n\t\treturn NULL;\n\n\treturn c;\n}\n\nvoid l2cap_chan_put(struct l2cap_chan *c)\n{\n\tBT_DBG(\"chan %p orig refcnt %u\", c, kref_read(&c->kref));\n\n\tkref_put(&c->kref, l2cap_chan_destroy);\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_put);\n\nvoid l2cap_chan_set_defaults(struct l2cap_chan *chan)\n{\n\tchan->fcs  = L2CAP_FCS_CRC16;\n\tchan->max_tx = L2CAP_DEFAULT_MAX_TX;\n\tchan->tx_win = L2CAP_DEFAULT_TX_WINDOW;\n\tchan->tx_win_max = L2CAP_DEFAULT_TX_WINDOW;\n\tchan->remote_max_tx = chan->max_tx;\n\tchan->remote_tx_win = chan->tx_win;\n\tchan->ack_win = L2CAP_DEFAULT_TX_WINDOW;\n\tchan->sec_level = BT_SECURITY_LOW;\n\tchan->flush_to = L2CAP_DEFAULT_FLUSH_TO;\n\tchan->retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;\n\tchan->monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;\n\n\tchan->conf_state = 0;\n\tset_bit(CONF_NOT_COMPLETE, &chan->conf_state);\n\n\tset_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_set_defaults);\n\nstatic void l2cap_le_flowctl_init(struct l2cap_chan *chan, u16 tx_credits)\n{\n\tchan->sdu = NULL;\n\tchan->sdu_last_frag = NULL;\n\tchan->sdu_len = 0;\n\tchan->tx_credits = tx_credits;\n\t/* Derive MPS from connection MTU to stop HCI fragmentation */\n\tchan->mps = min_t(u16, chan->imtu, chan->conn->mtu - L2CAP_HDR_SIZE);\n\t/* Give enough credits for a full packet */\n\tchan->rx_credits = (chan->imtu / chan->mps) + 1;\n\n\tskb_queue_head_init(&chan->tx_q);\n}\n\nstatic void l2cap_ecred_init(struct l2cap_chan *chan, u16 tx_credits)\n{\n\tl2cap_le_flowctl_init(chan, tx_credits);\n\n\t/* L2CAP implementations shall support a minimum MPS of 64 octets */\n\tif (chan->mps < L2CAP_ECRED_MIN_MPS) {\n\t\tchan->mps = L2CAP_ECRED_MIN_MPS;\n\t\tchan->rx_credits = (chan->imtu / chan->mps) + 1;\n\t}\n}\n\nvoid __l2cap_chan_add(struct l2cap_conn *conn, struct l2cap_chan *chan)\n{\n\tBT_DBG(\"conn %p, psm 0x%2.2x, dcid 0x%4.4x\", conn,\n\t       __le16_to_cpu(chan->psm), chan->dcid);\n\n\tconn->disc_reason = HCI_ERROR_REMOTE_USER_TERM;\n\n\tchan->conn = conn;\n\n\tswitch (chan->chan_type) {\n\tcase L2CAP_CHAN_CONN_ORIENTED:\n\t\t/* Alloc CID for connection-oriented socket */\n\t\tchan->scid = l2cap_alloc_cid(conn);\n\t\tif (conn->hcon->type == ACL_LINK)\n\t\t\tchan->omtu = L2CAP_DEFAULT_MTU;\n\t\tbreak;\n\n\tcase L2CAP_CHAN_CONN_LESS:\n\t\t/* Connectionless socket */\n\t\tchan->scid = L2CAP_CID_CONN_LESS;\n\t\tchan->dcid = L2CAP_CID_CONN_LESS;\n\t\tchan->omtu = L2CAP_DEFAULT_MTU;\n\t\tbreak;\n\n\tcase L2CAP_CHAN_FIXED:\n\t\t/* Caller will set CID and CID specific MTU values */\n\t\tbreak;\n\n\tdefault:\n\t\t/* Raw socket can send/recv signalling messages only */\n\t\tchan->scid = L2CAP_CID_SIGNALING;\n\t\tchan->dcid = L2CAP_CID_SIGNALING;\n\t\tchan->omtu = L2CAP_DEFAULT_MTU;\n\t}\n\n\tchan->local_id\t\t= L2CAP_BESTEFFORT_ID;\n\tchan->local_stype\t= L2CAP_SERV_BESTEFFORT;\n\tchan->local_msdu\t= L2CAP_DEFAULT_MAX_SDU_SIZE;\n\tchan->local_sdu_itime\t= L2CAP_DEFAULT_SDU_ITIME;\n\tchan->local_acc_lat\t= L2CAP_DEFAULT_ACC_LAT;\n\tchan->local_flush_to\t= L2CAP_EFS_DEFAULT_FLUSH_TO;\n\n\tl2cap_chan_hold(chan);\n\n\t/* Only keep a reference for fixed channels if they requested it */\n\tif (chan->chan_type != L2CAP_CHAN_FIXED ||\n\t    test_bit(FLAG_HOLD_HCI_CONN, &chan->flags))\n\t\thci_conn_hold(conn->hcon);\n\n\tlist_add(&chan->list, &conn->chan_l);\n}\n\nvoid l2cap_chan_add(struct l2cap_conn *conn, struct l2cap_chan *chan)\n{\n\tmutex_lock(&conn->chan_lock);\n\t__l2cap_chan_add(conn, chan);\n\tmutex_unlock(&conn->chan_lock);\n}\n\nvoid l2cap_chan_del(struct l2cap_chan *chan, int err)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\t__clear_chan_timer(chan);\n\n\tBT_DBG(\"chan %p, conn %p, err %d, state %s\", chan, conn, err,\n\t       state_to_string(chan->state));\n\n\tchan->ops->teardown(chan, err);\n\n\tif (conn) {\n\t\tstruct amp_mgr *mgr = conn->hcon->amp_mgr;\n\t\t/* Delete from channel list */\n\t\tlist_del(&chan->list);\n\n\t\tl2cap_chan_put(chan);\n\n\t\tchan->conn = NULL;\n\n\t\t/* Reference was only held for non-fixed channels or\n\t\t * fixed channels that explicitly requested it using the\n\t\t * FLAG_HOLD_HCI_CONN flag.\n\t\t */\n\t\tif (chan->chan_type != L2CAP_CHAN_FIXED ||\n\t\t    test_bit(FLAG_HOLD_HCI_CONN, &chan->flags))\n\t\t\thci_conn_drop(conn->hcon);\n\n\t\tif (mgr && mgr->bredr_chan == chan)\n\t\t\tmgr->bredr_chan = NULL;\n\t}\n\n\tif (chan->hs_hchan) {\n\t\tstruct hci_chan *hs_hchan = chan->hs_hchan;\n\n\t\tBT_DBG(\"chan %p disconnect hs_hchan %p\", chan, hs_hchan);\n\t\tamp_disconnect_logical_link(hs_hchan);\n\t}\n\n\tif (test_bit(CONF_NOT_COMPLETE, &chan->conf_state))\n\t\treturn;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tskb_queue_purge(&chan->tx_q);\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\t\t__clear_retrans_timer(chan);\n\t\t__clear_monitor_timer(chan);\n\t\t__clear_ack_timer(chan);\n\n\t\tskb_queue_purge(&chan->srej_q);\n\n\t\tl2cap_seq_list_free(&chan->srej_list);\n\t\tl2cap_seq_list_free(&chan->retrans_list);\n\t\tfallthrough;\n\n\tcase L2CAP_MODE_STREAMING:\n\t\tskb_queue_purge(&chan->tx_q);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_del);\n\nstatic void __l2cap_chan_list(struct l2cap_conn *conn, l2cap_chan_func_t func,\n\t\t\t      void *data)\n{\n\tstruct l2cap_chan *chan;\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tfunc(chan, data);\n\t}\n}\n\nvoid l2cap_chan_list(struct l2cap_conn *conn, l2cap_chan_func_t func,\n\t\t     void *data)\n{\n\tif (!conn)\n\t\treturn;\n\n\tmutex_lock(&conn->chan_lock);\n\t__l2cap_chan_list(conn, func, data);\n\tmutex_unlock(&conn->chan_lock);\n}\n\nEXPORT_SYMBOL_GPL(l2cap_chan_list);\n\nstatic void l2cap_conn_update_id_addr(struct work_struct *work)\n{\n\tstruct l2cap_conn *conn = container_of(work, struct l2cap_conn,\n\t\t\t\t\t       id_addr_update_work);\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_chan *chan;\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tl2cap_chan_lock(chan);\n\t\tbacpy(&chan->dst, &hcon->dst);\n\t\tchan->dst_type = bdaddr_dst_type(hcon);\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\nstatic void l2cap_chan_le_connect_reject(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_le_conn_rsp rsp;\n\tu16 result;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\tresult = L2CAP_CR_LE_AUTHORIZATION;\n\telse\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\n\tl2cap_state_change(chan, BT_DISCONN);\n\n\trsp.dcid    = cpu_to_le16(chan->scid);\n\trsp.mtu     = cpu_to_le16(chan->imtu);\n\trsp.mps     = cpu_to_le16(chan->mps);\n\trsp.credits = cpu_to_le16(chan->rx_credits);\n\trsp.result  = cpu_to_le16(result);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_RSP, sizeof(rsp),\n\t\t       &rsp);\n}\n\nstatic void l2cap_chan_ecred_connect_reject(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_ecred_conn_rsp rsp;\n\tu16 result;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\tresult = L2CAP_CR_LE_AUTHORIZATION;\n\telse\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\n\tl2cap_state_change(chan, BT_DISCONN);\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\trsp.result  = cpu_to_le16(result);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_RSP, sizeof(rsp),\n\t\t       &rsp);\n}\n\nstatic void l2cap_chan_connect_reject(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_conn_rsp rsp;\n\tu16 result;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\tresult = L2CAP_CR_SEC_BLOCK;\n\telse\n\t\tresult = L2CAP_CR_BAD_PSM;\n\n\tl2cap_state_change(chan, BT_DISCONN);\n\n\trsp.scid   = cpu_to_le16(chan->dcid);\n\trsp.dcid   = cpu_to_le16(chan->scid);\n\trsp.result = cpu_to_le16(result);\n\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP, sizeof(rsp), &rsp);\n}\n\nvoid l2cap_chan_close(struct l2cap_chan *chan, int reason)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\tswitch (chan->state) {\n\tcase BT_LISTEN:\n\t\tchan->ops->teardown(chan, 0);\n\t\tbreak;\n\n\tcase BT_CONNECTED:\n\tcase BT_CONFIG:\n\t\tif (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\t\t\tl2cap_send_disconn_req(chan, reason);\n\t\t} else\n\t\t\tl2cap_chan_del(chan, reason);\n\t\tbreak;\n\n\tcase BT_CONNECT2:\n\t\tif (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\tif (conn->hcon->type == ACL_LINK)\n\t\t\t\tl2cap_chan_connect_reject(chan);\n\t\t\telse if (conn->hcon->type == LE_LINK) {\n\t\t\t\tswitch (chan->mode) {\n\t\t\t\tcase L2CAP_MODE_LE_FLOWCTL:\n\t\t\t\t\tl2cap_chan_le_connect_reject(chan);\n\t\t\t\t\tbreak;\n\t\t\t\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\t\t\t\tl2cap_chan_ecred_connect_reject(chan);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tl2cap_chan_del(chan, reason);\n\t\tbreak;\n\n\tcase BT_CONNECT:\n\tcase BT_DISCONN:\n\t\tl2cap_chan_del(chan, reason);\n\t\tbreak;\n\n\tdefault:\n\t\tchan->ops->teardown(chan, 0);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(l2cap_chan_close);\n\nstatic inline u8 l2cap_get_auth_type(struct l2cap_chan *chan)\n{\n\tswitch (chan->chan_type) {\n\tcase L2CAP_CHAN_RAW:\n\t\tswitch (chan->sec_level) {\n\t\tcase BT_SECURITY_HIGH:\n\t\tcase BT_SECURITY_FIPS:\n\t\t\treturn HCI_AT_DEDICATED_BONDING_MITM;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\treturn HCI_AT_DEDICATED_BONDING;\n\t\tdefault:\n\t\t\treturn HCI_AT_NO_BONDING;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_CHAN_CONN_LESS:\n\t\tif (chan->psm == cpu_to_le16(L2CAP_PSM_3DSP)) {\n\t\t\tif (chan->sec_level == BT_SECURITY_LOW)\n\t\t\t\tchan->sec_level = BT_SECURITY_SDP;\n\t\t}\n\t\tif (chan->sec_level == BT_SECURITY_HIGH ||\n\t\t    chan->sec_level == BT_SECURITY_FIPS)\n\t\t\treturn HCI_AT_NO_BONDING_MITM;\n\t\telse\n\t\t\treturn HCI_AT_NO_BONDING;\n\t\tbreak;\n\tcase L2CAP_CHAN_CONN_ORIENTED:\n\t\tif (chan->psm == cpu_to_le16(L2CAP_PSM_SDP)) {\n\t\t\tif (chan->sec_level == BT_SECURITY_LOW)\n\t\t\t\tchan->sec_level = BT_SECURITY_SDP;\n\n\t\t\tif (chan->sec_level == BT_SECURITY_HIGH ||\n\t\t\t    chan->sec_level == BT_SECURITY_FIPS)\n\t\t\t\treturn HCI_AT_NO_BONDING_MITM;\n\t\t\telse\n\t\t\t\treturn HCI_AT_NO_BONDING;\n\t\t}\n\t\tfallthrough;\n\n\tdefault:\n\t\tswitch (chan->sec_level) {\n\t\tcase BT_SECURITY_HIGH:\n\t\tcase BT_SECURITY_FIPS:\n\t\t\treturn HCI_AT_GENERAL_BONDING_MITM;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\treturn HCI_AT_GENERAL_BONDING;\n\t\tdefault:\n\t\t\treturn HCI_AT_NO_BONDING;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n/* Service level security */\nint l2cap_chan_check_security(struct l2cap_chan *chan, bool initiator)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\t__u8 auth_type;\n\n\tif (conn->hcon->type == LE_LINK)\n\t\treturn smp_conn_security(conn->hcon, chan->sec_level);\n\n\tauth_type = l2cap_get_auth_type(chan);\n\n\treturn hci_conn_security(conn->hcon, chan->sec_level, auth_type,\n\t\t\t\t initiator);\n}\n\nstatic u8 l2cap_get_ident(struct l2cap_conn *conn)\n{\n\tu8 id;\n\n\t/* Get next available identificator.\n\t *    1 - 128 are used by kernel.\n\t *  129 - 199 are reserved.\n\t *  200 - 254 are used by utilities like l2ping, etc.\n\t */\n\n\tmutex_lock(&conn->ident_lock);\n\n\tif (++conn->tx_ident > 128)\n\t\tconn->tx_ident = 1;\n\n\tid = conn->tx_ident;\n\n\tmutex_unlock(&conn->ident_lock);\n\n\treturn id;\n}\n\nstatic void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,\n\t\t\t   void *data)\n{\n\tstruct sk_buff *skb = l2cap_build_cmd(conn, code, ident, len, data);\n\tu8 flags;\n\n\tBT_DBG(\"code 0x%2.2x\", code);\n\n\tif (!skb)\n\t\treturn;\n\n\t/* Use NO_FLUSH if supported or we have an LE link (which does\n\t * not support auto-flushing packets) */\n\tif (lmp_no_flush_capable(conn->hcon->hdev) ||\n\t    conn->hcon->type == LE_LINK)\n\t\tflags = ACL_START_NO_FLUSH;\n\telse\n\t\tflags = ACL_START;\n\n\tbt_cb(skb)->force_active = BT_POWER_FORCE_ACTIVE_ON;\n\tskb->priority = HCI_PRIO_MAX;\n\n\thci_send_acl(conn->hchan, skb, flags);\n}\n\nstatic bool __chan_is_moving(struct l2cap_chan *chan)\n{\n\treturn chan->move_state != L2CAP_MOVE_STABLE &&\n\t       chan->move_state != L2CAP_MOVE_WAIT_PREPARE;\n}\n\nstatic void l2cap_do_send(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct hci_conn *hcon = chan->conn->hcon;\n\tu16 flags;\n\n\tBT_DBG(\"chan %p, skb %p len %d priority %u\", chan, skb, skb->len,\n\t       skb->priority);\n\n\tif (chan->hs_hcon && !__chan_is_moving(chan)) {\n\t\tif (chan->hs_hchan)\n\t\t\thci_send_acl(chan->hs_hchan, skb, ACL_COMPLETE);\n\t\telse\n\t\t\tkfree_skb(skb);\n\n\t\treturn;\n\t}\n\n\t/* Use NO_FLUSH for LE links (where this is the only option) or\n\t * if the BR/EDR link supports it and flushing has not been\n\t * explicitly requested (through FLAG_FLUSHABLE).\n\t */\n\tif (hcon->type == LE_LINK ||\n\t    (!test_bit(FLAG_FLUSHABLE, &chan->flags) &&\n\t     lmp_no_flush_capable(hcon->hdev)))\n\t\tflags = ACL_START_NO_FLUSH;\n\telse\n\t\tflags = ACL_START;\n\n\tbt_cb(skb)->force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n\thci_send_acl(chan->conn->hchan, skb, flags);\n}\n\nstatic void __unpack_enhanced_control(u16 enh, struct l2cap_ctrl *control)\n{\n\tcontrol->reqseq = (enh & L2CAP_CTRL_REQSEQ) >> L2CAP_CTRL_REQSEQ_SHIFT;\n\tcontrol->final = (enh & L2CAP_CTRL_FINAL) >> L2CAP_CTRL_FINAL_SHIFT;\n\n\tif (enh & L2CAP_CTRL_FRAME_TYPE) {\n\t\t/* S-Frame */\n\t\tcontrol->sframe = 1;\n\t\tcontrol->poll = (enh & L2CAP_CTRL_POLL) >> L2CAP_CTRL_POLL_SHIFT;\n\t\tcontrol->super = (enh & L2CAP_CTRL_SUPERVISE) >> L2CAP_CTRL_SUPER_SHIFT;\n\n\t\tcontrol->sar = 0;\n\t\tcontrol->txseq = 0;\n\t} else {\n\t\t/* I-Frame */\n\t\tcontrol->sframe = 0;\n\t\tcontrol->sar = (enh & L2CAP_CTRL_SAR) >> L2CAP_CTRL_SAR_SHIFT;\n\t\tcontrol->txseq = (enh & L2CAP_CTRL_TXSEQ) >> L2CAP_CTRL_TXSEQ_SHIFT;\n\n\t\tcontrol->poll = 0;\n\t\tcontrol->super = 0;\n\t}\n}\n\nstatic void __unpack_extended_control(u32 ext, struct l2cap_ctrl *control)\n{\n\tcontrol->reqseq = (ext & L2CAP_EXT_CTRL_REQSEQ) >> L2CAP_EXT_CTRL_REQSEQ_SHIFT;\n\tcontrol->final = (ext & L2CAP_EXT_CTRL_FINAL) >> L2CAP_EXT_CTRL_FINAL_SHIFT;\n\n\tif (ext & L2CAP_EXT_CTRL_FRAME_TYPE) {\n\t\t/* S-Frame */\n\t\tcontrol->sframe = 1;\n\t\tcontrol->poll = (ext & L2CAP_EXT_CTRL_POLL) >> L2CAP_EXT_CTRL_POLL_SHIFT;\n\t\tcontrol->super = (ext & L2CAP_EXT_CTRL_SUPERVISE) >> L2CAP_EXT_CTRL_SUPER_SHIFT;\n\n\t\tcontrol->sar = 0;\n\t\tcontrol->txseq = 0;\n\t} else {\n\t\t/* I-Frame */\n\t\tcontrol->sframe = 0;\n\t\tcontrol->sar = (ext & L2CAP_EXT_CTRL_SAR) >> L2CAP_EXT_CTRL_SAR_SHIFT;\n\t\tcontrol->txseq = (ext & L2CAP_EXT_CTRL_TXSEQ) >> L2CAP_EXT_CTRL_TXSEQ_SHIFT;\n\n\t\tcontrol->poll = 0;\n\t\tcontrol->super = 0;\n\t}\n}\n\nstatic inline void __unpack_control(struct l2cap_chan *chan,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags)) {\n\t\t__unpack_extended_control(get_unaligned_le32(skb->data),\n\t\t\t\t\t  &bt_cb(skb)->l2cap);\n\t\tskb_pull(skb, L2CAP_EXT_CTRL_SIZE);\n\t} else {\n\t\t__unpack_enhanced_control(get_unaligned_le16(skb->data),\n\t\t\t\t\t  &bt_cb(skb)->l2cap);\n\t\tskb_pull(skb, L2CAP_ENH_CTRL_SIZE);\n\t}\n}\n\nstatic u32 __pack_extended_control(struct l2cap_ctrl *control)\n{\n\tu32 packed;\n\n\tpacked = control->reqseq << L2CAP_EXT_CTRL_REQSEQ_SHIFT;\n\tpacked |= control->final << L2CAP_EXT_CTRL_FINAL_SHIFT;\n\n\tif (control->sframe) {\n\t\tpacked |= control->poll << L2CAP_EXT_CTRL_POLL_SHIFT;\n\t\tpacked |= control->super << L2CAP_EXT_CTRL_SUPER_SHIFT;\n\t\tpacked |= L2CAP_EXT_CTRL_FRAME_TYPE;\n\t} else {\n\t\tpacked |= control->sar << L2CAP_EXT_CTRL_SAR_SHIFT;\n\t\tpacked |= control->txseq << L2CAP_EXT_CTRL_TXSEQ_SHIFT;\n\t}\n\n\treturn packed;\n}\n\nstatic u16 __pack_enhanced_control(struct l2cap_ctrl *control)\n{\n\tu16 packed;\n\n\tpacked = control->reqseq << L2CAP_CTRL_REQSEQ_SHIFT;\n\tpacked |= control->final << L2CAP_CTRL_FINAL_SHIFT;\n\n\tif (control->sframe) {\n\t\tpacked |= control->poll << L2CAP_CTRL_POLL_SHIFT;\n\t\tpacked |= control->super << L2CAP_CTRL_SUPER_SHIFT;\n\t\tpacked |= L2CAP_CTRL_FRAME_TYPE;\n\t} else {\n\t\tpacked |= control->sar << L2CAP_CTRL_SAR_SHIFT;\n\t\tpacked |= control->txseq << L2CAP_CTRL_TXSEQ_SHIFT;\n\t}\n\n\treturn packed;\n}\n\nstatic inline void __pack_control(struct l2cap_chan *chan,\n\t\t\t\t  struct l2cap_ctrl *control,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags)) {\n\t\tput_unaligned_le32(__pack_extended_control(control),\n\t\t\t\t   skb->data + L2CAP_HDR_SIZE);\n\t} else {\n\t\tput_unaligned_le16(__pack_enhanced_control(control),\n\t\t\t\t   skb->data + L2CAP_HDR_SIZE);\n\t}\n}\n\nstatic inline unsigned int __ertm_hdr_size(struct l2cap_chan *chan)\n{\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\treturn L2CAP_EXT_HDR_SIZE;\n\telse\n\t\treturn L2CAP_ENH_HDR_SIZE;\n}\n\nstatic struct sk_buff *l2cap_create_sframe_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t       u32 control)\n{\n\tstruct sk_buff *skb;\n\tstruct l2cap_hdr *lh;\n\tint hlen = __ertm_hdr_size(chan);\n\n\tif (chan->fcs == L2CAP_FCS_CRC16)\n\t\thlen += L2CAP_FCS_SIZE;\n\n\tskb = bt_skb_alloc(hlen, GFP_KERNEL);\n\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->len = cpu_to_le16(hlen - L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\tput_unaligned_le32(control, skb_put(skb, L2CAP_EXT_CTRL_SIZE));\n\telse\n\t\tput_unaligned_le16(control, skb_put(skb, L2CAP_ENH_CTRL_SIZE));\n\n\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\tu16 fcs = crc16(0, (u8 *)skb->data, skb->len);\n\t\tput_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));\n\t}\n\n\tskb->priority = HCI_PRIO_MAX;\n\treturn skb;\n}\n\nstatic void l2cap_send_sframe(struct l2cap_chan *chan,\n\t\t\t      struct l2cap_ctrl *control)\n{\n\tstruct sk_buff *skb;\n\tu32 control_field;\n\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tif (!control->sframe)\n\t\treturn;\n\n\tif (__chan_is_moving(chan))\n\t\treturn;\n\n\tif (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state) &&\n\t    !control->poll)\n\t\tcontrol->final = 1;\n\n\tif (control->super == L2CAP_SUPER_RR)\n\t\tclear_bit(CONN_RNR_SENT, &chan->conn_state);\n\telse if (control->super == L2CAP_SUPER_RNR)\n\t\tset_bit(CONN_RNR_SENT, &chan->conn_state);\n\n\tif (control->super != L2CAP_SUPER_SREJ) {\n\t\tchan->last_acked_seq = control->reqseq;\n\t\t__clear_ack_timer(chan);\n\t}\n\n\tBT_DBG(\"reqseq %d, final %d, poll %d, super %d\", control->reqseq,\n\t       control->final, control->poll, control->super);\n\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\tcontrol_field = __pack_extended_control(control);\n\telse\n\t\tcontrol_field = __pack_enhanced_control(control);\n\n\tskb = l2cap_create_sframe_pdu(chan, control_field);\n\tif (!IS_ERR(skb))\n\t\tl2cap_do_send(chan, skb);\n}\n\nstatic void l2cap_send_rr_or_rnr(struct l2cap_chan *chan, bool poll)\n{\n\tstruct l2cap_ctrl control;\n\n\tBT_DBG(\"chan %p, poll %d\", chan, poll);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.poll = poll;\n\n\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state))\n\t\tcontrol.super = L2CAP_SUPER_RNR;\n\telse\n\t\tcontrol.super = L2CAP_SUPER_RR;\n\n\tcontrol.reqseq = chan->buffer_seq;\n\tl2cap_send_sframe(chan, &control);\n}\n\nstatic inline int __l2cap_no_conn_pending(struct l2cap_chan *chan)\n{\n\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED)\n\t\treturn true;\n\n\treturn !test_bit(CONF_CONNECT_PEND, &chan->conf_state);\n}\n\nstatic bool __amp_capable(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct hci_dev *hdev;\n\tbool amp_available = false;\n\n\tif (!(conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\treturn false;\n\n\tif (!(conn->remote_fixed_chan & L2CAP_FC_A2MP))\n\t\treturn false;\n\n\tread_lock(&hci_dev_list_lock);\n\tlist_for_each_entry(hdev, &hci_dev_list, list) {\n\t\tif (hdev->amp_type != AMP_TYPE_BREDR &&\n\t\t    test_bit(HCI_UP, &hdev->flags)) {\n\t\t\tamp_available = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&hci_dev_list_lock);\n\n\tif (chan->chan_policy == BT_CHANNEL_POLICY_AMP_PREFERRED)\n\t\treturn amp_available;\n\n\treturn false;\n}\n\nstatic bool l2cap_check_efs(struct l2cap_chan *chan)\n{\n\t/* Check EFS parameters */\n\treturn true;\n}\n\nvoid l2cap_send_conn_req(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_conn_req req;\n\n\treq.scid = cpu_to_le16(chan->scid);\n\treq.psm  = chan->psm;\n\n\tchan->ident = l2cap_get_ident(conn);\n\n\tset_bit(CONF_CONNECT_PEND, &chan->conf_state);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_REQ, sizeof(req), &req);\n}\n\nstatic void l2cap_send_create_chan_req(struct l2cap_chan *chan, u8 amp_id)\n{\n\tstruct l2cap_create_chan_req req;\n\treq.scid = cpu_to_le16(chan->scid);\n\treq.psm  = chan->psm;\n\treq.amp_id = amp_id;\n\n\tchan->ident = l2cap_get_ident(chan->conn);\n\n\tl2cap_send_cmd(chan->conn, chan->ident, L2CAP_CREATE_CHAN_REQ,\n\t\t       sizeof(req), &req);\n}\n\nstatic void l2cap_move_setup(struct l2cap_chan *chan)\n{\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->mode != L2CAP_MODE_ERTM)\n\t\treturn;\n\n\t__clear_retrans_timer(chan);\n\t__clear_monitor_timer(chan);\n\t__clear_ack_timer(chan);\n\n\tchan->retry_count = 0;\n\tskb_queue_walk(&chan->tx_q, skb) {\n\t\tif (bt_cb(skb)->l2cap.retries)\n\t\t\tbt_cb(skb)->l2cap.retries = 1;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tchan->expected_tx_seq = chan->buffer_seq;\n\n\tclear_bit(CONN_REJ_ACT, &chan->conn_state);\n\tclear_bit(CONN_SREJ_ACT, &chan->conn_state);\n\tl2cap_seq_list_clear(&chan->retrans_list);\n\tl2cap_seq_list_clear(&chan->srej_list);\n\tskb_queue_purge(&chan->srej_q);\n\n\tchan->tx_state = L2CAP_TX_STATE_XMIT;\n\tchan->rx_state = L2CAP_RX_STATE_MOVE;\n\n\tset_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n}\n\nstatic void l2cap_move_done(struct l2cap_chan *chan)\n{\n\tu8 move_role = chan->move_role;\n\tBT_DBG(\"chan %p\", chan);\n\n\tchan->move_state = L2CAP_MOVE_STABLE;\n\tchan->move_role = L2CAP_MOVE_ROLE_NONE;\n\n\tif (chan->mode != L2CAP_MODE_ERTM)\n\t\treturn;\n\n\tswitch (move_role) {\n\tcase L2CAP_MOVE_ROLE_INITIATOR:\n\t\tl2cap_tx(chan, NULL, NULL, L2CAP_EV_EXPLICIT_POLL);\n\t\tchan->rx_state = L2CAP_RX_STATE_WAIT_F;\n\t\tbreak;\n\tcase L2CAP_MOVE_ROLE_RESPONDER:\n\t\tchan->rx_state = L2CAP_RX_STATE_WAIT_P;\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_chan_ready(struct l2cap_chan *chan)\n{\n\t/* The channel may have already been flagged as connected in\n\t * case of receiving data before the L2CAP info req/rsp\n\t * procedure is complete.\n\t */\n\tif (chan->state == BT_CONNECTED)\n\t\treturn;\n\n\t/* This clears all conf flags, including CONF_NOT_COMPLETE */\n\tchan->conf_state = 0;\n\t__clear_chan_timer(chan);\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tif (!chan->tx_credits)\n\t\t\tchan->ops->suspend(chan);\n\t\tbreak;\n\t}\n\n\tchan->state = BT_CONNECTED;\n\n\tchan->ops->ready(chan);\n}\n\nstatic void l2cap_le_connect(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_le_conn_req req;\n\n\tif (test_and_set_bit(FLAG_LE_CONN_REQ_SENT, &chan->flags))\n\t\treturn;\n\n\tif (!chan->imtu)\n\t\tchan->imtu = chan->conn->mtu;\n\n\tl2cap_le_flowctl_init(chan, 0);\n\n\tmemset(&req, 0, sizeof(req));\n\treq.psm     = chan->psm;\n\treq.scid    = cpu_to_le16(chan->scid);\n\treq.mtu     = cpu_to_le16(chan->imtu);\n\treq.mps     = cpu_to_le16(chan->mps);\n\treq.credits = cpu_to_le16(chan->rx_credits);\n\n\tchan->ident = l2cap_get_ident(conn);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_REQ,\n\t\t       sizeof(req), &req);\n}\n\nstruct l2cap_ecred_conn_data {\n\tstruct {\n\t\tstruct l2cap_ecred_conn_req req;\n\t\t__le16 scid[5];\n\t} __packed pdu;\n\tstruct l2cap_chan *chan;\n\tstruct pid *pid;\n\tint count;\n};\n\nstatic void l2cap_ecred_defer_connect(struct l2cap_chan *chan, void *data)\n{\n\tstruct l2cap_ecred_conn_data *conn = data;\n\tstruct pid *pid;\n\n\tif (chan == conn->chan)\n\t\treturn;\n\n\tif (!test_and_clear_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\treturn;\n\n\tpid = chan->ops->get_peer_pid(chan);\n\n\t/* Only add deferred channels with the same PID/PSM */\n\tif (conn->pid != pid || chan->psm != conn->chan->psm || chan->ident ||\n\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL || chan->state != BT_CONNECT)\n\t\treturn;\n\n\tif (test_and_set_bit(FLAG_ECRED_CONN_REQ_SENT, &chan->flags))\n\t\treturn;\n\n\tl2cap_ecred_init(chan, 0);\n\n\t/* Set the same ident so we can match on the rsp */\n\tchan->ident = conn->chan->ident;\n\n\t/* Include all channels deferred */\n\tconn->pdu.scid[conn->count] = cpu_to_le16(chan->scid);\n\n\tconn->count++;\n}\n\nstatic void l2cap_ecred_connect(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_ecred_conn_data data;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\treturn;\n\n\tif (test_and_set_bit(FLAG_ECRED_CONN_REQ_SENT, &chan->flags))\n\t\treturn;\n\n\tl2cap_ecred_init(chan, 0);\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.pdu.req.psm     = chan->psm;\n\tdata.pdu.req.mtu     = cpu_to_le16(chan->imtu);\n\tdata.pdu.req.mps     = cpu_to_le16(chan->mps);\n\tdata.pdu.req.credits = cpu_to_le16(chan->rx_credits);\n\tdata.pdu.scid[0]     = cpu_to_le16(chan->scid);\n\n\tchan->ident = l2cap_get_ident(conn);\n\n\tdata.count = 1;\n\tdata.chan = chan;\n\tdata.pid = chan->ops->get_peer_pid(chan);\n\n\t__l2cap_chan_list(conn, l2cap_ecred_defer_connect, &data);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_ECRED_CONN_REQ,\n\t\t       sizeof(data.pdu.req) + data.count * sizeof(__le16),\n\t\t       &data.pdu);\n}\n\nstatic void l2cap_le_start(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tif (!smp_conn_security(conn->hcon, chan->sec_level))\n\t\treturn;\n\n\tif (!chan->psm) {\n\t\tl2cap_chan_ready(chan);\n\t\treturn;\n\t}\n\n\tif (chan->state == BT_CONNECT) {\n\t\tif (chan->mode == L2CAP_MODE_EXT_FLOWCTL)\n\t\t\tl2cap_ecred_connect(chan);\n\t\telse\n\t\t\tl2cap_le_connect(chan);\n\t}\n}\n\nstatic void l2cap_start_connection(struct l2cap_chan *chan)\n{\n\tif (__amp_capable(chan)) {\n\t\tBT_DBG(\"chan %p AMP capable: discover AMPs\", chan);\n\t\ta2mp_discover_amp(chan);\n\t} else if (chan->conn->hcon->type == LE_LINK) {\n\t\tl2cap_le_start(chan);\n\t} else {\n\t\tl2cap_send_conn_req(chan);\n\t}\n}\n\nstatic void l2cap_request_info(struct l2cap_conn *conn)\n{\n\tstruct l2cap_info_req req;\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)\n\t\treturn;\n\n\treq.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\n\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;\n\tconn->info_ident = l2cap_get_ident(conn);\n\n\tschedule_delayed_work(&conn->info_timer, L2CAP_INFO_TIMEOUT);\n\n\tl2cap_send_cmd(conn, conn->info_ident, L2CAP_INFO_REQ,\n\t\t       sizeof(req), &req);\n}\n\nstatic bool l2cap_check_enc_key_size(struct hci_conn *hcon)\n{\n\t/* The minimum encryption key size needs to be enforced by the\n\t * host stack before establishing any L2CAP connections. The\n\t * specification in theory allows a minimum of 1, but to align\n\t * BR/EDR and LE transports, a minimum of 7 is chosen.\n\t *\n\t * This check might also be called for unencrypted connections\n\t * that have no key size requirements. Ensure that the link is\n\t * actually encrypted before enforcing a key size.\n\t */\n\tint min_key_size = hcon->hdev->min_enc_key_size;\n\n\t/* On FIPS security level, key size must be 16 bytes */\n\tif (hcon->sec_level == BT_SECURITY_FIPS)\n\t\tmin_key_size = 16;\n\n\treturn (!test_bit(HCI_CONN_ENCRYPT, &hcon->flags) ||\n\t\thcon->enc_key_size >= min_key_size);\n}\n\nstatic void l2cap_do_start(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tif (conn->hcon->type == LE_LINK) {\n\t\tl2cap_le_start(chan);\n\t\treturn;\n\t}\n\n\tif (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)) {\n\t\tl2cap_request_info(conn);\n\t\treturn;\n\t}\n\n\tif (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))\n\t\treturn;\n\n\tif (!l2cap_chan_check_security(chan, true) ||\n\t    !__l2cap_no_conn_pending(chan))\n\t\treturn;\n\n\tif (l2cap_check_enc_key_size(conn->hcon))\n\t\tl2cap_start_connection(chan);\n\telse\n\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n}\n\nstatic inline int l2cap_mode_supported(__u8 mode, __u32 feat_mask)\n{\n\tu32 local_feat_mask = l2cap_feat_mask;\n\tif (!disable_ertm)\n\t\tlocal_feat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING;\n\n\tswitch (mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\treturn L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;\n\tdefault:\n\t\treturn 0x00;\n\t}\n}\n\nstatic void l2cap_send_disconn_req(struct l2cap_chan *chan, int err)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_disconn_req req;\n\n\tif (!conn)\n\t\treturn;\n\n\tif (chan->mode == L2CAP_MODE_ERTM && chan->state == BT_CONNECTED) {\n\t\t__clear_retrans_timer(chan);\n\t\t__clear_monitor_timer(chan);\n\t\t__clear_ack_timer(chan);\n\t}\n\n\tif (chan->scid == L2CAP_CID_A2MP) {\n\t\tl2cap_state_change(chan, BT_DISCONN);\n\t\treturn;\n\t}\n\n\treq.dcid = cpu_to_le16(chan->dcid);\n\treq.scid = cpu_to_le16(chan->scid);\n\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_DISCONN_REQ,\n\t\t       sizeof(req), &req);\n\n\tl2cap_state_change_and_error(chan, BT_DISCONN, err);\n}\n\n/* ---- L2CAP connections ---- */\nstatic void l2cap_conn_start(struct l2cap_conn *conn)\n{\n\tstruct l2cap_chan *chan, *tmp;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry_safe(chan, tmp, &conn->chan_l, list) {\n\t\tl2cap_chan_lock(chan);\n\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\tl2cap_chan_ready(chan);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chan->state == BT_CONNECT) {\n\t\t\tif (!l2cap_chan_check_security(chan, true) ||\n\t\t\t    !__l2cap_no_conn_pending(chan)) {\n\t\t\t\tl2cap_chan_unlock(chan);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!l2cap_mode_supported(chan->mode, conn->feat_mask)\n\t\t\t    && test_bit(CONF_STATE2_DEVICE,\n\t\t\t\t\t&chan->conf_state)) {\n\t\t\t\tl2cap_chan_close(chan, ECONNRESET);\n\t\t\t\tl2cap_chan_unlock(chan);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (l2cap_check_enc_key_size(conn->hcon))\n\t\t\t\tl2cap_start_connection(chan);\n\t\t\telse\n\t\t\t\tl2cap_chan_close(chan, ECONNREFUSED);\n\n\t\t} else if (chan->state == BT_CONNECT2) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\tchar buf[128];\n\t\t\trsp.scid = cpu_to_le16(chan->dcid);\n\t\t\trsp.dcid = cpu_to_le16(chan->scid);\n\n\t\t\tif (l2cap_chan_check_security(chan, false)) {\n\t\t\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_PEND);\n\t\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_AUTHOR_PEND);\n\t\t\t\t\tchan->ops->defer(chan);\n\n\t\t\t\t} else {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\t\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_PEND);\n\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_AUTHEN_PEND);\n\t\t\t}\n\n\t\t\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,\n\t\t\t\t       sizeof(rsp), &rsp);\n\n\t\t\tif (test_bit(CONF_REQ_SENT, &chan->conf_state) ||\n\t\t\t    rsp.result != L2CAP_CR_SUCCESS) {\n\t\t\t\tl2cap_chan_unlock(chan);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\t\t\tchan->num_conf_req++;\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\nstatic void l2cap_le_conn_ready(struct l2cap_conn *conn)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct hci_dev *hdev = hcon->hdev;\n\n\tBT_DBG(\"%s conn %p\", hdev->name, conn);\n\n\t/* For outgoing pairing which doesn't necessarily have an\n\t * associated socket (e.g. mgmt_pair_device).\n\t */\n\tif (hcon->out)\n\t\tsmp_conn_security(hcon, hcon->pending_sec_level);\n\n\t/* For LE peripheral connections, make sure the connection interval\n\t * is in the range of the minimum and maximum interval that has\n\t * been configured for this connection. If not, then trigger\n\t * the connection update procedure.\n\t */\n\tif (hcon->role == HCI_ROLE_SLAVE &&\n\t    (hcon->le_conn_interval < hcon->le_conn_min_interval ||\n\t     hcon->le_conn_interval > hcon->le_conn_max_interval)) {\n\t\tstruct l2cap_conn_param_update_req req;\n\n\t\treq.min = cpu_to_le16(hcon->le_conn_min_interval);\n\t\treq.max = cpu_to_le16(hcon->le_conn_max_interval);\n\t\treq.latency = cpu_to_le16(hcon->le_conn_latency);\n\t\treq.to_multiplier = cpu_to_le16(hcon->le_supv_timeout);\n\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t       L2CAP_CONN_PARAM_UPDATE_REQ, sizeof(req), &req);\n\t}\n}\n\nstatic void l2cap_conn_ready(struct l2cap_conn *conn)\n{\n\tstruct l2cap_chan *chan;\n\tstruct hci_conn *hcon = conn->hcon;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tif (hcon->type == ACL_LINK)\n\t\tl2cap_request_info(conn);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\n\t\tl2cap_chan_lock(chan);\n\n\t\tif (chan->scid == L2CAP_CID_A2MP) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hcon->type == LE_LINK) {\n\t\t\tl2cap_le_start(chan);\n\t\t} else if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)\n\t\t\t\tl2cap_chan_ready(chan);\n\t\t} else if (chan->state == BT_CONNECT) {\n\t\t\tl2cap_do_start(chan);\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n\n\tif (hcon->type == LE_LINK)\n\t\tl2cap_le_conn_ready(conn);\n\n\tqueue_work(hcon->hdev->workqueue, &conn->pending_rx_work);\n}\n\n/* Notify sockets that we cannot guaranty reliability anymore */\nstatic void l2cap_conn_unreliable(struct l2cap_conn *conn, int err)\n{\n\tstruct l2cap_chan *chan;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tif (test_bit(FLAG_FORCE_RELIABLE, &chan->flags))\n\t\t\tl2cap_chan_set_err(chan, err);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\nstatic void l2cap_info_timeout(struct work_struct *work)\n{\n\tstruct l2cap_conn *conn = container_of(work, struct l2cap_conn,\n\t\t\t\t\t       info_timer.work);\n\n\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\tconn->info_ident = 0;\n\n\tl2cap_conn_start(conn);\n}\n\n/*\n * l2cap_user\n * External modules can register l2cap_user objects on l2cap_conn. The ->probe\n * callback is called during registration. The ->remove callback is called\n * during unregistration.\n * An l2cap_user object can either be explicitly unregistered or when the\n * underlying l2cap_conn object is deleted. This guarantees that l2cap->hcon,\n * l2cap->hchan, .. are valid as long as the remove callback hasn't been called.\n * External modules must own a reference to the l2cap_conn object if they intend\n * to call l2cap_unregister_user(). The l2cap_conn object might get destroyed at\n * any time if they don't.\n */\n\nint l2cap_register_user(struct l2cap_conn *conn, struct l2cap_user *user)\n{\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\tint ret;\n\n\t/* We need to check whether l2cap_conn is registered. If it is not, we\n\t * must not register the l2cap_user. l2cap_conn_del() is unregisters\n\t * l2cap_conn objects, but doesn't provide its own locking. Instead, it\n\t * relies on the parent hci_conn object to be locked. This itself relies\n\t * on the hci_dev object to be locked. So we must lock the hci device\n\t * here, too. */\n\n\thci_dev_lock(hdev);\n\n\tif (!list_empty(&user->list)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* conn->hchan is NULL after l2cap_conn_del() was called */\n\tif (!conn->hchan) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tret = user->probe(conn, user);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tlist_add(&user->list, &conn->users);\n\tret = 0;\n\nout_unlock:\n\thci_dev_unlock(hdev);\n\treturn ret;\n}\nEXPORT_SYMBOL(l2cap_register_user);\n\nvoid l2cap_unregister_user(struct l2cap_conn *conn, struct l2cap_user *user)\n{\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\n\thci_dev_lock(hdev);\n\n\tif (list_empty(&user->list))\n\t\tgoto out_unlock;\n\n\tlist_del_init(&user->list);\n\tuser->remove(conn, user);\n\nout_unlock:\n\thci_dev_unlock(hdev);\n}\nEXPORT_SYMBOL(l2cap_unregister_user);\n\nstatic void l2cap_unregister_all_users(struct l2cap_conn *conn)\n{\n\tstruct l2cap_user *user;\n\n\twhile (!list_empty(&conn->users)) {\n\t\tuser = list_first_entry(&conn->users, struct l2cap_user, list);\n\t\tlist_del_init(&user->list);\n\t\tuser->remove(conn, user);\n\t}\n}\n\nstatic void l2cap_conn_del(struct hci_conn *hcon, int err)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct l2cap_chan *chan, *l;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p conn %p, err %d\", hcon, conn, err);\n\n\tkfree_skb(conn->rx_skb);\n\n\tskb_queue_purge(&conn->pending_rx);\n\n\t/* We can not call flush_work(&conn->pending_rx_work) here since we\n\t * might block if we are running on a worker from the same workqueue\n\t * pending_rx_work is waiting on.\n\t */\n\tif (work_pending(&conn->pending_rx_work))\n\t\tcancel_work_sync(&conn->pending_rx_work);\n\n\tif (work_pending(&conn->id_addr_update_work))\n\t\tcancel_work_sync(&conn->id_addr_update_work);\n\n\tl2cap_unregister_all_users(conn);\n\n\t/* Force the connection to be immediately dropped */\n\thcon->disc_timeout = 0;\n\n\tmutex_lock(&conn->chan_lock);\n\n\t/* Kill channels */\n\tlist_for_each_entry_safe(chan, l, &conn->chan_l, list) {\n\t\tl2cap_chan_hold(chan);\n\t\tl2cap_chan_lock(chan);\n\n\t\tl2cap_chan_del(chan, err);\n\n\t\tchan->ops->close(chan);\n\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n\n\thci_chan_del(conn->hchan);\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)\n\t\tcancel_delayed_work_sync(&conn->info_timer);\n\n\thcon->l2cap_data = NULL;\n\tconn->hchan = NULL;\n\tl2cap_conn_put(conn);\n}\n\nstatic void l2cap_conn_free(struct kref *ref)\n{\n\tstruct l2cap_conn *conn = container_of(ref, struct l2cap_conn, ref);\n\n\thci_conn_put(conn->hcon);\n\tkfree(conn);\n}\n\nstruct l2cap_conn *l2cap_conn_get(struct l2cap_conn *conn)\n{\n\tkref_get(&conn->ref);\n\treturn conn;\n}\nEXPORT_SYMBOL(l2cap_conn_get);\n\nvoid l2cap_conn_put(struct l2cap_conn *conn)\n{\n\tkref_put(&conn->ref, l2cap_conn_free);\n}\nEXPORT_SYMBOL(l2cap_conn_put);\n\n/* ---- Socket interface ---- */\n\n/* Find socket with psm and source / destination bdaddr.\n * Returns closest match.\n */\nstatic struct l2cap_chan *l2cap_global_chan_by_psm(int state, __le16 psm,\n\t\t\t\t\t\t   bdaddr_t *src,\n\t\t\t\t\t\t   bdaddr_t *dst,\n\t\t\t\t\t\t   u8 link_type)\n{\n\tstruct l2cap_chan *c, *tmp, *c1 = NULL;\n\n\tread_lock(&chan_list_lock);\n\n\tlist_for_each_entry_safe(c, tmp, &chan_list, global_l) {\n\t\tif (state && c->state != state)\n\t\t\tcontinue;\n\n\t\tif (link_type == ACL_LINK && c->src_type != BDADDR_BREDR)\n\t\t\tcontinue;\n\n\t\tif (link_type == LE_LINK && c->src_type == BDADDR_BREDR)\n\t\t\tcontinue;\n\n\t\tif (c->chan_type != L2CAP_CHAN_FIXED && c->psm == psm) {\n\t\t\tint src_match, dst_match;\n\t\t\tint src_any, dst_any;\n\n\t\t\t/* Exact match. */\n\t\t\tsrc_match = !bacmp(&c->src, src);\n\t\t\tdst_match = !bacmp(&c->dst, dst);\n\t\t\tif (src_match && dst_match) {\n\t\t\t\tif (!l2cap_chan_hold_unless_zero(c))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tread_unlock(&chan_list_lock);\n\t\t\t\treturn c;\n\t\t\t}\n\n\t\t\t/* Closest match */\n\t\t\tsrc_any = !bacmp(&c->src, BDADDR_ANY);\n\t\t\tdst_any = !bacmp(&c->dst, BDADDR_ANY);\n\t\t\tif ((src_match && dst_any) || (src_any && dst_match) ||\n\t\t\t    (src_any && dst_any))\n\t\t\t\tc1 = c;\n\t\t}\n\t}\n\n\tif (c1)\n\t\tc1 = l2cap_chan_hold_unless_zero(c1);\n\n\tread_unlock(&chan_list_lock);\n\n\treturn c1;\n}\n\nstatic void l2cap_monitor_timeout(struct work_struct *work)\n{\n\tstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\n\t\t\t\t\t       monitor_timer.work);\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tl2cap_chan_lock(chan);\n\n\tif (!chan->conn) {\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t\treturn;\n\t}\n\n\tl2cap_tx(chan, NULL, NULL, L2CAP_EV_MONITOR_TO);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nstatic void l2cap_retrans_timeout(struct work_struct *work)\n{\n\tstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\n\t\t\t\t\t       retrans_timer.work);\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tl2cap_chan_lock(chan);\n\n\tif (!chan->conn) {\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t\treturn;\n\t}\n\n\tl2cap_tx(chan, NULL, NULL, L2CAP_EV_RETRANS_TO);\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nstatic void l2cap_streaming_send(struct l2cap_chan *chan,\n\t\t\t\t struct sk_buff_head *skbs)\n{\n\tstruct sk_buff *skb;\n\tstruct l2cap_ctrl *control;\n\n\tBT_DBG(\"chan %p, skbs %p\", chan, skbs);\n\n\tif (__chan_is_moving(chan))\n\t\treturn;\n\n\tskb_queue_splice_tail_init(skbs, &chan->tx_q);\n\n\twhile (!skb_queue_empty(&chan->tx_q)) {\n\n\t\tskb = skb_dequeue(&chan->tx_q);\n\n\t\tbt_cb(skb)->l2cap.retries = 1;\n\t\tcontrol = &bt_cb(skb)->l2cap;\n\n\t\tcontrol->reqseq = 0;\n\t\tcontrol->txseq = chan->next_tx_seq;\n\n\t\t__pack_control(chan, control, skb);\n\n\t\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\t\tu16 fcs = crc16(0, (u8 *) skb->data, skb->len);\n\t\t\tput_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));\n\t\t}\n\n\t\tl2cap_do_send(chan, skb);\n\n\t\tBT_DBG(\"Sent txseq %u\", control->txseq);\n\n\t\tchan->next_tx_seq = __next_seq(chan, chan->next_tx_seq);\n\t\tchan->frames_sent++;\n\t}\n}\n\nstatic int l2cap_ertm_send(struct l2cap_chan *chan)\n{\n\tstruct sk_buff *skb, *tx_skb;\n\tstruct l2cap_ctrl *control;\n\tint sent = 0;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->state != BT_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\tif (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))\n\t\treturn 0;\n\n\tif (__chan_is_moving(chan))\n\t\treturn 0;\n\n\twhile (chan->tx_send_head &&\n\t       chan->unacked_frames < chan->remote_tx_win &&\n\t       chan->tx_state == L2CAP_TX_STATE_XMIT) {\n\n\t\tskb = chan->tx_send_head;\n\n\t\tbt_cb(skb)->l2cap.retries = 1;\n\t\tcontrol = &bt_cb(skb)->l2cap;\n\n\t\tif (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))\n\t\t\tcontrol->final = 1;\n\n\t\tcontrol->reqseq = chan->buffer_seq;\n\t\tchan->last_acked_seq = chan->buffer_seq;\n\t\tcontrol->txseq = chan->next_tx_seq;\n\n\t\t__pack_control(chan, control, skb);\n\n\t\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\t\tu16 fcs = crc16(0, (u8 *) skb->data, skb->len);\n\t\t\tput_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));\n\t\t}\n\n\t\t/* Clone after data has been modified. Data is assumed to be\n\t\t   read-only (for locking purposes) on cloned sk_buffs.\n\t\t */\n\t\ttx_skb = skb_clone(skb, GFP_KERNEL);\n\n\t\tif (!tx_skb)\n\t\t\tbreak;\n\n\t\t__set_retrans_timer(chan);\n\n\t\tchan->next_tx_seq = __next_seq(chan, chan->next_tx_seq);\n\t\tchan->unacked_frames++;\n\t\tchan->frames_sent++;\n\t\tsent++;\n\n\t\tif (skb_queue_is_last(&chan->tx_q, skb))\n\t\t\tchan->tx_send_head = NULL;\n\t\telse\n\t\t\tchan->tx_send_head = skb_queue_next(&chan->tx_q, skb);\n\n\t\tl2cap_do_send(chan, tx_skb);\n\t\tBT_DBG(\"Sent txseq %u\", control->txseq);\n\t}\n\n\tBT_DBG(\"Sent %d, %u unacked, %u in ERTM queue\", sent,\n\t       chan->unacked_frames, skb_queue_len(&chan->tx_q));\n\n\treturn sent;\n}\n\nstatic void l2cap_ertm_resend(struct l2cap_chan *chan)\n{\n\tstruct l2cap_ctrl control;\n\tstruct sk_buff *skb;\n\tstruct sk_buff *tx_skb;\n\tu16 seq;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))\n\t\treturn;\n\n\tif (__chan_is_moving(chan))\n\t\treturn;\n\n\twhile (chan->retrans_list.head != L2CAP_SEQ_LIST_CLEAR) {\n\t\tseq = l2cap_seq_list_pop(&chan->retrans_list);\n\n\t\tskb = l2cap_ertm_seq_in_queue(&chan->tx_q, seq);\n\t\tif (!skb) {\n\t\t\tBT_DBG(\"Error: Can't retransmit seq %d, frame missing\",\n\t\t\t       seq);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbt_cb(skb)->l2cap.retries++;\n\t\tcontrol = bt_cb(skb)->l2cap;\n\n\t\tif (chan->max_tx != 0 &&\n\t\t    bt_cb(skb)->l2cap.retries > chan->max_tx) {\n\t\t\tBT_DBG(\"Retry limit exceeded (%d)\", chan->max_tx);\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tl2cap_seq_list_clear(&chan->retrans_list);\n\t\t\tbreak;\n\t\t}\n\n\t\tcontrol.reqseq = chan->buffer_seq;\n\t\tif (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))\n\t\t\tcontrol.final = 1;\n\t\telse\n\t\t\tcontrol.final = 0;\n\n\t\tif (skb_cloned(skb)) {\n\t\t\t/* Cloned sk_buffs are read-only, so we need a\n\t\t\t * writeable copy\n\t\t\t */\n\t\t\ttx_skb = skb_copy(skb, GFP_KERNEL);\n\t\t} else {\n\t\t\ttx_skb = skb_clone(skb, GFP_KERNEL);\n\t\t}\n\n\t\tif (!tx_skb) {\n\t\t\tl2cap_seq_list_clear(&chan->retrans_list);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Update skb contents */\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags)) {\n\t\t\tput_unaligned_le32(__pack_extended_control(&control),\n\t\t\t\t\t   tx_skb->data + L2CAP_HDR_SIZE);\n\t\t} else {\n\t\t\tput_unaligned_le16(__pack_enhanced_control(&control),\n\t\t\t\t\t   tx_skb->data + L2CAP_HDR_SIZE);\n\t\t}\n\n\t\t/* Update FCS */\n\t\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\t\tu16 fcs = crc16(0, (u8 *) tx_skb->data,\n\t\t\t\t\ttx_skb->len - L2CAP_FCS_SIZE);\n\t\t\tput_unaligned_le16(fcs, skb_tail_pointer(tx_skb) -\n\t\t\t\t\t\tL2CAP_FCS_SIZE);\n\t\t}\n\n\t\tl2cap_do_send(chan, tx_skb);\n\n\t\tBT_DBG(\"Resent txseq %d\", control.txseq);\n\n\t\tchan->last_acked_seq = chan->buffer_seq;\n\t}\n}\n\nstatic void l2cap_retransmit(struct l2cap_chan *chan,\n\t\t\t     struct l2cap_ctrl *control)\n{\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tl2cap_seq_list_append(&chan->retrans_list, control->reqseq);\n\tl2cap_ertm_resend(chan);\n}\n\nstatic void l2cap_retransmit_all(struct l2cap_chan *chan,\n\t\t\t\t struct l2cap_ctrl *control)\n{\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tif (control->poll)\n\t\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\n\tl2cap_seq_list_clear(&chan->retrans_list);\n\n\tif (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))\n\t\treturn;\n\n\tif (chan->unacked_frames) {\n\t\tskb_queue_walk(&chan->tx_q, skb) {\n\t\t\tif (bt_cb(skb)->l2cap.txseq == control->reqseq ||\n\t\t\t    skb == chan->tx_send_head)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tskb_queue_walk_from(&chan->tx_q, skb) {\n\t\t\tif (skb == chan->tx_send_head)\n\t\t\t\tbreak;\n\n\t\t\tl2cap_seq_list_append(&chan->retrans_list,\n\t\t\t\t\t      bt_cb(skb)->l2cap.txseq);\n\t\t}\n\n\t\tl2cap_ertm_resend(chan);\n\t}\n}\n\nstatic void l2cap_send_ack(struct l2cap_chan *chan)\n{\n\tstruct l2cap_ctrl control;\n\tu16 frames_to_ack = __seq_offset(chan, chan->buffer_seq,\n\t\t\t\t\t chan->last_acked_seq);\n\tint threshold;\n\n\tBT_DBG(\"chan %p last_acked_seq %d buffer_seq %d\",\n\t       chan, chan->last_acked_seq, chan->buffer_seq);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\n\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state) &&\n\t    chan->rx_state == L2CAP_RX_STATE_RECV) {\n\t\t__clear_ack_timer(chan);\n\t\tcontrol.super = L2CAP_SUPER_RNR;\n\t\tcontrol.reqseq = chan->buffer_seq;\n\t\tl2cap_send_sframe(chan, &control);\n\t} else {\n\t\tif (!test_bit(CONN_REMOTE_BUSY, &chan->conn_state)) {\n\t\t\tl2cap_ertm_send(chan);\n\t\t\t/* If any i-frames were sent, they included an ack */\n\t\t\tif (chan->buffer_seq == chan->last_acked_seq)\n\t\t\t\tframes_to_ack = 0;\n\t\t}\n\n\t\t/* Ack now if the window is 3/4ths full.\n\t\t * Calculate without mul or div\n\t\t */\n\t\tthreshold = chan->ack_win;\n\t\tthreshold += threshold << 1;\n\t\tthreshold >>= 2;\n\n\t\tBT_DBG(\"frames_to_ack %u, threshold %d\", frames_to_ack,\n\t\t       threshold);\n\n\t\tif (frames_to_ack >= threshold) {\n\t\t\t__clear_ack_timer(chan);\n\t\t\tcontrol.super = L2CAP_SUPER_RR;\n\t\t\tcontrol.reqseq = chan->buffer_seq;\n\t\t\tl2cap_send_sframe(chan, &control);\n\t\t\tframes_to_ack = 0;\n\t\t}\n\n\t\tif (frames_to_ack)\n\t\t\t__set_ack_timer(chan);\n\t}\n}\n\nstatic inline int l2cap_skbuff_fromiovec(struct l2cap_chan *chan,\n\t\t\t\t\t struct msghdr *msg, int len,\n\t\t\t\t\t int count, struct sk_buff *skb)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff **frag;\n\tint sent = 0;\n\n\tif (!copy_from_iter_full(skb_put(skb, count), count, &msg->msg_iter))\n\t\treturn -EFAULT;\n\n\tsent += count;\n\tlen  -= count;\n\n\t/* Continuation fragments (no L2CAP header) */\n\tfrag = &skb_shinfo(skb)->frag_list;\n\twhile (len) {\n\t\tstruct sk_buff *tmp;\n\n\t\tcount = min_t(unsigned int, conn->mtu, len);\n\n\t\ttmp = chan->ops->alloc_skb(chan, 0, count,\n\t\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn PTR_ERR(tmp);\n\n\t\t*frag = tmp;\n\n\t\tif (!copy_from_iter_full(skb_put(*frag, count), count,\n\t\t\t\t   &msg->msg_iter))\n\t\t\treturn -EFAULT;\n\n\t\tsent += count;\n\t\tlen  -= count;\n\n\t\tskb->len += (*frag)->len;\n\t\tskb->data_len += (*frag)->len;\n\n\t\tfrag = &(*frag)->next;\n\t}\n\n\treturn sent;\n}\n\nstatic struct sk_buff *l2cap_create_connless_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t\t struct msghdr *msg, size_t len)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff *skb;\n\tint err, count, hlen = L2CAP_HDR_SIZE + L2CAP_PSMLEN_SIZE;\n\tstruct l2cap_hdr *lh;\n\n\tBT_DBG(\"chan %p psm 0x%2.2x len %zu\", chan,\n\t       __le16_to_cpu(chan->psm), len);\n\n\tcount = min_t(unsigned int, (conn->mtu - hlen), len);\n\n\tskb = chan->ops->alloc_skb(chan, hlen, count,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\t/* Create L2CAP header */\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\tlh->len = cpu_to_le16(len + L2CAP_PSMLEN_SIZE);\n\tput_unaligned(chan->psm, (__le16 *) skb_put(skb, L2CAP_PSMLEN_SIZE));\n\n\terr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\n\tif (unlikely(err < 0)) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn skb;\n}\n\nstatic struct sk_buff *l2cap_create_basic_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t      struct msghdr *msg, size_t len)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff *skb;\n\tint err, count;\n\tstruct l2cap_hdr *lh;\n\n\tBT_DBG(\"chan %p len %zu\", chan, len);\n\n\tcount = min_t(unsigned int, (conn->mtu - L2CAP_HDR_SIZE), len);\n\n\tskb = chan->ops->alloc_skb(chan, L2CAP_HDR_SIZE, count,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\t/* Create L2CAP header */\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\tlh->len = cpu_to_le16(len);\n\n\terr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\n\tif (unlikely(err < 0)) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn skb;\n}\n\nstatic struct sk_buff *l2cap_create_iframe_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t       struct msghdr *msg, size_t len,\n\t\t\t\t\t       u16 sdulen)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff *skb;\n\tint err, count, hlen;\n\tstruct l2cap_hdr *lh;\n\n\tBT_DBG(\"chan %p len %zu\", chan, len);\n\n\tif (!conn)\n\t\treturn ERR_PTR(-ENOTCONN);\n\n\thlen = __ertm_hdr_size(chan);\n\n\tif (sdulen)\n\t\thlen += L2CAP_SDULEN_SIZE;\n\n\tif (chan->fcs == L2CAP_FCS_CRC16)\n\t\thlen += L2CAP_FCS_SIZE;\n\n\tcount = min_t(unsigned int, (conn->mtu - hlen), len);\n\n\tskb = chan->ops->alloc_skb(chan, hlen, count,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\t/* Create L2CAP header */\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\tlh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));\n\n\t/* Control header is populated later */\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\tput_unaligned_le32(0, skb_put(skb, L2CAP_EXT_CTRL_SIZE));\n\telse\n\t\tput_unaligned_le16(0, skb_put(skb, L2CAP_ENH_CTRL_SIZE));\n\n\tif (sdulen)\n\t\tput_unaligned_le16(sdulen, skb_put(skb, L2CAP_SDULEN_SIZE));\n\n\terr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\n\tif (unlikely(err < 0)) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tbt_cb(skb)->l2cap.fcs = chan->fcs;\n\tbt_cb(skb)->l2cap.retries = 0;\n\treturn skb;\n}\n\nstatic int l2cap_segment_sdu(struct l2cap_chan *chan,\n\t\t\t     struct sk_buff_head *seg_queue,\n\t\t\t     struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tu16 sdu_len;\n\tsize_t pdu_len;\n\tu8 sar;\n\n\tBT_DBG(\"chan %p, msg %p, len %zu\", chan, msg, len);\n\n\t/* It is critical that ERTM PDUs fit in a single HCI fragment,\n\t * so fragmented skbs are not used.  The HCI layer's handling\n\t * of fragmented skbs is not compatible with ERTM's queueing.\n\t */\n\n\t/* PDU size is derived from the HCI MTU */\n\tpdu_len = chan->conn->mtu;\n\n\t/* Constrain PDU size for BR/EDR connections */\n\tif (!chan->hs_hcon)\n\t\tpdu_len = min_t(size_t, pdu_len, L2CAP_BREDR_MAX_PAYLOAD);\n\n\t/* Adjust for largest possible L2CAP overhead. */\n\tif (chan->fcs)\n\t\tpdu_len -= L2CAP_FCS_SIZE;\n\n\tpdu_len -= __ertm_hdr_size(chan);\n\n\t/* Remote device may have requested smaller PDUs */\n\tpdu_len = min_t(size_t, pdu_len, chan->remote_mps);\n\n\tif (len <= pdu_len) {\n\t\tsar = L2CAP_SAR_UNSEGMENTED;\n\t\tsdu_len = 0;\n\t\tpdu_len = len;\n\t} else {\n\t\tsar = L2CAP_SAR_START;\n\t\tsdu_len = len;\n\t}\n\n\twhile (len > 0) {\n\t\tskb = l2cap_create_iframe_pdu(chan, msg, pdu_len, sdu_len);\n\n\t\tif (IS_ERR(skb)) {\n\t\t\t__skb_queue_purge(seg_queue);\n\t\t\treturn PTR_ERR(skb);\n\t\t}\n\n\t\tbt_cb(skb)->l2cap.sar = sar;\n\t\t__skb_queue_tail(seg_queue, skb);\n\n\t\tlen -= pdu_len;\n\t\tif (sdu_len)\n\t\t\tsdu_len = 0;\n\n\t\tif (len <= pdu_len) {\n\t\t\tsar = L2CAP_SAR_END;\n\t\t\tpdu_len = len;\n\t\t} else {\n\t\t\tsar = L2CAP_SAR_CONTINUE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct sk_buff *l2cap_create_le_flowctl_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t\t   struct msghdr *msg,\n\t\t\t\t\t\t   size_t len, u16 sdulen)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff *skb;\n\tint err, count, hlen;\n\tstruct l2cap_hdr *lh;\n\n\tBT_DBG(\"chan %p len %zu\", chan, len);\n\n\tif (!conn)\n\t\treturn ERR_PTR(-ENOTCONN);\n\n\thlen = L2CAP_HDR_SIZE;\n\n\tif (sdulen)\n\t\thlen += L2CAP_SDULEN_SIZE;\n\n\tcount = min_t(unsigned int, (conn->mtu - hlen), len);\n\n\tskb = chan->ops->alloc_skb(chan, hlen, count,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\t/* Create L2CAP header */\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\tlh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));\n\n\tif (sdulen)\n\t\tput_unaligned_le16(sdulen, skb_put(skb, L2CAP_SDULEN_SIZE));\n\n\terr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\n\tif (unlikely(err < 0)) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic int l2cap_segment_le_sdu(struct l2cap_chan *chan,\n\t\t\t\tstruct sk_buff_head *seg_queue,\n\t\t\t\tstruct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tsize_t pdu_len;\n\tu16 sdu_len;\n\n\tBT_DBG(\"chan %p, msg %p, len %zu\", chan, msg, len);\n\n\tsdu_len = len;\n\tpdu_len = chan->remote_mps - L2CAP_SDULEN_SIZE;\n\n\twhile (len > 0) {\n\t\tif (len <= pdu_len)\n\t\t\tpdu_len = len;\n\n\t\tskb = l2cap_create_le_flowctl_pdu(chan, msg, pdu_len, sdu_len);\n\t\tif (IS_ERR(skb)) {\n\t\t\t__skb_queue_purge(seg_queue);\n\t\t\treturn PTR_ERR(skb);\n\t\t}\n\n\t\t__skb_queue_tail(seg_queue, skb);\n\n\t\tlen -= pdu_len;\n\n\t\tif (sdu_len) {\n\t\t\tsdu_len = 0;\n\t\t\tpdu_len += L2CAP_SDULEN_SIZE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void l2cap_le_flowctl_send(struct l2cap_chan *chan)\n{\n\tint sent = 0;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twhile (chan->tx_credits && !skb_queue_empty(&chan->tx_q)) {\n\t\tl2cap_do_send(chan, skb_dequeue(&chan->tx_q));\n\t\tchan->tx_credits--;\n\t\tsent++;\n\t}\n\n\tBT_DBG(\"Sent %d credits %u queued %u\", sent, chan->tx_credits,\n\t       skb_queue_len(&chan->tx_q));\n}\n\nint l2cap_chan_send(struct l2cap_chan *chan, struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct sk_buff_head seg_queue;\n\n\tif (!chan->conn)\n\t\treturn -ENOTCONN;\n\n\t/* Connectionless channel */\n\tif (chan->chan_type == L2CAP_CHAN_CONN_LESS) {\n\t\tskb = l2cap_create_connless_pdu(chan, msg, len);\n\t\tif (IS_ERR(skb))\n\t\t\treturn PTR_ERR(skb);\n\n\t\t/* Channel lock is released before requesting new skb and then\n\t\t * reacquired thus we need to recheck channel state.\n\t\t */\n\t\tif (chan->state != BT_CONNECTED) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\n\t\tl2cap_do_send(chan, skb);\n\t\treturn len;\n\t}\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\t/* Check outgoing MTU */\n\t\tif (len > chan->omtu)\n\t\t\treturn -EMSGSIZE;\n\n\t\t__skb_queue_head_init(&seg_queue);\n\n\t\terr = l2cap_segment_le_sdu(chan, &seg_queue, msg, len);\n\n\t\tif (chan->state != BT_CONNECTED) {\n\t\t\t__skb_queue_purge(&seg_queue);\n\t\t\terr = -ENOTCONN;\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tskb_queue_splice_tail_init(&seg_queue, &chan->tx_q);\n\n\t\tl2cap_le_flowctl_send(chan);\n\n\t\tif (!chan->tx_credits)\n\t\t\tchan->ops->suspend(chan);\n\n\t\terr = len;\n\n\t\tbreak;\n\n\tcase L2CAP_MODE_BASIC:\n\t\t/* Check outgoing MTU */\n\t\tif (len > chan->omtu)\n\t\t\treturn -EMSGSIZE;\n\n\t\t/* Create a basic PDU */\n\t\tskb = l2cap_create_basic_pdu(chan, msg, len);\n\t\tif (IS_ERR(skb))\n\t\t\treturn PTR_ERR(skb);\n\n\t\t/* Channel lock is released before requesting new skb and then\n\t\t * reacquired thus we need to recheck channel state.\n\t\t */\n\t\tif (chan->state != BT_CONNECTED) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\n\t\tl2cap_do_send(chan, skb);\n\t\terr = len;\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\t/* Check outgoing MTU */\n\t\tif (len > chan->omtu) {\n\t\t\terr = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\n\t\t__skb_queue_head_init(&seg_queue);\n\n\t\t/* Do segmentation before calling in to the state machine,\n\t\t * since it's possible to block while waiting for memory\n\t\t * allocation.\n\t\t */\n\t\terr = l2cap_segment_sdu(chan, &seg_queue, msg, len);\n\n\t\t/* The channel could have been closed while segmenting,\n\t\t * check that it is still connected.\n\t\t */\n\t\tif (chan->state != BT_CONNECTED) {\n\t\t\t__skb_queue_purge(&seg_queue);\n\t\t\terr = -ENOTCONN;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (chan->mode == L2CAP_MODE_ERTM)\n\t\t\tl2cap_tx(chan, NULL, &seg_queue, L2CAP_EV_DATA_REQUEST);\n\t\telse\n\t\t\tl2cap_streaming_send(chan, &seg_queue);\n\n\t\terr = len;\n\n\t\t/* If the skbs were not queued for sending, they'll still be in\n\t\t * seg_queue and need to be purged.\n\t\t */\n\t\t__skb_queue_purge(&seg_queue);\n\t\tbreak;\n\n\tdefault:\n\t\tBT_DBG(\"bad state %1.1x\", chan->mode);\n\t\terr = -EBADFD;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_send);\n\nstatic void l2cap_send_srej(struct l2cap_chan *chan, u16 txseq)\n{\n\tstruct l2cap_ctrl control;\n\tu16 seq;\n\n\tBT_DBG(\"chan %p, txseq %u\", chan, txseq);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.super = L2CAP_SUPER_SREJ;\n\n\tfor (seq = chan->expected_tx_seq; seq != txseq;\n\t     seq = __next_seq(chan, seq)) {\n\t\tif (!l2cap_ertm_seq_in_queue(&chan->srej_q, seq)) {\n\t\t\tcontrol.reqseq = seq;\n\t\t\tl2cap_send_sframe(chan, &control);\n\t\t\tl2cap_seq_list_append(&chan->srej_list, seq);\n\t\t}\n\t}\n\n\tchan->expected_tx_seq = __next_seq(chan, txseq);\n}\n\nstatic void l2cap_send_srej_tail(struct l2cap_chan *chan)\n{\n\tstruct l2cap_ctrl control;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->srej_list.tail == L2CAP_SEQ_LIST_CLEAR)\n\t\treturn;\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.super = L2CAP_SUPER_SREJ;\n\tcontrol.reqseq = chan->srej_list.tail;\n\tl2cap_send_sframe(chan, &control);\n}\n\nstatic void l2cap_send_srej_list(struct l2cap_chan *chan, u16 txseq)\n{\n\tstruct l2cap_ctrl control;\n\tu16 initial_head;\n\tu16 seq;\n\n\tBT_DBG(\"chan %p, txseq %u\", chan, txseq);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.super = L2CAP_SUPER_SREJ;\n\n\t/* Capture initial list head to allow only one pass through the list. */\n\tinitial_head = chan->srej_list.head;\n\n\tdo {\n\t\tseq = l2cap_seq_list_pop(&chan->srej_list);\n\t\tif (seq == txseq || seq == L2CAP_SEQ_LIST_CLEAR)\n\t\t\tbreak;\n\n\t\tcontrol.reqseq = seq;\n\t\tl2cap_send_sframe(chan, &control);\n\t\tl2cap_seq_list_append(&chan->srej_list, seq);\n\t} while (chan->srej_list.head != initial_head);\n}\n\nstatic void l2cap_process_reqseq(struct l2cap_chan *chan, u16 reqseq)\n{\n\tstruct sk_buff *acked_skb;\n\tu16 ackseq;\n\n\tBT_DBG(\"chan %p, reqseq %u\", chan, reqseq);\n\n\tif (chan->unacked_frames == 0 || reqseq == chan->expected_ack_seq)\n\t\treturn;\n\n\tBT_DBG(\"expected_ack_seq %u, unacked_frames %u\",\n\t       chan->expected_ack_seq, chan->unacked_frames);\n\n\tfor (ackseq = chan->expected_ack_seq; ackseq != reqseq;\n\t     ackseq = __next_seq(chan, ackseq)) {\n\n\t\tacked_skb = l2cap_ertm_seq_in_queue(&chan->tx_q, ackseq);\n\t\tif (acked_skb) {\n\t\t\tskb_unlink(acked_skb, &chan->tx_q);\n\t\t\tkfree_skb(acked_skb);\n\t\t\tchan->unacked_frames--;\n\t\t}\n\t}\n\n\tchan->expected_ack_seq = reqseq;\n\n\tif (chan->unacked_frames == 0)\n\t\t__clear_retrans_timer(chan);\n\n\tBT_DBG(\"unacked_frames %u\", chan->unacked_frames);\n}\n\nstatic void l2cap_abort_rx_srej_sent(struct l2cap_chan *chan)\n{\n\tBT_DBG(\"chan %p\", chan);\n\n\tchan->expected_tx_seq = chan->buffer_seq;\n\tl2cap_seq_list_clear(&chan->srej_list);\n\tskb_queue_purge(&chan->srej_q);\n\tchan->rx_state = L2CAP_RX_STATE_RECV;\n}\n\nstatic void l2cap_tx_state_xmit(struct l2cap_chan *chan,\n\t\t\t\tstruct l2cap_ctrl *control,\n\t\t\t\tstruct sk_buff_head *skbs, u8 event)\n{\n\tBT_DBG(\"chan %p, control %p, skbs %p, event %d\", chan, control, skbs,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_DATA_REQUEST:\n\t\tif (chan->tx_send_head == NULL)\n\t\t\tchan->tx_send_head = skb_peek(skbs);\n\n\t\tskb_queue_splice_tail_init(skbs, &chan->tx_q);\n\t\tl2cap_ertm_send(chan);\n\t\tbreak;\n\tcase L2CAP_EV_LOCAL_BUSY_DETECTED:\n\t\tBT_DBG(\"Enter LOCAL_BUSY\");\n\t\tset_bit(CONN_LOCAL_BUSY, &chan->conn_state);\n\n\t\tif (chan->rx_state == L2CAP_RX_STATE_SREJ_SENT) {\n\t\t\t/* The SREJ_SENT state must be aborted if we are to\n\t\t\t * enter the LOCAL_BUSY state.\n\t\t\t */\n\t\t\tl2cap_abort_rx_srej_sent(chan);\n\t\t}\n\n\t\tl2cap_send_ack(chan);\n\n\t\tbreak;\n\tcase L2CAP_EV_LOCAL_BUSY_CLEAR:\n\t\tBT_DBG(\"Exit LOCAL_BUSY\");\n\t\tclear_bit(CONN_LOCAL_BUSY, &chan->conn_state);\n\n\t\tif (test_bit(CONN_RNR_SENT, &chan->conn_state)) {\n\t\t\tstruct l2cap_ctrl local_control;\n\n\t\t\tmemset(&local_control, 0, sizeof(local_control));\n\t\t\tlocal_control.sframe = 1;\n\t\t\tlocal_control.super = L2CAP_SUPER_RR;\n\t\t\tlocal_control.poll = 1;\n\t\t\tlocal_control.reqseq = chan->buffer_seq;\n\t\t\tl2cap_send_sframe(chan, &local_control);\n\n\t\t\tchan->retry_count = 1;\n\t\t\t__set_monitor_timer(chan);\n\t\t\tchan->tx_state = L2CAP_TX_STATE_WAIT_F;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_REQSEQ_AND_FBIT:\n\t\tl2cap_process_reqseq(chan, control->reqseq);\n\t\tbreak;\n\tcase L2CAP_EV_EXPLICIT_POLL:\n\t\tl2cap_send_rr_or_rnr(chan, 1);\n\t\tchan->retry_count = 1;\n\t\t__set_monitor_timer(chan);\n\t\t__clear_ack_timer(chan);\n\t\tchan->tx_state = L2CAP_TX_STATE_WAIT_F;\n\t\tbreak;\n\tcase L2CAP_EV_RETRANS_TO:\n\t\tl2cap_send_rr_or_rnr(chan, 1);\n\t\tchan->retry_count = 1;\n\t\t__set_monitor_timer(chan);\n\t\tchan->tx_state = L2CAP_TX_STATE_WAIT_F;\n\t\tbreak;\n\tcase L2CAP_EV_RECV_FBIT:\n\t\t/* Nothing to process */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_tx_state_wait_f(struct l2cap_chan *chan,\n\t\t\t\t  struct l2cap_ctrl *control,\n\t\t\t\t  struct sk_buff_head *skbs, u8 event)\n{\n\tBT_DBG(\"chan %p, control %p, skbs %p, event %d\", chan, control, skbs,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_DATA_REQUEST:\n\t\tif (chan->tx_send_head == NULL)\n\t\t\tchan->tx_send_head = skb_peek(skbs);\n\t\t/* Queue data, but don't send. */\n\t\tskb_queue_splice_tail_init(skbs, &chan->tx_q);\n\t\tbreak;\n\tcase L2CAP_EV_LOCAL_BUSY_DETECTED:\n\t\tBT_DBG(\"Enter LOCAL_BUSY\");\n\t\tset_bit(CONN_LOCAL_BUSY, &chan->conn_state);\n\n\t\tif (chan->rx_state == L2CAP_RX_STATE_SREJ_SENT) {\n\t\t\t/* The SREJ_SENT state must be aborted if we are to\n\t\t\t * enter the LOCAL_BUSY state.\n\t\t\t */\n\t\t\tl2cap_abort_rx_srej_sent(chan);\n\t\t}\n\n\t\tl2cap_send_ack(chan);\n\n\t\tbreak;\n\tcase L2CAP_EV_LOCAL_BUSY_CLEAR:\n\t\tBT_DBG(\"Exit LOCAL_BUSY\");\n\t\tclear_bit(CONN_LOCAL_BUSY, &chan->conn_state);\n\n\t\tif (test_bit(CONN_RNR_SENT, &chan->conn_state)) {\n\t\t\tstruct l2cap_ctrl local_control;\n\t\t\tmemset(&local_control, 0, sizeof(local_control));\n\t\t\tlocal_control.sframe = 1;\n\t\t\tlocal_control.super = L2CAP_SUPER_RR;\n\t\t\tlocal_control.poll = 1;\n\t\t\tlocal_control.reqseq = chan->buffer_seq;\n\t\t\tl2cap_send_sframe(chan, &local_control);\n\n\t\t\tchan->retry_count = 1;\n\t\t\t__set_monitor_timer(chan);\n\t\t\tchan->tx_state = L2CAP_TX_STATE_WAIT_F;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_REQSEQ_AND_FBIT:\n\t\tl2cap_process_reqseq(chan, control->reqseq);\n\t\tfallthrough;\n\n\tcase L2CAP_EV_RECV_FBIT:\n\t\tif (control && control->final) {\n\t\t\t__clear_monitor_timer(chan);\n\t\t\tif (chan->unacked_frames > 0)\n\t\t\t\t__set_retrans_timer(chan);\n\t\t\tchan->retry_count = 0;\n\t\t\tchan->tx_state = L2CAP_TX_STATE_XMIT;\n\t\t\tBT_DBG(\"recv fbit tx_state 0x2.2%x\", chan->tx_state);\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_EXPLICIT_POLL:\n\t\t/* Ignore */\n\t\tbreak;\n\tcase L2CAP_EV_MONITOR_TO:\n\t\tif (chan->max_tx == 0 || chan->retry_count < chan->max_tx) {\n\t\t\tl2cap_send_rr_or_rnr(chan, 1);\n\t\t\t__set_monitor_timer(chan);\n\t\t\tchan->retry_count++;\n\t\t} else {\n\t\t\tl2cap_send_disconn_req(chan, ECONNABORTED);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_tx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\n\t\t     struct sk_buff_head *skbs, u8 event)\n{\n\tBT_DBG(\"chan %p, control %p, skbs %p, event %d, state %d\",\n\t       chan, control, skbs, event, chan->tx_state);\n\n\tswitch (chan->tx_state) {\n\tcase L2CAP_TX_STATE_XMIT:\n\t\tl2cap_tx_state_xmit(chan, control, skbs, event);\n\t\tbreak;\n\tcase L2CAP_TX_STATE_WAIT_F:\n\t\tl2cap_tx_state_wait_f(chan, control, skbs, event);\n\t\tbreak;\n\tdefault:\n\t\t/* Ignore event */\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_pass_to_tx(struct l2cap_chan *chan,\n\t\t\t     struct l2cap_ctrl *control)\n{\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\tl2cap_tx(chan, control, NULL, L2CAP_EV_RECV_REQSEQ_AND_FBIT);\n}\n\nstatic void l2cap_pass_to_tx_fbit(struct l2cap_chan *chan,\n\t\t\t\t  struct l2cap_ctrl *control)\n{\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\tl2cap_tx(chan, control, NULL, L2CAP_EV_RECV_FBIT);\n}\n\n/* Copy frame to all raw sockets on that connection */\nstatic void l2cap_raw_recv(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct sk_buff *nskb;\n\tstruct l2cap_chan *chan;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tif (chan->chan_type != L2CAP_CHAN_RAW)\n\t\t\tcontinue;\n\n\t\t/* Don't send frame to the channel it came from */\n\t\tif (bt_cb(skb)->l2cap.chan == chan)\n\t\t\tcontinue;\n\n\t\tnskb = skb_clone(skb, GFP_KERNEL);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\t\tif (chan->ops->recv(chan, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\n/* ---- L2CAP signalling commands ---- */\nstatic struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn, u8 code,\n\t\t\t\t       u8 ident, u16 dlen, void *data)\n{\n\tstruct sk_buff *skb, **frag;\n\tstruct l2cap_cmd_hdr *cmd;\n\tstruct l2cap_hdr *lh;\n\tint len, count;\n\n\tBT_DBG(\"conn %p, code 0x%2.2x, ident 0x%2.2x, len %u\",\n\t       conn, code, ident, dlen);\n\n\tif (conn->mtu < L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE)\n\t\treturn NULL;\n\n\tlen = L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE + dlen;\n\tcount = min_t(unsigned int, conn->mtu, len);\n\n\tskb = bt_skb_alloc(count, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->len = cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);\n\n\tif (conn->hcon->type == LE_LINK)\n\t\tlh->cid = cpu_to_le16(L2CAP_CID_LE_SIGNALING);\n\telse\n\t\tlh->cid = cpu_to_le16(L2CAP_CID_SIGNALING);\n\n\tcmd = skb_put(skb, L2CAP_CMD_HDR_SIZE);\n\tcmd->code  = code;\n\tcmd->ident = ident;\n\tcmd->len   = cpu_to_le16(dlen);\n\n\tif (dlen) {\n\t\tcount -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;\n\t\tskb_put_data(skb, data, count);\n\t\tdata += count;\n\t}\n\n\tlen -= skb->len;\n\n\t/* Continuation fragments (no L2CAP header) */\n\tfrag = &skb_shinfo(skb)->frag_list;\n\twhile (len) {\n\t\tcount = min_t(unsigned int, conn->mtu, len);\n\n\t\t*frag = bt_skb_alloc(count, GFP_KERNEL);\n\t\tif (!*frag)\n\t\t\tgoto fail;\n\n\t\tskb_put_data(*frag, data, count);\n\n\t\tlen  -= count;\n\t\tdata += count;\n\n\t\tfrag = &(*frag)->next;\n\t}\n\n\treturn skb;\n\nfail:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstatic inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen,\n\t\t\t\t     unsigned long *val)\n{\n\tstruct l2cap_conf_opt *opt = *ptr;\n\tint len;\n\n\tlen = L2CAP_CONF_OPT_SIZE + opt->len;\n\t*ptr += len;\n\n\t*type = opt->type;\n\t*olen = opt->len;\n\n\tswitch (opt->len) {\n\tcase 1:\n\t\t*val = *((u8 *) opt->val);\n\t\tbreak;\n\n\tcase 2:\n\t\t*val = get_unaligned_le16(opt->val);\n\t\tbreak;\n\n\tcase 4:\n\t\t*val = get_unaligned_le32(opt->val);\n\t\tbreak;\n\n\tdefault:\n\t\t*val = (unsigned long) opt->val;\n\t\tbreak;\n\t}\n\n\tBT_DBG(\"type 0x%2.2x len %u val 0x%lx\", *type, opt->len, *val);\n\treturn len;\n}\n\nstatic void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val, size_t size)\n{\n\tstruct l2cap_conf_opt *opt = *ptr;\n\n\tBT_DBG(\"type 0x%2.2x len %u val 0x%lx\", type, len, val);\n\n\tif (size < L2CAP_CONF_OPT_SIZE + len)\n\t\treturn;\n\n\topt->type = type;\n\topt->len  = len;\n\n\tswitch (len) {\n\tcase 1:\n\t\t*((u8 *) opt->val)  = val;\n\t\tbreak;\n\n\tcase 2:\n\t\tput_unaligned_le16(val, opt->val);\n\t\tbreak;\n\n\tcase 4:\n\t\tput_unaligned_le32(val, opt->val);\n\t\tbreak;\n\n\tdefault:\n\t\tmemcpy(opt->val, (void *) val, len);\n\t\tbreak;\n\t}\n\n\t*ptr += L2CAP_CONF_OPT_SIZE + len;\n}\n\nstatic void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan, size_t size)\n{\n\tstruct l2cap_conf_efs efs;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tefs.id\t\t= chan->local_id;\n\t\tefs.stype\t= chan->local_stype;\n\t\tefs.msdu\t= cpu_to_le16(chan->local_msdu);\n\t\tefs.sdu_itime\t= cpu_to_le32(chan->local_sdu_itime);\n\t\tefs.acc_lat\t= cpu_to_le32(L2CAP_DEFAULT_ACC_LAT);\n\t\tefs.flush_to\t= cpu_to_le32(L2CAP_EFS_DEFAULT_FLUSH_TO);\n\t\tbreak;\n\n\tcase L2CAP_MODE_STREAMING:\n\t\tefs.id\t\t= 1;\n\t\tefs.stype\t= L2CAP_SERV_BESTEFFORT;\n\t\tefs.msdu\t= cpu_to_le16(chan->local_msdu);\n\t\tefs.sdu_itime\t= cpu_to_le32(chan->local_sdu_itime);\n\t\tefs.acc_lat\t= 0;\n\t\tefs.flush_to\t= 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tl2cap_add_conf_opt(ptr, L2CAP_CONF_EFS, sizeof(efs),\n\t\t\t   (unsigned long) &efs, size);\n}\n\nstatic void l2cap_ack_timeout(struct work_struct *work)\n{\n\tstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\n\t\t\t\t\t       ack_timer.work);\n\tu16 frames_to_ack;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tl2cap_chan_lock(chan);\n\n\tframes_to_ack = __seq_offset(chan, chan->buffer_seq,\n\t\t\t\t     chan->last_acked_seq);\n\n\tif (frames_to_ack)\n\t\tl2cap_send_rr_or_rnr(chan, 0);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nint l2cap_ertm_init(struct l2cap_chan *chan)\n{\n\tint err;\n\n\tchan->next_tx_seq = 0;\n\tchan->expected_tx_seq = 0;\n\tchan->expected_ack_seq = 0;\n\tchan->unacked_frames = 0;\n\tchan->buffer_seq = 0;\n\tchan->frames_sent = 0;\n\tchan->last_acked_seq = 0;\n\tchan->sdu = NULL;\n\tchan->sdu_last_frag = NULL;\n\tchan->sdu_len = 0;\n\n\tskb_queue_head_init(&chan->tx_q);\n\n\tchan->local_amp_id = AMP_ID_BREDR;\n\tchan->move_id = AMP_ID_BREDR;\n\tchan->move_state = L2CAP_MOVE_STABLE;\n\tchan->move_role = L2CAP_MOVE_ROLE_NONE;\n\n\tif (chan->mode != L2CAP_MODE_ERTM)\n\t\treturn 0;\n\n\tchan->rx_state = L2CAP_RX_STATE_RECV;\n\tchan->tx_state = L2CAP_TX_STATE_XMIT;\n\n\tskb_queue_head_init(&chan->srej_q);\n\n\terr = l2cap_seq_list_init(&chan->srej_list, chan->tx_win);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = l2cap_seq_list_init(&chan->retrans_list, chan->remote_tx_win);\n\tif (err < 0)\n\t\tl2cap_seq_list_free(&chan->srej_list);\n\n\treturn err;\n}\n\nstatic inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)\n{\n\tswitch (mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (l2cap_mode_supported(mode, remote_feat_mask))\n\t\t\treturn mode;\n\t\tfallthrough;\n\tdefault:\n\t\treturn L2CAP_MODE_BASIC;\n\t}\n}\n\nstatic inline bool __l2cap_ews_supported(struct l2cap_conn *conn)\n{\n\treturn ((conn->local_fixed_chan & L2CAP_FC_A2MP) &&\n\t\t(conn->feat_mask & L2CAP_FEAT_EXT_WINDOW));\n}\n\nstatic inline bool __l2cap_efs_supported(struct l2cap_conn *conn)\n{\n\treturn ((conn->local_fixed_chan & L2CAP_FC_A2MP) &&\n\t\t(conn->feat_mask & L2CAP_FEAT_EXT_FLOW));\n}\n\nstatic void __l2cap_set_ertm_timeouts(struct l2cap_chan *chan,\n\t\t\t\t      struct l2cap_conf_rfc *rfc)\n{\n\tif (chan->local_amp_id != AMP_ID_BREDR && chan->hs_hcon) {\n\t\tu64 ertm_to = chan->hs_hcon->hdev->amp_be_flush_to;\n\n\t\t/* Class 1 devices have must have ERTM timeouts\n\t\t * exceeding the Link Supervision Timeout.  The\n\t\t * default Link Supervision Timeout for AMP\n\t\t * controllers is 10 seconds.\n\t\t *\n\t\t * Class 1 devices use 0xffffffff for their\n\t\t * best-effort flush timeout, so the clamping logic\n\t\t * will result in a timeout that meets the above\n\t\t * requirement.  ERTM timeouts are 16-bit values, so\n\t\t * the maximum timeout is 65.535 seconds.\n\t\t */\n\n\t\t/* Convert timeout to milliseconds and round */\n\t\tertm_to = DIV_ROUND_UP_ULL(ertm_to, 1000);\n\n\t\t/* This is the recommended formula for class 2 devices\n\t\t * that start ERTM timers when packets are sent to the\n\t\t * controller.\n\t\t */\n\t\tertm_to = 3 * ertm_to + 500;\n\n\t\tif (ertm_to > 0xffff)\n\t\t\tertm_to = 0xffff;\n\n\t\trfc->retrans_timeout = cpu_to_le16((u16) ertm_to);\n\t\trfc->monitor_timeout = rfc->retrans_timeout;\n\t} else {\n\t\trfc->retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);\n\t\trfc->monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);\n\t}\n}\n\nstatic inline void l2cap_txwin_setup(struct l2cap_chan *chan)\n{\n\tif (chan->tx_win > L2CAP_DEFAULT_TX_WINDOW &&\n\t    __l2cap_ews_supported(chan->conn)) {\n\t\t/* use extended control field */\n\t\tset_bit(FLAG_EXT_CTRL, &chan->flags);\n\t\tchan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;\n\t} else {\n\t\tchan->tx_win = min_t(u16, chan->tx_win,\n\t\t\t\t     L2CAP_DEFAULT_TX_WINDOW);\n\t\tchan->tx_win_max = L2CAP_DEFAULT_TX_WINDOW;\n\t}\n\tchan->ack_win = chan->tx_win;\n}\n\nstatic void l2cap_mtu_auto(struct l2cap_chan *chan)\n{\n\tstruct hci_conn *conn = chan->conn->hcon;\n\n\tchan->imtu = L2CAP_DEFAULT_MIN_MTU;\n\n\t/* The 2-DH1 packet has between 2 and 56 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_2DH1))\n\t\tchan->imtu = 54;\n\n\t/* The 3-DH1 packet has between 2 and 85 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_3DH1))\n\t\tchan->imtu = 83;\n\n\t/* The 2-DH3 packet has between 2 and 369 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_2DH3))\n\t\tchan->imtu = 367;\n\n\t/* The 3-DH3 packet has between 2 and 554 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_3DH3))\n\t\tchan->imtu = 552;\n\n\t/* The 2-DH5 packet has between 2 and 681 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_2DH5))\n\t\tchan->imtu = 679;\n\n\t/* The 3-DH5 packet has between 2 and 1023 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_3DH5))\n\t\tchan->imtu = 1021;\n}\n\nstatic int l2cap_build_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)\n{\n\tstruct l2cap_conf_req *req = data;\n\tstruct l2cap_conf_rfc rfc = { .mode = chan->mode };\n\tvoid *ptr = req->data;\n\tvoid *endptr = data + data_size;\n\tu16 size;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->num_conf_req || chan->num_conf_rsp)\n\t\tgoto done;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (test_bit(CONF_STATE2_DEVICE, &chan->conf_state))\n\t\t\tbreak;\n\n\t\tif (__l2cap_efs_supported(chan->conn))\n\t\t\tset_bit(FLAG_EFS_ENABLE, &chan->flags);\n\n\t\tfallthrough;\n\tdefault:\n\t\tchan->mode = l2cap_select_mode(rfc.mode, chan->conn->feat_mask);\n\t\tbreak;\n\t}\n\ndone:\n\tif (chan->imtu != L2CAP_DEFAULT_MTU) {\n\t\tif (!chan->imtu)\n\t\t\tl2cap_mtu_auto(chan);\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu,\n\t\t\t\t   endptr - ptr);\n\t}\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tif (disable_ertm)\n\t\t\tbreak;\n\n\t\tif (!(chan->conn->feat_mask & L2CAP_FEAT_ERTM) &&\n\t\t    !(chan->conn->feat_mask & L2CAP_FEAT_STREAMING))\n\t\t\tbreak;\n\n\t\trfc.mode            = L2CAP_MODE_BASIC;\n\t\trfc.txwin_size      = 0;\n\t\trfc.max_transmit    = 0;\n\t\trfc.retrans_timeout = 0;\n\t\trfc.monitor_timeout = 0;\n\t\trfc.max_pdu_size    = 0;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\t\trfc.mode            = L2CAP_MODE_ERTM;\n\t\trfc.max_transmit    = chan->max_tx;\n\n\t\t__l2cap_set_ertm_timeouts(chan, &rfc);\n\n\t\tsize = min_t(u16, L2CAP_DEFAULT_MAX_PDU_SIZE, chan->conn->mtu -\n\t\t\t     L2CAP_EXT_HDR_SIZE - L2CAP_SDULEN_SIZE -\n\t\t\t     L2CAP_FCS_SIZE);\n\t\trfc.max_pdu_size = cpu_to_le16(size);\n\n\t\tl2cap_txwin_setup(chan);\n\n\t\trfc.txwin_size = min_t(u16, chan->tx_win,\n\t\t\t\t       L2CAP_DEFAULT_TX_WINDOW);\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\n\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags))\n\t\t\tl2cap_add_opt_efs(&ptr, chan, endptr - ptr);\n\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,\n\t\t\t\t\t   chan->tx_win, endptr - ptr);\n\n\t\tif (chan->conn->feat_mask & L2CAP_FEAT_FCS)\n\t\t\tif (chan->fcs == L2CAP_FCS_NONE ||\n\t\t\t    test_bit(CONF_RECV_NO_FCS, &chan->conf_state)) {\n\t\t\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1,\n\t\t\t\t\t\t   chan->fcs, endptr - ptr);\n\t\t\t}\n\t\tbreak;\n\n\tcase L2CAP_MODE_STREAMING:\n\t\tl2cap_txwin_setup(chan);\n\t\trfc.mode            = L2CAP_MODE_STREAMING;\n\t\trfc.txwin_size      = 0;\n\t\trfc.max_transmit    = 0;\n\t\trfc.retrans_timeout = 0;\n\t\trfc.monitor_timeout = 0;\n\n\t\tsize = min_t(u16, L2CAP_DEFAULT_MAX_PDU_SIZE, chan->conn->mtu -\n\t\t\t     L2CAP_EXT_HDR_SIZE - L2CAP_SDULEN_SIZE -\n\t\t\t     L2CAP_FCS_SIZE);\n\t\trfc.max_pdu_size = cpu_to_le16(size);\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\n\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags))\n\t\t\tl2cap_add_opt_efs(&ptr, chan, endptr - ptr);\n\n\t\tif (chan->conn->feat_mask & L2CAP_FEAT_FCS)\n\t\t\tif (chan->fcs == L2CAP_FCS_NONE ||\n\t\t\t    test_bit(CONF_RECV_NO_FCS, &chan->conf_state)) {\n\t\t\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1,\n\t\t\t\t\t\t   chan->fcs, endptr - ptr);\n\t\t\t}\n\t\tbreak;\n\t}\n\n\treq->dcid  = cpu_to_le16(chan->dcid);\n\treq->flags = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n\nstatic int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)\n{\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\tvoid *endptr = data + data_size;\n\tvoid *req = chan->conf_req;\n\tint len = chan->conf_len;\n\tint type, hint, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\tu8 remote_efs = 0;\n\tu16 mtu = L2CAP_DEFAULT_MTU;\n\tu16 result = L2CAP_CONF_SUCCESS;\n\tu16 size;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&req, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\thint  = type & L2CAP_CONF_HINT;\n\t\ttype &= L2CAP_CONF_MASK;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tmtu = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_QOS:\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\tset_bit(CONF_RECV_NO_FCS, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tremote_efs = 1;\n\t\t\tmemcpy(&efs, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (!(chan->conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tset_bit(FLAG_EXT_CTRL, &chan->flags);\n\t\t\tset_bit(CONF_EWS_RECV, &chan->conf_state);\n\t\t\tchan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;\n\t\t\tchan->remote_tx_win = val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\tl2cap_add_conf_opt(&ptr, (u8)type, sizeof(u8), type, endptr - ptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->num_conf_rsp || chan->num_conf_req > 1)\n\t\tgoto done;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) {\n\t\t\tchan->mode = l2cap_select_mode(rfc.mode,\n\t\t\t\t\t\t       chan->conn->feat_mask);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (remote_efs) {\n\t\t\tif (__l2cap_efs_supported(chan->conn))\n\t\t\t\tset_bit(FLAG_EFS_ENABLE, &chan->flags);\n\t\t\telse\n\t\t\t\treturn -ECONNREFUSED;\n\t\t}\n\n\t\tif (chan->mode != rfc.mode)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tbreak;\n\t}\n\ndone:\n\tif (chan->mode != rfc.mode) {\n\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\trfc.mode = chan->mode;\n\n\t\tif (chan->num_conf_rsp == 1)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t}\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\telse {\n\t\t\tchan->omtu = mtu;\n\t\t\tset_bit(CONF_MTU_DONE, &chan->conf_state);\n\t\t}\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu, endptr - ptr);\n\n\t\tif (remote_efs) {\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype) {\n\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\t\tif (chan->num_conf_req >= 1)\n\t\t\t\t\treturn -ECONNREFUSED;\n\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t} else {\n\t\t\t\t/* Send PENDING Conf Rsp */\n\t\t\t\tresult = L2CAP_CONF_PENDING;\n\t\t\t\tset_bit(CONF_LOC_CONF_PEND, &chan->conf_state);\n\t\t\t}\n\t\t}\n\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tif (!test_bit(CONF_EWS_RECV, &chan->conf_state))\n\t\t\t\tchan->remote_tx_win = rfc.txwin_size;\n\t\t\telse\n\t\t\t\trfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW;\n\n\t\t\tchan->remote_max_tx = rfc.max_transmit;\n\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\t__l2cap_set_ertm_timeouts(chan, &rfc);\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\t   sizeof(rfc), (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tif (remote_efs &&\n\t\t\t    test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->remote_id = efs.id;\n\t\t\t\tchan->remote_stype = efs.stype;\n\t\t\t\tchan->remote_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->remote_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t\tchan->remote_acc_lat =\n\t\t\t\t\tle32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->remote_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = chan->mode;\n\t\t}\n\n\t\tif (result == L2CAP_CONF_SUCCESS)\n\t\t\tset_bit(CONF_OUTPUT_DONE, &chan->conf_state);\n\t}\n\trsp->scid   = cpu_to_le16(chan->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n\nstatic int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,\n\t\t\t\tvoid *data, size_t size, u16 *result)\n{\n\tstruct l2cap_conf_req *req = data;\n\tvoid *ptr = req->data;\n\tvoid *endptr = data + size;\n\tint type, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\n\tBT_DBG(\"chan %p, rsp %p, len %d, req %p\", chan, rsp, len, data);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (val < L2CAP_DEFAULT_MIN_MTU) {\n\t\t\t\t*result = L2CAP_CONF_UNACCEPT;\n\t\t\t\tchan->imtu = L2CAP_DEFAULT_MIN_MTU;\n\t\t\t} else\n\t\t\t\tchan->imtu = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu,\n\t\t\t\t\t   endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO, 2,\n\t\t\t\t\t   chan->flush_to, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tif (test_bit(CONF_STATE2_DEVICE, &chan->conf_state) &&\n\t\t\t    rfc.mode != chan->mode)\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tchan->fcs = 0;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->ack_win = min_t(u16, val, chan->ack_win);\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,\n\t\t\t\t\t   chan->tx_win, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&efs, (void *)val, olen);\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype)\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs),\n\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (*result == L2CAP_CONF_PENDING)\n\t\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\t\tset_bit(CONF_RECV_NO_FCS,\n\t\t\t\t\t\t&chan->conf_state);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->mode == L2CAP_MODE_BASIC && chan->mode != rfc.mode)\n\t\treturn -ECONNREFUSED;\n\n\tchan->mode = rfc.mode;\n\n\tif (*result == L2CAP_CONF_SUCCESS || *result == L2CAP_CONF_PENDING) {\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t\t\tif (!test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t\t      rfc.txwin_size);\n\n\t\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->local_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->local_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tchan->local_acc_lat = le32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->local_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t\t}\n\t}\n\n\treq->dcid   = cpu_to_le16(chan->dcid);\n\treq->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n\nstatic int l2cap_build_conf_rsp(struct l2cap_chan *chan, void *data,\n\t\t\t\tu16 result, u16 flags)\n{\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\trsp->scid   = cpu_to_le16(chan->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(flags);\n\n\treturn ptr - data;\n}\n\nvoid __l2cap_le_connect_rsp_defer(struct l2cap_chan *chan)\n{\n\tstruct l2cap_le_conn_rsp rsp;\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\trsp.dcid    = cpu_to_le16(chan->scid);\n\trsp.mtu     = cpu_to_le16(chan->imtu);\n\trsp.mps     = cpu_to_le16(chan->mps);\n\trsp.credits = cpu_to_le16(chan->rx_credits);\n\trsp.result  = cpu_to_le16(L2CAP_CR_LE_SUCCESS);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_RSP, sizeof(rsp),\n\t\t       &rsp);\n}\n\nvoid __l2cap_ecred_conn_rsp_defer(struct l2cap_chan *chan)\n{\n\tstruct {\n\t\tstruct l2cap_ecred_conn_rsp rsp;\n\t\t__le16 dcid[5];\n\t} __packed pdu;\n\tstruct l2cap_conn *conn = chan->conn;\n\tu16 ident = chan->ident;\n\tint i = 0;\n\n\tif (!ident)\n\t\treturn;\n\n\tBT_DBG(\"chan %p ident %d\", chan, ident);\n\n\tpdu.rsp.mtu     = cpu_to_le16(chan->imtu);\n\tpdu.rsp.mps     = cpu_to_le16(chan->mps);\n\tpdu.rsp.credits = cpu_to_le16(chan->rx_credits);\n\tpdu.rsp.result  = cpu_to_le16(L2CAP_CR_LE_SUCCESS);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tif (chan->ident != ident)\n\t\t\tcontinue;\n\n\t\t/* Reset ident so only one response is sent */\n\t\tchan->ident = 0;\n\n\t\t/* Include all channels pending with the same ident */\n\t\tpdu.dcid[i++] = cpu_to_le16(chan->scid);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n\n\tl2cap_send_cmd(conn, ident, L2CAP_ECRED_CONN_RSP,\n\t\t\tsizeof(pdu.rsp) + i * sizeof(__le16), &pdu);\n}\n\nvoid __l2cap_connect_rsp_defer(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn_rsp rsp;\n\tstruct l2cap_conn *conn = chan->conn;\n\tu8 buf[128];\n\tu8 rsp_code;\n\n\trsp.scid   = cpu_to_le16(chan->dcid);\n\trsp.dcid   = cpu_to_le16(chan->scid);\n\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\n\tif (chan->hs_hcon)\n\t\trsp_code = L2CAP_CREATE_CHAN_RSP;\n\telse\n\t\trsp_code = L2CAP_CONN_RSP;\n\n\tBT_DBG(\"chan %p rsp_code %u\", chan, rsp_code);\n\n\tl2cap_send_cmd(conn, chan->ident, rsp_code, sizeof(rsp), &rsp);\n\n\tif (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))\n\t\treturn;\n\n\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\tchan->num_conf_req++;\n}\n\nstatic void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}\n\nstatic inline int l2cap_command_rej(struct l2cap_conn *conn,\n\t\t\t\t    struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t    u8 *data)\n{\n\tstruct l2cap_cmd_rej_unk *rej = (struct l2cap_cmd_rej_unk *) data;\n\n\tif (cmd_len < sizeof(*rej))\n\t\treturn -EPROTO;\n\n\tif (rej->reason != L2CAP_REJ_NOT_UNDERSTOOD)\n\t\treturn 0;\n\n\tif ((conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) &&\n\t    cmd->ident == conn->info_ident) {\n\t\tcancel_delayed_work(&conn->info_timer);\n\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\tconn->info_ident = 0;\n\n\t\tl2cap_conn_start(conn);\n\t}\n\n\treturn 0;\n}\n\nstatic struct l2cap_chan *l2cap_connect(struct l2cap_conn *conn,\n\t\t\t\t\tstruct l2cap_cmd_hdr *cmd,\n\t\t\t\t\tu8 *data, u8 rsp_code, u8 amp_id)\n{\n\tstruct l2cap_conn_req *req = (struct l2cap_conn_req *) data;\n\tstruct l2cap_conn_rsp rsp;\n\tstruct l2cap_chan *chan = NULL, *pchan;\n\tint result, status = L2CAP_CS_NO_INFO;\n\n\tu16 dcid = 0, scid = __le16_to_cpu(req->scid);\n\t__le16 psm = req->psm;\n\n\tBT_DBG(\"psm 0x%2.2x scid 0x%4.4x\", __le16_to_cpu(psm), scid);\n\n\t/* Check if we have socket listening on psm */\n\tpchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, &conn->hcon->src,\n\t\t\t\t\t &conn->hcon->dst, ACL_LINK);\n\tif (!pchan) {\n\t\tresult = L2CAP_CR_BAD_PSM;\n\t\tgoto sendresp;\n\t}\n\n\tmutex_lock(&conn->chan_lock);\n\tl2cap_chan_lock(pchan);\n\n\t/* Check if the ACL is secure enough (if not SDP) */\n\tif (psm != cpu_to_le16(L2CAP_PSM_SDP) &&\n\t    !hci_conn_check_link_mode(conn->hcon)) {\n\t\tconn->disc_reason = HCI_ERROR_AUTH_FAILURE;\n\t\tresult = L2CAP_CR_SEC_BLOCK;\n\t\tgoto response;\n\t}\n\n\tresult = L2CAP_CR_NO_MEM;\n\n\t/* Check for valid dynamic CID range (as per Erratum 3253) */\n\tif (scid < L2CAP_CID_DYN_START || scid > L2CAP_CID_DYN_END) {\n\t\tresult = L2CAP_CR_INVALID_SCID;\n\t\tgoto response;\n\t}\n\n\t/* Check if we already have channel with that dcid */\n\tif (__l2cap_get_chan_by_dcid(conn, scid)) {\n\t\tresult = L2CAP_CR_SCID_IN_USE;\n\t\tgoto response;\n\t}\n\n\tchan = pchan->ops->new_connection(pchan);\n\tif (!chan)\n\t\tgoto response;\n\n\t/* For certain devices (ex: HID mouse), support for authentication,\n\t * pairing and bonding is optional. For such devices, inorder to avoid\n\t * the ACL alive for too long after L2CAP disconnection, reset the ACL\n\t * disc_timeout back to HCI_DISCONN_TIMEOUT during L2CAP connect.\n\t */\n\tconn->hcon->disc_timeout = HCI_DISCONN_TIMEOUT;\n\n\tbacpy(&chan->src, &conn->hcon->src);\n\tbacpy(&chan->dst, &conn->hcon->dst);\n\tchan->src_type = bdaddr_src_type(conn->hcon);\n\tchan->dst_type = bdaddr_dst_type(conn->hcon);\n\tchan->psm  = psm;\n\tchan->dcid = scid;\n\tchan->local_amp_id = amp_id;\n\n\t__l2cap_chan_add(conn, chan);\n\n\tdcid = chan->scid;\n\n\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\n\tchan->ident = cmd->ident;\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {\n\t\tif (l2cap_chan_check_security(chan, false)) {\n\t\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t\t\tresult = L2CAP_CR_PEND;\n\t\t\t\tstatus = L2CAP_CS_AUTHOR_PEND;\n\t\t\t\tchan->ops->defer(chan);\n\t\t\t} else {\n\t\t\t\t/* Force pending result for AMP controllers.\n\t\t\t\t * The connection will succeed after the\n\t\t\t\t * physical link is up.\n\t\t\t\t */\n\t\t\t\tif (amp_id == AMP_ID_BREDR) {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\t\t\tresult = L2CAP_CR_SUCCESS;\n\t\t\t\t} else {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t\t\t\tresult = L2CAP_CR_PEND;\n\t\t\t\t}\n\t\t\t\tstatus = L2CAP_CS_NO_INFO;\n\t\t\t}\n\t\t} else {\n\t\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t\tresult = L2CAP_CR_PEND;\n\t\t\tstatus = L2CAP_CS_AUTHEN_PEND;\n\t\t}\n\t} else {\n\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\tresult = L2CAP_CR_PEND;\n\t\tstatus = L2CAP_CS_NO_INFO;\n\t}\n\nresponse:\n\tl2cap_chan_unlock(pchan);\n\tmutex_unlock(&conn->chan_lock);\n\tl2cap_chan_put(pchan);\n\nsendresp:\n\trsp.scid   = cpu_to_le16(scid);\n\trsp.dcid   = cpu_to_le16(dcid);\n\trsp.result = cpu_to_le16(result);\n\trsp.status = cpu_to_le16(status);\n\tl2cap_send_cmd(conn, cmd->ident, rsp_code, sizeof(rsp), &rsp);\n\n\tif (result == L2CAP_CR_PEND && status == L2CAP_CS_NO_INFO) {\n\t\tstruct l2cap_info_req info;\n\t\tinfo.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;\n\t\tconn->info_ident = l2cap_get_ident(conn);\n\n\t\tschedule_delayed_work(&conn->info_timer, L2CAP_INFO_TIMEOUT);\n\n\t\tl2cap_send_cmd(conn, conn->info_ident, L2CAP_INFO_REQ,\n\t\t\t       sizeof(info), &info);\n\t}\n\n\tif (chan && !test_bit(CONF_REQ_SENT, &chan->conf_state) &&\n\t    result == L2CAP_CR_SUCCESS) {\n\t\tu8 buf[128];\n\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\t\tchan->num_conf_req++;\n\t}\n\n\treturn chan;\n}\n\nstatic int l2cap_connect_req(struct l2cap_conn *conn,\n\t\t\t     struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)\n{\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\tstruct hci_conn *hcon = conn->hcon;\n\n\tif (cmd_len < sizeof(struct l2cap_conn_req))\n\t\treturn -EPROTO;\n\n\thci_dev_lock(hdev);\n\tif (hci_dev_test_flag(hdev, HCI_MGMT) &&\n\t    !test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &hcon->flags))\n\t\tmgmt_device_connected(hdev, hcon, NULL, 0);\n\thci_dev_unlock(hdev);\n\n\tl2cap_connect(conn, cmd, data, L2CAP_CONN_RSP, 0);\n\treturn 0;\n}\n\nstatic int l2cap_connect_create_rsp(struct l2cap_conn *conn,\n\t\t\t\t    struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t    u8 *data)\n{\n\tstruct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;\n\tu16 scid, dcid, result, status;\n\tstruct l2cap_chan *chan;\n\tu8 req[128];\n\tint err;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tscid   = __le16_to_cpu(rsp->scid);\n\tdcid   = __le16_to_cpu(rsp->dcid);\n\tresult = __le16_to_cpu(rsp->result);\n\tstatus = __le16_to_cpu(rsp->status);\n\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x\",\n\t       dcid, scid, result, status);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tif (scid) {\n\t\tchan = __l2cap_get_chan_by_scid(conn, scid);\n\t\tif (!chan) {\n\t\t\terr = -EBADSLT;\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tchan = __l2cap_get_chan_by_ident(conn, cmd->ident);\n\t\tif (!chan) {\n\t\t\terr = -EBADSLT;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tchan = l2cap_chan_hold_unless_zero(chan);\n\tif (!chan) {\n\t\terr = -EBADSLT;\n\t\tgoto unlock;\n\t}\n\n\terr = 0;\n\n\tl2cap_chan_lock(chan);\n\n\tswitch (result) {\n\tcase L2CAP_CR_SUCCESS:\n\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\tchan->ident = 0;\n\t\tchan->dcid = dcid;\n\t\tclear_bit(CONF_CONNECT_PEND, &chan->conf_state);\n\n\t\tif (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))\n\t\t\tbreak;\n\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, req, sizeof(req)), req);\n\t\tchan->num_conf_req++;\n\t\tbreak;\n\n\tcase L2CAP_CR_PEND:\n\t\tset_bit(CONF_CONNECT_PEND, &chan->conf_state);\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\tbreak;\n\t}\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\nunlock:\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn err;\n}\n\nstatic inline void set_default_fcs(struct l2cap_chan *chan)\n{\n\t/* FCS is enabled only in ERTM or streaming mode, if one or both\n\t * sides request it.\n\t */\n\tif (chan->mode != L2CAP_MODE_ERTM && chan->mode != L2CAP_MODE_STREAMING)\n\t\tchan->fcs = L2CAP_FCS_NONE;\n\telse if (!test_bit(CONF_RECV_NO_FCS, &chan->conf_state))\n\t\tchan->fcs = L2CAP_FCS_CRC16;\n}\n\nstatic void l2cap_send_efs_conf_rsp(struct l2cap_chan *chan, void *data,\n\t\t\t\t    u8 ident, u16 flags)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tBT_DBG(\"conn %p chan %p ident %d flags 0x%4.4x\", conn, chan, ident,\n\t       flags);\n\n\tclear_bit(CONF_LOC_CONF_PEND, &chan->conf_state);\n\tset_bit(CONF_OUTPUT_DONE, &chan->conf_state);\n\n\tl2cap_send_cmd(conn, ident, L2CAP_CONF_RSP,\n\t\t       l2cap_build_conf_rsp(chan, data,\n\t\t\t\t\t    L2CAP_CONF_SUCCESS, flags), data);\n}\n\nstatic void cmd_reject_invalid_cid(struct l2cap_conn *conn, u8 ident,\n\t\t\t\t   u16 scid, u16 dcid)\n{\n\tstruct l2cap_cmd_rej_cid rej;\n\n\trej.reason = cpu_to_le16(L2CAP_REJ_INVALID_CID);\n\trej.scid = __cpu_to_le16(scid);\n\trej.dcid = __cpu_to_le16(dcid);\n\n\tl2cap_send_cmd(conn, ident, L2CAP_COMMAND_REJ, sizeof(rej), &rej);\n}\n\nstatic inline int l2cap_config_req(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tstruct l2cap_conf_req *req = (struct l2cap_conf_req *) data;\n\tu16 dcid, flags;\n\tu8 rsp[64];\n\tstruct l2cap_chan *chan;\n\tint len, err = 0;\n\n\tif (cmd_len < sizeof(*req))\n\t\treturn -EPROTO;\n\n\tdcid  = __le16_to_cpu(req->dcid);\n\tflags = __le16_to_cpu(req->flags);\n\n\tBT_DBG(\"dcid 0x%4.4x flags 0x%2.2x\", dcid, flags);\n\n\tchan = l2cap_get_chan_by_scid(conn, dcid);\n\tif (!chan) {\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, dcid, 0);\n\t\treturn 0;\n\t}\n\n\tif (chan->state != BT_CONFIG && chan->state != BT_CONNECT2 &&\n\t    chan->state != BT_CONNECTED) {\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, chan->scid,\n\t\t\t\t       chan->dcid);\n\t\tgoto unlock;\n\t}\n\n\t/* Reject if config buffer is too small. */\n\tlen = cmd_len - sizeof(*req);\n\tif (chan->conf_len + len > sizeof(chan->conf_req)) {\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t       l2cap_build_conf_rsp(chan, rsp,\n\t\t\t       L2CAP_CONF_REJECT, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Store config. */\n\tmemcpy(chan->conf_req + chan->conf_len, req->data, len);\n\tchan->conf_len += len;\n\n\tif (flags & L2CAP_CONF_FLAG_CONTINUATION) {\n\t\t/* Incomplete config. Send empty response. */\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t       l2cap_build_conf_rsp(chan, rsp,\n\t\t\t       L2CAP_CONF_SUCCESS, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Complete config. */\n\tlen = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));\n\tif (len < 0) {\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\tgoto unlock;\n\t}\n\n\tchan->ident = cmd->ident;\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\n\tchan->num_conf_rsp++;\n\n\t/* Reset config buffer. */\n\tchan->conf_len = 0;\n\n\tif (!test_bit(CONF_OUTPUT_DONE, &chan->conf_state))\n\t\tgoto unlock;\n\n\tif (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {\n\t\tset_default_fcs(chan);\n\n\t\tif (chan->mode == L2CAP_MODE_ERTM ||\n\t\t    chan->mode == L2CAP_MODE_STREAMING)\n\t\t\terr = l2cap_ertm_init(chan);\n\n\t\tif (err < 0)\n\t\t\tl2cap_send_disconn_req(chan, -err);\n\t\telse\n\t\t\tl2cap_chan_ready(chan);\n\n\t\tgoto unlock;\n\t}\n\n\tif (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {\n\t\tu8 buf[64];\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\t\tchan->num_conf_req++;\n\t}\n\n\t/* Got Conf Rsp PENDING from remote side and assume we sent\n\t   Conf Rsp PENDING in the code above */\n\tif (test_bit(CONF_REM_CONF_PEND, &chan->conf_state) &&\n\t    test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {\n\n\t\t/* check compatibility */\n\n\t\t/* Send rsp for BR/EDR channel */\n\t\tif (!chan->hs_hcon)\n\t\t\tl2cap_send_efs_conf_rsp(chan, rsp, cmd->ident, flags);\n\t\telse\n\t\t\tchan->ident = cmd->ident;\n\t}\n\nunlock:\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\treturn err;\n}\n\nstatic inline int l2cap_config_rsp(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tstruct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;\n\tu16 scid, flags, result;\n\tstruct l2cap_chan *chan;\n\tint len = cmd_len - sizeof(*rsp);\n\tint err = 0;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tscid   = __le16_to_cpu(rsp->scid);\n\tflags  = __le16_to_cpu(rsp->flags);\n\tresult = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x len %d\", scid, flags,\n\t       result, len);\n\n\tchan = l2cap_get_chan_by_scid(conn, scid);\n\tif (!chan)\n\t\treturn 0;\n\n\tswitch (result) {\n\tcase L2CAP_CONF_SUCCESS:\n\t\tl2cap_conf_rfc_get(chan, rsp->data, len);\n\t\tclear_bit(CONF_REM_CONF_PEND, &chan->conf_state);\n\t\tbreak;\n\n\tcase L2CAP_CONF_PENDING:\n\t\tset_bit(CONF_REM_CONF_PEND, &chan->conf_state);\n\n\t\tif (test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {\n\t\t\tchar buf[64];\n\n\t\t\tlen = l2cap_parse_conf_rsp(chan, rsp->data, len,\n\t\t\t\t\t\t   buf, sizeof(buf), &result);\n\t\t\tif (len < 0) {\n\t\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!chan->hs_hcon) {\n\t\t\t\tl2cap_send_efs_conf_rsp(chan, buf, cmd->ident,\n\t\t\t\t\t\t\t0);\n\t\t\t} else {\n\t\t\t\tif (l2cap_check_efs(chan)) {\n\t\t\t\t\tamp_create_logical_link(chan);\n\t\t\t\t\tchan->ident = cmd->ident;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\n\tcase L2CAP_CONF_UNKNOWN:\n\tcase L2CAP_CONF_UNACCEPT:\n\t\tif (chan->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {\n\t\t\tchar req[64];\n\n\t\t\tif (len > sizeof(req) - sizeof(struct l2cap_conf_req)) {\n\t\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* throw out any old stored conf requests */\n\t\t\tresult = L2CAP_CONF_SUCCESS;\n\t\t\tlen = l2cap_parse_conf_rsp(chan, rsp->data, len,\n\t\t\t\t\t\t   req, sizeof(req), &result);\n\t\t\tif (len < 0) {\n\t\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t       L2CAP_CONF_REQ, len, req);\n\t\t\tchan->num_conf_req++;\n\t\t\tif (result != L2CAP_CONF_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tdefault:\n\t\tl2cap_chan_set_err(chan, ECONNRESET);\n\n\t\t__set_chan_timer(chan, L2CAP_DISC_REJ_TIMEOUT);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\tgoto done;\n\t}\n\n\tif (flags & L2CAP_CONF_FLAG_CONTINUATION)\n\t\tgoto done;\n\n\tset_bit(CONF_INPUT_DONE, &chan->conf_state);\n\n\tif (test_bit(CONF_OUTPUT_DONE, &chan->conf_state)) {\n\t\tset_default_fcs(chan);\n\n\t\tif (chan->mode == L2CAP_MODE_ERTM ||\n\t\t    chan->mode == L2CAP_MODE_STREAMING)\n\t\t\terr = l2cap_ertm_init(chan);\n\n\t\tif (err < 0)\n\t\t\tl2cap_send_disconn_req(chan, -err);\n\t\telse\n\t\t\tl2cap_chan_ready(chan);\n\t}\n\ndone:\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\treturn err;\n}\n\nstatic inline int l2cap_disconnect_req(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_disconn_req *req = (struct l2cap_disconn_req *) data;\n\tstruct l2cap_disconn_rsp rsp;\n\tu16 dcid, scid;\n\tstruct l2cap_chan *chan;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\tscid = __le16_to_cpu(req->scid);\n\tdcid = __le16_to_cpu(req->dcid);\n\n\tBT_DBG(\"scid 0x%4.4x dcid 0x%4.4x\", scid, dcid);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tchan = __l2cap_get_chan_by_scid(conn, dcid);\n\tif (!chan) {\n\t\tmutex_unlock(&conn->chan_lock);\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, dcid, scid);\n\t\treturn 0;\n\t}\n\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\n\trsp.dcid = cpu_to_le16(chan->scid);\n\trsp.scid = cpu_to_le16(chan->dcid);\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_DISCONN_RSP, sizeof(rsp), &rsp);\n\n\tchan->ops->set_shutdown(chan);\n\n\tl2cap_chan_del(chan, ECONNRESET);\n\n\tchan->ops->close(chan);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_disconnect_rsp(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_disconn_rsp *rsp = (struct l2cap_disconn_rsp *) data;\n\tu16 dcid, scid;\n\tstruct l2cap_chan *chan;\n\n\tif (cmd_len != sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tscid = __le16_to_cpu(rsp->scid);\n\tdcid = __le16_to_cpu(rsp->dcid);\n\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x\", dcid, scid);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tchan = __l2cap_get_chan_by_scid(conn, scid);\n\tif (!chan) {\n\t\tmutex_unlock(&conn->chan_lock);\n\t\treturn 0;\n\t}\n\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\n\tif (chan->state != BT_DISCONN) {\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t\tmutex_unlock(&conn->chan_lock);\n\t\treturn 0;\n\t}\n\n\tl2cap_chan_del(chan, 0);\n\n\tchan->ops->close(chan);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_information_req(struct l2cap_conn *conn,\n\t\t\t\t\tstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t\tu8 *data)\n{\n\tstruct l2cap_info_req *req = (struct l2cap_info_req *) data;\n\tu16 type;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\ttype = __le16_to_cpu(req->type);\n\n\tBT_DBG(\"type 0x%4.4x\", type);\n\n\tif (type == L2CAP_IT_FEAT_MASK) {\n\t\tu8 buf[8];\n\t\tu32 feat_mask = l2cap_feat_mask;\n\t\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;\n\t\trsp->type   = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\t\trsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);\n\t\tif (!disable_ertm)\n\t\t\tfeat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING\n\t\t\t\t| L2CAP_FEAT_FCS;\n\t\tif (conn->local_fixed_chan & L2CAP_FC_A2MP)\n\t\t\tfeat_mask |= L2CAP_FEAT_EXT_FLOW\n\t\t\t\t| L2CAP_FEAT_EXT_WINDOW;\n\n\t\tput_unaligned_le32(feat_mask, rsp->data);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_INFO_RSP, sizeof(buf),\n\t\t\t       buf);\n\t} else if (type == L2CAP_IT_FIXED_CHAN) {\n\t\tu8 buf[12];\n\t\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;\n\n\t\trsp->type   = cpu_to_le16(L2CAP_IT_FIXED_CHAN);\n\t\trsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);\n\t\trsp->data[0] = conn->local_fixed_chan;\n\t\tmemset(rsp->data + 1, 0, 7);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_INFO_RSP, sizeof(buf),\n\t\t\t       buf);\n\t} else {\n\t\tstruct l2cap_info_rsp rsp;\n\t\trsp.type   = cpu_to_le16(type);\n\t\trsp.result = cpu_to_le16(L2CAP_IR_NOTSUPP);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_INFO_RSP, sizeof(rsp),\n\t\t\t       &rsp);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int l2cap_information_rsp(struct l2cap_conn *conn,\n\t\t\t\t\tstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t\tu8 *data)\n{\n\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) data;\n\tu16 type, result;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\ttype   = __le16_to_cpu(rsp->type);\n\tresult = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"type 0x%4.4x result 0x%2.2x\", type, result);\n\n\t/* L2CAP Info req/rsp are unbound to channels, add extra checks */\n\tif (cmd->ident != conn->info_ident ||\n\t    conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)\n\t\treturn 0;\n\n\tcancel_delayed_work(&conn->info_timer);\n\n\tif (result != L2CAP_IR_SUCCESS) {\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\tconn->info_ident = 0;\n\n\t\tl2cap_conn_start(conn);\n\n\t\treturn 0;\n\t}\n\n\tswitch (type) {\n\tcase L2CAP_IT_FEAT_MASK:\n\t\tconn->feat_mask = get_unaligned_le32(rsp->data);\n\n\t\tif (conn->feat_mask & L2CAP_FEAT_FIXED_CHAN) {\n\t\t\tstruct l2cap_info_req req;\n\t\t\treq.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);\n\n\t\t\tconn->info_ident = l2cap_get_ident(conn);\n\n\t\t\tl2cap_send_cmd(conn, conn->info_ident,\n\t\t\t\t       L2CAP_INFO_REQ, sizeof(req), &req);\n\t\t} else {\n\t\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\t\tconn->info_ident = 0;\n\n\t\t\tl2cap_conn_start(conn);\n\t\t}\n\t\tbreak;\n\n\tcase L2CAP_IT_FIXED_CHAN:\n\t\tconn->remote_fixed_chan = rsp->data[0];\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\tconn->info_ident = 0;\n\n\t\tl2cap_conn_start(conn);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int l2cap_create_channel_req(struct l2cap_conn *conn,\n\t\t\t\t    struct l2cap_cmd_hdr *cmd,\n\t\t\t\t    u16 cmd_len, void *data)\n{\n\tstruct l2cap_create_chan_req *req = data;\n\tstruct l2cap_create_chan_rsp rsp;\n\tstruct l2cap_chan *chan;\n\tstruct hci_dev *hdev;\n\tu16 psm, scid;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\tif (!(conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\treturn -EINVAL;\n\n\tpsm = le16_to_cpu(req->psm);\n\tscid = le16_to_cpu(req->scid);\n\n\tBT_DBG(\"psm 0x%2.2x, scid 0x%4.4x, amp_id %d\", psm, scid, req->amp_id);\n\n\t/* For controller id 0 make BR/EDR connection */\n\tif (req->amp_id == AMP_ID_BREDR) {\n\t\tl2cap_connect(conn, cmd, data, L2CAP_CREATE_CHAN_RSP,\n\t\t\t      req->amp_id);\n\t\treturn 0;\n\t}\n\n\t/* Validate AMP controller id */\n\thdev = hci_dev_get(req->amp_id);\n\tif (!hdev)\n\t\tgoto error;\n\n\tif (hdev->dev_type != HCI_AMP || !test_bit(HCI_UP, &hdev->flags)) {\n\t\thci_dev_put(hdev);\n\t\tgoto error;\n\t}\n\n\tchan = l2cap_connect(conn, cmd, data, L2CAP_CREATE_CHAN_RSP,\n\t\t\t     req->amp_id);\n\tif (chan) {\n\t\tstruct amp_mgr *mgr = conn->hcon->amp_mgr;\n\t\tstruct hci_conn *hs_hcon;\n\n\t\ths_hcon = hci_conn_hash_lookup_ba(hdev, AMP_LINK,\n\t\t\t\t\t\t  &conn->hcon->dst);\n\t\tif (!hs_hcon) {\n\t\t\thci_dev_put(hdev);\n\t\t\tcmd_reject_invalid_cid(conn, cmd->ident, chan->scid,\n\t\t\t\t\t       chan->dcid);\n\t\t\treturn 0;\n\t\t}\n\n\t\tBT_DBG(\"mgr %p bredr_chan %p hs_hcon %p\", mgr, chan, hs_hcon);\n\n\t\tmgr->bredr_chan = chan;\n\t\tchan->hs_hcon = hs_hcon;\n\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\tconn->mtu = hdev->block_mtu;\n\t}\n\n\thci_dev_put(hdev);\n\n\treturn 0;\n\nerror:\n\trsp.dcid = 0;\n\trsp.scid = cpu_to_le16(scid);\n\trsp.result = cpu_to_le16(L2CAP_CR_BAD_AMP);\n\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CREATE_CHAN_RSP,\n\t\t       sizeof(rsp), &rsp);\n\n\treturn 0;\n}\n\nstatic void l2cap_send_move_chan_req(struct l2cap_chan *chan, u8 dest_amp_id)\n{\n\tstruct l2cap_move_chan_req req;\n\tu8 ident;\n\n\tBT_DBG(\"chan %p, dest_amp_id %d\", chan, dest_amp_id);\n\n\tident = l2cap_get_ident(chan->conn);\n\tchan->ident = ident;\n\n\treq.icid = cpu_to_le16(chan->scid);\n\treq.dest_amp_id = dest_amp_id;\n\n\tl2cap_send_cmd(chan->conn, ident, L2CAP_MOVE_CHAN_REQ, sizeof(req),\n\t\t       &req);\n\n\t__set_chan_timer(chan, L2CAP_MOVE_TIMEOUT);\n}\n\nstatic void l2cap_send_move_chan_rsp(struct l2cap_chan *chan, u16 result)\n{\n\tstruct l2cap_move_chan_rsp rsp;\n\n\tBT_DBG(\"chan %p, result 0x%4.4x\", chan, result);\n\n\trsp.icid = cpu_to_le16(chan->dcid);\n\trsp.result = cpu_to_le16(result);\n\n\tl2cap_send_cmd(chan->conn, chan->ident, L2CAP_MOVE_CHAN_RSP,\n\t\t       sizeof(rsp), &rsp);\n}\n\nstatic void l2cap_send_move_chan_cfm(struct l2cap_chan *chan, u16 result)\n{\n\tstruct l2cap_move_chan_cfm cfm;\n\n\tBT_DBG(\"chan %p, result 0x%4.4x\", chan, result);\n\n\tchan->ident = l2cap_get_ident(chan->conn);\n\n\tcfm.icid = cpu_to_le16(chan->scid);\n\tcfm.result = cpu_to_le16(result);\n\n\tl2cap_send_cmd(chan->conn, chan->ident, L2CAP_MOVE_CHAN_CFM,\n\t\t       sizeof(cfm), &cfm);\n\n\t__set_chan_timer(chan, L2CAP_MOVE_TIMEOUT);\n}\n\nstatic void l2cap_send_move_chan_cfm_icid(struct l2cap_conn *conn, u16 icid)\n{\n\tstruct l2cap_move_chan_cfm cfm;\n\n\tBT_DBG(\"conn %p, icid 0x%4.4x\", conn, icid);\n\n\tcfm.icid = cpu_to_le16(icid);\n\tcfm.result = cpu_to_le16(L2CAP_MC_UNCONFIRMED);\n\n\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_MOVE_CHAN_CFM,\n\t\t       sizeof(cfm), &cfm);\n}\n\nstatic void l2cap_send_move_chan_cfm_rsp(struct l2cap_conn *conn, u8 ident,\n\t\t\t\t\t u16 icid)\n{\n\tstruct l2cap_move_chan_cfm_rsp rsp;\n\n\tBT_DBG(\"icid 0x%4.4x\", icid);\n\n\trsp.icid = cpu_to_le16(icid);\n\tl2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM_RSP, sizeof(rsp), &rsp);\n}\n\nstatic void __release_logical_link(struct l2cap_chan *chan)\n{\n\tchan->hs_hchan = NULL;\n\tchan->hs_hcon = NULL;\n\n\t/* Placeholder - release the logical link */\n}\n\nstatic void l2cap_logical_fail(struct l2cap_chan *chan)\n{\n\t/* Logical link setup failed */\n\tif (chan->state != BT_CONNECTED) {\n\t\t/* Create channel failure, disconnect */\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tswitch (chan->move_role) {\n\tcase L2CAP_MOVE_ROLE_RESPONDER:\n\t\tl2cap_move_done(chan);\n\t\tl2cap_send_move_chan_rsp(chan, L2CAP_MR_NOT_SUPP);\n\t\tbreak;\n\tcase L2CAP_MOVE_ROLE_INITIATOR:\n\t\tif (chan->move_state == L2CAP_MOVE_WAIT_LOGICAL_COMP ||\n\t\t    chan->move_state == L2CAP_MOVE_WAIT_LOGICAL_CFM) {\n\t\t\t/* Remote has only sent pending or\n\t\t\t * success responses, clean up\n\t\t\t */\n\t\t\tl2cap_move_done(chan);\n\t\t}\n\n\t\t/* Other amp move states imply that the move\n\t\t * has already aborted\n\t\t */\n\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_logical_finish_create(struct l2cap_chan *chan,\n\t\t\t\t\tstruct hci_chan *hchan)\n{\n\tstruct l2cap_conf_rsp rsp;\n\n\tchan->hs_hchan = hchan;\n\tchan->hs_hcon->l2cap_data = chan->conn;\n\n\tl2cap_send_efs_conf_rsp(chan, &rsp, chan->ident, 0);\n\n\tif (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {\n\t\tint err;\n\n\t\tset_default_fcs(chan);\n\n\t\terr = l2cap_ertm_init(chan);\n\t\tif (err < 0)\n\t\t\tl2cap_send_disconn_req(chan, -err);\n\t\telse\n\t\t\tl2cap_chan_ready(chan);\n\t}\n}\n\nstatic void l2cap_logical_finish_move(struct l2cap_chan *chan,\n\t\t\t\t      struct hci_chan *hchan)\n{\n\tchan->hs_hcon = hchan->conn;\n\tchan->hs_hcon->l2cap_data = chan->conn;\n\n\tBT_DBG(\"move_state %d\", chan->move_state);\n\n\tswitch (chan->move_state) {\n\tcase L2CAP_MOVE_WAIT_LOGICAL_COMP:\n\t\t/* Move confirm will be sent after a success\n\t\t * response is received\n\t\t */\n\t\tchan->move_state = L2CAP_MOVE_WAIT_RSP_SUCCESS;\n\t\tbreak;\n\tcase L2CAP_MOVE_WAIT_LOGICAL_CFM:\n\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOCAL_BUSY;\n\t\t} else if (chan->move_role == L2CAP_MOVE_ROLE_INITIATOR) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM_RSP;\n\t\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_CONFIRMED);\n\t\t} else if (chan->move_role == L2CAP_MOVE_ROLE_RESPONDER) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM;\n\t\t\tl2cap_send_move_chan_rsp(chan, L2CAP_MR_SUCCESS);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* Move was not in expected state, free the channel */\n\t\t__release_logical_link(chan);\n\n\t\tchan->move_state = L2CAP_MOVE_STABLE;\n\t}\n}\n\n/* Call with chan locked */\nvoid l2cap_logical_cfm(struct l2cap_chan *chan, struct hci_chan *hchan,\n\t\t       u8 status)\n{\n\tBT_DBG(\"chan %p, hchan %p, status %d\", chan, hchan, status);\n\n\tif (status) {\n\t\tl2cap_logical_fail(chan);\n\t\t__release_logical_link(chan);\n\t\treturn;\n\t}\n\n\tif (chan->state != BT_CONNECTED) {\n\t\t/* Ignore logical link if channel is on BR/EDR */\n\t\tif (chan->local_amp_id != AMP_ID_BREDR)\n\t\t\tl2cap_logical_finish_create(chan, hchan);\n\t} else {\n\t\tl2cap_logical_finish_move(chan, hchan);\n\t}\n}\n\nvoid l2cap_move_start(struct l2cap_chan *chan)\n{\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->local_amp_id == AMP_ID_BREDR) {\n\t\tif (chan->chan_policy != BT_CHANNEL_POLICY_AMP_PREFERRED)\n\t\t\treturn;\n\t\tchan->move_role = L2CAP_MOVE_ROLE_INITIATOR;\n\t\tchan->move_state = L2CAP_MOVE_WAIT_PREPARE;\n\t\t/* Placeholder - start physical link setup */\n\t} else {\n\t\tchan->move_role = L2CAP_MOVE_ROLE_INITIATOR;\n\t\tchan->move_state = L2CAP_MOVE_WAIT_RSP_SUCCESS;\n\t\tchan->move_id = 0;\n\t\tl2cap_move_setup(chan);\n\t\tl2cap_send_move_chan_req(chan, 0);\n\t}\n}\n\nstatic void l2cap_do_create(struct l2cap_chan *chan, int result,\n\t\t\t    u8 local_amp_id, u8 remote_amp_id)\n{\n\tBT_DBG(\"chan %p state %s %u -> %u\", chan, state_to_string(chan->state),\n\t       local_amp_id, remote_amp_id);\n\n\tchan->fcs = L2CAP_FCS_NONE;\n\n\t/* Outgoing channel on AMP */\n\tif (chan->state == BT_CONNECT) {\n\t\tif (result == L2CAP_CR_SUCCESS) {\n\t\t\tchan->local_amp_id = local_amp_id;\n\t\t\tl2cap_send_create_chan_req(chan, remote_amp_id);\n\t\t} else {\n\t\t\t/* Revert to BR/EDR connect */\n\t\t\tl2cap_send_conn_req(chan);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t/* Incoming channel on AMP */\n\tif (__l2cap_no_conn_pending(chan)) {\n\t\tstruct l2cap_conn_rsp rsp;\n\t\tchar buf[128];\n\t\trsp.scid = cpu_to_le16(chan->dcid);\n\t\trsp.dcid = cpu_to_le16(chan->scid);\n\n\t\tif (result == L2CAP_CR_SUCCESS) {\n\t\t\t/* Send successful response */\n\t\t\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t} else {\n\t\t\t/* Send negative response */\n\t\t\trsp.result = cpu_to_le16(L2CAP_CR_NO_MEM);\n\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t}\n\n\t\tl2cap_send_cmd(chan->conn, chan->ident, L2CAP_CREATE_CHAN_RSP,\n\t\t\t       sizeof(rsp), &rsp);\n\n\t\tif (result == L2CAP_CR_SUCCESS) {\n\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\t\tl2cap_send_cmd(chan->conn, l2cap_get_ident(chan->conn),\n\t\t\t\t       L2CAP_CONF_REQ,\n\t\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\t\t\tchan->num_conf_req++;\n\t\t}\n\t}\n}\n\nstatic void l2cap_do_move_initiate(struct l2cap_chan *chan, u8 local_amp_id,\n\t\t\t\t   u8 remote_amp_id)\n{\n\tl2cap_move_setup(chan);\n\tchan->move_id = local_amp_id;\n\tchan->move_state = L2CAP_MOVE_WAIT_RSP;\n\n\tl2cap_send_move_chan_req(chan, remote_amp_id);\n}\n\nstatic void l2cap_do_move_respond(struct l2cap_chan *chan, int result)\n{\n\tstruct hci_chan *hchan = NULL;\n\n\t/* Placeholder - get hci_chan for logical link */\n\n\tif (hchan) {\n\t\tif (hchan->state == BT_CONNECTED) {\n\t\t\t/* Logical link is ready to go */\n\t\t\tchan->hs_hcon = hchan->conn;\n\t\t\tchan->hs_hcon->l2cap_data = chan->conn;\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM;\n\t\t\tl2cap_send_move_chan_rsp(chan, L2CAP_MR_SUCCESS);\n\n\t\t\tl2cap_logical_cfm(chan, hchan, L2CAP_MR_SUCCESS);\n\t\t} else {\n\t\t\t/* Wait for logical link to be ready */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_CFM;\n\t\t}\n\t} else {\n\t\t/* Logical link not available */\n\t\tl2cap_send_move_chan_rsp(chan, L2CAP_MR_NOT_ALLOWED);\n\t}\n}\n\nstatic void l2cap_do_move_cancel(struct l2cap_chan *chan, int result)\n{\n\tif (chan->move_role == L2CAP_MOVE_ROLE_RESPONDER) {\n\t\tu8 rsp_result;\n\t\tif (result == -EINVAL)\n\t\t\trsp_result = L2CAP_MR_BAD_ID;\n\t\telse\n\t\t\trsp_result = L2CAP_MR_NOT_ALLOWED;\n\n\t\tl2cap_send_move_chan_rsp(chan, rsp_result);\n\t}\n\n\tchan->move_role = L2CAP_MOVE_ROLE_NONE;\n\tchan->move_state = L2CAP_MOVE_STABLE;\n\n\t/* Restart data transmission */\n\tl2cap_ertm_send(chan);\n}\n\n/* Invoke with locked chan */\nvoid __l2cap_physical_cfm(struct l2cap_chan *chan, int result)\n{\n\tu8 local_amp_id = chan->local_amp_id;\n\tu8 remote_amp_id = chan->remote_amp_id;\n\n\tBT_DBG(\"chan %p, result %d, local_amp_id %d, remote_amp_id %d\",\n\t       chan, result, local_amp_id, remote_amp_id);\n\n\tif (chan->state == BT_DISCONN || chan->state == BT_CLOSED)\n\t\treturn;\n\n\tif (chan->state != BT_CONNECTED) {\n\t\tl2cap_do_create(chan, result, local_amp_id, remote_amp_id);\n\t} else if (result != L2CAP_MR_SUCCESS) {\n\t\tl2cap_do_move_cancel(chan, result);\n\t} else {\n\t\tswitch (chan->move_role) {\n\t\tcase L2CAP_MOVE_ROLE_INITIATOR:\n\t\t\tl2cap_do_move_initiate(chan, local_amp_id,\n\t\t\t\t\t       remote_amp_id);\n\t\t\tbreak;\n\t\tcase L2CAP_MOVE_ROLE_RESPONDER:\n\t\t\tl2cap_do_move_respond(chan, result);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tl2cap_do_move_cancel(chan, result);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic inline int l2cap_move_channel_req(struct l2cap_conn *conn,\n\t\t\t\t\t struct l2cap_cmd_hdr *cmd,\n\t\t\t\t\t u16 cmd_len, void *data)\n{\n\tstruct l2cap_move_chan_req *req = data;\n\tstruct l2cap_move_chan_rsp rsp;\n\tstruct l2cap_chan *chan;\n\tu16 icid = 0;\n\tu16 result = L2CAP_MR_NOT_ALLOWED;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\ticid = le16_to_cpu(req->icid);\n\n\tBT_DBG(\"icid 0x%4.4x, dest_amp_id %d\", icid, req->dest_amp_id);\n\n\tif (!(conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\treturn -EINVAL;\n\n\tchan = l2cap_get_chan_by_dcid(conn, icid);\n\tif (!chan) {\n\t\trsp.icid = cpu_to_le16(icid);\n\t\trsp.result = cpu_to_le16(L2CAP_MR_NOT_ALLOWED);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_MOVE_CHAN_RSP,\n\t\t\t       sizeof(rsp), &rsp);\n\t\treturn 0;\n\t}\n\n\tchan->ident = cmd->ident;\n\n\tif (chan->scid < L2CAP_CID_DYN_START ||\n\t    chan->chan_policy == BT_CHANNEL_POLICY_BREDR_ONLY ||\n\t    (chan->mode != L2CAP_MODE_ERTM &&\n\t     chan->mode != L2CAP_MODE_STREAMING)) {\n\t\tresult = L2CAP_MR_NOT_ALLOWED;\n\t\tgoto send_move_response;\n\t}\n\n\tif (chan->local_amp_id == req->dest_amp_id) {\n\t\tresult = L2CAP_MR_SAME_ID;\n\t\tgoto send_move_response;\n\t}\n\n\tif (req->dest_amp_id != AMP_ID_BREDR) {\n\t\tstruct hci_dev *hdev;\n\t\thdev = hci_dev_get(req->dest_amp_id);\n\t\tif (!hdev || hdev->dev_type != HCI_AMP ||\n\t\t    !test_bit(HCI_UP, &hdev->flags)) {\n\t\t\tif (hdev)\n\t\t\t\thci_dev_put(hdev);\n\n\t\t\tresult = L2CAP_MR_BAD_ID;\n\t\t\tgoto send_move_response;\n\t\t}\n\t\thci_dev_put(hdev);\n\t}\n\n\t/* Detect a move collision.  Only send a collision response\n\t * if this side has \"lost\", otherwise proceed with the move.\n\t * The winner has the larger bd_addr.\n\t */\n\tif ((__chan_is_moving(chan) ||\n\t     chan->move_role != L2CAP_MOVE_ROLE_NONE) &&\n\t    bacmp(&conn->hcon->src, &conn->hcon->dst) > 0) {\n\t\tresult = L2CAP_MR_COLLISION;\n\t\tgoto send_move_response;\n\t}\n\n\tchan->move_role = L2CAP_MOVE_ROLE_RESPONDER;\n\tl2cap_move_setup(chan);\n\tchan->move_id = req->dest_amp_id;\n\n\tif (req->dest_amp_id == AMP_ID_BREDR) {\n\t\t/* Moving to BR/EDR */\n\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOCAL_BUSY;\n\t\t\tresult = L2CAP_MR_PEND;\n\t\t} else {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM;\n\t\t\tresult = L2CAP_MR_SUCCESS;\n\t\t}\n\t} else {\n\t\tchan->move_state = L2CAP_MOVE_WAIT_PREPARE;\n\t\t/* Placeholder - uncomment when amp functions are available */\n\t\t/*amp_accept_physical(chan, req->dest_amp_id);*/\n\t\tresult = L2CAP_MR_PEND;\n\t}\n\nsend_move_response:\n\tl2cap_send_move_chan_rsp(chan, result);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\treturn 0;\n}\n\nstatic void l2cap_move_continue(struct l2cap_conn *conn, u16 icid, u16 result)\n{\n\tstruct l2cap_chan *chan;\n\tstruct hci_chan *hchan = NULL;\n\n\tchan = l2cap_get_chan_by_scid(conn, icid);\n\tif (!chan) {\n\t\tl2cap_send_move_chan_cfm_icid(conn, icid);\n\t\treturn;\n\t}\n\n\t__clear_chan_timer(chan);\n\tif (result == L2CAP_MR_PEND)\n\t\t__set_chan_timer(chan, L2CAP_MOVE_ERTX_TIMEOUT);\n\n\tswitch (chan->move_state) {\n\tcase L2CAP_MOVE_WAIT_LOGICAL_COMP:\n\t\t/* Move confirm will be sent when logical link\n\t\t * is complete.\n\t\t */\n\t\tchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_CFM;\n\t\tbreak;\n\tcase L2CAP_MOVE_WAIT_RSP_SUCCESS:\n\t\tif (result == L2CAP_MR_PEND) {\n\t\t\tbreak;\n\t\t} else if (test_bit(CONN_LOCAL_BUSY,\n\t\t\t\t    &chan->conn_state)) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOCAL_BUSY;\n\t\t} else {\n\t\t\t/* Logical link is up or moving to BR/EDR,\n\t\t\t * proceed with move\n\t\t\t */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM_RSP;\n\t\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_CONFIRMED);\n\t\t}\n\t\tbreak;\n\tcase L2CAP_MOVE_WAIT_RSP:\n\t\t/* Moving to AMP */\n\t\tif (result == L2CAP_MR_SUCCESS) {\n\t\t\t/* Remote is ready, send confirm immediately\n\t\t\t * after logical link is ready\n\t\t\t */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_CFM;\n\t\t} else {\n\t\t\t/* Both logical link and move success\n\t\t\t * are required to confirm\n\t\t\t */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_COMP;\n\t\t}\n\n\t\t/* Placeholder - get hci_chan for logical link */\n\t\tif (!hchan) {\n\t\t\t/* Logical link not available */\n\t\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If the logical link is not yet connected, do not\n\t\t * send confirmation.\n\t\t */\n\t\tif (hchan->state != BT_CONNECTED)\n\t\t\tbreak;\n\n\t\t/* Logical link is already ready to go */\n\n\t\tchan->hs_hcon = hchan->conn;\n\t\tchan->hs_hcon->l2cap_data = chan->conn;\n\n\t\tif (result == L2CAP_MR_SUCCESS) {\n\t\t\t/* Can confirm now */\n\t\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_CONFIRMED);\n\t\t} else {\n\t\t\t/* Now only need move success\n\t\t\t * to confirm\n\t\t\t */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_RSP_SUCCESS;\n\t\t}\n\n\t\tl2cap_logical_cfm(chan, hchan, L2CAP_MR_SUCCESS);\n\t\tbreak;\n\tdefault:\n\t\t/* Any other amp move state means the move failed. */\n\t\tchan->move_id = chan->local_amp_id;\n\t\tl2cap_move_done(chan);\n\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\n\t}\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nstatic void l2cap_move_fail(struct l2cap_conn *conn, u8 ident, u16 icid,\n\t\t\t    u16 result)\n{\n\tstruct l2cap_chan *chan;\n\n\tchan = l2cap_get_chan_by_ident(conn, ident);\n\tif (!chan) {\n\t\t/* Could not locate channel, icid is best guess */\n\t\tl2cap_send_move_chan_cfm_icid(conn, icid);\n\t\treturn;\n\t}\n\n\t__clear_chan_timer(chan);\n\n\tif (chan->move_role == L2CAP_MOVE_ROLE_INITIATOR) {\n\t\tif (result == L2CAP_MR_COLLISION) {\n\t\t\tchan->move_role = L2CAP_MOVE_ROLE_RESPONDER;\n\t\t} else {\n\t\t\t/* Cleanup - cancel move */\n\t\t\tchan->move_id = chan->local_amp_id;\n\t\t\tl2cap_move_done(chan);\n\t\t}\n\t}\n\n\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nstatic int l2cap_move_channel_rsp(struct l2cap_conn *conn,\n\t\t\t\t  struct l2cap_cmd_hdr *cmd,\n\t\t\t\t  u16 cmd_len, void *data)\n{\n\tstruct l2cap_move_chan_rsp *rsp = data;\n\tu16 icid, result;\n\n\tif (cmd_len != sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\ticid = le16_to_cpu(rsp->icid);\n\tresult = le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"icid 0x%4.4x, result 0x%4.4x\", icid, result);\n\n\tif (result == L2CAP_MR_SUCCESS || result == L2CAP_MR_PEND)\n\t\tl2cap_move_continue(conn, icid, result);\n\telse\n\t\tl2cap_move_fail(conn, cmd->ident, icid, result);\n\n\treturn 0;\n}\n\nstatic int l2cap_move_channel_confirm(struct l2cap_conn *conn,\n\t\t\t\t      struct l2cap_cmd_hdr *cmd,\n\t\t\t\t      u16 cmd_len, void *data)\n{\n\tstruct l2cap_move_chan_cfm *cfm = data;\n\tstruct l2cap_chan *chan;\n\tu16 icid, result;\n\n\tif (cmd_len != sizeof(*cfm))\n\t\treturn -EPROTO;\n\n\ticid = le16_to_cpu(cfm->icid);\n\tresult = le16_to_cpu(cfm->result);\n\n\tBT_DBG(\"icid 0x%4.4x, result 0x%4.4x\", icid, result);\n\n\tchan = l2cap_get_chan_by_dcid(conn, icid);\n\tif (!chan) {\n\t\t/* Spec requires a response even if the icid was not found */\n\t\tl2cap_send_move_chan_cfm_rsp(conn, cmd->ident, icid);\n\t\treturn 0;\n\t}\n\n\tif (chan->move_state == L2CAP_MOVE_WAIT_CONFIRM) {\n\t\tif (result == L2CAP_MC_CONFIRMED) {\n\t\t\tchan->local_amp_id = chan->move_id;\n\t\t\tif (chan->local_amp_id == AMP_ID_BREDR)\n\t\t\t\t__release_logical_link(chan);\n\t\t} else {\n\t\t\tchan->move_id = chan->local_amp_id;\n\t\t}\n\n\t\tl2cap_move_done(chan);\n\t}\n\n\tl2cap_send_move_chan_cfm_rsp(conn, cmd->ident, icid);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_move_channel_confirm_rsp(struct l2cap_conn *conn,\n\t\t\t\t\t\t struct l2cap_cmd_hdr *cmd,\n\t\t\t\t\t\t u16 cmd_len, void *data)\n{\n\tstruct l2cap_move_chan_cfm_rsp *rsp = data;\n\tstruct l2cap_chan *chan;\n\tu16 icid;\n\n\tif (cmd_len != sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\ticid = le16_to_cpu(rsp->icid);\n\n\tBT_DBG(\"icid 0x%4.4x\", icid);\n\n\tchan = l2cap_get_chan_by_scid(conn, icid);\n\tif (!chan)\n\t\treturn 0;\n\n\t__clear_chan_timer(chan);\n\n\tif (chan->move_state == L2CAP_MOVE_WAIT_CONFIRM_RSP) {\n\t\tchan->local_amp_id = chan->move_id;\n\n\t\tif (chan->local_amp_id == AMP_ID_BREDR && chan->hs_hchan)\n\t\t\t__release_logical_link(chan);\n\n\t\tl2cap_move_done(chan);\n\t}\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_conn_param_update_req(struct l2cap_conn *conn,\n\t\t\t\t\t      struct l2cap_cmd_hdr *cmd,\n\t\t\t\t\t      u16 cmd_len, u8 *data)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_conn_param_update_req *req;\n\tstruct l2cap_conn_param_update_rsp rsp;\n\tu16 min, max, latency, to_multiplier;\n\tint err;\n\n\tif (hcon->role != HCI_ROLE_MASTER)\n\t\treturn -EINVAL;\n\n\tif (cmd_len != sizeof(struct l2cap_conn_param_update_req))\n\t\treturn -EPROTO;\n\n\treq = (struct l2cap_conn_param_update_req *) data;\n\tmin\t\t= __le16_to_cpu(req->min);\n\tmax\t\t= __le16_to_cpu(req->max);\n\tlatency\t\t= __le16_to_cpu(req->latency);\n\tto_multiplier\t= __le16_to_cpu(req->to_multiplier);\n\n\tBT_DBG(\"min 0x%4.4x max 0x%4.4x latency: 0x%4.4x Timeout: 0x%4.4x\",\n\t       min, max, latency, to_multiplier);\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\terr = hci_check_conn_params(min, max, latency, to_multiplier);\n\tif (err)\n\t\trsp.result = cpu_to_le16(L2CAP_CONN_PARAM_REJECTED);\n\telse\n\t\trsp.result = cpu_to_le16(L2CAP_CONN_PARAM_ACCEPTED);\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_PARAM_UPDATE_RSP,\n\t\t       sizeof(rsp), &rsp);\n\n\tif (!err) {\n\t\tu8 store_hint;\n\n\t\tstore_hint = hci_le_conn_update(hcon, min, max, latency,\n\t\t\t\t\t\tto_multiplier);\n\t\tmgmt_new_conn_param(hcon->hdev, &hcon->dst, hcon->dst_type,\n\t\t\t\t    store_hint, min, max, latency,\n\t\t\t\t    to_multiplier);\n\n\t}\n\n\treturn 0;\n}\n\nstatic int l2cap_le_connect_rsp(struct l2cap_conn *conn,\n\t\t\t\tstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\tu8 *data)\n{\n\tstruct l2cap_le_conn_rsp *rsp = (struct l2cap_le_conn_rsp *) data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tu16 dcid, mtu, mps, credits, result;\n\tstruct l2cap_chan *chan;\n\tint err, sec_level;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tdcid    = __le16_to_cpu(rsp->dcid);\n\tmtu     = __le16_to_cpu(rsp->mtu);\n\tmps     = __le16_to_cpu(rsp->mps);\n\tcredits = __le16_to_cpu(rsp->credits);\n\tresult  = __le16_to_cpu(rsp->result);\n\n\tif (result == L2CAP_CR_LE_SUCCESS && (mtu < 23 || mps < 23 ||\n\t\t\t\t\t   dcid < L2CAP_CID_DYN_START ||\n\t\t\t\t\t   dcid > L2CAP_CID_LE_DYN_END))\n\t\treturn -EPROTO;\n\n\tBT_DBG(\"dcid 0x%4.4x mtu %u mps %u credits %u result 0x%2.2x\",\n\t       dcid, mtu, mps, credits, result);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tchan = __l2cap_get_chan_by_ident(conn, cmd->ident);\n\tif (!chan) {\n\t\terr = -EBADSLT;\n\t\tgoto unlock;\n\t}\n\n\terr = 0;\n\n\tl2cap_chan_lock(chan);\n\n\tswitch (result) {\n\tcase L2CAP_CR_LE_SUCCESS:\n\t\tif (__l2cap_get_chan_by_dcid(conn, dcid)) {\n\t\t\terr = -EBADSLT;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->ident = 0;\n\t\tchan->dcid = dcid;\n\t\tchan->omtu = mtu;\n\t\tchan->remote_mps = mps;\n\t\tchan->tx_credits = credits;\n\t\tl2cap_chan_ready(chan);\n\t\tbreak;\n\n\tcase L2CAP_CR_LE_AUTHENTICATION:\n\tcase L2CAP_CR_LE_ENCRYPTION:\n\t\t/* If we already have MITM protection we can't do\n\t\t * anything.\n\t\t */\n\t\tif (hcon->sec_level > BT_SECURITY_MEDIUM) {\n\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\tbreak;\n\t\t}\n\n\t\tsec_level = hcon->sec_level + 1;\n\t\tif (chan->sec_level < sec_level)\n\t\t\tchan->sec_level = sec_level;\n\n\t\t/* We'll need to send a new Connect Request */\n\t\tclear_bit(FLAG_LE_CONN_REQ_SENT, &chan->flags);\n\n\t\tsmp_conn_security(hcon, chan->sec_level);\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\tbreak;\n\t}\n\n\tl2cap_chan_unlock(chan);\n\nunlock:\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn err;\n}\n\nstatic inline int l2cap_bredr_sig_cmd(struct l2cap_conn *conn,\n\t\t\t\t      struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t      u8 *data)\n{\n\tint err = 0;\n\n\tswitch (cmd->code) {\n\tcase L2CAP_COMMAND_REJ:\n\t\tl2cap_command_rej(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONN_REQ:\n\t\terr = l2cap_connect_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONN_RSP:\n\tcase L2CAP_CREATE_CHAN_RSP:\n\t\tl2cap_connect_create_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONF_REQ:\n\t\terr = l2cap_config_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONF_RSP:\n\t\tl2cap_config_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_DISCONN_REQ:\n\t\terr = l2cap_disconnect_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_DISCONN_RSP:\n\t\tl2cap_disconnect_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECHO_REQ:\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_ECHO_RSP, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECHO_RSP:\n\t\tbreak;\n\n\tcase L2CAP_INFO_REQ:\n\t\terr = l2cap_information_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_INFO_RSP:\n\t\tl2cap_information_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CREATE_CHAN_REQ:\n\t\terr = l2cap_create_channel_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_MOVE_CHAN_REQ:\n\t\terr = l2cap_move_channel_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_MOVE_CHAN_RSP:\n\t\tl2cap_move_channel_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_MOVE_CHAN_CFM:\n\t\terr = l2cap_move_channel_confirm(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_MOVE_CHAN_CFM_RSP:\n\t\tl2cap_move_channel_confirm_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Unknown BR/EDR signaling command 0x%2.2x\", cmd->code);\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_le_connect_req(struct l2cap_conn *conn,\n\t\t\t\tstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\tu8 *data)\n{\n\tstruct l2cap_le_conn_req *req = (struct l2cap_le_conn_req *) data;\n\tstruct l2cap_le_conn_rsp rsp;\n\tstruct l2cap_chan *chan, *pchan;\n\tu16 dcid, scid, credits, mtu, mps;\n\t__le16 psm;\n\tu8 result;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\tscid = __le16_to_cpu(req->scid);\n\tmtu  = __le16_to_cpu(req->mtu);\n\tmps  = __le16_to_cpu(req->mps);\n\tpsm  = req->psm;\n\tdcid = 0;\n\tcredits = 0;\n\n\tif (mtu < 23 || mps < 23)\n\t\treturn -EPROTO;\n\n\tBT_DBG(\"psm 0x%2.2x scid 0x%4.4x mtu %u mps %u\", __le16_to_cpu(psm),\n\t       scid, mtu, mps);\n\n\t/* BLUETOOTH CORE SPECIFICATION Version 5.3 | Vol 3, Part A\n\t * page 1059:\n\t *\n\t * Valid range: 0x0001-0x00ff\n\t *\n\t * Table 4.15: L2CAP_LE_CREDIT_BASED_CONNECTION_REQ SPSM ranges\n\t */\n\tif (!psm || __le16_to_cpu(psm) > L2CAP_PSM_LE_DYN_END) {\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\t\tchan = NULL;\n\t\tgoto response;\n\t}\n\n\t/* Check if we have socket listening on psm */\n\tpchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, &conn->hcon->src,\n\t\t\t\t\t &conn->hcon->dst, LE_LINK);\n\tif (!pchan) {\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\t\tchan = NULL;\n\t\tgoto response;\n\t}\n\n\tmutex_lock(&conn->chan_lock);\n\tl2cap_chan_lock(pchan);\n\n\tif (!smp_sufficient_security(conn->hcon, pchan->sec_level,\n\t\t\t\t     SMP_ALLOW_STK)) {\n\t\tresult = L2CAP_CR_LE_AUTHENTICATION;\n\t\tchan = NULL;\n\t\tgoto response_unlock;\n\t}\n\n\t/* Check for valid dynamic CID range */\n\tif (scid < L2CAP_CID_DYN_START || scid > L2CAP_CID_LE_DYN_END) {\n\t\tresult = L2CAP_CR_LE_INVALID_SCID;\n\t\tchan = NULL;\n\t\tgoto response_unlock;\n\t}\n\n\t/* Check if we already have channel with that dcid */\n\tif (__l2cap_get_chan_by_dcid(conn, scid)) {\n\t\tresult = L2CAP_CR_LE_SCID_IN_USE;\n\t\tchan = NULL;\n\t\tgoto response_unlock;\n\t}\n\n\tchan = pchan->ops->new_connection(pchan);\n\tif (!chan) {\n\t\tresult = L2CAP_CR_LE_NO_MEM;\n\t\tgoto response_unlock;\n\t}\n\n\tbacpy(&chan->src, &conn->hcon->src);\n\tbacpy(&chan->dst, &conn->hcon->dst);\n\tchan->src_type = bdaddr_src_type(conn->hcon);\n\tchan->dst_type = bdaddr_dst_type(conn->hcon);\n\tchan->psm  = psm;\n\tchan->dcid = scid;\n\tchan->omtu = mtu;\n\tchan->remote_mps = mps;\n\n\t__l2cap_chan_add(conn, chan);\n\n\tl2cap_le_flowctl_init(chan, __le16_to_cpu(req->credits));\n\n\tdcid = chan->scid;\n\tcredits = chan->rx_credits;\n\n\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\n\tchan->ident = cmd->ident;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t/* The following result value is actually not defined\n\t\t * for LE CoC but we use it to let the function know\n\t\t * that it should bail out after doing its cleanup\n\t\t * instead of sending a response.\n\t\t */\n\t\tresult = L2CAP_CR_PEND;\n\t\tchan->ops->defer(chan);\n\t} else {\n\t\tl2cap_chan_ready(chan);\n\t\tresult = L2CAP_CR_LE_SUCCESS;\n\t}\n\nresponse_unlock:\n\tl2cap_chan_unlock(pchan);\n\tmutex_unlock(&conn->chan_lock);\n\tl2cap_chan_put(pchan);\n\n\tif (result == L2CAP_CR_PEND)\n\t\treturn 0;\n\nresponse:\n\tif (chan) {\n\t\trsp.mtu = cpu_to_le16(chan->imtu);\n\t\trsp.mps = cpu_to_le16(chan->mps);\n\t} else {\n\t\trsp.mtu = 0;\n\t\trsp.mps = 0;\n\t}\n\n\trsp.dcid    = cpu_to_le16(dcid);\n\trsp.credits = cpu_to_le16(credits);\n\trsp.result  = cpu_to_le16(result);\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_LE_CONN_RSP, sizeof(rsp), &rsp);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_le_credits(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tstruct l2cap_le_credits *pkt;\n\tstruct l2cap_chan *chan;\n\tu16 cid, credits, max_credits;\n\n\tif (cmd_len != sizeof(*pkt))\n\t\treturn -EPROTO;\n\n\tpkt = (struct l2cap_le_credits *) data;\n\tcid\t= __le16_to_cpu(pkt->cid);\n\tcredits\t= __le16_to_cpu(pkt->credits);\n\n\tBT_DBG(\"cid 0x%4.4x credits 0x%4.4x\", cid, credits);\n\n\tchan = l2cap_get_chan_by_dcid(conn, cid);\n\tif (!chan)\n\t\treturn -EBADSLT;\n\n\tmax_credits = LE_FLOWCTL_MAX_CREDITS - chan->tx_credits;\n\tif (credits > max_credits) {\n\t\tBT_ERR(\"LE credits overflow\");\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\n\t\t/* Return 0 so that we don't trigger an unnecessary\n\t\t * command reject packet.\n\t\t */\n\t\tgoto unlock;\n\t}\n\n\tchan->tx_credits += credits;\n\n\t/* Resume sending */\n\tl2cap_le_flowctl_send(chan);\n\n\tif (chan->tx_credits)\n\t\tchan->ops->resume(chan);\n\nunlock:\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_ecred_conn_req(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_ecred_conn_req *req = (void *) data;\n\tstruct {\n\t\tstruct l2cap_ecred_conn_rsp rsp;\n\t\t__le16 dcid[L2CAP_ECRED_MAX_CID];\n\t} __packed pdu;\n\tstruct l2cap_chan *chan, *pchan;\n\tu16 mtu, mps;\n\t__le16 psm;\n\tu8 result, len = 0;\n\tint i, num_scid;\n\tbool defer = false;\n\n\tif (!enable_ecred)\n\t\treturn -EINVAL;\n\n\tif (cmd_len < sizeof(*req) || (cmd_len - sizeof(*req)) % sizeof(u16)) {\n\t\tresult = L2CAP_CR_LE_INVALID_PARAMS;\n\t\tgoto response;\n\t}\n\n\tcmd_len -= sizeof(*req);\n\tnum_scid = cmd_len / sizeof(u16);\n\n\tif (num_scid > ARRAY_SIZE(pdu.dcid)) {\n\t\tresult = L2CAP_CR_LE_INVALID_PARAMS;\n\t\tgoto response;\n\t}\n\n\tmtu  = __le16_to_cpu(req->mtu);\n\tmps  = __le16_to_cpu(req->mps);\n\n\tif (mtu < L2CAP_ECRED_MIN_MTU || mps < L2CAP_ECRED_MIN_MPS) {\n\t\tresult = L2CAP_CR_LE_UNACCEPT_PARAMS;\n\t\tgoto response;\n\t}\n\n\tpsm  = req->psm;\n\n\t/* BLUETOOTH CORE SPECIFICATION Version 5.3 | Vol 3, Part A\n\t * page 1059:\n\t *\n\t * Valid range: 0x0001-0x00ff\n\t *\n\t * Table 4.15: L2CAP_LE_CREDIT_BASED_CONNECTION_REQ SPSM ranges\n\t */\n\tif (!psm || __le16_to_cpu(psm) > L2CAP_PSM_LE_DYN_END) {\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\t\tgoto response;\n\t}\n\n\tBT_DBG(\"psm 0x%2.2x mtu %u mps %u\", __le16_to_cpu(psm), mtu, mps);\n\n\tmemset(&pdu, 0, sizeof(pdu));\n\n\t/* Check if we have socket listening on psm */\n\tpchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, &conn->hcon->src,\n\t\t\t\t\t &conn->hcon->dst, LE_LINK);\n\tif (!pchan) {\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\t\tgoto response;\n\t}\n\n\tmutex_lock(&conn->chan_lock);\n\tl2cap_chan_lock(pchan);\n\n\tif (!smp_sufficient_security(conn->hcon, pchan->sec_level,\n\t\t\t\t     SMP_ALLOW_STK)) {\n\t\tresult = L2CAP_CR_LE_AUTHENTICATION;\n\t\tgoto unlock;\n\t}\n\n\tresult = L2CAP_CR_LE_SUCCESS;\n\n\tfor (i = 0; i < num_scid; i++) {\n\t\tu16 scid = __le16_to_cpu(req->scid[i]);\n\n\t\tBT_DBG(\"scid[%d] 0x%4.4x\", i, scid);\n\n\t\tpdu.dcid[i] = 0x0000;\n\t\tlen += sizeof(*pdu.dcid);\n\n\t\t/* Check for valid dynamic CID range */\n\t\tif (scid < L2CAP_CID_DYN_START || scid > L2CAP_CID_LE_DYN_END) {\n\t\t\tresult = L2CAP_CR_LE_INVALID_SCID;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check if we already have channel with that dcid */\n\t\tif (__l2cap_get_chan_by_dcid(conn, scid)) {\n\t\t\tresult = L2CAP_CR_LE_SCID_IN_USE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tchan = pchan->ops->new_connection(pchan);\n\t\tif (!chan) {\n\t\t\tresult = L2CAP_CR_LE_NO_MEM;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbacpy(&chan->src, &conn->hcon->src);\n\t\tbacpy(&chan->dst, &conn->hcon->dst);\n\t\tchan->src_type = bdaddr_src_type(conn->hcon);\n\t\tchan->dst_type = bdaddr_dst_type(conn->hcon);\n\t\tchan->psm  = psm;\n\t\tchan->dcid = scid;\n\t\tchan->omtu = mtu;\n\t\tchan->remote_mps = mps;\n\n\t\t__l2cap_chan_add(conn, chan);\n\n\t\tl2cap_ecred_init(chan, __le16_to_cpu(req->credits));\n\n\t\t/* Init response */\n\t\tif (!pdu.rsp.credits) {\n\t\t\tpdu.rsp.mtu = cpu_to_le16(chan->imtu);\n\t\t\tpdu.rsp.mps = cpu_to_le16(chan->mps);\n\t\t\tpdu.rsp.credits = cpu_to_le16(chan->rx_credits);\n\t\t}\n\n\t\tpdu.dcid[i] = cpu_to_le16(chan->scid);\n\n\t\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\n\t\tchan->ident = cmd->ident;\n\n\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t\tdefer = true;\n\t\t\tchan->ops->defer(chan);\n\t\t} else {\n\t\t\tl2cap_chan_ready(chan);\n\t\t}\n\t}\n\nunlock:\n\tl2cap_chan_unlock(pchan);\n\tmutex_unlock(&conn->chan_lock);\n\tl2cap_chan_put(pchan);\n\nresponse:\n\tpdu.rsp.result = cpu_to_le16(result);\n\n\tif (defer)\n\t\treturn 0;\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_ECRED_CONN_RSP,\n\t\t       sizeof(pdu.rsp) + len, &pdu);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_ecred_conn_rsp(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_ecred_conn_rsp *rsp = (void *) data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tu16 mtu, mps, credits, result;\n\tstruct l2cap_chan *chan, *tmp;\n\tint err = 0, sec_level;\n\tint i = 0;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tmtu     = __le16_to_cpu(rsp->mtu);\n\tmps     = __le16_to_cpu(rsp->mps);\n\tcredits = __le16_to_cpu(rsp->credits);\n\tresult  = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"mtu %u mps %u credits %u result 0x%4.4x\", mtu, mps, credits,\n\t       result);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tcmd_len -= sizeof(*rsp);\n\n\tlist_for_each_entry_safe(chan, tmp, &conn->chan_l, list) {\n\t\tu16 dcid;\n\n\t\tif (chan->ident != cmd->ident ||\n\t\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL ||\n\t\t    chan->state == BT_CONNECTED)\n\t\t\tcontinue;\n\n\t\tl2cap_chan_lock(chan);\n\n\t\t/* Check that there is a dcid for each pending channel */\n\t\tif (cmd_len < sizeof(dcid)) {\n\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdcid = __le16_to_cpu(rsp->dcid[i++]);\n\t\tcmd_len -= sizeof(u16);\n\n\t\tBT_DBG(\"dcid[%d] 0x%4.4x\", i, dcid);\n\n\t\t/* Check if dcid is already in use */\n\t\tif (dcid && __l2cap_get_chan_by_dcid(conn, dcid)) {\n\t\t\t/* If a device receives a\n\t\t\t * L2CAP_CREDIT_BASED_CONNECTION_RSP packet with an\n\t\t\t * already-assigned Destination CID, then both the\n\t\t\t * original channel and the new channel shall be\n\t\t\t * immediately discarded and not used.\n\t\t\t */\n\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tchan = __l2cap_get_chan_by_dcid(conn, dcid);\n\t\t\tl2cap_chan_lock(chan);\n\t\t\tl2cap_chan_del(chan, ECONNRESET);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (result) {\n\t\tcase L2CAP_CR_LE_AUTHENTICATION:\n\t\tcase L2CAP_CR_LE_ENCRYPTION:\n\t\t\t/* If we already have MITM protection we can't do\n\t\t\t * anything.\n\t\t\t */\n\t\t\tif (hcon->sec_level > BT_SECURITY_MEDIUM) {\n\t\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsec_level = hcon->sec_level + 1;\n\t\t\tif (chan->sec_level < sec_level)\n\t\t\t\tchan->sec_level = sec_level;\n\n\t\t\t/* We'll need to send a new Connect Request */\n\t\t\tclear_bit(FLAG_ECRED_CONN_REQ_SENT, &chan->flags);\n\n\t\t\tsmp_conn_security(hcon, chan->sec_level);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CR_LE_BAD_PSM:\n\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* If dcid was not set it means channels was refused */\n\t\t\tif (!dcid) {\n\t\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchan->ident = 0;\n\t\t\tchan->dcid = dcid;\n\t\t\tchan->omtu = mtu;\n\t\t\tchan->remote_mps = mps;\n\t\t\tchan->tx_credits = credits;\n\t\t\tl2cap_chan_ready(chan);\n\t\t\tbreak;\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn err;\n}\n\nstatic inline int l2cap_ecred_reconf_req(struct l2cap_conn *conn,\n\t\t\t\t\t struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t\t u8 *data)\n{\n\tstruct l2cap_ecred_reconf_req *req = (void *) data;\n\tstruct l2cap_ecred_reconf_rsp rsp;\n\tu16 mtu, mps, result;\n\tstruct l2cap_chan *chan;\n\tint i, num_scid;\n\n\tif (!enable_ecred)\n\t\treturn -EINVAL;\n\n\tif (cmd_len < sizeof(*req) || cmd_len - sizeof(*req) % sizeof(u16)) {\n\t\tresult = L2CAP_CR_LE_INVALID_PARAMS;\n\t\tgoto respond;\n\t}\n\n\tmtu = __le16_to_cpu(req->mtu);\n\tmps = __le16_to_cpu(req->mps);\n\n\tBT_DBG(\"mtu %u mps %u\", mtu, mps);\n\n\tif (mtu < L2CAP_ECRED_MIN_MTU) {\n\t\tresult = L2CAP_RECONF_INVALID_MTU;\n\t\tgoto respond;\n\t}\n\n\tif (mps < L2CAP_ECRED_MIN_MPS) {\n\t\tresult = L2CAP_RECONF_INVALID_MPS;\n\t\tgoto respond;\n\t}\n\n\tcmd_len -= sizeof(*req);\n\tnum_scid = cmd_len / sizeof(u16);\n\tresult = L2CAP_RECONF_SUCCESS;\n\n\tfor (i = 0; i < num_scid; i++) {\n\t\tu16 scid;\n\n\t\tscid = __le16_to_cpu(req->scid[i]);\n\t\tif (!scid)\n\t\t\treturn -EPROTO;\n\n\t\tchan = __l2cap_get_chan_by_dcid(conn, scid);\n\t\tif (!chan)\n\t\t\tcontinue;\n\n\t\t/* If the MTU value is decreased for any of the included\n\t\t * channels, then the receiver shall disconnect all\n\t\t * included channels.\n\t\t */\n\t\tif (chan->omtu > mtu) {\n\t\t\tBT_ERR(\"chan %p decreased MTU %u -> %u\", chan,\n\t\t\t       chan->omtu, mtu);\n\t\t\tresult = L2CAP_RECONF_INVALID_MTU;\n\t\t}\n\n\t\tchan->omtu = mtu;\n\t\tchan->remote_mps = mps;\n\t}\n\nrespond:\n\trsp.result = cpu_to_le16(result);\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_ECRED_RECONF_RSP, sizeof(rsp),\n\t\t       &rsp);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_ecred_reconf_rsp(struct l2cap_conn *conn,\n\t\t\t\t\t struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t\t u8 *data)\n{\n\tstruct l2cap_chan *chan, *tmp;\n\tstruct l2cap_ecred_conn_rsp *rsp = (void *) data;\n\tu16 result;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tresult = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"result 0x%4.4x\", rsp->result);\n\n\tif (!result)\n\t\treturn 0;\n\n\tlist_for_each_entry_safe(chan, tmp, &conn->chan_l, list) {\n\t\tif (chan->ident != cmd->ident)\n\t\t\tcontinue;\n\n\t\tl2cap_chan_del(chan, ECONNRESET);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int l2cap_le_command_rej(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_cmd_rej_unk *rej = (struct l2cap_cmd_rej_unk *) data;\n\tstruct l2cap_chan *chan;\n\n\tif (cmd_len < sizeof(*rej))\n\t\treturn -EPROTO;\n\n\tmutex_lock(&conn->chan_lock);\n\n\tchan = __l2cap_get_chan_by_ident(conn, cmd->ident);\n\tif (!chan)\n\t\tgoto done;\n\n\tl2cap_chan_lock(chan);\n\tl2cap_chan_del(chan, ECONNREFUSED);\n\tl2cap_chan_unlock(chan);\n\ndone:\n\tmutex_unlock(&conn->chan_lock);\n\treturn 0;\n}\n\nstatic inline int l2cap_le_sig_cmd(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tint err = 0;\n\n\tswitch (cmd->code) {\n\tcase L2CAP_COMMAND_REJ:\n\t\tl2cap_le_command_rej(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONN_PARAM_UPDATE_REQ:\n\t\terr = l2cap_conn_param_update_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONN_PARAM_UPDATE_RSP:\n\t\tbreak;\n\n\tcase L2CAP_LE_CONN_RSP:\n\t\tl2cap_le_connect_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_LE_CONN_REQ:\n\t\terr = l2cap_le_connect_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_LE_CREDITS:\n\t\terr = l2cap_le_credits(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECRED_CONN_REQ:\n\t\terr = l2cap_ecred_conn_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECRED_CONN_RSP:\n\t\terr = l2cap_ecred_conn_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECRED_RECONF_REQ:\n\t\terr = l2cap_ecred_reconf_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECRED_RECONF_RSP:\n\t\terr = l2cap_ecred_reconf_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_DISCONN_REQ:\n\t\terr = l2cap_disconnect_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_DISCONN_RSP:\n\t\tl2cap_disconnect_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Unknown LE signaling command 0x%2.2x\", cmd->code);\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic inline void l2cap_le_sig_channel(struct l2cap_conn *conn,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_cmd_hdr *cmd;\n\tu16 len;\n\tint err;\n\n\tif (hcon->type != LE_LINK)\n\t\tgoto drop;\n\n\tif (skb->len < L2CAP_CMD_HDR_SIZE)\n\t\tgoto drop;\n\n\tcmd = (void *) skb->data;\n\tskb_pull(skb, L2CAP_CMD_HDR_SIZE);\n\n\tlen = le16_to_cpu(cmd->len);\n\n\tBT_DBG(\"code 0x%2.2x len %d id 0x%2.2x\", cmd->code, len, cmd->ident);\n\n\tif (len != skb->len || !cmd->ident) {\n\t\tBT_DBG(\"corrupted command\");\n\t\tgoto drop;\n\t}\n\n\terr = l2cap_le_sig_cmd(conn, cmd, len, skb->data);\n\tif (err) {\n\t\tstruct l2cap_cmd_rej_unk rej;\n\n\t\tBT_ERR(\"Wrong link type (%d)\", err);\n\n\t\trej.reason = cpu_to_le16(L2CAP_REJ_NOT_UNDERSTOOD);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,\n\t\t\t       sizeof(rej), &rej);\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}\n\nstatic inline void l2cap_sig_channel(struct l2cap_conn *conn,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_cmd_hdr *cmd;\n\tint err;\n\n\tl2cap_raw_recv(conn, skb);\n\n\tif (hcon->type != ACL_LINK)\n\t\tgoto drop;\n\n\twhile (skb->len >= L2CAP_CMD_HDR_SIZE) {\n\t\tu16 len;\n\n\t\tcmd = (void *) skb->data;\n\t\tskb_pull(skb, L2CAP_CMD_HDR_SIZE);\n\n\t\tlen = le16_to_cpu(cmd->len);\n\n\t\tBT_DBG(\"code 0x%2.2x len %d id 0x%2.2x\", cmd->code, len,\n\t\t       cmd->ident);\n\n\t\tif (len > skb->len || !cmd->ident) {\n\t\t\tBT_DBG(\"corrupted command\");\n\t\t\tbreak;\n\t\t}\n\n\t\terr = l2cap_bredr_sig_cmd(conn, cmd, len, skb->data);\n\t\tif (err) {\n\t\t\tstruct l2cap_cmd_rej_unk rej;\n\n\t\t\tBT_ERR(\"Wrong link type (%d)\", err);\n\n\t\t\trej.reason = cpu_to_le16(L2CAP_REJ_NOT_UNDERSTOOD);\n\t\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,\n\t\t\t\t       sizeof(rej), &rej);\n\t\t}\n\n\t\tskb_pull(skb, len);\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}\n\nstatic int l2cap_check_fcs(struct l2cap_chan *chan,  struct sk_buff *skb)\n{\n\tu16 our_fcs, rcv_fcs;\n\tint hdr_size;\n\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\thdr_size = L2CAP_EXT_HDR_SIZE;\n\telse\n\t\thdr_size = L2CAP_ENH_HDR_SIZE;\n\n\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\tskb_trim(skb, skb->len - L2CAP_FCS_SIZE);\n\t\trcv_fcs = get_unaligned_le16(skb->data + skb->len);\n\t\tour_fcs = crc16(0, skb->data - hdr_size, skb->len + hdr_size);\n\n\t\tif (our_fcs != rcv_fcs)\n\t\t\treturn -EBADMSG;\n\t}\n\treturn 0;\n}\n\nstatic void l2cap_send_i_or_rr_or_rnr(struct l2cap_chan *chan)\n{\n\tstruct l2cap_ctrl control;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.final = 1;\n\tcontrol.reqseq = chan->buffer_seq;\n\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\n\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\tcontrol.super = L2CAP_SUPER_RNR;\n\t\tl2cap_send_sframe(chan, &control);\n\t}\n\n\tif (test_and_clear_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&\n\t    chan->unacked_frames > 0)\n\t\t__set_retrans_timer(chan);\n\n\t/* Send pending iframes */\n\tl2cap_ertm_send(chan);\n\n\tif (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state) &&\n\t    test_bit(CONN_SEND_FBIT, &chan->conn_state)) {\n\t\t/* F-bit wasn't sent in an s-frame or i-frame yet, so\n\t\t * send it now.\n\t\t */\n\t\tcontrol.super = L2CAP_SUPER_RR;\n\t\tl2cap_send_sframe(chan, &control);\n\t}\n}\n\nstatic void append_skb_frag(struct sk_buff *skb, struct sk_buff *new_frag,\n\t\t\t    struct sk_buff **last_frag)\n{\n\t/* skb->len reflects data in skb as well as all fragments\n\t * skb->data_len reflects only data in fragments\n\t */\n\tif (!skb_has_frag_list(skb))\n\t\tskb_shinfo(skb)->frag_list = new_frag;\n\n\tnew_frag->next = NULL;\n\n\t(*last_frag)->next = new_frag;\n\t*last_frag = new_frag;\n\n\tskb->len += new_frag->len;\n\tskb->data_len += new_frag->len;\n\tskb->truesize += new_frag->truesize;\n}\n\nstatic int l2cap_reassemble_sdu(struct l2cap_chan *chan, struct sk_buff *skb,\n\t\t\t\tstruct l2cap_ctrl *control)\n{\n\tint err = -EINVAL;\n\n\tswitch (control->sar) {\n\tcase L2CAP_SAR_UNSEGMENTED:\n\t\tif (chan->sdu)\n\t\t\tbreak;\n\n\t\terr = chan->ops->recv(chan, skb);\n\t\tbreak;\n\n\tcase L2CAP_SAR_START:\n\t\tif (chan->sdu)\n\t\t\tbreak;\n\n\t\tif (!pskb_may_pull(skb, L2CAP_SDULEN_SIZE))\n\t\t\tbreak;\n\n\t\tchan->sdu_len = get_unaligned_le16(skb->data);\n\t\tskb_pull(skb, L2CAP_SDULEN_SIZE);\n\n\t\tif (chan->sdu_len > chan->imtu) {\n\t\t\terr = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (skb->len >= chan->sdu_len)\n\t\t\tbreak;\n\n\t\tchan->sdu = skb;\n\t\tchan->sdu_last_frag = skb;\n\n\t\tskb = NULL;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase L2CAP_SAR_CONTINUE:\n\t\tif (!chan->sdu)\n\t\t\tbreak;\n\n\t\tappend_skb_frag(chan->sdu, skb,\n\t\t\t\t&chan->sdu_last_frag);\n\t\tskb = NULL;\n\n\t\tif (chan->sdu->len >= chan->sdu_len)\n\t\t\tbreak;\n\n\t\terr = 0;\n\t\tbreak;\n\n\tcase L2CAP_SAR_END:\n\t\tif (!chan->sdu)\n\t\t\tbreak;\n\n\t\tappend_skb_frag(chan->sdu, skb,\n\t\t\t\t&chan->sdu_last_frag);\n\t\tskb = NULL;\n\n\t\tif (chan->sdu->len != chan->sdu_len)\n\t\t\tbreak;\n\n\t\terr = chan->ops->recv(chan, chan->sdu);\n\n\t\tif (!err) {\n\t\t\t/* Reassembly complete */\n\t\t\tchan->sdu = NULL;\n\t\t\tchan->sdu_last_frag = NULL;\n\t\t\tchan->sdu_len = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tkfree_skb(chan->sdu);\n\t\tchan->sdu = NULL;\n\t\tchan->sdu_last_frag = NULL;\n\t\tchan->sdu_len = 0;\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_resegment(struct l2cap_chan *chan)\n{\n\t/* Placeholder */\n\treturn 0;\n}\n\nvoid l2cap_chan_busy(struct l2cap_chan *chan, int busy)\n{\n\tu8 event;\n\n\tif (chan->mode != L2CAP_MODE_ERTM)\n\t\treturn;\n\n\tevent = busy ? L2CAP_EV_LOCAL_BUSY_DETECTED : L2CAP_EV_LOCAL_BUSY_CLEAR;\n\tl2cap_tx(chan, NULL, NULL, event);\n}\n\nstatic int l2cap_rx_queued_iframes(struct l2cap_chan *chan)\n{\n\tint err = 0;\n\t/* Pass sequential frames to l2cap_reassemble_sdu()\n\t * until a gap is encountered.\n\t */\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twhile (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\tstruct sk_buff *skb;\n\t\tBT_DBG(\"Searching for skb with txseq %d (queue len %d)\",\n\t\t       chan->buffer_seq, skb_queue_len(&chan->srej_q));\n\n\t\tskb = l2cap_ertm_seq_in_queue(&chan->srej_q, chan->buffer_seq);\n\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tskb_unlink(skb, &chan->srej_q);\n\t\tchan->buffer_seq = __next_seq(chan, chan->buffer_seq);\n\t\terr = l2cap_reassemble_sdu(chan, skb, &bt_cb(skb)->l2cap);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (skb_queue_empty(&chan->srej_q)) {\n\t\tchan->rx_state = L2CAP_RX_STATE_RECV;\n\t\tl2cap_send_ack(chan);\n\t}\n\n\treturn err;\n}\n\nstatic void l2cap_handle_srej(struct l2cap_chan *chan,\n\t\t\t      struct l2cap_ctrl *control)\n{\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tif (control->reqseq == chan->next_tx_seq) {\n\t\tBT_DBG(\"Invalid reqseq %d, disconnecting\", control->reqseq);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tskb = l2cap_ertm_seq_in_queue(&chan->tx_q, control->reqseq);\n\n\tif (skb == NULL) {\n\t\tBT_DBG(\"Seq %d not available for retransmission\",\n\t\t       control->reqseq);\n\t\treturn;\n\t}\n\n\tif (chan->max_tx != 0 && bt_cb(skb)->l2cap.retries >= chan->max_tx) {\n\t\tBT_DBG(\"Retry limit exceeded (%d)\", chan->max_tx);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\tif (control->poll) {\n\t\tl2cap_pass_to_tx(chan, control);\n\n\t\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\t\tl2cap_retransmit(chan, control);\n\t\tl2cap_ertm_send(chan);\n\n\t\tif (chan->tx_state == L2CAP_TX_STATE_WAIT_F) {\n\t\t\tset_bit(CONN_SREJ_ACT, &chan->conn_state);\n\t\t\tchan->srej_save_reqseq = control->reqseq;\n\t\t}\n\t} else {\n\t\tl2cap_pass_to_tx_fbit(chan, control);\n\n\t\tif (control->final) {\n\t\t\tif (chan->srej_save_reqseq != control->reqseq ||\n\t\t\t    !test_and_clear_bit(CONN_SREJ_ACT,\n\t\t\t\t\t\t&chan->conn_state))\n\t\t\t\tl2cap_retransmit(chan, control);\n\t\t} else {\n\t\t\tl2cap_retransmit(chan, control);\n\t\t\tif (chan->tx_state == L2CAP_TX_STATE_WAIT_F) {\n\t\t\t\tset_bit(CONN_SREJ_ACT, &chan->conn_state);\n\t\t\t\tchan->srej_save_reqseq = control->reqseq;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void l2cap_handle_rej(struct l2cap_chan *chan,\n\t\t\t     struct l2cap_ctrl *control)\n{\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tif (control->reqseq == chan->next_tx_seq) {\n\t\tBT_DBG(\"Invalid reqseq %d, disconnecting\", control->reqseq);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tskb = l2cap_ertm_seq_in_queue(&chan->tx_q, control->reqseq);\n\n\tif (chan->max_tx && skb &&\n\t    bt_cb(skb)->l2cap.retries >= chan->max_tx) {\n\t\tBT_DBG(\"Retry limit exceeded (%d)\", chan->max_tx);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\tl2cap_pass_to_tx(chan, control);\n\n\tif (control->final) {\n\t\tif (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))\n\t\t\tl2cap_retransmit_all(chan, control);\n\t} else {\n\t\tl2cap_retransmit_all(chan, control);\n\t\tl2cap_ertm_send(chan);\n\t\tif (chan->tx_state == L2CAP_TX_STATE_WAIT_F)\n\t\t\tset_bit(CONN_REJ_ACT, &chan->conn_state);\n\t}\n}\n\nstatic u8 l2cap_classify_txseq(struct l2cap_chan *chan, u16 txseq)\n{\n\tBT_DBG(\"chan %p, txseq %d\", chan, txseq);\n\n\tBT_DBG(\"last_acked_seq %d, expected_tx_seq %d\", chan->last_acked_seq,\n\t       chan->expected_tx_seq);\n\n\tif (chan->rx_state == L2CAP_RX_STATE_SREJ_SENT) {\n\t\tif (__seq_offset(chan, txseq, chan->last_acked_seq) >=\n\t\t    chan->tx_win) {\n\t\t\t/* See notes below regarding \"double poll\" and\n\t\t\t * invalid packets.\n\t\t\t */\n\t\t\tif (chan->tx_win <= ((chan->tx_win_max + 1) >> 1)) {\n\t\t\t\tBT_DBG(\"Invalid/Ignore - after SREJ\");\n\t\t\t\treturn L2CAP_TXSEQ_INVALID_IGNORE;\n\t\t\t} else {\n\t\t\t\tBT_DBG(\"Invalid - in window after SREJ sent\");\n\t\t\t\treturn L2CAP_TXSEQ_INVALID;\n\t\t\t}\n\t\t}\n\n\t\tif (chan->srej_list.head == txseq) {\n\t\t\tBT_DBG(\"Expected SREJ\");\n\t\t\treturn L2CAP_TXSEQ_EXPECTED_SREJ;\n\t\t}\n\n\t\tif (l2cap_ertm_seq_in_queue(&chan->srej_q, txseq)) {\n\t\t\tBT_DBG(\"Duplicate SREJ - txseq already stored\");\n\t\t\treturn L2CAP_TXSEQ_DUPLICATE_SREJ;\n\t\t}\n\n\t\tif (l2cap_seq_list_contains(&chan->srej_list, txseq)) {\n\t\t\tBT_DBG(\"Unexpected SREJ - not requested\");\n\t\t\treturn L2CAP_TXSEQ_UNEXPECTED_SREJ;\n\t\t}\n\t}\n\n\tif (chan->expected_tx_seq == txseq) {\n\t\tif (__seq_offset(chan, txseq, chan->last_acked_seq) >=\n\t\t    chan->tx_win) {\n\t\t\tBT_DBG(\"Invalid - txseq outside tx window\");\n\t\t\treturn L2CAP_TXSEQ_INVALID;\n\t\t} else {\n\t\t\tBT_DBG(\"Expected\");\n\t\t\treturn L2CAP_TXSEQ_EXPECTED;\n\t\t}\n\t}\n\n\tif (__seq_offset(chan, txseq, chan->last_acked_seq) <\n\t    __seq_offset(chan, chan->expected_tx_seq, chan->last_acked_seq)) {\n\t\tBT_DBG(\"Duplicate - expected_tx_seq later than txseq\");\n\t\treturn L2CAP_TXSEQ_DUPLICATE;\n\t}\n\n\tif (__seq_offset(chan, txseq, chan->last_acked_seq) >= chan->tx_win) {\n\t\t/* A source of invalid packets is a \"double poll\" condition,\n\t\t * where delays cause us to send multiple poll packets.  If\n\t\t * the remote stack receives and processes both polls,\n\t\t * sequence numbers can wrap around in such a way that a\n\t\t * resent frame has a sequence number that looks like new data\n\t\t * with a sequence gap.  This would trigger an erroneous SREJ\n\t\t * request.\n\t\t *\n\t\t * Fortunately, this is impossible with a tx window that's\n\t\t * less than half of the maximum sequence number, which allows\n\t\t * invalid frames to be safely ignored.\n\t\t *\n\t\t * With tx window sizes greater than half of the tx window\n\t\t * maximum, the frame is invalid and cannot be ignored.  This\n\t\t * causes a disconnect.\n\t\t */\n\n\t\tif (chan->tx_win <= ((chan->tx_win_max + 1) >> 1)) {\n\t\t\tBT_DBG(\"Invalid/Ignore - txseq outside tx window\");\n\t\t\treturn L2CAP_TXSEQ_INVALID_IGNORE;\n\t\t} else {\n\t\t\tBT_DBG(\"Invalid - txseq outside tx window\");\n\t\t\treturn L2CAP_TXSEQ_INVALID;\n\t\t}\n\t} else {\n\t\tBT_DBG(\"Unexpected - txseq indicates missing frames\");\n\t\treturn L2CAP_TXSEQ_UNEXPECTED;\n\t}\n}\n\nstatic int l2cap_rx_state_recv(struct l2cap_chan *chan,\n\t\t\t       struct l2cap_ctrl *control,\n\t\t\t       struct sk_buff *skb, u8 event)\n{\n\tstruct l2cap_ctrl local_control;\n\tint err = 0;\n\tbool skb_in_use = false;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, event %d\", chan, control, skb,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_RECV_IFRAME:\n\t\tswitch (l2cap_classify_txseq(chan, control->txseq)) {\n\t\tcase L2CAP_TXSEQ_EXPECTED:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\n\t\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\t\tBT_DBG(\"Busy, discarding expected seq %d\",\n\t\t\t\t       control->txseq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchan->expected_tx_seq = __next_seq(chan,\n\t\t\t\t\t\t\t   control->txseq);\n\n\t\t\tchan->buffer_seq = chan->expected_tx_seq;\n\t\t\tskb_in_use = true;\n\n\t\t\t/* l2cap_reassemble_sdu may free skb, hence invalidate\n\t\t\t * control, so make a copy in advance to use it after\n\t\t\t * l2cap_reassemble_sdu returns and to avoid the race\n\t\t\t * condition, for example:\n\t\t\t *\n\t\t\t * The current thread calls:\n\t\t\t *   l2cap_reassemble_sdu\n\t\t\t *     chan->ops->recv == l2cap_sock_recv_cb\n\t\t\t *       __sock_queue_rcv_skb\n\t\t\t * Another thread calls:\n\t\t\t *   bt_sock_recvmsg\n\t\t\t *     skb_recv_datagram\n\t\t\t *     skb_free_datagram\n\t\t\t * Then the current thread tries to access control, but\n\t\t\t * it was freed by skb_free_datagram.\n\t\t\t */\n\t\t\tlocal_control = *control;\n\t\t\terr = l2cap_reassemble_sdu(chan, skb, control);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tif (local_control.final) {\n\t\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT,\n\t\t\t\t\t\t\t&chan->conn_state)) {\n\t\t\t\t\tlocal_control.final = 0;\n\t\t\t\t\tl2cap_retransmit_all(chan, &local_control);\n\t\t\t\t\tl2cap_ertm_send(chan);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state))\n\t\t\t\tl2cap_send_ack(chan);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_UNEXPECTED:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\n\t\t\t/* Can't issue SREJ frames in the local busy state.\n\t\t\t * Drop this frame, it will be seen as missing\n\t\t\t * when local busy is exited.\n\t\t\t */\n\t\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\t\tBT_DBG(\"Busy, discarding unexpected seq %d\",\n\t\t\t\t       control->txseq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* There was a gap in the sequence, so an SREJ\n\t\t\t * must be sent for each missing frame.  The\n\t\t\t * current frame is stored for later use.\n\t\t\t */\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tclear_bit(CONN_SREJ_ACT, &chan->conn_state);\n\t\t\tl2cap_seq_list_clear(&chan->srej_list);\n\t\t\tl2cap_send_srej(chan, control->txseq);\n\n\t\t\tchan->rx_state = L2CAP_RX_STATE_SREJ_SENT;\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_DUPLICATE:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID_IGNORE:\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID:\n\t\tdefault:\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RR:\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control->final) {\n\t\t\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state) &&\n\t\t\t    !__chan_is_moving(chan)) {\n\t\t\t\tcontrol->final = 0;\n\t\t\t\tl2cap_retransmit_all(chan, control);\n\t\t\t}\n\n\t\t\tl2cap_ertm_send(chan);\n\t\t} else if (control->poll) {\n\t\t\tl2cap_send_i_or_rr_or_rnr(chan);\n\t\t} else {\n\t\t\tif (test_and_clear_bit(CONN_REMOTE_BUSY,\n\t\t\t\t\t       &chan->conn_state) &&\n\t\t\t    chan->unacked_frames)\n\t\t\t\t__set_retrans_timer(chan);\n\n\t\t\tl2cap_ertm_send(chan);\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RNR:\n\t\tset_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control && control->poll) {\n\t\t\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\t\t\tl2cap_send_rr_or_rnr(chan, 0);\n\t\t}\n\t\t__clear_retrans_timer(chan);\n\t\tl2cap_seq_list_clear(&chan->retrans_list);\n\t\tbreak;\n\tcase L2CAP_EV_RECV_REJ:\n\t\tl2cap_handle_rej(chan, control);\n\t\tbreak;\n\tcase L2CAP_EV_RECV_SREJ:\n\t\tl2cap_handle_srej(chan, control);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (skb && !skb_in_use) {\n\t\tBT_DBG(\"Freeing %p\", skb);\n\t\tkfree_skb(skb);\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_rx_state_srej_sent(struct l2cap_chan *chan,\n\t\t\t\t    struct l2cap_ctrl *control,\n\t\t\t\t    struct sk_buff *skb, u8 event)\n{\n\tint err = 0;\n\tu16 txseq = control->txseq;\n\tbool skb_in_use = false;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, event %d\", chan, control, skb,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_RECV_IFRAME:\n\t\tswitch (l2cap_classify_txseq(chan, txseq)) {\n\t\tcase L2CAP_TXSEQ_EXPECTED:\n\t\t\t/* Keep frame for reassembly later */\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tchan->expected_tx_seq = __next_seq(chan, txseq);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_EXPECTED_SREJ:\n\t\t\tl2cap_seq_list_pop(&chan->srej_list);\n\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\terr = l2cap_rx_queued_iframes(chan);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_UNEXPECTED:\n\t\t\t/* Got a frame that can't be reassembled yet.\n\t\t\t * Save it for later, and send SREJs to cover\n\t\t\t * the missing frames.\n\t\t\t */\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tl2cap_send_srej(chan, control->txseq);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_UNEXPECTED_SREJ:\n\t\t\t/* This frame was requested with an SREJ, but\n\t\t\t * some expected retransmitted frames are\n\t\t\t * missing.  Request retransmission of missing\n\t\t\t * SREJ'd frames.\n\t\t\t */\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tl2cap_send_srej_list(chan, control->txseq);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_DUPLICATE_SREJ:\n\t\t\t/* We've already queued this frame.  Drop this copy. */\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_DUPLICATE:\n\t\t\t/* Expecting a later sequence number, so this frame\n\t\t\t * was already received.  Ignore it completely.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID_IGNORE:\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID:\n\t\tdefault:\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RR:\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control->final) {\n\t\t\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT,\n\t\t\t\t\t\t&chan->conn_state)) {\n\t\t\t\tcontrol->final = 0;\n\t\t\t\tl2cap_retransmit_all(chan, control);\n\t\t\t}\n\n\t\t\tl2cap_ertm_send(chan);\n\t\t} else if (control->poll) {\n\t\t\tif (test_and_clear_bit(CONN_REMOTE_BUSY,\n\t\t\t\t\t       &chan->conn_state) &&\n\t\t\t    chan->unacked_frames) {\n\t\t\t\t__set_retrans_timer(chan);\n\t\t\t}\n\n\t\t\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\t\t\tl2cap_send_srej_tail(chan);\n\t\t} else {\n\t\t\tif (test_and_clear_bit(CONN_REMOTE_BUSY,\n\t\t\t\t\t       &chan->conn_state) &&\n\t\t\t    chan->unacked_frames)\n\t\t\t\t__set_retrans_timer(chan);\n\n\t\t\tl2cap_send_ack(chan);\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RNR:\n\t\tset_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control->poll) {\n\t\t\tl2cap_send_srej_tail(chan);\n\t\t} else {\n\t\t\tstruct l2cap_ctrl rr_control;\n\t\t\tmemset(&rr_control, 0, sizeof(rr_control));\n\t\t\trr_control.sframe = 1;\n\t\t\trr_control.super = L2CAP_SUPER_RR;\n\t\t\trr_control.reqseq = chan->buffer_seq;\n\t\t\tl2cap_send_sframe(chan, &rr_control);\n\t\t}\n\n\t\tbreak;\n\tcase L2CAP_EV_RECV_REJ:\n\t\tl2cap_handle_rej(chan, control);\n\t\tbreak;\n\tcase L2CAP_EV_RECV_SREJ:\n\t\tl2cap_handle_srej(chan, control);\n\t\tbreak;\n\t}\n\n\tif (skb && !skb_in_use) {\n\t\tBT_DBG(\"Freeing %p\", skb);\n\t\tkfree_skb(skb);\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_finish_move(struct l2cap_chan *chan)\n{\n\tBT_DBG(\"chan %p\", chan);\n\n\tchan->rx_state = L2CAP_RX_STATE_RECV;\n\n\tif (chan->hs_hcon)\n\t\tchan->conn->mtu = chan->hs_hcon->hdev->block_mtu;\n\telse\n\t\tchan->conn->mtu = chan->conn->hcon->hdev->acl_mtu;\n\n\treturn l2cap_resegment(chan);\n}\n\nstatic int l2cap_rx_state_wait_p(struct l2cap_chan *chan,\n\t\t\t\t struct l2cap_ctrl *control,\n\t\t\t\t struct sk_buff *skb, u8 event)\n{\n\tint err;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, event %d\", chan, control, skb,\n\t       event);\n\n\tif (!control->poll)\n\t\treturn -EPROTO;\n\n\tl2cap_process_reqseq(chan, control->reqseq);\n\n\tif (!skb_queue_empty(&chan->tx_q))\n\t\tchan->tx_send_head = skb_peek(&chan->tx_q);\n\telse\n\t\tchan->tx_send_head = NULL;\n\n\t/* Rewind next_tx_seq to the point expected\n\t * by the receiver.\n\t */\n\tchan->next_tx_seq = control->reqseq;\n\tchan->unacked_frames = 0;\n\n\terr = l2cap_finish_move(chan);\n\tif (err)\n\t\treturn err;\n\n\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\tl2cap_send_i_or_rr_or_rnr(chan);\n\n\tif (event == L2CAP_EV_RECV_IFRAME)\n\t\treturn -EPROTO;\n\n\treturn l2cap_rx_state_recv(chan, control, NULL, event);\n}\n\nstatic int l2cap_rx_state_wait_f(struct l2cap_chan *chan,\n\t\t\t\t struct l2cap_ctrl *control,\n\t\t\t\t struct sk_buff *skb, u8 event)\n{\n\tint err;\n\n\tif (!control->final)\n\t\treturn -EPROTO;\n\n\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\tchan->rx_state = L2CAP_RX_STATE_RECV;\n\tl2cap_process_reqseq(chan, control->reqseq);\n\n\tif (!skb_queue_empty(&chan->tx_q))\n\t\tchan->tx_send_head = skb_peek(&chan->tx_q);\n\telse\n\t\tchan->tx_send_head = NULL;\n\n\t/* Rewind next_tx_seq to the point expected\n\t * by the receiver.\n\t */\n\tchan->next_tx_seq = control->reqseq;\n\tchan->unacked_frames = 0;\n\n\tif (chan->hs_hcon)\n\t\tchan->conn->mtu = chan->hs_hcon->hdev->block_mtu;\n\telse\n\t\tchan->conn->mtu = chan->conn->hcon->hdev->acl_mtu;\n\n\terr = l2cap_resegment(chan);\n\n\tif (!err)\n\t\terr = l2cap_rx_state_recv(chan, control, skb, event);\n\n\treturn err;\n}\n\nstatic bool __valid_reqseq(struct l2cap_chan *chan, u16 reqseq)\n{\n\t/* Make sure reqseq is for a packet that has been sent but not acked */\n\tu16 unacked;\n\n\tunacked = __seq_offset(chan, chan->next_tx_seq, chan->expected_ack_seq);\n\treturn __seq_offset(chan, chan->next_tx_seq, reqseq) <= unacked;\n}\n\nstatic int l2cap_rx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\n\t\t    struct sk_buff *skb, u8 event)\n{\n\tint err = 0;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, event %d, state %d\", chan,\n\t       control, skb, event, chan->rx_state);\n\n\tif (__valid_reqseq(chan, control->reqseq)) {\n\t\tswitch (chan->rx_state) {\n\t\tcase L2CAP_RX_STATE_RECV:\n\t\t\terr = l2cap_rx_state_recv(chan, control, skb, event);\n\t\t\tbreak;\n\t\tcase L2CAP_RX_STATE_SREJ_SENT:\n\t\t\terr = l2cap_rx_state_srej_sent(chan, control, skb,\n\t\t\t\t\t\t       event);\n\t\t\tbreak;\n\t\tcase L2CAP_RX_STATE_WAIT_P:\n\t\t\terr = l2cap_rx_state_wait_p(chan, control, skb, event);\n\t\t\tbreak;\n\t\tcase L2CAP_RX_STATE_WAIT_F:\n\t\t\terr = l2cap_rx_state_wait_f(chan, control, skb, event);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* shut it down */\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tBT_DBG(\"Invalid reqseq %d (next_tx_seq %d, expected_ack_seq %d\",\n\t\t       control->reqseq, chan->next_tx_seq,\n\t\t       chan->expected_ack_seq);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_stream_rx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\n\t\t\t   struct sk_buff *skb)\n{\n\t/* l2cap_reassemble_sdu may free skb, hence invalidate control, so store\n\t * the txseq field in advance to use it after l2cap_reassemble_sdu\n\t * returns and to avoid the race condition, for example:\n\t *\n\t * The current thread calls:\n\t *   l2cap_reassemble_sdu\n\t *     chan->ops->recv == l2cap_sock_recv_cb\n\t *       __sock_queue_rcv_skb\n\t * Another thread calls:\n\t *   bt_sock_recvmsg\n\t *     skb_recv_datagram\n\t *     skb_free_datagram\n\t * Then the current thread tries to access control, but it was freed by\n\t * skb_free_datagram.\n\t */\n\tu16 txseq = control->txseq;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, state %d\", chan, control, skb,\n\t       chan->rx_state);\n\n\tif (l2cap_classify_txseq(chan, txseq) == L2CAP_TXSEQ_EXPECTED) {\n\t\tl2cap_pass_to_tx(chan, control);\n\n\t\tBT_DBG(\"buffer_seq %u->%u\", chan->buffer_seq,\n\t\t       __next_seq(chan, chan->buffer_seq));\n\n\t\tchan->buffer_seq = __next_seq(chan, chan->buffer_seq);\n\n\t\tl2cap_reassemble_sdu(chan, skb, control);\n\t} else {\n\t\tif (chan->sdu) {\n\t\t\tkfree_skb(chan->sdu);\n\t\t\tchan->sdu = NULL;\n\t\t}\n\t\tchan->sdu_last_frag = NULL;\n\t\tchan->sdu_len = 0;\n\n\t\tif (skb) {\n\t\t\tBT_DBG(\"Freeing %p\", skb);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\tchan->last_acked_seq = txseq;\n\tchan->expected_tx_seq = __next_seq(chan, txseq);\n\n\treturn 0;\n}\n\nstatic int l2cap_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct l2cap_ctrl *control = &bt_cb(skb)->l2cap;\n\tu16 len;\n\tu8 event;\n\n\t__unpack_control(chan, skb);\n\n\tlen = skb->len;\n\n\t/*\n\t * We can just drop the corrupted I-frame here.\n\t * Receiver will miss it and start proper recovery\n\t * procedures and ask for retransmission.\n\t */\n\tif (l2cap_check_fcs(chan, skb))\n\t\tgoto drop;\n\n\tif (!control->sframe && control->sar == L2CAP_SAR_START)\n\t\tlen -= L2CAP_SDULEN_SIZE;\n\n\tif (chan->fcs == L2CAP_FCS_CRC16)\n\t\tlen -= L2CAP_FCS_SIZE;\n\n\tif (len > chan->mps) {\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\tgoto drop;\n\t}\n\n\tif (chan->ops->filter) {\n\t\tif (chan->ops->filter(chan, skb))\n\t\t\tgoto drop;\n\t}\n\n\tif (!control->sframe) {\n\t\tint err;\n\n\t\tBT_DBG(\"iframe sar %d, reqseq %d, final %d, txseq %d\",\n\t\t       control->sar, control->reqseq, control->final,\n\t\t       control->txseq);\n\n\t\t/* Validate F-bit - F=0 always valid, F=1 only\n\t\t * valid in TX WAIT_F\n\t\t */\n\t\tif (control->final && chan->tx_state != L2CAP_TX_STATE_WAIT_F)\n\t\t\tgoto drop;\n\n\t\tif (chan->mode != L2CAP_MODE_STREAMING) {\n\t\t\tevent = L2CAP_EV_RECV_IFRAME;\n\t\t\terr = l2cap_rx(chan, control, skb, event);\n\t\t} else {\n\t\t\terr = l2cap_stream_rx(chan, control, skb);\n\t\t}\n\n\t\tif (err)\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t} else {\n\t\tconst u8 rx_func_to_event[4] = {\n\t\t\tL2CAP_EV_RECV_RR, L2CAP_EV_RECV_REJ,\n\t\t\tL2CAP_EV_RECV_RNR, L2CAP_EV_RECV_SREJ\n\t\t};\n\n\t\t/* Only I-frames are expected in streaming mode */\n\t\tif (chan->mode == L2CAP_MODE_STREAMING)\n\t\t\tgoto drop;\n\n\t\tBT_DBG(\"sframe reqseq %d, final %d, poll %d, super %d\",\n\t\t       control->reqseq, control->final, control->poll,\n\t\t       control->super);\n\n\t\tif (len != 0) {\n\t\t\tBT_ERR(\"Trailing bytes: %d in sframe\", len);\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Validate F and P bits */\n\t\tif (control->final && (control->poll ||\n\t\t\t\t       chan->tx_state != L2CAP_TX_STATE_WAIT_F))\n\t\t\tgoto drop;\n\n\t\tevent = rx_func_to_event[control->super];\n\t\tif (l2cap_rx(chan, control, skb, event))\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t}\n\n\treturn 0;\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic void l2cap_chan_le_send_credits(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_le_credits pkt;\n\tu16 return_credits;\n\n\treturn_credits = (chan->imtu / chan->mps) + 1;\n\n\tif (chan->rx_credits >= return_credits)\n\t\treturn;\n\n\treturn_credits -= chan->rx_credits;\n\n\tBT_DBG(\"chan %p returning %u credits to sender\", chan, return_credits);\n\n\tchan->rx_credits += return_credits;\n\n\tpkt.cid     = cpu_to_le16(chan->scid);\n\tpkt.credits = cpu_to_le16(return_credits);\n\n\tchan->ident = l2cap_get_ident(conn);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CREDITS, sizeof(pkt), &pkt);\n}\n\nstatic int l2cap_ecred_recv(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tint err;\n\n\tBT_DBG(\"SDU reassemble complete: chan %p skb->len %u\", chan, skb->len);\n\n\t/* Wait recv to confirm reception before updating the credits */\n\terr = chan->ops->recv(chan, skb);\n\n\t/* Update credits whenever an SDU is received */\n\tl2cap_chan_le_send_credits(chan);\n\n\treturn err;\n}\n\nstatic int l2cap_ecred_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tint err;\n\n\tif (!chan->rx_credits) {\n\t\tBT_ERR(\"No credits to receive LE L2CAP data\");\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (chan->imtu < skb->len) {\n\t\tBT_ERR(\"Too big LE L2CAP PDU\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tchan->rx_credits--;\n\tBT_DBG(\"rx_credits %u -> %u\", chan->rx_credits + 1, chan->rx_credits);\n\n\t/* Update if remote had run out of credits, this should only happens\n\t * if the remote is not using the entire MPS.\n\t */\n\tif (!chan->rx_credits)\n\t\tl2cap_chan_le_send_credits(chan);\n\n\terr = 0;\n\n\tif (!chan->sdu) {\n\t\tu16 sdu_len;\n\n\t\tsdu_len = get_unaligned_le16(skb->data);\n\t\tskb_pull(skb, L2CAP_SDULEN_SIZE);\n\n\t\tBT_DBG(\"Start of new SDU. sdu_len %u skb->len %u imtu %u\",\n\t\t       sdu_len, skb->len, chan->imtu);\n\n\t\tif (sdu_len > chan->imtu) {\n\t\t\tBT_ERR(\"Too big LE L2CAP SDU length received\");\n\t\t\terr = -EMSGSIZE;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (skb->len > sdu_len) {\n\t\t\tBT_ERR(\"Too much LE L2CAP data received\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (skb->len == sdu_len)\n\t\t\treturn l2cap_ecred_recv(chan, skb);\n\n\t\tchan->sdu = skb;\n\t\tchan->sdu_len = sdu_len;\n\t\tchan->sdu_last_frag = skb;\n\n\t\t/* Detect if remote is not able to use the selected MPS */\n\t\tif (skb->len + L2CAP_SDULEN_SIZE < chan->mps) {\n\t\t\tu16 mps_len = skb->len + L2CAP_SDULEN_SIZE;\n\n\t\t\t/* Adjust the number of credits */\n\t\t\tBT_DBG(\"chan->mps %u -> %u\", chan->mps, mps_len);\n\t\t\tchan->mps = mps_len;\n\t\t\tl2cap_chan_le_send_credits(chan);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tBT_DBG(\"SDU fragment. chan->sdu->len %u skb->len %u chan->sdu_len %u\",\n\t       chan->sdu->len, skb->len, chan->sdu_len);\n\n\tif (chan->sdu->len + skb->len > chan->sdu_len) {\n\t\tBT_ERR(\"Too much LE L2CAP data received\");\n\t\terr = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\tappend_skb_frag(chan->sdu, skb, &chan->sdu_last_frag);\n\tskb = NULL;\n\n\tif (chan->sdu->len == chan->sdu_len) {\n\t\terr = l2cap_ecred_recv(chan, chan->sdu);\n\t\tif (!err) {\n\t\t\tchan->sdu = NULL;\n\t\t\tchan->sdu_last_frag = NULL;\n\t\t\tchan->sdu_len = 0;\n\t\t}\n\t}\n\nfailed:\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tkfree_skb(chan->sdu);\n\t\tchan->sdu = NULL;\n\t\tchan->sdu_last_frag = NULL;\n\t\tchan->sdu_len = 0;\n\t}\n\n\t/* We can't return an error here since we took care of the skb\n\t * freeing internally. An error return would cause the caller to\n\t * do a double-free of the skb.\n\t */\n\treturn 0;\n}\n\nstatic void l2cap_data_channel(struct l2cap_conn *conn, u16 cid,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct l2cap_chan *chan;\n\n\tchan = l2cap_get_chan_by_scid(conn, cid);\n\tif (!chan) {\n\t\tif (cid == L2CAP_CID_A2MP) {\n\t\t\tchan = a2mp_channel_create(conn, skb);\n\t\t\tif (!chan) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tl2cap_chan_hold(chan);\n\t\t\tl2cap_chan_lock(chan);\n\t\t} else {\n\t\t\tBT_DBG(\"unknown cid 0x%4.4x\", cid);\n\t\t\t/* Drop packet and return */\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tBT_DBG(\"chan %p, len %d\", chan, skb->len);\n\n\t/* If we receive data on a fixed channel before the info req/rsp\n\t * procedure is done simply assume that the channel is supported\n\t * and mark it as ready.\n\t */\n\tif (chan->chan_type == L2CAP_CHAN_FIXED)\n\t\tl2cap_chan_ready(chan);\n\n\tif (chan->state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tif (l2cap_ecred_data_rcv(chan, skb) < 0)\n\t\t\tgoto drop;\n\n\t\tgoto done;\n\n\tcase L2CAP_MODE_BASIC:\n\t\t/* If socket recv buffers overflows we drop data here\n\t\t * which is *bad* because L2CAP has to be reliable.\n\t\t * But we don't have any other choice. L2CAP doesn't\n\t\t * provide flow control mechanism. */\n\n\t\tif (chan->imtu < skb->len) {\n\t\t\tBT_ERR(\"Dropping L2CAP data: receive buffer overflow\");\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (!chan->ops->recv(chan, skb))\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tl2cap_data_rcv(chan, skb);\n\t\tgoto done;\n\n\tdefault:\n\t\tBT_DBG(\"chan %p: bad mode 0x%2.2x\", chan, chan->mode);\n\t\tbreak;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n\ndone:\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nstatic void l2cap_conless_channel(struct l2cap_conn *conn, __le16 psm,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_chan *chan;\n\n\tif (hcon->type != ACL_LINK)\n\t\tgoto free_skb;\n\n\tchan = l2cap_global_chan_by_psm(0, psm, &hcon->src, &hcon->dst,\n\t\t\t\t\tACL_LINK);\n\tif (!chan)\n\t\tgoto free_skb;\n\n\tBT_DBG(\"chan %p, len %d\", chan, skb->len);\n\n\tif (chan->state != BT_BOUND && chan->state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tif (chan->imtu < skb->len)\n\t\tgoto drop;\n\n\t/* Store remote BD_ADDR and PSM for msg_name */\n\tbacpy(&bt_cb(skb)->l2cap.bdaddr, &hcon->dst);\n\tbt_cb(skb)->l2cap.psm = psm;\n\n\tif (!chan->ops->recv(chan, skb)) {\n\t\tl2cap_chan_put(chan);\n\t\treturn;\n\t}\n\ndrop:\n\tl2cap_chan_put(chan);\nfree_skb:\n\tkfree_skb(skb);\n}\n\nstatic void l2cap_recv_frame(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct l2cap_hdr *lh = (void *) skb->data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tu16 cid, len;\n\t__le16 psm;\n\n\tif (hcon->state != BT_CONNECTED) {\n\t\tBT_DBG(\"queueing pending rx skb\");\n\t\tskb_queue_tail(&conn->pending_rx, skb);\n\t\treturn;\n\t}\n\n\tskb_pull(skb, L2CAP_HDR_SIZE);\n\tcid = __le16_to_cpu(lh->cid);\n\tlen = __le16_to_cpu(lh->len);\n\n\tif (len != skb->len) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* Since we can't actively block incoming LE connections we must\n\t * at least ensure that we ignore incoming data from them.\n\t */\n\tif (hcon->type == LE_LINK &&\n\t    hci_bdaddr_list_lookup(&hcon->hdev->reject_list, &hcon->dst,\n\t\t\t\t   bdaddr_dst_type(hcon))) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tBT_DBG(\"len %d, cid 0x%4.4x\", len, cid);\n\n\tswitch (cid) {\n\tcase L2CAP_CID_SIGNALING:\n\t\tl2cap_sig_channel(conn, skb);\n\t\tbreak;\n\n\tcase L2CAP_CID_CONN_LESS:\n\t\tpsm = get_unaligned((__le16 *) skb->data);\n\t\tskb_pull(skb, L2CAP_PSMLEN_SIZE);\n\t\tl2cap_conless_channel(conn, psm, skb);\n\t\tbreak;\n\n\tcase L2CAP_CID_LE_SIGNALING:\n\t\tl2cap_le_sig_channel(conn, skb);\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_data_channel(conn, cid, skb);\n\t\tbreak;\n\t}\n}\n\nstatic void process_pending_rx(struct work_struct *work)\n{\n\tstruct l2cap_conn *conn = container_of(work, struct l2cap_conn,\n\t\t\t\t\t       pending_rx_work);\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"\");\n\n\twhile ((skb = skb_dequeue(&conn->pending_rx)))\n\t\tl2cap_recv_frame(conn, skb);\n}\n\nstatic struct l2cap_conn *l2cap_conn_add(struct hci_conn *hcon)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct hci_chan *hchan;\n\n\tif (conn)\n\t\treturn conn;\n\n\thchan = hci_chan_create(hcon);\n\tif (!hchan)\n\t\treturn NULL;\n\n\tconn = kzalloc(sizeof(*conn), GFP_KERNEL);\n\tif (!conn) {\n\t\thci_chan_del(hchan);\n\t\treturn NULL;\n\t}\n\n\tkref_init(&conn->ref);\n\thcon->l2cap_data = conn;\n\tconn->hcon = hci_conn_get(hcon);\n\tconn->hchan = hchan;\n\n\tBT_DBG(\"hcon %p conn %p hchan %p\", hcon, conn, hchan);\n\n\tswitch (hcon->type) {\n\tcase LE_LINK:\n\t\tif (hcon->hdev->le_mtu) {\n\t\t\tconn->mtu = hcon->hdev->le_mtu;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tconn->mtu = hcon->hdev->acl_mtu;\n\t\tbreak;\n\t}\n\n\tconn->feat_mask = 0;\n\n\tconn->local_fixed_chan = L2CAP_FC_SIG_BREDR | L2CAP_FC_CONNLESS;\n\n\tif (hcon->type == ACL_LINK &&\n\t    hci_dev_test_flag(hcon->hdev, HCI_HS_ENABLED))\n\t\tconn->local_fixed_chan |= L2CAP_FC_A2MP;\n\n\tif (hci_dev_test_flag(hcon->hdev, HCI_LE_ENABLED) &&\n\t    (bredr_sc_enabled(hcon->hdev) ||\n\t     hci_dev_test_flag(hcon->hdev, HCI_FORCE_BREDR_SMP)))\n\t\tconn->local_fixed_chan |= L2CAP_FC_SMP_BREDR;\n\n\tmutex_init(&conn->ident_lock);\n\tmutex_init(&conn->chan_lock);\n\n\tINIT_LIST_HEAD(&conn->chan_l);\n\tINIT_LIST_HEAD(&conn->users);\n\n\tINIT_DELAYED_WORK(&conn->info_timer, l2cap_info_timeout);\n\n\tskb_queue_head_init(&conn->pending_rx);\n\tINIT_WORK(&conn->pending_rx_work, process_pending_rx);\n\tINIT_WORK(&conn->id_addr_update_work, l2cap_conn_update_id_addr);\n\n\tconn->disc_reason = HCI_ERROR_REMOTE_USER_TERM;\n\n\treturn conn;\n}\n\nstatic bool is_valid_psm(u16 psm, u8 dst_type)\n{\n\tif (!psm)\n\t\treturn false;\n\n\tif (bdaddr_type_is_le(dst_type))\n\t\treturn (psm <= 0x00ff);\n\n\t/* PSM must be odd and lsb of upper byte must be 0 */\n\treturn ((psm & 0x0101) == 0x0001);\n}\n\nstruct l2cap_chan_data {\n\tstruct l2cap_chan *chan;\n\tstruct pid *pid;\n\tint count;\n};\n\nstatic void l2cap_chan_by_pid(struct l2cap_chan *chan, void *data)\n{\n\tstruct l2cap_chan_data *d = data;\n\tstruct pid *pid;\n\n\tif (chan == d->chan)\n\t\treturn;\n\n\tif (!test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\treturn;\n\n\tpid = chan->ops->get_peer_pid(chan);\n\n\t/* Only count deferred channels with the same PID/PSM */\n\tif (d->pid != pid || chan->psm != d->chan->psm || chan->ident ||\n\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL || chan->state != BT_CONNECT)\n\t\treturn;\n\n\td->count++;\n}\n\nint l2cap_chan_connect(struct l2cap_chan *chan, __le16 psm, u16 cid,\n\t\t       bdaddr_t *dst, u8 dst_type)\n{\n\tstruct l2cap_conn *conn;\n\tstruct hci_conn *hcon;\n\tstruct hci_dev *hdev;\n\tint err;\n\n\tBT_DBG(\"%pMR -> %pMR (type %u) psm 0x%4.4x mode 0x%2.2x\", &chan->src,\n\t       dst, dst_type, __le16_to_cpu(psm), chan->mode);\n\n\thdev = hci_get_route(dst, &chan->src, chan->src_type);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\n\thci_dev_lock(hdev);\n\n\tif (!is_valid_psm(__le16_to_cpu(psm), dst_type) && !cid &&\n\t    chan->chan_type != L2CAP_CHAN_RAW) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED && !psm) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (chan->chan_type == L2CAP_CHAN_FIXED && !cid) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\t\tbreak;\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tif (!enable_ecred) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (!disable_ertm)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n\n\tswitch (chan->state) {\n\tcase BT_CONNECT:\n\tcase BT_CONNECT2:\n\tcase BT_CONFIG:\n\t\t/* Already connecting */\n\t\terr = 0;\n\t\tgoto done;\n\n\tcase BT_CONNECTED:\n\t\t/* Already connected */\n\t\terr = -EISCONN;\n\t\tgoto done;\n\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\t\t/* Can connect */\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\t/* Set destination address and psm */\n\tbacpy(&chan->dst, dst);\n\tchan->dst_type = dst_type;\n\n\tchan->psm = psm;\n\tchan->dcid = cid;\n\n\tif (bdaddr_type_is_le(dst_type)) {\n\t\t/* Convert from L2CAP channel address type to HCI address type\n\t\t */\n\t\tif (dst_type == BDADDR_LE_PUBLIC)\n\t\t\tdst_type = ADDR_LE_DEV_PUBLIC;\n\t\telse\n\t\t\tdst_type = ADDR_LE_DEV_RANDOM;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\t\thcon = hci_connect_le(hdev, dst, dst_type, false,\n\t\t\t\t\t      chan->sec_level,\n\t\t\t\t\t      HCI_LE_CONN_TIMEOUT,\n\t\t\t\t\t      HCI_ROLE_SLAVE);\n\t\telse\n\t\t\thcon = hci_connect_le_scan(hdev, dst, dst_type,\n\t\t\t\t\t\t   chan->sec_level,\n\t\t\t\t\t\t   HCI_LE_CONN_TIMEOUT,\n\t\t\t\t\t\t   CONN_REASON_L2CAP_CHAN);\n\n\t} else {\n\t\tu8 auth_type = l2cap_get_auth_type(chan);\n\t\thcon = hci_connect_acl(hdev, dst, chan->sec_level, auth_type,\n\t\t\t\t       CONN_REASON_L2CAP_CHAN);\n\t}\n\n\tif (IS_ERR(hcon)) {\n\t\terr = PTR_ERR(hcon);\n\t\tgoto done;\n\t}\n\n\tconn = l2cap_conn_add(hcon);\n\tif (!conn) {\n\t\thci_conn_drop(hcon);\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tif (chan->mode == L2CAP_MODE_EXT_FLOWCTL) {\n\t\tstruct l2cap_chan_data data;\n\n\t\tdata.chan = chan;\n\t\tdata.pid = chan->ops->get_peer_pid(chan);\n\t\tdata.count = 1;\n\n\t\tl2cap_chan_list(conn, l2cap_chan_by_pid, &data);\n\n\t\t/* Check if there isn't too many channels being connected */\n\t\tif (data.count > L2CAP_ECRED_CONN_SCID_MAX) {\n\t\t\thci_conn_drop(hcon);\n\t\t\terr = -EPROTO;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tmutex_lock(&conn->chan_lock);\n\tl2cap_chan_lock(chan);\n\n\tif (cid && __l2cap_get_chan_by_dcid(conn, cid)) {\n\t\thci_conn_drop(hcon);\n\t\terr = -EBUSY;\n\t\tgoto chan_unlock;\n\t}\n\n\t/* Update source addr of the socket */\n\tbacpy(&chan->src, &hcon->src);\n\tchan->src_type = bdaddr_src_type(hcon);\n\n\t__l2cap_chan_add(conn, chan);\n\n\t/* l2cap_chan_add takes its own ref so we can drop this one */\n\thci_conn_drop(hcon);\n\n\tl2cap_state_change(chan, BT_CONNECT);\n\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\n\t/* Release chan->sport so that it can be reused by other\n\t * sockets (as it's only used for listening sockets).\n\t */\n\twrite_lock(&chan_list_lock);\n\tchan->sport = 0;\n\twrite_unlock(&chan_list_lock);\n\n\tif (hcon->state == BT_CONNECTED) {\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\t__clear_chan_timer(chan);\n\t\t\tif (l2cap_chan_check_security(chan, true))\n\t\t\t\tl2cap_state_change(chan, BT_CONNECTED);\n\t\t} else\n\t\t\tl2cap_do_start(chan);\n\t}\n\n\terr = 0;\n\nchan_unlock:\n\tl2cap_chan_unlock(chan);\n\tmutex_unlock(&conn->chan_lock);\ndone:\n\thci_dev_unlock(hdev);\n\thci_dev_put(hdev);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_connect);\n\nstatic void l2cap_ecred_reconfigure(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct {\n\t\tstruct l2cap_ecred_reconf_req req;\n\t\t__le16 scid;\n\t} pdu;\n\n\tpdu.req.mtu = cpu_to_le16(chan->imtu);\n\tpdu.req.mps = cpu_to_le16(chan->mps);\n\tpdu.scid    = cpu_to_le16(chan->scid);\n\n\tchan->ident = l2cap_get_ident(conn);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_ECRED_RECONF_REQ,\n\t\t       sizeof(pdu), &pdu);\n}\n\nint l2cap_chan_reconfigure(struct l2cap_chan *chan, __u16 mtu)\n{\n\tif (chan->imtu > mtu)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"chan %p mtu 0x%4.4x\", chan, mtu);\n\n\tchan->imtu = mtu;\n\n\tl2cap_ecred_reconfigure(chan);\n\n\treturn 0;\n}\n\n/* ---- L2CAP interface with lower layer (HCI) ---- */\n\nint l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr)\n{\n\tint exact = 0, lm1 = 0, lm2 = 0;\n\tstruct l2cap_chan *c;\n\n\tBT_DBG(\"hdev %s, bdaddr %pMR\", hdev->name, bdaddr);\n\n\t/* Find listening sockets and check their link_mode */\n\tread_lock(&chan_list_lock);\n\tlist_for_each_entry(c, &chan_list, global_l) {\n\t\tif (c->state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (!bacmp(&c->src, &hdev->bdaddr)) {\n\t\t\tlm1 |= HCI_LM_ACCEPT;\n\t\t\tif (test_bit(FLAG_ROLE_SWITCH, &c->flags))\n\t\t\t\tlm1 |= HCI_LM_MASTER;\n\t\t\texact++;\n\t\t} else if (!bacmp(&c->src, BDADDR_ANY)) {\n\t\t\tlm2 |= HCI_LM_ACCEPT;\n\t\t\tif (test_bit(FLAG_ROLE_SWITCH, &c->flags))\n\t\t\t\tlm2 |= HCI_LM_MASTER;\n\t\t}\n\t}\n\tread_unlock(&chan_list_lock);\n\n\treturn exact ? lm1 : lm2;\n}\n\n/* Find the next fixed channel in BT_LISTEN state, continue iteration\n * from an existing channel in the list or from the beginning of the\n * global list (by passing NULL as first parameter).\n */\nstatic struct l2cap_chan *l2cap_global_fixed_chan(struct l2cap_chan *c,\n\t\t\t\t\t\t  struct hci_conn *hcon)\n{\n\tu8 src_type = bdaddr_src_type(hcon);\n\n\tread_lock(&chan_list_lock);\n\n\tif (c)\n\t\tc = list_next_entry(c, global_l);\n\telse\n\t\tc = list_entry(chan_list.next, typeof(*c), global_l);\n\n\tlist_for_each_entry_from(c, &chan_list, global_l) {\n\t\tif (c->chan_type != L2CAP_CHAN_FIXED)\n\t\t\tcontinue;\n\t\tif (c->state != BT_LISTEN)\n\t\t\tcontinue;\n\t\tif (bacmp(&c->src, &hcon->src) && bacmp(&c->src, BDADDR_ANY))\n\t\t\tcontinue;\n\t\tif (src_type != c->src_type)\n\t\t\tcontinue;\n\n\t\tc = l2cap_chan_hold_unless_zero(c);\n\t\tread_unlock(&chan_list_lock);\n\t\treturn c;\n\t}\n\n\tread_unlock(&chan_list_lock);\n\n\treturn NULL;\n}\n\nstatic void l2cap_connect_cfm(struct hci_conn *hcon, u8 status)\n{\n\tstruct hci_dev *hdev = hcon->hdev;\n\tstruct l2cap_conn *conn;\n\tstruct l2cap_chan *pchan;\n\tu8 dst_type;\n\n\tif (hcon->type != ACL_LINK && hcon->type != LE_LINK)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p bdaddr %pMR status %d\", hcon, &hcon->dst, status);\n\n\tif (status) {\n\t\tl2cap_conn_del(hcon, bt_to_errno(status));\n\t\treturn;\n\t}\n\n\tconn = l2cap_conn_add(hcon);\n\tif (!conn)\n\t\treturn;\n\n\tdst_type = bdaddr_dst_type(hcon);\n\n\t/* If device is blocked, do not create channels for it */\n\tif (hci_bdaddr_list_lookup(&hdev->reject_list, &hcon->dst, dst_type))\n\t\treturn;\n\n\t/* Find fixed channels and notify them of the new connection. We\n\t * use multiple individual lookups, continuing each time where\n\t * we left off, because the list lock would prevent calling the\n\t * potentially sleeping l2cap_chan_lock() function.\n\t */\n\tpchan = l2cap_global_fixed_chan(NULL, hcon);\n\twhile (pchan) {\n\t\tstruct l2cap_chan *chan, *next;\n\n\t\t/* Client fixed channels should override server ones */\n\t\tif (__l2cap_get_chan_by_dcid(conn, pchan->scid))\n\t\t\tgoto next;\n\n\t\tl2cap_chan_lock(pchan);\n\t\tchan = pchan->ops->new_connection(pchan);\n\t\tif (chan) {\n\t\t\tbacpy(&chan->src, &hcon->src);\n\t\t\tbacpy(&chan->dst, &hcon->dst);\n\t\t\tchan->src_type = bdaddr_src_type(hcon);\n\t\t\tchan->dst_type = dst_type;\n\n\t\t\t__l2cap_chan_add(conn, chan);\n\t\t}\n\n\t\tl2cap_chan_unlock(pchan);\nnext:\n\t\tnext = l2cap_global_fixed_chan(pchan, hcon);\n\t\tl2cap_chan_put(pchan);\n\t\tpchan = next;\n\t}\n\n\tl2cap_conn_ready(conn);\n}\n\nint l2cap_disconn_ind(struct hci_conn *hcon)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\n\tBT_DBG(\"hcon %p\", hcon);\n\n\tif (!conn)\n\t\treturn HCI_ERROR_REMOTE_USER_TERM;\n\treturn conn->disc_reason;\n}\n\nstatic void l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason)\n{\n\tif (hcon->type != ACL_LINK && hcon->type != LE_LINK)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p reason %d\", hcon, reason);\n\n\tl2cap_conn_del(hcon, bt_to_errno(reason));\n}\n\nstatic inline void l2cap_check_encryption(struct l2cap_chan *chan, u8 encrypt)\n{\n\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED)\n\t\treturn;\n\n\tif (encrypt == 0x00) {\n\t\tif (chan->sec_level == BT_SECURITY_MEDIUM) {\n\t\t\t__set_chan_timer(chan, L2CAP_ENC_TIMEOUT);\n\t\t} else if (chan->sec_level == BT_SECURITY_HIGH ||\n\t\t\t   chan->sec_level == BT_SECURITY_FIPS)\n\t\t\tl2cap_chan_close(chan, ECONNREFUSED);\n\t} else {\n\t\tif (chan->sec_level == BT_SECURITY_MEDIUM)\n\t\t\t__clear_chan_timer(chan);\n\t}\n}\n\nstatic void l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct l2cap_chan *chan;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"conn %p status 0x%2.2x encrypt %u\", conn, status, encrypt);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tl2cap_chan_lock(chan);\n\n\t\tBT_DBG(\"chan %p scid 0x%4.4x state %s\", chan, chan->scid,\n\t\t       state_to_string(chan->state));\n\n\t\tif (chan->scid == L2CAP_CID_A2MP) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!status && encrypt)\n\t\t\tchan->sec_level = hcon->sec_level;\n\n\t\tif (!__l2cap_no_conn_pending(chan)) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!status && (chan->state == BT_CONNECTED ||\n\t\t\t\tchan->state == BT_CONFIG)) {\n\t\t\tchan->ops->resume(chan);\n\t\t\tl2cap_check_encryption(chan, encrypt);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chan->state == BT_CONNECT) {\n\t\t\tif (!status && l2cap_check_enc_key_size(hcon))\n\t\t\t\tl2cap_start_connection(chan);\n\t\t\telse\n\t\t\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n\t\t} else if (chan->state == BT_CONNECT2 &&\n\t\t\t   !(chan->mode == L2CAP_MODE_EXT_FLOWCTL ||\n\t\t\t     chan->mode == L2CAP_MODE_LE_FLOWCTL)) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\t__u16 res, stat;\n\n\t\t\tif (!status && l2cap_check_enc_key_size(hcon)) {\n\t\t\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\t\t\tres = L2CAP_CR_PEND;\n\t\t\t\t\tstat = L2CAP_CS_AUTHOR_PEND;\n\t\t\t\t\tchan->ops->defer(chan);\n\t\t\t\t} else {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\t\t\tres = L2CAP_CR_SUCCESS;\n\t\t\t\t\tstat = L2CAP_CS_NO_INFO;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tl2cap_state_change(chan, BT_DISCONN);\n\t\t\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n\t\t\t\tres = L2CAP_CR_SEC_BLOCK;\n\t\t\t\tstat = L2CAP_CS_NO_INFO;\n\t\t\t}\n\n\t\t\trsp.scid   = cpu_to_le16(chan->dcid);\n\t\t\trsp.dcid   = cpu_to_le16(chan->scid);\n\t\t\trsp.result = cpu_to_le16(res);\n\t\t\trsp.status = cpu_to_le16(stat);\n\t\t\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,\n\t\t\t\t       sizeof(rsp), &rsp);\n\n\t\t\tif (!test_bit(CONF_REQ_SENT, &chan->conf_state) &&\n\t\t\t    res == L2CAP_CR_SUCCESS) {\n\t\t\t\tchar buf[128];\n\t\t\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\t       L2CAP_CONF_REQ,\n\t\t\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)),\n\t\t\t\t\t       buf);\n\t\t\t\tchan->num_conf_req++;\n\t\t\t}\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\n/* Append fragment into frame respecting the maximum len of rx_skb */\nstatic int l2cap_recv_frag(struct l2cap_conn *conn, struct sk_buff *skb,\n\t\t\t   u16 len)\n{\n\tif (!conn->rx_skb) {\n\t\t/* Allocate skb for the complete frame (with header) */\n\t\tconn->rx_skb = bt_skb_alloc(len, GFP_KERNEL);\n\t\tif (!conn->rx_skb)\n\t\t\treturn -ENOMEM;\n\t\t/* Init rx_len */\n\t\tconn->rx_len = len;\n\t}\n\n\t/* Copy as much as the rx_skb can hold */\n\tlen = min_t(u16, len, skb->len);\n\tskb_copy_from_linear_data(skb, skb_put(conn->rx_skb, len), len);\n\tskb_pull(skb, len);\n\tconn->rx_len -= len;\n\n\treturn len;\n}\n\nstatic int l2cap_recv_len(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct sk_buff *rx_skb;\n\tint len;\n\n\t/* Append just enough to complete the header */\n\tlen = l2cap_recv_frag(conn, skb, L2CAP_LEN_SIZE - conn->rx_skb->len);\n\n\t/* If header could not be read just continue */\n\tif (len < 0 || conn->rx_skb->len < L2CAP_LEN_SIZE)\n\t\treturn len;\n\n\trx_skb = conn->rx_skb;\n\tlen = get_unaligned_le16(rx_skb->data);\n\n\t/* Check if rx_skb has enough space to received all fragments */\n\tif (len + (L2CAP_HDR_SIZE - L2CAP_LEN_SIZE) <= skb_tailroom(rx_skb)) {\n\t\t/* Update expected len */\n\t\tconn->rx_len = len + (L2CAP_HDR_SIZE - L2CAP_LEN_SIZE);\n\t\treturn L2CAP_LEN_SIZE;\n\t}\n\n\t/* Reset conn->rx_skb since it will need to be reallocated in order to\n\t * fit all fragments.\n\t */\n\tconn->rx_skb = NULL;\n\n\t/* Reallocates rx_skb using the exact expected length */\n\tlen = l2cap_recv_frag(conn, rx_skb,\n\t\t\t      len + (L2CAP_HDR_SIZE - L2CAP_LEN_SIZE));\n\tkfree_skb(rx_skb);\n\n\treturn len;\n}\n\nstatic void l2cap_recv_reset(struct l2cap_conn *conn)\n{\n\tkfree_skb(conn->rx_skb);\n\tconn->rx_skb = NULL;\n\tconn->rx_len = 0;\n}\n\nvoid l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tint len;\n\n\t/* For AMP controller do not create l2cap conn */\n\tif (!conn && hcon->hdev->dev_type != HCI_PRIMARY)\n\t\tgoto drop;\n\n\tif (!conn)\n\t\tconn = l2cap_conn_add(hcon);\n\n\tif (!conn)\n\t\tgoto drop;\n\n\tBT_DBG(\"conn %p len %u flags 0x%x\", conn, skb->len, flags);\n\n\tswitch (flags) {\n\tcase ACL_START:\n\tcase ACL_START_NO_FLUSH:\n\tcase ACL_COMPLETE:\n\t\tif (conn->rx_skb) {\n\t\t\tBT_ERR(\"Unexpected start frame (len %d)\", skb->len);\n\t\t\tl2cap_recv_reset(conn);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t}\n\n\t\t/* Start fragment may not contain the L2CAP length so just\n\t\t * copy the initial byte when that happens and use conn->mtu as\n\t\t * expected length.\n\t\t */\n\t\tif (skb->len < L2CAP_LEN_SIZE) {\n\t\t\tl2cap_recv_frag(conn, skb, conn->mtu);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = get_unaligned_le16(skb->data) + L2CAP_HDR_SIZE;\n\n\t\tif (len == skb->len) {\n\t\t\t/* Complete frame received */\n\t\t\tl2cap_recv_frame(conn, skb);\n\t\t\treturn;\n\t\t}\n\n\t\tBT_DBG(\"Start: total len %d, frag len %u\", len, skb->len);\n\n\t\tif (skb->len > len) {\n\t\t\tBT_ERR(\"Frame is too long (len %u, expected len %d)\",\n\t\t\t       skb->len, len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Append fragment into frame (with header) */\n\t\tif (l2cap_recv_frag(conn, skb, len) < 0)\n\t\t\tgoto drop;\n\n\t\tbreak;\n\n\tcase ACL_CONT:\n\t\tBT_DBG(\"Cont: frag len %u (expecting %u)\", skb->len, conn->rx_len);\n\n\t\tif (!conn->rx_skb) {\n\t\t\tBT_ERR(\"Unexpected continuation frame (len %d)\", skb->len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Complete the L2CAP length if it has not been read */\n\t\tif (conn->rx_skb->len < L2CAP_LEN_SIZE) {\n\t\t\tif (l2cap_recv_len(conn, skb) < 0) {\n\t\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\t/* Header still could not be read just continue */\n\t\t\tif (conn->rx_skb->len < L2CAP_LEN_SIZE)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (skb->len > conn->rx_len) {\n\t\t\tBT_ERR(\"Fragment is too long (len %u, expected %u)\",\n\t\t\t       skb->len, conn->rx_len);\n\t\t\tl2cap_recv_reset(conn);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Append fragment into frame (with header) */\n\t\tl2cap_recv_frag(conn, skb, skb->len);\n\n\t\tif (!conn->rx_len) {\n\t\t\t/* Complete frame received. l2cap_recv_frame\n\t\t\t * takes ownership of the skb so set the global\n\t\t\t * rx_skb pointer to NULL first.\n\t\t\t */\n\t\t\tstruct sk_buff *rx_skb = conn->rx_skb;\n\t\t\tconn->rx_skb = NULL;\n\t\t\tl2cap_recv_frame(conn, rx_skb);\n\t\t}\n\t\tbreak;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}\n\nstatic struct hci_cb l2cap_cb = {\n\t.name\t\t= \"L2CAP\",\n\t.connect_cfm\t= l2cap_connect_cfm,\n\t.disconn_cfm\t= l2cap_disconn_cfm,\n\t.security_cfm\t= l2cap_security_cfm,\n};\n\nstatic int l2cap_debugfs_show(struct seq_file *f, void *p)\n{\n\tstruct l2cap_chan *c;\n\n\tread_lock(&chan_list_lock);\n\n\tlist_for_each_entry(c, &chan_list, global_l) {\n\t\tseq_printf(f, \"%pMR (%u) %pMR (%u) %d %d 0x%4.4x 0x%4.4x %d %d %d %d\\n\",\n\t\t\t   &c->src, c->src_type, &c->dst, c->dst_type,\n\t\t\t   c->state, __le16_to_cpu(c->psm),\n\t\t\t   c->scid, c->dcid, c->imtu, c->omtu,\n\t\t\t   c->sec_level, c->mode);\n\t}\n\n\tread_unlock(&chan_list_lock);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(l2cap_debugfs);\n\nstatic struct dentry *l2cap_debugfs;\n\nint __init l2cap_init(void)\n{\n\tint err;\n\n\terr = l2cap_init_sockets();\n\tif (err < 0)\n\t\treturn err;\n\n\thci_register_cb(&l2cap_cb);\n\n\tif (IS_ERR_OR_NULL(bt_debugfs))\n\t\treturn 0;\n\n\tl2cap_debugfs = debugfs_create_file(\"l2cap\", 0444, bt_debugfs,\n\t\t\t\t\t    NULL, &l2cap_debugfs_fops);\n\n\treturn 0;\n}\n\nvoid l2cap_exit(void)\n{\n\tdebugfs_remove(l2cap_debugfs);\n\thci_unregister_cb(&l2cap_cb);\n\tl2cap_cleanup_sockets();\n}\n\nmodule_param(disable_ertm, bool, 0644);\nMODULE_PARM_DESC(disable_ertm, \"Disable enhanced retransmission mode\");\n\nmodule_param(enable_ecred, bool, 0644);\nMODULE_PARM_DESC(enable_ecred, \"Enable enhanced credit flow control mode\");\n"], "filenames": ["net/bluetooth/l2cap_core.c"], "buggy_code_start_loc": [3767], "buggy_code_end_loc": [3768], "fixing_code_start_loc": [3767], "fixing_code_end_loc": [3769], "type": "CWE-824", "message": "There is an infoleak vulnerability in the Linux kernel's net/bluetooth/l2cap_core.c's l2cap_parse_conf_req function which can be used to leak kernel pointers remotely. We recommend upgrading past commit https://github.com/torvalds/linux/commit/b1a2cd50c0357f243b7435a732b4e62ba3157a2e https://www.google.com/url", "other": {"cve": {"id": "CVE-2022-42895", "sourceIdentifier": "cve-coordination@google.com", "published": "2022-11-23T15:15:10.557", "lastModified": "2023-01-23T18:29:23.887", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There is an infoleak vulnerability in the Linux kernel's net/bluetooth/l2cap_core.c's l2cap_parse_conf_req function which can be used to leak kernel pointers remotely. We recommend upgrading past commit https://github.com/torvalds/linux/commit/b1a2cd50c0357f243b7435a732b4e62ba3157a2e https://www.google.com/url"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.4, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-824"}]}, {"source": "cve-coordination@google.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-824"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/b1a2cd50c0357f243b7435a732b4e62ba3157a2e", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://kernel.dance/#b1a2cd50c0357f243b7435a732b4e62ba3157a2e", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b1a2cd50c0357f243b7435a732b4e62ba3157a2e"}}