{"buggy_code": ["/*\n * This file is part of mpv.\n *\n * mpv is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * mpv is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include \"osdep/io.h\"\n\n#include \"mpv_talloc.h\"\n#include \"common/msg.h\"\n#include \"options/options.h\"\n#include \"options/m_config.h\"\n#include \"options/path.h\"\n#include \"misc/ctype.h\"\n\n#include \"stream/stream.h\"\n#include \"demux.h\"\n#include \"stheader.h\"\n#include \"codec_tags.h\"\n\n#define MF_MAX_FILE_SIZE (1024 * 1024 * 256)\n\ntypedef struct mf {\n    struct mp_log *log;\n    struct sh_stream *sh;\n    int curr_frame;\n    int nr_of_files;\n    char **names;\n    // optional\n    struct stream **streams;\n} mf_t;\n\n\nstatic void mf_add(mf_t *mf, const char *fname)\n{\n    char *entry = talloc_strdup(mf, fname);\n    MP_TARRAY_APPEND(mf, mf->names, mf->nr_of_files, entry);\n}\n\nstatic mf_t *open_mf_pattern(void *talloc_ctx, struct demuxer *d, char *filename)\n{\n    struct mp_log *log = d->log;\n    int error_count = 0;\n    int count = 0;\n\n    mf_t *mf = talloc_zero(talloc_ctx, mf_t);\n    mf->log = log;\n\n    if (filename[0] == '@') {\n        struct stream *s = stream_create(filename + 1,\n                            d->stream_origin | STREAM_READ, d->cancel, d->global);\n        if (s) {\n            while (1) {\n                char buf[512];\n                int len = stream_read_peek(s, buf, sizeof(buf));\n                if (!len)\n                    break;\n                bstr data = (bstr){buf, len};\n                int pos = bstrchr(data, '\\n');\n                data = bstr_splice(data, 0, pos < 0 ? data.len : pos + 1);\n                bstr fname = bstr_strip(data);\n                if (fname.len) {\n                    if (bstrchr(fname, '\\0') >= 0) {\n                        mp_err(log, \"invalid filename\\n\");\n                        break;\n                    }\n                    char *entry = bstrto0(mf, fname);\n                    if (!mp_path_exists(entry)) {\n                        mp_verbose(log, \"file not found: '%s'\\n\", entry);\n                    } else {\n                        MP_TARRAY_APPEND(mf, mf->names, mf->nr_of_files, entry);\n                    }\n                }\n                stream_seek_skip(s, stream_tell(s) + data.len);\n            }\n            free_stream(s);\n\n            mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n            goto exit_mf;\n        }\n        mp_info(log, \"%s is not indirect filelist\\n\", filename + 1);\n    }\n\n    if (strchr(filename, ',')) {\n        mp_info(log, \"filelist: %s\\n\", filename);\n        bstr bfilename = bstr0(filename);\n\n        while (bfilename.len) {\n            bstr bfname;\n            bstr_split_tok(bfilename, \",\", &bfname, &bfilename);\n            char *fname2 = bstrdup0(mf, bfname);\n\n            if (!mp_path_exists(fname2))\n                mp_verbose(log, \"file not found: '%s'\\n\", fname2);\n            else {\n                mf_add(mf, fname2);\n            }\n            talloc_free(fname2);\n        }\n        mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n\n        goto exit_mf;\n    }\n\n    char *fname = talloc_size(mf, strlen(filename) + 32);\n\n#if HAVE_GLOB\n    if (!strchr(filename, '%')) {\n        strcpy(fname, filename);\n        if (!strchr(filename, '*'))\n            strcat(fname, \"*\");\n\n        mp_info(log, \"search expr: %s\\n\", fname);\n\n        glob_t gg;\n        if (glob(fname, 0, NULL, &gg)) {\n            talloc_free(mf);\n            return NULL;\n        }\n\n        for (int i = 0; i < gg.gl_pathc; i++) {\n            if (mp_path_isdir(gg.gl_pathv[i]))\n                continue;\n            mf_add(mf, gg.gl_pathv[i]);\n        }\n        mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n        globfree(&gg);\n        goto exit_mf;\n    }\n#endif\n\n    mp_info(log, \"search expr: %s\\n\", filename);\n\n    while (error_count < 5) {\n        sprintf(fname, filename, count++);\n        if (!mp_path_exists(fname)) {\n            error_count++;\n            mp_verbose(log, \"file not found: '%s'\\n\", fname);\n        } else {\n            mf_add(mf, fname);\n        }\n    }\n\n    mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n\nexit_mf:\n    return mf;\n}\n\nstatic mf_t *open_mf_single(void *talloc_ctx, struct mp_log *log, char *filename)\n{\n    mf_t *mf = talloc_zero(talloc_ctx, mf_t);\n    mf->log = log;\n    mf_add(mf, filename);\n    return mf;\n}\n\nstatic void demux_seek_mf(demuxer_t *demuxer, double seek_pts, int flags)\n{\n    mf_t *mf = demuxer->priv;\n    double newpos = seek_pts * mf->sh->codec->fps;\n    if (flags & SEEK_FACTOR)\n        newpos = seek_pts * (mf->nr_of_files - 1);\n    if (flags & SEEK_FORWARD) {\n        newpos = ceil(newpos);\n    } else {\n        newpos = MPMIN(floor(newpos), mf->nr_of_files - 1);\n    }\n    mf->curr_frame = MPCLAMP((int)newpos, 0, mf->nr_of_files);\n}\n\nstatic bool demux_mf_read_packet(struct demuxer *demuxer,\n                                 struct demux_packet **pkt)\n{\n    mf_t *mf = demuxer->priv;\n    if (mf->curr_frame >= mf->nr_of_files)\n        return false;\n    bool ok = false;\n\n    struct stream *entry_stream = NULL;\n    if (mf->streams)\n        entry_stream = mf->streams[mf->curr_frame];\n    struct stream *stream = entry_stream;\n    if (!stream) {\n        char *filename = mf->names[mf->curr_frame];\n        if (filename) {\n            stream = stream_create(filename, demuxer->stream_origin | STREAM_READ,\n                                   demuxer->cancel, demuxer->global);\n        }\n    }\n\n    if (stream) {\n        stream_seek(stream, 0);\n        bstr data = stream_read_complete(stream, NULL, MF_MAX_FILE_SIZE);\n        if (data.len) {\n            demux_packet_t *dp = new_demux_packet(data.len);\n            if (dp) {\n                memcpy(dp->buffer, data.start, data.len);\n                dp->pts = mf->curr_frame / mf->sh->codec->fps;\n                dp->keyframe = true;\n                dp->stream = mf->sh->index;\n                *pkt = dp;\n                ok = true;\n            }\n        }\n        talloc_free(data.start);\n    }\n\n    if (stream && stream != entry_stream)\n        free_stream(stream);\n\n    mf->curr_frame++;\n\n    if (!ok)\n        MP_ERR(demuxer, \"error reading image file\\n\");\n\n    return true;\n}\n\n// map file extension/type to a codec name\n\nstatic const struct {\n    const char *type;\n    const char *codec;\n} type2format[] = {\n    { \"bmp\",            \"bmp\" },\n    { \"dpx\",            \"dpx\" },\n    { \"j2c\",            \"jpeg2000\" },\n    { \"j2k\",            \"jpeg2000\" },\n    { \"jp2\",            \"jpeg2000\" },\n    { \"jpc\",            \"jpeg2000\" },\n    { \"jpeg\",           \"mjpeg\" },\n    { \"jpg\",            \"mjpeg\" },\n    { \"jps\",            \"mjpeg\" },\n    { \"jls\",            \"ljpeg\" },\n    { \"thm\",            \"mjpeg\" },\n    { \"db\",             \"mjpeg\" },\n    { \"pcd\",            \"photocd\" },\n    { \"pfm\",            \"pfm\" },\n    { \"pcx\",            \"pcx\" },\n    { \"png\",            \"png\" },\n    { \"pns\",            \"png\" },\n    { \"ptx\",            \"ptx\" },\n    { \"tga\",            \"targa\" },\n    { \"tif\",            \"tiff\" },\n    { \"tiff\",           \"tiff\" },\n    { \"sgi\",            \"sgi\" },\n    { \"sun\",            \"sunrast\" },\n    { \"ras\",            \"sunrast\" },\n    { \"rs\",             \"sunrast\" },\n    { \"ra\",             \"sunrast\" },\n    { \"im1\",            \"sunrast\" },\n    { \"im8\",            \"sunrast\" },\n    { \"im24\",           \"sunrast\" },\n    { \"im32\",           \"sunrast\" },\n    { \"sunras\",         \"sunrast\" },\n    { \"xbm\",            \"xbm\" },\n    { \"pam\",            \"pam\" },\n    { \"pbm\",            \"pbm\" },\n    { \"pgm\",            \"pgm\" },\n    { \"pgmyuv\",         \"pgmyuv\" },\n    { \"ppm\",            \"ppm\" },\n    { \"pnm\",            \"ppm\" },\n    { \"gif\",            \"gif\" }, // usually handled by demux_lavf\n    { \"pix\",            \"brender_pix\" },\n    { \"exr\",            \"exr\" },\n    { \"pic\",            \"pictor\" },\n    { \"xface\",          \"xface\" },\n    { \"xwd\",            \"xwd\" },\n    {0}\n};\n\nstatic const char *probe_format(mf_t *mf, char *type, enum demux_check check)\n{\n    if (check > DEMUX_CHECK_REQUEST)\n        return NULL;\n    char *org_type = type;\n    if (!type || !type[0]) {\n        char *p = strrchr(mf->names[0], '.');\n        if (p)\n            type = p + 1;\n    }\n    for (int i = 0; type2format[i].type; i++) {\n        if (type && strcasecmp(type, type2format[i].type) == 0)\n            return type2format[i].codec;\n    }\n    if (check == DEMUX_CHECK_REQUEST) {\n        if (!org_type) {\n            MP_ERR(mf, \"file type was not set! (try --mf-type=ext)\\n\");\n        } else {\n            MP_ERR(mf, \"--mf-type set to an unknown codec!\\n\");\n        }\n    }\n    return NULL;\n}\n\nstatic int demux_open_mf(demuxer_t *demuxer, enum demux_check check)\n{\n    mf_t *mf;\n\n    if (strncmp(demuxer->stream->url, \"mf://\", 5) == 0 &&\n        demuxer->stream->info && strcmp(demuxer->stream->info->name, \"mf\") == 0)\n    {\n        mf = open_mf_pattern(demuxer, demuxer, demuxer->stream->url + 5);\n    } else {\n        mf = open_mf_single(demuxer, demuxer->log, demuxer->stream->url);\n        int bog = 0;\n        MP_TARRAY_APPEND(mf, mf->streams, bog, demuxer->stream);\n    }\n\n    if (!mf || mf->nr_of_files < 1)\n        goto error;\n\n    double mf_fps;\n    char *mf_type;\n    mp_read_option_raw(demuxer->global, \"mf-fps\", &m_option_type_double, &mf_fps);\n    mp_read_option_raw(demuxer->global, \"mf-type\", &m_option_type_string, &mf_type);\n\n    const char *codec = mp_map_mimetype_to_video_codec(demuxer->stream->mime_type);\n    if (!codec || (mf_type && mf_type[0]))\n        codec = probe_format(mf, mf_type, check);\n    talloc_free(mf_type);\n    if (!codec)\n        goto error;\n\n    mf->curr_frame = 0;\n\n    // create a new video stream header\n    struct sh_stream *sh = demux_alloc_sh_stream(STREAM_VIDEO);\n    struct mp_codec_params *c = sh->codec;\n\n    c->codec = codec;\n    c->disp_w = 0;\n    c->disp_h = 0;\n    c->fps = mf_fps;\n    c->reliable_fps = true;\n\n    demux_add_sh_stream(demuxer, sh);\n\n    mf->sh = sh;\n    demuxer->priv = (void *)mf;\n    demuxer->seekable = true;\n    demuxer->duration = mf->nr_of_files / mf->sh->codec->fps;\n\n    return 0;\n\nerror:\n    return -1;\n}\n\nstatic void demux_close_mf(demuxer_t *demuxer)\n{\n}\n\nconst demuxer_desc_t demuxer_desc_mf = {\n    .name = \"mf\",\n    .desc = \"image files (mf)\",\n    .read_packet = demux_mf_read_packet,\n    .open = demux_open_mf,\n    .close = demux_close_mf,\n    .seek = demux_seek_mf,\n};\n"], "fixing_code": ["/*\n * This file is part of mpv.\n *\n * mpv is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * mpv is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include \"osdep/io.h\"\n\n#include \"mpv_talloc.h\"\n#include \"common/msg.h\"\n#include \"options/options.h\"\n#include \"options/m_config.h\"\n#include \"options/path.h\"\n#include \"misc/ctype.h\"\n\n#include \"stream/stream.h\"\n#include \"demux.h\"\n#include \"stheader.h\"\n#include \"codec_tags.h\"\n\n#define MF_MAX_FILE_SIZE (1024 * 1024 * 256)\n\ntypedef struct mf {\n    struct mp_log *log;\n    struct sh_stream *sh;\n    int curr_frame;\n    int nr_of_files;\n    char **names;\n    // optional\n    struct stream **streams;\n} mf_t;\n\n\nstatic void mf_add(mf_t *mf, const char *fname)\n{\n    char *entry = talloc_strdup(mf, fname);\n    MP_TARRAY_APPEND(mf, mf->names, mf->nr_of_files, entry);\n}\n\nstatic mf_t *open_mf_pattern(void *talloc_ctx, struct demuxer *d, char *filename)\n{\n    struct mp_log *log = d->log;\n    int error_count = 0;\n    int count = 0;\n\n    mf_t *mf = talloc_zero(talloc_ctx, mf_t);\n    mf->log = log;\n\n    if (filename[0] == '@') {\n        struct stream *s = stream_create(filename + 1,\n                            d->stream_origin | STREAM_READ, d->cancel, d->global);\n        if (s) {\n            while (1) {\n                char buf[512];\n                int len = stream_read_peek(s, buf, sizeof(buf));\n                if (!len)\n                    break;\n                bstr data = (bstr){buf, len};\n                int pos = bstrchr(data, '\\n');\n                data = bstr_splice(data, 0, pos < 0 ? data.len : pos + 1);\n                bstr fname = bstr_strip(data);\n                if (fname.len) {\n                    if (bstrchr(fname, '\\0') >= 0) {\n                        mp_err(log, \"invalid filename\\n\");\n                        break;\n                    }\n                    char *entry = bstrto0(mf, fname);\n                    if (!mp_path_exists(entry)) {\n                        mp_verbose(log, \"file not found: '%s'\\n\", entry);\n                    } else {\n                        MP_TARRAY_APPEND(mf, mf->names, mf->nr_of_files, entry);\n                    }\n                }\n                stream_seek_skip(s, stream_tell(s) + data.len);\n            }\n            free_stream(s);\n\n            mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n            goto exit_mf;\n        }\n        mp_info(log, \"%s is not indirect filelist\\n\", filename + 1);\n    }\n\n    if (strchr(filename, ',')) {\n        mp_info(log, \"filelist: %s\\n\", filename);\n        bstr bfilename = bstr0(filename);\n\n        while (bfilename.len) {\n            bstr bfname;\n            bstr_split_tok(bfilename, \",\", &bfname, &bfilename);\n            char *fname2 = bstrdup0(mf, bfname);\n\n            if (!mp_path_exists(fname2))\n                mp_verbose(log, \"file not found: '%s'\\n\", fname2);\n            else {\n                mf_add(mf, fname2);\n            }\n            talloc_free(fname2);\n        }\n        mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n\n        goto exit_mf;\n    }\n\n    size_t fname_avail = strlen(filename) + 32;\n    char *fname = talloc_size(mf, fname_avail);\n\n#if HAVE_GLOB\n    if (!strchr(filename, '%')) {\n        strcpy(fname, filename);\n        if (!strchr(filename, '*'))\n            strcat(fname, \"*\");\n\n        mp_info(log, \"search expr: %s\\n\", fname);\n\n        glob_t gg;\n        if (glob(fname, 0, NULL, &gg)) {\n            talloc_free(mf);\n            return NULL;\n        }\n\n        for (int i = 0; i < gg.gl_pathc; i++) {\n            if (mp_path_isdir(gg.gl_pathv[i]))\n                continue;\n            mf_add(mf, gg.gl_pathv[i]);\n        }\n        mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n        globfree(&gg);\n        goto exit_mf;\n    }\n#endif\n\n    // We're using arbitrary user input as printf format with 1 int argument.\n    // Any format which uses exactly 1 int argument would be valid, but for\n    // simplicity we reject all conversion specifiers except %% and simple\n    // integer specifier: %[.][NUM]d where NUM is 1-3 digits (%.d is valid)\n    const char *f = filename;\n    int MAXDIGS = 3, nspec = 0, bad_spec = 0, c;\n\n    while (nspec < 2 && (c = *f++)) {\n        if (c != '%')\n            continue;\n        if (*f != '%') {\n            nspec++;  // conversion specifier which isn't %%\n            if (*f == '.')\n                f++;\n            for (int ndig = 0; mp_isdigit(*f) && ndig < MAXDIGS; ndig++, f++)\n                /* no-op */;\n            if (*f != 'd') {\n                bad_spec++;  // not int, or beyond our validation capacity\n                break;\n            }\n        }\n        // *f is '%' or 'd'\n        f++;\n    }\n\n    // nspec==0 (zero specifiers) is rejected because fname wouldn't advance.\n    if (bad_spec || nspec != 1) {\n        mp_err(log, \"unsupported expr format: '%s'\\n\", filename);\n        goto exit_mf;\n    }\n\n    mp_info(log, \"search expr: %s\\n\", filename);\n\n    while (error_count < 5) {\n        if (snprintf(fname, fname_avail, filename, count++) >= fname_avail) {\n            mp_err(log, \"format result too long: '%s'\\n\", filename);\n            goto exit_mf;\n        }\n        if (!mp_path_exists(fname)) {\n            error_count++;\n            mp_verbose(log, \"file not found: '%s'\\n\", fname);\n        } else {\n            mf_add(mf, fname);\n        }\n    }\n\n    mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n\nexit_mf:\n    return mf;\n}\n\nstatic mf_t *open_mf_single(void *talloc_ctx, struct mp_log *log, char *filename)\n{\n    mf_t *mf = talloc_zero(talloc_ctx, mf_t);\n    mf->log = log;\n    mf_add(mf, filename);\n    return mf;\n}\n\nstatic void demux_seek_mf(demuxer_t *demuxer, double seek_pts, int flags)\n{\n    mf_t *mf = demuxer->priv;\n    double newpos = seek_pts * mf->sh->codec->fps;\n    if (flags & SEEK_FACTOR)\n        newpos = seek_pts * (mf->nr_of_files - 1);\n    if (flags & SEEK_FORWARD) {\n        newpos = ceil(newpos);\n    } else {\n        newpos = MPMIN(floor(newpos), mf->nr_of_files - 1);\n    }\n    mf->curr_frame = MPCLAMP((int)newpos, 0, mf->nr_of_files);\n}\n\nstatic bool demux_mf_read_packet(struct demuxer *demuxer,\n                                 struct demux_packet **pkt)\n{\n    mf_t *mf = demuxer->priv;\n    if (mf->curr_frame >= mf->nr_of_files)\n        return false;\n    bool ok = false;\n\n    struct stream *entry_stream = NULL;\n    if (mf->streams)\n        entry_stream = mf->streams[mf->curr_frame];\n    struct stream *stream = entry_stream;\n    if (!stream) {\n        char *filename = mf->names[mf->curr_frame];\n        if (filename) {\n            stream = stream_create(filename, demuxer->stream_origin | STREAM_READ,\n                                   demuxer->cancel, demuxer->global);\n        }\n    }\n\n    if (stream) {\n        stream_seek(stream, 0);\n        bstr data = stream_read_complete(stream, NULL, MF_MAX_FILE_SIZE);\n        if (data.len) {\n            demux_packet_t *dp = new_demux_packet(data.len);\n            if (dp) {\n                memcpy(dp->buffer, data.start, data.len);\n                dp->pts = mf->curr_frame / mf->sh->codec->fps;\n                dp->keyframe = true;\n                dp->stream = mf->sh->index;\n                *pkt = dp;\n                ok = true;\n            }\n        }\n        talloc_free(data.start);\n    }\n\n    if (stream && stream != entry_stream)\n        free_stream(stream);\n\n    mf->curr_frame++;\n\n    if (!ok)\n        MP_ERR(demuxer, \"error reading image file\\n\");\n\n    return true;\n}\n\n// map file extension/type to a codec name\n\nstatic const struct {\n    const char *type;\n    const char *codec;\n} type2format[] = {\n    { \"bmp\",            \"bmp\" },\n    { \"dpx\",            \"dpx\" },\n    { \"j2c\",            \"jpeg2000\" },\n    { \"j2k\",            \"jpeg2000\" },\n    { \"jp2\",            \"jpeg2000\" },\n    { \"jpc\",            \"jpeg2000\" },\n    { \"jpeg\",           \"mjpeg\" },\n    { \"jpg\",            \"mjpeg\" },\n    { \"jps\",            \"mjpeg\" },\n    { \"jls\",            \"ljpeg\" },\n    { \"thm\",            \"mjpeg\" },\n    { \"db\",             \"mjpeg\" },\n    { \"pcd\",            \"photocd\" },\n    { \"pfm\",            \"pfm\" },\n    { \"pcx\",            \"pcx\" },\n    { \"png\",            \"png\" },\n    { \"pns\",            \"png\" },\n    { \"ptx\",            \"ptx\" },\n    { \"tga\",            \"targa\" },\n    { \"tif\",            \"tiff\" },\n    { \"tiff\",           \"tiff\" },\n    { \"sgi\",            \"sgi\" },\n    { \"sun\",            \"sunrast\" },\n    { \"ras\",            \"sunrast\" },\n    { \"rs\",             \"sunrast\" },\n    { \"ra\",             \"sunrast\" },\n    { \"im1\",            \"sunrast\" },\n    { \"im8\",            \"sunrast\" },\n    { \"im24\",           \"sunrast\" },\n    { \"im32\",           \"sunrast\" },\n    { \"sunras\",         \"sunrast\" },\n    { \"xbm\",            \"xbm\" },\n    { \"pam\",            \"pam\" },\n    { \"pbm\",            \"pbm\" },\n    { \"pgm\",            \"pgm\" },\n    { \"pgmyuv\",         \"pgmyuv\" },\n    { \"ppm\",            \"ppm\" },\n    { \"pnm\",            \"ppm\" },\n    { \"gif\",            \"gif\" }, // usually handled by demux_lavf\n    { \"pix\",            \"brender_pix\" },\n    { \"exr\",            \"exr\" },\n    { \"pic\",            \"pictor\" },\n    { \"xface\",          \"xface\" },\n    { \"xwd\",            \"xwd\" },\n    {0}\n};\n\nstatic const char *probe_format(mf_t *mf, char *type, enum demux_check check)\n{\n    if (check > DEMUX_CHECK_REQUEST)\n        return NULL;\n    char *org_type = type;\n    if (!type || !type[0]) {\n        char *p = strrchr(mf->names[0], '.');\n        if (p)\n            type = p + 1;\n    }\n    for (int i = 0; type2format[i].type; i++) {\n        if (type && strcasecmp(type, type2format[i].type) == 0)\n            return type2format[i].codec;\n    }\n    if (check == DEMUX_CHECK_REQUEST) {\n        if (!org_type) {\n            MP_ERR(mf, \"file type was not set! (try --mf-type=ext)\\n\");\n        } else {\n            MP_ERR(mf, \"--mf-type set to an unknown codec!\\n\");\n        }\n    }\n    return NULL;\n}\n\nstatic int demux_open_mf(demuxer_t *demuxer, enum demux_check check)\n{\n    mf_t *mf;\n\n    if (strncmp(demuxer->stream->url, \"mf://\", 5) == 0 &&\n        demuxer->stream->info && strcmp(demuxer->stream->info->name, \"mf\") == 0)\n    {\n        mf = open_mf_pattern(demuxer, demuxer, demuxer->stream->url + 5);\n    } else {\n        mf = open_mf_single(demuxer, demuxer->log, demuxer->stream->url);\n        int bog = 0;\n        MP_TARRAY_APPEND(mf, mf->streams, bog, demuxer->stream);\n    }\n\n    if (!mf || mf->nr_of_files < 1)\n        goto error;\n\n    double mf_fps;\n    char *mf_type;\n    mp_read_option_raw(demuxer->global, \"mf-fps\", &m_option_type_double, &mf_fps);\n    mp_read_option_raw(demuxer->global, \"mf-type\", &m_option_type_string, &mf_type);\n\n    const char *codec = mp_map_mimetype_to_video_codec(demuxer->stream->mime_type);\n    if (!codec || (mf_type && mf_type[0]))\n        codec = probe_format(mf, mf_type, check);\n    talloc_free(mf_type);\n    if (!codec)\n        goto error;\n\n    mf->curr_frame = 0;\n\n    // create a new video stream header\n    struct sh_stream *sh = demux_alloc_sh_stream(STREAM_VIDEO);\n    struct mp_codec_params *c = sh->codec;\n\n    c->codec = codec;\n    c->disp_w = 0;\n    c->disp_h = 0;\n    c->fps = mf_fps;\n    c->reliable_fps = true;\n\n    demux_add_sh_stream(demuxer, sh);\n\n    mf->sh = sh;\n    demuxer->priv = (void *)mf;\n    demuxer->seekable = true;\n    demuxer->duration = mf->nr_of_files / mf->sh->codec->fps;\n\n    return 0;\n\nerror:\n    return -1;\n}\n\nstatic void demux_close_mf(demuxer_t *demuxer)\n{\n}\n\nconst demuxer_desc_t demuxer_desc_mf = {\n    .name = \"mf\",\n    .desc = \"image files (mf)\",\n    .read_packet = demux_mf_read_packet,\n    .open = demux_open_mf,\n    .close = demux_close_mf,\n    .seek = demux_seek_mf,\n};\n"], "filenames": ["demux/demux_mf.c"], "buggy_code_start_loc": [124], "buggy_code_end_loc": [155], "fixing_code_start_loc": [124], "fixing_code_end_loc": [190], "type": "CWE-134", "message": "A format string vulnerability in mpv through 0.33.0 allows user-assisted remote attackers to achieve code execution via a crafted m3u playlist file.", "other": {"cve": {"id": "CVE-2021-30145", "sourceIdentifier": "cve@mitre.org", "published": "2021-05-18T14:15:07.377", "lastModified": "2022-05-20T20:45:03.070", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A format string vulnerability in mpv through 0.33.0 allows user-assisted remote attackers to achieve code execution via a crafted m3u playlist file."}, {"lang": "es", "value": "Una vulnerabilidad de cadena de formato en mpv versiones hasta 0.33.0, permite a atacantes remotos asistidos por el usuario lograr una ejecuci\u00f3n de c\u00f3digo por medio de un archivo de m3u playlist dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-134"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mpv:mpv:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.33.0", "matchCriteriaId": "68C59BB4-2698-4AE1-84A8-2792D29A1A59"}]}]}], "references": [{"url": "https://devel0pment.de/?p=2217", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/mpv-player/mpv/commit/d0c530919d8cd4d7a774e38ab064e0fabdae34e6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mpv-player/mpv/releases/tag/v0.33.1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://mpv.io", "source": "cve@mitre.org", "tags": ["Product", "Vendor Advisory"]}, {"url": "https://security.gentoo.org/glsa/202107-46", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mpv-player/mpv/commit/d0c530919d8cd4d7a774e38ab064e0fabdae34e6"}}