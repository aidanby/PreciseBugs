{"buggy_code": ["/*\n * Copyright (c) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2017 Nicira, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <config.h>\n#include <sys/types.h>\n#include \"flow.h\"\n#include <errno.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <netinet/icmp6.h>\n#include <netinet/ip6.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"byte-order.h\"\n#include \"colors.h\"\n#include \"coverage.h\"\n#include \"csum.h\"\n#include \"openvswitch/dynamic-string.h\"\n#include \"hash.h\"\n#include \"jhash.h\"\n#include \"openvswitch/match.h\"\n#include \"dp-packet.h\"\n#include \"openflow/openflow.h\"\n#include \"packets.h\"\n#include \"odp-util.h\"\n#include \"random.h\"\n#include \"unaligned.h\"\n#include \"util.h\"\n#include \"openvswitch/nsh.h\"\n#include \"ovs-router.h\"\n#include \"lib/netdev-provider.h\"\n\nCOVERAGE_DEFINE(flow_extract);\nCOVERAGE_DEFINE(miniflow_malloc);\n\n/* U64 indices for segmented flow classification. */\nconst uint8_t flow_segment_u64s[4] = {\n    FLOW_SEGMENT_1_ENDS_AT / sizeof(uint64_t),\n    FLOW_SEGMENT_2_ENDS_AT / sizeof(uint64_t),\n    FLOW_SEGMENT_3_ENDS_AT / sizeof(uint64_t),\n    FLOW_U64S\n};\n\nint flow_vlan_limit = FLOW_MAX_VLAN_HEADERS;\n\n/* Asserts that field 'f1' follows immediately after 'f0' in struct flow,\n * without any intervening padding. */\n#define ASSERT_SEQUENTIAL(f0, f1)                       \\\n    BUILD_ASSERT_DECL(offsetof(struct flow, f0)         \\\n                      + MEMBER_SIZEOF(struct flow, f0)  \\\n                      == offsetof(struct flow, f1))\n\n/* Asserts that fields 'f0' and 'f1' are in the same 32-bit aligned word within\n * struct flow. */\n#define ASSERT_SAME_WORD(f0, f1)                        \\\n    BUILD_ASSERT_DECL(offsetof(struct flow, f0) / 4     \\\n                      == offsetof(struct flow, f1) / 4)\n\n/* Asserts that 'f0' and 'f1' are both sequential and within the same 32-bit\n * aligned word in struct flow. */\n#define ASSERT_SEQUENTIAL_SAME_WORD(f0, f1)     \\\n    ASSERT_SEQUENTIAL(f0, f1);                  \\\n    ASSERT_SAME_WORD(f0, f1)\n\n/* miniflow_extract() assumes the following to be true to optimize the\n * extraction process. */\nASSERT_SEQUENTIAL_SAME_WORD(nw_frag, nw_tos);\nASSERT_SEQUENTIAL_SAME_WORD(nw_tos, nw_ttl);\nASSERT_SEQUENTIAL_SAME_WORD(nw_ttl, nw_proto);\n\n/* TCP flags in the middle of a BE64, zeroes in the other half. */\nBUILD_ASSERT_DECL(offsetof(struct flow, tcp_flags) % 8 == 4);\n\n#if WORDS_BIGENDIAN\n#define TCP_FLAGS_BE32(tcp_ctl) ((OVS_FORCE ovs_be32)TCP_FLAGS_BE16(tcp_ctl) \\\n                                 << 16)\n#else\n#define TCP_FLAGS_BE32(tcp_ctl) ((OVS_FORCE ovs_be32)TCP_FLAGS_BE16(tcp_ctl))\n#endif\n\nASSERT_SEQUENTIAL_SAME_WORD(tp_src, tp_dst);\n\n/* Removes 'size' bytes from the head end of '*datap', of size '*sizep', which\n * must contain at least 'size' bytes of data.  Returns the first byte of data\n * removed. */\nstatic inline const void *\ndata_pull(const void **datap, size_t *sizep, size_t size)\n{\n    const char *data = *datap;\n    *datap = data + size;\n    *sizep -= size;\n    return data;\n}\n\n/* If '*datap' has at least 'size' bytes of data, removes that many bytes from\n * the head end of '*datap' and returns the first byte removed.  Otherwise,\n * returns a null pointer without modifying '*datap'. */\nstatic inline const void *\ndata_try_pull(const void **datap, size_t *sizep, size_t size)\n{\n    return OVS_LIKELY(*sizep >= size) ? data_pull(datap, sizep, size) : NULL;\n}\n\n/* Context for pushing data to a miniflow. */\nstruct mf_ctx {\n    struct flowmap map;\n    uint64_t *data;\n    uint64_t * const end;\n};\n\n/* miniflow_push_* macros allow filling in a miniflow data values in order.\n * Assertions are needed only when the layout of the struct flow is modified.\n * 'ofs' is a compile-time constant, which allows most of the code be optimized\n * away.  Some GCC versions gave warnings on ALWAYS_INLINE, so these are\n * defined as macros. */\n\n#if (FLOW_WC_SEQ != 41)\n#define MINIFLOW_ASSERT(X) ovs_assert(X)\nBUILD_MESSAGE(\"FLOW_WC_SEQ changed: miniflow_extract() will have runtime \"\n               \"assertions enabled. Consider updating FLOW_WC_SEQ after \"\n               \"testing\")\n#else\n#define MINIFLOW_ASSERT(X)\n#endif\n\n/* True if 'IDX' and higher bits are not set. */\n#define ASSERT_FLOWMAP_NOT_SET(FM, IDX)                                 \\\n{                                                                       \\\n    MINIFLOW_ASSERT(!((FM)->bits[(IDX) / MAP_T_BITS] &                  \\\n                      (MAP_MAX << ((IDX) % MAP_T_BITS))));              \\\n    for (size_t i = (IDX) / MAP_T_BITS + 1; i < FLOWMAP_UNITS; i++) {   \\\n        MINIFLOW_ASSERT(!(FM)->bits[i]);                                \\\n    }                                                                   \\\n}\n\n#define miniflow_set_map(MF, OFS)            \\\n    {                                        \\\n    ASSERT_FLOWMAP_NOT_SET(&MF.map, (OFS));  \\\n    flowmap_set(&MF.map, (OFS), 1);          \\\n}\n\n#define miniflow_assert_in_map(MF, OFS)              \\\n    MINIFLOW_ASSERT(flowmap_is_set(&MF.map, (OFS))); \\\n    ASSERT_FLOWMAP_NOT_SET(&MF.map, (OFS) + 1)\n\n#define miniflow_push_uint64_(MF, OFS, VALUE)              \\\n{                                                          \\\n    MINIFLOW_ASSERT(MF.data < MF.end && (OFS) % 8 == 0);   \\\n    *MF.data++ = VALUE;                                    \\\n    miniflow_set_map(MF, OFS / 8);                         \\\n}\n\n#define miniflow_push_be64_(MF, OFS, VALUE)                     \\\n    miniflow_push_uint64_(MF, OFS, (OVS_FORCE uint64_t)(VALUE))\n\n#define miniflow_push_uint32_(MF, OFS, VALUE)   \\\n    {                                           \\\n    MINIFLOW_ASSERT(MF.data < MF.end);          \\\n                                                \\\n    if ((OFS) % 8 == 0) {                       \\\n        miniflow_set_map(MF, OFS / 8);          \\\n        *(uint32_t *)MF.data = VALUE;           \\\n    } else if ((OFS) % 8 == 4) {                \\\n        miniflow_assert_in_map(MF, OFS / 8);    \\\n        *((uint32_t *)MF.data + 1) = VALUE;     \\\n        MF.data++;                              \\\n    }                                           \\\n}\n\n#define miniflow_push_be32_(MF, OFS, VALUE)                     \\\n    miniflow_push_uint32_(MF, OFS, (OVS_FORCE uint32_t)(VALUE))\n\n#define miniflow_push_uint16_(MF, OFS, VALUE)   \\\n{                                               \\\n    MINIFLOW_ASSERT(MF.data < MF.end);          \\\n                                                \\\n    if ((OFS) % 8 == 0) {                       \\\n        miniflow_set_map(MF, OFS / 8);          \\\n        *(uint16_t *)MF.data = VALUE;           \\\n    } else if ((OFS) % 8 == 2) {                \\\n        miniflow_assert_in_map(MF, OFS / 8);    \\\n        *((uint16_t *)MF.data + 1) = VALUE;     \\\n    } else if ((OFS) % 8 == 4) {                \\\n        miniflow_assert_in_map(MF, OFS / 8);    \\\n        *((uint16_t *)MF.data + 2) = VALUE;     \\\n    } else if ((OFS) % 8 == 6) {                \\\n        miniflow_assert_in_map(MF, OFS / 8);    \\\n        *((uint16_t *)MF.data + 3) = VALUE;     \\\n        MF.data++;                              \\\n    }                                           \\\n}\n\n#define miniflow_push_uint8_(MF, OFS, VALUE)            \\\n{                                                       \\\n    MINIFLOW_ASSERT(MF.data < MF.end);                  \\\n                                                        \\\n    if ((OFS) % 8 == 0) {                               \\\n        miniflow_set_map(MF, OFS / 8);                  \\\n        *(uint8_t *)MF.data = VALUE;                    \\\n    } else if ((OFS) % 8 == 7) {                        \\\n        miniflow_assert_in_map(MF, OFS / 8);            \\\n        *((uint8_t *)MF.data + 7) = VALUE;              \\\n        MF.data++;                                      \\\n    } else {                                            \\\n        miniflow_assert_in_map(MF, OFS / 8);            \\\n        *((uint8_t *)MF.data + ((OFS) % 8)) = VALUE;    \\\n    }                                                   \\\n}\n\n#define miniflow_pad_to_64_(MF, OFS)                            \\\n{                                                               \\\n    MINIFLOW_ASSERT((OFS) % 8 != 0);                            \\\n    miniflow_assert_in_map(MF, OFS / 8);                        \\\n                                                                \\\n    memset((uint8_t *)MF.data + (OFS) % 8, 0, 8 - (OFS) % 8);   \\\n    MF.data++;                                                  \\\n}\n\n#define miniflow_pad_from_64_(MF, OFS)                          \\\n{                                                               \\\n    MINIFLOW_ASSERT(MF.data < MF.end);                          \\\n                                                                \\\n    MINIFLOW_ASSERT((OFS) % 8 != 0);                            \\\n    miniflow_set_map(MF, OFS / 8);                              \\\n                                                                \\\n    memset((uint8_t *)MF.data, 0, (OFS) % 8);                   \\\n}\n\n#define miniflow_push_be16_(MF, OFS, VALUE)                     \\\n    miniflow_push_uint16_(MF, OFS, (OVS_FORCE uint16_t)VALUE);\n\n#define miniflow_push_be8_(MF, OFS, VALUE)                     \\\n    miniflow_push_uint8_(MF, OFS, (OVS_FORCE uint8_t)VALUE);\n\n#define miniflow_set_maps(MF, OFS, N_WORDS)                     \\\n{                                                               \\\n    size_t ofs = (OFS);                                         \\\n    size_t n_words = (N_WORDS);                                 \\\n                                                                \\\n    MINIFLOW_ASSERT(n_words && MF.data + n_words <= MF.end);    \\\n    ASSERT_FLOWMAP_NOT_SET(&MF.map, ofs);                       \\\n    flowmap_set(&MF.map, ofs, n_words);                         \\\n}\n\n/* Data at 'valuep' may be unaligned. */\n#define miniflow_push_words_(MF, OFS, VALUEP, N_WORDS)          \\\n{                                                               \\\n    MINIFLOW_ASSERT((OFS) % 8 == 0);                            \\\n    miniflow_set_maps(MF, (OFS) / 8, (N_WORDS));                \\\n    memcpy(MF.data, (VALUEP), (N_WORDS) * sizeof *MF.data);     \\\n    MF.data += (N_WORDS);                                       \\\n}\n\n/* Push 32-bit words padded to 64-bits. */\n#define miniflow_push_words_32_(MF, OFS, VALUEP, N_WORDS)               \\\n{                                                                       \\\n    miniflow_set_maps(MF, (OFS) / 8, DIV_ROUND_UP(N_WORDS, 2));         \\\n    memcpy(MF.data, (VALUEP), (N_WORDS) * sizeof(uint32_t));            \\\n    MF.data += DIV_ROUND_UP(N_WORDS, 2);                                \\\n    if ((N_WORDS) & 1) {                                                \\\n        *((uint32_t *)MF.data - 1) = 0;                                 \\\n    }                                                                   \\\n}\n\n/* Data at 'valuep' may be unaligned. */\n/* MACs start 64-aligned, and must be followed by other data or padding. */\n#define miniflow_push_macs_(MF, OFS, VALUEP)                    \\\n{                                                               \\\n    miniflow_set_maps(MF, (OFS) / 8, 2);                        \\\n    memcpy(MF.data, (VALUEP), 2 * ETH_ADDR_LEN);                \\\n    MF.data += 1;                   /* First word only. */      \\\n}\n\n#define miniflow_push_uint32(MF, FIELD, VALUE)                      \\\n    miniflow_push_uint32_(MF, offsetof(struct flow, FIELD), VALUE)\n\n#define miniflow_push_be32(MF, FIELD, VALUE)                        \\\n    miniflow_push_be32_(MF, offsetof(struct flow, FIELD), VALUE)\n\n#define miniflow_push_uint16(MF, FIELD, VALUE)                      \\\n    miniflow_push_uint16_(MF, offsetof(struct flow, FIELD), VALUE)\n\n#define miniflow_push_be16(MF, FIELD, VALUE)                        \\\n    miniflow_push_be16_(MF, offsetof(struct flow, FIELD), VALUE)\n\n#define miniflow_push_uint8(MF, FIELD, VALUE)                      \\\n    miniflow_push_uint8_(MF, offsetof(struct flow, FIELD), VALUE)\n\n#define miniflow_pad_to_64(MF, FIELD)                       \\\n    miniflow_pad_to_64_(MF, OFFSETOFEND(struct flow, FIELD))\n\n#define miniflow_pad_from_64(MF, FIELD)                       \\\n    miniflow_pad_from_64_(MF, offsetof(struct flow, FIELD))\n\n#define miniflow_push_words(MF, FIELD, VALUEP, N_WORDS)                 \\\n    miniflow_push_words_(MF, offsetof(struct flow, FIELD), VALUEP, N_WORDS)\n\n#define miniflow_push_words_32(MF, FIELD, VALUEP, N_WORDS)              \\\n    miniflow_push_words_32_(MF, offsetof(struct flow, FIELD), VALUEP, N_WORDS)\n\n#define miniflow_push_macs(MF, FIELD, VALUEP)                       \\\n    miniflow_push_macs_(MF, offsetof(struct flow, FIELD), VALUEP)\n\n/* Return the pointer to the miniflow data when called BEFORE the corresponding\n * push. */\n#define miniflow_pointer(MF, FIELD)                                     \\\n    (void *)((uint8_t *)MF.data + ((offsetof(struct flow, FIELD)) % 8))\n\n/* Pulls the MPLS headers at '*datap' and returns the count of them. */\nstatic inline int\nparse_mpls(const void **datap, size_t *sizep)\n{\n    const struct mpls_hdr *mh;\n    int count = 0;\n\n    while ((mh = data_try_pull(datap, sizep, sizeof *mh))) {\n        count++;\n        if (mh->mpls_lse.lo & htons(1 << MPLS_BOS_SHIFT)) {\n            break;\n        }\n    }\n    return MIN(count, FLOW_MAX_MPLS_LABELS);\n}\n\n/* passed vlan_hdrs arg must be at least size FLOW_MAX_VLAN_HEADERS. */\nstatic inline ALWAYS_INLINE size_t\nparse_vlan(const void **datap, size_t *sizep, union flow_vlan_hdr *vlan_hdrs)\n{\n    const ovs_be16 *eth_type;\n\n    memset(vlan_hdrs, 0, sizeof(union flow_vlan_hdr) * FLOW_MAX_VLAN_HEADERS);\n    data_pull(datap, sizep, ETH_ADDR_LEN * 2);\n\n    eth_type = *datap;\n\n    size_t n;\n    for (n = 0; eth_type_vlan(*eth_type) && n < flow_vlan_limit; n++) {\n        if (OVS_UNLIKELY(*sizep < sizeof(ovs_be32) + sizeof(ovs_be16))) {\n            break;\n        }\n\n        const ovs_16aligned_be32 *qp = data_pull(datap, sizep, sizeof *qp);\n        vlan_hdrs[n].qtag = get_16aligned_be32(qp);\n        vlan_hdrs[n].tci |= htons(VLAN_CFI);\n        eth_type = *datap;\n    }\n    return n;\n}\n\nstatic inline ALWAYS_INLINE ovs_be16\nparse_ethertype(const void **datap, size_t *sizep)\n{\n    const struct llc_snap_header *llc;\n    ovs_be16 proto;\n\n    proto = *(ovs_be16 *) data_pull(datap, sizep, sizeof proto);\n    if (OVS_LIKELY(ntohs(proto) >= ETH_TYPE_MIN)) {\n        return proto;\n    }\n\n    if (OVS_UNLIKELY(*sizep < sizeof *llc)) {\n        return htons(FLOW_DL_TYPE_NONE);\n    }\n\n    llc = *datap;\n    if (OVS_UNLIKELY(llc->llc.llc_dsap != LLC_DSAP_SNAP\n                     || llc->llc.llc_ssap != LLC_SSAP_SNAP\n                     || llc->llc.llc_cntl != LLC_CNTL_SNAP\n                     || memcmp(llc->snap.snap_org, SNAP_ORG_ETHERNET,\n                               sizeof llc->snap.snap_org))) {\n        return htons(FLOW_DL_TYPE_NONE);\n    }\n\n    data_pull(datap, sizep, sizeof *llc);\n\n    if (OVS_LIKELY(ntohs(llc->snap.snap_type) >= ETH_TYPE_MIN)) {\n        return llc->snap.snap_type;\n    }\n\n    return htons(FLOW_DL_TYPE_NONE);\n}\n\n/* Returns 'true' if the packet is an ND packet. In that case the '*nd_target'\n * and 'arp_buf[]' are filled in.  If the packet is not an ND packet, 'false'\n * is returned and no values are filled in on '*nd_target' or 'arp_buf[]'. */\nstatic inline bool\nparse_icmpv6(const void **datap, size_t *sizep, const struct icmp6_hdr *icmp,\n             uint32_t *rso_flags, const struct in6_addr **nd_target,\n             struct eth_addr arp_buf[2], uint8_t *opt_type)\n{\n    const uint32_t *reserved;\n    if (icmp->icmp6_code != 0 ||\n        (icmp->icmp6_type != ND_NEIGHBOR_SOLICIT &&\n         icmp->icmp6_type != ND_NEIGHBOR_ADVERT)) {\n        return false;\n    }\n\n    arp_buf[0] = eth_addr_zero;\n    arp_buf[1] = eth_addr_zero;\n    *opt_type = 0;\n\n    reserved = data_try_pull(datap, sizep, sizeof(uint32_t));\n    if (OVS_UNLIKELY(!reserved)) {\n        /* Invalid ND packet. */\n        return false;\n    }\n    *rso_flags = *reserved;\n\n    *nd_target = data_try_pull(datap, sizep, sizeof **nd_target);\n    if (OVS_UNLIKELY(!*nd_target)) {\n        return true;\n    }\n\n    while (*sizep >= 8) {\n        /* The minimum size of an option is 8 bytes, which also is\n         * the size of Ethernet link-layer options. */\n        const struct ovs_nd_lla_opt *lla_opt = *datap;\n        int opt_len = lla_opt->len * ND_LLA_OPT_LEN;\n\n        if (!opt_len || opt_len > *sizep) {\n            return true;\n        }\n\n        /* Store the link layer address if the appropriate option is\n         * provided.  It is considered an error if the same link\n         * layer option is specified twice. */\n        if (lla_opt->type == ND_OPT_SOURCE_LINKADDR && opt_len == 8) {\n            if (OVS_LIKELY(eth_addr_is_zero(arp_buf[0]))) {\n                arp_buf[0] = lla_opt->mac;\n                /* We use only first option type present in ND packet. */\n                if (*opt_type == 0) {\n                    *opt_type = lla_opt->type;\n                }\n            } else {\n                goto invalid;\n            }\n        } else if (lla_opt->type == ND_OPT_TARGET_LINKADDR && opt_len == 8) {\n            if (OVS_LIKELY(eth_addr_is_zero(arp_buf[1]))) {\n                arp_buf[1] = lla_opt->mac;\n                /* We use only first option type present in ND packet. */\n                if (*opt_type == 0) {\n                    *opt_type = lla_opt->type;\n                }\n            } else {\n                goto invalid;\n            }\n        }\n\n        if (OVS_UNLIKELY(!data_try_pull(datap, sizep, opt_len))) {\n            return true;\n        }\n    }\n    return true;\n\ninvalid:\n    *nd_target = NULL;\n    arp_buf[0] = eth_addr_zero;\n    arp_buf[1] = eth_addr_zero;\n    return true;\n}\n\nstatic inline bool\nparse_ipv6_ext_hdrs__(const void **datap, size_t *sizep, uint8_t *nw_proto,\n                      uint8_t *nw_frag,\n                      const struct ovs_16aligned_ip6_frag **frag_hdr)\n{\n    *frag_hdr = NULL;\n    while (1) {\n        if (OVS_LIKELY((*nw_proto != IPPROTO_HOPOPTS)\n                       && (*nw_proto != IPPROTO_ROUTING)\n                       && (*nw_proto != IPPROTO_DSTOPTS)\n                       && (*nw_proto != IPPROTO_AH)\n                       && (*nw_proto != IPPROTO_FRAGMENT))) {\n            /* It's either a terminal header (e.g., TCP, UDP) or one we\n             * don't understand.  In either case, we're done with the\n             * packet, so use it to fill in 'nw_proto'. */\n            return true;\n        }\n\n        /* We only verify that at least 8 bytes of the next header are\n         * available, but many of these headers are longer.  Ensure that\n         * accesses within the extension header are within those first 8\n         * bytes. All extension headers are required to be at least 8\n         * bytes. */\n        if (OVS_UNLIKELY(*sizep < 8)) {\n            return false;\n        }\n\n        if ((*nw_proto == IPPROTO_HOPOPTS)\n            || (*nw_proto == IPPROTO_ROUTING)\n            || (*nw_proto == IPPROTO_DSTOPTS)) {\n            /* These headers, while different, have the fields we care\n             * about in the same location and with the same\n             * interpretation. */\n            const struct ip6_ext *ext_hdr = *datap;\n            *nw_proto = ext_hdr->ip6e_nxt;\n            if (OVS_UNLIKELY(!data_try_pull(datap, sizep,\n                                            (ext_hdr->ip6e_len + 1) * 8))) {\n                return false;\n            }\n        } else if (*nw_proto == IPPROTO_AH) {\n            /* A standard AH definition isn't available, but the fields\n             * we care about are in the same location as the generic\n             * option header--only the header length is calculated\n             * differently. */\n            const struct ip6_ext *ext_hdr = *datap;\n            *nw_proto = ext_hdr->ip6e_nxt;\n            if (OVS_UNLIKELY(!data_try_pull(datap, sizep,\n                                            (ext_hdr->ip6e_len + 2) * 4))) {\n                return false;\n            }\n        } else if (*nw_proto == IPPROTO_FRAGMENT) {\n            *frag_hdr = *datap;\n\n            *nw_proto = (*frag_hdr)->ip6f_nxt;\n            if (!data_try_pull(datap, sizep, sizeof **frag_hdr)) {\n                return false;\n            }\n\n            /* We only process the first fragment. */\n            if ((*frag_hdr)->ip6f_offlg != htons(0)) {\n                *nw_frag = FLOW_NW_FRAG_ANY;\n                if (((*frag_hdr)->ip6f_offlg & IP6F_OFF_MASK) != htons(0)) {\n                    *nw_frag |= FLOW_NW_FRAG_LATER;\n                    *nw_proto = IPPROTO_FRAGMENT;\n                    return true;\n                }\n            }\n        }\n    }\n}\n\n/* Parses IPv6 extension headers until a terminal header (or header we\n * don't understand) is found.  'datap' points to the first extension\n * header and advances as parsing occurs; 'sizep' is the remaining size\n * and is decreased accordingly.  'nw_proto' starts as the first\n * extension header to process and is updated as the extension headers\n * are parsed.\n *\n * If a fragment header is found, '*frag_hdr' is set to the fragment\n * header and otherwise set to NULL.  If it is the first fragment,\n * extension header parsing otherwise continues as usual.  If it's not\n * the first fragment, 'nw_proto' is set to IPPROTO_FRAGMENT and 'nw_frag'\n * has FLOW_NW_FRAG_LATER set.  Both first and later fragments have\n * FLOW_NW_FRAG_ANY set in 'nw_frag'.\n *\n * A return value of false indicates that there was a problem parsing\n * the extension headers.*/\nbool\nparse_ipv6_ext_hdrs(const void **datap, size_t *sizep, uint8_t *nw_proto,\n                    uint8_t *nw_frag,\n                    const struct ovs_16aligned_ip6_frag **frag_hdr)\n{\n    return parse_ipv6_ext_hdrs__(datap, sizep, nw_proto, nw_frag,\n                                 frag_hdr);\n}\n\nbool\nparse_nsh(const void **datap, size_t *sizep, struct ovs_key_nsh *key)\n{\n    const struct nsh_hdr *nsh = (const struct nsh_hdr *) *datap;\n    uint8_t version, length, flags, ttl;\n\n    /* Check if it is long enough for NSH header, doesn't support\n     * MD type 2 yet\n     */\n    if (OVS_UNLIKELY(*sizep < NSH_BASE_HDR_LEN)) {\n        return false;\n    }\n\n    version = nsh_get_ver(nsh);\n    flags = nsh_get_flags(nsh);\n    length = nsh_hdr_len(nsh);\n    ttl = nsh_get_ttl(nsh);\n\n    if (OVS_UNLIKELY(length > *sizep || version != 0)) {\n        return false;\n    }\n\n    key->flags = flags;\n    key->ttl = ttl;\n    key->mdtype = nsh->md_type;\n    key->np = nsh->next_proto;\n    key->path_hdr = nsh_get_path_hdr(nsh);\n\n    switch (key->mdtype) {\n        case NSH_M_TYPE1:\n            if (length != NSH_M_TYPE1_LEN) {\n                return false;\n            }\n            for (size_t i = 0; i < 4; i++) {\n                key->context[i] = get_16aligned_be32(&nsh->md1.context[i]);\n            }\n            break;\n        case NSH_M_TYPE2:\n            /* Don't support MD type 2 metedata parsing yet */\n            if (length < NSH_BASE_HDR_LEN) {\n                return false;\n            }\n\n            memset(key->context, 0, sizeof(key->context));\n            break;\n        default:\n            /* We don't parse other context headers yet. */\n            memset(key->context, 0, sizeof(key->context));\n            break;\n    }\n\n    data_pull(datap, sizep, length);\n\n    return true;\n}\n\n/* This does the same thing as miniflow_extract() with a full-size 'flow' as\n * the destination. */\nvoid\nflow_extract(struct dp_packet *packet, struct flow *flow)\n{\n    struct {\n        struct miniflow mf;\n        uint64_t buf[FLOW_U64S];\n    } m;\n\n    COVERAGE_INC(flow_extract);\n\n    miniflow_extract(packet, &m.mf);\n    miniflow_expand(&m.mf, flow);\n}\n\nstatic inline bool\nipv4_sanity_check(const struct ip_header *nh, size_t size,\n                  int *ip_lenp, uint16_t *tot_lenp)\n{\n    int ip_len;\n    uint16_t tot_len;\n\n    if (OVS_UNLIKELY(size < IP_HEADER_LEN)) {\n        return false;\n    }\n    ip_len = IP_IHL(nh->ip_ihl_ver) * 4;\n\n    if (OVS_UNLIKELY(ip_len < IP_HEADER_LEN || size < ip_len)) {\n        return false;\n    }\n\n    tot_len = ntohs(nh->ip_tot_len);\n    if (OVS_UNLIKELY(tot_len > size || ip_len > tot_len ||\n                size - tot_len > UINT8_MAX)) {\n        return false;\n    }\n\n    *ip_lenp = ip_len;\n    *tot_lenp = tot_len;\n\n    return true;\n}\n\nstatic inline uint8_t\nipv4_get_nw_frag(const struct ip_header *nh)\n{\n    uint8_t nw_frag = 0;\n\n    if (OVS_UNLIKELY(IP_IS_FRAGMENT(nh->ip_frag_off))) {\n        nw_frag = FLOW_NW_FRAG_ANY;\n        if (nh->ip_frag_off & htons(IP_FRAG_OFF_MASK)) {\n            nw_frag |= FLOW_NW_FRAG_LATER;\n        }\n    }\n\n    return nw_frag;\n}\n\nstatic inline bool\nipv6_sanity_check(const struct ovs_16aligned_ip6_hdr *nh, size_t size)\n{\n    uint16_t plen;\n\n    if (OVS_UNLIKELY(size < sizeof *nh)) {\n        return false;\n    }\n\n    plen = ntohs(nh->ip6_plen);\n    if (OVS_UNLIKELY(plen + IPV6_HEADER_LEN > size)) {\n        return false;\n    }\n    /* Jumbo Payload option not supported yet. */\n    if (OVS_UNLIKELY(size - plen > UINT8_MAX)) {\n        return false;\n    }\n\n    return true;\n}\n\n/* Initializes 'dst' from 'packet' and 'md', taking the packet type into\n * account.  'dst' must have enough space for FLOW_U64S * 8 bytes.\n *\n * Initializes the layer offsets as follows:\n *\n *    - packet->l2_5_ofs to the\n *          * the start of the MPLS shim header. Can be zero, if the\n *            packet is of type (OFPHTN_ETHERTYPE, ETH_TYPE_MPLS).\n *          * UINT16_MAX when there is no MPLS shim header.\n *\n *    - packet->l3_ofs is set to\n *          * zero if the packet_type is in name space OFPHTN_ETHERTYPE\n *            and there is no MPLS shim header.\n *          * just past the Ethernet header, or just past the vlan_header if\n *            one is present, to the first byte of the payload of the\n *            Ethernet frame if the packet type is Ethernet and there is\n *            no MPLS shim header.\n *          * just past the MPLS label stack to the first byte of the MPLS\n *            payload if there is at least one MPLS shim header.\n *          * UINT16_MAX if the packet type is Ethernet and the frame is\n *            too short to contain an Ethernet header.\n *\n *    - packet->l4_ofs is set to just past the IPv4 or IPv6 header, if one is\n *      present and the packet has at least the content used for the fields\n *      of interest for the flow, otherwise UINT16_MAX.\n */\nvoid\nminiflow_extract(struct dp_packet *packet, struct miniflow *dst)\n{\n    /* Add code to this function (or its callees) to extract new fields. */\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n\n    const struct pkt_metadata *md = &packet->md;\n    const void *data = dp_packet_data(packet);\n    size_t size = dp_packet_size(packet);\n    ovs_be32 packet_type = packet->packet_type;\n    uint64_t *values = miniflow_values(dst);\n    struct mf_ctx mf = { FLOWMAP_EMPTY_INITIALIZER, values,\n                         values + FLOW_U64S };\n    const char *frame;\n    ovs_be16 dl_type = OVS_BE16_MAX;\n    uint8_t nw_frag, nw_tos, nw_ttl, nw_proto;\n    uint8_t *ct_nw_proto_p = NULL;\n    ovs_be16 ct_tp_src = 0, ct_tp_dst = 0;\n\n    /* Metadata. */\n    if (flow_tnl_dst_is_set(&md->tunnel)) {\n        miniflow_push_words(mf, tunnel, &md->tunnel,\n                            offsetof(struct flow_tnl, metadata) /\n                            sizeof(uint64_t));\n\n        if (!(md->tunnel.flags & FLOW_TNL_F_UDPIF)) {\n            if (md->tunnel.metadata.present.map) {\n                miniflow_push_words(mf, tunnel.metadata, &md->tunnel.metadata,\n                                    sizeof md->tunnel.metadata /\n                                    sizeof(uint64_t));\n            }\n        } else {\n            if (md->tunnel.metadata.present.len) {\n                miniflow_push_words(mf, tunnel.metadata.present,\n                                    &md->tunnel.metadata.present, 1);\n                miniflow_push_words(mf, tunnel.metadata.opts.gnv,\n                                    md->tunnel.metadata.opts.gnv,\n                                    DIV_ROUND_UP(md->tunnel.metadata.present.len,\n                                                 sizeof(uint64_t)));\n            }\n        }\n    }\n    if (md->skb_priority || md->pkt_mark) {\n        miniflow_push_uint32(mf, skb_priority, md->skb_priority);\n        miniflow_push_uint32(mf, pkt_mark, md->pkt_mark);\n    }\n    miniflow_push_uint32(mf, dp_hash, md->dp_hash);\n    miniflow_push_uint32(mf, in_port, odp_to_u32(md->in_port.odp_port));\n    if (md->ct_state) {\n        miniflow_push_uint32(mf, recirc_id, md->recirc_id);\n        miniflow_push_uint8(mf, ct_state, md->ct_state);\n        ct_nw_proto_p = miniflow_pointer(mf, ct_nw_proto);\n        miniflow_push_uint8(mf, ct_nw_proto, 0);\n        miniflow_push_uint16(mf, ct_zone, md->ct_zone);\n    } else if (md->recirc_id) {\n        miniflow_push_uint32(mf, recirc_id, md->recirc_id);\n        miniflow_pad_to_64(mf, recirc_id);\n    }\n\n    if (md->ct_state) {\n        miniflow_push_uint32(mf, ct_mark, md->ct_mark);\n        miniflow_push_be32(mf, packet_type, packet_type);\n\n        if (!ovs_u128_is_zero(md->ct_label)) {\n            miniflow_push_words(mf, ct_label, &md->ct_label,\n                                sizeof md->ct_label / sizeof(uint64_t));\n        }\n    } else {\n        miniflow_pad_from_64(mf, packet_type);\n        miniflow_push_be32(mf, packet_type, packet_type);\n    }\n\n    /* Initialize packet's layer pointer and offsets. */\n    frame = data;\n    dp_packet_reset_offsets(packet);\n\n    if (packet_type == htonl(PT_ETH)) {\n        /* Must have full Ethernet header to proceed. */\n        if (OVS_UNLIKELY(size < sizeof(struct eth_header))) {\n            goto out;\n        } else {\n            /* Link layer. */\n            ASSERT_SEQUENTIAL(dl_dst, dl_src);\n            miniflow_push_macs(mf, dl_dst, data);\n\n            /* VLAN */\n            union flow_vlan_hdr vlans[FLOW_MAX_VLAN_HEADERS];\n            size_t num_vlans = parse_vlan(&data, &size, vlans);\n\n            dl_type = parse_ethertype(&data, &size);\n            miniflow_push_be16(mf, dl_type, dl_type);\n            miniflow_pad_to_64(mf, dl_type);\n            if (num_vlans > 0) {\n                miniflow_push_words_32(mf, vlans, vlans, num_vlans);\n            }\n\n        }\n    } else {\n        /* Take dl_type from packet_type. */\n        dl_type = pt_ns_type_be(packet_type);\n        miniflow_pad_from_64(mf, dl_type);\n        miniflow_push_be16(mf, dl_type, dl_type);\n        /* Do not push vlan_tci, pad instead */\n        miniflow_pad_to_64(mf, dl_type);\n    }\n\n    /* Parse mpls. */\n    if (OVS_UNLIKELY(eth_type_mpls(dl_type))) {\n        int count;\n        const void *mpls = data;\n\n        packet->l2_5_ofs = (char *)data - frame;\n        count = parse_mpls(&data, &size);\n        miniflow_push_words_32(mf, mpls_lse, mpls, count);\n    }\n\n    /* Network layer. */\n    packet->l3_ofs = (char *)data - frame;\n\n    nw_frag = 0;\n    if (OVS_LIKELY(dl_type == htons(ETH_TYPE_IP))) {\n        const struct ip_header *nh = data;\n        int ip_len;\n        uint16_t tot_len;\n\n        if (OVS_UNLIKELY(!ipv4_sanity_check(nh, size, &ip_len, &tot_len))) {\n            goto out;\n        }\n        dp_packet_set_l2_pad_size(packet, size - tot_len);\n        size = tot_len;   /* Never pull padding. */\n\n        /* Push both source and destination address at once. */\n        miniflow_push_words(mf, nw_src, &nh->ip_src, 1);\n        if (ct_nw_proto_p && !md->ct_orig_tuple_ipv6) {\n            *ct_nw_proto_p = md->ct_orig_tuple.ipv4.ipv4_proto;\n            if (*ct_nw_proto_p) {\n                miniflow_push_words(mf, ct_nw_src,\n                                    &md->ct_orig_tuple.ipv4.ipv4_src, 1);\n                ct_tp_src = md->ct_orig_tuple.ipv4.src_port;\n                ct_tp_dst = md->ct_orig_tuple.ipv4.dst_port;\n            }\n        }\n\n        miniflow_push_be32(mf, ipv6_label, 0); /* Padding for IPv4. */\n\n        nw_tos = nh->ip_tos;\n        nw_ttl = nh->ip_ttl;\n        nw_proto = nh->ip_proto;\n        nw_frag = ipv4_get_nw_frag(nh);\n        data_pull(&data, &size, ip_len);\n    } else if (dl_type == htons(ETH_TYPE_IPV6)) {\n        const struct ovs_16aligned_ip6_hdr *nh = data;\n        ovs_be32 tc_flow;\n        uint16_t plen;\n\n        if (OVS_UNLIKELY(!ipv6_sanity_check(nh, size))) {\n            goto out;\n        }\n        data_pull(&data, &size, sizeof *nh);\n\n        plen = ntohs(nh->ip6_plen);\n        dp_packet_set_l2_pad_size(packet, size - plen);\n        size = plen;   /* Never pull padding. */\n\n        miniflow_push_words(mf, ipv6_src, &nh->ip6_src,\n                            sizeof nh->ip6_src / 8);\n        miniflow_push_words(mf, ipv6_dst, &nh->ip6_dst,\n                            sizeof nh->ip6_dst / 8);\n        if (ct_nw_proto_p && md->ct_orig_tuple_ipv6) {\n            *ct_nw_proto_p = md->ct_orig_tuple.ipv6.ipv6_proto;\n            if (*ct_nw_proto_p) {\n                miniflow_push_words(mf, ct_ipv6_src,\n                                    &md->ct_orig_tuple.ipv6.ipv6_src,\n                                    2 *\n                                    sizeof md->ct_orig_tuple.ipv6.ipv6_src / 8);\n                ct_tp_src = md->ct_orig_tuple.ipv6.src_port;\n                ct_tp_dst = md->ct_orig_tuple.ipv6.dst_port;\n            }\n        }\n\n        tc_flow = get_16aligned_be32(&nh->ip6_flow);\n        nw_tos = ntohl(tc_flow) >> 20;\n        nw_ttl = nh->ip6_hlim;\n        nw_proto = nh->ip6_nxt;\n\n        const struct ovs_16aligned_ip6_frag *frag_hdr;\n        if (!parse_ipv6_ext_hdrs__(&data, &size, &nw_proto, &nw_frag,\n                                   &frag_hdr)) {\n            goto out;\n        }\n\n        /* This needs to be after the parse_ipv6_ext_hdrs__() call because it\n         * leaves the nw_frag word uninitialized. */\n        ASSERT_SEQUENTIAL(ipv6_label, nw_frag);\n        ovs_be32 label = tc_flow & htonl(IPV6_LABEL_MASK);\n        miniflow_push_be32(mf, ipv6_label, label);\n    } else {\n        if (dl_type == htons(ETH_TYPE_ARP) ||\n            dl_type == htons(ETH_TYPE_RARP)) {\n            struct eth_addr arp_buf[2];\n            const struct arp_eth_header *arp = (const struct arp_eth_header *)\n                data_try_pull(&data, &size, ARP_ETH_HEADER_LEN);\n\n            if (OVS_LIKELY(arp) && OVS_LIKELY(arp->ar_hrd == htons(1))\n                && OVS_LIKELY(arp->ar_pro == htons(ETH_TYPE_IP))\n                && OVS_LIKELY(arp->ar_hln == ETH_ADDR_LEN)\n                && OVS_LIKELY(arp->ar_pln == 4)) {\n                miniflow_push_be32(mf, nw_src,\n                                   get_16aligned_be32(&arp->ar_spa));\n                miniflow_push_be32(mf, nw_dst,\n                                   get_16aligned_be32(&arp->ar_tpa));\n\n                /* We only match on the lower 8 bits of the opcode. */\n                if (OVS_LIKELY(ntohs(arp->ar_op) <= 0xff)) {\n                    miniflow_push_be32(mf, ipv6_label, 0); /* Pad with ARP. */\n                    miniflow_push_be32(mf, nw_frag, htonl(ntohs(arp->ar_op)));\n                }\n\n                /* Must be adjacent. */\n                ASSERT_SEQUENTIAL(arp_sha, arp_tha);\n\n                arp_buf[0] = arp->ar_sha;\n                arp_buf[1] = arp->ar_tha;\n                miniflow_push_macs(mf, arp_sha, arp_buf);\n                miniflow_pad_to_64(mf, arp_tha);\n            }\n        } else if (dl_type == htons(ETH_TYPE_NSH)) {\n            struct ovs_key_nsh nsh;\n\n            if (OVS_LIKELY(parse_nsh(&data, &size, &nsh))) {\n                miniflow_push_words(mf, nsh, &nsh,\n                                    sizeof(struct ovs_key_nsh) /\n                                    sizeof(uint64_t));\n            }\n        }\n        goto out;\n    }\n\n    packet->l4_ofs = (char *)data - frame;\n    miniflow_push_be32(mf, nw_frag,\n                       bytes_to_be32(nw_frag, nw_tos, nw_ttl, nw_proto));\n\n    if (OVS_LIKELY(!(nw_frag & FLOW_NW_FRAG_LATER))) {\n        if (OVS_LIKELY(nw_proto == IPPROTO_TCP)) {\n            if (OVS_LIKELY(size >= TCP_HEADER_LEN)) {\n                const struct tcp_header *tcp = data;\n\n                miniflow_push_be32(mf, arp_tha.ea[2], 0);\n                miniflow_push_be32(mf, tcp_flags,\n                                   TCP_FLAGS_BE32(tcp->tcp_ctl));\n                miniflow_push_be16(mf, tp_src, tcp->tcp_src);\n                miniflow_push_be16(mf, tp_dst, tcp->tcp_dst);\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_UDP)) {\n            if (OVS_LIKELY(size >= UDP_HEADER_LEN)) {\n                const struct udp_header *udp = data;\n\n                miniflow_push_be16(mf, tp_src, udp->udp_src);\n                miniflow_push_be16(mf, tp_dst, udp->udp_dst);\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_SCTP)) {\n            if (OVS_LIKELY(size >= SCTP_HEADER_LEN)) {\n                const struct sctp_header *sctp = data;\n\n                miniflow_push_be16(mf, tp_src, sctp->sctp_src);\n                miniflow_push_be16(mf, tp_dst, sctp->sctp_dst);\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_ICMP)) {\n            if (OVS_LIKELY(size >= ICMP_HEADER_LEN)) {\n                const struct icmp_header *icmp = data;\n\n                miniflow_push_be16(mf, tp_src, htons(icmp->icmp_type));\n                miniflow_push_be16(mf, tp_dst, htons(icmp->icmp_code));\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_IGMP)) {\n            if (OVS_LIKELY(size >= IGMP_HEADER_LEN)) {\n                const struct igmp_header *igmp = data;\n\n                miniflow_push_be16(mf, tp_src, htons(igmp->igmp_type));\n                miniflow_push_be16(mf, tp_dst, htons(igmp->igmp_code));\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n                miniflow_push_be32(mf, igmp_group_ip4,\n                                   get_16aligned_be32(&igmp->group));\n                miniflow_pad_to_64(mf, igmp_group_ip4);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_ICMPV6)) {\n            if (OVS_LIKELY(size >= sizeof(struct icmp6_hdr))) {\n                const struct in6_addr *nd_target;\n                struct eth_addr arp_buf[2];\n                /* This will populate whether we received Option 1\n                 * or Option 2. */\n                uint8_t opt_type;\n                /* This holds the ND Reserved field. */\n                uint32_t rso_flags;\n                const struct icmp6_hdr *icmp = data_pull(&data,\n                                               &size,ICMP6_HEADER_LEN);\n                if (parse_icmpv6(&data, &size, icmp,\n                                 &rso_flags, &nd_target, arp_buf, &opt_type)) {\n                    if (nd_target) {\n                        miniflow_push_words(mf, nd_target, nd_target,\n                                            sizeof *nd_target / sizeof(uint64_t));\n                    }\n                    miniflow_push_macs(mf, arp_sha, arp_buf);\n                    /* Populate options field and set the padding\n                     * accordingly. */\n                    if (opt_type != 0) {\n                        miniflow_push_be16(mf, tcp_flags, htons(opt_type));\n                        /* Pad to align with 64 bits.\n                         * This will zero out the pad3 field. */\n                        miniflow_pad_to_64(mf, tcp_flags);\n                    } else {\n                        /* Pad to align with 64 bits.\n                         * This will zero out the tcp_flags & pad3 field. */\n                        miniflow_pad_to_64(mf, arp_tha);\n                    }\n                    miniflow_push_be16(mf, tp_src, htons(icmp->icmp6_type));\n                    miniflow_push_be16(mf, tp_dst, htons(icmp->icmp6_code));\n                    miniflow_pad_to_64(mf, tp_dst);\n                    /* Fill ND reserved field. */\n                    miniflow_push_be32(mf, igmp_group_ip4, htonl(rso_flags));\n                    miniflow_pad_to_64(mf, igmp_group_ip4);\n                } else {\n                    /* ICMPv6 but not ND. */\n                    miniflow_push_be16(mf, tp_src, htons(icmp->icmp6_type));\n                    miniflow_push_be16(mf, tp_dst, htons(icmp->icmp6_code));\n                    miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                    miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n                }\n            }\n        }\n    }\n out:\n    dst->map = mf.map;\n}\n\novs_be16\nparse_dl_type(const struct eth_header *data_, size_t size)\n{\n    const void *data = data_;\n    union flow_vlan_hdr vlans[FLOW_MAX_VLAN_HEADERS];\n\n    parse_vlan(&data, &size, vlans);\n\n    return parse_ethertype(&data, &size);\n}\n\n/* Parses and return the TCP flags in 'packet', converted to host byte order.\n * If 'packet' is not an Ethernet packet embedding TCP, returns 0.\n *\n * The caller must ensure that 'packet' is at least ETH_HEADER_LEN bytes\n * long.'*/\nuint16_t\nparse_tcp_flags(struct dp_packet *packet)\n{\n    const void *data = dp_packet_data(packet);\n    const char *frame = (const char *)data;\n    size_t size = dp_packet_size(packet);\n    ovs_be16 dl_type;\n    uint8_t nw_frag = 0, nw_proto = 0;\n\n    if (packet->packet_type != htonl(PT_ETH)) {\n        return 0;\n    }\n\n    dp_packet_reset_offsets(packet);\n\n    data_pull(&data, &size, ETH_ADDR_LEN * 2);\n    dl_type = parse_ethertype(&data, &size);\n    if (OVS_UNLIKELY(eth_type_mpls(dl_type))) {\n        packet->l2_5_ofs = (char *)data - frame;\n    }\n    if (OVS_LIKELY(dl_type == htons(ETH_TYPE_IP))) {\n        const struct ip_header *nh = data;\n        int ip_len;\n        uint16_t tot_len;\n\n        if (OVS_UNLIKELY(!ipv4_sanity_check(nh, size, &ip_len, &tot_len))) {\n            return 0;\n        }\n        dp_packet_set_l2_pad_size(packet, size - tot_len);\n        packet->l3_ofs = (uint16_t)((char *)nh - frame);\n        nw_proto = nh->ip_proto;\n        nw_frag = ipv4_get_nw_frag(nh);\n\n        size = tot_len;   /* Never pull padding. */\n        data_pull(&data, &size, ip_len);\n    } else if (dl_type == htons(ETH_TYPE_IPV6)) {\n        const struct ovs_16aligned_ip6_hdr *nh = data;\n        uint16_t plen;\n\n        if (OVS_UNLIKELY(!ipv6_sanity_check(nh, size))) {\n            return 0;\n        }\n        packet->l3_ofs = (uint16_t)((char *)nh - frame);\n        data_pull(&data, &size, sizeof *nh);\n\n        plen = ntohs(nh->ip6_plen); /* Never pull padding. */\n        dp_packet_set_l2_pad_size(packet, size - plen);\n        size = plen;\n        const struct ovs_16aligned_ip6_frag *frag_hdr;\n        if (!parse_ipv6_ext_hdrs__(&data, &size, &nw_proto, &nw_frag,\n            &frag_hdr)) {\n            return 0;\n        }\n        nw_proto = nh->ip6_nxt;\n    } else {\n        return 0;\n    }\n\n    packet->l4_ofs = (uint16_t)((char *)data - frame);\n    if (!(nw_frag & FLOW_NW_FRAG_LATER) && nw_proto == IPPROTO_TCP &&\n        size >= TCP_HEADER_LEN) {\n        const struct tcp_header *tcp = data;\n\n        return TCP_FLAGS(tcp->tcp_ctl);\n    }\n\n    return 0;\n}\n\n/* For every bit of a field that is wildcarded in 'wildcards', sets the\n * corresponding bit in 'flow' to zero. */\nvoid\nflow_zero_wildcards(struct flow *flow, const struct flow_wildcards *wildcards)\n{\n    uint64_t *flow_u64 = (uint64_t *) flow;\n    const uint64_t *wc_u64 = (const uint64_t *) &wildcards->masks;\n    size_t i;\n\n    for (i = 0; i < FLOW_U64S; i++) {\n        flow_u64[i] &= wc_u64[i];\n    }\n}\n\nvoid\nflow_unwildcard_tp_ports(const struct flow *flow, struct flow_wildcards *wc)\n{\n    if (flow->nw_proto != IPPROTO_ICMP) {\n        memset(&wc->masks.tp_src, 0xff, sizeof wc->masks.tp_src);\n        memset(&wc->masks.tp_dst, 0xff, sizeof wc->masks.tp_dst);\n    } else {\n        wc->masks.tp_src = htons(0xff);\n        wc->masks.tp_dst = htons(0xff);\n    }\n}\n\n/* Initializes 'flow_metadata' with the metadata found in 'flow'. */\nvoid\nflow_get_metadata(const struct flow *flow, struct match *flow_metadata)\n{\n    int i;\n\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n\n    match_init_catchall(flow_metadata);\n    if (flow->tunnel.tun_id != htonll(0)) {\n        match_set_tun_id(flow_metadata, flow->tunnel.tun_id);\n    }\n    if (flow->tunnel.flags & FLOW_TNL_PUB_F_MASK) {\n        match_set_tun_flags(flow_metadata,\n                            flow->tunnel.flags & FLOW_TNL_PUB_F_MASK);\n    }\n    if (flow->tunnel.ip_src) {\n        match_set_tun_src(flow_metadata, flow->tunnel.ip_src);\n    }\n    if (flow->tunnel.ip_dst) {\n        match_set_tun_dst(flow_metadata, flow->tunnel.ip_dst);\n    }\n    if (ipv6_addr_is_set(&flow->tunnel.ipv6_src)) {\n        match_set_tun_ipv6_src(flow_metadata, &flow->tunnel.ipv6_src);\n    }\n    if (ipv6_addr_is_set(&flow->tunnel.ipv6_dst)) {\n        match_set_tun_ipv6_dst(flow_metadata, &flow->tunnel.ipv6_dst);\n    }\n    if (flow->tunnel.gbp_id != htons(0)) {\n        match_set_tun_gbp_id(flow_metadata, flow->tunnel.gbp_id);\n    }\n    if (flow->tunnel.gbp_flags) {\n        match_set_tun_gbp_flags(flow_metadata, flow->tunnel.gbp_flags);\n    }\n    if (flow->tunnel.erspan_ver) {\n        match_set_tun_erspan_ver(flow_metadata, flow->tunnel.erspan_ver);\n    }\n    if (flow->tunnel.erspan_idx) {\n        match_set_tun_erspan_idx(flow_metadata, flow->tunnel.erspan_idx);\n    }\n    if (flow->tunnel.erspan_dir) {\n        match_set_tun_erspan_dir(flow_metadata, flow->tunnel.erspan_dir);\n    }\n    if (flow->tunnel.erspan_hwid) {\n        match_set_tun_erspan_hwid(flow_metadata, flow->tunnel.erspan_hwid);\n    }\n    tun_metadata_get_fmd(&flow->tunnel, flow_metadata);\n    if (flow->metadata != htonll(0)) {\n        match_set_metadata(flow_metadata, flow->metadata);\n    }\n\n    for (i = 0; i < FLOW_N_REGS; i++) {\n        if (flow->regs[i]) {\n            match_set_reg(flow_metadata, i, flow->regs[i]);\n        }\n    }\n\n    if (flow->pkt_mark != 0) {\n        match_set_pkt_mark(flow_metadata, flow->pkt_mark);\n    }\n\n    match_set_in_port(flow_metadata, flow->in_port.ofp_port);\n    if (flow->packet_type != htonl(PT_ETH)) {\n        match_set_packet_type(flow_metadata, flow->packet_type);\n    }\n\n    if (flow->ct_state != 0) {\n        match_set_ct_state(flow_metadata, flow->ct_state);\n        /* Match dl_type since it is required for the later interpretation of\n         * the conntrack metadata. */\n        match_set_dl_type(flow_metadata, flow->dl_type);\n        if (is_ct_valid(flow, NULL, NULL) && flow->ct_nw_proto != 0) {\n            if (flow->dl_type == htons(ETH_TYPE_IP)) {\n                match_set_ct_nw_src(flow_metadata, flow->ct_nw_src);\n                match_set_ct_nw_dst(flow_metadata, flow->ct_nw_dst);\n                match_set_ct_nw_proto(flow_metadata, flow->ct_nw_proto);\n                match_set_ct_tp_src(flow_metadata, flow->ct_tp_src);\n                match_set_ct_tp_dst(flow_metadata, flow->ct_tp_dst);\n            } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n                match_set_ct_ipv6_src(flow_metadata, &flow->ct_ipv6_src);\n                match_set_ct_ipv6_dst(flow_metadata, &flow->ct_ipv6_dst);\n                match_set_ct_nw_proto(flow_metadata, flow->ct_nw_proto);\n                match_set_ct_tp_src(flow_metadata, flow->ct_tp_src);\n                match_set_ct_tp_dst(flow_metadata, flow->ct_tp_dst);\n            }\n        }\n    }\n    if (flow->ct_zone != 0) {\n        match_set_ct_zone(flow_metadata, flow->ct_zone);\n    }\n    if (flow->ct_mark != 0) {\n        match_set_ct_mark(flow_metadata, flow->ct_mark);\n    }\n    if (!ovs_u128_is_zero(flow->ct_label)) {\n        match_set_ct_label(flow_metadata, flow->ct_label);\n    }\n}\n\nconst char *\nct_state_to_string(uint32_t state)\n{\n    switch (state) {\n#define CS_STATE(ENUM, INDEX, NAME) case CS_##ENUM: return NAME;\n        CS_STATES\n#undef CS_STATE\n    default:\n        return NULL;\n    }\n}\n\nuint32_t\nct_state_from_string(const char *s)\n{\n#define CS_STATE(ENUM, INDEX, NAME) \\\n    if (!strcmp(s, NAME)) {         \\\n        return CS_##ENUM;           \\\n    }\n    CS_STATES\n#undef CS_STATE\n    return 0;\n}\n\n/* Parses conntrack state from 'state_str'.  If it is parsed successfully,\n * stores the parsed ct_state in 'ct_state', and returns true.  Otherwise,\n * returns false, and reports error message in 'ds'. */\nbool\nparse_ct_state(const char *state_str, uint32_t default_state,\n               uint32_t *ct_state, struct ds *ds)\n{\n    uint32_t state = default_state;\n    char *state_s = xstrdup(state_str);\n    char *save_ptr = NULL;\n\n    for (char *cs = strtok_r(state_s, \", \", &save_ptr); cs;\n         cs = strtok_r(NULL, \", \", &save_ptr)) {\n        uint32_t bit = ct_state_from_string(cs);\n        if (!bit) {\n            ds_put_format(ds, \"%s: unknown connection tracking state flag\",\n                          cs);\n            free(state_s);\n            return false;\n        }\n        state |= bit;\n    }\n\n    *ct_state = state;\n    free(state_s);\n\n    return true;\n}\n\n/* Checks the given conntrack state 'state' according to the constraints\n * listed in ovs-fields (7).  Returns true if it is valid.  Otherwise, returns\n * false, and reports error in 'ds'. */\nbool\nvalidate_ct_state(uint32_t state, struct ds *ds)\n{\n    bool valid_ct_state = true;\n    struct ds d_str = DS_EMPTY_INITIALIZER;\n\n    format_flags(&d_str, ct_state_to_string, state, '|');\n\n    if (state && !(state & CS_TRACKED)) {\n        ds_put_format(ds, \"%s: invalid connection state: \"\n                      \"If \\\"trk\\\" is unset, no other flags are set\\n\",\n                      ds_cstr(&d_str));\n        valid_ct_state = false;\n    }\n    if (state & CS_INVALID && state & ~(CS_TRACKED | CS_INVALID)) {\n        ds_put_format(ds, \"%s: invalid connection state: \"\n                      \"when \\\"inv\\\" is set, only \\\"trk\\\" may also be set\\n\",\n                      ds_cstr(&d_str));\n        valid_ct_state = false;\n    }\n    if (state & CS_NEW && state & CS_ESTABLISHED) {\n        ds_put_format(ds, \"%s: invalid connection state: \"\n                      \"\\\"new\\\" and \\\"est\\\" are mutually exclusive\\n\",\n                      ds_cstr(&d_str));\n        valid_ct_state = false;\n    }\n    if (state & CS_NEW && state & CS_REPLY_DIR) {\n        ds_put_format(ds, \"%s: invalid connection state: \"\n                      \"\\\"new\\\" and \\\"rpy\\\" are mutually exclusive\\n\",\n                      ds_cstr(&d_str));\n        valid_ct_state = false;\n    }\n\n    ds_destroy(&d_str);\n    return valid_ct_state;\n}\n\n/* Clears the fields in 'flow' associated with connection tracking. */\nvoid\nflow_clear_conntrack(struct flow *flow)\n{\n    flow->ct_state = 0;\n    flow->ct_zone = 0;\n    flow->ct_mark = 0;\n    flow->ct_label = OVS_U128_ZERO;\n\n    flow->ct_nw_proto = 0;\n    flow->ct_tp_src = 0;\n    flow->ct_tp_dst = 0;\n    if (flow->dl_type == htons(ETH_TYPE_IP)) {\n        flow->ct_nw_src = 0;\n        flow->ct_nw_dst = 0;\n    } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n        memset(&flow->ct_ipv6_src, 0, sizeof flow->ct_ipv6_src);\n        memset(&flow->ct_ipv6_dst, 0, sizeof flow->ct_ipv6_dst);\n    }\n}\n\nchar *\nflow_to_string(const struct flow *flow,\n               const struct ofputil_port_map *port_map)\n{\n    struct ds ds = DS_EMPTY_INITIALIZER;\n    flow_format(&ds, flow, port_map);\n    return ds_cstr(&ds);\n}\n\nconst char *\nflow_tun_flag_to_string(uint32_t flags)\n{\n    switch (flags) {\n    case FLOW_TNL_F_DONT_FRAGMENT:\n        return \"df\";\n    case FLOW_TNL_F_CSUM:\n        return \"csum\";\n    case FLOW_TNL_F_KEY:\n        return \"key\";\n    case FLOW_TNL_F_OAM:\n        return \"oam\";\n    default:\n        return NULL;\n    }\n}\n\nvoid\nformat_flags(struct ds *ds, const char *(*bit_to_string)(uint32_t),\n             uint32_t flags, char del)\n{\n    uint32_t bad = 0;\n\n    if (!flags) {\n        ds_put_char(ds, '0');\n        return;\n    }\n    while (flags) {\n        uint32_t bit = rightmost_1bit(flags);\n        const char *s;\n\n        s = bit_to_string(bit);\n        if (s) {\n            ds_put_format(ds, \"%s%c\", s, del);\n        } else {\n            bad |= bit;\n        }\n\n        flags &= ~bit;\n    }\n\n    if (bad) {\n        ds_put_format(ds, \"0x%\"PRIx32\"%c\", bad, del);\n    }\n    ds_chomp(ds, del);\n}\n\nvoid\nformat_flags_masked(struct ds *ds, const char *name,\n                    const char *(*bit_to_string)(uint32_t), uint32_t flags,\n                    uint32_t mask, uint32_t max_mask)\n{\n    if (name) {\n        ds_put_format(ds, \"%s%s=%s\", colors.param, name, colors.end);\n    }\n\n    if (mask == max_mask) {\n        format_flags(ds, bit_to_string, flags, '|');\n        return;\n    }\n\n    if (!mask) {\n        ds_put_cstr(ds, \"0/0\");\n        return;\n    }\n\n    while (mask) {\n        uint32_t bit = rightmost_1bit(mask);\n        const char *s = bit_to_string(bit);\n\n        ds_put_format(ds, \"%s%s\", (flags & bit) ? \"+\" : \"-\",\n                      s ? s : \"[Unknown]\");\n        mask &= ~bit;\n    }\n}\n\nstatic void\nput_u16_masked(struct ds *s, uint16_t value, uint16_t mask)\n{\n    if (!mask) {\n        ds_put_char(s, '*');\n    } else {\n        if (value > 9) {\n            ds_put_format(s, \"0x%\"PRIx16, value);\n        } else {\n            ds_put_format(s, \"%\"PRIu16, value);\n        }\n\n        if (mask != UINT16_MAX) {\n            ds_put_format(s, \"/0x%\"PRIx16, mask);\n        }\n    }\n}\n\nvoid\nformat_packet_type_masked(struct ds *s, ovs_be32 value, ovs_be32 mask)\n{\n    if (value == htonl(PT_ETH) && mask == OVS_BE32_MAX) {\n        ds_put_cstr(s, \"eth\");\n    } else {\n        ds_put_cstr(s, \"packet_type=(\");\n        put_u16_masked(s, pt_ns(value), pt_ns(mask));\n        ds_put_char(s, ',');\n        put_u16_masked(s, pt_ns_type(value), pt_ns_type(mask));\n        ds_put_char(s, ')');\n    }\n}\n\n/* Scans a string 's' of flags to determine their numerical value and\n * returns the number of characters parsed using 'bit_to_string' to\n * lookup flag names. Scanning continues until the character 'end' is\n * reached.\n *\n * In the event of a failure, a negative error code will be returned. In\n * addition, if 'res_string' is non-NULL then a descriptive string will\n * be returned incorporating the identifying string 'field_name'. This\n * error string must be freed by the caller.\n *\n * Upon success, the flag values will be stored in 'res_flags' and\n * optionally 'res_mask', if it is non-NULL (if it is NULL then any masks\n * present in the original string will be considered an error). The\n * caller may restrict the acceptable set of values through the mask\n * 'allowed'. */\nint\nparse_flags(const char *s, const char *(*bit_to_string)(uint32_t),\n            char end, const char *field_name, char **res_string,\n            uint32_t *res_flags, uint32_t allowed, uint32_t *res_mask)\n{\n    uint32_t result = 0;\n    int n;\n\n    /* Parse masked flags in numeric format? */\n    if (res_mask && ovs_scan(s, \"%\"SCNi32\"/%\"SCNi32\"%n\",\n                             res_flags, res_mask, &n) && n > 0) {\n        if (*res_flags & ~allowed || *res_mask & ~allowed) {\n            goto unknown;\n        }\n        return n;\n    }\n\n    n = 0;\n\n    if (res_mask && (*s == '+' || *s == '-')) {\n        uint32_t flags = 0, mask = 0;\n\n        /* Parse masked flags. */\n        while (s[0] != end) {\n            bool set;\n            uint32_t bit;\n            size_t len;\n\n            if (s[0] == '+') {\n                set = true;\n            } else if (s[0] == '-') {\n                set = false;\n            } else {\n                if (res_string) {\n                    *res_string = xasprintf(\"%s: %s must be preceded by '+' \"\n                                            \"(for SET) or '-' (NOT SET)\", s,\n                                            field_name);\n                }\n                return -EINVAL;\n            }\n            s++;\n            n++;\n\n            for (bit = 1; bit; bit <<= 1) {\n                const char *fname = bit_to_string(bit);\n\n                if (!fname) {\n                    continue;\n                }\n\n                len = strlen(fname);\n                if (strncmp(s, fname, len) ||\n                    (s[len] != '+' && s[len] != '-' && s[len] != end)) {\n                    continue;\n                }\n\n                if (mask & bit) {\n                    /* bit already set. */\n                    if (res_string) {\n                        *res_string = xasprintf(\"%s: Each %s flag can be \"\n                                                \"specified only once\", s,\n                                                field_name);\n                    }\n                    return -EINVAL;\n                }\n                if (!(bit & allowed)) {\n                    goto unknown;\n                }\n                if (set) {\n                   flags |= bit;\n                }\n                mask |= bit;\n                break;\n            }\n\n            if (!bit) {\n                goto unknown;\n            }\n            s += len;\n            n += len;\n        }\n\n        *res_flags = flags;\n        *res_mask = mask;\n        return n;\n    }\n\n    /* Parse unmasked flags.  If a flag is present, it is set, otherwise\n     * it is not set. */\n    while (s[n] != end) {\n        unsigned long long int flags;\n        uint32_t bit;\n        int n0;\n\n        if (ovs_scan(&s[n], \"%lli%n\", &flags, &n0)) {\n            if (flags & ~allowed) {\n                goto unknown;\n            }\n            n += n0 + (s[n + n0] == '|');\n            result |= flags;\n            continue;\n        }\n\n        for (bit = 1; bit; bit <<= 1) {\n            const char *name = bit_to_string(bit);\n            size_t len;\n\n            if (!name) {\n                continue;\n            }\n\n            len = strlen(name);\n            if (!strncmp(s + n, name, len) &&\n                (s[n + len] == '|' || s[n + len] == end)) {\n                if (!(bit & allowed)) {\n                    goto unknown;\n                }\n                result |= bit;\n                n += len + (s[n + len] == '|');\n                break;\n            }\n        }\n\n        if (!bit) {\n            goto unknown;\n        }\n    }\n\n    *res_flags = result;\n    if (res_mask) {\n        *res_mask = UINT32_MAX;\n    }\n    if (res_string) {\n        *res_string = NULL;\n    }\n    return n;\n\nunknown:\n    if (res_string) {\n        *res_string = xasprintf(\"%s: unknown %s flag(s)\", s, field_name);\n    }\n    return -EINVAL;\n}\n\nvoid\nflow_format(struct ds *ds,\n            const struct flow *flow, const struct ofputil_port_map *port_map)\n{\n    struct match match;\n    struct flow_wildcards *wc = &match.wc;\n\n    match_wc_init(&match, flow);\n\n    /* As this function is most often used for formatting a packet in a\n     * packet-in message, skip formatting the packet context fields that are\n     * all-zeroes to make the print-out easier on the eyes.  This means that a\n     * missing context field implies a zero value for that field.  This is\n     * similar to OpenFlow encoding of these fields, as the specification\n     * states that all-zeroes context fields should not be encoded in the\n     * packet-in messages. */\n    if (!flow->in_port.ofp_port) {\n        WC_UNMASK_FIELD(wc, in_port);\n    }\n    if (!flow->skb_priority) {\n        WC_UNMASK_FIELD(wc, skb_priority);\n    }\n    if (!flow->pkt_mark) {\n        WC_UNMASK_FIELD(wc, pkt_mark);\n    }\n    if (!flow->recirc_id) {\n        WC_UNMASK_FIELD(wc, recirc_id);\n    }\n    if (!flow->dp_hash) {\n        WC_UNMASK_FIELD(wc, dp_hash);\n    }\n    if (!flow->ct_state) {\n        WC_UNMASK_FIELD(wc, ct_state);\n    }\n    if (!flow->ct_zone) {\n        WC_UNMASK_FIELD(wc, ct_zone);\n    }\n    if (!flow->ct_mark) {\n        WC_UNMASK_FIELD(wc, ct_mark);\n    }\n    if (ovs_u128_is_zero(flow->ct_label)) {\n        WC_UNMASK_FIELD(wc, ct_label);\n    }\n    if (!is_ct_valid(flow, &match.wc, NULL) || !flow->ct_nw_proto) {\n        WC_UNMASK_FIELD(wc, ct_nw_proto);\n        WC_UNMASK_FIELD(wc, ct_tp_src);\n        WC_UNMASK_FIELD(wc, ct_tp_dst);\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            WC_UNMASK_FIELD(wc, ct_nw_src);\n            WC_UNMASK_FIELD(wc, ct_nw_dst);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            WC_UNMASK_FIELD(wc, ct_ipv6_src);\n            WC_UNMASK_FIELD(wc, ct_ipv6_dst);\n        }\n    }\n    for (int i = 0; i < FLOW_N_REGS; i++) {\n        if (!flow->regs[i]) {\n            WC_UNMASK_FIELD(wc, regs[i]);\n        }\n    }\n    if (!flow->metadata) {\n        WC_UNMASK_FIELD(wc, metadata);\n    }\n\n    match_format(&match, port_map, ds, OFP_DEFAULT_PRIORITY);\n}\n\nvoid\nflow_print(FILE *stream,\n           const struct flow *flow, const struct ofputil_port_map *port_map)\n{\n    char *s = flow_to_string(flow, port_map);\n    fputs(s, stream);\n    free(s);\n}\n\f\n/* flow_wildcards functions. */\n\n/* Initializes 'wc' as a set of wildcards that matches every packet. */\nvoid\nflow_wildcards_init_catchall(struct flow_wildcards *wc)\n{\n    memset(&wc->masks, 0, sizeof wc->masks);\n}\n\n/* Converts a flow into flow wildcards.  It sets the wildcard masks based on\n * the packet headers extracted to 'flow'.  It will not set the mask for fields\n * that do not make sense for the packet type.  OpenFlow-only metadata is\n * wildcarded, but other metadata is unconditionally exact-matched. */\nvoid\nflow_wildcards_init_for_packet(struct flow_wildcards *wc,\n                               const struct flow *flow)\n{\n    ovs_be16 dl_type = OVS_BE16_MAX;\n\n    memset(&wc->masks, 0x0, sizeof wc->masks);\n\n    /* Update this function whenever struct flow changes. */\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n\n    if (flow_tnl_dst_is_set(&flow->tunnel)) {\n        if (flow->tunnel.flags & FLOW_TNL_F_KEY) {\n            WC_MASK_FIELD(wc, tunnel.tun_id);\n        }\n        WC_MASK_FIELD(wc, tunnel.ip_src);\n        WC_MASK_FIELD(wc, tunnel.ip_dst);\n        WC_MASK_FIELD(wc, tunnel.ipv6_src);\n        WC_MASK_FIELD(wc, tunnel.ipv6_dst);\n        WC_MASK_FIELD(wc, tunnel.flags);\n        WC_MASK_FIELD(wc, tunnel.ip_tos);\n        WC_MASK_FIELD(wc, tunnel.ip_ttl);\n        WC_MASK_FIELD(wc, tunnel.tp_src);\n        WC_MASK_FIELD(wc, tunnel.tp_dst);\n        WC_MASK_FIELD(wc, tunnel.gbp_id);\n        WC_MASK_FIELD(wc, tunnel.gbp_flags);\n        WC_MASK_FIELD(wc, tunnel.erspan_ver);\n        WC_MASK_FIELD(wc, tunnel.erspan_idx);\n        WC_MASK_FIELD(wc, tunnel.erspan_dir);\n        WC_MASK_FIELD(wc, tunnel.erspan_hwid);\n\n        if (!(flow->tunnel.flags & FLOW_TNL_F_UDPIF)) {\n            if (flow->tunnel.metadata.present.map) {\n                wc->masks.tunnel.metadata.present.map =\n                                              flow->tunnel.metadata.present.map;\n                WC_MASK_FIELD(wc, tunnel.metadata.opts.u8);\n                WC_MASK_FIELD(wc, tunnel.metadata.tab);\n            }\n        } else {\n            WC_MASK_FIELD(wc, tunnel.metadata.present.len);\n            memset(wc->masks.tunnel.metadata.opts.gnv, 0xff,\n                   flow->tunnel.metadata.present.len);\n        }\n    } else if (flow->tunnel.tun_id) {\n        WC_MASK_FIELD(wc, tunnel.tun_id);\n    }\n\n    /* metadata, regs, and conj_id wildcarded. */\n\n    WC_MASK_FIELD(wc, skb_priority);\n    WC_MASK_FIELD(wc, pkt_mark);\n    WC_MASK_FIELD(wc, ct_state);\n    WC_MASK_FIELD(wc, ct_zone);\n    WC_MASK_FIELD(wc, ct_mark);\n    WC_MASK_FIELD(wc, ct_label);\n    WC_MASK_FIELD(wc, recirc_id);\n    WC_MASK_FIELD(wc, dp_hash);\n    WC_MASK_FIELD(wc, in_port);\n\n    /* actset_output wildcarded. */\n\n    WC_MASK_FIELD(wc, packet_type);\n    if (flow->packet_type == htonl(PT_ETH)) {\n        WC_MASK_FIELD(wc, dl_dst);\n        WC_MASK_FIELD(wc, dl_src);\n        WC_MASK_FIELD(wc, dl_type);\n        /* No need to set mask of inner VLANs that don't exist. */\n        for (int i = 0; i < FLOW_MAX_VLAN_HEADERS; i++) {\n            /* Always show the first zero VLAN. */\n            WC_MASK_FIELD(wc, vlans[i]);\n            if (flow->vlans[i].tci == htons(0)) {\n                break;\n            }\n        }\n        dl_type = flow->dl_type;\n    } else {\n        dl_type = pt_ns_type_be(flow->packet_type);\n    }\n\n    if (dl_type == htons(ETH_TYPE_IP)) {\n        WC_MASK_FIELD(wc, nw_src);\n        WC_MASK_FIELD(wc, nw_dst);\n        WC_MASK_FIELD(wc, ct_nw_src);\n        WC_MASK_FIELD(wc, ct_nw_dst);\n    } else if (dl_type == htons(ETH_TYPE_IPV6)) {\n        WC_MASK_FIELD(wc, ipv6_src);\n        WC_MASK_FIELD(wc, ipv6_dst);\n        WC_MASK_FIELD(wc, ipv6_label);\n        if (is_nd(flow, wc)) {\n            WC_MASK_FIELD(wc, arp_sha);\n            WC_MASK_FIELD(wc, arp_tha);\n            WC_MASK_FIELD(wc, nd_target);\n        } else {\n            WC_MASK_FIELD(wc, ct_ipv6_src);\n            WC_MASK_FIELD(wc, ct_ipv6_dst);\n        }\n    } else if (dl_type == htons(ETH_TYPE_ARP) ||\n               dl_type == htons(ETH_TYPE_RARP)) {\n        WC_MASK_FIELD(wc, nw_src);\n        WC_MASK_FIELD(wc, nw_dst);\n        WC_MASK_FIELD(wc, nw_proto);\n        WC_MASK_FIELD(wc, arp_sha);\n        WC_MASK_FIELD(wc, arp_tha);\n        return;\n    } else if (eth_type_mpls(dl_type)) {\n        for (int i = 0; i < FLOW_MAX_MPLS_LABELS; i++) {\n            WC_MASK_FIELD(wc, mpls_lse[i]);\n            if (flow->mpls_lse[i] & htonl(MPLS_BOS_MASK)) {\n                break;\n            }\n        }\n        return;\n    } else if (flow->dl_type == htons(ETH_TYPE_NSH)) {\n        WC_MASK_FIELD(wc, nsh.flags);\n        WC_MASK_FIELD(wc, nsh.ttl);\n        WC_MASK_FIELD(wc, nsh.mdtype);\n        WC_MASK_FIELD(wc, nsh.np);\n        WC_MASK_FIELD(wc, nsh.path_hdr);\n        WC_MASK_FIELD(wc, nsh.context);\n    } else {\n        return; /* Unknown ethertype. */\n    }\n\n    /* IPv4 or IPv6. */\n    WC_MASK_FIELD(wc, nw_frag);\n    WC_MASK_FIELD(wc, nw_tos);\n    WC_MASK_FIELD(wc, nw_ttl);\n    WC_MASK_FIELD(wc, nw_proto);\n    WC_MASK_FIELD(wc, ct_nw_proto);\n    WC_MASK_FIELD(wc, ct_tp_src);\n    WC_MASK_FIELD(wc, ct_tp_dst);\n\n    /* No transport layer header in later fragments. */\n    if (!(flow->nw_frag & FLOW_NW_FRAG_LATER) &&\n        (flow->nw_proto == IPPROTO_ICMP ||\n         flow->nw_proto == IPPROTO_ICMPV6 ||\n         flow->nw_proto == IPPROTO_TCP ||\n         flow->nw_proto == IPPROTO_UDP ||\n         flow->nw_proto == IPPROTO_SCTP ||\n         flow->nw_proto == IPPROTO_IGMP)) {\n        WC_MASK_FIELD(wc, tp_src);\n        WC_MASK_FIELD(wc, tp_dst);\n\n        if (flow->nw_proto == IPPROTO_TCP) {\n            WC_MASK_FIELD(wc, tcp_flags);\n        } else if (flow->nw_proto == IPPROTO_IGMP) {\n            WC_MASK_FIELD(wc, igmp_group_ip4);\n        }\n    }\n}\n\n/* Return a map of possible fields for a packet of the same type as 'flow'.\n * Including extra bits in the returned mask is not wrong, it is just less\n * optimal.\n *\n * This is a less precise version of flow_wildcards_init_for_packet() above. */\nvoid\nflow_wc_map(const struct flow *flow, struct flowmap *map)\n{\n    /* Update this function whenever struct flow changes. */\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n\n    flowmap_init(map);\n\n    if (flow_tnl_dst_is_set(&flow->tunnel)) {\n        FLOWMAP_SET__(map, tunnel, offsetof(struct flow_tnl, metadata));\n        if (!(flow->tunnel.flags & FLOW_TNL_F_UDPIF)) {\n            if (flow->tunnel.metadata.present.map) {\n                FLOWMAP_SET(map, tunnel.metadata);\n            }\n        } else {\n            FLOWMAP_SET(map, tunnel.metadata.present.len);\n            FLOWMAP_SET__(map, tunnel.metadata.opts.gnv,\n                          flow->tunnel.metadata.present.len);\n        }\n    }\n\n    /* Metadata fields that can appear on packet input. */\n    FLOWMAP_SET(map, skb_priority);\n    FLOWMAP_SET(map, pkt_mark);\n    FLOWMAP_SET(map, recirc_id);\n    FLOWMAP_SET(map, dp_hash);\n    FLOWMAP_SET(map, in_port);\n    FLOWMAP_SET(map, dl_dst);\n    FLOWMAP_SET(map, dl_src);\n    FLOWMAP_SET(map, dl_type);\n    FLOWMAP_SET(map, vlans);\n    FLOWMAP_SET(map, ct_state);\n    FLOWMAP_SET(map, ct_zone);\n    FLOWMAP_SET(map, ct_mark);\n    FLOWMAP_SET(map, ct_label);\n    FLOWMAP_SET(map, packet_type);\n\n    /* Ethertype-dependent fields. */\n    if (OVS_LIKELY(flow->dl_type == htons(ETH_TYPE_IP))) {\n        FLOWMAP_SET(map, nw_src);\n        FLOWMAP_SET(map, nw_dst);\n        FLOWMAP_SET(map, nw_proto);\n        FLOWMAP_SET(map, nw_frag);\n        FLOWMAP_SET(map, nw_tos);\n        FLOWMAP_SET(map, nw_ttl);\n        FLOWMAP_SET(map, tp_src);\n        FLOWMAP_SET(map, tp_dst);\n        FLOWMAP_SET(map, ct_nw_proto);\n        FLOWMAP_SET(map, ct_nw_src);\n        FLOWMAP_SET(map, ct_nw_dst);\n        FLOWMAP_SET(map, ct_tp_src);\n        FLOWMAP_SET(map, ct_tp_dst);\n\n        if (OVS_UNLIKELY(flow->nw_proto == IPPROTO_IGMP)) {\n            FLOWMAP_SET(map, igmp_group_ip4);\n        } else {\n            FLOWMAP_SET(map, tcp_flags);\n        }\n    } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n        FLOWMAP_SET(map, ipv6_src);\n        FLOWMAP_SET(map, ipv6_dst);\n        FLOWMAP_SET(map, ipv6_label);\n        FLOWMAP_SET(map, nw_proto);\n        FLOWMAP_SET(map, nw_frag);\n        FLOWMAP_SET(map, nw_tos);\n        FLOWMAP_SET(map, nw_ttl);\n        FLOWMAP_SET(map, tp_src);\n        FLOWMAP_SET(map, tp_dst);\n\n        if (OVS_UNLIKELY(is_nd(flow, NULL))) {\n            FLOWMAP_SET(map, nd_target);\n            FLOWMAP_SET(map, arp_sha);\n            FLOWMAP_SET(map, arp_tha);\n            FLOWMAP_SET(map, tcp_flags);\n            FLOWMAP_SET(map, igmp_group_ip4);\n        } else {\n            FLOWMAP_SET(map, ct_nw_proto);\n            FLOWMAP_SET(map, ct_ipv6_src);\n            FLOWMAP_SET(map, ct_ipv6_dst);\n            FLOWMAP_SET(map, ct_tp_src);\n            FLOWMAP_SET(map, ct_tp_dst);\n            FLOWMAP_SET(map, tcp_flags);\n        }\n    } else if (eth_type_mpls(flow->dl_type)) {\n        FLOWMAP_SET(map, mpls_lse);\n    } else if (flow->dl_type == htons(ETH_TYPE_ARP) ||\n               flow->dl_type == htons(ETH_TYPE_RARP)) {\n        FLOWMAP_SET(map, nw_src);\n        FLOWMAP_SET(map, nw_dst);\n        FLOWMAP_SET(map, nw_proto);\n        FLOWMAP_SET(map, arp_sha);\n        FLOWMAP_SET(map, arp_tha);\n    } else if (flow->dl_type == htons(ETH_TYPE_NSH)) {\n        FLOWMAP_SET(map, nsh.flags);\n        FLOWMAP_SET(map, nsh.mdtype);\n        FLOWMAP_SET(map, nsh.np);\n        FLOWMAP_SET(map, nsh.path_hdr);\n        FLOWMAP_SET(map, nsh.context);\n    }\n}\n\n/* Clear the metadata and register wildcard masks. They are not packet\n * header fields. */\nvoid\nflow_wildcards_clear_non_packet_fields(struct flow_wildcards *wc)\n{\n    /* Update this function whenever struct flow changes. */\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n\n    memset(&wc->masks.metadata, 0, sizeof wc->masks.metadata);\n    memset(&wc->masks.regs, 0, sizeof wc->masks.regs);\n    wc->masks.actset_output = 0;\n    wc->masks.conj_id = 0;\n}\n\n/* Returns true if 'wc' matches every packet, false if 'wc' fixes any bits or\n * fields. */\nbool\nflow_wildcards_is_catchall(const struct flow_wildcards *wc)\n{\n    const uint64_t *wc_u64 = (const uint64_t *) &wc->masks;\n    size_t i;\n\n    for (i = 0; i < FLOW_U64S; i++) {\n        if (wc_u64[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/* Sets 'dst' as the bitwise AND of wildcards in 'src1' and 'src2'.\n * That is, a bit or a field is wildcarded in 'dst' if it is wildcarded\n * in 'src1' or 'src2' or both.  */\nvoid\nflow_wildcards_and(struct flow_wildcards *dst,\n                   const struct flow_wildcards *src1,\n                   const struct flow_wildcards *src2)\n{\n    uint64_t *dst_u64 = (uint64_t *) &dst->masks;\n    const uint64_t *src1_u64 = (const uint64_t *) &src1->masks;\n    const uint64_t *src2_u64 = (const uint64_t *) &src2->masks;\n    size_t i;\n\n    for (i = 0; i < FLOW_U64S; i++) {\n        dst_u64[i] = src1_u64[i] & src2_u64[i];\n    }\n}\n\n/* Sets 'dst' as the bitwise OR of wildcards in 'src1' and 'src2'.  That\n * is, a bit or a field is wildcarded in 'dst' if it is neither\n * wildcarded in 'src1' nor 'src2'. */\nvoid\nflow_wildcards_or(struct flow_wildcards *dst,\n                  const struct flow_wildcards *src1,\n                  const struct flow_wildcards *src2)\n{\n    uint64_t *dst_u64 = (uint64_t *) &dst->masks;\n    const uint64_t *src1_u64 = (const uint64_t *) &src1->masks;\n    const uint64_t *src2_u64 = (const uint64_t *) &src2->masks;\n    size_t i;\n\n    for (i = 0; i < FLOW_U64S; i++) {\n        dst_u64[i] = src1_u64[i] | src2_u64[i];\n    }\n}\n\n/* Returns a hash of the wildcards in 'wc'. */\nuint32_t\nflow_wildcards_hash(const struct flow_wildcards *wc, uint32_t basis)\n{\n    return flow_hash(&wc->masks, basis);\n}\n\n/* Returns true if 'a' and 'b' represent the same wildcards, false if they are\n * different. */\nbool\nflow_wildcards_equal(const struct flow_wildcards *a,\n                     const struct flow_wildcards *b)\n{\n    return flow_equal(&a->masks, &b->masks);\n}\n\n/* Returns true if at least one bit or field is wildcarded in 'a' but not in\n * 'b', false otherwise. */\nbool\nflow_wildcards_has_extra(const struct flow_wildcards *a,\n                         const struct flow_wildcards *b)\n{\n    const uint64_t *a_u64 = (const uint64_t *) &a->masks;\n    const uint64_t *b_u64 = (const uint64_t *) &b->masks;\n    size_t i;\n\n    for (i = 0; i < FLOW_U64S; i++) {\n        if ((a_u64[i] & b_u64[i]) != b_u64[i]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/* Returns true if 'a' and 'b' are equal, except that 0-bits (wildcarded bits)\n * in 'wc' do not need to be equal in 'a' and 'b'. */\nbool\nflow_equal_except(const struct flow *a, const struct flow *b,\n                  const struct flow_wildcards *wc)\n{\n    const uint64_t *a_u64 = (const uint64_t *) a;\n    const uint64_t *b_u64 = (const uint64_t *) b;\n    const uint64_t *wc_u64 = (const uint64_t *) &wc->masks;\n    size_t i;\n\n    for (i = 0; i < FLOW_U64S; i++) {\n        if ((a_u64[i] ^ b_u64[i]) & wc_u64[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/* Sets the wildcard mask for register 'idx' in 'wc' to 'mask'.\n * (A 0-bit indicates a wildcard bit.) */\nvoid\nflow_wildcards_set_reg_mask(struct flow_wildcards *wc, int idx, uint32_t mask)\n{\n    wc->masks.regs[idx] = mask;\n}\n\n/* Sets the wildcard mask for register 'idx' in 'wc' to 'mask'.\n * (A 0-bit indicates a wildcard bit.) */\nvoid\nflow_wildcards_set_xreg_mask(struct flow_wildcards *wc, int idx, uint64_t mask)\n{\n    flow_set_xreg(&wc->masks, idx, mask);\n}\n\n/* Sets the wildcard mask for register 'idx' in 'wc' to 'mask'.\n * (A 0-bit indicates a wildcard bit.) */\nvoid\nflow_wildcards_set_xxreg_mask(struct flow_wildcards *wc, int idx,\n                              ovs_u128 mask)\n{\n    flow_set_xxreg(&wc->masks, idx, mask);\n}\n\n/* Calculates the 5-tuple hash from the given miniflow.\n * This returns the same value as flow_hash_5tuple for the corresponding\n * flow. */\nuint32_t\nminiflow_hash_5tuple(const struct miniflow *flow, uint32_t basis)\n{\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n    uint32_t hash = basis;\n\n    if (flow) {\n        ovs_be16 dl_type = MINIFLOW_GET_BE16(flow, dl_type);\n        uint8_t nw_proto;\n\n        if (dl_type == htons(ETH_TYPE_IPV6)) {\n            struct flowmap map = FLOWMAP_EMPTY_INITIALIZER;\n            uint64_t value;\n\n            FLOWMAP_SET(&map, ipv6_src);\n            FLOWMAP_SET(&map, ipv6_dst);\n\n            MINIFLOW_FOR_EACH_IN_FLOWMAP(value, flow, map) {\n                hash = hash_add64(hash, value);\n            }\n        } else if (dl_type == htons(ETH_TYPE_IP)\n                   || dl_type == htons(ETH_TYPE_ARP)) {\n            hash = hash_add(hash, MINIFLOW_GET_U32(flow, nw_src));\n            hash = hash_add(hash, MINIFLOW_GET_U32(flow, nw_dst));\n        } else {\n            goto out;\n        }\n\n        nw_proto = MINIFLOW_GET_U8(flow, nw_proto);\n        hash = hash_add(hash, nw_proto);\n        if (nw_proto != IPPROTO_TCP && nw_proto != IPPROTO_UDP\n            && nw_proto != IPPROTO_SCTP && nw_proto != IPPROTO_ICMP\n            && nw_proto != IPPROTO_ICMPV6) {\n            goto out;\n        }\n\n        /* Add both ports at once. */\n        hash = hash_add(hash, (OVS_FORCE uint32_t) miniflow_get_ports(flow));\n    }\nout:\n    return hash_finish(hash, 42);\n}\n\nASSERT_SEQUENTIAL_SAME_WORD(tp_src, tp_dst);\nASSERT_SEQUENTIAL(ipv6_src, ipv6_dst);\n\n/* Calculates the 5-tuple hash from the given flow. */\nuint32_t\nflow_hash_5tuple(const struct flow *flow, uint32_t basis)\n{\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n    uint32_t hash = basis;\n\n    if (flow) {\n\n        if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            const uint64_t *flow_u64 = (const uint64_t *)flow;\n            int ofs = offsetof(struct flow, ipv6_src) / 8;\n            int end = ofs + 2 * sizeof flow->ipv6_src / 8;\n\n            for (;ofs < end; ofs++) {\n                hash = hash_add64(hash, flow_u64[ofs]);\n            }\n        } else if (flow->dl_type == htons(ETH_TYPE_IP)\n                   || flow->dl_type == htons(ETH_TYPE_ARP)) {\n            hash = hash_add(hash, (OVS_FORCE uint32_t) flow->nw_src);\n            hash = hash_add(hash, (OVS_FORCE uint32_t) flow->nw_dst);\n        } else {\n            goto out;\n        }\n\n        hash = hash_add(hash, flow->nw_proto);\n        if (flow->nw_proto != IPPROTO_TCP && flow->nw_proto != IPPROTO_UDP\n            && flow->nw_proto != IPPROTO_SCTP && flow->nw_proto != IPPROTO_ICMP\n            && flow->nw_proto != IPPROTO_ICMPV6) {\n            goto out;\n        }\n\n        /* Add both ports at once. */\n        hash = hash_add(hash,\n                        ((const uint32_t *)flow)[offsetof(struct flow, tp_src)\n                                                 / sizeof(uint32_t)]);\n    }\nout:\n    return hash_finish(hash, 42); /* Arbitrary number. */\n}\n\n/* Hashes 'flow' based on its L2 through L4 protocol information. */\nuint32_t\nflow_hash_symmetric_l4(const struct flow *flow, uint32_t basis)\n{\n    struct {\n        union {\n            ovs_be32 ipv4_addr;\n            struct in6_addr ipv6_addr;\n        };\n        ovs_be16 eth_type;\n        ovs_be16 vlan_tci;\n        ovs_be16 tp_port;\n        struct eth_addr eth_addr;\n        uint8_t ip_proto;\n    } fields;\n\n    int i;\n\n    memset(&fields, 0, sizeof fields);\n    for (i = 0; i < ARRAY_SIZE(fields.eth_addr.be16); i++) {\n        fields.eth_addr.be16[i] = flow->dl_src.be16[i] ^ flow->dl_dst.be16[i];\n    }\n    for (i = 0; i < FLOW_MAX_VLAN_HEADERS; i++) {\n        fields.vlan_tci ^= flow->vlans[i].tci & htons(VLAN_VID_MASK);\n    }\n    fields.eth_type = flow->dl_type;\n\n    /* UDP source and destination port are not taken into account because they\n     * will not necessarily be symmetric in a bidirectional flow. */\n    if (fields.eth_type == htons(ETH_TYPE_IP)) {\n        fields.ipv4_addr = flow->nw_src ^ flow->nw_dst;\n        fields.ip_proto = flow->nw_proto;\n        if (fields.ip_proto == IPPROTO_TCP || fields.ip_proto == IPPROTO_SCTP) {\n            fields.tp_port = flow->tp_src ^ flow->tp_dst;\n        }\n    } else if (fields.eth_type == htons(ETH_TYPE_IPV6)) {\n        const uint8_t *a = &flow->ipv6_src.s6_addr[0];\n        const uint8_t *b = &flow->ipv6_dst.s6_addr[0];\n        uint8_t *ipv6_addr = &fields.ipv6_addr.s6_addr[0];\n\n        for (i=0; i<16; i++) {\n            ipv6_addr[i] = a[i] ^ b[i];\n        }\n        fields.ip_proto = flow->nw_proto;\n        if (fields.ip_proto == IPPROTO_TCP || fields.ip_proto == IPPROTO_SCTP) {\n            fields.tp_port = flow->tp_src ^ flow->tp_dst;\n        }\n    }\n    return jhash_bytes(&fields, sizeof fields, basis);\n}\n\n/* Symmetrically Hashes non-IP 'flow' based on its L2 headers. */\nuint32_t\nflow_hash_symmetric_l2(const struct flow *flow, uint32_t basis)\n{\n    union {\n        struct {\n            ovs_be16 eth_type;\n            ovs_be16 vlan_tci;\n            struct eth_addr eth_addr;\n            ovs_be16 pad;\n        };\n        uint32_t word[3];\n    } fields;\n\n    uint32_t hash = basis;\n    int i;\n\n    if (flow->packet_type != htonl(PT_ETH)) {\n        /* Cannot hash non-Ethernet flows */\n        return 0;\n    }\n\n    for (i = 0; i < ARRAY_SIZE(fields.eth_addr.be16); i++) {\n        fields.eth_addr.be16[i] =\n                flow->dl_src.be16[i] ^ flow->dl_dst.be16[i];\n    }\n    fields.vlan_tci = 0;\n    for (i = 0; i < FLOW_MAX_VLAN_HEADERS; i++) {\n        fields.vlan_tci ^= flow->vlans[i].tci & htons(VLAN_VID_MASK);\n    }\n    fields.eth_type = flow->dl_type;\n    fields.pad = 0;\n\n    hash = hash_add(hash, fields.word[0]);\n    hash = hash_add(hash, fields.word[1]);\n    hash = hash_add(hash, fields.word[2]);\n    return hash_finish(hash, basis);\n}\n\n/* Hashes 'flow' based on its L3 through L4 protocol information */\nuint32_t\nflow_hash_symmetric_l3l4(const struct flow *flow, uint32_t basis,\n                         bool inc_udp_ports)\n{\n    uint32_t hash = basis;\n\n    /* UDP source and destination port are also taken into account. */\n    if (flow->dl_type == htons(ETH_TYPE_IP)) {\n        hash = hash_add(hash,\n                        (OVS_FORCE uint32_t) (flow->nw_src ^ flow->nw_dst));\n    } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n        /* IPv6 addresses are 64-bit aligned inside struct flow. */\n        const uint64_t *a = ALIGNED_CAST(uint64_t *, flow->ipv6_src.s6_addr);\n        const uint64_t *b = ALIGNED_CAST(uint64_t *, flow->ipv6_dst.s6_addr);\n\n        for (int i = 0; i < sizeof flow->ipv6_src / sizeof *a; i++) {\n            hash = hash_add64(hash, a[i] ^ b[i]);\n        }\n    } else {\n        /* Revert to hashing L2 headers */\n        return flow_hash_symmetric_l2(flow, basis);\n    }\n    hash = hash_add(hash, flow->nw_proto);\n    if (!(flow->nw_frag & FLOW_NW_FRAG_MASK)\n        && (flow->nw_proto == IPPROTO_TCP || flow->nw_proto == IPPROTO_SCTP ||\n            (inc_udp_ports && flow->nw_proto == IPPROTO_UDP))) {\n        hash = hash_add(hash,\n                        (OVS_FORCE uint16_t) (flow->tp_src ^ flow->tp_dst));\n    }\n\n    return hash_finish(hash, basis);\n}\n\n/* Hashes 'flow' based on its nw_dst and nw_src for multipath. */\nuint32_t\nflow_hash_symmetric_l3(const struct flow *flow, uint32_t basis)\n{\n    struct {\n        union {\n            ovs_be32 ipv4_addr;\n            struct in6_addr ipv6_addr;\n        };\n        ovs_be16 eth_type;\n    } fields;\n\n    int i;\n\n    memset(&fields, 0, sizeof fields);\n    fields.eth_type = flow->dl_type;\n\n    if (fields.eth_type == htons(ETH_TYPE_IP)) {\n        fields.ipv4_addr = flow->nw_src ^ flow->nw_dst;\n    } else if (fields.eth_type == htons(ETH_TYPE_IPV6)) {\n        const uint8_t *a = &flow->ipv6_src.s6_addr[0];\n        const uint8_t *b = &flow->ipv6_dst.s6_addr[0];\n        uint8_t *ipv6_addr = &fields.ipv6_addr.s6_addr[0];\n\n        for (i = 0; i < 16; i++) {\n            ipv6_addr[i] = a[i] ^ b[i];\n        }\n    }\n    return jhash_bytes(&fields, sizeof fields, basis);\n}\n\n/* Initialize a flow with random fields that matter for nx_hash_fields. */\nvoid\nflow_random_hash_fields(struct flow *flow)\n{\n    uint16_t rnd = random_uint16();\n    int i;\n\n    /* Initialize to all zeros. */\n    memset(flow, 0, sizeof *flow);\n\n    eth_addr_random(&flow->dl_src);\n    eth_addr_random(&flow->dl_dst);\n\n    for (i = 0; i < FLOW_MAX_VLAN_HEADERS; i++) {\n        uint16_t vlan = random_uint16() & VLAN_VID_MASK;\n        flow->vlans[i].tpid = htons(ETH_TYPE_VLAN_8021Q);\n        flow->vlans[i].tci = htons(vlan | VLAN_CFI);\n    }\n\n    /* Make most of the random flows IPv4, some IPv6, and rest random. */\n    flow->dl_type = rnd < 0x8000 ? htons(ETH_TYPE_IP) :\n        rnd < 0xc000 ? htons(ETH_TYPE_IPV6) : (OVS_FORCE ovs_be16)rnd;\n\n    if (dl_type_is_ip_any(flow->dl_type)) {\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            flow->nw_src = (OVS_FORCE ovs_be32)random_uint32();\n            flow->nw_dst = (OVS_FORCE ovs_be32)random_uint32();\n        } else {\n            random_bytes(&flow->ipv6_src, sizeof flow->ipv6_src);\n            random_bytes(&flow->ipv6_dst, sizeof flow->ipv6_dst);\n        }\n        /* Make most of IP flows TCP, some UDP or SCTP, and rest random. */\n        rnd = random_uint16();\n        flow->nw_proto = rnd < 0x8000 ? IPPROTO_TCP :\n            rnd < 0xc000 ? IPPROTO_UDP :\n            rnd < 0xd000 ? IPPROTO_SCTP : (uint8_t)rnd;\n        if (flow->nw_proto == IPPROTO_TCP ||\n            flow->nw_proto == IPPROTO_UDP ||\n            flow->nw_proto == IPPROTO_SCTP) {\n            flow->tp_src = (OVS_FORCE ovs_be16)random_uint16();\n            flow->tp_dst = (OVS_FORCE ovs_be16)random_uint16();\n        }\n    }\n}\n\n/* Masks the fields in 'wc' that are used by the flow hash 'fields'. */\nvoid\nflow_mask_hash_fields(const struct flow *flow, struct flow_wildcards *wc,\n                      enum nx_hash_fields fields)\n{\n    int i;\n    switch (fields) {\n    case NX_HASH_FIELDS_ETH_SRC:\n        memset(&wc->masks.dl_src, 0xff, sizeof wc->masks.dl_src);\n        break;\n\n    case NX_HASH_FIELDS_SYMMETRIC_L4:\n        memset(&wc->masks.dl_src, 0xff, sizeof wc->masks.dl_src);\n        memset(&wc->masks.dl_dst, 0xff, sizeof wc->masks.dl_dst);\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            memset(&wc->masks.nw_src, 0xff, sizeof wc->masks.nw_src);\n            memset(&wc->masks.nw_dst, 0xff, sizeof wc->masks.nw_dst);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            memset(&wc->masks.ipv6_src, 0xff, sizeof wc->masks.ipv6_src);\n            memset(&wc->masks.ipv6_dst, 0xff, sizeof wc->masks.ipv6_dst);\n        }\n        if (is_ip_any(flow)) {\n            memset(&wc->masks.nw_proto, 0xff, sizeof wc->masks.nw_proto);\n            /* Unwildcard port only for non-UDP packets as udp port\n             * numbers are not used in hash calculations.\n             */\n            if (flow->nw_proto != IPPROTO_UDP) {\n                flow_unwildcard_tp_ports(flow, wc);\n            }\n        }\n        for (i = 0; i < FLOW_MAX_VLAN_HEADERS; i++) {\n            wc->masks.vlans[i].tci |= htons(VLAN_VID_MASK | VLAN_CFI);\n        }\n        break;\n    case NX_HASH_FIELDS_SYMMETRIC_L3L4_UDP:\n        if (is_ip_any(flow) && flow->nw_proto == IPPROTO_UDP\n            && !(flow->nw_frag & FLOW_NW_FRAG_MASK)) {\n            memset(&wc->masks.tp_src, 0xff, sizeof wc->masks.tp_src);\n            memset(&wc->masks.tp_dst, 0xff, sizeof wc->masks.tp_dst);\n        }\n        /* fall through */\n    case NX_HASH_FIELDS_SYMMETRIC_L3L4:\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            memset(&wc->masks.nw_src, 0xff, sizeof wc->masks.nw_src);\n            memset(&wc->masks.nw_dst, 0xff, sizeof wc->masks.nw_dst);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            memset(&wc->masks.ipv6_src, 0xff, sizeof wc->masks.ipv6_src);\n            memset(&wc->masks.ipv6_dst, 0xff, sizeof wc->masks.ipv6_dst);\n        } else {\n            break; /* non-IP flow */\n        }\n        memset(&wc->masks.nw_proto, 0xff, sizeof wc->masks.nw_proto);\n        if ((flow->nw_proto == IPPROTO_TCP || flow->nw_proto == IPPROTO_SCTP)\n             && !(flow->nw_frag & FLOW_NW_FRAG_MASK)) {\n            memset(&wc->masks.tp_src, 0xff, sizeof wc->masks.tp_src);\n            memset(&wc->masks.tp_dst, 0xff, sizeof wc->masks.tp_dst);\n        }\n        break;\n\n    case NX_HASH_FIELDS_NW_SRC:\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            memset(&wc->masks.nw_src, 0xff, sizeof wc->masks.nw_src);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            memset(&wc->masks.ipv6_src, 0xff, sizeof wc->masks.ipv6_src);\n        }\n        break;\n\n    case NX_HASH_FIELDS_NW_DST:\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            memset(&wc->masks.nw_dst, 0xff, sizeof wc->masks.nw_dst);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            memset(&wc->masks.ipv6_dst, 0xff, sizeof wc->masks.ipv6_dst);\n        }\n        break;\n\n    case NX_HASH_FIELDS_SYMMETRIC_L3:\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            memset(&wc->masks.nw_src, 0xff, sizeof wc->masks.nw_src);\n            memset(&wc->masks.nw_dst, 0xff, sizeof wc->masks.nw_dst);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            memset(&wc->masks.ipv6_src, 0xff, sizeof wc->masks.ipv6_src);\n            memset(&wc->masks.ipv6_dst, 0xff, sizeof wc->masks.ipv6_dst);\n        }\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Hashes the portions of 'flow' designated by 'fields'. */\nuint32_t\nflow_hash_fields(const struct flow *flow, enum nx_hash_fields fields,\n                 uint16_t basis)\n{\n    switch (fields) {\n\n    case NX_HASH_FIELDS_ETH_SRC:\n        return jhash_bytes(&flow->dl_src, sizeof flow->dl_src, basis);\n\n    case NX_HASH_FIELDS_SYMMETRIC_L4:\n        return flow_hash_symmetric_l4(flow, basis);\n\n    case NX_HASH_FIELDS_SYMMETRIC_L3L4:\n        return flow_hash_symmetric_l3l4(flow, basis, false);\n\n    case NX_HASH_FIELDS_SYMMETRIC_L3L4_UDP:\n        return flow_hash_symmetric_l3l4(flow, basis, true);\n\n    case NX_HASH_FIELDS_NW_SRC:\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            return jhash_bytes(&flow->nw_src, sizeof flow->nw_src, basis);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            return jhash_bytes(&flow->ipv6_src, sizeof flow->ipv6_src, basis);\n        } else {\n            return basis;\n        }\n\n    case NX_HASH_FIELDS_NW_DST:\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            return jhash_bytes(&flow->nw_dst, sizeof flow->nw_dst, basis);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            return jhash_bytes(&flow->ipv6_dst, sizeof flow->ipv6_dst, basis);\n        } else {\n            return basis;\n        }\n\n    case NX_HASH_FIELDS_SYMMETRIC_L3:\n        return flow_hash_symmetric_l3(flow, basis);\n    }\n\n    OVS_NOT_REACHED();\n}\n\n/* Returns a string representation of 'fields'. */\nconst char *\nflow_hash_fields_to_str(enum nx_hash_fields fields)\n{\n    switch (fields) {\n    case NX_HASH_FIELDS_ETH_SRC: return \"eth_src\";\n    case NX_HASH_FIELDS_SYMMETRIC_L4: return \"symmetric_l4\";\n    case NX_HASH_FIELDS_SYMMETRIC_L3L4: return \"symmetric_l3l4\";\n    case NX_HASH_FIELDS_SYMMETRIC_L3L4_UDP: return \"symmetric_l3l4+udp\";\n    case NX_HASH_FIELDS_NW_SRC: return \"nw_src\";\n    case NX_HASH_FIELDS_NW_DST: return \"nw_dst\";\n    case NX_HASH_FIELDS_SYMMETRIC_L3: return \"symmetric_l3\";\n    default: return \"<unknown>\";\n    }\n}\n\n/* Returns true if the value of 'fields' is supported. Otherwise false. */\nbool\nflow_hash_fields_valid(enum nx_hash_fields fields)\n{\n    return fields == NX_HASH_FIELDS_ETH_SRC\n        || fields == NX_HASH_FIELDS_SYMMETRIC_L4\n        || fields == NX_HASH_FIELDS_SYMMETRIC_L3L4\n        || fields == NX_HASH_FIELDS_SYMMETRIC_L3L4_UDP\n        || fields == NX_HASH_FIELDS_NW_SRC\n        || fields == NX_HASH_FIELDS_NW_DST\n        || fields == NX_HASH_FIELDS_SYMMETRIC_L3;\n}\n\n/* Returns a hash value for the bits of 'flow' that are active based on\n * 'wc', given 'basis'. */\nuint32_t\nflow_hash_in_wildcards(const struct flow *flow,\n                       const struct flow_wildcards *wc, uint32_t basis)\n{\n    const uint64_t *wc_u64 = (const uint64_t *) &wc->masks;\n    const uint64_t *flow_u64 = (const uint64_t *) flow;\n    uint32_t hash;\n    size_t i;\n\n    hash = basis;\n    for (i = 0; i < FLOW_U64S; i++) {\n        hash = hash_add64(hash, flow_u64[i] & wc_u64[i]);\n    }\n    return hash_finish(hash, 8 * FLOW_U64S);\n}\n\n/* Sets the VLAN VID that 'flow' matches to 'vid', which is interpreted as an\n * OpenFlow 1.0 \"dl_vlan\" value:\n *\n *      - If it is in the range 0...4095, 'flow->vlans[0].tci' is set to match\n *        that VLAN.  Any existing PCP match is unchanged (it becomes 0 if\n *        'flow' previously matched packets without a VLAN header).\n *\n *      - If it is OFP_VLAN_NONE, 'flow->vlan_tci' is set to match a packet\n *        without a VLAN tag.\n *\n *      - Other values of 'vid' should not be used. */\nvoid\nflow_set_dl_vlan(struct flow *flow, ovs_be16 vid, int id)\n{\n    if (vid == htons(OFP10_VLAN_NONE)) {\n        flow->vlans[id].tci = htons(0);\n    } else {\n        vid &= htons(VLAN_VID_MASK);\n        flow->vlans[id].tci &= ~htons(VLAN_VID_MASK);\n        flow->vlans[id].tci |= htons(VLAN_CFI) | vid;\n    }\n}\n\n/* Sets the VLAN header TPID, which must be either ETH_TYPE_VLAN_8021Q or\n * ETH_TYPE_VLAN_8021AD. */\nvoid\nflow_fix_vlan_tpid(struct flow *flow)\n{\n    if (flow->vlans[0].tpid == htons(0) && flow->vlans[0].tci != 0) {\n        flow->vlans[0].tpid = htons(ETH_TYPE_VLAN_8021Q);\n    }\n}\n\n/* Sets the VLAN VID that 'flow' matches to 'vid', which is interpreted as an\n * OpenFlow 1.2 \"vlan_vid\" value, that is, the low 13 bits of 'vlan_tci' (VID\n * plus CFI). */\nvoid\nflow_set_vlan_vid(struct flow *flow, ovs_be16 vid)\n{\n    ovs_be16 mask = htons(VLAN_VID_MASK | VLAN_CFI);\n    flow->vlans[0].tci &= ~mask;\n    flow->vlans[0].tci |= vid & mask;\n}\n\n/* Sets the VLAN PCP that 'flow' matches to 'pcp', which should be in the\n * range 0...7.\n *\n * This function has no effect on the VLAN ID that 'flow' matches.\n *\n * After calling this function, 'flow' will not match packets without a VLAN\n * header. */\nvoid\nflow_set_vlan_pcp(struct flow *flow, uint8_t pcp, int id)\n{\n    pcp &= 0x07;\n    flow->vlans[id].tci &= ~htons(VLAN_PCP_MASK);\n    flow->vlans[id].tci |= htons((pcp << VLAN_PCP_SHIFT) | VLAN_CFI);\n}\n\n/* Counts the number of VLAN headers. */\nint\nflow_count_vlan_headers(const struct flow *flow)\n{\n    int i;\n\n    for (i = 0; i < FLOW_MAX_VLAN_HEADERS; i++) {\n        if (!(flow->vlans[i].tci & htons(VLAN_CFI))) {\n            break;\n        }\n    }\n    return i;\n}\n\n/* Given '*p_an' and '*p_bn' pointing to one past the last VLAN header of\n * 'a' and 'b' respectively, skip common VLANs so that they point to the\n * first different VLAN counting from bottom. */\nvoid\nflow_skip_common_vlan_headers(const struct flow *a, int *p_an,\n                              const struct flow *b, int *p_bn)\n{\n    int an = *p_an, bn = *p_bn;\n\n    for (an--, bn--; an >= 0 && bn >= 0; an--, bn--) {\n        if (a->vlans[an].qtag != b->vlans[bn].qtag) {\n            break;\n        }\n    }\n    *p_an = an;\n    *p_bn = bn;\n}\n\nvoid\nflow_pop_vlan(struct flow *flow, struct flow_wildcards *wc)\n{\n    int n = flow_count_vlan_headers(flow);\n    if (n > 1) {\n        if (wc) {\n            memset(&wc->masks.vlans[1], 0xff,\n                   sizeof(union flow_vlan_hdr) * (n - 1));\n        }\n        memmove(&flow->vlans[0], &flow->vlans[1],\n                sizeof(union flow_vlan_hdr) * (n - 1));\n    }\n    if (n > 0) {\n        memset(&flow->vlans[n - 1], 0, sizeof(union flow_vlan_hdr));\n    }\n}\n\nvoid\nflow_push_vlan_uninit(struct flow *flow, struct flow_wildcards *wc)\n{\n    if (wc) {\n        int n = flow_count_vlan_headers(flow);\n        if (n) {\n            memset(wc->masks.vlans, 0xff, sizeof(union flow_vlan_hdr) * n);\n        }\n    }\n    memmove(&flow->vlans[1], &flow->vlans[0],\n            sizeof(union flow_vlan_hdr) * (FLOW_MAX_VLAN_HEADERS - 1));\n    memset(&flow->vlans[0], 0, sizeof(union flow_vlan_hdr));\n}\n\n/* Returns the number of MPLS LSEs present in 'flow'\n *\n * Returns 0 if the 'dl_type' of 'flow' is not an MPLS ethernet type.\n * Otherwise traverses 'flow''s MPLS label stack stopping at the\n * first entry that has the BoS bit set. If no such entry exists then\n * the maximum number of LSEs that can be stored in 'flow' is returned.\n */\nint\nflow_count_mpls_labels(const struct flow *flow, struct flow_wildcards *wc)\n{\n    /* dl_type is always masked. */\n    if (eth_type_mpls(flow->dl_type)) {\n        int i;\n        int cnt;\n\n        cnt = 0;\n        for (i = 0; i < FLOW_MAX_MPLS_LABELS; i++) {\n            if (wc) {\n                wc->masks.mpls_lse[i] |= htonl(MPLS_BOS_MASK);\n            }\n            if (flow->mpls_lse[i] & htonl(MPLS_BOS_MASK)) {\n                return i + 1;\n            }\n            if (flow->mpls_lse[i]) {\n                cnt++;\n            }\n        }\n        return cnt;\n    } else {\n        return 0;\n    }\n}\n\n/* Returns the number consecutive of MPLS LSEs, starting at the\n * innermost LSE, that are common in 'a' and 'b'.\n *\n * 'an' must be flow_count_mpls_labels(a).\n * 'bn' must be flow_count_mpls_labels(b).\n */\nint\nflow_count_common_mpls_labels(const struct flow *a, int an,\n                              const struct flow *b, int bn,\n                              struct flow_wildcards *wc)\n{\n    int min_n = MIN(an, bn);\n    if (min_n == 0) {\n        return 0;\n    } else {\n        int common_n = 0;\n        int a_last = an - 1;\n        int b_last = bn - 1;\n        int i;\n\n        for (i = 0; i < min_n; i++) {\n            if (wc) {\n                wc->masks.mpls_lse[a_last - i] = OVS_BE32_MAX;\n                wc->masks.mpls_lse[b_last - i] = OVS_BE32_MAX;\n            }\n            if (a->mpls_lse[a_last - i] != b->mpls_lse[b_last - i]) {\n                break;\n            } else {\n                common_n++;\n            }\n        }\n\n        return common_n;\n    }\n}\n\n/* Adds a new outermost MPLS label to 'flow' and changes 'flow''s Ethernet type\n * to 'mpls_eth_type', which must be an MPLS Ethertype.\n *\n * If the new label is the first MPLS label in 'flow', it is generated as;\n *\n *     - label: 2, if 'flow' is IPv6, otherwise 0.\n *\n *     - TTL: IPv4 or IPv6 TTL, if present and nonzero, otherwise 64.\n *\n *     - TC: IPv4 or IPv6 TOS, if present, otherwise 0.\n *\n *     - BoS: 1.\n *\n * If the new label is the second or later label MPLS label in 'flow', it is\n * generated as;\n *\n *     - label: Copied from outer label.\n *\n *     - TTL: Copied from outer label.\n *\n *     - TC: Copied from outer label.\n *\n *     - BoS: 0.\n *\n * 'n' must be flow_count_mpls_labels(flow).  'n' must be less than\n * FLOW_MAX_MPLS_LABELS (because otherwise flow->mpls_lse[] would overflow).\n */\nvoid\nflow_push_mpls(struct flow *flow, int n, ovs_be16 mpls_eth_type,\n               struct flow_wildcards *wc, bool clear_flow_L3)\n{\n    ovs_assert(eth_type_mpls(mpls_eth_type));\n    ovs_assert(n < FLOW_MAX_MPLS_LABELS);\n\n    if (n) {\n        int i;\n\n        if (wc) {\n            memset(&wc->masks.mpls_lse, 0xff, sizeof *wc->masks.mpls_lse * n);\n        }\n        for (i = n; i >= 1; i--) {\n            flow->mpls_lse[i] = flow->mpls_lse[i - 1];\n        }\n        flow->mpls_lse[0] = (flow->mpls_lse[1] & htonl(~MPLS_BOS_MASK));\n    } else {\n        int label = 0;          /* IPv4 Explicit Null. */\n        int tc = 0;\n        int ttl = 64;\n\n        if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            label = 2;\n        }\n\n        if (is_ip_any(flow)) {\n            tc = (flow->nw_tos & IP_DSCP_MASK) >> 2;\n            if (wc) {\n                wc->masks.nw_tos |= IP_DSCP_MASK;\n                wc->masks.nw_ttl = 0xff;\n            }\n\n            if (flow->nw_ttl) {\n                ttl = flow->nw_ttl;\n            }\n        }\n\n        flow->mpls_lse[0] = set_mpls_lse_values(ttl, tc, 1, htonl(label));\n\n        if (clear_flow_L3) {\n            /* Clear all L3 and L4 fields and dp_hash. */\n            BUILD_ASSERT(FLOW_WC_SEQ == 41);\n            memset((char *) flow + FLOW_SEGMENT_2_ENDS_AT, 0,\n                   sizeof(struct flow) - FLOW_SEGMENT_2_ENDS_AT);\n            flow->dp_hash = 0;\n        }\n    }\n    flow->dl_type = mpls_eth_type;\n}\n\n/* Tries to remove the outermost MPLS label from 'flow'.  Returns true if\n * successful, false otherwise.  On success, sets 'flow''s Ethernet type to\n * 'eth_type'.\n *\n * 'n' must be flow_count_mpls_labels(flow). */\nbool\nflow_pop_mpls(struct flow *flow, int n, ovs_be16 eth_type,\n              struct flow_wildcards *wc)\n{\n    int i;\n\n    if (n == 0) {\n        /* Nothing to pop. */\n        return false;\n    } else if (n == FLOW_MAX_MPLS_LABELS) {\n        if (wc) {\n            wc->masks.mpls_lse[n - 1] |= htonl(MPLS_BOS_MASK);\n        }\n        if (!(flow->mpls_lse[n - 1] & htonl(MPLS_BOS_MASK))) {\n            /* Can't pop because don't know what to fill in mpls_lse[n - 1]. */\n            return false;\n        }\n    }\n\n    if (wc) {\n        memset(&wc->masks.mpls_lse[1], 0xff,\n               sizeof *wc->masks.mpls_lse * (n - 1));\n    }\n    for (i = 1; i < n; i++) {\n        flow->mpls_lse[i - 1] = flow->mpls_lse[i];\n    }\n    flow->mpls_lse[n - 1] = 0;\n    flow->dl_type = eth_type;\n    return true;\n}\n\n/* Sets the MPLS Label that 'flow' matches to 'label', which is interpreted\n * as an OpenFlow 1.1 \"mpls_label\" value. */\nvoid\nflow_set_mpls_label(struct flow *flow, int idx, ovs_be32 label)\n{\n    set_mpls_lse_label(&flow->mpls_lse[idx], label);\n}\n\n/* Sets the MPLS TTL that 'flow' matches to 'ttl', which should be in the\n * range 0...255. */\nvoid\nflow_set_mpls_ttl(struct flow *flow, int idx, uint8_t ttl)\n{\n    set_mpls_lse_ttl(&flow->mpls_lse[idx], ttl);\n}\n\n/* Sets the MPLS TC that 'flow' matches to 'tc', which should be in the\n * range 0...7. */\nvoid\nflow_set_mpls_tc(struct flow *flow, int idx, uint8_t tc)\n{\n    set_mpls_lse_tc(&flow->mpls_lse[idx], tc);\n}\n\n/* Sets the MPLS BOS bit that 'flow' matches to which should be 0 or 1. */\nvoid\nflow_set_mpls_bos(struct flow *flow, int idx, uint8_t bos)\n{\n    set_mpls_lse_bos(&flow->mpls_lse[idx], bos);\n}\n\n/* Sets the entire MPLS LSE. */\nvoid\nflow_set_mpls_lse(struct flow *flow, int idx, ovs_be32 lse)\n{\n    flow->mpls_lse[idx] = lse;\n}\n\nstatic void\nflow_compose_l7(struct dp_packet *p, const void *l7, size_t l7_len)\n{\n    if (l7_len) {\n        if (l7) {\n            dp_packet_put(p, l7, l7_len);\n        } else {\n            uint8_t *payload = dp_packet_put_uninit(p, l7_len);\n            for (size_t i = 0; i < l7_len; i++) {\n                payload[i] = i;\n            }\n        }\n    }\n}\n\nstatic size_t\nflow_compose_l4(struct dp_packet *p, const struct flow *flow,\n                const void *l7, size_t l7_len)\n{\n    size_t orig_len = dp_packet_size(p);\n\n    if (!(flow->nw_frag & FLOW_NW_FRAG_ANY)\n        || !(flow->nw_frag & FLOW_NW_FRAG_LATER)) {\n        if (flow->nw_proto == IPPROTO_TCP) {\n            struct tcp_header *tcp = dp_packet_put_zeros(p, sizeof *tcp);\n            tcp->tcp_src = flow->tp_src;\n            tcp->tcp_dst = flow->tp_dst;\n            tcp->tcp_ctl = TCP_CTL(ntohs(flow->tcp_flags), 5);\n            if (!(flow->tcp_flags & htons(TCP_SYN | TCP_FIN | TCP_RST))) {\n                flow_compose_l7(p, l7, l7_len);\n            }\n        } else if (flow->nw_proto == IPPROTO_UDP) {\n            struct udp_header *udp = dp_packet_put_zeros(p, sizeof *udp);\n            udp->udp_src = flow->tp_src;\n            udp->udp_dst = flow->tp_dst;\n            udp->udp_len = htons(sizeof *udp + l7_len);\n            flow_compose_l7(p, l7, l7_len);\n        } else if (flow->nw_proto == IPPROTO_SCTP) {\n            struct sctp_header *sctp = dp_packet_put_zeros(p, sizeof *sctp);\n            sctp->sctp_src = flow->tp_src;\n            sctp->sctp_dst = flow->tp_dst;\n            /* XXX Someone should figure out what L7 data to include. */\n        } else if (flow->nw_proto == IPPROTO_ICMP) {\n            struct icmp_header *icmp = dp_packet_put_zeros(p, sizeof *icmp);\n            icmp->icmp_type = ntohs(flow->tp_src);\n            icmp->icmp_code = ntohs(flow->tp_dst);\n            if ((icmp->icmp_type == ICMP4_ECHO_REQUEST ||\n                 icmp->icmp_type == ICMP4_ECHO_REPLY)\n                && icmp->icmp_code == 0) {\n                flow_compose_l7(p, l7, l7_len);\n            } else {\n                /* XXX Add inner IP packet for e.g. destination unreachable? */\n            }\n        } else if (flow->nw_proto == IPPROTO_IGMP) {\n            struct igmp_header *igmp = dp_packet_put_zeros(p, sizeof *igmp);\n            igmp->igmp_type = ntohs(flow->tp_src);\n            igmp->igmp_code = ntohs(flow->tp_dst);\n            put_16aligned_be32(&igmp->group, flow->igmp_group_ip4);\n        } else if (flow->nw_proto == IPPROTO_ICMPV6) {\n            struct icmp6_hdr *icmp = dp_packet_put_zeros(p, sizeof *icmp);\n            icmp->icmp6_type = ntohs(flow->tp_src);\n            icmp->icmp6_code = ntohs(flow->tp_dst);\n            uint32_t *reserved = &icmp->icmp6_dataun.icmp6_un_data32[0];\n            *reserved = ntohl(flow->igmp_group_ip4);\n\n            if (icmp->icmp6_code == 0 &&\n                (icmp->icmp6_type == ND_NEIGHBOR_SOLICIT ||\n                 icmp->icmp6_type == ND_NEIGHBOR_ADVERT)) {\n                struct in6_addr *nd_target;\n                struct ovs_nd_lla_opt *lla_opt;\n\n                nd_target = dp_packet_put_zeros(p, sizeof *nd_target);\n                *nd_target = flow->nd_target;\n\n                if (!eth_addr_is_zero(flow->arp_sha)) {\n                    lla_opt = dp_packet_put_zeros(p, 8);\n                    lla_opt->len = 1;\n                    lla_opt->type = ND_OPT_SOURCE_LINKADDR;\n                    lla_opt->mac = flow->arp_sha;\n                }\n                if (!eth_addr_is_zero(flow->arp_tha)) {\n                    lla_opt = dp_packet_put_zeros(p, 8);\n                    lla_opt->len = 1;\n                    lla_opt->type = ND_OPT_TARGET_LINKADDR;\n                    lla_opt->mac = flow->arp_tha;\n                }\n            } else if (icmp->icmp6_code == 0 &&\n                       (icmp->icmp6_type == ICMP6_ECHO_REQUEST ||\n                        icmp->icmp6_type == ICMP6_ECHO_REPLY)) {\n                flow_compose_l7(p, l7, l7_len);\n            } else {\n                /* XXX Add inner IP packet for e.g. destination unreachable? */\n            }\n        }\n    }\n\n    return dp_packet_size(p) - orig_len;\n}\n\nstatic void\nflow_compose_l4_csum(struct dp_packet *p, const struct flow *flow,\n                     uint32_t pseudo_hdr_csum)\n{\n    size_t l4_len = (char *) dp_packet_tail(p) - (char *) dp_packet_l4(p);\n\n    if (!(flow->nw_frag & FLOW_NW_FRAG_ANY)\n        || !(flow->nw_frag & FLOW_NW_FRAG_LATER)) {\n        if (flow->nw_proto == IPPROTO_TCP) {\n            struct tcp_header *tcp = dp_packet_l4(p);\n\n            tcp->tcp_csum = 0;\n            tcp->tcp_csum = csum_finish(csum_continue(pseudo_hdr_csum,\n                                                      tcp, l4_len));\n        } else if (flow->nw_proto == IPPROTO_UDP) {\n            struct udp_header *udp = dp_packet_l4(p);\n\n            udp->udp_csum = 0;\n            udp->udp_csum = csum_finish(csum_continue(pseudo_hdr_csum,\n                                                      udp, l4_len));\n            if (!udp->udp_csum) {\n                udp->udp_csum = htons(0xffff);\n            }\n        } else if (flow->nw_proto == IPPROTO_ICMP) {\n            struct icmp_header *icmp = dp_packet_l4(p);\n\n            icmp->icmp_csum = 0;\n            icmp->icmp_csum = csum(icmp, l4_len);\n        } else if (flow->nw_proto == IPPROTO_IGMP) {\n            struct igmp_header *igmp = dp_packet_l4(p);\n\n            igmp->igmp_csum = 0;\n            igmp->igmp_csum = csum(igmp, l4_len);\n        } else if (flow->nw_proto == IPPROTO_ICMPV6) {\n            struct icmp6_hdr *icmp = dp_packet_l4(p);\n\n            icmp->icmp6_cksum = 0;\n            icmp->icmp6_cksum = (OVS_FORCE uint16_t)\n                csum_finish(csum_continue(pseudo_hdr_csum, icmp, l4_len));\n        }\n    }\n}\n\n/* Increase the size of packet composed by 'flow_compose_minimal'\n * up to 'size' bytes.  Fixes all the required packet headers like\n * ip/udp lengths and l3/l4 checksums.\n *\n * 'size' needs to be larger then the current packet size.  */\nvoid\npacket_expand(struct dp_packet *p, const struct flow *flow, size_t size)\n{\n    size_t extra_size;\n\n    ovs_assert(size > dp_packet_size(p));\n\n    extra_size = size - dp_packet_size(p);\n    dp_packet_put_zeros(p, extra_size);\n\n    if (flow->dl_type == htons(FLOW_DL_TYPE_NONE)) {\n        struct eth_header *eth = dp_packet_eth(p);\n\n        eth->eth_type = htons(dp_packet_size(p));\n    } else if (dl_type_is_ip_any(flow->dl_type)) {\n        uint32_t pseudo_hdr_csum;\n        size_t l4_len = (char *) dp_packet_tail(p) - (char *) dp_packet_l4(p);\n\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            struct ip_header *ip = dp_packet_l3(p);\n\n            ip->ip_tot_len = htons(p->l4_ofs - p->l3_ofs + l4_len);\n            ip->ip_csum = 0;\n            ip->ip_csum = csum(ip, sizeof *ip);\n\n            pseudo_hdr_csum = packet_csum_pseudoheader(ip);\n        } else { /* ETH_TYPE_IPV6 */\n            struct ovs_16aligned_ip6_hdr *nh = dp_packet_l3(p);\n\n            nh->ip6_plen = htons(l4_len);\n            pseudo_hdr_csum = packet_csum_pseudoheader6(nh);\n        }\n\n        if ((!(flow->nw_frag & FLOW_NW_FRAG_ANY)\n             || !(flow->nw_frag & FLOW_NW_FRAG_LATER))\n            && flow->nw_proto == IPPROTO_UDP) {\n            struct udp_header *udp = dp_packet_l4(p);\n\n            udp->udp_len = htons(l4_len + extra_size);\n        }\n        flow_compose_l4_csum(p, flow, pseudo_hdr_csum);\n    }\n}\n\n/* Puts into 'p' a packet that flow_extract() would parse as having the given\n * 'flow'.\n *\n * (This is useful only for testing, obviously, and the packet isn't really\n * valid.  Lots of fields are just zeroed.)\n *\n * For packets whose protocols can encapsulate arbitrary L7 payloads, 'l7' and\n * 'l7_len' determine that payload:\n *\n *    - If 'l7_len' is zero, no payload is included.\n *\n *    - If 'l7_len' is nonzero and 'l7' is null, an arbitrary payload 'l7_len'\n *      bytes long is included.\n *\n *    - If 'l7_len' is nonzero and 'l7' is nonnull, the payload is copied\n *      from 'l7'. */\nvoid\nflow_compose(struct dp_packet *p, const struct flow *flow,\n             const void *l7, size_t l7_len)\n{\n    /* Add code to this function (or its callees) for emitting new fields or\n     * protocols.  (This isn't essential, so it can be skipped for initial\n     * testing.) */\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n\n    uint32_t pseudo_hdr_csum;\n    size_t l4_len;\n\n    /* eth_compose() sets l3 pointer and makes sure it is 32-bit aligned. */\n    eth_compose(p, flow->dl_dst, flow->dl_src, ntohs(flow->dl_type), 0);\n    if (flow->dl_type == htons(FLOW_DL_TYPE_NONE)) {\n        struct eth_header *eth = dp_packet_eth(p);\n        eth->eth_type = htons(dp_packet_size(p));\n        return;\n    }\n\n    for (int encaps = FLOW_MAX_VLAN_HEADERS - 1; encaps >= 0; encaps--) {\n        if (flow->vlans[encaps].tci & htons(VLAN_CFI)) {\n            eth_push_vlan(p, flow->vlans[encaps].tpid,\n                          flow->vlans[encaps].tci);\n        }\n    }\n\n    if (flow->dl_type == htons(ETH_TYPE_IP)) {\n        struct ip_header *ip;\n\n        ip = dp_packet_put_zeros(p, sizeof *ip);\n        ip->ip_ihl_ver = IP_IHL_VER(5, 4);\n        ip->ip_tos = flow->nw_tos;\n        ip->ip_ttl = flow->nw_ttl;\n        ip->ip_proto = flow->nw_proto;\n        put_16aligned_be32(&ip->ip_src, flow->nw_src);\n        put_16aligned_be32(&ip->ip_dst, flow->nw_dst);\n\n        if (flow->nw_frag & FLOW_NW_FRAG_ANY) {\n            ip->ip_frag_off |= htons(IP_MORE_FRAGMENTS);\n            if (flow->nw_frag & FLOW_NW_FRAG_LATER) {\n                ip->ip_frag_off |= htons(100);\n            }\n        }\n\n        dp_packet_set_l4(p, dp_packet_tail(p));\n\n        l4_len = flow_compose_l4(p, flow, l7, l7_len);\n\n        ip = dp_packet_l3(p);\n        ip->ip_tot_len = htons(p->l4_ofs - p->l3_ofs + l4_len);\n        /* Checksum has already been zeroed by put_zeros call. */\n        ip->ip_csum = csum(ip, sizeof *ip);\n\n        pseudo_hdr_csum = packet_csum_pseudoheader(ip);\n        flow_compose_l4_csum(p, flow, pseudo_hdr_csum);\n    } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n        struct ovs_16aligned_ip6_hdr *nh;\n\n        nh = dp_packet_put_zeros(p, sizeof *nh);\n        put_16aligned_be32(&nh->ip6_flow, htonl(6 << 28) |\n                           htonl(flow->nw_tos << 20) | flow->ipv6_label);\n        nh->ip6_hlim = flow->nw_ttl;\n        nh->ip6_nxt = flow->nw_proto;\n\n        memcpy(&nh->ip6_src, &flow->ipv6_src, sizeof(nh->ip6_src));\n        memcpy(&nh->ip6_dst, &flow->ipv6_dst, sizeof(nh->ip6_dst));\n\n        dp_packet_set_l4(p, dp_packet_tail(p));\n\n        l4_len = flow_compose_l4(p, flow, l7, l7_len);\n\n        nh = dp_packet_l3(p);\n        nh->ip6_plen = htons(l4_len);\n\n        pseudo_hdr_csum = packet_csum_pseudoheader6(nh);\n        flow_compose_l4_csum(p, flow, pseudo_hdr_csum);\n    } else if (flow->dl_type == htons(ETH_TYPE_ARP) ||\n               flow->dl_type == htons(ETH_TYPE_RARP)) {\n        struct arp_eth_header *arp;\n\n        arp = dp_packet_put_zeros(p, sizeof *arp);\n        dp_packet_set_l3(p, arp);\n        arp->ar_hrd = htons(1);\n        arp->ar_pro = htons(ETH_TYPE_IP);\n        arp->ar_hln = ETH_ADDR_LEN;\n        arp->ar_pln = 4;\n        arp->ar_op = htons(flow->nw_proto);\n\n        if (flow->nw_proto == ARP_OP_REQUEST ||\n            flow->nw_proto == ARP_OP_REPLY) {\n            put_16aligned_be32(&arp->ar_spa, flow->nw_src);\n            put_16aligned_be32(&arp->ar_tpa, flow->nw_dst);\n            arp->ar_sha = flow->arp_sha;\n            arp->ar_tha = flow->arp_tha;\n        }\n    }\n\n    if (eth_type_mpls(flow->dl_type)) {\n        int n;\n\n        p->l2_5_ofs = p->l3_ofs;\n        for (n = 1; n < FLOW_MAX_MPLS_LABELS; n++) {\n            if (flow->mpls_lse[n - 1] & htonl(MPLS_BOS_MASK)) {\n                break;\n            }\n        }\n        while (n > 0) {\n            push_mpls(p, flow->dl_type, flow->mpls_lse[--n]);\n        }\n    }\n}\n\f\n/* Compressed flow. */\n\n/* Completes an initialization of 'dst' as a miniflow copy of 'src' begun by\n * the caller.  The caller must have already computed 'dst->map' properly to\n * indicate the significant uint64_t elements of 'src'.\n *\n * Normally the significant elements are the ones that are non-zero.  However,\n * when a miniflow is initialized from a (mini)mask, the values can be zeroes,\n * so that the flow and mask always have the same maps. */\nvoid\nminiflow_init(struct miniflow *dst, const struct flow *src)\n{\n    uint64_t *dst_u64 = miniflow_values(dst);\n    size_t idx;\n\n    FLOWMAP_FOR_EACH_INDEX(idx, dst->map) {\n        *dst_u64++ = flow_u64_value(src, idx);\n    }\n}\n\n/* Initialize the maps of 'flow' from 'src'. */\nvoid\nminiflow_map_init(struct miniflow *flow, const struct flow *src)\n{\n    /* Initialize map, counting the number of nonzero elements. */\n    flowmap_init(&flow->map);\n    for (size_t i = 0; i < FLOW_U64S; i++) {\n        if (flow_u64_value(src, i)) {\n            flowmap_set(&flow->map, i, 1);\n        }\n    }\n}\n\n/* Allocates 'n' count of miniflows, consecutive in memory, initializing the\n * map of each from 'src'.\n * Returns the size of the miniflow data. */\nsize_t\nminiflow_alloc(struct miniflow *dsts[], size_t n, const struct miniflow *src)\n{\n    size_t n_values = miniflow_n_values(src);\n    size_t data_size = MINIFLOW_VALUES_SIZE(n_values);\n    struct miniflow *dst = xmalloc(n * (sizeof *src + data_size));\n    size_t i;\n\n    COVERAGE_INC(miniflow_malloc);\n\n    for (i = 0; i < n; i++) {\n        *dst = *src;   /* Copy maps. */\n        dsts[i] = dst;\n        dst += 1;      /* Just past the maps. */\n        dst = (struct miniflow *)((uint64_t *)dst + n_values); /* Skip data. */\n    }\n    return data_size;\n}\n\n/* Returns a miniflow copy of 'src'.  The caller must eventually free() the\n * returned miniflow. */\nstruct miniflow *\nminiflow_create(const struct flow *src)\n{\n    struct miniflow tmp;\n    struct miniflow *dst;\n\n    miniflow_map_init(&tmp, src);\n\n    miniflow_alloc(&dst, 1, &tmp);\n    miniflow_init(dst, src);\n    return dst;\n}\n\n/* Initializes 'dst' as a copy of 'src'.  The caller must have allocated\n * 'dst' to have inline space for 'n_values' data in 'src'. */\nvoid\nminiflow_clone(struct miniflow *dst, const struct miniflow *src,\n               size_t n_values)\n{\n    *dst = *src;   /* Copy maps. */\n    memcpy(miniflow_values(dst), miniflow_get_values(src),\n           MINIFLOW_VALUES_SIZE(n_values));\n}\n\n/* Initializes 'dst' as a copy of 'src'. */\nvoid\nminiflow_expand(const struct miniflow *src, struct flow *dst)\n{\n    memset(dst, 0, sizeof *dst);\n    flow_union_with_miniflow(dst, src);\n}\n\n/* Returns true if 'a' and 'b' are equal miniflows, false otherwise. */\nbool\nminiflow_equal(const struct miniflow *a, const struct miniflow *b)\n{\n    const uint64_t *ap = miniflow_get_values(a);\n    const uint64_t *bp = miniflow_get_values(b);\n\n    /* This is mostly called after a matching hash, so it is highly likely that\n     * the maps are equal as well. */\n    if (OVS_LIKELY(flowmap_equal(a->map, b->map))) {\n        return !memcmp(ap, bp, miniflow_n_values(a) * sizeof *ap);\n    } else {\n        size_t idx;\n\n        FLOWMAP_FOR_EACH_INDEX (idx, flowmap_or(a->map, b->map)) {\n            if ((flowmap_is_set(&a->map, idx) ? *ap++ : 0)\n                != (flowmap_is_set(&b->map, idx) ? *bp++ : 0)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/* Returns false if 'a' and 'b' differ at the places where there are 1-bits\n * in 'mask', true otherwise. */\nbool\nminiflow_equal_in_minimask(const struct miniflow *a, const struct miniflow *b,\n                           const struct minimask *mask)\n{\n    const uint64_t *p = miniflow_get_values(&mask->masks);\n    size_t idx;\n\n    FLOWMAP_FOR_EACH_INDEX(idx, mask->masks.map) {\n        if ((miniflow_get(a, idx) ^ miniflow_get(b, idx)) & *p++) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/* Returns true if 'a' and 'b' are equal at the places where there are 1-bits\n * in 'mask', false if they differ. */\nbool\nminiflow_equal_flow_in_minimask(const struct miniflow *a, const struct flow *b,\n                                const struct minimask *mask)\n{\n    const uint64_t *p = miniflow_get_values(&mask->masks);\n    size_t idx;\n\n    FLOWMAP_FOR_EACH_INDEX(idx, mask->masks.map) {\n        if ((miniflow_get(a, idx) ^ flow_u64_value(b, idx)) & *p++) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\f\nvoid\nminimask_init(struct minimask *mask, const struct flow_wildcards *wc)\n{\n    miniflow_init(&mask->masks, &wc->masks);\n}\n\n/* Returns a minimask copy of 'wc'.  The caller must eventually free the\n * returned minimask with free(). */\nstruct minimask *\nminimask_create(const struct flow_wildcards *wc)\n{\n    return (struct minimask *)miniflow_create(&wc->masks);\n}\n\n/* Initializes 'dst_' as the bit-wise \"and\" of 'a_' and 'b_'.\n *\n * The caller must provide room for FLOW_U64S \"uint64_t\"s in 'storage', which\n * must follow '*dst_' in memory, for use by 'dst_'.  The caller must *not*\n * free 'dst_' free(). */\nvoid\nminimask_combine(struct minimask *dst_,\n                 const struct minimask *a_, const struct minimask *b_,\n                 uint64_t storage[FLOW_U64S])\n{\n    struct miniflow *dst = &dst_->masks;\n    uint64_t *dst_values = storage;\n    const struct miniflow *a = &a_->masks;\n    const struct miniflow *b = &b_->masks;\n    size_t idx;\n\n    flowmap_init(&dst->map);\n\n    FLOWMAP_FOR_EACH_INDEX(idx, flowmap_and(a->map, b->map)) {\n        /* Both 'a' and 'b' have non-zero data at 'idx'. */\n        uint64_t mask = *miniflow_get__(a, idx) & *miniflow_get__(b, idx);\n\n        if (mask) {\n            flowmap_set(&dst->map, idx, 1);\n            *dst_values++ = mask;\n        }\n    }\n}\n\n/* Initializes 'wc' as a copy of 'mask'. */\nvoid\nminimask_expand(const struct minimask *mask, struct flow_wildcards *wc)\n{\n    miniflow_expand(&mask->masks, &wc->masks);\n}\n\n/* Returns true if 'a' and 'b' are the same flow mask, false otherwise.\n * Minimasks may not have zero data values, so for the minimasks to be the\n * same, they need to have the same map and the same data values. */\nbool\nminimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    return !memcmp(a, b, sizeof *a\n                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));\n}\n\n/* Returns true if at least one bit matched by 'b' is wildcarded by 'a',\n * false otherwise. */\nbool\nminimask_has_extra(const struct minimask *a, const struct minimask *b)\n{\n    const uint64_t *bp = miniflow_get_values(&b->masks);\n    size_t idx;\n\n    FLOWMAP_FOR_EACH_INDEX(idx, b->masks.map) {\n        uint64_t b_u64 = *bp++;\n\n        /* 'b_u64' is non-zero, check if the data in 'a' is either zero\n         * or misses some of the bits in 'b_u64'. */\n        if (!MINIFLOW_IN_MAP(&a->masks, idx)\n            || ((*miniflow_get__(&a->masks, idx) & b_u64) != b_u64)) {\n            return true; /* 'a' wildcards some bits 'b' doesn't. */\n        }\n    }\n\n    return false;\n}\n\nvoid\nflow_limit_vlans(int vlan_limit)\n{\n    if (vlan_limit <= 0) {\n        flow_vlan_limit = FLOW_MAX_VLAN_HEADERS;\n    } else {\n        flow_vlan_limit = MIN(vlan_limit, FLOW_MAX_VLAN_HEADERS);\n    }\n}\n\nstruct netdev *\nflow_get_tunnel_netdev(struct flow_tnl *tunnel)\n{\n    char iface[IFNAMSIZ];\n    struct in6_addr ip6;\n    struct in6_addr gw;\n\n    if (tunnel->ip_src) {\n        in6_addr_set_mapped_ipv4(&ip6, tunnel->ip_src);\n    } else if (ipv6_addr_is_set(&tunnel->ipv6_src)) {\n        ip6 = tunnel->ipv6_src;\n    } else {\n        return NULL;\n    }\n\n    if (!ovs_router_lookup(0, &ip6, iface, NULL, &gw)) {\n        return NULL;\n    }\n\n    return netdev_from_name(iface);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2017, 2019 Nicira, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <config.h>\n#include <sys/types.h>\n#include \"flow.h\"\n#include <errno.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <netinet/icmp6.h>\n#include <netinet/ip6.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"byte-order.h\"\n#include \"colors.h\"\n#include \"coverage.h\"\n#include \"csum.h\"\n#include \"openvswitch/dynamic-string.h\"\n#include \"hash.h\"\n#include \"jhash.h\"\n#include \"openvswitch/match.h\"\n#include \"dp-packet.h\"\n#include \"openflow/openflow.h\"\n#include \"packets.h\"\n#include \"odp-util.h\"\n#include \"random.h\"\n#include \"unaligned.h\"\n#include \"util.h\"\n#include \"openvswitch/nsh.h\"\n#include \"ovs-router.h\"\n#include \"lib/netdev-provider.h\"\n\nCOVERAGE_DEFINE(flow_extract);\nCOVERAGE_DEFINE(miniflow_malloc);\n\n/* U64 indices for segmented flow classification. */\nconst uint8_t flow_segment_u64s[4] = {\n    FLOW_SEGMENT_1_ENDS_AT / sizeof(uint64_t),\n    FLOW_SEGMENT_2_ENDS_AT / sizeof(uint64_t),\n    FLOW_SEGMENT_3_ENDS_AT / sizeof(uint64_t),\n    FLOW_U64S\n};\n\nint flow_vlan_limit = FLOW_MAX_VLAN_HEADERS;\n\n/* Asserts that field 'f1' follows immediately after 'f0' in struct flow,\n * without any intervening padding. */\n#define ASSERT_SEQUENTIAL(f0, f1)                       \\\n    BUILD_ASSERT_DECL(offsetof(struct flow, f0)         \\\n                      + MEMBER_SIZEOF(struct flow, f0)  \\\n                      == offsetof(struct flow, f1))\n\n/* Asserts that fields 'f0' and 'f1' are in the same 32-bit aligned word within\n * struct flow. */\n#define ASSERT_SAME_WORD(f0, f1)                        \\\n    BUILD_ASSERT_DECL(offsetof(struct flow, f0) / 4     \\\n                      == offsetof(struct flow, f1) / 4)\n\n/* Asserts that 'f0' and 'f1' are both sequential and within the same 32-bit\n * aligned word in struct flow. */\n#define ASSERT_SEQUENTIAL_SAME_WORD(f0, f1)     \\\n    ASSERT_SEQUENTIAL(f0, f1);                  \\\n    ASSERT_SAME_WORD(f0, f1)\n\n/* miniflow_extract() assumes the following to be true to optimize the\n * extraction process. */\nASSERT_SEQUENTIAL_SAME_WORD(nw_frag, nw_tos);\nASSERT_SEQUENTIAL_SAME_WORD(nw_tos, nw_ttl);\nASSERT_SEQUENTIAL_SAME_WORD(nw_ttl, nw_proto);\n\n/* TCP flags in the middle of a BE64, zeroes in the other half. */\nBUILD_ASSERT_DECL(offsetof(struct flow, tcp_flags) % 8 == 4);\n\n#if WORDS_BIGENDIAN\n#define TCP_FLAGS_BE32(tcp_ctl) ((OVS_FORCE ovs_be32)TCP_FLAGS_BE16(tcp_ctl) \\\n                                 << 16)\n#else\n#define TCP_FLAGS_BE32(tcp_ctl) ((OVS_FORCE ovs_be32)TCP_FLAGS_BE16(tcp_ctl))\n#endif\n\nASSERT_SEQUENTIAL_SAME_WORD(tp_src, tp_dst);\n\n/* Removes 'size' bytes from the head end of '*datap', of size '*sizep', which\n * must contain at least 'size' bytes of data.  Returns the first byte of data\n * removed. */\nstatic inline const void *\ndata_pull(const void **datap, size_t *sizep, size_t size)\n{\n    const char *data = *datap;\n    *datap = data + size;\n    *sizep -= size;\n    return data;\n}\n\n/* If '*datap' has at least 'size' bytes of data, removes that many bytes from\n * the head end of '*datap' and returns the first byte removed.  Otherwise,\n * returns a null pointer without modifying '*datap'. */\nstatic inline const void *\ndata_try_pull(const void **datap, size_t *sizep, size_t size)\n{\n    return OVS_LIKELY(*sizep >= size) ? data_pull(datap, sizep, size) : NULL;\n}\n\n/* Context for pushing data to a miniflow. */\nstruct mf_ctx {\n    struct flowmap map;\n    uint64_t *data;\n    uint64_t * const end;\n};\n\n/* miniflow_push_* macros allow filling in a miniflow data values in order.\n * Assertions are needed only when the layout of the struct flow is modified.\n * 'ofs' is a compile-time constant, which allows most of the code be optimized\n * away.  Some GCC versions gave warnings on ALWAYS_INLINE, so these are\n * defined as macros. */\n\n#if (FLOW_WC_SEQ != 41)\n#define MINIFLOW_ASSERT(X) ovs_assert(X)\nBUILD_MESSAGE(\"FLOW_WC_SEQ changed: miniflow_extract() will have runtime \"\n               \"assertions enabled. Consider updating FLOW_WC_SEQ after \"\n               \"testing\")\n#else\n#define MINIFLOW_ASSERT(X)\n#endif\n\n/* True if 'IDX' and higher bits are not set. */\n#define ASSERT_FLOWMAP_NOT_SET(FM, IDX)                                 \\\n{                                                                       \\\n    MINIFLOW_ASSERT(!((FM)->bits[(IDX) / MAP_T_BITS] &                  \\\n                      (MAP_MAX << ((IDX) % MAP_T_BITS))));              \\\n    for (size_t i = (IDX) / MAP_T_BITS + 1; i < FLOWMAP_UNITS; i++) {   \\\n        MINIFLOW_ASSERT(!(FM)->bits[i]);                                \\\n    }                                                                   \\\n}\n\n#define miniflow_set_map(MF, OFS)            \\\n    {                                        \\\n    ASSERT_FLOWMAP_NOT_SET(&MF.map, (OFS));  \\\n    flowmap_set(&MF.map, (OFS), 1);          \\\n}\n\n#define miniflow_assert_in_map(MF, OFS)              \\\n    MINIFLOW_ASSERT(flowmap_is_set(&MF.map, (OFS))); \\\n    ASSERT_FLOWMAP_NOT_SET(&MF.map, (OFS) + 1)\n\n#define miniflow_push_uint64_(MF, OFS, VALUE)              \\\n{                                                          \\\n    MINIFLOW_ASSERT(MF.data < MF.end && (OFS) % 8 == 0);   \\\n    *MF.data++ = VALUE;                                    \\\n    miniflow_set_map(MF, OFS / 8);                         \\\n}\n\n#define miniflow_push_be64_(MF, OFS, VALUE)                     \\\n    miniflow_push_uint64_(MF, OFS, (OVS_FORCE uint64_t)(VALUE))\n\n#define miniflow_push_uint32_(MF, OFS, VALUE)   \\\n    {                                           \\\n    MINIFLOW_ASSERT(MF.data < MF.end);          \\\n                                                \\\n    if ((OFS) % 8 == 0) {                       \\\n        miniflow_set_map(MF, OFS / 8);          \\\n        *(uint32_t *)MF.data = VALUE;           \\\n    } else if ((OFS) % 8 == 4) {                \\\n        miniflow_assert_in_map(MF, OFS / 8);    \\\n        *((uint32_t *)MF.data + 1) = VALUE;     \\\n        MF.data++;                              \\\n    }                                           \\\n}\n\n#define miniflow_push_be32_(MF, OFS, VALUE)                     \\\n    miniflow_push_uint32_(MF, OFS, (OVS_FORCE uint32_t)(VALUE))\n\n#define miniflow_push_uint16_(MF, OFS, VALUE)   \\\n{                                               \\\n    MINIFLOW_ASSERT(MF.data < MF.end);          \\\n                                                \\\n    if ((OFS) % 8 == 0) {                       \\\n        miniflow_set_map(MF, OFS / 8);          \\\n        *(uint16_t *)MF.data = VALUE;           \\\n    } else if ((OFS) % 8 == 2) {                \\\n        miniflow_assert_in_map(MF, OFS / 8);    \\\n        *((uint16_t *)MF.data + 1) = VALUE;     \\\n    } else if ((OFS) % 8 == 4) {                \\\n        miniflow_assert_in_map(MF, OFS / 8);    \\\n        *((uint16_t *)MF.data + 2) = VALUE;     \\\n    } else if ((OFS) % 8 == 6) {                \\\n        miniflow_assert_in_map(MF, OFS / 8);    \\\n        *((uint16_t *)MF.data + 3) = VALUE;     \\\n        MF.data++;                              \\\n    }                                           \\\n}\n\n#define miniflow_push_uint8_(MF, OFS, VALUE)            \\\n{                                                       \\\n    MINIFLOW_ASSERT(MF.data < MF.end);                  \\\n                                                        \\\n    if ((OFS) % 8 == 0) {                               \\\n        miniflow_set_map(MF, OFS / 8);                  \\\n        *(uint8_t *)MF.data = VALUE;                    \\\n    } else if ((OFS) % 8 == 7) {                        \\\n        miniflow_assert_in_map(MF, OFS / 8);            \\\n        *((uint8_t *)MF.data + 7) = VALUE;              \\\n        MF.data++;                                      \\\n    } else {                                            \\\n        miniflow_assert_in_map(MF, OFS / 8);            \\\n        *((uint8_t *)MF.data + ((OFS) % 8)) = VALUE;    \\\n    }                                                   \\\n}\n\n#define miniflow_pad_to_64_(MF, OFS)                            \\\n{                                                               \\\n    MINIFLOW_ASSERT((OFS) % 8 != 0);                            \\\n    miniflow_assert_in_map(MF, OFS / 8);                        \\\n                                                                \\\n    memset((uint8_t *)MF.data + (OFS) % 8, 0, 8 - (OFS) % 8);   \\\n    MF.data++;                                                  \\\n}\n\n#define miniflow_pad_from_64_(MF, OFS)                          \\\n{                                                               \\\n    MINIFLOW_ASSERT(MF.data < MF.end);                          \\\n                                                                \\\n    MINIFLOW_ASSERT((OFS) % 8 != 0);                            \\\n    miniflow_set_map(MF, OFS / 8);                              \\\n                                                                \\\n    memset((uint8_t *)MF.data, 0, (OFS) % 8);                   \\\n}\n\n#define miniflow_push_be16_(MF, OFS, VALUE)                     \\\n    miniflow_push_uint16_(MF, OFS, (OVS_FORCE uint16_t)VALUE);\n\n#define miniflow_push_be8_(MF, OFS, VALUE)                     \\\n    miniflow_push_uint8_(MF, OFS, (OVS_FORCE uint8_t)VALUE);\n\n#define miniflow_set_maps(MF, OFS, N_WORDS)                     \\\n{                                                               \\\n    size_t ofs = (OFS);                                         \\\n    size_t n_words = (N_WORDS);                                 \\\n                                                                \\\n    MINIFLOW_ASSERT(n_words && MF.data + n_words <= MF.end);    \\\n    ASSERT_FLOWMAP_NOT_SET(&MF.map, ofs);                       \\\n    flowmap_set(&MF.map, ofs, n_words);                         \\\n}\n\n/* Data at 'valuep' may be unaligned. */\n#define miniflow_push_words_(MF, OFS, VALUEP, N_WORDS)          \\\n{                                                               \\\n    MINIFLOW_ASSERT((OFS) % 8 == 0);                            \\\n    miniflow_set_maps(MF, (OFS) / 8, (N_WORDS));                \\\n    memcpy(MF.data, (VALUEP), (N_WORDS) * sizeof *MF.data);     \\\n    MF.data += (N_WORDS);                                       \\\n}\n\n/* Push 32-bit words padded to 64-bits. */\n#define miniflow_push_words_32_(MF, OFS, VALUEP, N_WORDS)               \\\n{                                                                       \\\n    miniflow_set_maps(MF, (OFS) / 8, DIV_ROUND_UP(N_WORDS, 2));         \\\n    memcpy(MF.data, (VALUEP), (N_WORDS) * sizeof(uint32_t));            \\\n    MF.data += DIV_ROUND_UP(N_WORDS, 2);                                \\\n    if ((N_WORDS) & 1) {                                                \\\n        *((uint32_t *)MF.data - 1) = 0;                                 \\\n    }                                                                   \\\n}\n\n/* Data at 'valuep' may be unaligned. */\n/* MACs start 64-aligned, and must be followed by other data or padding. */\n#define miniflow_push_macs_(MF, OFS, VALUEP)                    \\\n{                                                               \\\n    miniflow_set_maps(MF, (OFS) / 8, 2);                        \\\n    memcpy(MF.data, (VALUEP), 2 * ETH_ADDR_LEN);                \\\n    MF.data += 1;                   /* First word only. */      \\\n}\n\n#define miniflow_push_uint32(MF, FIELD, VALUE)                      \\\n    miniflow_push_uint32_(MF, offsetof(struct flow, FIELD), VALUE)\n\n#define miniflow_push_be32(MF, FIELD, VALUE)                        \\\n    miniflow_push_be32_(MF, offsetof(struct flow, FIELD), VALUE)\n\n#define miniflow_push_uint16(MF, FIELD, VALUE)                      \\\n    miniflow_push_uint16_(MF, offsetof(struct flow, FIELD), VALUE)\n\n#define miniflow_push_be16(MF, FIELD, VALUE)                        \\\n    miniflow_push_be16_(MF, offsetof(struct flow, FIELD), VALUE)\n\n#define miniflow_push_uint8(MF, FIELD, VALUE)                      \\\n    miniflow_push_uint8_(MF, offsetof(struct flow, FIELD), VALUE)\n\n#define miniflow_pad_to_64(MF, FIELD)                       \\\n    miniflow_pad_to_64_(MF, OFFSETOFEND(struct flow, FIELD))\n\n#define miniflow_pad_from_64(MF, FIELD)                       \\\n    miniflow_pad_from_64_(MF, offsetof(struct flow, FIELD))\n\n#define miniflow_push_words(MF, FIELD, VALUEP, N_WORDS)                 \\\n    miniflow_push_words_(MF, offsetof(struct flow, FIELD), VALUEP, N_WORDS)\n\n#define miniflow_push_words_32(MF, FIELD, VALUEP, N_WORDS)              \\\n    miniflow_push_words_32_(MF, offsetof(struct flow, FIELD), VALUEP, N_WORDS)\n\n#define miniflow_push_macs(MF, FIELD, VALUEP)                       \\\n    miniflow_push_macs_(MF, offsetof(struct flow, FIELD), VALUEP)\n\n/* Return the pointer to the miniflow data when called BEFORE the corresponding\n * push. */\n#define miniflow_pointer(MF, FIELD)                                     \\\n    (void *)((uint8_t *)MF.data + ((offsetof(struct flow, FIELD)) % 8))\n\n/* Pulls the MPLS headers at '*datap' and returns the count of them. */\nstatic inline int\nparse_mpls(const void **datap, size_t *sizep)\n{\n    const struct mpls_hdr *mh;\n    int count = 0;\n\n    while ((mh = data_try_pull(datap, sizep, sizeof *mh))) {\n        count++;\n        if (mh->mpls_lse.lo & htons(1 << MPLS_BOS_SHIFT)) {\n            break;\n        }\n    }\n    return MIN(count, FLOW_MAX_MPLS_LABELS);\n}\n\n/* passed vlan_hdrs arg must be at least size FLOW_MAX_VLAN_HEADERS. */\nstatic inline ALWAYS_INLINE size_t\nparse_vlan(const void **datap, size_t *sizep, union flow_vlan_hdr *vlan_hdrs)\n{\n    const ovs_be16 *eth_type;\n\n    memset(vlan_hdrs, 0, sizeof(union flow_vlan_hdr) * FLOW_MAX_VLAN_HEADERS);\n    data_pull(datap, sizep, ETH_ADDR_LEN * 2);\n\n    eth_type = *datap;\n\n    size_t n;\n    for (n = 0; eth_type_vlan(*eth_type) && n < flow_vlan_limit; n++) {\n        if (OVS_UNLIKELY(*sizep < sizeof(ovs_be32) + sizeof(ovs_be16))) {\n            break;\n        }\n\n        const ovs_16aligned_be32 *qp = data_pull(datap, sizep, sizeof *qp);\n        vlan_hdrs[n].qtag = get_16aligned_be32(qp);\n        vlan_hdrs[n].tci |= htons(VLAN_CFI);\n        eth_type = *datap;\n    }\n    return n;\n}\n\nstatic inline ALWAYS_INLINE ovs_be16\nparse_ethertype(const void **datap, size_t *sizep)\n{\n    const struct llc_snap_header *llc;\n    ovs_be16 proto;\n\n    proto = *(ovs_be16 *) data_pull(datap, sizep, sizeof proto);\n    if (OVS_LIKELY(ntohs(proto) >= ETH_TYPE_MIN)) {\n        return proto;\n    }\n\n    if (OVS_UNLIKELY(*sizep < sizeof *llc)) {\n        return htons(FLOW_DL_TYPE_NONE);\n    }\n\n    llc = *datap;\n    if (OVS_UNLIKELY(llc->llc.llc_dsap != LLC_DSAP_SNAP\n                     || llc->llc.llc_ssap != LLC_SSAP_SNAP\n                     || llc->llc.llc_cntl != LLC_CNTL_SNAP\n                     || memcmp(llc->snap.snap_org, SNAP_ORG_ETHERNET,\n                               sizeof llc->snap.snap_org))) {\n        return htons(FLOW_DL_TYPE_NONE);\n    }\n\n    data_pull(datap, sizep, sizeof *llc);\n\n    if (OVS_LIKELY(ntohs(llc->snap.snap_type) >= ETH_TYPE_MIN)) {\n        return llc->snap.snap_type;\n    }\n\n    return htons(FLOW_DL_TYPE_NONE);\n}\n\n/* Returns 'true' if the packet is an ND packet. In that case the '*nd_target'\n * and 'arp_buf[]' are filled in.  If the packet is not an ND packet, 'false'\n * is returned and no values are filled in on '*nd_target' or 'arp_buf[]'. */\nstatic inline bool\nparse_icmpv6(const void **datap, size_t *sizep, const struct icmp6_hdr *icmp,\n             uint32_t *rso_flags, const struct in6_addr **nd_target,\n             struct eth_addr arp_buf[2], uint8_t *opt_type)\n{\n    const uint32_t *reserved;\n    if (icmp->icmp6_code != 0 ||\n        (icmp->icmp6_type != ND_NEIGHBOR_SOLICIT &&\n         icmp->icmp6_type != ND_NEIGHBOR_ADVERT)) {\n        return false;\n    }\n\n    arp_buf[0] = eth_addr_zero;\n    arp_buf[1] = eth_addr_zero;\n    *opt_type = 0;\n\n    reserved = data_try_pull(datap, sizep, sizeof(uint32_t));\n    if (OVS_UNLIKELY(!reserved)) {\n        /* Invalid ND packet. */\n        return false;\n    }\n    *rso_flags = *reserved;\n\n    *nd_target = data_try_pull(datap, sizep, sizeof **nd_target);\n    if (OVS_UNLIKELY(!*nd_target)) {\n        return true;\n    }\n\n    while (*sizep >= 8) {\n        /* The minimum size of an option is 8 bytes, which also is\n         * the size of Ethernet link-layer options. */\n        const struct ovs_nd_lla_opt *lla_opt = *datap;\n        int opt_len = lla_opt->len * ND_LLA_OPT_LEN;\n\n        if (!opt_len || opt_len > *sizep) {\n            return true;\n        }\n\n        /* Store the link layer address if the appropriate option is\n         * provided.  It is considered an error if the same link\n         * layer option is specified twice. */\n        if (lla_opt->type == ND_OPT_SOURCE_LINKADDR && opt_len == 8) {\n            if (OVS_LIKELY(eth_addr_is_zero(arp_buf[0]))) {\n                arp_buf[0] = lla_opt->mac;\n                /* We use only first option type present in ND packet. */\n                if (*opt_type == 0) {\n                    *opt_type = lla_opt->type;\n                }\n            } else {\n                goto invalid;\n            }\n        } else if (lla_opt->type == ND_OPT_TARGET_LINKADDR && opt_len == 8) {\n            if (OVS_LIKELY(eth_addr_is_zero(arp_buf[1]))) {\n                arp_buf[1] = lla_opt->mac;\n                /* We use only first option type present in ND packet. */\n                if (*opt_type == 0) {\n                    *opt_type = lla_opt->type;\n                }\n            } else {\n                goto invalid;\n            }\n        }\n\n        if (OVS_UNLIKELY(!data_try_pull(datap, sizep, opt_len))) {\n            return true;\n        }\n    }\n    return true;\n\ninvalid:\n    *nd_target = NULL;\n    arp_buf[0] = eth_addr_zero;\n    arp_buf[1] = eth_addr_zero;\n    return true;\n}\n\nstatic inline bool\nparse_ipv6_ext_hdrs__(const void **datap, size_t *sizep, uint8_t *nw_proto,\n                      uint8_t *nw_frag,\n                      const struct ovs_16aligned_ip6_frag **frag_hdr)\n{\n    *frag_hdr = NULL;\n    while (1) {\n        if (OVS_LIKELY((*nw_proto != IPPROTO_HOPOPTS)\n                       && (*nw_proto != IPPROTO_ROUTING)\n                       && (*nw_proto != IPPROTO_DSTOPTS)\n                       && (*nw_proto != IPPROTO_AH)\n                       && (*nw_proto != IPPROTO_FRAGMENT))) {\n            /* It's either a terminal header (e.g., TCP, UDP) or one we\n             * don't understand.  In either case, we're done with the\n             * packet, so use it to fill in 'nw_proto'. */\n            return true;\n        }\n\n        /* We only verify that at least 8 bytes of the next header are\n         * available, but many of these headers are longer.  Ensure that\n         * accesses within the extension header are within those first 8\n         * bytes. All extension headers are required to be at least 8\n         * bytes. */\n        if (OVS_UNLIKELY(*sizep < 8)) {\n            return false;\n        }\n\n        if ((*nw_proto == IPPROTO_HOPOPTS)\n            || (*nw_proto == IPPROTO_ROUTING)\n            || (*nw_proto == IPPROTO_DSTOPTS)) {\n            /* These headers, while different, have the fields we care\n             * about in the same location and with the same\n             * interpretation. */\n            const struct ip6_ext *ext_hdr = *datap;\n            *nw_proto = ext_hdr->ip6e_nxt;\n            if (OVS_UNLIKELY(!data_try_pull(datap, sizep,\n                                            (ext_hdr->ip6e_len + 1) * 8))) {\n                return false;\n            }\n        } else if (*nw_proto == IPPROTO_AH) {\n            /* A standard AH definition isn't available, but the fields\n             * we care about are in the same location as the generic\n             * option header--only the header length is calculated\n             * differently. */\n            const struct ip6_ext *ext_hdr = *datap;\n            *nw_proto = ext_hdr->ip6e_nxt;\n            if (OVS_UNLIKELY(!data_try_pull(datap, sizep,\n                                            (ext_hdr->ip6e_len + 2) * 4))) {\n                return false;\n            }\n        } else if (*nw_proto == IPPROTO_FRAGMENT) {\n            *frag_hdr = *datap;\n\n            *nw_proto = (*frag_hdr)->ip6f_nxt;\n            if (!data_try_pull(datap, sizep, sizeof **frag_hdr)) {\n                return false;\n            }\n\n            /* We only process the first fragment. */\n            if ((*frag_hdr)->ip6f_offlg != htons(0)) {\n                *nw_frag = FLOW_NW_FRAG_ANY;\n                if (((*frag_hdr)->ip6f_offlg & IP6F_OFF_MASK) != htons(0)) {\n                    *nw_frag |= FLOW_NW_FRAG_LATER;\n                    *nw_proto = IPPROTO_FRAGMENT;\n                    return true;\n                }\n            }\n        }\n    }\n}\n\n/* Parses IPv6 extension headers until a terminal header (or header we\n * don't understand) is found.  'datap' points to the first extension\n * header and advances as parsing occurs; 'sizep' is the remaining size\n * and is decreased accordingly.  'nw_proto' starts as the first\n * extension header to process and is updated as the extension headers\n * are parsed.\n *\n * If a fragment header is found, '*frag_hdr' is set to the fragment\n * header and otherwise set to NULL.  If it is the first fragment,\n * extension header parsing otherwise continues as usual.  If it's not\n * the first fragment, 'nw_proto' is set to IPPROTO_FRAGMENT and 'nw_frag'\n * has FLOW_NW_FRAG_LATER set.  Both first and later fragments have\n * FLOW_NW_FRAG_ANY set in 'nw_frag'.\n *\n * A return value of false indicates that there was a problem parsing\n * the extension headers.*/\nbool\nparse_ipv6_ext_hdrs(const void **datap, size_t *sizep, uint8_t *nw_proto,\n                    uint8_t *nw_frag,\n                    const struct ovs_16aligned_ip6_frag **frag_hdr)\n{\n    return parse_ipv6_ext_hdrs__(datap, sizep, nw_proto, nw_frag,\n                                 frag_hdr);\n}\n\nbool\nparse_nsh(const void **datap, size_t *sizep, struct ovs_key_nsh *key)\n{\n    const struct nsh_hdr *nsh = (const struct nsh_hdr *) *datap;\n    uint8_t version, length, flags, ttl;\n\n    /* Check if it is long enough for NSH header, doesn't support\n     * MD type 2 yet\n     */\n    if (OVS_UNLIKELY(*sizep < NSH_BASE_HDR_LEN)) {\n        return false;\n    }\n\n    version = nsh_get_ver(nsh);\n    flags = nsh_get_flags(nsh);\n    length = nsh_hdr_len(nsh);\n    ttl = nsh_get_ttl(nsh);\n\n    if (OVS_UNLIKELY(length > *sizep || version != 0)) {\n        return false;\n    }\n\n    key->flags = flags;\n    key->ttl = ttl;\n    key->mdtype = nsh->md_type;\n    key->np = nsh->next_proto;\n    key->path_hdr = nsh_get_path_hdr(nsh);\n\n    switch (key->mdtype) {\n        case NSH_M_TYPE1:\n            if (length != NSH_M_TYPE1_LEN) {\n                return false;\n            }\n            for (size_t i = 0; i < 4; i++) {\n                key->context[i] = get_16aligned_be32(&nsh->md1.context[i]);\n            }\n            break;\n        case NSH_M_TYPE2:\n            /* Don't support MD type 2 metedata parsing yet */\n            if (length < NSH_BASE_HDR_LEN) {\n                return false;\n            }\n\n            memset(key->context, 0, sizeof(key->context));\n            break;\n        default:\n            /* We don't parse other context headers yet. */\n            memset(key->context, 0, sizeof(key->context));\n            break;\n    }\n\n    data_pull(datap, sizep, length);\n\n    return true;\n}\n\n/* This does the same thing as miniflow_extract() with a full-size 'flow' as\n * the destination. */\nvoid\nflow_extract(struct dp_packet *packet, struct flow *flow)\n{\n    struct {\n        struct miniflow mf;\n        uint64_t buf[FLOW_U64S];\n    } m;\n\n    COVERAGE_INC(flow_extract);\n\n    miniflow_extract(packet, &m.mf);\n    miniflow_expand(&m.mf, flow);\n}\n\nstatic inline bool\nipv4_sanity_check(const struct ip_header *nh, size_t size,\n                  int *ip_lenp, uint16_t *tot_lenp)\n{\n    int ip_len;\n    uint16_t tot_len;\n\n    if (OVS_UNLIKELY(size < IP_HEADER_LEN)) {\n        return false;\n    }\n    ip_len = IP_IHL(nh->ip_ihl_ver) * 4;\n\n    if (OVS_UNLIKELY(ip_len < IP_HEADER_LEN || size < ip_len)) {\n        return false;\n    }\n\n    tot_len = ntohs(nh->ip_tot_len);\n    if (OVS_UNLIKELY(tot_len > size || ip_len > tot_len ||\n                size - tot_len > UINT8_MAX)) {\n        return false;\n    }\n\n    *ip_lenp = ip_len;\n    *tot_lenp = tot_len;\n\n    return true;\n}\n\nstatic inline uint8_t\nipv4_get_nw_frag(const struct ip_header *nh)\n{\n    uint8_t nw_frag = 0;\n\n    if (OVS_UNLIKELY(IP_IS_FRAGMENT(nh->ip_frag_off))) {\n        nw_frag = FLOW_NW_FRAG_ANY;\n        if (nh->ip_frag_off & htons(IP_FRAG_OFF_MASK)) {\n            nw_frag |= FLOW_NW_FRAG_LATER;\n        }\n    }\n\n    return nw_frag;\n}\n\nstatic inline bool\nipv6_sanity_check(const struct ovs_16aligned_ip6_hdr *nh, size_t size)\n{\n    uint16_t plen;\n\n    if (OVS_UNLIKELY(size < sizeof *nh)) {\n        return false;\n    }\n\n    plen = ntohs(nh->ip6_plen);\n    if (OVS_UNLIKELY(plen + IPV6_HEADER_LEN > size)) {\n        return false;\n    }\n    /* Jumbo Payload option not supported yet. */\n    if (OVS_UNLIKELY(size - plen > UINT8_MAX)) {\n        return false;\n    }\n\n    return true;\n}\n\n/* Initializes 'dst' from 'packet' and 'md', taking the packet type into\n * account.  'dst' must have enough space for FLOW_U64S * 8 bytes.\n *\n * Initializes the layer offsets as follows:\n *\n *    - packet->l2_5_ofs to the\n *          * the start of the MPLS shim header. Can be zero, if the\n *            packet is of type (OFPHTN_ETHERTYPE, ETH_TYPE_MPLS).\n *          * UINT16_MAX when there is no MPLS shim header.\n *\n *    - packet->l3_ofs is set to\n *          * zero if the packet_type is in name space OFPHTN_ETHERTYPE\n *            and there is no MPLS shim header.\n *          * just past the Ethernet header, or just past the vlan_header if\n *            one is present, to the first byte of the payload of the\n *            Ethernet frame if the packet type is Ethernet and there is\n *            no MPLS shim header.\n *          * just past the MPLS label stack to the first byte of the MPLS\n *            payload if there is at least one MPLS shim header.\n *          * UINT16_MAX if the packet type is Ethernet and the frame is\n *            too short to contain an Ethernet header.\n *\n *    - packet->l4_ofs is set to just past the IPv4 or IPv6 header, if one is\n *      present and the packet has at least the content used for the fields\n *      of interest for the flow, otherwise UINT16_MAX.\n */\nvoid\nminiflow_extract(struct dp_packet *packet, struct miniflow *dst)\n{\n    /* Add code to this function (or its callees) to extract new fields. */\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n\n    const struct pkt_metadata *md = &packet->md;\n    const void *data = dp_packet_data(packet);\n    size_t size = dp_packet_size(packet);\n    ovs_be32 packet_type = packet->packet_type;\n    uint64_t *values = miniflow_values(dst);\n    struct mf_ctx mf = { FLOWMAP_EMPTY_INITIALIZER, values,\n                         values + FLOW_U64S };\n    const char *frame;\n    ovs_be16 dl_type = OVS_BE16_MAX;\n    uint8_t nw_frag, nw_tos, nw_ttl, nw_proto;\n    uint8_t *ct_nw_proto_p = NULL;\n    ovs_be16 ct_tp_src = 0, ct_tp_dst = 0;\n\n    /* Metadata. */\n    if (flow_tnl_dst_is_set(&md->tunnel)) {\n        miniflow_push_words(mf, tunnel, &md->tunnel,\n                            offsetof(struct flow_tnl, metadata) /\n                            sizeof(uint64_t));\n\n        if (!(md->tunnel.flags & FLOW_TNL_F_UDPIF)) {\n            if (md->tunnel.metadata.present.map) {\n                miniflow_push_words(mf, tunnel.metadata, &md->tunnel.metadata,\n                                    sizeof md->tunnel.metadata /\n                                    sizeof(uint64_t));\n            }\n        } else {\n            if (md->tunnel.metadata.present.len) {\n                miniflow_push_words(mf, tunnel.metadata.present,\n                                    &md->tunnel.metadata.present, 1);\n                miniflow_push_words(mf, tunnel.metadata.opts.gnv,\n                                    md->tunnel.metadata.opts.gnv,\n                                    DIV_ROUND_UP(md->tunnel.metadata.present.len,\n                                                 sizeof(uint64_t)));\n            }\n        }\n    }\n    if (md->skb_priority || md->pkt_mark) {\n        miniflow_push_uint32(mf, skb_priority, md->skb_priority);\n        miniflow_push_uint32(mf, pkt_mark, md->pkt_mark);\n    }\n    miniflow_push_uint32(mf, dp_hash, md->dp_hash);\n    miniflow_push_uint32(mf, in_port, odp_to_u32(md->in_port.odp_port));\n    if (md->ct_state) {\n        miniflow_push_uint32(mf, recirc_id, md->recirc_id);\n        miniflow_push_uint8(mf, ct_state, md->ct_state);\n        ct_nw_proto_p = miniflow_pointer(mf, ct_nw_proto);\n        miniflow_push_uint8(mf, ct_nw_proto, 0);\n        miniflow_push_uint16(mf, ct_zone, md->ct_zone);\n    } else if (md->recirc_id) {\n        miniflow_push_uint32(mf, recirc_id, md->recirc_id);\n        miniflow_pad_to_64(mf, recirc_id);\n    }\n\n    if (md->ct_state) {\n        miniflow_push_uint32(mf, ct_mark, md->ct_mark);\n        miniflow_push_be32(mf, packet_type, packet_type);\n\n        if (!ovs_u128_is_zero(md->ct_label)) {\n            miniflow_push_words(mf, ct_label, &md->ct_label,\n                                sizeof md->ct_label / sizeof(uint64_t));\n        }\n    } else {\n        miniflow_pad_from_64(mf, packet_type);\n        miniflow_push_be32(mf, packet_type, packet_type);\n    }\n\n    /* Initialize packet's layer pointer and offsets. */\n    frame = data;\n    dp_packet_reset_offsets(packet);\n\n    if (packet_type == htonl(PT_ETH)) {\n        /* Must have full Ethernet header to proceed. */\n        if (OVS_UNLIKELY(size < sizeof(struct eth_header))) {\n            goto out;\n        } else {\n            /* Link layer. */\n            ASSERT_SEQUENTIAL(dl_dst, dl_src);\n            miniflow_push_macs(mf, dl_dst, data);\n\n            /* VLAN */\n            union flow_vlan_hdr vlans[FLOW_MAX_VLAN_HEADERS];\n            size_t num_vlans = parse_vlan(&data, &size, vlans);\n\n            dl_type = parse_ethertype(&data, &size);\n            miniflow_push_be16(mf, dl_type, dl_type);\n            miniflow_pad_to_64(mf, dl_type);\n            if (num_vlans > 0) {\n                miniflow_push_words_32(mf, vlans, vlans, num_vlans);\n            }\n\n        }\n    } else {\n        /* Take dl_type from packet_type. */\n        dl_type = pt_ns_type_be(packet_type);\n        miniflow_pad_from_64(mf, dl_type);\n        miniflow_push_be16(mf, dl_type, dl_type);\n        /* Do not push vlan_tci, pad instead */\n        miniflow_pad_to_64(mf, dl_type);\n    }\n\n    /* Parse mpls. */\n    if (OVS_UNLIKELY(eth_type_mpls(dl_type))) {\n        int count;\n        const void *mpls = data;\n\n        packet->l2_5_ofs = (char *)data - frame;\n        count = parse_mpls(&data, &size);\n        miniflow_push_words_32(mf, mpls_lse, mpls, count);\n    }\n\n    /* Network layer. */\n    packet->l3_ofs = (char *)data - frame;\n\n    nw_frag = 0;\n    if (OVS_LIKELY(dl_type == htons(ETH_TYPE_IP))) {\n        const struct ip_header *nh = data;\n        int ip_len;\n        uint16_t tot_len;\n\n        if (OVS_UNLIKELY(!ipv4_sanity_check(nh, size, &ip_len, &tot_len))) {\n            goto out;\n        }\n        dp_packet_set_l2_pad_size(packet, size - tot_len);\n        size = tot_len;   /* Never pull padding. */\n\n        /* Push both source and destination address at once. */\n        miniflow_push_words(mf, nw_src, &nh->ip_src, 1);\n        if (ct_nw_proto_p && !md->ct_orig_tuple_ipv6) {\n            *ct_nw_proto_p = md->ct_orig_tuple.ipv4.ipv4_proto;\n            if (*ct_nw_proto_p) {\n                miniflow_push_words(mf, ct_nw_src,\n                                    &md->ct_orig_tuple.ipv4.ipv4_src, 1);\n                ct_tp_src = md->ct_orig_tuple.ipv4.src_port;\n                ct_tp_dst = md->ct_orig_tuple.ipv4.dst_port;\n            }\n        }\n\n        miniflow_push_be32(mf, ipv6_label, 0); /* Padding for IPv4. */\n\n        nw_tos = nh->ip_tos;\n        nw_ttl = nh->ip_ttl;\n        nw_proto = nh->ip_proto;\n        nw_frag = ipv4_get_nw_frag(nh);\n        data_pull(&data, &size, ip_len);\n    } else if (dl_type == htons(ETH_TYPE_IPV6)) {\n        const struct ovs_16aligned_ip6_hdr *nh = data;\n        ovs_be32 tc_flow;\n        uint16_t plen;\n\n        if (OVS_UNLIKELY(!ipv6_sanity_check(nh, size))) {\n            goto out;\n        }\n        data_pull(&data, &size, sizeof *nh);\n\n        plen = ntohs(nh->ip6_plen);\n        dp_packet_set_l2_pad_size(packet, size - plen);\n        size = plen;   /* Never pull padding. */\n\n        miniflow_push_words(mf, ipv6_src, &nh->ip6_src,\n                            sizeof nh->ip6_src / 8);\n        miniflow_push_words(mf, ipv6_dst, &nh->ip6_dst,\n                            sizeof nh->ip6_dst / 8);\n        if (ct_nw_proto_p && md->ct_orig_tuple_ipv6) {\n            *ct_nw_proto_p = md->ct_orig_tuple.ipv6.ipv6_proto;\n            if (*ct_nw_proto_p) {\n                miniflow_push_words(mf, ct_ipv6_src,\n                                    &md->ct_orig_tuple.ipv6.ipv6_src,\n                                    2 *\n                                    sizeof md->ct_orig_tuple.ipv6.ipv6_src / 8);\n                ct_tp_src = md->ct_orig_tuple.ipv6.src_port;\n                ct_tp_dst = md->ct_orig_tuple.ipv6.dst_port;\n            }\n        }\n\n        tc_flow = get_16aligned_be32(&nh->ip6_flow);\n        nw_tos = ntohl(tc_flow) >> 20;\n        nw_ttl = nh->ip6_hlim;\n        nw_proto = nh->ip6_nxt;\n\n        const struct ovs_16aligned_ip6_frag *frag_hdr;\n        if (!parse_ipv6_ext_hdrs__(&data, &size, &nw_proto, &nw_frag,\n                                   &frag_hdr)) {\n            goto out;\n        }\n\n        /* This needs to be after the parse_ipv6_ext_hdrs__() call because it\n         * leaves the nw_frag word uninitialized. */\n        ASSERT_SEQUENTIAL(ipv6_label, nw_frag);\n        ovs_be32 label = tc_flow & htonl(IPV6_LABEL_MASK);\n        miniflow_push_be32(mf, ipv6_label, label);\n    } else {\n        if (dl_type == htons(ETH_TYPE_ARP) ||\n            dl_type == htons(ETH_TYPE_RARP)) {\n            struct eth_addr arp_buf[2];\n            const struct arp_eth_header *arp = (const struct arp_eth_header *)\n                data_try_pull(&data, &size, ARP_ETH_HEADER_LEN);\n\n            if (OVS_LIKELY(arp) && OVS_LIKELY(arp->ar_hrd == htons(1))\n                && OVS_LIKELY(arp->ar_pro == htons(ETH_TYPE_IP))\n                && OVS_LIKELY(arp->ar_hln == ETH_ADDR_LEN)\n                && OVS_LIKELY(arp->ar_pln == 4)) {\n                miniflow_push_be32(mf, nw_src,\n                                   get_16aligned_be32(&arp->ar_spa));\n                miniflow_push_be32(mf, nw_dst,\n                                   get_16aligned_be32(&arp->ar_tpa));\n\n                /* We only match on the lower 8 bits of the opcode. */\n                if (OVS_LIKELY(ntohs(arp->ar_op) <= 0xff)) {\n                    miniflow_push_be32(mf, ipv6_label, 0); /* Pad with ARP. */\n                    miniflow_push_be32(mf, nw_frag, htonl(ntohs(arp->ar_op)));\n                }\n\n                /* Must be adjacent. */\n                ASSERT_SEQUENTIAL(arp_sha, arp_tha);\n\n                arp_buf[0] = arp->ar_sha;\n                arp_buf[1] = arp->ar_tha;\n                miniflow_push_macs(mf, arp_sha, arp_buf);\n                miniflow_pad_to_64(mf, arp_tha);\n            }\n        } else if (dl_type == htons(ETH_TYPE_NSH)) {\n            struct ovs_key_nsh nsh;\n\n            if (OVS_LIKELY(parse_nsh(&data, &size, &nsh))) {\n                miniflow_push_words(mf, nsh, &nsh,\n                                    sizeof(struct ovs_key_nsh) /\n                                    sizeof(uint64_t));\n            }\n        }\n        goto out;\n    }\n\n    packet->l4_ofs = (char *)data - frame;\n    miniflow_push_be32(mf, nw_frag,\n                       bytes_to_be32(nw_frag, nw_tos, nw_ttl, nw_proto));\n\n    if (OVS_LIKELY(!(nw_frag & FLOW_NW_FRAG_LATER))) {\n        if (OVS_LIKELY(nw_proto == IPPROTO_TCP)) {\n            if (OVS_LIKELY(size >= TCP_HEADER_LEN)) {\n                const struct tcp_header *tcp = data;\n\n                miniflow_push_be32(mf, arp_tha.ea[2], 0);\n                miniflow_push_be32(mf, tcp_flags,\n                                   TCP_FLAGS_BE32(tcp->tcp_ctl));\n                miniflow_push_be16(mf, tp_src, tcp->tcp_src);\n                miniflow_push_be16(mf, tp_dst, tcp->tcp_dst);\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_UDP)) {\n            if (OVS_LIKELY(size >= UDP_HEADER_LEN)) {\n                const struct udp_header *udp = data;\n\n                miniflow_push_be16(mf, tp_src, udp->udp_src);\n                miniflow_push_be16(mf, tp_dst, udp->udp_dst);\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_SCTP)) {\n            if (OVS_LIKELY(size >= SCTP_HEADER_LEN)) {\n                const struct sctp_header *sctp = data;\n\n                miniflow_push_be16(mf, tp_src, sctp->sctp_src);\n                miniflow_push_be16(mf, tp_dst, sctp->sctp_dst);\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_ICMP)) {\n            if (OVS_LIKELY(size >= ICMP_HEADER_LEN)) {\n                const struct icmp_header *icmp = data;\n\n                miniflow_push_be16(mf, tp_src, htons(icmp->icmp_type));\n                miniflow_push_be16(mf, tp_dst, htons(icmp->icmp_code));\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_IGMP)) {\n            if (OVS_LIKELY(size >= IGMP_HEADER_LEN)) {\n                const struct igmp_header *igmp = data;\n\n                miniflow_push_be16(mf, tp_src, htons(igmp->igmp_type));\n                miniflow_push_be16(mf, tp_dst, htons(igmp->igmp_code));\n                miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n                miniflow_push_be32(mf, igmp_group_ip4,\n                                   get_16aligned_be32(&igmp->group));\n                miniflow_pad_to_64(mf, igmp_group_ip4);\n            }\n        } else if (OVS_LIKELY(nw_proto == IPPROTO_ICMPV6)) {\n            if (OVS_LIKELY(size >= sizeof(struct icmp6_hdr))) {\n                const struct in6_addr *nd_target;\n                struct eth_addr arp_buf[2];\n                /* This will populate whether we received Option 1\n                 * or Option 2. */\n                uint8_t opt_type;\n                /* This holds the ND Reserved field. */\n                uint32_t rso_flags;\n                const struct icmp6_hdr *icmp = data_pull(&data,\n                                               &size,ICMP6_HEADER_LEN);\n                if (parse_icmpv6(&data, &size, icmp,\n                                 &rso_flags, &nd_target, arp_buf, &opt_type)) {\n                    if (nd_target) {\n                        miniflow_push_words(mf, nd_target, nd_target,\n                                            sizeof *nd_target / sizeof(uint64_t));\n                    }\n                    miniflow_push_macs(mf, arp_sha, arp_buf);\n                    /* Populate options field and set the padding\n                     * accordingly. */\n                    if (opt_type != 0) {\n                        miniflow_push_be16(mf, tcp_flags, htons(opt_type));\n                        /* Pad to align with 64 bits.\n                         * This will zero out the pad3 field. */\n                        miniflow_pad_to_64(mf, tcp_flags);\n                    } else {\n                        /* Pad to align with 64 bits.\n                         * This will zero out the tcp_flags & pad3 field. */\n                        miniflow_pad_to_64(mf, arp_tha);\n                    }\n                    miniflow_push_be16(mf, tp_src, htons(icmp->icmp6_type));\n                    miniflow_push_be16(mf, tp_dst, htons(icmp->icmp6_code));\n                    miniflow_pad_to_64(mf, tp_dst);\n                    /* Fill ND reserved field. */\n                    miniflow_push_be32(mf, igmp_group_ip4, htonl(rso_flags));\n                    miniflow_pad_to_64(mf, igmp_group_ip4);\n                } else {\n                    /* ICMPv6 but not ND. */\n                    miniflow_push_be16(mf, tp_src, htons(icmp->icmp6_type));\n                    miniflow_push_be16(mf, tp_dst, htons(icmp->icmp6_code));\n                    miniflow_push_be16(mf, ct_tp_src, ct_tp_src);\n                    miniflow_push_be16(mf, ct_tp_dst, ct_tp_dst);\n                }\n            }\n        }\n    }\n out:\n    dst->map = mf.map;\n}\n\novs_be16\nparse_dl_type(const struct eth_header *data_, size_t size)\n{\n    const void *data = data_;\n    union flow_vlan_hdr vlans[FLOW_MAX_VLAN_HEADERS];\n\n    parse_vlan(&data, &size, vlans);\n\n    return parse_ethertype(&data, &size);\n}\n\n/* Parses and return the TCP flags in 'packet', converted to host byte order.\n * If 'packet' is not an Ethernet packet embedding TCP, returns 0.\n *\n * The caller must ensure that 'packet' is at least ETH_HEADER_LEN bytes\n * long.'*/\nuint16_t\nparse_tcp_flags(struct dp_packet *packet)\n{\n    const void *data = dp_packet_data(packet);\n    const char *frame = (const char *)data;\n    size_t size = dp_packet_size(packet);\n    ovs_be16 dl_type;\n    uint8_t nw_frag = 0, nw_proto = 0;\n\n    if (packet->packet_type != htonl(PT_ETH)) {\n        return 0;\n    }\n\n    dp_packet_reset_offsets(packet);\n\n    data_pull(&data, &size, ETH_ADDR_LEN * 2);\n    dl_type = parse_ethertype(&data, &size);\n    if (OVS_UNLIKELY(eth_type_mpls(dl_type))) {\n        packet->l2_5_ofs = (char *)data - frame;\n    }\n    if (OVS_LIKELY(dl_type == htons(ETH_TYPE_IP))) {\n        const struct ip_header *nh = data;\n        int ip_len;\n        uint16_t tot_len;\n\n        if (OVS_UNLIKELY(!ipv4_sanity_check(nh, size, &ip_len, &tot_len))) {\n            return 0;\n        }\n        dp_packet_set_l2_pad_size(packet, size - tot_len);\n        packet->l3_ofs = (uint16_t)((char *)nh - frame);\n        nw_proto = nh->ip_proto;\n        nw_frag = ipv4_get_nw_frag(nh);\n\n        size = tot_len;   /* Never pull padding. */\n        data_pull(&data, &size, ip_len);\n    } else if (dl_type == htons(ETH_TYPE_IPV6)) {\n        const struct ovs_16aligned_ip6_hdr *nh = data;\n        uint16_t plen;\n\n        if (OVS_UNLIKELY(!ipv6_sanity_check(nh, size))) {\n            return 0;\n        }\n        packet->l3_ofs = (uint16_t)((char *)nh - frame);\n        data_pull(&data, &size, sizeof *nh);\n\n        plen = ntohs(nh->ip6_plen); /* Never pull padding. */\n        dp_packet_set_l2_pad_size(packet, size - plen);\n        size = plen;\n        const struct ovs_16aligned_ip6_frag *frag_hdr;\n        if (!parse_ipv6_ext_hdrs__(&data, &size, &nw_proto, &nw_frag,\n            &frag_hdr)) {\n            return 0;\n        }\n        nw_proto = nh->ip6_nxt;\n    } else {\n        return 0;\n    }\n\n    packet->l4_ofs = (uint16_t)((char *)data - frame);\n    if (!(nw_frag & FLOW_NW_FRAG_LATER) && nw_proto == IPPROTO_TCP &&\n        size >= TCP_HEADER_LEN) {\n        const struct tcp_header *tcp = data;\n\n        return TCP_FLAGS(tcp->tcp_ctl);\n    }\n\n    return 0;\n}\n\n/* For every bit of a field that is wildcarded in 'wildcards', sets the\n * corresponding bit in 'flow' to zero. */\nvoid\nflow_zero_wildcards(struct flow *flow, const struct flow_wildcards *wildcards)\n{\n    uint64_t *flow_u64 = (uint64_t *) flow;\n    const uint64_t *wc_u64 = (const uint64_t *) &wildcards->masks;\n    size_t i;\n\n    for (i = 0; i < FLOW_U64S; i++) {\n        flow_u64[i] &= wc_u64[i];\n    }\n}\n\nvoid\nflow_unwildcard_tp_ports(const struct flow *flow, struct flow_wildcards *wc)\n{\n    if (flow->nw_proto != IPPROTO_ICMP) {\n        memset(&wc->masks.tp_src, 0xff, sizeof wc->masks.tp_src);\n        memset(&wc->masks.tp_dst, 0xff, sizeof wc->masks.tp_dst);\n    } else {\n        wc->masks.tp_src = htons(0xff);\n        wc->masks.tp_dst = htons(0xff);\n    }\n}\n\n/* Initializes 'flow_metadata' with the metadata found in 'flow'. */\nvoid\nflow_get_metadata(const struct flow *flow, struct match *flow_metadata)\n{\n    int i;\n\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n\n    match_init_catchall(flow_metadata);\n    if (flow->tunnel.tun_id != htonll(0)) {\n        match_set_tun_id(flow_metadata, flow->tunnel.tun_id);\n    }\n    if (flow->tunnel.flags & FLOW_TNL_PUB_F_MASK) {\n        match_set_tun_flags(flow_metadata,\n                            flow->tunnel.flags & FLOW_TNL_PUB_F_MASK);\n    }\n    if (flow->tunnel.ip_src) {\n        match_set_tun_src(flow_metadata, flow->tunnel.ip_src);\n    }\n    if (flow->tunnel.ip_dst) {\n        match_set_tun_dst(flow_metadata, flow->tunnel.ip_dst);\n    }\n    if (ipv6_addr_is_set(&flow->tunnel.ipv6_src)) {\n        match_set_tun_ipv6_src(flow_metadata, &flow->tunnel.ipv6_src);\n    }\n    if (ipv6_addr_is_set(&flow->tunnel.ipv6_dst)) {\n        match_set_tun_ipv6_dst(flow_metadata, &flow->tunnel.ipv6_dst);\n    }\n    if (flow->tunnel.gbp_id != htons(0)) {\n        match_set_tun_gbp_id(flow_metadata, flow->tunnel.gbp_id);\n    }\n    if (flow->tunnel.gbp_flags) {\n        match_set_tun_gbp_flags(flow_metadata, flow->tunnel.gbp_flags);\n    }\n    if (flow->tunnel.erspan_ver) {\n        match_set_tun_erspan_ver(flow_metadata, flow->tunnel.erspan_ver);\n    }\n    if (flow->tunnel.erspan_idx) {\n        match_set_tun_erspan_idx(flow_metadata, flow->tunnel.erspan_idx);\n    }\n    if (flow->tunnel.erspan_dir) {\n        match_set_tun_erspan_dir(flow_metadata, flow->tunnel.erspan_dir);\n    }\n    if (flow->tunnel.erspan_hwid) {\n        match_set_tun_erspan_hwid(flow_metadata, flow->tunnel.erspan_hwid);\n    }\n    tun_metadata_get_fmd(&flow->tunnel, flow_metadata);\n    if (flow->metadata != htonll(0)) {\n        match_set_metadata(flow_metadata, flow->metadata);\n    }\n\n    for (i = 0; i < FLOW_N_REGS; i++) {\n        if (flow->regs[i]) {\n            match_set_reg(flow_metadata, i, flow->regs[i]);\n        }\n    }\n\n    if (flow->pkt_mark != 0) {\n        match_set_pkt_mark(flow_metadata, flow->pkt_mark);\n    }\n\n    match_set_in_port(flow_metadata, flow->in_port.ofp_port);\n    if (flow->packet_type != htonl(PT_ETH)) {\n        match_set_packet_type(flow_metadata, flow->packet_type);\n    }\n\n    if (flow->ct_state != 0) {\n        match_set_ct_state(flow_metadata, flow->ct_state);\n        /* Match dl_type since it is required for the later interpretation of\n         * the conntrack metadata. */\n        match_set_dl_type(flow_metadata, flow->dl_type);\n        if (is_ct_valid(flow, NULL, NULL) && flow->ct_nw_proto != 0) {\n            if (flow->dl_type == htons(ETH_TYPE_IP)) {\n                match_set_ct_nw_src(flow_metadata, flow->ct_nw_src);\n                match_set_ct_nw_dst(flow_metadata, flow->ct_nw_dst);\n                match_set_ct_nw_proto(flow_metadata, flow->ct_nw_proto);\n                match_set_ct_tp_src(flow_metadata, flow->ct_tp_src);\n                match_set_ct_tp_dst(flow_metadata, flow->ct_tp_dst);\n            } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n                match_set_ct_ipv6_src(flow_metadata, &flow->ct_ipv6_src);\n                match_set_ct_ipv6_dst(flow_metadata, &flow->ct_ipv6_dst);\n                match_set_ct_nw_proto(flow_metadata, flow->ct_nw_proto);\n                match_set_ct_tp_src(flow_metadata, flow->ct_tp_src);\n                match_set_ct_tp_dst(flow_metadata, flow->ct_tp_dst);\n            }\n        }\n    }\n    if (flow->ct_zone != 0) {\n        match_set_ct_zone(flow_metadata, flow->ct_zone);\n    }\n    if (flow->ct_mark != 0) {\n        match_set_ct_mark(flow_metadata, flow->ct_mark);\n    }\n    if (!ovs_u128_is_zero(flow->ct_label)) {\n        match_set_ct_label(flow_metadata, flow->ct_label);\n    }\n}\n\nconst char *\nct_state_to_string(uint32_t state)\n{\n    switch (state) {\n#define CS_STATE(ENUM, INDEX, NAME) case CS_##ENUM: return NAME;\n        CS_STATES\n#undef CS_STATE\n    default:\n        return NULL;\n    }\n}\n\nuint32_t\nct_state_from_string(const char *s)\n{\n#define CS_STATE(ENUM, INDEX, NAME) \\\n    if (!strcmp(s, NAME)) {         \\\n        return CS_##ENUM;           \\\n    }\n    CS_STATES\n#undef CS_STATE\n    return 0;\n}\n\n/* Parses conntrack state from 'state_str'.  If it is parsed successfully,\n * stores the parsed ct_state in 'ct_state', and returns true.  Otherwise,\n * returns false, and reports error message in 'ds'. */\nbool\nparse_ct_state(const char *state_str, uint32_t default_state,\n               uint32_t *ct_state, struct ds *ds)\n{\n    uint32_t state = default_state;\n    char *state_s = xstrdup(state_str);\n    char *save_ptr = NULL;\n\n    for (char *cs = strtok_r(state_s, \", \", &save_ptr); cs;\n         cs = strtok_r(NULL, \", \", &save_ptr)) {\n        uint32_t bit = ct_state_from_string(cs);\n        if (!bit) {\n            ds_put_format(ds, \"%s: unknown connection tracking state flag\",\n                          cs);\n            free(state_s);\n            return false;\n        }\n        state |= bit;\n    }\n\n    *ct_state = state;\n    free(state_s);\n\n    return true;\n}\n\n/* Checks the given conntrack state 'state' according to the constraints\n * listed in ovs-fields (7).  Returns true if it is valid.  Otherwise, returns\n * false, and reports error in 'ds'. */\nbool\nvalidate_ct_state(uint32_t state, struct ds *ds)\n{\n    bool valid_ct_state = true;\n    struct ds d_str = DS_EMPTY_INITIALIZER;\n\n    format_flags(&d_str, ct_state_to_string, state, '|');\n\n    if (state && !(state & CS_TRACKED)) {\n        ds_put_format(ds, \"%s: invalid connection state: \"\n                      \"If \\\"trk\\\" is unset, no other flags are set\\n\",\n                      ds_cstr(&d_str));\n        valid_ct_state = false;\n    }\n    if (state & CS_INVALID && state & ~(CS_TRACKED | CS_INVALID)) {\n        ds_put_format(ds, \"%s: invalid connection state: \"\n                      \"when \\\"inv\\\" is set, only \\\"trk\\\" may also be set\\n\",\n                      ds_cstr(&d_str));\n        valid_ct_state = false;\n    }\n    if (state & CS_NEW && state & CS_ESTABLISHED) {\n        ds_put_format(ds, \"%s: invalid connection state: \"\n                      \"\\\"new\\\" and \\\"est\\\" are mutually exclusive\\n\",\n                      ds_cstr(&d_str));\n        valid_ct_state = false;\n    }\n    if (state & CS_NEW && state & CS_REPLY_DIR) {\n        ds_put_format(ds, \"%s: invalid connection state: \"\n                      \"\\\"new\\\" and \\\"rpy\\\" are mutually exclusive\\n\",\n                      ds_cstr(&d_str));\n        valid_ct_state = false;\n    }\n\n    ds_destroy(&d_str);\n    return valid_ct_state;\n}\n\n/* Clears the fields in 'flow' associated with connection tracking. */\nvoid\nflow_clear_conntrack(struct flow *flow)\n{\n    flow->ct_state = 0;\n    flow->ct_zone = 0;\n    flow->ct_mark = 0;\n    flow->ct_label = OVS_U128_ZERO;\n\n    flow->ct_nw_proto = 0;\n    flow->ct_tp_src = 0;\n    flow->ct_tp_dst = 0;\n    if (flow->dl_type == htons(ETH_TYPE_IP)) {\n        flow->ct_nw_src = 0;\n        flow->ct_nw_dst = 0;\n    } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n        memset(&flow->ct_ipv6_src, 0, sizeof flow->ct_ipv6_src);\n        memset(&flow->ct_ipv6_dst, 0, sizeof flow->ct_ipv6_dst);\n    }\n}\n\nchar *\nflow_to_string(const struct flow *flow,\n               const struct ofputil_port_map *port_map)\n{\n    struct ds ds = DS_EMPTY_INITIALIZER;\n    flow_format(&ds, flow, port_map);\n    return ds_cstr(&ds);\n}\n\nconst char *\nflow_tun_flag_to_string(uint32_t flags)\n{\n    switch (flags) {\n    case FLOW_TNL_F_DONT_FRAGMENT:\n        return \"df\";\n    case FLOW_TNL_F_CSUM:\n        return \"csum\";\n    case FLOW_TNL_F_KEY:\n        return \"key\";\n    case FLOW_TNL_F_OAM:\n        return \"oam\";\n    default:\n        return NULL;\n    }\n}\n\nvoid\nformat_flags(struct ds *ds, const char *(*bit_to_string)(uint32_t),\n             uint32_t flags, char del)\n{\n    uint32_t bad = 0;\n\n    if (!flags) {\n        ds_put_char(ds, '0');\n        return;\n    }\n    while (flags) {\n        uint32_t bit = rightmost_1bit(flags);\n        const char *s;\n\n        s = bit_to_string(bit);\n        if (s) {\n            ds_put_format(ds, \"%s%c\", s, del);\n        } else {\n            bad |= bit;\n        }\n\n        flags &= ~bit;\n    }\n\n    if (bad) {\n        ds_put_format(ds, \"0x%\"PRIx32\"%c\", bad, del);\n    }\n    ds_chomp(ds, del);\n}\n\nvoid\nformat_flags_masked(struct ds *ds, const char *name,\n                    const char *(*bit_to_string)(uint32_t), uint32_t flags,\n                    uint32_t mask, uint32_t max_mask)\n{\n    if (name) {\n        ds_put_format(ds, \"%s%s=%s\", colors.param, name, colors.end);\n    }\n\n    if (mask == max_mask) {\n        format_flags(ds, bit_to_string, flags, '|');\n        return;\n    }\n\n    if (!mask) {\n        ds_put_cstr(ds, \"0/0\");\n        return;\n    }\n\n    while (mask) {\n        uint32_t bit = rightmost_1bit(mask);\n        const char *s = bit_to_string(bit);\n\n        ds_put_format(ds, \"%s%s\", (flags & bit) ? \"+\" : \"-\",\n                      s ? s : \"[Unknown]\");\n        mask &= ~bit;\n    }\n}\n\nstatic void\nput_u16_masked(struct ds *s, uint16_t value, uint16_t mask)\n{\n    if (!mask) {\n        ds_put_char(s, '*');\n    } else {\n        if (value > 9) {\n            ds_put_format(s, \"0x%\"PRIx16, value);\n        } else {\n            ds_put_format(s, \"%\"PRIu16, value);\n        }\n\n        if (mask != UINT16_MAX) {\n            ds_put_format(s, \"/0x%\"PRIx16, mask);\n        }\n    }\n}\n\nvoid\nformat_packet_type_masked(struct ds *s, ovs_be32 value, ovs_be32 mask)\n{\n    if (value == htonl(PT_ETH) && mask == OVS_BE32_MAX) {\n        ds_put_cstr(s, \"eth\");\n    } else {\n        ds_put_cstr(s, \"packet_type=(\");\n        put_u16_masked(s, pt_ns(value), pt_ns(mask));\n        ds_put_char(s, ',');\n        put_u16_masked(s, pt_ns_type(value), pt_ns_type(mask));\n        ds_put_char(s, ')');\n    }\n}\n\n/* Scans a string 's' of flags to determine their numerical value and\n * returns the number of characters parsed using 'bit_to_string' to\n * lookup flag names. Scanning continues until the character 'end' is\n * reached.\n *\n * In the event of a failure, a negative error code will be returned. In\n * addition, if 'res_string' is non-NULL then a descriptive string will\n * be returned incorporating the identifying string 'field_name'. This\n * error string must be freed by the caller.\n *\n * Upon success, the flag values will be stored in 'res_flags' and\n * optionally 'res_mask', if it is non-NULL (if it is NULL then any masks\n * present in the original string will be considered an error). The\n * caller may restrict the acceptable set of values through the mask\n * 'allowed'. */\nint\nparse_flags(const char *s, const char *(*bit_to_string)(uint32_t),\n            char end, const char *field_name, char **res_string,\n            uint32_t *res_flags, uint32_t allowed, uint32_t *res_mask)\n{\n    uint32_t result = 0;\n    int n;\n\n    /* Parse masked flags in numeric format? */\n    if (res_mask && ovs_scan(s, \"%\"SCNi32\"/%\"SCNi32\"%n\",\n                             res_flags, res_mask, &n) && n > 0) {\n        if (*res_flags & ~allowed || *res_mask & ~allowed) {\n            goto unknown;\n        }\n        return n;\n    }\n\n    n = 0;\n\n    if (res_mask && (*s == '+' || *s == '-')) {\n        uint32_t flags = 0, mask = 0;\n\n        /* Parse masked flags. */\n        while (s[0] != end) {\n            bool set;\n            uint32_t bit;\n            size_t len;\n\n            if (s[0] == '+') {\n                set = true;\n            } else if (s[0] == '-') {\n                set = false;\n            } else {\n                if (res_string) {\n                    *res_string = xasprintf(\"%s: %s must be preceded by '+' \"\n                                            \"(for SET) or '-' (NOT SET)\", s,\n                                            field_name);\n                }\n                return -EINVAL;\n            }\n            s++;\n            n++;\n\n            for (bit = 1; bit; bit <<= 1) {\n                const char *fname = bit_to_string(bit);\n\n                if (!fname) {\n                    continue;\n                }\n\n                len = strlen(fname);\n                if (strncmp(s, fname, len) ||\n                    (s[len] != '+' && s[len] != '-' && s[len] != end)) {\n                    continue;\n                }\n\n                if (mask & bit) {\n                    /* bit already set. */\n                    if (res_string) {\n                        *res_string = xasprintf(\"%s: Each %s flag can be \"\n                                                \"specified only once\", s,\n                                                field_name);\n                    }\n                    return -EINVAL;\n                }\n                if (!(bit & allowed)) {\n                    goto unknown;\n                }\n                if (set) {\n                   flags |= bit;\n                }\n                mask |= bit;\n                break;\n            }\n\n            if (!bit) {\n                goto unknown;\n            }\n            s += len;\n            n += len;\n        }\n\n        *res_flags = flags;\n        *res_mask = mask;\n        return n;\n    }\n\n    /* Parse unmasked flags.  If a flag is present, it is set, otherwise\n     * it is not set. */\n    while (s[n] != end) {\n        unsigned long long int flags;\n        uint32_t bit;\n        int n0;\n\n        if (ovs_scan(&s[n], \"%lli%n\", &flags, &n0)) {\n            if (flags & ~allowed) {\n                goto unknown;\n            }\n            n += n0 + (s[n + n0] == '|');\n            result |= flags;\n            continue;\n        }\n\n        for (bit = 1; bit; bit <<= 1) {\n            const char *name = bit_to_string(bit);\n            size_t len;\n\n            if (!name) {\n                continue;\n            }\n\n            len = strlen(name);\n            if (!strncmp(s + n, name, len) &&\n                (s[n + len] == '|' || s[n + len] == end)) {\n                if (!(bit & allowed)) {\n                    goto unknown;\n                }\n                result |= bit;\n                n += len + (s[n + len] == '|');\n                break;\n            }\n        }\n\n        if (!bit) {\n            goto unknown;\n        }\n    }\n\n    *res_flags = result;\n    if (res_mask) {\n        *res_mask = UINT32_MAX;\n    }\n    if (res_string) {\n        *res_string = NULL;\n    }\n    return n;\n\nunknown:\n    if (res_string) {\n        *res_string = xasprintf(\"%s: unknown %s flag(s)\", s, field_name);\n    }\n    return -EINVAL;\n}\n\nvoid\nflow_format(struct ds *ds,\n            const struct flow *flow, const struct ofputil_port_map *port_map)\n{\n    struct match match;\n    struct flow_wildcards *wc = &match.wc;\n\n    match_wc_init(&match, flow);\n\n    /* As this function is most often used for formatting a packet in a\n     * packet-in message, skip formatting the packet context fields that are\n     * all-zeroes to make the print-out easier on the eyes.  This means that a\n     * missing context field implies a zero value for that field.  This is\n     * similar to OpenFlow encoding of these fields, as the specification\n     * states that all-zeroes context fields should not be encoded in the\n     * packet-in messages. */\n    if (!flow->in_port.ofp_port) {\n        WC_UNMASK_FIELD(wc, in_port);\n    }\n    if (!flow->skb_priority) {\n        WC_UNMASK_FIELD(wc, skb_priority);\n    }\n    if (!flow->pkt_mark) {\n        WC_UNMASK_FIELD(wc, pkt_mark);\n    }\n    if (!flow->recirc_id) {\n        WC_UNMASK_FIELD(wc, recirc_id);\n    }\n    if (!flow->dp_hash) {\n        WC_UNMASK_FIELD(wc, dp_hash);\n    }\n    if (!flow->ct_state) {\n        WC_UNMASK_FIELD(wc, ct_state);\n    }\n    if (!flow->ct_zone) {\n        WC_UNMASK_FIELD(wc, ct_zone);\n    }\n    if (!flow->ct_mark) {\n        WC_UNMASK_FIELD(wc, ct_mark);\n    }\n    if (ovs_u128_is_zero(flow->ct_label)) {\n        WC_UNMASK_FIELD(wc, ct_label);\n    }\n    if (!is_ct_valid(flow, &match.wc, NULL) || !flow->ct_nw_proto) {\n        WC_UNMASK_FIELD(wc, ct_nw_proto);\n        WC_UNMASK_FIELD(wc, ct_tp_src);\n        WC_UNMASK_FIELD(wc, ct_tp_dst);\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            WC_UNMASK_FIELD(wc, ct_nw_src);\n            WC_UNMASK_FIELD(wc, ct_nw_dst);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            WC_UNMASK_FIELD(wc, ct_ipv6_src);\n            WC_UNMASK_FIELD(wc, ct_ipv6_dst);\n        }\n    }\n    for (int i = 0; i < FLOW_N_REGS; i++) {\n        if (!flow->regs[i]) {\n            WC_UNMASK_FIELD(wc, regs[i]);\n        }\n    }\n    if (!flow->metadata) {\n        WC_UNMASK_FIELD(wc, metadata);\n    }\n\n    match_format(&match, port_map, ds, OFP_DEFAULT_PRIORITY);\n}\n\nvoid\nflow_print(FILE *stream,\n           const struct flow *flow, const struct ofputil_port_map *port_map)\n{\n    char *s = flow_to_string(flow, port_map);\n    fputs(s, stream);\n    free(s);\n}\n\f\n/* flow_wildcards functions. */\n\n/* Initializes 'wc' as a set of wildcards that matches every packet. */\nvoid\nflow_wildcards_init_catchall(struct flow_wildcards *wc)\n{\n    memset(&wc->masks, 0, sizeof wc->masks);\n}\n\n/* Converts a flow into flow wildcards.  It sets the wildcard masks based on\n * the packet headers extracted to 'flow'.  It will not set the mask for fields\n * that do not make sense for the packet type.  OpenFlow-only metadata is\n * wildcarded, but other metadata is unconditionally exact-matched. */\nvoid\nflow_wildcards_init_for_packet(struct flow_wildcards *wc,\n                               const struct flow *flow)\n{\n    ovs_be16 dl_type = OVS_BE16_MAX;\n\n    memset(&wc->masks, 0x0, sizeof wc->masks);\n\n    /* Update this function whenever struct flow changes. */\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n\n    if (flow_tnl_dst_is_set(&flow->tunnel)) {\n        if (flow->tunnel.flags & FLOW_TNL_F_KEY) {\n            WC_MASK_FIELD(wc, tunnel.tun_id);\n        }\n        WC_MASK_FIELD(wc, tunnel.ip_src);\n        WC_MASK_FIELD(wc, tunnel.ip_dst);\n        WC_MASK_FIELD(wc, tunnel.ipv6_src);\n        WC_MASK_FIELD(wc, tunnel.ipv6_dst);\n        WC_MASK_FIELD(wc, tunnel.flags);\n        WC_MASK_FIELD(wc, tunnel.ip_tos);\n        WC_MASK_FIELD(wc, tunnel.ip_ttl);\n        WC_MASK_FIELD(wc, tunnel.tp_src);\n        WC_MASK_FIELD(wc, tunnel.tp_dst);\n        WC_MASK_FIELD(wc, tunnel.gbp_id);\n        WC_MASK_FIELD(wc, tunnel.gbp_flags);\n        WC_MASK_FIELD(wc, tunnel.erspan_ver);\n        WC_MASK_FIELD(wc, tunnel.erspan_idx);\n        WC_MASK_FIELD(wc, tunnel.erspan_dir);\n        WC_MASK_FIELD(wc, tunnel.erspan_hwid);\n\n        if (!(flow->tunnel.flags & FLOW_TNL_F_UDPIF)) {\n            if (flow->tunnel.metadata.present.map) {\n                wc->masks.tunnel.metadata.present.map =\n                                              flow->tunnel.metadata.present.map;\n                WC_MASK_FIELD(wc, tunnel.metadata.opts.u8);\n                WC_MASK_FIELD(wc, tunnel.metadata.tab);\n            }\n        } else {\n            WC_MASK_FIELD(wc, tunnel.metadata.present.len);\n            memset(wc->masks.tunnel.metadata.opts.gnv, 0xff,\n                   flow->tunnel.metadata.present.len);\n        }\n    } else if (flow->tunnel.tun_id) {\n        WC_MASK_FIELD(wc, tunnel.tun_id);\n    }\n\n    /* metadata, regs, and conj_id wildcarded. */\n\n    WC_MASK_FIELD(wc, skb_priority);\n    WC_MASK_FIELD(wc, pkt_mark);\n    WC_MASK_FIELD(wc, ct_state);\n    WC_MASK_FIELD(wc, ct_zone);\n    WC_MASK_FIELD(wc, ct_mark);\n    WC_MASK_FIELD(wc, ct_label);\n    WC_MASK_FIELD(wc, recirc_id);\n    WC_MASK_FIELD(wc, dp_hash);\n    WC_MASK_FIELD(wc, in_port);\n\n    /* actset_output wildcarded. */\n\n    WC_MASK_FIELD(wc, packet_type);\n    if (flow->packet_type == htonl(PT_ETH)) {\n        WC_MASK_FIELD(wc, dl_dst);\n        WC_MASK_FIELD(wc, dl_src);\n        WC_MASK_FIELD(wc, dl_type);\n        /* No need to set mask of inner VLANs that don't exist. */\n        for (int i = 0; i < FLOW_MAX_VLAN_HEADERS; i++) {\n            /* Always show the first zero VLAN. */\n            WC_MASK_FIELD(wc, vlans[i]);\n            if (flow->vlans[i].tci == htons(0)) {\n                break;\n            }\n        }\n        dl_type = flow->dl_type;\n    } else {\n        dl_type = pt_ns_type_be(flow->packet_type);\n    }\n\n    if (dl_type == htons(ETH_TYPE_IP)) {\n        WC_MASK_FIELD(wc, nw_src);\n        WC_MASK_FIELD(wc, nw_dst);\n        WC_MASK_FIELD(wc, ct_nw_src);\n        WC_MASK_FIELD(wc, ct_nw_dst);\n    } else if (dl_type == htons(ETH_TYPE_IPV6)) {\n        WC_MASK_FIELD(wc, ipv6_src);\n        WC_MASK_FIELD(wc, ipv6_dst);\n        WC_MASK_FIELD(wc, ipv6_label);\n        if (is_nd(flow, wc)) {\n            WC_MASK_FIELD(wc, arp_sha);\n            WC_MASK_FIELD(wc, arp_tha);\n            WC_MASK_FIELD(wc, nd_target);\n        } else {\n            WC_MASK_FIELD(wc, ct_ipv6_src);\n            WC_MASK_FIELD(wc, ct_ipv6_dst);\n        }\n    } else if (dl_type == htons(ETH_TYPE_ARP) ||\n               dl_type == htons(ETH_TYPE_RARP)) {\n        WC_MASK_FIELD(wc, nw_src);\n        WC_MASK_FIELD(wc, nw_dst);\n        WC_MASK_FIELD(wc, nw_proto);\n        WC_MASK_FIELD(wc, arp_sha);\n        WC_MASK_FIELD(wc, arp_tha);\n        return;\n    } else if (eth_type_mpls(dl_type)) {\n        for (int i = 0; i < FLOW_MAX_MPLS_LABELS; i++) {\n            WC_MASK_FIELD(wc, mpls_lse[i]);\n            if (flow->mpls_lse[i] & htonl(MPLS_BOS_MASK)) {\n                break;\n            }\n        }\n        return;\n    } else if (flow->dl_type == htons(ETH_TYPE_NSH)) {\n        WC_MASK_FIELD(wc, nsh.flags);\n        WC_MASK_FIELD(wc, nsh.ttl);\n        WC_MASK_FIELD(wc, nsh.mdtype);\n        WC_MASK_FIELD(wc, nsh.np);\n        WC_MASK_FIELD(wc, nsh.path_hdr);\n        WC_MASK_FIELD(wc, nsh.context);\n    } else {\n        return; /* Unknown ethertype. */\n    }\n\n    /* IPv4 or IPv6. */\n    WC_MASK_FIELD(wc, nw_frag);\n    WC_MASK_FIELD(wc, nw_tos);\n    WC_MASK_FIELD(wc, nw_ttl);\n    WC_MASK_FIELD(wc, nw_proto);\n    WC_MASK_FIELD(wc, ct_nw_proto);\n    WC_MASK_FIELD(wc, ct_tp_src);\n    WC_MASK_FIELD(wc, ct_tp_dst);\n\n    /* No transport layer header in later fragments. */\n    if (!(flow->nw_frag & FLOW_NW_FRAG_LATER) &&\n        (flow->nw_proto == IPPROTO_ICMP ||\n         flow->nw_proto == IPPROTO_ICMPV6 ||\n         flow->nw_proto == IPPROTO_TCP ||\n         flow->nw_proto == IPPROTO_UDP ||\n         flow->nw_proto == IPPROTO_SCTP ||\n         flow->nw_proto == IPPROTO_IGMP)) {\n        WC_MASK_FIELD(wc, tp_src);\n        WC_MASK_FIELD(wc, tp_dst);\n\n        if (flow->nw_proto == IPPROTO_TCP) {\n            WC_MASK_FIELD(wc, tcp_flags);\n        } else if (flow->nw_proto == IPPROTO_IGMP) {\n            WC_MASK_FIELD(wc, igmp_group_ip4);\n        }\n    }\n}\n\n/* Return a map of possible fields for a packet of the same type as 'flow'.\n * Including extra bits in the returned mask is not wrong, it is just less\n * optimal.\n *\n * This is a less precise version of flow_wildcards_init_for_packet() above. */\nvoid\nflow_wc_map(const struct flow *flow, struct flowmap *map)\n{\n    /* Update this function whenever struct flow changes. */\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n\n    flowmap_init(map);\n\n    if (flow_tnl_dst_is_set(&flow->tunnel)) {\n        FLOWMAP_SET__(map, tunnel, offsetof(struct flow_tnl, metadata));\n        if (!(flow->tunnel.flags & FLOW_TNL_F_UDPIF)) {\n            if (flow->tunnel.metadata.present.map) {\n                FLOWMAP_SET(map, tunnel.metadata);\n            }\n        } else {\n            FLOWMAP_SET(map, tunnel.metadata.present.len);\n            FLOWMAP_SET__(map, tunnel.metadata.opts.gnv,\n                          flow->tunnel.metadata.present.len);\n        }\n    }\n\n    /* Metadata fields that can appear on packet input. */\n    FLOWMAP_SET(map, skb_priority);\n    FLOWMAP_SET(map, pkt_mark);\n    FLOWMAP_SET(map, recirc_id);\n    FLOWMAP_SET(map, dp_hash);\n    FLOWMAP_SET(map, in_port);\n    FLOWMAP_SET(map, dl_dst);\n    FLOWMAP_SET(map, dl_src);\n    FLOWMAP_SET(map, dl_type);\n    FLOWMAP_SET(map, vlans);\n    FLOWMAP_SET(map, ct_state);\n    FLOWMAP_SET(map, ct_zone);\n    FLOWMAP_SET(map, ct_mark);\n    FLOWMAP_SET(map, ct_label);\n    FLOWMAP_SET(map, packet_type);\n\n    /* Ethertype-dependent fields. */\n    if (OVS_LIKELY(flow->dl_type == htons(ETH_TYPE_IP))) {\n        FLOWMAP_SET(map, nw_src);\n        FLOWMAP_SET(map, nw_dst);\n        FLOWMAP_SET(map, nw_proto);\n        FLOWMAP_SET(map, nw_frag);\n        FLOWMAP_SET(map, nw_tos);\n        FLOWMAP_SET(map, nw_ttl);\n        FLOWMAP_SET(map, tp_src);\n        FLOWMAP_SET(map, tp_dst);\n        FLOWMAP_SET(map, ct_nw_proto);\n        FLOWMAP_SET(map, ct_nw_src);\n        FLOWMAP_SET(map, ct_nw_dst);\n        FLOWMAP_SET(map, ct_tp_src);\n        FLOWMAP_SET(map, ct_tp_dst);\n\n        if (OVS_UNLIKELY(flow->nw_proto == IPPROTO_IGMP)) {\n            FLOWMAP_SET(map, igmp_group_ip4);\n        } else {\n            FLOWMAP_SET(map, tcp_flags);\n        }\n    } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n        FLOWMAP_SET(map, ipv6_src);\n        FLOWMAP_SET(map, ipv6_dst);\n        FLOWMAP_SET(map, ipv6_label);\n        FLOWMAP_SET(map, nw_proto);\n        FLOWMAP_SET(map, nw_frag);\n        FLOWMAP_SET(map, nw_tos);\n        FLOWMAP_SET(map, nw_ttl);\n        FLOWMAP_SET(map, tp_src);\n        FLOWMAP_SET(map, tp_dst);\n\n        if (OVS_UNLIKELY(is_nd(flow, NULL))) {\n            FLOWMAP_SET(map, nd_target);\n            FLOWMAP_SET(map, arp_sha);\n            FLOWMAP_SET(map, arp_tha);\n            FLOWMAP_SET(map, tcp_flags);\n            FLOWMAP_SET(map, igmp_group_ip4);\n        } else {\n            FLOWMAP_SET(map, ct_nw_proto);\n            FLOWMAP_SET(map, ct_ipv6_src);\n            FLOWMAP_SET(map, ct_ipv6_dst);\n            FLOWMAP_SET(map, ct_tp_src);\n            FLOWMAP_SET(map, ct_tp_dst);\n            FLOWMAP_SET(map, tcp_flags);\n        }\n    } else if (eth_type_mpls(flow->dl_type)) {\n        FLOWMAP_SET(map, mpls_lse);\n    } else if (flow->dl_type == htons(ETH_TYPE_ARP) ||\n               flow->dl_type == htons(ETH_TYPE_RARP)) {\n        FLOWMAP_SET(map, nw_src);\n        FLOWMAP_SET(map, nw_dst);\n        FLOWMAP_SET(map, nw_proto);\n        FLOWMAP_SET(map, arp_sha);\n        FLOWMAP_SET(map, arp_tha);\n    } else if (flow->dl_type == htons(ETH_TYPE_NSH)) {\n        FLOWMAP_SET(map, nsh.flags);\n        FLOWMAP_SET(map, nsh.mdtype);\n        FLOWMAP_SET(map, nsh.np);\n        FLOWMAP_SET(map, nsh.path_hdr);\n        FLOWMAP_SET(map, nsh.context);\n    }\n}\n\n/* Clear the metadata and register wildcard masks. They are not packet\n * header fields. */\nvoid\nflow_wildcards_clear_non_packet_fields(struct flow_wildcards *wc)\n{\n    /* Update this function whenever struct flow changes. */\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n\n    memset(&wc->masks.metadata, 0, sizeof wc->masks.metadata);\n    memset(&wc->masks.regs, 0, sizeof wc->masks.regs);\n    wc->masks.actset_output = 0;\n    wc->masks.conj_id = 0;\n}\n\n/* Returns true if 'wc' matches every packet, false if 'wc' fixes any bits or\n * fields. */\nbool\nflow_wildcards_is_catchall(const struct flow_wildcards *wc)\n{\n    const uint64_t *wc_u64 = (const uint64_t *) &wc->masks;\n    size_t i;\n\n    for (i = 0; i < FLOW_U64S; i++) {\n        if (wc_u64[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/* Sets 'dst' as the bitwise AND of wildcards in 'src1' and 'src2'.\n * That is, a bit or a field is wildcarded in 'dst' if it is wildcarded\n * in 'src1' or 'src2' or both.  */\nvoid\nflow_wildcards_and(struct flow_wildcards *dst,\n                   const struct flow_wildcards *src1,\n                   const struct flow_wildcards *src2)\n{\n    uint64_t *dst_u64 = (uint64_t *) &dst->masks;\n    const uint64_t *src1_u64 = (const uint64_t *) &src1->masks;\n    const uint64_t *src2_u64 = (const uint64_t *) &src2->masks;\n    size_t i;\n\n    for (i = 0; i < FLOW_U64S; i++) {\n        dst_u64[i] = src1_u64[i] & src2_u64[i];\n    }\n}\n\n/* Sets 'dst' as the bitwise OR of wildcards in 'src1' and 'src2'.  That\n * is, a bit or a field is wildcarded in 'dst' if it is neither\n * wildcarded in 'src1' nor 'src2'. */\nvoid\nflow_wildcards_or(struct flow_wildcards *dst,\n                  const struct flow_wildcards *src1,\n                  const struct flow_wildcards *src2)\n{\n    uint64_t *dst_u64 = (uint64_t *) &dst->masks;\n    const uint64_t *src1_u64 = (const uint64_t *) &src1->masks;\n    const uint64_t *src2_u64 = (const uint64_t *) &src2->masks;\n    size_t i;\n\n    for (i = 0; i < FLOW_U64S; i++) {\n        dst_u64[i] = src1_u64[i] | src2_u64[i];\n    }\n}\n\n/* Returns a hash of the wildcards in 'wc'. */\nuint32_t\nflow_wildcards_hash(const struct flow_wildcards *wc, uint32_t basis)\n{\n    return flow_hash(&wc->masks, basis);\n}\n\n/* Returns true if 'a' and 'b' represent the same wildcards, false if they are\n * different. */\nbool\nflow_wildcards_equal(const struct flow_wildcards *a,\n                     const struct flow_wildcards *b)\n{\n    return flow_equal(&a->masks, &b->masks);\n}\n\n/* Returns true if at least one bit or field is wildcarded in 'a' but not in\n * 'b', false otherwise. */\nbool\nflow_wildcards_has_extra(const struct flow_wildcards *a,\n                         const struct flow_wildcards *b)\n{\n    const uint64_t *a_u64 = (const uint64_t *) &a->masks;\n    const uint64_t *b_u64 = (const uint64_t *) &b->masks;\n    size_t i;\n\n    for (i = 0; i < FLOW_U64S; i++) {\n        if ((a_u64[i] & b_u64[i]) != b_u64[i]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/* Returns true if 'a' and 'b' are equal, except that 0-bits (wildcarded bits)\n * in 'wc' do not need to be equal in 'a' and 'b'. */\nbool\nflow_equal_except(const struct flow *a, const struct flow *b,\n                  const struct flow_wildcards *wc)\n{\n    const uint64_t *a_u64 = (const uint64_t *) a;\n    const uint64_t *b_u64 = (const uint64_t *) b;\n    const uint64_t *wc_u64 = (const uint64_t *) &wc->masks;\n    size_t i;\n\n    for (i = 0; i < FLOW_U64S; i++) {\n        if ((a_u64[i] ^ b_u64[i]) & wc_u64[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/* Sets the wildcard mask for register 'idx' in 'wc' to 'mask'.\n * (A 0-bit indicates a wildcard bit.) */\nvoid\nflow_wildcards_set_reg_mask(struct flow_wildcards *wc, int idx, uint32_t mask)\n{\n    wc->masks.regs[idx] = mask;\n}\n\n/* Sets the wildcard mask for register 'idx' in 'wc' to 'mask'.\n * (A 0-bit indicates a wildcard bit.) */\nvoid\nflow_wildcards_set_xreg_mask(struct flow_wildcards *wc, int idx, uint64_t mask)\n{\n    flow_set_xreg(&wc->masks, idx, mask);\n}\n\n/* Sets the wildcard mask for register 'idx' in 'wc' to 'mask'.\n * (A 0-bit indicates a wildcard bit.) */\nvoid\nflow_wildcards_set_xxreg_mask(struct flow_wildcards *wc, int idx,\n                              ovs_u128 mask)\n{\n    flow_set_xxreg(&wc->masks, idx, mask);\n}\n\n/* Calculates the 5-tuple hash from the given miniflow.\n * This returns the same value as flow_hash_5tuple for the corresponding\n * flow. */\nuint32_t\nminiflow_hash_5tuple(const struct miniflow *flow, uint32_t basis)\n{\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n    uint32_t hash = basis;\n\n    if (flow) {\n        ovs_be16 dl_type = MINIFLOW_GET_BE16(flow, dl_type);\n        uint8_t nw_proto;\n\n        if (dl_type == htons(ETH_TYPE_IPV6)) {\n            struct flowmap map = FLOWMAP_EMPTY_INITIALIZER;\n            uint64_t value;\n\n            FLOWMAP_SET(&map, ipv6_src);\n            FLOWMAP_SET(&map, ipv6_dst);\n\n            MINIFLOW_FOR_EACH_IN_FLOWMAP(value, flow, map) {\n                hash = hash_add64(hash, value);\n            }\n        } else if (dl_type == htons(ETH_TYPE_IP)\n                   || dl_type == htons(ETH_TYPE_ARP)) {\n            hash = hash_add(hash, MINIFLOW_GET_U32(flow, nw_src));\n            hash = hash_add(hash, MINIFLOW_GET_U32(flow, nw_dst));\n        } else {\n            goto out;\n        }\n\n        nw_proto = MINIFLOW_GET_U8(flow, nw_proto);\n        hash = hash_add(hash, nw_proto);\n        if (nw_proto != IPPROTO_TCP && nw_proto != IPPROTO_UDP\n            && nw_proto != IPPROTO_SCTP && nw_proto != IPPROTO_ICMP\n            && nw_proto != IPPROTO_ICMPV6) {\n            goto out;\n        }\n\n        /* Add both ports at once. */\n        hash = hash_add(hash, (OVS_FORCE uint32_t) miniflow_get_ports(flow));\n    }\nout:\n    return hash_finish(hash, 42);\n}\n\nASSERT_SEQUENTIAL_SAME_WORD(tp_src, tp_dst);\nASSERT_SEQUENTIAL(ipv6_src, ipv6_dst);\n\n/* Calculates the 5-tuple hash from the given flow. */\nuint32_t\nflow_hash_5tuple(const struct flow *flow, uint32_t basis)\n{\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n    uint32_t hash = basis;\n\n    if (flow) {\n\n        if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            const uint64_t *flow_u64 = (const uint64_t *)flow;\n            int ofs = offsetof(struct flow, ipv6_src) / 8;\n            int end = ofs + 2 * sizeof flow->ipv6_src / 8;\n\n            for (;ofs < end; ofs++) {\n                hash = hash_add64(hash, flow_u64[ofs]);\n            }\n        } else if (flow->dl_type == htons(ETH_TYPE_IP)\n                   || flow->dl_type == htons(ETH_TYPE_ARP)) {\n            hash = hash_add(hash, (OVS_FORCE uint32_t) flow->nw_src);\n            hash = hash_add(hash, (OVS_FORCE uint32_t) flow->nw_dst);\n        } else {\n            goto out;\n        }\n\n        hash = hash_add(hash, flow->nw_proto);\n        if (flow->nw_proto != IPPROTO_TCP && flow->nw_proto != IPPROTO_UDP\n            && flow->nw_proto != IPPROTO_SCTP && flow->nw_proto != IPPROTO_ICMP\n            && flow->nw_proto != IPPROTO_ICMPV6) {\n            goto out;\n        }\n\n        /* Add both ports at once. */\n        hash = hash_add(hash,\n                        ((const uint32_t *)flow)[offsetof(struct flow, tp_src)\n                                                 / sizeof(uint32_t)]);\n    }\nout:\n    return hash_finish(hash, 42); /* Arbitrary number. */\n}\n\n/* Hashes 'flow' based on its L2 through L4 protocol information. */\nuint32_t\nflow_hash_symmetric_l4(const struct flow *flow, uint32_t basis)\n{\n    struct {\n        union {\n            ovs_be32 ipv4_addr;\n            struct in6_addr ipv6_addr;\n        };\n        ovs_be16 eth_type;\n        ovs_be16 vlan_tci;\n        ovs_be16 tp_port;\n        struct eth_addr eth_addr;\n        uint8_t ip_proto;\n    } fields;\n\n    int i;\n\n    memset(&fields, 0, sizeof fields);\n    for (i = 0; i < ARRAY_SIZE(fields.eth_addr.be16); i++) {\n        fields.eth_addr.be16[i] = flow->dl_src.be16[i] ^ flow->dl_dst.be16[i];\n    }\n    for (i = 0; i < FLOW_MAX_VLAN_HEADERS; i++) {\n        fields.vlan_tci ^= flow->vlans[i].tci & htons(VLAN_VID_MASK);\n    }\n    fields.eth_type = flow->dl_type;\n\n    /* UDP source and destination port are not taken into account because they\n     * will not necessarily be symmetric in a bidirectional flow. */\n    if (fields.eth_type == htons(ETH_TYPE_IP)) {\n        fields.ipv4_addr = flow->nw_src ^ flow->nw_dst;\n        fields.ip_proto = flow->nw_proto;\n        if (fields.ip_proto == IPPROTO_TCP || fields.ip_proto == IPPROTO_SCTP) {\n            fields.tp_port = flow->tp_src ^ flow->tp_dst;\n        }\n    } else if (fields.eth_type == htons(ETH_TYPE_IPV6)) {\n        const uint8_t *a = &flow->ipv6_src.s6_addr[0];\n        const uint8_t *b = &flow->ipv6_dst.s6_addr[0];\n        uint8_t *ipv6_addr = &fields.ipv6_addr.s6_addr[0];\n\n        for (i=0; i<16; i++) {\n            ipv6_addr[i] = a[i] ^ b[i];\n        }\n        fields.ip_proto = flow->nw_proto;\n        if (fields.ip_proto == IPPROTO_TCP || fields.ip_proto == IPPROTO_SCTP) {\n            fields.tp_port = flow->tp_src ^ flow->tp_dst;\n        }\n    }\n    return jhash_bytes(&fields, sizeof fields, basis);\n}\n\n/* Symmetrically Hashes non-IP 'flow' based on its L2 headers. */\nuint32_t\nflow_hash_symmetric_l2(const struct flow *flow, uint32_t basis)\n{\n    union {\n        struct {\n            ovs_be16 eth_type;\n            ovs_be16 vlan_tci;\n            struct eth_addr eth_addr;\n            ovs_be16 pad;\n        };\n        uint32_t word[3];\n    } fields;\n\n    uint32_t hash = basis;\n    int i;\n\n    if (flow->packet_type != htonl(PT_ETH)) {\n        /* Cannot hash non-Ethernet flows */\n        return 0;\n    }\n\n    for (i = 0; i < ARRAY_SIZE(fields.eth_addr.be16); i++) {\n        fields.eth_addr.be16[i] =\n                flow->dl_src.be16[i] ^ flow->dl_dst.be16[i];\n    }\n    fields.vlan_tci = 0;\n    for (i = 0; i < FLOW_MAX_VLAN_HEADERS; i++) {\n        fields.vlan_tci ^= flow->vlans[i].tci & htons(VLAN_VID_MASK);\n    }\n    fields.eth_type = flow->dl_type;\n    fields.pad = 0;\n\n    hash = hash_add(hash, fields.word[0]);\n    hash = hash_add(hash, fields.word[1]);\n    hash = hash_add(hash, fields.word[2]);\n    return hash_finish(hash, basis);\n}\n\n/* Hashes 'flow' based on its L3 through L4 protocol information */\nuint32_t\nflow_hash_symmetric_l3l4(const struct flow *flow, uint32_t basis,\n                         bool inc_udp_ports)\n{\n    uint32_t hash = basis;\n\n    /* UDP source and destination port are also taken into account. */\n    if (flow->dl_type == htons(ETH_TYPE_IP)) {\n        hash = hash_add(hash,\n                        (OVS_FORCE uint32_t) (flow->nw_src ^ flow->nw_dst));\n    } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n        /* IPv6 addresses are 64-bit aligned inside struct flow. */\n        const uint64_t *a = ALIGNED_CAST(uint64_t *, flow->ipv6_src.s6_addr);\n        const uint64_t *b = ALIGNED_CAST(uint64_t *, flow->ipv6_dst.s6_addr);\n\n        for (int i = 0; i < sizeof flow->ipv6_src / sizeof *a; i++) {\n            hash = hash_add64(hash, a[i] ^ b[i]);\n        }\n    } else {\n        /* Revert to hashing L2 headers */\n        return flow_hash_symmetric_l2(flow, basis);\n    }\n    hash = hash_add(hash, flow->nw_proto);\n    if (!(flow->nw_frag & FLOW_NW_FRAG_MASK)\n        && (flow->nw_proto == IPPROTO_TCP || flow->nw_proto == IPPROTO_SCTP ||\n            (inc_udp_ports && flow->nw_proto == IPPROTO_UDP))) {\n        hash = hash_add(hash,\n                        (OVS_FORCE uint16_t) (flow->tp_src ^ flow->tp_dst));\n    }\n\n    return hash_finish(hash, basis);\n}\n\n/* Hashes 'flow' based on its nw_dst and nw_src for multipath. */\nuint32_t\nflow_hash_symmetric_l3(const struct flow *flow, uint32_t basis)\n{\n    struct {\n        union {\n            ovs_be32 ipv4_addr;\n            struct in6_addr ipv6_addr;\n        };\n        ovs_be16 eth_type;\n    } fields;\n\n    int i;\n\n    memset(&fields, 0, sizeof fields);\n    fields.eth_type = flow->dl_type;\n\n    if (fields.eth_type == htons(ETH_TYPE_IP)) {\n        fields.ipv4_addr = flow->nw_src ^ flow->nw_dst;\n    } else if (fields.eth_type == htons(ETH_TYPE_IPV6)) {\n        const uint8_t *a = &flow->ipv6_src.s6_addr[0];\n        const uint8_t *b = &flow->ipv6_dst.s6_addr[0];\n        uint8_t *ipv6_addr = &fields.ipv6_addr.s6_addr[0];\n\n        for (i = 0; i < 16; i++) {\n            ipv6_addr[i] = a[i] ^ b[i];\n        }\n    }\n    return jhash_bytes(&fields, sizeof fields, basis);\n}\n\n/* Initialize a flow with random fields that matter for nx_hash_fields. */\nvoid\nflow_random_hash_fields(struct flow *flow)\n{\n    uint16_t rnd = random_uint16();\n    int i;\n\n    /* Initialize to all zeros. */\n    memset(flow, 0, sizeof *flow);\n\n    eth_addr_random(&flow->dl_src);\n    eth_addr_random(&flow->dl_dst);\n\n    for (i = 0; i < FLOW_MAX_VLAN_HEADERS; i++) {\n        uint16_t vlan = random_uint16() & VLAN_VID_MASK;\n        flow->vlans[i].tpid = htons(ETH_TYPE_VLAN_8021Q);\n        flow->vlans[i].tci = htons(vlan | VLAN_CFI);\n    }\n\n    /* Make most of the random flows IPv4, some IPv6, and rest random. */\n    flow->dl_type = rnd < 0x8000 ? htons(ETH_TYPE_IP) :\n        rnd < 0xc000 ? htons(ETH_TYPE_IPV6) : (OVS_FORCE ovs_be16)rnd;\n\n    if (dl_type_is_ip_any(flow->dl_type)) {\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            flow->nw_src = (OVS_FORCE ovs_be32)random_uint32();\n            flow->nw_dst = (OVS_FORCE ovs_be32)random_uint32();\n        } else {\n            random_bytes(&flow->ipv6_src, sizeof flow->ipv6_src);\n            random_bytes(&flow->ipv6_dst, sizeof flow->ipv6_dst);\n        }\n        /* Make most of IP flows TCP, some UDP or SCTP, and rest random. */\n        rnd = random_uint16();\n        flow->nw_proto = rnd < 0x8000 ? IPPROTO_TCP :\n            rnd < 0xc000 ? IPPROTO_UDP :\n            rnd < 0xd000 ? IPPROTO_SCTP : (uint8_t)rnd;\n        if (flow->nw_proto == IPPROTO_TCP ||\n            flow->nw_proto == IPPROTO_UDP ||\n            flow->nw_proto == IPPROTO_SCTP) {\n            flow->tp_src = (OVS_FORCE ovs_be16)random_uint16();\n            flow->tp_dst = (OVS_FORCE ovs_be16)random_uint16();\n        }\n    }\n}\n\n/* Masks the fields in 'wc' that are used by the flow hash 'fields'. */\nvoid\nflow_mask_hash_fields(const struct flow *flow, struct flow_wildcards *wc,\n                      enum nx_hash_fields fields)\n{\n    int i;\n    switch (fields) {\n    case NX_HASH_FIELDS_ETH_SRC:\n        memset(&wc->masks.dl_src, 0xff, sizeof wc->masks.dl_src);\n        break;\n\n    case NX_HASH_FIELDS_SYMMETRIC_L4:\n        memset(&wc->masks.dl_src, 0xff, sizeof wc->masks.dl_src);\n        memset(&wc->masks.dl_dst, 0xff, sizeof wc->masks.dl_dst);\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            memset(&wc->masks.nw_src, 0xff, sizeof wc->masks.nw_src);\n            memset(&wc->masks.nw_dst, 0xff, sizeof wc->masks.nw_dst);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            memset(&wc->masks.ipv6_src, 0xff, sizeof wc->masks.ipv6_src);\n            memset(&wc->masks.ipv6_dst, 0xff, sizeof wc->masks.ipv6_dst);\n        }\n        if (is_ip_any(flow)) {\n            memset(&wc->masks.nw_proto, 0xff, sizeof wc->masks.nw_proto);\n            /* Unwildcard port only for non-UDP packets as udp port\n             * numbers are not used in hash calculations.\n             */\n            if (flow->nw_proto != IPPROTO_UDP) {\n                flow_unwildcard_tp_ports(flow, wc);\n            }\n        }\n        for (i = 0; i < FLOW_MAX_VLAN_HEADERS; i++) {\n            wc->masks.vlans[i].tci |= htons(VLAN_VID_MASK | VLAN_CFI);\n        }\n        break;\n    case NX_HASH_FIELDS_SYMMETRIC_L3L4_UDP:\n        if (is_ip_any(flow) && flow->nw_proto == IPPROTO_UDP\n            && !(flow->nw_frag & FLOW_NW_FRAG_MASK)) {\n            memset(&wc->masks.tp_src, 0xff, sizeof wc->masks.tp_src);\n            memset(&wc->masks.tp_dst, 0xff, sizeof wc->masks.tp_dst);\n        }\n        /* fall through */\n    case NX_HASH_FIELDS_SYMMETRIC_L3L4:\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            memset(&wc->masks.nw_src, 0xff, sizeof wc->masks.nw_src);\n            memset(&wc->masks.nw_dst, 0xff, sizeof wc->masks.nw_dst);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            memset(&wc->masks.ipv6_src, 0xff, sizeof wc->masks.ipv6_src);\n            memset(&wc->masks.ipv6_dst, 0xff, sizeof wc->masks.ipv6_dst);\n        } else {\n            break; /* non-IP flow */\n        }\n        memset(&wc->masks.nw_proto, 0xff, sizeof wc->masks.nw_proto);\n        if ((flow->nw_proto == IPPROTO_TCP || flow->nw_proto == IPPROTO_SCTP)\n             && !(flow->nw_frag & FLOW_NW_FRAG_MASK)) {\n            memset(&wc->masks.tp_src, 0xff, sizeof wc->masks.tp_src);\n            memset(&wc->masks.tp_dst, 0xff, sizeof wc->masks.tp_dst);\n        }\n        break;\n\n    case NX_HASH_FIELDS_NW_SRC:\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            memset(&wc->masks.nw_src, 0xff, sizeof wc->masks.nw_src);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            memset(&wc->masks.ipv6_src, 0xff, sizeof wc->masks.ipv6_src);\n        }\n        break;\n\n    case NX_HASH_FIELDS_NW_DST:\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            memset(&wc->masks.nw_dst, 0xff, sizeof wc->masks.nw_dst);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            memset(&wc->masks.ipv6_dst, 0xff, sizeof wc->masks.ipv6_dst);\n        }\n        break;\n\n    case NX_HASH_FIELDS_SYMMETRIC_L3:\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            memset(&wc->masks.nw_src, 0xff, sizeof wc->masks.nw_src);\n            memset(&wc->masks.nw_dst, 0xff, sizeof wc->masks.nw_dst);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            memset(&wc->masks.ipv6_src, 0xff, sizeof wc->masks.ipv6_src);\n            memset(&wc->masks.ipv6_dst, 0xff, sizeof wc->masks.ipv6_dst);\n        }\n        break;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Hashes the portions of 'flow' designated by 'fields'. */\nuint32_t\nflow_hash_fields(const struct flow *flow, enum nx_hash_fields fields,\n                 uint16_t basis)\n{\n    switch (fields) {\n\n    case NX_HASH_FIELDS_ETH_SRC:\n        return jhash_bytes(&flow->dl_src, sizeof flow->dl_src, basis);\n\n    case NX_HASH_FIELDS_SYMMETRIC_L4:\n        return flow_hash_symmetric_l4(flow, basis);\n\n    case NX_HASH_FIELDS_SYMMETRIC_L3L4:\n        return flow_hash_symmetric_l3l4(flow, basis, false);\n\n    case NX_HASH_FIELDS_SYMMETRIC_L3L4_UDP:\n        return flow_hash_symmetric_l3l4(flow, basis, true);\n\n    case NX_HASH_FIELDS_NW_SRC:\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            return jhash_bytes(&flow->nw_src, sizeof flow->nw_src, basis);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            return jhash_bytes(&flow->ipv6_src, sizeof flow->ipv6_src, basis);\n        } else {\n            return basis;\n        }\n\n    case NX_HASH_FIELDS_NW_DST:\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            return jhash_bytes(&flow->nw_dst, sizeof flow->nw_dst, basis);\n        } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            return jhash_bytes(&flow->ipv6_dst, sizeof flow->ipv6_dst, basis);\n        } else {\n            return basis;\n        }\n\n    case NX_HASH_FIELDS_SYMMETRIC_L3:\n        return flow_hash_symmetric_l3(flow, basis);\n    }\n\n    OVS_NOT_REACHED();\n}\n\n/* Returns a string representation of 'fields'. */\nconst char *\nflow_hash_fields_to_str(enum nx_hash_fields fields)\n{\n    switch (fields) {\n    case NX_HASH_FIELDS_ETH_SRC: return \"eth_src\";\n    case NX_HASH_FIELDS_SYMMETRIC_L4: return \"symmetric_l4\";\n    case NX_HASH_FIELDS_SYMMETRIC_L3L4: return \"symmetric_l3l4\";\n    case NX_HASH_FIELDS_SYMMETRIC_L3L4_UDP: return \"symmetric_l3l4+udp\";\n    case NX_HASH_FIELDS_NW_SRC: return \"nw_src\";\n    case NX_HASH_FIELDS_NW_DST: return \"nw_dst\";\n    case NX_HASH_FIELDS_SYMMETRIC_L3: return \"symmetric_l3\";\n    default: return \"<unknown>\";\n    }\n}\n\n/* Returns true if the value of 'fields' is supported. Otherwise false. */\nbool\nflow_hash_fields_valid(enum nx_hash_fields fields)\n{\n    return fields == NX_HASH_FIELDS_ETH_SRC\n        || fields == NX_HASH_FIELDS_SYMMETRIC_L4\n        || fields == NX_HASH_FIELDS_SYMMETRIC_L3L4\n        || fields == NX_HASH_FIELDS_SYMMETRIC_L3L4_UDP\n        || fields == NX_HASH_FIELDS_NW_SRC\n        || fields == NX_HASH_FIELDS_NW_DST\n        || fields == NX_HASH_FIELDS_SYMMETRIC_L3;\n}\n\n/* Returns a hash value for the bits of 'flow' that are active based on\n * 'wc', given 'basis'. */\nuint32_t\nflow_hash_in_wildcards(const struct flow *flow,\n                       const struct flow_wildcards *wc, uint32_t basis)\n{\n    const uint64_t *wc_u64 = (const uint64_t *) &wc->masks;\n    const uint64_t *flow_u64 = (const uint64_t *) flow;\n    uint32_t hash;\n    size_t i;\n\n    hash = basis;\n    for (i = 0; i < FLOW_U64S; i++) {\n        hash = hash_add64(hash, flow_u64[i] & wc_u64[i]);\n    }\n    return hash_finish(hash, 8 * FLOW_U64S);\n}\n\n/* Sets the VLAN VID that 'flow' matches to 'vid', which is interpreted as an\n * OpenFlow 1.0 \"dl_vlan\" value:\n *\n *      - If it is in the range 0...4095, 'flow->vlans[0].tci' is set to match\n *        that VLAN.  Any existing PCP match is unchanged (it becomes 0 if\n *        'flow' previously matched packets without a VLAN header).\n *\n *      - If it is OFP_VLAN_NONE, 'flow->vlan_tci' is set to match a packet\n *        without a VLAN tag.\n *\n *      - Other values of 'vid' should not be used. */\nvoid\nflow_set_dl_vlan(struct flow *flow, ovs_be16 vid, int id)\n{\n    if (vid == htons(OFP10_VLAN_NONE)) {\n        flow->vlans[id].tci = htons(0);\n    } else {\n        vid &= htons(VLAN_VID_MASK);\n        flow->vlans[id].tci &= ~htons(VLAN_VID_MASK);\n        flow->vlans[id].tci |= htons(VLAN_CFI) | vid;\n    }\n}\n\n/* Sets the VLAN header TPID, which must be either ETH_TYPE_VLAN_8021Q or\n * ETH_TYPE_VLAN_8021AD. */\nvoid\nflow_fix_vlan_tpid(struct flow *flow)\n{\n    if (flow->vlans[0].tpid == htons(0) && flow->vlans[0].tci != 0) {\n        flow->vlans[0].tpid = htons(ETH_TYPE_VLAN_8021Q);\n    }\n}\n\n/* Sets the VLAN VID that 'flow' matches to 'vid', which is interpreted as an\n * OpenFlow 1.2 \"vlan_vid\" value, that is, the low 13 bits of 'vlan_tci' (VID\n * plus CFI). */\nvoid\nflow_set_vlan_vid(struct flow *flow, ovs_be16 vid)\n{\n    ovs_be16 mask = htons(VLAN_VID_MASK | VLAN_CFI);\n    flow->vlans[0].tci &= ~mask;\n    flow->vlans[0].tci |= vid & mask;\n}\n\n/* Sets the VLAN PCP that 'flow' matches to 'pcp', which should be in the\n * range 0...7.\n *\n * This function has no effect on the VLAN ID that 'flow' matches.\n *\n * After calling this function, 'flow' will not match packets without a VLAN\n * header. */\nvoid\nflow_set_vlan_pcp(struct flow *flow, uint8_t pcp, int id)\n{\n    pcp &= 0x07;\n    flow->vlans[id].tci &= ~htons(VLAN_PCP_MASK);\n    flow->vlans[id].tci |= htons((pcp << VLAN_PCP_SHIFT) | VLAN_CFI);\n}\n\n/* Counts the number of VLAN headers. */\nint\nflow_count_vlan_headers(const struct flow *flow)\n{\n    int i;\n\n    for (i = 0; i < FLOW_MAX_VLAN_HEADERS; i++) {\n        if (!(flow->vlans[i].tci & htons(VLAN_CFI))) {\n            break;\n        }\n    }\n    return i;\n}\n\n/* Given '*p_an' and '*p_bn' pointing to one past the last VLAN header of\n * 'a' and 'b' respectively, skip common VLANs so that they point to the\n * first different VLAN counting from bottom. */\nvoid\nflow_skip_common_vlan_headers(const struct flow *a, int *p_an,\n                              const struct flow *b, int *p_bn)\n{\n    int an = *p_an, bn = *p_bn;\n\n    for (an--, bn--; an >= 0 && bn >= 0; an--, bn--) {\n        if (a->vlans[an].qtag != b->vlans[bn].qtag) {\n            break;\n        }\n    }\n    *p_an = an;\n    *p_bn = bn;\n}\n\nvoid\nflow_pop_vlan(struct flow *flow, struct flow_wildcards *wc)\n{\n    int n = flow_count_vlan_headers(flow);\n    if (n > 1) {\n        if (wc) {\n            memset(&wc->masks.vlans[1], 0xff,\n                   sizeof(union flow_vlan_hdr) * (n - 1));\n        }\n        memmove(&flow->vlans[0], &flow->vlans[1],\n                sizeof(union flow_vlan_hdr) * (n - 1));\n    }\n    if (n > 0) {\n        memset(&flow->vlans[n - 1], 0, sizeof(union flow_vlan_hdr));\n    }\n}\n\nvoid\nflow_push_vlan_uninit(struct flow *flow, struct flow_wildcards *wc)\n{\n    if (wc) {\n        int n = flow_count_vlan_headers(flow);\n        if (n) {\n            memset(wc->masks.vlans, 0xff, sizeof(union flow_vlan_hdr) * n);\n        }\n    }\n    memmove(&flow->vlans[1], &flow->vlans[0],\n            sizeof(union flow_vlan_hdr) * (FLOW_MAX_VLAN_HEADERS - 1));\n    memset(&flow->vlans[0], 0, sizeof(union flow_vlan_hdr));\n}\n\n/* Returns the number of MPLS LSEs present in 'flow'\n *\n * Returns 0 if the 'dl_type' of 'flow' is not an MPLS ethernet type.\n * Otherwise traverses 'flow''s MPLS label stack stopping at the\n * first entry that has the BoS bit set. If no such entry exists then\n * the maximum number of LSEs that can be stored in 'flow' is returned.\n */\nint\nflow_count_mpls_labels(const struct flow *flow, struct flow_wildcards *wc)\n{\n    /* dl_type is always masked. */\n    if (eth_type_mpls(flow->dl_type)) {\n        int i;\n        int cnt;\n\n        cnt = 0;\n        for (i = 0; i < FLOW_MAX_MPLS_LABELS; i++) {\n            if (wc) {\n                wc->masks.mpls_lse[i] |= htonl(MPLS_BOS_MASK);\n            }\n            if (flow->mpls_lse[i] & htonl(MPLS_BOS_MASK)) {\n                return i + 1;\n            }\n            if (flow->mpls_lse[i]) {\n                cnt++;\n            }\n        }\n        return cnt;\n    } else {\n        return 0;\n    }\n}\n\n/* Returns the number consecutive of MPLS LSEs, starting at the\n * innermost LSE, that are common in 'a' and 'b'.\n *\n * 'an' must be flow_count_mpls_labels(a).\n * 'bn' must be flow_count_mpls_labels(b).\n */\nint\nflow_count_common_mpls_labels(const struct flow *a, int an,\n                              const struct flow *b, int bn,\n                              struct flow_wildcards *wc)\n{\n    int min_n = MIN(an, bn);\n    if (min_n == 0) {\n        return 0;\n    } else {\n        int common_n = 0;\n        int a_last = an - 1;\n        int b_last = bn - 1;\n        int i;\n\n        for (i = 0; i < min_n; i++) {\n            if (wc) {\n                wc->masks.mpls_lse[a_last - i] = OVS_BE32_MAX;\n                wc->masks.mpls_lse[b_last - i] = OVS_BE32_MAX;\n            }\n            if (a->mpls_lse[a_last - i] != b->mpls_lse[b_last - i]) {\n                break;\n            } else {\n                common_n++;\n            }\n        }\n\n        return common_n;\n    }\n}\n\n/* Adds a new outermost MPLS label to 'flow' and changes 'flow''s Ethernet type\n * to 'mpls_eth_type', which must be an MPLS Ethertype.\n *\n * If the new label is the first MPLS label in 'flow', it is generated as;\n *\n *     - label: 2, if 'flow' is IPv6, otherwise 0.\n *\n *     - TTL: IPv4 or IPv6 TTL, if present and nonzero, otherwise 64.\n *\n *     - TC: IPv4 or IPv6 TOS, if present, otherwise 0.\n *\n *     - BoS: 1.\n *\n * If the new label is the second or later label MPLS label in 'flow', it is\n * generated as;\n *\n *     - label: Copied from outer label.\n *\n *     - TTL: Copied from outer label.\n *\n *     - TC: Copied from outer label.\n *\n *     - BoS: 0.\n *\n * 'n' must be flow_count_mpls_labels(flow).  'n' must be less than\n * FLOW_MAX_MPLS_LABELS (because otherwise flow->mpls_lse[] would overflow).\n */\nvoid\nflow_push_mpls(struct flow *flow, int n, ovs_be16 mpls_eth_type,\n               struct flow_wildcards *wc, bool clear_flow_L3)\n{\n    ovs_assert(eth_type_mpls(mpls_eth_type));\n    ovs_assert(n < FLOW_MAX_MPLS_LABELS);\n\n    if (n) {\n        int i;\n\n        if (wc) {\n            memset(&wc->masks.mpls_lse, 0xff, sizeof *wc->masks.mpls_lse * n);\n        }\n        for (i = n; i >= 1; i--) {\n            flow->mpls_lse[i] = flow->mpls_lse[i - 1];\n        }\n        flow->mpls_lse[0] = (flow->mpls_lse[1] & htonl(~MPLS_BOS_MASK));\n    } else {\n        int label = 0;          /* IPv4 Explicit Null. */\n        int tc = 0;\n        int ttl = 64;\n\n        if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n            label = 2;\n        }\n\n        if (is_ip_any(flow)) {\n            tc = (flow->nw_tos & IP_DSCP_MASK) >> 2;\n            if (wc) {\n                wc->masks.nw_tos |= IP_DSCP_MASK;\n                wc->masks.nw_ttl = 0xff;\n            }\n\n            if (flow->nw_ttl) {\n                ttl = flow->nw_ttl;\n            }\n        }\n\n        flow->mpls_lse[0] = set_mpls_lse_values(ttl, tc, 1, htonl(label));\n\n        if (clear_flow_L3) {\n            /* Clear all L3 and L4 fields and dp_hash. */\n            BUILD_ASSERT(FLOW_WC_SEQ == 41);\n            memset((char *) flow + FLOW_SEGMENT_2_ENDS_AT, 0,\n                   sizeof(struct flow) - FLOW_SEGMENT_2_ENDS_AT);\n            flow->dp_hash = 0;\n        }\n    }\n    flow->dl_type = mpls_eth_type;\n}\n\n/* Tries to remove the outermost MPLS label from 'flow'.  Returns true if\n * successful, false otherwise.  On success, sets 'flow''s Ethernet type to\n * 'eth_type'.\n *\n * 'n' must be flow_count_mpls_labels(flow). */\nbool\nflow_pop_mpls(struct flow *flow, int n, ovs_be16 eth_type,\n              struct flow_wildcards *wc)\n{\n    int i;\n\n    if (n == 0) {\n        /* Nothing to pop. */\n        return false;\n    } else if (n == FLOW_MAX_MPLS_LABELS) {\n        if (wc) {\n            wc->masks.mpls_lse[n - 1] |= htonl(MPLS_BOS_MASK);\n        }\n        if (!(flow->mpls_lse[n - 1] & htonl(MPLS_BOS_MASK))) {\n            /* Can't pop because don't know what to fill in mpls_lse[n - 1]. */\n            return false;\n        }\n    }\n\n    if (wc) {\n        memset(&wc->masks.mpls_lse[1], 0xff,\n               sizeof *wc->masks.mpls_lse * (n - 1));\n    }\n    for (i = 1; i < n; i++) {\n        flow->mpls_lse[i - 1] = flow->mpls_lse[i];\n    }\n    flow->mpls_lse[n - 1] = 0;\n    flow->dl_type = eth_type;\n    return true;\n}\n\n/* Sets the MPLS Label that 'flow' matches to 'label', which is interpreted\n * as an OpenFlow 1.1 \"mpls_label\" value. */\nvoid\nflow_set_mpls_label(struct flow *flow, int idx, ovs_be32 label)\n{\n    set_mpls_lse_label(&flow->mpls_lse[idx], label);\n}\n\n/* Sets the MPLS TTL that 'flow' matches to 'ttl', which should be in the\n * range 0...255. */\nvoid\nflow_set_mpls_ttl(struct flow *flow, int idx, uint8_t ttl)\n{\n    set_mpls_lse_ttl(&flow->mpls_lse[idx], ttl);\n}\n\n/* Sets the MPLS TC that 'flow' matches to 'tc', which should be in the\n * range 0...7. */\nvoid\nflow_set_mpls_tc(struct flow *flow, int idx, uint8_t tc)\n{\n    set_mpls_lse_tc(&flow->mpls_lse[idx], tc);\n}\n\n/* Sets the MPLS BOS bit that 'flow' matches to which should be 0 or 1. */\nvoid\nflow_set_mpls_bos(struct flow *flow, int idx, uint8_t bos)\n{\n    set_mpls_lse_bos(&flow->mpls_lse[idx], bos);\n}\n\n/* Sets the entire MPLS LSE. */\nvoid\nflow_set_mpls_lse(struct flow *flow, int idx, ovs_be32 lse)\n{\n    flow->mpls_lse[idx] = lse;\n}\n\nstatic void\nflow_compose_l7(struct dp_packet *p, const void *l7, size_t l7_len)\n{\n    if (l7_len) {\n        if (l7) {\n            dp_packet_put(p, l7, l7_len);\n        } else {\n            uint8_t *payload = dp_packet_put_uninit(p, l7_len);\n            for (size_t i = 0; i < l7_len; i++) {\n                payload[i] = i;\n            }\n        }\n    }\n}\n\nstatic size_t\nflow_compose_l4(struct dp_packet *p, const struct flow *flow,\n                const void *l7, size_t l7_len)\n{\n    size_t orig_len = dp_packet_size(p);\n\n    if (!(flow->nw_frag & FLOW_NW_FRAG_ANY)\n        || !(flow->nw_frag & FLOW_NW_FRAG_LATER)) {\n        if (flow->nw_proto == IPPROTO_TCP) {\n            struct tcp_header *tcp = dp_packet_put_zeros(p, sizeof *tcp);\n            tcp->tcp_src = flow->tp_src;\n            tcp->tcp_dst = flow->tp_dst;\n            tcp->tcp_ctl = TCP_CTL(ntohs(flow->tcp_flags), 5);\n            if (!(flow->tcp_flags & htons(TCP_SYN | TCP_FIN | TCP_RST))) {\n                flow_compose_l7(p, l7, l7_len);\n            }\n        } else if (flow->nw_proto == IPPROTO_UDP) {\n            struct udp_header *udp = dp_packet_put_zeros(p, sizeof *udp);\n            udp->udp_src = flow->tp_src;\n            udp->udp_dst = flow->tp_dst;\n            udp->udp_len = htons(sizeof *udp + l7_len);\n            flow_compose_l7(p, l7, l7_len);\n        } else if (flow->nw_proto == IPPROTO_SCTP) {\n            struct sctp_header *sctp = dp_packet_put_zeros(p, sizeof *sctp);\n            sctp->sctp_src = flow->tp_src;\n            sctp->sctp_dst = flow->tp_dst;\n            /* XXX Someone should figure out what L7 data to include. */\n        } else if (flow->nw_proto == IPPROTO_ICMP) {\n            struct icmp_header *icmp = dp_packet_put_zeros(p, sizeof *icmp);\n            icmp->icmp_type = ntohs(flow->tp_src);\n            icmp->icmp_code = ntohs(flow->tp_dst);\n            if ((icmp->icmp_type == ICMP4_ECHO_REQUEST ||\n                 icmp->icmp_type == ICMP4_ECHO_REPLY)\n                && icmp->icmp_code == 0) {\n                flow_compose_l7(p, l7, l7_len);\n            } else {\n                /* XXX Add inner IP packet for e.g. destination unreachable? */\n            }\n        } else if (flow->nw_proto == IPPROTO_IGMP) {\n            struct igmp_header *igmp = dp_packet_put_zeros(p, sizeof *igmp);\n            igmp->igmp_type = ntohs(flow->tp_src);\n            igmp->igmp_code = ntohs(flow->tp_dst);\n            put_16aligned_be32(&igmp->group, flow->igmp_group_ip4);\n        } else if (flow->nw_proto == IPPROTO_ICMPV6) {\n            struct icmp6_hdr *icmp = dp_packet_put_zeros(p, sizeof *icmp);\n            icmp->icmp6_type = ntohs(flow->tp_src);\n            icmp->icmp6_code = ntohs(flow->tp_dst);\n            uint32_t *reserved = &icmp->icmp6_dataun.icmp6_un_data32[0];\n            *reserved = ntohl(flow->igmp_group_ip4);\n\n            if (icmp->icmp6_code == 0 &&\n                (icmp->icmp6_type == ND_NEIGHBOR_SOLICIT ||\n                 icmp->icmp6_type == ND_NEIGHBOR_ADVERT)) {\n                struct in6_addr *nd_target;\n                struct ovs_nd_lla_opt *lla_opt;\n\n                nd_target = dp_packet_put_zeros(p, sizeof *nd_target);\n                *nd_target = flow->nd_target;\n\n                if (!eth_addr_is_zero(flow->arp_sha)) {\n                    lla_opt = dp_packet_put_zeros(p, 8);\n                    lla_opt->len = 1;\n                    lla_opt->type = ND_OPT_SOURCE_LINKADDR;\n                    lla_opt->mac = flow->arp_sha;\n                }\n                if (!eth_addr_is_zero(flow->arp_tha)) {\n                    lla_opt = dp_packet_put_zeros(p, 8);\n                    lla_opt->len = 1;\n                    lla_opt->type = ND_OPT_TARGET_LINKADDR;\n                    lla_opt->mac = flow->arp_tha;\n                }\n            } else if (icmp->icmp6_code == 0 &&\n                       (icmp->icmp6_type == ICMP6_ECHO_REQUEST ||\n                        icmp->icmp6_type == ICMP6_ECHO_REPLY)) {\n                flow_compose_l7(p, l7, l7_len);\n            } else {\n                /* XXX Add inner IP packet for e.g. destination unreachable? */\n            }\n        }\n    }\n\n    return dp_packet_size(p) - orig_len;\n}\n\nstatic void\nflow_compose_l4_csum(struct dp_packet *p, const struct flow *flow,\n                     uint32_t pseudo_hdr_csum)\n{\n    size_t l4_len = (char *) dp_packet_tail(p) - (char *) dp_packet_l4(p);\n\n    if (!(flow->nw_frag & FLOW_NW_FRAG_ANY)\n        || !(flow->nw_frag & FLOW_NW_FRAG_LATER)) {\n        if (flow->nw_proto == IPPROTO_TCP) {\n            struct tcp_header *tcp = dp_packet_l4(p);\n\n            tcp->tcp_csum = 0;\n            tcp->tcp_csum = csum_finish(csum_continue(pseudo_hdr_csum,\n                                                      tcp, l4_len));\n        } else if (flow->nw_proto == IPPROTO_UDP) {\n            struct udp_header *udp = dp_packet_l4(p);\n\n            udp->udp_csum = 0;\n            udp->udp_csum = csum_finish(csum_continue(pseudo_hdr_csum,\n                                                      udp, l4_len));\n            if (!udp->udp_csum) {\n                udp->udp_csum = htons(0xffff);\n            }\n        } else if (flow->nw_proto == IPPROTO_ICMP) {\n            struct icmp_header *icmp = dp_packet_l4(p);\n\n            icmp->icmp_csum = 0;\n            icmp->icmp_csum = csum(icmp, l4_len);\n        } else if (flow->nw_proto == IPPROTO_IGMP) {\n            struct igmp_header *igmp = dp_packet_l4(p);\n\n            igmp->igmp_csum = 0;\n            igmp->igmp_csum = csum(igmp, l4_len);\n        } else if (flow->nw_proto == IPPROTO_ICMPV6) {\n            struct icmp6_hdr *icmp = dp_packet_l4(p);\n\n            icmp->icmp6_cksum = 0;\n            icmp->icmp6_cksum = (OVS_FORCE uint16_t)\n                csum_finish(csum_continue(pseudo_hdr_csum, icmp, l4_len));\n        }\n    }\n}\n\n/* Increase the size of packet composed by 'flow_compose_minimal'\n * up to 'size' bytes.  Fixes all the required packet headers like\n * ip/udp lengths and l3/l4 checksums.\n *\n * 'size' needs to be larger then the current packet size.  */\nvoid\npacket_expand(struct dp_packet *p, const struct flow *flow, size_t size)\n{\n    size_t extra_size;\n\n    ovs_assert(size > dp_packet_size(p));\n\n    extra_size = size - dp_packet_size(p);\n    dp_packet_put_zeros(p, extra_size);\n\n    if (flow->dl_type == htons(FLOW_DL_TYPE_NONE)) {\n        struct eth_header *eth = dp_packet_eth(p);\n\n        eth->eth_type = htons(dp_packet_size(p));\n    } else if (dl_type_is_ip_any(flow->dl_type)) {\n        uint32_t pseudo_hdr_csum;\n        size_t l4_len = (char *) dp_packet_tail(p) - (char *) dp_packet_l4(p);\n\n        if (flow->dl_type == htons(ETH_TYPE_IP)) {\n            struct ip_header *ip = dp_packet_l3(p);\n\n            ip->ip_tot_len = htons(p->l4_ofs - p->l3_ofs + l4_len);\n            ip->ip_csum = 0;\n            ip->ip_csum = csum(ip, sizeof *ip);\n\n            pseudo_hdr_csum = packet_csum_pseudoheader(ip);\n        } else { /* ETH_TYPE_IPV6 */\n            struct ovs_16aligned_ip6_hdr *nh = dp_packet_l3(p);\n\n            nh->ip6_plen = htons(l4_len);\n            pseudo_hdr_csum = packet_csum_pseudoheader6(nh);\n        }\n\n        if ((!(flow->nw_frag & FLOW_NW_FRAG_ANY)\n             || !(flow->nw_frag & FLOW_NW_FRAG_LATER))\n            && flow->nw_proto == IPPROTO_UDP) {\n            struct udp_header *udp = dp_packet_l4(p);\n\n            udp->udp_len = htons(l4_len + extra_size);\n        }\n        flow_compose_l4_csum(p, flow, pseudo_hdr_csum);\n    }\n}\n\n/* Puts into 'p' a packet that flow_extract() would parse as having the given\n * 'flow'.\n *\n * (This is useful only for testing, obviously, and the packet isn't really\n * valid.  Lots of fields are just zeroed.)\n *\n * For packets whose protocols can encapsulate arbitrary L7 payloads, 'l7' and\n * 'l7_len' determine that payload:\n *\n *    - If 'l7_len' is zero, no payload is included.\n *\n *    - If 'l7_len' is nonzero and 'l7' is null, an arbitrary payload 'l7_len'\n *      bytes long is included.\n *\n *    - If 'l7_len' is nonzero and 'l7' is nonnull, the payload is copied\n *      from 'l7'. */\nvoid\nflow_compose(struct dp_packet *p, const struct flow *flow,\n             const void *l7, size_t l7_len)\n{\n    /* Add code to this function (or its callees) for emitting new fields or\n     * protocols.  (This isn't essential, so it can be skipped for initial\n     * testing.) */\n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);\n\n    uint32_t pseudo_hdr_csum;\n    size_t l4_len;\n\n    /* eth_compose() sets l3 pointer and makes sure it is 32-bit aligned. */\n    eth_compose(p, flow->dl_dst, flow->dl_src, ntohs(flow->dl_type), 0);\n    if (flow->dl_type == htons(FLOW_DL_TYPE_NONE)) {\n        struct eth_header *eth = dp_packet_eth(p);\n        eth->eth_type = htons(dp_packet_size(p));\n        return;\n    }\n\n    for (int encaps = FLOW_MAX_VLAN_HEADERS - 1; encaps >= 0; encaps--) {\n        if (flow->vlans[encaps].tci & htons(VLAN_CFI)) {\n            eth_push_vlan(p, flow->vlans[encaps].tpid,\n                          flow->vlans[encaps].tci);\n        }\n    }\n\n    if (flow->dl_type == htons(ETH_TYPE_IP)) {\n        struct ip_header *ip;\n\n        ip = dp_packet_put_zeros(p, sizeof *ip);\n        ip->ip_ihl_ver = IP_IHL_VER(5, 4);\n        ip->ip_tos = flow->nw_tos;\n        ip->ip_ttl = flow->nw_ttl;\n        ip->ip_proto = flow->nw_proto;\n        put_16aligned_be32(&ip->ip_src, flow->nw_src);\n        put_16aligned_be32(&ip->ip_dst, flow->nw_dst);\n\n        if (flow->nw_frag & FLOW_NW_FRAG_ANY) {\n            ip->ip_frag_off |= htons(IP_MORE_FRAGMENTS);\n            if (flow->nw_frag & FLOW_NW_FRAG_LATER) {\n                ip->ip_frag_off |= htons(100);\n            }\n        }\n\n        dp_packet_set_l4(p, dp_packet_tail(p));\n\n        l4_len = flow_compose_l4(p, flow, l7, l7_len);\n\n        ip = dp_packet_l3(p);\n        ip->ip_tot_len = htons(p->l4_ofs - p->l3_ofs + l4_len);\n        /* Checksum has already been zeroed by put_zeros call. */\n        ip->ip_csum = csum(ip, sizeof *ip);\n\n        pseudo_hdr_csum = packet_csum_pseudoheader(ip);\n        flow_compose_l4_csum(p, flow, pseudo_hdr_csum);\n    } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n        struct ovs_16aligned_ip6_hdr *nh;\n\n        nh = dp_packet_put_zeros(p, sizeof *nh);\n        put_16aligned_be32(&nh->ip6_flow, htonl(6 << 28) |\n                           htonl(flow->nw_tos << 20) | flow->ipv6_label);\n        nh->ip6_hlim = flow->nw_ttl;\n        nh->ip6_nxt = flow->nw_proto;\n\n        memcpy(&nh->ip6_src, &flow->ipv6_src, sizeof(nh->ip6_src));\n        memcpy(&nh->ip6_dst, &flow->ipv6_dst, sizeof(nh->ip6_dst));\n\n        dp_packet_set_l4(p, dp_packet_tail(p));\n\n        l4_len = flow_compose_l4(p, flow, l7, l7_len);\n\n        nh = dp_packet_l3(p);\n        nh->ip6_plen = htons(l4_len);\n\n        pseudo_hdr_csum = packet_csum_pseudoheader6(nh);\n        flow_compose_l4_csum(p, flow, pseudo_hdr_csum);\n    } else if (flow->dl_type == htons(ETH_TYPE_ARP) ||\n               flow->dl_type == htons(ETH_TYPE_RARP)) {\n        struct arp_eth_header *arp;\n\n        arp = dp_packet_put_zeros(p, sizeof *arp);\n        dp_packet_set_l3(p, arp);\n        arp->ar_hrd = htons(1);\n        arp->ar_pro = htons(ETH_TYPE_IP);\n        arp->ar_hln = ETH_ADDR_LEN;\n        arp->ar_pln = 4;\n        arp->ar_op = htons(flow->nw_proto);\n\n        if (flow->nw_proto == ARP_OP_REQUEST ||\n            flow->nw_proto == ARP_OP_REPLY) {\n            put_16aligned_be32(&arp->ar_spa, flow->nw_src);\n            put_16aligned_be32(&arp->ar_tpa, flow->nw_dst);\n            arp->ar_sha = flow->arp_sha;\n            arp->ar_tha = flow->arp_tha;\n        }\n    }\n\n    if (eth_type_mpls(flow->dl_type)) {\n        int n;\n\n        p->l2_5_ofs = p->l3_ofs;\n        for (n = 1; n < FLOW_MAX_MPLS_LABELS; n++) {\n            if (flow->mpls_lse[n - 1] & htonl(MPLS_BOS_MASK)) {\n                break;\n            }\n        }\n        while (n > 0) {\n            push_mpls(p, flow->dl_type, flow->mpls_lse[--n]);\n        }\n    }\n}\n\f\n/* Compressed flow. */\n\n/* Completes an initialization of 'dst' as a miniflow copy of 'src' begun by\n * the caller.  The caller must have already computed 'dst->map' properly to\n * indicate the significant uint64_t elements of 'src'.\n *\n * Normally the significant elements are the ones that are non-zero.  However,\n * when a miniflow is initialized from a (mini)mask, the values can be zeroes,\n * so that the flow and mask always have the same maps. */\nvoid\nminiflow_init(struct miniflow *dst, const struct flow *src)\n{\n    uint64_t *dst_u64 = miniflow_values(dst);\n    size_t idx;\n\n    FLOWMAP_FOR_EACH_INDEX(idx, dst->map) {\n        *dst_u64++ = flow_u64_value(src, idx);\n    }\n}\n\n/* Initialize the maps of 'flow' from 'src'. */\nvoid\nminiflow_map_init(struct miniflow *flow, const struct flow *src)\n{\n    /* Initialize map, counting the number of nonzero elements. */\n    flowmap_init(&flow->map);\n    for (size_t i = 0; i < FLOW_U64S; i++) {\n        if (flow_u64_value(src, i)) {\n            flowmap_set(&flow->map, i, 1);\n        }\n    }\n}\n\n/* Allocates 'n' count of miniflows, consecutive in memory, initializing the\n * map of each from 'src'.\n * Returns the size of the miniflow data. */\nsize_t\nminiflow_alloc(struct miniflow *dsts[], size_t n, const struct miniflow *src)\n{\n    size_t n_values = miniflow_n_values(src);\n    size_t data_size = MINIFLOW_VALUES_SIZE(n_values);\n    struct miniflow *dst = xmalloc(n * (sizeof *src + data_size));\n    size_t i;\n\n    COVERAGE_INC(miniflow_malloc);\n\n    for (i = 0; i < n; i++) {\n        *dst = *src;   /* Copy maps. */\n        dsts[i] = dst;\n        dst += 1;      /* Just past the maps. */\n        dst = (struct miniflow *)((uint64_t *)dst + n_values); /* Skip data. */\n    }\n    return data_size;\n}\n\n/* Returns a miniflow copy of 'src'.  The caller must eventually free() the\n * returned miniflow. */\nstruct miniflow *\nminiflow_create(const struct flow *src)\n{\n    struct miniflow tmp;\n    struct miniflow *dst;\n\n    miniflow_map_init(&tmp, src);\n\n    miniflow_alloc(&dst, 1, &tmp);\n    miniflow_init(dst, src);\n    return dst;\n}\n\n/* Initializes 'dst' as a copy of 'src'.  The caller must have allocated\n * 'dst' to have inline space for 'n_values' data in 'src'. */\nvoid\nminiflow_clone(struct miniflow *dst, const struct miniflow *src,\n               size_t n_values)\n{\n    *dst = *src;   /* Copy maps. */\n    memcpy(miniflow_values(dst), miniflow_get_values(src),\n           MINIFLOW_VALUES_SIZE(n_values));\n}\n\n/* Initializes 'dst' as a copy of 'src'. */\nvoid\nminiflow_expand(const struct miniflow *src, struct flow *dst)\n{\n    memset(dst, 0, sizeof *dst);\n    flow_union_with_miniflow(dst, src);\n}\n\n/* Returns true if 'a' and 'b' are equal miniflows, false otherwise. */\nbool\nminiflow_equal(const struct miniflow *a, const struct miniflow *b)\n{\n    const uint64_t *ap = miniflow_get_values(a);\n    const uint64_t *bp = miniflow_get_values(b);\n\n    /* This is mostly called after a matching hash, so it is highly likely that\n     * the maps are equal as well. */\n    if (OVS_LIKELY(flowmap_equal(a->map, b->map))) {\n        return !memcmp(ap, bp, miniflow_n_values(a) * sizeof *ap);\n    } else {\n        size_t idx;\n\n        FLOWMAP_FOR_EACH_INDEX (idx, flowmap_or(a->map, b->map)) {\n            if ((flowmap_is_set(&a->map, idx) ? *ap++ : 0)\n                != (flowmap_is_set(&b->map, idx) ? *bp++ : 0)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/* Returns false if 'a' and 'b' differ at the places where there are 1-bits\n * in 'mask', true otherwise. */\nbool\nminiflow_equal_in_minimask(const struct miniflow *a, const struct miniflow *b,\n                           const struct minimask *mask)\n{\n    const uint64_t *p = miniflow_get_values(&mask->masks);\n    size_t idx;\n\n    FLOWMAP_FOR_EACH_INDEX(idx, mask->masks.map) {\n        if ((miniflow_get(a, idx) ^ miniflow_get(b, idx)) & *p++) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/* Returns true if 'a' and 'b' are equal at the places where there are 1-bits\n * in 'mask', false if they differ. */\nbool\nminiflow_equal_flow_in_minimask(const struct miniflow *a, const struct flow *b,\n                                const struct minimask *mask)\n{\n    const uint64_t *p = miniflow_get_values(&mask->masks);\n    size_t idx;\n\n    FLOWMAP_FOR_EACH_INDEX(idx, mask->masks.map) {\n        if ((miniflow_get(a, idx) ^ flow_u64_value(b, idx)) & *p++) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\f\nvoid\nminimask_init(struct minimask *mask, const struct flow_wildcards *wc)\n{\n    miniflow_init(&mask->masks, &wc->masks);\n}\n\n/* Returns a minimask copy of 'wc'.  The caller must eventually free the\n * returned minimask with free(). */\nstruct minimask *\nminimask_create(const struct flow_wildcards *wc)\n{\n    return (struct minimask *)miniflow_create(&wc->masks);\n}\n\n/* Initializes 'dst_' as the bit-wise \"and\" of 'a_' and 'b_'.\n *\n * The caller must provide room for FLOW_U64S \"uint64_t\"s in 'storage', which\n * must follow '*dst_' in memory, for use by 'dst_'.  The caller must *not*\n * free 'dst_' free(). */\nvoid\nminimask_combine(struct minimask *dst_,\n                 const struct minimask *a_, const struct minimask *b_,\n                 uint64_t storage[FLOW_U64S])\n{\n    struct miniflow *dst = &dst_->masks;\n    uint64_t *dst_values = storage;\n    const struct miniflow *a = &a_->masks;\n    const struct miniflow *b = &b_->masks;\n    size_t idx;\n\n    flowmap_init(&dst->map);\n\n    FLOWMAP_FOR_EACH_INDEX(idx, flowmap_and(a->map, b->map)) {\n        /* Both 'a' and 'b' have non-zero data at 'idx'. */\n        uint64_t mask = *miniflow_get__(a, idx) & *miniflow_get__(b, idx);\n\n        if (mask) {\n            flowmap_set(&dst->map, idx, 1);\n            *dst_values++ = mask;\n        }\n    }\n}\n\n/* Initializes 'wc' as a copy of 'mask'. */\nvoid\nminimask_expand(const struct minimask *mask, struct flow_wildcards *wc)\n{\n    miniflow_expand(&mask->masks, &wc->masks);\n}\n\n/* Returns true if 'a' and 'b' are the same flow mask, false otherwise.\n * Minimasks may not have zero data values, so for the minimasks to be the\n * same, they need to have the same map and the same data values. */\nbool\nminimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    /* At first glance, it might seem that this can be reasonably optimized\n     * into a single memcmp() for the total size of the region.  Such an\n     * optimization will work OK with most implementations of memcmp() that\n     * proceed from the start of the regions to be compared to the end in\n     * reasonably sized chunks.  However, memcmp() is not required to be\n     * implemented that way, and an implementation that, for example, compares\n     * all of the bytes in both regions without early exit when it finds a\n     * difference, or one that compares, say, 64 bytes at a time, could access\n     * an unmapped region of memory if minimasks 'a' and 'b' have different\n     * lengths.  By first checking that the maps are the same with the first\n     * memcmp(), we verify that 'a' and 'b' have the same length and therefore\n     * ensure that the second memcmp() is safe. */\n    return (!memcmp(a, b, sizeof *a)\n            && !memcmp(a + 1, b + 1,\n                       MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks))));\n}\n\n/* Returns true if at least one bit matched by 'b' is wildcarded by 'a',\n * false otherwise. */\nbool\nminimask_has_extra(const struct minimask *a, const struct minimask *b)\n{\n    const uint64_t *bp = miniflow_get_values(&b->masks);\n    size_t idx;\n\n    FLOWMAP_FOR_EACH_INDEX(idx, b->masks.map) {\n        uint64_t b_u64 = *bp++;\n\n        /* 'b_u64' is non-zero, check if the data in 'a' is either zero\n         * or misses some of the bits in 'b_u64'. */\n        if (!MINIFLOW_IN_MAP(&a->masks, idx)\n            || ((*miniflow_get__(&a->masks, idx) & b_u64) != b_u64)) {\n            return true; /* 'a' wildcards some bits 'b' doesn't. */\n        }\n    }\n\n    return false;\n}\n\nvoid\nflow_limit_vlans(int vlan_limit)\n{\n    if (vlan_limit <= 0) {\n        flow_vlan_limit = FLOW_MAX_VLAN_HEADERS;\n    } else {\n        flow_vlan_limit = MIN(vlan_limit, FLOW_MAX_VLAN_HEADERS);\n    }\n}\n\nstruct netdev *\nflow_get_tunnel_netdev(struct flow_tnl *tunnel)\n{\n    char iface[IFNAMSIZ];\n    struct in6_addr ip6;\n    struct in6_addr gw;\n\n    if (tunnel->ip_src) {\n        in6_addr_set_mapped_ipv4(&ip6, tunnel->ip_src);\n    } else if (ipv6_addr_is_set(&tunnel->ipv6_src)) {\n        ip6 = tunnel->ipv6_src;\n    } else {\n        return NULL;\n    }\n\n    if (!ovs_router_lookup(0, &ip6, iface, NULL, &gw)) {\n        return NULL;\n    }\n\n    return netdev_from_name(iface);\n}\n"], "filenames": ["lib/flow.c"], "buggy_code_start_loc": [2], "buggy_code_end_loc": [3514], "fixing_code_start_loc": [2], "fixing_code_end_loc": [3527], "type": "CWE-125", "message": "In ovs versions v0.90.0 through v2.5.0 are vulnerable to heap buffer over-read in flow.c. An unsafe comparison of \u201cminimasks\u201d function could lead access to an unmapped region of memory. This vulnerability is capable of crashing the software, memory modification, and possible remote execution.", "other": {"cve": {"id": "CVE-2022-32166", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2022-09-28T10:15:09.560", "lastModified": "2022-11-04T19:17:53.980", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In ovs versions v0.90.0 through v2.5.0 are vulnerable to heap buffer over-read in flow.c. An unsafe comparison of \u201cminimasks\u201d function could lead access to an unmapped region of memory. This vulnerability is capable of crashing the software, memory modification, and possible remote execution."}, {"lang": "es", "value": "ovs versiones v0.90.0 hasta v2.5.0, son vulnerables a una lectura excesiva del buffer de la pila en el archivo flow.c. Una comparaci\u00f3n no segura de la funci\u00f3n \"minimasks\" podr\u00eda conllevar a un acceso a una regi\u00f3n de memoria no mapeada. Esta vulnerabilidad es capaz de bloquear el software, modificar la memoria y una posible ejecuci\u00f3n remota"}], "metrics": {"cvssMetricV31": [{"source": "vulnerabilitylab@mend.io", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "vulnerabilitylab@mend.io", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cloudbase:open_vswitch:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.90.0", "versionEndIncluding": "2.5.0", "matchCriteriaId": "8AEEEAC8-0D7E-4656-90B4-22D040FEA4BA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/cloudbase/ovs/commit/2ed6505555cdcb46f9b1f0329d1491b75290fc73", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/10/msg00036.html", "source": "vulnerabilitylab@mend.io", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.mend.io/vulnerability-database/CVE-2022-32166", "source": "vulnerabilitylab@mend.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cloudbase/ovs/commit/2ed6505555cdcb46f9b1f0329d1491b75290fc73"}}