{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Driver for Meywa-Denki & KAYAC YUREX\n *\n * Copyright (C) 2010 Tomoki Sekiyama (tomoki.sekiyama@gmail.com)\n */\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kref.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/hid.h>\n\n#define DRIVER_AUTHOR \"Tomoki Sekiyama\"\n#define DRIVER_DESC \"Driver for Meywa-Denki & KAYAC YUREX\"\n\n#define YUREX_VENDOR_ID\t\t0x0c45\n#define YUREX_PRODUCT_ID\t0x1010\n\n#define CMD_ACK\t\t'!'\n#define CMD_ANIMATE\t'A'\n#define CMD_COUNT\t'C'\n#define CMD_LED\t\t'L'\n#define CMD_READ\t'R'\n#define CMD_SET\t\t'S'\n#define CMD_VERSION\t'V'\n#define CMD_EOF\t\t0x0d\n#define CMD_PADDING\t0xff\n\n#define YUREX_BUF_SIZE\t\t8\n#define YUREX_WRITE_TIMEOUT\t(HZ*2)\n\n/* table of devices that work with this driver */\nstatic struct usb_device_id yurex_table[] = {\n\t{ USB_DEVICE(YUREX_VENDOR_ID, YUREX_PRODUCT_ID) },\n\t{ }\t\t\t\t\t/* Terminating entry */\n};\nMODULE_DEVICE_TABLE(usb, yurex_table);\n\n#ifdef CONFIG_USB_DYNAMIC_MINORS\n#define YUREX_MINOR_BASE\t0\n#else\n#define YUREX_MINOR_BASE\t192\n#endif\n\n/* Structure to hold all of our device specific stuff */\nstruct usb_yurex {\n\tstruct usb_device\t*udev;\n\tstruct usb_interface\t*interface;\n\t__u8\t\t\tint_in_endpointAddr;\n\tstruct urb\t\t*urb;\t\t/* URB for interrupt in */\n\tunsigned char           *int_buffer;\t/* buffer for intterupt in */\n\tstruct urb\t\t*cntl_urb;\t/* URB for control msg */\n\tstruct usb_ctrlrequest\t*cntl_req;\t/* req for control msg */\n\tunsigned char\t\t*cntl_buffer;\t/* buffer for control msg */\n\n\tstruct kref\t\tkref;\n\tstruct mutex\t\tio_mutex;\n\tstruct fasync_struct\t*async_queue;\n\twait_queue_head_t\twaitq;\n\n\tspinlock_t\t\tlock;\n\t__s64\t\t\tbbu;\t\t/* BBU from device */\n};\n#define to_yurex_dev(d) container_of(d, struct usb_yurex, kref)\n\nstatic struct usb_driver yurex_driver;\nstatic const struct file_operations yurex_fops;\n\n\nstatic void yurex_control_callback(struct urb *urb)\n{\n\tstruct usb_yurex *dev = urb->context;\n\tint status = urb->status;\n\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"%s - control failed: %d\\n\",\n\t\t\t__func__, status);\n\t\twake_up_interruptible(&dev->waitq);\n\t\treturn;\n\t}\n\t/* on success, sender woken up by CMD_ACK int in, or timeout */\n}\n\nstatic void yurex_delete(struct kref *kref)\n{\n\tstruct usb_yurex *dev = to_yurex_dev(kref);\n\n\tdev_dbg(&dev->interface->dev, \"%s\\n\", __func__);\n\n\tusb_put_dev(dev->udev);\n\tif (dev->cntl_urb) {\n\t\tusb_kill_urb(dev->cntl_urb);\n\t\tkfree(dev->cntl_req);\n\t\tif (dev->cntl_buffer)\n\t\t\tusb_free_coherent(dev->udev, YUREX_BUF_SIZE,\n\t\t\t\tdev->cntl_buffer, dev->cntl_urb->transfer_dma);\n\t\tusb_free_urb(dev->cntl_urb);\n\t}\n\tif (dev->urb) {\n\t\tusb_kill_urb(dev->urb);\n\t\tif (dev->int_buffer)\n\t\t\tusb_free_coherent(dev->udev, YUREX_BUF_SIZE,\n\t\t\t\tdev->int_buffer, dev->urb->transfer_dma);\n\t\tusb_free_urb(dev->urb);\n\t}\n\tkfree(dev);\n}\n\n/*\n * usb class driver info in order to get a minor number from the usb core,\n * and to have the device registered with the driver core\n */\nstatic struct usb_class_driver yurex_class = {\n\t.name =\t\t\"yurex%d\",\n\t.fops =\t\t&yurex_fops,\n\t.minor_base =\tYUREX_MINOR_BASE,\n};\n\nstatic void yurex_interrupt(struct urb *urb)\n{\n\tstruct usb_yurex *dev = urb->context;\n\tunsigned char *buf = dev->int_buffer;\n\tint status = urb->status;\n\tunsigned long flags;\n\tint retval, i;\n\n\tswitch (status) {\n\tcase 0: /*success*/\n\t\tbreak;\n\tcase -EOVERFLOW:\n\t\tdev_err(&dev->interface->dev,\n\t\t\t\"%s - overflow with length %d, actual length is %d\\n\",\n\t\t\t__func__, YUREX_BUF_SIZE, dev->urb->actual_length);\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -EILSEQ:\n\t\t/* The device is terminated, clean up */\n\t\treturn;\n\tdefault:\n\t\tdev_err(&dev->interface->dev,\n\t\t\t\"%s - unknown status received: %d\\n\", __func__, status);\n\t\tgoto exit;\n\t}\n\n\t/* handle received message */\n\tswitch (buf[0]) {\n\tcase CMD_COUNT:\n\tcase CMD_READ:\n\t\tif (buf[6] == CMD_EOF) {\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\tdev->bbu = 0;\n\t\t\tfor (i = 1; i < 6; i++) {\n\t\t\t\tdev->bbu += buf[i];\n\t\t\t\tif (i != 5)\n\t\t\t\t\tdev->bbu <<= 8;\n\t\t\t}\n\t\t\tdev_dbg(&dev->interface->dev, \"%s count: %lld\\n\",\n\t\t\t\t__func__, dev->bbu);\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\t\tkill_fasync(&dev->async_queue, SIGIO, POLL_IN);\n\t\t}\n\t\telse\n\t\t\tdev_dbg(&dev->interface->dev,\n\t\t\t\t\"data format error - no EOF\\n\");\n\t\tbreak;\n\tcase CMD_ACK:\n\t\tdev_dbg(&dev->interface->dev, \"%s ack: %c\\n\",\n\t\t\t__func__, buf[1]);\n\t\twake_up_interruptible(&dev->waitq);\n\t\tbreak;\n\t}\n\nexit:\n\tretval = usb_submit_urb(dev->urb, GFP_ATOMIC);\n\tif (retval) {\n\t\tdev_err(&dev->interface->dev, \"%s - usb_submit_urb failed: %d\\n\",\n\t\t\t__func__, retval);\n\t}\n}\n\nstatic int yurex_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct usb_yurex *dev;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint retval = -ENOMEM;\n\tDEFINE_WAIT(wait);\n\tint res;\n\n\t/* allocate memory for our device state and initialize it */\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\tgoto error;\n\tkref_init(&dev->kref);\n\tmutex_init(&dev->io_mutex);\n\tspin_lock_init(&dev->lock);\n\tinit_waitqueue_head(&dev->waitq);\n\n\tdev->udev = usb_get_dev(interface_to_usbdev(interface));\n\tdev->interface = interface;\n\n\t/* set up the endpoint information */\n\tiface_desc = interface->cur_altsetting;\n\tres = usb_find_int_in_endpoint(iface_desc, &endpoint);\n\tif (res) {\n\t\tdev_err(&interface->dev, \"Could not find endpoints\\n\");\n\t\tretval = res;\n\t\tgoto error;\n\t}\n\n\tdev->int_in_endpointAddr = endpoint->bEndpointAddress;\n\n\t/* allocate control URB */\n\tdev->cntl_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->cntl_urb)\n\t\tgoto error;\n\n\t/* allocate buffer for control req */\n\tdev->cntl_req = kmalloc(YUREX_BUF_SIZE, GFP_KERNEL);\n\tif (!dev->cntl_req)\n\t\tgoto error;\n\n\t/* allocate buffer for control msg */\n\tdev->cntl_buffer = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,\n\t\t\t\t\t      GFP_KERNEL,\n\t\t\t\t\t      &dev->cntl_urb->transfer_dma);\n\tif (!dev->cntl_buffer) {\n\t\tdev_err(&interface->dev, \"Could not allocate cntl_buffer\\n\");\n\t\tgoto error;\n\t}\n\n\t/* configure control URB */\n\tdev->cntl_req->bRequestType = USB_DIR_OUT | USB_TYPE_CLASS |\n\t\t\t\t      USB_RECIP_INTERFACE;\n\tdev->cntl_req->bRequest\t= HID_REQ_SET_REPORT;\n\tdev->cntl_req->wValue\t= cpu_to_le16((HID_OUTPUT_REPORT + 1) << 8);\n\tdev->cntl_req->wIndex\t= cpu_to_le16(iface_desc->desc.bInterfaceNumber);\n\tdev->cntl_req->wLength\t= cpu_to_le16(YUREX_BUF_SIZE);\n\n\tusb_fill_control_urb(dev->cntl_urb, dev->udev,\n\t\t\t     usb_sndctrlpipe(dev->udev, 0),\n\t\t\t     (void *)dev->cntl_req, dev->cntl_buffer,\n\t\t\t     YUREX_BUF_SIZE, yurex_control_callback, dev);\n\tdev->cntl_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\n\t/* allocate interrupt URB */\n\tdev->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->urb)\n\t\tgoto error;\n\n\t/* allocate buffer for interrupt in */\n\tdev->int_buffer = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,\n\t\t\t\t\tGFP_KERNEL, &dev->urb->transfer_dma);\n\tif (!dev->int_buffer) {\n\t\tdev_err(&interface->dev, \"Could not allocate int_buffer\\n\");\n\t\tgoto error;\n\t}\n\n\t/* configure interrupt URB */\n\tusb_fill_int_urb(dev->urb, dev->udev,\n\t\t\t usb_rcvintpipe(dev->udev, dev->int_in_endpointAddr),\n\t\t\t dev->int_buffer, YUREX_BUF_SIZE, yurex_interrupt,\n\t\t\t dev, 1);\n\tdev->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tif (usb_submit_urb(dev->urb, GFP_KERNEL)) {\n\t\tretval = -EIO;\n\t\tdev_err(&interface->dev, \"Could not submitting URB\\n\");\n\t\tgoto error;\n\t}\n\n\t/* save our data pointer in this interface device */\n\tusb_set_intfdata(interface, dev);\n\tdev->bbu = -1;\n\n\t/* we can register the device now, as it is ready */\n\tretval = usb_register_dev(interface, &yurex_class);\n\tif (retval) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"Not able to get a minor for this device.\\n\");\n\t\tusb_set_intfdata(interface, NULL);\n\t\tgoto error;\n\t}\n\n\tdev_info(&interface->dev,\n\t\t \"USB YUREX device now attached to Yurex #%d\\n\",\n\t\t interface->minor);\n\n\treturn 0;\n\nerror:\n\tif (dev)\n\t\t/* this frees allocated memory */\n\t\tkref_put(&dev->kref, yurex_delete);\n\treturn retval;\n}\n\nstatic void yurex_disconnect(struct usb_interface *interface)\n{\n\tstruct usb_yurex *dev;\n\tint minor = interface->minor;\n\n\tdev = usb_get_intfdata(interface);\n\tusb_set_intfdata(interface, NULL);\n\n\t/* give back our minor */\n\tusb_deregister_dev(interface, &yurex_class);\n\n\t/* prevent more I/O from starting */\n\tmutex_lock(&dev->io_mutex);\n\tdev->interface = NULL;\n\tmutex_unlock(&dev->io_mutex);\n\n\t/* wakeup waiters */\n\tkill_fasync(&dev->async_queue, SIGIO, POLL_IN);\n\twake_up_interruptible(&dev->waitq);\n\n\t/* decrement our usage count */\n\tkref_put(&dev->kref, yurex_delete);\n\n\tdev_info(&interface->dev, \"USB YUREX #%d now disconnected\\n\", minor);\n}\n\nstatic struct usb_driver yurex_driver = {\n\t.name =\t\t\"yurex\",\n\t.probe =\tyurex_probe,\n\t.disconnect =\tyurex_disconnect,\n\t.id_table =\tyurex_table,\n};\n\n\nstatic int yurex_fasync(int fd, struct file *file, int on)\n{\n\tstruct usb_yurex *dev;\n\n\tdev = file->private_data;\n\treturn fasync_helper(fd, file, on, &dev->async_queue);\n}\n\nstatic int yurex_open(struct inode *inode, struct file *file)\n{\n\tstruct usb_yurex *dev;\n\tstruct usb_interface *interface;\n\tint subminor;\n\tint retval = 0;\n\n\tsubminor = iminor(inode);\n\n\tinterface = usb_find_interface(&yurex_driver, subminor);\n\tif (!interface) {\n\t\tprintk(KERN_ERR \"%s - error, can't find device for minor %d\",\n\t\t       __func__, subminor);\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tdev = usb_get_intfdata(interface);\n\tif (!dev) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t/* increment our usage count for the device */\n\tkref_get(&dev->kref);\n\n\t/* save our object in the file's private structure */\n\tmutex_lock(&dev->io_mutex);\n\tfile->private_data = dev;\n\tmutex_unlock(&dev->io_mutex);\n\nexit:\n\treturn retval;\n}\n\nstatic int yurex_release(struct inode *inode, struct file *file)\n{\n\tstruct usb_yurex *dev;\n\n\tdev = file->private_data;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\t/* decrement the count on our device */\n\tkref_put(&dev->kref, yurex_delete);\n\treturn 0;\n}\n\nstatic ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint retval = 0;\n\tint bytes_read = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t/* already disconnected */\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (*ppos < bytes_read) {\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n\t\t\tretval = -EFAULT;\n\t\telse {\n\t\t\tretval = bytes_read - *ppos;\n\t\t\t*ppos += bytes_read;\n\t\t}\n\t}\n\nexit:\n\tmutex_unlock(&dev->io_mutex);\n\treturn retval;\n}\n\nstatic ssize_t yurex_write(struct file *file, const char __user *user_buffer,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint i, set = 0, retval = 0;\n\tchar buffer[16];\n\tchar *data = buffer;\n\tunsigned long long c, c2 = 0;\n\tsigned long timeout = 0;\n\tDEFINE_WAIT(wait);\n\n\tcount = min(sizeof(buffer), count);\n\tdev = file->private_data;\n\n\t/* verify that we actually have some data to write */\n\tif (count == 0)\n\t\tgoto error;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t/* already disconnected */\n\t\tmutex_unlock(&dev->io_mutex);\n\t\tretval = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (copy_from_user(buffer, user_buffer, count)) {\n\t\tmutex_unlock(&dev->io_mutex);\n\t\tretval = -EFAULT;\n\t\tgoto error;\n\t}\n\tmemset(dev->cntl_buffer, CMD_PADDING, YUREX_BUF_SIZE);\n\n\tswitch (buffer[0]) {\n\tcase CMD_ANIMATE:\n\tcase CMD_LED:\n\t\tdev->cntl_buffer[0] = buffer[0];\n\t\tdev->cntl_buffer[1] = buffer[1];\n\t\tdev->cntl_buffer[2] = CMD_EOF;\n\t\tbreak;\n\tcase CMD_READ:\n\tcase CMD_VERSION:\n\t\tdev->cntl_buffer[0] = buffer[0];\n\t\tdev->cntl_buffer[1] = 0x00;\n\t\tdev->cntl_buffer[2] = CMD_EOF;\n\t\tbreak;\n\tcase CMD_SET:\n\t\tdata++;\n\t\t/* FALL THROUGH */\n\tcase '0' ... '9':\n\t\tset = 1;\n\t\tc = c2 = simple_strtoull(data, NULL, 0);\n\t\tdev->cntl_buffer[0] = CMD_SET;\n\t\tfor (i = 1; i < 6; i++) {\n\t\t\tdev->cntl_buffer[i] = (c>>32) & 0xff;\n\t\t\tc <<= 8;\n\t\t}\n\t\tbuffer[6] = CMD_EOF;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&dev->io_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t/* send the data as the control msg */\n\tprepare_to_wait(&dev->waitq, &wait, TASK_INTERRUPTIBLE);\n\tdev_dbg(&dev->interface->dev, \"%s - submit %c\\n\", __func__,\n\t\tdev->cntl_buffer[0]);\n\tretval = usb_submit_urb(dev->cntl_urb, GFP_KERNEL);\n\tif (retval >= 0)\n\t\ttimeout = schedule_timeout(YUREX_WRITE_TIMEOUT);\n\tfinish_wait(&dev->waitq, &wait);\n\n\tmutex_unlock(&dev->io_mutex);\n\n\tif (retval < 0) {\n\t\tdev_err(&dev->interface->dev,\n\t\t\t\"%s - failed to send bulk msg, error %d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto error;\n\t}\n\tif (set && timeout)\n\t\tdev->bbu = c2;\n\treturn timeout ? count : -EIO;\n\nerror:\n\treturn retval;\n}\n\nstatic const struct file_operations yurex_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tyurex_read,\n\t.write =\tyurex_write,\n\t.open =\t\tyurex_open,\n\t.release =\tyurex_release,\n\t.fasync\t=\tyurex_fasync,\n\t.llseek =\tdefault_llseek,\n};\n\nmodule_usb_driver(yurex_driver);\n\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Driver for Meywa-Denki & KAYAC YUREX\n *\n * Copyright (C) 2010 Tomoki Sekiyama (tomoki.sekiyama@gmail.com)\n */\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kref.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/hid.h>\n\n#define DRIVER_AUTHOR \"Tomoki Sekiyama\"\n#define DRIVER_DESC \"Driver for Meywa-Denki & KAYAC YUREX\"\n\n#define YUREX_VENDOR_ID\t\t0x0c45\n#define YUREX_PRODUCT_ID\t0x1010\n\n#define CMD_ACK\t\t'!'\n#define CMD_ANIMATE\t'A'\n#define CMD_COUNT\t'C'\n#define CMD_LED\t\t'L'\n#define CMD_READ\t'R'\n#define CMD_SET\t\t'S'\n#define CMD_VERSION\t'V'\n#define CMD_EOF\t\t0x0d\n#define CMD_PADDING\t0xff\n\n#define YUREX_BUF_SIZE\t\t8\n#define YUREX_WRITE_TIMEOUT\t(HZ*2)\n\n/* table of devices that work with this driver */\nstatic struct usb_device_id yurex_table[] = {\n\t{ USB_DEVICE(YUREX_VENDOR_ID, YUREX_PRODUCT_ID) },\n\t{ }\t\t\t\t\t/* Terminating entry */\n};\nMODULE_DEVICE_TABLE(usb, yurex_table);\n\n#ifdef CONFIG_USB_DYNAMIC_MINORS\n#define YUREX_MINOR_BASE\t0\n#else\n#define YUREX_MINOR_BASE\t192\n#endif\n\n/* Structure to hold all of our device specific stuff */\nstruct usb_yurex {\n\tstruct usb_device\t*udev;\n\tstruct usb_interface\t*interface;\n\t__u8\t\t\tint_in_endpointAddr;\n\tstruct urb\t\t*urb;\t\t/* URB for interrupt in */\n\tunsigned char           *int_buffer;\t/* buffer for intterupt in */\n\tstruct urb\t\t*cntl_urb;\t/* URB for control msg */\n\tstruct usb_ctrlrequest\t*cntl_req;\t/* req for control msg */\n\tunsigned char\t\t*cntl_buffer;\t/* buffer for control msg */\n\n\tstruct kref\t\tkref;\n\tstruct mutex\t\tio_mutex;\n\tstruct fasync_struct\t*async_queue;\n\twait_queue_head_t\twaitq;\n\n\tspinlock_t\t\tlock;\n\t__s64\t\t\tbbu;\t\t/* BBU from device */\n};\n#define to_yurex_dev(d) container_of(d, struct usb_yurex, kref)\n\nstatic struct usb_driver yurex_driver;\nstatic const struct file_operations yurex_fops;\n\n\nstatic void yurex_control_callback(struct urb *urb)\n{\n\tstruct usb_yurex *dev = urb->context;\n\tint status = urb->status;\n\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"%s - control failed: %d\\n\",\n\t\t\t__func__, status);\n\t\twake_up_interruptible(&dev->waitq);\n\t\treturn;\n\t}\n\t/* on success, sender woken up by CMD_ACK int in, or timeout */\n}\n\nstatic void yurex_delete(struct kref *kref)\n{\n\tstruct usb_yurex *dev = to_yurex_dev(kref);\n\n\tdev_dbg(&dev->interface->dev, \"%s\\n\", __func__);\n\n\tusb_put_dev(dev->udev);\n\tif (dev->cntl_urb) {\n\t\tusb_kill_urb(dev->cntl_urb);\n\t\tkfree(dev->cntl_req);\n\t\tif (dev->cntl_buffer)\n\t\t\tusb_free_coherent(dev->udev, YUREX_BUF_SIZE,\n\t\t\t\tdev->cntl_buffer, dev->cntl_urb->transfer_dma);\n\t\tusb_free_urb(dev->cntl_urb);\n\t}\n\tif (dev->urb) {\n\t\tusb_kill_urb(dev->urb);\n\t\tif (dev->int_buffer)\n\t\t\tusb_free_coherent(dev->udev, YUREX_BUF_SIZE,\n\t\t\t\tdev->int_buffer, dev->urb->transfer_dma);\n\t\tusb_free_urb(dev->urb);\n\t}\n\tkfree(dev);\n}\n\n/*\n * usb class driver info in order to get a minor number from the usb core,\n * and to have the device registered with the driver core\n */\nstatic struct usb_class_driver yurex_class = {\n\t.name =\t\t\"yurex%d\",\n\t.fops =\t\t&yurex_fops,\n\t.minor_base =\tYUREX_MINOR_BASE,\n};\n\nstatic void yurex_interrupt(struct urb *urb)\n{\n\tstruct usb_yurex *dev = urb->context;\n\tunsigned char *buf = dev->int_buffer;\n\tint status = urb->status;\n\tunsigned long flags;\n\tint retval, i;\n\n\tswitch (status) {\n\tcase 0: /*success*/\n\t\tbreak;\n\tcase -EOVERFLOW:\n\t\tdev_err(&dev->interface->dev,\n\t\t\t\"%s - overflow with length %d, actual length is %d\\n\",\n\t\t\t__func__, YUREX_BUF_SIZE, dev->urb->actual_length);\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -EILSEQ:\n\t\t/* The device is terminated, clean up */\n\t\treturn;\n\tdefault:\n\t\tdev_err(&dev->interface->dev,\n\t\t\t\"%s - unknown status received: %d\\n\", __func__, status);\n\t\tgoto exit;\n\t}\n\n\t/* handle received message */\n\tswitch (buf[0]) {\n\tcase CMD_COUNT:\n\tcase CMD_READ:\n\t\tif (buf[6] == CMD_EOF) {\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\tdev->bbu = 0;\n\t\t\tfor (i = 1; i < 6; i++) {\n\t\t\t\tdev->bbu += buf[i];\n\t\t\t\tif (i != 5)\n\t\t\t\t\tdev->bbu <<= 8;\n\t\t\t}\n\t\t\tdev_dbg(&dev->interface->dev, \"%s count: %lld\\n\",\n\t\t\t\t__func__, dev->bbu);\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\t\tkill_fasync(&dev->async_queue, SIGIO, POLL_IN);\n\t\t}\n\t\telse\n\t\t\tdev_dbg(&dev->interface->dev,\n\t\t\t\t\"data format error - no EOF\\n\");\n\t\tbreak;\n\tcase CMD_ACK:\n\t\tdev_dbg(&dev->interface->dev, \"%s ack: %c\\n\",\n\t\t\t__func__, buf[1]);\n\t\twake_up_interruptible(&dev->waitq);\n\t\tbreak;\n\t}\n\nexit:\n\tretval = usb_submit_urb(dev->urb, GFP_ATOMIC);\n\tif (retval) {\n\t\tdev_err(&dev->interface->dev, \"%s - usb_submit_urb failed: %d\\n\",\n\t\t\t__func__, retval);\n\t}\n}\n\nstatic int yurex_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct usb_yurex *dev;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint retval = -ENOMEM;\n\tDEFINE_WAIT(wait);\n\tint res;\n\n\t/* allocate memory for our device state and initialize it */\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\tgoto error;\n\tkref_init(&dev->kref);\n\tmutex_init(&dev->io_mutex);\n\tspin_lock_init(&dev->lock);\n\tinit_waitqueue_head(&dev->waitq);\n\n\tdev->udev = usb_get_dev(interface_to_usbdev(interface));\n\tdev->interface = interface;\n\n\t/* set up the endpoint information */\n\tiface_desc = interface->cur_altsetting;\n\tres = usb_find_int_in_endpoint(iface_desc, &endpoint);\n\tif (res) {\n\t\tdev_err(&interface->dev, \"Could not find endpoints\\n\");\n\t\tretval = res;\n\t\tgoto error;\n\t}\n\n\tdev->int_in_endpointAddr = endpoint->bEndpointAddress;\n\n\t/* allocate control URB */\n\tdev->cntl_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->cntl_urb)\n\t\tgoto error;\n\n\t/* allocate buffer for control req */\n\tdev->cntl_req = kmalloc(YUREX_BUF_SIZE, GFP_KERNEL);\n\tif (!dev->cntl_req)\n\t\tgoto error;\n\n\t/* allocate buffer for control msg */\n\tdev->cntl_buffer = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,\n\t\t\t\t\t      GFP_KERNEL,\n\t\t\t\t\t      &dev->cntl_urb->transfer_dma);\n\tif (!dev->cntl_buffer) {\n\t\tdev_err(&interface->dev, \"Could not allocate cntl_buffer\\n\");\n\t\tgoto error;\n\t}\n\n\t/* configure control URB */\n\tdev->cntl_req->bRequestType = USB_DIR_OUT | USB_TYPE_CLASS |\n\t\t\t\t      USB_RECIP_INTERFACE;\n\tdev->cntl_req->bRequest\t= HID_REQ_SET_REPORT;\n\tdev->cntl_req->wValue\t= cpu_to_le16((HID_OUTPUT_REPORT + 1) << 8);\n\tdev->cntl_req->wIndex\t= cpu_to_le16(iface_desc->desc.bInterfaceNumber);\n\tdev->cntl_req->wLength\t= cpu_to_le16(YUREX_BUF_SIZE);\n\n\tusb_fill_control_urb(dev->cntl_urb, dev->udev,\n\t\t\t     usb_sndctrlpipe(dev->udev, 0),\n\t\t\t     (void *)dev->cntl_req, dev->cntl_buffer,\n\t\t\t     YUREX_BUF_SIZE, yurex_control_callback, dev);\n\tdev->cntl_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\n\t/* allocate interrupt URB */\n\tdev->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->urb)\n\t\tgoto error;\n\n\t/* allocate buffer for interrupt in */\n\tdev->int_buffer = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,\n\t\t\t\t\tGFP_KERNEL, &dev->urb->transfer_dma);\n\tif (!dev->int_buffer) {\n\t\tdev_err(&interface->dev, \"Could not allocate int_buffer\\n\");\n\t\tgoto error;\n\t}\n\n\t/* configure interrupt URB */\n\tusb_fill_int_urb(dev->urb, dev->udev,\n\t\t\t usb_rcvintpipe(dev->udev, dev->int_in_endpointAddr),\n\t\t\t dev->int_buffer, YUREX_BUF_SIZE, yurex_interrupt,\n\t\t\t dev, 1);\n\tdev->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tif (usb_submit_urb(dev->urb, GFP_KERNEL)) {\n\t\tretval = -EIO;\n\t\tdev_err(&interface->dev, \"Could not submitting URB\\n\");\n\t\tgoto error;\n\t}\n\n\t/* save our data pointer in this interface device */\n\tusb_set_intfdata(interface, dev);\n\tdev->bbu = -1;\n\n\t/* we can register the device now, as it is ready */\n\tretval = usb_register_dev(interface, &yurex_class);\n\tif (retval) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"Not able to get a minor for this device.\\n\");\n\t\tusb_set_intfdata(interface, NULL);\n\t\tgoto error;\n\t}\n\n\tdev_info(&interface->dev,\n\t\t \"USB YUREX device now attached to Yurex #%d\\n\",\n\t\t interface->minor);\n\n\treturn 0;\n\nerror:\n\tif (dev)\n\t\t/* this frees allocated memory */\n\t\tkref_put(&dev->kref, yurex_delete);\n\treturn retval;\n}\n\nstatic void yurex_disconnect(struct usb_interface *interface)\n{\n\tstruct usb_yurex *dev;\n\tint minor = interface->minor;\n\n\tdev = usb_get_intfdata(interface);\n\tusb_set_intfdata(interface, NULL);\n\n\t/* give back our minor */\n\tusb_deregister_dev(interface, &yurex_class);\n\n\t/* prevent more I/O from starting */\n\tmutex_lock(&dev->io_mutex);\n\tdev->interface = NULL;\n\tmutex_unlock(&dev->io_mutex);\n\n\t/* wakeup waiters */\n\tkill_fasync(&dev->async_queue, SIGIO, POLL_IN);\n\twake_up_interruptible(&dev->waitq);\n\n\t/* decrement our usage count */\n\tkref_put(&dev->kref, yurex_delete);\n\n\tdev_info(&interface->dev, \"USB YUREX #%d now disconnected\\n\", minor);\n}\n\nstatic struct usb_driver yurex_driver = {\n\t.name =\t\t\"yurex\",\n\t.probe =\tyurex_probe,\n\t.disconnect =\tyurex_disconnect,\n\t.id_table =\tyurex_table,\n};\n\n\nstatic int yurex_fasync(int fd, struct file *file, int on)\n{\n\tstruct usb_yurex *dev;\n\n\tdev = file->private_data;\n\treturn fasync_helper(fd, file, on, &dev->async_queue);\n}\n\nstatic int yurex_open(struct inode *inode, struct file *file)\n{\n\tstruct usb_yurex *dev;\n\tstruct usb_interface *interface;\n\tint subminor;\n\tint retval = 0;\n\n\tsubminor = iminor(inode);\n\n\tinterface = usb_find_interface(&yurex_driver, subminor);\n\tif (!interface) {\n\t\tprintk(KERN_ERR \"%s - error, can't find device for minor %d\",\n\t\t       __func__, subminor);\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tdev = usb_get_intfdata(interface);\n\tif (!dev) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t/* increment our usage count for the device */\n\tkref_get(&dev->kref);\n\n\t/* save our object in the file's private structure */\n\tmutex_lock(&dev->io_mutex);\n\tfile->private_data = dev;\n\tmutex_unlock(&dev->io_mutex);\n\nexit:\n\treturn retval;\n}\n\nstatic int yurex_release(struct inode *inode, struct file *file)\n{\n\tstruct usb_yurex *dev;\n\n\tdev = file->private_data;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\t/* decrement the count on our device */\n\tkref_put(&dev->kref, yurex_delete);\n\treturn 0;\n}\n\nstatic ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint len = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t/* already disconnected */\n\t\tmutex_unlock(&dev->io_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tlen = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tmutex_unlock(&dev->io_mutex);\n\n\treturn simple_read_from_buffer(buffer, count, ppos, in_buffer, len);\n}\n\nstatic ssize_t yurex_write(struct file *file, const char __user *user_buffer,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint i, set = 0, retval = 0;\n\tchar buffer[16];\n\tchar *data = buffer;\n\tunsigned long long c, c2 = 0;\n\tsigned long timeout = 0;\n\tDEFINE_WAIT(wait);\n\n\tcount = min(sizeof(buffer), count);\n\tdev = file->private_data;\n\n\t/* verify that we actually have some data to write */\n\tif (count == 0)\n\t\tgoto error;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t/* already disconnected */\n\t\tmutex_unlock(&dev->io_mutex);\n\t\tretval = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (copy_from_user(buffer, user_buffer, count)) {\n\t\tmutex_unlock(&dev->io_mutex);\n\t\tretval = -EFAULT;\n\t\tgoto error;\n\t}\n\tmemset(dev->cntl_buffer, CMD_PADDING, YUREX_BUF_SIZE);\n\n\tswitch (buffer[0]) {\n\tcase CMD_ANIMATE:\n\tcase CMD_LED:\n\t\tdev->cntl_buffer[0] = buffer[0];\n\t\tdev->cntl_buffer[1] = buffer[1];\n\t\tdev->cntl_buffer[2] = CMD_EOF;\n\t\tbreak;\n\tcase CMD_READ:\n\tcase CMD_VERSION:\n\t\tdev->cntl_buffer[0] = buffer[0];\n\t\tdev->cntl_buffer[1] = 0x00;\n\t\tdev->cntl_buffer[2] = CMD_EOF;\n\t\tbreak;\n\tcase CMD_SET:\n\t\tdata++;\n\t\t/* FALL THROUGH */\n\tcase '0' ... '9':\n\t\tset = 1;\n\t\tc = c2 = simple_strtoull(data, NULL, 0);\n\t\tdev->cntl_buffer[0] = CMD_SET;\n\t\tfor (i = 1; i < 6; i++) {\n\t\t\tdev->cntl_buffer[i] = (c>>32) & 0xff;\n\t\t\tc <<= 8;\n\t\t}\n\t\tbuffer[6] = CMD_EOF;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&dev->io_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t/* send the data as the control msg */\n\tprepare_to_wait(&dev->waitq, &wait, TASK_INTERRUPTIBLE);\n\tdev_dbg(&dev->interface->dev, \"%s - submit %c\\n\", __func__,\n\t\tdev->cntl_buffer[0]);\n\tretval = usb_submit_urb(dev->cntl_urb, GFP_KERNEL);\n\tif (retval >= 0)\n\t\ttimeout = schedule_timeout(YUREX_WRITE_TIMEOUT);\n\tfinish_wait(&dev->waitq, &wait);\n\n\tmutex_unlock(&dev->io_mutex);\n\n\tif (retval < 0) {\n\t\tdev_err(&dev->interface->dev,\n\t\t\t\"%s - failed to send bulk msg, error %d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto error;\n\t}\n\tif (set && timeout)\n\t\tdev->bbu = c2;\n\treturn timeout ? count : -EIO;\n\nerror:\n\treturn retval;\n}\n\nstatic const struct file_operations yurex_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tyurex_read,\n\t.write =\tyurex_write,\n\t.open =\t\tyurex_open,\n\t.release =\tyurex_release,\n\t.fasync\t=\tyurex_fasync,\n\t.llseek =\tdefault_llseek,\n};\n\nmodule_usb_driver(yurex_driver);\n\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/usb/misc/yurex.c"], "buggy_code_start_loc": [399], "buggy_code_end_loc": [428], "fixing_code_start_loc": [399], "fixing_code_end_loc": [417], "type": "CWE-787", "message": "An issue was discovered in yurex_read in drivers/usb/misc/yurex.c in the Linux kernel before 4.17.7. Local attackers could use user access read/writes with incorrect bounds checking in the yurex USB driver to crash the kernel or potentially escalate privileges.", "other": {"cve": {"id": "CVE-2018-16276", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-31T16:29:00.297", "lastModified": "2023-02-24T18:34:53.373", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in yurex_read in drivers/usb/misc/yurex.c in the Linux kernel before 4.17.7. Local attackers could use user access read/writes with incorrect bounds checking in the yurex USB driver to crash the kernel or potentially escalate privileges."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en yurex_read en drivers/usb/misc/yurex.c en el kernel de Linux hasta la versi\u00f3n 4.17.7. Los atacantes locales pueden emplear lecturas/escrituras de acceso de usuario con una comprobaci\u00f3n incorrecta de l\u00edmites en el controlador USB yurex para provocar el cierre inesperado del kernel o escalar privilegios."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.37", "versionEndExcluding": "3.16.58", "matchCriteriaId": "6709E332-D8F5-4A37-8A4F-4A0B3FF3DF68"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.116", "matchCriteriaId": "B705DF0B-72E0-4235-B926-487421212142"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.4.141", "matchCriteriaId": "82C20CB4-34CD-4F0F-A814-1F8556E44926"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.113", "matchCriteriaId": "A6849CAE-E4B6-4599-BDE0-0E0C2B1E27B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.14.56", "matchCriteriaId": "258042EC-C23D-49FC-8DC4-6FE8E59C0EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15", "versionEndExcluding": "4.17.7", "matchCriteriaId": "EBF5119F-9F8D-4D56-A013-47E6BDD3D56F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f1e255d60ae66a9f672ff9a207ee6cd8e33d2679", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1106095", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1115593", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.17.7", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/f1e255d60ae66a9f672ff9a207ee6cd8e33d2679", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/10/msg00003.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3776-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3776-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3847-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3847-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3847-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3849-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3849-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4308", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f1e255d60ae66a9f672ff9a207ee6cd8e33d2679"}}