{"buggy_code": ["# frozen_string_literal: true\n\nclass IO\n  # We need to use this for a jruby work around on both 1.8 and 1.9.\n  # So this either creates the constant (on 1.8), or harmlessly\n  # reopens it (on 1.9).\n  module WaitReadable\n  end\nend\n\nrequire 'puma/detect'\nrequire 'tempfile'\nrequire 'forwardable'\n\nif Puma::IS_JRUBY\n  # We have to work around some OpenSSL buffer/io-readiness bugs\n  # so we pull it in regardless of if the user is binding\n  # to an SSL socket\n  require 'openssl'\nend\n\nmodule Puma\n\n  class ConnectionError < RuntimeError; end\n\n  # An instance of this class represents a unique request from a client.\n  # For example, this could be a web request from a browser or from CURL.\n  #\n  # An instance of `Puma::Client` can be used as if it were an IO object\n  # by the reactor. The reactor is expected to call `#to_io`\n  # on any non-IO objects it polls. For example, nio4r internally calls\n  # `IO::try_convert` (which may call `#to_io`) when a new socket is\n  # registered.\n  #\n  # Instances of this class are responsible for knowing if\n  # the header and body are fully buffered via the `try_to_finish` method.\n  # They can be used to \"time out\" a response via the `timeout_at` reader.\n  class Client\n    # The object used for a request with no body. All requests with\n    # no body share this one object since it has no state.\n    EmptyBody = NullIO.new\n\n    include Puma::Const\n    extend Forwardable\n\n    def initialize(io, env=nil)\n      @io = io\n      @to_io = io.to_io\n      @proto_env = env\n      if !env\n        @env = nil\n      else\n        @env = env.dup\n      end\n\n      @parser = HttpParser.new\n      @parsed_bytes = 0\n      @read_header = true\n      @ready = false\n\n      @body = nil\n      @body_read_start = nil\n      @buffer = nil\n      @tempfile = nil\n\n      @timeout_at = nil\n\n      @requests_served = 0\n      @hijacked = false\n\n      @peerip = nil\n      @remote_addr_header = nil\n\n      @body_remain = 0\n\n      @in_last_chunk = false\n    end\n\n    attr_reader :env, :to_io, :body, :io, :timeout_at, :ready, :hijacked,\n                :tempfile\n\n    attr_writer :peerip\n\n    attr_accessor :remote_addr_header\n\n    def_delegators :@io, :closed?\n\n    def inspect\n      \"#<Puma::Client:0x#{object_id.to_s(16)} @ready=#{@ready.inspect}>\"\n    end\n\n    # For the hijack protocol (allows us to just put the Client object\n    # into the env)\n    def call\n      @hijacked = true\n      env[HIJACK_IO] ||= @io\n    end\n\n    def in_data_phase\n      !@read_header\n    end\n\n    def set_timeout(val)\n      @timeout_at = Time.now + val\n    end\n\n    def reset(fast_check=true)\n      @parser.reset\n      @read_header = true\n      @env = @proto_env.dup\n      @body = nil\n      @tempfile = nil\n      @parsed_bytes = 0\n      @ready = false\n      @body_remain = 0\n      @peerip = nil\n      @in_last_chunk = false\n\n      if @buffer\n        @parsed_bytes = @parser.execute(@env, @buffer, @parsed_bytes)\n\n        if @parser.finished?\n          return setup_body\n        elsif @parsed_bytes >= MAX_HEADER\n          raise HttpParserError,\n            \"HEADER is longer than allowed, aborting client early.\"\n        end\n\n        return false\n      else\n        begin\n          if fast_check &&\n              IO.select([@to_io], nil, nil, FAST_TRACK_KA_TIMEOUT)\n            return try_to_finish\n          end\n        rescue IOError\n          # swallow it\n        end\n\n      end\n    end\n\n    def close\n      begin\n        @io.close\n      rescue IOError\n        Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n      end\n    end\n\n    def try_to_finish\n      return read_body unless @read_header\n\n      begin\n        data = @io.read_nonblock(CHUNK_SIZE)\n      rescue Errno::EAGAIN\n        return false\n      rescue SystemCallError, IOError, EOFError\n        raise ConnectionError, \"Connection error detected during read\"\n      end\n\n      # No data means a closed socket\n      unless data\n        @buffer = nil\n        set_ready\n        raise EOFError\n      end\n\n      if @buffer\n        @buffer << data\n      else\n        @buffer = data\n      end\n\n      @parsed_bytes = @parser.execute(@env, @buffer, @parsed_bytes)\n\n      if @parser.finished?\n        return setup_body\n      elsif @parsed_bytes >= MAX_HEADER\n        raise HttpParserError,\n          \"HEADER is longer than allowed, aborting client early.\"\n      end\n\n      false\n    end\n\n    if IS_JRUBY\n      def jruby_start_try_to_finish\n        return read_body unless @read_header\n\n        begin\n          data = @io.sysread_nonblock(CHUNK_SIZE)\n        rescue OpenSSL::SSL::SSLError => e\n          return false if e.kind_of? IO::WaitReadable\n          raise e\n        end\n\n        # No data means a closed socket\n        unless data\n          @buffer = nil\n          set_ready\n          raise EOFError\n        end\n\n        if @buffer\n          @buffer << data\n        else\n          @buffer = data\n        end\n\n        @parsed_bytes = @parser.execute(@env, @buffer, @parsed_bytes)\n\n        if @parser.finished?\n          return setup_body\n        elsif @parsed_bytes >= MAX_HEADER\n          raise HttpParserError,\n            \"HEADER is longer than allowed, aborting client early.\"\n        end\n\n        false\n      end\n\n      def eagerly_finish\n        return true if @ready\n\n        if @io.kind_of? OpenSSL::SSL::SSLSocket\n          return true if jruby_start_try_to_finish\n        end\n\n        return false unless IO.select([@to_io], nil, nil, 0)\n        try_to_finish\n      end\n\n    else\n\n      def eagerly_finish\n        return true if @ready\n        return false unless IO.select([@to_io], nil, nil, 0)\n        try_to_finish\n      end\n    end # IS_JRUBY\n\n    def finish\n      return true if @ready\n      until try_to_finish\n        IO.select([@to_io], nil, nil)\n      end\n      true\n    end\n\n    def write_error(status_code)\n      begin\n        @io << ERROR_RESPONSE[status_code]\n      rescue StandardError\n      end\n    end\n\n    def peerip\n      return @peerip if @peerip\n\n      if @remote_addr_header\n        hdr = (@env[@remote_addr_header] || LOCALHOST_ADDR).split(/[\\s,]/).first\n        @peerip = hdr\n        return hdr\n      end\n\n      @peerip ||= @io.peeraddr.last\n    end\n\n    private\n\n    def setup_body\n      @body_read_start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :millisecond)\n\n      if @env[HTTP_EXPECT] == CONTINUE\n        # TODO allow a hook here to check the headers before\n        # going forward\n        @io << HTTP_11_100\n        @io.flush\n      end\n\n      @read_header = false\n\n      body = @parser.body\n\n      te = @env[TRANSFER_ENCODING2]\n\n      if te && CHUNKED.casecmp(te) == 0\n        return setup_chunked_body(body)\n      end\n\n      @chunked_body = false\n\n      cl = @env[CONTENT_LENGTH]\n\n      unless cl\n        @buffer = body.empty? ? nil : body\n        @body = EmptyBody\n        set_ready\n        return true\n      end\n\n      remain = cl.to_i - body.bytesize\n\n      if remain <= 0\n        @body = StringIO.new(body)\n        @buffer = nil\n        set_ready\n        return true\n      end\n\n      if remain > MAX_BODY\n        @body = Tempfile.new(Const::PUMA_TMP_BASE)\n        @body.binmode\n        @tempfile = @body\n      else\n        # The body[0,0] trick is to get an empty string in the same\n        # encoding as body.\n        @body = StringIO.new body[0,0]\n      end\n\n      @body.write body\n\n      @body_remain = remain\n\n      return false\n    end\n\n    def read_body\n      if @chunked_body\n        return read_chunked_body\n      end\n\n      # Read an odd sized chunk so we can read even sized ones\n      # after this\n      remain = @body_remain\n\n      if remain > CHUNK_SIZE\n        want = CHUNK_SIZE\n      else\n        want = remain\n      end\n\n      begin\n        chunk = @io.read_nonblock(want)\n      rescue Errno::EAGAIN\n        return false\n      rescue SystemCallError, IOError\n        raise ConnectionError, \"Connection error detected during read\"\n      end\n\n      # No chunk means a closed socket\n      unless chunk\n        @body.close\n        @buffer = nil\n        set_ready\n        raise EOFError\n      end\n\n      remain -= @body.write(chunk)\n\n      if remain <= 0\n        @body.rewind\n        @buffer = nil\n        set_ready\n        return true\n      end\n\n      @body_remain = remain\n\n      false\n    end\n\n    def read_chunked_body\n      while true\n        begin\n          chunk = @io.read_nonblock(4096)\n        rescue IO::WaitReadable\n          return false\n        rescue SystemCallError, IOError\n          raise ConnectionError, \"Connection error detected during read\"\n        end\n\n        # No chunk means a closed socket\n        unless chunk\n          @body.close\n          @buffer = nil\n          set_ready\n          raise EOFError\n        end\n\n        return true if decode_chunk(chunk)\n      end\n    end\n\n    def setup_chunked_body(body)\n      @chunked_body = true\n      @partial_part_left = 0\n      @prev_chunk = \"\"\n\n      @body = Tempfile.new(Const::PUMA_TMP_BASE)\n      @body.binmode\n      @tempfile = @body\n\n      return decode_chunk(body)\n    end\n\n    def decode_chunk(chunk)\n      if @partial_part_left > 0\n        if @partial_part_left <= chunk.size\n          if @partial_part_left > 2\n            @body << chunk[0..(@partial_part_left-3)] # skip the \\r\\n\n          end\n          chunk = chunk[@partial_part_left..-1]\n          @partial_part_left = 0\n        else\n          @body << chunk if @partial_part_left > 2 # don't include the last \\r\\n\n          @partial_part_left -= chunk.size\n          return false\n        end\n      end\n\n      if @prev_chunk.empty?\n        io = StringIO.new(chunk)\n      else\n        io = StringIO.new(@prev_chunk+chunk)\n        @prev_chunk = \"\"\n      end\n\n      while !io.eof?\n        line = io.gets\n        if line.end_with?(\"\\r\\n\")\n          len = line.strip.to_i(16)\n          if len == 0\n            @in_last_chunk = true\n            @body.rewind\n            rest = io.read\n            last_crlf_size = \"\\r\\n\".bytesize\n            if rest.bytesize < last_crlf_size\n              @buffer = nil\n              @partial_part_left = last_crlf_size - rest.bytesize\n              return false\n            else\n              @buffer = rest[last_crlf_size..-1]\n              @buffer = nil if @buffer.empty?\n              set_ready\n              return true\n            end\n          end\n\n          len += 2\n\n          part = io.read(len)\n\n          unless part\n            @partial_part_left = len\n            next\n          end\n\n          got = part.size\n\n          case\n          when got == len\n            @body << part[0..-3] # to skip the ending \\r\\n\n          when got <= len - 2\n            @body << part\n            @partial_part_left = len - part.size\n          when got == len - 1 # edge where we get just \\r but not \\n\n            @body << part[0..-2]\n            @partial_part_left = len - part.size\n          end\n        else\n          @prev_chunk = line\n          return false\n        end\n      end\n\n      if @in_last_chunk\n        set_ready\n        true\n      else\n        false\n      end\n    end\n\n    def set_ready\n      if @body_read_start\n        @env['puma.request_body_wait'] = Process.clock_gettime(Process::CLOCK_MONOTONIC, :millisecond) - @body_read_start\n      end\n      @requests_served += 1\n      @ready = true\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass IO\n  # We need to use this for a jruby work around on both 1.8 and 1.9.\n  # So this either creates the constant (on 1.8), or harmlessly\n  # reopens it (on 1.9).\n  module WaitReadable\n  end\nend\n\nrequire 'puma/detect'\nrequire 'tempfile'\nrequire 'forwardable'\n\nif Puma::IS_JRUBY\n  # We have to work around some OpenSSL buffer/io-readiness bugs\n  # so we pull it in regardless of if the user is binding\n  # to an SSL socket\n  require 'openssl'\nend\n\nmodule Puma\n\n  class ConnectionError < RuntimeError; end\n\n  # An instance of this class represents a unique request from a client.\n  # For example, this could be a web request from a browser or from CURL.\n  #\n  # An instance of `Puma::Client` can be used as if it were an IO object\n  # by the reactor. The reactor is expected to call `#to_io`\n  # on any non-IO objects it polls. For example, nio4r internally calls\n  # `IO::try_convert` (which may call `#to_io`) when a new socket is\n  # registered.\n  #\n  # Instances of this class are responsible for knowing if\n  # the header and body are fully buffered via the `try_to_finish` method.\n  # They can be used to \"time out\" a response via the `timeout_at` reader.\n  class Client\n    # The object used for a request with no body. All requests with\n    # no body share this one object since it has no state.\n    EmptyBody = NullIO.new\n\n    include Puma::Const\n    extend Forwardable\n\n    def initialize(io, env=nil)\n      @io = io\n      @to_io = io.to_io\n      @proto_env = env\n      if !env\n        @env = nil\n      else\n        @env = env.dup\n      end\n\n      @parser = HttpParser.new\n      @parsed_bytes = 0\n      @read_header = true\n      @ready = false\n\n      @body = nil\n      @body_read_start = nil\n      @buffer = nil\n      @tempfile = nil\n\n      @timeout_at = nil\n\n      @requests_served = 0\n      @hijacked = false\n\n      @peerip = nil\n      @remote_addr_header = nil\n\n      @body_remain = 0\n\n      @in_last_chunk = false\n    end\n\n    attr_reader :env, :to_io, :body, :io, :timeout_at, :ready, :hijacked,\n                :tempfile\n\n    attr_writer :peerip\n\n    attr_accessor :remote_addr_header\n\n    def_delegators :@io, :closed?\n\n    def inspect\n      \"#<Puma::Client:0x#{object_id.to_s(16)} @ready=#{@ready.inspect}>\"\n    end\n\n    # For the hijack protocol (allows us to just put the Client object\n    # into the env)\n    def call\n      @hijacked = true\n      env[HIJACK_IO] ||= @io\n    end\n\n    def in_data_phase\n      !@read_header\n    end\n\n    def set_timeout(val)\n      @timeout_at = Time.now + val\n    end\n\n    def reset(fast_check=true)\n      @parser.reset\n      @read_header = true\n      @env = @proto_env.dup\n      @body = nil\n      @tempfile = nil\n      @parsed_bytes = 0\n      @ready = false\n      @body_remain = 0\n      @peerip = nil\n      @in_last_chunk = false\n\n      if @buffer\n        @parsed_bytes = @parser.execute(@env, @buffer, @parsed_bytes)\n\n        if @parser.finished?\n          return setup_body\n        elsif @parsed_bytes >= MAX_HEADER\n          raise HttpParserError,\n            \"HEADER is longer than allowed, aborting client early.\"\n        end\n\n        return false\n      else\n        begin\n          if fast_check &&\n              IO.select([@to_io], nil, nil, FAST_TRACK_KA_TIMEOUT)\n            return try_to_finish\n          end\n        rescue IOError\n          # swallow it\n        end\n\n      end\n    end\n\n    def close\n      begin\n        @io.close\n      rescue IOError\n        Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n      end\n    end\n\n    def try_to_finish\n      return read_body unless @read_header\n\n      begin\n        data = @io.read_nonblock(CHUNK_SIZE)\n      rescue Errno::EAGAIN\n        return false\n      rescue SystemCallError, IOError, EOFError\n        raise ConnectionError, \"Connection error detected during read\"\n      end\n\n      # No data means a closed socket\n      unless data\n        @buffer = nil\n        set_ready\n        raise EOFError\n      end\n\n      if @buffer\n        @buffer << data\n      else\n        @buffer = data\n      end\n\n      @parsed_bytes = @parser.execute(@env, @buffer, @parsed_bytes)\n\n      if @parser.finished?\n        return setup_body\n      elsif @parsed_bytes >= MAX_HEADER\n        raise HttpParserError,\n          \"HEADER is longer than allowed, aborting client early.\"\n      end\n\n      false\n    end\n\n    if IS_JRUBY\n      def jruby_start_try_to_finish\n        return read_body unless @read_header\n\n        begin\n          data = @io.sysread_nonblock(CHUNK_SIZE)\n        rescue OpenSSL::SSL::SSLError => e\n          return false if e.kind_of? IO::WaitReadable\n          raise e\n        end\n\n        # No data means a closed socket\n        unless data\n          @buffer = nil\n          set_ready\n          raise EOFError\n        end\n\n        if @buffer\n          @buffer << data\n        else\n          @buffer = data\n        end\n\n        @parsed_bytes = @parser.execute(@env, @buffer, @parsed_bytes)\n\n        if @parser.finished?\n          return setup_body\n        elsif @parsed_bytes >= MAX_HEADER\n          raise HttpParserError,\n            \"HEADER is longer than allowed, aborting client early.\"\n        end\n\n        false\n      end\n\n      def eagerly_finish\n        return true if @ready\n\n        if @io.kind_of? OpenSSL::SSL::SSLSocket\n          return true if jruby_start_try_to_finish\n        end\n\n        return false unless IO.select([@to_io], nil, nil, 0)\n        try_to_finish\n      end\n\n    else\n\n      def eagerly_finish\n        return true if @ready\n        return false unless IO.select([@to_io], nil, nil, 0)\n        try_to_finish\n      end\n    end # IS_JRUBY\n\n    def finish\n      return true if @ready\n      until try_to_finish\n        IO.select([@to_io], nil, nil)\n      end\n      true\n    end\n\n    def write_error(status_code)\n      begin\n        @io << ERROR_RESPONSE[status_code]\n      rescue StandardError\n      end\n    end\n\n    def peerip\n      return @peerip if @peerip\n\n      if @remote_addr_header\n        hdr = (@env[@remote_addr_header] || LOCALHOST_ADDR).split(/[\\s,]/).first\n        @peerip = hdr\n        return hdr\n      end\n\n      @peerip ||= @io.peeraddr.last\n    end\n\n    private\n\n    def setup_body\n      @body_read_start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :millisecond)\n\n      if @env[HTTP_EXPECT] == CONTINUE\n        # TODO allow a hook here to check the headers before\n        # going forward\n        @io << HTTP_11_100\n        @io.flush\n      end\n\n      @read_header = false\n\n      body = @parser.body\n\n      te = @env[TRANSFER_ENCODING2]\n\n      if te\n        if te.include?(\",\")\n          te.split(\",\").each do |part|\n            if CHUNKED.casecmp(part.strip) == 0\n              return setup_chunked_body(body)\n            end\n          end\n        elsif CHUNKED.casecmp(te) == 0\n          return setup_chunked_body(body)\n        end\n      end\n\n      @chunked_body = false\n\n      cl = @env[CONTENT_LENGTH]\n\n      unless cl\n        @buffer = body.empty? ? nil : body\n        @body = EmptyBody\n        set_ready\n        return true\n      end\n\n      remain = cl.to_i - body.bytesize\n\n      if remain <= 0\n        @body = StringIO.new(body)\n        @buffer = nil\n        set_ready\n        return true\n      end\n\n      if remain > MAX_BODY\n        @body = Tempfile.new(Const::PUMA_TMP_BASE)\n        @body.binmode\n        @tempfile = @body\n      else\n        # The body[0,0] trick is to get an empty string in the same\n        # encoding as body.\n        @body = StringIO.new body[0,0]\n      end\n\n      @body.write body\n\n      @body_remain = remain\n\n      return false\n    end\n\n    def read_body\n      if @chunked_body\n        return read_chunked_body\n      end\n\n      # Read an odd sized chunk so we can read even sized ones\n      # after this\n      remain = @body_remain\n\n      if remain > CHUNK_SIZE\n        want = CHUNK_SIZE\n      else\n        want = remain\n      end\n\n      begin\n        chunk = @io.read_nonblock(want)\n      rescue Errno::EAGAIN\n        return false\n      rescue SystemCallError, IOError\n        raise ConnectionError, \"Connection error detected during read\"\n      end\n\n      # No chunk means a closed socket\n      unless chunk\n        @body.close\n        @buffer = nil\n        set_ready\n        raise EOFError\n      end\n\n      remain -= @body.write(chunk)\n\n      if remain <= 0\n        @body.rewind\n        @buffer = nil\n        set_ready\n        return true\n      end\n\n      @body_remain = remain\n\n      false\n    end\n\n    def read_chunked_body\n      while true\n        begin\n          chunk = @io.read_nonblock(4096)\n        rescue IO::WaitReadable\n          return false\n        rescue SystemCallError, IOError\n          raise ConnectionError, \"Connection error detected during read\"\n        end\n\n        # No chunk means a closed socket\n        unless chunk\n          @body.close\n          @buffer = nil\n          set_ready\n          raise EOFError\n        end\n\n        return true if decode_chunk(chunk)\n      end\n    end\n\n    def setup_chunked_body(body)\n      @chunked_body = true\n      @partial_part_left = 0\n      @prev_chunk = \"\"\n\n      @body = Tempfile.new(Const::PUMA_TMP_BASE)\n      @body.binmode\n      @tempfile = @body\n\n      return decode_chunk(body)\n    end\n\n    def decode_chunk(chunk)\n      if @partial_part_left > 0\n        if @partial_part_left <= chunk.size\n          if @partial_part_left > 2\n            @body << chunk[0..(@partial_part_left-3)] # skip the \\r\\n\n          end\n          chunk = chunk[@partial_part_left..-1]\n          @partial_part_left = 0\n        else\n          @body << chunk if @partial_part_left > 2 # don't include the last \\r\\n\n          @partial_part_left -= chunk.size\n          return false\n        end\n      end\n\n      if @prev_chunk.empty?\n        io = StringIO.new(chunk)\n      else\n        io = StringIO.new(@prev_chunk+chunk)\n        @prev_chunk = \"\"\n      end\n\n      while !io.eof?\n        line = io.gets\n        if line.end_with?(\"\\r\\n\")\n          len = line.strip.to_i(16)\n          if len == 0\n            @in_last_chunk = true\n            @body.rewind\n            rest = io.read\n            last_crlf_size = \"\\r\\n\".bytesize\n            if rest.bytesize < last_crlf_size\n              @buffer = nil\n              @partial_part_left = last_crlf_size - rest.bytesize\n              return false\n            else\n              @buffer = rest[last_crlf_size..-1]\n              @buffer = nil if @buffer.empty?\n              set_ready\n              return true\n            end\n          end\n\n          len += 2\n\n          part = io.read(len)\n\n          unless part\n            @partial_part_left = len\n            next\n          end\n\n          got = part.size\n\n          case\n          when got == len\n            @body << part[0..-3] # to skip the ending \\r\\n\n          when got <= len - 2\n            @body << part\n            @partial_part_left = len - part.size\n          when got == len - 1 # edge where we get just \\r but not \\n\n            @body << part[0..-2]\n            @partial_part_left = len - part.size\n          end\n        else\n          @prev_chunk = line\n          return false\n        end\n      end\n\n      if @in_last_chunk\n        set_ready\n        true\n      else\n        false\n      end\n    end\n\n    def set_ready\n      if @body_read_start\n        @env['puma.request_body_wait'] = Process.clock_gettime(Process::CLOCK_MONOTONIC, :millisecond) - @body_read_start\n      end\n      @requests_served += 1\n      @ready = true\n    end\n  end\nend\n"], "filenames": ["lib/puma/client.rb"], "buggy_code_start_loc": [288], "buggy_code_end_loc": [290], "fixing_code_start_loc": [288], "fixing_code_end_loc": [298], "type": "CWE-444", "message": "In Puma (RubyGem) before 4.3.4 and 3.12.5, an attacker could smuggle an HTTP response, by using an invalid transfer-encoding header. The problem has been fixed in Puma 3.12.5 and Puma 4.3.4.", "other": {"cve": {"id": "CVE-2020-11076", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-22T15:15:11.363", "lastModified": "2023-03-03T02:39:26.110", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Puma (RubyGem) before 4.3.4 and 3.12.5, an attacker could smuggle an HTTP response, by using an invalid transfer-encoding header. The problem has been fixed in Puma 3.12.5 and Puma 4.3.4."}, {"lang": "es", "value": "En Puma (RubyGem) versiones anteriores a 4.3.4 y 3.12.5, un atacante podr\u00eda hacer pasar sin autorizaci\u00f3n una respuesta HTTP, mediante el uso de un encabezado de codificaci\u00f3n transfer no v\u00e1lido. El problema ha sido corregido en Puma versi\u00f3n 3.12.5 y Puma versi\u00f3n 4.3.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:puma:puma:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.12.6", "matchCriteriaId": "94D6645C-59B2-466F-A147-B23EF284DEBA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puma:puma:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.3.5", "matchCriteriaId": "916E4164-0951-4145-85D6-684EF781F13A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00034.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00038.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/puma/puma/blob/master/History.md#434435-and-31253126--2020-05-22", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/puma/puma/commit/f24d5521295a2152c286abb0a45a1e1e2bd275bd", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/puma/puma/security/advisories/GHSA-x7jg-6pwg-fx5h", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00009.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SKIY5H67GJIGJL6SMFWFLUQQQR3EMVPR/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/puma/puma/commit/f24d5521295a2152c286abb0a45a1e1e2bd275bd"}}