{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.flamingo.test.docker;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.xwiki.flamingo.skin.test.po.AttachmentsPane;\nimport org.xwiki.flamingo.skin.test.po.AttachmentsViewPage;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.rest.model.jaxb.Page;\nimport org.xwiki.test.docker.junit5.TestConfiguration;\nimport org.xwiki.test.docker.junit5.TestReference;\nimport org.xwiki.test.docker.junit5.UITest;\nimport org.xwiki.test.ui.TestUtils;\nimport org.xwiki.test.ui.po.ChangesPane;\nimport org.xwiki.test.ui.po.ComparePage;\nimport org.xwiki.test.ui.po.DeletePageOutcomePage;\nimport org.xwiki.test.ui.po.HistoryPane;\nimport org.xwiki.test.ui.po.ViewPage;\nimport org.xwiki.test.ui.po.diff.DocumentDiffSummary;\nimport org.xwiki.test.ui.po.diff.EntityDiff;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Tests related to the attachments.\n *\n * @version $Id$\n * @since 11.3RC1\n */\n@UITest(properties = {\n    // Add the FileUploadPlugin which is needed by the test to upload attachment files\n    \"xwikiCfgPlugins=com.xpn.xwiki.plugin.fileupload.FileUploadPlugin\"\n})\nclass AttachmentIT\n{\n    private static final String FIRST_ATTACHMENT = \"SmallAttachment.txt\";\n\n    private static final String SECOND_ATTACHMENT = \"SmallAttachment2.txt\";\n\n    private static final String IMAGE_ATTACHMENT = \"image.gif\";\n\n    private static final String SMALL_SIZE_ATTACHMENT = \"SmallSizeAttachment.png\";\n\n    private static final String CHOICE_EMPTY = \"(empty)\";\n\n    @BeforeAll\n    public void setup(TestUtils setup)\n    {\n        setup.createUser(\"User2\", \"pass\", \"\");\n        setup.createUserAndLogin(\"User1\", \"pass\");\n    }\n\n    private File getFileToUpload(TestConfiguration testConfiguration, String filename)\n    {\n        return new File(testConfiguration.getBrowser().getTestResourcesPath(), \"AttachmentIT/\" + filename);\n    }\n\n    /**\n     * Ensure that the attachment is properly deleted through the UI.\n     *\n     * @throws Exception in case of errors\n     */\n    @Test\n    @Order(1)\n    void uploadAttachments(TestUtils setup, TestReference testReference, TestConfiguration testConfiguration)\n        throws Exception\n    {\n        String testPageName = setup.serializeReference(testReference).split(\":\")[1];\n        setup.rest().delete(testReference);\n        setup.rest().savePage(testReference, \"\", \"\");\n        Page page = setup.rest().get(testReference);\n        // We make the page hidden as we identified some issues specific to hidden pages (see XWIKI-20093).\n        // If it happens that some issues are specific to non-hidden pages, the test will need to be improved to \n        // cover both cases (which will make the execution time of the test suite larger).\n        page.setHidden(true);\n        setup.rest().save(page);\n        ViewPage viewPage = setup.gotoPage(testReference);\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n\n        // Upload two attachments and check them\n        attachmentsPane.setFileToUpload(getFileToUpload(testConfiguration, FIRST_ATTACHMENT).getAbsolutePath());\n        attachmentsPane.waitForUploadToFinish(FIRST_ATTACHMENT);\n        attachmentsPane.clickHideProgress();\n        attachmentsPane.setFileToUpload(getFileToUpload(testConfiguration, SECOND_ATTACHMENT).getAbsolutePath());\n        attachmentsPane.waitForUploadToFinish(SECOND_ATTACHMENT);\n        attachmentsPane.clickHideProgress();\n        assertEquals(2, attachmentsPane.getNumberOfAttachments());\n        assertTrue(attachmentsPane.attachmentExistsByFileName(FIRST_ATTACHMENT));\n        assertTrue(attachmentsPane.attachmentExistsByFileName(SECOND_ATTACHMENT));\n        assertEquals(\"1.1\", attachmentsPane.getLatestVersionOfAttachment(FIRST_ATTACHMENT));\n        assertEquals(\"1.1\", attachmentsPane.getLatestVersionOfAttachment(SECOND_ATTACHMENT));\n\n        String attachmentURLScheme = String.format(\"%sdownload/%s/%%s?rev=1.1\", setup.getBaseBinURL(),\n            testPageName.replace('.', '/'));\n        assertEquals(String.format(attachmentURLScheme, FIRST_ATTACHMENT),\n            attachmentsPane.getAttachmentLink(FIRST_ATTACHMENT).getAttribute(\"href\"));\n        assertEquals(String.format(attachmentURLScheme, SECOND_ATTACHMENT),\n            attachmentsPane.getAttachmentLink(SECOND_ATTACHMENT).getAttribute(\"href\"));\n\n        attachmentsPane.getAttachmentLink(FIRST_ATTACHMENT).click();\n        assertEquals(\"This is a small attachment.\", setup.getDriver().findElement(By.tagName(\"html\")).getText());\n        setup.getDriver().navigate().back();\n\n        // TODO: remove when https://jira.xwiki.org/browse/XWIKI-15513 is fixed\n        setup.getDriver().navigate().refresh();\n        viewPage.waitForDocExtraPaneActive(\"attachments\");\n\n        attachmentsPane.getAttachmentLink(SECOND_ATTACHMENT).click();\n        assertEquals(\"This is another small attachment.\", setup.getDriver().findElement(By.tagName(\"html\")).getText());\n        setup.getDriver().navigate().back();\n        // TODO: remove when https://jira.xwiki.org/browse/XWIKI-15513 is fixed\n        setup.getDriver().navigate().refresh();\n        viewPage.waitForDocExtraPaneActive(\"attachments\");\n\n        // Upload another version of the first attachment\n        attachmentsPane.setFileToUpload(getFileToUpload(testConfiguration, \"v2/\" + FIRST_ATTACHMENT).getAbsolutePath());\n        attachmentsPane.waitForUploadToFinish(FIRST_ATTACHMENT);\n        attachmentsPane.clickHideProgress();\n        assertTrue(attachmentsPane.attachmentExistsByFileName(FIRST_ATTACHMENT));\n        assertEquals(\"1.2\", attachmentsPane.getLatestVersionOfAttachment(FIRST_ATTACHMENT));\n        String attachmentURL = String.format(\"%sdownload/%s/%s?rev=1.2\", setup.getBaseBinURL(),\n            testPageName.replace('.', '/'), FIRST_ATTACHMENT);\n        assertEquals(attachmentURL, attachmentsPane.getAttachmentLink(FIRST_ATTACHMENT).getAttribute(\"href\"));\n        attachmentsPane.getAttachmentLink(FIRST_ATTACHMENT).click();\n        assertEquals(\"This is a small attachment v2.\", setup.getDriver().findElement(By.tagName(\"html\")).getText());\n        setup.getDriver().navigate().back();\n        // TODO: remove when https://jira.xwiki.org/browse/XWIKI-15513 is fixed\n        setup.getDriver().navigate().refresh();\n        viewPage.waitForDocExtraPaneActive(\"attachments\");\n        attachmentsPane.waitForAttachmentsLiveData();\n\n        attachmentsPane.deleteAttachmentByFileByName(FIRST_ATTACHMENT);\n        assertEquals(1, attachmentsPane.getNumberOfAttachments());\n        assertTrue(attachmentsPane.attachmentExistsByFileName(SECOND_ATTACHMENT));\n\n        // Go back to the page so we can check that the right attachment has really been deleted\n        setup.gotoPage(testReference);\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(1, attachmentsPane.getNumberOfAttachments());\n        assertEquals(String.format(attachmentURLScheme, SECOND_ATTACHMENT),\n            attachmentsPane.getAttachmentLink(SECOND_ATTACHMENT).getAttribute(\"href\"));\n    }\n\n    @Test\n    @Order(2)\n    void attachAndViewGifImage(TestUtils setup, TestReference testReference, TestConfiguration testConfiguration)\n    {\n        // Prepare the page to display the GIF image. We explicitly set the width to a value greater than the actual\n        // image width because we want the code that resizes the image on the server side to be executed (even if the\n        // image is not actually resized).\n        setup.createPage(testReference, String.format(\"[[image:image.gif||width=%s]]\", 142), \"\");\n\n        // Attach the GIF image.\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        attachmentsPane.setFileToUpload(getFileToUpload(testConfiguration, IMAGE_ATTACHMENT).getAbsolutePath());\n        attachmentsPane.waitForUploadToFinish(IMAGE_ATTACHMENT);\n        assertTrue(attachmentsPane.attachmentExistsByFileName(IMAGE_ATTACHMENT));\n    }\n\n    @Test\n    @Order(3)\n    void diffWithDeletedAttachments(TestUtils setup, TestReference testReference,\n        TestConfiguration testConfiguration) throws Exception\n    {\n        // v1.1\n        setup.createPage(testReference, \"\", \"\");\n        // v2.1\n        setup.attachFile(testReference, \"toto.txt\",\n            getClass().getResourceAsStream(\"/AttachmentIT/testDiff/v1.1/toto.txt\"), true);\n        // v3.1\n        setup.deleteAttachement(testReference, \"toto.txt\");\n        // Milliseconds are dropped from attachment date: if we create them too fast\n        // we cannot rely on date to compare them. So make sure to wait at least 1 sec before continue the work.\n        Thread.sleep(1000);\n        // v4.1\n        setup.attachFile(testReference, \"toto.txt\",\n            getClass().getResourceAsStream(\"/AttachmentIT/testDiff/v2.1/toto.txt\"), true);\n        // v5.1\n        setup.attachFile(testReference, \"toto.txt\",\n            getClass().getResourceAsStream(\"/AttachmentIT/testDiff/v2.2/toto.txt\"), false);\n        // v6.1\n        setup.attachFile(testReference, \"toto.txt\",\n            getClass().getResourceAsStream(\"/AttachmentIT/testDiff/v2.3/toto.txt\"), false);\n        // v7.1\n        setup.deleteAttachement(testReference, \"toto.txt\");\n\n        ViewPage viewPage = setup.gotoPage(testReference);\n        HistoryPane historyPane = viewPage.openHistoryDocExtraPane();\n        ComparePage compare = historyPane.compare(\"1.1\", \"2.1\");\n\n        ChangesPane changesPane = compare.getChangesPane();\n        DocumentDiffSummary diffSummary = changesPane.getDiffSummary();\n        assertEquals(Collections.singletonList(\"toto.txt\"),\n            diffSummary.toggleAttachmentsDetails().getAddedAttachments());\n        EntityDiff content = changesPane.getEntityDiff(\"toto.txt\");\n        assertEquals(Arrays.asList(\"@@ -1,0 +1,1 @@\", \"+v1.1\"), content.getDiff(\"Content\"));\n\n        viewPage = setup.gotoPage(testReference);\n        historyPane = viewPage.openHistoryDocExtraPane();\n        compare = historyPane.compare(\"2.1\", \"3.1\");\n        changesPane = compare.getChangesPane();\n        diffSummary = changesPane.getDiffSummary();\n        assertEquals(Collections.singletonList(\"toto.txt\"),\n            diffSummary.toggleAttachmentsDetails().getRemovedAttachments());\n        content = changesPane.getEntityDiff(\"toto.txt\");\n        assertEquals(Arrays.asList(\"@@ -1,1 +1,0 @@\", \"-v1.1\"), content.getDiff(\"Content\"));\n\n        viewPage = setup.gotoPage(testReference);\n        historyPane = viewPage.openHistoryDocExtraPane();\n        compare = historyPane.compare(\"5.1\", \"7.1\");\n        changesPane = compare.getChangesPane();\n        diffSummary = changesPane.getDiffSummary();\n        assertEquals(Collections.singletonList(\"toto.txt\"),\n            diffSummary.toggleAttachmentsDetails().getRemovedAttachments());\n        content = changesPane.getEntityDiff(\"toto.txt\");\n        assertEquals(Arrays.asList(\"@@ -1,1 +1,0 @@\", \"-v2.2\"), content.getDiff(\"Content\"));\n\n        viewPage = setup.gotoPage(testReference);\n        historyPane = viewPage.openHistoryDocExtraPane();\n        compare = historyPane.compare(\"2.1\", \"6.1\");\n        changesPane = compare.getChangesPane();\n        diffSummary = changesPane.getDiffSummary();\n        assertEquals(Collections.singletonList(\"toto.txt\"),\n            diffSummary.toggleAttachmentsDetails().getModifiedAttachments());\n        content = changesPane.getEntityDiff(\"toto.txt\");\n        assertEquals(Arrays.asList(\"@@ -1,1 +1,1 @@\", \"-v<del>1</del>.<del>1</del>\", \"+v<ins>2</ins>.<ins>3</ins>\"),\n            content.getDiff(\"Content\"));\n\n    }\n\n    /**\n     * Ensure that an attachment is properly restored after a rollback of a page that has been restored from deletion.\n     */\n    @Test\n    @Order(4)\n    void rollbackAttachmentFromRestoredPage(TestUtils setup, TestReference testReference) throws Exception\n    {\n        setup.deletePage(testReference);\n\n        // v1.1\n        setup.createPage(testReference, \"\");\n\n        // v2.1\n        setup.attachFile(testReference, \"toto.txt\",\n            getClass().getResourceAsStream(\"/AttachmentIT/testDiff/v1.1/toto.txt\"), true);\n        // v3.1\n        setup.attachFile(testReference, \"toto.txt\",\n            getClass().getResourceAsStream(\"/AttachmentIT/testDiff/v2.1/toto.txt\"), false);\n\n        setup.deletePage(testReference);\n        setup.gotoPage(testReference);\n\n        DeletePageOutcomePage deletePageOutcomePage = new DeletePageOutcomePage();\n        ViewPage viewPage = deletePageOutcomePage.clickRestore();\n\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertTrue(attachmentsPane.attachmentExistsByFileName(\"toto.txt\"));\n        assertEquals(\"1.2\", attachmentsPane.getLatestVersionOfAttachment(\"toto.txt\"));\n        attachmentsPane.getAttachmentLink(\"toto.txt\").click();\n        assertEquals(\"v2.1\", setup.getDriver().findElement(By.tagName(\"html\")).getText());\n\n        viewPage = setup.gotoPage(testReference);\n        HistoryPane historyPane = viewPage.openHistoryDocExtraPane();\n        viewPage = historyPane.rollbackToVersion(\"2.1\");\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertTrue(attachmentsPane.attachmentExistsByFileName(\"toto.txt\"));\n        assertEquals(\"1.3\", attachmentsPane.getLatestVersionOfAttachment(\"toto.txt\"));\n        attachmentsPane.getAttachmentLink(\"toto.txt\").click();\n        assertEquals(\"v1.1\", setup.getDriver().findElement(By.tagName(\"html\")).getText());\n    }\n\n    @Test\n    @Order(5)\n    void filterAttachmentsLivetable(TestUtils setup, TestReference testReference) throws Exception\n    {\n        ViewPage viewPage = setup.createPage(testReference, \"\", \"\");\n\n        // Upload attachments with 2 different users.\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        setup.attachFile(testReference, FIRST_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + FIRST_ATTACHMENT), false);\n        setup.attachFile(testReference, SECOND_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + SECOND_ATTACHMENT), false);\n\n        setup.login(\"User2\", \"pass\");\n        setup.gotoPage(testReference);\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        setup.attachFile(testReference, SMALL_SIZE_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + SMALL_SIZE_ATTACHMENT), false);\n\n        attachmentsPane.filterColumn(2, \"SmallAttachment\");\n        assertEquals(2, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        attachmentsPane.filterColumn(2, \" \");\n\n        attachmentsPane.filterColumn(1, \"Image\");\n        assertEquals(1, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(SMALL_SIZE_ATTACHMENT, attachmentsPane.getAttachmentNameByIndex(1));\n        attachmentsPane.filterColumn(1, \"Text\");\n        assertEquals(2, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        attachmentsPane.filterColumn(1, CHOICE_EMPTY);\n\n        attachmentsPane.filterColumn(3, \"Tiny\");\n        assertEquals(2, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        attachmentsPane.filterColumn(3, \"Small\");\n        assertEquals(1, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(SMALL_SIZE_ATTACHMENT, attachmentsPane.getAttachmentNameByIndex(1));\n        attachmentsPane.filterColumn(3, CHOICE_EMPTY);\n\n        attachmentsPane.filterColumn(5, \"User1\");\n        assertEquals(2, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        attachmentsPane.filterColumn(5, \"User2\");\n        assertEquals(1, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(SMALL_SIZE_ATTACHMENT, attachmentsPane.getAttachmentNameByIndex(1));\n        attachmentsPane.filterColumn(5, \" \");\n\n        String firstAttachUploadDate = attachmentsPane.getDateOfLastUpload(FIRST_ATTACHMENT);\n        List<String> uploadDates =\n            Arrays.asList(firstAttachUploadDate, attachmentsPane.getDateOfLastUpload(SECOND_ATTACHMENT),\n                attachmentsPane.getDateOfLastUpload(SMALL_SIZE_ATTACHMENT));\n        attachmentsPane.filterColumn(4, firstAttachUploadDate);\n        long expected = uploadDates.stream().filter(d -> d.equals(firstAttachUploadDate)).count();\n        assertEquals(expected, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        attachmentsPane.filterColumn(4, \" \");\n    }\n\n    @Test\n    @Order(6)\n    void addAttachmentsMacroToPageContent(TestUtils setup, TestReference testReference) throws Exception\n    {\n        setup.loginAsSuperAdmin();\n\n        DocumentReference attachmentsDocRef =\n            new DocumentReference(\"PageWithAttachments\", testReference.getLastSpaceReference());\n        setup.createPage(attachmentsDocRef, \"\", \"\");\n        setup.attachFile(attachmentsDocRef, FIRST_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + FIRST_ATTACHMENT), false);\n        setup.attachFile(attachmentsDocRef, SECOND_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + SECOND_ATTACHMENT), false);\n        setup.attachFile(attachmentsDocRef, IMAGE_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + IMAGE_ATTACHMENT), false);\n\n        ViewPage viewPage = setup.createPage(testReference, getAttachmentsMacroContent(attachmentsDocRef), \"\");\n\n        setup.attachFile(testReference, FIRST_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + FIRST_ATTACHMENT), false);\n        setup.attachFile(testReference, SECOND_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + SECOND_ATTACHMENT), false);\n\n        viewPage.reloadPage();\n        AttachmentsPane pageAttachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        AttachmentsPane macroAttachmentsPane = new AttachmentsPane(\"testAttachments\");\n\n        // Check the delete action with multiple attachments liveData displayed.\n        assertEquals(3, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(2, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        macroAttachmentsPane.deleteAttachmentByFileByName(FIRST_ATTACHMENT);\n        assertEquals(2, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(2, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n\n        pageAttachmentsPane.deleteAttachmentByFileByName(FIRST_ATTACHMENT);\n        assertEquals(2, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(1, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n\n        // Check filtering with multiple attachments liveData displayed.\n        macroAttachmentsPane.filterColumn(2, IMAGE_ATTACHMENT);\n        assertEquals(1, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(1, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        macroAttachmentsPane.filterColumn(2, \" \");\n\n        pageAttachmentsPane.filterColumn(2, SECOND_ATTACHMENT);\n        assertEquals(2, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(1, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        pageAttachmentsPane.filterColumn(2, \" \");\n\n        macroAttachmentsPane.filterColumn(1, \"Image\");\n        assertEquals(1, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(1, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        macroAttachmentsPane.filterColumn(1, CHOICE_EMPTY);\n    }\n\n    @Test\n    @Order(7)\n    void addSeveralAttachmentsAtOnce(TestUtils setup, TestReference testReference, TestConfiguration testConfiguration)\n    {\n        setup.loginAsSuperAdmin();\n        setup.createPage(testReference, \"\");\n\n        // Upload 4 files at once.\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        attachmentsPane.setFilesToUpload(List.of(\n            getFileToUpload(testConfiguration, FIRST_ATTACHMENT).getAbsolutePath(),\n            getFileToUpload(testConfiguration, SECOND_ATTACHMENT).getAbsolutePath(),\n            getFileToUpload(testConfiguration, IMAGE_ATTACHMENT).getAbsolutePath(),\n            getFileToUpload(testConfiguration, SMALL_SIZE_ATTACHMENT).getAbsolutePath()\n        ));\n        // Wait for the last file to be uploaded.\n        attachmentsPane.waitForUploadToFinish(SMALL_SIZE_ATTACHMENT);\n\n        assertEquals(4, attachmentsPane.getNumberOfAttachments());\n    }\n\n    private String getAttachmentsMacroContent(DocumentReference docRef)\n    {\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(\"{{velocity}}\\n\");\n        sb.append(\"#template('attachment_macros.vm')\\n\");\n        sb.append(\"#set($attachmentsDoc = $xwiki.getDocument(\\\"\" + docRef + \"\\\"))\\n\");\n        sb.append(\"#showAttachmentsLiveData($attachmentsDoc 'testAttachments')\\n\");\n        sb.append(\"{{/velocity}}\");\n\n        return sb.toString();\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Vector;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.script.ScriptContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.bridge.event.ActionExecutedEvent;\nimport org.xwiki.bridge.event.ActionExecutingEvent;\nimport org.xwiki.component.descriptor.ComponentDescriptor;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.container.Container;\nimport org.xwiki.container.Request;\nimport org.xwiki.container.servlet.ServletContainerException;\nimport org.xwiki.container.servlet.ServletContainerInitializer;\nimport org.xwiki.container.servlet.ServletRequest;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.csrf.CSRFToken;\nimport org.xwiki.internal.web.DocExistValidator;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.job.internal.DefaultJobProgress;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceProvider;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.EntityReferenceValueProvider;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.validation.EntityNameValidationConfiguration;\nimport org.xwiki.model.validation.EntityNameValidationManager;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.WrappedThreadEventListener;\nimport org.xwiki.rendering.async.AsyncContext;\nimport org.xwiki.rendering.internal.transformation.MutableRenderingContext;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.resource.NotFoundResourceHandlerException;\nimport org.xwiki.resource.ResourceReferenceHandler;\nimport org.xwiki.resource.ResourceReferenceManager;\nimport org.xwiki.resource.ResourceType;\nimport org.xwiki.resource.entity.EntityResourceReference;\nimport org.xwiki.resource.internal.DefaultResourceReferenceHandlerChain;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.security.authorization.AuthorizationException;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.template.TemplateManager;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.velocity.VelocityManager;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.web.LegacyAction;\nimport com.xpn.xwiki.monitor.api.MonitorPlugin;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;\nimport com.xpn.xwiki.redirection.RedirectionFilter;\n\n/**\n * <p>\n * Root class for most XWiki actions. It provides a common framework that allows actions to execute just the specific\n * action code, handling the extra activities, such as preparing the context and retrieving the document corresponding\n * to the URL.\n * </p>\n * <p>\n * It defines two methods, {@link #action(XWikiContext)} and {@link #render(XWikiContext)}, that should be overridden by\n * specific actions. {@link #action(XWikiContext)} should contain the processing part of the action.\n * {@link #render(XWikiContext)} should return the name of a template that should be rendered, or manually write to the\n * {@link XWikiResponse response} stream.\n * </p>\n * <p>\n * Serving a request goes through the following phases:\n * </p>\n * <ul>\n * <li>Wrapping the request and response object in XWiki specific wrappers</li>\n * <li>Prepare the request {@link XWikiContext XWiki-specific context}</li>\n * <li>Initialize/retrieve the XWiki object corresponding to the requested wiki</li>\n * <li>Handle file uploads</li>\n * <li>Prepare the velocity context</li>\n * <li>Prepare the document objects corresponding to the requested URL</li>\n * <li>Send action pre-notifications to listeners</li>\n * <li>Run the overridden {@link #action(XWikiContext)}</li>\n * <li>If {@link #action(XWikiContext)} returns true, run the overridden {@link #render(XWikiContext)}</li>\n * <li>If {@link #render(XWikiContext)} returned a string (template name), render the template with that name</li>\n * <li>Send action post-notifications to listeners</li>\n * </ul>\n * <p>\n * During this process, also handle specific errors, like when a document does not exist, or the user does not have the\n * right to perform the current action.\n * </p>\n */\npublic abstract class XWikiAction implements LegacyAction\n{\n    public static final String ACTION_PROGRESS = \"actionprogress\";\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiAction.class);\n\n    /**\n     * Actions that need to be resolved on the main wiki instead of the current non-existing wiki. This is used to be\n     * able to render the skin even on a wiki that doesn't exist.\n     */\n    private static final List<String> ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST =\n        Arrays.asList(\"skin\", \"ssx\", \"jsx\", \"download\");\n\n    @Inject\n    protected ComponentDescriptor<LegacyAction> componentDescriptor;\n\n    @Inject\n    protected Container container;\n\n    @Inject\n    protected Execution execution;\n\n    @Inject\n    protected ObservationManager observation;\n\n    @Inject\n    @Named(\"context\")\n    private ComponentManager componentManager;\n\n    /**\n     * Indicate if the action allow asynchronous display (among which the XWiki initialization).\n     */\n    protected boolean waitForXWikiInitialization = true;\n\n    @Inject\n    @Named(\"currentmixed\")\n    private DocumentReferenceResolver<String> currentmixedReferenceResolver;\n\n    @Inject\n    private ContextualAuthorizationManager autorization;\n\n    private ContextualLocalizationManager localization;\n\n    private JobProgressManager progress;\n\n    private ScriptContextManager scriptContextManager;\n\n    private EntityNameValidationManager entityNameValidationManager;\n\n    private EntityNameValidationConfiguration entityNameValidationConfiguration;\n\n    private EntityReferenceSerializer<String> localSerializer;\n\n    @Inject\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    @Inject\n    @Named(\"document\")\n    private UserReferenceResolver<DocumentReference> userReferenceResolver;\n\n    /**\n     * @return the class of the XWikiForm in charge of parsing the request\n     * @since 13.0\n     */\n    protected Class<? extends XWikiForm> getFormClass()\n    {\n        return null;\n    }\n\n    protected ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    /**\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        return this.currentmixedReferenceResolver;\n    }\n\n    /**\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected ContextualAuthorizationManager getContextualAuthorizationManager()\n    {\n        return this.autorization;\n    }\n\n    protected String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    protected JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    protected EntityNameValidationManager getEntityNameValidationManager()\n    {\n        if (this.entityNameValidationManager == null) {\n            this.entityNameValidationManager = Utils.getComponent(EntityNameValidationManager.class);\n        }\n        return this.entityNameValidationManager;\n    }\n\n    protected EntityNameValidationConfiguration getEntityNameValidationConfiguration()\n    {\n        if (this.entityNameValidationConfiguration == null) {\n            this.entityNameValidationConfiguration = Utils.getComponent(EntityNameValidationConfiguration.class);\n        }\n\n        return this.entityNameValidationConfiguration;\n    }\n\n    protected EntityReferenceSerializer<String> getLocalSerializer()\n    {\n        if (this.localSerializer == null) {\n            this.localSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n        return this.localSerializer;\n    }\n\n    /**\n     * @return the current unmodified {@link ScriptContext} instance\n     * @since 8.3M1\n     */\n    protected ScriptContext getCurrentScriptContext()\n    {\n        if (this.scriptContextManager == null) {\n            this.scriptContextManager = Utils.getComponent(ScriptContextManager.class);\n        }\n\n        return this.scriptContextManager.getCurrentScriptContext();\n    }\n\n    @Override\n    public void execute(HttpServletRequest servletRequest, HttpServletResponse servletResponse) throws Exception\n    {\n        XWikiContext context = null;\n\n        try {\n            // Initialize the XWiki Context which is the main object used to pass information across\n            // classes/methods. It's also wrapping the request, response, and all container objects\n            // in general.\n            context = initializeXWikiContext(servletRequest, servletResponse);\n\n            // From this line forward all information can be found in the XWiki Context.\n            execute(context);\n        } finally {\n            if (context != null) {\n                cleanupComponents();\n            }\n        }\n    }\n\n    /**\n     * Ensure that the given entity reference is valid according to the configured name strategy. Always returns true if\n     * the name strategy is not found.\n     *\n     * @param entityReference the entity reference name to validate\n     * @return {@code true} if the entity reference name is valid according to the name strategy.\n     * @since 12.0RC1\n     */\n    protected boolean isEntityReferenceNameValid(EntityReference entityReference)\n    {\n        if (this.getEntityNameValidationManager().getEntityReferenceNameStrategy() != null\n            && this.getEntityNameValidationConfiguration().useValidation()) {\n            if (!this.getEntityNameValidationManager().getEntityReferenceNameStrategy().isValid(entityReference)) {\n                Object[] args = {getLocalSerializer().serialize(entityReference)};\n                XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,\n                    \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,\n                    args);\n                ScriptContext scontext = getCurrentScriptContext();\n                scontext.setAttribute(\"invalidNameReference\", entityReference, ScriptContext.ENGINE_SCOPE);\n                scontext.setAttribute(\"createException\", invalidNameException, ScriptContext.ENGINE_SCOPE);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Write an error response to an ajax request.\n     *\n     * @param httpStatusCode The status code to set on the response.\n     * @param message The message that should be displayed.\n     * @param context the context.\n     */\n    protected void writeAjaxErrorResponse(int httpStatusCode, String message, XWikiContext context)\n    {\n        try {\n            context.getResponse().setContentType(\"text/plain\");\n            context.getResponse().setStatus(httpStatusCode);\n            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());\n            context.getResponse().getWriter().print(message);\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to send error response to AJAX save and continue request.\", e);\n        }\n    }\n\n    public void execute(XWikiContext context) throws Exception\n    {\n        MonitorPlugin monitor = null;\n        FileUploadPlugin fileupload = null;\n        DefaultJobProgress actionProgress = null;\n        String docName = \"\";\n\n        boolean debug = StringUtils.equals(context.getRequest().get(\"debug\"), \"true\");\n\n        String sasync = context.getRequest().get(\"async\");\n\n        try {\n            String action = context.getAction();\n\n            // Start progress\n            if (debug) {\n                actionProgress = new DefaultJobProgress(context.getURL().toExternalForm());\n                this.observation.addListener(new WrappedThreadEventListener(actionProgress));\n\n                // Register the action progress in the context\n                ExecutionContext econtext = this.execution.getContext();\n                if (econtext != null) {\n                    econtext.setProperty(XWikiAction.ACTION_PROGRESS, actionProgress);\n                }\n            }\n\n            getProgress().pushLevelProgress(2, this);\n\n            getProgress().startStep(this, \"Get XWiki instance\");\n\n            // Initialize context.getWiki() with the main wiki\n            XWiki xwiki;\n\n            // Verify that the requested wiki exists\n            try {\n                // Don't show init screen if async is forced to false\n                xwiki = XWiki.getXWiki(this.waitForXWikiInitialization || StringUtils.equals(sasync, \"false\"), context);\n\n                // If XWiki is still initializing display initialization template\n                if (xwiki == null) {\n                    // Display initialization template\n                    renderInit(context);\n\n                    // Initialization template has been displayed, stop here.\n                    return;\n                }\n            } catch (XWikiException e) {\n                // If the wiki asked by the user doesn't exist, then we first attempt to use any existing global\n                // redirects. If there are none, then we display the specific error template.\n                if (e.getCode() == XWikiException.ERROR_XWIKI_DOES_NOT_EXIST) {\n                    xwiki = XWiki.getMainXWiki(context);\n\n                    // Initialize the url factory\n                    XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n                    context.setURLFactory(urlf);\n\n                    // Initialize the velocity context and its bindings so that it may be used in the velocity templates\n                    // that we\n                    // are parsing below.\n                    VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n                    VelocityContext vcontext = velocityManager.getVelocityContext();\n\n                    if (!sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {\n                        // Starting XWiki 5.0M2, 'xwiki.virtual.redirect' was removed. Warn users still using it.\n                        if (!StringUtils.isEmpty(context.getWiki().Param(\"xwiki.virtual.redirect\"))) {\n                            LOGGER.warn(String.format(\"%s %s\", \"'xwiki.virtual.redirect' is no longer supported.\",\n                                \"Please update your configuration and/or see XWIKI-8914 for more details.\"));\n                        }\n\n                        // Display the error template only for actions that are not ignored\n                        if (!ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST.contains(action)) {\n\n                            // Add localization resources to the context\n                            xwiki.prepareResources(context);\n\n                            // Set the main home page in the main space of the main wiki as the current requested entity\n                            // since we cannot set the non existing one as it would generate errors obviously...\n                            EntityReferenceValueProvider valueProvider =\n                                Utils.getComponent(EntityReferenceValueProvider.class);\n                            xwiki.setPhonyDocument(new DocumentReference(valueProvider.getDefaultValue(EntityType.WIKI),\n                                valueProvider.getDefaultValue(EntityType.SPACE),\n                                valueProvider.getDefaultValue(EntityType.DOCUMENT)), context, vcontext);\n\n                            // Parse the error template\n                            Utils.parseTemplate(context.getWiki().Param(\"xwiki.wiki_exception\", \"wikidoesnotexist\"),\n                                context);\n\n                            // Error template was displayed, stop here.\n                            return;\n                        }\n\n                        // At this point, we allow regular execution of the ignored action because even if the wiki\n                        // does not exist, we still need to allow UI resources to be retrieved (from the filesystem\n                        // and the main wiki) or our error template will not be rendered properly.\n\n                        // Proceed with serving the main wiki\n\n                    } else {\n                        // Global redirect was executed, stop here.\n                        return;\n                    }\n                } else {\n                    LOGGER.error(\"Uncaught exception during XWiki initialisation:\", e);\n                    throw e;\n                }\n            }\n\n            // Send global redirection (if any)\n            if (sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {\n                return;\n            }\n\n            XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n            context.setURLFactory(urlf);\n\n            // Handle ability to enter space URLs and convert them to page URLs (Nested Documents)\n            if (redirectSpaceURLs(action, urlf, xwiki, context)) {\n                return;\n            }\n\n            String sajax = context.getRequest().get(\"ajax\");\n            boolean ajax = false;\n            if (sajax != null && !sajax.trim().equals(\"\") && !sajax.equals(\"0\")) {\n                ajax = true;\n            }\n            context.put(\"ajax\", ajax);\n\n            boolean async = false;\n            if (StringUtils.isNotEmpty(sasync)) {\n                async = sasync.equals(\"true\");\n            } else {\n                // By default allow asynchronous rendering for \"human oriented\" actions which are not executing an ajax\n                // request\n                async = !ajax && !this.waitForXWikiInitialization;\n            }\n            Utils.getComponent(AsyncContext.class).setEnabled(async);\n\n            // Any error before this will be treated using a redirection to an error page\n\n            if (monitor != null) {\n                monitor.startTimer(\"request\");\n            }\n\n            getProgress().startStep(this, \"Execute request\");\n\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            VelocityContext vcontext = velocityManager.getVelocityContext();\n\n            getProgress().pushLevelProgress(7, this);\n\n            boolean eventSent = false;\n            try {\n                getProgress().startStep(this, \"Prepare documents and put them in the context\");\n\n                // Prepare documents and put them in the context\n                if (!xwiki.prepareDocuments(context.getRequest(), context, vcontext)) {\n                    return;\n                }\n\n                // Start monitoring timer\n                monitor = (MonitorPlugin) xwiki.getPlugin(\"monitor\", context);\n                if (monitor != null) {\n                    monitor.startRequest(\"\", context.getAction(), context.getURL());\n                    monitor.startTimer(\"multipart\");\n                }\n\n                getProgress().startStep(this, \"Parses multipart\");\n\n                // Parses multipart so that params in multipart are available for all actions\n                fileupload = Utils.handleMultipart(context.getRequest().getHttpServletRequest(), context);\n                if (monitor != null) {\n                    monitor.endTimer(\"multipart\");\n                }\n\n                if (monitor != null) {\n                    monitor.setWikiPage(context.getDoc().getFullName());\n                }\n\n                getProgress().startStep(this, \"Send [\" + context.getAction() + \"] action start event\");\n\n                // For the moment we're sending the XWiki context as the data, but this will be\n                // changed in the future, when the whole platform will be written using components\n                // and there won't be a need for the context.\n                try {\n                    ActionExecutingEvent event = new ActionExecutingEvent(context.getAction());\n                    this.observation.notify(event, context.getDoc(), context);\n                    eventSent = true;\n                    if (event.isCanceled()) {\n                        // Action has been canceled\n                        // TODO: do something special ?\n                        return;\n                    }\n                } catch (Throwable ex) {\n                    LOGGER.error(\"Cannot send action notifications for document [\" + context.getDoc()\n                        + \" using action [\" + context.getAction() + \"]\", ex);\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"prenotify\");\n                }\n\n                // Call the Actions\n\n                getProgress().startStep(this, \"Search and execute entity resource handler\");\n\n                // Call the new Entity Resource Reference Handler.\n                ResourceReferenceHandler entityResourceReferenceHandler = Utils.getComponent(\n                    new DefaultParameterizedType(null, ResourceReferenceHandler.class, ResourceType.class), \"bin\");\n                EntityResourceReference entityResourceReference =\n                    (EntityResourceReference) Utils.getComponent(ResourceReferenceManager.class).getResourceReference();\n\n                // We save the current action set since:\n                // - by default the action is set to \"view\" for Extensions not installed as root and contributing some\n                // new Entity Action (see https://jira.xwiki.org/browse/XWIKI-15182).\n                // - we want to set back the action in case no ResourceReferenceHandler was found to handle the URL\n                // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                String originalAction = context.getAction();\n                try {\n                    // Force the action in the context because of https://jira.xwiki.org/browse/XWIKI-15182.\n                    // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                    context.setAction(entityResourceReference.getAction().getActionName());\n                    entityResourceReferenceHandler.handle(entityResourceReference,\n                        DefaultResourceReferenceHandlerChain.EMPTY);\n                    // Don't let the old actions kick in!\n                    return;\n                } catch (NotFoundResourceHandlerException e) {\n                    // No Entity Resource Action has been found. Don't do anything and let it go through\n                    // so that the old Action system kicks in...\n                    // Put back the action, because of https://jira.xwiki.org/browse/XWIKI-15182\n                    // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                    context.setAction(originalAction);\n                }\n\n                getProgress().startStep(this, \"Execute action render\");\n\n                // Handle the XWiki.RedirectClass object that can be attached to the current document\n                boolean hasRedirect = handleRedirect(context);\n\n                // Then call the old Actions for backward compatibility (and because a lot of them have not been\n                // migrated to new Actions yet).\n                String renderResult = null;\n                XWikiDocument doc = context.getDoc();\n                docName = doc.getFullName();\n                if (!hasRedirect && action(context)) {\n                    renderResult = render(context);\n                }\n\n                if (renderResult != null) {\n                    // check for doc existence\n                    if (shouldReturnDocDoesNotExist(doc, context)) {\n                        String page = Utils.getPage(context.getRequest(), \"docdoesnotexist\");\n\n                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");\n                        Utils.parseTemplate(page, context);\n                    } else {\n                        String page = Utils.getPage(context.getRequest(), renderResult);\n\n                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");\n                        Utils.parseTemplate(page, !page.equals(\"direct\"), context);\n                    }\n                }\n                return;\n            } catch (Throwable e) {\n                if (e instanceof IOException) {\n                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP,\n                        XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION, \"Exception while sending response\", e);\n                }\n\n                if (!(e instanceof XWikiException)) {\n                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_UNKNOWN,\n                        \"Uncaught exception\", e);\n                }\n\n                try {\n                    XWikiException xex = (XWikiException) e;\n                    if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        // Connection aborted from the client side, there's not much we can do on the server side. We\n                        // simply ignore it.\n                        LOGGER.debug(\"Connection aborted\", e);\n                        // We don't write any other message to the response, as the connection is broken, anyway.\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_ACCESS_DENIED) {\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.access_exception\", \"accessdenied\"), context);\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_INACTIVE\n                        || xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {\n                        if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {\n                            context.put(\"cause\", \"disabled\");\n                        }\n                        // In case of user disabled or inactive, the resources are actually forbidden.\n                        context.getResponse().setStatus(HttpServletResponse.SC_FORBIDDEN);\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.user_exception\", \"userinactive\"), context);\n\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_ATTACHMENT_NOT_FOUND) {\n                        context.put(\"message\", \"attachmentdoesnotexist\");\n                        Utils.parseTemplate(\n                            context.getWiki().Param(\"xwiki.attachment_exception\", \"attachmentdoesnotexist\"), context);\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION) {\n                        vcontext.put(\"message\", localizePlainOrKey(\"platform.core.invalidUrl\"));\n                        xwiki.setPhonyDocument(xwiki.getDefaultSpace(context) + \".\" + xwiki.getDefaultPage(context),\n                            context, vcontext);\n                        context.getResponse().setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.invalid_url_exception\", \"error\"), context);\n                        return;\n                    }\n                    // Note: We don't use the vcontext variable computed above since apparently the velocity context\n                    // can have changed in between. Thus we get it again to be sure we're setting the binding in the\n                    // right one.\n                    velocityManager.getVelocityContext().put(\"exp\", e);\n                    if (LOGGER.isWarnEnabled()) {\n                        // Don't log \"Broken Pipe\" exceptions since they're not real errors and we don't want to pollute\n                        // the logs with unnecessary stack traces. It just means the client side has cancelled the\n                        // connection.\n                        if (ExceptionUtils.getRootCauseMessage(e).equals(\"IOException: Broken pipe\")) {\n                            return;\n                        }\n                        LOGGER.warn(\"Uncaught exception: \" + e.getMessage(), e);\n                    }\n                    // If the request is an AJAX request, we don't return a whole HTML page, but just the exception\n                    // inline.\n                    String exceptionTemplate = ajax ? \"exceptioninline\" : \"exception\";\n                    Utils.parseTemplate(Utils.getPage(context.getRequest(), exceptionTemplate), context);\n                    return;\n                } catch (XWikiException ex) {\n                    if (ex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        LOGGER.error(\"Connection aborted\");\n                    }\n                } catch (Exception e2) {\n                    // I hope this never happens\n                    LOGGER.error(\"Uncaught exceptions (inner): \", e);\n                    LOGGER.error(\"Uncaught exceptions (outer): \", e2);\n                }\n                return;\n            } finally {\n                // Let's make sure we have flushed content and closed\n                try {\n                    context.getResponse().getWriter().flush();\n                } catch (Throwable e) {\n                    // This might happen if the connection was closed, for example.\n                    // If we can't flush, then there's nothing more we can send to the client.\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"request\");\n                    monitor.startTimer(\"notify\");\n                }\n\n                if (eventSent) {\n                    // For the moment we're sending the XWiki context as the data, but this will be\n                    // changed in the future, when the whole platform will be written using components\n                    // and there won't be a need for the context.\n                    try {\n                        this.observation.notify(new ActionExecutedEvent(context.getAction()), context.getDoc(), context);\n                    } catch (Throwable ex) {\n                        LOGGER.error(\"Cannot send action notifications for document [\" + docName + \" using action [\"\n                            + context.getAction() + \"]\", ex);\n                    }\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"notify\");\n                }\n\n                getProgress().startStep(this, \"Cleanup database connections\");\n\n                // Make sure we cleanup database connections\n                // There could be cases where we have some\n                xwiki.getStore().cleanUp(context);\n\n                getProgress().popLevelProgress(this);\n            }\n        } finally {\n            // End request\n            if (monitor != null) {\n                monitor.endRequest();\n            }\n\n            // Stop progress\n            if (actionProgress != null) {\n                getProgress().popLevelProgress(this);\n\n                this.observation.removeListener(actionProgress.getName());\n            }\n\n            if (fileupload != null) {\n                fileupload.cleanFileList(context);\n            }\n        }\n    }\n\n    /**\n     * Check if the given document exists or not and if it should return a 404 based on the context. A {@link\n     * DocExistValidator} with an hint matching the current action is used to check if the document exists. When no\n     * {@link DocExistValidator} is found, the response is always {@code false} When a {@link DocExistValidator} is\n     * found, the result is delegated to {@link DocExistValidator#docExist(XWikiDocument, XWikiContext)}.\n     *\n     * @param doc the doc for which to check it exists or not\n     * @param context the current context\n     * @return {@code true} if we should return a 404\n     * @throws ComponentLookupException if an error occurs when instantiating a {@link DocExistValidator}\n     */\n    private boolean shouldReturnDocDoesNotExist(XWikiDocument doc, XWikiContext context) throws ComponentLookupException\n    {\n        boolean result = false;\n        String action = context.getAction();\n        if (this.componentManager.hasComponent(DocExistValidator.class, action)) {\n            result = this.componentManager.<DocExistValidator>getInstance(DocExistValidator.class, action)\n                .docExist(doc, context);\n        }\n        return result;\n    }\n\n    private void renderInit(XWikiContext xcontext) throws Exception\n    {\n        RenderingContext renderingContext = Utils.getComponent(RenderingContext.class);\n        MutableRenderingContext mutableRenderingContext =\n            renderingContext instanceof MutableRenderingContext ? (MutableRenderingContext) renderingContext : null;\n\n        if (mutableRenderingContext != null) {\n            mutableRenderingContext.push(renderingContext.getTransformation(), renderingContext.getXDOM(),\n                renderingContext.getDefaultSyntax(), \"init.vm\", renderingContext.isRestricted(), Syntax.XHTML_1_0);\n        }\n\n        xcontext.getResponse().setStatus(202);\n        xcontext.getResponse().setContentType(\"text/html; charset=UTF-8\");\n\n        try {\n            Utils.getComponent(TemplateManager.class).render(\"init.vm\", xcontext.getResponse().getWriter());\n        } finally {\n            if (mutableRenderingContext != null) {\n                mutableRenderingContext.pop();\n            }\n        }\n\n        xcontext.getResponse().flushBuffer();\n\n        xcontext.setFinished(true);\n    }\n\n    protected XWikiContext initializeXWikiContext(HttpServletRequest servletRequest,\n        HttpServletResponse servletResponse)\n        throws XWikiException, ServletException, InstantiationException, IllegalAccessException\n    {\n        XWikiForm form;\n        if (getFormClass() != null) {\n            form = getFormClass().newInstance();\n        } else {\n            form = null;\n        }\n\n        return initializeXWikiContext(servletRequest, servletResponse, form);\n    }\n\n    /**\n     * @return the name to put in the {@link XWikiContext}, by default the component role hint is used\n     * @since 13.0\n     */\n    protected String getName()\n    {\n        return this.componentDescriptor.getRoleHint();\n    }\n\n    protected XWikiContext initializeXWikiContext(HttpServletRequest servletRequest,\n        HttpServletResponse servletResponse, XWikiForm form) throws XWikiException, ServletException\n    {\n        String action = getName();\n\n        XWikiRequest request = new XWikiServletRequest(servletRequest);\n        XWikiResponse response = new XWikiServletResponse(servletResponse);\n        XWikiContext context = Utils.prepareContext(action, request, response,\n            new XWikiServletContext(servletRequest.getServletContext()));\n\n        if (form != null) {\n            form.reset(request);\n        }\n\n        // Add the form to the context\n        context.setForm(form);\n\n        // Initialize the Container component which is the new way of transporting the Context in the new\n        // component architecture.\n        initializeContainerComponent(context);\n\n        return context;\n    }\n\n    protected void initializeContainerComponent(XWikiContext context) throws ServletException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request,\n        // response and session to components which require them.\n        // In the future this Servlet will be replaced by the XWikiPlexusServlet Servlet.\n        ServletContainerInitializer containerInitializer = Utils.getComponent(ServletContainerInitializer.class);\n\n        try {\n            containerInitializer.initializeRequest(context.getRequest().getHttpServletRequest(), context);\n            containerInitializer.initializeResponse(context.getResponse());\n            containerInitializer.initializeSession(context.getRequest().getHttpServletRequest());\n        } catch (ServletContainerException e) {\n            throw new ServletException(\"Failed to initialize Request/Response or Session\", e);\n        }\n    }\n\n    protected void cleanupComponents()\n    {\n        // We must ensure we clean the ThreadLocal variables located in the Container and Execution\n        // components as otherwise we will have a potential memory leak.\n        container.removeRequest();\n        container.removeResponse();\n        container.removeSession();\n        execution.removeContext();\n    }\n\n    public String getRealPath(String path)\n    {\n        Request request = this.container.getRequest();\n\n        if (request instanceof ServletRequest) {\n            return ((ServletRequest) request).getHttpServletRequest().getServletContext().getRealPath(path);\n        }\n\n        return null;\n    }\n\n    // hook\n    public boolean action(XWikiContext context) throws XWikiException\n    {\n        return true;\n    }\n\n    // hook\n    public String render(XWikiContext context) throws XWikiException\n    {\n        return null;\n    }\n\n    /**\n     * Indicate if the action support redirection. The default value is {@code false}.\n     *\n     * @return {@code true} if the action supports redirections, {@code false} otherwise\n     * @since 14.0RC1\n     */\n    @Unstable\n    protected boolean supportRedirections()\n    {\n        return false;\n    }\n\n    private UserReference getCurrentUserReference(XWikiContext context)\n    {\n        return this.userReferenceResolver.resolve(context.getUserReference());\n    }\n\n    protected void handleRevision(XWikiContext context) throws XWikiException\n    {\n        String rev = context.getRequest().getParameter(\"rev\");\n        if (rev != null) {\n            context.put(\"rev\", rev);\n            XWikiDocument doc = (XWikiDocument) context.get(\"doc\");\n            XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n            // if the doc is deleted and we request a specific language, we have to set the locale so we can retrieve\n            // properly the document revision.\n            if (rev.startsWith(\"deleted\") && !StringUtils.isEmpty(context.getRequest().getParameter(\"language\"))\n                && doc == tdoc) {\n                Locale locale = LocaleUtils.toLocale(context.getRequest().getParameter(\"language\"), Locale.ROOT);\n                tdoc = new XWikiDocument(tdoc.getDocumentReference(), locale);\n            }\n\n            DocumentReference documentReference = doc.getDocumentReference();\n            try {\n                documentRevisionProvider\n                    .checkAccess(Right.VIEW, getCurrentUserReference(context), documentReference, rev);\n            } catch (AuthorizationException e) {\n                Object[] args = { documentReference, rev, context.getUserReference() };\n                throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                    \"Access to document {0} with revision {1} has been denied to user {2}\", e, args);\n            }\n\n            XWikiDocument rdoc;\n            XWikiDocument rtdoc;\n            if (doc.getLocale().equals(tdoc.getLocale())) {\n                rdoc = this.documentRevisionProvider.getRevision(doc.getDocumentReferenceWithLocale(), rev);\n                rtdoc = rdoc;\n            } else {\n                rdoc = doc;\n                rtdoc = this.documentRevisionProvider.getRevision(tdoc.getDocumentReferenceWithLocale(), rev);\n            }\n            if (rdoc == null) {\n                Object[] args = { doc.getDocumentReferenceWithLocale(), rev };\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_UNEXISTANT_VERSION,\n                    \"Version {1} does not exist while reading document {0}\", null, args);\n            }\n\n            context.put(\"tdoc\", rtdoc);\n            context.put(\"cdoc\", rdoc);\n            context.put(\"doc\", rdoc);\n        }\n    }\n\n    /**\n     * Send redirection based on a regexp pattern (if any) set at the main wiki level. To enable this feature you must\n     * add xwiki.preferences.redirect=1 to your xwiki.cfg.\n     *\n     * @param response the servlet response\n     * @param url url of the request\n     * @param context the XWiki context\n     * @return true if a redirection has been sent\n     */\n    protected boolean sendGlobalRedirect(XWikiResponse response, String url, XWikiContext context) throws Exception\n    {\n        if (\"1\".equals(context.getWiki().Param(\"xwiki.preferences.redirect\"))) {\n            // Note: This implementation is not performant at all and will slow down the wiki as the number\n            // of redirects increases. A better implementation would use a cache of redirects and would use\n            // the notification mechanism to update the cache when the XWiki.XWikiPreferences document is\n            // modified.\n            XWikiDocument globalPreferences = context.getWiki().getDocument(\"xwiki:XWiki.XWikiPreferences\", context);\n            Vector<BaseObject> redirects = globalPreferences.getObjects(\"XWiki.GlobalRedirect\");\n\n            if (redirects != null) {\n                for (BaseObject redir : redirects) {\n                    if (redir != null) {\n                        String p = redir.getStringValue(\"pattern\");\n                        if (p != null && url.matches(p)) {\n                            String dest = redir.getStringValue(\"destination\");\n                            response.sendRedirect(url.replaceAll(p, dest));\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Perform a redirect to the given URL.\n     * @param response the response to use to perform the redirect\n     * @param url the location of the redirect\n     * @throws XWikiException in case of IOException when performing the redirect.\n     */\n    protected void sendRedirect(XWikiResponse response, String url) throws XWikiException\n    {\n        try {\n            if (url != null) {\n                response.sendRedirect(response.encodeRedirectURL(url));\n            }\n        } catch (IOException e) {\n            Object[] args = {url};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_REDIRECT_EXCEPTION,\n                \"Exception while sending redirect to page {0}\", e, args);\n        }\n    }\n\n    /**\n     * Gets the translated version of a document, in the specified language. If the translation does not exist, a new\n     * document translation is created. If the requested language does not correspond to a translation (is not defined\n     * or is the same as the main document), then the main document is returned.\n     *\n     * @param doc the main (default, untranslated) document to translate\n     * @param language the requested document language\n     * @param context the current request context\n     * @return the translated document, or the original untranslated document if the requested language is not a\n     *         translation\n     * @throws XWikiException if the translation cannot be retrieved from the database\n     */\n    protected XWikiDocument getTranslatedDocument(XWikiDocument doc, String language, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument tdoc;\n        if (StringUtils.isBlank(language) || language.equals(\"default\") || language.equals(doc.getDefaultLanguage())) {\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(language, context);\n            if (tdoc == doc) {\n                tdoc = new XWikiDocument(doc.getDocumentReference());\n                tdoc.setLanguage(language);\n                tdoc.setStore(doc.getStore());\n            }\n            tdoc.setTranslation(1);\n        }\n        return tdoc;\n    }\n\n    /**\n     * Perform CSRF check and redirect to the resubmission page if needed. Throws an exception if the access should be\n     * denied, returns false if the check failed and the user will be redirected to a resubmission page.\n     *\n     * @param context current xwiki context containing the request\n     * @return true if the check succeeded, false if resubmission is needed\n     * @throws XWikiException if the check fails\n     */\n    protected boolean csrfTokenCheck(XWikiContext context) throws XWikiException\n    {\n        return csrfTokenCheck(context, false);\n    }\n\n    /**\n     * Perform CSRF check and redirect to the resubmission page if needed. Throws an exception if the access should be\n     * denied, returns false if the check failed and the user will be redirected to a resubmission page.\n     *\n     * @param context current xwiki context containing the request\n     * @param jsonAnswer if true, returns a JSON answer in case of AJAX request: allow to process it properly on client.\n     * @return true if the check succeeded, false if resubmission is needed\n     * @throws XWikiException if the check fails\n     * @since 11.3RC1\n     */\n    protected boolean csrfTokenCheck(XWikiContext context, boolean jsonAnswer) throws XWikiException\n    {\n        final boolean isAjaxRequest = Utils.isAjaxRequest(context);\n        CSRFToken csrf = Utils.getComponent(CSRFToken.class);\n        try {\n            String token = context.getRequest().getParameter(\"form_token\");\n            if (!csrf.isTokenValid(token)) {\n                if (isAjaxRequest) {\n                    if (jsonAnswer) {\n                        Map<String, String> jsonObject = new LinkedHashMap<>();\n                        jsonObject.put(\"errorType\", \"CSRF\");\n                        jsonObject.put(\"resubmissionURI\", csrf.getRequestURI());\n                        jsonObject.put(\"newToken\", csrf.getToken());\n                        this.answerJSON(context, HttpServletResponse.SC_FORBIDDEN, jsonObject);\n                    } else {\n                        final String csrfCheckFailedMessage = localizePlainOrKey(\"core.editors.csrfCheckFailed\");\n                        writeAjaxErrorResponse(HttpServletResponse.SC_FORBIDDEN, csrfCheckFailedMessage, context);\n                    }\n                } else {\n                    sendRedirect(context.getResponse(), csrf.getResubmissionURL());\n                }\n\n                return false;\n            }\n        } catch (XWikiException exception) {\n            // too bad\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied, secret token verification failed\", exception);\n        }\n        return true;\n    }\n\n    /**\n     * In order to let users enter URLs to Spaces we do the following when receiving {@code /A/B} (where A and B are\n     * spaces):\n     * <ul>\n     * <li>check that the action is \"view\" (we only support this for the view action since otherwise this would break\n     * apps written before this concept was introduced in XWiki 7.2M1)</li>\n     * <li>if A.B exists then continue</li>\n     * <li>if A.B doesn't exist then forward to A.B.WebHome</li>\n     * </ul>\n     * In order to disable this redirect you should provide the {@code spaceRedirect=false} Query String parameter and\n     * value.\n     *\n     * @since 7.2M1\n     */\n    private boolean redirectSpaceURLs(String action, XWikiURLFactory urlf, XWiki xwiki, XWikiContext context)\n        throws Exception\n    {\n        if (\"view\".equals(action) && !\"false\".equalsIgnoreCase(context.getRequest().getParameter(\"spaceRedirect\"))) {\n            DocumentReference reference = xwiki.getDocumentReference(context.getRequest(), context);\n            if (!xwiki.exists(reference, context)) {\n                String defaultDocumentName = Utils.getComponent(EntityReferenceProvider.class)\n                    .getDefaultReference(EntityType.DOCUMENT).getName();\n                // Avoid an infinite loop by ensuring we're not on a WebHome already\n                if (!reference.getName().equals(defaultDocumentName)) {\n                    // Consider the reference as a Space Reference and Construct a new reference to the home of that\n                    // Space. Then generate the URL for it and forward to it\n                    SpaceReference spaceReference = new SpaceReference(reference.getName(), reference.getParent());\n                    // Extract the anchor\n                    String anchor = new URL(context.getRequest().getRequestURL().toString()).getRef();\n                    URL forwardURL = urlf.createURL(getLocalSerializer().serialize(spaceReference), defaultDocumentName,\n                        action, context.getRequest().getQueryString(), anchor,\n                        spaceReference.getWikiReference().getName(), context);\n                    // Since createURL() contain the webapp context and since RequestDispatcher should not contain it,\n                    // we need to remove it!\n                    String webappContext = xwiki.getWebAppPath(context);\n                    String relativeURL = urlf.getURL(forwardURL, context);\n                    relativeURL = '/' + StringUtils.substringAfter(relativeURL, webappContext);\n                    context.getRequest().getRequestDispatcher(relativeURL).forward(context.getRequest(),\n                        context.getResponse());\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Answer to a request with a JSON content.\n     * \n     * @param context the current context of the request.\n     * @param status the status code to send back.\n     * @param answer the content of the JSON answer.\n     * @throws XWikiException in case of error during the serialization of the JSON.\n     */\n    protected void answerJSON(XWikiContext context, int status, Map<String, String> answer) throws XWikiException\n    {\n        ObjectMapper mapper = new ObjectMapper();\n\n        try {\n            String jsonAnswerAsString = mapper.writeValueAsString(answer);\n            context.getResponse().setContentType(\"application/json\");\n            context.getResponse().setContentLength(jsonAnswerAsString.length());\n            context.getResponse().setStatus(status);\n            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());\n            context.getResponse().getWriter().print(jsonAnswerAsString);\n            context.setResponseSent(true);\n        } catch (IOException e) {\n            throw new XWikiException(\"Error while sending JSON answer.\", e);\n        }\n    }\n\n    /**\n     * Make sure to set the right length (or nothing) in the response.\n     * \n     * @param response the response\n     * @param length the length to set in the response\n     * @since 11.10\n     * @since 10.11.10\n     * @since 11.3.6\n     */\n    protected void setContentLength(XWikiResponse response, long length)\n    {\n        // Set the content length in the response\n        response.setContentLengthLong(length);\n    }\n\n    /**\n     * Helper used resolve the template passed to the action if the current user have access to it.\n     * \n     * @param template the template to copy\n     * @return the reference of the template if not empty and the current user have access to it\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected DocumentReference resolveTemplate(String template)\n    {\n        if (StringUtils.isNotBlank(template)) {\n            DocumentReference templateReference = getCurrentMixedDocumentReferenceResolver().resolve(template);\n\n            // Make sure the current user have access to the template document before copying it\n            if (getContextualAuthorizationManager().hasAccess(Right.VIEW, templateReference)) {\n                return templateReference;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Helper used by various actions to initialize a document by copying a template to it.\n     * \n     * @param document the document to update\n     * @param template the template to copy\n     * @param context the XWiki context\n     * @return true if the document was updated, false otherwise (for example when the current user does not have view\n     *         right on the template document)\n     * @throws XWikiException when failing to copy the template\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected boolean readFromTemplate(XWikiDocument document, String template, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference templateReference = resolveTemplate(template);\n\n        if (templateReference != null) {\n            document.readFromTemplate(templateReference, context);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Loop over the {@link RedirectionFilter} components until one of them perform a redirection. If none of the does,\n     * the action continues normally.\n     *\n     * @param context the current wiki content\n     * @return {@code true} if a redirection has been performed, {@code false} otherwise\n     * @throws XWikiException in case of error during the execution of a redirection filter\n     */\n    private boolean handleRedirect(XWikiContext context) throws XWikiException\n    {\n        // If no redirection are expected, this step is skipped.\n        if (this.supportRedirections()) {\n            try {\n                for (RedirectionFilter filter : this.componentManager.<RedirectionFilter>getInstanceList(\n                    RedirectionFilter.class)) {\n                    if (filter.redirect(context)) {\n                        return true;\n                    }\n                }\n            } catch (ComponentLookupException e) {\n                throw new XWikiException(\"Failed to resolve the redirection filters list\", e);\n            }\n        }\n        return false;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.test.ui;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Serializable;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response.Status;\nimport javax.ws.rs.core.UriBuilder;\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.JAXBException;\nimport javax.xml.bind.Marshaller;\nimport javax.xml.bind.Unmarshaller;\n\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpMethod;\nimport org.apache.commons.httpclient.UsernamePasswordCredentials;\nimport org.apache.commons.httpclient.auth.AuthScope;\nimport org.apache.commons.httpclient.methods.DeleteMethod;\nimport org.apache.commons.httpclient.methods.EntityEnclosingMethod;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.methods.InputStreamRequestEntity;\nimport org.apache.commons.httpclient.methods.PostMethod;\nimport org.apache.commons.httpclient.methods.PutMethod;\nimport org.apache.commons.httpclient.methods.RequestEntity;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Cookie;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.NoSuchElementException;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.support.ui.ExpectedCondition;\nimport org.opentest4j.AssertionFailedError;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.AbstractLocalizedEntityReference;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.ObjectPropertyReference;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rest.model.jaxb.Page;\nimport org.xwiki.rest.model.jaxb.Property;\nimport org.xwiki.rest.model.jaxb.Xwiki;\nimport org.xwiki.rest.resources.attachments.AttachmentResource;\nimport org.xwiki.rest.resources.classes.ClassPropertyResource;\nimport org.xwiki.rest.resources.objects.ObjectPropertyResource;\nimport org.xwiki.rest.resources.objects.ObjectResource;\nimport org.xwiki.rest.resources.objects.ObjectsResource;\nimport org.xwiki.rest.resources.pages.PageResource;\nimport org.xwiki.rest.resources.pages.PageTranslationResource;\nimport org.xwiki.test.integration.XWikiExecutor;\nimport org.xwiki.test.ui.po.BasePage;\nimport org.xwiki.test.ui.po.ViewPage;\nimport org.xwiki.test.ui.po.editor.ClassEditPage;\nimport org.xwiki.test.ui.po.editor.ObjectEditPage;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\n/**\n * Helper methods for testing, not related to a specific Page Object. Also made available to tests classes.\n *\n * @version $Id$\n * @since 3.2M3\n */\npublic class TestUtils\n{\n    /**\n     * @since 5.0M2\n     */\n    public static final UsernamePasswordCredentials ADMIN_CREDENTIALS =\n        new UsernamePasswordCredentials(\"Admin\", \"admin\");\n\n    /**\n     * @since 5.1M1\n     */\n    public static final UsernamePasswordCredentials SUPER_ADMIN_CREDENTIALS =\n        new UsernamePasswordCredentials(\"superadmin\", \"pass\");\n\n    /**\n     * @since 5.0M2\n     * @deprecated since 7.3M1, use {@link #getBaseURL()} instead\n     */\n    @Deprecated\n    public static final String BASE_URL = XWikiExecutor.URL + \":\" + XWikiExecutor.DEFAULT_PORT\n        + XWikiExecutor.DEFAULT_CONTEXT + \"/\";\n\n    /**\n     * @since 5.0M2\n     * @deprecated since 7.3M1, use {@link #getBaseBinURL()} instead\n     */\n    @Deprecated\n    public static final String BASE_BIN_URL = BASE_URL + \"bin/\";\n\n    /**\n     * @since 5.0M2\n     * @deprecated since 7.3M1, use {@link #getBaseURL()} instead\n     */\n    @Deprecated\n    public static final String BASE_REST_URL = BASE_URL + \"rest/\";\n\n    /**\n     * @since 7.3M1\n     */\n    public static final int[] STATUS_OK_NOT_FOUND =\n        new int[] { Status.OK.getStatusCode(), Status.NOT_FOUND.getStatusCode() };\n\n    /**\n     * @since 7.3M1\n     */\n    public static final int[] STATUS_OK = new int[] { Status.OK.getStatusCode() };\n\n    /**\n     * @since 7.3M1\n     */\n    public static final int[] STATUS_NO_CONTENT = new int[] { Status.NO_CONTENT.getStatusCode() };\n\n    /**\n     * @since 8.3RC1\n     */\n    public static final int[] STATUS_NO_CONTENT_NOT_FOUND =\n        new int[] { Status.NO_CONTENT.getStatusCode(), Status.NOT_FOUND.getStatusCode() };\n\n    /**\n     * @since 7.3M1\n     */\n    public static final int[] STATUS_CREATED_ACCEPTED =\n        new int[] { Status.CREATED.getStatusCode(), Status.ACCEPTED.getStatusCode() };\n\n    /**\n     * @since 7.3M1\n     */\n    public static final int[] STATUS_CREATED = new int[] { Status.CREATED.getStatusCode() };\n\n    /**\n     * @since 9.5RC1\n     */\n    public static final int[] STATUS_ACCEPTED = new int[] { Status.ACCEPTED.getStatusCode() };\n\n    private static PersistentTestContext context;\n\n    private static ComponentManager componentManager;\n\n    private static EntityReferenceResolver<String> relativeReferenceResolver;\n\n    private static EntityReferenceSerializer<String> referenceSerializer;\n\n    private static EntityReferenceResolver<String> referenceResolver;\n\n    private static EntityReferenceSerializer<String> localReferenceSerializer;\n\n    /**\n     * Used to convert Java object into its REST XML representation.\n     */\n    private static Marshaller marshaller;\n\n    /**\n     * Used to convert REST request XML result into its Java representation.\n     */\n    private static Unmarshaller unmarshaller;\n\n    private static String urlPrefix = XWikiExecutor.URL;\n\n    /** Cached secret token. TODO cache for each user. */\n    private String secretToken = null;\n\n    private HttpClient httpClient;\n\n    /**\n     * @since 8.0M1\n     */\n    private List<XWikiExecutor> executors;\n\n    /**\n     * @since 7.3M1\n     */\n    private int currentExecutorIndex = 0;\n\n    /**\n     * @since 7.3M1\n     */\n    private String currentWiki = \"xwiki\";\n\n    private RestTestUtils rest;\n\n    public TestUtils()\n    {\n        this.httpClient = new HttpClient();\n\n        setDefaultCredentials(SUPER_ADMIN_CREDENTIALS);\n\n        this.rest = new RestTestUtils(this);\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public XWikiExecutor getCurrentExecutor()\n    {\n        return this.executors != null && this.executors.size() > this.currentExecutorIndex\n            ? this.executors.get(this.currentExecutorIndex) : null;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public void switchExecutor(int index)\n    {\n        this.currentExecutorIndex = index;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public void setExecutors(List<XWikiExecutor> executors)\n    {\n        this.executors = executors;\n    }\n\n    /** Used so that AllTests can set the persistent test context. */\n    public static void setContext(PersistentTestContext context)\n    {\n        TestUtils.context = context;\n    }\n\n    public static void initializeComponent(ComponentManager componentManager) throws Exception\n    {\n        TestUtils.componentManager = componentManager;\n        TestUtils.relativeReferenceResolver =\n            TestUtils.componentManager.getInstance(EntityReferenceResolver.TYPE_STRING, \"relative\");\n        TestUtils.referenceResolver = TestUtils.componentManager.getInstance(EntityReferenceResolver.TYPE_STRING);\n        TestUtils.referenceSerializer = TestUtils.componentManager.getInstance(EntityReferenceSerializer.TYPE_STRING);\n        TestUtils.localReferenceSerializer = TestUtils.componentManager.getInstance(\n            new DefaultParameterizedType(null, EntityReferenceSerializer.class, String.class), \"local\");\n    }\n\n    public XWikiWebDriver getDriver()\n    {\n        return TestUtils.context.getDriver();\n    }\n\n    public Session getSession()\n    {\n        return this.new Session(getDriver().manage().getCookies(), getSecretToken());\n    }\n\n    public void setSession(Session session)\n    {\n        WebDriver.Options options = getDriver().manage();\n        options.deleteAllCookies();\n        if (session != null) {\n            for (Cookie cookie : session.getCookies()) {\n                // Using a cookie for single component domain (i.e., without '.', like 'localhost' or 'xwikiweb') \n                // apparently triggers the following error in firefox:\n                // org.openqa.selenium.UnableToSetCookieException:\n                //[Exception... \"Component returned failure code: 0x80070057 (NS_ERROR_ILLEGAL_VALUE)\n                // [nsICookieManager.add]\" nsresult: \"0x80070057 (NS_ERROR_ILLEGAL_VALUE)\"\n                // location: \"JS frame :: chrome://marionette/content/cookie.js :: cookie.add :: line 177\" data: no]\n                //\n                // According to the following discussions:\n                // - https://stackoverflow.com/questions/1134290/cookies-on-localhost-with-explicit-domain\n                // - https://github.com/mozilla/geckodriver/issues/1579\n                // a working solution is to put null in the cookie domain.\n                // Now we might need to fix this in our real code, but the situation is not quite clear for me.\n                if (cookie.getDomain() !=null && !cookie.getDomain().contains(\".\")) {\n                    cookie = new Cookie(cookie.getName(), cookie.getValue(), null, cookie.getPath(),\n                        cookie.getExpiry(), cookie.isSecure(), cookie.isHttpOnly());\n                }\n                options.addCookie(cookie);\n            }\n        }\n        if (session != null && !StringUtils.isEmpty(session.getSecretToken())) {\n            this.secretToken = session.getSecretToken();\n        } else {\n            recacheSecretToken();\n        }\n    }\n\n    /**\n     * @since 7.0RC1\n     */\n    public void setDefaultCredentials(String username, String password)\n    {\n        setDefaultCredentials(new UsernamePasswordCredentials(username, password));\n    }\n\n    /**\n     * @since 7.0RC1\n     */\n    public UsernamePasswordCredentials setDefaultCredentials(UsernamePasswordCredentials defaultCredentials)\n    {\n        UsernamePasswordCredentials currentCredentials = getDefaultCredentials();\n\n        if (defaultCredentials != null) {\n            this.httpClient.getState().setCredentials(AuthScope.ANY, defaultCredentials);\n            this.httpClient.getParams().setAuthenticationPreemptive(true);\n        } else {\n            this.httpClient.getState().clearCredentials();\n            this.httpClient.getParams().setAuthenticationPreemptive(false);\n        }\n\n        return currentCredentials;\n    }\n\n    public UsernamePasswordCredentials getDefaultCredentials()\n    {\n        return (UsernamePasswordCredentials) this.httpClient.getState().getCredentials(AuthScope.ANY);\n    }\n\n    public void loginAsSuperAdmin()\n    {\n        login(SUPER_ADMIN_CREDENTIALS.getUserName(), SUPER_ADMIN_CREDENTIALS.getPassword());\n    }\n\n    public void loginAsSuperAdminAndGotoPage(String pageURL)\n    {\n        loginAndGotoPage(SUPER_ADMIN_CREDENTIALS.getUserName(), SUPER_ADMIN_CREDENTIALS.getPassword(), pageURL);\n    }\n\n    public void loginAsAdmin()\n    {\n        login(ADMIN_CREDENTIALS.getUserName(), ADMIN_CREDENTIALS.getPassword());\n    }\n\n    public void loginAsAdminAndGotoPage(String pageURL)\n    {\n        loginAndGotoPage(ADMIN_CREDENTIALS.getUserName(), ADMIN_CREDENTIALS.getPassword(), pageURL);\n    }\n\n    public void login(String username, String password)\n    {\n        loginAndGotoPage(username, password, null);\n    }\n\n    public void loginAndGotoPage(String username, String password, String pageURL)\n    {\n        loginAndGotoPage(username, password, pageURL, true);\n    }\n\n    /**\n     * @since 11.6RC1\n     */\n    public void loginAndGotoPage(String username, String password, String pageURL, boolean checkLoginSuccess)\n    {\n        if (!username.equals(getLoggedInUserName())) {\n            // Log in and direct to a non existent page so that it loads very fast and we don't incur the time cost of\n            // going to the home page for example.\n            // Also recache the CSRF token\n            String destUrl = getURL(\"XWiki\", \"Register\", \"register\");\n            getDriver().get(getURLToLoginAndGotoPage(username, password, destUrl));\n\n            if (checkLoginSuccess && !getDriver().getCurrentUrl().startsWith(destUrl)) {\n                throw new RuntimeException(\n                    String.format(\"Login failed with credentials: [%s] / [%s]. Was expecting to be on URL [%s] but \"\n                        + \"was on [%s]. Page source is [%s]\", username, password, destUrl,\n                        getDriver().getCurrentUrl(), getDriver().getPageSource()));\n\n            }\n            recacheSecretTokenWhenOnRegisterPage();\n            if (pageURL != null) {\n                // Go to the page asked\n                getDriver().get(pageURL);\n            } else {\n                getDriver().get(getURLToNonExistentPage());\n            }\n\n            setDefaultCredentials(username, password);\n        }\n    }\n\n    /**\n     * Consider using setSession(null) because it will drop the cookies which is faster than invoking a logout action.\n     */\n    public String getURLToLogout()\n    {\n        return getURL(\"XWiki\", \"XWikiLogin\", \"logout\");\n    }\n\n    public String getURLToLoginAsAdmin()\n    {\n        return getURLToLoginAs(ADMIN_CREDENTIALS.getUserName(), ADMIN_CREDENTIALS.getPassword());\n    }\n\n    public String getURLToLoginAsSuperAdmin()\n    {\n        return getURLToLoginAs(SUPER_ADMIN_CREDENTIALS.getUserName(), SUPER_ADMIN_CREDENTIALS.getPassword());\n    }\n\n    public String getURLToLoginAs(final String username, final String password)\n    {\n        return getURLToLoginAndGotoPage(username, password, null);\n    }\n\n    /**\n     * @param pageURL the URL of the page to go to after logging in.\n     * @return URL to accomplish login and goto.\n     */\n    public String getURLToLoginAsAdminAndGotoPage(final String pageURL)\n    {\n        return getURLToLoginAndGotoPage(ADMIN_CREDENTIALS.getUserName(), ADMIN_CREDENTIALS.getPassword(), pageURL);\n    }\n\n    /**\n     * @param pageURL the URL of the page to go to after logging in.\n     * @return URL to accomplish login and goto.\n     */\n    public String getURLToLoginAsSuperAdminAndGotoPage(final String pageURL)\n    {\n        return getURLToLoginAndGotoPage(SUPER_ADMIN_CREDENTIALS.getUserName(), SUPER_ADMIN_CREDENTIALS.getPassword(),\n            pageURL);\n    }\n\n    /**\n     * @param username the name of the user to log in as.\n     * @param password the password for the user to log in.\n     * @param pageURL the URL of the page to go to after logging in.\n     * @return URL to accomplish login and goto.\n     */\n    public String getURLToLoginAndGotoPage(final String username, final String password, final String pageURL)\n    {\n        Map<String, String> parameters = new HashMap<String, String>()\n        {\n            {\n                put(\"j_username\", username);\n                put(\"j_password\", password);\n                if (pageURL != null && pageURL.length() > 0) {\n                    put(\"xredirect\", pageURL);\n                }\n            }\n        };\n        return getURL(\"XWiki\", \"XWikiLogin\", \"loginsubmit\", parameters);\n    }\n\n    /**\n     * @return URL to a non existent page that loads very fast (we are using plain mode so that we don't even have to\n     *         display the skin ;))\n     */\n    public String getURLToNonExistentPage()\n    {\n        return getURL(\"NonExistentSpace\", \"NonExistentPage\", \"view\", \"xpage=plain\");\n    }\n\n    /**\n     * After successful completion of this function, you are guaranteed to be logged in as the given user and on the\n     * page passed in pageURL.\n     */\n    public void assertOnPage(final String pageURL)\n    {\n        final String pageURI = pageURL.replaceAll(\"\\\\?.*\", \"\");\n        getDriver().waitUntilCondition(new ExpectedCondition<Boolean>()\n        {\n            @Override\n            public Boolean apply(WebDriver driver)\n            {\n                return getDriver().getCurrentUrl().contains(pageURI);\n            }\n        });\n    }\n\n    public String getLoggedInUserName()\n    {\n        By userAvatarInDrawer = By.id(\"tmUser\");\n        if (!getDriver().hasElementWithoutWaiting(userAvatarInDrawer)) {\n            // Guest\n            return null;\n        }\n\n        WebElement element = getDriver().findElementWithoutWaiting(userAvatarInDrawer);\n        String href = element.getAttribute(\"href\");\n        String loggedInUserName = href.substring(href.lastIndexOf(\"/\") + 1);\n\n        // Return\n        return loggedInUserName;\n    }\n\n    public void createUserAndLogin(final String username, final String password, Object... properties)\n    {\n        createUserAndLoginWithRedirect(username, password, getURLToNonExistentPage(), properties);\n    }\n\n    public void createUserAndLoginWithRedirect(final String username, final String password, String url,\n        Object... properties)\n    {\n        createUser(username, password, getURLToLoginAndGotoPage(username, password, url), properties);\n\n        setDefaultCredentials(username, password);\n    }\n\n    public void createUser(final String username, final String password, String redirectURL, Object... properties)\n    {\n        Map<String, String> parameters = new HashMap<String, String>();\n        parameters.put(\"register\", \"1\");\n        parameters.put(\"xwikiname\", username);\n        parameters.put(\"register_password\", password);\n        parameters.put(\"register2_password\", password);\n        parameters.put(\"register_email\", \"\");\n        if (!StringUtils.isEmpty(redirectURL)) {\n            parameters.put(\"xredirect\", redirectURL);\n        }\n        parameters.put(\"form_token\", getSecretToken());\n        getDriver().get(getURL(\"XWiki\", \"Register\", \"register\", parameters));\n        recacheSecretToken();\n        if (properties.length > 0) {\n            updateObject(\"XWiki\", username, \"XWiki.XWikiUsers\", 0, properties);\n        }\n    }\n\n    /**\n     * Creates the Admin user, add it to the XWikiAdminGroup and login.\n     * Note that this method requires to be superadmin to be effective.\n     *\n     * @since 12.2\n     */\n    public void createAdminUser()\n    {\n        createAdminUser(false);\n    }\n\n    /**\n     * Creates the Admin user, add it to the XWikiAdminGroup and login.\n     * Note that this method requires to be superadmin to be effective.\n     *\n     * @param programming true of the user should also be given programming right\n     * @since 15.1RC1\n     * @since 14.10.5\n     */\n    public void createAdminUser(boolean programming)\n    {\n        String username = ADMIN_CREDENTIALS.getUserName();\n        String password = ADMIN_CREDENTIALS.getPassword();\n        LocalDocumentReference userReference = new LocalDocumentReference(\"XWiki\", username);\n        Page userPage = rest().page(userReference);\n        userPage.setObjects(new org.xwiki.rest.model.jaxb.Objects());\n        org.xwiki.rest.model.jaxb.Object userObject = RestTestUtils.object(\"XWiki.XWikiUsers\");\n\n        // Set password\n        userObject.getProperties().add(RestTestUtils.property(\"password\", password));\n        userPage.getObjects().getObjectSummaries().add(userObject);\n\n        // Save the user page\n        try {\n            rest().save(userPage);\n        } catch (Exception e) {\n            fail(\"Failed to save the user with name [\" + username + \"]\", e);\n        }\n        // Add the user to XWikiAllGroup\n        addObject(\"XWiki\", \"XWikiAllGroup\", \"XWiki.XWikiGroups\", \"member\", serializeReference(userReference));\n        // Add the user to XWikiAdminGroup group (before we login as the user does not have admin right at first)\n        addObject(\"XWiki\", \"XWikiAdminGroup\", \"XWiki.XWikiGroups\", \"member\", serializeReference(userReference));\n        // Give ADMIN right (and maybe PROGRAMMING right) to XWikiAdminGroup\n        setGlobalRights(\"XWiki.XWikiAdminGroup\", \"\", programming ? \"admin,programming\" : \"admin\", true);\n        loginAsAdmin();\n    }\n\n    /**\n     * Add or update a {@code XWikiGlobalRights} xobject to the current wiki's {@code XWikiPreferences} document.\n     *\n     * @param groups the comma-separated list of groups that will have the rights (e.g. {@code XWiki.XWikiAdminGroup}.\n     *               Can be empty or null\n     * @param users the comma-separated list of users that will have the rights (e.g. {@code XWiki.Admin}. Can be\n     *              empty of null\n     * @param rights the comma-separated list of rights to give (e.g. {@code edit,admin})\n     * @param enabled true if the rights should be allowed, false if they should be disabled\n     * @since 12.2\n     */\n    public void setGlobalRights(String groups, String users, String rights, boolean enabled)\n    {\n        EntityReference xwikiPreferencesReference = new EntityReference(\"XWikiPreferences\", EntityType.DOCUMENT,\n            new EntityReference(\"XWiki\", EntityType.SPACE));\n        setRights(xwikiPreferencesReference, \"XWiki.XWikiGlobalRights\", groups, users, rights, enabled);\n    }\n\n    /**\n     * Add or update a {@code XWikiRights} xobject to the document specified in the passed entity reference.\n     *\n     * @param entityReference the reference to the document for which to set rights for\n     * @param groups the comma-separated list of groups that will have the rights (e.g. {@code XWiki.XWikiAdminGroup}.\n     *               Can be empty or null\n     * @param users the comma-separated list of users that will have the rights (e.g. {@code XWiki.Admin}. Can be\n     *              empty of null\n     * @param rights the comma-separated list of rights to give (e.g. {@code edit,admin})\n     * @param enabled true if the rights should be allowed, false if they should be denied\n     * @since 12.2\n     */\n    public void setRights(EntityReference entityReference, String groups, String users, String rights, boolean enabled)\n    {\n        setRights(entityReference, \"XWiki.XWikiRights\", groups, users, rights, enabled);\n    }\n\n    /**\n     * Add or update a {@code XWikiRights} xobject to the specified space reference.\n     *\n     * @param space the reference to the space for which to set rights for\n     * @param groups the comma-separated list of groups that will have the rights (e.g. {@code XWiki.XWikiAdminGroup}.\n     *               Can be empty or null\n     * @param users the comma-separated list of users that will have the rights (e.g. {@code XWiki.Admin}. Can be\n     *              empty of null\n     * @param rights the comma-separated list of rights to give (e.g. {@code edit,admin})\n     * @param enabled true if the rights should be allowed, false if they should be denied\n     * @since 14.10\n     */\n    public void setRightsOnSpace(SpaceReference space, String groups, String users, String rights, boolean enabled)\n    {\n        DocumentReference documentReference = new DocumentReference(\"WebPreferences\", space);\n        setRights(documentReference, \"XWiki.XWikiGlobalRights\", groups, users, rights, enabled);\n    }\n\n    private void setRights(EntityReference entityReference, String rightClassName, String groups, String users,\n        String rights, boolean enabled)\n    {\n        String normalizedUsers = users == null ? \"\" : users;\n        String normalizedGroups = groups == null ? \"\" : groups;\n        addObject(entityReference, rightClassName, \"groups\", normalizedGroups, \"levels\", rights,\n            \"users\", normalizedUsers, \"allow\", enabled ? \"1\" : \"0\");\n    }\n\n    public ViewPage gotoPage(String space, String page)\n    {\n        gotoPage(space, page, \"view\");\n        return new ViewPage();\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage gotoPage(EntityReference reference)\n    {\n        gotoPage(reference, \"view\");\n        return new ViewPage();\n    }\n\n    public void gotoPage(String space, String page, String action)\n    {\n        gotoPage(space, page, action, \"\");\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void gotoPage(EntityReference reference, String action)\n    {\n        gotoPage(reference, action, \"\");\n    }\n\n    /**\n     * @since 3.5M1\n     */\n    public void gotoPage(String space, String page, String action, Object... queryParameters)\n    {\n        gotoPage(space, page, action, toQueryString(queryParameters));\n    }\n\n    /**\n     * @since 11.3RC1\n     */\n    public void gotoPage(EntityReference reference, String action, Object... queryParameters)\n    {\n        gotoPage(reference, action, toQueryString(queryParameters));\n    }\n\n    public void gotoPage(String space, String page, String action, Map<String, ?> queryParameters)\n    {\n        gotoPage(Collections.singletonList(space), page, action, queryParameters);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void gotoPage(List<String> spaces, String page, String action, Map<String, ?> queryParameters)\n    {\n        gotoPage(spaces, page, action, toQueryString(queryParameters));\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void gotoPage(EntityReference reference, String action, Map<String, ?> queryParameters)\n    {\n        gotoPage(reference, action, toQueryString(queryParameters));\n    }\n\n    public void gotoPage(String space, String page, String action, String queryString)\n    {\n        gotoPage(Collections.singletonList(space), page, action, queryString);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void gotoPage(List<String> spaces, String page, String action, String queryString)\n    {\n        gotoPage(getURL(spaces, page, action, queryString));\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void gotoPage(EntityReference reference, String action, String queryString)\n    {\n        gotoPage(reference, action, queryString, null);\n    }\n\n    /**\n     * @since 10.9\n     */\n    public void gotoPage(EntityReference reference, String action, String queryString, String fragment)\n    {\n        gotoPage(getURL(reference, action, queryString, fragment));\n\n        // Update current wiki\n        EntityReference wikiReference = reference.extractReference(EntityType.WIKI);\n        if (wikiReference != null) {\n            this.currentWiki = wikiReference.getName();\n        }\n    }\n\n    public void gotoPage(String url)\n    {\n        getDriver().get(url);\n    }\n\n    public String getURLToDeletePage(String space, String page)\n    {\n        return getURL(space, page, \"delete\", \"confirm=1\");\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public String getURLToDeletePage(EntityReference reference)\n    {\n        return getURLToDeletePage(reference, false);\n    }\n\n    /**\n     * @since 12.9RC1\n     */\n    public String getURLToDeletePage(EntityReference reference, boolean affectChildren)\n    {\n        String queryString = \"confirm=1&async=false\";\n        if (affectChildren) {\n            queryString += \"&affectChildren=true\";\n        }\n        return getURL(reference, \"delete\", queryString);\n    }\n\n    /**\n     * @param space the name of the space to delete\n     * @return the URL that can be used to delete the specified pace\n     * @since 4.5\n     */\n    public String getURLToDeleteSpace(String space)\n    {\n        return getURL(space, \"WebHome\", \"deletespace\", \"confirm=1&async=false&affectChidlren=on\");\n    }\n\n    /**\n     * @param space the reference of the space to delete\n     * @return the URL that can be used to delete the specified pace\n     * @since 14.1RC1\n     */\n    public String getURLToDeleteSpace(EntityReference space)\n    {\n        return getURL(space, \"WebHome\", \"deletespace\", \"confirm=1&async=false&affectChidlren=on\");\n    }\n\n    public ViewPage createPage(String space, String page, String content, String title)\n    {\n        return createPage(Collections.singletonList(space), page, content, title);\n    }\n\n    /**\n     * @since 11.5RC1\n     * @since 11.3.1\n     */\n    public ViewPage createPage(EntityReference reference, String content)\n    {\n        return createPage(reference, content, this.serializeReference(reference), null);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage createPage(EntityReference reference, String content, String title)\n    {\n        return createPage(reference, content, title, null);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage createPage(List<String> spaces, String page, String content, String title)\n    {\n        return createPage(spaces, page, content, title, null);\n    }\n\n    public ViewPage createPage(String space, String page, String content, String title, String syntaxId)\n    {\n        return createPage(Collections.singletonList(space), page, content, title, syntaxId);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage createPage(EntityReference reference, String content, String title, String syntaxId)\n    {\n        return createPage(reference, content, title, syntaxId, null);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage createPage(List<String> spaces, String page, String content, String title, String syntaxId)\n    {\n        return createPage(spaces, page, content, title, syntaxId, null);\n    }\n\n    public ViewPage createPage(String space, String page, String content, String title, String syntaxId,\n        String parentFullPageName)\n    {\n        return createPage(Collections.singletonList(space), page, content, title, syntaxId, parentFullPageName);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage createPage(List<String> spaces, String page, String content, String title, String syntaxId,\n        String parentFullPageName)\n    {\n        Map<String, String> queryMap = new HashMap<String, String>();\n        if (content != null) {\n            queryMap.put(\"content\", content);\n        }\n        if (title != null) {\n            queryMap.put(\"title\", title);\n        }\n        if (syntaxId != null) {\n            queryMap.put(\"syntaxId\", syntaxId);\n        }\n        if (parentFullPageName != null) {\n            queryMap.put(\"parent\", parentFullPageName);\n        }\n        gotoPage(spaces, page, \"save\", queryMap);\n        return new ViewPage();\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage createPage(EntityReference reference, String content, String title, String syntaxId,\n        String parentFullPageName)\n    {\n        Map<String, String> queryMap = new HashMap<>();\n        if (content != null) {\n            queryMap.put(\"content\", content);\n        }\n        if (title != null) {\n            queryMap.put(\"title\", title);\n        }\n        if (syntaxId != null) {\n            queryMap.put(\"syntaxId\", syntaxId);\n        }\n        if (parentFullPageName != null) {\n            queryMap.put(\"parent\", parentFullPageName);\n        }\n        gotoPage(reference, \"save\", queryMap);\n        return new ViewPage();\n    }\n\n    /**\n     * @since 5.1M2\n     */\n    public ViewPage createPageWithAttachment(String space, String page, String content, String title, String syntaxId,\n        String parentFullPageName, String attachmentName, InputStream attachmentData) throws Exception\n    {\n        return createPageWithAttachment(space, page, content, title, syntaxId, parentFullPageName, attachmentName,\n            attachmentData, null);\n    }\n\n    /**\n     * @since 5.1M2\n     */\n    public ViewPage createPageWithAttachment(String space, String page, String content, String title, String syntaxId,\n        String parentFullPageName, String attachmentName, InputStream attachmentData,\n        UsernamePasswordCredentials credentials) throws Exception\n    {\n        return createPageWithAttachment(Collections.singletonList(space), page, content, title, syntaxId,\n            parentFullPageName, attachmentName, attachmentData, credentials);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage createPageWithAttachment(List<String> spaces, String page, String content, String title,\n        String syntaxId, String parentFullPageName, String attachmentName, InputStream attachmentData,\n        UsernamePasswordCredentials credentials) throws Exception\n    {\n        ViewPage vp = createPage(spaces, page, content, title, syntaxId, parentFullPageName);\n        attachFile(spaces, page, attachmentName, attachmentData, false, credentials);\n        return vp;\n    }\n\n    /**\n     * @since 5.1M2\n     */\n    public ViewPage createPageWithAttachment(String space, String page, String content, String title,\n        String attachmentName, InputStream attachmentData) throws Exception\n    {\n        return createPageWithAttachment(space, page, content, title, null, null, attachmentName, attachmentData);\n    }\n\n    /**\n     * @since 5.1M2\n     */\n    public ViewPage createPageWithAttachment(String space, String page, String content, String title,\n        String attachmentName, InputStream attachmentData, UsernamePasswordCredentials credentials) throws Exception\n    {\n        ViewPage vp = createPage(space, page, content, title);\n        attachFile(space, page, attachmentName, attachmentData, false, credentials);\n        return vp;\n    }\n\n    /**\n     * @since 12.2\n     */\n    public ViewPage createPageWithAttachment(EntityReference reference, String content, String title,\n        String attachmentName, InputStream attachmentData, UsernamePasswordCredentials credentials) throws Exception\n    {\n        ViewPage vp = createPage(reference, content, title);\n        attachFile(reference, attachmentName, attachmentData, false, credentials);\n        return vp;\n    }\n\n    /**\n     * @since 12.2\n     */\n    public ViewPage createPageWithAttachment(EntityReference reference, String content, String title,\n        String attachmentName, InputStream attachmentData) throws Exception\n    {\n        return createPageWithAttachment(reference, content, title, attachmentName, attachmentData, null);\n    }\n\n    public void deletePage(String space, String page)\n    {\n        getDriver().get(getURLToDeletePage(space, page));\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void deletePage(EntityReference reference)\n    {\n        deletePage(reference, false);\n    }\n\n    /**\n     * @since 12.9RC1\n     */\n    public void deletePage(EntityReference reference, boolean affectChildren)\n    {\n        getDriver().get(getURLToDeletePage(reference, affectChildren));\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public EntityReference resolveDocumentReference(String referenceAsString)\n    {\n        return referenceResolver.resolve(referenceAsString, EntityType.DOCUMENT);\n    }\n\n    /**\n     * @since 7.2M3\n     */\n    public EntityReference resolveSpaceReference(String referenceAsString)\n    {\n        return referenceResolver.resolve(referenceAsString, EntityType.SPACE);\n    }\n\n    /**\n     * @since 7.2RC1\n     */\n    public String serializeReference(EntityReference reference)\n    {\n        return referenceSerializer.serialize(reference);\n    }\n\n    /**\n     * Accesses the URL to delete the specified space.\n     *\n     * @param space the name of the space to delete\n     * @since 4.5\n     */\n    public void deleteSpace(String space)\n    {\n        getDriver().get(getURLToDeleteSpace(space));\n    }\n\n    /**\n     * Accesses the URL to delete the specified space.\n     *\n     * @param space the reference of the space to delete\n     * @since 14.1RC1\n     */\n    public void deleteSpace(EntityReference space)\n    {\n        getDriver().get(getURLToDeleteSpace(space));\n    }\n\n    public boolean pageExists(String space, String page) throws Exception\n    {\n        return rest().exists(new LocalDocumentReference(space, page));\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public boolean pageExists(List<String> spaces, String page) throws Exception\n    {\n        return rest().exists(new LocalDocumentReference(spaces, page));\n    }\n\n    /**\n     * Get the URL to view a page.\n     *\n     * @param space the space in which the page resides.\n     * @param page the name of the page.\n     */\n    public String getURL(String space, String page)\n    {\n        return getURL(space, page, \"view\");\n    }\n\n    /**\n     * Get the URL of an action on a page.\n     *\n     * @param space the space in which the page resides.\n     * @param page the name of the page.\n     * @param action the action to do on the page.\n     */\n    public String getURL(String space, String page, String action)\n    {\n        return getURL(space, page, action, \"\");\n    }\n\n    /**\n     * Get the URL of an action on a page with a specified query string.\n     *\n     * @param space the space in which the page resides.\n     * @param page the name of the page.\n     * @param action the action to do on the page.\n     * @param queryString the query string to pass in the URL.\n     */\n    public String getURL(String space, String page, String action, String queryString)\n    {\n        return getURL(action, new String[] { space, page }, queryString);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public String getURL(List<String> spaces, String page)\n    {\n        return getURL(spaces, page, \"view\", \"\");\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public String getURL(List<String> spaces, String page, String action, String queryString)\n    {\n        List<String> path = new ArrayList<>(spaces);\n        path.add(page);\n        return getURL(action, path.toArray(new String[] {}), queryString);\n    }\n\n    /**\n     * @since 12.2\n     */\n    public String getURL(EntityReference reference)\n    {\n        return getURL(reference, \"view\", \"\");\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public String getURL(EntityReference reference, String action, String queryString)\n    {\n        return getURL(reference, action, queryString, null);\n    }\n\n    /**\n     * @since 10.9\n     */\n    public String getURL(EntityReference reference, String action, String queryString, String fragment)\n    {\n        Serializable locale = reference.getParameters().get(\"locale\");\n        if (locale != null) {\n            queryString += \"&language=\" + locale;\n        }\n        return getURL(action, extractListFromReference(reference).toArray(new String[] {}), queryString, fragment);\n    }\n\n    /**\n     * @since 9.7RC1\n     */\n    public String executeAndGetBodyAsString(EntityReference reference, Map<String, ?> queryParameters) throws Exception\n    {\n        gotoPage(getURL(reference, \"get\", toQueryString(queryParameters)));\n        \n        return getDriver().findElementWithoutWaiting(By.tagName(\"body\")).getText();\n    }\n\n    /**\n     * @since 15.1RC1\n     * @since 14.10.5\n     */\n    public String executeWiki(String wikiContent, Syntax wikiSyntax) throws Exception\n    {\n        LocalDocumentReference reference =\n            new LocalDocumentReference(List.of(\"Test\", \"Execute\"), UUID.randomUUID().toString());\n\n        rest().savePage(reference, wikiContent, wikiSyntax.toIdString(), null, null);\n\n        return executeAndGetBodyAsString(reference, null);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public String getURLFragment(EntityReference reference)\n    {\n        return StringUtils.join(extractListFromReference(reference), \"/\");\n    }\n\n    private List<String> extractListFromReference(EntityReference reference)\n    {\n        List<String> path = new ArrayList<>();\n        // Add the spaces\n        EntityReference spaceReference = reference.extractReference(EntityType.SPACE);\n        EntityReference wikiReference = reference.extractReference(EntityType.WIKI);\n        for (EntityReference singleReference : spaceReference.removeParent(wikiReference).getReversedReferenceChain()) {\n            path.add(singleReference.getName());\n        }\n        if (reference.getType() == EntityType.DOCUMENT) {\n            path.add(reference.getName());\n        }\n        return path;\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public String getCurrentWiki()\n    {\n        return this.currentWiki;\n    }\n\n    /**\n     * @since 14.5\n     */\n    public void setCurrentWiki(String currentWiki)\n    {\n        this.currentWiki = currentWiki;\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public String getBaseURL()\n    {\n        String baseURL;\n\n        // If the URL has the port specified then consider it's a full URL and use it, otherwise add the port and the\n        // webapp context\n        if (TestUtils.urlPrefix.matches(\"http://.*:[0-9]+/.*\")) {\n            baseURL = TestUtils.urlPrefix;\n        } else {\n            baseURL = TestUtils.urlPrefix + \":\"\n                + (getCurrentExecutor() != null ? getCurrentExecutor().getPort() : XWikiExecutor.DEFAULT_PORT)\n                + XWikiExecutor.DEFAULT_CONTEXT;\n        }\n\n        if (!baseURL.endsWith(\"/\")) {\n            baseURL = baseURL + \"/\";\n        }\n\n        return baseURL;\n    }\n\n    /**\n     * @since 10.6RC1\n     */\n    public static void setURLPrefix(String urlPrefix)\n    {\n        TestUtils.urlPrefix = urlPrefix;\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public String getBaseBinURL()\n    {\n        return getBaseBinURL(this.currentWiki);\n    }\n\n    /**\n     * @since 11.2RC1\n     */\n    public String getBaseBinURL(String wiki)\n    {\n        return getBaseURL() + ((StringUtils.isEmpty(wiki) || wiki.equals(\"xwiki\")) ? \"bin/\" : \"wiki/\" + wiki + '/');\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getURL(String action, String[] path, String queryString)\n    {\n        return getURL(action, path, queryString, null);\n    }\n\n    /**\n     * @since 10.9\n     */\n    public String getURL(String action, String[] path, String queryString, String fragment)\n    {\n        StringBuilder builder = new StringBuilder(getBaseBinURL());\n\n        if (!StringUtils.isEmpty(action)) {\n            builder.append(action).append('/');\n        }\n        List<String> escapedPath = new ArrayList<>();\n        for (String element : path) {\n            escapedPath.add(escapeURL(element));\n        }\n        builder.append(StringUtils.join(escapedPath, '/'));\n\n        boolean needToAddSecretToken = !Arrays.asList(\"view\", \"register\", \"download\", \"export\").contains(action);\n        if (needToAddSecretToken || !StringUtils.isEmpty(queryString)) {\n            builder.append('?');\n        }\n        if (needToAddSecretToken) {\n            addQueryStringEntry(builder, \"form_token\", getSecretToken());\n            builder.append('&');\n        }\n        if (!StringUtils.isEmpty(queryString)) {\n            builder.append(queryString);\n        }\n\n        if (!StringUtils.isEmpty(fragment)) {\n            builder.append('#').append(fragment);\n        }\n\n        return builder.toString();\n    }\n\n    /**\n     * Get the URL of an action on a page with specified parameters. If you need to pass multiple parameters with the\n     * same key, this function will not work.\n     *\n     * @param space the space in which the page resides.\n     * @param page the name of the page.\n     * @param action the action to do on the page.\n     * @param queryParameters the parameters to pass in the URL, these will be automatically URL encoded.\n     */\n    public String getURL(String space, String page, String action, Map<String, ?> queryParameters)\n    {\n        return getURL(space, page, action, toQueryString(queryParameters));\n    }\n\n    /**\n     * @param space the name of the space that contains the page with the specified attachment\n     * @param page the name of the page that holds the attachment\n     * @param attachment the attachment name\n     * @param action the action to perform on the attachment\n     * @param queryString the URL query string\n     * @return the URL that performs the specified action on the specified attachment\n     */\n    public String getAttachmentURL(String space, String page, String attachment, String action, String queryString)\n    {\n        return getURL(action, new String[] { space, page, attachment }, queryString);\n    }\n\n    /**\n     * @param space the name of the space that contains the page with the specified attachment\n     * @param page the name of the page that holds the attachment\n     * @param attachment the attachment name\n     * @param action the action to perform on the attachment\n     * @return the URL that performs the specified action on the specified attachment\n     */\n    public String getAttachmentURL(String space, String page, String attachment, String action)\n    {\n        return getAttachmentURL(space, page, attachment, action, \"\");\n    }\n\n    /**\n     * @param space the name of the space that contains the page with the specified attachment\n     * @param page the name of the page that holds the attachment\n     * @param attachment the attachment name\n     * @return the URL to download the specified attachment\n     */\n    public String getAttachmentURL(String space, String page, String attachment)\n    {\n        return getAttachmentURL(space, page, attachment, \"download\");\n    }\n\n    /**\n     * (Re)-cache the secret token used for CSRF protection. A user with edit rights on Main.WebHome must be logged in.\n     * This method must be called before {@link #getSecretToken()} is called and after each re-login.\n     *\n     * @see #getSecretToken()\n     */\n    public void recacheSecretToken()\n    {\n        // Save the current URL to be able to get back after we cache the secret token. We're not using the browser's\n        // Back button because if the current page is the result of a POST request then by going back we are re-sending\n        // the POST data which can have unexpected results. Moreover, some browsers pop up a modal confirmation box\n        // which blocks the test.\n        String previousURL = getDriver().getCurrentUrl();\n        // Go to the registration page because the registration form uses secret token.\n        gotoPage(getCurrentWiki(), \"Register\", \"register\");\n        recacheSecretTokenWhenOnRegisterPage();\n        // Return to the previous page.\n        getDriver().get(previousURL);\n    }\n\n    private void recacheSecretTokenWhenOnRegisterPage()\n    {\n        try {\n            WebElement tokenInput = getDriver().findElement(By.xpath(\"//input[@name='form_token']\"));\n            this.secretToken = tokenInput.getAttribute(\"value\");\n        } catch (NoSuchElementException exception) {\n            // Something is really wrong if this happens.\n            System.out.println(\"Warning: Failed to cache anti-CSRF secret token, some tests might fail!\");\n            exception.printStackTrace();\n        }\n    }\n\n    /**\n     * Get the secret token used for CSRF protection. Remember to call {@link #recacheSecretToken()} first.\n     *\n     * @return anti-CSRF secret token, or empty string if the token was not cached\n     * @see #recacheSecretToken()\n     */\n    public String getSecretToken()\n    {\n        if (this.secretToken == null) {\n            System.out.println(\"Warning: No cached anti-CSRF token found. \"\n                + \"Make sure to call recacheSecretToken() before getSecretToken(), otherwise this test might fail.\");\n            return \"\";\n        }\n        return this.secretToken;\n    }\n\n    /**\n     * This class represents all cookies stored in the browser. Use with getSession() and setSession()\n     */\n    public class Session\n    {\n        private final Set<Cookie> cookies;\n\n        private final String secretToken;\n\n        private Session(final Set<Cookie> cookies, final String secretToken)\n        {\n            this.cookies = Collections.unmodifiableSet(new HashSet<Cookie>()\n            {\n                {\n                    addAll(cookies);\n                }\n            });\n            this.secretToken = secretToken;\n        }\n\n        private Set<Cookie> getCookies()\n        {\n            return this.cookies;\n        }\n\n        private String getSecretToken()\n        {\n            return this.secretToken;\n        }\n    }\n\n    public boolean isInWYSIWYGEditMode()\n    {\n        return getDriver().findElements(By.xpath(\"//div[@id='editcolumn' and contains(@class, 'editor-wysiwyg')]\"))\n            .size() > 0;\n    }\n\n    public boolean isInWikiEditMode()\n    {\n        return getDriver().findElements(By.xpath(\"//div[@id='editcolumn' and contains(@class, 'editor-wiki')]\"))\n            .size() > 0;\n    }\n\n    public boolean isInViewMode()\n    {\n        return !getDriver().hasElementWithoutWaiting(By.id(\"editMeta\"));\n    }\n\n    public boolean isInSourceViewMode()\n    {\n        String currentURL = getDriver().getCurrentUrl();\n        return currentURL.contains(\"/view/\") && currentURL.contains(\"viewer=code\");\n    }\n\n    public boolean isInInlineEditMode()\n    {\n        String currentURL = getDriver().getCurrentUrl();\n        // Keep checking the deprecated inline action for backward compatibility.\n        return currentURL.contains(\"editor=inline\") || currentURL.contains(\"/inline/\");\n    }\n\n    public boolean isInRightsEditMode()\n    {\n        return getDriver().getCurrentUrl().contains(\"editor=rights\");\n    }\n\n    public boolean isInObjectEditMode()\n    {\n        return getDriver().getCurrentUrl().contains(\"editor=object\");\n    }\n\n    public boolean isInClassEditMode()\n    {\n        return getDriver().getCurrentUrl().contains(\"editor=class\");\n    }\n\n    public boolean isInDeleteMode()\n    {\n        return getDriver().getCurrentUrl().contains(\"/delete/\");\n    }\n\n    public boolean isInRenameMode()\n    {\n        return getDriver().getCurrentUrl().contains(\"xpage=rename\");\n    }\n\n    public boolean isInCreateMode()\n    {\n        return getDriver().getCurrentUrl().contains(\"/create/\");\n    }\n\n    public boolean isInAdminMode()\n    {\n        return getDriver().getCurrentUrl().contains(\"/admin/\");\n    }\n\n    /**\n     * Verify if the passed reference corresponds to the current page, independently of the wiki.\n     * Throws an {@link AssertionFailedError} if it's not the case.\n     *\n     * @param reference the reference to the document to check\n     * @since 12.2\n     */\n    public void assertOnPage(EntityReference reference)\n    {\n        if (EntityType.DOCUMENT.equals(reference.getType())) {\n            BasePage bp = new BasePage();\n            assertEquals(localReferenceSerializer.serialize(reference), bp.getMetaDataValue(\"document\"));\n        } else {\n            throw new IllegalArgumentException(\"You should pass a reference to a document\");\n        }\n    }\n\n    /**\n     * Forces the current user to be the Guest user by clearing all coookies.\n     */\n    public void forceGuestUser()\n    {\n        setSession(null);\n    }\n\n    public void addObject(String space, String page, String className, Object... properties)\n    {\n        gotoPage(space, page, \"objectadd\", toQueryParameters(className, null, properties));\n    }\n\n    /**\n     * @since 7.2RC1\n     */\n    public void addObject(EntityReference reference, String className, Object... properties)\n    {\n        gotoPage(reference, \"objectadd\", toQueryParameters(className, null, properties));\n    }\n\n    /**\n     * @since 7.3M2\n     */\n    public void addObject(EntityReference reference, String className, Map<String, ?> properties)\n    {\n        gotoPage(reference, \"objectadd\", toQueryParameters(className, null, properties));\n    }\n\n    public void addObject(String space, String page, String className, Map<String, ?> properties)\n    {\n        gotoPage(space, page, \"objectadd\", toQueryParameters(className, null, properties));\n    }\n\n    public void deleteObject(String space, String page, String className, int objectNumber) throws Exception\n    {\n        TestUtils.assertStatusCodes(\n            rest().executeDelete(ObjectResource.class, getCurrentWiki(), space, page, className, objectNumber), true,\n            STATUS_NO_CONTENT_NOT_FOUND);\n    }\n\n    public void updateObject(String space, String page, String className, int objectNumber, Map<String, ?> properties)\n    {\n        gotoPage(space, page, \"save\", toQueryParameters(className, objectNumber, properties));\n    }\n\n    public void updateObject(String space, String page, String className, int objectNumber, Object... properties)\n    {\n        updateObject(Collections.singletonList(space), page, className, objectNumber, properties);\n    }\n\n    /**\n     * @since 11.5RC1\n     * @since 11.3.1\n     */\n    public void updateObject(EntityReference entityReference, String className, int objectNumber,\n        Object... properties)\n    {\n        // TODO: would be even quicker using REST\n        Map<String, Object> queryParameters =\n            (Map<String, Object>) toQueryParameters(className, objectNumber, properties);\n\n        // Append the updateOrCreate objectPolicy since we always want this in our tests.\n        queryParameters.put(\"objectPolicy\", \"updateOrCreate\");\n\n        gotoPage(entityReference, \"save\", queryParameters);\n    }\n\n    /**\n     * @since 8.3RC1\n     */\n    public void updateObject(List<String> spaces, String page, String className, int objectNumber, Object... properties)\n    {\n        // TODO: would be even quicker using REST\n        Map<String, Object> queryParameters =\n            (Map<String, Object>) toQueryParameters(className, objectNumber, properties);\n\n        // Append the updateOrCreate objectPolicy since we always want this in our tests.\n        queryParameters.put(\"objectPolicy\", \"updateOrCreate\");\n\n        gotoPage(spaces, page, \"save\", queryParameters);\n    }\n\n    /**\n     * @since 11.3RC1\n     */\n    public void addClassProperty(EntityReference reference, String propertyName, String propertyType)\n    {\n        gotoPage(reference, \"propadd\", \"propname\", propertyName, \"proptype\", propertyType);\n    }\n\n    /**\n     * @since 11.3RC1\n     */\n    public void updateClassProperty(EntityReference reference, Object... queryParameters)\n    {\n        gotoPage(reference, \"propupdate\", queryParameters);\n    }\n\n    public void addClassProperty(String space, String page, String propertyName, String propertyType)\n    {\n        gotoPage(space, page, \"propadd\", \"propname\", propertyName, \"proptype\", propertyType);\n    }\n\n    /**\n     * @since 3.5M1\n     */\n    public String toQueryString(Object... queryParameters)\n    {\n        return toQueryString(toQueryParameters(queryParameters));\n    }\n\n    /**\n     * @since 3.5M1\n     */\n    public String toQueryString(Map<String, ?> queryParameters)\n    {\n        StringBuilder builder = new StringBuilder();\n\n        if (queryParameters != null) {\n            for (Map.Entry<String, ?> entry : queryParameters.entrySet()) {\n                addQueryStringEntry(builder, entry.getKey(), entry.getValue());\n                builder.append('&');\n            }\n        }\n\n        return builder.toString();\n    }\n\n    /**\n     * @since 3.2M1\n     */\n    public void addQueryStringEntry(StringBuilder builder, String key, Object value)\n    {\n        if (value != null) {\n            if (value instanceof Iterable) {\n                for (Object element : (Iterable<?>) value) {\n                    addQueryStringEntry(builder, key, element.toString());\n                    builder.append('&');\n                }\n            } else {\n                addQueryStringEntry(builder, key, value.toString());\n            }\n        } else {\n            addQueryStringEntry(builder, key, (String) null);\n        }\n    }\n\n    /**\n     * @since 3.2M1\n     */\n    public void addQueryStringEntry(StringBuilder builder, String key, String value)\n    {\n        builder.append(escapeURL(key));\n        if (value != null) {\n            builder.append('=');\n            builder.append(escapeURL(value));\n        }\n    }\n\n    /**\n     * @since 3.5M1\n     */\n    public Map<String, ?> toQueryParameters(Object... properties)\n    {\n        return toQueryParameters(null, null, properties);\n    }\n\n    public Map<String, ?> toQueryParameters(String className, Integer objectNumber, Object... properties)\n    {\n        Map<String, Object> queryParameters = new HashMap<String, Object>();\n\n        queryParameters.put(\"classname\", className);\n\n        for (int i = 0; i < properties.length; i += 2) {\n            int nextIndex = i + 1;\n            queryParameters.put(toQueryParameterKey(className, objectNumber, (String) properties[i]),\n                nextIndex < properties.length ? properties[nextIndex] : null);\n        }\n\n        return queryParameters;\n    }\n\n    public Map<String, ?> toQueryParameters(String className, Integer objectNumber, Map<String, ?> properties)\n    {\n        Map<String, Object> queryParameters = new HashMap<String, Object>();\n\n        if (className != null) {\n            queryParameters.put(\"classname\", className);\n        }\n\n        for (Map.Entry<String, ?> entry : properties.entrySet()) {\n            queryParameters.put(toQueryParameterKey(className, objectNumber, entry.getKey()), entry.getValue());\n        }\n\n        return queryParameters;\n    }\n\n    public String toQueryParameterKey(String className, Integer objectNumber, String key)\n    {\n        if (className == null) {\n            return key;\n        } else {\n            StringBuilder keyBuilder = new StringBuilder(className);\n\n            keyBuilder.append('_');\n\n            if (objectNumber != null) {\n                keyBuilder.append(objectNumber);\n                keyBuilder.append('_');\n            }\n\n            keyBuilder.append(key);\n\n            return keyBuilder.toString();\n        }\n    }\n\n    public ObjectEditPage editObjects(String space, String page)\n    {\n        gotoPage(space, page, \"edit\", \"editor=object\");\n        return new ObjectEditPage();\n    }\n\n    public ClassEditPage editClass(String space, String page)\n    {\n        gotoPage(space, page, \"edit\", \"editor=class\");\n        return new ClassEditPage();\n    }\n\n    /**\n     * Goes to a page in edit class mode.\n     *\n     * @param reference a document reference\n     * @return the {@link ClassEditPage} Page Object for the page\n     * @since 14.0RC1\n     */\n    public ClassEditPage editClass(DocumentReference reference)\n    {\n        gotoPage(reference, \"edit\", \"editor=class\");\n        return new ClassEditPage();\n    }\n\n    public String getVersion() throws Exception\n    {\n        Xwiki xwiki = rest().getResource(\"\", null);\n\n        return xwiki.getVersion();\n    }\n\n    public String getMavenVersion() throws Exception\n    {\n        String version = getVersion();\n\n        int index = version.indexOf('-');\n        if (index > 0) {\n            version = version.substring(0, index) + \"-SNAPSHOT\";\n        }\n\n        return version;\n    }\n\n    public void attachFile(String space, String page, String name, File file, boolean failIfExists) throws Exception\n    {\n        InputStream is = new FileInputStream(file);\n        try {\n            attachFile(space, page, name, is, failIfExists);\n        } finally {\n            is.close();\n        }\n    }\n\n    /**\n     * @since 5.1M2\n     */\n    public void attachFile(String space, String page, String name, InputStream is, boolean failIfExists,\n        UsernamePasswordCredentials credentials) throws Exception\n    {\n        attachFile(Collections.singletonList(space), page, name, is, failIfExists, credentials);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void attachFile(List<String> spaces, String page, String name, InputStream is, boolean failIfExists,\n        UsernamePasswordCredentials credentials) throws Exception\n    {\n        UsernamePasswordCredentials currentCredentials = getDefaultCredentials();\n\n        try {\n            if (credentials != null) {\n                setDefaultCredentials(credentials);\n            }\n            attachFile(spaces, page, name, is, failIfExists);\n        } finally {\n            setDefaultCredentials(currentCredentials);\n        }\n    }\n\n    public void attachFile(String space, String page, String name, InputStream is, boolean failIfExists)\n        throws Exception\n    {\n        attachFile(Collections.singletonList(space), page, name, is, failIfExists);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void attachFile(List<String> spaces, String page, String name, InputStream is, boolean failIfExists)\n        throws Exception\n    {\n        AttachmentReference reference =\n            new AttachmentReference(name, new DocumentReference(getCurrentWiki(), spaces, page));\n\n        attachFile(reference, is, failIfExists);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public void attachFile(EntityReference pageReference, String name, InputStream is, boolean failIfExists)\n        throws Exception\n    {\n        EntityReference reference = new EntityReference(name, EntityType.ATTACHMENT, pageReference);\n\n        attachFile(reference, is, failIfExists);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public void attachFile(EntityReference reference, Object is, boolean failIfExists) throws Exception\n    {\n        rest().attachFile(reference, is, failIfExists);\n    }\n\n    /**\n     * @since 12.2\n     */\n    public void attachFile(EntityReference pageReference, String name, InputStream is, boolean failIfExists,\n        UsernamePasswordCredentials credentials) throws Exception\n    {\n        UsernamePasswordCredentials currentCredentials = getDefaultCredentials();\n        EntityReference reference = new EntityReference(name, EntityType.ATTACHMENT, pageReference);\n\n        try {\n            if (credentials != null) {\n                setDefaultCredentials(credentials);\n            }\n            attachFile(reference, is, failIfExists);\n        } finally {\n            if (credentials != null) {\n                setDefaultCredentials(currentCredentials);\n            }\n        }\n    }\n\n    public void deleteAttachement(EntityReference pageReference, String filename) throws Exception\n    {\n        EntityReference reference = new EntityReference(filename, EntityType.ATTACHMENT, pageReference);\n        deleteAttachement(reference);\n    }\n\n    public void deleteAttachement(EntityReference reference) throws Exception\n    {\n        rest().deleteAttachement(reference);\n    }\n\n    // FIXME: improve that with a REST API to directly import a XAR\n    public void importXar(File file) throws Exception\n    {\n        // attach file\n        attachFile(\"XWiki\", \"Import\", file.getName(), file, false);\n\n        // import file\n        executeGet(\n            getBaseBinURL() + \"import/XWiki/Import?historyStrategy=add&importAsBackup=true&ajax&action=import&name=\"\n                + escapeURL(file.getName()),\n            Status.OK.getStatusCode());\n    }\n\n    /**\n     * Delete the latest version from the history of a page, using the {@code /deleteversions/} action.\n     *\n     * @param space the space name of the page\n     * @param page the name of the page\n     * @since 7.0M2\n     */\n    public void deleteLatestVersion(String space, String page)\n    {\n        deleteVersion(space, page, \"latest\");\n    }\n\n    /**\n     * Delete a specific version from the history of a page, using the {@code /deleteversions/} action.\n     *\n     * @param space the space name of the page\n     * @param page the name of the page\n     * @param version the version to delete\n     * @since 7.0M2\n     */\n    public void deleteVersion(String space, String page, String version)\n    {\n        deleteVersions(space, page, version, version);\n    }\n\n    /**\n     * Delete an interval of versions from the history of a page, using the {@code /deleteversions/} action.\n     *\n     * @param space the space name of the page\n     * @param page the name of the page\n     * @param v1 the starting version to delete\n     * @param v2 the ending version to delete\n     * @since 7.0M2\n     */\n    public void deleteVersions(String space, String page, String v1, String v2)\n    {\n        gotoPage(space, page, \"deleteversions\", \"rev1\", v1, \"rev2\", v2, \"confirm\", \"1\");\n    }\n\n    /**\n     * Roll back a page to the previous version, using the {@code /rollback/} action.\n     *\n     * @param space the space name of the page\n     * @param page the name of the page\n     * @since 7.0M2\n     */\n    public void rollbackToPreviousVersion(String space, String page)\n    {\n        rollBackTo(space, page, \"previous\");\n    }\n\n    /**\n     * Roll back a page to the specified version, using the {@code /rollback/} action.\n     *\n     * @param space the space name of the page\n     * @param page the name of the page\n     * @param version the version to rollback to\n     * @since 7.0M2\n     */\n    public void rollBackTo(String space, String page, String version)\n    {\n        gotoPage(space, page, \"rollback\", \"rev\", version, \"confirm\", \"1\");\n    }\n\n    /**\n     * Set the hierarchy mode used in the wiki\n     *\n     * @param mode the mode to use (\"reference\" or \"parentchild\")\n     * @since 7.2M2\n     */\n    public void setHierarchyMode(String mode)\n    {\n        setPropertyInXWikiPreferences(\"core.hierarchyMode\", \"String\", mode);\n    }\n\n    /**\n     * Add and set a property into XWiki.XWikiPreferences. Create XWiki.XWikiPreferences if it does not exist.\n     *\n     * @param propertyName name of the property to set\n     * @param propertyType the type of the property to add\n     * @param value value to set to the property\n     * @since 7.2M2\n     */\n    public void setPropertyInXWikiPreferences(String propertyName, String propertyType, Object value)\n    {\n        addClassProperty(\"XWiki\", \"XWikiPreferences\", propertyName, propertyType);\n        gotoPage(\"XWiki\", \"XWikiPreferences\", \"edit\", \"editor\", \"object\");\n        ObjectEditPage objectEditPage = new ObjectEditPage();\n        if (objectEditPage.hasObject(\"XWiki.XWikiPreferences\")) {\n            updateObject(\"XWiki\", \"XWikiPreferences\", \"XWiki.XWikiPreferences\", 0, propertyName, value);\n        } else {\n            addObject(\"XWiki\", \"XWikiPreferences\", \"XWiki.XWikiPreferences\", propertyName, value);\n        }\n    }\n\n    /**\n     * Set global xwiki configuration options (as if the xwiki.cfg file had been modified). This is useful for testing\n     * configuration options.\n     *\n     * @param configuration the configuration in {@link Properties} format. For example \"param1=value2\\nparam2=value2\"\n     * @throws IOException if an error occurs while parsing the configuration\n     */\n    public void setPropertyInXWikiCfg(String configuration) throws IOException\n    {\n        Properties properties = new Properties();\n        properties.load(new ByteArrayInputStream(configuration.getBytes()));\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(\"{{velocity}}\\n\"\n                + \"#set($config = $!services.component.getInstance(\\\"org.xwiki.configuration.\"\n                + \"ConfigurationSource\\\", \\\"xwikicfg\\\"))\\n\"\n                + \"#set($props = $config.getProperties())\\n\");\n\n            // Since we don't have access to the XWiki object from Selenium tests and since we don't want to restart XWiki\n        // with a different xwiki.cfg file for each test that requires a configuration change, we use the following\n        // trick: We create a document and we access the XWiki object with a Velocity script inside that document.\n        for (Map.Entry<Object, Object> param : properties.entrySet()) {\n            sb.append(\"#set($discard = $props.put('\").append(param.getKey()).append(\"', '\")\n                .append(param.getValue()).append(\"'))\\n\");\n        }\n        sb.append(\"#set($discard = $config.set($props))\\n\"\n            + \"{{/velocity}}\");\n        createPage(\"Test\", \"XWikiConfigurationPageForTest\", sb.toString(), \"Test page to change xwiki.cfg\");\n    }\n\n    /**\n     * Sets the value of an existing property of XWiki.XWikiPreferences.\n     *\n     * @param propertyName name of the property to set\n     * @param value value to set to the property\n     * @return the previous value, if the property was set, {@code null} otherwise\n     * @since 9.7RC1\n     */\n    public String setWikiPreference(String propertyName, String value) throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(getCurrentWiki(), \"XWiki\", \"XWikiPreferences\");\n        ObjectReference objectReference = new ObjectReference(\"XWiki.XWikiPreferences[0]\", documentReference);\n\n        Property property = RestTestUtils.property(propertyName, value);\n\n        org.xwiki.rest.model.jaxb.Object preferenceObject = rest().get(objectReference, false);\n        String previousValue = null;\n\n        if (preferenceObject == null) {\n            // The object does not exist, create it\n\n            preferenceObject = RestTestUtils.object(\"XWiki.XWikiPreferences\");\n            preferenceObject.withProperties(property);\n\n            TestUtils.assertStatusCodes(\n                rest().executePost(ObjectsResource.class, preferenceObject, rest().toElements(documentReference)), true,\n                STATUS_CREATED);\n        } else {\n            // The object exist just set the property (faster than updating the whole object)\n            ObjectPropertyReference propertyReference = new ObjectPropertyReference(propertyName, objectReference);\n\n            TestUtils.assertStatusCodes(\n                rest().executePut(ObjectPropertyResource.class, property, rest().toElements(propertyReference)), true,\n                STATUS_ACCEPTED);\n\n            Property unsetProperty = RestTestUtils.property(propertyName, null);\n            previousValue =\n                preferenceObject.getProperties().stream().filter(prop -> Objects.equals(propertyName, prop.getName()))\n                    .findFirst().orElse(unsetProperty).getValue();\n        }\n\n        return previousValue;\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public static void assertStatuses(int actualCode, int... expectedCodes)\n    {\n        if (!ArrayUtils.contains(expectedCodes, actualCode)) {\n            fail(String.format(\"Unexpected code [%s], was expecting one of [%s]\",\n                actualCode, Arrays.toString(expectedCodes)));\n        }\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public static <M extends HttpMethod> M assertStatusCodes(M method, boolean release, int... expectedCodes)\n        throws Exception\n    {\n        if (expectedCodes.length > 0) {\n            int actualCode = method.getStatusCode();\n\n            if (!ArrayUtils.contains(expectedCodes, actualCode)) {\n                if (actualCode == Status.INTERNAL_SERVER_ERROR.getStatusCode()) {\n                    String message;\n                    try {\n                        message = method.getResponseBodyAsString();\n                    } catch (IOException e) {\n                        message = \"\";\n                    }\n\n                    fail(String.format(\"Unexpected internal server error with message [%s] for [%s]\",\n                        message, method.getURI()));\n                } else {\n                    fail(String.format(\"Unexpected code [%s], was expecting one of [%s] for [%s]\",\n                        actualCode, Arrays.toString(expectedCodes), method.getURI()));\n                }\n            }\n        }\n\n        if (release) {\n            method.releaseConnection();\n        }\n\n        return method;\n    }\n\n    // HTTP\n\n    /**\n     * Encodes a given string so that it may be used as a URL component. Compatible with javascript decodeURIComponent,\n     * though more strict than encodeURIComponent: all characters except [a-zA-Z0-9], '.', '-', '*', '_' are encoded.\n     * Uses the same algorithm than the one used to generate URLs as otherwise tests won't find the proper matches...\n     * See XWikiServletURLFactory#encodeWithinPath() and #encodeWithinQuery().\n     *\n     * @param url the url to encode\n     */\n    public String escapeURL(String url)\n    {\n        String encodedURL;\n        try {\n            encodedURL = URLEncoder.encode(url, \"UTF-8\");\n        } catch (Exception e) {\n            // Should not happen (UTF-8 is always available)\n            throw new RuntimeException(\"Missing charset [UTF-8]\", e);\n        }\n\n        // The previous call will convert \" \" into \"+\" (and \"+\" into \"%2B\") so we need to convert \"+\" into \"%20\"\n        // It's ok since %20 is allowed in both the URL path and the query string (and anchor).\n        encodedURL = encodedURL.replaceAll(\"\\\\+\", \"%20\");\n\n        return encodedURL;\n    }\n\n    /**\n     * Usage example:\n     * \n     * <pre>\n     * {@code\n     * By.xpath(\"//a[. = \" + escapeXPath(value) + \"]\")\n     * }\n     * </pre>\n     * \n     * @param value the value to escape\n     * @return the escaped value\n     */\n    public String escapeXPath(String value)\n    {\n        return \"concat('\" + value.replace(\"'\", \"', \\\"'\\\", '\") + \"', '')\";\n    }\n\n    public InputStream getInputStream(String path, Map<String, ?> queryParams) throws Exception\n    {\n        return getInputStream(getBaseURL(), path, queryParams);\n    }\n\n    public String getString(String path, Map<String, ?> queryParams) throws Exception\n    {\n        return getString(getBaseURL(), path, queryParams);\n    }\n\n    /**\n     * Extended version to work in a docker context.\n     *\n     * @param baseURL the base url\n     * @param path an additional path added after the base url\n     * @param queryParams additional query parameter added to the computed url\n     * @return the context of the computed url\n     * @throws Exception in case of error when executing the request\n     */\n    public String getString(String baseURL, String path, Map<String, ?> queryParams) throws Exception\n    {\n        try (InputStream inputStream = getInputStream(baseURL, path, queryParams)) {\n            return IOUtils.toString(inputStream);\n        }\n    }\n\n    public InputStream getInputStream(String prefix, String path, Map<String, ?> queryParams, Object... elements)\n        throws Exception\n    {\n        String cleanPrefix = prefix.endsWith(\"/\") ? prefix.substring(0, prefix.length() - 1) : prefix;\n        if (path.startsWith(cleanPrefix)) {\n            cleanPrefix = \"\";\n        }\n\n        UriBuilder builder = UriBuilder.fromUri(cleanPrefix).path(path.startsWith(\"/\") ? path.substring(1) : path);\n\n        if (queryParams != null) {\n            for (Map.Entry<String, ?> entry : queryParams.entrySet()) {\n                if (entry.getValue() instanceof Object[]) {\n                    builder.queryParam(entry.getKey(), (Object[]) entry.getValue());\n                } else {\n                    builder.queryParam(entry.getKey(), entry.getValue());\n                }\n            }\n        }\n\n        String url = builder.build(elements).toString();\n\n        return executeGet(url, Status.OK.getStatusCode()).getResponseBodyAsStream();\n    }\n\n    protected GetMethod executeGet(String uri) throws Exception\n    {\n        GetMethod getMethod = new GetMethod(uri);\n\n        this.httpClient.executeMethod(getMethod);\n\n        return getMethod;\n    }\n\n    protected GetMethod executeGet(String uri, int... expectedCodes) throws Exception\n    {\n        return executeGet(uri, false, expectedCodes);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    protected GetMethod executeGet(String uri, boolean release, int... expectedCodes) throws Exception\n    {\n        return assertStatusCodes(executeGet(uri), release, expectedCodes);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    protected PostMethod executePost(String uri, InputStream content, String mediaType) throws Exception\n    {\n        PostMethod postMethod = new PostMethod(uri);\n        RequestEntity entity = new InputStreamRequestEntity(content, mediaType);\n        postMethod.setRequestEntity(entity);\n\n        this.httpClient.executeMethod(postMethod);\n\n        return postMethod;\n    }\n\n    protected PostMethod executePost(String uri, InputStream content, String mediaType, int... expectedCodes)\n        throws Exception\n    {\n        return executePost(uri, content, mediaType, true, expectedCodes);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    protected PostMethod executePost(String uri, InputStream content, String mediaType, boolean release,\n        int... expectedCodes) throws Exception\n    {\n        return assertStatusCodes(executePost(uri, content, mediaType), false, expectedCodes);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    protected DeleteMethod executeDelete(String uri) throws Exception\n    {\n        DeleteMethod postMethod = new DeleteMethod(uri);\n\n        this.httpClient.executeMethod(postMethod);\n\n        return postMethod;\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    protected void executeDelete(String uri, int... expectedCodes) throws Exception\n    {\n        assertStatusCodes(executeDelete(uri), true, expectedCodes);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    protected PutMethod executePut(String uri, InputStream content, String mediaType) throws Exception\n    {\n        PutMethod putMethod = new PutMethod(uri);\n        RequestEntity entity = new InputStreamRequestEntity(content, mediaType);\n        putMethod.setRequestEntity(entity);\n\n        this.httpClient.executeMethod(putMethod);\n\n        return putMethod;\n    }\n\n    protected void executePut(String uri, InputStream content, String mediaType, int... expectedCodes) throws Exception\n    {\n        executePut(uri, content, mediaType, true, expectedCodes);\n    }\n\n    protected PutMethod executePut(String uri, InputStream content, String mediaType, boolean release,\n        int... expectedCodes) throws Exception\n    {\n        return assertStatusCodes(executePut(uri, content, mediaType), release, expectedCodes);\n    }\n\n    // REST\n\n    public RestTestUtils rest()\n    {\n        return this.rest;\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    // TODO: Refactor TestUtils to move RestTestUtils tools to xwiki-platform-test-integration\n    public static class RestTestUtils\n    {\n        public static final Boolean ELEMENTS_ENCODED = new Boolean(true);\n\n        public static final Map<EntityType, ResourceAPI> RESOURCES_MAP = new IdentityHashMap<>();\n\n        public static String urlPrefix;\n\n        public static class ResourceAPI\n        {\n            public Class<?> api;\n\n            public Class<?> localeAPI;\n\n            public ResourceAPI(Class<?> api, Class<?> localeAPI)\n            {\n                this.api = api;\n                this.localeAPI = localeAPI;\n            }\n        }\n\n        /**\n         * Used to match number part of the object reference name.\n         */\n        private static final Pattern OBJECT_NAME_PATTERN = Pattern.compile(\"(\\\\\\\\*)\\\\[(\\\\d*)\\\\]$\");\n\n        static {\n            try {\n                // Initialize REST related tools\n                JAXBContext jaxbContext = JAXBContext\n                    .newInstance(\"org.xwiki.rest.model.jaxb:org.xwiki.extension.repository.xwiki.model.jaxb\");\n                marshaller = jaxbContext.createMarshaller();\n                unmarshaller = jaxbContext.createUnmarshaller();\n            } catch (JAXBException e) {\n                throw new RuntimeException(e);\n            }\n\n            RESOURCES_MAP.put(EntityType.DOCUMENT, new ResourceAPI(PageResource.class, PageTranslationResource.class));\n            RESOURCES_MAP.put(EntityType.OBJECT, new ResourceAPI(ObjectResource.class, null));\n            RESOURCES_MAP.put(EntityType.OBJECT_PROPERTY, new ResourceAPI(ObjectPropertyResource.class, null));\n            RESOURCES_MAP.put(EntityType.CLASS_PROPERTY, new ResourceAPI(ClassPropertyResource.class, null));\n        }\n\n        /**\n         * @since 7.3M1\n         */\n        public static org.xwiki.rest.model.jaxb.Object object(String className)\n        {\n            org.xwiki.rest.model.jaxb.Object obj = new org.xwiki.rest.model.jaxb.Object();\n\n            obj.setClassName(className);\n\n            return obj;\n        }\n\n        /**\n         * @since 7.3M1\n         */\n        public static String toPropertyString(Object value)\n        {\n            String stringValue;\n\n            if (value instanceof Iterable) {\n                StringBuilder builder = new StringBuilder();\n                for (Object item : (Iterable) value) {\n                    if (builder.length() > 0) {\n                        builder.append('|');\n                    }\n\n                    builder.append(item);\n                }\n\n                stringValue = builder.toString();\n            } else if (value != null) {\n                stringValue = value.toString();\n            } else {\n                stringValue = null;\n            }\n\n            return stringValue;\n        }\n\n        /**\n         * @since 7.3M1\n         */\n        public static Property property(String name, Object value)\n        {\n            Property property = new Property();\n\n            property.setName(name);\n            property.setValue(toPropertyString(value));\n\n            return property;\n        }\n\n        private TestUtils testUtils;\n\n        public RestTestUtils(TestUtils testUtils)\n        {\n            this.testUtils = testUtils;\n        }\n\n        public String getBaseURL()\n        {\n            String prefix;\n            if (RestTestUtils.urlPrefix != null) {\n                prefix = RestTestUtils.urlPrefix;\n            } else {\n                prefix = this.testUtils.getBaseURL();\n            }\n            if (!prefix.endsWith(\"/\")) {\n                prefix = prefix + \"/\";\n            }\n            return prefix + \"rest\";\n        }\n\n        /**\n         * Used when running in a docker container for example and thus when we need a REST URL pointing to a host\n         * different than the TestUTils baseURL which is used inside the Selenium docker container and is thus\n         * different from a REST URL used outside of any container and that needs to call XWiki running inside a\n         * container... ;)\n         *\n         * @since 10.9\n         */\n        public void setURLPrefix(String newURLPrefix)\n        {\n            RestTestUtils.urlPrefix = newURLPrefix;\n        }\n\n        private String toSpaceElement(Iterable<?> spaces)\n        {\n            StringBuilder builder = new StringBuilder();\n\n            for (Object space : spaces) {\n                if (builder.length() > 0) {\n                    builder.append(\"/spaces/\");\n                }\n\n                if (space instanceof EntityReference) {\n                    builder.append(((EntityReference) space).getName());\n                } else {\n                    builder.append(space.toString());\n                }\n            }\n\n            return builder.toString();\n        }\n\n        private String toSpaceElement(String spaceReference)\n        {\n            return toSpaceElement(\n                relativeReferenceResolver.resolve(spaceReference, EntityType.SPACE).getReversedReferenceChain());\n        }\n\n        protected Object[] toElements(Page page)\n        {\n            List<Object> elements = new ArrayList<>();\n\n            // Add wiki\n            if (page.getWiki() != null) {\n                elements.add(page.getWiki());\n            } else {\n                elements.add(this.testUtils.getCurrentWiki());\n            }\n\n            // Add spaces\n            elements.add(toSpaceElement(page.getSpace()));\n\n            // Add name\n            elements.add(page.getName());\n\n            // Add translation\n            if (StringUtils.isNotEmpty(page.getLanguage())) {\n                elements.add(page.getLanguage());\n            }\n\n            return elements.toArray();\n        }\n\n        public Object[] toElements(org.xwiki.rest.model.jaxb.Object obj, boolean onlyDocument)\n        {\n            List<Object> elements = new ArrayList<>();\n\n            // Add wiki\n            if (obj.getWiki() != null) {\n                elements.add(obj.getWiki());\n            } else {\n                elements.add(this.testUtils.getCurrentWiki());\n            }\n\n            // Add spaces\n            elements.add(toSpaceElement(obj.getSpace()));\n\n            // Add name\n            elements.add(obj.getPageName());\n\n            if (!onlyDocument) {\n                // Add class\n                elements.add(obj.getClassName());\n\n                // Add number\n                elements.add(obj.getNumber());\n            }\n\n            return elements.toArray();\n        }\n\n        public Object[] toElements(EntityReference reference)\n        {\n            if (reference == null) {\n                return ArrayUtils.EMPTY_OBJECT_ARRAY;\n            }\n\n            List<EntityReference> references = reference.getReversedReferenceChain();\n\n            List<Object> elements = new ArrayList<>(references.size() + 2);\n\n            // Indicate that elements are already encoded\n            elements.add(ELEMENTS_ENCODED);\n\n            // Add current wiki if the reference does not contains any\n            if (reference.extractReference(EntityType.WIKI) == null) {\n                elements.add(this.testUtils.escapeURL(this.testUtils.getCurrentWiki()));\n            }\n\n            // Add reference\n            for (EntityReference ref : references) {\n                if (ref.getType() == EntityType.SPACE) {\n                    // The URI builder does not support multiple elements like space reference so we hack it by doing\n                    // the opposite of what is done when reading the URL (generate a value looking like\n                    // \"space1/spaces/space2\")\n                    Object value = elements.get(elements.size() - 1);\n\n                    StringBuilder builder;\n                    if (value instanceof StringBuilder) {\n                        builder = (StringBuilder) value;\n                        builder.append(\"/spaces/\");\n                    } else {\n                        builder = new StringBuilder();\n                        elements.add(builder);\n                    }\n\n                    builder.append(this.testUtils.escapeURL(ref.getName()));\n                } else if (ref.getType() == EntityType.OBJECT) {\n                    // The REST API is no in sync with the ObjectReference structure:\n                    // was is a unique name in ObjectReference is two separated class name and index in REST API\n                    String classReferenceStr;\n                    String objectNumberStr;\n\n                    Matcher matcher = OBJECT_NAME_PATTERN.matcher(ref.getName());\n                    if (matcher.find()) {\n                        if (matcher.group(1).length() % 2 == 0) {\n                            classReferenceStr = ref.getName().substring(0, matcher.end(1));\n                            objectNumberStr = matcher.group(2);\n                        } else {\n                            classReferenceStr = ref.getName();\n                            objectNumberStr = null;\n                        }\n                    } else {\n                        classReferenceStr = ref.getName();\n                        objectNumberStr = null;\n                    }\n\n                    elements.add(classReferenceStr);\n                    elements.add(objectNumberStr);\n                } else {\n                    elements.add(this.testUtils.escapeURL(ref.getName()));\n                }\n            }\n\n            // Add locale\n            Locale locale = getLocale(reference);\n            if (locale != null) {\n                elements.add(locale);\n            }\n\n            return elements.toArray();\n        }\n\n        /**\n         * Add or update.\n         */\n        public void save(Page page, int... expectedCodes) throws Exception\n        {\n            save(page, true, expectedCodes);\n        }\n\n        public EntityEnclosingMethod save(Page page, boolean release, int... expectedCodes) throws Exception\n        {\n            if (expectedCodes.length == 0) {\n                // Allow create or modify by default\n                expectedCodes = STATUS_CREATED_ACCEPTED;\n            }\n\n            Class resourceClass =\n                StringUtils.isEmpty(page.getLanguage()) ? PageResource.class : PageTranslationResource.class;\n\n            return TestUtils.assertStatusCodes(executePut(resourceClass, page, toElements(page)), release,\n                expectedCodes);\n        }\n\n        /**\n         * @since 7.3M1\n         */\n        public Page page(EntityReference reference)\n        {\n            Page page = new Page();\n\n            // Add current wiki if the reference does not contains any\n            EntityReference wikiReference = reference.extractReference(EntityType.WIKI);\n            if (wikiReference == null) {\n                page.setWiki(this.testUtils.getCurrentWiki());\n            } else {\n                page.setWiki(wikiReference.getName());\n            }\n\n            // Add spaces\n            EntityReference spaceReference = reference.extractReference(EntityType.SPACE).removeParent(wikiReference);\n            page.setSpace(referenceSerializer.serialize(spaceReference));\n\n            // Add page\n            EntityReference documentReference = reference.extractReference(EntityType.DOCUMENT);\n            page.setName(documentReference.getName());\n\n            // Add locale\n            if (reference instanceof AbstractLocalizedEntityReference) {\n                Locale locale = getLocale(reference);\n                if (locale != null) {\n                    page.setLanguage(locale.toString());\n                }\n            }\n\n            return page;\n        }\n\n        /**\n         * @since 9.8RC1\n         */\n        public org.xwiki.rest.model.jaxb.Object object(EntityReference parentReference, String className)\n        {\n            return object(parentReference, className, 0);\n        }\n\n        /**\n         * @since 9.8RC1\n         */\n        public org.xwiki.rest.model.jaxb.Object object(EntityReference parentReference, String className, int number)\n        {\n            org.xwiki.rest.model.jaxb.Object obj = new org.xwiki.rest.model.jaxb.Object();\n\n            // Add current wiki if the reference does not contains any\n            EntityReference wikiReference = parentReference.extractReference(EntityType.WIKI);\n            if (wikiReference == null) {\n                obj.setWiki(this.testUtils.getCurrentWiki());\n            } else {\n                obj.setWiki(wikiReference.getName());\n            }\n\n            // Add spaces\n            EntityReference spaceReference =\n                parentReference.extractReference(EntityType.SPACE).removeParent(wikiReference);\n            obj.setSpace(referenceSerializer.serialize(spaceReference));\n\n            // Add page\n            EntityReference documentReference = parentReference.extractReference(EntityType.DOCUMENT);\n            obj.setPageName(documentReference.getName());\n\n            // Add class reference\n            obj.setClassName(className);\n            // Add object number\n            obj.setNumber(number);\n\n            return obj;\n        }\n\n        /**\n         * @since 7.3M1\n         */\n        public void savePage(EntityReference reference) throws Exception\n        {\n            savePage(reference, null, null, null, null);\n        }\n\n        /**\n         * @since 7.3M1\n         */\n        public void savePage(EntityReference reference, String content, String title) throws Exception\n        {\n            savePage(reference, content, null, title, null);\n        }\n\n        /**\n         * @since 7.3M1\n         */\n        public void savePage(EntityReference reference, String content, String syntaxId, String title,\n            String parentFullPageName) throws Exception\n        {\n            Page page = page(reference);\n\n            if (content != null) {\n                page.setContent(content);\n            }\n            if (title != null) {\n                page.setTitle(title);\n            }\n            if (syntaxId != null) {\n                page.setSyntax(syntaxId);\n            }\n            if (parentFullPageName != null) {\n                page.setParent(parentFullPageName);\n            }\n\n            save(page, true);\n        }\n\n        /**\n         * Add a new object.\n         */\n        public void add(org.xwiki.rest.model.jaxb.Object obj) throws Exception\n        {\n            add(obj, true);\n        }\n\n        /**\n         * Add a new object.\n         */\n        public EntityEnclosingMethod add(org.xwiki.rest.model.jaxb.Object obj, boolean release) throws Exception\n        {\n            return TestUtils.assertStatusCodes(executePost(ObjectsResource.class, obj, toElements(obj, true)), release,\n                STATUS_CREATED);\n        }\n\n        /**\n         * Fail if the object does not exist.\n         */\n        public void update(org.xwiki.rest.model.jaxb.Object obj) throws Exception\n        {\n            update(obj, true);\n        }\n\n        /**\n         * Fail if the object does not exist.\n         */\n        public EntityEnclosingMethod update(org.xwiki.rest.model.jaxb.Object obj, boolean release) throws Exception\n        {\n            return TestUtils.assertStatusCodes(executePut(ObjectResource.class, obj, toElements(obj, false)), release,\n                STATUS_CREATED_ACCEPTED);\n        }\n\n        public void delete(EntityReference reference) throws Exception\n        {\n            Class<?> resource = getResourceAPI(reference);\n\n            TestUtils.assertStatusCodes(executeDelete(resource, toElements(reference)), true,\n                STATUS_NO_CONTENT_NOT_FOUND);\n        }\n\n        // TODO: make EntityReference#getParameter() public\n        private Locale getLocale(EntityReference reference)\n        {\n            if (reference instanceof AbstractLocalizedEntityReference) {\n                return ((AbstractLocalizedEntityReference) reference).getLocale();\n            }\n\n            return null;\n        }\n\n        public void deletePage(String space, String page) throws Exception\n        {\n            delete(new LocalDocumentReference(space, page));\n        }\n\n        /**\n         * @since 9.0RC1\n         */\n        public void deletePage(String space, String page, Locale locale) throws Exception\n        {\n            delete(new LocalDocumentReference(space, page, locale));\n        }\n\n        /**\n         * @since 8.0M1\n         */\n        public void attachFile(EntityReference reference, Object is, boolean failIfExists) throws Exception\n        {\n            // make sure the page exist\n            if (!exists(reference.getParent())) {\n                savePage(reference.getParent());\n            }\n\n            if (failIfExists) {\n                assertStatusCodes(executePut(AttachmentResource.class, is, toElements(reference)), true,\n                    STATUS_CREATED);\n            } else {\n                assertStatusCodes(executePut(AttachmentResource.class, is, toElements(reference)), true,\n                    STATUS_CREATED_ACCEPTED);\n            }\n        }\n\n        public void deleteAttachement(EntityReference reference) throws Exception\n        {\n            assertStatusCodes(executeDelete(AttachmentResource.class, toElements(reference)), true, STATUS_NO_CONTENT);\n        }\n\n        public boolean exists(EntityReference reference) throws Exception\n        {\n            GetMethod getMethod = executeGet(reference);\n\n            getMethod.releaseConnection();\n\n            return getMethod.getStatusCode() == Status.OK.getStatusCode();\n        }\n\n        /**\n         * Return object model of the passed reference. Fail if none could be found.\n         * \n         * @since 7.3\n         */\n        public <T> T get(EntityReference reference) throws Exception\n        {\n            return get(reference, true);\n        }\n\n        /**\n         * Return object model of the passed reference or null if none could be found.\n         * \n         * @since 8.0M1\n         */\n        public <T> T get(EntityReference reference, boolean failIfNotFound) throws Exception\n        {\n            Class<?> resource = getResourceAPI(reference);\n\n            return get(resource, reference, failIfNotFound);\n        }\n\n        /**\n         * @since 9.0RC1\n         */\n        public Class<?> getResourceAPI(EntityReference reference) throws Exception\n        {\n            ResourceAPI resource = RESOURCES_MAP.get(reference.getType());\n\n            if (resource == null) {\n                throw new Exception(\"Unsuported type [\" + reference.getType() + \"]\");\n            }\n\n            return getLocale(reference) != null ? resource.localeAPI : resource.api;\n        }\n\n        /**\n         * Return object model of the passed reference with the passed resource URI. Fail if none could be found.\n         * \n         * @since 8.0M1\n         */\n        public <T> T get(Object resourceURI, EntityReference reference) throws Exception\n        {\n            return get(resourceURI, reference, true);\n        }\n\n        /**\n         * Return object model of the passed reference with the passed resource URI or null if none could be found.\n         * \n         * @since 8.0M1\n         */\n        public <T> T get(Object resourceURI, EntityReference reference, boolean failIfNotFound) throws Exception\n        {\n            GetMethod getMethod = assertStatusCodes(executeGet(resourceURI, reference), false,\n                failIfNotFound ? STATUS_OK : STATUS_OK_NOT_FOUND);\n\n            if (getMethod.getStatusCode() == Status.NOT_FOUND.getStatusCode()) {\n                return null;\n            }\n\n            if (reference != null && reference.getType() == EntityType.ATTACHMENT) {\n                return (T) getMethod.getResponseBodyAsStream();\n            } else {\n                try {\n                    try (InputStream stream = getMethod.getResponseBodyAsStream()) {\n                        return toResource(stream);\n                    }\n                } finally {\n                    getMethod.releaseConnection();\n                }\n            }\n        }\n\n        public <T> T get(Object resourceURI, boolean failIfNotFound) throws Exception\n        {\n            return get(resourceURI, null, failIfNotFound);\n        }\n\n        public InputStream getInputStream(String resourceUri, Map<String, ?> queryParams, Object... elements)\n            throws Exception\n        {\n            return this.testUtils.getInputStream(getBaseURL(), resourceUri, queryParams, elements);\n        }\n\n        public InputStream postRESTInputStream(Object resourceUri, Object restObject, Object... elements)\n            throws Exception\n        {\n            return postInputStream(resourceUri, restObject, Collections.<String, Object[]>emptyMap(), elements);\n        }\n\n        public InputStream postInputStream(Object resourceUri, Object restObject, Map<String, Object[]> queryParams,\n            Object... elements) throws Exception\n        {\n            return executePost(resourceUri, restObject, queryParams, elements).getResponseBodyAsStream();\n        }\n\n        public <T> T toResource(InputStream is) throws JAXBException\n        {\n            return (T) unmarshaller.unmarshal(is);\n        }\n\n        protected InputStream toResourceInputStream(Object restObject) throws JAXBException\n        {\n            InputStream resourceStream;\n            if (restObject instanceof InputStream) {\n                resourceStream = (InputStream) restObject;\n            } else if (restObject instanceof byte[]) {\n                resourceStream = new ByteArrayInputStream((byte[]) restObject);\n            } else {\n                ByteArrayOutputStream stream = new ByteArrayOutputStream();\n                marshaller.marshal(restObject, stream);\n                resourceStream = new ByteArrayInputStream(stream.toByteArray());\n            }\n\n            return resourceStream;\n        }\n\n        /**\n         * @since 7.3\n         */\n        public GetMethod executeGet(EntityReference reference) throws Exception\n        {\n            Class<?> resource = getResourceAPI(reference);\n\n            return executeGet(resource, reference);\n        }\n\n        /**\n         * @since 8.0M1\n         */\n        public GetMethod executeGet(Object resourceURI, EntityReference reference) throws Exception\n        {\n            return executeGet(resourceURI, toElements(reference));\n        }\n\n        public GetMethod executeGet(Object resourceUri, Object... elements) throws Exception\n        {\n            return executeGet(resourceUri, Collections.<String, Object[]>emptyMap(), elements);\n        }\n\n        public GetMethod executeGet(Object resourceUri, Map<String, Object[]> queryParams, Object... elements)\n            throws Exception\n        {\n            // Build URI\n            String uri = createUri(resourceUri, queryParams, elements).toString();\n\n            return this.testUtils.executeGet(uri);\n        }\n\n        public PostMethod executePost(Object resourceUri, Object restObject, Object... elements) throws Exception\n        {\n            return executePost(resourceUri, restObject, Collections.<String, Object[]>emptyMap(), elements);\n        }\n\n        public PostMethod executePost(Object resourceUri, Object restObject, Map<String, Object[]> queryParams,\n            Object... elements) throws Exception\n        {\n            // Build URI\n            String uri = createUri(resourceUri, queryParams, elements).toString();\n\n            try (InputStream resourceStream = toResourceInputStream(restObject)) {\n                return this.testUtils.executePost(uri, resourceStream, MediaType.APPLICATION_XML);\n            }\n        }\n\n        public PutMethod executePut(Object resourceUri, Object restObject, Object... elements) throws Exception\n        {\n            return executePut(resourceUri, restObject, Collections.<String, Object[]>emptyMap(), elements);\n        }\n\n        public PutMethod executePut(Object resourceUri, Object restObject, Map<String, Object[]> queryParams,\n            Object... elements) throws Exception\n        {\n            // Build URI\n            String uri = createUri(resourceUri, queryParams, elements).toString();\n\n            try (InputStream resourceStream = toResourceInputStream(restObject)) {\n                return this.testUtils.executePut(uri, resourceStream, MediaType.APPLICATION_XML);\n            }\n        }\n\n        public DeleteMethod executeDelete(Object resourceUri, Object... elements) throws Exception\n        {\n            return executeDelete(resourceUri, Collections.<String, Object[]>emptyMap(), elements);\n        }\n\n        public DeleteMethod executeDelete(Object resourceUri, Map<String, Object[]> queryParams, Object... elements)\n            throws Exception\n        {\n            // Build URI\n            String uri = createUri(resourceUri, queryParams, elements).toString();\n\n            return this.testUtils.executeDelete(uri);\n        }\n\n        public URI createUri(Object resourceUri, Map<String, Object[]> queryParams, Object... elements)\n        {\n            if (resourceUri instanceof URI) {\n                return (URI) resourceUri;\n            }\n\n            // Create URI builder\n            UriBuilder builder = getUriBuilder(resourceUri, queryParams);\n\n            // Build URI\n            URI uri;\n            if (elements.length > 0 && elements[0] == ELEMENTS_ENCODED) {\n                uri = builder.buildFromEncoded(Arrays.copyOfRange(elements, 1, elements.length));\n            } else {\n                uri = builder.build(elements);\n            }\n\n            return uri;\n        }\n\n        public UriBuilder getUriBuilder(Object resourceUri, Map<String, Object[]> queryParams)\n        {\n            // Create URI builder\n            UriBuilder builder;\n            if (resourceUri instanceof Class) {\n                builder = getUriBuilder((Class) resourceUri);\n            } else {\n                String stringResourceUri = (String) resourceUri;\n                builder = UriBuilder.fromUri(getBaseURL().substring(0, getBaseURL().length() - 1))\n                    .path(!stringResourceUri.isEmpty() && stringResourceUri.charAt(0) == '/'\n                        ? stringResourceUri.substring(1) : stringResourceUri);\n            }\n\n            // Add query parameters\n            if (queryParams != null) {\n                for (Map.Entry<String, Object[]> entry : queryParams.entrySet()) {\n                    builder.queryParam(entry.getKey(), entry.getValue());\n                }\n            }\n\n            return builder;\n        }\n\n        protected UriBuilder getUriBuilder(Class<?> resource)\n        {\n            return UriBuilder.fromUri(getBaseURL()).path(resource);\n        }\n\n        public byte[] getBuffer(String resourceUri, Map<String, Object[]> queryParams, Object... elements)\n            throws Exception\n        {\n            InputStream is = getInputStream(resourceUri, queryParams, elements);\n\n            byte[] buffer;\n            try {\n                buffer = IOUtils.toByteArray(is);\n            } finally {\n                is.close();\n            }\n\n            return buffer;\n        }\n\n        public <T> T getResource(String resourceUri, Map<String, Object[]> queryParams, Object... elements)\n            throws Exception\n        {\n            T resource;\n            try (InputStream is = getInputStream(resourceUri, queryParams, elements)) {\n                resource = (T) unmarshaller.unmarshal(is);\n            }\n\n            return resource;\n        }\n\n        public static Property getProperty(String name, org.xwiki.rest.model.jaxb.Object preferencesObject,\n            boolean create)\n        {\n            for (Property property : preferencesObject.getProperties()) {\n                if (property.getName().equals(name)) {\n                    return property;\n                }\n            }\n\n            if (create) {\n                Property property = property(name, null);\n                preferencesObject.getProperties().add(property);\n\n                return property;\n            }\n\n            return null;\n        }\n    }\n\n    /**\n     * Disable Syntax Highlighting.\n     *\n     * @since 9.7RC1\n     */\n    public void disableSyntaxHighlighting() throws Exception\n    {\n        ObjectPropertyReference enabledPropertyReference =\n            new ObjectPropertyReference(\"enabled\", new ObjectReference(\"SyntaxHighlighting.ConfigurationClass[0]\",\n                new DocumentReference(getCurrentWiki(), \"SyntaxHighlighting\", \"Configuration\")));\n\n        Property property = new Property();\n        property.setValue(\"0\");\n\n        TestUtils.assertStatusCodes(\n            rest().executePut(ObjectPropertyResource.class, property, rest().toElements(enabledPropertyReference)),\n            true, STATUS_ACCEPTED);\n    }\n\n    /**\n     * @since 11.5RC1\n     */\n    public void switchTab(String tabHandle)\n    {\n        getDriver().switchTo().window(tabHandle);\n    }\n\n    /**\n     * @since 11.5RC1\n     */\n    public String getCurrentTabHandle()\n    {\n        return getDriver().getWindowHandle();\n    }\n\n    /**\n     * @since 11.5RC1\n     */\n    public String openLinkInTab(By by, String... existingTabHandles)\n    {\n        getDriver().findElement(by).sendKeys(Keys.chord(Keys.CONTROL, Keys.RETURN));\n\n        // It might take a bit of time for the driver to know there's another window.\n        getDriver().waitUntilCondition(input -> input.getWindowHandles().size() == existingTabHandles.length + 1);\n        Set<String> windowHandles = getDriver().getWrappedDriver().getWindowHandles();\n        String newTabHandle = null;\n        List<String> tabHandles = Arrays.asList(existingTabHandles);\n        for (String handle : windowHandles) {\n            if (!tabHandles.contains(handle)) {\n                newTabHandle = handle;\n                break;\n            }\n        }\n        return newTabHandle;\n    }\n\n    /**\n     * @since 11.5\n     * @since 11.6RC1\n     */\n    public void closeTab(String secondTabHandle)\n    {\n        String currentTab = getCurrentTabHandle();\n        switchTab(secondTabHandle);\n        getDriver().close();\n        switchTab(currentTab);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.test.ui.po;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.LocaleUtils;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.JavascriptExecutor;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.support.FindBy;\nimport org.openqa.selenium.support.FindBys;\nimport org.openqa.selenium.support.ui.ExpectedConditions;\nimport org.xwiki.test.ui.po.editor.ClassEditPage;\nimport org.xwiki.test.ui.po.editor.EditPage;\nimport org.xwiki.test.ui.po.editor.ObjectEditPage;\nimport org.xwiki.test.ui.po.editor.RightsEditPage;\nimport org.xwiki.test.ui.po.editor.WYSIWYGEditPage;\nimport org.xwiki.test.ui.po.editor.WikiEditPage;\n\n/**\n * Represents the common actions possible on all Pages.\n * \n * @version $Id$\n * @since 3.2M3\n */\npublic class BasePage extends BaseElement\n{\n    /**\n     * Used for sending keyboard shortcuts to.\n     */\n    @FindBy(id = \"xwikimaincontainer\")\n    private WebElement mainContainerDiv;\n\n    /**\n     * The top floating content menu bar.\n     */\n    @FindBy(id = \"contentmenu\")\n    private WebElement contentMenuBar;\n\n    @FindBy(xpath = \"//div[@id='tmCreate']/a[contains(@role, 'button')]\")\n    private WebElement tmCreate;\n\n    @FindBy(xpath = \"//div[@id='tmMoreActions']/a[contains(@role, 'button')]\")\n    private WebElement moreActionsMenu;\n\n    @FindBy(id = \"tmDrawerActivator\")\n    private WebElement drawerActivator;\n\n    @FindBy(xpath = \"//input[@id='tmWatchDocument']/../span[contains(@class, 'bootstrap-switch-label')]\")\n    private WebElement watchDocumentLink;\n\n    @FindBy(id = \"tmPage\")\n    private WebElement pageMenu;\n\n    @FindBys({@FindBy(id = \"tmRegister\"), @FindBy(tagName = \"a\")})\n    private WebElement registerLink;\n\n    @FindBy(xpath = \"//a[@id='tmLogin']\")\n    private WebElement loginLink;\n\n    @FindBy(xpath = \"//a[@id='tmUser']\")\n    private WebElement userLink;\n\n    @FindBy(xpath = \"//li[contains(@class, 'navbar-avatar')]//img[contains(@class, 'avatar')]\")\n    private WebElement userAvatarImage;\n\n    @FindBy(id = \"document-title\")\n    private WebElement documentTitle;\n\n    @FindBy(xpath = \"//input[@id='tmWatchSpace']/../span[contains(@class, 'bootstrap-switch-label')]\")\n    private WebElement watchSpaceLink;\n\n    @FindBy(xpath = \"//input[@id='tmWatchWiki']/../span[contains(@class, 'bootstrap-switch-label')]\")\n    private WebElement watchWikiLink;\n\n    @FindBy(css = \"#tmMoreActions a[title='Children']\")\n    private WebElement childrenLink;\n\n    @FindBy(id = \"tmNotifications\")\n    private WebElement notificationsMenu;\n\n    /**\n     * Used to scroll the page to the top before accessing the floating menu.\n     */\n    @FindBy(id = \"companylogo\")\n    protected WebElement logo;\n\n    /**\n     * Note: when reusing instances of BasePage, the constructor is not doing the work anymore and the\n     * {@link #waitUntilPageIsReady()} method needs to be executed manually, when needed.\n     * <p>\n     * Note2: Never call the constructor before navigating to the page you need to test first.\n     */\n    public BasePage()\n    {\n        super();\n        waitUntilPageIsReady();\n    }\n\n    public String getPageTitle()\n    {\n        return getDriver().getTitle();\n    }\n\n    // TODO I think this should be in the AbstractTest instead -cjdelisle\n    public String getPageURL()\n    {\n        return getDriver().getCurrentUrl();\n    }\n\n    /**\n     * @param metaName the name of the XWiki document metadata\n     * @return the value of the specified XWiki document metadata for the current XWiki document\n     * @see #getHTMLMetaDataValue(String)\n     */\n    public String getMetaDataValue(String metaName)\n    {\n        return getDriver().findElement(By.xpath(\"/html\")).getAttribute(\"data-xwiki-\" + metaName);\n    }\n\n    /**\n     * @param metaName the name of the HTML meta field\n     * @return the value of the requested HTML meta field with from the current page\n     * @since 7.2RC1\n     */\n    public String getHTMLMetaDataValue(String metaName)\n    {\n        return getDriver().findElement(By.xpath(\"//meta[@name='\" + metaName + \"']\")).getAttribute(\"content\");\n    }\n\n    /**\n     * @return true if we are currently logged in, false otherwise\n     */\n    public boolean isAuthenticated()\n    {\n        return getDriver().hasElementWithoutWaiting(By.id(\"tmUser\"));\n    }\n\n    /**\n     * Determine if the current page is a new document.\n     * \n     * @return true if the document is new, false otherwise\n     */\n    public boolean isNewDocument()\n    {\n        return (Boolean) ((JavascriptExecutor) getDriver()).executeScript(\"return XWiki.docisnew\");\n    }\n\n    /**\n     * Perform a click on a \"edit menu\" sub-menu entry.\n     *\n     * @param id The id of the entry to follow\n     */\n    protected void clickEditSubMenuEntry(String id)\n    {\n        clickSubMenuEntryFromMenu(By.xpath(\"//div[@id='tmEdit']/*[contains(@class, 'dropdown-toggle')]\"), id);\n    }\n\n    /**\n     * Performs a click on the \"edit\" button.\n     */\n    public void edit()\n    {\n        WebElement editMenuButton =\n            getDriver().findElement(By.xpath(\"//div[@id='tmEdit']/a[contains(@role, 'button')]\"));\n        editMenuButton.click();\n    }\n\n    /**\n     * Gets a string representation of the URL for editing the page.\n     */\n    public String getEditURL()\n    {\n        return getDriver().findElement(By.xpath(\"//div[@id='tmEdit']//a\")).getAttribute(\"href\");\n    }\n\n    /**\n     * Performs a click on the \"edit wiki\" entry of the content menu.\n     */\n    public WikiEditPage editWiki()\n    {\n        clickEditSubMenuEntry(\"tmEditWiki\");\n        return new WikiEditPage();\n    }\n\n    /**\n     * Performs a click on the \"edit wysiwyg\" entry of the content menu.\n     */\n    public WYSIWYGEditPage editWYSIWYG()\n    {\n        clickEditSubMenuEntry(\"tmEditWysiwyg\");\n        return new WYSIWYGEditPage();\n    }\n\n    /**\n     * Performs a click on the \"edit inline\" entry of the content menu.\n     */\n    public <T extends InlinePage> T editInline()\n    {\n        clickEditSubMenuEntry(\"tmEditInline\");\n        return createInlinePage();\n    }\n\n    /**\n     * Can be overridden to return extended {@link InlinePage}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected <T extends InlinePage> T createInlinePage()\n    {\n        return (T) new InlinePage();\n    }\n\n    /**\n     * Performs a click on the \"edit acces rights\" entry of the content menu.\n     */\n    public RightsEditPage editRights()\n    {\n        clickEditSubMenuEntry(\"tmEditRights\");\n        return new RightsEditPage();\n    }\n\n    /**\n     * Performs a click on the \"edit objects\" entry of the content menu.\n     */\n    public ObjectEditPage editObjects()\n    {\n        clickEditSubMenuEntry(\"tmEditObject\");\n        return new ObjectEditPage();\n    }\n\n    /**\n     * Performs a click on the \"edit class\" entry of the content menu.\n     */\n    public ClassEditPage editClass()\n    {\n        clickEditSubMenuEntry(\"tmEditClass\");\n        return new ClassEditPage();\n    }\n\n    /**\n     * @since 3.2M3\n     */\n    public void sendKeys(CharSequence... keys)\n    {\n        this.mainContainerDiv.sendKeys(keys);\n    }\n\n    /**\n     * Refresh the page and wait for the javascript to be also loaded.\n     *\n     * @since 14.1\n     */\n    public BasePage reloadPage()\n    {\n        getDriver().navigate().refresh();\n        waitUntilPageIsReady();\n        return this;\n    }\n\n    /**\n     * @since 7.2M3\n     */\n    public void toggleDrawer()\n    {\n        if (isDrawerVisible()) {\n            hideDrawer();\n        } else {\n            showDrawer();\n        }\n    }\n\n    /**\n     * @return true if the drawer used to be hidden\n     * @since 8.4.5\n     * @since 9.0RC1\n     */\n    public boolean showDrawer()\n    {\n        if (!isDrawerVisible()) {\n            // Open the drawer.\n            this.drawerActivator.click();\n            waitForDrawer(true);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @return true if the drawer used to be displayed\n     * @since 8.4.5\n     * @since 9.0RC1\n     */\n    public boolean hideDrawer()\n    {\n        if (isDrawerVisible()) {\n            // Close the drawer by clicking outside.\n            // We don't perform directly a click since it could lead to a\n            // org.openqa.selenium.ElementClickInterceptedException because of a drawer-overlay above it.\n            // The click through action is performed with a move and click, which is what we really want.\n            getDriver().createActions().click(this.mainContainerDiv).perform();\n            waitForDrawer(false);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    private void waitForDrawer(boolean visible)\n    {\n        getDriver().waitUntilCondition(\n            ExpectedConditions.attributeToBe(this.drawerActivator, \"aria-expanded\", String.valueOf(visible)));\n    }\n\n    /**\n     * @since 8.4.5\n     * @since 9.0RC1\n     */\n    public boolean isDrawerVisible()\n    {\n        return \"true\".equals(this.drawerActivator.getAttribute(\"aria-expanded\"));\n    }\n\n    /**\n     * @since 7.2M3\n     */\n    public void toggleActionMenu()\n    {\n        this.moreActionsMenu.click();\n    }\n\n    /**\n     * @since 7.0RC1\n     */\n    public void clickMoreActionsSubMenuEntry(String id)\n    {\n        clickSubMenuEntryFromMenu(By.xpath(\"//div[@id='tmMoreActions']/a[contains(@role, 'button')]\"), id);\n    }\n\n    /**\n     * @since 7.3M2\n     * @deprecated use {@link #clickMoreActionsSubMenuEntry(String)} instead which has a better name\n     */\n    @Deprecated\n    public void clickAdminActionsSubMenuEntry(String id)\n    {\n        clickMoreActionsSubMenuEntry(id);\n    }\n\n    /**\n     * @since 7.0RC1\n     */\n    private void clickSubMenuEntryFromMenu(By menuBy, String id)\n    {\n        // Open the parent Menu\n        getDriver().findElement(menuBy).click();\n        // Wait for the submenu entry to be visible\n        getDriver().waitUntilElementIsVisible(By.id(id));\n        // Click on the specified entry\n        getDriver().findElement(By.id(id)).click();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public CreatePagePage createPage()\n    {\n        this.tmCreate.click();\n        return new CreatePagePage();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public CopyPage copy()\n    {\n        clickMoreActionsSubMenuEntry(\"tmActionCopy\");\n        return new CopyPage();\n    }\n\n    public RenamePage rename()\n    {\n        clickMoreActionsSubMenuEntry(\"tmActionRename\");\n        return new RenamePage();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public ConfirmationPage delete()\n    {\n        clickMoreActionsSubMenuEntry(\"tmActionDelete\");\n        return new ConfirmationPage();\n    }\n\n    /**\n     * Specific delete action when the delete action is performed on a page.\n     *\n     * @return a specialized confirmation page for page deletion\n     * @since 12.8RC1\n     */\n    public DeletePageConfirmationPage deletePage()\n    {\n        clickMoreActionsSubMenuEntry(\"tmActionDelete\");\n        return new DeletePageConfirmationPage();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public boolean canDelete()\n    {\n        toggleActionMenu();\n        // Don't wait here since test can use this method to verify that there's no Delete right on the current page\n        // and calling hasElement() would incurr the wait timeout.\n        boolean canDelete = getDriver().hasElementWithoutWaiting(By.id(\"tmActionDelete\"));\n        toggleActionMenu();\n        return canDelete;\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public void watchDocument()\n    {\n        toggleNotificationsMenu();\n        this.watchDocumentLink.click();\n        toggleActionMenu();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public boolean hasLoginLink()\n    {\n        // Note that we cannot test if the loginLink field is accessible since we're using an AjaxElementLocatorFactory\n        // and thus it would wait 15 seconds before considering it's not accessible.\n        return !getDriver().findElementsWithoutWaiting(By.id(\"tmLogin\")).isEmpty();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public LoginPage login()\n    {\n        toggleDrawer();\n        this.loginLink.click();\n        return new LoginPage();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public String getCurrentUser()\n    {\n        // We need to show the drawer because #getText() does not allow getting hidden text (but allow finding the\n        // element and its attributes...)\n        boolean hide = showDrawer();\n\n        String user = this.userLink.getText();\n\n        if (hide) {\n            hideDrawer();\n        }\n\n        return user;\n    }\n\n    /**\n     * @since 9.0RC1\n     */\n    public List<Locale> getLocales()\n    {\n        List<WebElement> elements =\n            getDriver().findElementsWithoutWaiting(By.xpath(\"//ul[@id='tmLanguages_menu']/li/a\"));\n        List<Locale> locales = new ArrayList<>(elements.size());\n        for (WebElement element : elements) {\n            String href = element.getAttribute(\"href\");\n            Matcher matcher = Pattern.compile(\".*\\\\?.*language=([^=&]*)\").matcher(href);\n            if (matcher.matches()) {\n                String locale = matcher.group(1);\n                locales.add(LocaleUtils.toLocale(locale));\n            }\n        }\n\n        return locales;\n    }\n\n    /**\n     * @since 9.0RC1\n     */\n    public ViewPage clickLocale(Locale locale)\n    {\n        // Open drawer\n        toggleDrawer();\n\n        // Open Languages\n        WebElement languagesElement = getDriver().findElementWithoutWaiting(By.xpath(\"//a[@id='tmLanguages']\"));\n        languagesElement.click();\n\n        // Wait for the languages submenu to be open\n        getDriver().waitUntilCondition(webDriver -> getDriver().findElementWithoutWaiting(By.id(\"tmLanguages_menu\"))\n            .getAttribute(\"class\").contains(\"collapse in\"));\n\n        // Click passed locale\n        WebElement localeElement = getDriver().findElementWithoutWaiting(\n            By.xpath(\"//ul[@id='tmLanguages_menu']/li/a[contains(@href,'language=\" + locale + \"')]\"));\n        localeElement.click();\n\n        return new ViewPage();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public void logout()\n    {\n        toggleDrawer();\n        getDriver().findElement(By.id(\"tmLogout\")).click();\n        // Update the CSRF token because the context user has changed (it's guest user now). Otherwise, APIs like\n        // TestUtils#createUser*(), which expect the currently cached token to be valid, will fail because they would be\n        // using the token of the previously logged in user.\n        getUtil().recacheSecretToken();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public RegistrationPage register()\n    {\n        toggleDrawer();\n        this.registerLink.click();\n        return new RegistrationPage();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public String getDocumentTitle()\n    {\n        return this.documentTitle.getText();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public void watchSpace()\n    {\n        toggleNotificationsMenu();\n        this.watchSpaceLink.click();\n        toggleNotificationsMenu();\n    }\n\n    /**\n     * @since 6.0M1\n     */\n    public void watchWiki()\n    {\n        toggleNotificationsMenu();\n        this.watchWikiLink.click();\n        toggleNotificationsMenu();\n    }\n\n    /**\n     * Opens the viewer that lists the children of the current page.\n     * \n     * @return the viewer that lists the child pages\n     * @since 7.3RC1\n     */\n    public ChildrenViewer viewChildren()\n    {\n        toggleActionMenu();\n        this.childrenLink.click();\n        return new ChildrenViewer();\n    }\n\n    /**\n     * Says if the notifications menu is present (it is displayed only if it has some content).\n     * \n     * @return either or not the notifications menu is present\n     * @since 7.4M1\n     */\n    public boolean hasNotificationsMenu()\n    {\n        return getDriver().hasElementWithoutWaiting(By.id(\"tmNotifications\"));\n    }\n\n    /**\n     * Open/Close the notifications menu.\n     * \n     * @since 7.4M1\n     */\n    public void toggleNotificationsMenu()\n    {\n        boolean hasMenu = isNotificationsMenuOpen();\n        this.notificationsMenu.click();\n        if (hasMenu) {\n            getDriver().waitUntilElementDisappears(this.notificationsMenu, By.className(\"dropdown-menu\"));\n        } else {\n            getDriver().waitUntilElementIsVisible(this.notificationsMenu, By.className(\"dropdown-menu\"));\n        }\n    }\n\n    /**\n     * @return true if the notifications menu is open\n     * @since 7.4M1\n     */\n    public boolean isNotificationsMenuOpen()\n    {\n        return this.notificationsMenu.findElement(By.className(\"dropdown-menu\")).isDisplayed();\n    }\n\n    /**\n     * @return the text of uncaught errors\n     * @since 8.0M1\n     */\n    public String getErrorContent()\n    {\n        return getDriver()\n            .findElementWithoutWaiting(By.xpath(\"//div[@id = 'mainContentArea']/pre[contains(@class, 'xwikierror')]\"))\n            .getText();\n    }\n\n    /**\n     * @param panelTitle the panel displayed title\n     * @return true if the panel is visible in the left panels or false otherwise\n     * @since 10.6RC1\n     */\n    public boolean hasLeftPanel(String panelTitle)\n    {\n        return getDriver().hasElementWithoutWaiting(\n            By.xpath(\"//div[@id = 'leftPanels']/div/h1[@class = 'xwikipaneltitle' and text() = '\" + panelTitle + \"']\"));\n    }\n\n    public boolean isForbidden()\n    {\n        List<WebElement> messages = getDriver().findElementsWithoutWaiting(By.className(\"xwikimessage\"));\n        for (WebElement message : messages) {\n            if (message.getText().contains(\"You are not allowed to view this page or perform this action.\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Use the following keyboard shortcut and wait for a new page to load. This should be only used for shortcuts that\n     * indeed loads a new page.\n     * \n     * @param shortcut the keyboard key combination to perform.\n     */\n    private void useShortcutKeyAndLoads(CharSequence... shortcut)\n    {\n        getDriver().addPageNotYetReloadedMarker();\n        getDriver().createActions().sendKeys(shortcut).perform();\n        getDriver().waitUntilPageIsReloaded();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to edit page.\n     * \n     * @return a new {@link EditPage}\n     * @since 11.9RC1\n     */\n    public EditPage useShortcutKeyForEditing()\n    {\n        useShortcutKeyAndLoads(\"e\");\n        return new EditPage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to wiki edit page.\n     * \n     * @return a new {@link WikiEditPage}\n     * @since 11.9RC1\n     */\n    public WikiEditPage useShortcutKeyForWikiEditing()\n    {\n        useShortcutKeyAndLoads(\"k\");\n        return new WikiEditPage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to WYSIWYG edit page.\n     * \n     * @return a new {@link WYSIWYGEditPage}\n     * @since 11.9RC1\n     */\n    public WYSIWYGEditPage useShortcutKeyForWysiwygEditing()\n    {\n        useShortcutKeyAndLoads(\"g\");\n        return new WYSIWYGEditPage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to Inline Form edit page.\n     * \n     * @return a new {@link InlinePage}\n     * @since 11.9RC1\n     */\n    public InlinePage useShortcutKeyForInlineEditing()\n    {\n        useShortcutKeyAndLoads(\"f\");\n        return new InlinePage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to rights edit page.\n     * \n     * @return a new {@link BasePage}: it can be actually either a {@link RightsEditPage} or an AdministrationPage\n     *         depending if the page is terminal or not.\n     * @since 11.9RC1\n     */\n    public BasePage useShortcutKeyForRightsEditing()\n    {\n        useShortcutKeyAndLoads(\"r\");\n        return new BasePage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to object edit page.\n     * \n     * @return a new {@link ObjectEditPage}\n     * @since 11.9RC1\n     */\n    public ObjectEditPage useShortcutKeyForObjectEditing()\n    {\n        useShortcutKeyAndLoads(\"o\");\n        return new ObjectEditPage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to class edit page.\n     * \n     * @return a new {@link ClassEditPage}\n     * @since 11.9RC1\n     */\n    public ClassEditPage useShortcutKeyForClassEditing()\n    {\n        useShortcutKeyAndLoads(\"s\");\n        return new ClassEditPage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to delete page.\n     * \n     * @return a new {@link ConfirmationPage}\n     * @since 11.9RC1\n     */\n    public ConfirmationPage useShortcutKeyForPageDeletion()\n    {\n        useShortcutKeyAndLoads(Keys.DELETE);\n        return new ConfirmationPage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to rename page.\n     * \n     * @return a new {@link RenamePage}\n     * @since 11.9RC1\n     */\n    public RenamePage useShortcutKeyForPageRenaming()\n    {\n        useShortcutKeyAndLoads(Keys.F2);\n        return new RenamePage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to the source view of a page.\n     * \n     * @return a new {@link ViewPage}\n     * @since 11.9RC1\n     */\n    public ViewPage useShortcutKeyForSourceViewer()\n    {\n        useShortcutKeyAndLoads(\"d\");\n        return new ViewPage();\n    }\n\n    /**\n     * @return true if there's a rendering error on the page (i.e. an element with the class\n     *         {@code xwikirenderingerror})\n     * @since 13.3RC1\n     */\n    public boolean hasRenderingError()\n    {\n        return getDriver().hasElementWithoutWaiting(By.className(\"xwikirenderingerror\"));\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.flamingo.test.docker;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.xwiki.flamingo.skin.test.po.AttachmentsPane;\nimport org.xwiki.flamingo.skin.test.po.AttachmentsViewPage;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.rest.model.jaxb.Page;\nimport org.xwiki.test.docker.junit5.TestConfiguration;\nimport org.xwiki.test.docker.junit5.TestReference;\nimport org.xwiki.test.docker.junit5.UITest;\nimport org.xwiki.test.ui.TestUtils;\nimport org.xwiki.test.ui.po.BasePage;\nimport org.xwiki.test.ui.po.ChangesPane;\nimport org.xwiki.test.ui.po.ComparePage;\nimport org.xwiki.test.ui.po.DeletePageOutcomePage;\nimport org.xwiki.test.ui.po.HistoryPane;\nimport org.xwiki.test.ui.po.ViewPage;\nimport org.xwiki.test.ui.po.diff.DocumentDiffSummary;\nimport org.xwiki.test.ui.po.diff.EntityDiff;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Tests related to the attachments.\n *\n * @version $Id$\n * @since 11.3RC1\n */\n@UITest(properties = {\n    // Add the FileUploadPlugin which is needed by the test to upload attachment files\n    \"xwikiCfgPlugins=com.xpn.xwiki.plugin.fileupload.FileUploadPlugin\"\n})\nclass AttachmentIT\n{\n    private static final String FIRST_ATTACHMENT = \"SmallAttachment.txt\";\n\n    private static final String SECOND_ATTACHMENT = \"SmallAttachment2.txt\";\n\n    private static final String IMAGE_ATTACHMENT = \"image.gif\";\n\n    private static final String SMALL_SIZE_ATTACHMENT = \"SmallSizeAttachment.png\";\n\n    private static final String CHOICE_EMPTY = \"(empty)\";\n\n    @BeforeAll\n    public void setup(TestUtils setup)\n    {\n        setup.createUser(\"User2\", \"pass\", \"\");\n        setup.createUserAndLogin(\"User1\", \"pass\");\n    }\n\n    private File getFileToUpload(TestConfiguration testConfiguration, String filename)\n    {\n        return new File(testConfiguration.getBrowser().getTestResourcesPath(), \"AttachmentIT/\" + filename);\n    }\n\n    /**\n     * Ensure that the attachment is properly deleted through the UI.\n     *\n     * @throws Exception in case of errors\n     */\n    @Test\n    @Order(1)\n    void uploadAttachments(TestUtils setup, TestReference testReference, TestConfiguration testConfiguration)\n        throws Exception\n    {\n        String testPageName = setup.serializeReference(testReference).split(\":\")[1];\n        setup.rest().delete(testReference);\n        setup.rest().savePage(testReference, \"\", \"\");\n        Page page = setup.rest().get(testReference);\n        // We make the page hidden as we identified some issues specific to hidden pages (see XWIKI-20093).\n        // If it happens that some issues are specific to non-hidden pages, the test will need to be improved to \n        // cover both cases (which will make the execution time of the test suite larger).\n        page.setHidden(true);\n        setup.rest().save(page);\n        ViewPage viewPage = setup.gotoPage(testReference);\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n\n        // Upload two attachments and check them\n        attachmentsPane.setFileToUpload(getFileToUpload(testConfiguration, FIRST_ATTACHMENT).getAbsolutePath());\n        attachmentsPane.waitForUploadToFinish(FIRST_ATTACHMENT);\n        attachmentsPane.clickHideProgress();\n        attachmentsPane.setFileToUpload(getFileToUpload(testConfiguration, SECOND_ATTACHMENT).getAbsolutePath());\n        attachmentsPane.waitForUploadToFinish(SECOND_ATTACHMENT);\n        attachmentsPane.clickHideProgress();\n        assertEquals(2, attachmentsPane.getNumberOfAttachments());\n        assertTrue(attachmentsPane.attachmentExistsByFileName(FIRST_ATTACHMENT));\n        assertTrue(attachmentsPane.attachmentExistsByFileName(SECOND_ATTACHMENT));\n        assertEquals(\"1.1\", attachmentsPane.getLatestVersionOfAttachment(FIRST_ATTACHMENT));\n        assertEquals(\"1.1\", attachmentsPane.getLatestVersionOfAttachment(SECOND_ATTACHMENT));\n\n        String attachmentURLScheme = String.format(\"%sdownload/%s/%%s?rev=1.1\", setup.getBaseBinURL(),\n            testPageName.replace('.', '/'));\n        assertEquals(String.format(attachmentURLScheme, FIRST_ATTACHMENT),\n            attachmentsPane.getAttachmentLink(FIRST_ATTACHMENT).getAttribute(\"href\"));\n        assertEquals(String.format(attachmentURLScheme, SECOND_ATTACHMENT),\n            attachmentsPane.getAttachmentLink(SECOND_ATTACHMENT).getAttribute(\"href\"));\n\n        attachmentsPane.getAttachmentLink(FIRST_ATTACHMENT).click();\n        assertEquals(\"This is a small attachment.\", setup.getDriver().findElement(By.tagName(\"html\")).getText());\n        setup.getDriver().navigate().back();\n\n        // TODO: remove when https://jira.xwiki.org/browse/XWIKI-15513 is fixed\n        setup.getDriver().navigate().refresh();\n        viewPage.waitForDocExtraPaneActive(\"attachments\");\n\n        attachmentsPane.getAttachmentLink(SECOND_ATTACHMENT).click();\n        assertEquals(\"This is another small attachment.\", setup.getDriver().findElement(By.tagName(\"html\")).getText());\n        setup.getDriver().navigate().back();\n        // TODO: remove when https://jira.xwiki.org/browse/XWIKI-15513 is fixed\n        setup.getDriver().navigate().refresh();\n        viewPage.waitForDocExtraPaneActive(\"attachments\");\n\n        // Upload another version of the first attachment\n        attachmentsPane.setFileToUpload(getFileToUpload(testConfiguration, \"v2/\" + FIRST_ATTACHMENT).getAbsolutePath());\n        attachmentsPane.waitForUploadToFinish(FIRST_ATTACHMENT);\n        attachmentsPane.clickHideProgress();\n        assertTrue(attachmentsPane.attachmentExistsByFileName(FIRST_ATTACHMENT));\n        assertEquals(\"1.2\", attachmentsPane.getLatestVersionOfAttachment(FIRST_ATTACHMENT));\n        String attachmentURL = String.format(\"%sdownload/%s/%s?rev=1.2\", setup.getBaseBinURL(),\n            testPageName.replace('.', '/'), FIRST_ATTACHMENT);\n        assertEquals(attachmentURL, attachmentsPane.getAttachmentLink(FIRST_ATTACHMENT).getAttribute(\"href\"));\n        attachmentsPane.getAttachmentLink(FIRST_ATTACHMENT).click();\n        assertEquals(\"This is a small attachment v2.\", setup.getDriver().findElement(By.tagName(\"html\")).getText());\n        setup.getDriver().navigate().back();\n        // TODO: remove when https://jira.xwiki.org/browse/XWIKI-15513 is fixed\n        setup.getDriver().navigate().refresh();\n        viewPage.waitForDocExtraPaneActive(\"attachments\");\n        attachmentsPane.waitForAttachmentsLiveData();\n\n        attachmentsPane.deleteAttachmentByFileByName(FIRST_ATTACHMENT);\n        assertEquals(1, attachmentsPane.getNumberOfAttachments());\n        assertTrue(attachmentsPane.attachmentExistsByFileName(SECOND_ATTACHMENT));\n\n        // Go back to the page so we can check that the right attachment has really been deleted\n        setup.gotoPage(testReference);\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(1, attachmentsPane.getNumberOfAttachments());\n        assertEquals(String.format(attachmentURLScheme, SECOND_ATTACHMENT),\n            attachmentsPane.getAttachmentLink(SECOND_ATTACHMENT).getAttribute(\"href\"));\n    }\n\n    @Test\n    @Order(2)\n    void attachAndViewGifImage(TestUtils setup, TestReference testReference, TestConfiguration testConfiguration)\n    {\n        // Prepare the page to display the GIF image. We explicitly set the width to a value greater than the actual\n        // image width because we want the code that resizes the image on the server side to be executed (even if the\n        // image is not actually resized).\n        setup.createPage(testReference, String.format(\"[[image:image.gif||width=%s]]\", 142), \"\");\n\n        // Attach the GIF image.\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        attachmentsPane.setFileToUpload(getFileToUpload(testConfiguration, IMAGE_ATTACHMENT).getAbsolutePath());\n        attachmentsPane.waitForUploadToFinish(IMAGE_ATTACHMENT);\n        assertTrue(attachmentsPane.attachmentExistsByFileName(IMAGE_ATTACHMENT));\n    }\n\n    @Test\n    @Order(3)\n    void diffWithDeletedAttachments(TestUtils setup, TestReference testReference,\n        TestConfiguration testConfiguration) throws Exception\n    {\n        // v1.1\n        setup.createPage(testReference, \"\", \"\");\n        // v2.1\n        setup.attachFile(testReference, \"toto.txt\",\n            getClass().getResourceAsStream(\"/AttachmentIT/testDiff/v1.1/toto.txt\"), true);\n        // v3.1\n        setup.deleteAttachement(testReference, \"toto.txt\");\n        // Milliseconds are dropped from attachment date: if we create them too fast\n        // we cannot rely on date to compare them. So make sure to wait at least 1 sec before continue the work.\n        Thread.sleep(1000);\n        // v4.1\n        setup.attachFile(testReference, \"toto.txt\",\n            getClass().getResourceAsStream(\"/AttachmentIT/testDiff/v2.1/toto.txt\"), true);\n        // v5.1\n        setup.attachFile(testReference, \"toto.txt\",\n            getClass().getResourceAsStream(\"/AttachmentIT/testDiff/v2.2/toto.txt\"), false);\n        // v6.1\n        setup.attachFile(testReference, \"toto.txt\",\n            getClass().getResourceAsStream(\"/AttachmentIT/testDiff/v2.3/toto.txt\"), false);\n        // v7.1\n        setup.deleteAttachement(testReference, \"toto.txt\");\n\n        ViewPage viewPage = setup.gotoPage(testReference);\n        HistoryPane historyPane = viewPage.openHistoryDocExtraPane();\n        ComparePage compare = historyPane.compare(\"1.1\", \"2.1\");\n\n        ChangesPane changesPane = compare.getChangesPane();\n        DocumentDiffSummary diffSummary = changesPane.getDiffSummary();\n        assertEquals(Collections.singletonList(\"toto.txt\"),\n            diffSummary.toggleAttachmentsDetails().getAddedAttachments());\n        EntityDiff content = changesPane.getEntityDiff(\"toto.txt\");\n        assertEquals(Arrays.asList(\"@@ -1,0 +1,1 @@\", \"+v1.1\"), content.getDiff(\"Content\"));\n\n        viewPage = setup.gotoPage(testReference);\n        historyPane = viewPage.openHistoryDocExtraPane();\n        compare = historyPane.compare(\"2.1\", \"3.1\");\n        changesPane = compare.getChangesPane();\n        diffSummary = changesPane.getDiffSummary();\n        assertEquals(Collections.singletonList(\"toto.txt\"),\n            diffSummary.toggleAttachmentsDetails().getRemovedAttachments());\n        content = changesPane.getEntityDiff(\"toto.txt\");\n        assertEquals(Arrays.asList(\"@@ -1,1 +1,0 @@\", \"-v1.1\"), content.getDiff(\"Content\"));\n\n        viewPage = setup.gotoPage(testReference);\n        historyPane = viewPage.openHistoryDocExtraPane();\n        compare = historyPane.compare(\"5.1\", \"7.1\");\n        changesPane = compare.getChangesPane();\n        diffSummary = changesPane.getDiffSummary();\n        assertEquals(Collections.singletonList(\"toto.txt\"),\n            diffSummary.toggleAttachmentsDetails().getRemovedAttachments());\n        content = changesPane.getEntityDiff(\"toto.txt\");\n        assertEquals(Arrays.asList(\"@@ -1,1 +1,0 @@\", \"-v2.2\"), content.getDiff(\"Content\"));\n\n        viewPage = setup.gotoPage(testReference);\n        historyPane = viewPage.openHistoryDocExtraPane();\n        compare = historyPane.compare(\"2.1\", \"6.1\");\n        changesPane = compare.getChangesPane();\n        diffSummary = changesPane.getDiffSummary();\n        assertEquals(Collections.singletonList(\"toto.txt\"),\n            diffSummary.toggleAttachmentsDetails().getModifiedAttachments());\n        content = changesPane.getEntityDiff(\"toto.txt\");\n        assertEquals(Arrays.asList(\"@@ -1,1 +1,1 @@\", \"-v<del>1</del>.<del>1</del>\", \"+v<ins>2</ins>.<ins>3</ins>\"),\n            content.getDiff(\"Content\"));\n\n    }\n\n    /**\n     * Ensure that an attachment is properly restored after a rollback of a page that has been restored from deletion.\n     */\n    @Test\n    @Order(4)\n    void rollbackAttachmentFromRestoredPage(TestUtils setup, TestReference testReference) throws Exception\n    {\n        setup.deletePage(testReference);\n\n        // v1.1\n        setup.createPage(testReference, \"\");\n\n        // v2.1\n        setup.attachFile(testReference, \"toto.txt\",\n            getClass().getResourceAsStream(\"/AttachmentIT/testDiff/v1.1/toto.txt\"), true);\n        // v3.1\n        setup.attachFile(testReference, \"toto.txt\",\n            getClass().getResourceAsStream(\"/AttachmentIT/testDiff/v2.1/toto.txt\"), false);\n\n        setup.deletePage(testReference);\n        setup.gotoPage(testReference);\n\n        DeletePageOutcomePage deletePageOutcomePage = new DeletePageOutcomePage();\n        ViewPage viewPage = deletePageOutcomePage.clickRestore();\n\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertTrue(attachmentsPane.attachmentExistsByFileName(\"toto.txt\"));\n        assertEquals(\"1.2\", attachmentsPane.getLatestVersionOfAttachment(\"toto.txt\"));\n        attachmentsPane.getAttachmentLink(\"toto.txt\").click();\n        assertEquals(\"v2.1\", setup.getDriver().findElement(By.tagName(\"html\")).getText());\n\n        viewPage = setup.gotoPage(testReference);\n        HistoryPane historyPane = viewPage.openHistoryDocExtraPane();\n        viewPage = historyPane.rollbackToVersion(\"2.1\");\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertTrue(attachmentsPane.attachmentExistsByFileName(\"toto.txt\"));\n        assertEquals(\"1.3\", attachmentsPane.getLatestVersionOfAttachment(\"toto.txt\"));\n        attachmentsPane.getAttachmentLink(\"toto.txt\").click();\n        assertEquals(\"v1.1\", setup.getDriver().findElement(By.tagName(\"html\")).getText());\n    }\n\n    @Test\n    @Order(5)\n    void filterAttachmentsLivetable(TestUtils setup, TestReference testReference) throws Exception\n    {\n        ViewPage viewPage = setup.createPage(testReference, \"\", \"\");\n\n        // Upload attachments with 2 different users.\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        setup.attachFile(testReference, FIRST_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + FIRST_ATTACHMENT), false);\n        setup.attachFile(testReference, SECOND_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + SECOND_ATTACHMENT), false);\n\n        setup.login(\"User2\", \"pass\");\n        setup.gotoPage(testReference);\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        setup.attachFile(testReference, SMALL_SIZE_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + SMALL_SIZE_ATTACHMENT), false);\n\n        attachmentsPane.filterColumn(2, \"SmallAttachment\");\n        assertEquals(2, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        attachmentsPane.filterColumn(2, \" \");\n\n        attachmentsPane.filterColumn(1, \"Image\");\n        assertEquals(1, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(SMALL_SIZE_ATTACHMENT, attachmentsPane.getAttachmentNameByIndex(1));\n        attachmentsPane.filterColumn(1, \"Text\");\n        assertEquals(2, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        attachmentsPane.filterColumn(1, CHOICE_EMPTY);\n\n        attachmentsPane.filterColumn(3, \"Tiny\");\n        assertEquals(2, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        attachmentsPane.filterColumn(3, \"Small\");\n        assertEquals(1, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(SMALL_SIZE_ATTACHMENT, attachmentsPane.getAttachmentNameByIndex(1));\n        attachmentsPane.filterColumn(3, CHOICE_EMPTY);\n\n        attachmentsPane.filterColumn(5, \"User1\");\n        assertEquals(2, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        attachmentsPane.filterColumn(5, \"User2\");\n        assertEquals(1, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(SMALL_SIZE_ATTACHMENT, attachmentsPane.getAttachmentNameByIndex(1));\n        attachmentsPane.filterColumn(5, \" \");\n\n        String firstAttachUploadDate = attachmentsPane.getDateOfLastUpload(FIRST_ATTACHMENT);\n        List<String> uploadDates =\n            Arrays.asList(firstAttachUploadDate, attachmentsPane.getDateOfLastUpload(SECOND_ATTACHMENT),\n                attachmentsPane.getDateOfLastUpload(SMALL_SIZE_ATTACHMENT));\n        attachmentsPane.filterColumn(4, firstAttachUploadDate);\n        long expected = uploadDates.stream().filter(d -> d.equals(firstAttachUploadDate)).count();\n        assertEquals(expected, attachmentsPane.getNumberOfAttachmentsDisplayed());\n        attachmentsPane.filterColumn(4, \" \");\n    }\n\n    @Test\n    @Order(6)\n    void addAttachmentsMacroToPageContent(TestUtils setup, TestReference testReference) throws Exception\n    {\n        setup.loginAsSuperAdmin();\n\n        DocumentReference attachmentsDocRef =\n            new DocumentReference(\"PageWithAttachments\", testReference.getLastSpaceReference());\n        setup.createPage(attachmentsDocRef, \"\", \"\");\n        setup.attachFile(attachmentsDocRef, FIRST_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + FIRST_ATTACHMENT), false);\n        setup.attachFile(attachmentsDocRef, SECOND_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + SECOND_ATTACHMENT), false);\n        setup.attachFile(attachmentsDocRef, IMAGE_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + IMAGE_ATTACHMENT), false);\n\n        ViewPage viewPage = setup.createPage(testReference, getAttachmentsMacroContent(attachmentsDocRef), \"\");\n\n        setup.attachFile(testReference, FIRST_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + FIRST_ATTACHMENT), false);\n        setup.attachFile(testReference, SECOND_ATTACHMENT,\n            getClass().getResourceAsStream(\"/AttachmentIT/\" + SECOND_ATTACHMENT), false);\n\n        viewPage.reloadPage();\n        AttachmentsPane pageAttachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        AttachmentsPane macroAttachmentsPane = new AttachmentsPane(\"testAttachments\");\n\n        // Check the delete action with multiple attachments liveData displayed.\n        assertEquals(3, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(2, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        macroAttachmentsPane.deleteAttachmentByFileByName(FIRST_ATTACHMENT);\n        assertEquals(2, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(2, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n\n        pageAttachmentsPane.deleteAttachmentByFileByName(FIRST_ATTACHMENT);\n        assertEquals(2, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(1, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n\n        // Check filtering with multiple attachments liveData displayed.\n        macroAttachmentsPane.filterColumn(2, IMAGE_ATTACHMENT);\n        assertEquals(1, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(1, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        macroAttachmentsPane.filterColumn(2, \" \");\n\n        pageAttachmentsPane.filterColumn(2, SECOND_ATTACHMENT);\n        assertEquals(2, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(1, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        pageAttachmentsPane.filterColumn(2, \" \");\n\n        macroAttachmentsPane.filterColumn(1, \"Image\");\n        assertEquals(1, macroAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        assertEquals(1, pageAttachmentsPane.getNumberOfAttachmentsDisplayed());\n        macroAttachmentsPane.filterColumn(1, CHOICE_EMPTY);\n    }\n\n    @Test\n    @Order(7)\n    void addSeveralAttachmentsAtOnce(TestUtils setup, TestReference testReference, TestConfiguration testConfiguration)\n    {\n        setup.loginAsSuperAdmin();\n        setup.createPage(testReference, \"\");\n\n        // Upload 4 files at once.\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        attachmentsPane.setFilesToUpload(List.of(\n            getFileToUpload(testConfiguration, FIRST_ATTACHMENT).getAbsolutePath(),\n            getFileToUpload(testConfiguration, SECOND_ATTACHMENT).getAbsolutePath(),\n            getFileToUpload(testConfiguration, IMAGE_ATTACHMENT).getAbsolutePath(),\n            getFileToUpload(testConfiguration, SMALL_SIZE_ATTACHMENT).getAbsolutePath()\n        ));\n        // Wait for the last file to be uploaded.\n        attachmentsPane.waitForUploadToFinish(SMALL_SIZE_ATTACHMENT);\n\n        assertEquals(4, attachmentsPane.getNumberOfAttachments());\n    }\n\n    /**\n     * Check the display of delete attachment message when it contains special characters.\n     */\n    @Test\n    @Order(8)\n    void deleteAttachmentWithSpecialChar(TestUtils setup, TestReference testReference)\n    {\n        setup.loginAsSuperAdmin();\n        setup.createPage(testReference, \"Empty content\");\n        String attachmentName = \"<img src=x>\";\n        AttachmentReference attachmentReference = new AttachmentReference(attachmentName, testReference);\n        setup.gotoPage(attachmentReference, \"delattachment\");\n        BasePage basePage = new BasePage();\n        assertEquals(String.format(\"Error\\n\"\n                + \"Failed to delete attachment %s\\n\"\n                + \"This attachment does not exist.\", attachmentName),\n                basePage.getXWikiMessageContent());\n    }\n\n    private String getAttachmentsMacroContent(DocumentReference docRef)\n    {\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(\"{{velocity}}\\n\");\n        sb.append(\"#template('attachment_macros.vm')\\n\");\n        sb.append(\"#set($attachmentsDoc = $xwiki.getDocument(\\\"\" + docRef + \"\\\"))\\n\");\n        sb.append(\"#showAttachmentsLiveData($attachmentsDoc 'testAttachments')\\n\");\n        sb.append(\"{{/velocity}}\");\n\n        return sb.toString();\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Vector;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.script.ScriptContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.bridge.event.ActionExecutedEvent;\nimport org.xwiki.bridge.event.ActionExecutingEvent;\nimport org.xwiki.component.descriptor.ComponentDescriptor;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.container.Container;\nimport org.xwiki.container.Request;\nimport org.xwiki.container.servlet.ServletContainerException;\nimport org.xwiki.container.servlet.ServletContainerInitializer;\nimport org.xwiki.container.servlet.ServletRequest;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.csrf.CSRFToken;\nimport org.xwiki.internal.web.DocExistValidator;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.job.internal.DefaultJobProgress;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceProvider;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.EntityReferenceValueProvider;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.validation.EntityNameValidationConfiguration;\nimport org.xwiki.model.validation.EntityNameValidationManager;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.WrappedThreadEventListener;\nimport org.xwiki.rendering.async.AsyncContext;\nimport org.xwiki.rendering.internal.transformation.MutableRenderingContext;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.resource.NotFoundResourceHandlerException;\nimport org.xwiki.resource.ResourceReferenceHandler;\nimport org.xwiki.resource.ResourceReferenceManager;\nimport org.xwiki.resource.ResourceType;\nimport org.xwiki.resource.entity.EntityResourceReference;\nimport org.xwiki.resource.internal.DefaultResourceReferenceHandlerChain;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.security.authorization.AuthorizationException;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.template.TemplateManager;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.velocity.VelocityManager;\nimport org.xwiki.xml.XMLUtils;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.web.LegacyAction;\nimport com.xpn.xwiki.monitor.api.MonitorPlugin;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;\nimport com.xpn.xwiki.redirection.RedirectionFilter;\n\n/**\n * <p>\n * Root class for most XWiki actions. It provides a common framework that allows actions to execute just the specific\n * action code, handling the extra activities, such as preparing the context and retrieving the document corresponding\n * to the URL.\n * </p>\n * <p>\n * It defines two methods, {@link #action(XWikiContext)} and {@link #render(XWikiContext)}, that should be overridden by\n * specific actions. {@link #action(XWikiContext)} should contain the processing part of the action.\n * {@link #render(XWikiContext)} should return the name of a template that should be rendered, or manually write to the\n * {@link XWikiResponse response} stream.\n * </p>\n * <p>\n * Serving a request goes through the following phases:\n * </p>\n * <ul>\n * <li>Wrapping the request and response object in XWiki specific wrappers</li>\n * <li>Prepare the request {@link XWikiContext XWiki-specific context}</li>\n * <li>Initialize/retrieve the XWiki object corresponding to the requested wiki</li>\n * <li>Handle file uploads</li>\n * <li>Prepare the velocity context</li>\n * <li>Prepare the document objects corresponding to the requested URL</li>\n * <li>Send action pre-notifications to listeners</li>\n * <li>Run the overridden {@link #action(XWikiContext)}</li>\n * <li>If {@link #action(XWikiContext)} returns true, run the overridden {@link #render(XWikiContext)}</li>\n * <li>If {@link #render(XWikiContext)} returned a string (template name), render the template with that name</li>\n * <li>Send action post-notifications to listeners</li>\n * </ul>\n * <p>\n * During this process, also handle specific errors, like when a document does not exist, or the user does not have the\n * right to perform the current action.\n * </p>\n */\npublic abstract class XWikiAction implements LegacyAction\n{\n    public static final String ACTION_PROGRESS = \"actionprogress\";\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiAction.class);\n\n    /**\n     * Actions that need to be resolved on the main wiki instead of the current non-existing wiki. This is used to be\n     * able to render the skin even on a wiki that doesn't exist.\n     */\n    private static final List<String> ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST =\n        Arrays.asList(\"skin\", \"ssx\", \"jsx\", \"download\");\n\n    @Inject\n    protected ComponentDescriptor<LegacyAction> componentDescriptor;\n\n    @Inject\n    protected Container container;\n\n    @Inject\n    protected Execution execution;\n\n    @Inject\n    protected ObservationManager observation;\n\n    @Inject\n    @Named(\"context\")\n    private ComponentManager componentManager;\n\n    /**\n     * Indicate if the action allow asynchronous display (among which the XWiki initialization).\n     */\n    protected boolean waitForXWikiInitialization = true;\n\n    @Inject\n    @Named(\"currentmixed\")\n    private DocumentReferenceResolver<String> currentmixedReferenceResolver;\n\n    @Inject\n    private ContextualAuthorizationManager autorization;\n\n    private ContextualLocalizationManager localization;\n\n    private JobProgressManager progress;\n\n    private ScriptContextManager scriptContextManager;\n\n    private EntityNameValidationManager entityNameValidationManager;\n\n    private EntityNameValidationConfiguration entityNameValidationConfiguration;\n\n    private EntityReferenceSerializer<String> localSerializer;\n\n    @Inject\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    @Inject\n    @Named(\"document\")\n    private UserReferenceResolver<DocumentReference> userReferenceResolver;\n\n    /**\n     * @return the class of the XWikiForm in charge of parsing the request\n     * @since 13.0\n     */\n    protected Class<? extends XWikiForm> getFormClass()\n    {\n        return null;\n    }\n\n    protected ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    /**\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        return this.currentmixedReferenceResolver;\n    }\n\n    /**\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected ContextualAuthorizationManager getContextualAuthorizationManager()\n    {\n        return this.autorization;\n    }\n\n    protected String localizePlainOrKey(String key, Object... parameters)\n    {\n        return XMLUtils.escape(StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key));\n    }\n\n    protected JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    protected EntityNameValidationManager getEntityNameValidationManager()\n    {\n        if (this.entityNameValidationManager == null) {\n            this.entityNameValidationManager = Utils.getComponent(EntityNameValidationManager.class);\n        }\n        return this.entityNameValidationManager;\n    }\n\n    protected EntityNameValidationConfiguration getEntityNameValidationConfiguration()\n    {\n        if (this.entityNameValidationConfiguration == null) {\n            this.entityNameValidationConfiguration = Utils.getComponent(EntityNameValidationConfiguration.class);\n        }\n\n        return this.entityNameValidationConfiguration;\n    }\n\n    protected EntityReferenceSerializer<String> getLocalSerializer()\n    {\n        if (this.localSerializer == null) {\n            this.localSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n        return this.localSerializer;\n    }\n\n    /**\n     * @return the current unmodified {@link ScriptContext} instance\n     * @since 8.3M1\n     */\n    protected ScriptContext getCurrentScriptContext()\n    {\n        if (this.scriptContextManager == null) {\n            this.scriptContextManager = Utils.getComponent(ScriptContextManager.class);\n        }\n\n        return this.scriptContextManager.getCurrentScriptContext();\n    }\n\n    @Override\n    public void execute(HttpServletRequest servletRequest, HttpServletResponse servletResponse) throws Exception\n    {\n        XWikiContext context = null;\n\n        try {\n            // Initialize the XWiki Context which is the main object used to pass information across\n            // classes/methods. It's also wrapping the request, response, and all container objects\n            // in general.\n            context = initializeXWikiContext(servletRequest, servletResponse);\n\n            // From this line forward all information can be found in the XWiki Context.\n            execute(context);\n        } finally {\n            if (context != null) {\n                cleanupComponents();\n            }\n        }\n    }\n\n    /**\n     * Ensure that the given entity reference is valid according to the configured name strategy. Always returns true if\n     * the name strategy is not found.\n     *\n     * @param entityReference the entity reference name to validate\n     * @return {@code true} if the entity reference name is valid according to the name strategy.\n     * @since 12.0RC1\n     */\n    protected boolean isEntityReferenceNameValid(EntityReference entityReference)\n    {\n        if (this.getEntityNameValidationManager().getEntityReferenceNameStrategy() != null\n            && this.getEntityNameValidationConfiguration().useValidation()) {\n            if (!this.getEntityNameValidationManager().getEntityReferenceNameStrategy().isValid(entityReference)) {\n                Object[] args = {getLocalSerializer().serialize(entityReference)};\n                XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,\n                    \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,\n                    args);\n                ScriptContext scontext = getCurrentScriptContext();\n                scontext.setAttribute(\"invalidNameReference\", entityReference, ScriptContext.ENGINE_SCOPE);\n                scontext.setAttribute(\"createException\", invalidNameException, ScriptContext.ENGINE_SCOPE);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Write an error response to an ajax request.\n     *\n     * @param httpStatusCode The status code to set on the response.\n     * @param message The message that should be displayed.\n     * @param context the context.\n     */\n    protected void writeAjaxErrorResponse(int httpStatusCode, String message, XWikiContext context)\n    {\n        try {\n            context.getResponse().setContentType(\"text/plain\");\n            context.getResponse().setStatus(httpStatusCode);\n            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());\n            context.getResponse().getWriter().print(message);\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to send error response to AJAX save and continue request.\", e);\n        }\n    }\n\n    public void execute(XWikiContext context) throws Exception\n    {\n        MonitorPlugin monitor = null;\n        FileUploadPlugin fileupload = null;\n        DefaultJobProgress actionProgress = null;\n        String docName = \"\";\n\n        boolean debug = StringUtils.equals(context.getRequest().get(\"debug\"), \"true\");\n\n        String sasync = context.getRequest().get(\"async\");\n\n        try {\n            String action = context.getAction();\n\n            // Start progress\n            if (debug) {\n                actionProgress = new DefaultJobProgress(context.getURL().toExternalForm());\n                this.observation.addListener(new WrappedThreadEventListener(actionProgress));\n\n                // Register the action progress in the context\n                ExecutionContext econtext = this.execution.getContext();\n                if (econtext != null) {\n                    econtext.setProperty(XWikiAction.ACTION_PROGRESS, actionProgress);\n                }\n            }\n\n            getProgress().pushLevelProgress(2, this);\n\n            getProgress().startStep(this, \"Get XWiki instance\");\n\n            // Initialize context.getWiki() with the main wiki\n            XWiki xwiki;\n\n            // Verify that the requested wiki exists\n            try {\n                // Don't show init screen if async is forced to false\n                xwiki = XWiki.getXWiki(this.waitForXWikiInitialization || StringUtils.equals(sasync, \"false\"), context);\n\n                // If XWiki is still initializing display initialization template\n                if (xwiki == null) {\n                    // Display initialization template\n                    renderInit(context);\n\n                    // Initialization template has been displayed, stop here.\n                    return;\n                }\n            } catch (XWikiException e) {\n                // If the wiki asked by the user doesn't exist, then we first attempt to use any existing global\n                // redirects. If there are none, then we display the specific error template.\n                if (e.getCode() == XWikiException.ERROR_XWIKI_DOES_NOT_EXIST) {\n                    xwiki = XWiki.getMainXWiki(context);\n\n                    // Initialize the url factory\n                    XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n                    context.setURLFactory(urlf);\n\n                    // Initialize the velocity context and its bindings so that it may be used in the velocity templates\n                    // that we\n                    // are parsing below.\n                    VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n                    VelocityContext vcontext = velocityManager.getVelocityContext();\n\n                    if (!sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {\n                        // Starting XWiki 5.0M2, 'xwiki.virtual.redirect' was removed. Warn users still using it.\n                        if (!StringUtils.isEmpty(context.getWiki().Param(\"xwiki.virtual.redirect\"))) {\n                            LOGGER.warn(String.format(\"%s %s\", \"'xwiki.virtual.redirect' is no longer supported.\",\n                                \"Please update your configuration and/or see XWIKI-8914 for more details.\"));\n                        }\n\n                        // Display the error template only for actions that are not ignored\n                        if (!ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST.contains(action)) {\n\n                            // Add localization resources to the context\n                            xwiki.prepareResources(context);\n\n                            // Set the main home page in the main space of the main wiki as the current requested entity\n                            // since we cannot set the non existing one as it would generate errors obviously...\n                            EntityReferenceValueProvider valueProvider =\n                                Utils.getComponent(EntityReferenceValueProvider.class);\n                            xwiki.setPhonyDocument(new DocumentReference(valueProvider.getDefaultValue(EntityType.WIKI),\n                                valueProvider.getDefaultValue(EntityType.SPACE),\n                                valueProvider.getDefaultValue(EntityType.DOCUMENT)), context, vcontext);\n\n                            // Parse the error template\n                            Utils.parseTemplate(context.getWiki().Param(\"xwiki.wiki_exception\", \"wikidoesnotexist\"),\n                                context);\n\n                            // Error template was displayed, stop here.\n                            return;\n                        }\n\n                        // At this point, we allow regular execution of the ignored action because even if the wiki\n                        // does not exist, we still need to allow UI resources to be retrieved (from the filesystem\n                        // and the main wiki) or our error template will not be rendered properly.\n\n                        // Proceed with serving the main wiki\n\n                    } else {\n                        // Global redirect was executed, stop here.\n                        return;\n                    }\n                } else {\n                    LOGGER.error(\"Uncaught exception during XWiki initialisation:\", e);\n                    throw e;\n                }\n            }\n\n            // Send global redirection (if any)\n            if (sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {\n                return;\n            }\n\n            XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n            context.setURLFactory(urlf);\n\n            // Handle ability to enter space URLs and convert them to page URLs (Nested Documents)\n            if (redirectSpaceURLs(action, urlf, xwiki, context)) {\n                return;\n            }\n\n            String sajax = context.getRequest().get(\"ajax\");\n            boolean ajax = false;\n            if (sajax != null && !sajax.trim().equals(\"\") && !sajax.equals(\"0\")) {\n                ajax = true;\n            }\n            context.put(\"ajax\", ajax);\n\n            boolean async = false;\n            if (StringUtils.isNotEmpty(sasync)) {\n                async = sasync.equals(\"true\");\n            } else {\n                // By default allow asynchronous rendering for \"human oriented\" actions which are not executing an ajax\n                // request\n                async = !ajax && !this.waitForXWikiInitialization;\n            }\n            Utils.getComponent(AsyncContext.class).setEnabled(async);\n\n            // Any error before this will be treated using a redirection to an error page\n\n            if (monitor != null) {\n                monitor.startTimer(\"request\");\n            }\n\n            getProgress().startStep(this, \"Execute request\");\n\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            VelocityContext vcontext = velocityManager.getVelocityContext();\n\n            getProgress().pushLevelProgress(7, this);\n\n            boolean eventSent = false;\n            try {\n                getProgress().startStep(this, \"Prepare documents and put them in the context\");\n\n                // Prepare documents and put them in the context\n                if (!xwiki.prepareDocuments(context.getRequest(), context, vcontext)) {\n                    return;\n                }\n\n                // Start monitoring timer\n                monitor = (MonitorPlugin) xwiki.getPlugin(\"monitor\", context);\n                if (monitor != null) {\n                    monitor.startRequest(\"\", context.getAction(), context.getURL());\n                    monitor.startTimer(\"multipart\");\n                }\n\n                getProgress().startStep(this, \"Parses multipart\");\n\n                // Parses multipart so that params in multipart are available for all actions\n                fileupload = Utils.handleMultipart(context.getRequest().getHttpServletRequest(), context);\n                if (monitor != null) {\n                    monitor.endTimer(\"multipart\");\n                }\n\n                if (monitor != null) {\n                    monitor.setWikiPage(context.getDoc().getFullName());\n                }\n\n                getProgress().startStep(this, \"Send [\" + context.getAction() + \"] action start event\");\n\n                // For the moment we're sending the XWiki context as the data, but this will be\n                // changed in the future, when the whole platform will be written using components\n                // and there won't be a need for the context.\n                try {\n                    ActionExecutingEvent event = new ActionExecutingEvent(context.getAction());\n                    this.observation.notify(event, context.getDoc(), context);\n                    eventSent = true;\n                    if (event.isCanceled()) {\n                        // Action has been canceled\n                        // TODO: do something special ?\n                        return;\n                    }\n                } catch (Throwable ex) {\n                    LOGGER.error(\"Cannot send action notifications for document [\" + context.getDoc()\n                        + \" using action [\" + context.getAction() + \"]\", ex);\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"prenotify\");\n                }\n\n                // Call the Actions\n\n                getProgress().startStep(this, \"Search and execute entity resource handler\");\n\n                // Call the new Entity Resource Reference Handler.\n                ResourceReferenceHandler entityResourceReferenceHandler = Utils.getComponent(\n                    new DefaultParameterizedType(null, ResourceReferenceHandler.class, ResourceType.class), \"bin\");\n                EntityResourceReference entityResourceReference =\n                    (EntityResourceReference) Utils.getComponent(ResourceReferenceManager.class).getResourceReference();\n\n                // We save the current action set since:\n                // - by default the action is set to \"view\" for Extensions not installed as root and contributing some\n                // new Entity Action (see https://jira.xwiki.org/browse/XWIKI-15182).\n                // - we want to set back the action in case no ResourceReferenceHandler was found to handle the URL\n                // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                String originalAction = context.getAction();\n                try {\n                    // Force the action in the context because of https://jira.xwiki.org/browse/XWIKI-15182.\n                    // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                    context.setAction(entityResourceReference.getAction().getActionName());\n                    entityResourceReferenceHandler.handle(entityResourceReference,\n                        DefaultResourceReferenceHandlerChain.EMPTY);\n                    // Don't let the old actions kick in!\n                    return;\n                } catch (NotFoundResourceHandlerException e) {\n                    // No Entity Resource Action has been found. Don't do anything and let it go through\n                    // so that the old Action system kicks in...\n                    // Put back the action, because of https://jira.xwiki.org/browse/XWIKI-15182\n                    // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                    context.setAction(originalAction);\n                }\n\n                getProgress().startStep(this, \"Execute action render\");\n\n                // Handle the XWiki.RedirectClass object that can be attached to the current document\n                boolean hasRedirect = handleRedirect(context);\n\n                // Then call the old Actions for backward compatibility (and because a lot of them have not been\n                // migrated to new Actions yet).\n                String renderResult = null;\n                XWikiDocument doc = context.getDoc();\n                docName = doc.getFullName();\n                if (!hasRedirect && action(context)) {\n                    renderResult = render(context);\n                }\n\n                if (renderResult != null) {\n                    // check for doc existence\n                    if (shouldReturnDocDoesNotExist(doc, context)) {\n                        String page = Utils.getPage(context.getRequest(), \"docdoesnotexist\");\n\n                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");\n                        Utils.parseTemplate(page, context);\n                    } else {\n                        String page = Utils.getPage(context.getRequest(), renderResult);\n\n                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");\n                        Utils.parseTemplate(page, !page.equals(\"direct\"), context);\n                    }\n                }\n                return;\n            } catch (Throwable e) {\n                if (e instanceof IOException) {\n                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP,\n                        XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION, \"Exception while sending response\", e);\n                }\n\n                if (!(e instanceof XWikiException)) {\n                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_UNKNOWN,\n                        \"Uncaught exception\", e);\n                }\n\n                try {\n                    XWikiException xex = (XWikiException) e;\n                    if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        // Connection aborted from the client side, there's not much we can do on the server side. We\n                        // simply ignore it.\n                        LOGGER.debug(\"Connection aborted\", e);\n                        // We don't write any other message to the response, as the connection is broken, anyway.\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_ACCESS_DENIED) {\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.access_exception\", \"accessdenied\"), context);\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_INACTIVE\n                        || xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {\n                        if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {\n                            context.put(\"cause\", \"disabled\");\n                        }\n                        // In case of user disabled or inactive, the resources are actually forbidden.\n                        context.getResponse().setStatus(HttpServletResponse.SC_FORBIDDEN);\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.user_exception\", \"userinactive\"), context);\n\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_ATTACHMENT_NOT_FOUND) {\n                        context.put(\"message\", \"attachmentdoesnotexist\");\n                        Utils.parseTemplate(\n                            context.getWiki().Param(\"xwiki.attachment_exception\", \"attachmentdoesnotexist\"), context);\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION) {\n                        vcontext.put(\"message\", localizePlainOrKey(\"platform.core.invalidUrl\"));\n                        xwiki.setPhonyDocument(xwiki.getDefaultSpace(context) + \".\" + xwiki.getDefaultPage(context),\n                            context, vcontext);\n                        context.getResponse().setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.invalid_url_exception\", \"error\"), context);\n                        return;\n                    }\n                    // Note: We don't use the vcontext variable computed above since apparently the velocity context\n                    // can have changed in between. Thus we get it again to be sure we're setting the binding in the\n                    // right one.\n                    velocityManager.getVelocityContext().put(\"exp\", e);\n                    if (LOGGER.isWarnEnabled()) {\n                        // Don't log \"Broken Pipe\" exceptions since they're not real errors and we don't want to pollute\n                        // the logs with unnecessary stack traces. It just means the client side has cancelled the\n                        // connection.\n                        if (ExceptionUtils.getRootCauseMessage(e).equals(\"IOException: Broken pipe\")) {\n                            return;\n                        }\n                        LOGGER.warn(\"Uncaught exception: \" + e.getMessage(), e);\n                    }\n                    // If the request is an AJAX request, we don't return a whole HTML page, but just the exception\n                    // inline.\n                    String exceptionTemplate = ajax ? \"exceptioninline\" : \"exception\";\n                    Utils.parseTemplate(Utils.getPage(context.getRequest(), exceptionTemplate), context);\n                    return;\n                } catch (XWikiException ex) {\n                    if (ex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        LOGGER.error(\"Connection aborted\");\n                    }\n                } catch (Exception e2) {\n                    // I hope this never happens\n                    LOGGER.error(\"Uncaught exceptions (inner): \", e);\n                    LOGGER.error(\"Uncaught exceptions (outer): \", e2);\n                }\n                return;\n            } finally {\n                // Let's make sure we have flushed content and closed\n                try {\n                    context.getResponse().getWriter().flush();\n                } catch (Throwable e) {\n                    // This might happen if the connection was closed, for example.\n                    // If we can't flush, then there's nothing more we can send to the client.\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"request\");\n                    monitor.startTimer(\"notify\");\n                }\n\n                if (eventSent) {\n                    // For the moment we're sending the XWiki context as the data, but this will be\n                    // changed in the future, when the whole platform will be written using components\n                    // and there won't be a need for the context.\n                    try {\n                        this.observation.notify(new ActionExecutedEvent(context.getAction()), context.getDoc(), context);\n                    } catch (Throwable ex) {\n                        LOGGER.error(\"Cannot send action notifications for document [\" + docName + \" using action [\"\n                            + context.getAction() + \"]\", ex);\n                    }\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"notify\");\n                }\n\n                getProgress().startStep(this, \"Cleanup database connections\");\n\n                // Make sure we cleanup database connections\n                // There could be cases where we have some\n                xwiki.getStore().cleanUp(context);\n\n                getProgress().popLevelProgress(this);\n            }\n        } finally {\n            // End request\n            if (monitor != null) {\n                monitor.endRequest();\n            }\n\n            // Stop progress\n            if (actionProgress != null) {\n                getProgress().popLevelProgress(this);\n\n                this.observation.removeListener(actionProgress.getName());\n            }\n\n            if (fileupload != null) {\n                fileupload.cleanFileList(context);\n            }\n        }\n    }\n\n    /**\n     * Check if the given document exists or not and if it should return a 404 based on the context. A {@link\n     * DocExistValidator} with an hint matching the current action is used to check if the document exists. When no\n     * {@link DocExistValidator} is found, the response is always {@code false} When a {@link DocExistValidator} is\n     * found, the result is delegated to {@link DocExistValidator#docExist(XWikiDocument, XWikiContext)}.\n     *\n     * @param doc the doc for which to check it exists or not\n     * @param context the current context\n     * @return {@code true} if we should return a 404\n     * @throws ComponentLookupException if an error occurs when instantiating a {@link DocExistValidator}\n     */\n    private boolean shouldReturnDocDoesNotExist(XWikiDocument doc, XWikiContext context) throws ComponentLookupException\n    {\n        boolean result = false;\n        String action = context.getAction();\n        if (this.componentManager.hasComponent(DocExistValidator.class, action)) {\n            result = this.componentManager.<DocExistValidator>getInstance(DocExistValidator.class, action)\n                .docExist(doc, context);\n        }\n        return result;\n    }\n\n    private void renderInit(XWikiContext xcontext) throws Exception\n    {\n        RenderingContext renderingContext = Utils.getComponent(RenderingContext.class);\n        MutableRenderingContext mutableRenderingContext =\n            renderingContext instanceof MutableRenderingContext ? (MutableRenderingContext) renderingContext : null;\n\n        if (mutableRenderingContext != null) {\n            mutableRenderingContext.push(renderingContext.getTransformation(), renderingContext.getXDOM(),\n                renderingContext.getDefaultSyntax(), \"init.vm\", renderingContext.isRestricted(), Syntax.XHTML_1_0);\n        }\n\n        xcontext.getResponse().setStatus(202);\n        xcontext.getResponse().setContentType(\"text/html; charset=UTF-8\");\n\n        try {\n            Utils.getComponent(TemplateManager.class).render(\"init.vm\", xcontext.getResponse().getWriter());\n        } finally {\n            if (mutableRenderingContext != null) {\n                mutableRenderingContext.pop();\n            }\n        }\n\n        xcontext.getResponse().flushBuffer();\n\n        xcontext.setFinished(true);\n    }\n\n    protected XWikiContext initializeXWikiContext(HttpServletRequest servletRequest,\n        HttpServletResponse servletResponse)\n        throws XWikiException, ServletException, InstantiationException, IllegalAccessException\n    {\n        XWikiForm form;\n        if (getFormClass() != null) {\n            form = getFormClass().newInstance();\n        } else {\n            form = null;\n        }\n\n        return initializeXWikiContext(servletRequest, servletResponse, form);\n    }\n\n    /**\n     * @return the name to put in the {@link XWikiContext}, by default the component role hint is used\n     * @since 13.0\n     */\n    protected String getName()\n    {\n        return this.componentDescriptor.getRoleHint();\n    }\n\n    protected XWikiContext initializeXWikiContext(HttpServletRequest servletRequest,\n        HttpServletResponse servletResponse, XWikiForm form) throws XWikiException, ServletException\n    {\n        String action = getName();\n\n        XWikiRequest request = new XWikiServletRequest(servletRequest);\n        XWikiResponse response = new XWikiServletResponse(servletResponse);\n        XWikiContext context = Utils.prepareContext(action, request, response,\n            new XWikiServletContext(servletRequest.getServletContext()));\n\n        if (form != null) {\n            form.reset(request);\n        }\n\n        // Add the form to the context\n        context.setForm(form);\n\n        // Initialize the Container component which is the new way of transporting the Context in the new\n        // component architecture.\n        initializeContainerComponent(context);\n\n        return context;\n    }\n\n    protected void initializeContainerComponent(XWikiContext context) throws ServletException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request,\n        // response and session to components which require them.\n        // In the future this Servlet will be replaced by the XWikiPlexusServlet Servlet.\n        ServletContainerInitializer containerInitializer = Utils.getComponent(ServletContainerInitializer.class);\n\n        try {\n            containerInitializer.initializeRequest(context.getRequest().getHttpServletRequest(), context);\n            containerInitializer.initializeResponse(context.getResponse());\n            containerInitializer.initializeSession(context.getRequest().getHttpServletRequest());\n        } catch (ServletContainerException e) {\n            throw new ServletException(\"Failed to initialize Request/Response or Session\", e);\n        }\n    }\n\n    protected void cleanupComponents()\n    {\n        // We must ensure we clean the ThreadLocal variables located in the Container and Execution\n        // components as otherwise we will have a potential memory leak.\n        container.removeRequest();\n        container.removeResponse();\n        container.removeSession();\n        execution.removeContext();\n    }\n\n    public String getRealPath(String path)\n    {\n        Request request = this.container.getRequest();\n\n        if (request instanceof ServletRequest) {\n            return ((ServletRequest) request).getHttpServletRequest().getServletContext().getRealPath(path);\n        }\n\n        return null;\n    }\n\n    // hook\n    public boolean action(XWikiContext context) throws XWikiException\n    {\n        return true;\n    }\n\n    // hook\n    public String render(XWikiContext context) throws XWikiException\n    {\n        return null;\n    }\n\n    /**\n     * Indicate if the action support redirection. The default value is {@code false}.\n     *\n     * @return {@code true} if the action supports redirections, {@code false} otherwise\n     * @since 14.0RC1\n     */\n    @Unstable\n    protected boolean supportRedirections()\n    {\n        return false;\n    }\n\n    private UserReference getCurrentUserReference(XWikiContext context)\n    {\n        return this.userReferenceResolver.resolve(context.getUserReference());\n    }\n\n    protected void handleRevision(XWikiContext context) throws XWikiException\n    {\n        String rev = context.getRequest().getParameter(\"rev\");\n        if (rev != null) {\n            context.put(\"rev\", rev);\n            XWikiDocument doc = (XWikiDocument) context.get(\"doc\");\n            XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n            // if the doc is deleted and we request a specific language, we have to set the locale so we can retrieve\n            // properly the document revision.\n            if (rev.startsWith(\"deleted\") && !StringUtils.isEmpty(context.getRequest().getParameter(\"language\"))\n                && doc == tdoc) {\n                Locale locale = LocaleUtils.toLocale(context.getRequest().getParameter(\"language\"), Locale.ROOT);\n                tdoc = new XWikiDocument(tdoc.getDocumentReference(), locale);\n            }\n\n            DocumentReference documentReference = doc.getDocumentReference();\n            try {\n                documentRevisionProvider\n                    .checkAccess(Right.VIEW, getCurrentUserReference(context), documentReference, rev);\n            } catch (AuthorizationException e) {\n                Object[] args = { documentReference, rev, context.getUserReference() };\n                throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                    \"Access to document {0} with revision {1} has been denied to user {2}\", e, args);\n            }\n\n            XWikiDocument rdoc;\n            XWikiDocument rtdoc;\n            if (doc.getLocale().equals(tdoc.getLocale())) {\n                rdoc = this.documentRevisionProvider.getRevision(doc.getDocumentReferenceWithLocale(), rev);\n                rtdoc = rdoc;\n            } else {\n                rdoc = doc;\n                rtdoc = this.documentRevisionProvider.getRevision(tdoc.getDocumentReferenceWithLocale(), rev);\n            }\n            if (rdoc == null) {\n                Object[] args = { doc.getDocumentReferenceWithLocale(), rev };\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_UNEXISTANT_VERSION,\n                    \"Version {1} does not exist while reading document {0}\", null, args);\n            }\n\n            context.put(\"tdoc\", rtdoc);\n            context.put(\"cdoc\", rdoc);\n            context.put(\"doc\", rdoc);\n        }\n    }\n\n    /**\n     * Send redirection based on a regexp pattern (if any) set at the main wiki level. To enable this feature you must\n     * add xwiki.preferences.redirect=1 to your xwiki.cfg.\n     *\n     * @param response the servlet response\n     * @param url url of the request\n     * @param context the XWiki context\n     * @return true if a redirection has been sent\n     */\n    protected boolean sendGlobalRedirect(XWikiResponse response, String url, XWikiContext context) throws Exception\n    {\n        if (\"1\".equals(context.getWiki().Param(\"xwiki.preferences.redirect\"))) {\n            // Note: This implementation is not performant at all and will slow down the wiki as the number\n            // of redirects increases. A better implementation would use a cache of redirects and would use\n            // the notification mechanism to update the cache when the XWiki.XWikiPreferences document is\n            // modified.\n            XWikiDocument globalPreferences = context.getWiki().getDocument(\"xwiki:XWiki.XWikiPreferences\", context);\n            Vector<BaseObject> redirects = globalPreferences.getObjects(\"XWiki.GlobalRedirect\");\n\n            if (redirects != null) {\n                for (BaseObject redir : redirects) {\n                    if (redir != null) {\n                        String p = redir.getStringValue(\"pattern\");\n                        if (p != null && url.matches(p)) {\n                            String dest = redir.getStringValue(\"destination\");\n                            response.sendRedirect(url.replaceAll(p, dest));\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Perform a redirect to the given URL.\n     * @param response the response to use to perform the redirect\n     * @param url the location of the redirect\n     * @throws XWikiException in case of IOException when performing the redirect.\n     */\n    protected void sendRedirect(XWikiResponse response, String url) throws XWikiException\n    {\n        try {\n            if (url != null) {\n                response.sendRedirect(response.encodeRedirectURL(url));\n            }\n        } catch (IOException e) {\n            Object[] args = {url};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_REDIRECT_EXCEPTION,\n                \"Exception while sending redirect to page {0}\", e, args);\n        }\n    }\n\n    /**\n     * Gets the translated version of a document, in the specified language. If the translation does not exist, a new\n     * document translation is created. If the requested language does not correspond to a translation (is not defined\n     * or is the same as the main document), then the main document is returned.\n     *\n     * @param doc the main (default, untranslated) document to translate\n     * @param language the requested document language\n     * @param context the current request context\n     * @return the translated document, or the original untranslated document if the requested language is not a\n     *         translation\n     * @throws XWikiException if the translation cannot be retrieved from the database\n     */\n    protected XWikiDocument getTranslatedDocument(XWikiDocument doc, String language, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument tdoc;\n        if (StringUtils.isBlank(language) || language.equals(\"default\") || language.equals(doc.getDefaultLanguage())) {\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(language, context);\n            if (tdoc == doc) {\n                tdoc = new XWikiDocument(doc.getDocumentReference());\n                tdoc.setLanguage(language);\n                tdoc.setStore(doc.getStore());\n            }\n            tdoc.setTranslation(1);\n        }\n        return tdoc;\n    }\n\n    /**\n     * Perform CSRF check and redirect to the resubmission page if needed. Throws an exception if the access should be\n     * denied, returns false if the check failed and the user will be redirected to a resubmission page.\n     *\n     * @param context current xwiki context containing the request\n     * @return true if the check succeeded, false if resubmission is needed\n     * @throws XWikiException if the check fails\n     */\n    protected boolean csrfTokenCheck(XWikiContext context) throws XWikiException\n    {\n        return csrfTokenCheck(context, false);\n    }\n\n    /**\n     * Perform CSRF check and redirect to the resubmission page if needed. Throws an exception if the access should be\n     * denied, returns false if the check failed and the user will be redirected to a resubmission page.\n     *\n     * @param context current xwiki context containing the request\n     * @param jsonAnswer if true, returns a JSON answer in case of AJAX request: allow to process it properly on client.\n     * @return true if the check succeeded, false if resubmission is needed\n     * @throws XWikiException if the check fails\n     * @since 11.3RC1\n     */\n    protected boolean csrfTokenCheck(XWikiContext context, boolean jsonAnswer) throws XWikiException\n    {\n        final boolean isAjaxRequest = Utils.isAjaxRequest(context);\n        CSRFToken csrf = Utils.getComponent(CSRFToken.class);\n        try {\n            String token = context.getRequest().getParameter(\"form_token\");\n            if (!csrf.isTokenValid(token)) {\n                if (isAjaxRequest) {\n                    if (jsonAnswer) {\n                        Map<String, String> jsonObject = new LinkedHashMap<>();\n                        jsonObject.put(\"errorType\", \"CSRF\");\n                        jsonObject.put(\"resubmissionURI\", csrf.getRequestURI());\n                        jsonObject.put(\"newToken\", csrf.getToken());\n                        this.answerJSON(context, HttpServletResponse.SC_FORBIDDEN, jsonObject);\n                    } else {\n                        final String csrfCheckFailedMessage = localizePlainOrKey(\"core.editors.csrfCheckFailed\");\n                        writeAjaxErrorResponse(HttpServletResponse.SC_FORBIDDEN, csrfCheckFailedMessage, context);\n                    }\n                } else {\n                    sendRedirect(context.getResponse(), csrf.getResubmissionURL());\n                }\n\n                return false;\n            }\n        } catch (XWikiException exception) {\n            // too bad\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied, secret token verification failed\", exception);\n        }\n        return true;\n    }\n\n    /**\n     * In order to let users enter URLs to Spaces we do the following when receiving {@code /A/B} (where A and B are\n     * spaces):\n     * <ul>\n     * <li>check that the action is \"view\" (we only support this for the view action since otherwise this would break\n     * apps written before this concept was introduced in XWiki 7.2M1)</li>\n     * <li>if A.B exists then continue</li>\n     * <li>if A.B doesn't exist then forward to A.B.WebHome</li>\n     * </ul>\n     * In order to disable this redirect you should provide the {@code spaceRedirect=false} Query String parameter and\n     * value.\n     *\n     * @since 7.2M1\n     */\n    private boolean redirectSpaceURLs(String action, XWikiURLFactory urlf, XWiki xwiki, XWikiContext context)\n        throws Exception\n    {\n        if (\"view\".equals(action) && !\"false\".equalsIgnoreCase(context.getRequest().getParameter(\"spaceRedirect\"))) {\n            DocumentReference reference = xwiki.getDocumentReference(context.getRequest(), context);\n            if (!xwiki.exists(reference, context)) {\n                String defaultDocumentName = Utils.getComponent(EntityReferenceProvider.class)\n                    .getDefaultReference(EntityType.DOCUMENT).getName();\n                // Avoid an infinite loop by ensuring we're not on a WebHome already\n                if (!reference.getName().equals(defaultDocumentName)) {\n                    // Consider the reference as a Space Reference and Construct a new reference to the home of that\n                    // Space. Then generate the URL for it and forward to it\n                    SpaceReference spaceReference = new SpaceReference(reference.getName(), reference.getParent());\n                    // Extract the anchor\n                    String anchor = new URL(context.getRequest().getRequestURL().toString()).getRef();\n                    URL forwardURL = urlf.createURL(getLocalSerializer().serialize(spaceReference), defaultDocumentName,\n                        action, context.getRequest().getQueryString(), anchor,\n                        spaceReference.getWikiReference().getName(), context);\n                    // Since createURL() contain the webapp context and since RequestDispatcher should not contain it,\n                    // we need to remove it!\n                    String webappContext = xwiki.getWebAppPath(context);\n                    String relativeURL = urlf.getURL(forwardURL, context);\n                    relativeURL = '/' + StringUtils.substringAfter(relativeURL, webappContext);\n                    context.getRequest().getRequestDispatcher(relativeURL).forward(context.getRequest(),\n                        context.getResponse());\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Answer to a request with a JSON content.\n     * \n     * @param context the current context of the request.\n     * @param status the status code to send back.\n     * @param answer the content of the JSON answer.\n     * @throws XWikiException in case of error during the serialization of the JSON.\n     */\n    protected void answerJSON(XWikiContext context, int status, Map<String, String> answer) throws XWikiException\n    {\n        ObjectMapper mapper = new ObjectMapper();\n\n        try {\n            String jsonAnswerAsString = mapper.writeValueAsString(answer);\n            context.getResponse().setContentType(\"application/json\");\n            context.getResponse().setContentLength(jsonAnswerAsString.length());\n            context.getResponse().setStatus(status);\n            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());\n            context.getResponse().getWriter().print(jsonAnswerAsString);\n            context.setResponseSent(true);\n        } catch (IOException e) {\n            throw new XWikiException(\"Error while sending JSON answer.\", e);\n        }\n    }\n\n    /**\n     * Make sure to set the right length (or nothing) in the response.\n     * \n     * @param response the response\n     * @param length the length to set in the response\n     * @since 11.10\n     * @since 10.11.10\n     * @since 11.3.6\n     */\n    protected void setContentLength(XWikiResponse response, long length)\n    {\n        // Set the content length in the response\n        response.setContentLengthLong(length);\n    }\n\n    /**\n     * Helper used resolve the template passed to the action if the current user have access to it.\n     * \n     * @param template the template to copy\n     * @return the reference of the template if not empty and the current user have access to it\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected DocumentReference resolveTemplate(String template)\n    {\n        if (StringUtils.isNotBlank(template)) {\n            DocumentReference templateReference = getCurrentMixedDocumentReferenceResolver().resolve(template);\n\n            // Make sure the current user have access to the template document before copying it\n            if (getContextualAuthorizationManager().hasAccess(Right.VIEW, templateReference)) {\n                return templateReference;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Helper used by various actions to initialize a document by copying a template to it.\n     * \n     * @param document the document to update\n     * @param template the template to copy\n     * @param context the XWiki context\n     * @return true if the document was updated, false otherwise (for example when the current user does not have view\n     *         right on the template document)\n     * @throws XWikiException when failing to copy the template\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected boolean readFromTemplate(XWikiDocument document, String template, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference templateReference = resolveTemplate(template);\n\n        if (templateReference != null) {\n            document.readFromTemplate(templateReference, context);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Loop over the {@link RedirectionFilter} components until one of them perform a redirection. If none of the does,\n     * the action continues normally.\n     *\n     * @param context the current wiki content\n     * @return {@code true} if a redirection has been performed, {@code false} otherwise\n     * @throws XWikiException in case of error during the execution of a redirection filter\n     */\n    private boolean handleRedirect(XWikiContext context) throws XWikiException\n    {\n        // If no redirection are expected, this step is skipped.\n        if (this.supportRedirections()) {\n            try {\n                for (RedirectionFilter filter : this.componentManager.<RedirectionFilter>getInstanceList(\n                    RedirectionFilter.class)) {\n                    if (filter.redirect(context)) {\n                        return true;\n                    }\n                }\n            } catch (ComponentLookupException e) {\n                throw new XWikiException(\"Failed to resolve the redirection filters list\", e);\n            }\n        }\n        return false;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.test.ui;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Serializable;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response.Status;\nimport javax.ws.rs.core.UriBuilder;\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.JAXBException;\nimport javax.xml.bind.Marshaller;\nimport javax.xml.bind.Unmarshaller;\n\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpMethod;\nimport org.apache.commons.httpclient.UsernamePasswordCredentials;\nimport org.apache.commons.httpclient.auth.AuthScope;\nimport org.apache.commons.httpclient.methods.DeleteMethod;\nimport org.apache.commons.httpclient.methods.EntityEnclosingMethod;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.methods.InputStreamRequestEntity;\nimport org.apache.commons.httpclient.methods.PostMethod;\nimport org.apache.commons.httpclient.methods.PutMethod;\nimport org.apache.commons.httpclient.methods.RequestEntity;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Cookie;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.NoSuchElementException;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.support.ui.ExpectedCondition;\nimport org.opentest4j.AssertionFailedError;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.AbstractLocalizedEntityReference;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.ObjectPropertyReference;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rest.model.jaxb.Page;\nimport org.xwiki.rest.model.jaxb.Property;\nimport org.xwiki.rest.model.jaxb.Xwiki;\nimport org.xwiki.rest.resources.attachments.AttachmentResource;\nimport org.xwiki.rest.resources.classes.ClassPropertyResource;\nimport org.xwiki.rest.resources.objects.ObjectPropertyResource;\nimport org.xwiki.rest.resources.objects.ObjectResource;\nimport org.xwiki.rest.resources.objects.ObjectsResource;\nimport org.xwiki.rest.resources.pages.PageResource;\nimport org.xwiki.rest.resources.pages.PageTranslationResource;\nimport org.xwiki.test.integration.XWikiExecutor;\nimport org.xwiki.test.ui.po.BasePage;\nimport org.xwiki.test.ui.po.ViewPage;\nimport org.xwiki.test.ui.po.editor.ClassEditPage;\nimport org.xwiki.test.ui.po.editor.ObjectEditPage;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\n/**\n * Helper methods for testing, not related to a specific Page Object. Also made available to tests classes.\n *\n * @version $Id$\n * @since 3.2M3\n */\npublic class TestUtils\n{\n    /**\n     * @since 5.0M2\n     */\n    public static final UsernamePasswordCredentials ADMIN_CREDENTIALS =\n        new UsernamePasswordCredentials(\"Admin\", \"admin\");\n\n    /**\n     * @since 5.1M1\n     */\n    public static final UsernamePasswordCredentials SUPER_ADMIN_CREDENTIALS =\n        new UsernamePasswordCredentials(\"superadmin\", \"pass\");\n\n    /**\n     * @since 5.0M2\n     * @deprecated since 7.3M1, use {@link #getBaseURL()} instead\n     */\n    @Deprecated\n    public static final String BASE_URL = XWikiExecutor.URL + \":\" + XWikiExecutor.DEFAULT_PORT\n        + XWikiExecutor.DEFAULT_CONTEXT + \"/\";\n\n    /**\n     * @since 5.0M2\n     * @deprecated since 7.3M1, use {@link #getBaseBinURL()} instead\n     */\n    @Deprecated\n    public static final String BASE_BIN_URL = BASE_URL + \"bin/\";\n\n    /**\n     * @since 5.0M2\n     * @deprecated since 7.3M1, use {@link #getBaseURL()} instead\n     */\n    @Deprecated\n    public static final String BASE_REST_URL = BASE_URL + \"rest/\";\n\n    /**\n     * @since 7.3M1\n     */\n    public static final int[] STATUS_OK_NOT_FOUND =\n        new int[] { Status.OK.getStatusCode(), Status.NOT_FOUND.getStatusCode() };\n\n    /**\n     * @since 7.3M1\n     */\n    public static final int[] STATUS_OK = new int[] { Status.OK.getStatusCode() };\n\n    /**\n     * @since 7.3M1\n     */\n    public static final int[] STATUS_NO_CONTENT = new int[] { Status.NO_CONTENT.getStatusCode() };\n\n    /**\n     * @since 8.3RC1\n     */\n    public static final int[] STATUS_NO_CONTENT_NOT_FOUND =\n        new int[] { Status.NO_CONTENT.getStatusCode(), Status.NOT_FOUND.getStatusCode() };\n\n    /**\n     * @since 7.3M1\n     */\n    public static final int[] STATUS_CREATED_ACCEPTED =\n        new int[] { Status.CREATED.getStatusCode(), Status.ACCEPTED.getStatusCode() };\n\n    /**\n     * @since 7.3M1\n     */\n    public static final int[] STATUS_CREATED = new int[] { Status.CREATED.getStatusCode() };\n\n    /**\n     * @since 9.5RC1\n     */\n    public static final int[] STATUS_ACCEPTED = new int[] { Status.ACCEPTED.getStatusCode() };\n\n    private static PersistentTestContext context;\n\n    private static ComponentManager componentManager;\n\n    private static EntityReferenceResolver<String> relativeReferenceResolver;\n\n    private static EntityReferenceSerializer<String> referenceSerializer;\n\n    private static EntityReferenceResolver<String> referenceResolver;\n\n    private static EntityReferenceSerializer<String> localReferenceSerializer;\n\n    /**\n     * Used to convert Java object into its REST XML representation.\n     */\n    private static Marshaller marshaller;\n\n    /**\n     * Used to convert REST request XML result into its Java representation.\n     */\n    private static Unmarshaller unmarshaller;\n\n    private static String urlPrefix = XWikiExecutor.URL;\n\n    /** Cached secret token. TODO cache for each user. */\n    private String secretToken = null;\n\n    private HttpClient httpClient;\n\n    /**\n     * @since 8.0M1\n     */\n    private List<XWikiExecutor> executors;\n\n    /**\n     * @since 7.3M1\n     */\n    private int currentExecutorIndex = 0;\n\n    /**\n     * @since 7.3M1\n     */\n    private String currentWiki = \"xwiki\";\n\n    private RestTestUtils rest;\n\n    public TestUtils()\n    {\n        this.httpClient = new HttpClient();\n\n        setDefaultCredentials(SUPER_ADMIN_CREDENTIALS);\n\n        this.rest = new RestTestUtils(this);\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public XWikiExecutor getCurrentExecutor()\n    {\n        return this.executors != null && this.executors.size() > this.currentExecutorIndex\n            ? this.executors.get(this.currentExecutorIndex) : null;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public void switchExecutor(int index)\n    {\n        this.currentExecutorIndex = index;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public void setExecutors(List<XWikiExecutor> executors)\n    {\n        this.executors = executors;\n    }\n\n    /** Used so that AllTests can set the persistent test context. */\n    public static void setContext(PersistentTestContext context)\n    {\n        TestUtils.context = context;\n    }\n\n    public static void initializeComponent(ComponentManager componentManager) throws Exception\n    {\n        TestUtils.componentManager = componentManager;\n        TestUtils.relativeReferenceResolver =\n            TestUtils.componentManager.getInstance(EntityReferenceResolver.TYPE_STRING, \"relative\");\n        TestUtils.referenceResolver = TestUtils.componentManager.getInstance(EntityReferenceResolver.TYPE_STRING);\n        TestUtils.referenceSerializer = TestUtils.componentManager.getInstance(EntityReferenceSerializer.TYPE_STRING);\n        TestUtils.localReferenceSerializer = TestUtils.componentManager.getInstance(\n            new DefaultParameterizedType(null, EntityReferenceSerializer.class, String.class), \"local\");\n    }\n\n    public XWikiWebDriver getDriver()\n    {\n        return TestUtils.context.getDriver();\n    }\n\n    public Session getSession()\n    {\n        return this.new Session(getDriver().manage().getCookies(), getSecretToken());\n    }\n\n    public void setSession(Session session)\n    {\n        WebDriver.Options options = getDriver().manage();\n        options.deleteAllCookies();\n        if (session != null) {\n            for (Cookie cookie : session.getCookies()) {\n                // Using a cookie for single component domain (i.e., without '.', like 'localhost' or 'xwikiweb') \n                // apparently triggers the following error in firefox:\n                // org.openqa.selenium.UnableToSetCookieException:\n                //[Exception... \"Component returned failure code: 0x80070057 (NS_ERROR_ILLEGAL_VALUE)\n                // [nsICookieManager.add]\" nsresult: \"0x80070057 (NS_ERROR_ILLEGAL_VALUE)\"\n                // location: \"JS frame :: chrome://marionette/content/cookie.js :: cookie.add :: line 177\" data: no]\n                //\n                // According to the following discussions:\n                // - https://stackoverflow.com/questions/1134290/cookies-on-localhost-with-explicit-domain\n                // - https://github.com/mozilla/geckodriver/issues/1579\n                // a working solution is to put null in the cookie domain.\n                // Now we might need to fix this in our real code, but the situation is not quite clear for me.\n                if (cookie.getDomain() !=null && !cookie.getDomain().contains(\".\")) {\n                    cookie = new Cookie(cookie.getName(), cookie.getValue(), null, cookie.getPath(),\n                        cookie.getExpiry(), cookie.isSecure(), cookie.isHttpOnly());\n                }\n                options.addCookie(cookie);\n            }\n        }\n        if (session != null && !StringUtils.isEmpty(session.getSecretToken())) {\n            this.secretToken = session.getSecretToken();\n        } else {\n            recacheSecretToken();\n        }\n    }\n\n    /**\n     * @since 7.0RC1\n     */\n    public void setDefaultCredentials(String username, String password)\n    {\n        setDefaultCredentials(new UsernamePasswordCredentials(username, password));\n    }\n\n    /**\n     * @since 7.0RC1\n     */\n    public UsernamePasswordCredentials setDefaultCredentials(UsernamePasswordCredentials defaultCredentials)\n    {\n        UsernamePasswordCredentials currentCredentials = getDefaultCredentials();\n\n        if (defaultCredentials != null) {\n            this.httpClient.getState().setCredentials(AuthScope.ANY, defaultCredentials);\n            this.httpClient.getParams().setAuthenticationPreemptive(true);\n        } else {\n            this.httpClient.getState().clearCredentials();\n            this.httpClient.getParams().setAuthenticationPreemptive(false);\n        }\n\n        return currentCredentials;\n    }\n\n    public UsernamePasswordCredentials getDefaultCredentials()\n    {\n        return (UsernamePasswordCredentials) this.httpClient.getState().getCredentials(AuthScope.ANY);\n    }\n\n    public void loginAsSuperAdmin()\n    {\n        login(SUPER_ADMIN_CREDENTIALS.getUserName(), SUPER_ADMIN_CREDENTIALS.getPassword());\n    }\n\n    public void loginAsSuperAdminAndGotoPage(String pageURL)\n    {\n        loginAndGotoPage(SUPER_ADMIN_CREDENTIALS.getUserName(), SUPER_ADMIN_CREDENTIALS.getPassword(), pageURL);\n    }\n\n    public void loginAsAdmin()\n    {\n        login(ADMIN_CREDENTIALS.getUserName(), ADMIN_CREDENTIALS.getPassword());\n    }\n\n    public void loginAsAdminAndGotoPage(String pageURL)\n    {\n        loginAndGotoPage(ADMIN_CREDENTIALS.getUserName(), ADMIN_CREDENTIALS.getPassword(), pageURL);\n    }\n\n    public void login(String username, String password)\n    {\n        loginAndGotoPage(username, password, null);\n    }\n\n    public void loginAndGotoPage(String username, String password, String pageURL)\n    {\n        loginAndGotoPage(username, password, pageURL, true);\n    }\n\n    /**\n     * @since 11.6RC1\n     */\n    public void loginAndGotoPage(String username, String password, String pageURL, boolean checkLoginSuccess)\n    {\n        if (!username.equals(getLoggedInUserName())) {\n            // Log in and direct to a non existent page so that it loads very fast and we don't incur the time cost of\n            // going to the home page for example.\n            // Also recache the CSRF token\n            String destUrl = getURL(\"XWiki\", \"Register\", \"register\");\n            getDriver().get(getURLToLoginAndGotoPage(username, password, destUrl));\n\n            if (checkLoginSuccess && !getDriver().getCurrentUrl().startsWith(destUrl)) {\n                throw new RuntimeException(\n                    String.format(\"Login failed with credentials: [%s] / [%s]. Was expecting to be on URL [%s] but \"\n                        + \"was on [%s]. Page source is [%s]\", username, password, destUrl,\n                        getDriver().getCurrentUrl(), getDriver().getPageSource()));\n\n            }\n            recacheSecretTokenWhenOnRegisterPage();\n            if (pageURL != null) {\n                // Go to the page asked\n                getDriver().get(pageURL);\n            } else {\n                getDriver().get(getURLToNonExistentPage());\n            }\n\n            setDefaultCredentials(username, password);\n        }\n    }\n\n    /**\n     * Consider using setSession(null) because it will drop the cookies which is faster than invoking a logout action.\n     */\n    public String getURLToLogout()\n    {\n        return getURL(\"XWiki\", \"XWikiLogin\", \"logout\");\n    }\n\n    public String getURLToLoginAsAdmin()\n    {\n        return getURLToLoginAs(ADMIN_CREDENTIALS.getUserName(), ADMIN_CREDENTIALS.getPassword());\n    }\n\n    public String getURLToLoginAsSuperAdmin()\n    {\n        return getURLToLoginAs(SUPER_ADMIN_CREDENTIALS.getUserName(), SUPER_ADMIN_CREDENTIALS.getPassword());\n    }\n\n    public String getURLToLoginAs(final String username, final String password)\n    {\n        return getURLToLoginAndGotoPage(username, password, null);\n    }\n\n    /**\n     * @param pageURL the URL of the page to go to after logging in.\n     * @return URL to accomplish login and goto.\n     */\n    public String getURLToLoginAsAdminAndGotoPage(final String pageURL)\n    {\n        return getURLToLoginAndGotoPage(ADMIN_CREDENTIALS.getUserName(), ADMIN_CREDENTIALS.getPassword(), pageURL);\n    }\n\n    /**\n     * @param pageURL the URL of the page to go to after logging in.\n     * @return URL to accomplish login and goto.\n     */\n    public String getURLToLoginAsSuperAdminAndGotoPage(final String pageURL)\n    {\n        return getURLToLoginAndGotoPage(SUPER_ADMIN_CREDENTIALS.getUserName(), SUPER_ADMIN_CREDENTIALS.getPassword(),\n            pageURL);\n    }\n\n    /**\n     * @param username the name of the user to log in as.\n     * @param password the password for the user to log in.\n     * @param pageURL the URL of the page to go to after logging in.\n     * @return URL to accomplish login and goto.\n     */\n    public String getURLToLoginAndGotoPage(final String username, final String password, final String pageURL)\n    {\n        Map<String, String> parameters = new HashMap<String, String>()\n        {\n            {\n                put(\"j_username\", username);\n                put(\"j_password\", password);\n                if (pageURL != null && pageURL.length() > 0) {\n                    put(\"xredirect\", pageURL);\n                }\n            }\n        };\n        return getURL(\"XWiki\", \"XWikiLogin\", \"loginsubmit\", parameters);\n    }\n\n    /**\n     * @return URL to a non existent page that loads very fast (we are using plain mode so that we don't even have to\n     *         display the skin ;))\n     */\n    public String getURLToNonExistentPage()\n    {\n        return getURL(\"NonExistentSpace\", \"NonExistentPage\", \"view\", \"xpage=plain\");\n    }\n\n    /**\n     * After successful completion of this function, you are guaranteed to be logged in as the given user and on the\n     * page passed in pageURL.\n     */\n    public void assertOnPage(final String pageURL)\n    {\n        final String pageURI = pageURL.replaceAll(\"\\\\?.*\", \"\");\n        getDriver().waitUntilCondition(new ExpectedCondition<Boolean>()\n        {\n            @Override\n            public Boolean apply(WebDriver driver)\n            {\n                return getDriver().getCurrentUrl().contains(pageURI);\n            }\n        });\n    }\n\n    public String getLoggedInUserName()\n    {\n        By userAvatarInDrawer = By.id(\"tmUser\");\n        if (!getDriver().hasElementWithoutWaiting(userAvatarInDrawer)) {\n            // Guest\n            return null;\n        }\n\n        WebElement element = getDriver().findElementWithoutWaiting(userAvatarInDrawer);\n        String href = element.getAttribute(\"href\");\n        String loggedInUserName = href.substring(href.lastIndexOf(\"/\") + 1);\n\n        // Return\n        return loggedInUserName;\n    }\n\n    public void createUserAndLogin(final String username, final String password, Object... properties)\n    {\n        createUserAndLoginWithRedirect(username, password, getURLToNonExistentPage(), properties);\n    }\n\n    public void createUserAndLoginWithRedirect(final String username, final String password, String url,\n        Object... properties)\n    {\n        createUser(username, password, getURLToLoginAndGotoPage(username, password, url), properties);\n\n        setDefaultCredentials(username, password);\n    }\n\n    public void createUser(final String username, final String password, String redirectURL, Object... properties)\n    {\n        Map<String, String> parameters = new HashMap<String, String>();\n        parameters.put(\"register\", \"1\");\n        parameters.put(\"xwikiname\", username);\n        parameters.put(\"register_password\", password);\n        parameters.put(\"register2_password\", password);\n        parameters.put(\"register_email\", \"\");\n        if (!StringUtils.isEmpty(redirectURL)) {\n            parameters.put(\"xredirect\", redirectURL);\n        }\n        parameters.put(\"form_token\", getSecretToken());\n        getDriver().get(getURL(\"XWiki\", \"Register\", \"register\", parameters));\n        recacheSecretToken();\n        if (properties.length > 0) {\n            updateObject(\"XWiki\", username, \"XWiki.XWikiUsers\", 0, properties);\n        }\n    }\n\n    /**\n     * Creates the Admin user, add it to the XWikiAdminGroup and login.\n     * Note that this method requires to be superadmin to be effective.\n     *\n     * @since 12.2\n     */\n    public void createAdminUser()\n    {\n        createAdminUser(false);\n    }\n\n    /**\n     * Creates the Admin user, add it to the XWikiAdminGroup and login.\n     * Note that this method requires to be superadmin to be effective.\n     *\n     * @param programming true of the user should also be given programming right\n     * @since 15.1RC1\n     * @since 14.10.5\n     */\n    public void createAdminUser(boolean programming)\n    {\n        String username = ADMIN_CREDENTIALS.getUserName();\n        String password = ADMIN_CREDENTIALS.getPassword();\n        LocalDocumentReference userReference = new LocalDocumentReference(\"XWiki\", username);\n        Page userPage = rest().page(userReference);\n        userPage.setObjects(new org.xwiki.rest.model.jaxb.Objects());\n        org.xwiki.rest.model.jaxb.Object userObject = RestTestUtils.object(\"XWiki.XWikiUsers\");\n\n        // Set password\n        userObject.getProperties().add(RestTestUtils.property(\"password\", password));\n        userPage.getObjects().getObjectSummaries().add(userObject);\n\n        // Save the user page\n        try {\n            rest().save(userPage);\n        } catch (Exception e) {\n            fail(\"Failed to save the user with name [\" + username + \"]\", e);\n        }\n        // Add the user to XWikiAllGroup\n        addObject(\"XWiki\", \"XWikiAllGroup\", \"XWiki.XWikiGroups\", \"member\", serializeReference(userReference));\n        // Add the user to XWikiAdminGroup group (before we login as the user does not have admin right at first)\n        addObject(\"XWiki\", \"XWikiAdminGroup\", \"XWiki.XWikiGroups\", \"member\", serializeReference(userReference));\n        // Give ADMIN right (and maybe PROGRAMMING right) to XWikiAdminGroup\n        setGlobalRights(\"XWiki.XWikiAdminGroup\", \"\", programming ? \"admin,programming\" : \"admin\", true);\n        loginAsAdmin();\n    }\n\n    /**\n     * Add or update a {@code XWikiGlobalRights} xobject to the current wiki's {@code XWikiPreferences} document.\n     *\n     * @param groups the comma-separated list of groups that will have the rights (e.g. {@code XWiki.XWikiAdminGroup}.\n     *               Can be empty or null\n     * @param users the comma-separated list of users that will have the rights (e.g. {@code XWiki.Admin}. Can be\n     *              empty of null\n     * @param rights the comma-separated list of rights to give (e.g. {@code edit,admin})\n     * @param enabled true if the rights should be allowed, false if they should be disabled\n     * @since 12.2\n     */\n    public void setGlobalRights(String groups, String users, String rights, boolean enabled)\n    {\n        EntityReference xwikiPreferencesReference = new EntityReference(\"XWikiPreferences\", EntityType.DOCUMENT,\n            new EntityReference(\"XWiki\", EntityType.SPACE));\n        setRights(xwikiPreferencesReference, \"XWiki.XWikiGlobalRights\", groups, users, rights, enabled);\n    }\n\n    /**\n     * Add or update a {@code XWikiRights} xobject to the document specified in the passed entity reference.\n     *\n     * @param entityReference the reference to the document for which to set rights for\n     * @param groups the comma-separated list of groups that will have the rights (e.g. {@code XWiki.XWikiAdminGroup}.\n     *               Can be empty or null\n     * @param users the comma-separated list of users that will have the rights (e.g. {@code XWiki.Admin}. Can be\n     *              empty of null\n     * @param rights the comma-separated list of rights to give (e.g. {@code edit,admin})\n     * @param enabled true if the rights should be allowed, false if they should be denied\n     * @since 12.2\n     */\n    public void setRights(EntityReference entityReference, String groups, String users, String rights, boolean enabled)\n    {\n        setRights(entityReference, \"XWiki.XWikiRights\", groups, users, rights, enabled);\n    }\n\n    /**\n     * Add or update a {@code XWikiRights} xobject to the specified space reference.\n     *\n     * @param space the reference to the space for which to set rights for\n     * @param groups the comma-separated list of groups that will have the rights (e.g. {@code XWiki.XWikiAdminGroup}.\n     *               Can be empty or null\n     * @param users the comma-separated list of users that will have the rights (e.g. {@code XWiki.Admin}. Can be\n     *              empty of null\n     * @param rights the comma-separated list of rights to give (e.g. {@code edit,admin})\n     * @param enabled true if the rights should be allowed, false if they should be denied\n     * @since 14.10\n     */\n    public void setRightsOnSpace(SpaceReference space, String groups, String users, String rights, boolean enabled)\n    {\n        DocumentReference documentReference = new DocumentReference(\"WebPreferences\", space);\n        setRights(documentReference, \"XWiki.XWikiGlobalRights\", groups, users, rights, enabled);\n    }\n\n    private void setRights(EntityReference entityReference, String rightClassName, String groups, String users,\n        String rights, boolean enabled)\n    {\n        String normalizedUsers = users == null ? \"\" : users;\n        String normalizedGroups = groups == null ? \"\" : groups;\n        addObject(entityReference, rightClassName, \"groups\", normalizedGroups, \"levels\", rights,\n            \"users\", normalizedUsers, \"allow\", enabled ? \"1\" : \"0\");\n    }\n\n    public ViewPage gotoPage(String space, String page)\n    {\n        gotoPage(space, page, \"view\");\n        return new ViewPage();\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage gotoPage(EntityReference reference)\n    {\n        gotoPage(reference, \"view\");\n        return new ViewPage();\n    }\n\n    public void gotoPage(String space, String page, String action)\n    {\n        gotoPage(space, page, action, \"\");\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void gotoPage(EntityReference reference, String action)\n    {\n        gotoPage(reference, action, \"\");\n    }\n\n    /**\n     * @since 3.5M1\n     */\n    public void gotoPage(String space, String page, String action, Object... queryParameters)\n    {\n        gotoPage(space, page, action, toQueryString(queryParameters));\n    }\n\n    /**\n     * @since 11.3RC1\n     */\n    public void gotoPage(EntityReference reference, String action, Object... queryParameters)\n    {\n        gotoPage(reference, action, toQueryString(queryParameters));\n    }\n\n    public void gotoPage(String space, String page, String action, Map<String, ?> queryParameters)\n    {\n        gotoPage(Collections.singletonList(space), page, action, queryParameters);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void gotoPage(List<String> spaces, String page, String action, Map<String, ?> queryParameters)\n    {\n        gotoPage(spaces, page, action, toQueryString(queryParameters));\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void gotoPage(EntityReference reference, String action, Map<String, ?> queryParameters)\n    {\n        gotoPage(reference, action, toQueryString(queryParameters));\n    }\n\n    public void gotoPage(String space, String page, String action, String queryString)\n    {\n        gotoPage(Collections.singletonList(space), page, action, queryString);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void gotoPage(List<String> spaces, String page, String action, String queryString)\n    {\n        gotoPage(getURL(spaces, page, action, queryString));\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void gotoPage(EntityReference reference, String action, String queryString)\n    {\n        gotoPage(reference, action, queryString, null);\n    }\n\n    /**\n     * @since 10.9\n     */\n    public void gotoPage(EntityReference reference, String action, String queryString, String fragment)\n    {\n        gotoPage(getURL(reference, action, queryString, fragment));\n\n        // Update current wiki\n        EntityReference wikiReference = reference.extractReference(EntityType.WIKI);\n        if (wikiReference != null) {\n            this.currentWiki = wikiReference.getName();\n        }\n    }\n\n    public void gotoPage(String url)\n    {\n        getDriver().get(url);\n    }\n\n    public String getURLToDeletePage(String space, String page)\n    {\n        return getURL(space, page, \"delete\", \"confirm=1\");\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public String getURLToDeletePage(EntityReference reference)\n    {\n        return getURLToDeletePage(reference, false);\n    }\n\n    /**\n     * @since 12.9RC1\n     */\n    public String getURLToDeletePage(EntityReference reference, boolean affectChildren)\n    {\n        String queryString = \"confirm=1&async=false\";\n        if (affectChildren) {\n            queryString += \"&affectChildren=true\";\n        }\n        return getURL(reference, \"delete\", queryString);\n    }\n\n    /**\n     * @param space the name of the space to delete\n     * @return the URL that can be used to delete the specified pace\n     * @since 4.5\n     */\n    public String getURLToDeleteSpace(String space)\n    {\n        return getURL(space, \"WebHome\", \"deletespace\", \"confirm=1&async=false&affectChidlren=on\");\n    }\n\n    /**\n     * @param space the reference of the space to delete\n     * @return the URL that can be used to delete the specified pace\n     * @since 14.1RC1\n     */\n    public String getURLToDeleteSpace(EntityReference space)\n    {\n        return getURL(space, \"WebHome\", \"deletespace\", \"confirm=1&async=false&affectChidlren=on\");\n    }\n\n    public ViewPage createPage(String space, String page, String content, String title)\n    {\n        return createPage(Collections.singletonList(space), page, content, title);\n    }\n\n    /**\n     * @since 11.5RC1\n     * @since 11.3.1\n     */\n    public ViewPage createPage(EntityReference reference, String content)\n    {\n        return createPage(reference, content, this.serializeReference(reference), null);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage createPage(EntityReference reference, String content, String title)\n    {\n        return createPage(reference, content, title, null);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage createPage(List<String> spaces, String page, String content, String title)\n    {\n        return createPage(spaces, page, content, title, null);\n    }\n\n    public ViewPage createPage(String space, String page, String content, String title, String syntaxId)\n    {\n        return createPage(Collections.singletonList(space), page, content, title, syntaxId);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage createPage(EntityReference reference, String content, String title, String syntaxId)\n    {\n        return createPage(reference, content, title, syntaxId, null);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage createPage(List<String> spaces, String page, String content, String title, String syntaxId)\n    {\n        return createPage(spaces, page, content, title, syntaxId, null);\n    }\n\n    public ViewPage createPage(String space, String page, String content, String title, String syntaxId,\n        String parentFullPageName)\n    {\n        return createPage(Collections.singletonList(space), page, content, title, syntaxId, parentFullPageName);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage createPage(List<String> spaces, String page, String content, String title, String syntaxId,\n        String parentFullPageName)\n    {\n        Map<String, String> queryMap = new HashMap<String, String>();\n        if (content != null) {\n            queryMap.put(\"content\", content);\n        }\n        if (title != null) {\n            queryMap.put(\"title\", title);\n        }\n        if (syntaxId != null) {\n            queryMap.put(\"syntaxId\", syntaxId);\n        }\n        if (parentFullPageName != null) {\n            queryMap.put(\"parent\", parentFullPageName);\n        }\n        gotoPage(spaces, page, \"save\", queryMap);\n        return new ViewPage();\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage createPage(EntityReference reference, String content, String title, String syntaxId,\n        String parentFullPageName)\n    {\n        Map<String, String> queryMap = new HashMap<>();\n        if (content != null) {\n            queryMap.put(\"content\", content);\n        }\n        if (title != null) {\n            queryMap.put(\"title\", title);\n        }\n        if (syntaxId != null) {\n            queryMap.put(\"syntaxId\", syntaxId);\n        }\n        if (parentFullPageName != null) {\n            queryMap.put(\"parent\", parentFullPageName);\n        }\n        gotoPage(reference, \"save\", queryMap);\n        return new ViewPage();\n    }\n\n    /**\n     * @since 5.1M2\n     */\n    public ViewPage createPageWithAttachment(String space, String page, String content, String title, String syntaxId,\n        String parentFullPageName, String attachmentName, InputStream attachmentData) throws Exception\n    {\n        return createPageWithAttachment(space, page, content, title, syntaxId, parentFullPageName, attachmentName,\n            attachmentData, null);\n    }\n\n    /**\n     * @since 5.1M2\n     */\n    public ViewPage createPageWithAttachment(String space, String page, String content, String title, String syntaxId,\n        String parentFullPageName, String attachmentName, InputStream attachmentData,\n        UsernamePasswordCredentials credentials) throws Exception\n    {\n        return createPageWithAttachment(Collections.singletonList(space), page, content, title, syntaxId,\n            parentFullPageName, attachmentName, attachmentData, credentials);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public ViewPage createPageWithAttachment(List<String> spaces, String page, String content, String title,\n        String syntaxId, String parentFullPageName, String attachmentName, InputStream attachmentData,\n        UsernamePasswordCredentials credentials) throws Exception\n    {\n        ViewPage vp = createPage(spaces, page, content, title, syntaxId, parentFullPageName);\n        attachFile(spaces, page, attachmentName, attachmentData, false, credentials);\n        return vp;\n    }\n\n    /**\n     * @since 5.1M2\n     */\n    public ViewPage createPageWithAttachment(String space, String page, String content, String title,\n        String attachmentName, InputStream attachmentData) throws Exception\n    {\n        return createPageWithAttachment(space, page, content, title, null, null, attachmentName, attachmentData);\n    }\n\n    /**\n     * @since 5.1M2\n     */\n    public ViewPage createPageWithAttachment(String space, String page, String content, String title,\n        String attachmentName, InputStream attachmentData, UsernamePasswordCredentials credentials) throws Exception\n    {\n        ViewPage vp = createPage(space, page, content, title);\n        attachFile(space, page, attachmentName, attachmentData, false, credentials);\n        return vp;\n    }\n\n    /**\n     * @since 12.2\n     */\n    public ViewPage createPageWithAttachment(EntityReference reference, String content, String title,\n        String attachmentName, InputStream attachmentData, UsernamePasswordCredentials credentials) throws Exception\n    {\n        ViewPage vp = createPage(reference, content, title);\n        attachFile(reference, attachmentName, attachmentData, false, credentials);\n        return vp;\n    }\n\n    /**\n     * @since 12.2\n     */\n    public ViewPage createPageWithAttachment(EntityReference reference, String content, String title,\n        String attachmentName, InputStream attachmentData) throws Exception\n    {\n        return createPageWithAttachment(reference, content, title, attachmentName, attachmentData, null);\n    }\n\n    public void deletePage(String space, String page)\n    {\n        getDriver().get(getURLToDeletePage(space, page));\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void deletePage(EntityReference reference)\n    {\n        deletePage(reference, false);\n    }\n\n    /**\n     * @since 12.9RC1\n     */\n    public void deletePage(EntityReference reference, boolean affectChildren)\n    {\n        getDriver().get(getURLToDeletePage(reference, affectChildren));\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public EntityReference resolveDocumentReference(String referenceAsString)\n    {\n        return referenceResolver.resolve(referenceAsString, EntityType.DOCUMENT);\n    }\n\n    /**\n     * @since 7.2M3\n     */\n    public EntityReference resolveSpaceReference(String referenceAsString)\n    {\n        return referenceResolver.resolve(referenceAsString, EntityType.SPACE);\n    }\n\n    /**\n     * @since 7.2RC1\n     */\n    public String serializeReference(EntityReference reference)\n    {\n        return referenceSerializer.serialize(reference);\n    }\n\n    /**\n     * Accesses the URL to delete the specified space.\n     *\n     * @param space the name of the space to delete\n     * @since 4.5\n     */\n    public void deleteSpace(String space)\n    {\n        getDriver().get(getURLToDeleteSpace(space));\n    }\n\n    /**\n     * Accesses the URL to delete the specified space.\n     *\n     * @param space the reference of the space to delete\n     * @since 14.1RC1\n     */\n    public void deleteSpace(EntityReference space)\n    {\n        getDriver().get(getURLToDeleteSpace(space));\n    }\n\n    public boolean pageExists(String space, String page) throws Exception\n    {\n        return rest().exists(new LocalDocumentReference(space, page));\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public boolean pageExists(List<String> spaces, String page) throws Exception\n    {\n        return rest().exists(new LocalDocumentReference(spaces, page));\n    }\n\n    /**\n     * Get the URL to view a page.\n     *\n     * @param space the space in which the page resides.\n     * @param page the name of the page.\n     */\n    public String getURL(String space, String page)\n    {\n        return getURL(space, page, \"view\");\n    }\n\n    /**\n     * Get the URL of an action on a page.\n     *\n     * @param space the space in which the page resides.\n     * @param page the name of the page.\n     * @param action the action to do on the page.\n     */\n    public String getURL(String space, String page, String action)\n    {\n        return getURL(space, page, action, \"\");\n    }\n\n    /**\n     * Get the URL of an action on a page with a specified query string.\n     *\n     * @param space the space in which the page resides.\n     * @param page the name of the page.\n     * @param action the action to do on the page.\n     * @param queryString the query string to pass in the URL.\n     */\n    public String getURL(String space, String page, String action, String queryString)\n    {\n        return getURL(action, new String[] { space, page }, queryString);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public String getURL(List<String> spaces, String page)\n    {\n        return getURL(spaces, page, \"view\", \"\");\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public String getURL(List<String> spaces, String page, String action, String queryString)\n    {\n        List<String> path = new ArrayList<>(spaces);\n        path.add(page);\n        return getURL(action, path.toArray(new String[] {}), queryString);\n    }\n\n    /**\n     * @since 12.2\n     */\n    public String getURL(EntityReference reference)\n    {\n        return getURL(reference, \"view\", \"\");\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public String getURL(EntityReference reference, String action, String queryString)\n    {\n        return getURL(reference, action, queryString, null);\n    }\n\n    /**\n     * @since 10.9\n     */\n    public String getURL(EntityReference reference, String action, String queryString, String fragment)\n    {\n        Serializable locale = reference.getParameters().get(\"locale\");\n        if (locale != null) {\n            queryString += \"&language=\" + locale;\n        }\n        return getURL(action, extractListFromReference(reference).toArray(new String[] {}), queryString, fragment);\n    }\n\n    /**\n     * @since 9.7RC1\n     */\n    public String executeAndGetBodyAsString(EntityReference reference, Map<String, ?> queryParameters) throws Exception\n    {\n        gotoPage(getURL(reference, \"get\", toQueryString(queryParameters)));\n        \n        return getDriver().findElementWithoutWaiting(By.tagName(\"body\")).getText();\n    }\n\n    /**\n     * @since 15.1RC1\n     * @since 14.10.5\n     */\n    public String executeWiki(String wikiContent, Syntax wikiSyntax) throws Exception\n    {\n        LocalDocumentReference reference =\n            new LocalDocumentReference(List.of(\"Test\", \"Execute\"), UUID.randomUUID().toString());\n\n        rest().savePage(reference, wikiContent, wikiSyntax.toIdString(), null, null);\n\n        return executeAndGetBodyAsString(reference, null);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public String getURLFragment(EntityReference reference)\n    {\n        return StringUtils.join(extractListFromReference(reference), \"/\");\n    }\n\n    private List<String> extractListFromReference(EntityReference reference)\n    {\n        List<String> path = new ArrayList<>();\n        // Add the spaces\n        EntityReference spaceReference = reference.extractReference(EntityType.SPACE);\n        EntityReference wikiReference = reference.extractReference(EntityType.WIKI);\n        for (EntityReference singleReference : spaceReference.removeParent(wikiReference).getReversedReferenceChain()) {\n            path.add(singleReference.getName());\n        }\n        if (reference.getType() == EntityType.DOCUMENT || reference.getType() == EntityType.ATTACHMENT) {\n            path.add(reference.getName());\n        }\n        return path;\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public String getCurrentWiki()\n    {\n        return this.currentWiki;\n    }\n\n    /**\n     * @since 14.5\n     */\n    public void setCurrentWiki(String currentWiki)\n    {\n        this.currentWiki = currentWiki;\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public String getBaseURL()\n    {\n        String baseURL;\n\n        // If the URL has the port specified then consider it's a full URL and use it, otherwise add the port and the\n        // webapp context\n        if (TestUtils.urlPrefix.matches(\"http://.*:[0-9]+/.*\")) {\n            baseURL = TestUtils.urlPrefix;\n        } else {\n            baseURL = TestUtils.urlPrefix + \":\"\n                + (getCurrentExecutor() != null ? getCurrentExecutor().getPort() : XWikiExecutor.DEFAULT_PORT)\n                + XWikiExecutor.DEFAULT_CONTEXT;\n        }\n\n        if (!baseURL.endsWith(\"/\")) {\n            baseURL = baseURL + \"/\";\n        }\n\n        return baseURL;\n    }\n\n    /**\n     * @since 10.6RC1\n     */\n    public static void setURLPrefix(String urlPrefix)\n    {\n        TestUtils.urlPrefix = urlPrefix;\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public String getBaseBinURL()\n    {\n        return getBaseBinURL(this.currentWiki);\n    }\n\n    /**\n     * @since 11.2RC1\n     */\n    public String getBaseBinURL(String wiki)\n    {\n        return getBaseURL() + ((StringUtils.isEmpty(wiki) || wiki.equals(\"xwiki\")) ? \"bin/\" : \"wiki/\" + wiki + '/');\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getURL(String action, String[] path, String queryString)\n    {\n        return getURL(action, path, queryString, null);\n    }\n\n    /**\n     * @since 10.9\n     */\n    public String getURL(String action, String[] path, String queryString, String fragment)\n    {\n        StringBuilder builder = new StringBuilder(getBaseBinURL());\n\n        if (!StringUtils.isEmpty(action)) {\n            builder.append(action).append('/');\n        }\n        List<String> escapedPath = new ArrayList<>();\n        for (String element : path) {\n            escapedPath.add(escapeURL(element));\n        }\n        builder.append(StringUtils.join(escapedPath, '/'));\n\n        boolean needToAddSecretToken = !Arrays.asList(\"view\", \"register\", \"download\", \"export\").contains(action);\n        if (needToAddSecretToken || !StringUtils.isEmpty(queryString)) {\n            builder.append('?');\n        }\n        if (needToAddSecretToken) {\n            addQueryStringEntry(builder, \"form_token\", getSecretToken());\n            builder.append('&');\n        }\n        if (!StringUtils.isEmpty(queryString)) {\n            builder.append(queryString);\n        }\n\n        if (!StringUtils.isEmpty(fragment)) {\n            builder.append('#').append(fragment);\n        }\n\n        return builder.toString();\n    }\n\n    /**\n     * Get the URL of an action on a page with specified parameters. If you need to pass multiple parameters with the\n     * same key, this function will not work.\n     *\n     * @param space the space in which the page resides.\n     * @param page the name of the page.\n     * @param action the action to do on the page.\n     * @param queryParameters the parameters to pass in the URL, these will be automatically URL encoded.\n     */\n    public String getURL(String space, String page, String action, Map<String, ?> queryParameters)\n    {\n        return getURL(space, page, action, toQueryString(queryParameters));\n    }\n\n    /**\n     * @param space the name of the space that contains the page with the specified attachment\n     * @param page the name of the page that holds the attachment\n     * @param attachment the attachment name\n     * @param action the action to perform on the attachment\n     * @param queryString the URL query string\n     * @return the URL that performs the specified action on the specified attachment\n     */\n    public String getAttachmentURL(String space, String page, String attachment, String action, String queryString)\n    {\n        return getURL(action, new String[] { space, page, attachment }, queryString);\n    }\n\n    /**\n     * @param space the name of the space that contains the page with the specified attachment\n     * @param page the name of the page that holds the attachment\n     * @param attachment the attachment name\n     * @param action the action to perform on the attachment\n     * @return the URL that performs the specified action on the specified attachment\n     */\n    public String getAttachmentURL(String space, String page, String attachment, String action)\n    {\n        return getAttachmentURL(space, page, attachment, action, \"\");\n    }\n\n    /**\n     * @param space the name of the space that contains the page with the specified attachment\n     * @param page the name of the page that holds the attachment\n     * @param attachment the attachment name\n     * @return the URL to download the specified attachment\n     */\n    public String getAttachmentURL(String space, String page, String attachment)\n    {\n        return getAttachmentURL(space, page, attachment, \"download\");\n    }\n\n    /**\n     * (Re)-cache the secret token used for CSRF protection. A user with edit rights on Main.WebHome must be logged in.\n     * This method must be called before {@link #getSecretToken()} is called and after each re-login.\n     *\n     * @see #getSecretToken()\n     */\n    public void recacheSecretToken()\n    {\n        // Save the current URL to be able to get back after we cache the secret token. We're not using the browser's\n        // Back button because if the current page is the result of a POST request then by going back we are re-sending\n        // the POST data which can have unexpected results. Moreover, some browsers pop up a modal confirmation box\n        // which blocks the test.\n        String previousURL = getDriver().getCurrentUrl();\n        // Go to the registration page because the registration form uses secret token.\n        gotoPage(getCurrentWiki(), \"Register\", \"register\");\n        recacheSecretTokenWhenOnRegisterPage();\n        // Return to the previous page.\n        getDriver().get(previousURL);\n    }\n\n    private void recacheSecretTokenWhenOnRegisterPage()\n    {\n        try {\n            WebElement tokenInput = getDriver().findElement(By.xpath(\"//input[@name='form_token']\"));\n            this.secretToken = tokenInput.getAttribute(\"value\");\n        } catch (NoSuchElementException exception) {\n            // Something is really wrong if this happens.\n            System.out.println(\"Warning: Failed to cache anti-CSRF secret token, some tests might fail!\");\n            exception.printStackTrace();\n        }\n    }\n\n    /**\n     * Get the secret token used for CSRF protection. Remember to call {@link #recacheSecretToken()} first.\n     *\n     * @return anti-CSRF secret token, or empty string if the token was not cached\n     * @see #recacheSecretToken()\n     */\n    public String getSecretToken()\n    {\n        if (this.secretToken == null) {\n            System.out.println(\"Warning: No cached anti-CSRF token found. \"\n                + \"Make sure to call recacheSecretToken() before getSecretToken(), otherwise this test might fail.\");\n            return \"\";\n        }\n        return this.secretToken;\n    }\n\n    /**\n     * This class represents all cookies stored in the browser. Use with getSession() and setSession()\n     */\n    public class Session\n    {\n        private final Set<Cookie> cookies;\n\n        private final String secretToken;\n\n        private Session(final Set<Cookie> cookies, final String secretToken)\n        {\n            this.cookies = Collections.unmodifiableSet(new HashSet<Cookie>()\n            {\n                {\n                    addAll(cookies);\n                }\n            });\n            this.secretToken = secretToken;\n        }\n\n        private Set<Cookie> getCookies()\n        {\n            return this.cookies;\n        }\n\n        private String getSecretToken()\n        {\n            return this.secretToken;\n        }\n    }\n\n    public boolean isInWYSIWYGEditMode()\n    {\n        return getDriver().findElements(By.xpath(\"//div[@id='editcolumn' and contains(@class, 'editor-wysiwyg')]\"))\n            .size() > 0;\n    }\n\n    public boolean isInWikiEditMode()\n    {\n        return getDriver().findElements(By.xpath(\"//div[@id='editcolumn' and contains(@class, 'editor-wiki')]\"))\n            .size() > 0;\n    }\n\n    public boolean isInViewMode()\n    {\n        return !getDriver().hasElementWithoutWaiting(By.id(\"editMeta\"));\n    }\n\n    public boolean isInSourceViewMode()\n    {\n        String currentURL = getDriver().getCurrentUrl();\n        return currentURL.contains(\"/view/\") && currentURL.contains(\"viewer=code\");\n    }\n\n    public boolean isInInlineEditMode()\n    {\n        String currentURL = getDriver().getCurrentUrl();\n        // Keep checking the deprecated inline action for backward compatibility.\n        return currentURL.contains(\"editor=inline\") || currentURL.contains(\"/inline/\");\n    }\n\n    public boolean isInRightsEditMode()\n    {\n        return getDriver().getCurrentUrl().contains(\"editor=rights\");\n    }\n\n    public boolean isInObjectEditMode()\n    {\n        return getDriver().getCurrentUrl().contains(\"editor=object\");\n    }\n\n    public boolean isInClassEditMode()\n    {\n        return getDriver().getCurrentUrl().contains(\"editor=class\");\n    }\n\n    public boolean isInDeleteMode()\n    {\n        return getDriver().getCurrentUrl().contains(\"/delete/\");\n    }\n\n    public boolean isInRenameMode()\n    {\n        return getDriver().getCurrentUrl().contains(\"xpage=rename\");\n    }\n\n    public boolean isInCreateMode()\n    {\n        return getDriver().getCurrentUrl().contains(\"/create/\");\n    }\n\n    public boolean isInAdminMode()\n    {\n        return getDriver().getCurrentUrl().contains(\"/admin/\");\n    }\n\n    /**\n     * Verify if the passed reference corresponds to the current page, independently of the wiki.\n     * Throws an {@link AssertionFailedError} if it's not the case.\n     *\n     * @param reference the reference to the document to check\n     * @since 12.2\n     */\n    public void assertOnPage(EntityReference reference)\n    {\n        if (EntityType.DOCUMENT.equals(reference.getType())) {\n            BasePage bp = new BasePage();\n            assertEquals(localReferenceSerializer.serialize(reference), bp.getMetaDataValue(\"document\"));\n        } else {\n            throw new IllegalArgumentException(\"You should pass a reference to a document\");\n        }\n    }\n\n    /**\n     * Forces the current user to be the Guest user by clearing all coookies.\n     */\n    public void forceGuestUser()\n    {\n        setSession(null);\n    }\n\n    public void addObject(String space, String page, String className, Object... properties)\n    {\n        gotoPage(space, page, \"objectadd\", toQueryParameters(className, null, properties));\n    }\n\n    /**\n     * @since 7.2RC1\n     */\n    public void addObject(EntityReference reference, String className, Object... properties)\n    {\n        gotoPage(reference, \"objectadd\", toQueryParameters(className, null, properties));\n    }\n\n    /**\n     * @since 7.3M2\n     */\n    public void addObject(EntityReference reference, String className, Map<String, ?> properties)\n    {\n        gotoPage(reference, \"objectadd\", toQueryParameters(className, null, properties));\n    }\n\n    public void addObject(String space, String page, String className, Map<String, ?> properties)\n    {\n        gotoPage(space, page, \"objectadd\", toQueryParameters(className, null, properties));\n    }\n\n    public void deleteObject(String space, String page, String className, int objectNumber) throws Exception\n    {\n        TestUtils.assertStatusCodes(\n            rest().executeDelete(ObjectResource.class, getCurrentWiki(), space, page, className, objectNumber), true,\n            STATUS_NO_CONTENT_NOT_FOUND);\n    }\n\n    public void updateObject(String space, String page, String className, int objectNumber, Map<String, ?> properties)\n    {\n        gotoPage(space, page, \"save\", toQueryParameters(className, objectNumber, properties));\n    }\n\n    public void updateObject(String space, String page, String className, int objectNumber, Object... properties)\n    {\n        updateObject(Collections.singletonList(space), page, className, objectNumber, properties);\n    }\n\n    /**\n     * @since 11.5RC1\n     * @since 11.3.1\n     */\n    public void updateObject(EntityReference entityReference, String className, int objectNumber,\n        Object... properties)\n    {\n        // TODO: would be even quicker using REST\n        Map<String, Object> queryParameters =\n            (Map<String, Object>) toQueryParameters(className, objectNumber, properties);\n\n        // Append the updateOrCreate objectPolicy since we always want this in our tests.\n        queryParameters.put(\"objectPolicy\", \"updateOrCreate\");\n\n        gotoPage(entityReference, \"save\", queryParameters);\n    }\n\n    /**\n     * @since 8.3RC1\n     */\n    public void updateObject(List<String> spaces, String page, String className, int objectNumber, Object... properties)\n    {\n        // TODO: would be even quicker using REST\n        Map<String, Object> queryParameters =\n            (Map<String, Object>) toQueryParameters(className, objectNumber, properties);\n\n        // Append the updateOrCreate objectPolicy since we always want this in our tests.\n        queryParameters.put(\"objectPolicy\", \"updateOrCreate\");\n\n        gotoPage(spaces, page, \"save\", queryParameters);\n    }\n\n    /**\n     * @since 11.3RC1\n     */\n    public void addClassProperty(EntityReference reference, String propertyName, String propertyType)\n    {\n        gotoPage(reference, \"propadd\", \"propname\", propertyName, \"proptype\", propertyType);\n    }\n\n    /**\n     * @since 11.3RC1\n     */\n    public void updateClassProperty(EntityReference reference, Object... queryParameters)\n    {\n        gotoPage(reference, \"propupdate\", queryParameters);\n    }\n\n    public void addClassProperty(String space, String page, String propertyName, String propertyType)\n    {\n        gotoPage(space, page, \"propadd\", \"propname\", propertyName, \"proptype\", propertyType);\n    }\n\n    /**\n     * @since 3.5M1\n     */\n    public String toQueryString(Object... queryParameters)\n    {\n        return toQueryString(toQueryParameters(queryParameters));\n    }\n\n    /**\n     * @since 3.5M1\n     */\n    public String toQueryString(Map<String, ?> queryParameters)\n    {\n        StringBuilder builder = new StringBuilder();\n\n        if (queryParameters != null) {\n            for (Map.Entry<String, ?> entry : queryParameters.entrySet()) {\n                addQueryStringEntry(builder, entry.getKey(), entry.getValue());\n                builder.append('&');\n            }\n        }\n\n        return builder.toString();\n    }\n\n    /**\n     * @since 3.2M1\n     */\n    public void addQueryStringEntry(StringBuilder builder, String key, Object value)\n    {\n        if (value != null) {\n            if (value instanceof Iterable) {\n                for (Object element : (Iterable<?>) value) {\n                    addQueryStringEntry(builder, key, element.toString());\n                    builder.append('&');\n                }\n            } else {\n                addQueryStringEntry(builder, key, value.toString());\n            }\n        } else {\n            addQueryStringEntry(builder, key, (String) null);\n        }\n    }\n\n    /**\n     * @since 3.2M1\n     */\n    public void addQueryStringEntry(StringBuilder builder, String key, String value)\n    {\n        builder.append(escapeURL(key));\n        if (value != null) {\n            builder.append('=');\n            builder.append(escapeURL(value));\n        }\n    }\n\n    /**\n     * @since 3.5M1\n     */\n    public Map<String, ?> toQueryParameters(Object... properties)\n    {\n        return toQueryParameters(null, null, properties);\n    }\n\n    public Map<String, ?> toQueryParameters(String className, Integer objectNumber, Object... properties)\n    {\n        Map<String, Object> queryParameters = new HashMap<String, Object>();\n\n        queryParameters.put(\"classname\", className);\n\n        for (int i = 0; i < properties.length; i += 2) {\n            int nextIndex = i + 1;\n            queryParameters.put(toQueryParameterKey(className, objectNumber, (String) properties[i]),\n                nextIndex < properties.length ? properties[nextIndex] : null);\n        }\n\n        return queryParameters;\n    }\n\n    public Map<String, ?> toQueryParameters(String className, Integer objectNumber, Map<String, ?> properties)\n    {\n        Map<String, Object> queryParameters = new HashMap<String, Object>();\n\n        if (className != null) {\n            queryParameters.put(\"classname\", className);\n        }\n\n        for (Map.Entry<String, ?> entry : properties.entrySet()) {\n            queryParameters.put(toQueryParameterKey(className, objectNumber, entry.getKey()), entry.getValue());\n        }\n\n        return queryParameters;\n    }\n\n    public String toQueryParameterKey(String className, Integer objectNumber, String key)\n    {\n        if (className == null) {\n            return key;\n        } else {\n            StringBuilder keyBuilder = new StringBuilder(className);\n\n            keyBuilder.append('_');\n\n            if (objectNumber != null) {\n                keyBuilder.append(objectNumber);\n                keyBuilder.append('_');\n            }\n\n            keyBuilder.append(key);\n\n            return keyBuilder.toString();\n        }\n    }\n\n    public ObjectEditPage editObjects(String space, String page)\n    {\n        gotoPage(space, page, \"edit\", \"editor=object\");\n        return new ObjectEditPage();\n    }\n\n    public ClassEditPage editClass(String space, String page)\n    {\n        gotoPage(space, page, \"edit\", \"editor=class\");\n        return new ClassEditPage();\n    }\n\n    /**\n     * Goes to a page in edit class mode.\n     *\n     * @param reference a document reference\n     * @return the {@link ClassEditPage} Page Object for the page\n     * @since 14.0RC1\n     */\n    public ClassEditPage editClass(DocumentReference reference)\n    {\n        gotoPage(reference, \"edit\", \"editor=class\");\n        return new ClassEditPage();\n    }\n\n    public String getVersion() throws Exception\n    {\n        Xwiki xwiki = rest().getResource(\"\", null);\n\n        return xwiki.getVersion();\n    }\n\n    public String getMavenVersion() throws Exception\n    {\n        String version = getVersion();\n\n        int index = version.indexOf('-');\n        if (index > 0) {\n            version = version.substring(0, index) + \"-SNAPSHOT\";\n        }\n\n        return version;\n    }\n\n    public void attachFile(String space, String page, String name, File file, boolean failIfExists) throws Exception\n    {\n        InputStream is = new FileInputStream(file);\n        try {\n            attachFile(space, page, name, is, failIfExists);\n        } finally {\n            is.close();\n        }\n    }\n\n    /**\n     * @since 5.1M2\n     */\n    public void attachFile(String space, String page, String name, InputStream is, boolean failIfExists,\n        UsernamePasswordCredentials credentials) throws Exception\n    {\n        attachFile(Collections.singletonList(space), page, name, is, failIfExists, credentials);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void attachFile(List<String> spaces, String page, String name, InputStream is, boolean failIfExists,\n        UsernamePasswordCredentials credentials) throws Exception\n    {\n        UsernamePasswordCredentials currentCredentials = getDefaultCredentials();\n\n        try {\n            if (credentials != null) {\n                setDefaultCredentials(credentials);\n            }\n            attachFile(spaces, page, name, is, failIfExists);\n        } finally {\n            setDefaultCredentials(currentCredentials);\n        }\n    }\n\n    public void attachFile(String space, String page, String name, InputStream is, boolean failIfExists)\n        throws Exception\n    {\n        attachFile(Collections.singletonList(space), page, name, is, failIfExists);\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void attachFile(List<String> spaces, String page, String name, InputStream is, boolean failIfExists)\n        throws Exception\n    {\n        AttachmentReference reference =\n            new AttachmentReference(name, new DocumentReference(getCurrentWiki(), spaces, page));\n\n        attachFile(reference, is, failIfExists);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public void attachFile(EntityReference pageReference, String name, InputStream is, boolean failIfExists)\n        throws Exception\n    {\n        EntityReference reference = new EntityReference(name, EntityType.ATTACHMENT, pageReference);\n\n        attachFile(reference, is, failIfExists);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public void attachFile(EntityReference reference, Object is, boolean failIfExists) throws Exception\n    {\n        rest().attachFile(reference, is, failIfExists);\n    }\n\n    /**\n     * @since 12.2\n     */\n    public void attachFile(EntityReference pageReference, String name, InputStream is, boolean failIfExists,\n        UsernamePasswordCredentials credentials) throws Exception\n    {\n        UsernamePasswordCredentials currentCredentials = getDefaultCredentials();\n        EntityReference reference = new EntityReference(name, EntityType.ATTACHMENT, pageReference);\n\n        try {\n            if (credentials != null) {\n                setDefaultCredentials(credentials);\n            }\n            attachFile(reference, is, failIfExists);\n        } finally {\n            if (credentials != null) {\n                setDefaultCredentials(currentCredentials);\n            }\n        }\n    }\n\n    public void deleteAttachement(EntityReference pageReference, String filename) throws Exception\n    {\n        EntityReference reference = new EntityReference(filename, EntityType.ATTACHMENT, pageReference);\n        deleteAttachement(reference);\n    }\n\n    public void deleteAttachement(EntityReference reference) throws Exception\n    {\n        rest().deleteAttachement(reference);\n    }\n\n    // FIXME: improve that with a REST API to directly import a XAR\n    public void importXar(File file) throws Exception\n    {\n        // attach file\n        attachFile(\"XWiki\", \"Import\", file.getName(), file, false);\n\n        // import file\n        executeGet(\n            getBaseBinURL() + \"import/XWiki/Import?historyStrategy=add&importAsBackup=true&ajax&action=import&name=\"\n                + escapeURL(file.getName()),\n            Status.OK.getStatusCode());\n    }\n\n    /**\n     * Delete the latest version from the history of a page, using the {@code /deleteversions/} action.\n     *\n     * @param space the space name of the page\n     * @param page the name of the page\n     * @since 7.0M2\n     */\n    public void deleteLatestVersion(String space, String page)\n    {\n        deleteVersion(space, page, \"latest\");\n    }\n\n    /**\n     * Delete a specific version from the history of a page, using the {@code /deleteversions/} action.\n     *\n     * @param space the space name of the page\n     * @param page the name of the page\n     * @param version the version to delete\n     * @since 7.0M2\n     */\n    public void deleteVersion(String space, String page, String version)\n    {\n        deleteVersions(space, page, version, version);\n    }\n\n    /**\n     * Delete an interval of versions from the history of a page, using the {@code /deleteversions/} action.\n     *\n     * @param space the space name of the page\n     * @param page the name of the page\n     * @param v1 the starting version to delete\n     * @param v2 the ending version to delete\n     * @since 7.0M2\n     */\n    public void deleteVersions(String space, String page, String v1, String v2)\n    {\n        gotoPage(space, page, \"deleteversions\", \"rev1\", v1, \"rev2\", v2, \"confirm\", \"1\");\n    }\n\n    /**\n     * Roll back a page to the previous version, using the {@code /rollback/} action.\n     *\n     * @param space the space name of the page\n     * @param page the name of the page\n     * @since 7.0M2\n     */\n    public void rollbackToPreviousVersion(String space, String page)\n    {\n        rollBackTo(space, page, \"previous\");\n    }\n\n    /**\n     * Roll back a page to the specified version, using the {@code /rollback/} action.\n     *\n     * @param space the space name of the page\n     * @param page the name of the page\n     * @param version the version to rollback to\n     * @since 7.0M2\n     */\n    public void rollBackTo(String space, String page, String version)\n    {\n        gotoPage(space, page, \"rollback\", \"rev\", version, \"confirm\", \"1\");\n    }\n\n    /**\n     * Set the hierarchy mode used in the wiki\n     *\n     * @param mode the mode to use (\"reference\" or \"parentchild\")\n     * @since 7.2M2\n     */\n    public void setHierarchyMode(String mode)\n    {\n        setPropertyInXWikiPreferences(\"core.hierarchyMode\", \"String\", mode);\n    }\n\n    /**\n     * Add and set a property into XWiki.XWikiPreferences. Create XWiki.XWikiPreferences if it does not exist.\n     *\n     * @param propertyName name of the property to set\n     * @param propertyType the type of the property to add\n     * @param value value to set to the property\n     * @since 7.2M2\n     */\n    public void setPropertyInXWikiPreferences(String propertyName, String propertyType, Object value)\n    {\n        addClassProperty(\"XWiki\", \"XWikiPreferences\", propertyName, propertyType);\n        gotoPage(\"XWiki\", \"XWikiPreferences\", \"edit\", \"editor\", \"object\");\n        ObjectEditPage objectEditPage = new ObjectEditPage();\n        if (objectEditPage.hasObject(\"XWiki.XWikiPreferences\")) {\n            updateObject(\"XWiki\", \"XWikiPreferences\", \"XWiki.XWikiPreferences\", 0, propertyName, value);\n        } else {\n            addObject(\"XWiki\", \"XWikiPreferences\", \"XWiki.XWikiPreferences\", propertyName, value);\n        }\n    }\n\n    /**\n     * Set global xwiki configuration options (as if the xwiki.cfg file had been modified). This is useful for testing\n     * configuration options.\n     *\n     * @param configuration the configuration in {@link Properties} format. For example \"param1=value2\\nparam2=value2\"\n     * @throws IOException if an error occurs while parsing the configuration\n     */\n    public void setPropertyInXWikiCfg(String configuration) throws IOException\n    {\n        Properties properties = new Properties();\n        properties.load(new ByteArrayInputStream(configuration.getBytes()));\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(\"{{velocity}}\\n\"\n                + \"#set($config = $!services.component.getInstance(\\\"org.xwiki.configuration.\"\n                + \"ConfigurationSource\\\", \\\"xwikicfg\\\"))\\n\"\n                + \"#set($props = $config.getProperties())\\n\");\n\n            // Since we don't have access to the XWiki object from Selenium tests and since we don't want to restart XWiki\n        // with a different xwiki.cfg file for each test that requires a configuration change, we use the following\n        // trick: We create a document and we access the XWiki object with a Velocity script inside that document.\n        for (Map.Entry<Object, Object> param : properties.entrySet()) {\n            sb.append(\"#set($discard = $props.put('\").append(param.getKey()).append(\"', '\")\n                .append(param.getValue()).append(\"'))\\n\");\n        }\n        sb.append(\"#set($discard = $config.set($props))\\n\"\n            + \"{{/velocity}}\");\n        createPage(\"Test\", \"XWikiConfigurationPageForTest\", sb.toString(), \"Test page to change xwiki.cfg\");\n    }\n\n    /**\n     * Sets the value of an existing property of XWiki.XWikiPreferences.\n     *\n     * @param propertyName name of the property to set\n     * @param value value to set to the property\n     * @return the previous value, if the property was set, {@code null} otherwise\n     * @since 9.7RC1\n     */\n    public String setWikiPreference(String propertyName, String value) throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(getCurrentWiki(), \"XWiki\", \"XWikiPreferences\");\n        ObjectReference objectReference = new ObjectReference(\"XWiki.XWikiPreferences[0]\", documentReference);\n\n        Property property = RestTestUtils.property(propertyName, value);\n\n        org.xwiki.rest.model.jaxb.Object preferenceObject = rest().get(objectReference, false);\n        String previousValue = null;\n\n        if (preferenceObject == null) {\n            // The object does not exist, create it\n\n            preferenceObject = RestTestUtils.object(\"XWiki.XWikiPreferences\");\n            preferenceObject.withProperties(property);\n\n            TestUtils.assertStatusCodes(\n                rest().executePost(ObjectsResource.class, preferenceObject, rest().toElements(documentReference)), true,\n                STATUS_CREATED);\n        } else {\n            // The object exist just set the property (faster than updating the whole object)\n            ObjectPropertyReference propertyReference = new ObjectPropertyReference(propertyName, objectReference);\n\n            TestUtils.assertStatusCodes(\n                rest().executePut(ObjectPropertyResource.class, property, rest().toElements(propertyReference)), true,\n                STATUS_ACCEPTED);\n\n            Property unsetProperty = RestTestUtils.property(propertyName, null);\n            previousValue =\n                preferenceObject.getProperties().stream().filter(prop -> Objects.equals(propertyName, prop.getName()))\n                    .findFirst().orElse(unsetProperty).getValue();\n        }\n\n        return previousValue;\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public static void assertStatuses(int actualCode, int... expectedCodes)\n    {\n        if (!ArrayUtils.contains(expectedCodes, actualCode)) {\n            fail(String.format(\"Unexpected code [%s], was expecting one of [%s]\",\n                actualCode, Arrays.toString(expectedCodes)));\n        }\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    public static <M extends HttpMethod> M assertStatusCodes(M method, boolean release, int... expectedCodes)\n        throws Exception\n    {\n        if (expectedCodes.length > 0) {\n            int actualCode = method.getStatusCode();\n\n            if (!ArrayUtils.contains(expectedCodes, actualCode)) {\n                if (actualCode == Status.INTERNAL_SERVER_ERROR.getStatusCode()) {\n                    String message;\n                    try {\n                        message = method.getResponseBodyAsString();\n                    } catch (IOException e) {\n                        message = \"\";\n                    }\n\n                    fail(String.format(\"Unexpected internal server error with message [%s] for [%s]\",\n                        message, method.getURI()));\n                } else {\n                    fail(String.format(\"Unexpected code [%s], was expecting one of [%s] for [%s]\",\n                        actualCode, Arrays.toString(expectedCodes), method.getURI()));\n                }\n            }\n        }\n\n        if (release) {\n            method.releaseConnection();\n        }\n\n        return method;\n    }\n\n    // HTTP\n\n    /**\n     * Encodes a given string so that it may be used as a URL component. Compatible with javascript decodeURIComponent,\n     * though more strict than encodeURIComponent: all characters except [a-zA-Z0-9], '.', '-', '*', '_' are encoded.\n     * Uses the same algorithm than the one used to generate URLs as otherwise tests won't find the proper matches...\n     * See XWikiServletURLFactory#encodeWithinPath() and #encodeWithinQuery().\n     *\n     * @param url the url to encode\n     */\n    public String escapeURL(String url)\n    {\n        String encodedURL;\n        try {\n            encodedURL = URLEncoder.encode(url, \"UTF-8\");\n        } catch (Exception e) {\n            // Should not happen (UTF-8 is always available)\n            throw new RuntimeException(\"Missing charset [UTF-8]\", e);\n        }\n\n        // The previous call will convert \" \" into \"+\" (and \"+\" into \"%2B\") so we need to convert \"+\" into \"%20\"\n        // It's ok since %20 is allowed in both the URL path and the query string (and anchor).\n        encodedURL = encodedURL.replaceAll(\"\\\\+\", \"%20\");\n\n        return encodedURL;\n    }\n\n    /**\n     * Usage example:\n     * \n     * <pre>\n     * {@code\n     * By.xpath(\"//a[. = \" + escapeXPath(value) + \"]\")\n     * }\n     * </pre>\n     * \n     * @param value the value to escape\n     * @return the escaped value\n     */\n    public String escapeXPath(String value)\n    {\n        return \"concat('\" + value.replace(\"'\", \"', \\\"'\\\", '\") + \"', '')\";\n    }\n\n    public InputStream getInputStream(String path, Map<String, ?> queryParams) throws Exception\n    {\n        return getInputStream(getBaseURL(), path, queryParams);\n    }\n\n    public String getString(String path, Map<String, ?> queryParams) throws Exception\n    {\n        return getString(getBaseURL(), path, queryParams);\n    }\n\n    /**\n     * Extended version to work in a docker context.\n     *\n     * @param baseURL the base url\n     * @param path an additional path added after the base url\n     * @param queryParams additional query parameter added to the computed url\n     * @return the context of the computed url\n     * @throws Exception in case of error when executing the request\n     */\n    public String getString(String baseURL, String path, Map<String, ?> queryParams) throws Exception\n    {\n        try (InputStream inputStream = getInputStream(baseURL, path, queryParams)) {\n            return IOUtils.toString(inputStream);\n        }\n    }\n\n    public InputStream getInputStream(String prefix, String path, Map<String, ?> queryParams, Object... elements)\n        throws Exception\n    {\n        String cleanPrefix = prefix.endsWith(\"/\") ? prefix.substring(0, prefix.length() - 1) : prefix;\n        if (path.startsWith(cleanPrefix)) {\n            cleanPrefix = \"\";\n        }\n\n        UriBuilder builder = UriBuilder.fromUri(cleanPrefix).path(path.startsWith(\"/\") ? path.substring(1) : path);\n\n        if (queryParams != null) {\n            for (Map.Entry<String, ?> entry : queryParams.entrySet()) {\n                if (entry.getValue() instanceof Object[]) {\n                    builder.queryParam(entry.getKey(), (Object[]) entry.getValue());\n                } else {\n                    builder.queryParam(entry.getKey(), entry.getValue());\n                }\n            }\n        }\n\n        String url = builder.build(elements).toString();\n\n        return executeGet(url, Status.OK.getStatusCode()).getResponseBodyAsStream();\n    }\n\n    protected GetMethod executeGet(String uri) throws Exception\n    {\n        GetMethod getMethod = new GetMethod(uri);\n\n        this.httpClient.executeMethod(getMethod);\n\n        return getMethod;\n    }\n\n    protected GetMethod executeGet(String uri, int... expectedCodes) throws Exception\n    {\n        return executeGet(uri, false, expectedCodes);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    protected GetMethod executeGet(String uri, boolean release, int... expectedCodes) throws Exception\n    {\n        return assertStatusCodes(executeGet(uri), release, expectedCodes);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    protected PostMethod executePost(String uri, InputStream content, String mediaType) throws Exception\n    {\n        PostMethod postMethod = new PostMethod(uri);\n        RequestEntity entity = new InputStreamRequestEntity(content, mediaType);\n        postMethod.setRequestEntity(entity);\n\n        this.httpClient.executeMethod(postMethod);\n\n        return postMethod;\n    }\n\n    protected PostMethod executePost(String uri, InputStream content, String mediaType, int... expectedCodes)\n        throws Exception\n    {\n        return executePost(uri, content, mediaType, true, expectedCodes);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    protected PostMethod executePost(String uri, InputStream content, String mediaType, boolean release,\n        int... expectedCodes) throws Exception\n    {\n        return assertStatusCodes(executePost(uri, content, mediaType), false, expectedCodes);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    protected DeleteMethod executeDelete(String uri) throws Exception\n    {\n        DeleteMethod postMethod = new DeleteMethod(uri);\n\n        this.httpClient.executeMethod(postMethod);\n\n        return postMethod;\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    protected void executeDelete(String uri, int... expectedCodes) throws Exception\n    {\n        assertStatusCodes(executeDelete(uri), true, expectedCodes);\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    protected PutMethod executePut(String uri, InputStream content, String mediaType) throws Exception\n    {\n        PutMethod putMethod = new PutMethod(uri);\n        RequestEntity entity = new InputStreamRequestEntity(content, mediaType);\n        putMethod.setRequestEntity(entity);\n\n        this.httpClient.executeMethod(putMethod);\n\n        return putMethod;\n    }\n\n    protected void executePut(String uri, InputStream content, String mediaType, int... expectedCodes) throws Exception\n    {\n        executePut(uri, content, mediaType, true, expectedCodes);\n    }\n\n    protected PutMethod executePut(String uri, InputStream content, String mediaType, boolean release,\n        int... expectedCodes) throws Exception\n    {\n        return assertStatusCodes(executePut(uri, content, mediaType), release, expectedCodes);\n    }\n\n    // REST\n\n    public RestTestUtils rest()\n    {\n        return this.rest;\n    }\n\n    /**\n     * @since 7.3M1\n     */\n    // TODO: Refactor TestUtils to move RestTestUtils tools to xwiki-platform-test-integration\n    public static class RestTestUtils\n    {\n        public static final Boolean ELEMENTS_ENCODED = new Boolean(true);\n\n        public static final Map<EntityType, ResourceAPI> RESOURCES_MAP = new IdentityHashMap<>();\n\n        public static String urlPrefix;\n\n        public static class ResourceAPI\n        {\n            public Class<?> api;\n\n            public Class<?> localeAPI;\n\n            public ResourceAPI(Class<?> api, Class<?> localeAPI)\n            {\n                this.api = api;\n                this.localeAPI = localeAPI;\n            }\n        }\n\n        /**\n         * Used to match number part of the object reference name.\n         */\n        private static final Pattern OBJECT_NAME_PATTERN = Pattern.compile(\"(\\\\\\\\*)\\\\[(\\\\d*)\\\\]$\");\n\n        static {\n            try {\n                // Initialize REST related tools\n                JAXBContext jaxbContext = JAXBContext\n                    .newInstance(\"org.xwiki.rest.model.jaxb:org.xwiki.extension.repository.xwiki.model.jaxb\");\n                marshaller = jaxbContext.createMarshaller();\n                unmarshaller = jaxbContext.createUnmarshaller();\n            } catch (JAXBException e) {\n                throw new RuntimeException(e);\n            }\n\n            RESOURCES_MAP.put(EntityType.DOCUMENT, new ResourceAPI(PageResource.class, PageTranslationResource.class));\n            RESOURCES_MAP.put(EntityType.OBJECT, new ResourceAPI(ObjectResource.class, null));\n            RESOURCES_MAP.put(EntityType.OBJECT_PROPERTY, new ResourceAPI(ObjectPropertyResource.class, null));\n            RESOURCES_MAP.put(EntityType.CLASS_PROPERTY, new ResourceAPI(ClassPropertyResource.class, null));\n        }\n\n        /**\n         * @since 7.3M1\n         */\n        public static org.xwiki.rest.model.jaxb.Object object(String className)\n        {\n            org.xwiki.rest.model.jaxb.Object obj = new org.xwiki.rest.model.jaxb.Object();\n\n            obj.setClassName(className);\n\n            return obj;\n        }\n\n        /**\n         * @since 7.3M1\n         */\n        public static String toPropertyString(Object value)\n        {\n            String stringValue;\n\n            if (value instanceof Iterable) {\n                StringBuilder builder = new StringBuilder();\n                for (Object item : (Iterable) value) {\n                    if (builder.length() > 0) {\n                        builder.append('|');\n                    }\n\n                    builder.append(item);\n                }\n\n                stringValue = builder.toString();\n            } else if (value != null) {\n                stringValue = value.toString();\n            } else {\n                stringValue = null;\n            }\n\n            return stringValue;\n        }\n\n        /**\n         * @since 7.3M1\n         */\n        public static Property property(String name, Object value)\n        {\n            Property property = new Property();\n\n            property.setName(name);\n            property.setValue(toPropertyString(value));\n\n            return property;\n        }\n\n        private TestUtils testUtils;\n\n        public RestTestUtils(TestUtils testUtils)\n        {\n            this.testUtils = testUtils;\n        }\n\n        public String getBaseURL()\n        {\n            String prefix;\n            if (RestTestUtils.urlPrefix != null) {\n                prefix = RestTestUtils.urlPrefix;\n            } else {\n                prefix = this.testUtils.getBaseURL();\n            }\n            if (!prefix.endsWith(\"/\")) {\n                prefix = prefix + \"/\";\n            }\n            return prefix + \"rest\";\n        }\n\n        /**\n         * Used when running in a docker container for example and thus when we need a REST URL pointing to a host\n         * different than the TestUTils baseURL which is used inside the Selenium docker container and is thus\n         * different from a REST URL used outside of any container and that needs to call XWiki running inside a\n         * container... ;)\n         *\n         * @since 10.9\n         */\n        public void setURLPrefix(String newURLPrefix)\n        {\n            RestTestUtils.urlPrefix = newURLPrefix;\n        }\n\n        private String toSpaceElement(Iterable<?> spaces)\n        {\n            StringBuilder builder = new StringBuilder();\n\n            for (Object space : spaces) {\n                if (builder.length() > 0) {\n                    builder.append(\"/spaces/\");\n                }\n\n                if (space instanceof EntityReference) {\n                    builder.append(((EntityReference) space).getName());\n                } else {\n                    builder.append(space.toString());\n                }\n            }\n\n            return builder.toString();\n        }\n\n        private String toSpaceElement(String spaceReference)\n        {\n            return toSpaceElement(\n                relativeReferenceResolver.resolve(spaceReference, EntityType.SPACE).getReversedReferenceChain());\n        }\n\n        protected Object[] toElements(Page page)\n        {\n            List<Object> elements = new ArrayList<>();\n\n            // Add wiki\n            if (page.getWiki() != null) {\n                elements.add(page.getWiki());\n            } else {\n                elements.add(this.testUtils.getCurrentWiki());\n            }\n\n            // Add spaces\n            elements.add(toSpaceElement(page.getSpace()));\n\n            // Add name\n            elements.add(page.getName());\n\n            // Add translation\n            if (StringUtils.isNotEmpty(page.getLanguage())) {\n                elements.add(page.getLanguage());\n            }\n\n            return elements.toArray();\n        }\n\n        public Object[] toElements(org.xwiki.rest.model.jaxb.Object obj, boolean onlyDocument)\n        {\n            List<Object> elements = new ArrayList<>();\n\n            // Add wiki\n            if (obj.getWiki() != null) {\n                elements.add(obj.getWiki());\n            } else {\n                elements.add(this.testUtils.getCurrentWiki());\n            }\n\n            // Add spaces\n            elements.add(toSpaceElement(obj.getSpace()));\n\n            // Add name\n            elements.add(obj.getPageName());\n\n            if (!onlyDocument) {\n                // Add class\n                elements.add(obj.getClassName());\n\n                // Add number\n                elements.add(obj.getNumber());\n            }\n\n            return elements.toArray();\n        }\n\n        public Object[] toElements(EntityReference reference)\n        {\n            if (reference == null) {\n                return ArrayUtils.EMPTY_OBJECT_ARRAY;\n            }\n\n            List<EntityReference> references = reference.getReversedReferenceChain();\n\n            List<Object> elements = new ArrayList<>(references.size() + 2);\n\n            // Indicate that elements are already encoded\n            elements.add(ELEMENTS_ENCODED);\n\n            // Add current wiki if the reference does not contains any\n            if (reference.extractReference(EntityType.WIKI) == null) {\n                elements.add(this.testUtils.escapeURL(this.testUtils.getCurrentWiki()));\n            }\n\n            // Add reference\n            for (EntityReference ref : references) {\n                if (ref.getType() == EntityType.SPACE) {\n                    // The URI builder does not support multiple elements like space reference so we hack it by doing\n                    // the opposite of what is done when reading the URL (generate a value looking like\n                    // \"space1/spaces/space2\")\n                    Object value = elements.get(elements.size() - 1);\n\n                    StringBuilder builder;\n                    if (value instanceof StringBuilder) {\n                        builder = (StringBuilder) value;\n                        builder.append(\"/spaces/\");\n                    } else {\n                        builder = new StringBuilder();\n                        elements.add(builder);\n                    }\n\n                    builder.append(this.testUtils.escapeURL(ref.getName()));\n                } else if (ref.getType() == EntityType.OBJECT) {\n                    // The REST API is no in sync with the ObjectReference structure:\n                    // was is a unique name in ObjectReference is two separated class name and index in REST API\n                    String classReferenceStr;\n                    String objectNumberStr;\n\n                    Matcher matcher = OBJECT_NAME_PATTERN.matcher(ref.getName());\n                    if (matcher.find()) {\n                        if (matcher.group(1).length() % 2 == 0) {\n                            classReferenceStr = ref.getName().substring(0, matcher.end(1));\n                            objectNumberStr = matcher.group(2);\n                        } else {\n                            classReferenceStr = ref.getName();\n                            objectNumberStr = null;\n                        }\n                    } else {\n                        classReferenceStr = ref.getName();\n                        objectNumberStr = null;\n                    }\n\n                    elements.add(classReferenceStr);\n                    elements.add(objectNumberStr);\n                } else {\n                    elements.add(this.testUtils.escapeURL(ref.getName()));\n                }\n            }\n\n            // Add locale\n            Locale locale = getLocale(reference);\n            if (locale != null) {\n                elements.add(locale);\n            }\n\n            return elements.toArray();\n        }\n\n        /**\n         * Add or update.\n         */\n        public void save(Page page, int... expectedCodes) throws Exception\n        {\n            save(page, true, expectedCodes);\n        }\n\n        public EntityEnclosingMethod save(Page page, boolean release, int... expectedCodes) throws Exception\n        {\n            if (expectedCodes.length == 0) {\n                // Allow create or modify by default\n                expectedCodes = STATUS_CREATED_ACCEPTED;\n            }\n\n            Class resourceClass =\n                StringUtils.isEmpty(page.getLanguage()) ? PageResource.class : PageTranslationResource.class;\n\n            return TestUtils.assertStatusCodes(executePut(resourceClass, page, toElements(page)), release,\n                expectedCodes);\n        }\n\n        /**\n         * @since 7.3M1\n         */\n        public Page page(EntityReference reference)\n        {\n            Page page = new Page();\n\n            // Add current wiki if the reference does not contains any\n            EntityReference wikiReference = reference.extractReference(EntityType.WIKI);\n            if (wikiReference == null) {\n                page.setWiki(this.testUtils.getCurrentWiki());\n            } else {\n                page.setWiki(wikiReference.getName());\n            }\n\n            // Add spaces\n            EntityReference spaceReference = reference.extractReference(EntityType.SPACE).removeParent(wikiReference);\n            page.setSpace(referenceSerializer.serialize(spaceReference));\n\n            // Add page\n            EntityReference documentReference = reference.extractReference(EntityType.DOCUMENT);\n            page.setName(documentReference.getName());\n\n            // Add locale\n            if (reference instanceof AbstractLocalizedEntityReference) {\n                Locale locale = getLocale(reference);\n                if (locale != null) {\n                    page.setLanguage(locale.toString());\n                }\n            }\n\n            return page;\n        }\n\n        /**\n         * @since 9.8RC1\n         */\n        public org.xwiki.rest.model.jaxb.Object object(EntityReference parentReference, String className)\n        {\n            return object(parentReference, className, 0);\n        }\n\n        /**\n         * @since 9.8RC1\n         */\n        public org.xwiki.rest.model.jaxb.Object object(EntityReference parentReference, String className, int number)\n        {\n            org.xwiki.rest.model.jaxb.Object obj = new org.xwiki.rest.model.jaxb.Object();\n\n            // Add current wiki if the reference does not contains any\n            EntityReference wikiReference = parentReference.extractReference(EntityType.WIKI);\n            if (wikiReference == null) {\n                obj.setWiki(this.testUtils.getCurrentWiki());\n            } else {\n                obj.setWiki(wikiReference.getName());\n            }\n\n            // Add spaces\n            EntityReference spaceReference =\n                parentReference.extractReference(EntityType.SPACE).removeParent(wikiReference);\n            obj.setSpace(referenceSerializer.serialize(spaceReference));\n\n            // Add page\n            EntityReference documentReference = parentReference.extractReference(EntityType.DOCUMENT);\n            obj.setPageName(documentReference.getName());\n\n            // Add class reference\n            obj.setClassName(className);\n            // Add object number\n            obj.setNumber(number);\n\n            return obj;\n        }\n\n        /**\n         * @since 7.3M1\n         */\n        public void savePage(EntityReference reference) throws Exception\n        {\n            savePage(reference, null, null, null, null);\n        }\n\n        /**\n         * @since 7.3M1\n         */\n        public void savePage(EntityReference reference, String content, String title) throws Exception\n        {\n            savePage(reference, content, null, title, null);\n        }\n\n        /**\n         * @since 7.3M1\n         */\n        public void savePage(EntityReference reference, String content, String syntaxId, String title,\n            String parentFullPageName) throws Exception\n        {\n            Page page = page(reference);\n\n            if (content != null) {\n                page.setContent(content);\n            }\n            if (title != null) {\n                page.setTitle(title);\n            }\n            if (syntaxId != null) {\n                page.setSyntax(syntaxId);\n            }\n            if (parentFullPageName != null) {\n                page.setParent(parentFullPageName);\n            }\n\n            save(page, true);\n        }\n\n        /**\n         * Add a new object.\n         */\n        public void add(org.xwiki.rest.model.jaxb.Object obj) throws Exception\n        {\n            add(obj, true);\n        }\n\n        /**\n         * Add a new object.\n         */\n        public EntityEnclosingMethod add(org.xwiki.rest.model.jaxb.Object obj, boolean release) throws Exception\n        {\n            return TestUtils.assertStatusCodes(executePost(ObjectsResource.class, obj, toElements(obj, true)), release,\n                STATUS_CREATED);\n        }\n\n        /**\n         * Fail if the object does not exist.\n         */\n        public void update(org.xwiki.rest.model.jaxb.Object obj) throws Exception\n        {\n            update(obj, true);\n        }\n\n        /**\n         * Fail if the object does not exist.\n         */\n        public EntityEnclosingMethod update(org.xwiki.rest.model.jaxb.Object obj, boolean release) throws Exception\n        {\n            return TestUtils.assertStatusCodes(executePut(ObjectResource.class, obj, toElements(obj, false)), release,\n                STATUS_CREATED_ACCEPTED);\n        }\n\n        public void delete(EntityReference reference) throws Exception\n        {\n            Class<?> resource = getResourceAPI(reference);\n\n            TestUtils.assertStatusCodes(executeDelete(resource, toElements(reference)), true,\n                STATUS_NO_CONTENT_NOT_FOUND);\n        }\n\n        // TODO: make EntityReference#getParameter() public\n        private Locale getLocale(EntityReference reference)\n        {\n            if (reference instanceof AbstractLocalizedEntityReference) {\n                return ((AbstractLocalizedEntityReference) reference).getLocale();\n            }\n\n            return null;\n        }\n\n        public void deletePage(String space, String page) throws Exception\n        {\n            delete(new LocalDocumentReference(space, page));\n        }\n\n        /**\n         * @since 9.0RC1\n         */\n        public void deletePage(String space, String page, Locale locale) throws Exception\n        {\n            delete(new LocalDocumentReference(space, page, locale));\n        }\n\n        /**\n         * @since 8.0M1\n         */\n        public void attachFile(EntityReference reference, Object is, boolean failIfExists) throws Exception\n        {\n            // make sure the page exist\n            if (!exists(reference.getParent())) {\n                savePage(reference.getParent());\n            }\n\n            if (failIfExists) {\n                assertStatusCodes(executePut(AttachmentResource.class, is, toElements(reference)), true,\n                    STATUS_CREATED);\n            } else {\n                assertStatusCodes(executePut(AttachmentResource.class, is, toElements(reference)), true,\n                    STATUS_CREATED_ACCEPTED);\n            }\n        }\n\n        public void deleteAttachement(EntityReference reference) throws Exception\n        {\n            assertStatusCodes(executeDelete(AttachmentResource.class, toElements(reference)), true, STATUS_NO_CONTENT);\n        }\n\n        public boolean exists(EntityReference reference) throws Exception\n        {\n            GetMethod getMethod = executeGet(reference);\n\n            getMethod.releaseConnection();\n\n            return getMethod.getStatusCode() == Status.OK.getStatusCode();\n        }\n\n        /**\n         * Return object model of the passed reference. Fail if none could be found.\n         * \n         * @since 7.3\n         */\n        public <T> T get(EntityReference reference) throws Exception\n        {\n            return get(reference, true);\n        }\n\n        /**\n         * Return object model of the passed reference or null if none could be found.\n         * \n         * @since 8.0M1\n         */\n        public <T> T get(EntityReference reference, boolean failIfNotFound) throws Exception\n        {\n            Class<?> resource = getResourceAPI(reference);\n\n            return get(resource, reference, failIfNotFound);\n        }\n\n        /**\n         * @since 9.0RC1\n         */\n        public Class<?> getResourceAPI(EntityReference reference) throws Exception\n        {\n            ResourceAPI resource = RESOURCES_MAP.get(reference.getType());\n\n            if (resource == null) {\n                throw new Exception(\"Unsuported type [\" + reference.getType() + \"]\");\n            }\n\n            return getLocale(reference) != null ? resource.localeAPI : resource.api;\n        }\n\n        /**\n         * Return object model of the passed reference with the passed resource URI. Fail if none could be found.\n         * \n         * @since 8.0M1\n         */\n        public <T> T get(Object resourceURI, EntityReference reference) throws Exception\n        {\n            return get(resourceURI, reference, true);\n        }\n\n        /**\n         * Return object model of the passed reference with the passed resource URI or null if none could be found.\n         * \n         * @since 8.0M1\n         */\n        public <T> T get(Object resourceURI, EntityReference reference, boolean failIfNotFound) throws Exception\n        {\n            GetMethod getMethod = assertStatusCodes(executeGet(resourceURI, reference), false,\n                failIfNotFound ? STATUS_OK : STATUS_OK_NOT_FOUND);\n\n            if (getMethod.getStatusCode() == Status.NOT_FOUND.getStatusCode()) {\n                return null;\n            }\n\n            if (reference != null && reference.getType() == EntityType.ATTACHMENT) {\n                return (T) getMethod.getResponseBodyAsStream();\n            } else {\n                try {\n                    try (InputStream stream = getMethod.getResponseBodyAsStream()) {\n                        return toResource(stream);\n                    }\n                } finally {\n                    getMethod.releaseConnection();\n                }\n            }\n        }\n\n        public <T> T get(Object resourceURI, boolean failIfNotFound) throws Exception\n        {\n            return get(resourceURI, null, failIfNotFound);\n        }\n\n        public InputStream getInputStream(String resourceUri, Map<String, ?> queryParams, Object... elements)\n            throws Exception\n        {\n            return this.testUtils.getInputStream(getBaseURL(), resourceUri, queryParams, elements);\n        }\n\n        public InputStream postRESTInputStream(Object resourceUri, Object restObject, Object... elements)\n            throws Exception\n        {\n            return postInputStream(resourceUri, restObject, Collections.<String, Object[]>emptyMap(), elements);\n        }\n\n        public InputStream postInputStream(Object resourceUri, Object restObject, Map<String, Object[]> queryParams,\n            Object... elements) throws Exception\n        {\n            return executePost(resourceUri, restObject, queryParams, elements).getResponseBodyAsStream();\n        }\n\n        public <T> T toResource(InputStream is) throws JAXBException\n        {\n            return (T) unmarshaller.unmarshal(is);\n        }\n\n        protected InputStream toResourceInputStream(Object restObject) throws JAXBException\n        {\n            InputStream resourceStream;\n            if (restObject instanceof InputStream) {\n                resourceStream = (InputStream) restObject;\n            } else if (restObject instanceof byte[]) {\n                resourceStream = new ByteArrayInputStream((byte[]) restObject);\n            } else {\n                ByteArrayOutputStream stream = new ByteArrayOutputStream();\n                marshaller.marshal(restObject, stream);\n                resourceStream = new ByteArrayInputStream(stream.toByteArray());\n            }\n\n            return resourceStream;\n        }\n\n        /**\n         * @since 7.3\n         */\n        public GetMethod executeGet(EntityReference reference) throws Exception\n        {\n            Class<?> resource = getResourceAPI(reference);\n\n            return executeGet(resource, reference);\n        }\n\n        /**\n         * @since 8.0M1\n         */\n        public GetMethod executeGet(Object resourceURI, EntityReference reference) throws Exception\n        {\n            return executeGet(resourceURI, toElements(reference));\n        }\n\n        public GetMethod executeGet(Object resourceUri, Object... elements) throws Exception\n        {\n            return executeGet(resourceUri, Collections.<String, Object[]>emptyMap(), elements);\n        }\n\n        public GetMethod executeGet(Object resourceUri, Map<String, Object[]> queryParams, Object... elements)\n            throws Exception\n        {\n            // Build URI\n            String uri = createUri(resourceUri, queryParams, elements).toString();\n\n            return this.testUtils.executeGet(uri);\n        }\n\n        public PostMethod executePost(Object resourceUri, Object restObject, Object... elements) throws Exception\n        {\n            return executePost(resourceUri, restObject, Collections.<String, Object[]>emptyMap(), elements);\n        }\n\n        public PostMethod executePost(Object resourceUri, Object restObject, Map<String, Object[]> queryParams,\n            Object... elements) throws Exception\n        {\n            // Build URI\n            String uri = createUri(resourceUri, queryParams, elements).toString();\n\n            try (InputStream resourceStream = toResourceInputStream(restObject)) {\n                return this.testUtils.executePost(uri, resourceStream, MediaType.APPLICATION_XML);\n            }\n        }\n\n        public PutMethod executePut(Object resourceUri, Object restObject, Object... elements) throws Exception\n        {\n            return executePut(resourceUri, restObject, Collections.<String, Object[]>emptyMap(), elements);\n        }\n\n        public PutMethod executePut(Object resourceUri, Object restObject, Map<String, Object[]> queryParams,\n            Object... elements) throws Exception\n        {\n            // Build URI\n            String uri = createUri(resourceUri, queryParams, elements).toString();\n\n            try (InputStream resourceStream = toResourceInputStream(restObject)) {\n                return this.testUtils.executePut(uri, resourceStream, MediaType.APPLICATION_XML);\n            }\n        }\n\n        public DeleteMethod executeDelete(Object resourceUri, Object... elements) throws Exception\n        {\n            return executeDelete(resourceUri, Collections.<String, Object[]>emptyMap(), elements);\n        }\n\n        public DeleteMethod executeDelete(Object resourceUri, Map<String, Object[]> queryParams, Object... elements)\n            throws Exception\n        {\n            // Build URI\n            String uri = createUri(resourceUri, queryParams, elements).toString();\n\n            return this.testUtils.executeDelete(uri);\n        }\n\n        public URI createUri(Object resourceUri, Map<String, Object[]> queryParams, Object... elements)\n        {\n            if (resourceUri instanceof URI) {\n                return (URI) resourceUri;\n            }\n\n            // Create URI builder\n            UriBuilder builder = getUriBuilder(resourceUri, queryParams);\n\n            // Build URI\n            URI uri;\n            if (elements.length > 0 && elements[0] == ELEMENTS_ENCODED) {\n                uri = builder.buildFromEncoded(Arrays.copyOfRange(elements, 1, elements.length));\n            } else {\n                uri = builder.build(elements);\n            }\n\n            return uri;\n        }\n\n        public UriBuilder getUriBuilder(Object resourceUri, Map<String, Object[]> queryParams)\n        {\n            // Create URI builder\n            UriBuilder builder;\n            if (resourceUri instanceof Class) {\n                builder = getUriBuilder((Class) resourceUri);\n            } else {\n                String stringResourceUri = (String) resourceUri;\n                builder = UriBuilder.fromUri(getBaseURL().substring(0, getBaseURL().length() - 1))\n                    .path(!stringResourceUri.isEmpty() && stringResourceUri.charAt(0) == '/'\n                        ? stringResourceUri.substring(1) : stringResourceUri);\n            }\n\n            // Add query parameters\n            if (queryParams != null) {\n                for (Map.Entry<String, Object[]> entry : queryParams.entrySet()) {\n                    builder.queryParam(entry.getKey(), entry.getValue());\n                }\n            }\n\n            return builder;\n        }\n\n        protected UriBuilder getUriBuilder(Class<?> resource)\n        {\n            return UriBuilder.fromUri(getBaseURL()).path(resource);\n        }\n\n        public byte[] getBuffer(String resourceUri, Map<String, Object[]> queryParams, Object... elements)\n            throws Exception\n        {\n            InputStream is = getInputStream(resourceUri, queryParams, elements);\n\n            byte[] buffer;\n            try {\n                buffer = IOUtils.toByteArray(is);\n            } finally {\n                is.close();\n            }\n\n            return buffer;\n        }\n\n        public <T> T getResource(String resourceUri, Map<String, Object[]> queryParams, Object... elements)\n            throws Exception\n        {\n            T resource;\n            try (InputStream is = getInputStream(resourceUri, queryParams, elements)) {\n                resource = (T) unmarshaller.unmarshal(is);\n            }\n\n            return resource;\n        }\n\n        public static Property getProperty(String name, org.xwiki.rest.model.jaxb.Object preferencesObject,\n            boolean create)\n        {\n            for (Property property : preferencesObject.getProperties()) {\n                if (property.getName().equals(name)) {\n                    return property;\n                }\n            }\n\n            if (create) {\n                Property property = property(name, null);\n                preferencesObject.getProperties().add(property);\n\n                return property;\n            }\n\n            return null;\n        }\n    }\n\n    /**\n     * Disable Syntax Highlighting.\n     *\n     * @since 9.7RC1\n     */\n    public void disableSyntaxHighlighting() throws Exception\n    {\n        ObjectPropertyReference enabledPropertyReference =\n            new ObjectPropertyReference(\"enabled\", new ObjectReference(\"SyntaxHighlighting.ConfigurationClass[0]\",\n                new DocumentReference(getCurrentWiki(), \"SyntaxHighlighting\", \"Configuration\")));\n\n        Property property = new Property();\n        property.setValue(\"0\");\n\n        TestUtils.assertStatusCodes(\n            rest().executePut(ObjectPropertyResource.class, property, rest().toElements(enabledPropertyReference)),\n            true, STATUS_ACCEPTED);\n    }\n\n    /**\n     * @since 11.5RC1\n     */\n    public void switchTab(String tabHandle)\n    {\n        getDriver().switchTo().window(tabHandle);\n    }\n\n    /**\n     * @since 11.5RC1\n     */\n    public String getCurrentTabHandle()\n    {\n        return getDriver().getWindowHandle();\n    }\n\n    /**\n     * @since 11.5RC1\n     */\n    public String openLinkInTab(By by, String... existingTabHandles)\n    {\n        getDriver().findElement(by).sendKeys(Keys.chord(Keys.CONTROL, Keys.RETURN));\n\n        // It might take a bit of time for the driver to know there's another window.\n        getDriver().waitUntilCondition(input -> input.getWindowHandles().size() == existingTabHandles.length + 1);\n        Set<String> windowHandles = getDriver().getWrappedDriver().getWindowHandles();\n        String newTabHandle = null;\n        List<String> tabHandles = Arrays.asList(existingTabHandles);\n        for (String handle : windowHandles) {\n            if (!tabHandles.contains(handle)) {\n                newTabHandle = handle;\n                break;\n            }\n        }\n        return newTabHandle;\n    }\n\n    /**\n     * @since 11.5\n     * @since 11.6RC1\n     */\n    public void closeTab(String secondTabHandle)\n    {\n        String currentTab = getCurrentTabHandle();\n        switchTab(secondTabHandle);\n        getDriver().close();\n        switchTab(currentTab);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.test.ui.po;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.LocaleUtils;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.JavascriptExecutor;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.support.FindBy;\nimport org.openqa.selenium.support.FindBys;\nimport org.openqa.selenium.support.ui.ExpectedConditions;\nimport org.xwiki.test.ui.po.editor.ClassEditPage;\nimport org.xwiki.test.ui.po.editor.EditPage;\nimport org.xwiki.test.ui.po.editor.ObjectEditPage;\nimport org.xwiki.test.ui.po.editor.RightsEditPage;\nimport org.xwiki.test.ui.po.editor.WYSIWYGEditPage;\nimport org.xwiki.test.ui.po.editor.WikiEditPage;\n\n/**\n * Represents the common actions possible on all Pages.\n * \n * @version $Id$\n * @since 3.2M3\n */\npublic class BasePage extends BaseElement\n{\n    /**\n     * Used for sending keyboard shortcuts to.\n     */\n    @FindBy(id = \"xwikimaincontainer\")\n    private WebElement mainContainerDiv;\n\n    /**\n     * The top floating content menu bar.\n     */\n    @FindBy(id = \"contentmenu\")\n    private WebElement contentMenuBar;\n\n    @FindBy(xpath = \"//div[@id='tmCreate']/a[contains(@role, 'button')]\")\n    private WebElement tmCreate;\n\n    @FindBy(xpath = \"//div[@id='tmMoreActions']/a[contains(@role, 'button')]\")\n    private WebElement moreActionsMenu;\n\n    @FindBy(id = \"tmDrawerActivator\")\n    private WebElement drawerActivator;\n\n    @FindBy(xpath = \"//input[@id='tmWatchDocument']/../span[contains(@class, 'bootstrap-switch-label')]\")\n    private WebElement watchDocumentLink;\n\n    @FindBy(id = \"tmPage\")\n    private WebElement pageMenu;\n\n    @FindBys({@FindBy(id = \"tmRegister\"), @FindBy(tagName = \"a\")})\n    private WebElement registerLink;\n\n    @FindBy(xpath = \"//a[@id='tmLogin']\")\n    private WebElement loginLink;\n\n    @FindBy(xpath = \"//a[@id='tmUser']\")\n    private WebElement userLink;\n\n    @FindBy(xpath = \"//li[contains(@class, 'navbar-avatar')]//img[contains(@class, 'avatar')]\")\n    private WebElement userAvatarImage;\n\n    @FindBy(id = \"document-title\")\n    private WebElement documentTitle;\n\n    @FindBy(xpath = \"//input[@id='tmWatchSpace']/../span[contains(@class, 'bootstrap-switch-label')]\")\n    private WebElement watchSpaceLink;\n\n    @FindBy(xpath = \"//input[@id='tmWatchWiki']/../span[contains(@class, 'bootstrap-switch-label')]\")\n    private WebElement watchWikiLink;\n\n    @FindBy(css = \"#tmMoreActions a[title='Children']\")\n    private WebElement childrenLink;\n\n    @FindBy(id = \"tmNotifications\")\n    private WebElement notificationsMenu;\n\n    /**\n     * Used to scroll the page to the top before accessing the floating menu.\n     */\n    @FindBy(id = \"companylogo\")\n    protected WebElement logo;\n\n    /**\n     * Note: when reusing instances of BasePage, the constructor is not doing the work anymore and the\n     * {@link #waitUntilPageIsReady()} method needs to be executed manually, when needed.\n     * <p>\n     * Note2: Never call the constructor before navigating to the page you need to test first.\n     */\n    public BasePage()\n    {\n        super();\n        waitUntilPageIsReady();\n    }\n\n    public String getPageTitle()\n    {\n        return getDriver().getTitle();\n    }\n\n    // TODO I think this should be in the AbstractTest instead -cjdelisle\n    public String getPageURL()\n    {\n        return getDriver().getCurrentUrl();\n    }\n\n    /**\n     * @param metaName the name of the XWiki document metadata\n     * @return the value of the specified XWiki document metadata for the current XWiki document\n     * @see #getHTMLMetaDataValue(String)\n     */\n    public String getMetaDataValue(String metaName)\n    {\n        return getDriver().findElement(By.xpath(\"/html\")).getAttribute(\"data-xwiki-\" + metaName);\n    }\n\n    /**\n     * @param metaName the name of the HTML meta field\n     * @return the value of the requested HTML meta field with from the current page\n     * @since 7.2RC1\n     */\n    public String getHTMLMetaDataValue(String metaName)\n    {\n        return getDriver().findElement(By.xpath(\"//meta[@name='\" + metaName + \"']\")).getAttribute(\"content\");\n    }\n\n    /**\n     * @return true if we are currently logged in, false otherwise\n     */\n    public boolean isAuthenticated()\n    {\n        return getDriver().hasElementWithoutWaiting(By.id(\"tmUser\"));\n    }\n\n    /**\n     * Determine if the current page is a new document.\n     * \n     * @return true if the document is new, false otherwise\n     */\n    public boolean isNewDocument()\n    {\n        return (Boolean) ((JavascriptExecutor) getDriver()).executeScript(\"return XWiki.docisnew\");\n    }\n\n    /**\n     * Perform a click on a \"edit menu\" sub-menu entry.\n     *\n     * @param id The id of the entry to follow\n     */\n    protected void clickEditSubMenuEntry(String id)\n    {\n        clickSubMenuEntryFromMenu(By.xpath(\"//div[@id='tmEdit']/*[contains(@class, 'dropdown-toggle')]\"), id);\n    }\n\n    /**\n     * Performs a click on the \"edit\" button.\n     */\n    public void edit()\n    {\n        WebElement editMenuButton =\n            getDriver().findElement(By.xpath(\"//div[@id='tmEdit']/a[contains(@role, 'button')]\"));\n        editMenuButton.click();\n    }\n\n    /**\n     * Gets a string representation of the URL for editing the page.\n     */\n    public String getEditURL()\n    {\n        return getDriver().findElement(By.xpath(\"//div[@id='tmEdit']//a\")).getAttribute(\"href\");\n    }\n\n    /**\n     * Performs a click on the \"edit wiki\" entry of the content menu.\n     */\n    public WikiEditPage editWiki()\n    {\n        clickEditSubMenuEntry(\"tmEditWiki\");\n        return new WikiEditPage();\n    }\n\n    /**\n     * Performs a click on the \"edit wysiwyg\" entry of the content menu.\n     */\n    public WYSIWYGEditPage editWYSIWYG()\n    {\n        clickEditSubMenuEntry(\"tmEditWysiwyg\");\n        return new WYSIWYGEditPage();\n    }\n\n    /**\n     * Performs a click on the \"edit inline\" entry of the content menu.\n     */\n    public <T extends InlinePage> T editInline()\n    {\n        clickEditSubMenuEntry(\"tmEditInline\");\n        return createInlinePage();\n    }\n\n    /**\n     * Can be overridden to return extended {@link InlinePage}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected <T extends InlinePage> T createInlinePage()\n    {\n        return (T) new InlinePage();\n    }\n\n    /**\n     * Performs a click on the \"edit acces rights\" entry of the content menu.\n     */\n    public RightsEditPage editRights()\n    {\n        clickEditSubMenuEntry(\"tmEditRights\");\n        return new RightsEditPage();\n    }\n\n    /**\n     * Performs a click on the \"edit objects\" entry of the content menu.\n     */\n    public ObjectEditPage editObjects()\n    {\n        clickEditSubMenuEntry(\"tmEditObject\");\n        return new ObjectEditPage();\n    }\n\n    /**\n     * Performs a click on the \"edit class\" entry of the content menu.\n     */\n    public ClassEditPage editClass()\n    {\n        clickEditSubMenuEntry(\"tmEditClass\");\n        return new ClassEditPage();\n    }\n\n    /**\n     * @since 3.2M3\n     */\n    public void sendKeys(CharSequence... keys)\n    {\n        this.mainContainerDiv.sendKeys(keys);\n    }\n\n    /**\n     * Refresh the page and wait for the javascript to be also loaded.\n     *\n     * @since 14.1\n     */\n    public BasePage reloadPage()\n    {\n        getDriver().navigate().refresh();\n        waitUntilPageIsReady();\n        return this;\n    }\n\n    /**\n     * @since 7.2M3\n     */\n    public void toggleDrawer()\n    {\n        if (isDrawerVisible()) {\n            hideDrawer();\n        } else {\n            showDrawer();\n        }\n    }\n\n    /**\n     * @return true if the drawer used to be hidden\n     * @since 8.4.5\n     * @since 9.0RC1\n     */\n    public boolean showDrawer()\n    {\n        if (!isDrawerVisible()) {\n            // Open the drawer.\n            this.drawerActivator.click();\n            waitForDrawer(true);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @return true if the drawer used to be displayed\n     * @since 8.4.5\n     * @since 9.0RC1\n     */\n    public boolean hideDrawer()\n    {\n        if (isDrawerVisible()) {\n            // Close the drawer by clicking outside.\n            // We don't perform directly a click since it could lead to a\n            // org.openqa.selenium.ElementClickInterceptedException because of a drawer-overlay above it.\n            // The click through action is performed with a move and click, which is what we really want.\n            getDriver().createActions().click(this.mainContainerDiv).perform();\n            waitForDrawer(false);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    private void waitForDrawer(boolean visible)\n    {\n        getDriver().waitUntilCondition(\n            ExpectedConditions.attributeToBe(this.drawerActivator, \"aria-expanded\", String.valueOf(visible)));\n    }\n\n    /**\n     * @since 8.4.5\n     * @since 9.0RC1\n     */\n    public boolean isDrawerVisible()\n    {\n        return \"true\".equals(this.drawerActivator.getAttribute(\"aria-expanded\"));\n    }\n\n    /**\n     * @since 7.2M3\n     */\n    public void toggleActionMenu()\n    {\n        this.moreActionsMenu.click();\n    }\n\n    /**\n     * @since 7.0RC1\n     */\n    public void clickMoreActionsSubMenuEntry(String id)\n    {\n        clickSubMenuEntryFromMenu(By.xpath(\"//div[@id='tmMoreActions']/a[contains(@role, 'button')]\"), id);\n    }\n\n    /**\n     * @since 7.3M2\n     * @deprecated use {@link #clickMoreActionsSubMenuEntry(String)} instead which has a better name\n     */\n    @Deprecated\n    public void clickAdminActionsSubMenuEntry(String id)\n    {\n        clickMoreActionsSubMenuEntry(id);\n    }\n\n    /**\n     * @since 7.0RC1\n     */\n    private void clickSubMenuEntryFromMenu(By menuBy, String id)\n    {\n        // Open the parent Menu\n        getDriver().findElement(menuBy).click();\n        // Wait for the submenu entry to be visible\n        getDriver().waitUntilElementIsVisible(By.id(id));\n        // Click on the specified entry\n        getDriver().findElement(By.id(id)).click();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public CreatePagePage createPage()\n    {\n        this.tmCreate.click();\n        return new CreatePagePage();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public CopyPage copy()\n    {\n        clickMoreActionsSubMenuEntry(\"tmActionCopy\");\n        return new CopyPage();\n    }\n\n    public RenamePage rename()\n    {\n        clickMoreActionsSubMenuEntry(\"tmActionRename\");\n        return new RenamePage();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public ConfirmationPage delete()\n    {\n        clickMoreActionsSubMenuEntry(\"tmActionDelete\");\n        return new ConfirmationPage();\n    }\n\n    /**\n     * Specific delete action when the delete action is performed on a page.\n     *\n     * @return a specialized confirmation page for page deletion\n     * @since 12.8RC1\n     */\n    public DeletePageConfirmationPage deletePage()\n    {\n        clickMoreActionsSubMenuEntry(\"tmActionDelete\");\n        return new DeletePageConfirmationPage();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public boolean canDelete()\n    {\n        toggleActionMenu();\n        // Don't wait here since test can use this method to verify that there's no Delete right on the current page\n        // and calling hasElement() would incurr the wait timeout.\n        boolean canDelete = getDriver().hasElementWithoutWaiting(By.id(\"tmActionDelete\"));\n        toggleActionMenu();\n        return canDelete;\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public void watchDocument()\n    {\n        toggleNotificationsMenu();\n        this.watchDocumentLink.click();\n        toggleActionMenu();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public boolean hasLoginLink()\n    {\n        // Note that we cannot test if the loginLink field is accessible since we're using an AjaxElementLocatorFactory\n        // and thus it would wait 15 seconds before considering it's not accessible.\n        return !getDriver().findElementsWithoutWaiting(By.id(\"tmLogin\")).isEmpty();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public LoginPage login()\n    {\n        toggleDrawer();\n        this.loginLink.click();\n        return new LoginPage();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public String getCurrentUser()\n    {\n        // We need to show the drawer because #getText() does not allow getting hidden text (but allow finding the\n        // element and its attributes...)\n        boolean hide = showDrawer();\n\n        String user = this.userLink.getText();\n\n        if (hide) {\n            hideDrawer();\n        }\n\n        return user;\n    }\n\n    /**\n     * @since 9.0RC1\n     */\n    public List<Locale> getLocales()\n    {\n        List<WebElement> elements =\n            getDriver().findElementsWithoutWaiting(By.xpath(\"//ul[@id='tmLanguages_menu']/li/a\"));\n        List<Locale> locales = new ArrayList<>(elements.size());\n        for (WebElement element : elements) {\n            String href = element.getAttribute(\"href\");\n            Matcher matcher = Pattern.compile(\".*\\\\?.*language=([^=&]*)\").matcher(href);\n            if (matcher.matches()) {\n                String locale = matcher.group(1);\n                locales.add(LocaleUtils.toLocale(locale));\n            }\n        }\n\n        return locales;\n    }\n\n    /**\n     * @since 9.0RC1\n     */\n    public ViewPage clickLocale(Locale locale)\n    {\n        // Open drawer\n        toggleDrawer();\n\n        // Open Languages\n        WebElement languagesElement = getDriver().findElementWithoutWaiting(By.xpath(\"//a[@id='tmLanguages']\"));\n        languagesElement.click();\n\n        // Wait for the languages submenu to be open\n        getDriver().waitUntilCondition(webDriver -> getDriver().findElementWithoutWaiting(By.id(\"tmLanguages_menu\"))\n            .getAttribute(\"class\").contains(\"collapse in\"));\n\n        // Click passed locale\n        WebElement localeElement = getDriver().findElementWithoutWaiting(\n            By.xpath(\"//ul[@id='tmLanguages_menu']/li/a[contains(@href,'language=\" + locale + \"')]\"));\n        localeElement.click();\n\n        return new ViewPage();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public void logout()\n    {\n        toggleDrawer();\n        getDriver().findElement(By.id(\"tmLogout\")).click();\n        // Update the CSRF token because the context user has changed (it's guest user now). Otherwise, APIs like\n        // TestUtils#createUser*(), which expect the currently cached token to be valid, will fail because they would be\n        // using the token of the previously logged in user.\n        getUtil().recacheSecretToken();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public RegistrationPage register()\n    {\n        toggleDrawer();\n        this.registerLink.click();\n        return new RegistrationPage();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public String getDocumentTitle()\n    {\n        return this.documentTitle.getText();\n    }\n\n    /**\n     * @since 4.5M1\n     */\n    public void watchSpace()\n    {\n        toggleNotificationsMenu();\n        this.watchSpaceLink.click();\n        toggleNotificationsMenu();\n    }\n\n    /**\n     * @since 6.0M1\n     */\n    public void watchWiki()\n    {\n        toggleNotificationsMenu();\n        this.watchWikiLink.click();\n        toggleNotificationsMenu();\n    }\n\n    /**\n     * Opens the viewer that lists the children of the current page.\n     * \n     * @return the viewer that lists the child pages\n     * @since 7.3RC1\n     */\n    public ChildrenViewer viewChildren()\n    {\n        toggleActionMenu();\n        this.childrenLink.click();\n        return new ChildrenViewer();\n    }\n\n    /**\n     * Says if the notifications menu is present (it is displayed only if it has some content).\n     * \n     * @return either or not the notifications menu is present\n     * @since 7.4M1\n     */\n    public boolean hasNotificationsMenu()\n    {\n        return getDriver().hasElementWithoutWaiting(By.id(\"tmNotifications\"));\n    }\n\n    /**\n     * Open/Close the notifications menu.\n     * \n     * @since 7.4M1\n     */\n    public void toggleNotificationsMenu()\n    {\n        boolean hasMenu = isNotificationsMenuOpen();\n        this.notificationsMenu.click();\n        if (hasMenu) {\n            getDriver().waitUntilElementDisappears(this.notificationsMenu, By.className(\"dropdown-menu\"));\n        } else {\n            getDriver().waitUntilElementIsVisible(this.notificationsMenu, By.className(\"dropdown-menu\"));\n        }\n    }\n\n    /**\n     * @return true if the notifications menu is open\n     * @since 7.4M1\n     */\n    public boolean isNotificationsMenuOpen()\n    {\n        return this.notificationsMenu.findElement(By.className(\"dropdown-menu\")).isDisplayed();\n    }\n\n    /**\n     * @return the text of uncaught errors\n     * @since 8.0M1\n     */\n    public String getErrorContent()\n    {\n        return getDriver()\n            .findElementWithoutWaiting(By.xpath(\"//div[@id = 'mainContentArea']/pre[contains(@class, 'xwikierror')]\"))\n            .getText();\n    }\n\n    /**\n     * @param panelTitle the panel displayed title\n     * @return true if the panel is visible in the left panels or false otherwise\n     * @since 10.6RC1\n     */\n    public boolean hasLeftPanel(String panelTitle)\n    {\n        return getDriver().hasElementWithoutWaiting(\n            By.xpath(\"//div[@id = 'leftPanels']/div/h1[@class = 'xwikipaneltitle' and text() = '\" + panelTitle + \"']\"));\n    }\n\n    public boolean isForbidden()\n    {\n        List<WebElement> messages = getDriver().findElementsWithoutWaiting(By.className(\"xwikimessage\"));\n        for (WebElement message : messages) {\n            if (message.getText().contains(\"You are not allowed to view this page or perform this action.\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @return the full text of an {@code xwikimessage} box displayed in the full content (e.g. in case of error).\n     * @since 15.1RC1\n     * @since 14.10.6\n     */\n    public String getXWikiMessageContent()\n    {\n        return getDriver()\n            .findElementWithoutWaiting(By.xpath(\"//div[@id = 'mainContentArea']/div[contains(@class, 'xwikimessage')]\"))\n            .getText();\n    }\n\n    /**\n     * Use the following keyboard shortcut and wait for a new page to load. This should be only used for shortcuts that\n     * indeed loads a new page.\n     * \n     * @param shortcut the keyboard key combination to perform.\n     */\n    private void useShortcutKeyAndLoads(CharSequence... shortcut)\n    {\n        getDriver().addPageNotYetReloadedMarker();\n        getDriver().createActions().sendKeys(shortcut).perform();\n        getDriver().waitUntilPageIsReloaded();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to edit page.\n     * \n     * @return a new {@link EditPage}\n     * @since 11.9RC1\n     */\n    public EditPage useShortcutKeyForEditing()\n    {\n        useShortcutKeyAndLoads(\"e\");\n        return new EditPage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to wiki edit page.\n     * \n     * @return a new {@link WikiEditPage}\n     * @since 11.9RC1\n     */\n    public WikiEditPage useShortcutKeyForWikiEditing()\n    {\n        useShortcutKeyAndLoads(\"k\");\n        return new WikiEditPage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to WYSIWYG edit page.\n     * \n     * @return a new {@link WYSIWYGEditPage}\n     * @since 11.9RC1\n     */\n    public WYSIWYGEditPage useShortcutKeyForWysiwygEditing()\n    {\n        useShortcutKeyAndLoads(\"g\");\n        return new WYSIWYGEditPage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to Inline Form edit page.\n     * \n     * @return a new {@link InlinePage}\n     * @since 11.9RC1\n     */\n    public InlinePage useShortcutKeyForInlineEditing()\n    {\n        useShortcutKeyAndLoads(\"f\");\n        return new InlinePage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to rights edit page.\n     * \n     * @return a new {@link BasePage}: it can be actually either a {@link RightsEditPage} or an AdministrationPage\n     *         depending if the page is terminal or not.\n     * @since 11.9RC1\n     */\n    public BasePage useShortcutKeyForRightsEditing()\n    {\n        useShortcutKeyAndLoads(\"r\");\n        return new BasePage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to object edit page.\n     * \n     * @return a new {@link ObjectEditPage}\n     * @since 11.9RC1\n     */\n    public ObjectEditPage useShortcutKeyForObjectEditing()\n    {\n        useShortcutKeyAndLoads(\"o\");\n        return new ObjectEditPage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to class edit page.\n     * \n     * @return a new {@link ClassEditPage}\n     * @since 11.9RC1\n     */\n    public ClassEditPage useShortcutKeyForClassEditing()\n    {\n        useShortcutKeyAndLoads(\"s\");\n        return new ClassEditPage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to delete page.\n     * \n     * @return a new {@link ConfirmationPage}\n     * @since 11.9RC1\n     */\n    public ConfirmationPage useShortcutKeyForPageDeletion()\n    {\n        useShortcutKeyAndLoads(Keys.DELETE);\n        return new ConfirmationPage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to rename page.\n     * \n     * @return a new {@link RenamePage}\n     * @since 11.9RC1\n     */\n    public RenamePage useShortcutKeyForPageRenaming()\n    {\n        useShortcutKeyAndLoads(Keys.F2);\n        return new RenamePage();\n    }\n\n    /**\n     * Use keyboard shortcuts to go to the source view of a page.\n     * \n     * @return a new {@link ViewPage}\n     * @since 11.9RC1\n     */\n    public ViewPage useShortcutKeyForSourceViewer()\n    {\n        useShortcutKeyAndLoads(\"d\");\n        return new ViewPage();\n    }\n\n    /**\n     * @return true if there's a rendering error on the page (i.e. an element with the class\n     *         {@code xwikirenderingerror})\n     * @since 13.3RC1\n     */\n    public boolean hasRenderingError()\n    {\n        return getDriver().hasElementWithoutWaiting(By.className(\"xwikirenderingerror\"));\n    }\n}\n"], "filenames": ["xwiki-platform-core/xwiki-platform-flamingo/xwiki-platform-flamingo-skin/xwiki-platform-flamingo-skin-test/xwiki-platform-flamingo-skin-test-docker/src/test/it/org/xwiki/flamingo/test/docker/AttachmentIT.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/web/XWikiAction.java", "xwiki-platform-core/xwiki-platform-test/xwiki-platform-test-ui/src/main/java/org/xwiki/test/ui/TestUtils.java", "xwiki-platform-core/xwiki-platform-test/xwiki-platform-test-ui/src/main/java/org/xwiki/test/ui/po/BasePage.java"], "buggy_code_start_loc": [32, 92, 1196, 671], "buggy_code_end_loc": [427, 238, 1197, 671], "fixing_code_start_loc": [33, 93, 1196, 672], "fixing_code_end_loc": [449, 239, 1197, 684], "type": "CWE-79", "message": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. It's possible to perform an XSS by forging a request to a delete attachment action with a specific attachment name. Now this XSS can be exploited only if the attacker knows the CSRF token of the user, or if the user ignores the warning about the missing CSRF token. The vulnerability has been patched in XWiki 15.1-rc-1 and XWiki 14.10.6.", "other": {"cve": {"id": "CVE-2023-35157", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-23T19:15:09.343", "lastModified": "2023-06-30T07:15:41.237", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. It's possible to perform an XSS by forging a request to a delete attachment action with a specific attachment name. Now this XSS can be exploited only if the attacker knows the CSRF token of the user, or if the user ignores the warning about the missing CSRF token. The vulnerability has been patched in XWiki 15.1-rc-1 and XWiki 14.10.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.7, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.7, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}, {"lang": "en", "value": "CWE-80"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionEndExcluding": "14.10.6", "matchCriteriaId": "15032E92-0B19-4A83-A1D0-4A369F4300CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "8F9D9551-B148-44B6-A5B3-889E6E7B72E8"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/35e9073ffec567861e0abeea072bd97921a3decf", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-phwm-87rg-27qq", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-20339", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Permissions Required", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/35e9073ffec567861e0abeea072bd97921a3decf"}}