{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-present Facebook, Inc. (http://www.facebook.com)  |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/base/object-data.h\"\n\n#include \"hphp/runtime/base/array-init.h\"\n#include \"hphp/runtime/base/builtin-functions.h\"\n#include \"hphp/runtime/base/collections.h\"\n#include \"hphp/runtime/base/container-functions.h\"\n#include \"hphp/runtime/base/exceptions.h\"\n#include \"hphp/runtime/base/execution-context.h\"\n#include \"hphp/runtime/base/mixed-array-defs.h\"\n#include \"hphp/runtime/base/object-iterator.h\"\n#include \"hphp/runtime/base/runtime-error.h\"\n#include \"hphp/runtime/base/request-info.h\"\n#include \"hphp/runtime/base/tv-comparisons.h\"\n#include \"hphp/runtime/base/tv-refcount.h\"\n#include \"hphp/runtime/base/tv-type.h\"\n#include \"hphp/runtime/base/type-variant.h\"\n#include \"hphp/runtime/base/variable-serializer.h\"\n\n#include \"hphp/runtime/ext/generator/ext_generator.h\"\n#include \"hphp/runtime/ext/simplexml/ext_simplexml.h\"\n#include \"hphp/runtime/ext/datetime/ext_datetime.h\"\n#include \"hphp/runtime/ext/std/ext_std_closure.h\"\n\n#include \"hphp/runtime/vm/class.h\"\n#include \"hphp/runtime/vm/member-operations.h\"\n#include \"hphp/runtime/vm/memo-cache.h\"\n#include \"hphp/runtime/vm/native-data.h\"\n#include \"hphp/runtime/vm/native-prop-handler.h\"\n#include \"hphp/runtime/vm/jit/translator-inline.h\"\n#include \"hphp/runtime/vm/repo.h\"\n#include \"hphp/runtime/vm/repo-global-data.h\"\n\n#include \"hphp/system/systemlib.h\"\n\n#include <folly/Hash.h>\n#include <folly/ScopeGuard.h>\n\n#include <vector>\n\nnamespace HPHP {\n\n//////////////////////////////////////////////////////////////////////\n\nTRACE_SET_MOD(runtime);\n\n//////////////////////////////////////////////////////////////////////\n\nnamespace {\n\nconst StaticString s_clone(\"__clone\");\n\nALWAYS_INLINE\nvoid verifyTypeHint(const Class* thisCls,\n                    const Class::Prop* prop,\n                    tv_lval val) {\n  assertx(tvIsPlausible(*val));\n  assertx(type(val) != KindOfUninit);\n  if (!prop || RuntimeOption::EvalCheckPropTypeHints <= 0) return;\n  if (prop->typeConstraint.isCheckable()) {\n    prop->typeConstraint.verifyProperty(val, thisCls, prop->cls, prop->name);\n  }\n  if (RuntimeOption::EvalEnforceGenericsUB <= 0) return;\n  for (auto const& ub : prop->ubs) {\n    if (ub.isCheckable()) {\n      ub.verifyProperty(val, thisCls, prop->cls, prop->name);\n    }\n  }\n}\n\nALWAYS_INLINE\nvoid unsetTypeHint(const Class::Prop* prop) {\n  if (RuntimeOption::EvalCheckPropTypeHints <= 0) return;\n  if (!prop || prop->typeConstraint.isMixedResolved()) return;\n  raise_property_typehint_unset_error(\n    prop->cls,\n    prop->name,\n    prop->typeConstraint.isSoft(),\n    prop->typeConstraint.isUpperBound()\n  );\n}\n\n}\n\n//////////////////////////////////////////////////////////////////////\n\n// Check that the given property's type matches its type-hint.\nnamespace {\nbool assertATypeHint(const TypeConstraint& tc, tv_rval val) {\n  if (!tc.isCheckable() || tc.isSoft()) return true;\n  if (val.type() == KindOfUninit) return tc.maybeMixed();\n  return tc.assertCheck(val);\n}\n}\n\nbool ObjectData::assertTypeHint(tv_rval prop, Slot slot) const {\n  assertx(tvIsPlausible(*prop));\n  assertx(slot < m_cls->numDeclProperties());\n  auto const& propDecl = m_cls->declProperties()[slot];\n\n  if (debug && RuntimeOption::RepoAuthoritative) {\n    // The fact that uninitialized LateInit props are uninint isn't\n    // reflected in the repo-auth-type.\n    if (prop.type() != KindOfUninit || !(propDecl.attrs & AttrLateInit)) {\n      always_assert(tvMatchesRepoAuthType(*prop, propDecl.repoAuthType));\n    }\n  }\n\n  // If we're not hard enforcing, then the prop might contain anything.\n  if (RuntimeOption::EvalCheckPropTypeHints <= 2) return true;\n  if (!propDecl.typeConstraint.isCheckable() ||\n      propDecl.typeConstraint.isSoft()) return true;\n  if (propDecl.typeConstraint.isUpperBound() &&\n      RuntimeOption::EvalEnforceGenericsUB < 2) return true;\n  if (prop.type() == KindOfNull && !(propDecl.attrs & AttrNoImplicitNullable)) {\n    return true;\n  }\n  if (prop.type() == KindOfUninit && (propDecl.attrs & AttrLateInit)) {\n    return true;\n  }\n  assertATypeHint(propDecl.typeConstraint, prop);\n  if (RuntimeOption::EvalEnforceGenericsUB <= 2) return true;\n  for (auto const& ub : propDecl.ubs) {\n    if (!assertATypeHint(ub, prop)) return false;\n  }\n  return true;\n}\n\n//////////////////////////////////////////////////////////////////////\n\nNEVER_INLINE\nstatic void freeDynPropArray(ObjectData* inst) {\n  auto& table = g_context->dynPropTable;\n  auto it = table.find(inst);\n  assertx(it != end(table));\n  assertx(it->second.arr().isPHPArray());\n  it->second.destroy();\n  table.erase(it);\n}\n\nNEVER_INLINE\nvoid ObjectData::slowDestroyCases() {\n  assertx(slowDestroyCheck());\n\n  if (getAttribute(UsedMemoCache)) {\n    assertx(m_cls->hasMemoSlots());\n    auto const nSlots = m_cls->numMemoSlots();\n    for (Slot i = 0; i < nSlots; ++i) {\n      auto slot = memoSlot(i);\n      if (slot->isCache()) {\n        if (auto cache = slot->getCache()) req::destroy_raw(cache);\n      } else {\n        tvDecRefGen(*slot->getValue());\n      }\n    }\n  }\n\n  if (UNLIKELY(getAttribute(HasDynPropArr))) freeDynPropArray(this);\n  if (UNLIKELY(getAttribute(IsWeakRefed))) {\n    WeakRefData::invalidateWeakRef((uintptr_t)this);\n  }\n\n  auto const memoSize = m_cls->memoSize();\n  auto const ptr = reinterpret_cast<char*>(this) - memoSize;\n  tl_heap->objFreeIndex(ptr, m_cls->sizeIdx());\n}\n\n// Single check for a couple different unlikely actions during destruction.\ninline bool ObjectData::slowDestroyCheck() const {\n  return m_aux16 & (HasDynPropArr | IsWeakRefed | UsedMemoCache | BigAllocSize);\n}\n\nvoid ObjectData::release(ObjectData* obj, const Class* cls) noexcept {\n  assertx(obj->kindIsValid());\n  assertx(!obj->hasInstanceDtor());\n  assertx(!obj->hasNativeData());\n  assertx(obj->getVMClass() == cls);\n  assertx(cls->releaseFunc() == &ObjectData::release);\n  assertx(obj->props()->checkInvariants(cls->numDeclProperties()));\n\n  // Note: cleanups done in this function are only run for classes without an\n  // instanceDtor. Some of these cleanups are duplicated in ~ObjectData, and\n  // your instanceDtor may call that to have them run; if you choose not to run\n  // ~ObjectData from your instanceDtor you MUST do some of them manually\n  // (e.g. invalidate WeakRefs). Some cleanups (e.g. clearing memo caches) are\n  // not done from ~ObjectData because it is assumed they're not needed for\n  // builtin classes (and in the case of memo caches, since the clearing needs\n  // to be done differently when there is native data).\n  // Finally, cleanups such as invalidating WeakRefs that have to be done for\n  // correctness MUST also be done in Collector::sweep, since none of the code\n  // in this function or the instanceDtor will be run when the object is\n  // collected by GC.\n\n  // `obj' is being torn down now---be careful about where/how you dereference\n  // it from here on.\n\n  obj->props()->release(cls->countablePropsEnd());\n\n  if (UNLIKELY(obj->slowDestroyCheck())) {\n    obj->slowDestroyCases();\n  } else {\n    assertx((obj->m_aux16 & BigAllocSize) == 0);\n    auto const memoSize = cls->memoSize();\n    auto const ptr = reinterpret_cast<char*>(obj) - memoSize;\n    assertx(memoSize == 0 ||\n            reinterpret_cast<const MemoNode*>(ptr)->objOff() == memoSize);\n\n    tl_heap->freeSmallIndex(ptr, cls->sizeIdx());\n  }\n\n  AARCH64_WALKABLE_FRAME();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// class info\n\nStrNR ObjectData::getClassName() const {\n  return m_cls->preClass()->nameStr();\n}\n\nbool ObjectData::instanceof(const String& s) const {\n  assertx(kindIsValid());\n  auto const cls = Unit::lookupClass(s.get());\n  return cls && instanceof(cls);\n}\n\nbool ObjectData::toBooleanImpl() const noexcept {\n  // Note: if you add more cases here, hhbbc/class-util.cpp also needs\n  // to be changed.\n  if (isCollection()) {\n    if (RuntimeOption::EvalNoticeOnCollectionToBool) {\n      raise_notice(\n        \"%s to boolean cast\",\n        collections::typeToString((CollectionType)m_kind)->data()\n      );\n    }\n    return collections::toBool(this);\n  }\n\n  if (instanceof(SimpleXMLElement_classof())) {\n    // SimpleXMLElement is the only non-collection class that has custom bool\n    // casting.\n    if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {\n      raise_notice(\"SimpleXMLElement to boolean cast\");\n    }\n    return SimpleXMLElement_objectCast(this, KindOfBoolean).toBoolean();\n  }\n\n  always_assert(false);\n  return false;\n}\n\nint64_t ObjectData::toInt64Impl() const noexcept {\n  // SimpleXMLElement is the only class that has proper custom int casting.\n  assertx(instanceof(SimpleXMLElement_classof()));\n  if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {\n    raise_notice(\"SimpleXMLElement to integer cast\");\n  }\n  return SimpleXMLElement_objectCast(this, KindOfInt64).toInt64();\n}\n\ndouble ObjectData::toDoubleImpl() const noexcept {\n  // SimpleXMLElement is the only class that has custom double casting.\n  assertx(instanceof(SimpleXMLElement_classof()));\n  if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {\n    raise_notice(\"SimpleXMLElement to double cast\");\n  }\n  return SimpleXMLElement_objectCast(this, KindOfDouble).toDouble();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// instance methods and properties\n\nconst StaticString s_getIterator(\"getIterator\");\n\nObject ObjectData::iterableObject(bool& isIterable,\n                                  bool mayImplementIterator /* = true */) {\n  assertx(mayImplementIterator || !isIterator());\n  if (mayImplementIterator && isIterator()) {\n    isIterable = true;\n    return Object(this);\n  }\n  Object obj(this);\n  while (obj->instanceof(SystemLib::s_IteratorAggregateClass)) {\n    auto iterator = obj->o_invoke_few_args(s_getIterator, 0);\n    if (!iterator.isObject()) break;\n    auto o = iterator.getObjectData();\n    if (o->isIterator()) {\n      isIterable = true;\n      return Object{o};\n    }\n    obj.reset(o);\n  }\n  if (!isIterator() && obj->instanceof(SimpleXMLElement_classof())) {\n    if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {\n      raise_notice(\"SimpleXMLElement used as iterator\");\n    }\n    isIterable = true;\n    return create_object(\n      s_SimpleXMLElementIterator,\n      make_vec_array(obj)\n    );\n  }\n  isIterable = false;\n  return obj;\n}\n\nArray& ObjectData::dynPropArray() const {\n  assertx(getAttribute(HasDynPropArr));\n  assertx(g_context->dynPropTable.count(this));\n  assertx(g_context->dynPropTable[this].arr().isPHPArray());\n  return g_context->dynPropTable[this].arr();\n}\n\nvoid ObjectData::setDynProps(const Array& newArr) {\n  // don't expose the ref returned by setDynPropArr\n  (void)setDynPropArray(newArr);\n}\n\nvoid ObjectData::reserveDynProps(int numDynamic) {\n  // don't expose the ref returned by reserveProperties()\n  (void)reserveProperties(numDynamic);\n}\n\nArray& ObjectData::reserveProperties(int numDynamic /* = 2 */) {\n  if (getAttribute(HasDynPropArr)) {\n    return dynPropArray();\n  }\n\n  return setDynPropArray(\n      Array::attach(MixedArray::MakeReserveMixed(numDynamic))\n  );\n}\n\nArray& ObjectData::setDynPropArray(const Array& newArr) {\n  assertx(!g_context->dynPropTable.count(this));\n  assertx(!getAttribute(HasDynPropArr));\n  assertx(newArr.isPHPArray());\n\n  if (m_cls->forbidsDynamicProps()) {\n    throw_object_forbids_dynamic_props(getClassName().data());\n  }\n  if (RuntimeOption::EvalNoticeOnCreateDynamicProp) {\n    IterateKV(newArr.get(), [&] (TypedValue k, TypedValue v) {\n      auto const key = tvCastToString(k);\n      raiseCreateDynamicProp(key.get());\n    });\n  }\n\n  // newArr can have refcount 2 or higher\n  auto& arr = g_context->dynPropTable[this].arr();\n  assertx(arr.isPHPArray());\n  arr = newArr;\n  setAttribute(HasDynPropArr);\n  return arr;\n}\n\ntv_lval ObjectData::makeDynProp(const StringData* key) {\n  if (RuntimeOption::EvalNoticeOnCreateDynamicProp) {\n    raiseCreateDynamicProp(key);\n  }\n  return reserveProperties().lvalForce(StrNR(key), AccessFlags::Key);\n}\n\nvoid ObjectData::setDynProp(const StringData* key, TypedValue val) {\n  if (RuntimeOption::EvalNoticeOnCreateDynamicProp) {\n    raiseCreateDynamicProp(key);\n  }\n  reserveProperties().set(StrNR(key), val, true);\n}\n\nVariant ObjectData::o_get(const String& propName, bool error /* = true */,\n                          const String& context /*= null_string*/) {\n  assertx(kindIsValid());\n\n  // This is not (just) a check for empty string; property names that start\n  // with null are intentionally being rejected here.\n  if (UNLIKELY(!*propName.data())) {\n    throw_invalid_property_name(propName);\n  }\n\n  Class* ctx = nullptr;\n  if (!context.empty()) {\n    ctx = Unit::lookupClass(context.get());\n  }\n\n  // Can't use propImpl here because if the property is not accessible and\n  // there is no native get, propImpl will raise_error(\"Cannot access ...\",\n  // but o_get will only (maybe) raise_notice(\"Undefined property ...\" :-(\n\n  auto const lookup = getPropImpl<false, true, true>(ctx, propName.get());\n  if (lookup.val && lookup.accessible) {\n    if (lookup.val.type() != KindOfUninit) {\n      return Variant::wrap(lookup.val.tv());\n    } else if (lookup.prop && (lookup.prop->attrs & AttrLateInit)) {\n      if (error) throw_late_init_prop(lookup.prop->cls, propName.get(), false);\n      return uninit_null();\n    }\n  }\n\n  if (error) {\n    raise_notice(\"Undefined property: %s::$%s\", getClassName().data(),\n                 propName.data());\n  }\n\n  return uninit_null();\n}\n\nvoid ObjectData::o_set(const String& propName, const Variant& v,\n                       const String& context /* = null_string */) {\n  assertx(kindIsValid());\n\n  // This is not (just) a check for empty string; property names that start\n  // with null are intentionally being rejected here.\n  if (UNLIKELY(!*propName.data())) {\n    throw_invalid_property_name(propName);\n  }\n\n  Class* ctx = nullptr;\n  if (!context.empty()) {\n    ctx = Unit::lookupClass(context.get());\n  }\n\n  // Can't use setProp here because if the property is not accessible and\n  // there is no native set, setProp will raise_error(\"Cannot access ...\",\n  // but o_set will skip writing and return normally.\n\n  auto const lookup = getPropImpl<true, false, true>(ctx, propName.get());\n  auto prop = lookup.val;\n  if (prop && lookup.accessible) {\n    if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {\n      throwMutateConstProp(lookup.slot);\n    }\n    auto val = tvToInit(*v.asTypedValue());\n    verifyTypeHint(m_cls, lookup.prop, &val);\n    tvSet(val, prop);\n    return;\n  }\n\n  if (!prop) {\n    setDynProp(propName.get(), tvToInit(*v.asTypedValue()));\n  }\n}\n\nvoid ObjectData::o_setArray(const Array& properties) {\n  for (ArrayIter iter(properties); iter; ++iter) {\n    String k = iter.first().toString();\n    Class* ctx = nullptr;\n    // If the key begins with a NUL, it's a private or protected property. Read\n    // the class name from between the two NUL bytes.\n    //\n    // Note: if you change this, you need to change similar logic in\n    // apc-object.\n    if (!k.empty() && k[0] == '\\0') {\n      int subLen = k.find('\\0', 1) + 1;\n      String cls = k.substr(1, subLen - 2);\n      if (cls.size() == 1 && cls[0] == '*') {\n        // Protected.\n        ctx = m_cls;\n      } else {\n        // Private.\n        ctx = Unit::lookupClass(cls.get());\n        if (!ctx) continue;\n      }\n      k = k.substr(subLen);\n    }\n\n    setProp(ctx, k.get(), tvAssertPlausible(iter.secondVal()));\n  }\n}\n\nvoid ObjectData::o_getArray(Array& props,\n                            bool pubOnly /* = false */,\n                            bool ignoreLateInit /* = false */) const {\n  assertx(kindIsValid());\n\n  // Fast path for classes with no declared properties\n  if (!m_cls->numDeclProperties() && getAttribute(HasDynPropArr)) {\n    props = dynPropArray();\n    if (RuntimeOption::EvalNoticeOnReadDynamicProp) {\n      IterateKV(props.get(), [&](TypedValue k, TypedValue) {\n        auto const key = tvCastToString(k);\n        raiseReadDynamicProp(key.get());\n      });\n    }\n    return;\n  }\n\n  auto cls = m_cls;\n  if (cls->hasReifiedGenerics()) {\n    auto const slot = cls->lookupReifiedInitProp();\n    assertx(slot != kInvalidSlot);\n    auto const declProps = cls->declProperties();\n    auto const prop = declProps[slot];\n    auto val = this->propRvalAtOffset(slot);\n    props.set(StrNR(prop.name).asString(), val.tv());\n  }\n  IteratePropToArrayOrderNoInc(\n    this,\n    [&](Slot slot, const Class::Prop& prop, tv_rval val) {\n      assertx(assertTypeHint(val, slot));\n      if (UNLIKELY(val.type() == KindOfUninit)) {\n        if (!ignoreLateInit && (prop.attrs & AttrLateInit)) {\n          throw_late_init_prop(prop.cls, prop.name, false);\n        }\n      } else if (!pubOnly || (prop.attrs & AttrPublic)) {\n        // Skip all the reified properties since we already prepended the\n        // current class' reified property to the list\n        if (prop.name != s_86reified_prop.get()) {\n          props.set(StrNR(prop.mangledName).asString(), val.tv());\n        }\n      }\n    },\n    [&](TypedValue key_tv, TypedValue val) {\n      props.set(key_tv, val, true);\n      if (RuntimeOption::EvalNoticeOnReadDynamicProp) {\n        auto const key = tvCastToString(key_tv);\n        raiseReadDynamicProp(key.get());\n      }\n    }\n  );\n}\n\n// a constant for ArrayIterators that changes the way the\n// object is converted to an array\nconst int64_t ARRAY_OBJ_ITERATOR_STD_PROP_LIST = 1;\n\nconst StaticString s_flags(\"flags\"),\n                   s_storage(\"storage\");\n\ntemplate <IntishCast IC /* = IntishCast::None */>\nArray ObjectData::toArray(bool pubOnly /* = false */,\n                          bool ignoreLateInit /* = false */) const {\n  assertx(kindIsValid());\n\n  // We can quickly tell if this object is a collection, which lets us avoid\n  // checking for each class in turn if it's not one.\n  if (isCollection()) {\n    return collections::toArray<IC>(this);\n  } else if (UNLIKELY(m_cls->rtAttribute(Class::CallToImpl))) {\n    // If we end up with other classes that need special behavior, turn the\n    // assert into an if and add cases.\n    assertx(instanceof(SimpleXMLElement_classof()));\n    if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {\n      raise_notice(\"SimpleXMLElement to array cast\");\n    }\n    return SimpleXMLElement_objectCast(this, KindOfArray).toArray();\n  } else if (UNLIKELY(instanceof(SystemLib::s_ArrayIteratorClass))) {\n    auto const flags = getProp(SystemLib::s_ArrayIteratorClass, s_flags.get());\n    assertx(flags.is_set());\n    if (UNLIKELY(flags.type() == KindOfInt64 &&\n                 flags.val().num == ARRAY_OBJ_ITERATOR_STD_PROP_LIST)) {\n      auto ret = Array::CreateDArray();\n      o_getArray(ret, true, ignoreLateInit);\n      return ret;\n    }\n\n    check_recursion_throw();\n\n    auto const storage = getProp(SystemLib::s_ArrayIteratorClass, s_storage.get());\n    assertx(storage.is_set());\n    return tvCastToArrayLike(storage.tv());\n  } else if (UNLIKELY(instanceof(c_Closure::classof()))) {\n    return make_varray(Object(const_cast<ObjectData*>(this)));\n  } else if (UNLIKELY(instanceof(DateTimeData::getClass()))) {\n    return Native::data<DateTimeData>(this)->getDebugInfo();\n  } else {\n    auto ret = Array::CreateDArray();\n    o_getArray(ret, pubOnly, ignoreLateInit);\n    return ret;\n  }\n}\n\ntemplate\nArray ObjectData::toArray<IntishCast::None>(bool, bool) const;\ntemplate\nArray ObjectData::toArray<IntishCast::Cast>(bool, bool) const;\n\n\nnamespace {\n\nsize_t getPropertyIfAccessible(ObjectData* obj,\n                               const Class* ctx,\n                               const StringData* key,\n                               Array& properties,\n                               size_t propLeft) {\n  auto const prop = obj->getProp(ctx, key);\n  if (prop && prop.type() != KindOfUninit) {\n    --propLeft;\n    properties.set(StrNR(key), prop.tv(), true);\n  }\n  return propLeft;\n}\n\n}\n\nArray ObjectData::o_toIterArray(const String& context) {\n  if (!m_cls->numDeclProperties()) {\n    if (getAttribute(HasDynPropArr)) {\n      auto const props = dynPropArray();\n      if (RuntimeOption::EvalNoticeOnReadDynamicProp) {\n        IterateKV(props.get(), [&](TypedValue k, TypedValue) {\n          auto const key = tvCastToString(k);\n          raiseReadDynamicProp(key.get());\n        });\n      }\n      // not returning Array&; makes a copy\n      return props;\n    }\n    return Array::CreateDArray();\n  }\n\n  size_t accessibleProps = m_cls->declPropNumAccessible();\n  size_t size = accessibleProps;\n  if (getAttribute(HasDynPropArr)) {\n    size += dynPropArray().size();\n  }\n  Array retArray { Array::attach(MixedArray::MakeReserveMixed(size)) };\n\n  Class* ctx = nullptr;\n  if (!context.empty()) {\n    ctx = Unit::lookupClass(context.get());\n  }\n\n  // Get all declared properties first, bottom-to-top in the inheritance\n  // hierarchy, in declaration order.\n  const Class* klass = m_cls;\n  while (klass) {\n    const PreClass::Prop* props = klass->preClass()->properties();\n    const size_t numProps = klass->preClass()->numProperties();\n\n    for (size_t i = 0; i < numProps; ++i) {\n      auto key = const_cast<StringData*>(props[i].name());\n      accessibleProps = getPropertyIfAccessible(\n          this, ctx, key, retArray, accessibleProps);\n    }\n    klass = klass->parent();\n  }\n  if (!(m_cls->attrs() & AttrNoExpandTrait) && accessibleProps > 0) {\n    // we may have properties from traits\n    for (auto const& prop : m_cls->declProperties()) {\n      auto const key = prop.name.get();\n      if (!retArray.get()->exists(key)) {\n        accessibleProps = getPropertyIfAccessible(\n          this, ctx, key, retArray, accessibleProps);\n        if (accessibleProps == 0) break;\n      }\n    }\n  }\n\n  // Now get dynamic properties.\n  if (getAttribute(HasDynPropArr)) {\n    auto& dynProps = dynPropArray();\n    auto ad = dynProps.get();\n    ssize_t iter = ad->iter_begin();\n    auto pos_limit = ad->iter_end();\n    while (iter != pos_limit) {\n      ad = dynProps.get();\n      auto const key = ad->nvGetKey(iter);\n      iter = ad->iter_advance(iter);\n\n      if (RuntimeOption::EvalNoticeOnReadDynamicProp) {\n        auto const k = tvCastToString(key);\n        raiseReadDynamicProp(k.get());\n      }\n\n      // You can get this if you cast an array to object. These\n      // properties must be dynamic because you can't declare a\n      // property with a non-string name.\n      if (UNLIKELY(!isStringType(key.m_type))) {\n        assertx(key.m_type == KindOfInt64);\n        auto const val = dynProps.get()->at(key.m_data.num);\n        retArray.set(key.m_data.num, val);\n        continue;\n      }\n\n      auto const strKey = key.m_data.pstr;\n      auto const val = dynProps.get()->at(strKey);\n      retArray.set(StrNR(strKey), val, true /* isKey */);\n    }\n  }\n\n  return retArray;\n}\n\nstatic bool decode_invoke(const String& s, ObjectData* obj, bool fatal,\n                          CallCtx& ctx) {\n  ctx.this_ = obj;\n  ctx.cls = obj->getVMClass();\n  ctx.dynamic = true;\n\n  ctx.func = ctx.cls->lookupMethod(s.get());\n  if (!ctx.func) {\n    // Bail if this_ is non-null AND we could not find a method.\n    o_invoke_failed(ctx.cls->name()->data(), s.data(), fatal);\n    return false;\n  }\n\n  // Null out this_ for statically called methods\n  if (ctx.func->isStaticInPrologue()) {\n    ctx.this_ = nullptr;\n  }\n  return true;\n}\n\nVariant ObjectData::o_invoke(const String& s, const Variant& params,\n                             bool fatal /* = true */) {\n  CallCtx ctx;\n  if (!decode_invoke(s, this, fatal, ctx) ||\n      (!isContainer(params) && !params.isNull())) {\n    return Variant(Variant::NullInit());\n  }\n  return Variant::attach(\n    g_context->invokeFunc(ctx, params)\n  );\n}\n\n#define INVOKE_FEW_ARGS_IMPL3                        \\\n  const Variant& a0, const Variant& a1, const Variant& a2\n#define INVOKE_FEW_ARGS_IMPL6                        \\\n  INVOKE_FEW_ARGS_IMPL3,                             \\\n  const Variant& a3, const Variant& a4, const Variant& a5\n#define INVOKE_FEW_ARGS_IMPL10                       \\\n  INVOKE_FEW_ARGS_IMPL6,                             \\\n  const Variant& a6, const Variant& a7, const Variant& a8, const Variant& a9\n#define INVOKE_FEW_ARGS_IMPL_ARGS INVOKE_FEW_ARGS(IMPL,INVOKE_FEW_ARGS_COUNT)\n\nVariant ObjectData::o_invoke_few_args(const String& s, int count,\n                                      INVOKE_FEW_ARGS_IMPL_ARGS) {\n\n  CallCtx ctx;\n  if (!decode_invoke(s, this, true, ctx)) {\n    return Variant(Variant::NullInit());\n  }\n\n  TypedValue args[INVOKE_FEW_ARGS_COUNT];\n  switch(count) {\n    default: not_implemented();\n#if INVOKE_FEW_ARGS_COUNT > 6\n    case 10: tvCopy(*a9.asTypedValue(), args[9]);\n    case  9: tvCopy(*a8.asTypedValue(), args[8]);\n    case  8: tvCopy(*a7.asTypedValue(), args[7]);\n    case  7: tvCopy(*a6.asTypedValue(), args[6]);\n#endif\n#if INVOKE_FEW_ARGS_COUNT > 3\n    case  6: tvCopy(*a5.asTypedValue(), args[5]);\n    case  5: tvCopy(*a4.asTypedValue(), args[4]);\n    case  4: tvCopy(*a3.asTypedValue(), args[3]);\n#endif\n    case  3: tvCopy(*a2.asTypedValue(), args[2]);\n    case  2: tvCopy(*a1.asTypedValue(), args[1]);\n    case  1: tvCopy(*a0.asTypedValue(), args[0]);\n    case  0: break;\n  }\n\n  return Variant::attach(\n    g_context->invokeFuncFew(ctx, count, args)\n  );\n}\n\nObjectData* ObjectData::clone() {\n  if (isCppBuiltin()) {\n    assertx(!m_cls->hasMemoSlots());\n    if (isCollection()) return collections::clone(this);\n    if (instanceof(c_Closure::classof())) {\n      return c_Closure::fromObject(this)->clone();\n    }\n    assertx(instanceof(c_Awaitable::classof()));\n    // cloning WaitHandles is not allowed\n    // invoke the instanceCtor to get the right sort of exception\n    auto const ctor = m_cls->instanceCtor();\n    ctor(m_cls);\n    always_assert(false);\n  }\n\n  // clone prevents a leak if something throws before clone() returns\n  Object clone;\n  auto const nProps = m_cls->numDeclProperties();\n  if (hasNativeData()) {\n    assertx(m_cls->instanceDtor() == Native::nativeDataInstanceDtor);\n    clone = Object::attach(\n      Native::nativeDataInstanceCopyCtor(this, m_cls, nProps)\n    );\n    assertx(clone->hasExactlyOneRef());\n    assertx(clone->hasInstanceDtor());\n  } else {\n    auto const alloc = allocMemoInit(m_cls);\n\n    auto const obj = new (NotNull{}, alloc.mem)\n                     ObjectData(m_cls, InitRaw{}, alloc.flags);\n    clone = Object::attach(obj);\n    assertx(clone->hasExactlyOneRef());\n    assertx(!clone->hasInstanceDtor());\n  }\n\n  auto const cloneProps = clone->props();\n  cloneProps->init(m_cls->numDeclProperties());\n  for (auto slot = Slot{0}; slot < nProps; slot++) {\n    auto index = m_cls->propSlotToIndex(slot);\n    tvDup(*props()->at(index), cloneProps->at(index));\n    assertx(assertTypeHint(cloneProps->at(index), slot));\n  }\n\n  if (UNLIKELY(getAttribute(HasDynPropArr))) {\n    clone->setAttribute(HasDynPropArr);\n    g_context->dynPropTable.emplace(clone.get(), dynPropArray().get());\n  }\n  if (m_cls->rtAttribute(Class::HasClone)) {\n    assertx(!isCppBuiltin());\n    auto const method = clone->m_cls->lookupMethod(s_clone.get());\n    assertx(method);\n    clone->unlockObject();\n    SCOPE_EXIT { clone->lockObject(); };\n    g_context->invokeMethodV(clone.get(), method, InvokeArgs{}, false);\n  }\n  return clone.detach();\n}\n\nbool ObjectData::equal(const ObjectData& other) const {\n  if (this == &other) return true;\n  if (isCollection()) {\n    return collections::equals(this, &other);\n  }\n  if (UNLIKELY(instanceof(SystemLib::s_DateTimeInterfaceClass) &&\n               other.instanceof(SystemLib::s_DateTimeInterfaceClass))) {\n    return DateTimeData::compare(this, &other) == 0;\n  }\n  if (getVMClass() != other.getVMClass()) return false;\n  if (UNLIKELY(instanceof(SimpleXMLElement_classof()))) {\n    if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {\n      raise_notice(\"SimpleXMLElement equality comparison\");\n    }\n    // Compare the whole object (including native data), not just props\n    auto ar1 = SimpleXMLElement_objectCast(this, KindOfArray).toArray();\n    auto ar2 = SimpleXMLElement_objectCast(&other, KindOfArray).toArray();\n    return ArrayData::Equal(ar1.get(), ar2.get());\n  }\n  if (UNLIKELY(instanceof(c_Closure::classof()))) {\n    // First comparison already proves they are different\n    return false;\n  }\n\n  // check for dynamic props first because we need to short-circuit if there's\n  // a different number of them\n  auto thisSize = UNLIKELY(getAttribute(HasDynPropArr)) ?\n    dynPropArray().size() : 0;\n  size_t otherSize = 0;\n  ArrayData* otherDynProps = nullptr;\n  if (UNLIKELY(other.getAttribute(HasDynPropArr))) {\n    otherDynProps = other.dynPropArray().get();\n    otherSize = otherDynProps->size();\n  }\n  if (thisSize != otherSize) return false;\n\n  // Prevent circular referenced objects/arrays or deep ones.\n  check_recursion_error();\n\n  bool result = true;\n  IteratePropMemOrderNoInc(\n    this,\n    [&](Slot slot, const Class::Prop& prop, tv_rval thisVal) {\n      auto otherVal = other.propRvalAtOffset(slot);\n      if ((UNLIKELY(thisVal.type() == KindOfUninit) ||\n           UNLIKELY(otherVal.type() == KindOfUninit)) &&\n          (prop.attrs & AttrLateInit)) {\n        throw_late_init_prop(prop.cls, prop.name, false);\n      }\n      if (!tvEqual(thisVal.tv(), otherVal.tv())) {\n        result = false;\n        return true;\n      }\n      return false;\n    },\n    [&](TypedValue key, TypedValue thisVal) {\n      auto const otherVal = otherDynProps->get(key);\n      if (!otherVal.is_init() || !tvEqual(thisVal, otherVal)) {\n        result = false;\n        return true;\n      }\n      return false;\n    }\n  );\n  return result;\n}\n\nbool ObjectData::less(const ObjectData& other) const {\n  // compare is not symmetrical; order of operands matters here\n  return compare(other) < 0;\n}\n\nbool ObjectData::lessEqual(const ObjectData& other) const {\n  // compare is not symmetrical; order of operands matters here\n  return compare(other) <= 0;\n}\n\nbool ObjectData::more(const ObjectData& other) const {\n  // compare is not symmetrical; order of operands matters here\n  return other.compare(*this) < 0;\n}\n\nbool ObjectData::moreEqual(const ObjectData& other) const {\n  // compare is not symmetrical; order of operands matters here\n  return other.compare(*this) <= 0;\n}\n\nint64_t ObjectData::compare(const ObjectData& other) const {\n  if (isCollection() || other.isCollection()) {\n    throw_collection_compare_exception();\n  }\n  if (this == &other) return 0;\n  if (UNLIKELY(instanceof(SystemLib::s_DateTimeInterfaceClass) &&\n               other.instanceof(SystemLib::s_DateTimeInterfaceClass))) {\n    return DateTimeData::compare(this, &other);\n  }\n  // Return 1 for different classes to match PHP7 behavior.\n  if (getVMClass() != other.getVMClass()) return 1;\n  if (UNLIKELY(instanceof(SimpleXMLElement_classof()))) {\n    if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {\n      raise_notice(\"SimpleXMLElement comparison\");\n    }\n    // Compare the whole object (including native data), not just props\n    auto ar1 = SimpleXMLElement_objectCast(this, KindOfArray).toArray();\n    auto ar2 = SimpleXMLElement_objectCast(&other, KindOfArray).toArray();\n    return ArrayData::Compare(ar1.get(), ar2.get());\n  }\n  if (UNLIKELY(instanceof(c_Closure::classof()))) {\n    // comparing different closures with <=> always returns 1\n    return 1;\n  }\n\n  // check for dynamic props first, because we need to short circuit if there's\n  // a different number of them\n  auto thisSize = UNLIKELY(getAttribute(HasDynPropArr)) ?\n    dynPropArray().size() : 0;\n  size_t otherSize = 0;\n  ArrayData* otherDynProps = nullptr;\n  if (UNLIKELY(other.getAttribute(HasDynPropArr))) {\n    otherDynProps = other.dynPropArray().get();\n    otherSize = otherDynProps->size();\n  }\n  if (thisSize > otherSize) {\n    return 1;\n  } else if (thisSize < otherSize) {\n    return -1;\n  }\n\n  // Prevent circular referenced objects/arrays or deep ones.\n  check_recursion_error();\n\n  int64_t result = 0;\n  IteratePropToArrayOrderNoInc(\n    this,\n    [&](Slot slot, const Class::Prop& prop, tv_rval thisVal) {\n      auto otherVal = other.propRvalAtOffset(slot);\n      if ((UNLIKELY(thisVal.type() == KindOfUninit) ||\n           UNLIKELY(otherVal.type() == KindOfUninit)) &&\n          (prop.attrs & AttrLateInit)) {\n        throw_late_init_prop(prop.cls, prop.name, false);\n      }\n      auto cmp = tvCompare(thisVal.tv(), otherVal.tv());\n      if (cmp != 0) {\n        result = cmp;\n        return true;\n      }\n      return false;\n    },\n    [&](TypedValue key, TypedValue thisVal) {\n      auto const otherVal = otherDynProps->get(key);\n      if (!otherVal.is_init()) {\n        result = 1;\n        return true;\n      }\n      auto cmp = tvCompare(thisVal, otherVal);\n      if (cmp != 0) {\n        result = cmp;\n        return true;\n      }\n      return false;\n    }\n  );\n  return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nconst StaticString\n  s___sleep(\"__sleep\"),\n  s___toDebugDisplay(\"__toDebugDisplay\"),\n  s___wakeup(\"__wakeup\"),\n  s___debugInfo(\"__debugInfo\");\n\nvoid deepInitHelper(ObjectProps* props,\n                    const Class::PropInitVec* initVec,\n                    size_t nProps) {\n  auto initIter = initVec->cbegin();\n  props->init(nProps);\n  props->foreach(nProps, [&](tv_lval lval){\n    auto entry = *initIter++;\n    tvCopy(entry.val.tv(), lval);\n    if (entry.deepInit) {\n      tvIncRefGen(*lval);\n      collections::deepCopy(lval);\n    }\n  });\n}\n\nvoid ObjectData::setReifiedGenerics(Class* cls, ArrayData* reifiedTypes) {\n  auto const arg = make_array_like_tv(reifiedTypes);\n  auto const meth = cls->lookupMethod(s_86reifiedinit.get());\n  assertx(meth != nullptr);\n  g_context->invokeMethod(this, meth, InvokeArgs(&arg, 1));\n}\n\n// called from jit code\nObjectData* ObjectData::newInstanceRawSmall(Class* cls, size_t size,\n                                            size_t index) {\n  assertx(size <= kMaxSmallSize);\n  assertx(!cls->hasMemoSlots());\n  assertx(cls->sizeIdx() == index);\n  auto mem = tl_heap->mallocSmallIndexSize(index, size);\n  auto const flags = IsBeingConstructed | SmallAllocSize;\n  return new (NotNull{}, mem) ObjectData(cls, InitRaw{}, flags);\n}\n\nObjectData* ObjectData::newInstanceRawBig(Class* cls, size_t size) {\n  assertx(!cls->hasMemoSlots());\n  auto mem = tl_heap->mallocBigSize(size);\n  auto const flags = IsBeingConstructed | BigAllocSize;\n  return new (NotNull{}, mem) ObjectData(cls, InitRaw{}, flags);\n}\n\n// called from jit code\nObjectData* ObjectData::newInstanceRawMemoSmall(Class* cls,\n                                                size_t size,\n                                                size_t index,\n                                                size_t objoff) {\n  assertx(size <= kMaxSmallSize);\n  assertx(cls->hasMemoSlots());\n  assertx(!cls->getNativeDataInfo());\n  assertx(objoff == ObjectData::objOffFromMemoNode(cls));\n  assertx(cls->sizeIdx() == index);\n  auto mem = tl_heap->mallocSmallIndexSize(index, size);\n  new (NotNull{}, mem) MemoNode(objoff);\n  mem = reinterpret_cast<char*>(mem) + objoff;\n  auto const flags = IsBeingConstructed | SmallAllocSize;\n  return new (NotNull{}, mem) ObjectData(cls, InitRaw{}, flags);\n}\n\nObjectData* ObjectData::newInstanceRawMemoBig(Class* cls,\n                                              size_t size,\n                                              size_t objoff) {\n  assertx(cls->hasMemoSlots());\n  assertx(!cls->getNativeDataInfo());\n  assertx(objoff == ObjectData::objOffFromMemoNode(cls));\n  auto mem = tl_heap->mallocBigSize(size);\n  new (NotNull{}, mem) MemoNode(objoff);\n  mem = reinterpret_cast<char*>(mem) + objoff;\n  auto const flags = IsBeingConstructed | BigAllocSize;\n  return new (NotNull{}, mem) ObjectData(cls, InitRaw{}, flags);\n}\n\n// Note: the normal object destruction path does not actually call this\n// destructor.  See ObjectData::release.\nObjectData::~ObjectData() {\n  if (UNLIKELY(slowDestroyCheck())) {\n    // The only builtin classes that use ~ObjectData and support memoization\n    // are ones with native data, and the memo slot cleanup for them happens\n    // in nativeDataInstanceDtor.\n    assertx(!getAttribute(UsedMemoCache) || hasNativeData());\n    if (getAttribute(HasDynPropArr)) freeDynPropArray(this);\n    if (getAttribute(IsWeakRefed)) {\n      WeakRefData::invalidateWeakRef((uintptr_t)this);\n    }\n  }\n}\n\nObject ObjectData::FromArray(ArrayData* properties) {\n  assertx(properties->isPHPArrayType());\n  Object retval{SystemLib::s_stdclassClass};\n  retval->setAttribute(HasDynPropArr);\n  g_context->dynPropTable.emplace(retval.get(), properties);\n  return retval;\n}\n\nNEVER_INLINE\nvoid ObjectData::throwMutateConstProp(Slot prop) const {\n  throw_cannot_modify_const_prop(\n    getClassName().data(),\n    m_cls->declProperties()[prop].name->data()\n  );\n}\n\ntemplate <bool forWrite, bool forRead, bool ignoreLateInit>\nALWAYS_INLINE\nObjectData::PropLookup ObjectData::getPropImpl(\n  const Class* ctx,\n  const StringData* key\n) {\n  auto const lookup = m_cls->getDeclPropSlot(ctx, key);\n  auto const propSlot = lookup.slot;\n\n  if (LIKELY(propSlot != kInvalidSlot)) {\n    // We found a visible property, but it might not be accessible.  No need to\n    // check if there is a dynamic property with this name.\n    auto const propIndex = m_cls->propSlotToIndex(propSlot);\n    auto prop = props()->at(propIndex);\n    assertx(assertTypeHint(prop, propSlot));\n\n    auto const& declProp = m_cls->declProperties()[propSlot];\n    if (!ignoreLateInit && lookup.accessible) {\n      if (UNLIKELY(type(prop) == KindOfUninit) &&\n          (declProp.attrs & AttrLateInit)) {\n        throw_late_init_prop(declProp.cls, key, false);\n      }\n    }\n\n    return {\n     prop,\n     &declProp,\n     propSlot,\n     lookup.accessible,\n     // we always return true in the !forWrite case; this way the compiler\n     // may optimize away this value, and if a caller intends to write but\n     // instantiates with false by mistake it will always see const\n     forWrite\n       ? bool(declProp.attrs & AttrIsConst)\n       : true\n    };\n  }\n\n  // We could not find a visible declared property. We need to check for a\n  // dynamic property with this name.\n  if (UNLIKELY(getAttribute(HasDynPropArr))) {\n    auto& arr = dynPropArray();\n    if (arr->exists(key)) {\n      if (forRead && RuntimeOption::EvalNoticeOnReadDynamicProp) {\n        raiseReadDynamicProp(key);\n      }\n      // Returning a non-declared property. We know that it is accessible and\n      // not const since all dynamic properties are. If we may write to\n      // the property we need to allow the array to escalate.\n      auto const lval = arr.lval(StrNR(key), AccessFlags::Key);\n      return { lval, nullptr, kInvalidSlot, true, !forWrite };\n    }\n  }\n\n  return { nullptr, nullptr, kInvalidSlot, false, !forWrite };\n}\n\ntv_lval ObjectData::getPropLval(const Class* ctx, const StringData* key) {\n  auto const lookup = getPropImpl<true, false, true>(ctx, key);\n  if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {\n    throwMutateConstProp(lookup.slot);\n  }\n  return lookup.val && lookup.accessible ? lookup.val : nullptr;\n}\n\ntv_rval ObjectData::getProp(const Class* ctx, const StringData* key) const {\n  auto const lookup = const_cast<ObjectData*>(this)\n    ->getPropImpl<false, true, false>(ctx, key);\n  return lookup.val && lookup.accessible ? lookup.val : nullptr;\n}\n\ntv_rval ObjectData::getPropIgnoreLateInit(const Class* ctx,\n                                          const StringData* key) const {\n  auto const lookup = const_cast<ObjectData*>(this)\n    ->getPropImpl<false, true, true>(ctx, key);\n  return lookup.val && lookup.accessible ? lookup.val : nullptr;\n}\n\ntv_lval ObjectData::getPropIgnoreAccessibility(const StringData* key) {\n  auto const lookup = getPropImpl<false, true, true>(nullptr, key);\n  auto prop = lookup.val;\n  if (!prop) return nullptr;\n  if (lookup.prop && type(prop) == KindOfUninit &&\n      (lookup.prop->attrs & AttrLateInit)) {\n    throw_late_init_prop(lookup.prop->cls, key, false);\n  }\n  return prop;\n}\n\n//////////////////////////////////////////////////////////////////////\n\ninline InvokeResult::InvokeResult(bool ok, Variant&& v) :\n  val(*v.asTypedValue()) {\n  tvWriteUninit(*v.asTypedValue());\n  val.m_aux.u_ok = ok;\n}\n\nstatic InvokeResult guardedNativePropResult(Variant result) {\n  if (!Native::isPropHandled(result)) {\n    return {false, make_tv<KindOfUninit>()};\n  }\n  return InvokeResult{true, std::move(result)};\n}\n\nInvokeResult ObjectData::invokeNativeGetProp(const StringData* key) {\n  return guardedNativePropResult(\n      Native::getProp(Object{this}, StrNR(key))\n  );\n}\n\nbool ObjectData::invokeNativeSetProp(const StringData* key, TypedValue val) {\n  auto r = guardedNativePropResult(\n    Native::setProp(Object{this}, StrNR(key), tvAsCVarRef(&val))\n  );\n  tvDecRefGen(r.val);\n  return r.ok();\n}\n\nInvokeResult ObjectData::invokeNativeIssetProp(const StringData* key) {\n  return guardedNativePropResult(\n      Native::issetProp(Object{this}, StrNR(key))\n  );\n}\n\nbool ObjectData::invokeNativeUnsetProp(const StringData* key) {\n  auto r = guardedNativePropResult(\n      Native::unsetProp(Object{this}, StrNR(key))\n  );\n  tvDecRefGen(r.val);\n  return r.ok();\n}\n\n//////////////////////////////////////////////////////////////////////\n\ntemplate<ObjectData::PropMode mode>\nALWAYS_INLINE\ntv_lval ObjectData::propImpl(TypedValue* tvRef, const Class* ctx,\n                             const StringData* key) {\n  auto constexpr write = (mode == PropMode::DimForWrite);\n  auto constexpr read = (mode == PropMode::ReadNoWarn) ||\n                        (mode == PropMode::ReadWarn);\n  auto const lookup = getPropImpl<write, read, false>(ctx, key);\n  auto const prop = lookup.val;\n\n  if (prop) {\n    if (lookup.accessible) {\n      auto const checkConstProp = [&]() {\n        if (mode == PropMode::DimForWrite) {\n          if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {\n            throwMutateConstProp(lookup.slot);\n          }\n        }\n        return prop;\n      };\n\n      // Property exists, is accessible, and is not unset.\n      if (type(prop) != KindOfUninit) return checkConstProp();\n\n      if (mode == PropMode::ReadWarn) raiseUndefProp(key);\n      if (write) return checkConstProp();\n      return const_cast<TypedValue*>(&immutable_null_base);\n    }\n\n    // Property exists, but it is either protected or private since accessible\n    // is false.\n    auto const propSlot = m_cls->lookupDeclProp(key);\n    auto const attrs = m_cls->declProperties()[propSlot].attrs;\n    auto const priv = (attrs & AttrPrivate) ? \"private\" : \"protected\";\n\n    raise_error(\n      \"Cannot access %s property %s::$%s\",\n      priv,\n      m_cls->preClass()->name()->data(),\n      key->data()\n    );\n  }\n\n  // First see if native getter is implemented.\n  if (m_cls->rtAttribute(Class::HasNativePropHandler)) {\n    if (auto r = invokeNativeGetProp(key)) {\n      tvCopy(r.val, *tvRef);\n      return tvRef;\n    }\n  }\n\n  if (UNLIKELY(!*key->data())) {\n    throw_invalid_property_name(StrNR(key));\n  }\n\n  if (mode == PropMode::ReadWarn) raiseUndefProp(key);\n  if (write) return makeDynProp(key);\n  return const_cast<TypedValue*>(&immutable_null_base);\n}\n\ntv_lval ObjectData::prop(\n  TypedValue* tvRef,\n  const Class* ctx,\n  const StringData* key\n) {\n  return propImpl<PropMode::ReadNoWarn>(tvRef, ctx, key);\n}\n\ntv_lval ObjectData::propW(\n  TypedValue* tvRef,\n  const Class* ctx,\n  const StringData* key\n) {\n  return propImpl<PropMode::ReadWarn>(tvRef, ctx, key);\n}\n\ntv_lval ObjectData::propU(\n  TypedValue* tvRef,\n  const Class* ctx,\n  const StringData* key\n) {\n  return propImpl<PropMode::DimForWrite>(tvRef, ctx, key);\n}\n\ntv_lval ObjectData::propD(\n  TypedValue* tvRef,\n  const Class* ctx,\n  const StringData* key\n) {\n  return propImpl<PropMode::DimForWrite>(tvRef, ctx, key);\n}\n\nbool ObjectData::propIsset(const Class* ctx, const StringData* key) {\n  auto const lookup = getPropImpl<false, true, true>(ctx, key);\n  if (lookup.val && lookup.accessible) {\n    if (lookup.val.type() != KindOfUninit) {\n      return lookup.val.type() != KindOfNull;\n    }\n    if (lookup.prop && (lookup.prop->attrs & AttrLateInit)) {\n      return false;\n    }\n  }\n\n  if (m_cls->rtAttribute(Class::HasNativePropHandler)) {\n    if (auto r = invokeNativeIssetProp(key)) {\n      tvCastToBooleanInPlace(&r.val);\n      return r.val.m_data.num;\n    }\n  }\n\n  return false;\n}\n\nvoid ObjectData::setProp(Class* ctx, const StringData* key, TypedValue val) {\n  assertx(tvIsPlausible(val));\n  assertx(val.m_type != KindOfUninit);\n\n  auto const lookup = getPropImpl<true, false, true>(ctx, key);\n  auto const prop = lookup.val;\n\n  if (prop && lookup.accessible) {\n    if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {\n      throwMutateConstProp(lookup.slot);\n    }\n    // TODO(T61738946): We can remove the temporary here once we no longer\n    // coerce class_meth types.\n    Variant tmp = tvAsVariant(&val);\n    verifyTypeHint(m_cls, lookup.prop, tmp.asTypedValue());\n    tvMove(tmp.detach(), prop);\n    return;\n  }\n\n  // First see if native setter is implemented.\n  if (m_cls->rtAttribute(Class::HasNativePropHandler) &&\n      invokeNativeSetProp(key, val)) {\n    return;\n  }\n\n  if (prop) raise_error(\"Cannot access protected property\");\n\n  if (UNLIKELY(!*key->data())) {\n    throw_invalid_property_name(StrNR(key));\n  }\n  setDynProp(key, val);\n}\n\ntv_lval ObjectData::setOpProp(TypedValue& tvRef,\n                              Class* ctx,\n                              SetOpOp op,\n                              const StringData* key,\n                              TypedValue* val) {\n  auto const lookup = getPropImpl<true, true, false>(ctx, key);\n  auto prop = lookup.val;\n\n  if (prop && lookup.accessible) {\n    if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {\n      throwMutateConstProp(lookup.slot);\n    }\n\n    auto const needsCheck = lookup.prop && [&] {\n      auto const& tc = lookup.prop->typeConstraint;\n      if (setOpNeedsTypeCheck(tc, op, prop)) {\n        return true;\n      }\n      for (auto& ub : lookup.prop->ubs) {\n        if (setOpNeedsTypeCheck(ub, op, prop)) return true;\n      }\n      return false;\n    }();\n\n    if (needsCheck) {\n      /*\n       * If this property has a type-hint, we can't do the setop truly in\n       * place. We need to verify that the new value satisfies the type-hint\n       * before assigning back to the property (if we raise a warning and throw,\n       * we don't want to have already put the value into the prop).\n       */\n      TypedValue temp;\n      tvDup(*prop, temp);\n      SCOPE_FAIL { tvDecRefGen(&temp); };\n      setopBody(&temp, op, val);\n      verifyTypeHint(m_cls, lookup.prop, &temp);\n      tvMove(temp, prop);\n    } else {\n      setopBody(prop, op, val);\n    }\n    return prop;\n  }\n\n  if (UNLIKELY(!*key->data())) throw_invalid_property_name(StrNR(key));\n\n  // Native accessors.\n  if (m_cls->rtAttribute(Class::HasNativePropHandler)) {\n    if (auto r = invokeNativeGetProp(key)) {\n      tvCopy(r.val, tvRef);\n      setopBody(&tvRef, op, val);\n      if (invokeNativeSetProp(key, tvRef)) {\n        return &tvRef;\n      }\n    }\n    // XXX else, write tvRef = null?\n  }\n\n  if (prop) raise_error(\"Cannot access protected property\");\n\n  // No visible/accessible property, and no applicable native method:\n  // create a new dynamic property.  (We know this is a new property,\n  // or it would've hit the visible && accessible case above.)\n  prop = makeDynProp(key);\n  assertx(type(prop) == KindOfNull); // cannot exist yet\n  setopBody(prop, op, val);\n  return prop;\n}\n\nTypedValue ObjectData::incDecProp(Class* ctx, IncDecOp op, const StringData* key) {\n  auto const lookup = getPropImpl<true, true, false>(ctx, key);\n  auto prop = lookup.val;\n\n  if (prop && lookup.accessible) {\n    if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {\n      throwMutateConstProp(lookup.slot);\n    }\n    if (type(prop) == KindOfUninit) {\n      tvWriteNull(prop);\n    }\n\n    /*\n     * If this property has a type-hint, we can't do the inc-dec truely in\n     * place. We need to verify that the new value satisfies the type-hint\n     * before assigning back to the property (if we raise a warning and throw,\n     * we don't want to have already put the value into the prop).\n     *\n     * If the prop is an integer and we're doing the common pre/post inc/dec\n     * ops, we know the type won't change, so we can skip the type-hint check in\n     * that case.\n     */\n    auto const fast = [&]{\n      if (RuntimeOption::EvalCheckPropTypeHints <= 0) return true;\n      auto const isAnyCheckable = lookup.prop && [&] {\n        if (lookup.prop->typeConstraint.isCheckable()) return true;\n        for (auto const& ub : lookup.prop->ubs) {\n          if (ub.isCheckable()) return true;\n        }\n        return false;\n      }();\n      if (!isAnyCheckable) return true;\n\n      if (!isIntType(type(prop))) return false;\n      return\n        op == IncDecOp::PreInc || op == IncDecOp::PostInc ||\n        op == IncDecOp::PreDec || op == IncDecOp::PostDec;\n    }();\n    if (fast) return IncDecBody(op, tvAssertPlausible(prop));\n\n    TypedValue temp;\n    tvDup(tvAssertPlausible(*prop), temp);\n    SCOPE_FAIL { tvDecRefGen(&temp); };\n    auto result = IncDecBody(op, &temp);\n    SCOPE_FAIL { tvDecRefGen(&result); };\n    verifyTypeHint(m_cls, lookup.prop, &temp);\n    tvMove(temp, tvAssertPlausible(prop));\n    return result;\n  }\n\n  if (UNLIKELY(!*key->data())) throw_invalid_property_name(StrNR(key));\n\n  // Native accessors.\n  if (m_cls->rtAttribute(Class::HasNativePropHandler)) {\n    if (auto r = invokeNativeGetProp(key)) {\n      SCOPE_EXIT { tvDecRefGen(r.val); };\n      auto const dest = IncDecBody(op, tvAssertPlausible(&r.val));\n      if (invokeNativeSetProp(key, tvAssertPlausible(r.val))) {\n        return dest;\n      }\n    }\n  }\n\n  if (prop) raise_error(\"Cannot access protected property\");\n\n  // No visible/accessible property, and no applicable native method:\n  // create a new dynamic property.  (We know this is a new property,\n  // or it would've hit the visible && accessible case above.)\n  prop = makeDynProp(key);\n  assertx(type(prop) == KindOfNull); // cannot exist yet\n  return IncDecBody(op, prop);\n}\n\nvoid ObjectData::unsetProp(Class* ctx, const StringData* key) {\n  auto const lookup = getPropImpl<true, false, true>(ctx, key);\n  auto const prop = lookup.val;\n\n  if (prop && lookup.accessible &&\n      (type(prop) != KindOfUninit ||\n       (lookup.prop && (lookup.prop->attrs & AttrLateInit)))) {\n    if (lookup.slot != kInvalidSlot) {\n      // Declared property.\n      if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {\n        throwMutateConstProp(lookup.slot);\n      }\n      unsetTypeHint(lookup.prop);\n      tvSet(*uninit_variant.asTypedValue(), prop);\n    } else {\n      // Dynamic property.\n      dynPropArray().remove(StrNR(key).asString(), true /* isString */);\n    }\n    return;\n  }\n\n  // Native unset first.\n  if (m_cls->rtAttribute(Class::HasNativePropHandler) &&\n      invokeNativeUnsetProp(key)) {\n    return;\n  }\n\n  if (prop && !lookup.accessible) {\n    // Defined property that is not accessible.\n    raise_error(\"Cannot unset inaccessible property\");\n  }\n\n  if (UNLIKELY(!*key->data())) {\n    throw_invalid_property_name(StrNR(key));\n  }\n}\n\nvoid ObjectData::raiseObjToIntNotice(const char* clsName) {\n  raise_notice(\"Object of class %s could not be converted to int\", clsName);\n}\n\nvoid ObjectData::raiseObjToDoubleNotice(const char* clsName) {\n  raise_notice(\"Object of class %s could not be converted to float\", clsName);\n}\n\nvoid ObjectData::raiseAbstractClassError(Class* cls) {\n  Attr attrs = cls->attrs();\n  raise_error(\"Cannot instantiate %s %s\",\n              (attrs & AttrInterface) ? \"interface\" :\n              (attrs & AttrTrait)     ? \"trait\" :\n              (attrs & AttrEnum)      ? \"enum\" : \"abstract class\",\n              cls->preClass()->name()->data());\n}\n\nvoid ObjectData::raiseUndefProp(const StringData* key) const {\n  raise_notice(\"Undefined property: %s::$%s\",\n               m_cls->name()->data(), key->data());\n}\n\nvoid ObjectData::raiseCreateDynamicProp(const StringData* key) const {\n  if (m_cls == SystemLib::s_stdclassClass ||\n      m_cls == SystemLib::s___PHP_Incomplete_ClassClass) {\n    // these classes (but not classes derived from them) don't get notices\n    return;\n  }\n  if (key->isStatic()) {\n    raise_notice(\"Created dynamic property with static name %s::%s\",\n                 m_cls->name()->data(), key->data());\n  } else {\n    raise_notice(\"Created dynamic property with dynamic name %s::%s\",\n                 m_cls->name()->data(), key->data());\n  }\n}\n\nvoid ObjectData::raiseReadDynamicProp(const StringData* key) const {\n  if (m_cls == SystemLib::s_stdclassClass ||\n      m_cls == SystemLib::s___PHP_Incomplete_ClassClass) {\n    // these classes (but not classes derived from them) don't get notices\n    return;\n  }\n  if (key->isStatic()) {\n    raise_notice(\"Read dynamic property with static name %s::%s\",\n                 m_cls->name()->data(), key->data());\n  } else {\n    raise_notice(\"Read dynamic property with dynamic name %s::%s\",\n                 m_cls->name()->data(), key->data());\n  }\n}\n\nvoid ObjectData::raiseImplicitInvokeToString() const {\n  raise_notice(\"Implicitly invoked %s::__toString\", m_cls->name()->data());\n}\n\nVariant ObjectData::InvokeSimple(ObjectData* obj, const StaticString& name) {\n  auto const meth = obj->methodNamed(name.get());\n  return meth\n    ? g_context->invokeMethodV(obj, meth, InvokeArgs{}, false)\n    : uninit_null();\n}\n\nVariant ObjectData::invokeSleep() {\n  return InvokeSimple(this, s___sleep);\n}\n\nVariant ObjectData::invokeToDebugDisplay() {\n  return InvokeSimple(this, s___toDebugDisplay);\n}\n\nVariant ObjectData::invokeWakeup() {\n  unlockObject();\n  SCOPE_EXIT { lockObject(); };\n  return InvokeSimple(this, s___wakeup);\n}\n\nVariant ObjectData::invokeDebugInfo() {\n  return InvokeSimple(this, s___debugInfo);\n}\n\nString ObjectData::invokeToString() {\n  if (RuntimeOption::EvalFatalOnConvertObjectToString) {\n    raise_convert_object_to_string(classname_cstr());\n  }\n\n  const Func* method = m_cls->getToString();\n  if (!method) {\n    // If the object does not define a __toString() method, raise a\n    // recoverable error\n    raise_recoverable_error(\n      \"Object of class %s could not be converted to string\",\n      classname_cstr()\n    );\n    // If the user error handler decides to allow execution to continue,\n    // we return the empty string.\n    return empty_string();\n  }\n  if (RuntimeOption::EvalNoticeOnImplicitInvokeToString) {\n    raiseImplicitInvokeToString();\n  }\n  auto const tv = g_context->invokeMethod(this, method, InvokeArgs{}, false);\n  if (!isStringType(tv.m_type)) {\n    // Discard the value returned by the __toString() method and raise\n    // a recoverable error\n    tvDecRefGen(tv);\n    raise_recoverable_error(\n      \"Method %s::__toString() must return a string value\",\n      m_cls->preClass()->name()->data());\n    // If the user error handler decides to allow execution to continue,\n    // we return the empty string.\n    return empty_string();\n  }\n\n  return String::attach(tv.m_data.pstr);\n}\n\nbool ObjectData::hasToString() {\n  return (m_cls->getToString() != nullptr);\n}\n\nconst char* ObjectData::classname_cstr() const {\n  return getClassName().data();\n}\n\n} // HPHP\n", "/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-present Facebook, Inc. (http://www.facebook.com)  |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n#include \"hphp/runtime/base/variable-unserializer.h\"\n\n#include <algorithm>\n#include <utility>\n\n#include <folly/Conv.h>\n#include <folly/Range.h>\n#include <folly/lang/Launder.h>\n\n#include \"hphp/runtime/base/array-init.h\"\n#include \"hphp/runtime/base/array-iterator.h\"\n#include \"hphp/runtime/base/autoload-handler.h\"\n#include \"hphp/runtime/base/set-array.h\"\n#include \"hphp/runtime/base/collections.h\"\n#include \"hphp/runtime/base/comparisons.h\"\n#include \"hphp/runtime/base/dummy-resource.h\"\n#include \"hphp/runtime/base/execution-context.h\"\n#include \"hphp/runtime/base/runtime-error.h\"\n#include \"hphp/runtime/base/runtime-option.h\"\n#include \"hphp/runtime/base/struct-log-util.h\"\n#include \"hphp/runtime/base/request-info.h\"\n#include \"hphp/runtime/base/variable-serializer.h\"\n\n#include \"hphp/runtime/ext/collections/ext_collections-map.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-pair.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-set.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-vector.h\"\n#include \"hphp/runtime/ext/std/ext_std_classobj.h\"\n\n#include \"hphp/runtime/vm/native-data.h\"\n#include \"hphp/runtime/vm/repo-global-data.h\"\n#include \"hphp/runtime/vm/repo.h\"\n\n#include \"hphp/runtime/vm/jit/perf-counters.h\"\n\n#include \"hphp/zend/zend-strtod.h\"\n\nnamespace HPHP {\n\nnamespace {\n\nenum class ArrayKind { PHP, Dict, Vec, Keyset };\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnexpectedSep(char expect, char actual) {\n  throw Exception(\"Expected '%c' but got '%c'\", expect, actual);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwOutOfRange(int64_t id) {\n  throw Exception(\"Id %\" PRId64 \" out of range\", id);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnexpectedStr(const char* expect, folly::StringPiece& actual) {\n  throw Exception(\"Expected '%s' but got '%.*s'\", expect,\n                  (int)actual.size(), actual.data());\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnknownType(char type) {\n  throw Exception(\"Unknown type '%c'\", type);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwInvalidPair() {\n  throw Exception(\"Pair objects must have exactly 2 elements\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwInvalidOFormat(const String& clsName) {\n  throw Exception(\"%s does not support the 'O' serialization format\",\n                  clsName.data());\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwMangledPrivateProperty() {\n  throw Exception(\"Mangled private object property\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnterminatedProperty() {\n  throw Exception(\"Object property not terminated properly\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwNotCollection(const String& clsName) {\n  throw Exception(\"%s is not a collection class\", clsName.data());\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnexpectedType(const String& key, const ObjectData* obj,\n                         TypedValue type) {\n  auto msg = folly::format(\n    \"Property {} for class {} was deserialized with type ({}) that \"\n    \"didn't match what we inferred in static analysis\",\n    key,\n    obj->getVMClass()->name(),\n    tname(type.m_type)\n  ).str();\n  throw Exception(msg);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnexpectedType(const StringData* key, const ObjectData* obj,\n                         TypedValue type) {\n  String str(key->data(), key->size(), CopyString);\n  throwUnexpectedType(str, obj, type);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwArraySizeOutOfBounds() {\n  throw Exception(\"Array size out of bounds\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwInvalidKey() {\n  throw Exception(\"Invalid key\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnterminatedElement() {\n  throw Exception(\"Array element not terminated properly\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwLargeStringSize(int64_t size) {\n  throw Exception(\"Size of serialized string (%\" PRId64 \") exceeds max\", size);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwNegativeStringSize(int64_t size) {\n  throw Exception(\"Size of serialized string (%\" PRId64 \") \"\n                  \"must not be negative\", size);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwBadFormat(const ObjectData* obj, char type) {\n  throw Exception(\"%s does not support the '%c' serialization format\",\n                  header_names[(int)obj->headerKind()], type);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwInvalidHashKey(const ObjectData* obj) {\n  throw Exception(\"%s values must be integers or strings\",\n                  header_names[(int)obj->headerKind()]);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwColRKey() {\n  throw Exception(\"Referring to collection keys using the 'r' encoding \"\n                    \"is not supported\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwColRefValue() {\n  throw Exception(\"Collection values cannot be taken by reference\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwColRefKey() {\n  throw Exception(\"Collection keys cannot be taken by reference\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnexpectedEOB() {\n  throw Exception(\"Unexpected end of buffer during unserialization\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwVecRefValue() {\n  throw Exception(\"Vecs cannot contain references\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwDictRefValue() {\n  throw Exception(\"Dicts cannot contain references\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwKeysetValue() {\n  throw Exception(\"Keysets can only contain integers and strings\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwInvalidClassName() {\n  throw Exception(\"Provided class name is invalid\");\n}\n\nvoid warnOrThrowUnknownClass(const String& clsName) {\n  if (RuntimeOption::EvalForbidUnserializeIncompleteClass) {\n    auto const msg = folly::sformat(\n      \"Attempted to unserialize class named '{}' but it doesn't exist\",\n      clsName.toCppString()\n    );\n    if (RuntimeOption::EvalForbidUnserializeIncompleteClass > 1) {\n      throw_object(\"Exception\", make_vec_array(msg));\n    } else {\n      raise_warning(msg);\n    }\n  }\n}\n}\n\nconst StaticString\n  s_serialized(\"serialized\"),\n  s_unserialize(\"unserialize\"),\n  s_PHP_Incomplete_Class(\"__PHP_Incomplete_Class\"),\n  s_PHP_Incomplete_Class_Name(\"__PHP_Incomplete_Class_Name\"),\n  s___wakeup(\"__wakeup\");\n\n///////////////////////////////////////////////////////////////////////////////\n\nconst StaticString s_force_darrays{\"force_darrays\"};\nconst StaticString s_mark_legacy_arrays{\"mark_legacy_arrays\"};\n\nVariableUnserializer::VariableUnserializer(\n  const char* str,\n  size_t len,\n  Type type,\n  bool allowUnknownSerializableClass,\n  const Array& options)\n    : m_type(type)\n    , m_readOnly(false)\n    , m_buf(str)\n    , m_end(str + len)\n    , m_unknownSerializable(allowUnknownSerializableClass)\n    , m_options(options)\n    , m_begin(str)\n    , m_forceDArrays{m_options[s_force_darrays].toBoolean()}\n    , m_markLegacyArrays{m_options[s_mark_legacy_arrays].toBoolean()}\n{}\n\nVariableUnserializer::Type VariableUnserializer::type() const {\n  return m_type;\n}\n\nbool VariableUnserializer::allowUnknownSerializableClass() const {\n  return m_unknownSerializable;\n}\n\nconst char* VariableUnserializer::head() const {\n  return m_buf;\n}\n\nconst char* VariableUnserializer::begin() const {\n  return m_begin;\n}\n\nconst char* VariableUnserializer::end() const {\n  return m_end;\n}\n\nchar VariableUnserializer::peek() const {\n  check();\n  return *m_buf;\n}\n\nchar VariableUnserializer::peekBack() const {\n  return m_buf[-1];\n}\n\nbool VariableUnserializer::endOfBuffer() const {\n  return m_buf >= m_end;\n}\n\nchar VariableUnserializer::readChar() {\n  check();\n  return *(m_buf++);\n}\n\nvoid VariableUnserializer::add(tv_lval v, UnserializeMode mode) {\n  switch (mode) {\n    case UnserializeMode::Value:  m_refs.emplace_back(v); break;\n    // We don't support refs to collection keys; use nullptr as a sentinel.\n    case UnserializeMode::ColKey: m_refs.emplace_back(nullptr); break;\n    case UnserializeMode::Key:    break;\n  }\n}\n\nvoid VariableUnserializer::reserveForAdd(size_t count) {\n  // If the array is large, the space for the backrefs could be\n  // significant, so we need to check for OOM beforehand. To do this,\n  // we need to do some guess work to estimate what memory the vector\n  // will consume once we've done the reserve (we assume the vector\n  // doubles in capacity as necessary).\n  auto const newSize = m_refs.size() + count;\n  auto const capacity = m_refs.capacity();\n  if (newSize <= capacity) return;\n  auto const total =\n    (folly::nextPowTwo(newSize) - capacity) *\n    sizeof(decltype(m_refs)::value_type);\n  if (UNLIKELY(total > kMaxSmallSize && tl_heap->preAllocOOM(total))) {\n    check_non_safepoint_surprise();\n  }\n  m_refs.reserve(newSize);\n}\n\nTypedValue VariableUnserializer::getByVal(int id) {\n  if (id <= 0 || id > m_refs.size()) throwOutOfRange(id);\n  auto const result = m_refs[id - 1];\n  if (!result) throwColRKey();\n  return result.tv();\n}\n\nvoid VariableUnserializer::check() const {\n  if (m_buf >= m_end) throwUnexpectedEOB();\n}\n\nvoid VariableUnserializer::checkElemTermination() const {\n  auto const ch = peekBack();\n  if (ch != ';' && ch != '}') throwUnterminatedElement();\n}\n\nvoid VariableUnserializer::set(const char* buf, const char* end) {\n  m_buf = buf;\n  m_end = end;\n}\n\nVariant VariableUnserializer::unserialize() {\n  Variant v;\n  unserializeVariant(v.asTypedValue());\n  if (UNLIKELY(StructuredLog::coinflip(RuntimeOption::EvalSerDesSampleRate))) {\n    String ser(m_begin, m_end - m_begin, CopyString);\n    auto const fmt = folly::sformat(\"VU{}\", (int)m_type);\n    StructuredLog::logSerDes(fmt.c_str(), \"des\", ser, v);\n  }\n\n  for (auto& obj : m_sleepingObjects) {\n    obj->invokeWakeup();\n  }\n\n  return v;\n}\n\nnamespace {\nstd::pair<int64_t,const char*> hh_strtoll_base10(const char* p) {\n  int64_t x = 0;\n  bool neg = false;\n  if (*p == '-') {\n    neg = true;\n    ++p;\n  }\n  while (*p >= '0' && *p <= '9') {\n    x = (x * 10) + ('0' - *p);\n    ++p;\n  }\n  if (!neg) {\n    x = -x;\n  }\n  return std::pair<int64_t,const char*>(x, p);\n}\n}\n\nint64_t VariableUnserializer::readInt() {\n  check();\n  auto r = hh_strtoll_base10(m_buf);\n  m_buf = r.second;\n  return r.first;\n}\n\ndouble VariableUnserializer::readDouble() {\n  check();\n  const char* newBuf;\n  double r = zend_strtod(m_buf, &newBuf);\n  m_buf = newBuf;\n  return r;\n}\n\nfolly::StringPiece VariableUnserializer::readStr(unsigned n) {\n  check();\n  auto const bufferLimit = std::min(size_t(m_end - m_buf), size_t(n));\n  auto str = folly::StringPiece(m_buf, bufferLimit);\n  m_buf += bufferLimit;\n  return str;\n}\n\nvoid VariableUnserializer::expectChar(char expected) {\n  char ch = readChar();\n  if (UNLIKELY(ch != expected)) {\n    throwUnexpectedSep(expected, ch);\n  }\n}\n\nnamespace {\nbool isWhitelistClass(const String& requestedClassName,\n                      const Array& list,\n                      bool includeSubclasses) {\n  if (!list.empty()) {\n    for (ArrayIter iter(list); iter; ++iter) {\n      auto allowedClassName = iter.second().toString();\n      auto const matches = includeSubclasses\n        ? HHVM_FN(is_a)(requestedClassName, allowedClassName, true)\n        : allowedClassName.get()->isame(requestedClassName.get());\n      if (matches) return true;\n    }\n  }\n  return false;\n}\n}\n\nconst StaticString s_throw(\"throw\");\nconst StaticString s_allowed_classes(\"allowed_classes\");\nconst StaticString s_include_subclasses(\"include_subclasses\");\n\nbool VariableUnserializer::whitelistCheck(const String& clsName) const {\n  if (m_type != Type::Serialize || m_options.isNull()) {\n    return true;\n  }\n\n  // PHP7-style class whitelisting\n  // Allowed classes are allowed,\n  // all others result in __Incomplete_PHP_Class\n  if (m_options.exists(s_allowed_classes)) {\n    auto allowed_classes = m_options[s_allowed_classes];\n    auto const ok = [&] {\n      if (allowed_classes.isArray()) {\n        auto const subs = m_options[s_include_subclasses].toBoolean();\n        return isWhitelistClass(clsName,\n                                allowed_classes.toArray(),\n                                subs);\n      } else if (allowed_classes.isBoolean()) {\n        return allowed_classes.toBoolean();\n      } else {\n        throw InvalidAllowedClassesException();\n      }\n    }();\n\n    if (!ok && m_options[s_throw].toBoolean()) {\n      throw_object(m_options[s_throw].toString(),\n                   make_vec_array(clsName));\n    }\n    return ok;\n  }\n\n  if (!RuntimeOption::UnserializationWhitelistCheck) {\n    // No need for BC HHVM-style whitelist check,\n    // since the check isn't enabled.\n    // Go with PHP5 default behavior of allowing all\n    return true;\n  }\n\n  // Check for old-style whitelist\n  if (isWhitelistClass(clsName, m_options, false)) {\n    return true;\n  }\n\n  // Non-whitelisted class with a check enabled,\n  // are we willing to hard-error over it?\n  const char* err_msg =\n    \"The object being unserialized with class name '%s' \"\n    \"is not in the given whitelist\"; // followed by ' in <filename> on line %d'.\n\n  if (RuntimeOption::UnserializationWhitelistCheckWarningOnly) {\n    // Nope, just whine to the user and let it through\n    raise_warning(err_msg, clsName.c_str());\n    return true;\n  } else {\n    // Yes, shut it down.\n    raise_error(err_msg, clsName.c_str());\n    return false;\n  }\n}\n\nvoid VariableUnserializer::addSleepingObject(const Object& o) {\n  m_sleepingObjects.emplace_back(o);\n}\n\nbool VariableUnserializer::matchString(folly::StringPiece str) {\n  const char* p = m_buf;\n  assertx(p <= m_end);\n  int total = 0;\n  if (*p == 'S' && type() == VariableUnserializer::Type::APCSerialize) {\n    total = 2 + 8 + 1;\n    if (p + total > m_end) return false;\n    p++;\n    if (*p++ != ':') return false;\n    auto const sd = *reinterpret_cast<StringData*const*>(p);\n    assertx(sd->isStatic());\n    if (str.compare(sd->slice()) != 0) return false;\n    p += size_t(8);\n  } else {\n    const auto ss = str.size();\n    if (ss >= 100) return false;\n    int digits = ss >= 10 ? 2 : 1;\n    total = 2 + digits + 2 + ss + 2;\n    if (p + total > m_end) return false;\n    if (*p++ != 's') return false;\n    if (*p++ != ':') return false;\n    if (digits == 2) {\n      if (*p++ != '0' + ss/10) return false;\n      if (*p++ != '0' + ss%10) return false;\n    } else {\n      if (*p++ != '0' + ss) return false;\n    }\n    if (*p++ != ':') return false;\n    if (*p++ != '\\\"') return false;\n    if (memcmp(p, str.data(), ss)) return false;\n    p += ss;\n    if (*p++ != '\\\"') return false;\n  }\n  if (*p++ != ';') return false;\n  assertx(m_buf + total == p);\n  m_buf = p;\n  return true;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n// remainingProps should include the current property being unserialized.\nvoid VariableUnserializer::unserializePropertyValue(tv_lval v,\n                                                    int remainingProps) {\n  assertx(remainingProps > 0);\n  unserializeVariant(v);\n  if (--remainingProps > 0) {\n    auto lastChar = peekBack();\n    if (lastChar != ';' && lastChar != '}') {\n      throwUnterminatedProperty();\n    }\n  }\n}\n\n// nProp should include the current property being unserialized.\nNEVER_INLINE\nvoid VariableUnserializer::unserializeProp(ObjectData* obj,\n                                           const String& key,\n                                           Class* ctx,\n                                           const String& realKey,\n                                           int nProp) {\n\n  auto const cls = obj->getVMClass();\n  auto const lookup = cls->getDeclPropSlot(ctx, key.get());\n  auto const slot = lookup.slot;\n  tv_lval t;\n\n  if (slot == kInvalidSlot || !lookup.accessible) {\n    // Unserialize as a dynamic property. If this is the first, we need to\n    // pre-allocate space in the array to ensure the elements don't move during\n    // unserialization.\n    t = obj->makeDynProp(realKey.get());\n  } else {\n    // We'll check if this doesn't violate the type-hint once we're done\n    // unserializing all the props.\n    t = obj->getPropLval(ctx, key.get());\n  }\n\n  unserializePropertyValue(t, nProp);\n  if (!RuntimeOption::RepoAuthoritative) return;\n  if (!Repo::get().global().HardPrivatePropInference) return;\n\n  /*\n   * We assume for performance reasons in repo authoriative mode that\n   * we can see all the sets to private properties in a class.\n   *\n   * It's a hole in this if we don't check unserialization doesn't\n   * violate what we've seen, which we handle by throwing if the repo\n   * was built with this option.\n   */\n  if (UNLIKELY(slot == kInvalidSlot)) return;\n  auto const repoTy = cls->declPropRepoAuthType(slot);\n  if (LIKELY(tvMatchesRepoAuthType(*t, repoTy))) return;\n  if (t.type() == KindOfUninit &&\n      (cls->declProperties()[slot].attrs & AttrLateInit)) {\n    return;\n  }\n  throwUnexpectedType(key, obj, *t);\n}\n\n\nNEVER_INLINE\nvoid VariableUnserializer::unserializeRemainingProps(\n  Object& obj,\n  int remainingProps,\n  Variant& serializedNativeData,\n  bool& hasSerializedNativeData) {\n  obj->unlockObject();\n  SCOPE_EXIT { obj->lockObject(); };\n  while (remainingProps > 0) {\n    /*\n      use the number of properties remaining as an estimate for\n      the total number of dynamic properties when we see the\n      first dynamic prop.  see getVariantPtr\n    */\n    Variant v;\n    unserializeVariant(v.asTypedValue(), UnserializeMode::Key);\n    String key = v.toString();\n    int ksize = key.size();\n    const char *kdata = key.data();\n    int subLen = 0;\n    if (key == s_serializedNativeDataKey) {\n      unserializePropertyValue(serializedNativeData.asTypedValue(),\n                               remainingProps--);\n      hasSerializedNativeData = true;\n    } else if (kdata[0] == '\\0') {\n      if (UNLIKELY(!ksize)) {\n        raise_error(\"Cannot access empty property\");\n      }\n      // private or protected\n      subLen = strlen(folly::launder(kdata) + 1) + 2;\n      if (UNLIKELY(subLen >= ksize)) {\n        if (subLen == ksize) {\n          raise_error(\"Cannot access empty property\");\n        } else {\n          throwMangledPrivateProperty();\n        }\n      }\n      String k(kdata + subLen, ksize - subLen, CopyString);\n      Class* ctx = (Class*)-1;\n      if (kdata[1] != '*') {\n        ctx = Unit::lookupClass(\n          String(kdata + 1, subLen - 2, CopyString).get());\n      }\n      unserializeProp(obj.get(), k, ctx, key,\n                      remainingProps--);\n    } else {\n      unserializeProp(obj.get(), key, nullptr, key,\n                      remainingProps--);\n    }\n  }\n}\n\nnamespace {\n\nstatic const StaticString\n  s_Vector(\"Vector\"), s_HH_Vector(\"HH\\\\Vector\"),\n  s_Map(\"Map\"), s_HH_Map(\"HH\\\\Map\"),\n  s_Set(\"Set\"), s_HH_Set(\"HH\\\\Set\"),\n  s_Pair(\"Pair\"), s_HH_Pair(\"HH\\\\Pair\"),\n  s_StableMap(\"StableMap\");\n\n/*\n * For namespaced collections, returns an \"alternate\" name, which is a\n * collection name with or without the namespace qualifier, depending on\n * what's passed.\n * If no alternate name is found, returns nullptr.\n */\nconst StringData* getAlternateCollectionName(const StringData* clsName) {\n  typedef hphp_hash_map<const StringData*, const StringData*,\n                        string_data_hash, string_data_isame> ClsNameMap;\n\n  auto getAltMap = [] {\n    typedef std::pair<StaticString, StaticString> SStringPair;\n\n    static ClsNameMap m;\n\n    static std::vector<SStringPair> mappings {\n      std::make_pair(s_Vector, s_HH_Vector),\n      std::make_pair(s_Map, s_HH_Map),\n      std::make_pair(s_Set, s_HH_Set),\n      std::make_pair(s_Pair, s_HH_Pair)\n    };\n\n    for (const auto& p : mappings) {\n      m[p.first.get()] = p.second.get();\n      m[p.second.get()] = p.first.get();\n    }\n\n    // As part of StableMap merging into Map, StableMap is an alias for HH\\\\Map,\n    // but Map is the sole alias for HH\\\\Map\n    m[s_StableMap.get()] = s_HH_Map.get();\n    return &m;\n  };\n\n  static const ClsNameMap* altMap = getAltMap();\n\n  auto it = altMap->find(clsName);\n  return it != altMap->end() ? it->second : nullptr;\n}\n\nClass* tryAlternateCollectionClass(const StringData* clsName) {\n  auto altName = getAlternateCollectionName(clsName);\n  return altName ? Unit::getClass(altName, /* autoload */ false) : nullptr;\n}\n\n/*\n * Try to read 'str' while advancing 'cur' without reaching 'end'.\n */\nALWAYS_INLINE\nstatic bool match(const char*& cur,\n                  const char* expected,\n                  const char* const end) {\n  if (cur + strlen(expected) >= end) return false;\n  while (*expected) {\n    if (*cur++ != *expected++) return false;\n  }\n  return true;\n}\n\nALWAYS_INLINE\nstatic int64_t read64(const char*& cur) {\n  auto p = hh_strtoll_base10(cur);\n  cur = p.second;\n  return p.first;\n}\n\n/*\n * Read an int64 from 'cur' into 'out'. Returns false on unexpected\n * (but possibly still legal) format or if 'end' is reached.\n */\nALWAYS_INLINE\nbool readInt64(const char*& cur, const char* const end, int64_t& out) {\n  if (!match(cur, \"i:\", end)) return false;\n  out = read64(cur);\n  return match(cur, \";\", end);\n}\n\n/*\n * Read, allocate, and return a string from 'cur'. Returns null on unexpected\n * (but possibly still legal) format or if 'end' is reached, without allocating.\n */\nALWAYS_INLINE\nstatic StringData* readStringData(const char*& cur, const char* const end,\n                                  int maxLen) {\n  if (!match(cur, \"s:\", end)) return nullptr;\n  auto len = read64(cur);\n  if (len < 0 || len >= maxLen) return nullptr;\n  if (!match(cur, \":\\\"\", end)) return nullptr;\n  auto const slice = folly::StringPiece(cur, len);\n  if ((cur += len) >= end) return nullptr;\n  if (!match(cur, \"\\\";\", end)) return nullptr;\n  // TODO(11398853): Consider streaming/non-temporal stores here.\n  auto sd = StringData::Make(slice, CopyString);\n  return sd;\n}\n}\n\nNEVER_INLINE\nvoid VariableUnserializer::unserializeVariant(\n    tv_lval self,\n    UnserializeMode mode /* = UnserializeMode::Value */) {\n\n  // If we're overwriting an array element or property value, save the old\n  // value in case it's later referenced via an r: or R: ref.\n  if (isRefcountedType(self.type()) && mode == UnserializeMode::Value) {\n    m_overwrittenList.append(*self);\n  }\n\n  // NOTE: If you make changes to how serialization and unserialization work,\n  // make sure to update reserialize() here and test_apc_reserialize()\n  // in \"test/ext/test_ext_apc.cpp\".\n\n  char type = readChar();\n  char sep = readChar();\n\n  if (type != 'R') {\n    add(self, mode);\n  }\n\n  if (type == 'N') {\n    if (sep != ';') throwUnexpectedSep(';', sep);\n    tvSetNull(self); // NULL *IS* the value, without we get undefined warnings\n    return;\n  }\n  if (sep != ':') throwUnexpectedSep(':', sep);\n\n  switch (type) {\n  case 'r':\n  case 'R':\n    {\n      int64_t id = readInt();\n      tvSet(getByVal(id), self);\n    }\n    break;\n  case 'b':\n    {\n      int64_t v = readInt();\n      tvSetBool((bool)v, self);\n      break;\n    }\n  case 'i':\n    {\n      int64_t v = readInt();\n      tvSetInt(v, self);\n      break;\n    }\n  case 'd':\n    {\n      char ch = peek();\n      bool negative = false;\n      if (ch == '-') {\n        negative = true;\n        readChar();\n        ch = peek();\n      }\n      double v;\n      if (ch == 'I') {\n        auto str = readStr(3);\n        if (str.size() != 3 || str[1] != 'N' || str[2] != 'F') {\n          throwUnexpectedStr(\"INF\", str);\n        }\n        v = std::numeric_limits<double>::infinity();\n      } else if (ch == 'N') {\n        auto str = readStr(3);\n        if (str.size() != 3 || str[1] != 'A' || str[2] != 'N') {\n          throwUnexpectedStr(\"NAN\", str);\n        }\n        v = std::numeric_limits<double>::quiet_NaN();\n      } else {\n        v = readDouble();\n      }\n      tvSetDouble(negative ? -v : v, self);\n    }\n    break;\n  case 's':\n    {\n      String v = unserializeString();\n      tvMove(make_tv<KindOfString>(v.detach()), self);\n      if (!endOfBuffer()) {\n        // Semicolon *should* always be required,\n        // but PHP's implementation allows omitting it\n        // and still functioning.\n        // Worse, it throws it away without any check.\n        // So we'll do the same.  Sigh.\n        readChar();\n      }\n    }\n    return;\n  case 'S':\n    if (this->type() == VariableUnserializer::Type::APCSerialize) {\n      auto str = readStr(8);\n      assertx(str.size() == 8);\n      auto const sd = *reinterpret_cast<StringData*const*>(&str[0]);\n      assertx(sd->isStatic());\n      tvMove(make_tv<KindOfPersistentString>(sd), self);\n    } else {\n      throwUnknownType(type);\n    }\n    break;\n  case 'a': // PHP array\n  case 'D': // Dict\n    {\n      // Check stack depth to avoid overflow.\n      check_recursion_throw();\n      // It seems silly to check this here, but GCC actually generates much\n      // better code this way.\n      auto a = (type == 'a') ?\n        unserializeArray() :\n        unserializeDict();\n      if (UNLIKELY(m_markLegacyArrays && type == 'a')) {\n        a.setLegacyArray(true);\n      }\n      tvMove(make_array_like_tv(a.detach()), self);\n    }\n    return; // array has '}' terminating\n  case 'x': // legacy dict\n    {\n      // Check stack depth to avoid overflow.\n      check_recursion_throw();\n      auto a = unserializeDict();\n      a.setLegacyArray(true);\n      tvMove(make_array_like_tv(a.detach()), self);\n    }\n    return; // array has '}' terminating\n  case 'Y': // DArray\n    {\n      // Check stack depth to avoid overflow.\n      check_recursion_throw();\n      auto a = unserializeDArray();\n      if (UNLIKELY(m_markLegacyArrays)) {\n        a.setLegacyArray(true);\n      }\n      tvMove(make_array_like_tv(a.detach()), self);\n    }\n    return; // array has '}' terminating\n  case 'y': // VArray\n    {\n      // Check stack depth to avoid overflow.\n      check_recursion_throw();\n      auto a = unserializeVArray();\n      if (UNLIKELY(m_markLegacyArrays)) {\n        a.setLegacyArray(true);\n      }\n      tvMove(make_array_like_tv(a.detach()), self);\n    }\n    return; // array has '}' terminating\n  case 'v': // Vec\n    {\n      // Check stack depth to avoid overflow.\n      check_recursion_throw();\n      auto a = unserializeVec();\n      tvMove(make_tv<KindOfVec>(a.detach()), self);\n    }\n    return; // array has '}' terminating\n  case 'X': // legacy vec\n  {\n    // Check stack depth to avoid overflow.\n    check_recursion_throw();\n    auto a = unserializeVec();\n    a.setLegacyArray(true);\n    tvMove(make_tv<KindOfVec>(a.detach()), self);\n  }\n  return; // array has '}' terminating\n  case 'k': // Keyset\n    {\n      // Check stack depth to avoid overflow.\n      check_recursion_throw();\n      auto a = unserializeKeyset();\n      tvMove(make_tv<KindOfKeyset>(a.detach()), self);\n    }\n    return; // array has '}' terminating\n  case 'L':\n    {\n      int64_t id = readInt();\n      expectChar(':');\n      String rsrcName = unserializeString();\n      expectChar('{');\n      expectChar('}');\n      auto rsrc = req::make<DummyResource>();\n      rsrc->o_setResourceId(id);\n      rsrc->m_class_name = std::move(rsrcName);\n      tvMove(make_tv<KindOfResource>(rsrc.detach()->hdr()), self);\n    }\n    return; // resource has '}' terminating\n  case 'O':\n  case 'V':\n  case 'K':\n    {\n      String clsName = unserializeString();\n\n      expectChar(':');\n      const int64_t size = readInt();\n      expectChar(':');\n      expectChar('{');\n\n      const bool allowObjectFormatForCollections = true;\n\n      Class* cls = nullptr;\n\n      // If we are potentially dealing with a collection, we need to try to\n      // load the collection class under an alternate name so that we can\n      // deserialize data that was serialized before the migration of\n      // collections to the HH namespace.\n\n      if (type == 'O') {\n        if (whitelistCheck(clsName)) {\n          if (allowObjectFormatForCollections) {\n            // In order to support the legacy {O|V}:{Set|Vector|Map}\n            // serialization, we defer autoloading until we know that there's\n            // no alternate (builtin) collection class.\n            cls = Unit::getClass(clsName.get(), /* autoload */ false);\n            if (!cls) {\n              cls = tryAlternateCollectionClass(clsName.get());\n            }\n          }\n\n          // No valid class was found, lets try the autoloader.\n          if (!cls) {\n            if (!is_valid_class_name(clsName.slice())) {\n              throwInvalidClassName();\n            }\n            cls = Unit::loadClass(clsName.get()); // with autoloading\n          }\n        }\n      } else {\n        // Collections are CPP builtins; don't attempt to autoload\n        cls = Unit::getClass(clsName.get(), /* autoload */ false);\n        if (!cls) {\n          cls = tryAlternateCollectionClass(clsName.get());\n        }\n        if (!cls || !cls->isCollectionClass()) {\n          throwNotCollection(clsName);\n        }\n      }\n\n      Object obj;\n      auto remainingProps = size;\n      if (cls) {\n        // Only unserialize CPP extension types which can actually support\n        // it. Otherwise, we risk creating a CPP object without having it\n        // initialized completely.\n        if (cls->instanceCtor() && !cls->isCppSerializable() &&\n            !cls->isCollectionClass()) {\n          assertx(obj.isNull());\n          throw_null_pointer_exception();\n        } else {\n          if (UNLIKELY(collections::isType(cls, CollectionType::Pair))) {\n            if (UNLIKELY(size != 2)) {\n              throwInvalidPair();\n            }\n            // pairs can't be constructed without elements\n            obj = Object{req::make<c_Pair>(make_tv<KindOfNull>(),\n                                           make_tv<KindOfNull>(),\n                                           c_Pair::NoIncRef{})};\n          } else if (UNLIKELY(cls->hasReifiedGenerics())) {\n            // First prop on the serialized list is the reified generics prop\n            if (!matchString(s_86reified_prop.slice())) {\n              throwInvalidOFormat(clsName);\n            }\n            TypedValue tv = make_tv<KindOfNull>();\n            auto const t = tv_lval{&tv};\n            unserializePropertyValue(t, remainingProps--);\n            if (!TypeStructure::coerceToTypeStructureList_SERDE_ONLY(t)) {\n              throwInvalidOFormat(clsName);\n            }\n            assertx(tvIsHAMSafeVArray(t));\n            obj = Object{cls, t.val().parr};\n          } else {\n            obj = Object{cls};\n          }\n        }\n      } else {\n        warnOrThrowUnknownClass(clsName);\n        obj = Object{SystemLib::s___PHP_Incomplete_ClassClass};\n        obj->setProp(nullptr, s_PHP_Incomplete_Class_Name.get(),\n                     clsName.asTypedValue());\n      }\n      assertx(!obj.isNull());\n      tvSet(make_tv<KindOfObject>(obj.get()), self);\n\n      if (remainingProps > 0) {\n        // Check stack depth to avoid overflow.\n        check_recursion_throw();\n\n        if (type == 'O') {\n          // Collections are not allowed\n          if (obj->isCollection()) {\n            throwInvalidOFormat(clsName);\n          }\n\n          Variant serializedNativeData = init_null();\n          bool hasSerializedNativeData = false;\n          bool checkRepoAuthType =\n            RuntimeOption::RepoAuthoritative &&\n            Repo::get().global().HardPrivatePropInference;\n          Class* objCls = obj->getVMClass();\n          // Try fast case.\n          if (remainingProps >= objCls->numDeclProperties() -\n                                (objCls->hasReifiedGenerics() ? 1 : 0)) {\n            auto mismatch = false;\n            auto const objProps = obj->props();\n\n            auto const declProps = objCls->declProperties();\n            for (auto const& p : declProps) {\n              auto slot = p.serializationIdx;\n              auto index = objCls->propSlotToIndex(slot);\n              auto const& prop = declProps[slot];\n              if (prop.name == s_86reified_prop.get()) continue;\n              if (!matchString(prop.mangledName->slice())) {\n                mismatch = true;\n                break;\n              }\n\n              // don't need to worry about overwritten list, because\n              // this is definitely the first time we're setting this\n              // property.\n              auto const t = objProps->at(index);\n              unserializePropertyValue(t, remainingProps--);\n\n              if (UNLIKELY(checkRepoAuthType &&\n                           !tvMatchesRepoAuthType(*t, prop.repoAuthType))) {\n                throwUnexpectedType(prop.name, obj.get(), *t);\n              }\n            }\n            // If everything matched, all remaining properties are dynamic.\n            if (!mismatch && remainingProps > 0) {\n              // the dynPropTable can be mutated while we're deserializing\n              // the contents of this object's prop array. Don't hold a\n              // reference to this object's entry in the table while looping.\n              obj->reserveDynProps(remainingProps);\n              while (remainingProps > 0) {\n                Variant v;\n                unserializeVariant(v.asTypedValue(), UnserializeMode::Key);\n                String key = v.toString();\n                if (key == s_serializedNativeDataKey) {\n                  unserializePropertyValue(serializedNativeData.asTypedValue(),\n                                           remainingProps--);\n                  hasSerializedNativeData = true;\n                } else {\n                  auto kdata = key.data();\n                  if (kdata[0] == '\\0') {\n                    auto ksize = key.size();\n                    if (UNLIKELY(ksize == 0)) {\n                      raise_error(\"Cannot access empty property\");\n                    }\n                    // private or protected\n                    auto subLen = strlen(folly::launder(kdata) + 1) + 2;\n                    if (UNLIKELY(subLen >= ksize)) {\n                      if (subLen == ksize) {\n                        raise_error(\"Cannot access empty property\");\n                      } else {\n                        throwMangledPrivateProperty();\n                      }\n                    }\n                  }\n                  auto const lval = obj->makeDynProp(key.get());\n                  unserializePropertyValue(lval, remainingProps--);\n                }\n              }\n            }\n          }\n          if (remainingProps > 0) {\n            INC_TPC(unser_prop_slow);\n            unserializeRemainingProps(obj, remainingProps,\n                                      serializedNativeData,\n                                      hasSerializedNativeData);\n            remainingProps = 0;\n          } else {\n            INC_TPC(unser_prop_fast);\n          }\n\n          // Verify that all the unserialized properties satisfy their\n          // type-hints. Its safe to do it like this (after we've set the values\n          // in the properties) because this object hasn't escaped to the\n          // outside world yet.\n          obj->verifyPropTypeHints();\n\n          // nativeDataWakeup is called last to ensure that all properties are\n          // already unserialized. We also ensure that nativeDataWakeup is\n          // invoked regardless of whether or not serialized native data exists\n          // within the serialized content.\n          if (obj->hasNativeData() &&\n              obj->getVMClass()->getNativeDataInfo()->isSerializable()) {\n            Native::nativeDataWakeup(obj.get(), serializedNativeData);\n          } else if (hasSerializedNativeData) {\n            raise_warning(\"%s does not expect any serialized native data.\",\n                          clsName.data());\n          }\n        } else {\n          assertx(type == 'V' || type == 'K');\n          if (!obj->isCollection()) {\n            throwNotCollection(clsName);\n          }\n          unserializeCollection(obj.get(), size, type);\n        }\n      }\n      expectChar('}');\n\n      if (cls &&\n          cls->lookupMethod(s___wakeup.get()) &&\n          (this->type() != VariableUnserializer::Type::DebuggerSerialize ||\n           (cls->instanceCtor() && cls->isCppSerializable()))) {\n        // Don't call wakeup when unserializing for the debugger, except for\n        // natively implemented classes.\n        addSleepingObject(obj);\n      }\n\n      check_non_safepoint_surprise();\n    }\n    return; // object has '}' terminating\n  case 'C':\n    {\n      if (this->type() == VariableUnserializer::Type::DebuggerSerialize) {\n        raise_error(\"Debugger shouldn't call custom unserialize method\");\n      }\n      String clsName = unserializeString();\n\n      expectChar(':');\n      String serialized = unserializeString('{', '}');\n\n      auto obj = [&]() -> Object {\n        if (whitelistCheck(clsName)) {\n          // Try loading without the autoloader first\n          auto cls = Unit::getClass(clsName.get(), /* autoload */ false);\n          if (!cls) {\n            if (!is_valid_class_name(clsName.slice())) {\n              throwInvalidClassName();\n            }\n            cls = Unit::loadClass(clsName.get());\n          }\n          if (cls) {\n            return Object::attach(g_context->createObject(cls, init_null_variant,\n                                                          false /* init */));\n          }\n        }\n        if (!allowUnknownSerializableClass()) {\n          raise_error(\"unknown class %s\", clsName.data());\n        }\n        warnOrThrowUnknownClass(clsName);\n        Object ret = create_object_only(s_PHP_Incomplete_Class);\n        ret->setProp(nullptr, s_PHP_Incomplete_Class_Name.get(),\n                     clsName.asTypedValue());\n        ret->setProp(nullptr, s_serialized.get(), serialized.asTypedValue());\n        return ret;\n      }();\n\n      if (!obj->instanceof(SystemLib::s_SerializableClass)) {\n        raise_warning(\"Class %s has no unserializer\",\n                      obj->getClassName().data());\n      } else {\n        obj->o_invoke_few_args(s_unserialize, 1, serialized);\n      }\n\n      tvMove(make_tv<KindOfObject>(obj.detach()), self);\n    }\n    return; // object has '}' terminating\n  default:\n    throwUnknownType(type);\n  }\n  expectChar(';');\n}\n\nArray VariableUnserializer::unserializeArray() {\n  int64_t size = readInt();\n  expectChar(':');\n  expectChar('{');\n  if (size == 0) {\n    expectChar('}');\n    return m_forceDArrays || type() == Type::Serialize\n      ? Array::CreateDArray()\n      : Array::Create();\n  }\n  if (UNLIKELY(size < 0 || size > std::numeric_limits<int>::max())) {\n    throwArraySizeOutOfBounds();\n  }\n  // For large arrays, do a naive pre-check for OOM.\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(size);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  // Pre-allocate an ArrayData of the given size, to avoid escalation in the\n  // middle, which breaks references.\n  auto arr = m_forceDArrays || type() == Type::Serialize\n    ? DArrayInit(size).toArray()\n    : MixedArrayInit(size).toArray();\n  reserveForAdd(size);\n\n  for (int64_t i = 0; i < size; i++) {\n    Variant key;\n    unserializeVariant(key.asTypedValue(), UnserializeMode::Key);\n    if (!key.isString() && !key.isInteger()) throwInvalidKey();\n    unserializeVariant(MixedArray::LvalInPlace(arr.get(), key));\n    if (i < size - 1) checkElemTermination();\n  }\n\n  check_non_safepoint_surprise();\n  expectChar('}');\n  return arr;\n}\n\narrprov::Tag VariableUnserializer::unserializeProvenanceTag() {\n  auto const finish = [&] (auto tag) -> arrprov::Tag {\n    if (!RuntimeOption::EvalArrayProvenance) return {};\n    return tag;\n  };\n\n  auto const read_filename = [&]() -> const StringData* {\n    if (peek() == 't') {\n      assertx(m_unitFilename);\n      expectChar('t');\n      return m_unitFilename;\n    } else {\n      expectChar('s');\n      expectChar(':');\n      return makeStaticString(unserializeString().get());\n    }\n  };\n\n  if (type() != VariableUnserializer::Type::Internal) return {};\n  if (peek() == 'p') {\n    expectChar('p');\n    expectChar(':');\n    expectChar('i');\n    expectChar(':');\n    auto const line = static_cast<int>(readInt());\n    expectChar(';');\n    auto const filename = read_filename();\n    expectChar(';');\n    return finish(\n      arrprov::Tag { filename, line }\n    );\n  } else if (peek() == 'P') {\n    expectChar('P');\n    expectChar(';');\n    return finish(\n      arrprov::Tag::RepoUnion()\n    );\n  } else if (peek() == 'r') {\n    expectChar('r');\n    expectChar(':');\n    auto const filename = read_filename();\n    expectChar(';');\n    return finish(\n      arrprov::Tag::TraitMerge(filename)\n    );\n  } else if (peek() == 'e') {\n    expectChar('e');\n    expectChar(':');\n    auto const filename = read_filename();\n    expectChar(';');\n    return finish(\n      arrprov::Tag::LargeEnum(filename)\n    );\n  } else {\n    return {};\n  }\n}\n\nArray VariableUnserializer::unserializeDict() {\n  if (m_dvOverrides) m_dvOverrides->push_back(false);\n\n  int64_t size = readInt();\n  expectChar(':');\n  expectChar('{');\n\n  auto provTag = unserializeProvenanceTag();\n  if (!RO::EvalArrProvHackArrays) provTag = {};\n\n  if (size == 0) {\n    expectChar('}');\n    return Array::attach(provTag\n      ? arrprov::tagStaticArr(staticEmptyDictArray(), provTag)\n      : staticEmptyDictArray()\n    );\n  }\n  if (UNLIKELY(size < 0 || size > std::numeric_limits<int>::max())) {\n    throwArraySizeOutOfBounds();\n  }\n\n  // For large arrays, do a naive pre-check for OOM.\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(size);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  Array arr = DictInit(size).toArray();\n  for (int64_t i = 0; i < size; i++) {\n    Variant key;\n    unserializeVariant(key.asTypedValue(), UnserializeMode::Key);\n    if (!key.isString() && !key.isInteger()) throwInvalidKey();\n    unserializeVariant(MixedArray::LvalInPlace(arr.get(), key));\n    if (i < size - 1) checkElemTermination();\n  }\n\n  check_non_safepoint_surprise();\n  expectChar('}');\n  if (provTag) arrprov::setTag<arrprov::Mode::Emplace>(arr.get(), provTag);\n  return arr;\n}\n\nArray VariableUnserializer::unserializeVec() {\n  if (m_dvOverrides) m_dvOverrides->push_back(false);\n\n  int64_t size = readInt();\n  expectChar(':');\n  expectChar('{');\n\n  auto provTag = unserializeProvenanceTag();\n  if (!RO::EvalArrProvHackArrays) provTag = {};\n\n  if (size == 0) {\n    expectChar('}');\n    return Array::attach(provTag\n      ? arrprov::tagStaticArr(staticEmptyVec(), provTag)\n      : staticEmptyVec()\n    );\n  }\n  if (UNLIKELY(size < 0 || size > std::numeric_limits<int>::max())) {\n    throwArraySizeOutOfBounds();\n  }\n  auto const sizeClass = PackedArray::capacityToSizeIndex(size);\n  auto const allocsz = MemoryManager::sizeIndex2Size(sizeClass);\n\n  // For large arrays, do a naive pre-check for OOM.\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  Array arr = VecInit(size).toArray();\n  reserveForAdd(size);\n\n  for (int64_t i = 0; i < size; i++) {\n    unserializeVariant(PackedArray::LvalNewInPlace(arr.get()));\n    if (i < size - 1) checkElemTermination();\n  }\n  check_non_safepoint_surprise();\n  expectChar('}');\n  if (provTag) arrprov::setTag<arrprov::Mode::Emplace>(arr.get(), provTag);\n  return arr;\n}\n\nArray VariableUnserializer::unserializeVArray() {\n  if (m_dvOverrides) m_dvOverrides->push_back(true);\n\n  int64_t size = readInt();\n  expectChar(':');\n  expectChar('{');\n\n  auto provTag = unserializeProvenanceTag();\n  if (!RO::EvalArrProvDVArrays) provTag = {};\n\n  if (size == 0) {\n    expectChar('}');\n    if (m_type != Type::Serialize) {\n      return Array::attach(provTag\n        ? arrprov::tagStaticArr(staticEmptyVArray(), provTag)\n        : staticEmptyVArray()\n      );\n    }\n    return m_forceDArrays\n      ? Array::attach(provTag\n          ? arrprov::tagStaticArr(staticEmptyDArray(), provTag)\n          : staticEmptyDArray()\n        )\n      : Array::attach(provTag\n          ? arrprov::tagStaticArr(staticEmptyVArray(), provTag)\n          : staticEmptyVArray()\n        );\n  }\n  if (UNLIKELY(size < 0 || size > std::numeric_limits<int>::max())) {\n    throwArraySizeOutOfBounds();\n  }\n\n  auto const oomCheck = [&](size_t allocsz) {\n    // For large arrays, do a naive pre-check for OOM.\n    if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n      check_non_safepoint_surprise();\n    }\n  };\n\n  auto arr = Array{};\n  if (m_forceDArrays && m_type == Type::Serialize) {\n    // Deserialize to vector-ish darray. Use direct calls to MixedArray.\n    oomCheck(MixedArray::computeAllocBytesFromMaxElms(size));\n\n    arr = DArrayInit(size).toArray();\n    reserveForAdd(size);\n\n    for (int64_t i = 0; i < size; i++) {\n      unserializeVariant(MixedArray::LvalInPlace(arr.get(), i));\n      if (i < size - 1) checkElemTermination();\n    }\n  } else {\n    // Deserialize to varray. Use direct calls to MixedArray.\n    auto const index = PackedArray::capacityToSizeIndex(size);\n    oomCheck(MemoryManager::sizeIndex2Size(index));\n\n    arr = VArrayInit(size).toArray();\n    reserveForAdd(size);\n\n    for (int64_t i = 0; i < size; i++) {\n      unserializeVariant(PackedArray::LvalNewInPlace(arr.get()));\n      if (i < size - 1) checkElemTermination();\n    }\n  }\n\n  check_non_safepoint_surprise();\n  expectChar('}');\n  if (provTag) arrprov::setTag<arrprov::Mode::Emplace>(arr.get(), provTag);\n  return arr;\n}\n\nArray VariableUnserializer::unserializeDArray() {\n  if (m_dvOverrides) m_dvOverrides->push_back(true);\n\n  int64_t size = readInt();\n  expectChar(':');\n  expectChar('{');\n\n  auto provTag = unserializeProvenanceTag();\n  if (!RO::EvalArrProvDVArrays) provTag = {};\n\n  if (size == 0) {\n    expectChar('}');\n    return Array::attach(provTag\n      ? arrprov::tagStaticArr(staticEmptyDArray(), provTag)\n      : staticEmptyDArray()\n    );\n  }\n  if (UNLIKELY(size < 0 || size > std::numeric_limits<int>::max())) {\n    throwArraySizeOutOfBounds();\n  }\n\n  // For large arrays, do a naive pre-check for OOM.\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(size);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  auto arr = DArrayInit(size).toArray();\n  reserveForAdd(size);\n\n  for (int64_t i = 0; i < size; i++) {\n    Variant key;\n    unserializeVariant(key.asTypedValue(), UnserializeMode::Key);\n    if (!key.isString() && !key.isInteger()) throwInvalidKey();\n    unserializeVariant(MixedArray::LvalInPlace(arr.get(), key));\n    if (i < size - 1) checkElemTermination();\n  }\n\n  check_non_safepoint_surprise();\n  expectChar('}');\n  if (provTag) arrprov::setTag<arrprov::Mode::Emplace>(arr.get(), provTag);\n  return arr;\n}\n\nArray VariableUnserializer::unserializeKeyset() {\n  int64_t size = readInt();\n  expectChar(':');\n  expectChar('{');\n  if (size == 0) {\n    expectChar('}');\n    return Array::CreateKeyset();\n  }\n  if (UNLIKELY(size < 0 || size > std::numeric_limits<int>::max())) {\n    throwArraySizeOutOfBounds();\n  }\n\n  // For large arrays, do a naive pre-check for OOM.\n  auto const allocsz = SetArray::computeAllocBytesFromMaxElms(size);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  KeysetInit init(size);\n  for (int64_t i = 0; i < size; i++) {\n    Variant key;\n    // Use key mode to stop the unserializer from keeping a pointer to this\n    // variant (since its stack-allocated).\n    unserializeVariant(key.asTypedValue(), UnserializeMode::Key);\n\n    auto const type = key.getType();\n    if (UNLIKELY(!isStringType(type) && !isIntType(type))) {\n      throwKeysetValue();\n    }\n\n    init.add(key);\n\n    if (i < (size - 1)) {\n      auto lastChar = peekBack();\n      if ((lastChar != ';' && lastChar != '}')) {\n        throwUnterminatedElement();\n      }\n    }\n  }\n  check_non_safepoint_surprise();\n  expectChar('}');\n  return init.toArray();\n}\n\n\nfolly::StringPiece\nVariableUnserializer::unserializeStringPiece(char delimiter0, char delimiter1) {\n  int64_t size = readInt();\n  if (size >= RuntimeOption::MaxSerializedStringSize) {\n    throwLargeStringSize(size);\n  }\n  if (size < 0) {\n    throwNegativeStringSize(size);\n  }\n  expectChar(':');\n  expectChar(delimiter0);\n  auto const piece = readStr(size);\n  expectChar(delimiter1);\n  return piece;\n}\n\nString VariableUnserializer::unserializeString(char delimiter0,\n                                               char delimiter1) {\n  auto const piece = unserializeStringPiece(delimiter0, delimiter1);\n  return String::attach(readOnly() ?\n                        makeStaticString(piece) :\n                        StringData::Make(piece, CopyString));\n}\n\nvoid VariableUnserializer::unserializeCollection(ObjectData* obj, int64_t sz,\n                                                 char type) {\n  switch (obj->collectionType()) {\n    case CollectionType::Pair:\n      unserializePair(obj, sz, type);\n      break;\n    case CollectionType::Vector:\n    case CollectionType::ImmVector:\n      unserializeVector(obj, sz, type);\n      break;\n    case CollectionType::Map:\n    case CollectionType::ImmMap:\n      unserializeMap(obj, sz, type);\n      break;\n    case CollectionType::Set:\n    case CollectionType::ImmSet:\n      unserializeSet(obj, sz, type);\n      break;\n  }\n}\n\nvoid VariableUnserializer::unserializeVector(ObjectData* obj, int64_t sz,\n                                             char type) {\n  if (type != 'V') throwBadFormat(obj, type);\n\n  auto const sizeClass = PackedArray::capacityToSizeIndex(sz);\n  auto const allocsz = MemoryManager::sizeIndex2Size(sizeClass);\n  // For large vectors, do a naive pre-check for OOM.\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  auto bvec = static_cast<BaseVector*>(obj);\n  bvec->reserve(sz);\n  reserveForAdd(sz);\n  for (int64_t i = 0; i < sz; ++i) {\n    auto tv = bvec->appendForUnserialize(i);\n    HPHP::type(tv) = KindOfNull;\n    unserializeVariant(tv);\n  }\n}\n\n/*\n * Attempts to unserialize into an initially empty HH\\Map of string->int/string.\n * Returns false and leaves both 'map' and 'uns' untouched on failure, including\n * unexpected types and possibly legal, but uncommon, encodings.\n */\nNEVER_INLINE\nbool VariableUnserializer::tryUnserializeStrIntMap(BaseMap* map, int64_t sz) {\n  auto b = head();\n  /*\n   * For efficiency, we don't add the keys/values to m_refs, so don't support\n   * back-references appearing after this point. For simplicity, we thus require\n   * this map to be the root object being unserialized.\n   */\n  if (folly::StringPiece(begin(), b) !=\n      folly::to<std::string>(\"K:6:\\\"HH\\\\Map\\\":\", sz, \":{\")) {\n    return false;\n  }\n  auto const end = this->end();\n  auto const maxKeyLen = RuntimeOption::MaxSerializedStringSize;\n  /*\n   * First, parse the entire input and allocate the keys (accessing lots of\n   * data, but mostly sequentially).\n   */\n  auto checkPoint = map->batchInsertBegin(sz);\n  int64_t i = 0;\n  for (; i < sz; ++i) {\n    auto sd = readStringData(b, end, maxKeyLen);\n    if (!sd) break;\n    String key = String::attach(sd);\n    auto tv = map->batchInsert(key.get());\n    tv->m_type = KindOfNull;\n    if (*b == 'i') {\n      if (!readInt64(b, end, tv->m_data.num)) break;\n      tv->m_type = KindOfInt64;\n    } else if (*b == 's') {\n      auto sd = readStringData(b, end, maxKeyLen);\n      if (!sd) break;\n      tv->m_data.pstr = sd;\n      tv->m_type = KindOfString;\n    } else {\n      break;\n    }\n  }\n  /*\n   * On success, finalize the hash table insertion (very random access).\n   */\n  if (i == sz && map->tryBatchInsertEnd(checkPoint)) {\n    set(b, end);\n    return true;\n  }\n  map->batchInsertAbort(checkPoint);\n  return false;\n}\n\nvoid VariableUnserializer::unserializeMap(ObjectData* obj, int64_t sz,\n                                          char type) {\n  if (type != 'K') throwBadFormat(obj, type);\n\n  // For large maps, do a naive pre-check for OOM.\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(sz);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  auto map = static_cast<BaseMap*>(obj);\n  map->reserve(sz);\n  if (sz >= RuntimeOption::UnserializationBigMapThreshold &&\n      tryUnserializeStrIntMap(map, sz)) {\n    return;\n  }\n\n  reserveForAdd(sz + sz); // keys + values\n  for (int64_t i = 0; i < sz; ++i) {\n    Variant k;\n    unserializeVariant(k.asTypedValue(), UnserializeMode::ColKey);\n    TypedValue* tv = nullptr;\n    if (k.isInteger()) {\n      auto h = k.toInt64();\n      tv = map->findForUnserialize(h);\n      // Be robust against manually crafted inputs with conflicting elements\n      if (UNLIKELY(!tv)) {\n        tv = k.asTypedValue();\n        goto do_unserialize;\n      }\n    } else if (k.isString()) {\n      auto key = k.getStringData();\n      tv = map->findForUnserialize(key);\n      // Be robust against manually crafted inputs with conflicting elements\n      if (UNLIKELY(!tv)) {\n        tv = k.asTypedValue();\n        goto do_unserialize;\n      }\n    } else {\n      throwInvalidKey();\n    }\n    tv->m_type = KindOfNull;\ndo_unserialize:\n    unserializeVariant(tv);\n  }\n}\n\nvoid VariableUnserializer::unserializeSet(ObjectData* obj, int64_t sz,\n                                          char type) {\n  if (type != 'V') throwBadFormat(obj, type);\n\n  // For large maps, do a naive pre-check for OOM.\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(sz);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  auto set = static_cast<BaseSet*>(obj);\n  set->reserve(sz);\n\n  reserveForAdd(sz);\n  for (int64_t i = 0; i < sz; ++i) {\n    // When unserializing an element of a Set, we use Mode::ColKey for now.\n    // This will make the unserializer to reserve an id for the element\n    // but won't allow referencing the element via 'r' or 'R'.\n    Variant k;\n    unserializeVariant(k.asTypedValue(), UnserializeMode::ColKey);\n    if (k.isInteger()) {\n      auto h = k.toInt64();\n      auto tv = set->findForUnserialize(h);\n      // Be robust against manually crafted inputs with conflicting elements\n      if (UNLIKELY(!tv)) continue;\n      tv->m_type = KindOfInt64;\n      tv->m_data.num = h;\n    } else if (k.isString()) {\n      auto key = k.getStringData();\n      auto tv = set->findForUnserialize(key);\n      if (UNLIKELY(!tv)) continue;\n      // This increments the string's refcount twice, once for\n      // the key and once for the value\n      tvDup(make_tv<KindOfString>(key), *tv);\n    } else {\n      throwInvalidHashKey(obj);\n    }\n  }\n}\n\nvoid VariableUnserializer::unserializePair(ObjectData* obj, int64_t sz,\n                                           char type) {\n  assertx(sz == 2);\n  if (type != 'V') throwBadFormat(obj, type);\n  auto pair = static_cast<c_Pair*>(obj);\n  unserializeVariant(pair->at(0));\n  unserializeVariant(pair->at(1));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid VariableUnserializer::reserialize(StringBuffer& buf) {\n\n  char type = readChar();\n  char sep = readChar();\n\n  if (type == 'N') {\n    buf.append(type);\n    buf.append(sep);\n    return;\n  }\n\n  switch (type) {\n  case 'r':\n  case 'R':\n  case 'b':\n  case 'i':\n  case 'd':\n    {\n      buf.append(type);\n      buf.append(sep);\n      while (peek() != ';') {\n        char ch;\n        ch = readChar();\n        buf.append(ch);\n      }\n    }\n    break;\n  case 'S':\n  case 'A':\n    {\n      // shouldn't happen, but keep the code here anyway.\n      buf.append(type);\n      buf.append(sep);\n      auto str = readStr(8);\n      buf.append(str.data(), str.size());\n    }\n    break;\n  case 's':\n    {\n      String v = unserializeString();\n      assertx(!v.isNull());\n      if (v.get()->isStatic()) {\n        union {\n          char pointer[8];\n          StringData *sd;\n        } u;\n        u.sd = v.get();\n        buf.append(\"S:\");\n        buf.append(u.pointer, 8);\n        buf.append(';');\n      } else {\n        buf.append(\"s:\");\n        buf.append(v.size());\n        buf.append(\":\\\"\");\n        buf.append(v.data(), v.size());\n        buf.append(\"\\\";\");\n      }\n      sep = readChar();\n      return;\n    }\n    break;\n  case 'a':\n  case 'D':\n  case 'Y':\n  case 'H':\n    {\n      buf.append(type == 'a' ? \"a:\" : (type == 'Y' ? \"Y:\" :\n            (type == 'D' ? \"D:\" : \"H:\")));\n      int64_t size = readInt();\n      char sep2 = readChar();\n      buf.append(size);\n      buf.append(sep2);\n      sep2 = readChar();\n      buf.append(sep2);\n      for (int64_t i = 0; i < size; i++) {\n        reserialize(buf); // key\n        reserialize(buf); // value\n      }\n      sep2 = readChar(); // '}'\n      buf.append(sep2);\n      return;\n    }\n    break;\n  case 'v':\n  case 'k':\n  case 'y':\n    {\n      buf.append(type == 'v' ? \"v:\" : (type == 'y' ? \"y:\" : \"k:\"));\n      int64_t size = readInt();\n      char sep2 = readChar();\n      buf.append(size);\n      buf.append(sep2);\n      sep2 = readChar();\n      buf.append(sep2);\n      for (int64_t i = 0; i < size; ++i) {\n        reserialize(buf);\n      }\n      sep2 = readChar(); // '}'\n      buf.append(sep2);\n      return;\n    }\n  case 'o':\n  case 'O':\n  case 'V':\n  case 'K':\n    {\n      buf.append(type);\n      buf.append(sep);\n\n      auto const clsName = unserializeStringPiece();\n      buf.append(static_cast<int>(clsName.size()));\n      buf.append(\":\\\"\");\n      buf.append(clsName.data(), clsName.size());\n      buf.append(\"\\\":\");\n\n      readChar();\n      int64_t size = readInt();\n      char sep2 = readChar();\n\n      buf.append(size);\n      buf.append(sep2);\n      sep2 = readChar(); // '{'\n      buf.append(sep2);\n      // 'V' type is a series with values only, while all other\n      // types are series with keys and values\n      int64_t i = type == 'V' ? size : size * 2;\n      while (i--) {\n        reserialize(buf);\n      }\n      sep2 = readChar(); // '}'\n      buf.append(sep2);\n      return;\n    }\n    break;\n  case 'C':\n    {\n      buf.append(type);\n      buf.append(sep);\n\n      auto const clsName = unserializeStringPiece();\n      buf.append(static_cast<int>(clsName.size()));\n      buf.append(\":\\\"\");\n      buf.append(clsName.data(), clsName.size());\n      buf.append(\"\\\":\");\n\n      sep = readChar(); // ':'\n      auto const serialized = unserializeStringPiece('{', '}');\n      buf.append(static_cast<int>(serialized.size()));\n      buf.append(\":{\");\n      buf.append(serialized.data(), serialized.size());\n      buf.append('}');\n      return;\n    }\n    break;\n  default:\n    throwUnknownType(type);\n  }\n\n  sep = readChar(); // the last ';'\n  buf.append(sep);\n}\n\n}\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-present Facebook, Inc. (http://www.facebook.com)  |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/base/object-data.h\"\n\n#include \"hphp/runtime/base/array-init.h\"\n#include \"hphp/runtime/base/builtin-functions.h\"\n#include \"hphp/runtime/base/collections.h\"\n#include \"hphp/runtime/base/container-functions.h\"\n#include \"hphp/runtime/base/exceptions.h\"\n#include \"hphp/runtime/base/execution-context.h\"\n#include \"hphp/runtime/base/mixed-array-defs.h\"\n#include \"hphp/runtime/base/object-iterator.h\"\n#include \"hphp/runtime/base/runtime-error.h\"\n#include \"hphp/runtime/base/request-info.h\"\n#include \"hphp/runtime/base/tv-comparisons.h\"\n#include \"hphp/runtime/base/tv-refcount.h\"\n#include \"hphp/runtime/base/tv-type.h\"\n#include \"hphp/runtime/base/type-variant.h\"\n#include \"hphp/runtime/base/variable-serializer.h\"\n\n#include \"hphp/runtime/ext/generator/ext_generator.h\"\n#include \"hphp/runtime/ext/simplexml/ext_simplexml.h\"\n#include \"hphp/runtime/ext/datetime/ext_datetime.h\"\n#include \"hphp/runtime/ext/std/ext_std_closure.h\"\n\n#include \"hphp/runtime/vm/class.h\"\n#include \"hphp/runtime/vm/member-operations.h\"\n#include \"hphp/runtime/vm/memo-cache.h\"\n#include \"hphp/runtime/vm/native-data.h\"\n#include \"hphp/runtime/vm/native-prop-handler.h\"\n#include \"hphp/runtime/vm/jit/translator-inline.h\"\n#include \"hphp/runtime/vm/repo.h\"\n#include \"hphp/runtime/vm/repo-global-data.h\"\n\n#include \"hphp/system/systemlib.h\"\n\n#include <folly/Hash.h>\n#include <folly/ScopeGuard.h>\n\n#include <vector>\n\nnamespace HPHP {\n\n//////////////////////////////////////////////////////////////////////\n\nTRACE_SET_MOD(runtime);\n\n//////////////////////////////////////////////////////////////////////\n\nnamespace {\n\nconst StaticString s_clone(\"__clone\");\n\nALWAYS_INLINE\nvoid verifyTypeHint(const Class* thisCls,\n                    const Class::Prop* prop,\n                    tv_lval val) {\n  assertx(tvIsPlausible(*val));\n  assertx(type(val) != KindOfUninit);\n  if (!prop || RuntimeOption::EvalCheckPropTypeHints <= 0) return;\n  if (prop->typeConstraint.isCheckable()) {\n    prop->typeConstraint.verifyProperty(val, thisCls, prop->cls, prop->name);\n  }\n  if (RuntimeOption::EvalEnforceGenericsUB <= 0) return;\n  for (auto const& ub : prop->ubs) {\n    if (ub.isCheckable()) {\n      ub.verifyProperty(val, thisCls, prop->cls, prop->name);\n    }\n  }\n}\n\nALWAYS_INLINE\nvoid unsetTypeHint(const Class::Prop* prop) {\n  if (RuntimeOption::EvalCheckPropTypeHints <= 0) return;\n  if (!prop || prop->typeConstraint.isMixedResolved()) return;\n  raise_property_typehint_unset_error(\n    prop->cls,\n    prop->name,\n    prop->typeConstraint.isSoft(),\n    prop->typeConstraint.isUpperBound()\n  );\n}\n\n}\n\n//////////////////////////////////////////////////////////////////////\n\n// Check that the given property's type matches its type-hint.\nnamespace {\nbool assertATypeHint(const TypeConstraint& tc, tv_rval val) {\n  if (!tc.isCheckable() || tc.isSoft()) return true;\n  if (val.type() == KindOfUninit) return tc.maybeMixed();\n  return tc.assertCheck(val);\n}\n}\n\nbool ObjectData::assertTypeHint(tv_rval prop, Slot slot) const {\n  assertx(tvIsPlausible(*prop));\n  assertx(slot < m_cls->numDeclProperties());\n  auto const& propDecl = m_cls->declProperties()[slot];\n\n  if (debug && RuntimeOption::RepoAuthoritative) {\n    // The fact that uninitialized LateInit props are uninint isn't\n    // reflected in the repo-auth-type.\n    if (prop.type() != KindOfUninit || !(propDecl.attrs & AttrLateInit)) {\n      always_assert(tvMatchesRepoAuthType(*prop, propDecl.repoAuthType));\n    }\n  }\n\n  // If we're not hard enforcing, then the prop might contain anything.\n  if (RuntimeOption::EvalCheckPropTypeHints <= 2) return true;\n  if (!propDecl.typeConstraint.isCheckable() ||\n      propDecl.typeConstraint.isSoft()) return true;\n  if (propDecl.typeConstraint.isUpperBound() &&\n      RuntimeOption::EvalEnforceGenericsUB < 2) return true;\n  if (prop.type() == KindOfNull && !(propDecl.attrs & AttrNoImplicitNullable)) {\n    return true;\n  }\n  if (prop.type() == KindOfUninit && (propDecl.attrs & AttrLateInit)) {\n    return true;\n  }\n  assertATypeHint(propDecl.typeConstraint, prop);\n  if (RuntimeOption::EvalEnforceGenericsUB <= 2) return true;\n  for (auto const& ub : propDecl.ubs) {\n    if (!assertATypeHint(ub, prop)) return false;\n  }\n  return true;\n}\n\n//////////////////////////////////////////////////////////////////////\n\nNEVER_INLINE\nstatic void freeDynPropArray(ObjectData* inst) {\n  auto& table = g_context->dynPropTable;\n  auto it = table.find(inst);\n  assertx(it != end(table));\n  assertx(it->second.arr().isPHPArray());\n  it->second.destroy();\n  table.erase(it);\n}\n\nNEVER_INLINE\nvoid ObjectData::slowDestroyCases() {\n  assertx(slowDestroyCheck());\n\n  if (getAttribute(UsedMemoCache)) {\n    assertx(m_cls->hasMemoSlots());\n    auto const nSlots = m_cls->numMemoSlots();\n    for (Slot i = 0; i < nSlots; ++i) {\n      auto slot = memoSlot(i);\n      if (slot->isCache()) {\n        if (auto cache = slot->getCache()) req::destroy_raw(cache);\n      } else {\n        tvDecRefGen(*slot->getValue());\n      }\n    }\n  }\n\n  if (UNLIKELY(getAttribute(HasDynPropArr))) freeDynPropArray(this);\n  if (UNLIKELY(getAttribute(IsWeakRefed))) {\n    WeakRefData::invalidateWeakRef((uintptr_t)this);\n  }\n\n  auto const memoSize = m_cls->memoSize();\n  auto const ptr = reinterpret_cast<char*>(this) - memoSize;\n  tl_heap->objFreeIndex(ptr, m_cls->sizeIdx());\n}\n\n// Single check for a couple different unlikely actions during destruction.\ninline bool ObjectData::slowDestroyCheck() const {\n  return m_aux16 & (HasDynPropArr | IsWeakRefed | UsedMemoCache | BigAllocSize);\n}\n\nvoid ObjectData::release(ObjectData* obj, const Class* cls) noexcept {\n  assertx(obj->kindIsValid());\n  assertx(!obj->hasInstanceDtor());\n  assertx(!obj->hasNativeData());\n  assertx(obj->getVMClass() == cls);\n  assertx(cls->releaseFunc() == &ObjectData::release);\n  assertx(obj->props()->checkInvariants(cls->numDeclProperties()));\n\n  // Note: cleanups done in this function are only run for classes without an\n  // instanceDtor. Some of these cleanups are duplicated in ~ObjectData, and\n  // your instanceDtor may call that to have them run; if you choose not to run\n  // ~ObjectData from your instanceDtor you MUST do some of them manually\n  // (e.g. invalidate WeakRefs). Some cleanups (e.g. clearing memo caches) are\n  // not done from ~ObjectData because it is assumed they're not needed for\n  // builtin classes (and in the case of memo caches, since the clearing needs\n  // to be done differently when there is native data).\n  // Finally, cleanups such as invalidating WeakRefs that have to be done for\n  // correctness MUST also be done in Collector::sweep, since none of the code\n  // in this function or the instanceDtor will be run when the object is\n  // collected by GC.\n\n  // `obj' is being torn down now---be careful about where/how you dereference\n  // it from here on.\n\n  obj->props()->release(cls->countablePropsEnd());\n\n  if (UNLIKELY(obj->slowDestroyCheck())) {\n    obj->slowDestroyCases();\n  } else {\n    assertx((obj->m_aux16 & BigAllocSize) == 0);\n    auto const memoSize = cls->memoSize();\n    auto const ptr = reinterpret_cast<char*>(obj) - memoSize;\n    assertx(memoSize == 0 ||\n            reinterpret_cast<const MemoNode*>(ptr)->objOff() == memoSize);\n\n    tl_heap->freeSmallIndex(ptr, cls->sizeIdx());\n  }\n\n  AARCH64_WALKABLE_FRAME();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// class info\n\nStrNR ObjectData::getClassName() const {\n  return m_cls->preClass()->nameStr();\n}\n\nbool ObjectData::instanceof(const String& s) const {\n  assertx(kindIsValid());\n  auto const cls = Unit::lookupClass(s.get());\n  return cls && instanceof(cls);\n}\n\nbool ObjectData::toBooleanImpl() const noexcept {\n  // Note: if you add more cases here, hhbbc/class-util.cpp also needs\n  // to be changed.\n  if (isCollection()) {\n    if (RuntimeOption::EvalNoticeOnCollectionToBool) {\n      raise_notice(\n        \"%s to boolean cast\",\n        collections::typeToString((CollectionType)m_kind)->data()\n      );\n    }\n    return collections::toBool(this);\n  }\n\n  if (instanceof(SimpleXMLElement_classof())) {\n    // SimpleXMLElement is the only non-collection class that has custom bool\n    // casting.\n    if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {\n      raise_notice(\"SimpleXMLElement to boolean cast\");\n    }\n    return SimpleXMLElement_objectCast(this, KindOfBoolean).toBoolean();\n  }\n\n  always_assert(false);\n  return false;\n}\n\nint64_t ObjectData::toInt64Impl() const noexcept {\n  // SimpleXMLElement is the only class that has proper custom int casting.\n  assertx(instanceof(SimpleXMLElement_classof()));\n  if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {\n    raise_notice(\"SimpleXMLElement to integer cast\");\n  }\n  return SimpleXMLElement_objectCast(this, KindOfInt64).toInt64();\n}\n\ndouble ObjectData::toDoubleImpl() const noexcept {\n  // SimpleXMLElement is the only class that has custom double casting.\n  assertx(instanceof(SimpleXMLElement_classof()));\n  if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {\n    raise_notice(\"SimpleXMLElement to double cast\");\n  }\n  return SimpleXMLElement_objectCast(this, KindOfDouble).toDouble();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// instance methods and properties\n\nconst StaticString s_getIterator(\"getIterator\");\n\nObject ObjectData::iterableObject(bool& isIterable,\n                                  bool mayImplementIterator /* = true */) {\n  assertx(mayImplementIterator || !isIterator());\n  if (mayImplementIterator && isIterator()) {\n    isIterable = true;\n    return Object(this);\n  }\n  Object obj(this);\n  while (obj->instanceof(SystemLib::s_IteratorAggregateClass)) {\n    auto iterator = obj->o_invoke_few_args(s_getIterator, 0);\n    if (!iterator.isObject()) break;\n    auto o = iterator.getObjectData();\n    if (o->isIterator()) {\n      isIterable = true;\n      return Object{o};\n    }\n    obj.reset(o);\n  }\n  if (!isIterator() && obj->instanceof(SimpleXMLElement_classof())) {\n    if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {\n      raise_notice(\"SimpleXMLElement used as iterator\");\n    }\n    isIterable = true;\n    return create_object(\n      s_SimpleXMLElementIterator,\n      make_vec_array(obj)\n    );\n  }\n  isIterable = false;\n  return obj;\n}\n\nArray& ObjectData::dynPropArray() const {\n  assertx(getAttribute(HasDynPropArr));\n  assertx(g_context->dynPropTable.count(this));\n  assertx(g_context->dynPropTable[this].arr().isPHPArray());\n  return g_context->dynPropTable[this].arr();\n}\n\nvoid ObjectData::setDynProps(const Array& newArr) {\n  // don't expose the ref returned by setDynPropArr\n  (void)setDynPropArray(newArr);\n}\n\nvoid ObjectData::reserveDynProps(int numDynamic) {\n  // don't expose the ref returned by reserveProperties()\n  (void)reserveProperties(numDynamic);\n}\n\nArray& ObjectData::reserveProperties(int numDynamic /* = 2 */) {\n  if (getAttribute(HasDynPropArr)) {\n    return dynPropArray();\n  }\n\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(numDynamic);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  return setDynPropArray(\n      Array::attach(MixedArray::MakeReserveMixed(numDynamic))\n  );\n}\n\nArray& ObjectData::setDynPropArray(const Array& newArr) {\n  assertx(!g_context->dynPropTable.count(this));\n  assertx(!getAttribute(HasDynPropArr));\n  assertx(newArr.isPHPArray());\n\n  if (m_cls->forbidsDynamicProps()) {\n    throw_object_forbids_dynamic_props(getClassName().data());\n  }\n  if (RuntimeOption::EvalNoticeOnCreateDynamicProp) {\n    IterateKV(newArr.get(), [&] (TypedValue k, TypedValue v) {\n      auto const key = tvCastToString(k);\n      raiseCreateDynamicProp(key.get());\n    });\n  }\n\n  // newArr can have refcount 2 or higher\n  auto& arr = g_context->dynPropTable[this].arr();\n  assertx(arr.isPHPArray());\n  arr = newArr;\n  setAttribute(HasDynPropArr);\n  return arr;\n}\n\ntv_lval ObjectData::makeDynProp(const StringData* key) {\n  if (RuntimeOption::EvalNoticeOnCreateDynamicProp) {\n    raiseCreateDynamicProp(key);\n  }\n  return reserveProperties().lvalForce(StrNR(key), AccessFlags::Key);\n}\n\nvoid ObjectData::setDynProp(const StringData* key, TypedValue val) {\n  if (RuntimeOption::EvalNoticeOnCreateDynamicProp) {\n    raiseCreateDynamicProp(key);\n  }\n  reserveProperties().set(StrNR(key), val, true);\n}\n\nVariant ObjectData::o_get(const String& propName, bool error /* = true */,\n                          const String& context /*= null_string*/) {\n  assertx(kindIsValid());\n\n  // This is not (just) a check for empty string; property names that start\n  // with null are intentionally being rejected here.\n  if (UNLIKELY(!*propName.data())) {\n    throw_invalid_property_name(propName);\n  }\n\n  Class* ctx = nullptr;\n  if (!context.empty()) {\n    ctx = Unit::lookupClass(context.get());\n  }\n\n  // Can't use propImpl here because if the property is not accessible and\n  // there is no native get, propImpl will raise_error(\"Cannot access ...\",\n  // but o_get will only (maybe) raise_notice(\"Undefined property ...\" :-(\n\n  auto const lookup = getPropImpl<false, true, true>(ctx, propName.get());\n  if (lookup.val && lookup.accessible) {\n    if (lookup.val.type() != KindOfUninit) {\n      return Variant::wrap(lookup.val.tv());\n    } else if (lookup.prop && (lookup.prop->attrs & AttrLateInit)) {\n      if (error) throw_late_init_prop(lookup.prop->cls, propName.get(), false);\n      return uninit_null();\n    }\n  }\n\n  if (error) {\n    raise_notice(\"Undefined property: %s::$%s\", getClassName().data(),\n                 propName.data());\n  }\n\n  return uninit_null();\n}\n\nvoid ObjectData::o_set(const String& propName, const Variant& v,\n                       const String& context /* = null_string */) {\n  assertx(kindIsValid());\n\n  // This is not (just) a check for empty string; property names that start\n  // with null are intentionally being rejected here.\n  if (UNLIKELY(!*propName.data())) {\n    throw_invalid_property_name(propName);\n  }\n\n  Class* ctx = nullptr;\n  if (!context.empty()) {\n    ctx = Unit::lookupClass(context.get());\n  }\n\n  // Can't use setProp here because if the property is not accessible and\n  // there is no native set, setProp will raise_error(\"Cannot access ...\",\n  // but o_set will skip writing and return normally.\n\n  auto const lookup = getPropImpl<true, false, true>(ctx, propName.get());\n  auto prop = lookup.val;\n  if (prop && lookup.accessible) {\n    if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {\n      throwMutateConstProp(lookup.slot);\n    }\n    auto val = tvToInit(*v.asTypedValue());\n    verifyTypeHint(m_cls, lookup.prop, &val);\n    tvSet(val, prop);\n    return;\n  }\n\n  if (!prop) {\n    setDynProp(propName.get(), tvToInit(*v.asTypedValue()));\n  }\n}\n\nvoid ObjectData::o_setArray(const Array& properties) {\n  for (ArrayIter iter(properties); iter; ++iter) {\n    String k = iter.first().toString();\n    Class* ctx = nullptr;\n    // If the key begins with a NUL, it's a private or protected property. Read\n    // the class name from between the two NUL bytes.\n    //\n    // Note: if you change this, you need to change similar logic in\n    // apc-object.\n    if (!k.empty() && k[0] == '\\0') {\n      int subLen = k.find('\\0', 1) + 1;\n      String cls = k.substr(1, subLen - 2);\n      if (cls.size() == 1 && cls[0] == '*') {\n        // Protected.\n        ctx = m_cls;\n      } else {\n        // Private.\n        ctx = Unit::lookupClass(cls.get());\n        if (!ctx) continue;\n      }\n      k = k.substr(subLen);\n    }\n\n    setProp(ctx, k.get(), tvAssertPlausible(iter.secondVal()));\n  }\n}\n\nvoid ObjectData::o_getArray(Array& props,\n                            bool pubOnly /* = false */,\n                            bool ignoreLateInit /* = false */) const {\n  assertx(kindIsValid());\n\n  // Fast path for classes with no declared properties\n  if (!m_cls->numDeclProperties() && getAttribute(HasDynPropArr)) {\n    props = dynPropArray();\n    if (RuntimeOption::EvalNoticeOnReadDynamicProp) {\n      IterateKV(props.get(), [&](TypedValue k, TypedValue) {\n        auto const key = tvCastToString(k);\n        raiseReadDynamicProp(key.get());\n      });\n    }\n    return;\n  }\n\n  auto cls = m_cls;\n  if (cls->hasReifiedGenerics()) {\n    auto const slot = cls->lookupReifiedInitProp();\n    assertx(slot != kInvalidSlot);\n    auto const declProps = cls->declProperties();\n    auto const prop = declProps[slot];\n    auto val = this->propRvalAtOffset(slot);\n    props.set(StrNR(prop.name).asString(), val.tv());\n  }\n  IteratePropToArrayOrderNoInc(\n    this,\n    [&](Slot slot, const Class::Prop& prop, tv_rval val) {\n      assertx(assertTypeHint(val, slot));\n      if (UNLIKELY(val.type() == KindOfUninit)) {\n        if (!ignoreLateInit && (prop.attrs & AttrLateInit)) {\n          throw_late_init_prop(prop.cls, prop.name, false);\n        }\n      } else if (!pubOnly || (prop.attrs & AttrPublic)) {\n        // Skip all the reified properties since we already prepended the\n        // current class' reified property to the list\n        if (prop.name != s_86reified_prop.get()) {\n          props.set(StrNR(prop.mangledName).asString(), val.tv());\n        }\n      }\n    },\n    [&](TypedValue key_tv, TypedValue val) {\n      props.set(key_tv, val, true);\n      if (RuntimeOption::EvalNoticeOnReadDynamicProp) {\n        auto const key = tvCastToString(key_tv);\n        raiseReadDynamicProp(key.get());\n      }\n    }\n  );\n}\n\n// a constant for ArrayIterators that changes the way the\n// object is converted to an array\nconst int64_t ARRAY_OBJ_ITERATOR_STD_PROP_LIST = 1;\n\nconst StaticString s_flags(\"flags\"),\n                   s_storage(\"storage\");\n\ntemplate <IntishCast IC /* = IntishCast::None */>\nArray ObjectData::toArray(bool pubOnly /* = false */,\n                          bool ignoreLateInit /* = false */) const {\n  assertx(kindIsValid());\n\n  // We can quickly tell if this object is a collection, which lets us avoid\n  // checking for each class in turn if it's not one.\n  if (isCollection()) {\n    return collections::toArray<IC>(this);\n  } else if (UNLIKELY(m_cls->rtAttribute(Class::CallToImpl))) {\n    // If we end up with other classes that need special behavior, turn the\n    // assert into an if and add cases.\n    assertx(instanceof(SimpleXMLElement_classof()));\n    if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {\n      raise_notice(\"SimpleXMLElement to array cast\");\n    }\n    return SimpleXMLElement_objectCast(this, KindOfArray).toArray();\n  } else if (UNLIKELY(instanceof(SystemLib::s_ArrayIteratorClass))) {\n    auto const flags = getProp(SystemLib::s_ArrayIteratorClass, s_flags.get());\n    assertx(flags.is_set());\n    if (UNLIKELY(flags.type() == KindOfInt64 &&\n                 flags.val().num == ARRAY_OBJ_ITERATOR_STD_PROP_LIST)) {\n      auto ret = Array::CreateDArray();\n      o_getArray(ret, true, ignoreLateInit);\n      return ret;\n    }\n\n    check_recursion_throw();\n\n    auto const storage = getProp(SystemLib::s_ArrayIteratorClass, s_storage.get());\n    assertx(storage.is_set());\n    return tvCastToArrayLike(storage.tv());\n  } else if (UNLIKELY(instanceof(c_Closure::classof()))) {\n    return make_varray(Object(const_cast<ObjectData*>(this)));\n  } else if (UNLIKELY(instanceof(DateTimeData::getClass()))) {\n    return Native::data<DateTimeData>(this)->getDebugInfo();\n  } else {\n    auto ret = Array::CreateDArray();\n    o_getArray(ret, pubOnly, ignoreLateInit);\n    return ret;\n  }\n}\n\ntemplate\nArray ObjectData::toArray<IntishCast::None>(bool, bool) const;\ntemplate\nArray ObjectData::toArray<IntishCast::Cast>(bool, bool) const;\n\n\nnamespace {\n\nsize_t getPropertyIfAccessible(ObjectData* obj,\n                               const Class* ctx,\n                               const StringData* key,\n                               Array& properties,\n                               size_t propLeft) {\n  auto const prop = obj->getProp(ctx, key);\n  if (prop && prop.type() != KindOfUninit) {\n    --propLeft;\n    properties.set(StrNR(key), prop.tv(), true);\n  }\n  return propLeft;\n}\n\n}\n\nArray ObjectData::o_toIterArray(const String& context) {\n  if (!m_cls->numDeclProperties()) {\n    if (getAttribute(HasDynPropArr)) {\n      auto const props = dynPropArray();\n      if (RuntimeOption::EvalNoticeOnReadDynamicProp) {\n        IterateKV(props.get(), [&](TypedValue k, TypedValue) {\n          auto const key = tvCastToString(k);\n          raiseReadDynamicProp(key.get());\n        });\n      }\n      // not returning Array&; makes a copy\n      return props;\n    }\n    return Array::CreateDArray();\n  }\n\n  size_t accessibleProps = m_cls->declPropNumAccessible();\n  size_t size = accessibleProps;\n  if (getAttribute(HasDynPropArr)) {\n    size += dynPropArray().size();\n  }\n  Array retArray { Array::attach(MixedArray::MakeReserveMixed(size)) };\n\n  Class* ctx = nullptr;\n  if (!context.empty()) {\n    ctx = Unit::lookupClass(context.get());\n  }\n\n  // Get all declared properties first, bottom-to-top in the inheritance\n  // hierarchy, in declaration order.\n  const Class* klass = m_cls;\n  while (klass) {\n    const PreClass::Prop* props = klass->preClass()->properties();\n    const size_t numProps = klass->preClass()->numProperties();\n\n    for (size_t i = 0; i < numProps; ++i) {\n      auto key = const_cast<StringData*>(props[i].name());\n      accessibleProps = getPropertyIfAccessible(\n          this, ctx, key, retArray, accessibleProps);\n    }\n    klass = klass->parent();\n  }\n  if (!(m_cls->attrs() & AttrNoExpandTrait) && accessibleProps > 0) {\n    // we may have properties from traits\n    for (auto const& prop : m_cls->declProperties()) {\n      auto const key = prop.name.get();\n      if (!retArray.get()->exists(key)) {\n        accessibleProps = getPropertyIfAccessible(\n          this, ctx, key, retArray, accessibleProps);\n        if (accessibleProps == 0) break;\n      }\n    }\n  }\n\n  // Now get dynamic properties.\n  if (getAttribute(HasDynPropArr)) {\n    auto& dynProps = dynPropArray();\n    auto ad = dynProps.get();\n    ssize_t iter = ad->iter_begin();\n    auto pos_limit = ad->iter_end();\n    while (iter != pos_limit) {\n      ad = dynProps.get();\n      auto const key = ad->nvGetKey(iter);\n      iter = ad->iter_advance(iter);\n\n      if (RuntimeOption::EvalNoticeOnReadDynamicProp) {\n        auto const k = tvCastToString(key);\n        raiseReadDynamicProp(k.get());\n      }\n\n      // You can get this if you cast an array to object. These\n      // properties must be dynamic because you can't declare a\n      // property with a non-string name.\n      if (UNLIKELY(!isStringType(key.m_type))) {\n        assertx(key.m_type == KindOfInt64);\n        auto const val = dynProps.get()->at(key.m_data.num);\n        retArray.set(key.m_data.num, val);\n        continue;\n      }\n\n      auto const strKey = key.m_data.pstr;\n      auto const val = dynProps.get()->at(strKey);\n      retArray.set(StrNR(strKey), val, true /* isKey */);\n    }\n  }\n\n  return retArray;\n}\n\nstatic bool decode_invoke(const String& s, ObjectData* obj, bool fatal,\n                          CallCtx& ctx) {\n  ctx.this_ = obj;\n  ctx.cls = obj->getVMClass();\n  ctx.dynamic = true;\n\n  ctx.func = ctx.cls->lookupMethod(s.get());\n  if (!ctx.func) {\n    // Bail if this_ is non-null AND we could not find a method.\n    o_invoke_failed(ctx.cls->name()->data(), s.data(), fatal);\n    return false;\n  }\n\n  // Null out this_ for statically called methods\n  if (ctx.func->isStaticInPrologue()) {\n    ctx.this_ = nullptr;\n  }\n  return true;\n}\n\nVariant ObjectData::o_invoke(const String& s, const Variant& params,\n                             bool fatal /* = true */) {\n  CallCtx ctx;\n  if (!decode_invoke(s, this, fatal, ctx) ||\n      (!isContainer(params) && !params.isNull())) {\n    return Variant(Variant::NullInit());\n  }\n  return Variant::attach(\n    g_context->invokeFunc(ctx, params)\n  );\n}\n\n#define INVOKE_FEW_ARGS_IMPL3                        \\\n  const Variant& a0, const Variant& a1, const Variant& a2\n#define INVOKE_FEW_ARGS_IMPL6                        \\\n  INVOKE_FEW_ARGS_IMPL3,                             \\\n  const Variant& a3, const Variant& a4, const Variant& a5\n#define INVOKE_FEW_ARGS_IMPL10                       \\\n  INVOKE_FEW_ARGS_IMPL6,                             \\\n  const Variant& a6, const Variant& a7, const Variant& a8, const Variant& a9\n#define INVOKE_FEW_ARGS_IMPL_ARGS INVOKE_FEW_ARGS(IMPL,INVOKE_FEW_ARGS_COUNT)\n\nVariant ObjectData::o_invoke_few_args(const String& s, int count,\n                                      INVOKE_FEW_ARGS_IMPL_ARGS) {\n\n  CallCtx ctx;\n  if (!decode_invoke(s, this, true, ctx)) {\n    return Variant(Variant::NullInit());\n  }\n\n  TypedValue args[INVOKE_FEW_ARGS_COUNT];\n  switch(count) {\n    default: not_implemented();\n#if INVOKE_FEW_ARGS_COUNT > 6\n    case 10: tvCopy(*a9.asTypedValue(), args[9]);\n    case  9: tvCopy(*a8.asTypedValue(), args[8]);\n    case  8: tvCopy(*a7.asTypedValue(), args[7]);\n    case  7: tvCopy(*a6.asTypedValue(), args[6]);\n#endif\n#if INVOKE_FEW_ARGS_COUNT > 3\n    case  6: tvCopy(*a5.asTypedValue(), args[5]);\n    case  5: tvCopy(*a4.asTypedValue(), args[4]);\n    case  4: tvCopy(*a3.asTypedValue(), args[3]);\n#endif\n    case  3: tvCopy(*a2.asTypedValue(), args[2]);\n    case  2: tvCopy(*a1.asTypedValue(), args[1]);\n    case  1: tvCopy(*a0.asTypedValue(), args[0]);\n    case  0: break;\n  }\n\n  return Variant::attach(\n    g_context->invokeFuncFew(ctx, count, args)\n  );\n}\n\nObjectData* ObjectData::clone() {\n  if (isCppBuiltin()) {\n    assertx(!m_cls->hasMemoSlots());\n    if (isCollection()) return collections::clone(this);\n    if (instanceof(c_Closure::classof())) {\n      return c_Closure::fromObject(this)->clone();\n    }\n    assertx(instanceof(c_Awaitable::classof()));\n    // cloning WaitHandles is not allowed\n    // invoke the instanceCtor to get the right sort of exception\n    auto const ctor = m_cls->instanceCtor();\n    ctor(m_cls);\n    always_assert(false);\n  }\n\n  // clone prevents a leak if something throws before clone() returns\n  Object clone;\n  auto const nProps = m_cls->numDeclProperties();\n  if (hasNativeData()) {\n    assertx(m_cls->instanceDtor() == Native::nativeDataInstanceDtor);\n    clone = Object::attach(\n      Native::nativeDataInstanceCopyCtor(this, m_cls, nProps)\n    );\n    assertx(clone->hasExactlyOneRef());\n    assertx(clone->hasInstanceDtor());\n  } else {\n    auto const alloc = allocMemoInit(m_cls);\n\n    auto const obj = new (NotNull{}, alloc.mem)\n                     ObjectData(m_cls, InitRaw{}, alloc.flags);\n    clone = Object::attach(obj);\n    assertx(clone->hasExactlyOneRef());\n    assertx(!clone->hasInstanceDtor());\n  }\n\n  auto const cloneProps = clone->props();\n  cloneProps->init(m_cls->numDeclProperties());\n  for (auto slot = Slot{0}; slot < nProps; slot++) {\n    auto index = m_cls->propSlotToIndex(slot);\n    tvDup(*props()->at(index), cloneProps->at(index));\n    assertx(assertTypeHint(cloneProps->at(index), slot));\n  }\n\n  if (UNLIKELY(getAttribute(HasDynPropArr))) {\n    clone->setAttribute(HasDynPropArr);\n    g_context->dynPropTable.emplace(clone.get(), dynPropArray().get());\n  }\n  if (m_cls->rtAttribute(Class::HasClone)) {\n    assertx(!isCppBuiltin());\n    auto const method = clone->m_cls->lookupMethod(s_clone.get());\n    assertx(method);\n    clone->unlockObject();\n    SCOPE_EXIT { clone->lockObject(); };\n    g_context->invokeMethodV(clone.get(), method, InvokeArgs{}, false);\n  }\n  return clone.detach();\n}\n\nbool ObjectData::equal(const ObjectData& other) const {\n  if (this == &other) return true;\n  if (isCollection()) {\n    return collections::equals(this, &other);\n  }\n  if (UNLIKELY(instanceof(SystemLib::s_DateTimeInterfaceClass) &&\n               other.instanceof(SystemLib::s_DateTimeInterfaceClass))) {\n    return DateTimeData::compare(this, &other) == 0;\n  }\n  if (getVMClass() != other.getVMClass()) return false;\n  if (UNLIKELY(instanceof(SimpleXMLElement_classof()))) {\n    if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {\n      raise_notice(\"SimpleXMLElement equality comparison\");\n    }\n    // Compare the whole object (including native data), not just props\n    auto ar1 = SimpleXMLElement_objectCast(this, KindOfArray).toArray();\n    auto ar2 = SimpleXMLElement_objectCast(&other, KindOfArray).toArray();\n    return ArrayData::Equal(ar1.get(), ar2.get());\n  }\n  if (UNLIKELY(instanceof(c_Closure::classof()))) {\n    // First comparison already proves they are different\n    return false;\n  }\n\n  // check for dynamic props first because we need to short-circuit if there's\n  // a different number of them\n  auto thisSize = UNLIKELY(getAttribute(HasDynPropArr)) ?\n    dynPropArray().size() : 0;\n  size_t otherSize = 0;\n  ArrayData* otherDynProps = nullptr;\n  if (UNLIKELY(other.getAttribute(HasDynPropArr))) {\n    otherDynProps = other.dynPropArray().get();\n    otherSize = otherDynProps->size();\n  }\n  if (thisSize != otherSize) return false;\n\n  // Prevent circular referenced objects/arrays or deep ones.\n  check_recursion_error();\n\n  bool result = true;\n  IteratePropMemOrderNoInc(\n    this,\n    [&](Slot slot, const Class::Prop& prop, tv_rval thisVal) {\n      auto otherVal = other.propRvalAtOffset(slot);\n      if ((UNLIKELY(thisVal.type() == KindOfUninit) ||\n           UNLIKELY(otherVal.type() == KindOfUninit)) &&\n          (prop.attrs & AttrLateInit)) {\n        throw_late_init_prop(prop.cls, prop.name, false);\n      }\n      if (!tvEqual(thisVal.tv(), otherVal.tv())) {\n        result = false;\n        return true;\n      }\n      return false;\n    },\n    [&](TypedValue key, TypedValue thisVal) {\n      auto const otherVal = otherDynProps->get(key);\n      if (!otherVal.is_init() || !tvEqual(thisVal, otherVal)) {\n        result = false;\n        return true;\n      }\n      return false;\n    }\n  );\n  return result;\n}\n\nbool ObjectData::less(const ObjectData& other) const {\n  // compare is not symmetrical; order of operands matters here\n  return compare(other) < 0;\n}\n\nbool ObjectData::lessEqual(const ObjectData& other) const {\n  // compare is not symmetrical; order of operands matters here\n  return compare(other) <= 0;\n}\n\nbool ObjectData::more(const ObjectData& other) const {\n  // compare is not symmetrical; order of operands matters here\n  return other.compare(*this) < 0;\n}\n\nbool ObjectData::moreEqual(const ObjectData& other) const {\n  // compare is not symmetrical; order of operands matters here\n  return other.compare(*this) <= 0;\n}\n\nint64_t ObjectData::compare(const ObjectData& other) const {\n  if (isCollection() || other.isCollection()) {\n    throw_collection_compare_exception();\n  }\n  if (this == &other) return 0;\n  if (UNLIKELY(instanceof(SystemLib::s_DateTimeInterfaceClass) &&\n               other.instanceof(SystemLib::s_DateTimeInterfaceClass))) {\n    return DateTimeData::compare(this, &other);\n  }\n  // Return 1 for different classes to match PHP7 behavior.\n  if (getVMClass() != other.getVMClass()) return 1;\n  if (UNLIKELY(instanceof(SimpleXMLElement_classof()))) {\n    if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {\n      raise_notice(\"SimpleXMLElement comparison\");\n    }\n    // Compare the whole object (including native data), not just props\n    auto ar1 = SimpleXMLElement_objectCast(this, KindOfArray).toArray();\n    auto ar2 = SimpleXMLElement_objectCast(&other, KindOfArray).toArray();\n    return ArrayData::Compare(ar1.get(), ar2.get());\n  }\n  if (UNLIKELY(instanceof(c_Closure::classof()))) {\n    // comparing different closures with <=> always returns 1\n    return 1;\n  }\n\n  // check for dynamic props first, because we need to short circuit if there's\n  // a different number of them\n  auto thisSize = UNLIKELY(getAttribute(HasDynPropArr)) ?\n    dynPropArray().size() : 0;\n  size_t otherSize = 0;\n  ArrayData* otherDynProps = nullptr;\n  if (UNLIKELY(other.getAttribute(HasDynPropArr))) {\n    otherDynProps = other.dynPropArray().get();\n    otherSize = otherDynProps->size();\n  }\n  if (thisSize > otherSize) {\n    return 1;\n  } else if (thisSize < otherSize) {\n    return -1;\n  }\n\n  // Prevent circular referenced objects/arrays or deep ones.\n  check_recursion_error();\n\n  int64_t result = 0;\n  IteratePropToArrayOrderNoInc(\n    this,\n    [&](Slot slot, const Class::Prop& prop, tv_rval thisVal) {\n      auto otherVal = other.propRvalAtOffset(slot);\n      if ((UNLIKELY(thisVal.type() == KindOfUninit) ||\n           UNLIKELY(otherVal.type() == KindOfUninit)) &&\n          (prop.attrs & AttrLateInit)) {\n        throw_late_init_prop(prop.cls, prop.name, false);\n      }\n      auto cmp = tvCompare(thisVal.tv(), otherVal.tv());\n      if (cmp != 0) {\n        result = cmp;\n        return true;\n      }\n      return false;\n    },\n    [&](TypedValue key, TypedValue thisVal) {\n      auto const otherVal = otherDynProps->get(key);\n      if (!otherVal.is_init()) {\n        result = 1;\n        return true;\n      }\n      auto cmp = tvCompare(thisVal, otherVal);\n      if (cmp != 0) {\n        result = cmp;\n        return true;\n      }\n      return false;\n    }\n  );\n  return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nconst StaticString\n  s___sleep(\"__sleep\"),\n  s___toDebugDisplay(\"__toDebugDisplay\"),\n  s___wakeup(\"__wakeup\"),\n  s___debugInfo(\"__debugInfo\");\n\nvoid deepInitHelper(ObjectProps* props,\n                    const Class::PropInitVec* initVec,\n                    size_t nProps) {\n  auto initIter = initVec->cbegin();\n  props->init(nProps);\n  props->foreach(nProps, [&](tv_lval lval){\n    auto entry = *initIter++;\n    tvCopy(entry.val.tv(), lval);\n    if (entry.deepInit) {\n      tvIncRefGen(*lval);\n      collections::deepCopy(lval);\n    }\n  });\n}\n\nvoid ObjectData::setReifiedGenerics(Class* cls, ArrayData* reifiedTypes) {\n  auto const arg = make_array_like_tv(reifiedTypes);\n  auto const meth = cls->lookupMethod(s_86reifiedinit.get());\n  assertx(meth != nullptr);\n  g_context->invokeMethod(this, meth, InvokeArgs(&arg, 1));\n}\n\n// called from jit code\nObjectData* ObjectData::newInstanceRawSmall(Class* cls, size_t size,\n                                            size_t index) {\n  assertx(size <= kMaxSmallSize);\n  assertx(!cls->hasMemoSlots());\n  assertx(cls->sizeIdx() == index);\n  auto mem = tl_heap->mallocSmallIndexSize(index, size);\n  auto const flags = IsBeingConstructed | SmallAllocSize;\n  return new (NotNull{}, mem) ObjectData(cls, InitRaw{}, flags);\n}\n\nObjectData* ObjectData::newInstanceRawBig(Class* cls, size_t size) {\n  assertx(!cls->hasMemoSlots());\n  auto mem = tl_heap->mallocBigSize(size);\n  auto const flags = IsBeingConstructed | BigAllocSize;\n  return new (NotNull{}, mem) ObjectData(cls, InitRaw{}, flags);\n}\n\n// called from jit code\nObjectData* ObjectData::newInstanceRawMemoSmall(Class* cls,\n                                                size_t size,\n                                                size_t index,\n                                                size_t objoff) {\n  assertx(size <= kMaxSmallSize);\n  assertx(cls->hasMemoSlots());\n  assertx(!cls->getNativeDataInfo());\n  assertx(objoff == ObjectData::objOffFromMemoNode(cls));\n  assertx(cls->sizeIdx() == index);\n  auto mem = tl_heap->mallocSmallIndexSize(index, size);\n  new (NotNull{}, mem) MemoNode(objoff);\n  mem = reinterpret_cast<char*>(mem) + objoff;\n  auto const flags = IsBeingConstructed | SmallAllocSize;\n  return new (NotNull{}, mem) ObjectData(cls, InitRaw{}, flags);\n}\n\nObjectData* ObjectData::newInstanceRawMemoBig(Class* cls,\n                                              size_t size,\n                                              size_t objoff) {\n  assertx(cls->hasMemoSlots());\n  assertx(!cls->getNativeDataInfo());\n  assertx(objoff == ObjectData::objOffFromMemoNode(cls));\n  auto mem = tl_heap->mallocBigSize(size);\n  new (NotNull{}, mem) MemoNode(objoff);\n  mem = reinterpret_cast<char*>(mem) + objoff;\n  auto const flags = IsBeingConstructed | BigAllocSize;\n  return new (NotNull{}, mem) ObjectData(cls, InitRaw{}, flags);\n}\n\n// Note: the normal object destruction path does not actually call this\n// destructor.  See ObjectData::release.\nObjectData::~ObjectData() {\n  if (UNLIKELY(slowDestroyCheck())) {\n    // The only builtin classes that use ~ObjectData and support memoization\n    // are ones with native data, and the memo slot cleanup for them happens\n    // in nativeDataInstanceDtor.\n    assertx(!getAttribute(UsedMemoCache) || hasNativeData());\n    if (getAttribute(HasDynPropArr)) freeDynPropArray(this);\n    if (getAttribute(IsWeakRefed)) {\n      WeakRefData::invalidateWeakRef((uintptr_t)this);\n    }\n  }\n}\n\nObject ObjectData::FromArray(ArrayData* properties) {\n  assertx(properties->isPHPArrayType());\n  Object retval{SystemLib::s_stdclassClass};\n  retval->setAttribute(HasDynPropArr);\n  g_context->dynPropTable.emplace(retval.get(), properties);\n  return retval;\n}\n\nNEVER_INLINE\nvoid ObjectData::throwMutateConstProp(Slot prop) const {\n  throw_cannot_modify_const_prop(\n    getClassName().data(),\n    m_cls->declProperties()[prop].name->data()\n  );\n}\n\ntemplate <bool forWrite, bool forRead, bool ignoreLateInit>\nALWAYS_INLINE\nObjectData::PropLookup ObjectData::getPropImpl(\n  const Class* ctx,\n  const StringData* key\n) {\n  auto const lookup = m_cls->getDeclPropSlot(ctx, key);\n  auto const propSlot = lookup.slot;\n\n  if (LIKELY(propSlot != kInvalidSlot)) {\n    // We found a visible property, but it might not be accessible.  No need to\n    // check if there is a dynamic property with this name.\n    auto const propIndex = m_cls->propSlotToIndex(propSlot);\n    auto prop = props()->at(propIndex);\n    assertx(assertTypeHint(prop, propSlot));\n\n    auto const& declProp = m_cls->declProperties()[propSlot];\n    if (!ignoreLateInit && lookup.accessible) {\n      if (UNLIKELY(type(prop) == KindOfUninit) &&\n          (declProp.attrs & AttrLateInit)) {\n        throw_late_init_prop(declProp.cls, key, false);\n      }\n    }\n\n    return {\n     prop,\n     &declProp,\n     propSlot,\n     lookup.accessible,\n     // we always return true in the !forWrite case; this way the compiler\n     // may optimize away this value, and if a caller intends to write but\n     // instantiates with false by mistake it will always see const\n     forWrite\n       ? bool(declProp.attrs & AttrIsConst)\n       : true\n    };\n  }\n\n  // We could not find a visible declared property. We need to check for a\n  // dynamic property with this name.\n  if (UNLIKELY(getAttribute(HasDynPropArr))) {\n    auto& arr = dynPropArray();\n    if (arr->exists(key)) {\n      if (forRead && RuntimeOption::EvalNoticeOnReadDynamicProp) {\n        raiseReadDynamicProp(key);\n      }\n      // Returning a non-declared property. We know that it is accessible and\n      // not const since all dynamic properties are. If we may write to\n      // the property we need to allow the array to escalate.\n      auto const lval = arr.lval(StrNR(key), AccessFlags::Key);\n      return { lval, nullptr, kInvalidSlot, true, !forWrite };\n    }\n  }\n\n  return { nullptr, nullptr, kInvalidSlot, false, !forWrite };\n}\n\ntv_lval ObjectData::getPropLval(const Class* ctx, const StringData* key) {\n  auto const lookup = getPropImpl<true, false, true>(ctx, key);\n  if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {\n    throwMutateConstProp(lookup.slot);\n  }\n  return lookup.val && lookup.accessible ? lookup.val : nullptr;\n}\n\ntv_rval ObjectData::getProp(const Class* ctx, const StringData* key) const {\n  auto const lookup = const_cast<ObjectData*>(this)\n    ->getPropImpl<false, true, false>(ctx, key);\n  return lookup.val && lookup.accessible ? lookup.val : nullptr;\n}\n\ntv_rval ObjectData::getPropIgnoreLateInit(const Class* ctx,\n                                          const StringData* key) const {\n  auto const lookup = const_cast<ObjectData*>(this)\n    ->getPropImpl<false, true, true>(ctx, key);\n  return lookup.val && lookup.accessible ? lookup.val : nullptr;\n}\n\ntv_lval ObjectData::getPropIgnoreAccessibility(const StringData* key) {\n  auto const lookup = getPropImpl<false, true, true>(nullptr, key);\n  auto prop = lookup.val;\n  if (!prop) return nullptr;\n  if (lookup.prop && type(prop) == KindOfUninit &&\n      (lookup.prop->attrs & AttrLateInit)) {\n    throw_late_init_prop(lookup.prop->cls, key, false);\n  }\n  return prop;\n}\n\n//////////////////////////////////////////////////////////////////////\n\ninline InvokeResult::InvokeResult(bool ok, Variant&& v) :\n  val(*v.asTypedValue()) {\n  tvWriteUninit(*v.asTypedValue());\n  val.m_aux.u_ok = ok;\n}\n\nstatic InvokeResult guardedNativePropResult(Variant result) {\n  if (!Native::isPropHandled(result)) {\n    return {false, make_tv<KindOfUninit>()};\n  }\n  return InvokeResult{true, std::move(result)};\n}\n\nInvokeResult ObjectData::invokeNativeGetProp(const StringData* key) {\n  return guardedNativePropResult(\n      Native::getProp(Object{this}, StrNR(key))\n  );\n}\n\nbool ObjectData::invokeNativeSetProp(const StringData* key, TypedValue val) {\n  auto r = guardedNativePropResult(\n    Native::setProp(Object{this}, StrNR(key), tvAsCVarRef(&val))\n  );\n  tvDecRefGen(r.val);\n  return r.ok();\n}\n\nInvokeResult ObjectData::invokeNativeIssetProp(const StringData* key) {\n  return guardedNativePropResult(\n      Native::issetProp(Object{this}, StrNR(key))\n  );\n}\n\nbool ObjectData::invokeNativeUnsetProp(const StringData* key) {\n  auto r = guardedNativePropResult(\n      Native::unsetProp(Object{this}, StrNR(key))\n  );\n  tvDecRefGen(r.val);\n  return r.ok();\n}\n\n//////////////////////////////////////////////////////////////////////\n\ntemplate<ObjectData::PropMode mode>\nALWAYS_INLINE\ntv_lval ObjectData::propImpl(TypedValue* tvRef, const Class* ctx,\n                             const StringData* key) {\n  auto constexpr write = (mode == PropMode::DimForWrite);\n  auto constexpr read = (mode == PropMode::ReadNoWarn) ||\n                        (mode == PropMode::ReadWarn);\n  auto const lookup = getPropImpl<write, read, false>(ctx, key);\n  auto const prop = lookup.val;\n\n  if (prop) {\n    if (lookup.accessible) {\n      auto const checkConstProp = [&]() {\n        if (mode == PropMode::DimForWrite) {\n          if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {\n            throwMutateConstProp(lookup.slot);\n          }\n        }\n        return prop;\n      };\n\n      // Property exists, is accessible, and is not unset.\n      if (type(prop) != KindOfUninit) return checkConstProp();\n\n      if (mode == PropMode::ReadWarn) raiseUndefProp(key);\n      if (write) return checkConstProp();\n      return const_cast<TypedValue*>(&immutable_null_base);\n    }\n\n    // Property exists, but it is either protected or private since accessible\n    // is false.\n    auto const propSlot = m_cls->lookupDeclProp(key);\n    auto const attrs = m_cls->declProperties()[propSlot].attrs;\n    auto const priv = (attrs & AttrPrivate) ? \"private\" : \"protected\";\n\n    raise_error(\n      \"Cannot access %s property %s::$%s\",\n      priv,\n      m_cls->preClass()->name()->data(),\n      key->data()\n    );\n  }\n\n  // First see if native getter is implemented.\n  if (m_cls->rtAttribute(Class::HasNativePropHandler)) {\n    if (auto r = invokeNativeGetProp(key)) {\n      tvCopy(r.val, *tvRef);\n      return tvRef;\n    }\n  }\n\n  if (UNLIKELY(!*key->data())) {\n    throw_invalid_property_name(StrNR(key));\n  }\n\n  if (mode == PropMode::ReadWarn) raiseUndefProp(key);\n  if (write) return makeDynProp(key);\n  return const_cast<TypedValue*>(&immutable_null_base);\n}\n\ntv_lval ObjectData::prop(\n  TypedValue* tvRef,\n  const Class* ctx,\n  const StringData* key\n) {\n  return propImpl<PropMode::ReadNoWarn>(tvRef, ctx, key);\n}\n\ntv_lval ObjectData::propW(\n  TypedValue* tvRef,\n  const Class* ctx,\n  const StringData* key\n) {\n  return propImpl<PropMode::ReadWarn>(tvRef, ctx, key);\n}\n\ntv_lval ObjectData::propU(\n  TypedValue* tvRef,\n  const Class* ctx,\n  const StringData* key\n) {\n  return propImpl<PropMode::DimForWrite>(tvRef, ctx, key);\n}\n\ntv_lval ObjectData::propD(\n  TypedValue* tvRef,\n  const Class* ctx,\n  const StringData* key\n) {\n  return propImpl<PropMode::DimForWrite>(tvRef, ctx, key);\n}\n\nbool ObjectData::propIsset(const Class* ctx, const StringData* key) {\n  auto const lookup = getPropImpl<false, true, true>(ctx, key);\n  if (lookup.val && lookup.accessible) {\n    if (lookup.val.type() != KindOfUninit) {\n      return lookup.val.type() != KindOfNull;\n    }\n    if (lookup.prop && (lookup.prop->attrs & AttrLateInit)) {\n      return false;\n    }\n  }\n\n  if (m_cls->rtAttribute(Class::HasNativePropHandler)) {\n    if (auto r = invokeNativeIssetProp(key)) {\n      tvCastToBooleanInPlace(&r.val);\n      return r.val.m_data.num;\n    }\n  }\n\n  return false;\n}\n\nvoid ObjectData::setProp(Class* ctx, const StringData* key, TypedValue val) {\n  assertx(tvIsPlausible(val));\n  assertx(val.m_type != KindOfUninit);\n\n  auto const lookup = getPropImpl<true, false, true>(ctx, key);\n  auto const prop = lookup.val;\n\n  if (prop && lookup.accessible) {\n    if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {\n      throwMutateConstProp(lookup.slot);\n    }\n    // TODO(T61738946): We can remove the temporary here once we no longer\n    // coerce class_meth types.\n    Variant tmp = tvAsVariant(&val);\n    verifyTypeHint(m_cls, lookup.prop, tmp.asTypedValue());\n    tvMove(tmp.detach(), prop);\n    return;\n  }\n\n  // First see if native setter is implemented.\n  if (m_cls->rtAttribute(Class::HasNativePropHandler) &&\n      invokeNativeSetProp(key, val)) {\n    return;\n  }\n\n  if (prop) raise_error(\"Cannot access protected property\");\n\n  if (UNLIKELY(!*key->data())) {\n    throw_invalid_property_name(StrNR(key));\n  }\n  setDynProp(key, val);\n}\n\ntv_lval ObjectData::setOpProp(TypedValue& tvRef,\n                              Class* ctx,\n                              SetOpOp op,\n                              const StringData* key,\n                              TypedValue* val) {\n  auto const lookup = getPropImpl<true, true, false>(ctx, key);\n  auto prop = lookup.val;\n\n  if (prop && lookup.accessible) {\n    if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {\n      throwMutateConstProp(lookup.slot);\n    }\n\n    auto const needsCheck = lookup.prop && [&] {\n      auto const& tc = lookup.prop->typeConstraint;\n      if (setOpNeedsTypeCheck(tc, op, prop)) {\n        return true;\n      }\n      for (auto& ub : lookup.prop->ubs) {\n        if (setOpNeedsTypeCheck(ub, op, prop)) return true;\n      }\n      return false;\n    }();\n\n    if (needsCheck) {\n      /*\n       * If this property has a type-hint, we can't do the setop truly in\n       * place. We need to verify that the new value satisfies the type-hint\n       * before assigning back to the property (if we raise a warning and throw,\n       * we don't want to have already put the value into the prop).\n       */\n      TypedValue temp;\n      tvDup(*prop, temp);\n      SCOPE_FAIL { tvDecRefGen(&temp); };\n      setopBody(&temp, op, val);\n      verifyTypeHint(m_cls, lookup.prop, &temp);\n      tvMove(temp, prop);\n    } else {\n      setopBody(prop, op, val);\n    }\n    return prop;\n  }\n\n  if (UNLIKELY(!*key->data())) throw_invalid_property_name(StrNR(key));\n\n  // Native accessors.\n  if (m_cls->rtAttribute(Class::HasNativePropHandler)) {\n    if (auto r = invokeNativeGetProp(key)) {\n      tvCopy(r.val, tvRef);\n      setopBody(&tvRef, op, val);\n      if (invokeNativeSetProp(key, tvRef)) {\n        return &tvRef;\n      }\n    }\n    // XXX else, write tvRef = null?\n  }\n\n  if (prop) raise_error(\"Cannot access protected property\");\n\n  // No visible/accessible property, and no applicable native method:\n  // create a new dynamic property.  (We know this is a new property,\n  // or it would've hit the visible && accessible case above.)\n  prop = makeDynProp(key);\n  assertx(type(prop) == KindOfNull); // cannot exist yet\n  setopBody(prop, op, val);\n  return prop;\n}\n\nTypedValue ObjectData::incDecProp(Class* ctx, IncDecOp op, const StringData* key) {\n  auto const lookup = getPropImpl<true, true, false>(ctx, key);\n  auto prop = lookup.val;\n\n  if (prop && lookup.accessible) {\n    if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {\n      throwMutateConstProp(lookup.slot);\n    }\n    if (type(prop) == KindOfUninit) {\n      tvWriteNull(prop);\n    }\n\n    /*\n     * If this property has a type-hint, we can't do the inc-dec truely in\n     * place. We need to verify that the new value satisfies the type-hint\n     * before assigning back to the property (if we raise a warning and throw,\n     * we don't want to have already put the value into the prop).\n     *\n     * If the prop is an integer and we're doing the common pre/post inc/dec\n     * ops, we know the type won't change, so we can skip the type-hint check in\n     * that case.\n     */\n    auto const fast = [&]{\n      if (RuntimeOption::EvalCheckPropTypeHints <= 0) return true;\n      auto const isAnyCheckable = lookup.prop && [&] {\n        if (lookup.prop->typeConstraint.isCheckable()) return true;\n        for (auto const& ub : lookup.prop->ubs) {\n          if (ub.isCheckable()) return true;\n        }\n        return false;\n      }();\n      if (!isAnyCheckable) return true;\n\n      if (!isIntType(type(prop))) return false;\n      return\n        op == IncDecOp::PreInc || op == IncDecOp::PostInc ||\n        op == IncDecOp::PreDec || op == IncDecOp::PostDec;\n    }();\n    if (fast) return IncDecBody(op, tvAssertPlausible(prop));\n\n    TypedValue temp;\n    tvDup(tvAssertPlausible(*prop), temp);\n    SCOPE_FAIL { tvDecRefGen(&temp); };\n    auto result = IncDecBody(op, &temp);\n    SCOPE_FAIL { tvDecRefGen(&result); };\n    verifyTypeHint(m_cls, lookup.prop, &temp);\n    tvMove(temp, tvAssertPlausible(prop));\n    return result;\n  }\n\n  if (UNLIKELY(!*key->data())) throw_invalid_property_name(StrNR(key));\n\n  // Native accessors.\n  if (m_cls->rtAttribute(Class::HasNativePropHandler)) {\n    if (auto r = invokeNativeGetProp(key)) {\n      SCOPE_EXIT { tvDecRefGen(r.val); };\n      auto const dest = IncDecBody(op, tvAssertPlausible(&r.val));\n      if (invokeNativeSetProp(key, tvAssertPlausible(r.val))) {\n        return dest;\n      }\n    }\n  }\n\n  if (prop) raise_error(\"Cannot access protected property\");\n\n  // No visible/accessible property, and no applicable native method:\n  // create a new dynamic property.  (We know this is a new property,\n  // or it would've hit the visible && accessible case above.)\n  prop = makeDynProp(key);\n  assertx(type(prop) == KindOfNull); // cannot exist yet\n  return IncDecBody(op, prop);\n}\n\nvoid ObjectData::unsetProp(Class* ctx, const StringData* key) {\n  auto const lookup = getPropImpl<true, false, true>(ctx, key);\n  auto const prop = lookup.val;\n\n  if (prop && lookup.accessible &&\n      (type(prop) != KindOfUninit ||\n       (lookup.prop && (lookup.prop->attrs & AttrLateInit)))) {\n    if (lookup.slot != kInvalidSlot) {\n      // Declared property.\n      if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {\n        throwMutateConstProp(lookup.slot);\n      }\n      unsetTypeHint(lookup.prop);\n      tvSet(*uninit_variant.asTypedValue(), prop);\n    } else {\n      // Dynamic property.\n      dynPropArray().remove(StrNR(key).asString(), true /* isString */);\n    }\n    return;\n  }\n\n  // Native unset first.\n  if (m_cls->rtAttribute(Class::HasNativePropHandler) &&\n      invokeNativeUnsetProp(key)) {\n    return;\n  }\n\n  if (prop && !lookup.accessible) {\n    // Defined property that is not accessible.\n    raise_error(\"Cannot unset inaccessible property\");\n  }\n\n  if (UNLIKELY(!*key->data())) {\n    throw_invalid_property_name(StrNR(key));\n  }\n}\n\nvoid ObjectData::raiseObjToIntNotice(const char* clsName) {\n  raise_notice(\"Object of class %s could not be converted to int\", clsName);\n}\n\nvoid ObjectData::raiseObjToDoubleNotice(const char* clsName) {\n  raise_notice(\"Object of class %s could not be converted to float\", clsName);\n}\n\nvoid ObjectData::raiseAbstractClassError(Class* cls) {\n  Attr attrs = cls->attrs();\n  raise_error(\"Cannot instantiate %s %s\",\n              (attrs & AttrInterface) ? \"interface\" :\n              (attrs & AttrTrait)     ? \"trait\" :\n              (attrs & AttrEnum)      ? \"enum\" : \"abstract class\",\n              cls->preClass()->name()->data());\n}\n\nvoid ObjectData::raiseUndefProp(const StringData* key) const {\n  raise_notice(\"Undefined property: %s::$%s\",\n               m_cls->name()->data(), key->data());\n}\n\nvoid ObjectData::raiseCreateDynamicProp(const StringData* key) const {\n  if (m_cls == SystemLib::s_stdclassClass ||\n      m_cls == SystemLib::s___PHP_Incomplete_ClassClass) {\n    // these classes (but not classes derived from them) don't get notices\n    return;\n  }\n  if (key->isStatic()) {\n    raise_notice(\"Created dynamic property with static name %s::%s\",\n                 m_cls->name()->data(), key->data());\n  } else {\n    raise_notice(\"Created dynamic property with dynamic name %s::%s\",\n                 m_cls->name()->data(), key->data());\n  }\n}\n\nvoid ObjectData::raiseReadDynamicProp(const StringData* key) const {\n  if (m_cls == SystemLib::s_stdclassClass ||\n      m_cls == SystemLib::s___PHP_Incomplete_ClassClass) {\n    // these classes (but not classes derived from them) don't get notices\n    return;\n  }\n  if (key->isStatic()) {\n    raise_notice(\"Read dynamic property with static name %s::%s\",\n                 m_cls->name()->data(), key->data());\n  } else {\n    raise_notice(\"Read dynamic property with dynamic name %s::%s\",\n                 m_cls->name()->data(), key->data());\n  }\n}\n\nvoid ObjectData::raiseImplicitInvokeToString() const {\n  raise_notice(\"Implicitly invoked %s::__toString\", m_cls->name()->data());\n}\n\nVariant ObjectData::InvokeSimple(ObjectData* obj, const StaticString& name) {\n  auto const meth = obj->methodNamed(name.get());\n  return meth\n    ? g_context->invokeMethodV(obj, meth, InvokeArgs{}, false)\n    : uninit_null();\n}\n\nVariant ObjectData::invokeSleep() {\n  return InvokeSimple(this, s___sleep);\n}\n\nVariant ObjectData::invokeToDebugDisplay() {\n  return InvokeSimple(this, s___toDebugDisplay);\n}\n\nVariant ObjectData::invokeWakeup() {\n  unlockObject();\n  SCOPE_EXIT { lockObject(); };\n  return InvokeSimple(this, s___wakeup);\n}\n\nVariant ObjectData::invokeDebugInfo() {\n  return InvokeSimple(this, s___debugInfo);\n}\n\nString ObjectData::invokeToString() {\n  if (RuntimeOption::EvalFatalOnConvertObjectToString) {\n    raise_convert_object_to_string(classname_cstr());\n  }\n\n  const Func* method = m_cls->getToString();\n  if (!method) {\n    // If the object does not define a __toString() method, raise a\n    // recoverable error\n    raise_recoverable_error(\n      \"Object of class %s could not be converted to string\",\n      classname_cstr()\n    );\n    // If the user error handler decides to allow execution to continue,\n    // we return the empty string.\n    return empty_string();\n  }\n  if (RuntimeOption::EvalNoticeOnImplicitInvokeToString) {\n    raiseImplicitInvokeToString();\n  }\n  auto const tv = g_context->invokeMethod(this, method, InvokeArgs{}, false);\n  if (!isStringType(tv.m_type)) {\n    // Discard the value returned by the __toString() method and raise\n    // a recoverable error\n    tvDecRefGen(tv);\n    raise_recoverable_error(\n      \"Method %s::__toString() must return a string value\",\n      m_cls->preClass()->name()->data());\n    // If the user error handler decides to allow execution to continue,\n    // we return the empty string.\n    return empty_string();\n  }\n\n  return String::attach(tv.m_data.pstr);\n}\n\nbool ObjectData::hasToString() {\n  return (m_cls->getToString() != nullptr);\n}\n\nconst char* ObjectData::classname_cstr() const {\n  return getClassName().data();\n}\n\n} // HPHP\n", "/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-present Facebook, Inc. (http://www.facebook.com)  |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n#include \"hphp/runtime/base/variable-unserializer.h\"\n\n#include <algorithm>\n#include <utility>\n\n#include <folly/Conv.h>\n#include <folly/Range.h>\n#include <folly/lang/Launder.h>\n\n#include \"hphp/runtime/base/array-init.h\"\n#include \"hphp/runtime/base/array-iterator.h\"\n#include \"hphp/runtime/base/autoload-handler.h\"\n#include \"hphp/runtime/base/set-array.h\"\n#include \"hphp/runtime/base/collections.h\"\n#include \"hphp/runtime/base/comparisons.h\"\n#include \"hphp/runtime/base/dummy-resource.h\"\n#include \"hphp/runtime/base/execution-context.h\"\n#include \"hphp/runtime/base/runtime-error.h\"\n#include \"hphp/runtime/base/runtime-option.h\"\n#include \"hphp/runtime/base/struct-log-util.h\"\n#include \"hphp/runtime/base/request-info.h\"\n#include \"hphp/runtime/base/variable-serializer.h\"\n\n#include \"hphp/runtime/ext/collections/ext_collections-map.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-pair.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-set.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-vector.h\"\n#include \"hphp/runtime/ext/std/ext_std_classobj.h\"\n\n#include \"hphp/runtime/vm/native-data.h\"\n#include \"hphp/runtime/vm/repo-global-data.h\"\n#include \"hphp/runtime/vm/repo.h\"\n\n#include \"hphp/runtime/vm/jit/perf-counters.h\"\n\n#include \"hphp/zend/zend-strtod.h\"\n\nnamespace HPHP {\n\nnamespace {\n\nenum class ArrayKind { PHP, Dict, Vec, Keyset };\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnexpectedSep(char expect, char actual) {\n  throw Exception(\"Expected '%c' but got '%c'\", expect, actual);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwOutOfRange(int64_t id) {\n  throw Exception(\"Id %\" PRId64 \" out of range\", id);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnexpectedStr(const char* expect, folly::StringPiece& actual) {\n  throw Exception(\"Expected '%s' but got '%.*s'\", expect,\n                  (int)actual.size(), actual.data());\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnknownType(char type) {\n  throw Exception(\"Unknown type '%c'\", type);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwInvalidPair() {\n  throw Exception(\"Pair objects must have exactly 2 elements\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwInvalidOFormat(const String& clsName) {\n  throw Exception(\"%s does not support the 'O' serialization format\",\n                  clsName.data());\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwMangledPrivateProperty() {\n  throw Exception(\"Mangled private object property\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnterminatedProperty() {\n  throw Exception(\"Object property not terminated properly\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwNotCollection(const String& clsName) {\n  throw Exception(\"%s is not a collection class\", clsName.data());\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnexpectedType(const String& key, const ObjectData* obj,\n                         TypedValue type) {\n  auto msg = folly::format(\n    \"Property {} for class {} was deserialized with type ({}) that \"\n    \"didn't match what we inferred in static analysis\",\n    key,\n    obj->getVMClass()->name(),\n    tname(type.m_type)\n  ).str();\n  throw Exception(msg);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnexpectedType(const StringData* key, const ObjectData* obj,\n                         TypedValue type) {\n  String str(key->data(), key->size(), CopyString);\n  throwUnexpectedType(str, obj, type);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwArraySizeOutOfBounds() {\n  throw Exception(\"Array size out of bounds\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwInvalidKey() {\n  throw Exception(\"Invalid key\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnterminatedElement() {\n  throw Exception(\"Array element not terminated properly\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwLargeStringSize(int64_t size) {\n  throw Exception(\"Size of serialized string (%\" PRId64 \") exceeds max\", size);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwNegativeStringSize(int64_t size) {\n  throw Exception(\"Size of serialized string (%\" PRId64 \") \"\n                  \"must not be negative\", size);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwBadFormat(const ObjectData* obj, char type) {\n  throw Exception(\"%s does not support the '%c' serialization format\",\n                  header_names[(int)obj->headerKind()], type);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwInvalidHashKey(const ObjectData* obj) {\n  throw Exception(\"%s values must be integers or strings\",\n                  header_names[(int)obj->headerKind()]);\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwColRKey() {\n  throw Exception(\"Referring to collection keys using the 'r' encoding \"\n                    \"is not supported\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwColRefValue() {\n  throw Exception(\"Collection values cannot be taken by reference\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwColRefKey() {\n  throw Exception(\"Collection keys cannot be taken by reference\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwUnexpectedEOB() {\n  throw Exception(\"Unexpected end of buffer during unserialization\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwVecRefValue() {\n  throw Exception(\"Vecs cannot contain references\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwDictRefValue() {\n  throw Exception(\"Dicts cannot contain references\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwKeysetValue() {\n  throw Exception(\"Keysets can only contain integers and strings\");\n}\n\n[[noreturn]] NEVER_INLINE\nvoid throwInvalidClassName() {\n  throw Exception(\"Provided class name is invalid\");\n}\n\nvoid warnOrThrowUnknownClass(const String& clsName) {\n  if (RuntimeOption::EvalForbidUnserializeIncompleteClass) {\n    auto const msg = folly::sformat(\n      \"Attempted to unserialize class named '{}' but it doesn't exist\",\n      clsName.toCppString()\n    );\n    if (RuntimeOption::EvalForbidUnserializeIncompleteClass > 1) {\n      throw_object(\"Exception\", make_vec_array(msg));\n    } else {\n      raise_warning(msg);\n    }\n  }\n}\n}\n\nconst StaticString\n  s_serialized(\"serialized\"),\n  s_unserialize(\"unserialize\"),\n  s_PHP_Incomplete_Class(\"__PHP_Incomplete_Class\"),\n  s_PHP_Incomplete_Class_Name(\"__PHP_Incomplete_Class_Name\"),\n  s___wakeup(\"__wakeup\");\n\n///////////////////////////////////////////////////////////////////////////////\n\nconst StaticString s_force_darrays{\"force_darrays\"};\nconst StaticString s_mark_legacy_arrays{\"mark_legacy_arrays\"};\n\nVariableUnserializer::VariableUnserializer(\n  const char* str,\n  size_t len,\n  Type type,\n  bool allowUnknownSerializableClass,\n  const Array& options)\n    : m_type(type)\n    , m_readOnly(false)\n    , m_buf(str)\n    , m_end(str + len)\n    , m_unknownSerializable(allowUnknownSerializableClass)\n    , m_options(options)\n    , m_begin(str)\n    , m_forceDArrays{m_options[s_force_darrays].toBoolean()}\n    , m_markLegacyArrays{m_options[s_mark_legacy_arrays].toBoolean()}\n{}\n\nVariableUnserializer::Type VariableUnserializer::type() const {\n  return m_type;\n}\n\nbool VariableUnserializer::allowUnknownSerializableClass() const {\n  return m_unknownSerializable;\n}\n\nconst char* VariableUnserializer::head() const {\n  return m_buf;\n}\n\nconst char* VariableUnserializer::begin() const {\n  return m_begin;\n}\n\nconst char* VariableUnserializer::end() const {\n  return m_end;\n}\n\nchar VariableUnserializer::peek() const {\n  check();\n  return *m_buf;\n}\n\nchar VariableUnserializer::peekBack() const {\n  return m_buf[-1];\n}\n\nbool VariableUnserializer::endOfBuffer() const {\n  return m_buf >= m_end;\n}\n\nchar VariableUnserializer::readChar() {\n  check();\n  return *(m_buf++);\n}\n\nvoid VariableUnserializer::add(tv_lval v, UnserializeMode mode) {\n  switch (mode) {\n    case UnserializeMode::Value:  m_refs.emplace_back(v); break;\n    // We don't support refs to collection keys; use nullptr as a sentinel.\n    case UnserializeMode::ColKey: m_refs.emplace_back(nullptr); break;\n    case UnserializeMode::Key:    break;\n  }\n}\n\nvoid VariableUnserializer::reserveForAdd(size_t count) {\n  // If the array is large, the space for the backrefs could be\n  // significant, so we need to check for OOM beforehand. To do this,\n  // we need to do some guess work to estimate what memory the vector\n  // will consume once we've done the reserve (we assume the vector\n  // doubles in capacity as necessary).\n  auto const newSize = m_refs.size() + count;\n  auto const capacity = m_refs.capacity();\n  if (newSize <= capacity) return;\n  auto const total =\n    (folly::nextPowTwo(newSize) - capacity) *\n    sizeof(decltype(m_refs)::value_type);\n  if (UNLIKELY(total > kMaxSmallSize && tl_heap->preAllocOOM(total))) {\n    check_non_safepoint_surprise();\n  }\n  m_refs.reserve(newSize);\n}\n\nTypedValue VariableUnserializer::getByVal(int id) {\n  if (id <= 0 || id > m_refs.size()) throwOutOfRange(id);\n  auto const result = m_refs[id - 1];\n  if (!result) throwColRKey();\n  return result.tv();\n}\n\nvoid VariableUnserializer::check() const {\n  if (m_buf >= m_end) throwUnexpectedEOB();\n}\n\nvoid VariableUnserializer::checkElemTermination() const {\n  auto const ch = peekBack();\n  if (ch != ';' && ch != '}') throwUnterminatedElement();\n}\n\nvoid VariableUnserializer::set(const char* buf, const char* end) {\n  m_buf = buf;\n  m_end = end;\n}\n\nVariant VariableUnserializer::unserialize() {\n  Variant v;\n  unserializeVariant(v.asTypedValue());\n  if (UNLIKELY(StructuredLog::coinflip(RuntimeOption::EvalSerDesSampleRate))) {\n    String ser(m_begin, m_end - m_begin, CopyString);\n    auto const fmt = folly::sformat(\"VU{}\", (int)m_type);\n    StructuredLog::logSerDes(fmt.c_str(), \"des\", ser, v);\n  }\n\n  for (auto& obj : m_sleepingObjects) {\n    obj->invokeWakeup();\n  }\n\n  return v;\n}\n\nnamespace {\nstd::pair<int64_t,const char*> hh_strtoll_base10(const char* p) {\n  int64_t x = 0;\n  bool neg = false;\n  if (*p == '-') {\n    neg = true;\n    ++p;\n  }\n  while (*p >= '0' && *p <= '9') {\n    x = (x * 10) + ('0' - *p);\n    ++p;\n  }\n  if (!neg) {\n    x = -x;\n  }\n  return std::pair<int64_t,const char*>(x, p);\n}\n}\n\nint64_t VariableUnserializer::readInt() {\n  check();\n  auto r = hh_strtoll_base10(m_buf);\n  m_buf = r.second;\n  return r.first;\n}\n\ndouble VariableUnserializer::readDouble() {\n  check();\n  const char* newBuf;\n  double r = zend_strtod(m_buf, &newBuf);\n  m_buf = newBuf;\n  return r;\n}\n\nfolly::StringPiece VariableUnserializer::readStr(unsigned n) {\n  check();\n  auto const bufferLimit = std::min(size_t(m_end - m_buf), size_t(n));\n  auto str = folly::StringPiece(m_buf, bufferLimit);\n  m_buf += bufferLimit;\n  return str;\n}\n\nvoid VariableUnserializer::expectChar(char expected) {\n  char ch = readChar();\n  if (UNLIKELY(ch != expected)) {\n    throwUnexpectedSep(expected, ch);\n  }\n}\n\nnamespace {\nbool isWhitelistClass(const String& requestedClassName,\n                      const Array& list,\n                      bool includeSubclasses) {\n  if (!list.empty()) {\n    for (ArrayIter iter(list); iter; ++iter) {\n      auto allowedClassName = iter.second().toString();\n      auto const matches = includeSubclasses\n        ? HHVM_FN(is_a)(requestedClassName, allowedClassName, true)\n        : allowedClassName.get()->isame(requestedClassName.get());\n      if (matches) return true;\n    }\n  }\n  return false;\n}\n}\n\nconst StaticString s_throw(\"throw\");\nconst StaticString s_allowed_classes(\"allowed_classes\");\nconst StaticString s_include_subclasses(\"include_subclasses\");\n\nbool VariableUnserializer::whitelistCheck(const String& clsName) const {\n  if (m_type != Type::Serialize || m_options.isNull()) {\n    return true;\n  }\n\n  // PHP7-style class whitelisting\n  // Allowed classes are allowed,\n  // all others result in __Incomplete_PHP_Class\n  if (m_options.exists(s_allowed_classes)) {\n    auto allowed_classes = m_options[s_allowed_classes];\n    auto const ok = [&] {\n      if (allowed_classes.isArray()) {\n        auto const subs = m_options[s_include_subclasses].toBoolean();\n        return isWhitelistClass(clsName,\n                                allowed_classes.toArray(),\n                                subs);\n      } else if (allowed_classes.isBoolean()) {\n        return allowed_classes.toBoolean();\n      } else {\n        throw InvalidAllowedClassesException();\n      }\n    }();\n\n    if (!ok && m_options[s_throw].toBoolean()) {\n      throw_object(m_options[s_throw].toString(),\n                   make_vec_array(clsName));\n    }\n    return ok;\n  }\n\n  if (!RuntimeOption::UnserializationWhitelistCheck) {\n    // No need for BC HHVM-style whitelist check,\n    // since the check isn't enabled.\n    // Go with PHP5 default behavior of allowing all\n    return true;\n  }\n\n  // Check for old-style whitelist\n  if (isWhitelistClass(clsName, m_options, false)) {\n    return true;\n  }\n\n  // Non-whitelisted class with a check enabled,\n  // are we willing to hard-error over it?\n  const char* err_msg =\n    \"The object being unserialized with class name '%s' \"\n    \"is not in the given whitelist\"; // followed by ' in <filename> on line %d'.\n\n  if (RuntimeOption::UnserializationWhitelistCheckWarningOnly) {\n    // Nope, just whine to the user and let it through\n    raise_warning(err_msg, clsName.c_str());\n    return true;\n  } else {\n    // Yes, shut it down.\n    raise_error(err_msg, clsName.c_str());\n    return false;\n  }\n}\n\nvoid VariableUnserializer::addSleepingObject(const Object& o) {\n  m_sleepingObjects.emplace_back(o);\n}\n\nbool VariableUnserializer::matchString(folly::StringPiece str) {\n  const char* p = m_buf;\n  assertx(p <= m_end);\n  int total = 0;\n  if (*p == 'S' && type() == VariableUnserializer::Type::APCSerialize) {\n    total = 2 + 8 + 1;\n    if (p + total > m_end) return false;\n    p++;\n    if (*p++ != ':') return false;\n    auto const sd = *reinterpret_cast<StringData*const*>(p);\n    assertx(sd->isStatic());\n    if (str.compare(sd->slice()) != 0) return false;\n    p += size_t(8);\n  } else {\n    const auto ss = str.size();\n    if (ss >= 100) return false;\n    int digits = ss >= 10 ? 2 : 1;\n    total = 2 + digits + 2 + ss + 2;\n    if (p + total > m_end) return false;\n    if (*p++ != 's') return false;\n    if (*p++ != ':') return false;\n    if (digits == 2) {\n      if (*p++ != '0' + ss/10) return false;\n      if (*p++ != '0' + ss%10) return false;\n    } else {\n      if (*p++ != '0' + ss) return false;\n    }\n    if (*p++ != ':') return false;\n    if (*p++ != '\\\"') return false;\n    if (memcmp(p, str.data(), ss)) return false;\n    p += ss;\n    if (*p++ != '\\\"') return false;\n  }\n  if (*p++ != ';') return false;\n  assertx(m_buf + total == p);\n  m_buf = p;\n  return true;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n// remainingProps should include the current property being unserialized.\nvoid VariableUnserializer::unserializePropertyValue(tv_lval v,\n                                                    int remainingProps) {\n  assertx(remainingProps > 0);\n  unserializeVariant(v);\n  if (--remainingProps > 0) {\n    auto lastChar = peekBack();\n    if (lastChar != ';' && lastChar != '}') {\n      throwUnterminatedProperty();\n    }\n  }\n}\n\n// nProp should include the current property being unserialized.\nNEVER_INLINE\nvoid VariableUnserializer::unserializeProp(ObjectData* obj,\n                                           const String& key,\n                                           Class* ctx,\n                                           const String& realKey,\n                                           int nProp) {\n\n  auto const cls = obj->getVMClass();\n  auto const lookup = cls->getDeclPropSlot(ctx, key.get());\n  auto const slot = lookup.slot;\n  tv_lval t;\n\n  if (slot == kInvalidSlot || !lookup.accessible) {\n    // Unserialize as a dynamic property. If this is the first, we need to\n    // pre-allocate space in the array to ensure the elements don't move during\n    // unserialization.\n    obj->reserveDynProps(nProp);\n    t = obj->makeDynProp(realKey.get());\n  } else {\n    // We'll check if this doesn't violate the type-hint once we're done\n    // unserializing all the props.\n    t = obj->getPropLval(ctx, key.get());\n  }\n\n  unserializePropertyValue(t, nProp);\n  if (!RuntimeOption::RepoAuthoritative) return;\n  if (!Repo::get().global().HardPrivatePropInference) return;\n\n  /*\n   * We assume for performance reasons in repo authoriative mode that\n   * we can see all the sets to private properties in a class.\n   *\n   * It's a hole in this if we don't check unserialization doesn't\n   * violate what we've seen, which we handle by throwing if the repo\n   * was built with this option.\n   */\n  if (UNLIKELY(slot == kInvalidSlot)) return;\n  auto const repoTy = cls->declPropRepoAuthType(slot);\n  if (LIKELY(tvMatchesRepoAuthType(*t, repoTy))) return;\n  if (t.type() == KindOfUninit &&\n      (cls->declProperties()[slot].attrs & AttrLateInit)) {\n    return;\n  }\n  throwUnexpectedType(key, obj, *t);\n}\n\n\nNEVER_INLINE\nvoid VariableUnserializer::unserializeRemainingProps(\n  Object& obj,\n  int remainingProps,\n  Variant& serializedNativeData,\n  bool& hasSerializedNativeData) {\n  obj->unlockObject();\n  SCOPE_EXIT { obj->lockObject(); };\n  while (remainingProps > 0) {\n    /*\n      use the number of properties remaining as an estimate for\n      the total number of dynamic properties when we see the\n      first dynamic prop.  see getVariantPtr\n    */\n    Variant v;\n    unserializeVariant(v.asTypedValue(), UnserializeMode::Key);\n    String key = v.toString();\n    int ksize = key.size();\n    const char *kdata = key.data();\n    int subLen = 0;\n    if (key == s_serializedNativeDataKey) {\n      unserializePropertyValue(serializedNativeData.asTypedValue(),\n                               remainingProps--);\n      hasSerializedNativeData = true;\n    } else if (kdata[0] == '\\0') {\n      if (UNLIKELY(!ksize)) {\n        raise_error(\"Cannot access empty property\");\n      }\n      // private or protected\n      subLen = strlen(folly::launder(kdata) + 1) + 2;\n      if (UNLIKELY(subLen >= ksize)) {\n        if (subLen == ksize) {\n          raise_error(\"Cannot access empty property\");\n        } else {\n          throwMangledPrivateProperty();\n        }\n      }\n      String k(kdata + subLen, ksize - subLen, CopyString);\n      Class* ctx = (Class*)-1;\n      if (kdata[1] != '*') {\n        ctx = Unit::lookupClass(\n          String(kdata + 1, subLen - 2, CopyString).get());\n      }\n      unserializeProp(obj.get(), k, ctx, key,\n                      remainingProps--);\n    } else {\n      unserializeProp(obj.get(), key, nullptr, key,\n                      remainingProps--);\n    }\n  }\n}\n\nnamespace {\n\nstatic const StaticString\n  s_Vector(\"Vector\"), s_HH_Vector(\"HH\\\\Vector\"),\n  s_Map(\"Map\"), s_HH_Map(\"HH\\\\Map\"),\n  s_Set(\"Set\"), s_HH_Set(\"HH\\\\Set\"),\n  s_Pair(\"Pair\"), s_HH_Pair(\"HH\\\\Pair\"),\n  s_StableMap(\"StableMap\");\n\n/*\n * For namespaced collections, returns an \"alternate\" name, which is a\n * collection name with or without the namespace qualifier, depending on\n * what's passed.\n * If no alternate name is found, returns nullptr.\n */\nconst StringData* getAlternateCollectionName(const StringData* clsName) {\n  typedef hphp_hash_map<const StringData*, const StringData*,\n                        string_data_hash, string_data_isame> ClsNameMap;\n\n  auto getAltMap = [] {\n    typedef std::pair<StaticString, StaticString> SStringPair;\n\n    static ClsNameMap m;\n\n    static std::vector<SStringPair> mappings {\n      std::make_pair(s_Vector, s_HH_Vector),\n      std::make_pair(s_Map, s_HH_Map),\n      std::make_pair(s_Set, s_HH_Set),\n      std::make_pair(s_Pair, s_HH_Pair)\n    };\n\n    for (const auto& p : mappings) {\n      m[p.first.get()] = p.second.get();\n      m[p.second.get()] = p.first.get();\n    }\n\n    // As part of StableMap merging into Map, StableMap is an alias for HH\\\\Map,\n    // but Map is the sole alias for HH\\\\Map\n    m[s_StableMap.get()] = s_HH_Map.get();\n    return &m;\n  };\n\n  static const ClsNameMap* altMap = getAltMap();\n\n  auto it = altMap->find(clsName);\n  return it != altMap->end() ? it->second : nullptr;\n}\n\nClass* tryAlternateCollectionClass(const StringData* clsName) {\n  auto altName = getAlternateCollectionName(clsName);\n  return altName ? Unit::getClass(altName, /* autoload */ false) : nullptr;\n}\n\n/*\n * Try to read 'str' while advancing 'cur' without reaching 'end'.\n */\nALWAYS_INLINE\nstatic bool match(const char*& cur,\n                  const char* expected,\n                  const char* const end) {\n  if (cur + strlen(expected) >= end) return false;\n  while (*expected) {\n    if (*cur++ != *expected++) return false;\n  }\n  return true;\n}\n\nALWAYS_INLINE\nstatic int64_t read64(const char*& cur) {\n  auto p = hh_strtoll_base10(cur);\n  cur = p.second;\n  return p.first;\n}\n\n/*\n * Read an int64 from 'cur' into 'out'. Returns false on unexpected\n * (but possibly still legal) format or if 'end' is reached.\n */\nALWAYS_INLINE\nbool readInt64(const char*& cur, const char* const end, int64_t& out) {\n  if (!match(cur, \"i:\", end)) return false;\n  out = read64(cur);\n  return match(cur, \";\", end);\n}\n\n/*\n * Read, allocate, and return a string from 'cur'. Returns null on unexpected\n * (but possibly still legal) format or if 'end' is reached, without allocating.\n */\nALWAYS_INLINE\nstatic StringData* readStringData(const char*& cur, const char* const end,\n                                  int maxLen) {\n  if (!match(cur, \"s:\", end)) return nullptr;\n  auto len = read64(cur);\n  if (len < 0 || len >= maxLen) return nullptr;\n  if (!match(cur, \":\\\"\", end)) return nullptr;\n  auto const slice = folly::StringPiece(cur, len);\n  if ((cur += len) >= end) return nullptr;\n  if (!match(cur, \"\\\";\", end)) return nullptr;\n  // TODO(11398853): Consider streaming/non-temporal stores here.\n  auto sd = StringData::Make(slice, CopyString);\n  return sd;\n}\n}\n\nNEVER_INLINE\nvoid VariableUnserializer::unserializeVariant(\n    tv_lval self,\n    UnserializeMode mode /* = UnserializeMode::Value */) {\n\n  // If we're overwriting an array element or property value, save the old\n  // value in case it's later referenced via an r: or R: ref.\n  if (isRefcountedType(self.type()) && mode == UnserializeMode::Value) {\n    m_overwrittenList.append(*self);\n  }\n\n  // NOTE: If you make changes to how serialization and unserialization work,\n  // make sure to update reserialize() here and test_apc_reserialize()\n  // in \"test/ext/test_ext_apc.cpp\".\n\n  char type = readChar();\n  char sep = readChar();\n\n  if (type != 'R') {\n    add(self, mode);\n  }\n\n  if (type == 'N') {\n    if (sep != ';') throwUnexpectedSep(';', sep);\n    tvSetNull(self); // NULL *IS* the value, without we get undefined warnings\n    return;\n  }\n  if (sep != ':') throwUnexpectedSep(':', sep);\n\n  switch (type) {\n  case 'r':\n  case 'R':\n    {\n      int64_t id = readInt();\n      tvSet(getByVal(id), self);\n    }\n    break;\n  case 'b':\n    {\n      int64_t v = readInt();\n      tvSetBool((bool)v, self);\n      break;\n    }\n  case 'i':\n    {\n      int64_t v = readInt();\n      tvSetInt(v, self);\n      break;\n    }\n  case 'd':\n    {\n      char ch = peek();\n      bool negative = false;\n      if (ch == '-') {\n        negative = true;\n        readChar();\n        ch = peek();\n      }\n      double v;\n      if (ch == 'I') {\n        auto str = readStr(3);\n        if (str.size() != 3 || str[1] != 'N' || str[2] != 'F') {\n          throwUnexpectedStr(\"INF\", str);\n        }\n        v = std::numeric_limits<double>::infinity();\n      } else if (ch == 'N') {\n        auto str = readStr(3);\n        if (str.size() != 3 || str[1] != 'A' || str[2] != 'N') {\n          throwUnexpectedStr(\"NAN\", str);\n        }\n        v = std::numeric_limits<double>::quiet_NaN();\n      } else {\n        v = readDouble();\n      }\n      tvSetDouble(negative ? -v : v, self);\n    }\n    break;\n  case 's':\n    {\n      String v = unserializeString();\n      tvMove(make_tv<KindOfString>(v.detach()), self);\n      if (!endOfBuffer()) {\n        // Semicolon *should* always be required,\n        // but PHP's implementation allows omitting it\n        // and still functioning.\n        // Worse, it throws it away without any check.\n        // So we'll do the same.  Sigh.\n        readChar();\n      }\n    }\n    return;\n  case 'S':\n    if (this->type() == VariableUnserializer::Type::APCSerialize) {\n      auto str = readStr(8);\n      assertx(str.size() == 8);\n      auto const sd = *reinterpret_cast<StringData*const*>(&str[0]);\n      assertx(sd->isStatic());\n      tvMove(make_tv<KindOfPersistentString>(sd), self);\n    } else {\n      throwUnknownType(type);\n    }\n    break;\n  case 'a': // PHP array\n  case 'D': // Dict\n    {\n      // Check stack depth to avoid overflow.\n      check_recursion_throw();\n      // It seems silly to check this here, but GCC actually generates much\n      // better code this way.\n      auto a = (type == 'a') ?\n        unserializeArray() :\n        unserializeDict();\n      if (UNLIKELY(m_markLegacyArrays && type == 'a')) {\n        a.setLegacyArray(true);\n      }\n      tvMove(make_array_like_tv(a.detach()), self);\n    }\n    return; // array has '}' terminating\n  case 'x': // legacy dict\n    {\n      // Check stack depth to avoid overflow.\n      check_recursion_throw();\n      auto a = unserializeDict();\n      a.setLegacyArray(true);\n      tvMove(make_array_like_tv(a.detach()), self);\n    }\n    return; // array has '}' terminating\n  case 'Y': // DArray\n    {\n      // Check stack depth to avoid overflow.\n      check_recursion_throw();\n      auto a = unserializeDArray();\n      if (UNLIKELY(m_markLegacyArrays)) {\n        a.setLegacyArray(true);\n      }\n      tvMove(make_array_like_tv(a.detach()), self);\n    }\n    return; // array has '}' terminating\n  case 'y': // VArray\n    {\n      // Check stack depth to avoid overflow.\n      check_recursion_throw();\n      auto a = unserializeVArray();\n      if (UNLIKELY(m_markLegacyArrays)) {\n        a.setLegacyArray(true);\n      }\n      tvMove(make_array_like_tv(a.detach()), self);\n    }\n    return; // array has '}' terminating\n  case 'v': // Vec\n    {\n      // Check stack depth to avoid overflow.\n      check_recursion_throw();\n      auto a = unserializeVec();\n      tvMove(make_tv<KindOfVec>(a.detach()), self);\n    }\n    return; // array has '}' terminating\n  case 'X': // legacy vec\n  {\n    // Check stack depth to avoid overflow.\n    check_recursion_throw();\n    auto a = unserializeVec();\n    a.setLegacyArray(true);\n    tvMove(make_tv<KindOfVec>(a.detach()), self);\n  }\n  return; // array has '}' terminating\n  case 'k': // Keyset\n    {\n      // Check stack depth to avoid overflow.\n      check_recursion_throw();\n      auto a = unserializeKeyset();\n      tvMove(make_tv<KindOfKeyset>(a.detach()), self);\n    }\n    return; // array has '}' terminating\n  case 'L':\n    {\n      int64_t id = readInt();\n      expectChar(':');\n      String rsrcName = unserializeString();\n      expectChar('{');\n      expectChar('}');\n      auto rsrc = req::make<DummyResource>();\n      rsrc->o_setResourceId(id);\n      rsrc->m_class_name = std::move(rsrcName);\n      tvMove(make_tv<KindOfResource>(rsrc.detach()->hdr()), self);\n    }\n    return; // resource has '}' terminating\n  case 'O':\n  case 'V':\n  case 'K':\n    {\n      String clsName = unserializeString();\n\n      expectChar(':');\n      const int64_t size = readInt();\n      expectChar(':');\n      expectChar('{');\n\n      const bool allowObjectFormatForCollections = true;\n\n      Class* cls = nullptr;\n\n      // If we are potentially dealing with a collection, we need to try to\n      // load the collection class under an alternate name so that we can\n      // deserialize data that was serialized before the migration of\n      // collections to the HH namespace.\n\n      if (type == 'O') {\n        if (whitelistCheck(clsName)) {\n          if (allowObjectFormatForCollections) {\n            // In order to support the legacy {O|V}:{Set|Vector|Map}\n            // serialization, we defer autoloading until we know that there's\n            // no alternate (builtin) collection class.\n            cls = Unit::getClass(clsName.get(), /* autoload */ false);\n            if (!cls) {\n              cls = tryAlternateCollectionClass(clsName.get());\n            }\n          }\n\n          // No valid class was found, lets try the autoloader.\n          if (!cls) {\n            if (!is_valid_class_name(clsName.slice())) {\n              throwInvalidClassName();\n            }\n            cls = Unit::loadClass(clsName.get()); // with autoloading\n          }\n        }\n      } else {\n        // Collections are CPP builtins; don't attempt to autoload\n        cls = Unit::getClass(clsName.get(), /* autoload */ false);\n        if (!cls) {\n          cls = tryAlternateCollectionClass(clsName.get());\n        }\n        if (!cls || !cls->isCollectionClass()) {\n          throwNotCollection(clsName);\n        }\n      }\n\n      Object obj;\n      auto remainingProps = size;\n      if (cls) {\n        // Only unserialize CPP extension types which can actually support\n        // it. Otherwise, we risk creating a CPP object without having it\n        // initialized completely.\n        if (cls->instanceCtor() && !cls->isCppSerializable() &&\n            !cls->isCollectionClass()) {\n          assertx(obj.isNull());\n          throw_null_pointer_exception();\n        } else {\n          if (UNLIKELY(collections::isType(cls, CollectionType::Pair))) {\n            if (UNLIKELY(size != 2)) {\n              throwInvalidPair();\n            }\n            // pairs can't be constructed without elements\n            obj = Object{req::make<c_Pair>(make_tv<KindOfNull>(),\n                                           make_tv<KindOfNull>(),\n                                           c_Pair::NoIncRef{})};\n          } else if (UNLIKELY(cls->hasReifiedGenerics())) {\n            // First prop on the serialized list is the reified generics prop\n            if (!matchString(s_86reified_prop.slice())) {\n              throwInvalidOFormat(clsName);\n            }\n            TypedValue tv = make_tv<KindOfNull>();\n            auto const t = tv_lval{&tv};\n            unserializePropertyValue(t, remainingProps--);\n            if (!TypeStructure::coerceToTypeStructureList_SERDE_ONLY(t)) {\n              throwInvalidOFormat(clsName);\n            }\n            assertx(tvIsHAMSafeVArray(t));\n            obj = Object{cls, t.val().parr};\n          } else {\n            obj = Object{cls};\n          }\n        }\n      } else {\n        warnOrThrowUnknownClass(clsName);\n        obj = Object{SystemLib::s___PHP_Incomplete_ClassClass};\n        obj->setProp(nullptr, s_PHP_Incomplete_Class_Name.get(),\n                     clsName.asTypedValue());\n      }\n      assertx(!obj.isNull());\n      tvSet(make_tv<KindOfObject>(obj.get()), self);\n\n      if (remainingProps > 0) {\n        // Check stack depth to avoid overflow.\n        check_recursion_throw();\n\n        if (type == 'O') {\n          // Collections are not allowed\n          if (obj->isCollection()) {\n            throwInvalidOFormat(clsName);\n          }\n\n          Variant serializedNativeData = init_null();\n          bool hasSerializedNativeData = false;\n          bool checkRepoAuthType =\n            RuntimeOption::RepoAuthoritative &&\n            Repo::get().global().HardPrivatePropInference;\n          Class* objCls = obj->getVMClass();\n          // Try fast case.\n          if (remainingProps >= objCls->numDeclProperties() -\n                                (objCls->hasReifiedGenerics() ? 1 : 0)) {\n            auto mismatch = false;\n            auto const objProps = obj->props();\n\n            auto const declProps = objCls->declProperties();\n            for (auto const& p : declProps) {\n              auto slot = p.serializationIdx;\n              auto index = objCls->propSlotToIndex(slot);\n              auto const& prop = declProps[slot];\n              if (prop.name == s_86reified_prop.get()) continue;\n              if (!matchString(prop.mangledName->slice())) {\n                mismatch = true;\n                break;\n              }\n\n              // don't need to worry about overwritten list, because\n              // this is definitely the first time we're setting this\n              // property.\n              auto const t = objProps->at(index);\n              unserializePropertyValue(t, remainingProps--);\n\n              if (UNLIKELY(checkRepoAuthType &&\n                           !tvMatchesRepoAuthType(*t, prop.repoAuthType))) {\n                throwUnexpectedType(prop.name, obj.get(), *t);\n              }\n            }\n            // If everything matched, all remaining properties are dynamic.\n            if (!mismatch && remainingProps > 0) {\n              // the dynPropTable can be mutated while we're deserializing\n              // the contents of this object's prop array. Don't hold a\n              // reference to this object's entry in the table while looping.\n              obj->reserveDynProps(remainingProps);\n              while (remainingProps > 0) {\n                Variant v;\n                unserializeVariant(v.asTypedValue(), UnserializeMode::Key);\n                String key = v.toString();\n                if (key == s_serializedNativeDataKey) {\n                  unserializePropertyValue(serializedNativeData.asTypedValue(),\n                                           remainingProps--);\n                  hasSerializedNativeData = true;\n                } else {\n                  auto kdata = key.data();\n                  if (kdata[0] == '\\0') {\n                    auto ksize = key.size();\n                    if (UNLIKELY(ksize == 0)) {\n                      raise_error(\"Cannot access empty property\");\n                    }\n                    // private or protected\n                    auto subLen = strlen(folly::launder(kdata) + 1) + 2;\n                    if (UNLIKELY(subLen >= ksize)) {\n                      if (subLen == ksize) {\n                        raise_error(\"Cannot access empty property\");\n                      } else {\n                        throwMangledPrivateProperty();\n                      }\n                    }\n                  }\n                  auto const lval = obj->makeDynProp(key.get());\n                  unserializePropertyValue(lval, remainingProps--);\n                }\n              }\n            }\n          }\n          if (remainingProps > 0) {\n            INC_TPC(unser_prop_slow);\n            unserializeRemainingProps(obj, remainingProps,\n                                      serializedNativeData,\n                                      hasSerializedNativeData);\n            remainingProps = 0;\n          } else {\n            INC_TPC(unser_prop_fast);\n          }\n\n          // Verify that all the unserialized properties satisfy their\n          // type-hints. Its safe to do it like this (after we've set the values\n          // in the properties) because this object hasn't escaped to the\n          // outside world yet.\n          obj->verifyPropTypeHints();\n\n          // nativeDataWakeup is called last to ensure that all properties are\n          // already unserialized. We also ensure that nativeDataWakeup is\n          // invoked regardless of whether or not serialized native data exists\n          // within the serialized content.\n          if (obj->hasNativeData() &&\n              obj->getVMClass()->getNativeDataInfo()->isSerializable()) {\n            Native::nativeDataWakeup(obj.get(), serializedNativeData);\n          } else if (hasSerializedNativeData) {\n            raise_warning(\"%s does not expect any serialized native data.\",\n                          clsName.data());\n          }\n        } else {\n          assertx(type == 'V' || type == 'K');\n          if (!obj->isCollection()) {\n            throwNotCollection(clsName);\n          }\n          unserializeCollection(obj.get(), size, type);\n        }\n      }\n      expectChar('}');\n\n      if (cls &&\n          cls->lookupMethod(s___wakeup.get()) &&\n          (this->type() != VariableUnserializer::Type::DebuggerSerialize ||\n           (cls->instanceCtor() && cls->isCppSerializable()))) {\n        // Don't call wakeup when unserializing for the debugger, except for\n        // natively implemented classes.\n        addSleepingObject(obj);\n      }\n\n      check_non_safepoint_surprise();\n    }\n    return; // object has '}' terminating\n  case 'C':\n    {\n      if (this->type() == VariableUnserializer::Type::DebuggerSerialize) {\n        raise_error(\"Debugger shouldn't call custom unserialize method\");\n      }\n      String clsName = unserializeString();\n\n      expectChar(':');\n      String serialized = unserializeString('{', '}');\n\n      auto obj = [&]() -> Object {\n        if (whitelistCheck(clsName)) {\n          // Try loading without the autoloader first\n          auto cls = Unit::getClass(clsName.get(), /* autoload */ false);\n          if (!cls) {\n            if (!is_valid_class_name(clsName.slice())) {\n              throwInvalidClassName();\n            }\n            cls = Unit::loadClass(clsName.get());\n          }\n          if (cls) {\n            return Object::attach(g_context->createObject(cls, init_null_variant,\n                                                          false /* init */));\n          }\n        }\n        if (!allowUnknownSerializableClass()) {\n          raise_error(\"unknown class %s\", clsName.data());\n        }\n        warnOrThrowUnknownClass(clsName);\n        Object ret = create_object_only(s_PHP_Incomplete_Class);\n        ret->setProp(nullptr, s_PHP_Incomplete_Class_Name.get(),\n                     clsName.asTypedValue());\n        ret->setProp(nullptr, s_serialized.get(), serialized.asTypedValue());\n        return ret;\n      }();\n\n      if (!obj->instanceof(SystemLib::s_SerializableClass)) {\n        raise_warning(\"Class %s has no unserializer\",\n                      obj->getClassName().data());\n      } else {\n        obj->o_invoke_few_args(s_unserialize, 1, serialized);\n      }\n\n      tvMove(make_tv<KindOfObject>(obj.detach()), self);\n    }\n    return; // object has '}' terminating\n  default:\n    throwUnknownType(type);\n  }\n  expectChar(';');\n}\n\nArray VariableUnserializer::unserializeArray() {\n  int64_t size = readInt();\n  expectChar(':');\n  expectChar('{');\n  if (size == 0) {\n    expectChar('}');\n    return m_forceDArrays || type() == Type::Serialize\n      ? Array::CreateDArray()\n      : Array::Create();\n  }\n  if (UNLIKELY(size < 0 || size > std::numeric_limits<int>::max())) {\n    throwArraySizeOutOfBounds();\n  }\n  // For large arrays, do a naive pre-check for OOM.\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(size);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  // Pre-allocate an ArrayData of the given size, to avoid escalation in the\n  // middle, which breaks references.\n  auto arr = m_forceDArrays || type() == Type::Serialize\n    ? DArrayInit(size).toArray()\n    : MixedArrayInit(size).toArray();\n  reserveForAdd(size);\n\n  for (int64_t i = 0; i < size; i++) {\n    Variant key;\n    unserializeVariant(key.asTypedValue(), UnserializeMode::Key);\n    if (!key.isString() && !key.isInteger()) throwInvalidKey();\n    unserializeVariant(MixedArray::LvalInPlace(arr.get(), key));\n    if (i < size - 1) checkElemTermination();\n  }\n\n  check_non_safepoint_surprise();\n  expectChar('}');\n  return arr;\n}\n\narrprov::Tag VariableUnserializer::unserializeProvenanceTag() {\n  auto const finish = [&] (auto tag) -> arrprov::Tag {\n    if (!RuntimeOption::EvalArrayProvenance) return {};\n    return tag;\n  };\n\n  auto const read_filename = [&]() -> const StringData* {\n    if (peek() == 't') {\n      assertx(m_unitFilename);\n      expectChar('t');\n      return m_unitFilename;\n    } else {\n      expectChar('s');\n      expectChar(':');\n      return makeStaticString(unserializeString().get());\n    }\n  };\n\n  if (type() != VariableUnserializer::Type::Internal) return {};\n  if (peek() == 'p') {\n    expectChar('p');\n    expectChar(':');\n    expectChar('i');\n    expectChar(':');\n    auto const line = static_cast<int>(readInt());\n    expectChar(';');\n    auto const filename = read_filename();\n    expectChar(';');\n    return finish(\n      arrprov::Tag { filename, line }\n    );\n  } else if (peek() == 'P') {\n    expectChar('P');\n    expectChar(';');\n    return finish(\n      arrprov::Tag::RepoUnion()\n    );\n  } else if (peek() == 'r') {\n    expectChar('r');\n    expectChar(':');\n    auto const filename = read_filename();\n    expectChar(';');\n    return finish(\n      arrprov::Tag::TraitMerge(filename)\n    );\n  } else if (peek() == 'e') {\n    expectChar('e');\n    expectChar(':');\n    auto const filename = read_filename();\n    expectChar(';');\n    return finish(\n      arrprov::Tag::LargeEnum(filename)\n    );\n  } else {\n    return {};\n  }\n}\n\nArray VariableUnserializer::unserializeDict() {\n  if (m_dvOverrides) m_dvOverrides->push_back(false);\n\n  int64_t size = readInt();\n  expectChar(':');\n  expectChar('{');\n\n  auto provTag = unserializeProvenanceTag();\n  if (!RO::EvalArrProvHackArrays) provTag = {};\n\n  if (size == 0) {\n    expectChar('}');\n    return Array::attach(provTag\n      ? arrprov::tagStaticArr(staticEmptyDictArray(), provTag)\n      : staticEmptyDictArray()\n    );\n  }\n  if (UNLIKELY(size < 0 || size > std::numeric_limits<int>::max())) {\n    throwArraySizeOutOfBounds();\n  }\n\n  // For large arrays, do a naive pre-check for OOM.\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(size);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  Array arr = DictInit(size).toArray();\n  for (int64_t i = 0; i < size; i++) {\n    Variant key;\n    unserializeVariant(key.asTypedValue(), UnserializeMode::Key);\n    if (!key.isString() && !key.isInteger()) throwInvalidKey();\n    unserializeVariant(MixedArray::LvalInPlace(arr.get(), key));\n    if (i < size - 1) checkElemTermination();\n  }\n\n  check_non_safepoint_surprise();\n  expectChar('}');\n  if (provTag) arrprov::setTag<arrprov::Mode::Emplace>(arr.get(), provTag);\n  return arr;\n}\n\nArray VariableUnserializer::unserializeVec() {\n  if (m_dvOverrides) m_dvOverrides->push_back(false);\n\n  int64_t size = readInt();\n  expectChar(':');\n  expectChar('{');\n\n  auto provTag = unserializeProvenanceTag();\n  if (!RO::EvalArrProvHackArrays) provTag = {};\n\n  if (size == 0) {\n    expectChar('}');\n    return Array::attach(provTag\n      ? arrprov::tagStaticArr(staticEmptyVec(), provTag)\n      : staticEmptyVec()\n    );\n  }\n  if (UNLIKELY(size < 0 || size > std::numeric_limits<int>::max())) {\n    throwArraySizeOutOfBounds();\n  }\n  auto const sizeClass = PackedArray::capacityToSizeIndex(size);\n  auto const allocsz = MemoryManager::sizeIndex2Size(sizeClass);\n\n  // For large arrays, do a naive pre-check for OOM.\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  Array arr = VecInit(size).toArray();\n  reserveForAdd(size);\n\n  for (int64_t i = 0; i < size; i++) {\n    unserializeVariant(PackedArray::LvalNewInPlace(arr.get()));\n    if (i < size - 1) checkElemTermination();\n  }\n  check_non_safepoint_surprise();\n  expectChar('}');\n  if (provTag) arrprov::setTag<arrprov::Mode::Emplace>(arr.get(), provTag);\n  return arr;\n}\n\nArray VariableUnserializer::unserializeVArray() {\n  if (m_dvOverrides) m_dvOverrides->push_back(true);\n\n  int64_t size = readInt();\n  expectChar(':');\n  expectChar('{');\n\n  auto provTag = unserializeProvenanceTag();\n  if (!RO::EvalArrProvDVArrays) provTag = {};\n\n  if (size == 0) {\n    expectChar('}');\n    if (m_type != Type::Serialize) {\n      return Array::attach(provTag\n        ? arrprov::tagStaticArr(staticEmptyVArray(), provTag)\n        : staticEmptyVArray()\n      );\n    }\n    return m_forceDArrays\n      ? Array::attach(provTag\n          ? arrprov::tagStaticArr(staticEmptyDArray(), provTag)\n          : staticEmptyDArray()\n        )\n      : Array::attach(provTag\n          ? arrprov::tagStaticArr(staticEmptyVArray(), provTag)\n          : staticEmptyVArray()\n        );\n  }\n  if (UNLIKELY(size < 0 || size > std::numeric_limits<int>::max())) {\n    throwArraySizeOutOfBounds();\n  }\n\n  auto const oomCheck = [&](size_t allocsz) {\n    // For large arrays, do a naive pre-check for OOM.\n    if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n      check_non_safepoint_surprise();\n    }\n  };\n\n  auto arr = Array{};\n  if (m_forceDArrays && m_type == Type::Serialize) {\n    // Deserialize to vector-ish darray. Use direct calls to MixedArray.\n    oomCheck(MixedArray::computeAllocBytesFromMaxElms(size));\n\n    arr = DArrayInit(size).toArray();\n    reserveForAdd(size);\n\n    for (int64_t i = 0; i < size; i++) {\n      unserializeVariant(MixedArray::LvalInPlace(arr.get(), i));\n      if (i < size - 1) checkElemTermination();\n    }\n  } else {\n    // Deserialize to varray. Use direct calls to MixedArray.\n    auto const index = PackedArray::capacityToSizeIndex(size);\n    oomCheck(MemoryManager::sizeIndex2Size(index));\n\n    arr = VArrayInit(size).toArray();\n    reserveForAdd(size);\n\n    for (int64_t i = 0; i < size; i++) {\n      unserializeVariant(PackedArray::LvalNewInPlace(arr.get()));\n      if (i < size - 1) checkElemTermination();\n    }\n  }\n\n  check_non_safepoint_surprise();\n  expectChar('}');\n  if (provTag) arrprov::setTag<arrprov::Mode::Emplace>(arr.get(), provTag);\n  return arr;\n}\n\nArray VariableUnserializer::unserializeDArray() {\n  if (m_dvOverrides) m_dvOverrides->push_back(true);\n\n  int64_t size = readInt();\n  expectChar(':');\n  expectChar('{');\n\n  auto provTag = unserializeProvenanceTag();\n  if (!RO::EvalArrProvDVArrays) provTag = {};\n\n  if (size == 0) {\n    expectChar('}');\n    return Array::attach(provTag\n      ? arrprov::tagStaticArr(staticEmptyDArray(), provTag)\n      : staticEmptyDArray()\n    );\n  }\n  if (UNLIKELY(size < 0 || size > std::numeric_limits<int>::max())) {\n    throwArraySizeOutOfBounds();\n  }\n\n  // For large arrays, do a naive pre-check for OOM.\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(size);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  auto arr = DArrayInit(size).toArray();\n  reserveForAdd(size);\n\n  for (int64_t i = 0; i < size; i++) {\n    Variant key;\n    unserializeVariant(key.asTypedValue(), UnserializeMode::Key);\n    if (!key.isString() && !key.isInteger()) throwInvalidKey();\n    unserializeVariant(MixedArray::LvalInPlace(arr.get(), key));\n    if (i < size - 1) checkElemTermination();\n  }\n\n  check_non_safepoint_surprise();\n  expectChar('}');\n  if (provTag) arrprov::setTag<arrprov::Mode::Emplace>(arr.get(), provTag);\n  return arr;\n}\n\nArray VariableUnserializer::unserializeKeyset() {\n  int64_t size = readInt();\n  expectChar(':');\n  expectChar('{');\n  if (size == 0) {\n    expectChar('}');\n    return Array::CreateKeyset();\n  }\n  if (UNLIKELY(size < 0 || size > std::numeric_limits<int>::max())) {\n    throwArraySizeOutOfBounds();\n  }\n\n  // For large arrays, do a naive pre-check for OOM.\n  auto const allocsz = SetArray::computeAllocBytesFromMaxElms(size);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  KeysetInit init(size);\n  for (int64_t i = 0; i < size; i++) {\n    Variant key;\n    // Use key mode to stop the unserializer from keeping a pointer to this\n    // variant (since its stack-allocated).\n    unserializeVariant(key.asTypedValue(), UnserializeMode::Key);\n\n    auto const type = key.getType();\n    if (UNLIKELY(!isStringType(type) && !isIntType(type))) {\n      throwKeysetValue();\n    }\n\n    init.add(key);\n\n    if (i < (size - 1)) {\n      auto lastChar = peekBack();\n      if ((lastChar != ';' && lastChar != '}')) {\n        throwUnterminatedElement();\n      }\n    }\n  }\n  check_non_safepoint_surprise();\n  expectChar('}');\n  return init.toArray();\n}\n\n\nfolly::StringPiece\nVariableUnserializer::unserializeStringPiece(char delimiter0, char delimiter1) {\n  int64_t size = readInt();\n  if (size >= RuntimeOption::MaxSerializedStringSize) {\n    throwLargeStringSize(size);\n  }\n  if (size < 0) {\n    throwNegativeStringSize(size);\n  }\n  expectChar(':');\n  expectChar(delimiter0);\n  auto const piece = readStr(size);\n  expectChar(delimiter1);\n  return piece;\n}\n\nString VariableUnserializer::unserializeString(char delimiter0,\n                                               char delimiter1) {\n  auto const piece = unserializeStringPiece(delimiter0, delimiter1);\n  return String::attach(readOnly() ?\n                        makeStaticString(piece) :\n                        StringData::Make(piece, CopyString));\n}\n\nvoid VariableUnserializer::unserializeCollection(ObjectData* obj, int64_t sz,\n                                                 char type) {\n  switch (obj->collectionType()) {\n    case CollectionType::Pair:\n      unserializePair(obj, sz, type);\n      break;\n    case CollectionType::Vector:\n    case CollectionType::ImmVector:\n      unserializeVector(obj, sz, type);\n      break;\n    case CollectionType::Map:\n    case CollectionType::ImmMap:\n      unserializeMap(obj, sz, type);\n      break;\n    case CollectionType::Set:\n    case CollectionType::ImmSet:\n      unserializeSet(obj, sz, type);\n      break;\n  }\n}\n\nvoid VariableUnserializer::unserializeVector(ObjectData* obj, int64_t sz,\n                                             char type) {\n  if (type != 'V') throwBadFormat(obj, type);\n\n  auto const sizeClass = PackedArray::capacityToSizeIndex(sz);\n  auto const allocsz = MemoryManager::sizeIndex2Size(sizeClass);\n  // For large vectors, do a naive pre-check for OOM.\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  auto bvec = static_cast<BaseVector*>(obj);\n  bvec->reserve(sz);\n  reserveForAdd(sz);\n  for (int64_t i = 0; i < sz; ++i) {\n    auto tv = bvec->appendForUnserialize(i);\n    HPHP::type(tv) = KindOfNull;\n    unserializeVariant(tv);\n  }\n}\n\n/*\n * Attempts to unserialize into an initially empty HH\\Map of string->int/string.\n * Returns false and leaves both 'map' and 'uns' untouched on failure, including\n * unexpected types and possibly legal, but uncommon, encodings.\n */\nNEVER_INLINE\nbool VariableUnserializer::tryUnserializeStrIntMap(BaseMap* map, int64_t sz) {\n  auto b = head();\n  /*\n   * For efficiency, we don't add the keys/values to m_refs, so don't support\n   * back-references appearing after this point. For simplicity, we thus require\n   * this map to be the root object being unserialized.\n   */\n  if (folly::StringPiece(begin(), b) !=\n      folly::to<std::string>(\"K:6:\\\"HH\\\\Map\\\":\", sz, \":{\")) {\n    return false;\n  }\n  auto const end = this->end();\n  auto const maxKeyLen = RuntimeOption::MaxSerializedStringSize;\n  /*\n   * First, parse the entire input and allocate the keys (accessing lots of\n   * data, but mostly sequentially).\n   */\n  auto checkPoint = map->batchInsertBegin(sz);\n  int64_t i = 0;\n  for (; i < sz; ++i) {\n    auto sd = readStringData(b, end, maxKeyLen);\n    if (!sd) break;\n    String key = String::attach(sd);\n    auto tv = map->batchInsert(key.get());\n    tv->m_type = KindOfNull;\n    if (*b == 'i') {\n      if (!readInt64(b, end, tv->m_data.num)) break;\n      tv->m_type = KindOfInt64;\n    } else if (*b == 's') {\n      auto sd = readStringData(b, end, maxKeyLen);\n      if (!sd) break;\n      tv->m_data.pstr = sd;\n      tv->m_type = KindOfString;\n    } else {\n      break;\n    }\n  }\n  /*\n   * On success, finalize the hash table insertion (very random access).\n   */\n  if (i == sz && map->tryBatchInsertEnd(checkPoint)) {\n    set(b, end);\n    return true;\n  }\n  map->batchInsertAbort(checkPoint);\n  return false;\n}\n\nvoid VariableUnserializer::unserializeMap(ObjectData* obj, int64_t sz,\n                                          char type) {\n  if (type != 'K') throwBadFormat(obj, type);\n\n  // For large maps, do a naive pre-check for OOM.\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(sz);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  auto map = static_cast<BaseMap*>(obj);\n  map->reserve(sz);\n  if (sz >= RuntimeOption::UnserializationBigMapThreshold &&\n      tryUnserializeStrIntMap(map, sz)) {\n    return;\n  }\n\n  reserveForAdd(sz + sz); // keys + values\n  for (int64_t i = 0; i < sz; ++i) {\n    Variant k;\n    unserializeVariant(k.asTypedValue(), UnserializeMode::ColKey);\n    TypedValue* tv = nullptr;\n    if (k.isInteger()) {\n      auto h = k.toInt64();\n      tv = map->findForUnserialize(h);\n      // Be robust against manually crafted inputs with conflicting elements\n      if (UNLIKELY(!tv)) {\n        tv = k.asTypedValue();\n        goto do_unserialize;\n      }\n    } else if (k.isString()) {\n      auto key = k.getStringData();\n      tv = map->findForUnserialize(key);\n      // Be robust against manually crafted inputs with conflicting elements\n      if (UNLIKELY(!tv)) {\n        tv = k.asTypedValue();\n        goto do_unserialize;\n      }\n    } else {\n      throwInvalidKey();\n    }\n    tv->m_type = KindOfNull;\ndo_unserialize:\n    unserializeVariant(tv);\n  }\n}\n\nvoid VariableUnserializer::unserializeSet(ObjectData* obj, int64_t sz,\n                                          char type) {\n  if (type != 'V') throwBadFormat(obj, type);\n\n  // For large maps, do a naive pre-check for OOM.\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(sz);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n\n  auto set = static_cast<BaseSet*>(obj);\n  set->reserve(sz);\n\n  reserveForAdd(sz);\n  for (int64_t i = 0; i < sz; ++i) {\n    // When unserializing an element of a Set, we use Mode::ColKey for now.\n    // This will make the unserializer to reserve an id for the element\n    // but won't allow referencing the element via 'r' or 'R'.\n    Variant k;\n    unserializeVariant(k.asTypedValue(), UnserializeMode::ColKey);\n    if (k.isInteger()) {\n      auto h = k.toInt64();\n      auto tv = set->findForUnserialize(h);\n      // Be robust against manually crafted inputs with conflicting elements\n      if (UNLIKELY(!tv)) continue;\n      tv->m_type = KindOfInt64;\n      tv->m_data.num = h;\n    } else if (k.isString()) {\n      auto key = k.getStringData();\n      auto tv = set->findForUnserialize(key);\n      if (UNLIKELY(!tv)) continue;\n      // This increments the string's refcount twice, once for\n      // the key and once for the value\n      tvDup(make_tv<KindOfString>(key), *tv);\n    } else {\n      throwInvalidHashKey(obj);\n    }\n  }\n}\n\nvoid VariableUnserializer::unserializePair(ObjectData* obj, int64_t sz,\n                                           char type) {\n  assertx(sz == 2);\n  if (type != 'V') throwBadFormat(obj, type);\n  auto pair = static_cast<c_Pair*>(obj);\n  unserializeVariant(pair->at(0));\n  unserializeVariant(pair->at(1));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid VariableUnserializer::reserialize(StringBuffer& buf) {\n\n  char type = readChar();\n  char sep = readChar();\n\n  if (type == 'N') {\n    buf.append(type);\n    buf.append(sep);\n    return;\n  }\n\n  switch (type) {\n  case 'r':\n  case 'R':\n  case 'b':\n  case 'i':\n  case 'd':\n    {\n      buf.append(type);\n      buf.append(sep);\n      while (peek() != ';') {\n        char ch;\n        ch = readChar();\n        buf.append(ch);\n      }\n    }\n    break;\n  case 'S':\n  case 'A':\n    {\n      // shouldn't happen, but keep the code here anyway.\n      buf.append(type);\n      buf.append(sep);\n      auto str = readStr(8);\n      buf.append(str.data(), str.size());\n    }\n    break;\n  case 's':\n    {\n      String v = unserializeString();\n      assertx(!v.isNull());\n      if (v.get()->isStatic()) {\n        union {\n          char pointer[8];\n          StringData *sd;\n        } u;\n        u.sd = v.get();\n        buf.append(\"S:\");\n        buf.append(u.pointer, 8);\n        buf.append(';');\n      } else {\n        buf.append(\"s:\");\n        buf.append(v.size());\n        buf.append(\":\\\"\");\n        buf.append(v.data(), v.size());\n        buf.append(\"\\\";\");\n      }\n      sep = readChar();\n      return;\n    }\n    break;\n  case 'a':\n  case 'D':\n  case 'Y':\n  case 'H':\n    {\n      buf.append(type == 'a' ? \"a:\" : (type == 'Y' ? \"Y:\" :\n            (type == 'D' ? \"D:\" : \"H:\")));\n      int64_t size = readInt();\n      char sep2 = readChar();\n      buf.append(size);\n      buf.append(sep2);\n      sep2 = readChar();\n      buf.append(sep2);\n      for (int64_t i = 0; i < size; i++) {\n        reserialize(buf); // key\n        reserialize(buf); // value\n      }\n      sep2 = readChar(); // '}'\n      buf.append(sep2);\n      return;\n    }\n    break;\n  case 'v':\n  case 'k':\n  case 'y':\n    {\n      buf.append(type == 'v' ? \"v:\" : (type == 'y' ? \"y:\" : \"k:\"));\n      int64_t size = readInt();\n      char sep2 = readChar();\n      buf.append(size);\n      buf.append(sep2);\n      sep2 = readChar();\n      buf.append(sep2);\n      for (int64_t i = 0; i < size; ++i) {\n        reserialize(buf);\n      }\n      sep2 = readChar(); // '}'\n      buf.append(sep2);\n      return;\n    }\n  case 'o':\n  case 'O':\n  case 'V':\n  case 'K':\n    {\n      buf.append(type);\n      buf.append(sep);\n\n      auto const clsName = unserializeStringPiece();\n      buf.append(static_cast<int>(clsName.size()));\n      buf.append(\":\\\"\");\n      buf.append(clsName.data(), clsName.size());\n      buf.append(\"\\\":\");\n\n      readChar();\n      int64_t size = readInt();\n      char sep2 = readChar();\n\n      buf.append(size);\n      buf.append(sep2);\n      sep2 = readChar(); // '{'\n      buf.append(sep2);\n      // 'V' type is a series with values only, while all other\n      // types are series with keys and values\n      int64_t i = type == 'V' ? size : size * 2;\n      while (i--) {\n        reserialize(buf);\n      }\n      sep2 = readChar(); // '}'\n      buf.append(sep2);\n      return;\n    }\n    break;\n  case 'C':\n    {\n      buf.append(type);\n      buf.append(sep);\n\n      auto const clsName = unserializeStringPiece();\n      buf.append(static_cast<int>(clsName.size()));\n      buf.append(\":\\\"\");\n      buf.append(clsName.data(), clsName.size());\n      buf.append(\"\\\":\");\n\n      sep = readChar(); // ':'\n      auto const serialized = unserializeStringPiece('{', '}');\n      buf.append(static_cast<int>(serialized.size()));\n      buf.append(\":{\");\n      buf.append(serialized.data(), serialized.size());\n      buf.append('}');\n      return;\n    }\n    break;\n  default:\n    throwUnknownType(type);\n  }\n\n  sep = readChar(); // the last ';'\n  buf.append(sep);\n}\n\n}\n"], "filenames": ["hphp/runtime/base/object-data.cpp", "hphp/runtime/base/variable-unserializer.cpp"], "buggy_code_start_loc": [342, 554], "buggy_code_end_loc": [342, 554], "fixing_code_start_loc": [343, 555], "fixing_code_end_loc": [348, 556], "type": "CWE-416", "message": "When unserializing an object with dynamic properties HHVM needs to pre-reserve the full size of the dynamic property array before inserting anything into it. Otherwise the array might resize, invalidating previously stored references. This pre-reservation was not occurring in HHVM prior to v4.32.3, between versions 4.33.0 and 4.56.0, 4.57.0, 4.58.0, 4.58.1, 4.59.0, 4.60.0, 4.61.0, 4.62.0.", "other": {"cve": {"id": "CVE-2020-1900", "sourceIdentifier": "cve-assign@fb.com", "published": "2021-03-11T01:15:14.490", "lastModified": "2021-03-18T14:10:46.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "When unserializing an object with dynamic properties HHVM needs to pre-reserve the full size of the dynamic property array before inserting anything into it. Otherwise the array might resize, invalidating previously stored references. This pre-reservation was not occurring in HHVM prior to v4.32.3, between versions 4.33.0 and 4.56.0, 4.57.0, 4.58.0, 4.58.1, 4.59.0, 4.60.0, 4.61.0, 4.62.0."}, {"lang": "es", "value": "Cuando se anula la serializaci\u00f3n de un objeto con propiedades din\u00e1micas, HHVM necesita reservar previamente el tama\u00f1o completo de la matriz de propiedades din\u00e1micas antes de insertar algo en ella.&#xa0;De lo contrario, la matriz podr\u00eda cambiar de tama\u00f1o, invalidando las referencias almacenadas previamente.&#xa0;Esta reserva previa no estaba ocurriendo en HHVM versiones anteriores a v4.32.3, entre las versiones 4.33.0 y 4.56.0, 4.57.0, 4.58.0, 4.58.1, 4.59.0, 4.60.0, 4.61.0, 4.62 .0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.32.3", "matchCriteriaId": "D2372F3F-5757-4097-BA67-61D7597F6D65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.33.0", "versionEndExcluding": "4.56.1", "matchCriteriaId": "E83916FC-54F0-4A1B-99AD-0B81774170EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.57.0:*:*:*:*:*:*:*", "matchCriteriaId": "4F80C7A6-7FD9-4EAB-8533-F5C8ABF9F258"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.58.0:*:*:*:*:*:*:*", "matchCriteriaId": "2006DF19-68B4-4139-AAAF-7F81B9742DA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.58.1:*:*:*:*:*:*:*", "matchCriteriaId": "8A9D0CEF-7EC2-421B-A45D-48D9663DB60B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.59.0:*:*:*:*:*:*:*", "matchCriteriaId": "169B4C73-75D5-46FD-BADB-384ABFB9A6C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.60.0:*:*:*:*:*:*:*", "matchCriteriaId": "A48FC296-D7B6-4B58-A386-9F5F5F6294AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.61.0:*:*:*:*:*:*:*", "matchCriteriaId": "5F702D76-27C2-4798-BF3C-242906E8E697"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.62.0:*:*:*:*:*:*:*", "matchCriteriaId": "AC078675-9A81-4B74-8818-0FFE9AF66296"}]}]}], "references": [{"url": "https://github.com/facebook/hhvm/commit/c1c4bb0cf9e076aafaf4ff3515556ef9faf906f3", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hhvm.com/blog/2020/06/30/security-update.html", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hhvm/commit/c1c4bb0cf9e076aafaf4ff3515556ef9faf906f3"}}