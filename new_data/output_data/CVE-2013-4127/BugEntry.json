{"buggy_code": ["/* Copyright (C) 2009 Red Hat, Inc.\n * Author: Michael S. Tsirkin <mst@redhat.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.\n *\n * virtio-net server in host kernel.\n */\n\n#include <linux/compat.h>\n#include <linux/eventfd.h>\n#include <linux/vhost.h>\n#include <linux/virtio_net.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\n#include <linux/net.h>\n#include <linux/if_packet.h>\n#include <linux/if_arp.h>\n#include <linux/if_tun.h>\n#include <linux/if_macvlan.h>\n#include <linux/if_vlan.h>\n\n#include <net/sock.h>\n\n#include \"vhost.h\"\n\nstatic int experimental_zcopytx = 1;\nmodule_param(experimental_zcopytx, int, 0444);\nMODULE_PARM_DESC(experimental_zcopytx, \"Enable Zero Copy TX;\"\n\t\t                       \" 1 -Enable; 0 - Disable\");\n\n/* Max number of bytes transferred before requeueing the job.\n * Using this limit prevents one virtqueue from starving others. */\n#define VHOST_NET_WEIGHT 0x80000\n\n/* MAX number of TX used buffers for outstanding zerocopy */\n#define VHOST_MAX_PEND 128\n#define VHOST_GOODCOPY_LEN 256\n\n/*\n * For transmit, used buffer len is unused; we override it to track buffer\n * status internally; used for zerocopy tx only.\n */\n/* Lower device DMA failed */\n#define VHOST_DMA_FAILED_LEN\t3\n/* Lower device DMA done */\n#define VHOST_DMA_DONE_LEN\t2\n/* Lower device DMA in progress */\n#define VHOST_DMA_IN_PROGRESS\t1\n/* Buffer unused */\n#define VHOST_DMA_CLEAR_LEN\t0\n\n#define VHOST_DMA_IS_DONE(len) ((len) >= VHOST_DMA_DONE_LEN)\n\nenum {\n\tVHOST_NET_FEATURES = VHOST_FEATURES |\n\t\t\t (1ULL << VHOST_NET_F_VIRTIO_NET_HDR) |\n\t\t\t (1ULL << VIRTIO_NET_F_MRG_RXBUF),\n};\n\nenum {\n\tVHOST_NET_VQ_RX = 0,\n\tVHOST_NET_VQ_TX = 1,\n\tVHOST_NET_VQ_MAX = 2,\n};\n\nstruct vhost_net_ubuf_ref {\n\tstruct kref kref;\n\twait_queue_head_t wait;\n\tstruct vhost_virtqueue *vq;\n};\n\nstruct vhost_net_virtqueue {\n\tstruct vhost_virtqueue vq;\n\t/* hdr is used to store the virtio header.\n\t * Since each iovec has >= 1 byte length, we never need more than\n\t * header length entries to store the header. */\n\tstruct iovec hdr[sizeof(struct virtio_net_hdr_mrg_rxbuf)];\n\tsize_t vhost_hlen;\n\tsize_t sock_hlen;\n\t/* vhost zerocopy support fields below: */\n\t/* last used idx for outstanding DMA zerocopy buffers */\n\tint upend_idx;\n\t/* first used idx for DMA done zerocopy buffers */\n\tint done_idx;\n\t/* an array of userspace buffers info */\n\tstruct ubuf_info *ubuf_info;\n\t/* Reference counting for outstanding ubufs.\n\t * Protected by vq mutex. Writers must also take device mutex. */\n\tstruct vhost_net_ubuf_ref *ubufs;\n};\n\nstruct vhost_net {\n\tstruct vhost_dev dev;\n\tstruct vhost_net_virtqueue vqs[VHOST_NET_VQ_MAX];\n\tstruct vhost_poll poll[VHOST_NET_VQ_MAX];\n\t/* Number of TX recently submitted.\n\t * Protected by tx vq lock. */\n\tunsigned tx_packets;\n\t/* Number of times zerocopy TX recently failed.\n\t * Protected by tx vq lock. */\n\tunsigned tx_zcopy_err;\n\t/* Flush in progress. Protected by tx vq lock. */\n\tbool tx_flush;\n};\n\nstatic unsigned vhost_net_zcopy_mask __read_mostly;\n\nstatic void vhost_net_enable_zcopy(int vq)\n{\n\tvhost_net_zcopy_mask |= 0x1 << vq;\n}\n\nstatic void vhost_net_zerocopy_done_signal(struct kref *kref)\n{\n\tstruct vhost_net_ubuf_ref *ubufs;\n\n\tubufs = container_of(kref, struct vhost_net_ubuf_ref, kref);\n\twake_up(&ubufs->wait);\n}\n\nstatic struct vhost_net_ubuf_ref *\nvhost_net_ubuf_alloc(struct vhost_virtqueue *vq, bool zcopy)\n{\n\tstruct vhost_net_ubuf_ref *ubufs;\n\t/* No zero copy backend? Nothing to count. */\n\tif (!zcopy)\n\t\treturn NULL;\n\tubufs = kmalloc(sizeof(*ubufs), GFP_KERNEL);\n\tif (!ubufs)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkref_init(&ubufs->kref);\n\tinit_waitqueue_head(&ubufs->wait);\n\tubufs->vq = vq;\n\treturn ubufs;\n}\n\nstatic void vhost_net_ubuf_put(struct vhost_net_ubuf_ref *ubufs)\n{\n\tkref_put(&ubufs->kref, vhost_net_zerocopy_done_signal);\n}\n\nstatic void vhost_net_ubuf_put_and_wait(struct vhost_net_ubuf_ref *ubufs)\n{\n\tkref_put(&ubufs->kref, vhost_net_zerocopy_done_signal);\n\twait_event(ubufs->wait, !atomic_read(&ubufs->kref.refcount));\n\tkfree(ubufs);\n}\n\nstatic void vhost_net_clear_ubuf_info(struct vhost_net *n)\n{\n\tint i;\n\n\tfor (i = 0; i < VHOST_NET_VQ_MAX; ++i) {\n\t\tkfree(n->vqs[i].ubuf_info);\n\t\tn->vqs[i].ubuf_info = NULL;\n\t}\n}\n\nint vhost_net_set_ubuf_info(struct vhost_net *n)\n{\n\tbool zcopy;\n\tint i;\n\n\tfor (i = 0; i < VHOST_NET_VQ_MAX; ++i) {\n\t\tzcopy = vhost_net_zcopy_mask & (0x1 << i);\n\t\tif (!zcopy)\n\t\t\tcontinue;\n\t\tn->vqs[i].ubuf_info = kmalloc(sizeof(*n->vqs[i].ubuf_info) *\n\t\t\t\t\t      UIO_MAXIOV, GFP_KERNEL);\n\t\tif  (!n->vqs[i].ubuf_info)\n\t\t\tgoto err;\n\t}\n\treturn 0;\n\nerr:\n\tvhost_net_clear_ubuf_info(n);\n\treturn -ENOMEM;\n}\n\nvoid vhost_net_vq_reset(struct vhost_net *n)\n{\n\tint i;\n\n\tvhost_net_clear_ubuf_info(n);\n\n\tfor (i = 0; i < VHOST_NET_VQ_MAX; i++) {\n\t\tn->vqs[i].done_idx = 0;\n\t\tn->vqs[i].upend_idx = 0;\n\t\tn->vqs[i].ubufs = NULL;\n\t\tn->vqs[i].vhost_hlen = 0;\n\t\tn->vqs[i].sock_hlen = 0;\n\t}\n\n}\n\nstatic void vhost_net_tx_packet(struct vhost_net *net)\n{\n\t++net->tx_packets;\n\tif (net->tx_packets < 1024)\n\t\treturn;\n\tnet->tx_packets = 0;\n\tnet->tx_zcopy_err = 0;\n}\n\nstatic void vhost_net_tx_err(struct vhost_net *net)\n{\n\t++net->tx_zcopy_err;\n}\n\nstatic bool vhost_net_tx_select_zcopy(struct vhost_net *net)\n{\n\t/* TX flush waits for outstanding DMAs to be done.\n\t * Don't start new DMAs.\n\t */\n\treturn !net->tx_flush &&\n\t\tnet->tx_packets / 64 >= net->tx_zcopy_err;\n}\n\nstatic bool vhost_sock_zcopy(struct socket *sock)\n{\n\treturn unlikely(experimental_zcopytx) &&\n\t\tsock_flag(sock->sk, SOCK_ZEROCOPY);\n}\n\n/* Pop first len bytes from iovec. Return number of segments used. */\nstatic int move_iovec_hdr(struct iovec *from, struct iovec *to,\n\t\t\t  size_t len, int iov_count)\n{\n\tint seg = 0;\n\tsize_t size;\n\n\twhile (len && seg < iov_count) {\n\t\tsize = min(from->iov_len, len);\n\t\tto->iov_base = from->iov_base;\n\t\tto->iov_len = size;\n\t\tfrom->iov_len -= size;\n\t\tfrom->iov_base += size;\n\t\tlen -= size;\n\t\t++from;\n\t\t++to;\n\t\t++seg;\n\t}\n\treturn seg;\n}\n/* Copy iovec entries for len bytes from iovec. */\nstatic void copy_iovec_hdr(const struct iovec *from, struct iovec *to,\n\t\t\t   size_t len, int iovcount)\n{\n\tint seg = 0;\n\tsize_t size;\n\n\twhile (len && seg < iovcount) {\n\t\tsize = min(from->iov_len, len);\n\t\tto->iov_base = from->iov_base;\n\t\tto->iov_len = size;\n\t\tlen -= size;\n\t\t++from;\n\t\t++to;\n\t\t++seg;\n\t}\n}\n\n/* In case of DMA done not in order in lower device driver for some reason.\n * upend_idx is used to track end of used idx, done_idx is used to track head\n * of used idx. Once lower device DMA done contiguously, we will signal KVM\n * guest used idx.\n */\nstatic int vhost_zerocopy_signal_used(struct vhost_net *net,\n\t\t\t\t      struct vhost_virtqueue *vq)\n{\n\tstruct vhost_net_virtqueue *nvq =\n\t\tcontainer_of(vq, struct vhost_net_virtqueue, vq);\n\tint i;\n\tint j = 0;\n\n\tfor (i = nvq->done_idx; i != nvq->upend_idx; i = (i + 1) % UIO_MAXIOV) {\n\t\tif (vq->heads[i].len == VHOST_DMA_FAILED_LEN)\n\t\t\tvhost_net_tx_err(net);\n\t\tif (VHOST_DMA_IS_DONE(vq->heads[i].len)) {\n\t\t\tvq->heads[i].len = VHOST_DMA_CLEAR_LEN;\n\t\t\tvhost_add_used_and_signal(vq->dev, vq,\n\t\t\t\t\t\t  vq->heads[i].id, 0);\n\t\t\t++j;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif (j)\n\t\tnvq->done_idx = i;\n\treturn j;\n}\n\nstatic void vhost_zerocopy_callback(struct ubuf_info *ubuf, bool success)\n{\n\tstruct vhost_net_ubuf_ref *ubufs = ubuf->ctx;\n\tstruct vhost_virtqueue *vq = ubufs->vq;\n\tint cnt = atomic_read(&ubufs->kref.refcount);\n\n\t/*\n\t * Trigger polling thread if guest stopped submitting new buffers:\n\t * in this case, the refcount after decrement will eventually reach 1\n\t * so here it is 2.\n\t * We also trigger polling periodically after each 16 packets\n\t * (the value 16 here is more or less arbitrary, it's tuned to trigger\n\t * less than 10% of times).\n\t */\n\tif (cnt <= 2 || !(cnt % 16))\n\t\tvhost_poll_queue(&vq->poll);\n\t/* set len to mark this desc buffers done DMA */\n\tvq->heads[ubuf->desc].len = success ?\n\t\tVHOST_DMA_DONE_LEN : VHOST_DMA_FAILED_LEN;\n\tvhost_net_ubuf_put(ubufs);\n}\n\n/* Expects to be always run from workqueue - which acts as\n * read-size critical section for our kind of RCU. */\nstatic void handle_tx(struct vhost_net *net)\n{\n\tstruct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_TX];\n\tstruct vhost_virtqueue *vq = &nvq->vq;\n\tunsigned out, in, s;\n\tint head;\n\tstruct msghdr msg = {\n\t\t.msg_name = NULL,\n\t\t.msg_namelen = 0,\n\t\t.msg_control = NULL,\n\t\t.msg_controllen = 0,\n\t\t.msg_iov = vq->iov,\n\t\t.msg_flags = MSG_DONTWAIT,\n\t};\n\tsize_t len, total_len = 0;\n\tint err;\n\tsize_t hdr_size;\n\tstruct socket *sock;\n\tstruct vhost_net_ubuf_ref *uninitialized_var(ubufs);\n\tbool zcopy, zcopy_used;\n\n\t/* TODO: check that we are running from vhost_worker? */\n\tsock = rcu_dereference_check(vq->private_data, 1);\n\tif (!sock)\n\t\treturn;\n\n\tmutex_lock(&vq->mutex);\n\tvhost_disable_notify(&net->dev, vq);\n\n\thdr_size = nvq->vhost_hlen;\n\tzcopy = nvq->ubufs;\n\n\tfor (;;) {\n\t\t/* Release DMAs done buffers first */\n\t\tif (zcopy)\n\t\t\tvhost_zerocopy_signal_used(net, vq);\n\n\t\thead = vhost_get_vq_desc(&net->dev, vq, vq->iov,\n\t\t\t\t\t ARRAY_SIZE(vq->iov),\n\t\t\t\t\t &out, &in,\n\t\t\t\t\t NULL, NULL);\n\t\t/* On error, stop handling until the next kick. */\n\t\tif (unlikely(head < 0))\n\t\t\tbreak;\n\t\t/* Nothing new?  Wait for eventfd to tell us they refilled. */\n\t\tif (head == vq->num) {\n\t\t\tint num_pends;\n\n\t\t\t/* If more outstanding DMAs, queue the work.\n\t\t\t * Handle upend_idx wrap around\n\t\t\t */\n\t\t\tnum_pends = likely(nvq->upend_idx >= nvq->done_idx) ?\n\t\t\t\t    (nvq->upend_idx - nvq->done_idx) :\n\t\t\t\t    (nvq->upend_idx + UIO_MAXIOV -\n\t\t\t\t     nvq->done_idx);\n\t\t\tif (unlikely(num_pends > VHOST_MAX_PEND))\n\t\t\t\tbreak;\n\t\t\tif (unlikely(vhost_enable_notify(&net->dev, vq))) {\n\t\t\t\tvhost_disable_notify(&net->dev, vq);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (in) {\n\t\t\tvq_err(vq, \"Unexpected descriptor format for TX: \"\n\t\t\t       \"out %d, int %d\\n\", out, in);\n\t\t\tbreak;\n\t\t}\n\t\t/* Skip header. TODO: support TSO. */\n\t\ts = move_iovec_hdr(vq->iov, nvq->hdr, hdr_size, out);\n\t\tmsg.msg_iovlen = out;\n\t\tlen = iov_length(vq->iov, out);\n\t\t/* Sanity check */\n\t\tif (!len) {\n\t\t\tvq_err(vq, \"Unexpected header len for TX: \"\n\t\t\t       \"%zd expected %zd\\n\",\n\t\t\t       iov_length(nvq->hdr, s), hdr_size);\n\t\t\tbreak;\n\t\t}\n\t\tzcopy_used = zcopy && (len >= VHOST_GOODCOPY_LEN ||\n\t\t\t\t       nvq->upend_idx != nvq->done_idx);\n\n\t\t/* use msg_control to pass vhost zerocopy ubuf info to skb */\n\t\tif (zcopy_used) {\n\t\t\tvq->heads[nvq->upend_idx].id = head;\n\t\t\tif (!vhost_net_tx_select_zcopy(net) ||\n\t\t\t    len < VHOST_GOODCOPY_LEN) {\n\t\t\t\t/* copy don't need to wait for DMA done */\n\t\t\t\tvq->heads[nvq->upend_idx].len =\n\t\t\t\t\t\t\tVHOST_DMA_DONE_LEN;\n\t\t\t\tmsg.msg_control = NULL;\n\t\t\t\tmsg.msg_controllen = 0;\n\t\t\t\tubufs = NULL;\n\t\t\t} else {\n\t\t\t\tstruct ubuf_info *ubuf;\n\t\t\t\tubuf = nvq->ubuf_info + nvq->upend_idx;\n\n\t\t\t\tvq->heads[nvq->upend_idx].len =\n\t\t\t\t\tVHOST_DMA_IN_PROGRESS;\n\t\t\t\tubuf->callback = vhost_zerocopy_callback;\n\t\t\t\tubuf->ctx = nvq->ubufs;\n\t\t\t\tubuf->desc = nvq->upend_idx;\n\t\t\t\tmsg.msg_control = ubuf;\n\t\t\t\tmsg.msg_controllen = sizeof(ubuf);\n\t\t\t\tubufs = nvq->ubufs;\n\t\t\t\tkref_get(&ubufs->kref);\n\t\t\t}\n\t\t\tnvq->upend_idx = (nvq->upend_idx + 1) % UIO_MAXIOV;\n\t\t} else\n\t\t\tmsg.msg_control = NULL;\n\t\t/* TODO: Check specific error and bomb out unless ENOBUFS? */\n\t\terr = sock->ops->sendmsg(NULL, sock, &msg, len);\n\t\tif (unlikely(err < 0)) {\n\t\t\tif (zcopy_used) {\n\t\t\t\tif (ubufs)\n\t\t\t\t\tvhost_net_ubuf_put(ubufs);\n\t\t\t\tnvq->upend_idx = ((unsigned)nvq->upend_idx - 1)\n\t\t\t\t\t% UIO_MAXIOV;\n\t\t\t}\n\t\t\tvhost_discard_vq_desc(vq, 1);\n\t\t\tbreak;\n\t\t}\n\t\tif (err != len)\n\t\t\tpr_debug(\"Truncated TX packet: \"\n\t\t\t\t \" len %d != %zd\\n\", err, len);\n\t\tif (!zcopy_used)\n\t\t\tvhost_add_used_and_signal(&net->dev, vq, head, 0);\n\t\telse\n\t\t\tvhost_zerocopy_signal_used(net, vq);\n\t\ttotal_len += len;\n\t\tvhost_net_tx_packet(net);\n\t\tif (unlikely(total_len >= VHOST_NET_WEIGHT)) {\n\t\t\tvhost_poll_queue(&vq->poll);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&vq->mutex);\n}\n\nstatic int peek_head_len(struct sock *sk)\n{\n\tstruct sk_buff *head;\n\tint len = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sk->sk_receive_queue.lock, flags);\n\thead = skb_peek(&sk->sk_receive_queue);\n\tif (likely(head)) {\n\t\tlen = head->len;\n\t\tif (vlan_tx_tag_present(head))\n\t\t\tlen += VLAN_HLEN;\n\t}\n\n\tspin_unlock_irqrestore(&sk->sk_receive_queue.lock, flags);\n\treturn len;\n}\n\n/* This is a multi-buffer version of vhost_get_desc, that works if\n *\tvq has read descriptors only.\n * @vq\t\t- the relevant virtqueue\n * @datalen\t- data length we'll be reading\n * @iovcount\t- returned count of io vectors we fill\n * @log\t\t- vhost log\n * @log_num\t- log offset\n * @quota       - headcount quota, 1 for big buffer\n *\treturns number of buffer heads allocated, negative on error\n */\nstatic int get_rx_bufs(struct vhost_virtqueue *vq,\n\t\t       struct vring_used_elem *heads,\n\t\t       int datalen,\n\t\t       unsigned *iovcount,\n\t\t       struct vhost_log *log,\n\t\t       unsigned *log_num,\n\t\t       unsigned int quota)\n{\n\tunsigned int out, in;\n\tint seg = 0;\n\tint headcount = 0;\n\tunsigned d;\n\tint r, nlogs = 0;\n\n\twhile (datalen > 0 && headcount < quota) {\n\t\tif (unlikely(seg >= UIO_MAXIOV)) {\n\t\t\tr = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\t\td = vhost_get_vq_desc(vq->dev, vq, vq->iov + seg,\n\t\t\t\t      ARRAY_SIZE(vq->iov) - seg, &out,\n\t\t\t\t      &in, log, log_num);\n\t\tif (d == vq->num) {\n\t\t\tr = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(out || in <= 0)) {\n\t\t\tvq_err(vq, \"unexpected descriptor format for RX: \"\n\t\t\t\t\"out %d, in %d\\n\", out, in);\n\t\t\tr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(log)) {\n\t\t\tnlogs += *log_num;\n\t\t\tlog += *log_num;\n\t\t}\n\t\theads[headcount].id = d;\n\t\theads[headcount].len = iov_length(vq->iov + seg, in);\n\t\tdatalen -= heads[headcount].len;\n\t\t++headcount;\n\t\tseg += in;\n\t}\n\theads[headcount - 1].len += datalen;\n\t*iovcount = seg;\n\tif (unlikely(log))\n\t\t*log_num = nlogs;\n\treturn headcount;\nerr:\n\tvhost_discard_vq_desc(vq, headcount);\n\treturn r;\n}\n\n/* Expects to be always run from workqueue - which acts as\n * read-size critical section for our kind of RCU. */\nstatic void handle_rx(struct vhost_net *net)\n{\n\tstruct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];\n\tstruct vhost_virtqueue *vq = &nvq->vq;\n\tunsigned uninitialized_var(in), log;\n\tstruct vhost_log *vq_log;\n\tstruct msghdr msg = {\n\t\t.msg_name = NULL,\n\t\t.msg_namelen = 0,\n\t\t.msg_control = NULL, /* FIXME: get and handle RX aux data. */\n\t\t.msg_controllen = 0,\n\t\t.msg_iov = vq->iov,\n\t\t.msg_flags = MSG_DONTWAIT,\n\t};\n\tstruct virtio_net_hdr_mrg_rxbuf hdr = {\n\t\t.hdr.flags = 0,\n\t\t.hdr.gso_type = VIRTIO_NET_HDR_GSO_NONE\n\t};\n\tsize_t total_len = 0;\n\tint err, mergeable;\n\ts16 headcount;\n\tsize_t vhost_hlen, sock_hlen;\n\tsize_t vhost_len, sock_len;\n\t/* TODO: check that we are running from vhost_worker? */\n\tstruct socket *sock = rcu_dereference_check(vq->private_data, 1);\n\n\tif (!sock)\n\t\treturn;\n\n\tmutex_lock(&vq->mutex);\n\tvhost_disable_notify(&net->dev, vq);\n\tvhost_hlen = nvq->vhost_hlen;\n\tsock_hlen = nvq->sock_hlen;\n\n\tvq_log = unlikely(vhost_has_feature(&net->dev, VHOST_F_LOG_ALL)) ?\n\t\tvq->log : NULL;\n\tmergeable = vhost_has_feature(&net->dev, VIRTIO_NET_F_MRG_RXBUF);\n\n\twhile ((sock_len = peek_head_len(sock->sk))) {\n\t\tsock_len += sock_hlen;\n\t\tvhost_len = sock_len + vhost_hlen;\n\t\theadcount = get_rx_bufs(vq, vq->heads, vhost_len,\n\t\t\t\t\t&in, vq_log, &log,\n\t\t\t\t\tlikely(mergeable) ? UIO_MAXIOV : 1);\n\t\t/* On error, stop handling until the next kick. */\n\t\tif (unlikely(headcount < 0))\n\t\t\tbreak;\n\t\t/* OK, now we need to know about added descriptors. */\n\t\tif (!headcount) {\n\t\t\tif (unlikely(vhost_enable_notify(&net->dev, vq))) {\n\t\t\t\t/* They have slipped one in as we were\n\t\t\t\t * doing that: check again. */\n\t\t\t\tvhost_disable_notify(&net->dev, vq);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Nothing new?  Wait for eventfd to tell us\n\t\t\t * they refilled. */\n\t\t\tbreak;\n\t\t}\n\t\t/* We don't need to be notified again. */\n\t\tif (unlikely((vhost_hlen)))\n\t\t\t/* Skip header. TODO: support TSO. */\n\t\t\tmove_iovec_hdr(vq->iov, nvq->hdr, vhost_hlen, in);\n\t\telse\n\t\t\t/* Copy the header for use in VIRTIO_NET_F_MRG_RXBUF:\n\t\t\t * needed because recvmsg can modify msg_iov. */\n\t\t\tcopy_iovec_hdr(vq->iov, nvq->hdr, sock_hlen, in);\n\t\tmsg.msg_iovlen = in;\n\t\terr = sock->ops->recvmsg(NULL, sock, &msg,\n\t\t\t\t\t sock_len, MSG_DONTWAIT | MSG_TRUNC);\n\t\t/* Userspace might have consumed the packet meanwhile:\n\t\t * it's not supposed to do this usually, but might be hard\n\t\t * to prevent. Discard data we got (if any) and keep going. */\n\t\tif (unlikely(err != sock_len)) {\n\t\t\tpr_debug(\"Discarded rx packet: \"\n\t\t\t\t \" len %d, expected %zd\\n\", err, sock_len);\n\t\t\tvhost_discard_vq_desc(vq, headcount);\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(vhost_hlen) &&\n\t\t    memcpy_toiovecend(nvq->hdr, (unsigned char *)&hdr, 0,\n\t\t\t\t      vhost_hlen)) {\n\t\t\tvq_err(vq, \"Unable to write vnet_hdr at addr %p\\n\",\n\t\t\t       vq->iov->iov_base);\n\t\t\tbreak;\n\t\t}\n\t\t/* TODO: Should check and handle checksum. */\n\t\tif (likely(mergeable) &&\n\t\t    memcpy_toiovecend(nvq->hdr, (unsigned char *)&headcount,\n\t\t\t\t      offsetof(typeof(hdr), num_buffers),\n\t\t\t\t      sizeof hdr.num_buffers)) {\n\t\t\tvq_err(vq, \"Failed num_buffers write\");\n\t\t\tvhost_discard_vq_desc(vq, headcount);\n\t\t\tbreak;\n\t\t}\n\t\tvhost_add_used_and_signal_n(&net->dev, vq, vq->heads,\n\t\t\t\t\t    headcount);\n\t\tif (unlikely(vq_log))\n\t\t\tvhost_log_write(vq, vq_log, log, vhost_len);\n\t\ttotal_len += vhost_len;\n\t\tif (unlikely(total_len >= VHOST_NET_WEIGHT)) {\n\t\t\tvhost_poll_queue(&vq->poll);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&vq->mutex);\n}\n\nstatic void handle_tx_kick(struct vhost_work *work)\n{\n\tstruct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,\n\t\t\t\t\t\t  poll.work);\n\tstruct vhost_net *net = container_of(vq->dev, struct vhost_net, dev);\n\n\thandle_tx(net);\n}\n\nstatic void handle_rx_kick(struct vhost_work *work)\n{\n\tstruct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,\n\t\t\t\t\t\t  poll.work);\n\tstruct vhost_net *net = container_of(vq->dev, struct vhost_net, dev);\n\n\thandle_rx(net);\n}\n\nstatic void handle_tx_net(struct vhost_work *work)\n{\n\tstruct vhost_net *net = container_of(work, struct vhost_net,\n\t\t\t\t\t     poll[VHOST_NET_VQ_TX].work);\n\thandle_tx(net);\n}\n\nstatic void handle_rx_net(struct vhost_work *work)\n{\n\tstruct vhost_net *net = container_of(work, struct vhost_net,\n\t\t\t\t\t     poll[VHOST_NET_VQ_RX].work);\n\thandle_rx(net);\n}\n\nstatic int vhost_net_open(struct inode *inode, struct file *f)\n{\n\tstruct vhost_net *n = kmalloc(sizeof *n, GFP_KERNEL);\n\tstruct vhost_dev *dev;\n\tstruct vhost_virtqueue **vqs;\n\tint r, i;\n\n\tif (!n)\n\t\treturn -ENOMEM;\n\tvqs = kmalloc(VHOST_NET_VQ_MAX * sizeof(*vqs), GFP_KERNEL);\n\tif (!vqs) {\n\t\tkfree(n);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev = &n->dev;\n\tvqs[VHOST_NET_VQ_TX] = &n->vqs[VHOST_NET_VQ_TX].vq;\n\tvqs[VHOST_NET_VQ_RX] = &n->vqs[VHOST_NET_VQ_RX].vq;\n\tn->vqs[VHOST_NET_VQ_TX].vq.handle_kick = handle_tx_kick;\n\tn->vqs[VHOST_NET_VQ_RX].vq.handle_kick = handle_rx_kick;\n\tfor (i = 0; i < VHOST_NET_VQ_MAX; i++) {\n\t\tn->vqs[i].ubufs = NULL;\n\t\tn->vqs[i].ubuf_info = NULL;\n\t\tn->vqs[i].upend_idx = 0;\n\t\tn->vqs[i].done_idx = 0;\n\t\tn->vqs[i].vhost_hlen = 0;\n\t\tn->vqs[i].sock_hlen = 0;\n\t}\n\tr = vhost_dev_init(dev, vqs, VHOST_NET_VQ_MAX);\n\tif (r < 0) {\n\t\tkfree(n);\n\t\tkfree(vqs);\n\t\treturn r;\n\t}\n\n\tvhost_poll_init(n->poll + VHOST_NET_VQ_TX, handle_tx_net, POLLOUT, dev);\n\tvhost_poll_init(n->poll + VHOST_NET_VQ_RX, handle_rx_net, POLLIN, dev);\n\n\tf->private_data = n;\n\n\treturn 0;\n}\n\nstatic void vhost_net_disable_vq(struct vhost_net *n,\n\t\t\t\t struct vhost_virtqueue *vq)\n{\n\tstruct vhost_net_virtqueue *nvq =\n\t\tcontainer_of(vq, struct vhost_net_virtqueue, vq);\n\tstruct vhost_poll *poll = n->poll + (nvq - n->vqs);\n\tif (!vq->private_data)\n\t\treturn;\n\tvhost_poll_stop(poll);\n}\n\nstatic int vhost_net_enable_vq(struct vhost_net *n,\n\t\t\t\tstruct vhost_virtqueue *vq)\n{\n\tstruct vhost_net_virtqueue *nvq =\n\t\tcontainer_of(vq, struct vhost_net_virtqueue, vq);\n\tstruct vhost_poll *poll = n->poll + (nvq - n->vqs);\n\tstruct socket *sock;\n\n\tsock = rcu_dereference_protected(vq->private_data,\n\t\t\t\t\t lockdep_is_held(&vq->mutex));\n\tif (!sock)\n\t\treturn 0;\n\n\treturn vhost_poll_start(poll, sock->file);\n}\n\nstatic struct socket *vhost_net_stop_vq(struct vhost_net *n,\n\t\t\t\t\tstruct vhost_virtqueue *vq)\n{\n\tstruct socket *sock;\n\n\tmutex_lock(&vq->mutex);\n\tsock = rcu_dereference_protected(vq->private_data,\n\t\t\t\t\t lockdep_is_held(&vq->mutex));\n\tvhost_net_disable_vq(n, vq);\n\trcu_assign_pointer(vq->private_data, NULL);\n\tmutex_unlock(&vq->mutex);\n\treturn sock;\n}\n\nstatic void vhost_net_stop(struct vhost_net *n, struct socket **tx_sock,\n\t\t\t   struct socket **rx_sock)\n{\n\t*tx_sock = vhost_net_stop_vq(n, &n->vqs[VHOST_NET_VQ_TX].vq);\n\t*rx_sock = vhost_net_stop_vq(n, &n->vqs[VHOST_NET_VQ_RX].vq);\n}\n\nstatic void vhost_net_flush_vq(struct vhost_net *n, int index)\n{\n\tvhost_poll_flush(n->poll + index);\n\tvhost_poll_flush(&n->vqs[index].vq.poll);\n}\n\nstatic void vhost_net_flush(struct vhost_net *n)\n{\n\tvhost_net_flush_vq(n, VHOST_NET_VQ_TX);\n\tvhost_net_flush_vq(n, VHOST_NET_VQ_RX);\n\tif (n->vqs[VHOST_NET_VQ_TX].ubufs) {\n\t\tmutex_lock(&n->vqs[VHOST_NET_VQ_TX].vq.mutex);\n\t\tn->tx_flush = true;\n\t\tmutex_unlock(&n->vqs[VHOST_NET_VQ_TX].vq.mutex);\n\t\t/* Wait for all lower device DMAs done. */\n\t\tvhost_net_ubuf_put_and_wait(n->vqs[VHOST_NET_VQ_TX].ubufs);\n\t\tmutex_lock(&n->vqs[VHOST_NET_VQ_TX].vq.mutex);\n\t\tn->tx_flush = false;\n\t\tkref_init(&n->vqs[VHOST_NET_VQ_TX].ubufs->kref);\n\t\tmutex_unlock(&n->vqs[VHOST_NET_VQ_TX].vq.mutex);\n\t}\n}\n\nstatic int vhost_net_release(struct inode *inode, struct file *f)\n{\n\tstruct vhost_net *n = f->private_data;\n\tstruct socket *tx_sock;\n\tstruct socket *rx_sock;\n\n\tvhost_net_stop(n, &tx_sock, &rx_sock);\n\tvhost_net_flush(n);\n\tvhost_dev_stop(&n->dev);\n\tvhost_dev_cleanup(&n->dev, false);\n\tvhost_net_vq_reset(n);\n\tif (tx_sock)\n\t\tfput(tx_sock->file);\n\tif (rx_sock)\n\t\tfput(rx_sock->file);\n\t/* We do an extra flush before freeing memory,\n\t * since jobs can re-queue themselves. */\n\tvhost_net_flush(n);\n\tkfree(n->dev.vqs);\n\tkfree(n);\n\treturn 0;\n}\n\nstatic struct socket *get_raw_socket(int fd)\n{\n\tstruct {\n\t\tstruct sockaddr_ll sa;\n\t\tchar  buf[MAX_ADDR_LEN];\n\t} uaddr;\n\tint uaddr_len = sizeof uaddr, r;\n\tstruct socket *sock = sockfd_lookup(fd, &r);\n\n\tif (!sock)\n\t\treturn ERR_PTR(-ENOTSOCK);\n\n\t/* Parameter checking */\n\tif (sock->sk->sk_type != SOCK_RAW) {\n\t\tr = -ESOCKTNOSUPPORT;\n\t\tgoto err;\n\t}\n\n\tr = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa,\n\t\t\t       &uaddr_len, 0);\n\tif (r)\n\t\tgoto err;\n\n\tif (uaddr.sa.sll_family != AF_PACKET) {\n\t\tr = -EPFNOSUPPORT;\n\t\tgoto err;\n\t}\n\treturn sock;\nerr:\n\tfput(sock->file);\n\treturn ERR_PTR(r);\n}\n\nstatic struct socket *get_tap_socket(int fd)\n{\n\tstruct file *file = fget(fd);\n\tstruct socket *sock;\n\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\tsock = tun_get_socket(file);\n\tif (!IS_ERR(sock))\n\t\treturn sock;\n\tsock = macvtap_get_socket(file);\n\tif (IS_ERR(sock))\n\t\tfput(file);\n\treturn sock;\n}\n\nstatic struct socket *get_socket(int fd)\n{\n\tstruct socket *sock;\n\n\t/* special case to disable backend */\n\tif (fd == -1)\n\t\treturn NULL;\n\tsock = get_raw_socket(fd);\n\tif (!IS_ERR(sock))\n\t\treturn sock;\n\tsock = get_tap_socket(fd);\n\tif (!IS_ERR(sock))\n\t\treturn sock;\n\treturn ERR_PTR(-ENOTSOCK);\n}\n\nstatic long vhost_net_set_backend(struct vhost_net *n, unsigned index, int fd)\n{\n\tstruct socket *sock, *oldsock;\n\tstruct vhost_virtqueue *vq;\n\tstruct vhost_net_virtqueue *nvq;\n\tstruct vhost_net_ubuf_ref *ubufs, *oldubufs = NULL;\n\tint r;\n\n\tmutex_lock(&n->dev.mutex);\n\tr = vhost_dev_check_owner(&n->dev);\n\tif (r)\n\t\tgoto err;\n\n\tif (index >= VHOST_NET_VQ_MAX) {\n\t\tr = -ENOBUFS;\n\t\tgoto err;\n\t}\n\tvq = &n->vqs[index].vq;\n\tnvq = &n->vqs[index];\n\tmutex_lock(&vq->mutex);\n\n\t/* Verify that ring has been setup correctly. */\n\tif (!vhost_vq_access_ok(vq)) {\n\t\tr = -EFAULT;\n\t\tgoto err_vq;\n\t}\n\tsock = get_socket(fd);\n\tif (IS_ERR(sock)) {\n\t\tr = PTR_ERR(sock);\n\t\tgoto err_vq;\n\t}\n\n\t/* start polling new socket */\n\toldsock = rcu_dereference_protected(vq->private_data,\n\t\t\t\t\t    lockdep_is_held(&vq->mutex));\n\tif (sock != oldsock) {\n\t\tubufs = vhost_net_ubuf_alloc(vq,\n\t\t\t\t\t     sock && vhost_sock_zcopy(sock));\n\t\tif (IS_ERR(ubufs)) {\n\t\t\tr = PTR_ERR(ubufs);\n\t\t\tgoto err_ubufs;\n\t\t}\n\n\t\tvhost_net_disable_vq(n, vq);\n\t\trcu_assign_pointer(vq->private_data, sock);\n\t\tr = vhost_init_used(vq);\n\t\tif (r)\n\t\t\tgoto err_used;\n\t\tr = vhost_net_enable_vq(n, vq);\n\t\tif (r)\n\t\t\tgoto err_used;\n\n\t\toldubufs = nvq->ubufs;\n\t\tnvq->ubufs = ubufs;\n\n\t\tn->tx_packets = 0;\n\t\tn->tx_zcopy_err = 0;\n\t\tn->tx_flush = false;\n\t}\n\n\tmutex_unlock(&vq->mutex);\n\n\tif (oldubufs) {\n\t\tvhost_net_ubuf_put_and_wait(oldubufs);\n\t\tmutex_lock(&vq->mutex);\n\t\tvhost_zerocopy_signal_used(n, vq);\n\t\tmutex_unlock(&vq->mutex);\n\t}\n\n\tif (oldsock) {\n\t\tvhost_net_flush_vq(n, index);\n\t\tfput(oldsock->file);\n\t}\n\n\tmutex_unlock(&n->dev.mutex);\n\treturn 0;\n\nerr_used:\n\trcu_assign_pointer(vq->private_data, oldsock);\n\tvhost_net_enable_vq(n, vq);\n\tif (ubufs)\n\t\tvhost_net_ubuf_put_and_wait(ubufs);\nerr_ubufs:\n\tfput(sock->file);\nerr_vq:\n\tmutex_unlock(&vq->mutex);\nerr:\n\tmutex_unlock(&n->dev.mutex);\n\treturn r;\n}\n\nstatic long vhost_net_reset_owner(struct vhost_net *n)\n{\n\tstruct socket *tx_sock = NULL;\n\tstruct socket *rx_sock = NULL;\n\tlong err;\n\tstruct vhost_memory *memory;\n\n\tmutex_lock(&n->dev.mutex);\n\terr = vhost_dev_check_owner(&n->dev);\n\tif (err)\n\t\tgoto done;\n\tmemory = vhost_dev_reset_owner_prepare();\n\tif (!memory) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\tvhost_net_stop(n, &tx_sock, &rx_sock);\n\tvhost_net_flush(n);\n\tvhost_dev_reset_owner(&n->dev, memory);\n\tvhost_net_vq_reset(n);\ndone:\n\tmutex_unlock(&n->dev.mutex);\n\tif (tx_sock)\n\t\tfput(tx_sock->file);\n\tif (rx_sock)\n\t\tfput(rx_sock->file);\n\treturn err;\n}\n\nstatic int vhost_net_set_features(struct vhost_net *n, u64 features)\n{\n\tsize_t vhost_hlen, sock_hlen, hdr_len;\n\tint i;\n\n\thdr_len = (features & (1 << VIRTIO_NET_F_MRG_RXBUF)) ?\n\t\t\tsizeof(struct virtio_net_hdr_mrg_rxbuf) :\n\t\t\tsizeof(struct virtio_net_hdr);\n\tif (features & (1 << VHOST_NET_F_VIRTIO_NET_HDR)) {\n\t\t/* vhost provides vnet_hdr */\n\t\tvhost_hlen = hdr_len;\n\t\tsock_hlen = 0;\n\t} else {\n\t\t/* socket provides vnet_hdr */\n\t\tvhost_hlen = 0;\n\t\tsock_hlen = hdr_len;\n\t}\n\tmutex_lock(&n->dev.mutex);\n\tif ((features & (1 << VHOST_F_LOG_ALL)) &&\n\t    !vhost_log_access_ok(&n->dev)) {\n\t\tmutex_unlock(&n->dev.mutex);\n\t\treturn -EFAULT;\n\t}\n\tn->dev.acked_features = features;\n\tsmp_wmb();\n\tfor (i = 0; i < VHOST_NET_VQ_MAX; ++i) {\n\t\tmutex_lock(&n->vqs[i].vq.mutex);\n\t\tn->vqs[i].vhost_hlen = vhost_hlen;\n\t\tn->vqs[i].sock_hlen = sock_hlen;\n\t\tmutex_unlock(&n->vqs[i].vq.mutex);\n\t}\n\tvhost_net_flush(n);\n\tmutex_unlock(&n->dev.mutex);\n\treturn 0;\n}\n\nstatic long vhost_net_set_owner(struct vhost_net *n)\n{\n\tint r;\n\n\tmutex_lock(&n->dev.mutex);\n\tif (vhost_dev_has_owner(&n->dev)) {\n\t\tr = -EBUSY;\n\t\tgoto out;\n\t}\n\tr = vhost_net_set_ubuf_info(n);\n\tif (r)\n\t\tgoto out;\n\tr = vhost_dev_set_owner(&n->dev);\n\tif (r)\n\t\tvhost_net_clear_ubuf_info(n);\n\tvhost_net_flush(n);\nout:\n\tmutex_unlock(&n->dev.mutex);\n\treturn r;\n}\n\nstatic long vhost_net_ioctl(struct file *f, unsigned int ioctl,\n\t\t\t    unsigned long arg)\n{\n\tstruct vhost_net *n = f->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tu64 __user *featurep = argp;\n\tstruct vhost_vring_file backend;\n\tu64 features;\n\tint r;\n\n\tswitch (ioctl) {\n\tcase VHOST_NET_SET_BACKEND:\n\t\tif (copy_from_user(&backend, argp, sizeof backend))\n\t\t\treturn -EFAULT;\n\t\treturn vhost_net_set_backend(n, backend.index, backend.fd);\n\tcase VHOST_GET_FEATURES:\n\t\tfeatures = VHOST_NET_FEATURES;\n\t\tif (copy_to_user(featurep, &features, sizeof features))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase VHOST_SET_FEATURES:\n\t\tif (copy_from_user(&features, featurep, sizeof features))\n\t\t\treturn -EFAULT;\n\t\tif (features & ~VHOST_NET_FEATURES)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn vhost_net_set_features(n, features);\n\tcase VHOST_RESET_OWNER:\n\t\treturn vhost_net_reset_owner(n);\n\tcase VHOST_SET_OWNER:\n\t\treturn vhost_net_set_owner(n);\n\tdefault:\n\t\tmutex_lock(&n->dev.mutex);\n\t\tr = vhost_dev_ioctl(&n->dev, ioctl, argp);\n\t\tif (r == -ENOIOCTLCMD)\n\t\t\tr = vhost_vring_ioctl(&n->dev, ioctl, argp);\n\t\telse\n\t\t\tvhost_net_flush(n);\n\t\tmutex_unlock(&n->dev.mutex);\n\t\treturn r;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstatic long vhost_net_compat_ioctl(struct file *f, unsigned int ioctl,\n\t\t\t\t   unsigned long arg)\n{\n\treturn vhost_net_ioctl(f, ioctl, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nstatic const struct file_operations vhost_net_fops = {\n\t.owner          = THIS_MODULE,\n\t.release        = vhost_net_release,\n\t.unlocked_ioctl = vhost_net_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl   = vhost_net_compat_ioctl,\n#endif\n\t.open           = vhost_net_open,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct miscdevice vhost_net_misc = {\n\t.minor = VHOST_NET_MINOR,\n\t.name = \"vhost-net\",\n\t.fops = &vhost_net_fops,\n};\n\nstatic int vhost_net_init(void)\n{\n\tif (experimental_zcopytx)\n\t\tvhost_net_enable_zcopy(VHOST_NET_VQ_TX);\n\treturn misc_register(&vhost_net_misc);\n}\nmodule_init(vhost_net_init);\n\nstatic void vhost_net_exit(void)\n{\n\tmisc_deregister(&vhost_net_misc);\n}\nmodule_exit(vhost_net_exit);\n\nMODULE_VERSION(\"0.0.1\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Michael S. Tsirkin\");\nMODULE_DESCRIPTION(\"Host kernel accelerator for virtio net\");\nMODULE_ALIAS_MISCDEV(VHOST_NET_MINOR);\nMODULE_ALIAS(\"devname:vhost-net\");\n"], "fixing_code": ["/* Copyright (C) 2009 Red Hat, Inc.\n * Author: Michael S. Tsirkin <mst@redhat.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.\n *\n * virtio-net server in host kernel.\n */\n\n#include <linux/compat.h>\n#include <linux/eventfd.h>\n#include <linux/vhost.h>\n#include <linux/virtio_net.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\n#include <linux/net.h>\n#include <linux/if_packet.h>\n#include <linux/if_arp.h>\n#include <linux/if_tun.h>\n#include <linux/if_macvlan.h>\n#include <linux/if_vlan.h>\n\n#include <net/sock.h>\n\n#include \"vhost.h\"\n\nstatic int experimental_zcopytx = 1;\nmodule_param(experimental_zcopytx, int, 0444);\nMODULE_PARM_DESC(experimental_zcopytx, \"Enable Zero Copy TX;\"\n\t\t                       \" 1 -Enable; 0 - Disable\");\n\n/* Max number of bytes transferred before requeueing the job.\n * Using this limit prevents one virtqueue from starving others. */\n#define VHOST_NET_WEIGHT 0x80000\n\n/* MAX number of TX used buffers for outstanding zerocopy */\n#define VHOST_MAX_PEND 128\n#define VHOST_GOODCOPY_LEN 256\n\n/*\n * For transmit, used buffer len is unused; we override it to track buffer\n * status internally; used for zerocopy tx only.\n */\n/* Lower device DMA failed */\n#define VHOST_DMA_FAILED_LEN\t3\n/* Lower device DMA done */\n#define VHOST_DMA_DONE_LEN\t2\n/* Lower device DMA in progress */\n#define VHOST_DMA_IN_PROGRESS\t1\n/* Buffer unused */\n#define VHOST_DMA_CLEAR_LEN\t0\n\n#define VHOST_DMA_IS_DONE(len) ((len) >= VHOST_DMA_DONE_LEN)\n\nenum {\n\tVHOST_NET_FEATURES = VHOST_FEATURES |\n\t\t\t (1ULL << VHOST_NET_F_VIRTIO_NET_HDR) |\n\t\t\t (1ULL << VIRTIO_NET_F_MRG_RXBUF),\n};\n\nenum {\n\tVHOST_NET_VQ_RX = 0,\n\tVHOST_NET_VQ_TX = 1,\n\tVHOST_NET_VQ_MAX = 2,\n};\n\nstruct vhost_net_ubuf_ref {\n\tstruct kref kref;\n\twait_queue_head_t wait;\n\tstruct vhost_virtqueue *vq;\n};\n\nstruct vhost_net_virtqueue {\n\tstruct vhost_virtqueue vq;\n\t/* hdr is used to store the virtio header.\n\t * Since each iovec has >= 1 byte length, we never need more than\n\t * header length entries to store the header. */\n\tstruct iovec hdr[sizeof(struct virtio_net_hdr_mrg_rxbuf)];\n\tsize_t vhost_hlen;\n\tsize_t sock_hlen;\n\t/* vhost zerocopy support fields below: */\n\t/* last used idx for outstanding DMA zerocopy buffers */\n\tint upend_idx;\n\t/* first used idx for DMA done zerocopy buffers */\n\tint done_idx;\n\t/* an array of userspace buffers info */\n\tstruct ubuf_info *ubuf_info;\n\t/* Reference counting for outstanding ubufs.\n\t * Protected by vq mutex. Writers must also take device mutex. */\n\tstruct vhost_net_ubuf_ref *ubufs;\n};\n\nstruct vhost_net {\n\tstruct vhost_dev dev;\n\tstruct vhost_net_virtqueue vqs[VHOST_NET_VQ_MAX];\n\tstruct vhost_poll poll[VHOST_NET_VQ_MAX];\n\t/* Number of TX recently submitted.\n\t * Protected by tx vq lock. */\n\tunsigned tx_packets;\n\t/* Number of times zerocopy TX recently failed.\n\t * Protected by tx vq lock. */\n\tunsigned tx_zcopy_err;\n\t/* Flush in progress. Protected by tx vq lock. */\n\tbool tx_flush;\n};\n\nstatic unsigned vhost_net_zcopy_mask __read_mostly;\n\nstatic void vhost_net_enable_zcopy(int vq)\n{\n\tvhost_net_zcopy_mask |= 0x1 << vq;\n}\n\nstatic void vhost_net_zerocopy_done_signal(struct kref *kref)\n{\n\tstruct vhost_net_ubuf_ref *ubufs;\n\n\tubufs = container_of(kref, struct vhost_net_ubuf_ref, kref);\n\twake_up(&ubufs->wait);\n}\n\nstatic struct vhost_net_ubuf_ref *\nvhost_net_ubuf_alloc(struct vhost_virtqueue *vq, bool zcopy)\n{\n\tstruct vhost_net_ubuf_ref *ubufs;\n\t/* No zero copy backend? Nothing to count. */\n\tif (!zcopy)\n\t\treturn NULL;\n\tubufs = kmalloc(sizeof(*ubufs), GFP_KERNEL);\n\tif (!ubufs)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkref_init(&ubufs->kref);\n\tinit_waitqueue_head(&ubufs->wait);\n\tubufs->vq = vq;\n\treturn ubufs;\n}\n\nstatic void vhost_net_ubuf_put(struct vhost_net_ubuf_ref *ubufs)\n{\n\tkref_put(&ubufs->kref, vhost_net_zerocopy_done_signal);\n}\n\nstatic void vhost_net_ubuf_put_and_wait(struct vhost_net_ubuf_ref *ubufs)\n{\n\tkref_put(&ubufs->kref, vhost_net_zerocopy_done_signal);\n\twait_event(ubufs->wait, !atomic_read(&ubufs->kref.refcount));\n}\n\nstatic void vhost_net_ubuf_put_wait_and_free(struct vhost_net_ubuf_ref *ubufs)\n{\n\tvhost_net_ubuf_put_and_wait(ubufs);\n\tkfree(ubufs);\n}\n\nstatic void vhost_net_clear_ubuf_info(struct vhost_net *n)\n{\n\tint i;\n\n\tfor (i = 0; i < VHOST_NET_VQ_MAX; ++i) {\n\t\tkfree(n->vqs[i].ubuf_info);\n\t\tn->vqs[i].ubuf_info = NULL;\n\t}\n}\n\nint vhost_net_set_ubuf_info(struct vhost_net *n)\n{\n\tbool zcopy;\n\tint i;\n\n\tfor (i = 0; i < VHOST_NET_VQ_MAX; ++i) {\n\t\tzcopy = vhost_net_zcopy_mask & (0x1 << i);\n\t\tif (!zcopy)\n\t\t\tcontinue;\n\t\tn->vqs[i].ubuf_info = kmalloc(sizeof(*n->vqs[i].ubuf_info) *\n\t\t\t\t\t      UIO_MAXIOV, GFP_KERNEL);\n\t\tif  (!n->vqs[i].ubuf_info)\n\t\t\tgoto err;\n\t}\n\treturn 0;\n\nerr:\n\tvhost_net_clear_ubuf_info(n);\n\treturn -ENOMEM;\n}\n\nvoid vhost_net_vq_reset(struct vhost_net *n)\n{\n\tint i;\n\n\tvhost_net_clear_ubuf_info(n);\n\n\tfor (i = 0; i < VHOST_NET_VQ_MAX; i++) {\n\t\tn->vqs[i].done_idx = 0;\n\t\tn->vqs[i].upend_idx = 0;\n\t\tn->vqs[i].ubufs = NULL;\n\t\tn->vqs[i].vhost_hlen = 0;\n\t\tn->vqs[i].sock_hlen = 0;\n\t}\n\n}\n\nstatic void vhost_net_tx_packet(struct vhost_net *net)\n{\n\t++net->tx_packets;\n\tif (net->tx_packets < 1024)\n\t\treturn;\n\tnet->tx_packets = 0;\n\tnet->tx_zcopy_err = 0;\n}\n\nstatic void vhost_net_tx_err(struct vhost_net *net)\n{\n\t++net->tx_zcopy_err;\n}\n\nstatic bool vhost_net_tx_select_zcopy(struct vhost_net *net)\n{\n\t/* TX flush waits for outstanding DMAs to be done.\n\t * Don't start new DMAs.\n\t */\n\treturn !net->tx_flush &&\n\t\tnet->tx_packets / 64 >= net->tx_zcopy_err;\n}\n\nstatic bool vhost_sock_zcopy(struct socket *sock)\n{\n\treturn unlikely(experimental_zcopytx) &&\n\t\tsock_flag(sock->sk, SOCK_ZEROCOPY);\n}\n\n/* Pop first len bytes from iovec. Return number of segments used. */\nstatic int move_iovec_hdr(struct iovec *from, struct iovec *to,\n\t\t\t  size_t len, int iov_count)\n{\n\tint seg = 0;\n\tsize_t size;\n\n\twhile (len && seg < iov_count) {\n\t\tsize = min(from->iov_len, len);\n\t\tto->iov_base = from->iov_base;\n\t\tto->iov_len = size;\n\t\tfrom->iov_len -= size;\n\t\tfrom->iov_base += size;\n\t\tlen -= size;\n\t\t++from;\n\t\t++to;\n\t\t++seg;\n\t}\n\treturn seg;\n}\n/* Copy iovec entries for len bytes from iovec. */\nstatic void copy_iovec_hdr(const struct iovec *from, struct iovec *to,\n\t\t\t   size_t len, int iovcount)\n{\n\tint seg = 0;\n\tsize_t size;\n\n\twhile (len && seg < iovcount) {\n\t\tsize = min(from->iov_len, len);\n\t\tto->iov_base = from->iov_base;\n\t\tto->iov_len = size;\n\t\tlen -= size;\n\t\t++from;\n\t\t++to;\n\t\t++seg;\n\t}\n}\n\n/* In case of DMA done not in order in lower device driver for some reason.\n * upend_idx is used to track end of used idx, done_idx is used to track head\n * of used idx. Once lower device DMA done contiguously, we will signal KVM\n * guest used idx.\n */\nstatic int vhost_zerocopy_signal_used(struct vhost_net *net,\n\t\t\t\t      struct vhost_virtqueue *vq)\n{\n\tstruct vhost_net_virtqueue *nvq =\n\t\tcontainer_of(vq, struct vhost_net_virtqueue, vq);\n\tint i;\n\tint j = 0;\n\n\tfor (i = nvq->done_idx; i != nvq->upend_idx; i = (i + 1) % UIO_MAXIOV) {\n\t\tif (vq->heads[i].len == VHOST_DMA_FAILED_LEN)\n\t\t\tvhost_net_tx_err(net);\n\t\tif (VHOST_DMA_IS_DONE(vq->heads[i].len)) {\n\t\t\tvq->heads[i].len = VHOST_DMA_CLEAR_LEN;\n\t\t\tvhost_add_used_and_signal(vq->dev, vq,\n\t\t\t\t\t\t  vq->heads[i].id, 0);\n\t\t\t++j;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif (j)\n\t\tnvq->done_idx = i;\n\treturn j;\n}\n\nstatic void vhost_zerocopy_callback(struct ubuf_info *ubuf, bool success)\n{\n\tstruct vhost_net_ubuf_ref *ubufs = ubuf->ctx;\n\tstruct vhost_virtqueue *vq = ubufs->vq;\n\tint cnt = atomic_read(&ubufs->kref.refcount);\n\n\t/*\n\t * Trigger polling thread if guest stopped submitting new buffers:\n\t * in this case, the refcount after decrement will eventually reach 1\n\t * so here it is 2.\n\t * We also trigger polling periodically after each 16 packets\n\t * (the value 16 here is more or less arbitrary, it's tuned to trigger\n\t * less than 10% of times).\n\t */\n\tif (cnt <= 2 || !(cnt % 16))\n\t\tvhost_poll_queue(&vq->poll);\n\t/* set len to mark this desc buffers done DMA */\n\tvq->heads[ubuf->desc].len = success ?\n\t\tVHOST_DMA_DONE_LEN : VHOST_DMA_FAILED_LEN;\n\tvhost_net_ubuf_put(ubufs);\n}\n\n/* Expects to be always run from workqueue - which acts as\n * read-size critical section for our kind of RCU. */\nstatic void handle_tx(struct vhost_net *net)\n{\n\tstruct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_TX];\n\tstruct vhost_virtqueue *vq = &nvq->vq;\n\tunsigned out, in, s;\n\tint head;\n\tstruct msghdr msg = {\n\t\t.msg_name = NULL,\n\t\t.msg_namelen = 0,\n\t\t.msg_control = NULL,\n\t\t.msg_controllen = 0,\n\t\t.msg_iov = vq->iov,\n\t\t.msg_flags = MSG_DONTWAIT,\n\t};\n\tsize_t len, total_len = 0;\n\tint err;\n\tsize_t hdr_size;\n\tstruct socket *sock;\n\tstruct vhost_net_ubuf_ref *uninitialized_var(ubufs);\n\tbool zcopy, zcopy_used;\n\n\t/* TODO: check that we are running from vhost_worker? */\n\tsock = rcu_dereference_check(vq->private_data, 1);\n\tif (!sock)\n\t\treturn;\n\n\tmutex_lock(&vq->mutex);\n\tvhost_disable_notify(&net->dev, vq);\n\n\thdr_size = nvq->vhost_hlen;\n\tzcopy = nvq->ubufs;\n\n\tfor (;;) {\n\t\t/* Release DMAs done buffers first */\n\t\tif (zcopy)\n\t\t\tvhost_zerocopy_signal_used(net, vq);\n\n\t\thead = vhost_get_vq_desc(&net->dev, vq, vq->iov,\n\t\t\t\t\t ARRAY_SIZE(vq->iov),\n\t\t\t\t\t &out, &in,\n\t\t\t\t\t NULL, NULL);\n\t\t/* On error, stop handling until the next kick. */\n\t\tif (unlikely(head < 0))\n\t\t\tbreak;\n\t\t/* Nothing new?  Wait for eventfd to tell us they refilled. */\n\t\tif (head == vq->num) {\n\t\t\tint num_pends;\n\n\t\t\t/* If more outstanding DMAs, queue the work.\n\t\t\t * Handle upend_idx wrap around\n\t\t\t */\n\t\t\tnum_pends = likely(nvq->upend_idx >= nvq->done_idx) ?\n\t\t\t\t    (nvq->upend_idx - nvq->done_idx) :\n\t\t\t\t    (nvq->upend_idx + UIO_MAXIOV -\n\t\t\t\t     nvq->done_idx);\n\t\t\tif (unlikely(num_pends > VHOST_MAX_PEND))\n\t\t\t\tbreak;\n\t\t\tif (unlikely(vhost_enable_notify(&net->dev, vq))) {\n\t\t\t\tvhost_disable_notify(&net->dev, vq);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (in) {\n\t\t\tvq_err(vq, \"Unexpected descriptor format for TX: \"\n\t\t\t       \"out %d, int %d\\n\", out, in);\n\t\t\tbreak;\n\t\t}\n\t\t/* Skip header. TODO: support TSO. */\n\t\ts = move_iovec_hdr(vq->iov, nvq->hdr, hdr_size, out);\n\t\tmsg.msg_iovlen = out;\n\t\tlen = iov_length(vq->iov, out);\n\t\t/* Sanity check */\n\t\tif (!len) {\n\t\t\tvq_err(vq, \"Unexpected header len for TX: \"\n\t\t\t       \"%zd expected %zd\\n\",\n\t\t\t       iov_length(nvq->hdr, s), hdr_size);\n\t\t\tbreak;\n\t\t}\n\t\tzcopy_used = zcopy && (len >= VHOST_GOODCOPY_LEN ||\n\t\t\t\t       nvq->upend_idx != nvq->done_idx);\n\n\t\t/* use msg_control to pass vhost zerocopy ubuf info to skb */\n\t\tif (zcopy_used) {\n\t\t\tvq->heads[nvq->upend_idx].id = head;\n\t\t\tif (!vhost_net_tx_select_zcopy(net) ||\n\t\t\t    len < VHOST_GOODCOPY_LEN) {\n\t\t\t\t/* copy don't need to wait for DMA done */\n\t\t\t\tvq->heads[nvq->upend_idx].len =\n\t\t\t\t\t\t\tVHOST_DMA_DONE_LEN;\n\t\t\t\tmsg.msg_control = NULL;\n\t\t\t\tmsg.msg_controllen = 0;\n\t\t\t\tubufs = NULL;\n\t\t\t} else {\n\t\t\t\tstruct ubuf_info *ubuf;\n\t\t\t\tubuf = nvq->ubuf_info + nvq->upend_idx;\n\n\t\t\t\tvq->heads[nvq->upend_idx].len =\n\t\t\t\t\tVHOST_DMA_IN_PROGRESS;\n\t\t\t\tubuf->callback = vhost_zerocopy_callback;\n\t\t\t\tubuf->ctx = nvq->ubufs;\n\t\t\t\tubuf->desc = nvq->upend_idx;\n\t\t\t\tmsg.msg_control = ubuf;\n\t\t\t\tmsg.msg_controllen = sizeof(ubuf);\n\t\t\t\tubufs = nvq->ubufs;\n\t\t\t\tkref_get(&ubufs->kref);\n\t\t\t}\n\t\t\tnvq->upend_idx = (nvq->upend_idx + 1) % UIO_MAXIOV;\n\t\t} else\n\t\t\tmsg.msg_control = NULL;\n\t\t/* TODO: Check specific error and bomb out unless ENOBUFS? */\n\t\terr = sock->ops->sendmsg(NULL, sock, &msg, len);\n\t\tif (unlikely(err < 0)) {\n\t\t\tif (zcopy_used) {\n\t\t\t\tif (ubufs)\n\t\t\t\t\tvhost_net_ubuf_put(ubufs);\n\t\t\t\tnvq->upend_idx = ((unsigned)nvq->upend_idx - 1)\n\t\t\t\t\t% UIO_MAXIOV;\n\t\t\t}\n\t\t\tvhost_discard_vq_desc(vq, 1);\n\t\t\tbreak;\n\t\t}\n\t\tif (err != len)\n\t\t\tpr_debug(\"Truncated TX packet: \"\n\t\t\t\t \" len %d != %zd\\n\", err, len);\n\t\tif (!zcopy_used)\n\t\t\tvhost_add_used_and_signal(&net->dev, vq, head, 0);\n\t\telse\n\t\t\tvhost_zerocopy_signal_used(net, vq);\n\t\ttotal_len += len;\n\t\tvhost_net_tx_packet(net);\n\t\tif (unlikely(total_len >= VHOST_NET_WEIGHT)) {\n\t\t\tvhost_poll_queue(&vq->poll);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&vq->mutex);\n}\n\nstatic int peek_head_len(struct sock *sk)\n{\n\tstruct sk_buff *head;\n\tint len = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sk->sk_receive_queue.lock, flags);\n\thead = skb_peek(&sk->sk_receive_queue);\n\tif (likely(head)) {\n\t\tlen = head->len;\n\t\tif (vlan_tx_tag_present(head))\n\t\t\tlen += VLAN_HLEN;\n\t}\n\n\tspin_unlock_irqrestore(&sk->sk_receive_queue.lock, flags);\n\treturn len;\n}\n\n/* This is a multi-buffer version of vhost_get_desc, that works if\n *\tvq has read descriptors only.\n * @vq\t\t- the relevant virtqueue\n * @datalen\t- data length we'll be reading\n * @iovcount\t- returned count of io vectors we fill\n * @log\t\t- vhost log\n * @log_num\t- log offset\n * @quota       - headcount quota, 1 for big buffer\n *\treturns number of buffer heads allocated, negative on error\n */\nstatic int get_rx_bufs(struct vhost_virtqueue *vq,\n\t\t       struct vring_used_elem *heads,\n\t\t       int datalen,\n\t\t       unsigned *iovcount,\n\t\t       struct vhost_log *log,\n\t\t       unsigned *log_num,\n\t\t       unsigned int quota)\n{\n\tunsigned int out, in;\n\tint seg = 0;\n\tint headcount = 0;\n\tunsigned d;\n\tint r, nlogs = 0;\n\n\twhile (datalen > 0 && headcount < quota) {\n\t\tif (unlikely(seg >= UIO_MAXIOV)) {\n\t\t\tr = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\t\td = vhost_get_vq_desc(vq->dev, vq, vq->iov + seg,\n\t\t\t\t      ARRAY_SIZE(vq->iov) - seg, &out,\n\t\t\t\t      &in, log, log_num);\n\t\tif (d == vq->num) {\n\t\t\tr = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(out || in <= 0)) {\n\t\t\tvq_err(vq, \"unexpected descriptor format for RX: \"\n\t\t\t\t\"out %d, in %d\\n\", out, in);\n\t\t\tr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(log)) {\n\t\t\tnlogs += *log_num;\n\t\t\tlog += *log_num;\n\t\t}\n\t\theads[headcount].id = d;\n\t\theads[headcount].len = iov_length(vq->iov + seg, in);\n\t\tdatalen -= heads[headcount].len;\n\t\t++headcount;\n\t\tseg += in;\n\t}\n\theads[headcount - 1].len += datalen;\n\t*iovcount = seg;\n\tif (unlikely(log))\n\t\t*log_num = nlogs;\n\treturn headcount;\nerr:\n\tvhost_discard_vq_desc(vq, headcount);\n\treturn r;\n}\n\n/* Expects to be always run from workqueue - which acts as\n * read-size critical section for our kind of RCU. */\nstatic void handle_rx(struct vhost_net *net)\n{\n\tstruct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];\n\tstruct vhost_virtqueue *vq = &nvq->vq;\n\tunsigned uninitialized_var(in), log;\n\tstruct vhost_log *vq_log;\n\tstruct msghdr msg = {\n\t\t.msg_name = NULL,\n\t\t.msg_namelen = 0,\n\t\t.msg_control = NULL, /* FIXME: get and handle RX aux data. */\n\t\t.msg_controllen = 0,\n\t\t.msg_iov = vq->iov,\n\t\t.msg_flags = MSG_DONTWAIT,\n\t};\n\tstruct virtio_net_hdr_mrg_rxbuf hdr = {\n\t\t.hdr.flags = 0,\n\t\t.hdr.gso_type = VIRTIO_NET_HDR_GSO_NONE\n\t};\n\tsize_t total_len = 0;\n\tint err, mergeable;\n\ts16 headcount;\n\tsize_t vhost_hlen, sock_hlen;\n\tsize_t vhost_len, sock_len;\n\t/* TODO: check that we are running from vhost_worker? */\n\tstruct socket *sock = rcu_dereference_check(vq->private_data, 1);\n\n\tif (!sock)\n\t\treturn;\n\n\tmutex_lock(&vq->mutex);\n\tvhost_disable_notify(&net->dev, vq);\n\tvhost_hlen = nvq->vhost_hlen;\n\tsock_hlen = nvq->sock_hlen;\n\n\tvq_log = unlikely(vhost_has_feature(&net->dev, VHOST_F_LOG_ALL)) ?\n\t\tvq->log : NULL;\n\tmergeable = vhost_has_feature(&net->dev, VIRTIO_NET_F_MRG_RXBUF);\n\n\twhile ((sock_len = peek_head_len(sock->sk))) {\n\t\tsock_len += sock_hlen;\n\t\tvhost_len = sock_len + vhost_hlen;\n\t\theadcount = get_rx_bufs(vq, vq->heads, vhost_len,\n\t\t\t\t\t&in, vq_log, &log,\n\t\t\t\t\tlikely(mergeable) ? UIO_MAXIOV : 1);\n\t\t/* On error, stop handling until the next kick. */\n\t\tif (unlikely(headcount < 0))\n\t\t\tbreak;\n\t\t/* OK, now we need to know about added descriptors. */\n\t\tif (!headcount) {\n\t\t\tif (unlikely(vhost_enable_notify(&net->dev, vq))) {\n\t\t\t\t/* They have slipped one in as we were\n\t\t\t\t * doing that: check again. */\n\t\t\t\tvhost_disable_notify(&net->dev, vq);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Nothing new?  Wait for eventfd to tell us\n\t\t\t * they refilled. */\n\t\t\tbreak;\n\t\t}\n\t\t/* We don't need to be notified again. */\n\t\tif (unlikely((vhost_hlen)))\n\t\t\t/* Skip header. TODO: support TSO. */\n\t\t\tmove_iovec_hdr(vq->iov, nvq->hdr, vhost_hlen, in);\n\t\telse\n\t\t\t/* Copy the header for use in VIRTIO_NET_F_MRG_RXBUF:\n\t\t\t * needed because recvmsg can modify msg_iov. */\n\t\t\tcopy_iovec_hdr(vq->iov, nvq->hdr, sock_hlen, in);\n\t\tmsg.msg_iovlen = in;\n\t\terr = sock->ops->recvmsg(NULL, sock, &msg,\n\t\t\t\t\t sock_len, MSG_DONTWAIT | MSG_TRUNC);\n\t\t/* Userspace might have consumed the packet meanwhile:\n\t\t * it's not supposed to do this usually, but might be hard\n\t\t * to prevent. Discard data we got (if any) and keep going. */\n\t\tif (unlikely(err != sock_len)) {\n\t\t\tpr_debug(\"Discarded rx packet: \"\n\t\t\t\t \" len %d, expected %zd\\n\", err, sock_len);\n\t\t\tvhost_discard_vq_desc(vq, headcount);\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(vhost_hlen) &&\n\t\t    memcpy_toiovecend(nvq->hdr, (unsigned char *)&hdr, 0,\n\t\t\t\t      vhost_hlen)) {\n\t\t\tvq_err(vq, \"Unable to write vnet_hdr at addr %p\\n\",\n\t\t\t       vq->iov->iov_base);\n\t\t\tbreak;\n\t\t}\n\t\t/* TODO: Should check and handle checksum. */\n\t\tif (likely(mergeable) &&\n\t\t    memcpy_toiovecend(nvq->hdr, (unsigned char *)&headcount,\n\t\t\t\t      offsetof(typeof(hdr), num_buffers),\n\t\t\t\t      sizeof hdr.num_buffers)) {\n\t\t\tvq_err(vq, \"Failed num_buffers write\");\n\t\t\tvhost_discard_vq_desc(vq, headcount);\n\t\t\tbreak;\n\t\t}\n\t\tvhost_add_used_and_signal_n(&net->dev, vq, vq->heads,\n\t\t\t\t\t    headcount);\n\t\tif (unlikely(vq_log))\n\t\t\tvhost_log_write(vq, vq_log, log, vhost_len);\n\t\ttotal_len += vhost_len;\n\t\tif (unlikely(total_len >= VHOST_NET_WEIGHT)) {\n\t\t\tvhost_poll_queue(&vq->poll);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&vq->mutex);\n}\n\nstatic void handle_tx_kick(struct vhost_work *work)\n{\n\tstruct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,\n\t\t\t\t\t\t  poll.work);\n\tstruct vhost_net *net = container_of(vq->dev, struct vhost_net, dev);\n\n\thandle_tx(net);\n}\n\nstatic void handle_rx_kick(struct vhost_work *work)\n{\n\tstruct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,\n\t\t\t\t\t\t  poll.work);\n\tstruct vhost_net *net = container_of(vq->dev, struct vhost_net, dev);\n\n\thandle_rx(net);\n}\n\nstatic void handle_tx_net(struct vhost_work *work)\n{\n\tstruct vhost_net *net = container_of(work, struct vhost_net,\n\t\t\t\t\t     poll[VHOST_NET_VQ_TX].work);\n\thandle_tx(net);\n}\n\nstatic void handle_rx_net(struct vhost_work *work)\n{\n\tstruct vhost_net *net = container_of(work, struct vhost_net,\n\t\t\t\t\t     poll[VHOST_NET_VQ_RX].work);\n\thandle_rx(net);\n}\n\nstatic int vhost_net_open(struct inode *inode, struct file *f)\n{\n\tstruct vhost_net *n = kmalloc(sizeof *n, GFP_KERNEL);\n\tstruct vhost_dev *dev;\n\tstruct vhost_virtqueue **vqs;\n\tint r, i;\n\n\tif (!n)\n\t\treturn -ENOMEM;\n\tvqs = kmalloc(VHOST_NET_VQ_MAX * sizeof(*vqs), GFP_KERNEL);\n\tif (!vqs) {\n\t\tkfree(n);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev = &n->dev;\n\tvqs[VHOST_NET_VQ_TX] = &n->vqs[VHOST_NET_VQ_TX].vq;\n\tvqs[VHOST_NET_VQ_RX] = &n->vqs[VHOST_NET_VQ_RX].vq;\n\tn->vqs[VHOST_NET_VQ_TX].vq.handle_kick = handle_tx_kick;\n\tn->vqs[VHOST_NET_VQ_RX].vq.handle_kick = handle_rx_kick;\n\tfor (i = 0; i < VHOST_NET_VQ_MAX; i++) {\n\t\tn->vqs[i].ubufs = NULL;\n\t\tn->vqs[i].ubuf_info = NULL;\n\t\tn->vqs[i].upend_idx = 0;\n\t\tn->vqs[i].done_idx = 0;\n\t\tn->vqs[i].vhost_hlen = 0;\n\t\tn->vqs[i].sock_hlen = 0;\n\t}\n\tr = vhost_dev_init(dev, vqs, VHOST_NET_VQ_MAX);\n\tif (r < 0) {\n\t\tkfree(n);\n\t\tkfree(vqs);\n\t\treturn r;\n\t}\n\n\tvhost_poll_init(n->poll + VHOST_NET_VQ_TX, handle_tx_net, POLLOUT, dev);\n\tvhost_poll_init(n->poll + VHOST_NET_VQ_RX, handle_rx_net, POLLIN, dev);\n\n\tf->private_data = n;\n\n\treturn 0;\n}\n\nstatic void vhost_net_disable_vq(struct vhost_net *n,\n\t\t\t\t struct vhost_virtqueue *vq)\n{\n\tstruct vhost_net_virtqueue *nvq =\n\t\tcontainer_of(vq, struct vhost_net_virtqueue, vq);\n\tstruct vhost_poll *poll = n->poll + (nvq - n->vqs);\n\tif (!vq->private_data)\n\t\treturn;\n\tvhost_poll_stop(poll);\n}\n\nstatic int vhost_net_enable_vq(struct vhost_net *n,\n\t\t\t\tstruct vhost_virtqueue *vq)\n{\n\tstruct vhost_net_virtqueue *nvq =\n\t\tcontainer_of(vq, struct vhost_net_virtqueue, vq);\n\tstruct vhost_poll *poll = n->poll + (nvq - n->vqs);\n\tstruct socket *sock;\n\n\tsock = rcu_dereference_protected(vq->private_data,\n\t\t\t\t\t lockdep_is_held(&vq->mutex));\n\tif (!sock)\n\t\treturn 0;\n\n\treturn vhost_poll_start(poll, sock->file);\n}\n\nstatic struct socket *vhost_net_stop_vq(struct vhost_net *n,\n\t\t\t\t\tstruct vhost_virtqueue *vq)\n{\n\tstruct socket *sock;\n\n\tmutex_lock(&vq->mutex);\n\tsock = rcu_dereference_protected(vq->private_data,\n\t\t\t\t\t lockdep_is_held(&vq->mutex));\n\tvhost_net_disable_vq(n, vq);\n\trcu_assign_pointer(vq->private_data, NULL);\n\tmutex_unlock(&vq->mutex);\n\treturn sock;\n}\n\nstatic void vhost_net_stop(struct vhost_net *n, struct socket **tx_sock,\n\t\t\t   struct socket **rx_sock)\n{\n\t*tx_sock = vhost_net_stop_vq(n, &n->vqs[VHOST_NET_VQ_TX].vq);\n\t*rx_sock = vhost_net_stop_vq(n, &n->vqs[VHOST_NET_VQ_RX].vq);\n}\n\nstatic void vhost_net_flush_vq(struct vhost_net *n, int index)\n{\n\tvhost_poll_flush(n->poll + index);\n\tvhost_poll_flush(&n->vqs[index].vq.poll);\n}\n\nstatic void vhost_net_flush(struct vhost_net *n)\n{\n\tvhost_net_flush_vq(n, VHOST_NET_VQ_TX);\n\tvhost_net_flush_vq(n, VHOST_NET_VQ_RX);\n\tif (n->vqs[VHOST_NET_VQ_TX].ubufs) {\n\t\tmutex_lock(&n->vqs[VHOST_NET_VQ_TX].vq.mutex);\n\t\tn->tx_flush = true;\n\t\tmutex_unlock(&n->vqs[VHOST_NET_VQ_TX].vq.mutex);\n\t\t/* Wait for all lower device DMAs done. */\n\t\tvhost_net_ubuf_put_and_wait(n->vqs[VHOST_NET_VQ_TX].ubufs);\n\t\tmutex_lock(&n->vqs[VHOST_NET_VQ_TX].vq.mutex);\n\t\tn->tx_flush = false;\n\t\tkref_init(&n->vqs[VHOST_NET_VQ_TX].ubufs->kref);\n\t\tmutex_unlock(&n->vqs[VHOST_NET_VQ_TX].vq.mutex);\n\t}\n}\n\nstatic int vhost_net_release(struct inode *inode, struct file *f)\n{\n\tstruct vhost_net *n = f->private_data;\n\tstruct socket *tx_sock;\n\tstruct socket *rx_sock;\n\n\tvhost_net_stop(n, &tx_sock, &rx_sock);\n\tvhost_net_flush(n);\n\tvhost_dev_stop(&n->dev);\n\tvhost_dev_cleanup(&n->dev, false);\n\tvhost_net_vq_reset(n);\n\tif (tx_sock)\n\t\tfput(tx_sock->file);\n\tif (rx_sock)\n\t\tfput(rx_sock->file);\n\t/* We do an extra flush before freeing memory,\n\t * since jobs can re-queue themselves. */\n\tvhost_net_flush(n);\n\tkfree(n->dev.vqs);\n\tkfree(n);\n\treturn 0;\n}\n\nstatic struct socket *get_raw_socket(int fd)\n{\n\tstruct {\n\t\tstruct sockaddr_ll sa;\n\t\tchar  buf[MAX_ADDR_LEN];\n\t} uaddr;\n\tint uaddr_len = sizeof uaddr, r;\n\tstruct socket *sock = sockfd_lookup(fd, &r);\n\n\tif (!sock)\n\t\treturn ERR_PTR(-ENOTSOCK);\n\n\t/* Parameter checking */\n\tif (sock->sk->sk_type != SOCK_RAW) {\n\t\tr = -ESOCKTNOSUPPORT;\n\t\tgoto err;\n\t}\n\n\tr = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa,\n\t\t\t       &uaddr_len, 0);\n\tif (r)\n\t\tgoto err;\n\n\tif (uaddr.sa.sll_family != AF_PACKET) {\n\t\tr = -EPFNOSUPPORT;\n\t\tgoto err;\n\t}\n\treturn sock;\nerr:\n\tfput(sock->file);\n\treturn ERR_PTR(r);\n}\n\nstatic struct socket *get_tap_socket(int fd)\n{\n\tstruct file *file = fget(fd);\n\tstruct socket *sock;\n\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\tsock = tun_get_socket(file);\n\tif (!IS_ERR(sock))\n\t\treturn sock;\n\tsock = macvtap_get_socket(file);\n\tif (IS_ERR(sock))\n\t\tfput(file);\n\treturn sock;\n}\n\nstatic struct socket *get_socket(int fd)\n{\n\tstruct socket *sock;\n\n\t/* special case to disable backend */\n\tif (fd == -1)\n\t\treturn NULL;\n\tsock = get_raw_socket(fd);\n\tif (!IS_ERR(sock))\n\t\treturn sock;\n\tsock = get_tap_socket(fd);\n\tif (!IS_ERR(sock))\n\t\treturn sock;\n\treturn ERR_PTR(-ENOTSOCK);\n}\n\nstatic long vhost_net_set_backend(struct vhost_net *n, unsigned index, int fd)\n{\n\tstruct socket *sock, *oldsock;\n\tstruct vhost_virtqueue *vq;\n\tstruct vhost_net_virtqueue *nvq;\n\tstruct vhost_net_ubuf_ref *ubufs, *oldubufs = NULL;\n\tint r;\n\n\tmutex_lock(&n->dev.mutex);\n\tr = vhost_dev_check_owner(&n->dev);\n\tif (r)\n\t\tgoto err;\n\n\tif (index >= VHOST_NET_VQ_MAX) {\n\t\tr = -ENOBUFS;\n\t\tgoto err;\n\t}\n\tvq = &n->vqs[index].vq;\n\tnvq = &n->vqs[index];\n\tmutex_lock(&vq->mutex);\n\n\t/* Verify that ring has been setup correctly. */\n\tif (!vhost_vq_access_ok(vq)) {\n\t\tr = -EFAULT;\n\t\tgoto err_vq;\n\t}\n\tsock = get_socket(fd);\n\tif (IS_ERR(sock)) {\n\t\tr = PTR_ERR(sock);\n\t\tgoto err_vq;\n\t}\n\n\t/* start polling new socket */\n\toldsock = rcu_dereference_protected(vq->private_data,\n\t\t\t\t\t    lockdep_is_held(&vq->mutex));\n\tif (sock != oldsock) {\n\t\tubufs = vhost_net_ubuf_alloc(vq,\n\t\t\t\t\t     sock && vhost_sock_zcopy(sock));\n\t\tif (IS_ERR(ubufs)) {\n\t\t\tr = PTR_ERR(ubufs);\n\t\t\tgoto err_ubufs;\n\t\t}\n\n\t\tvhost_net_disable_vq(n, vq);\n\t\trcu_assign_pointer(vq->private_data, sock);\n\t\tr = vhost_init_used(vq);\n\t\tif (r)\n\t\t\tgoto err_used;\n\t\tr = vhost_net_enable_vq(n, vq);\n\t\tif (r)\n\t\t\tgoto err_used;\n\n\t\toldubufs = nvq->ubufs;\n\t\tnvq->ubufs = ubufs;\n\n\t\tn->tx_packets = 0;\n\t\tn->tx_zcopy_err = 0;\n\t\tn->tx_flush = false;\n\t}\n\n\tmutex_unlock(&vq->mutex);\n\n\tif (oldubufs) {\n\t\tvhost_net_ubuf_put_wait_and_free(oldubufs);\n\t\tmutex_lock(&vq->mutex);\n\t\tvhost_zerocopy_signal_used(n, vq);\n\t\tmutex_unlock(&vq->mutex);\n\t}\n\n\tif (oldsock) {\n\t\tvhost_net_flush_vq(n, index);\n\t\tfput(oldsock->file);\n\t}\n\n\tmutex_unlock(&n->dev.mutex);\n\treturn 0;\n\nerr_used:\n\trcu_assign_pointer(vq->private_data, oldsock);\n\tvhost_net_enable_vq(n, vq);\n\tif (ubufs)\n\t\tvhost_net_ubuf_put_wait_and_free(ubufs);\nerr_ubufs:\n\tfput(sock->file);\nerr_vq:\n\tmutex_unlock(&vq->mutex);\nerr:\n\tmutex_unlock(&n->dev.mutex);\n\treturn r;\n}\n\nstatic long vhost_net_reset_owner(struct vhost_net *n)\n{\n\tstruct socket *tx_sock = NULL;\n\tstruct socket *rx_sock = NULL;\n\tlong err;\n\tstruct vhost_memory *memory;\n\n\tmutex_lock(&n->dev.mutex);\n\terr = vhost_dev_check_owner(&n->dev);\n\tif (err)\n\t\tgoto done;\n\tmemory = vhost_dev_reset_owner_prepare();\n\tif (!memory) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\tvhost_net_stop(n, &tx_sock, &rx_sock);\n\tvhost_net_flush(n);\n\tvhost_dev_reset_owner(&n->dev, memory);\n\tvhost_net_vq_reset(n);\ndone:\n\tmutex_unlock(&n->dev.mutex);\n\tif (tx_sock)\n\t\tfput(tx_sock->file);\n\tif (rx_sock)\n\t\tfput(rx_sock->file);\n\treturn err;\n}\n\nstatic int vhost_net_set_features(struct vhost_net *n, u64 features)\n{\n\tsize_t vhost_hlen, sock_hlen, hdr_len;\n\tint i;\n\n\thdr_len = (features & (1 << VIRTIO_NET_F_MRG_RXBUF)) ?\n\t\t\tsizeof(struct virtio_net_hdr_mrg_rxbuf) :\n\t\t\tsizeof(struct virtio_net_hdr);\n\tif (features & (1 << VHOST_NET_F_VIRTIO_NET_HDR)) {\n\t\t/* vhost provides vnet_hdr */\n\t\tvhost_hlen = hdr_len;\n\t\tsock_hlen = 0;\n\t} else {\n\t\t/* socket provides vnet_hdr */\n\t\tvhost_hlen = 0;\n\t\tsock_hlen = hdr_len;\n\t}\n\tmutex_lock(&n->dev.mutex);\n\tif ((features & (1 << VHOST_F_LOG_ALL)) &&\n\t    !vhost_log_access_ok(&n->dev)) {\n\t\tmutex_unlock(&n->dev.mutex);\n\t\treturn -EFAULT;\n\t}\n\tn->dev.acked_features = features;\n\tsmp_wmb();\n\tfor (i = 0; i < VHOST_NET_VQ_MAX; ++i) {\n\t\tmutex_lock(&n->vqs[i].vq.mutex);\n\t\tn->vqs[i].vhost_hlen = vhost_hlen;\n\t\tn->vqs[i].sock_hlen = sock_hlen;\n\t\tmutex_unlock(&n->vqs[i].vq.mutex);\n\t}\n\tvhost_net_flush(n);\n\tmutex_unlock(&n->dev.mutex);\n\treturn 0;\n}\n\nstatic long vhost_net_set_owner(struct vhost_net *n)\n{\n\tint r;\n\n\tmutex_lock(&n->dev.mutex);\n\tif (vhost_dev_has_owner(&n->dev)) {\n\t\tr = -EBUSY;\n\t\tgoto out;\n\t}\n\tr = vhost_net_set_ubuf_info(n);\n\tif (r)\n\t\tgoto out;\n\tr = vhost_dev_set_owner(&n->dev);\n\tif (r)\n\t\tvhost_net_clear_ubuf_info(n);\n\tvhost_net_flush(n);\nout:\n\tmutex_unlock(&n->dev.mutex);\n\treturn r;\n}\n\nstatic long vhost_net_ioctl(struct file *f, unsigned int ioctl,\n\t\t\t    unsigned long arg)\n{\n\tstruct vhost_net *n = f->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tu64 __user *featurep = argp;\n\tstruct vhost_vring_file backend;\n\tu64 features;\n\tint r;\n\n\tswitch (ioctl) {\n\tcase VHOST_NET_SET_BACKEND:\n\t\tif (copy_from_user(&backend, argp, sizeof backend))\n\t\t\treturn -EFAULT;\n\t\treturn vhost_net_set_backend(n, backend.index, backend.fd);\n\tcase VHOST_GET_FEATURES:\n\t\tfeatures = VHOST_NET_FEATURES;\n\t\tif (copy_to_user(featurep, &features, sizeof features))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase VHOST_SET_FEATURES:\n\t\tif (copy_from_user(&features, featurep, sizeof features))\n\t\t\treturn -EFAULT;\n\t\tif (features & ~VHOST_NET_FEATURES)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn vhost_net_set_features(n, features);\n\tcase VHOST_RESET_OWNER:\n\t\treturn vhost_net_reset_owner(n);\n\tcase VHOST_SET_OWNER:\n\t\treturn vhost_net_set_owner(n);\n\tdefault:\n\t\tmutex_lock(&n->dev.mutex);\n\t\tr = vhost_dev_ioctl(&n->dev, ioctl, argp);\n\t\tif (r == -ENOIOCTLCMD)\n\t\t\tr = vhost_vring_ioctl(&n->dev, ioctl, argp);\n\t\telse\n\t\t\tvhost_net_flush(n);\n\t\tmutex_unlock(&n->dev.mutex);\n\t\treturn r;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstatic long vhost_net_compat_ioctl(struct file *f, unsigned int ioctl,\n\t\t\t\t   unsigned long arg)\n{\n\treturn vhost_net_ioctl(f, ioctl, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nstatic const struct file_operations vhost_net_fops = {\n\t.owner          = THIS_MODULE,\n\t.release        = vhost_net_release,\n\t.unlocked_ioctl = vhost_net_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl   = vhost_net_compat_ioctl,\n#endif\n\t.open           = vhost_net_open,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct miscdevice vhost_net_misc = {\n\t.minor = VHOST_NET_MINOR,\n\t.name = \"vhost-net\",\n\t.fops = &vhost_net_fops,\n};\n\nstatic int vhost_net_init(void)\n{\n\tif (experimental_zcopytx)\n\t\tvhost_net_enable_zcopy(VHOST_NET_VQ_TX);\n\treturn misc_register(&vhost_net_misc);\n}\nmodule_init(vhost_net_init);\n\nstatic void vhost_net_exit(void)\n{\n\tmisc_deregister(&vhost_net_misc);\n}\nmodule_exit(vhost_net_exit);\n\nMODULE_VERSION(\"0.0.1\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Michael S. Tsirkin\");\nMODULE_DESCRIPTION(\"Host kernel accelerator for virtio net\");\nMODULE_ALIAS_MISCDEV(VHOST_NET_MINOR);\nMODULE_ALIAS(\"devname:vhost-net\");\n"], "filenames": ["drivers/vhost/net.c"], "buggy_code_start_loc": [152], "buggy_code_end_loc": [970], "fixing_code_start_loc": [153], "fixing_code_end_loc": [975], "type": "CWE-399", "message": "Use-after-free vulnerability in the vhost_net_set_backend function in drivers/vhost/net.c in the Linux kernel through 3.10.3 allows local users to cause a denial of service (OOPS and system crash) via vectors involving powering on a virtual machine.", "other": {"cve": {"id": "CVE-2013-4127", "sourceIdentifier": "secalert@redhat.com", "published": "2013-07-29T13:59:56.783", "lastModified": "2023-02-13T04:44:51.593", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use-after-free vulnerability in the vhost_net_set_backend function in drivers/vhost/net.c in the Linux kernel through 3.10.3 allows local users to cause a denial of service (OOPS and system crash) via vectors involving powering on a virtual machine."}, {"lang": "es", "value": "Vulnerabilidad de uso despu\u00e9s de liberaci\u00f3n en la funci\u00f3n vhost_net_set_backend en drivers/vhost/net.c en el kernel de Linux hasta la 3.10.3 , permite a usuarios locales provocar una denegaci\u00f3n de servicio (OOPS y ca\u00edda del sistema) a trav\u00e9s de vectores que involucran el encendido de una m\u00e1quina virtual."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.10.3", "matchCriteriaId": "975D0714-13D3-4F64-A431-F00F57505DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.9:*:*:*:*:*:*:*", "matchCriteriaId": "AAD268A0-096C-4C31-BEC5-D47F5149D462"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "32BD2427-C47F-4660-A1D9-448E500EF5B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "02048CE5-81C7-4DFB-BC40-CE4C86B7E022"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.12:*:*:*:*:*:*:*", "matchCriteriaId": "934D2B37-0575-4A75-B00B-0028316D6DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.13:*:*:*:*:*:*:*", "matchCriteriaId": "06754C21-995C-4850-A4DC-F21826C0F8C5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C623230-4497-41B9-9BD2-7A6CFDD77983"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "C72FA8A6-60A6-4486-A245-7BEF8B2A2711"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "D0D32776-8ADB-4E79-846A-C0C99FED19E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "B7D01673-D13F-487F-81B6-1279C187277E"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=dd7633ecd553a5e304d349aa6f8eb8a0417098c5", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/07/15/7", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=980643", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=984722", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/dd7633ecd553a5e304d349aa6f8eb8a0417098c5", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/dd7633ecd553a5e304d349aa6f8eb8a0417098c5"}}