{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * CAN driver for EMS Dr. Thomas Wuensche CPC-USB/ARM7\n *\n * Copyright (C) 2004-2009 EMS Dr. Thomas Wuensche\n */\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n\nMODULE_AUTHOR(\"Sebastian Haas <haas@ems-wuensche.com>\");\nMODULE_DESCRIPTION(\"CAN driver for EMS Dr. Thomas Wuensche CAN/USB interfaces\");\nMODULE_LICENSE(\"GPL v2\");\n\n/* Control-Values for CPC_Control() Command Subject Selection */\n#define CONTR_CAN_MESSAGE 0x04\n#define CONTR_CAN_STATE   0x0C\n#define CONTR_BUS_ERROR   0x1C\n\n/* Control Command Actions */\n#define CONTR_CONT_OFF 0\n#define CONTR_CONT_ON  1\n#define CONTR_ONCE     2\n\n/* Messages from CPC to PC */\n#define CPC_MSG_TYPE_CAN_FRAME       1  /* CAN data frame */\n#define CPC_MSG_TYPE_RTR_FRAME       8  /* CAN remote frame */\n#define CPC_MSG_TYPE_CAN_PARAMS      12 /* Actual CAN parameters */\n#define CPC_MSG_TYPE_CAN_STATE       14 /* CAN state message */\n#define CPC_MSG_TYPE_EXT_CAN_FRAME   16 /* Extended CAN data frame */\n#define CPC_MSG_TYPE_EXT_RTR_FRAME   17 /* Extended remote frame */\n#define CPC_MSG_TYPE_CONTROL         19 /* change interface behavior */\n#define CPC_MSG_TYPE_CONFIRM         20 /* command processed confirmation */\n#define CPC_MSG_TYPE_OVERRUN         21 /* overrun events */\n#define CPC_MSG_TYPE_CAN_FRAME_ERROR 23 /* detected bus errors */\n#define CPC_MSG_TYPE_ERR_COUNTER     25 /* RX/TX error counter */\n\n/* Messages from the PC to the CPC interface  */\n#define CPC_CMD_TYPE_CAN_FRAME     1   /* CAN data frame */\n#define CPC_CMD_TYPE_CONTROL       3   /* control of interface behavior */\n#define CPC_CMD_TYPE_CAN_PARAMS    6   /* set CAN parameters */\n#define CPC_CMD_TYPE_RTR_FRAME     13  /* CAN remote frame */\n#define CPC_CMD_TYPE_CAN_STATE     14  /* CAN state message */\n#define CPC_CMD_TYPE_EXT_CAN_FRAME 15  /* Extended CAN data frame */\n#define CPC_CMD_TYPE_EXT_RTR_FRAME 16  /* Extended CAN remote frame */\n#define CPC_CMD_TYPE_CAN_EXIT      200 /* exit the CAN */\n\n#define CPC_CMD_TYPE_INQ_ERR_COUNTER 25 /* request the CAN error counters */\n#define CPC_CMD_TYPE_CLEAR_MSG_QUEUE 8  /* clear CPC_MSG queue */\n#define CPC_CMD_TYPE_CLEAR_CMD_QUEUE 28 /* clear CPC_CMD queue */\n\n#define CPC_CC_TYPE_SJA1000 2 /* Philips basic CAN controller */\n\n#define CPC_CAN_ECODE_ERRFRAME 0x01 /* Ecode type */\n\n/* Overrun types */\n#define CPC_OVR_EVENT_CAN       0x01\n#define CPC_OVR_EVENT_CANSTATE  0x02\n#define CPC_OVR_EVENT_BUSERROR  0x04\n\n/*\n * If the CAN controller lost a message we indicate it with the highest bit\n * set in the count field.\n */\n#define CPC_OVR_HW 0x80\n\n/* Size of the \"struct ems_cpc_msg\" without the union */\n#define CPC_MSG_HEADER_LEN   11\n#define CPC_CAN_MSG_MIN_SIZE 5\n\n/* Define these values to match your devices */\n#define USB_CPCUSB_VENDOR_ID 0x12D6\n\n#define USB_CPCUSB_ARM7_PRODUCT_ID 0x0444\n\n/* Mode register NXP LPC2119/SJA1000 CAN Controller */\n#define SJA1000_MOD_NORMAL 0x00\n#define SJA1000_MOD_RM     0x01\n\n/* ECC register NXP LPC2119/SJA1000 CAN Controller */\n#define SJA1000_ECC_SEG   0x1F\n#define SJA1000_ECC_DIR   0x20\n#define SJA1000_ECC_ERR   0x06\n#define SJA1000_ECC_BIT   0x00\n#define SJA1000_ECC_FORM  0x40\n#define SJA1000_ECC_STUFF 0x80\n#define SJA1000_ECC_MASK  0xc0\n\n/* Status register content */\n#define SJA1000_SR_BS 0x80\n#define SJA1000_SR_ES 0x40\n\n#define SJA1000_DEFAULT_OUTPUT_CONTROL 0xDA\n\n/*\n * The device actually uses a 16MHz clock to generate the CAN clock\n * but it expects SJA1000 bit settings based on 8MHz (is internally\n * converted).\n */\n#define EMS_USB_ARM7_CLOCK 8000000\n\n#define CPC_TX_QUEUE_TRIGGER_LOW\t25\n#define CPC_TX_QUEUE_TRIGGER_HIGH\t35\n\n/*\n * CAN-Message representation in a CPC_MSG. Message object type is\n * CPC_MSG_TYPE_CAN_FRAME or CPC_MSG_TYPE_RTR_FRAME or\n * CPC_MSG_TYPE_EXT_CAN_FRAME or CPC_MSG_TYPE_EXT_RTR_FRAME.\n */\nstruct cpc_can_msg {\n\t__le32 id;\n\tu8 length;\n\tu8 msg[8];\n};\n\n/* Representation of the CAN parameters for the SJA1000 controller */\nstruct cpc_sja1000_params {\n\tu8 mode;\n\tu8 acc_code0;\n\tu8 acc_code1;\n\tu8 acc_code2;\n\tu8 acc_code3;\n\tu8 acc_mask0;\n\tu8 acc_mask1;\n\tu8 acc_mask2;\n\tu8 acc_mask3;\n\tu8 btr0;\n\tu8 btr1;\n\tu8 outp_contr;\n};\n\n/* CAN params message representation */\nstruct cpc_can_params {\n\tu8 cc_type;\n\n\t/* Will support M16C CAN controller in the future */\n\tunion {\n\t\tstruct cpc_sja1000_params sja1000;\n\t} cc_params;\n};\n\n/* Structure for confirmed message handling */\nstruct cpc_confirm {\n\tu8 error; /* error code */\n};\n\n/* Structure for overrun conditions */\nstruct cpc_overrun {\n\tu8 event;\n\tu8 count;\n};\n\n/* SJA1000 CAN errors (compatible to NXP LPC2119) */\nstruct cpc_sja1000_can_error {\n\tu8 ecc;\n\tu8 rxerr;\n\tu8 txerr;\n};\n\n/* structure for CAN error conditions */\nstruct cpc_can_error {\n\tu8 ecode;\n\n\tstruct {\n\t\tu8 cc_type;\n\n\t\t/* Other controllers may also provide error code capture regs */\n\t\tunion {\n\t\t\tstruct cpc_sja1000_can_error sja1000;\n\t\t} regs;\n\t} cc;\n};\n\n/*\n * Structure containing RX/TX error counter. This structure is used to request\n * the values of the CAN controllers TX and RX error counter.\n */\nstruct cpc_can_err_counter {\n\tu8 rx;\n\tu8 tx;\n};\n\n/* Main message type used between library and application */\nstruct __packed ems_cpc_msg {\n\tu8 type;\t/* type of message */\n\tu8 length;\t/* length of data within union 'msg' */\n\tu8 msgid;\t/* confirmation handle */\n\t__le32 ts_sec;\t/* timestamp in seconds */\n\t__le32 ts_nsec;\t/* timestamp in nano seconds */\n\n\tunion {\n\t\tu8 generic[64];\n\t\tstruct cpc_can_msg can_msg;\n\t\tstruct cpc_can_params can_params;\n\t\tstruct cpc_confirm confirmation;\n\t\tstruct cpc_overrun overrun;\n\t\tstruct cpc_can_error error;\n\t\tstruct cpc_can_err_counter err_counter;\n\t\tu8 can_state;\n\t} msg;\n};\n\n/*\n * Table of devices that work with this driver\n * NOTE: This driver supports only CPC-USB/ARM7 (LPC2119) yet.\n */\nstatic struct usb_device_id ems_usb_table[] = {\n\t{USB_DEVICE(USB_CPCUSB_VENDOR_ID, USB_CPCUSB_ARM7_PRODUCT_ID)},\n\t{} /* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, ems_usb_table);\n\n#define RX_BUFFER_SIZE      64\n#define CPC_HEADER_SIZE     4\n#define INTR_IN_BUFFER_SIZE 4\n\n#define MAX_RX_URBS 10\n#define MAX_TX_URBS 10\n\nstruct ems_usb;\n\nstruct ems_tx_urb_context {\n\tstruct ems_usb *dev;\n\n\tu32 echo_index;\n};\n\nstruct ems_usb {\n\tstruct can_priv can; /* must be the first member */\n\n\tstruct sk_buff *echo_skb[MAX_TX_URBS];\n\n\tstruct usb_device *udev;\n\tstruct net_device *netdev;\n\n\tatomic_t active_tx_urbs;\n\tstruct usb_anchor tx_submitted;\n\tstruct ems_tx_urb_context tx_contexts[MAX_TX_URBS];\n\n\tstruct usb_anchor rx_submitted;\n\n\tstruct urb *intr_urb;\n\n\tu8 *tx_msg_buffer;\n\n\tu8 *intr_in_buffer;\n\tunsigned int free_slots; /* remember number of available slots */\n\n\tstruct ems_cpc_msg active_params; /* active controller parameters */\n\tvoid *rxbuf[MAX_RX_URBS];\n\tdma_addr_t rxbuf_dma[MAX_RX_URBS];\n};\n\nstatic void ems_usb_read_interrupt_callback(struct urb *urb)\n{\n\tstruct ems_usb *dev = urb->context;\n\tstruct net_device *netdev = dev->netdev;\n\tint err;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tdev->free_slots = dev->intr_in_buffer[1];\n\t\tif (dev->free_slots > CPC_TX_QUEUE_TRIGGER_HIGH &&\n\t\t    netif_queue_stopped(netdev))\n\t\t\tnetif_wake_queue(netdev);\n\t\tbreak;\n\n\tcase -ECONNRESET: /* unlink */\n\tcase -ENOENT:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tnetdev_info(netdev, \"Rx interrupt aborted %d\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tif (err == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse if (err)\n\t\tnetdev_err(netdev, \"failed resubmitting intr urb: %d\\n\", err);\n}\n\nstatic void ems_usb_rx_can_msg(struct ems_usb *dev, struct ems_cpc_msg *msg)\n{\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tint i;\n\tstruct net_device_stats *stats = &dev->netdev->stats;\n\n\tskb = alloc_can_skb(dev->netdev, &cf);\n\tif (skb == NULL)\n\t\treturn;\n\n\tcf->can_id = le32_to_cpu(msg->msg.can_msg.id);\n\tcf->len = can_cc_dlc2len(msg->msg.can_msg.length & 0xF);\n\n\tif (msg->type == CPC_MSG_TYPE_EXT_CAN_FRAME ||\n\t    msg->type == CPC_MSG_TYPE_EXT_RTR_FRAME)\n\t\tcf->can_id |= CAN_EFF_FLAG;\n\n\tif (msg->type == CPC_MSG_TYPE_RTR_FRAME ||\n\t    msg->type == CPC_MSG_TYPE_EXT_RTR_FRAME) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\tcf->data[i] = msg->msg.can_msg.msg[i];\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\tnetif_rx(skb);\n}\n\nstatic void ems_usb_rx_err(struct ems_usb *dev, struct ems_cpc_msg *msg)\n{\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats = &dev->netdev->stats;\n\n\tskb = alloc_can_err_skb(dev->netdev, &cf);\n\tif (skb == NULL)\n\t\treturn;\n\n\tif (msg->type == CPC_MSG_TYPE_CAN_STATE) {\n\t\tu8 state = msg->msg.can_state;\n\n\t\tif (state & SJA1000_SR_BS) {\n\t\t\tdev->can.state = CAN_STATE_BUS_OFF;\n\t\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\n\t\t\tdev->can.can_stats.bus_off++;\n\t\t\tcan_bus_off(dev->netdev);\n\t\t} else if (state & SJA1000_SR_ES) {\n\t\t\tdev->can.state = CAN_STATE_ERROR_WARNING;\n\t\t\tdev->can.can_stats.error_warning++;\n\t\t} else {\n\t\t\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\t\tdev->can.can_stats.error_passive++;\n\t\t}\n\t} else if (msg->type == CPC_MSG_TYPE_CAN_FRAME_ERROR) {\n\t\tu8 ecc = msg->msg.error.cc.regs.sja1000.ecc;\n\t\tu8 txerr = msg->msg.error.cc.regs.sja1000.txerr;\n\t\tu8 rxerr = msg->msg.error.cc.regs.sja1000.rxerr;\n\n\t\t/* bus error interrupt */\n\t\tdev->can.can_stats.bus_error++;\n\t\tstats->rx_errors++;\n\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\t\tswitch (ecc & SJA1000_ECC_MASK) {\n\t\tcase SJA1000_ECC_BIT:\n\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n\t\t\tbreak;\n\t\tcase SJA1000_ECC_FORM:\n\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\t\tbreak;\n\t\tcase SJA1000_ECC_STUFF:\n\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcf->data[3] = ecc & SJA1000_ECC_SEG;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Error occurred during transmission? */\n\t\tif ((ecc & SJA1000_ECC_DIR) == 0)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_TX;\n\n\t\tif (dev->can.state == CAN_STATE_ERROR_WARNING ||\n\t\t    dev->can.state == CAN_STATE_ERROR_PASSIVE) {\n\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\t\tcf->data[1] = (txerr > rxerr) ?\n\t\t\t    CAN_ERR_CRTL_TX_PASSIVE : CAN_ERR_CRTL_RX_PASSIVE;\n\t\t}\n\t} else if (msg->type == CPC_MSG_TYPE_OVERRUN) {\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\t}\n\n\tnetif_rx(skb);\n}\n\n/*\n * callback for bulk IN urb\n */\nstatic void ems_usb_read_bulk_callback(struct urb *urb)\n{\n\tstruct ems_usb *dev = urb->context;\n\tstruct net_device *netdev;\n\tint retval;\n\n\tnetdev = dev->netdev;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0: /* success */\n\t\tbreak;\n\n\tcase -ENOENT:\n\t\treturn;\n\n\tdefault:\n\t\tnetdev_info(netdev, \"Rx URB aborted (%d)\\n\", urb->status);\n\t\tgoto resubmit_urb;\n\t}\n\n\tif (urb->actual_length > CPC_HEADER_SIZE) {\n\t\tstruct ems_cpc_msg *msg;\n\t\tu8 *ibuf = urb->transfer_buffer;\n\t\tu8 msg_count, start;\n\n\t\tmsg_count = ibuf[0] & ~0x80;\n\n\t\tstart = CPC_HEADER_SIZE;\n\n\t\twhile (msg_count) {\n\t\t\tmsg = (struct ems_cpc_msg *)&ibuf[start];\n\n\t\t\tswitch (msg->type) {\n\t\t\tcase CPC_MSG_TYPE_CAN_STATE:\n\t\t\t\t/* Process CAN state changes */\n\t\t\t\tems_usb_rx_err(dev, msg);\n\t\t\t\tbreak;\n\n\t\t\tcase CPC_MSG_TYPE_CAN_FRAME:\n\t\t\tcase CPC_MSG_TYPE_EXT_CAN_FRAME:\n\t\t\tcase CPC_MSG_TYPE_RTR_FRAME:\n\t\t\tcase CPC_MSG_TYPE_EXT_RTR_FRAME:\n\t\t\t\tems_usb_rx_can_msg(dev, msg);\n\t\t\t\tbreak;\n\n\t\t\tcase CPC_MSG_TYPE_CAN_FRAME_ERROR:\n\t\t\t\t/* Process errorframe */\n\t\t\t\tems_usb_rx_err(dev, msg);\n\t\t\t\tbreak;\n\n\t\t\tcase CPC_MSG_TYPE_OVERRUN:\n\t\t\t\t/* Message lost while receiving */\n\t\t\t\tems_usb_rx_err(dev, msg);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstart += CPC_MSG_HEADER_LEN + msg->length;\n\t\t\tmsg_count--;\n\n\t\t\tif (start > urb->transfer_buffer_length) {\n\t\t\t\tnetdev_err(netdev, \"format error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nresubmit_urb:\n\tusb_fill_bulk_urb(urb, dev->udev, usb_rcvbulkpipe(dev->udev, 2),\n\t\t\t  urb->transfer_buffer, RX_BUFFER_SIZE,\n\t\t\t  ems_usb_read_bulk_callback, dev);\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tif (retval == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse if (retval)\n\t\tnetdev_err(netdev,\n\t\t\t   \"failed resubmitting read bulk urb: %d\\n\", retval);\n}\n\n/*\n * callback for bulk IN urb\n */\nstatic void ems_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct ems_tx_urb_context *context = urb->context;\n\tstruct ems_usb *dev;\n\tstruct net_device *netdev;\n\n\tBUG_ON(!context);\n\n\tdev = context->dev;\n\tnetdev = dev->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tatomic_dec(&dev->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\", urb->status);\n\n\tnetif_trans_update(netdev);\n\n\t/* transmission complete interrupt */\n\tnetdev->stats.tx_packets++;\n\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, context->echo_index,\n\t\t\t\t\t\t   NULL);\n\n\t/* Release context */\n\tcontext->echo_index = MAX_TX_URBS;\n\n}\n\n/*\n * Send the given CPC command synchronously\n */\nstatic int ems_usb_command_msg(struct ems_usb *dev, struct ems_cpc_msg *msg)\n{\n\tint actual_length;\n\n\t/* Copy payload */\n\tmemcpy(&dev->tx_msg_buffer[CPC_HEADER_SIZE], msg,\n\t       msg->length + CPC_MSG_HEADER_LEN);\n\n\t/* Clear header */\n\tmemset(&dev->tx_msg_buffer[0], 0, CPC_HEADER_SIZE);\n\n\treturn usb_bulk_msg(dev->udev, usb_sndbulkpipe(dev->udev, 2),\n\t\t\t    &dev->tx_msg_buffer[0],\n\t\t\t    msg->length + CPC_MSG_HEADER_LEN + CPC_HEADER_SIZE,\n\t\t\t    &actual_length, 1000);\n}\n\n/*\n * Change CAN controllers' mode register\n */\nstatic int ems_usb_write_mode(struct ems_usb *dev, u8 mode)\n{\n\tdev->active_params.msg.can_params.cc_params.sja1000.mode = mode;\n\n\treturn ems_usb_command_msg(dev, &dev->active_params);\n}\n\n/*\n * Send a CPC_Control command to change behaviour when interface receives a CAN\n * message, bus error or CAN state changed notifications.\n */\nstatic int ems_usb_control_cmd(struct ems_usb *dev, u8 val)\n{\n\tstruct ems_cpc_msg cmd;\n\n\tcmd.type = CPC_CMD_TYPE_CONTROL;\n\tcmd.length = CPC_MSG_HEADER_LEN + 1;\n\n\tcmd.msgid = 0;\n\n\tcmd.msg.generic[0] = val;\n\n\treturn ems_usb_command_msg(dev, &cmd);\n}\n\n/*\n * Start interface\n */\nstatic int ems_usb_start(struct ems_usb *dev)\n{\n\tstruct net_device *netdev = dev->netdev;\n\tint err, i;\n\n\tdev->intr_in_buffer[0] = 0;\n\tdev->free_slots = 50; /* initial size */\n\n\tfor (i = 0; i < MAX_RX_URBS; i++) {\n\t\tstruct urb *urb = NULL;\n\t\tu8 *buf = NULL;\n\t\tdma_addr_t buf_dma;\n\n\t\t/* create a URB, and a buffer for it */\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = usb_alloc_coherent(dev->udev, RX_BUFFER_SIZE, GFP_KERNEL,\n\t\t\t\t\t &buf_dma);\n\t\tif (!buf) {\n\t\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\t\tusb_free_urb(urb);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\turb->transfer_dma = buf_dma;\n\n\t\tusb_fill_bulk_urb(urb, dev->udev, usb_rcvbulkpipe(dev->udev, 2),\n\t\t\t\t  buf, RX_BUFFER_SIZE,\n\t\t\t\t  ems_usb_read_bulk_callback, dev);\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tusb_anchor_urb(urb, &dev->rx_submitted);\n\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_coherent(dev->udev, RX_BUFFER_SIZE, buf,\n\t\t\t\t\t  urb->transfer_dma);\n\t\t\tusb_free_urb(urb);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev->rxbuf[i] = buf;\n\t\tdev->rxbuf_dma[i] = buf_dma;\n\n\t\t/* Drop reference, USB core will take care of freeing it */\n\t\tusb_free_urb(urb);\n\t}\n\n\t/* Did we submit any URBs */\n\tif (i == 0) {\n\t\tnetdev_warn(netdev, \"couldn't setup read URBs\\n\");\n\t\treturn err;\n\t}\n\n\t/* Warn if we've couldn't transmit all the URBs */\n\tif (i < MAX_RX_URBS)\n\t\tnetdev_warn(netdev, \"rx performance may be slow\\n\");\n\n\t/* Setup and start interrupt URB */\n\tusb_fill_int_urb(dev->intr_urb, dev->udev,\n\t\t\t usb_rcvintpipe(dev->udev, 1),\n\t\t\t dev->intr_in_buffer,\n\t\t\t INTR_IN_BUFFER_SIZE,\n\t\t\t ems_usb_read_interrupt_callback, dev, 1);\n\n\terr = usb_submit_urb(dev->intr_urb, GFP_KERNEL);\n\tif (err) {\n\t\tnetdev_warn(netdev, \"intr URB submit failed: %d\\n\", err);\n\n\t\treturn err;\n\t}\n\n\t/* CPC-USB will transfer received message to host */\n\terr = ems_usb_control_cmd(dev, CONTR_CAN_MESSAGE | CONTR_CONT_ON);\n\tif (err)\n\t\tgoto failed;\n\n\t/* CPC-USB will transfer CAN state changes to host */\n\terr = ems_usb_control_cmd(dev, CONTR_CAN_STATE | CONTR_CONT_ON);\n\tif (err)\n\t\tgoto failed;\n\n\t/* CPC-USB will transfer bus errors to host */\n\terr = ems_usb_control_cmd(dev, CONTR_BUS_ERROR | CONTR_CONT_ON);\n\tif (err)\n\t\tgoto failed;\n\n\terr = ems_usb_write_mode(dev, SJA1000_MOD_NORMAL);\n\tif (err)\n\t\tgoto failed;\n\n\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\treturn 0;\n\nfailed:\n\tnetdev_warn(netdev, \"couldn't submit control: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void unlink_all_urbs(struct ems_usb *dev)\n{\n\tint i;\n\n\tusb_unlink_urb(dev->intr_urb);\n\n\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\n\tfor (i = 0; i < MAX_RX_URBS; ++i)\n\t\tusb_free_coherent(dev->udev, RX_BUFFER_SIZE,\n\t\t\t\t  dev->rxbuf[i], dev->rxbuf_dma[i]);\n\n\tusb_kill_anchored_urbs(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\n\tfor (i = 0; i < MAX_TX_URBS; i++)\n\t\tdev->tx_contexts[i].echo_index = MAX_TX_URBS;\n}\n\nstatic int ems_usb_open(struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\tint err;\n\n\terr = ems_usb_write_mode(dev, SJA1000_MOD_RM);\n\tif (err)\n\t\treturn err;\n\n\t/* common open */\n\terr = open_candev(netdev);\n\tif (err)\n\t\treturn err;\n\n\t/* finally start device */\n\terr = ems_usb_start(dev);\n\tif (err) {\n\t\tif (err == -ENODEV)\n\t\t\tnetif_device_detach(dev->netdev);\n\n\t\tnetdev_warn(netdev, \"couldn't start device: %d\\n\", err);\n\n\t\tclose_candev(netdev);\n\n\t\treturn err;\n\t}\n\n\n\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\tstruct ems_tx_urb_context *context = NULL;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct ems_cpc_msg *msg;\n\tstruct urb *urb;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = CPC_HEADER_SIZE + CPC_MSG_HEADER_LEN\n\t\t\t+ sizeof(struct cpc_can_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(dev->udev, size, GFP_ATOMIC, &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tusb_free_urb(urb);\n\t\tgoto nomem;\n\t}\n\n\tmsg = (struct ems_cpc_msg *)&buf[CPC_HEADER_SIZE];\n\n\tmsg->msg.can_msg.id = cpu_to_le32(cf->can_id & CAN_ERR_MASK);\n\tmsg->msg.can_msg.length = cf->len;\n\n\tif (cf->can_id & CAN_RTR_FLAG) {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_RTR_FRAME : CPC_CMD_TYPE_RTR_FRAME;\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE;\n\t} else {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_CAN_FRAME : CPC_CMD_TYPE_CAN_FRAME;\n\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\tmsg->msg.can_msg.msg[i] = cf->data[i];\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE + cf->len;\n\t}\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (dev->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &dev->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * May never happen! When this happens we'd more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context) {\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\n\t\tnetdev_warn(netdev, \"couldn't find free context\\n\");\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tcontext->dev = dev;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 2), buf,\n\t\t\t  size, ems_usb_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &dev->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&dev->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\t\tdev_kfree_skb(skb);\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tif (err == -ENODEV) {\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\n\t\t\tstats->tx_dropped++;\n\t\t}\n\t} else {\n\t\tnetif_trans_update(netdev);\n\n\t\t/* Slow down tx path */\n\t\tif (atomic_read(&dev->active_tx_urbs) >= MAX_TX_URBS ||\n\t\t    dev->free_slots < CPC_TX_QUEUE_TRIGGER_LOW) {\n\t\t\tnetif_stop_queue(netdev);\n\t\t}\n\t}\n\n\t/*\n\t * Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ems_usb_close(struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\n\t/* Stop polling */\n\tunlink_all_urbs(dev);\n\n\tnetif_stop_queue(netdev);\n\n\t/* Set CAN controller to reset mode */\n\tif (ems_usb_write_mode(dev, SJA1000_MOD_RM))\n\t\tnetdev_warn(netdev, \"couldn't stop device\");\n\n\tclose_candev(netdev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ems_usb_netdev_ops = {\n\t.ndo_open = ems_usb_open,\n\t.ndo_stop = ems_usb_close,\n\t.ndo_start_xmit = ems_usb_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct can_bittiming_const ems_usb_bittiming_const = {\n\t.name = \"ems_usb\",\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 64,\n\t.brp_inc = 1,\n};\n\nstatic int ems_usb_set_mode(struct net_device *netdev, enum can_mode mode)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tif (ems_usb_write_mode(dev, SJA1000_MOD_NORMAL))\n\t\t\tnetdev_warn(netdev, \"couldn't start device\");\n\n\t\tif (netif_queue_stopped(netdev))\n\t\t\tnetif_wake_queue(netdev);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int ems_usb_set_bittiming(struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\tstruct can_bittiming *bt = &dev->can.bittiming;\n\tu8 btr0, btr1;\n\n\tbtr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);\n\tbtr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |\n\t\t(((bt->phase_seg2 - 1) & 0x7) << 4);\n\tif (dev->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tbtr1 |= 0x80;\n\n\tnetdev_info(netdev, \"setting BTR0=0x%02x BTR1=0x%02x\\n\", btr0, btr1);\n\n\tdev->active_params.msg.can_params.cc_params.sja1000.btr0 = btr0;\n\tdev->active_params.msg.can_params.cc_params.sja1000.btr1 = btr1;\n\n\treturn ems_usb_command_msg(dev, &dev->active_params);\n}\n\nstatic void init_params_sja1000(struct ems_cpc_msg *msg)\n{\n\tstruct cpc_sja1000_params *sja1000 =\n\t\t&msg->msg.can_params.cc_params.sja1000;\n\n\tmsg->type = CPC_CMD_TYPE_CAN_PARAMS;\n\tmsg->length = sizeof(struct cpc_can_params);\n\tmsg->msgid = 0;\n\n\tmsg->msg.can_params.cc_type = CPC_CC_TYPE_SJA1000;\n\n\t/* Acceptance filter open */\n\tsja1000->acc_code0 = 0x00;\n\tsja1000->acc_code1 = 0x00;\n\tsja1000->acc_code2 = 0x00;\n\tsja1000->acc_code3 = 0x00;\n\n\t/* Acceptance filter open */\n\tsja1000->acc_mask0 = 0xFF;\n\tsja1000->acc_mask1 = 0xFF;\n\tsja1000->acc_mask2 = 0xFF;\n\tsja1000->acc_mask3 = 0xFF;\n\n\tsja1000->btr0 = 0;\n\tsja1000->btr1 = 0;\n\n\tsja1000->outp_contr = SJA1000_DEFAULT_OUTPUT_CONTROL;\n\tsja1000->mode = SJA1000_MOD_RM;\n}\n\n/*\n * probe function for new CPC-USB devices\n */\nstatic int ems_usb_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct net_device *netdev;\n\tstruct ems_usb *dev;\n\tint i, err = -ENOMEM;\n\n\tnetdev = alloc_candev(sizeof(struct ems_usb), MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"ems_usb: Couldn't alloc candev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev = netdev_priv(netdev);\n\n\tdev->udev = interface_to_usbdev(intf);\n\tdev->netdev = netdev;\n\n\tdev->can.state = CAN_STATE_STOPPED;\n\tdev->can.clock.freq = EMS_USB_ARM7_CLOCK;\n\tdev->can.bittiming_const = &ems_usb_bittiming_const;\n\tdev->can.do_set_bittiming = ems_usb_set_bittiming;\n\tdev->can.do_set_mode = ems_usb_set_mode;\n\tdev->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;\n\n\tnetdev->netdev_ops = &ems_usb_netdev_ops;\n\n\tnetdev->flags |= IFF_ECHO; /* we support local echo */\n\n\tinit_usb_anchor(&dev->rx_submitted);\n\n\tinit_usb_anchor(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\n\tfor (i = 0; i < MAX_TX_URBS; i++)\n\t\tdev->tx_contexts[i].echo_index = MAX_TX_URBS;\n\n\tdev->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->intr_urb)\n\t\tgoto cleanup_candev;\n\n\tdev->intr_in_buffer = kzalloc(INTR_IN_BUFFER_SIZE, GFP_KERNEL);\n\tif (!dev->intr_in_buffer)\n\t\tgoto cleanup_intr_urb;\n\n\tdev->tx_msg_buffer = kzalloc(CPC_HEADER_SIZE +\n\t\t\t\t     sizeof(struct ems_cpc_msg), GFP_KERNEL);\n\tif (!dev->tx_msg_buffer)\n\t\tgoto cleanup_intr_in_buffer;\n\n\tusb_set_intfdata(intf, dev);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\tinit_params_sja1000(&dev->active_params);\n\n\terr = ems_usb_command_msg(dev, &dev->active_params);\n\tif (err) {\n\t\tnetdev_err(netdev, \"couldn't initialize controller: %d\\n\", err);\n\t\tgoto cleanup_tx_msg_buffer;\n\t}\n\n\terr = register_candev(netdev);\n\tif (err) {\n\t\tnetdev_err(netdev, \"couldn't register CAN device: %d\\n\", err);\n\t\tgoto cleanup_tx_msg_buffer;\n\t}\n\n\treturn 0;\n\ncleanup_tx_msg_buffer:\n\tkfree(dev->tx_msg_buffer);\n\ncleanup_intr_in_buffer:\n\tkfree(dev->intr_in_buffer);\n\ncleanup_intr_urb:\n\tusb_free_urb(dev->intr_urb);\n\ncleanup_candev:\n\tfree_candev(netdev);\n\n\treturn err;\n}\n\n/*\n * called by the usb core when the device is removed from the system\n */\nstatic void ems_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct ems_usb *dev = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tif (dev) {\n\t\tunregister_netdev(dev->netdev);\n\n\t\tunlink_all_urbs(dev);\n\n\t\tusb_free_urb(dev->intr_urb);\n\n\t\tkfree(dev->intr_in_buffer);\n\t\tkfree(dev->tx_msg_buffer);\n\n\t\tfree_candev(dev->netdev);\n\t}\n}\n\n/* usb specific object needed to register this driver with the usb subsystem */\nstatic struct usb_driver ems_usb_driver = {\n\t.name = \"ems_usb\",\n\t.probe = ems_usb_probe,\n\t.disconnect = ems_usb_disconnect,\n\t.id_table = ems_usb_table,\n};\n\nmodule_usb_driver(ems_usb_driver);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * CAN driver for EMS Dr. Thomas Wuensche CPC-USB/ARM7\n *\n * Copyright (C) 2004-2009 EMS Dr. Thomas Wuensche\n */\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n\nMODULE_AUTHOR(\"Sebastian Haas <haas@ems-wuensche.com>\");\nMODULE_DESCRIPTION(\"CAN driver for EMS Dr. Thomas Wuensche CAN/USB interfaces\");\nMODULE_LICENSE(\"GPL v2\");\n\n/* Control-Values for CPC_Control() Command Subject Selection */\n#define CONTR_CAN_MESSAGE 0x04\n#define CONTR_CAN_STATE   0x0C\n#define CONTR_BUS_ERROR   0x1C\n\n/* Control Command Actions */\n#define CONTR_CONT_OFF 0\n#define CONTR_CONT_ON  1\n#define CONTR_ONCE     2\n\n/* Messages from CPC to PC */\n#define CPC_MSG_TYPE_CAN_FRAME       1  /* CAN data frame */\n#define CPC_MSG_TYPE_RTR_FRAME       8  /* CAN remote frame */\n#define CPC_MSG_TYPE_CAN_PARAMS      12 /* Actual CAN parameters */\n#define CPC_MSG_TYPE_CAN_STATE       14 /* CAN state message */\n#define CPC_MSG_TYPE_EXT_CAN_FRAME   16 /* Extended CAN data frame */\n#define CPC_MSG_TYPE_EXT_RTR_FRAME   17 /* Extended remote frame */\n#define CPC_MSG_TYPE_CONTROL         19 /* change interface behavior */\n#define CPC_MSG_TYPE_CONFIRM         20 /* command processed confirmation */\n#define CPC_MSG_TYPE_OVERRUN         21 /* overrun events */\n#define CPC_MSG_TYPE_CAN_FRAME_ERROR 23 /* detected bus errors */\n#define CPC_MSG_TYPE_ERR_COUNTER     25 /* RX/TX error counter */\n\n/* Messages from the PC to the CPC interface  */\n#define CPC_CMD_TYPE_CAN_FRAME     1   /* CAN data frame */\n#define CPC_CMD_TYPE_CONTROL       3   /* control of interface behavior */\n#define CPC_CMD_TYPE_CAN_PARAMS    6   /* set CAN parameters */\n#define CPC_CMD_TYPE_RTR_FRAME     13  /* CAN remote frame */\n#define CPC_CMD_TYPE_CAN_STATE     14  /* CAN state message */\n#define CPC_CMD_TYPE_EXT_CAN_FRAME 15  /* Extended CAN data frame */\n#define CPC_CMD_TYPE_EXT_RTR_FRAME 16  /* Extended CAN remote frame */\n#define CPC_CMD_TYPE_CAN_EXIT      200 /* exit the CAN */\n\n#define CPC_CMD_TYPE_INQ_ERR_COUNTER 25 /* request the CAN error counters */\n#define CPC_CMD_TYPE_CLEAR_MSG_QUEUE 8  /* clear CPC_MSG queue */\n#define CPC_CMD_TYPE_CLEAR_CMD_QUEUE 28 /* clear CPC_CMD queue */\n\n#define CPC_CC_TYPE_SJA1000 2 /* Philips basic CAN controller */\n\n#define CPC_CAN_ECODE_ERRFRAME 0x01 /* Ecode type */\n\n/* Overrun types */\n#define CPC_OVR_EVENT_CAN       0x01\n#define CPC_OVR_EVENT_CANSTATE  0x02\n#define CPC_OVR_EVENT_BUSERROR  0x04\n\n/*\n * If the CAN controller lost a message we indicate it with the highest bit\n * set in the count field.\n */\n#define CPC_OVR_HW 0x80\n\n/* Size of the \"struct ems_cpc_msg\" without the union */\n#define CPC_MSG_HEADER_LEN   11\n#define CPC_CAN_MSG_MIN_SIZE 5\n\n/* Define these values to match your devices */\n#define USB_CPCUSB_VENDOR_ID 0x12D6\n\n#define USB_CPCUSB_ARM7_PRODUCT_ID 0x0444\n\n/* Mode register NXP LPC2119/SJA1000 CAN Controller */\n#define SJA1000_MOD_NORMAL 0x00\n#define SJA1000_MOD_RM     0x01\n\n/* ECC register NXP LPC2119/SJA1000 CAN Controller */\n#define SJA1000_ECC_SEG   0x1F\n#define SJA1000_ECC_DIR   0x20\n#define SJA1000_ECC_ERR   0x06\n#define SJA1000_ECC_BIT   0x00\n#define SJA1000_ECC_FORM  0x40\n#define SJA1000_ECC_STUFF 0x80\n#define SJA1000_ECC_MASK  0xc0\n\n/* Status register content */\n#define SJA1000_SR_BS 0x80\n#define SJA1000_SR_ES 0x40\n\n#define SJA1000_DEFAULT_OUTPUT_CONTROL 0xDA\n\n/*\n * The device actually uses a 16MHz clock to generate the CAN clock\n * but it expects SJA1000 bit settings based on 8MHz (is internally\n * converted).\n */\n#define EMS_USB_ARM7_CLOCK 8000000\n\n#define CPC_TX_QUEUE_TRIGGER_LOW\t25\n#define CPC_TX_QUEUE_TRIGGER_HIGH\t35\n\n/*\n * CAN-Message representation in a CPC_MSG. Message object type is\n * CPC_MSG_TYPE_CAN_FRAME or CPC_MSG_TYPE_RTR_FRAME or\n * CPC_MSG_TYPE_EXT_CAN_FRAME or CPC_MSG_TYPE_EXT_RTR_FRAME.\n */\nstruct cpc_can_msg {\n\t__le32 id;\n\tu8 length;\n\tu8 msg[8];\n};\n\n/* Representation of the CAN parameters for the SJA1000 controller */\nstruct cpc_sja1000_params {\n\tu8 mode;\n\tu8 acc_code0;\n\tu8 acc_code1;\n\tu8 acc_code2;\n\tu8 acc_code3;\n\tu8 acc_mask0;\n\tu8 acc_mask1;\n\tu8 acc_mask2;\n\tu8 acc_mask3;\n\tu8 btr0;\n\tu8 btr1;\n\tu8 outp_contr;\n};\n\n/* CAN params message representation */\nstruct cpc_can_params {\n\tu8 cc_type;\n\n\t/* Will support M16C CAN controller in the future */\n\tunion {\n\t\tstruct cpc_sja1000_params sja1000;\n\t} cc_params;\n};\n\n/* Structure for confirmed message handling */\nstruct cpc_confirm {\n\tu8 error; /* error code */\n};\n\n/* Structure for overrun conditions */\nstruct cpc_overrun {\n\tu8 event;\n\tu8 count;\n};\n\n/* SJA1000 CAN errors (compatible to NXP LPC2119) */\nstruct cpc_sja1000_can_error {\n\tu8 ecc;\n\tu8 rxerr;\n\tu8 txerr;\n};\n\n/* structure for CAN error conditions */\nstruct cpc_can_error {\n\tu8 ecode;\n\n\tstruct {\n\t\tu8 cc_type;\n\n\t\t/* Other controllers may also provide error code capture regs */\n\t\tunion {\n\t\t\tstruct cpc_sja1000_can_error sja1000;\n\t\t} regs;\n\t} cc;\n};\n\n/*\n * Structure containing RX/TX error counter. This structure is used to request\n * the values of the CAN controllers TX and RX error counter.\n */\nstruct cpc_can_err_counter {\n\tu8 rx;\n\tu8 tx;\n};\n\n/* Main message type used between library and application */\nstruct __packed ems_cpc_msg {\n\tu8 type;\t/* type of message */\n\tu8 length;\t/* length of data within union 'msg' */\n\tu8 msgid;\t/* confirmation handle */\n\t__le32 ts_sec;\t/* timestamp in seconds */\n\t__le32 ts_nsec;\t/* timestamp in nano seconds */\n\n\tunion {\n\t\tu8 generic[64];\n\t\tstruct cpc_can_msg can_msg;\n\t\tstruct cpc_can_params can_params;\n\t\tstruct cpc_confirm confirmation;\n\t\tstruct cpc_overrun overrun;\n\t\tstruct cpc_can_error error;\n\t\tstruct cpc_can_err_counter err_counter;\n\t\tu8 can_state;\n\t} msg;\n};\n\n/*\n * Table of devices that work with this driver\n * NOTE: This driver supports only CPC-USB/ARM7 (LPC2119) yet.\n */\nstatic struct usb_device_id ems_usb_table[] = {\n\t{USB_DEVICE(USB_CPCUSB_VENDOR_ID, USB_CPCUSB_ARM7_PRODUCT_ID)},\n\t{} /* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, ems_usb_table);\n\n#define RX_BUFFER_SIZE      64\n#define CPC_HEADER_SIZE     4\n#define INTR_IN_BUFFER_SIZE 4\n\n#define MAX_RX_URBS 10\n#define MAX_TX_URBS 10\n\nstruct ems_usb;\n\nstruct ems_tx_urb_context {\n\tstruct ems_usb *dev;\n\n\tu32 echo_index;\n};\n\nstruct ems_usb {\n\tstruct can_priv can; /* must be the first member */\n\n\tstruct sk_buff *echo_skb[MAX_TX_URBS];\n\n\tstruct usb_device *udev;\n\tstruct net_device *netdev;\n\n\tatomic_t active_tx_urbs;\n\tstruct usb_anchor tx_submitted;\n\tstruct ems_tx_urb_context tx_contexts[MAX_TX_URBS];\n\n\tstruct usb_anchor rx_submitted;\n\n\tstruct urb *intr_urb;\n\n\tu8 *tx_msg_buffer;\n\n\tu8 *intr_in_buffer;\n\tunsigned int free_slots; /* remember number of available slots */\n\n\tstruct ems_cpc_msg active_params; /* active controller parameters */\n\tvoid *rxbuf[MAX_RX_URBS];\n\tdma_addr_t rxbuf_dma[MAX_RX_URBS];\n};\n\nstatic void ems_usb_read_interrupt_callback(struct urb *urb)\n{\n\tstruct ems_usb *dev = urb->context;\n\tstruct net_device *netdev = dev->netdev;\n\tint err;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tdev->free_slots = dev->intr_in_buffer[1];\n\t\tif (dev->free_slots > CPC_TX_QUEUE_TRIGGER_HIGH &&\n\t\t    netif_queue_stopped(netdev))\n\t\t\tnetif_wake_queue(netdev);\n\t\tbreak;\n\n\tcase -ECONNRESET: /* unlink */\n\tcase -ENOENT:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tnetdev_info(netdev, \"Rx interrupt aborted %d\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tif (err == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse if (err)\n\t\tnetdev_err(netdev, \"failed resubmitting intr urb: %d\\n\", err);\n}\n\nstatic void ems_usb_rx_can_msg(struct ems_usb *dev, struct ems_cpc_msg *msg)\n{\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tint i;\n\tstruct net_device_stats *stats = &dev->netdev->stats;\n\n\tskb = alloc_can_skb(dev->netdev, &cf);\n\tif (skb == NULL)\n\t\treturn;\n\n\tcf->can_id = le32_to_cpu(msg->msg.can_msg.id);\n\tcf->len = can_cc_dlc2len(msg->msg.can_msg.length & 0xF);\n\n\tif (msg->type == CPC_MSG_TYPE_EXT_CAN_FRAME ||\n\t    msg->type == CPC_MSG_TYPE_EXT_RTR_FRAME)\n\t\tcf->can_id |= CAN_EFF_FLAG;\n\n\tif (msg->type == CPC_MSG_TYPE_RTR_FRAME ||\n\t    msg->type == CPC_MSG_TYPE_EXT_RTR_FRAME) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\tcf->data[i] = msg->msg.can_msg.msg[i];\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\tnetif_rx(skb);\n}\n\nstatic void ems_usb_rx_err(struct ems_usb *dev, struct ems_cpc_msg *msg)\n{\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats = &dev->netdev->stats;\n\n\tskb = alloc_can_err_skb(dev->netdev, &cf);\n\tif (skb == NULL)\n\t\treturn;\n\n\tif (msg->type == CPC_MSG_TYPE_CAN_STATE) {\n\t\tu8 state = msg->msg.can_state;\n\n\t\tif (state & SJA1000_SR_BS) {\n\t\t\tdev->can.state = CAN_STATE_BUS_OFF;\n\t\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\n\t\t\tdev->can.can_stats.bus_off++;\n\t\t\tcan_bus_off(dev->netdev);\n\t\t} else if (state & SJA1000_SR_ES) {\n\t\t\tdev->can.state = CAN_STATE_ERROR_WARNING;\n\t\t\tdev->can.can_stats.error_warning++;\n\t\t} else {\n\t\t\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\t\tdev->can.can_stats.error_passive++;\n\t\t}\n\t} else if (msg->type == CPC_MSG_TYPE_CAN_FRAME_ERROR) {\n\t\tu8 ecc = msg->msg.error.cc.regs.sja1000.ecc;\n\t\tu8 txerr = msg->msg.error.cc.regs.sja1000.txerr;\n\t\tu8 rxerr = msg->msg.error.cc.regs.sja1000.rxerr;\n\n\t\t/* bus error interrupt */\n\t\tdev->can.can_stats.bus_error++;\n\t\tstats->rx_errors++;\n\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\t\tswitch (ecc & SJA1000_ECC_MASK) {\n\t\tcase SJA1000_ECC_BIT:\n\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n\t\t\tbreak;\n\t\tcase SJA1000_ECC_FORM:\n\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\t\tbreak;\n\t\tcase SJA1000_ECC_STUFF:\n\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcf->data[3] = ecc & SJA1000_ECC_SEG;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Error occurred during transmission? */\n\t\tif ((ecc & SJA1000_ECC_DIR) == 0)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_TX;\n\n\t\tif (dev->can.state == CAN_STATE_ERROR_WARNING ||\n\t\t    dev->can.state == CAN_STATE_ERROR_PASSIVE) {\n\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\t\tcf->data[1] = (txerr > rxerr) ?\n\t\t\t    CAN_ERR_CRTL_TX_PASSIVE : CAN_ERR_CRTL_RX_PASSIVE;\n\t\t}\n\t} else if (msg->type == CPC_MSG_TYPE_OVERRUN) {\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\t}\n\n\tnetif_rx(skb);\n}\n\n/*\n * callback for bulk IN urb\n */\nstatic void ems_usb_read_bulk_callback(struct urb *urb)\n{\n\tstruct ems_usb *dev = urb->context;\n\tstruct net_device *netdev;\n\tint retval;\n\n\tnetdev = dev->netdev;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0: /* success */\n\t\tbreak;\n\n\tcase -ENOENT:\n\t\treturn;\n\n\tdefault:\n\t\tnetdev_info(netdev, \"Rx URB aborted (%d)\\n\", urb->status);\n\t\tgoto resubmit_urb;\n\t}\n\n\tif (urb->actual_length > CPC_HEADER_SIZE) {\n\t\tstruct ems_cpc_msg *msg;\n\t\tu8 *ibuf = urb->transfer_buffer;\n\t\tu8 msg_count, start;\n\n\t\tmsg_count = ibuf[0] & ~0x80;\n\n\t\tstart = CPC_HEADER_SIZE;\n\n\t\twhile (msg_count) {\n\t\t\tmsg = (struct ems_cpc_msg *)&ibuf[start];\n\n\t\t\tswitch (msg->type) {\n\t\t\tcase CPC_MSG_TYPE_CAN_STATE:\n\t\t\t\t/* Process CAN state changes */\n\t\t\t\tems_usb_rx_err(dev, msg);\n\t\t\t\tbreak;\n\n\t\t\tcase CPC_MSG_TYPE_CAN_FRAME:\n\t\t\tcase CPC_MSG_TYPE_EXT_CAN_FRAME:\n\t\t\tcase CPC_MSG_TYPE_RTR_FRAME:\n\t\t\tcase CPC_MSG_TYPE_EXT_RTR_FRAME:\n\t\t\t\tems_usb_rx_can_msg(dev, msg);\n\t\t\t\tbreak;\n\n\t\t\tcase CPC_MSG_TYPE_CAN_FRAME_ERROR:\n\t\t\t\t/* Process errorframe */\n\t\t\t\tems_usb_rx_err(dev, msg);\n\t\t\t\tbreak;\n\n\t\t\tcase CPC_MSG_TYPE_OVERRUN:\n\t\t\t\t/* Message lost while receiving */\n\t\t\t\tems_usb_rx_err(dev, msg);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstart += CPC_MSG_HEADER_LEN + msg->length;\n\t\t\tmsg_count--;\n\n\t\t\tif (start > urb->transfer_buffer_length) {\n\t\t\t\tnetdev_err(netdev, \"format error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nresubmit_urb:\n\tusb_fill_bulk_urb(urb, dev->udev, usb_rcvbulkpipe(dev->udev, 2),\n\t\t\t  urb->transfer_buffer, RX_BUFFER_SIZE,\n\t\t\t  ems_usb_read_bulk_callback, dev);\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tif (retval == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse if (retval)\n\t\tnetdev_err(netdev,\n\t\t\t   \"failed resubmitting read bulk urb: %d\\n\", retval);\n}\n\n/*\n * callback for bulk IN urb\n */\nstatic void ems_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct ems_tx_urb_context *context = urb->context;\n\tstruct ems_usb *dev;\n\tstruct net_device *netdev;\n\n\tBUG_ON(!context);\n\n\tdev = context->dev;\n\tnetdev = dev->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tatomic_dec(&dev->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\", urb->status);\n\n\tnetif_trans_update(netdev);\n\n\t/* transmission complete interrupt */\n\tnetdev->stats.tx_packets++;\n\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, context->echo_index,\n\t\t\t\t\t\t   NULL);\n\n\t/* Release context */\n\tcontext->echo_index = MAX_TX_URBS;\n\n}\n\n/*\n * Send the given CPC command synchronously\n */\nstatic int ems_usb_command_msg(struct ems_usb *dev, struct ems_cpc_msg *msg)\n{\n\tint actual_length;\n\n\t/* Copy payload */\n\tmemcpy(&dev->tx_msg_buffer[CPC_HEADER_SIZE], msg,\n\t       msg->length + CPC_MSG_HEADER_LEN);\n\n\t/* Clear header */\n\tmemset(&dev->tx_msg_buffer[0], 0, CPC_HEADER_SIZE);\n\n\treturn usb_bulk_msg(dev->udev, usb_sndbulkpipe(dev->udev, 2),\n\t\t\t    &dev->tx_msg_buffer[0],\n\t\t\t    msg->length + CPC_MSG_HEADER_LEN + CPC_HEADER_SIZE,\n\t\t\t    &actual_length, 1000);\n}\n\n/*\n * Change CAN controllers' mode register\n */\nstatic int ems_usb_write_mode(struct ems_usb *dev, u8 mode)\n{\n\tdev->active_params.msg.can_params.cc_params.sja1000.mode = mode;\n\n\treturn ems_usb_command_msg(dev, &dev->active_params);\n}\n\n/*\n * Send a CPC_Control command to change behaviour when interface receives a CAN\n * message, bus error or CAN state changed notifications.\n */\nstatic int ems_usb_control_cmd(struct ems_usb *dev, u8 val)\n{\n\tstruct ems_cpc_msg cmd;\n\n\tcmd.type = CPC_CMD_TYPE_CONTROL;\n\tcmd.length = CPC_MSG_HEADER_LEN + 1;\n\n\tcmd.msgid = 0;\n\n\tcmd.msg.generic[0] = val;\n\n\treturn ems_usb_command_msg(dev, &cmd);\n}\n\n/*\n * Start interface\n */\nstatic int ems_usb_start(struct ems_usb *dev)\n{\n\tstruct net_device *netdev = dev->netdev;\n\tint err, i;\n\n\tdev->intr_in_buffer[0] = 0;\n\tdev->free_slots = 50; /* initial size */\n\n\tfor (i = 0; i < MAX_RX_URBS; i++) {\n\t\tstruct urb *urb = NULL;\n\t\tu8 *buf = NULL;\n\t\tdma_addr_t buf_dma;\n\n\t\t/* create a URB, and a buffer for it */\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = usb_alloc_coherent(dev->udev, RX_BUFFER_SIZE, GFP_KERNEL,\n\t\t\t\t\t &buf_dma);\n\t\tif (!buf) {\n\t\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\t\tusb_free_urb(urb);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\turb->transfer_dma = buf_dma;\n\n\t\tusb_fill_bulk_urb(urb, dev->udev, usb_rcvbulkpipe(dev->udev, 2),\n\t\t\t\t  buf, RX_BUFFER_SIZE,\n\t\t\t\t  ems_usb_read_bulk_callback, dev);\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tusb_anchor_urb(urb, &dev->rx_submitted);\n\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_coherent(dev->udev, RX_BUFFER_SIZE, buf,\n\t\t\t\t\t  urb->transfer_dma);\n\t\t\tusb_free_urb(urb);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev->rxbuf[i] = buf;\n\t\tdev->rxbuf_dma[i] = buf_dma;\n\n\t\t/* Drop reference, USB core will take care of freeing it */\n\t\tusb_free_urb(urb);\n\t}\n\n\t/* Did we submit any URBs */\n\tif (i == 0) {\n\t\tnetdev_warn(netdev, \"couldn't setup read URBs\\n\");\n\t\treturn err;\n\t}\n\n\t/* Warn if we've couldn't transmit all the URBs */\n\tif (i < MAX_RX_URBS)\n\t\tnetdev_warn(netdev, \"rx performance may be slow\\n\");\n\n\t/* Setup and start interrupt URB */\n\tusb_fill_int_urb(dev->intr_urb, dev->udev,\n\t\t\t usb_rcvintpipe(dev->udev, 1),\n\t\t\t dev->intr_in_buffer,\n\t\t\t INTR_IN_BUFFER_SIZE,\n\t\t\t ems_usb_read_interrupt_callback, dev, 1);\n\n\terr = usb_submit_urb(dev->intr_urb, GFP_KERNEL);\n\tif (err) {\n\t\tnetdev_warn(netdev, \"intr URB submit failed: %d\\n\", err);\n\n\t\treturn err;\n\t}\n\n\t/* CPC-USB will transfer received message to host */\n\terr = ems_usb_control_cmd(dev, CONTR_CAN_MESSAGE | CONTR_CONT_ON);\n\tif (err)\n\t\tgoto failed;\n\n\t/* CPC-USB will transfer CAN state changes to host */\n\terr = ems_usb_control_cmd(dev, CONTR_CAN_STATE | CONTR_CONT_ON);\n\tif (err)\n\t\tgoto failed;\n\n\t/* CPC-USB will transfer bus errors to host */\n\terr = ems_usb_control_cmd(dev, CONTR_BUS_ERROR | CONTR_CONT_ON);\n\tif (err)\n\t\tgoto failed;\n\n\terr = ems_usb_write_mode(dev, SJA1000_MOD_NORMAL);\n\tif (err)\n\t\tgoto failed;\n\n\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\treturn 0;\n\nfailed:\n\tnetdev_warn(netdev, \"couldn't submit control: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void unlink_all_urbs(struct ems_usb *dev)\n{\n\tint i;\n\n\tusb_unlink_urb(dev->intr_urb);\n\n\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\n\tfor (i = 0; i < MAX_RX_URBS; ++i)\n\t\tusb_free_coherent(dev->udev, RX_BUFFER_SIZE,\n\t\t\t\t  dev->rxbuf[i], dev->rxbuf_dma[i]);\n\n\tusb_kill_anchored_urbs(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\n\tfor (i = 0; i < MAX_TX_URBS; i++)\n\t\tdev->tx_contexts[i].echo_index = MAX_TX_URBS;\n}\n\nstatic int ems_usb_open(struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\tint err;\n\n\terr = ems_usb_write_mode(dev, SJA1000_MOD_RM);\n\tif (err)\n\t\treturn err;\n\n\t/* common open */\n\terr = open_candev(netdev);\n\tif (err)\n\t\treturn err;\n\n\t/* finally start device */\n\terr = ems_usb_start(dev);\n\tif (err) {\n\t\tif (err == -ENODEV)\n\t\t\tnetif_device_detach(dev->netdev);\n\n\t\tnetdev_warn(netdev, \"couldn't start device: %d\\n\", err);\n\n\t\tclose_candev(netdev);\n\n\t\treturn err;\n\t}\n\n\n\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\tstruct ems_tx_urb_context *context = NULL;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct ems_cpc_msg *msg;\n\tstruct urb *urb;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = CPC_HEADER_SIZE + CPC_MSG_HEADER_LEN\n\t\t\t+ sizeof(struct cpc_can_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(dev->udev, size, GFP_ATOMIC, &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tusb_free_urb(urb);\n\t\tgoto nomem;\n\t}\n\n\tmsg = (struct ems_cpc_msg *)&buf[CPC_HEADER_SIZE];\n\n\tmsg->msg.can_msg.id = cpu_to_le32(cf->can_id & CAN_ERR_MASK);\n\tmsg->msg.can_msg.length = cf->len;\n\n\tif (cf->can_id & CAN_RTR_FLAG) {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_RTR_FRAME : CPC_CMD_TYPE_RTR_FRAME;\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE;\n\t} else {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_CAN_FRAME : CPC_CMD_TYPE_CAN_FRAME;\n\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\tmsg->msg.can_msg.msg[i] = cf->data[i];\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE + cf->len;\n\t}\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (dev->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &dev->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * May never happen! When this happens we'd more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context) {\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\n\t\tnetdev_warn(netdev, \"couldn't find free context\\n\");\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tcontext->dev = dev;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 2), buf,\n\t\t\t  size, ems_usb_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &dev->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&dev->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tif (err == -ENODEV) {\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\n\t\t\tstats->tx_dropped++;\n\t\t}\n\t} else {\n\t\tnetif_trans_update(netdev);\n\n\t\t/* Slow down tx path */\n\t\tif (atomic_read(&dev->active_tx_urbs) >= MAX_TX_URBS ||\n\t\t    dev->free_slots < CPC_TX_QUEUE_TRIGGER_LOW) {\n\t\t\tnetif_stop_queue(netdev);\n\t\t}\n\t}\n\n\t/*\n\t * Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ems_usb_close(struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\n\t/* Stop polling */\n\tunlink_all_urbs(dev);\n\n\tnetif_stop_queue(netdev);\n\n\t/* Set CAN controller to reset mode */\n\tif (ems_usb_write_mode(dev, SJA1000_MOD_RM))\n\t\tnetdev_warn(netdev, \"couldn't stop device\");\n\n\tclose_candev(netdev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ems_usb_netdev_ops = {\n\t.ndo_open = ems_usb_open,\n\t.ndo_stop = ems_usb_close,\n\t.ndo_start_xmit = ems_usb_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct can_bittiming_const ems_usb_bittiming_const = {\n\t.name = \"ems_usb\",\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 64,\n\t.brp_inc = 1,\n};\n\nstatic int ems_usb_set_mode(struct net_device *netdev, enum can_mode mode)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tif (ems_usb_write_mode(dev, SJA1000_MOD_NORMAL))\n\t\t\tnetdev_warn(netdev, \"couldn't start device\");\n\n\t\tif (netif_queue_stopped(netdev))\n\t\t\tnetif_wake_queue(netdev);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int ems_usb_set_bittiming(struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\tstruct can_bittiming *bt = &dev->can.bittiming;\n\tu8 btr0, btr1;\n\n\tbtr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);\n\tbtr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |\n\t\t(((bt->phase_seg2 - 1) & 0x7) << 4);\n\tif (dev->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tbtr1 |= 0x80;\n\n\tnetdev_info(netdev, \"setting BTR0=0x%02x BTR1=0x%02x\\n\", btr0, btr1);\n\n\tdev->active_params.msg.can_params.cc_params.sja1000.btr0 = btr0;\n\tdev->active_params.msg.can_params.cc_params.sja1000.btr1 = btr1;\n\n\treturn ems_usb_command_msg(dev, &dev->active_params);\n}\n\nstatic void init_params_sja1000(struct ems_cpc_msg *msg)\n{\n\tstruct cpc_sja1000_params *sja1000 =\n\t\t&msg->msg.can_params.cc_params.sja1000;\n\n\tmsg->type = CPC_CMD_TYPE_CAN_PARAMS;\n\tmsg->length = sizeof(struct cpc_can_params);\n\tmsg->msgid = 0;\n\n\tmsg->msg.can_params.cc_type = CPC_CC_TYPE_SJA1000;\n\n\t/* Acceptance filter open */\n\tsja1000->acc_code0 = 0x00;\n\tsja1000->acc_code1 = 0x00;\n\tsja1000->acc_code2 = 0x00;\n\tsja1000->acc_code3 = 0x00;\n\n\t/* Acceptance filter open */\n\tsja1000->acc_mask0 = 0xFF;\n\tsja1000->acc_mask1 = 0xFF;\n\tsja1000->acc_mask2 = 0xFF;\n\tsja1000->acc_mask3 = 0xFF;\n\n\tsja1000->btr0 = 0;\n\tsja1000->btr1 = 0;\n\n\tsja1000->outp_contr = SJA1000_DEFAULT_OUTPUT_CONTROL;\n\tsja1000->mode = SJA1000_MOD_RM;\n}\n\n/*\n * probe function for new CPC-USB devices\n */\nstatic int ems_usb_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct net_device *netdev;\n\tstruct ems_usb *dev;\n\tint i, err = -ENOMEM;\n\n\tnetdev = alloc_candev(sizeof(struct ems_usb), MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"ems_usb: Couldn't alloc candev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev = netdev_priv(netdev);\n\n\tdev->udev = interface_to_usbdev(intf);\n\tdev->netdev = netdev;\n\n\tdev->can.state = CAN_STATE_STOPPED;\n\tdev->can.clock.freq = EMS_USB_ARM7_CLOCK;\n\tdev->can.bittiming_const = &ems_usb_bittiming_const;\n\tdev->can.do_set_bittiming = ems_usb_set_bittiming;\n\tdev->can.do_set_mode = ems_usb_set_mode;\n\tdev->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;\n\n\tnetdev->netdev_ops = &ems_usb_netdev_ops;\n\n\tnetdev->flags |= IFF_ECHO; /* we support local echo */\n\n\tinit_usb_anchor(&dev->rx_submitted);\n\n\tinit_usb_anchor(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\n\tfor (i = 0; i < MAX_TX_URBS; i++)\n\t\tdev->tx_contexts[i].echo_index = MAX_TX_URBS;\n\n\tdev->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->intr_urb)\n\t\tgoto cleanup_candev;\n\n\tdev->intr_in_buffer = kzalloc(INTR_IN_BUFFER_SIZE, GFP_KERNEL);\n\tif (!dev->intr_in_buffer)\n\t\tgoto cleanup_intr_urb;\n\n\tdev->tx_msg_buffer = kzalloc(CPC_HEADER_SIZE +\n\t\t\t\t     sizeof(struct ems_cpc_msg), GFP_KERNEL);\n\tif (!dev->tx_msg_buffer)\n\t\tgoto cleanup_intr_in_buffer;\n\n\tusb_set_intfdata(intf, dev);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\tinit_params_sja1000(&dev->active_params);\n\n\terr = ems_usb_command_msg(dev, &dev->active_params);\n\tif (err) {\n\t\tnetdev_err(netdev, \"couldn't initialize controller: %d\\n\", err);\n\t\tgoto cleanup_tx_msg_buffer;\n\t}\n\n\terr = register_candev(netdev);\n\tif (err) {\n\t\tnetdev_err(netdev, \"couldn't register CAN device: %d\\n\", err);\n\t\tgoto cleanup_tx_msg_buffer;\n\t}\n\n\treturn 0;\n\ncleanup_tx_msg_buffer:\n\tkfree(dev->tx_msg_buffer);\n\ncleanup_intr_in_buffer:\n\tkfree(dev->intr_in_buffer);\n\ncleanup_intr_urb:\n\tusb_free_urb(dev->intr_urb);\n\ncleanup_candev:\n\tfree_candev(netdev);\n\n\treturn err;\n}\n\n/*\n * called by the usb core when the device is removed from the system\n */\nstatic void ems_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct ems_usb *dev = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tif (dev) {\n\t\tunregister_netdev(dev->netdev);\n\n\t\tunlink_all_urbs(dev);\n\n\t\tusb_free_urb(dev->intr_urb);\n\n\t\tkfree(dev->intr_in_buffer);\n\t\tkfree(dev->tx_msg_buffer);\n\n\t\tfree_candev(dev->netdev);\n\t}\n}\n\n/* usb specific object needed to register this driver with the usb subsystem */\nstatic struct usb_driver ems_usb_driver = {\n\t.name = \"ems_usb\",\n\t.probe = ems_usb_probe,\n\t.disconnect = ems_usb_disconnect,\n\t.id_table = ems_usb_table,\n};\n\nmodule_usb_driver(ems_usb_driver);\n"], "filenames": ["drivers/net/can/usb/ems_usb.c"], "buggy_code_start_loc": [822], "buggy_code_end_loc": [823], "fixing_code_start_loc": [821], "fixing_code_end_loc": [821], "type": "CWE-415", "message": "ems_usb_start_xmit in drivers/net/can/usb/ems_usb.c in the Linux kernel through 5.17.1 has a double free.", "other": {"cve": {"id": "CVE-2022-28390", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-03T21:15:08.163", "lastModified": "2023-02-01T15:11:03.270", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ems_usb_start_xmit in drivers/net/can/usb/ems_usb.c in the Linux kernel through 5.17.1 has a double free."}, {"lang": "es", "value": "La funci\u00f3n ems_usb_start_xmit en el archivo drivers/net/can/usb/ems_usb.c en el kernel de Linux versiones hasta 5.17.1, presenta una doble liberaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.17.1", "matchCriteriaId": "63CEA1F5-F935-4664-88B3-3433F56FFB8B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_baseboard_management_controller:h300e:*:*:*:*:*:*:*", "matchCriteriaId": "50E61C0A-01CA-4031-B4E0-D814E1D9CFCC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_baseboard_management_controller:h300s:*:*:*:*:*:*:*", "matchCriteriaId": "27227B35-932A-4035-B39F-6A455753C0D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_baseboard_management_controller:h410c:*:*:*:*:*:*:*", "matchCriteriaId": "489D20B9-166F-423D-8C48-A23D3026E33B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_baseboard_management_controller:h410s:*:*:*:*:*:*:*", "matchCriteriaId": "A4AD592C-222D-4C6F-B176-8145A1A5AFEC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_baseboard_management_controller:h500e:*:*:*:*:*:*:*", "matchCriteriaId": "8173DC0C-B9BB-4055-95B6-45EB08A3D923"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_baseboard_management_controller:h500s:*:*:*:*:*:*:*", "matchCriteriaId": "8603654B-A8A9-4DEB-B0DD-C82E1C885749"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_baseboard_management_controller:h700e:*:*:*:*:*:*:*", "matchCriteriaId": "14BCD5F2-E3FD-4877-8C93-5EF96008A287"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_baseboard_management_controller:h700s:*:*:*:*:*:*:*", "matchCriteriaId": "C855C933-F271-45E6-8E85-8D7CF2EF1BE6"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/c70222752228a62135cee3409dccefd494a24646", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6IHHC455LMSJNG4CSZ5CEAHYWY2DE5YW/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LAWC35TO642FOP3UCA3C6IF7NAUFOVZ6/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XFMPUI3WI4U2F7ONHRW36WDY4ZE7LGGT/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220513-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5127", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5173", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c70222752228a62135cee3409dccefd494a24646"}}