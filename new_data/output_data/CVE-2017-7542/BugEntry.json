{"buggy_code": ["/*\n * IPv6 library code, needed by static components when full IPv6 support is\n * not configured or static.  These functions are needed by GSO/GRO implementation.\n */\n#include <linux/export.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/ip6_fib.h>\n#include <net/addrconf.h>\n#include <net/secure_seq.h>\n#include <linux/netfilter.h>\n\nstatic u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 hash, id;\n\n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n\n\t/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n\t * set the hight order instead thus minimizing possible future\n\t * collisions.\n\t */\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}\n\n/* This function exists only for tap drivers that must support broken\n * clients requesting UFO without specifying an IPv6 fragment ID.\n *\n * This is similar to ipv6_select_ident() but we use an independent hash\n * seed to limit information leakage.\n *\n * The network header must be set before calling this.\n */\nvoid ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn;\n\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\tskb_shinfo(skb)->ip6_frag_id = htonl(id);\n}\nEXPORT_SYMBOL_GPL(ipv6_proxy_select_ident);\n\n__be32 ipv6_select_ident(struct net *net,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr)\n{\n\tstatic u32 ip6_idents_hashrnd __read_mostly;\n\tu32 id;\n\n\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n\n\tid = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);\n\treturn htonl(id);\n}\nEXPORT_SYMBOL(ipv6_select_ident);\n\nint ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tu16 offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\toffset += ipv6_optlen(exthdr);\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(ip6_find_1stfragopt);\n\n#if IS_ENABLED(CONFIG_IPV6)\nint ip6_dst_hoplimit(struct dst_entry *dst)\n{\n\tint hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);\n\tif (hoplimit == 0) {\n\t\tstruct net_device *dev = dst->dev;\n\t\tstruct inet6_dev *idev;\n\n\t\trcu_read_lock();\n\t\tidev = __in6_dev_get(dev);\n\t\tif (idev)\n\t\t\thoplimit = idev->cnf.hop_limit;\n\t\telse\n\t\t\thoplimit = dev_net(dev)->ipv6.devconf_all->hop_limit;\n\t\trcu_read_unlock();\n\t}\n\treturn hoplimit;\n}\nEXPORT_SYMBOL(ip6_dst_hoplimit);\n#endif\n\nint __ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tint len;\n\n\tlen = skb->len - sizeof(struct ipv6hdr);\n\tif (len > IPV6_MAXPLEN)\n\t\tlen = 0;\n\tipv6_hdr(skb)->payload_len = htons(len);\n\tIP6CB(skb)->nhoff = offsetof(struct ipv6hdr, nexthdr);\n\n\t/* if egress device is enslaved to an L3 master device pass the\n\t * skb to its handler for processing\n\t */\n\tskb = l3mdev_ip6_out(sk, skb);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\treturn nf_hook(NFPROTO_IPV6, NF_INET_LOCAL_OUT,\n\t\t       net, sk, skb, NULL, skb_dst(skb)->dev,\n\t\t       dst_output);\n}\nEXPORT_SYMBOL_GPL(__ip6_local_out);\n\nint ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tint err;\n\n\terr = __ip6_local_out(net, sk, skb);\n\tif (likely(err == 1))\n\t\terr = dst_output(net, sk, skb);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ip6_local_out);\n"], "fixing_code": ["/*\n * IPv6 library code, needed by static components when full IPv6 support is\n * not configured or static.  These functions are needed by GSO/GRO implementation.\n */\n#include <linux/export.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/ip6_fib.h>\n#include <net/addrconf.h>\n#include <net/secure_seq.h>\n#include <linux/netfilter.h>\n\nstatic u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 hash, id;\n\n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n\n\t/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n\t * set the hight order instead thus minimizing possible future\n\t * collisions.\n\t */\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}\n\n/* This function exists only for tap drivers that must support broken\n * clients requesting UFO without specifying an IPv6 fragment ID.\n *\n * This is similar to ipv6_select_ident() but we use an independent hash\n * seed to limit information leakage.\n *\n * The network header must be set before calling this.\n */\nvoid ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn;\n\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\tskb_shinfo(skb)->ip6_frag_id = htonl(id);\n}\nEXPORT_SYMBOL_GPL(ipv6_proxy_select_ident);\n\n__be32 ipv6_select_ident(struct net *net,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr)\n{\n\tstatic u32 ip6_idents_hashrnd __read_mostly;\n\tu32 id;\n\n\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n\n\tid = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);\n\treturn htonl(id);\n}\nEXPORT_SYMBOL(ipv6_select_ident);\n\nint ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tunsigned int offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\t\tunsigned int len;\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\tlen = ipv6_optlen(exthdr);\n\t\tif (len + offset >= IPV6_MAXPLEN)\n\t\t\treturn -EINVAL;\n\t\toffset += len;\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(ip6_find_1stfragopt);\n\n#if IS_ENABLED(CONFIG_IPV6)\nint ip6_dst_hoplimit(struct dst_entry *dst)\n{\n\tint hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);\n\tif (hoplimit == 0) {\n\t\tstruct net_device *dev = dst->dev;\n\t\tstruct inet6_dev *idev;\n\n\t\trcu_read_lock();\n\t\tidev = __in6_dev_get(dev);\n\t\tif (idev)\n\t\t\thoplimit = idev->cnf.hop_limit;\n\t\telse\n\t\t\thoplimit = dev_net(dev)->ipv6.devconf_all->hop_limit;\n\t\trcu_read_unlock();\n\t}\n\treturn hoplimit;\n}\nEXPORT_SYMBOL(ip6_dst_hoplimit);\n#endif\n\nint __ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tint len;\n\n\tlen = skb->len - sizeof(struct ipv6hdr);\n\tif (len > IPV6_MAXPLEN)\n\t\tlen = 0;\n\tipv6_hdr(skb)->payload_len = htons(len);\n\tIP6CB(skb)->nhoff = offsetof(struct ipv6hdr, nexthdr);\n\n\t/* if egress device is enslaved to an L3 master device pass the\n\t * skb to its handler for processing\n\t */\n\tskb = l3mdev_ip6_out(sk, skb);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\treturn nf_hook(NFPROTO_IPV6, NF_INET_LOCAL_OUT,\n\t\t       net, sk, skb, NULL, skb_dst(skb)->dev,\n\t\t       dst_output);\n}\nEXPORT_SYMBOL_GPL(__ip6_local_out);\n\nint ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tint err;\n\n\terr = __ip6_local_out(net, sk, skb);\n\tif (likely(err == 1))\n\t\terr = dst_output(net, sk, skb);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ip6_local_out);\n"], "filenames": ["net/ipv6/output_core.c"], "buggy_code_start_loc": [81], "buggy_code_end_loc": [115], "fixing_code_start_loc": [81], "fixing_code_end_loc": [119], "type": "CWE-190", "message": "The ip6_find_1stfragopt function in net/ipv6/output_core.c in the Linux kernel through 4.12.3 allows local users to cause a denial of service (integer overflow and infinite loop) by leveraging the ability to open a raw socket.", "other": {"cve": {"id": "CVE-2017-7542", "sourceIdentifier": "secalert@redhat.com", "published": "2017-07-21T16:29:00.393", "lastModified": "2023-02-12T23:30:40.070", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The ip6_find_1stfragopt function in net/ipv6/output_core.c in the Linux kernel through 4.12.3 allows local users to cause a denial of service (integer overflow and infinite loop) by leveraging the ability to open a raw socket."}, {"lang": "es", "value": "La funci\u00f3n ip6_find_1stfragopt en el archivo net/ipv6/output_core.c en el kernel de Linux hasta la versi\u00f3n 4.12.3, permite a los usuarios locales causar una denegaci\u00f3n de servicio (desbordamiento de enteros y bucle infinito) mediante la explotaci\u00f3n de la capacidad de abrir un socket sin procesar."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.12.3", "matchCriteriaId": "93B616B9-0E9C-48F4-B663-8278767861FB"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6399f1fae4ec29fab5ec76070435555e256ca3a6", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3927", "source": "secalert@redhat.com"}, {"url": "http://www.debian.org/security/2017/dsa-3945", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/99953", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2918", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2930", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2931", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2018:0169", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/6399f1fae4ec29fab5ec76070435555e256ca3a6", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://help.ecostruxureit.com/display/public/UADCE725/Security+fixes+in+StruxureWare+Data+Center+Expert+v7.6.0", "source": "secalert@redhat.com"}, {"url": "https://usn.ubuntu.com/3583-1/", "source": "secalert@redhat.com"}, {"url": "https://usn.ubuntu.com/3583-2/", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6399f1fae4ec29fab5ec76070435555e256ca3a6"}}