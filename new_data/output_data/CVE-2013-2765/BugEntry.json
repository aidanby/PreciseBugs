{"buggy_code": ["/*\n* ModSecurity for Apache 2.x, http://www.modsecurity.org/\n* Copyright (c) 2004-2011 Trustwave Holdings, Inc. (http://www.trustwave.com/)\n*\n* You may not use this file except in compliance with\n* the License. \u00a0You may obtain a copy of the License at\n*\n* \u00a0 \u00a0 http://www.apache.org/licenses/LICENSE-2.0\n*\n* If any of the files related to licensing are missing or if you have any\n* other questions related to licensing please contact Trustwave Holdings, Inc.\n* directly using the email address security@modsecurity.org.\n*/\n\n#include \"modsecurity.h\"\n#include \"re.h\"\n#include \"msc_parsers.h\"\n\n#define CHUNK_CAPACITY 8192\n\n\n/**\n *\n */\nvoid msre_engine_reqbody_processor_register(msre_engine *engine,\n    const char *name, void *fn_init, void *fn_process, void *fn_complete)\n{\n    msre_reqbody_processor_metadata *metadata = \n        (msre_reqbody_processor_metadata *)apr_pcalloc(engine->mp,\n            sizeof(msre_reqbody_processor_metadata));\n    if (metadata == NULL) return;\n\n    metadata->name = name;\n    metadata->init = fn_init;\n    metadata->process = fn_process;\n    metadata->complete = fn_complete;\n    apr_table_setn(engine->reqbody_processors, name, (void *)metadata);\n}\n\n/**\n * Prepare to accept the request body (part 2).\n */\nstatic apr_status_t modsecurity_request_body_start_init(modsec_rec *msr, char **error_msg) {\n    *error_msg = NULL;\n\n    if(msr->msc_reqbody_storage == MSC_REQBODY_MEMORY) {\n        /* Prepare to store request body in memory. */\n\n        msr->msc_reqbody_chunks = apr_array_make(msr->msc_reqbody_mp,\n            32, sizeof(msc_data_chunk *));\n        if (msr->msc_reqbody_chunks == NULL) {\n            *error_msg = apr_pstrdup(msr->mp, \"Input filter: Failed to prepare in-memory storage.\");\n            return -1;\n        }\n    } else {\n        /* Prepare to store request body on disk. */\n\n        msr->msc_reqbody_filename = apr_psprintf(msr->mp, \"%s/%s-%s-request_body-XXXXXX\",\n            msr->txcfg->tmp_dir, current_filetime(msr->mp), msr->txid);\n        if (msr->msc_reqbody_filename == NULL) {\n            *error_msg = apr_pstrdup(msr->mp, \"Input filter: Failed to generate an on-disk filename.\");\n            return -1;\n        }\n\n        msr->msc_reqbody_fd = msc_mkstemp((char *)msr->msc_reqbody_filename);\n        if (msr->msc_reqbody_fd < 0) {\n            *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to create temporary file: %s\",\n                msr->msc_reqbody_filename);\n            return -1;\n        }\n\n        msr_log(msr, 4, \"Input filter: Created temporary file to store request body: %s\",\n            msr->msc_reqbody_filename);\n    }\n\n    return 1;\n}\n\n/**\n * Prepare to accept the request body (part 1).\n */\napr_status_t modsecurity_request_body_start(modsec_rec *msr, char **error_msg) {\n    *error_msg = NULL;\n    msr->msc_reqbody_length = 0;\n    msr->stream_input_length = 0;\n\n    /* Create a separate memory pool that will be used\n     * to allocate structures from (not data, which is allocated\n     * via malloc).\n     */\n    apr_pool_create(&msr->msc_reqbody_mp, NULL);\n\n    /* Initialise request body processors, if any. */\n\n    if (msr->msc_reqbody_processor != NULL) {\n        char *my_error_msg = NULL;\n        msre_reqbody_processor_metadata *metadata =\n            (msre_reqbody_processor_metadata *)apr_table_get(msr->modsecurity->msre->reqbody_processors, msr->msc_reqbody_processor);\n\n        if (metadata != NULL) {\n            if (   (metadata->init != NULL)\n                && (metadata->init(msr, &my_error_msg) < 0))\n            {\n                *error_msg = apr_psprintf(msr->mp,\n                                          \"%s parsing error (init): %s\",\n                                          msr->msc_reqbody_processor,\n                                          my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = my_error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n            }\n        }\n        // TODO: All these below need to be registered in the same way as above\n        else if (strcmp(msr->msc_reqbody_processor, \"MULTIPART\") == 0) {\n            if (multipart_init(msr, &my_error_msg) < 0) {\n                *error_msg = apr_psprintf(msr->mp, \"Multipart parsing error (init): %s\", my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = my_error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n            }\n        }\n        else if (strcmp(msr->msc_reqbody_processor, \"XML\") == 0) {\n            if (xml_init(msr, &my_error_msg) < 0) {\n                *error_msg = apr_psprintf(msr->mp, \"XML parsing error (init): %s\", my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = my_error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n            }\n        }\n        else if (strcmp(msr->msc_reqbody_processor, \"URLENCODED\") == 0) {\n            /* Do nothing, URLENCODED processor does not support streaming yet. */\n        }\n        else {\n            *error_msg = apr_psprintf(msr->mp, \"Unknown request body processor: %s\",\n                msr->msc_reqbody_processor);\n            return -1;\n        }\n    }\n\n    return modsecurity_request_body_start_init(msr, error_msg);\n}\n\n/**\n * Stores a chunk of request body data to disk.\n */\nstatic apr_status_t modsecurity_request_body_store_disk(modsec_rec *msr,\n    const char *data, apr_size_t length, char **error_msg)\n{\n    apr_size_t i;\n\n    *error_msg = NULL;\n\n    i = write(msr->msc_reqbody_fd, data, length);\n    if (i != length) {\n        *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed writing %\" APR_SIZE_T_FMT\n            \" bytes to temporary file (rc %\" APR_SIZE_T_FMT \").\", length, i);\n        return -1;\n    }\n\n    return 1;\n}\n\n/**\n * Stores one chunk of request body data in memory.\n */\nstatic apr_status_t modsecurity_request_body_store_memory(modsec_rec *msr,\n    const char *data, apr_size_t length, char **error_msg)\n{\n    *error_msg = NULL;\n\n    /* Would storing this chunk mean going over the limit? */\n    if ((msr->msc_reqbody_spilltodisk)\n        && (msr->msc_reqbody_length + length > (apr_size_t)msr->txcfg->reqbody_inmemory_limit))\n    {\n        msc_data_chunk **chunks;\n        unsigned int disklen = 0;\n        int i;\n\n        msr_log(msr, 4, \"Input filter: Request too large to store in memory, switching to disk.\");\n\n        /* NOTE Must use modsecurity_request_body_store_disk() here\n         *      to prevent data to be sent to the streaming\n         *      processors again.\n         */\n\n        /* Initialise disk storage */\n        msr->msc_reqbody_storage = MSC_REQBODY_DISK;\n        if (modsecurity_request_body_start_init(msr, error_msg) < 0) return -1;\n\n        /* Write the data we keep in memory */\n        chunks = (msc_data_chunk **)msr->msc_reqbody_chunks->elts;\n        for(i = 0; i < msr->msc_reqbody_chunks->nelts; i++) {\n            disklen += chunks[i]->length;\n\n            if (modsecurity_request_body_store_disk(msr, chunks[i]->data, chunks[i]->length, error_msg) < 0) {\n                return -1;\n            }\n\n            free(chunks[i]->data);\n            chunks[i]->data = NULL;\n        }\n\n        /* Clear the memory pool as we no longer need the bits. */\n\n        /* IMP1 But since we only used apr_pool_clear memory might\n         * not be released back to the OS straight away?\n         */\n        msr->msc_reqbody_chunks = NULL;\n        apr_pool_clear(msr->msc_reqbody_mp);\n\n        msr_log(msr, 4, \"Input filter: Wrote %u bytes from memory to disk.\", disklen);\n\n        /* Continue with disk storage from now on */\n        return modsecurity_request_body_store_disk(msr, data, length, error_msg);\n    }\n\n    /* If we're here that means we are not over the\n     * request body in-memory limit yet.\n     */\n    {\n        unsigned long int bucket_offset, bucket_left;\n\n        bucket_offset = 0;\n        bucket_left = length;\n\n        /* Although we store the request body in chunks we don't\n         * want to use the same chunk sizes as the incoming memory\n         * buffers. They are often of very small sizes and that\n         * would make us waste a lot of memory. That's why we\n         * use our own chunks of CHUNK_CAPACITY sizes.\n         */\n\n        /* Loop until we empty this bucket into our chunks. */\n        while(bucket_left > 0) {\n            /* Allocate a new chunk if we have to. */\n            if (msr->msc_reqbody_chunk_current == NULL) {\n                msr->msc_reqbody_chunk_current = (msc_data_chunk *)\n                    apr_pcalloc(msr->msc_reqbody_mp, sizeof(msc_data_chunk));\n                if (msr->msc_reqbody_chunk_current == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to allocate %lu bytes \"\n                        \"for request body chunk.\", (unsigned long)sizeof(msc_data_chunk));\n                    return -1;\n                }\n\n                msr->msc_reqbody_chunk_current->data = malloc(CHUNK_CAPACITY);\n                if (msr->msc_reqbody_chunk_current->data == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to allocate %d bytes \"\n                        \"for request body chunk data.\", CHUNK_CAPACITY);\n                    return -1;\n                }\n\n                msr->msc_reqbody_chunk_current->length = 0;\n                msr->msc_reqbody_chunk_current->is_permanent = 1;\n\n                *(const msc_data_chunk **)apr_array_push(msr->msc_reqbody_chunks)\n                    = msr->msc_reqbody_chunk_current;\n            }\n\n            if (bucket_left < (CHUNK_CAPACITY - msr->msc_reqbody_chunk_current->length)) {\n                /* There's enough space in the current chunk. */\n                memcpy(msr->msc_reqbody_chunk_current->data +\n                    msr->msc_reqbody_chunk_current->length, data + bucket_offset, bucket_left);\n                msr->msc_reqbody_chunk_current->length += bucket_left;\n                bucket_left = 0;\n            } else {\n                /* Fill the existing chunk. */\n                unsigned long int copy_length = CHUNK_CAPACITY -\n                    msr->msc_reqbody_chunk_current->length;\n\n                memcpy(msr->msc_reqbody_chunk_current->data +\n                    msr->msc_reqbody_chunk_current->length, data + bucket_offset, copy_length);\n                bucket_offset += copy_length;\n                bucket_left -= copy_length;\n                msr->msc_reqbody_chunk_current->length += copy_length;\n\n                /* We're done with this chunk. Setting the pointer\n                 * to NULL is going to force a new chunk to be allocated\n                 * on the next go.\n                 */\n                msr->msc_reqbody_chunk_current = NULL;\n            }\n        }\n\n        msr->msc_reqbody_length += length;\n    }\n\n    return 1;\n}\n\n/**\n * Stores one chunk of request body data. Returns -1 on error.\n */\napr_status_t modsecurity_request_body_store(modsec_rec *msr,\n    const char *data, apr_size_t length, char **error_msg)\n{\n    *error_msg = NULL;\n\n    /* If we have a processor for this request body send\n     * data to it first (but only if it did not report an\n     * error on previous invocations).\n     */\n    if ((msr->msc_reqbody_processor != NULL) && (msr->msc_reqbody_error == 0)) {\n        char *my_error_msg = NULL;\n        msre_reqbody_processor_metadata *metadata =\n            (msre_reqbody_processor_metadata *)apr_table_get(msr->modsecurity->msre->reqbody_processors, msr->msc_reqbody_processor);\n\n        if (metadata != NULL) {\n            if (   (metadata->process != NULL)\n                && (metadata->process(msr, data, length, &my_error_msg) < 0))\n            {\n                *error_msg = apr_psprintf(msr->mp,\n                                          \"%s parsing error: %s\",\n                                          msr->msc_reqbody_processor,\n                                          my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = my_error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n            }\n        }\n        // TODO: All these below need to be registered in the same way as above\n        else if (strcmp(msr->msc_reqbody_processor, \"MULTIPART\") == 0) {\n            /* The per-request data length counter will\n             * be updated by the multipart parser.\n             */\n\n            /* Process data as multipart/form-data. */\n            if (multipart_process_chunk(msr, data, length, &my_error_msg) < 0) {\n                *error_msg = apr_psprintf(msr->mp, \"Multipart parsing error: %s\", my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = *error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n            }\n        }\n        else if (strcmp(msr->msc_reqbody_processor, \"XML\") == 0) {\n            /* Increase per-request data length counter. */\n            msr->msc_reqbody_no_files_length += length;\n\n            /* Process data as XML. */\n            if (xml_process_chunk(msr, data, length, &my_error_msg) < 0) {\n                *error_msg = apr_psprintf(msr->mp, \"XML parsing error: %s\", my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = *error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n            }\n        }\n        else if (strcmp(msr->msc_reqbody_processor, \"URLENCODED\") == 0) {\n            /* Increase per-request data length counter. */\n            msr->msc_reqbody_no_files_length += length;\n\n            /* Do nothing else, URLENCODED processor does not support streaming. */\n        }\n        else {\n            *error_msg = apr_psprintf(msr->mp, \"Unknown request body processor: %s\",\n                msr->msc_reqbody_processor);\n            return -1;\n        }\n    } else if (msr->txcfg->reqbody_buffering != REQUEST_BODY_FORCEBUF_OFF) {\n        /* Increase per-request data length counter if forcing buffering. */\n        msr->msc_reqbody_no_files_length += length;\n    }\n\n    /* Check that we are not over the request body no files limit. */\n    if (msr->msc_reqbody_no_files_length >= (unsigned long) msr->txcfg->reqbody_no_files_limit) {\n\n        *error_msg = apr_psprintf(msr->mp, \"Request body no files data length is larger than the \"\n                \"configured limit (%ld).\", msr->txcfg->reqbody_no_files_limit);\n        if (msr->txcfg->debuglog_level >= 1) {\n            msr_log(msr, 1, \"%s\", *error_msg);\n        }\n\n        if ((msr->txcfg->is_enabled == MODSEC_ENABLED) && (msr->txcfg->if_limit_action == REQUEST_BODY_LIMIT_ACTION_REJECT))   {\n            return -5;\n        } else if (msr->txcfg->if_limit_action == REQUEST_BODY_LIMIT_ACTION_PARTIAL)  {\n            if(msr->txcfg->is_enabled == MODSEC_ENABLED)\n                return -5;\n        }\n    }\n\n\n    /* Store data. */\n    if (msr->msc_reqbody_storage == MSC_REQBODY_MEMORY) {\n        return modsecurity_request_body_store_memory(msr, data, length, error_msg);\n    }\n    else\n        if (msr->msc_reqbody_storage == MSC_REQBODY_DISK) {\n        return modsecurity_request_body_store_disk(msr, data, length, error_msg);\n    }\n\n    /* Should never happen. */\n    *error_msg = apr_psprintf(msr->mp, \"Internal error, unknown value for msc_reqbody_storage: %u\",\n        msr->msc_reqbody_storage);\n    return -1;\n}\n\napr_status_t modsecurity_request_body_to_stream(modsec_rec *msr, const char *buffer, int buflen, char **error_msg) {\n    char *stream_input_body = NULL;\n    char *data = NULL;\n    int first_pkt = 0;\n\n    if(msr->stream_input_data == NULL)  {\n        msr->stream_input_data = (char *)calloc(sizeof(char), msr->stream_input_length + 1);\n        first_pkt = 1;\n    }\n    else    {\n\n        data = (char *)malloc(msr->stream_input_length + 1 - buflen);\n\n        if(data == NULL)\n            return -1;\n\n        memset(data, 0, msr->stream_input_length + 1 - buflen);\n        memcpy(data, msr->stream_input_data, msr->stream_input_length - buflen);\n\n        stream_input_body = (char *)realloc(msr->stream_input_data, msr->stream_input_length + 1);\n\n        msr->stream_input_data = (char *)stream_input_body;\n    }\n\n    if (msr->stream_input_data == NULL) {\n        if(data)    {\n            free(data);\n            data = NULL;\n        }\n        *error_msg = apr_psprintf(msr->mp, \"Unable to allocate memory to hold request body on stream. Asked for %\" APR_SIZE_T_FMT \" bytes.\",\n                msr->stream_input_length + 1);\n        return -1;\n    }\n\n    memset(msr->stream_input_data, 0, msr->stream_input_length+1);\n\n    if(first_pkt)   {\n        memcpy(msr->stream_input_data, buffer, msr->stream_input_length);\n    } else {\n        memcpy(msr->stream_input_data, data, msr->stream_input_length - buflen);\n        memcpy(msr->stream_input_data+(msr->stream_input_length - buflen), buffer, buflen);\n    }\n\n    if(data)    {\n        free(data);\n        data = NULL;\n    }\n\n    return 1;\n}\n/**\n * Replace a bunch of chunks holding a request body with a single large chunk.\n */\nstatic apr_status_t modsecurity_request_body_end_raw(modsec_rec *msr, char **error_msg) {\n    msc_data_chunk **chunks, *one_chunk;\n    char *d;\n    int i, sofar;\n\n    *error_msg = NULL;\n\n    /* Allocate a buffer large enough to hold the request body. */\n\n    if (msr->msc_reqbody_length + 1 == 0) {\n        *error_msg = apr_psprintf(msr->mp, \"Internal error, request body length will overflow: %u\",\n            msr->msc_reqbody_length);\n        return -1;\n    }\n\n    msr->msc_reqbody_buffer = malloc(msr->msc_reqbody_length + 1);\n    if (msr->msc_reqbody_buffer == NULL) {\n        *error_msg = apr_psprintf(msr->mp, \"Unable to allocate memory to hold request body. Asked for %u bytes.\",\n            msr->msc_reqbody_length + 1);\n        return -1;\n    }\n\n    msr->msc_reqbody_buffer[msr->msc_reqbody_length] = '\\0';\n\n    /* Copy the data we keep in chunks into the new buffer. */\n\n    sofar = 0;\n    d = msr->msc_reqbody_buffer;\n    chunks = (msc_data_chunk **)msr->msc_reqbody_chunks->elts;\n    for(i = 0; i < msr->msc_reqbody_chunks->nelts; i++) {\n        if (sofar + chunks[i]->length <= msr->msc_reqbody_length) {\n            memcpy(d, chunks[i]->data, chunks[i]->length);\n            d += chunks[i]->length;\n            sofar += chunks[i]->length;\n        } else {\n            *error_msg = apr_psprintf(msr->mp, \"Internal error, request body buffer overflow.\");\n            return -1;\n        }\n    }\n\n\n    /* Now free the memory used by the chunks. */\n\n    chunks = (msc_data_chunk **)msr->msc_reqbody_chunks->elts;\n    for(i = 0; i < msr->msc_reqbody_chunks->nelts; i++) {\n        free(chunks[i]->data);\n        chunks[i]->data = NULL;\n    }\n\n    /* Create a new array with only one chunk in it. */\n\n    msr->msc_reqbody_chunks = apr_array_make(msr->msc_reqbody_mp, 2, sizeof(msc_data_chunk *));\n    if (msr->msc_reqbody_chunks == NULL) {\n        *error_msg = apr_pstrdup(msr->mp, \"Failed to create structure to hold request body.\");\n        return -1;\n    }\n\n    one_chunk = (msc_data_chunk *)apr_pcalloc(msr->msc_reqbody_mp, sizeof(msc_data_chunk));\n    one_chunk->data = msr->msc_reqbody_buffer;\n    one_chunk->length = msr->msc_reqbody_length;\n    one_chunk->is_permanent = 1;\n    *(const msc_data_chunk **)apr_array_push(msr->msc_reqbody_chunks) = one_chunk;\n\n    if(msr->txcfg->reqbody_limit > 0 && msr->txcfg->reqbody_limit < msr->msc_reqbody_length)    {\n        msr->msc_reqbody_length = msr->txcfg->reqbody_limit;\n    }\n\n    return 1;\n}\n\n/**\n *\n */\nstatic apr_status_t modsecurity_request_body_end_urlencoded(modsec_rec *msr, char **error_msg) {\n    int invalid_count = 0;\n\n    *error_msg = NULL;\n\n    /* Create the raw buffer */\n    if (modsecurity_request_body_end_raw(msr, error_msg) != 1) {\n        return -1;\n    }\n\n    /* Parse URL-encoded arguments in the request body. */\n\n    if (parse_arguments(msr, msr->msc_reqbody_buffer, msr->msc_reqbody_length,\n        msr->txcfg->argument_separator, \"BODY\", msr->arguments, &invalid_count) < 0)\n    {\n        *error_msg = apr_pstrdup(msr->mp, \"Initialisation: Error occurred while parsing BODY arguments.\");\n        return -1;\n    }\n\n    if (invalid_count) {\n        msr->urlencoded_error = 1;\n    }\n\n    return 1;\n}\n\n/**\n * Stops receiving the request body.\n */\napr_status_t modsecurity_request_body_end(modsec_rec *msr, char **error_msg) {\n    *error_msg = NULL;\n\n    /* Close open file descriptors, if any. */\n    if (msr->msc_reqbody_storage == MSC_REQBODY_DISK) {\n        if (msr->msc_reqbody_fd > 0) {\n            close(msr->msc_reqbody_fd);\n            msr->msc_reqbody_fd = -1;\n        }\n    }\n\n    /* Note that we've read the body. */\n    msr->msc_reqbody_read = 1;\n\n    /* Finalise body processing. */\n    if ((msr->msc_reqbody_processor != NULL) && (msr->msc_reqbody_error == 0)) {\n        char *my_error_msg = NULL;\n        msre_reqbody_processor_metadata *metadata =\n            (msre_reqbody_processor_metadata *)apr_table_get(msr->modsecurity->msre->reqbody_processors, msr->msc_reqbody_processor);\n\n        if (metadata != NULL) {\n            if (   (metadata->complete != NULL)\n                && (metadata->complete(msr, &my_error_msg) < 0))\n            {\n                *error_msg = apr_psprintf(msr->mp,\n                                          \"%s parsing error (complete): %s\",\n                                          msr->msc_reqbody_processor,\n                                          my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = my_error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n            }\n        }\n        // TODO: All these below need to be registered in the same way as above\n        else if (strcmp(msr->msc_reqbody_processor, \"MULTIPART\") == 0) {\n            if (multipart_complete(msr, &my_error_msg) < 0) {\n                *error_msg = apr_psprintf(msr->mp, \"Multipart parsing error: %s\", my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = *error_msg;\n                if (msr->txcfg->debuglog_level >= 4) {\n                    msr_log(msr, 4, \"%s\", *error_msg);\n                }\n                return -1;\n            }\n\n            if (multipart_get_arguments(msr, \"BODY\", msr->arguments) < 0) {\n                *error_msg = \"Multipart parsing error: Failed to retrieve arguments.\";\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = *error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n                return -1;\n            }\n        }\n        else if (strcmp(msr->msc_reqbody_processor, \"URLENCODED\") == 0) {\n            return modsecurity_request_body_end_urlencoded(msr, error_msg);\n        }\n        else if (strcmp(msr->msc_reqbody_processor, \"XML\") == 0) {\n            if (xml_complete(msr, &my_error_msg) < 0) {\n                *error_msg = apr_psprintf(msr->mp, \"XML parser error: %s\", my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = *error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n                return -1;\n            }\n        }\n    } else if (msr->txcfg->reqbody_buffering != REQUEST_BODY_FORCEBUF_OFF) {\n        /* Convert to a single continous buffer, but don't do anything else. */\n        return modsecurity_request_body_end_raw(msr, error_msg);\n    }\n\n    /* Note the request body no files length. */\n    msr_log(msr, 4, \"Request body no files length: %\" APR_SIZE_T_FMT, msr->msc_reqbody_no_files_length);\n\n    return 1;\n}\n\n/**\n * Prepares to forward the request body.\n */\napr_status_t modsecurity_request_body_retrieve_start(modsec_rec *msr, char **error_msg) {\n    *error_msg = NULL;\n\n    if (msr->msc_reqbody_storage == MSC_REQBODY_MEMORY) {\n        msr->msc_reqbody_chunk_position = 0;\n        msr->msc_reqbody_chunk_offset = 0;\n\n        msr->msc_reqbody_disk_chunk = apr_pcalloc(msr->msc_reqbody_mp, sizeof(msc_data_chunk));\n        if (msr->msc_reqbody_disk_chunk == NULL) {\n            *error_msg = apr_psprintf(msr->mp, \"Failed to allocate %lu bytes for request body disk chunk.\",\n                (unsigned long)sizeof(msc_data_chunk));\n            return -1;\n        }\n        msr->msc_reqbody_disk_chunk->is_permanent = 1;\n    }\n    else\n    if (msr->msc_reqbody_storage == MSC_REQBODY_DISK) {\n        msr->msc_reqbody_disk_chunk = apr_pcalloc(msr->msc_reqbody_mp, sizeof(msc_data_chunk));\n        if (msr->msc_reqbody_disk_chunk == NULL) {\n            *error_msg = apr_psprintf(msr->mp, \"Failed to allocate %lu bytes for request body disk chunk.\",\n                (unsigned long)sizeof(msc_data_chunk));\n            return -1;\n        }\n\n        msr->msc_reqbody_disk_chunk->is_permanent = 0;\n        msr->msc_reqbody_disk_chunk->data = apr_palloc(msr->msc_reqbody_mp, CHUNK_CAPACITY);\n        if (msr->msc_reqbody_disk_chunk->data == NULL) {\n            *error_msg = apr_psprintf(msr->mp, \"Failed to allocate %d bytes for request body disk chunk data.\",\n                CHUNK_CAPACITY);\n            return -1;\n        }\n\n        msr->msc_reqbody_fd = open(msr->msc_reqbody_filename, O_RDONLY | O_BINARY);\n        if (msr->msc_reqbody_fd < 0) {\n            *error_msg = apr_psprintf(msr->mp, \"Failed to open temporary file for reading: %s\",\n                msr->msc_reqbody_filename);\n            return -1;\n        }\n    }\n\n    return 1;\n}\n\n/**\n *\n */\napr_status_t modsecurity_request_body_retrieve_end(modsec_rec *msr) {\n    if (msr->msc_reqbody_storage == MSC_REQBODY_DISK) {\n        if (msr->msc_reqbody_fd > 0) {\n            close(msr->msc_reqbody_fd);\n            msr->msc_reqbody_fd = -1;\n        }\n    }\n\n    return 1;\n}\n\n/**\n * Returns one chunk of request body data. It stores a NULL\n * in the chunk pointer when there is no data to return. The\n * return code is 1 if more calls can be made to retrieve more\n * data, 0 if there is no more data to retrieve, or -1 on error.\n *\n * The caller can limit the amount of data returned by providing\n * a non-negative value in nbytes.\n */\napr_status_t modsecurity_request_body_retrieve(modsec_rec *msr,\n    msc_data_chunk **chunk, long int nbytes, char **error_msg)\n{\n    msc_data_chunk **chunks;\n\n    *error_msg = NULL;\n\n    if (chunk == NULL) {\n        *error_msg = apr_pstrdup(msr->mp, \"Internal error, retrieving request body chunk.\");\n        return -1;\n    }\n    *chunk = NULL;\n\n    if (msr->msc_reqbody_storage == MSC_REQBODY_MEMORY) {\n        /* Are there any chunks left? */\n        if (msr->msc_reqbody_chunk_position >= msr->msc_reqbody_chunks->nelts) {\n            /* No more chunks. */\n            return 0;\n        }\n\n        /* We always respond with the same chunk, just different information in it. */\n        *chunk = msr->msc_reqbody_disk_chunk;\n\n        /* Advance to the current chunk and position on the\n         * next byte we need to send.\n         */\n        chunks = (msc_data_chunk **)msr->msc_reqbody_chunks->elts;\n        msr->msc_reqbody_disk_chunk->data = chunks[msr->msc_reqbody_chunk_position]->data\n            + msr->msc_reqbody_chunk_offset;\n\n        if (nbytes < 0) {\n            /* Send what's left in this chunk as there is no limit on the size. */\n            msr->msc_reqbody_disk_chunk->length = chunks[msr->msc_reqbody_chunk_position]->length;\n            msr->msc_reqbody_chunk_position++;\n            msr->msc_reqbody_chunk_offset = 0;\n        } else {\n            /* We have a limit we must obey. */\n\n            if (chunks[msr->msc_reqbody_chunk_position]->length -\n                msr->msc_reqbody_chunk_offset <= (unsigned int)nbytes)\n            {\n                /* If what's left in our chunk is less than the limit\n                 * then send it all back.\n                 */\n                msr->msc_reqbody_disk_chunk->length =\n                    chunks[msr->msc_reqbody_chunk_position]->length -\n                    msr->msc_reqbody_chunk_offset;\n                msr->msc_reqbody_chunk_position++;\n                msr->msc_reqbody_chunk_offset = 0;\n            } else {\n                /* If we have more data in our chunk, send the\n                 * maximum bytes we can (nbytes).\n                 */\n                msr->msc_reqbody_disk_chunk->length = nbytes;\n                msr->msc_reqbody_chunk_offset += nbytes;\n            }\n        }\n\n        /* If we've advanced beyond our last chunk then\n         * we have no more data to send.\n         */\n        if (msr->msc_reqbody_chunk_position >= msr->msc_reqbody_chunks->nelts) {\n            return 0; /* No more chunks. */\n        }\n\n        /* More data available. */\n        return 1;\n    }\n\n    if (msr->msc_reqbody_storage == MSC_REQBODY_DISK) {\n        long int my_nbytes = CHUNK_CAPACITY;\n        int i;\n\n        /* Send CHUNK_CAPACITY bytes at a time unless a lower limit was requested. */\n        if ((nbytes != -1)&&(my_nbytes > nbytes)) {\n            my_nbytes = nbytes;\n        }\n\n        i = read(msr->msc_reqbody_fd, msr->msc_reqbody_disk_chunk->data, my_nbytes);\n        if (i < 0) {\n            *error_msg = apr_psprintf(msr->mp, \"Input filter: Error reading from temporary file: %s\",\n                strerror(errno));\n            return -1;\n        }\n\n        *chunk = msr->msc_reqbody_disk_chunk;\n        msr->msc_reqbody_disk_chunk->length = i;\n\n        if (i == 0) return 0; /* No more data available. */\n\n        return 1; /* More data available. */\n    }\n\n    /* Should never happen. */\n    *error_msg = apr_psprintf(msr->mp, \"Internal error, invalid msc_reqbody_storage value: %u\",\n        msr->msc_reqbody_storage);\n\n    return -1;\n}\n\n/**\n *\n */\napr_status_t modsecurity_request_body_clear(modsec_rec *msr, char **error_msg) {\n    *error_msg = NULL;\n\n    /* Release memory we used to store request body data. */\n    if (msr->msc_reqbody_chunks != NULL) {\n        msc_data_chunk **chunks = (msc_data_chunk **)msr->msc_reqbody_chunks->elts;\n        int i;\n\n        for(i = 0; i < msr->msc_reqbody_chunks->nelts; i++) {\n            if (chunks[i]->data != NULL) {\n                free(chunks[i]->data);\n                chunks[i]->data = NULL;\n            }\n        }\n    }\n\n    if (msr->msc_reqbody_storage == MSC_REQBODY_DISK) {\n        int keep_body = 0;\n\n        /* Should we keep the body? This normally\n         * happens when a PUT method was used, which\n         * means the body is actually a file.\n         */\n        if ((msr->upload_remove_files == 0)&&(strcasecmp(msr->request_method, \"PUT\") == 0)) {\n            if (msr->txcfg->upload_dir != NULL) {\n                keep_body = 1;\n            } else {\n                *error_msg = apr_psprintf(msr->mp, \"Input filter: SecUploadDir is undefined, \"\n                    \"unable to store PUT file.\");\n            }\n        }\n\n        /* Deal with a request body stored in a file. */\n\n        if (msr->msc_reqbody_filename != NULL) {\n            if (keep_body) {\n                /* Move request body (which is a file) to the storage area. */\n                const char *put_filename = NULL;\n                const char *put_basename = NULL;\n\n                /* Construct the new filename. */\n                put_basename = file_basename(msr->msc_reqbody_mp, msr->msc_reqbody_filename);\n                if (put_basename == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to generate basename to PUT file \\\"%s\\\"\", log_escape(msr->msc_reqbody_mp, msr->msc_reqbody_filename));\n                    return -1;\n                }\n                put_filename = apr_psprintf(msr->msc_reqbody_mp, \"%s/%s\",\n                    msr->txcfg->upload_dir, put_basename);\n                if (put_filename == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to generate filename to PUT file \\\"%s\\\"\", log_escape(msr->msc_reqbody_mp, msr->msc_reqbody_filename));\n                    return -1;\n                }\n\n                if (apr_file_rename(msr->msc_reqbody_filename, put_filename,\n                    msr->msc_reqbody_mp) != APR_SUCCESS)\n                {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to rename file from \\\"%s\\\" to \\\"%s\\\".\",\n                        log_escape(msr->msc_reqbody_mp, msr->msc_reqbody_filename),\n                        log_escape(msr->msc_reqbody_mp, put_filename));\n                    return -1;\n                } else {\n                    msr_log(msr, 4, \"Input filter: Moved file from \\\"%s\\\" to \\\"%s\\\".\",\n                        log_escape(msr->msc_reqbody_mp, msr->msc_reqbody_filename),\n                        log_escape(msr->msc_reqbody_mp, put_filename));\n                }\n            } else {\n                /* make sure it is closed first */\n                if (msr->msc_reqbody_fd > 0) {\n                    close(msr->msc_reqbody_fd);\n                    msr->msc_reqbody_fd = -1;\n                }\n\n                /* We do not want to keep the request body. */\n                if (apr_file_remove(msr->msc_reqbody_filename,\n                    msr->msc_reqbody_mp) != APR_SUCCESS)\n                {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to delete temporary file: %s\",\n                        log_escape(msr->mp, msr->msc_reqbody_filename));\n                    return -1;\n                }\n\n                msr_log(msr, 4, \"Input filter: Removed temporary file: %s\",\n                    msr->msc_reqbody_filename);\n            }\n\n            msr->msc_reqbody_filename = NULL;\n        }\n    }\n\n    if (msr->msc_reqbody_mp != NULL) {\n        apr_pool_destroy(msr->msc_reqbody_mp);\n        msr->msc_reqbody_mp = NULL;\n    }\n\n    return 1;\n}\n"], "fixing_code": ["/*\n* ModSecurity for Apache 2.x, http://www.modsecurity.org/\n* Copyright (c) 2004-2011 Trustwave Holdings, Inc. (http://www.trustwave.com/)\n*\n* You may not use this file except in compliance with\n* the License. \u00a0You may obtain a copy of the License at\n*\n* \u00a0 \u00a0 http://www.apache.org/licenses/LICENSE-2.0\n*\n* If any of the files related to licensing are missing or if you have any\n* other questions related to licensing please contact Trustwave Holdings, Inc.\n* directly using the email address security@modsecurity.org.\n*/\n\n#include \"modsecurity.h\"\n#include \"re.h\"\n#include \"msc_parsers.h\"\n\n#define CHUNK_CAPACITY 8192\n\n\n/**\n *\n */\nvoid msre_engine_reqbody_processor_register(msre_engine *engine,\n    const char *name, void *fn_init, void *fn_process, void *fn_complete)\n{\n    msre_reqbody_processor_metadata *metadata = \n        (msre_reqbody_processor_metadata *)apr_pcalloc(engine->mp,\n            sizeof(msre_reqbody_processor_metadata));\n    if (metadata == NULL) return;\n\n    metadata->name = name;\n    metadata->init = fn_init;\n    metadata->process = fn_process;\n    metadata->complete = fn_complete;\n    apr_table_setn(engine->reqbody_processors, name, (void *)metadata);\n}\n\n/**\n * Prepare to accept the request body (part 2).\n */\nstatic apr_status_t modsecurity_request_body_start_init(modsec_rec *msr, char **error_msg) {\n    *error_msg = NULL;\n\n    if(msr->msc_reqbody_storage == MSC_REQBODY_MEMORY) {\n        /* Prepare to store request body in memory. */\n\n        msr->msc_reqbody_chunks = apr_array_make(msr->msc_reqbody_mp,\n            32, sizeof(msc_data_chunk *));\n        if (msr->msc_reqbody_chunks == NULL) {\n            *error_msg = apr_pstrdup(msr->mp, \"Input filter: Failed to prepare in-memory storage.\");\n            return -1;\n        }\n    } else {\n        /* Prepare to store request body on disk. */\n\n        msr->msc_reqbody_filename = apr_psprintf(msr->mp, \"%s/%s-%s-request_body-XXXXXX\",\n            msr->txcfg->tmp_dir, current_filetime(msr->mp), msr->txid);\n        if (msr->msc_reqbody_filename == NULL) {\n            *error_msg = apr_pstrdup(msr->mp, \"Input filter: Failed to generate an on-disk filename.\");\n            return -1;\n        }\n\n        msr->msc_reqbody_fd = msc_mkstemp((char *)msr->msc_reqbody_filename);\n        if (msr->msc_reqbody_fd < 0) {\n            *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to create temporary file: %s\",\n                msr->msc_reqbody_filename);\n            return -1;\n        }\n\n        msr_log(msr, 4, \"Input filter: Created temporary file to store request body: %s\",\n            msr->msc_reqbody_filename);\n    }\n\n    return 1;\n}\n\n/**\n * Prepare to accept the request body (part 1).\n */\napr_status_t modsecurity_request_body_start(modsec_rec *msr, char **error_msg) {\n    *error_msg = NULL;\n    msr->msc_reqbody_length = 0;\n    msr->stream_input_length = 0;\n\n    /* Create a separate memory pool that will be used\n     * to allocate structures from (not data, which is allocated\n     * via malloc).\n     */\n    apr_pool_create(&msr->msc_reqbody_mp, NULL);\n\n    /* Initialise request body processors, if any. */\n\n    if (msr->msc_reqbody_processor != NULL) {\n        char *my_error_msg = NULL;\n        msre_reqbody_processor_metadata *metadata =\n            (msre_reqbody_processor_metadata *)apr_table_get(msr->modsecurity->msre->reqbody_processors, msr->msc_reqbody_processor);\n\n        if (metadata != NULL) {\n            if (   (metadata->init != NULL)\n                && (metadata->init(msr, &my_error_msg) < 0))\n            {\n                *error_msg = apr_psprintf(msr->mp,\n                                          \"%s parsing error (init): %s\",\n                                          msr->msc_reqbody_processor,\n                                          my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = my_error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n            }\n        }\n        // TODO: All these below need to be registered in the same way as above\n        else if (strcmp(msr->msc_reqbody_processor, \"MULTIPART\") == 0) {\n            if (multipart_init(msr, &my_error_msg) < 0) {\n                *error_msg = apr_psprintf(msr->mp, \"Multipart parsing error (init): %s\", my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = my_error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n            }\n        }\n        else if (strcmp(msr->msc_reqbody_processor, \"XML\") == 0) {\n            if (xml_init(msr, &my_error_msg) < 0) {\n                *error_msg = apr_psprintf(msr->mp, \"XML parsing error (init): %s\", my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = my_error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n            }\n        }\n        else if (strcmp(msr->msc_reqbody_processor, \"URLENCODED\") == 0) {\n            /* Do nothing, URLENCODED processor does not support streaming yet. */\n        }\n        else {\n            *error_msg = apr_psprintf(msr->mp, \"Unknown request body processor: %s\",\n                msr->msc_reqbody_processor);\n            return -1;\n        }\n    }\n\n    return modsecurity_request_body_start_init(msr, error_msg);\n}\n\n/**\n * Stores a chunk of request body data to disk.\n */\nstatic apr_status_t modsecurity_request_body_store_disk(modsec_rec *msr,\n    const char *data, apr_size_t length, char **error_msg)\n{\n    apr_size_t i;\n\n    *error_msg = NULL;\n\n    i = write(msr->msc_reqbody_fd, data, length);\n    if (i != length) {\n        *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed writing %\" APR_SIZE_T_FMT\n            \" bytes to temporary file (rc %\" APR_SIZE_T_FMT \").\", length, i);\n        return -1;\n    }\n\n    return 1;\n}\n\n/**\n * Stores one chunk of request body data in memory.\n */\nstatic apr_status_t modsecurity_request_body_store_memory(modsec_rec *msr,\n    const char *data, apr_size_t length, char **error_msg)\n{\n    *error_msg = NULL;\n\n    /* Would storing this chunk mean going over the limit? */\n    if ((msr->msc_reqbody_spilltodisk)\n        && (msr->txcfg->reqbody_buffering != REQUEST_BODY_FORCEBUF_ON)\n        && (msr->msc_reqbody_length + length > (apr_size_t)msr->txcfg->reqbody_inmemory_limit))\n    {\n        msc_data_chunk **chunks;\n        unsigned int disklen = 0;\n        int i;\n\n        msr_log(msr, 4, \"Input filter: Request too large to store in memory, switching to disk.\");\n\n        /* NOTE Must use modsecurity_request_body_store_disk() here\n         *      to prevent data to be sent to the streaming\n         *      processors again.\n         */\n\n        /* Initialise disk storage */\n        msr->msc_reqbody_storage = MSC_REQBODY_DISK;\n        if (modsecurity_request_body_start_init(msr, error_msg) < 0) return -1;\n\n        /* Write the data we keep in memory */\n        chunks = (msc_data_chunk **)msr->msc_reqbody_chunks->elts;\n        for(i = 0; i < msr->msc_reqbody_chunks->nelts; i++) {\n            disklen += chunks[i]->length;\n\n            if (modsecurity_request_body_store_disk(msr, chunks[i]->data, chunks[i]->length, error_msg) < 0) {\n                return -1;\n            }\n\n            free(chunks[i]->data);\n            chunks[i]->data = NULL;\n        }\n\n        /* Clear the memory pool as we no longer need the bits. */\n\n        /* IMP1 But since we only used apr_pool_clear memory might\n         * not be released back to the OS straight away?\n         */\n        msr->msc_reqbody_chunks = NULL;\n        apr_pool_clear(msr->msc_reqbody_mp);\n\n        msr_log(msr, 4, \"Input filter: Wrote %u bytes from memory to disk.\", disklen);\n\n        /* Continue with disk storage from now on */\n        return modsecurity_request_body_store_disk(msr, data, length, error_msg);\n    }\n\n    /* If we're here that means we are not over the\n     * request body in-memory limit yet.\n     */\n    {\n        unsigned long int bucket_offset, bucket_left;\n\n        bucket_offset = 0;\n        bucket_left = length;\n\n        /* Although we store the request body in chunks we don't\n         * want to use the same chunk sizes as the incoming memory\n         * buffers. They are often of very small sizes and that\n         * would make us waste a lot of memory. That's why we\n         * use our own chunks of CHUNK_CAPACITY sizes.\n         */\n\n        /* Loop until we empty this bucket into our chunks. */\n        while(bucket_left > 0) {\n            /* Allocate a new chunk if we have to. */\n            if (msr->msc_reqbody_chunk_current == NULL) {\n                msr->msc_reqbody_chunk_current = (msc_data_chunk *)\n                    apr_pcalloc(msr->msc_reqbody_mp, sizeof(msc_data_chunk));\n                if (msr->msc_reqbody_chunk_current == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to allocate %lu bytes \"\n                        \"for request body chunk.\", (unsigned long)sizeof(msc_data_chunk));\n                    return -1;\n                }\n\n                msr->msc_reqbody_chunk_current->data = malloc(CHUNK_CAPACITY);\n                if (msr->msc_reqbody_chunk_current->data == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to allocate %d bytes \"\n                        \"for request body chunk data.\", CHUNK_CAPACITY);\n                    return -1;\n                }\n\n                msr->msc_reqbody_chunk_current->length = 0;\n                msr->msc_reqbody_chunk_current->is_permanent = 1;\n\n                *(const msc_data_chunk **)apr_array_push(msr->msc_reqbody_chunks)\n                    = msr->msc_reqbody_chunk_current;\n            }\n\n            if (bucket_left < (CHUNK_CAPACITY - msr->msc_reqbody_chunk_current->length)) {\n                /* There's enough space in the current chunk. */\n                memcpy(msr->msc_reqbody_chunk_current->data +\n                    msr->msc_reqbody_chunk_current->length, data + bucket_offset, bucket_left);\n                msr->msc_reqbody_chunk_current->length += bucket_left;\n                bucket_left = 0;\n            } else {\n                /* Fill the existing chunk. */\n                unsigned long int copy_length = CHUNK_CAPACITY -\n                    msr->msc_reqbody_chunk_current->length;\n\n                memcpy(msr->msc_reqbody_chunk_current->data +\n                    msr->msc_reqbody_chunk_current->length, data + bucket_offset, copy_length);\n                bucket_offset += copy_length;\n                bucket_left -= copy_length;\n                msr->msc_reqbody_chunk_current->length += copy_length;\n\n                /* We're done with this chunk. Setting the pointer\n                 * to NULL is going to force a new chunk to be allocated\n                 * on the next go.\n                 */\n                msr->msc_reqbody_chunk_current = NULL;\n            }\n        }\n\n        msr->msc_reqbody_length += length;\n    }\n\n    return 1;\n}\n\n/**\n * Stores one chunk of request body data. Returns -1 on error.\n */\napr_status_t modsecurity_request_body_store(modsec_rec *msr,\n    const char *data, apr_size_t length, char **error_msg)\n{\n    *error_msg = NULL;\n\n    /* If we have a processor for this request body send\n     * data to it first (but only if it did not report an\n     * error on previous invocations).\n     */\n    if ((msr->msc_reqbody_processor != NULL) && (msr->msc_reqbody_error == 0)) {\n        char *my_error_msg = NULL;\n        msre_reqbody_processor_metadata *metadata =\n            (msre_reqbody_processor_metadata *)apr_table_get(msr->modsecurity->msre->reqbody_processors, msr->msc_reqbody_processor);\n\n        if (metadata != NULL) {\n            if (   (metadata->process != NULL)\n                && (metadata->process(msr, data, length, &my_error_msg) < 0))\n            {\n                *error_msg = apr_psprintf(msr->mp,\n                                          \"%s parsing error: %s\",\n                                          msr->msc_reqbody_processor,\n                                          my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = my_error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n            }\n        }\n        // TODO: All these below need to be registered in the same way as above\n        else if (strcmp(msr->msc_reqbody_processor, \"MULTIPART\") == 0) {\n            /* The per-request data length counter will\n             * be updated by the multipart parser.\n             */\n\n            /* Process data as multipart/form-data. */\n            if (multipart_process_chunk(msr, data, length, &my_error_msg) < 0) {\n                *error_msg = apr_psprintf(msr->mp, \"Multipart parsing error: %s\", my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = *error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n            }\n        }\n        else if (strcmp(msr->msc_reqbody_processor, \"XML\") == 0) {\n            /* Increase per-request data length counter. */\n            msr->msc_reqbody_no_files_length += length;\n\n            /* Process data as XML. */\n            if (xml_process_chunk(msr, data, length, &my_error_msg) < 0) {\n                *error_msg = apr_psprintf(msr->mp, \"XML parsing error: %s\", my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = *error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n            }\n        }\n        else if (strcmp(msr->msc_reqbody_processor, \"URLENCODED\") == 0) {\n            /* Increase per-request data length counter. */\n            msr->msc_reqbody_no_files_length += length;\n\n            /* Do nothing else, URLENCODED processor does not support streaming. */\n        }\n        else {\n            *error_msg = apr_psprintf(msr->mp, \"Unknown request body processor: %s\",\n                msr->msc_reqbody_processor);\n            return -1;\n        }\n    } else if (msr->txcfg->reqbody_buffering != REQUEST_BODY_FORCEBUF_OFF) {\n        /* Increase per-request data length counter if forcing buffering. */\n        msr->msc_reqbody_no_files_length += length;\n    }\n\n    /* Check that we are not over the request body no files limit. */\n    if (msr->msc_reqbody_no_files_length >= (unsigned long) msr->txcfg->reqbody_no_files_limit) {\n\n        *error_msg = apr_psprintf(msr->mp, \"Request body no files data length is larger than the \"\n                \"configured limit (%ld).\", msr->txcfg->reqbody_no_files_limit);\n        if (msr->txcfg->debuglog_level >= 1) {\n            msr_log(msr, 1, \"%s\", *error_msg);\n        }\n\n        if ((msr->txcfg->is_enabled == MODSEC_ENABLED) && (msr->txcfg->if_limit_action == REQUEST_BODY_LIMIT_ACTION_REJECT))   {\n            return -5;\n        } else if (msr->txcfg->if_limit_action == REQUEST_BODY_LIMIT_ACTION_PARTIAL)  {\n            if(msr->txcfg->is_enabled == MODSEC_ENABLED)\n                return -5;\n        }\n    }\n\n\n    /* Store data. */\n    if (msr->msc_reqbody_storage == MSC_REQBODY_MEMORY) {\n        return modsecurity_request_body_store_memory(msr, data, length, error_msg);\n    }\n    else\n        if (msr->msc_reqbody_storage == MSC_REQBODY_DISK) {\n        return modsecurity_request_body_store_disk(msr, data, length, error_msg);\n    }\n\n    /* Should never happen. */\n    *error_msg = apr_psprintf(msr->mp, \"Internal error, unknown value for msc_reqbody_storage: %u\",\n        msr->msc_reqbody_storage);\n    return -1;\n}\n\napr_status_t modsecurity_request_body_to_stream(modsec_rec *msr, const char *buffer, int buflen, char **error_msg) {\n    char *stream_input_body = NULL;\n    char *data = NULL;\n    int first_pkt = 0;\n\n    if(msr->stream_input_data == NULL)  {\n        msr->stream_input_data = (char *)calloc(sizeof(char), msr->stream_input_length + 1);\n        first_pkt = 1;\n    }\n    else    {\n\n        data = (char *)malloc(msr->stream_input_length + 1 - buflen);\n\n        if(data == NULL)\n            return -1;\n\n        memset(data, 0, msr->stream_input_length + 1 - buflen);\n        memcpy(data, msr->stream_input_data, msr->stream_input_length - buflen);\n\n        stream_input_body = (char *)realloc(msr->stream_input_data, msr->stream_input_length + 1);\n\n        msr->stream_input_data = (char *)stream_input_body;\n    }\n\n    if (msr->stream_input_data == NULL) {\n        if(data)    {\n            free(data);\n            data = NULL;\n        }\n        *error_msg = apr_psprintf(msr->mp, \"Unable to allocate memory to hold request body on stream. Asked for %\" APR_SIZE_T_FMT \" bytes.\",\n                msr->stream_input_length + 1);\n        return -1;\n    }\n\n    memset(msr->stream_input_data, 0, msr->stream_input_length+1);\n\n    if(first_pkt)   {\n        memcpy(msr->stream_input_data, buffer, msr->stream_input_length);\n    } else {\n        memcpy(msr->stream_input_data, data, msr->stream_input_length - buflen);\n        memcpy(msr->stream_input_data+(msr->stream_input_length - buflen), buffer, buflen);\n    }\n\n    if(data)    {\n        free(data);\n        data = NULL;\n    }\n\n    return 1;\n}\n/**\n * Replace a bunch of chunks holding a request body with a single large chunk.\n */\nstatic apr_status_t modsecurity_request_body_end_raw(modsec_rec *msr, char **error_msg) {\n    msc_data_chunk **chunks, *one_chunk;\n    char *d;\n    int i, sofar;\n\n    *error_msg = NULL;\n\n    /* Allocate a buffer large enough to hold the request body. */\n\n    if (msr->msc_reqbody_length + 1 == 0) {\n        *error_msg = apr_psprintf(msr->mp, \"Internal error, request body length will overflow: %u\",\n            msr->msc_reqbody_length);\n        return -1;\n    }\n\n    msr->msc_reqbody_buffer = malloc(msr->msc_reqbody_length + 1);\n    if (msr->msc_reqbody_buffer == NULL) {\n        *error_msg = apr_psprintf(msr->mp, \"Unable to allocate memory to hold request body. Asked for %u bytes.\",\n            msr->msc_reqbody_length + 1);\n        return -1;\n    }\n\n    msr->msc_reqbody_buffer[msr->msc_reqbody_length] = '\\0';\n\n    /* Copy the data we keep in chunks into the new buffer. */\n\n    sofar = 0;\n    d = msr->msc_reqbody_buffer;\n    chunks = (msc_data_chunk **)msr->msc_reqbody_chunks->elts;\n    for(i = 0; i < msr->msc_reqbody_chunks->nelts; i++) {\n        if (sofar + chunks[i]->length <= msr->msc_reqbody_length) {\n            memcpy(d, chunks[i]->data, chunks[i]->length);\n            d += chunks[i]->length;\n            sofar += chunks[i]->length;\n        } else {\n            *error_msg = apr_psprintf(msr->mp, \"Internal error, request body buffer overflow.\");\n            return -1;\n        }\n    }\n\n\n    /* Now free the memory used by the chunks. */\n\n    chunks = (msc_data_chunk **)msr->msc_reqbody_chunks->elts;\n    for(i = 0; i < msr->msc_reqbody_chunks->nelts; i++) {\n        free(chunks[i]->data);\n        chunks[i]->data = NULL;\n    }\n\n    /* Create a new array with only one chunk in it. */\n\n    msr->msc_reqbody_chunks = apr_array_make(msr->msc_reqbody_mp, 2, sizeof(msc_data_chunk *));\n    if (msr->msc_reqbody_chunks == NULL) {\n        *error_msg = apr_pstrdup(msr->mp, \"Failed to create structure to hold request body.\");\n        return -1;\n    }\n\n    one_chunk = (msc_data_chunk *)apr_pcalloc(msr->msc_reqbody_mp, sizeof(msc_data_chunk));\n    one_chunk->data = msr->msc_reqbody_buffer;\n    one_chunk->length = msr->msc_reqbody_length;\n    one_chunk->is_permanent = 1;\n    *(const msc_data_chunk **)apr_array_push(msr->msc_reqbody_chunks) = one_chunk;\n\n    if(msr->txcfg->reqbody_limit > 0 && msr->txcfg->reqbody_limit < msr->msc_reqbody_length)    {\n        msr->msc_reqbody_length = msr->txcfg->reqbody_limit;\n    }\n\n    return 1;\n}\n\n/**\n *\n */\nstatic apr_status_t modsecurity_request_body_end_urlencoded(modsec_rec *msr, char **error_msg) {\n    int invalid_count = 0;\n\n    *error_msg = NULL;\n\n    /* Create the raw buffer */\n    if (modsecurity_request_body_end_raw(msr, error_msg) != 1) {\n        return -1;\n    }\n\n    /* Parse URL-encoded arguments in the request body. */\n\n    if (parse_arguments(msr, msr->msc_reqbody_buffer, msr->msc_reqbody_length,\n        msr->txcfg->argument_separator, \"BODY\", msr->arguments, &invalid_count) < 0)\n    {\n        *error_msg = apr_pstrdup(msr->mp, \"Initialisation: Error occurred while parsing BODY arguments.\");\n        return -1;\n    }\n\n    if (invalid_count) {\n        msr->urlencoded_error = 1;\n    }\n\n    return 1;\n}\n\n/**\n * Stops receiving the request body.\n */\napr_status_t modsecurity_request_body_end(modsec_rec *msr, char **error_msg) {\n    *error_msg = NULL;\n\n    /* Close open file descriptors, if any. */\n    if (msr->msc_reqbody_storage == MSC_REQBODY_DISK) {\n        if (msr->msc_reqbody_fd > 0) {\n            close(msr->msc_reqbody_fd);\n            msr->msc_reqbody_fd = -1;\n        }\n    }\n\n    /* Note that we've read the body. */\n    msr->msc_reqbody_read = 1;\n\n    /* Finalise body processing. */\n    if ((msr->msc_reqbody_processor != NULL) && (msr->msc_reqbody_error == 0)) {\n        char *my_error_msg = NULL;\n        msre_reqbody_processor_metadata *metadata =\n            (msre_reqbody_processor_metadata *)apr_table_get(msr->modsecurity->msre->reqbody_processors, msr->msc_reqbody_processor);\n\n        if (metadata != NULL) {\n            if (   (metadata->complete != NULL)\n                && (metadata->complete(msr, &my_error_msg) < 0))\n            {\n                *error_msg = apr_psprintf(msr->mp,\n                                          \"%s parsing error (complete): %s\",\n                                          msr->msc_reqbody_processor,\n                                          my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = my_error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n            }\n        }\n        // TODO: All these below need to be registered in the same way as above\n        else if (strcmp(msr->msc_reqbody_processor, \"MULTIPART\") == 0) {\n            if (multipart_complete(msr, &my_error_msg) < 0) {\n                *error_msg = apr_psprintf(msr->mp, \"Multipart parsing error: %s\", my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = *error_msg;\n                if (msr->txcfg->debuglog_level >= 4) {\n                    msr_log(msr, 4, \"%s\", *error_msg);\n                }\n                return -1;\n            }\n\n            if (multipart_get_arguments(msr, \"BODY\", msr->arguments) < 0) {\n                *error_msg = \"Multipart parsing error: Failed to retrieve arguments.\";\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = *error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n                return -1;\n            }\n        }\n        else if (strcmp(msr->msc_reqbody_processor, \"URLENCODED\") == 0) {\n            return modsecurity_request_body_end_urlencoded(msr, error_msg);\n        }\n        else if (strcmp(msr->msc_reqbody_processor, \"XML\") == 0) {\n            if (xml_complete(msr, &my_error_msg) < 0) {\n                *error_msg = apr_psprintf(msr->mp, \"XML parser error: %s\", my_error_msg);\n                msr->msc_reqbody_error = 1;\n                msr->msc_reqbody_error_msg = *error_msg;\n                msr_log(msr, 2, \"%s\", *error_msg);\n                return -1;\n            }\n        }\n    } else if (msr->txcfg->reqbody_buffering != REQUEST_BODY_FORCEBUF_OFF) {\n        /* Convert to a single continous buffer, but don't do anything else. */\n        return modsecurity_request_body_end_raw(msr, error_msg);\n    }\n\n    /* Note the request body no files length. */\n    msr_log(msr, 4, \"Request body no files length: %\" APR_SIZE_T_FMT, msr->msc_reqbody_no_files_length);\n\n    return 1;\n}\n\n/**\n * Prepares to forward the request body.\n */\napr_status_t modsecurity_request_body_retrieve_start(modsec_rec *msr, char **error_msg) {\n    *error_msg = NULL;\n\n    if (msr->msc_reqbody_storage == MSC_REQBODY_MEMORY) {\n        msr->msc_reqbody_chunk_position = 0;\n        msr->msc_reqbody_chunk_offset = 0;\n\n        msr->msc_reqbody_disk_chunk = apr_pcalloc(msr->msc_reqbody_mp, sizeof(msc_data_chunk));\n        if (msr->msc_reqbody_disk_chunk == NULL) {\n            *error_msg = apr_psprintf(msr->mp, \"Failed to allocate %lu bytes for request body disk chunk.\",\n                (unsigned long)sizeof(msc_data_chunk));\n            return -1;\n        }\n        msr->msc_reqbody_disk_chunk->is_permanent = 1;\n    }\n    else\n    if (msr->msc_reqbody_storage == MSC_REQBODY_DISK) {\n        msr->msc_reqbody_disk_chunk = apr_pcalloc(msr->msc_reqbody_mp, sizeof(msc_data_chunk));\n        if (msr->msc_reqbody_disk_chunk == NULL) {\n            *error_msg = apr_psprintf(msr->mp, \"Failed to allocate %lu bytes for request body disk chunk.\",\n                (unsigned long)sizeof(msc_data_chunk));\n            return -1;\n        }\n\n        msr->msc_reqbody_disk_chunk->is_permanent = 0;\n        msr->msc_reqbody_disk_chunk->data = apr_palloc(msr->msc_reqbody_mp, CHUNK_CAPACITY);\n        if (msr->msc_reqbody_disk_chunk->data == NULL) {\n            *error_msg = apr_psprintf(msr->mp, \"Failed to allocate %d bytes for request body disk chunk data.\",\n                CHUNK_CAPACITY);\n            return -1;\n        }\n\n        msr->msc_reqbody_fd = open(msr->msc_reqbody_filename, O_RDONLY | O_BINARY);\n        if (msr->msc_reqbody_fd < 0) {\n            *error_msg = apr_psprintf(msr->mp, \"Failed to open temporary file for reading: %s\",\n                msr->msc_reqbody_filename);\n            return -1;\n        }\n    }\n\n    return 1;\n}\n\n/**\n *\n */\napr_status_t modsecurity_request_body_retrieve_end(modsec_rec *msr) {\n    if (msr->msc_reqbody_storage == MSC_REQBODY_DISK) {\n        if (msr->msc_reqbody_fd > 0) {\n            close(msr->msc_reqbody_fd);\n            msr->msc_reqbody_fd = -1;\n        }\n    }\n\n    return 1;\n}\n\n/**\n * Returns one chunk of request body data. It stores a NULL\n * in the chunk pointer when there is no data to return. The\n * return code is 1 if more calls can be made to retrieve more\n * data, 0 if there is no more data to retrieve, or -1 on error.\n *\n * The caller can limit the amount of data returned by providing\n * a non-negative value in nbytes.\n */\napr_status_t modsecurity_request_body_retrieve(modsec_rec *msr,\n    msc_data_chunk **chunk, long int nbytes, char **error_msg)\n{\n    msc_data_chunk **chunks;\n\n    *error_msg = NULL;\n\n    if (chunk == NULL) {\n        *error_msg = apr_pstrdup(msr->mp, \"Internal error, retrieving request body chunk.\");\n        return -1;\n    }\n    *chunk = NULL;\n\n    if (msr->msc_reqbody_storage == MSC_REQBODY_MEMORY) {\n        /* Are there any chunks left? */\n        if (msr->msc_reqbody_chunk_position >= msr->msc_reqbody_chunks->nelts) {\n            /* No more chunks. */\n            return 0;\n        }\n\n        /* We always respond with the same chunk, just different information in it. */\n        *chunk = msr->msc_reqbody_disk_chunk;\n\n        /* Advance to the current chunk and position on the\n         * next byte we need to send.\n         */\n        chunks = (msc_data_chunk **)msr->msc_reqbody_chunks->elts;\n        msr->msc_reqbody_disk_chunk->data = chunks[msr->msc_reqbody_chunk_position]->data\n            + msr->msc_reqbody_chunk_offset;\n\n        if (nbytes < 0) {\n            /* Send what's left in this chunk as there is no limit on the size. */\n            msr->msc_reqbody_disk_chunk->length = chunks[msr->msc_reqbody_chunk_position]->length;\n            msr->msc_reqbody_chunk_position++;\n            msr->msc_reqbody_chunk_offset = 0;\n        } else {\n            /* We have a limit we must obey. */\n\n            if (chunks[msr->msc_reqbody_chunk_position]->length -\n                msr->msc_reqbody_chunk_offset <= (unsigned int)nbytes)\n            {\n                /* If what's left in our chunk is less than the limit\n                 * then send it all back.\n                 */\n                msr->msc_reqbody_disk_chunk->length =\n                    chunks[msr->msc_reqbody_chunk_position]->length -\n                    msr->msc_reqbody_chunk_offset;\n                msr->msc_reqbody_chunk_position++;\n                msr->msc_reqbody_chunk_offset = 0;\n            } else {\n                /* If we have more data in our chunk, send the\n                 * maximum bytes we can (nbytes).\n                 */\n                msr->msc_reqbody_disk_chunk->length = nbytes;\n                msr->msc_reqbody_chunk_offset += nbytes;\n            }\n        }\n\n        /* If we've advanced beyond our last chunk then\n         * we have no more data to send.\n         */\n        if (msr->msc_reqbody_chunk_position >= msr->msc_reqbody_chunks->nelts) {\n            return 0; /* No more chunks. */\n        }\n\n        /* More data available. */\n        return 1;\n    }\n\n    if (msr->msc_reqbody_storage == MSC_REQBODY_DISK) {\n        long int my_nbytes = CHUNK_CAPACITY;\n        int i;\n\n        /* Send CHUNK_CAPACITY bytes at a time unless a lower limit was requested. */\n        if ((nbytes != -1)&&(my_nbytes > nbytes)) {\n            my_nbytes = nbytes;\n        }\n\n        i = read(msr->msc_reqbody_fd, msr->msc_reqbody_disk_chunk->data, my_nbytes);\n        if (i < 0) {\n            *error_msg = apr_psprintf(msr->mp, \"Input filter: Error reading from temporary file: %s\",\n                strerror(errno));\n            return -1;\n        }\n\n        *chunk = msr->msc_reqbody_disk_chunk;\n        msr->msc_reqbody_disk_chunk->length = i;\n\n        if (i == 0) return 0; /* No more data available. */\n\n        return 1; /* More data available. */\n    }\n\n    /* Should never happen. */\n    *error_msg = apr_psprintf(msr->mp, \"Internal error, invalid msc_reqbody_storage value: %u\",\n        msr->msc_reqbody_storage);\n\n    return -1;\n}\n\n/**\n *\n */\napr_status_t modsecurity_request_body_clear(modsec_rec *msr, char **error_msg) {\n    *error_msg = NULL;\n\n    /* Release memory we used to store request body data. */\n    if (msr->msc_reqbody_chunks != NULL) {\n        msc_data_chunk **chunks = (msc_data_chunk **)msr->msc_reqbody_chunks->elts;\n        int i;\n\n        for(i = 0; i < msr->msc_reqbody_chunks->nelts; i++) {\n            if (chunks[i]->data != NULL) {\n                free(chunks[i]->data);\n                chunks[i]->data = NULL;\n            }\n        }\n    }\n\n    if (msr->msc_reqbody_storage == MSC_REQBODY_DISK) {\n        int keep_body = 0;\n\n        /* Should we keep the body? This normally\n         * happens when a PUT method was used, which\n         * means the body is actually a file.\n         */\n        if ((msr->upload_remove_files == 0)&&(strcasecmp(msr->request_method, \"PUT\") == 0)) {\n            if (msr->txcfg->upload_dir != NULL) {\n                keep_body = 1;\n            } else {\n                *error_msg = apr_psprintf(msr->mp, \"Input filter: SecUploadDir is undefined, \"\n                    \"unable to store PUT file.\");\n            }\n        }\n\n        /* Deal with a request body stored in a file. */\n\n        if (msr->msc_reqbody_filename != NULL) {\n            if (keep_body) {\n                /* Move request body (which is a file) to the storage area. */\n                const char *put_filename = NULL;\n                const char *put_basename = NULL;\n\n                /* Construct the new filename. */\n                put_basename = file_basename(msr->msc_reqbody_mp, msr->msc_reqbody_filename);\n                if (put_basename == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to generate basename to PUT file \\\"%s\\\"\", log_escape(msr->msc_reqbody_mp, msr->msc_reqbody_filename));\n                    return -1;\n                }\n                put_filename = apr_psprintf(msr->msc_reqbody_mp, \"%s/%s\",\n                    msr->txcfg->upload_dir, put_basename);\n                if (put_filename == NULL) {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to generate filename to PUT file \\\"%s\\\"\", log_escape(msr->msc_reqbody_mp, msr->msc_reqbody_filename));\n                    return -1;\n                }\n\n                if (apr_file_rename(msr->msc_reqbody_filename, put_filename,\n                    msr->msc_reqbody_mp) != APR_SUCCESS)\n                {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to rename file from \\\"%s\\\" to \\\"%s\\\".\",\n                        log_escape(msr->msc_reqbody_mp, msr->msc_reqbody_filename),\n                        log_escape(msr->msc_reqbody_mp, put_filename));\n                    return -1;\n                } else {\n                    msr_log(msr, 4, \"Input filter: Moved file from \\\"%s\\\" to \\\"%s\\\".\",\n                        log_escape(msr->msc_reqbody_mp, msr->msc_reqbody_filename),\n                        log_escape(msr->msc_reqbody_mp, put_filename));\n                }\n            } else {\n                /* make sure it is closed first */\n                if (msr->msc_reqbody_fd > 0) {\n                    close(msr->msc_reqbody_fd);\n                    msr->msc_reqbody_fd = -1;\n                }\n\n                /* We do not want to keep the request body. */\n                if (apr_file_remove(msr->msc_reqbody_filename,\n                    msr->msc_reqbody_mp) != APR_SUCCESS)\n                {\n                    *error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to delete temporary file: %s\",\n                        log_escape(msr->mp, msr->msc_reqbody_filename));\n                    return -1;\n                }\n\n                msr_log(msr, 4, \"Input filter: Removed temporary file: %s\",\n                    msr->msc_reqbody_filename);\n            }\n\n            msr->msc_reqbody_filename = NULL;\n        }\n    }\n\n    if (msr->msc_reqbody_mp != NULL) {\n        apr_pool_destroy(msr->msc_reqbody_mp);\n        msr->msc_reqbody_mp = NULL;\n    }\n\n    return 1;\n}\n"], "filenames": ["apache2/msc_reqbody.c"], "buggy_code_start_loc": [172], "buggy_code_end_loc": [172], "fixing_code_start_loc": [173], "fixing_code_end_loc": [174], "type": "CWE-476", "message": "The ModSecurity module before 2.7.4 for the Apache HTTP Server allows remote attackers to cause a denial of service (NULL pointer dereference, process crash, and disk consumption) via a POST request with a large body and a crafted Content-Type header.", "other": {"cve": {"id": "CVE-2013-2765", "sourceIdentifier": "cve@mitre.org", "published": "2013-07-15T15:55:01.267", "lastModified": "2021-02-10T15:57:02.803", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ModSecurity module before 2.7.4 for the Apache HTTP Server allows remote attackers to cause a denial of service (NULL pointer dereference, process crash, and disk consumption) via a POST request with a large body and a crafted Content-Type header."}, {"lang": "es", "value": "El m\u00f3dulo ModSecurity anterior a 2.7.4 para Apache HTTP Server, permite a atacantes remotos provocar una denegaci\u00f3n de servicio (deferencia a puntero NULO, ca\u00edda de proceso y consumo de disco) a trav\u00e9s de una petici\u00f3n POST con un cuerpo (body) de gran tama\u00f1o y una cabecera Content-Type manipulada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trustwave:modsecurity:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.4", "matchCriteriaId": "506EFFAC-FA4D-438F-941D-35548C270D4C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:apache:http_server:*:*:*:*:*:*:*:*", "matchCriteriaId": "5A6CD1F4-4C0E-4989-A2B3-DC086E8E80A3"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "DE554781-1EB9-446E-911F-6C11970C47F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.2:*:*:*:*:*:*:*", "matchCriteriaId": "D806A17E-B8F9-466D-807D-3F1E77603DC8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.3:*:*:*:*:*:*:*", "matchCriteriaId": "DFBF430B-0832-44B0-AA0E-BA9E467F7668"}]}]}], "references": [{"url": "http://archives.neohapsis.com/archives/bugtraq/2013-05/0125.html", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-08/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-08/msg00025.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-08/msg00031.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://sourceforge.net/mailarchive/message.php?msg_id=30900019", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.modsecurity.org/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.shookalabs.com/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=967615", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/SpiderLabs/ModSecurity/commit/0840b13612a0b7ef1ce7441cf811dcfc6b463fba", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/shookalabs/exploits/blob/master/modsecurity_cve_2013_2765_check.py", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://raw.github.com/SpiderLabs/ModSecurity/master/CHANGES", "source": "cve@mitre.org", "tags": ["Broken Link"]}]}, "github_commit_url": "https://github.com/SpiderLabs/ModSecurity/commit/0840b13612a0b7ef1ce7441cf811dcfc6b463fba"}}