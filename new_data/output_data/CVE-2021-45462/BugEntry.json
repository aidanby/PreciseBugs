{"buggy_code": ["/*\n * Copyright (C) 2019 by Sukchan Lee <acetcom@gmail.com>\n *\n * This file is part of Open5GS.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"gtp-path.h\"\n#include \"pfcp-path.h\"\n\n#define SGWU_GTP_HANDLED     1\n\nstatic ogs_pkbuf_pool_t *packet_pool = NULL;\n\nstatic void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    sgwu_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recv() failed\");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\"[DROP] Invalid GTPU version [%d]\", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\"[RECV] Echo Request from [%s]\", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\"[SEND] Echo Response to [%s]\", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \"ogs_sendto() failed\");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\"[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\"   QFI [0x%x]\",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to peer NF */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\"[DROP] Cannot decode GTPU packet\");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {\n        /* Nothing */\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) {\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_error_indication(pkbuf);\n        if (far) {\n            ogs_assert(true ==\n                ogs_pfcp_up_handle_error_indication(far, &report));\n\n            if (report.type.error_indication_report) {\n                ogs_assert(far->sess);\n                sess = SGWU_SESS(far->sess);\n                ogs_assert(sess);\n\n                ogs_assert(OGS_OK ==\n                    sgwu_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else {\n            ogs_error(\"[DROP] Cannot find FAR by Error-Indication\");\n            ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        }\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        struct ip *ip_h = NULL;\n        ogs_pfcp_object_t *pfcp_object = NULL;\n        ogs_pfcp_sess_t *pfcp_sess = NULL;\n        ogs_pfcp_pdr_t *pdr = NULL;\n\n        ip_h = (struct ip *)pkbuf->data;\n        ogs_assert(ip_h);\n\n        pfcp_object = ogs_pfcp_object_find_by_teid(teid);\n        if (!pfcp_object) {\n            /* TODO : Send Error Indication */\n            goto cleanup;\n        }\n\n        switch(pfcp_object->type) {\n        case OGS_PFCP_OBJ_PDR_TYPE:\n            pdr = (ogs_pfcp_pdr_t *)pfcp_object;\n            ogs_assert(pdr);\n            break;\n        case OGS_PFCP_OBJ_SESS_TYPE:\n            pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object;\n            ogs_assert(pfcp_sess);\n\n            ogs_list_for_each(&pfcp_sess->pdr_list, pdr) {\n                /* Check if Source Interface */\n                if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS &&\n                    pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION)\n                    continue;\n\n                /* Check if TEID */\n                if (teid != pdr->f_teid.teid)\n                    continue;\n\n                /* Check if QFI */\n                if (qfi && pdr->qfi != qfi)\n                    continue;\n\n                /* Check if Rule List in PDR */\n                if (ogs_list_first(&pdr->rule_list) &&\n                    ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL)\n                    continue;\n\n                break;\n            }\n\n            if (!pdr) {\n                /* TODO : Send Error Indication */\n                goto cleanup;\n            }\n\n            break;\n        default:\n            ogs_fatal(\"Unknown type [%d]\", pfcp_object->type);\n            ogs_assert_if_reached();\n        }\n\n        ogs_assert(pdr);\n        ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n        if (report.type.downlink_data_report) {\n            ogs_assert(pdr->sess);\n            ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE);\n            sess = SGWU_SESS(pdr->sess);\n            ogs_assert(sess);\n\n            report.downlink_data.pdr_id = pdr->id;\n            report.downlink_data.qfi = qfi; /* for 5GC */\n\n            ogs_assert(OGS_OK ==\n                sgwu_pfcp_send_session_report_request(sess, &report));\n        }\n    } else {\n        ogs_error(\"[DROP] Invalid GTPU Type [%d]\", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}\n\nint sgwu_gtp_init(void)\n{\n    ogs_pkbuf_config_t config;\n    memset(&config, 0, sizeof config);\n\n    config.cluster_2048_pool = ogs_app()->pool.packet;\n\n    packet_pool = ogs_pkbuf_pool_create(&config);\n\n    return OGS_OK;\n}\n\nvoid sgwu_gtp_final(void)\n{\n    ogs_pkbuf_pool_destroy(packet_pool);\n}\n\nint sgwu_gtp_open(void)\n{\n    ogs_socknode_t *node = NULL;\n    ogs_sock_t *sock = NULL;\n\n    ogs_list_for_each(&ogs_gtp_self()->gtpu_list, node) {\n        sock = ogs_gtp_server(node);\n        if (!sock) return OGS_ERROR;\n\n        if (sock->family == AF_INET)\n            ogs_gtp_self()->gtpu_sock = sock;\n        else if (sock->family == AF_INET6)\n            ogs_gtp_self()->gtpu_sock6 = sock;\n\n        node->poll = ogs_pollset_add(ogs_app()->pollset,\n                OGS_POLLIN, sock->fd, _gtpv1_u_recv_cb, sock);\n        ogs_assert(node->poll);\n    }\n\n    OGS_SETUP_GTPU_SERVER;\n\n    return OGS_OK;\n}\n\nvoid sgwu_gtp_close(void)\n{\n    ogs_socknode_remove_all(&ogs_gtp_self()->gtpu_list);\n}\n", "/*\n * Copyright (C) 2019 by Sukchan Lee <acetcom@gmail.com>\n *\n * This file is part of Open5GS.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"context.h\"\n\n#if HAVE_NETINET_IP_H\n#include <netinet/ip.h>\n#endif\n\n#if HAVE_NETINET_IP6_H\n#include <netinet/ip6.h>\n#endif\n\n#if HAVE_NETINET_IP_ICMP_H\n#include <netinet/ip_icmp.h>\n#endif\n\n#if HAVE_NETINET_ICMP6_H\n#include <netinet/icmp6.h>\n#endif\n\n#include \"event.h\"\n#include \"gtp-path.h\"\n#include \"pfcp-path.h\"\n#include \"s5c-build.h\"\n\nstatic bool check_if_router_solicit(ogs_pkbuf_t *pkbuf);\nstatic void send_router_advertisement(smf_sess_t *sess, uint8_t *ip6_dst);\n\nstatic void bearer_timeout(ogs_gtp_xact_t *xact, void *data);\n\nstatic void _gtpv2_c_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    smf_event_t *e = NULL;\n    int rv;\n    ssize_t size;\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n    ogs_gtp_node_t *gnode = NULL;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recvfrom() failed\");\n        ogs_pkbuf_free(pkbuf);\n        return;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    e = smf_event_new(SMF_EVT_S5C_MESSAGE);\n    gnode = ogs_gtp_node_find_by_addr(&smf_self()->sgw_s5c_list, &from);\n    if (!gnode) {\n        gnode = ogs_gtp_node_add_by_addr(&smf_self()->sgw_s5c_list, &from);\n        ogs_assert(gnode);\n        gnode->sock = data;\n    }\n    ogs_assert(e);\n    e->gnode = gnode;\n    e->pkbuf = pkbuf;\n\n    rv = ogs_queue_push(ogs_app()->queue, e);\n    if (rv != OGS_OK) {\n        ogs_warn(\"ogs_queue_push() failed:%d\", (int)rv);\n        ogs_pkbuf_free(e->pkbuf);\n        smf_event_free(e);\n    }\n}\n\nstatic void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recv() failed\");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\"[DROP] Invalid GTPU version [%d]\", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\"[RECV] Echo Request from [%s]\", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\"[SEND] Echo Response to [%s]\", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \"ogs_sendto() failed\");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\"[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\"   QFI [0x%x]\",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to TUN interface */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\"[DROP] Cannot decode GTPU packet\");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        smf_sess_t *sess = NULL;\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_teid(teid);\n        if (!far) {\n            ogs_error(\"No FAR for TEID [%d]\", teid);\n            goto cleanup;\n        }\n\n        if (far->dst_if != OGS_PFCP_INTERFACE_CP_FUNCTION) {\n            ogs_error(\"Invalid Destination Interface [%d]\", far->dst_if);\n            goto cleanup;\n        }\n\n        if (qfi) {\n            ogs_error(\"QFI[%d] Found\", qfi);\n            goto cleanup;\n        }\n\n        ogs_assert(far->sess);\n        sess = SMF_SESS(far->sess);\n        ogs_assert(sess);\n\n        if (sess->ipv6 && check_if_router_solicit(pkbuf) == true) {\n            struct ip6_hdr *ip6_h = (struct ip6_hdr *)pkbuf->data;\n            ogs_assert(ip6_h);\n            send_router_advertisement(sess, ip6_h->ip6_src.s6_addr);\n        }\n    } else {\n        ogs_error(\"[DROP] Invalid GTPU Type [%d]\", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}\n\nint smf_gtp_open(void)\n{\n    ogs_socknode_t *node = NULL;\n    ogs_sock_t *sock = NULL;\n\n    ogs_list_for_each(&ogs_gtp_self()->gtpc_list, node) {\n        sock = ogs_gtp_server(node);\n        if (!sock) return OGS_ERROR;\n        \n        node->poll = ogs_pollset_add(ogs_app()->pollset,\n                OGS_POLLIN, sock->fd, _gtpv2_c_recv_cb, sock);\n        ogs_assert(node->poll);\n    }\n    ogs_list_for_each(&ogs_gtp_self()->gtpc_list6, node) {\n        sock = ogs_gtp_server(node);\n        if (!sock) return OGS_ERROR;\n\n        node->poll = ogs_pollset_add(ogs_app()->pollset,\n                OGS_POLLIN, sock->fd, _gtpv2_c_recv_cb, sock);\n        ogs_assert(node->poll);\n    }\n\n    OGS_SETUP_GTPC_SERVER;\n\n    ogs_list_for_each(&ogs_gtp_self()->gtpu_list, node) {\n        sock = ogs_gtp_server(node);\n        if (!sock) return OGS_ERROR;\n\n        if (sock->family == AF_INET)\n            ogs_gtp_self()->gtpu_sock = sock;\n        else if (sock->family == AF_INET6)\n            ogs_gtp_self()->gtpu_sock6 = sock;\n\n        node->poll = ogs_pollset_add(ogs_app()->pollset,\n                OGS_POLLIN, sock->fd, _gtpv1_u_recv_cb, sock);\n        ogs_assert(node->poll);\n    }\n\n    OGS_SETUP_GTPU_SERVER;\n\n    /* Fetch link-local address for router advertisement */\n    if (ogs_gtp_self()->link_local_addr)\n        ogs_freeaddrinfo(ogs_gtp_self()->link_local_addr);\n    if (ogs_gtp_self()->gtpu_addr6)\n        ogs_gtp_self()->link_local_addr =\n            ogs_link_local_addr_by_sa(ogs_gtp_self()->gtpu_addr6);\n\n    return OGS_OK;\n}\n\nvoid smf_gtp_close(void)\n{\n    if (ogs_gtp_self()->link_local_addr)\n        ogs_freeaddrinfo(ogs_gtp_self()->link_local_addr);\n\n    ogs_socknode_remove_all(&ogs_gtp_self()->gtpc_list);\n    ogs_socknode_remove_all(&ogs_gtp_self()->gtpc_list6);\n\n    ogs_socknode_remove_all(&ogs_gtp_self()->gtpu_list);\n}\n\nint smf_gtp_send_create_session_response(\n        smf_sess_t *sess, ogs_gtp_xact_t *xact)\n{\n    int rv;\n    ogs_gtp_header_t h;\n    ogs_pkbuf_t *pkbuf = NULL;\n\n    ogs_assert(sess);\n    ogs_assert(xact);\n\n    memset(&h, 0, sizeof(ogs_gtp_header_t));\n    h.type = OGS_GTP_CREATE_SESSION_RESPONSE_TYPE;\n    h.teid = sess->sgw_s5c_teid;\n\n    pkbuf = smf_s5c_build_create_session_response(h.type, sess);\n    ogs_expect_or_return_val(pkbuf, OGS_ERROR);\n\n    rv = ogs_gtp_xact_update_tx(xact, &h, pkbuf);\n    ogs_expect_or_return_val(rv == OGS_OK, OGS_ERROR);\n\n    rv = ogs_gtp_xact_commit(xact);\n    ogs_expect(rv == OGS_OK);\n\n    return rv;\n}\n\nint smf_gtp_send_delete_session_response(\n        smf_sess_t *sess, ogs_gtp_xact_t *xact)\n{\n    int rv;\n    ogs_gtp_header_t h;\n    ogs_pkbuf_t *pkbuf = NULL;\n\n    ogs_assert(xact);\n    ogs_assert(sess);\n\n    memset(&h, 0, sizeof(ogs_gtp_header_t));\n    h.type = OGS_GTP_DELETE_SESSION_RESPONSE_TYPE;\n    h.teid = sess->sgw_s5c_teid;\n\n    pkbuf = smf_s5c_build_delete_session_response(h.type, sess);\n    ogs_expect_or_return_val(pkbuf, OGS_ERROR);\n\n    rv = ogs_gtp_xact_update_tx(xact, &h, pkbuf);\n    ogs_expect_or_return_val(rv == OGS_OK, OGS_ERROR);\n\n    rv = ogs_gtp_xact_commit(xact);\n    ogs_expect(rv == OGS_OK);\n\n    return rv;\n}\n\nint smf_gtp_send_delete_bearer_request(\n        smf_bearer_t *bearer, uint8_t pti, uint8_t cause_value)\n{\n    int rv;\n\n    ogs_gtp_xact_t *xact = NULL;\n    ogs_gtp_header_t h;\n    ogs_pkbuf_t *pkbuf = NULL;\n\n    smf_sess_t *sess = NULL;\n\n    ogs_assert(bearer);\n    sess = bearer->sess;\n    ogs_assert(sess);\n\n    memset(&h, 0, sizeof(ogs_gtp_header_t));\n    h.type = OGS_GTP_DELETE_BEARER_REQUEST_TYPE;\n    h.teid = sess->sgw_s5c_teid;\n\n    pkbuf = smf_s5c_build_delete_bearer_request(\n                h.type, bearer, pti, cause_value);\n    ogs_expect_or_return_val(pkbuf, OGS_ERROR);\n\n    xact = ogs_gtp_xact_local_create(\n            sess->gnode, &h, pkbuf, bearer_timeout, bearer);\n    ogs_expect_or_return_val(xact, OGS_ERROR);\n\n    rv = ogs_gtp_xact_commit(xact);\n    ogs_expect(rv == OGS_OK);\n\n    return rv;\n}\n\nstatic bool check_if_router_solicit(ogs_pkbuf_t *pkbuf)\n{\n    struct ip *ip_h = NULL;\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n    ogs_assert(pkbuf->data);\n\n    ip_h = (struct ip *)pkbuf->data;\n    if (ip_h->ip_v == 6) {\n        struct ip6_hdr *ip6_h = (struct ip6_hdr *)pkbuf->data;\n        if (ip6_h->ip6_nxt == IPPROTO_ICMPV6) {\n            struct icmp6_hdr *icmp_h =\n                (struct icmp6_hdr *)(pkbuf->data + sizeof(struct ip6_hdr));\n            if (icmp_h->icmp6_type == ND_ROUTER_SOLICIT) {\n                ogs_debug(\"      Router Solict\");\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nstatic void send_router_advertisement(smf_sess_t *sess, uint8_t *ip6_dst)\n{\n    int rv;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n\n    ogs_pfcp_pdr_t *pdr = NULL;\n    ogs_pfcp_ue_ip_t *ue_ip = NULL;\n    ogs_pfcp_subnet_t *subnet = NULL;\n    char ipstr[OGS_ADDRSTRLEN];\n\n    ogs_ipsubnet_t src_ipsub;\n    uint16_t plen = 0;\n    uint8_t nxt = 0;\n    uint8_t *p = NULL;\n    struct ip6_hdr *ip6_h =  NULL;\n    struct nd_router_advert *advert_h = NULL;\n    struct nd_opt_prefix_info *prefix = NULL;\n\n    ogs_assert(sess);\n    ue_ip = sess->ipv6;\n    ogs_assert(ue_ip);\n    subnet = ue_ip->subnet;\n    ogs_assert(subnet);\n\n    /* Fetch link-local address for router advertisement */\n    if (ogs_gtp_self()->link_local_addr) {\n        OGS_ADDR(ogs_gtp_self()->link_local_addr, ipstr);\n        rv = ogs_ipsubnet(&src_ipsub, ipstr, NULL);\n        ogs_expect_or_return(rv == OGS_OK);\n    } else {\n        /* For the case of loopback used for GTPU link-local address is not\n         * available, hence set the source IP to fe80::1\n        */\n        memset(src_ipsub.sub, 0, sizeof(src_ipsub.sub));\n        src_ipsub.sub[0] = htobe32(0xfe800000);\n        src_ipsub.sub[3] = htobe32(0x00000001);\n    }\n\n    ogs_debug(\"      Build Router Advertisement\");\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_GTPV1U_5GC_HEADER_LEN+200);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_reserve(pkbuf, OGS_GTPV1U_5GC_HEADER_LEN);\n    ogs_pkbuf_put(pkbuf, 200);\n    pkbuf->len = sizeof *ip6_h + sizeof *advert_h + sizeof *prefix;\n    memset(pkbuf->data, 0, pkbuf->len);\n\n    p = (uint8_t *)pkbuf->data;\n    ip6_h = (struct ip6_hdr *)p;\n    advert_h = (struct nd_router_advert *)((uint8_t *)ip6_h + sizeof *ip6_h);\n    prefix = (struct nd_opt_prefix_info *)\n        ((uint8_t*)advert_h + sizeof *advert_h);\n\n    advert_h->nd_ra_type = ND_ROUTER_ADVERT;\n    advert_h->nd_ra_code = 0;\n    advert_h->nd_ra_curhoplimit = 64;\n    advert_h->nd_ra_flags_reserved = 0;\n    advert_h->nd_ra_router_lifetime = htobe16(64800);  /* 64800s */\n    advert_h->nd_ra_reachable = 0;\n    advert_h->nd_ra_retransmit = 0;\n\n    prefix->nd_opt_pi_type = ND_OPT_PREFIX_INFORMATION;\n    prefix->nd_opt_pi_len = 4; /* 32bytes */\n    prefix->nd_opt_pi_prefix_len = OGS_IPV6_DEFAULT_PREFIX_LEN;\n    prefix->nd_opt_pi_flags_reserved =\n        ND_OPT_PI_FLAG_ONLINK|ND_OPT_PI_FLAG_AUTO;\n    prefix->nd_opt_pi_valid_time = htobe32(0xffffffff); /* Infinite */\n    prefix->nd_opt_pi_preferred_time = htobe32(0xffffffff); /* Infinite */\n    memcpy(prefix->nd_opt_pi_prefix.s6_addr,\n            ue_ip->addr, (OGS_IPV6_DEFAULT_PREFIX_LEN >> 3));\n\n    /* For IPv6 Pseudo-Header */\n    plen = htobe16(sizeof *advert_h + sizeof *prefix);\n    nxt = IPPROTO_ICMPV6;\n\n    memcpy(p, src_ipsub.sub, sizeof src_ipsub.sub);\n    p += sizeof src_ipsub.sub;\n    memcpy(p, ip6_dst, OGS_IPV6_LEN);\n    p += OGS_IPV6_LEN;\n    p += 2; memcpy(p, &plen, 2); p += 2;\n    p += 3; *p = nxt; p += 1;\n    advert_h->nd_ra_cksum = ogs_in_cksum((uint16_t *)pkbuf->data, pkbuf->len);\n\n    ip6_h->ip6_flow = htobe32(0x60000001);\n    ip6_h->ip6_plen = plen;\n    ip6_h->ip6_nxt = nxt;  /* ICMPv6 */\n    ip6_h->ip6_hlim = 0xff;\n    memcpy(ip6_h->ip6_src.s6_addr, src_ipsub.sub, sizeof src_ipsub.sub);\n    memcpy(ip6_h->ip6_dst.s6_addr, ip6_dst, OGS_IPV6_LEN);\n\n    ogs_list_for_each(&sess->pfcp.pdr_list, pdr) {\n        if (pdr->src_if == OGS_PFCP_INTERFACE_CP_FUNCTION && pdr->gnode) {\n            ogs_gtp_header_t gtp_hdesc;\n            ogs_gtp_extension_header_t ext_hdesc;\n\n            memset(&gtp_hdesc, 0, sizeof(gtp_hdesc));\n            memset(&ext_hdesc, 0, sizeof(ext_hdesc));\n\n            gtp_hdesc.type = OGS_GTPU_MSGTYPE_GPDU;\n            gtp_hdesc.teid = pdr->f_teid.teid;\n\n            ogs_gtp_send_user_plane(pdr->gnode, &gtp_hdesc, &ext_hdesc, pkbuf);\n\n            ogs_debug(\"      Send Router Advertisement\");\n            break;\n        }\n    }\n\n    ogs_pkbuf_free(pkbuf);\n}\n\nstatic void bearer_timeout(ogs_gtp_xact_t *xact, void *data)\n{\n    smf_bearer_t *bearer = data;\n    smf_sess_t *sess = NULL;\n    smf_ue_t *smf_ue = NULL;\n    uint8_t type = 0;\n\n    ogs_assert(bearer);\n    sess = bearer->sess;\n    ogs_assert(sess);\n    smf_ue = sess->smf_ue;\n    ogs_assert(smf_ue);\n\n    type = xact->seq[0].type;\n\n    switch (type) {\n    case OGS_GTP_DELETE_BEARER_REQUEST_TYPE:\n        ogs_error(\"[%s] No Delete Bearer Response\", smf_ue->imsi_bcd);\n        if (!smf_bearer_cycle(bearer)) {\n            ogs_warn(\"[%s] Bearer has already been removed\", smf_ue->imsi_bcd);\n            break;\n        }\n\n        ogs_assert(OGS_OK ==\n            smf_epc_pfcp_send_bearer_modification_request(\n                bearer, NULL, OGS_PFCP_MODIFY_REMOVE,\n                OGS_NAS_PROCEDURE_TRANSACTION_IDENTITY_UNASSIGNED,\n                OGS_GTP_CAUSE_UNDEFINED_VALUE));\n        break;\n    default:\n        ogs_error(\"GTP Timeout : IMSI[%s] Message-Type[%d]\",\n                smf_ue->imsi_bcd, type);\n        break;\n    }\n}\n", "/*\n * Copyright (C) 2019 by Sukchan Lee <acetcom@gmail.com>\n *\n * This file is part of Open5GS.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"context.h\"\n\n#if HAVE_NETINET_IP_H\n#include <netinet/ip.h>\n#endif\n\n#if HAVE_NETINET_IP6_H\n#include <netinet/ip6.h>\n#endif\n\n#if HAVE_NETINET_IP_ICMP_H\n#include <netinet/ip_icmp.h>\n#endif\n\n#if HAVE_NETINET_ICMP6_H\n#include <netinet/icmp6.h>\n#endif\n\n#if HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n\n#if HAVE_NET_IF_DL_H\n#include <net/if_dl.h>\n#endif\n\n#if HAVE_IFADDRS_H\n#include <ifaddrs.h>\n#endif\n\n#include \"arp-nd.h\"\n#include \"event.h\"\n#include \"gtp-path.h\"\n#include \"pfcp-path.h\"\n#include \"rule-match.h\"\n\n#define UPF_GTP_HANDLED     1\n\nconst uint8_t proxy_mac_addr[] = { 0x0e, 0x00, 0x00, 0x00, 0x00, 0x01 };\n\nstatic ogs_pkbuf_pool_t *packet_pool = NULL;\n\nstatic void upf_gtp_handle_multicast(ogs_pkbuf_t *recvbuf);\n\nstatic uint16_t _get_eth_type(uint8_t *data, uint len) {\n    if (len > ETHER_HDR_LEN) {\n        struct ether_header *hdr = (struct ether_header*)data;\n        return htobe16(hdr->ether_type);\n    }\n    return 0;\n}\n\nstatic void _gtpv1_tun_recv_common_cb(\n        short when, ogs_socket_t fd, bool has_eth, void *data)\n{\n    ogs_pkbuf_t *recvbuf = NULL;\n\n    upf_sess_t *sess = NULL;\n    ogs_pfcp_pdr_t *pdr = NULL;\n    ogs_pfcp_pdr_t *fallback_pdr = NULL;\n    ogs_pfcp_far_t *far = NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    recvbuf = ogs_tun_read(fd, packet_pool);\n    if (!recvbuf) {\n        ogs_warn(\"ogs_tun_read() failed\");\n        return;\n    }\n\n    if (has_eth) {\n        ogs_pkbuf_t *replybuf = NULL;\n        uint16_t eth_type = _get_eth_type(recvbuf->data, recvbuf->len);\n        uint8_t size;\n\n        if (eth_type == ETHERTYPE_ARP) {\n            if (is_arp_req(recvbuf->data, recvbuf->len)) {\n                replybuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN);\n                ogs_assert(replybuf);\n                ogs_pkbuf_reserve(replybuf, OGS_TUN_MAX_HEADROOM);\n                ogs_pkbuf_put(replybuf, OGS_MAX_PKT_LEN-OGS_TUN_MAX_HEADROOM);\n                size = arp_reply(replybuf->data, recvbuf->data, recvbuf->len,\n                    proxy_mac_addr);\n                ogs_pkbuf_trim(replybuf, size);\n                ogs_info(\"[SEND] reply to ARP request: %u\", size);\n            } else {\n                goto cleanup;\n            }\n        } else if (eth_type == ETHERTYPE_IPV6 &&\n                    is_nd_req(recvbuf->data, recvbuf->len)) {\n            replybuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN);\n            ogs_assert(replybuf);\n            ogs_pkbuf_reserve(replybuf, OGS_TUN_MAX_HEADROOM);\n            ogs_pkbuf_put(replybuf, OGS_MAX_PKT_LEN-OGS_TUN_MAX_HEADROOM);\n            size = nd_reply(replybuf->data, recvbuf->data, recvbuf->len,\n                proxy_mac_addr);\n            ogs_pkbuf_trim(replybuf, size);\n            ogs_info(\"[SEND] reply to ND solicit: %u\", size);\n        }\n        if (replybuf) {\n            if (ogs_tun_write(fd, replybuf) != OGS_OK)\n                ogs_warn(\"ogs_tun_write() for reply failed\");\n            goto cleanup;\n        }\n        if (eth_type != ETHERTYPE_IP && eth_type != ETHERTYPE_IPV6) {\n            ogs_error(\"[DROP] Invalid eth_type [%x]]\", eth_type);\n            ogs_log_hexdump(OGS_LOG_ERROR, recvbuf->data, recvbuf->len);\n            goto cleanup;\n        }\n        ogs_pkbuf_pull(recvbuf, ETHER_HDR_LEN);\n    }\n\n    sess = upf_sess_find_by_ue_ip_address(recvbuf);\n    if (!sess)\n        goto cleanup;\n\n    ogs_list_for_each(&sess->pfcp.pdr_list, pdr) {\n        far = pdr->far;\n        ogs_assert(far);\n\n        /* Check if PDR is Downlink */\n        if (pdr->src_if != OGS_PFCP_INTERFACE_CORE)\n            continue;\n\n        /* Save the Fallback PDR : Lowest precedence downlink PDR */\n        fallback_pdr = pdr;\n\n        /* Check if FAR is Downlink */\n        if (far->dst_if != OGS_PFCP_INTERFACE_ACCESS)\n            continue;\n\n        /* Check if Outer header creation */\n        if (far->outer_header_creation.ip4 == 0 &&\n            far->outer_header_creation.ip6 == 0 &&\n            far->outer_header_creation.udp4 == 0 &&\n            far->outer_header_creation.udp6 == 0 &&\n            far->outer_header_creation.gtpu4 == 0 &&\n            far->outer_header_creation.gtpu6 == 0)\n            continue;\n\n        /* Check if Rule List in PDR */\n        if (ogs_list_first(&pdr->rule_list) &&\n            ogs_pfcp_pdr_rule_find_by_packet(pdr, recvbuf) == NULL)\n            continue;\n\n        break;\n    }\n\n    if (!pdr)\n        pdr = fallback_pdr;\n\n    if (!pdr) {\n        if (ogs_app()->parameter.multicast) {\n            upf_gtp_handle_multicast(recvbuf);\n        }\n        goto cleanup;\n    }\n\n    ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, recvbuf, &report));\n\n    if (report.type.downlink_data_report) {\n        ogs_assert(pdr->sess);\n        sess = UPF_SESS(pdr->sess);\n        ogs_assert(sess);\n\n        report.downlink_data.pdr_id = pdr->id;\n        if (pdr->qer && pdr->qer->qfi)\n            report.downlink_data.qfi = pdr->qer->qfi; /* for 5GC */\n\n        ogs_assert(OGS_OK ==\n            upf_pfcp_send_session_report_request(sess, &report));\n    }\n\ncleanup:\n    ogs_pkbuf_free(recvbuf);\n}\n\nstatic void _gtpv1_tun_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    _gtpv1_tun_recv_common_cb(when, fd, false, data);\n}\n\nstatic void _gtpv1_tun_recv_eth_cb(short when, ogs_socket_t fd, void *data)\n{\n    _gtpv1_tun_recv_common_cb(when, fd, true, data);\n}\n\nstatic void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    upf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_reserve(pkbuf, OGS_TUN_MAX_HEADROOM);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN-OGS_TUN_MAX_HEADROOM);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recv() failed\");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\"[DROP] Invalid GTPU version [%d]\", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\"[RECV] Echo Request from [%s]\", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\"[SEND] Echo Response to [%s]\", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \"ogs_sendto() failed\");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\"[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\"   QFI [0x%x]\",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to TUN interface */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\"[DROP] Cannot decode GTPU packet\");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {\n        /* Nothing */\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) {\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_error_indication(pkbuf);\n        if (far) {\n            ogs_assert(true ==\n                ogs_pfcp_up_handle_error_indication(far, &report));\n\n            if (report.type.error_indication_report) {\n                ogs_assert(far->sess);\n                sess = UPF_SESS(far->sess);\n                ogs_assert(sess);\n\n                ogs_assert(OGS_OK ==\n                    upf_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else {\n            ogs_error(\"[DROP] Cannot find FAR by Error-Indication\");\n            ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        }\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        struct ip *ip_h = NULL;\n        ogs_pfcp_object_t *pfcp_object = NULL;\n        ogs_pfcp_sess_t *pfcp_sess = NULL;\n        ogs_pfcp_pdr_t *pdr = NULL;\n        ogs_pfcp_far_t *far = NULL;\n\n        ogs_pfcp_subnet_t *subnet = NULL;\n        ogs_pfcp_dev_t *dev = NULL;\n\n        ip_h = (struct ip *)pkbuf->data;\n        ogs_assert(ip_h);\n\n        pfcp_object = ogs_pfcp_object_find_by_teid(teid);\n        if (!pfcp_object) {\n            /* TODO : Send Error Indication */\n            goto cleanup;\n        }\n\n        switch(pfcp_object->type) {\n        case OGS_PFCP_OBJ_PDR_TYPE:\n            pdr = (ogs_pfcp_pdr_t *)pfcp_object;\n            ogs_assert(pdr);\n            break;\n        case OGS_PFCP_OBJ_SESS_TYPE:\n            pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object;\n            ogs_assert(pfcp_sess);\n\n            ogs_list_for_each(&pfcp_sess->pdr_list, pdr) {\n\n                /* Check if Source Interface */\n                if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS &&\n                    pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION)\n                    continue;\n\n                /* Check if TEID */\n                if (teid != pdr->f_teid.teid)\n                    continue;\n\n                /* Check if QFI */\n                if (qfi && pdr->qfi != qfi)\n                    continue;\n\n                /* Check if Rule List in PDR */\n                if (ogs_list_first(&pdr->rule_list) &&\n                    ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL)\n                    continue;\n\n                break;\n            }\n\n            if (!pdr) {\n                /* TODO : Send Error Indication */\n                goto cleanup;\n            }\n\n            break;\n        default:\n            ogs_fatal(\"Unknown type [%d]\", pfcp_object->type);\n            ogs_assert_if_reached();\n        }\n\n        ogs_assert(pdr);\n        ogs_assert(pdr->sess);\n        ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE);\n\n        sess = UPF_SESS(pdr->sess);\n        ogs_assert(sess);\n\n        far = pdr->far;\n        ogs_assert(far);\n\n        if (far->dst_if == OGS_PFCP_INTERFACE_CORE) {\n            uint16_t eth_type = 0;\n\n            if (ip_h->ip_v == 4 && sess->ipv4) {\n                subnet = sess->ipv4->subnet;\n                eth_type = ETHERTYPE_IP;\n            } else if (ip_h->ip_v == 6 && sess->ipv6) {\n                subnet = sess->ipv6->subnet;\n                eth_type = ETHERTYPE_IPV6;\n            }\n\n            if (!subnet) {\n#if 0 /* It's redundant log message */\n                ogs_error(\"[DROP] Cannot find subnet V:%d, IPv4:%p, IPv6:%p\",\n                        ip_h->ip_v, sess->ipv4, sess->ipv6);\n                ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n#endif\n                goto cleanup;\n            }\n\n            dev = subnet->dev;\n            ogs_assert(dev);\n\n            if (dev->is_tap) {\n                ogs_assert(eth_type);\n                eth_type = htobe16(eth_type);\n                ogs_pkbuf_push(pkbuf, sizeof(eth_type));\n                memcpy(pkbuf->data, &eth_type, sizeof(eth_type));\n                ogs_pkbuf_push(pkbuf, ETHER_ADDR_LEN);\n                memcpy(pkbuf->data, proxy_mac_addr, ETHER_ADDR_LEN);\n                ogs_pkbuf_push(pkbuf, ETHER_ADDR_LEN);\n                memcpy(pkbuf->data, dev->mac_addr, ETHER_ADDR_LEN);\n            }\n\n            /* TODO: if destined to another UE, hairpin back out. */\n            if (ogs_tun_write(dev->fd, pkbuf) != OGS_OK)\n                ogs_warn(\"ogs_tun_write() failed\");\n\n        } else if (far->dst_if == OGS_PFCP_INTERFACE_ACCESS) {\n            ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n            if (report.type.downlink_data_report) {\n                ogs_error(\"Indirect Data Fowarding Buffered\");\n\n                report.downlink_data.pdr_id = pdr->id;\n                if (pdr->qer && pdr->qer->qfi)\n                    report.downlink_data.qfi = pdr->qer->qfi; /* for 5GC */\n\n                ogs_assert(OGS_OK ==\n                    upf_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else if (far->dst_if == OGS_PFCP_INTERFACE_CP_FUNCTION) {\n\n            if (!far->gnode) {\n                ogs_error(\"No Outer Header Creation in FAR\");\n                goto cleanup;\n            }\n\n            if ((far->apply_action & OGS_PFCP_APPLY_ACTION_FORW) == 0) {\n                ogs_error(\"Not supported Apply Action [0x%x]\",\n                            far->apply_action);\n                goto cleanup;\n            }\n\n            ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n            ogs_assert(report.type.downlink_data_report == 0);\n\n        } else {\n            ogs_fatal(\"Not implemented : FAR-DST_IF[%d]\", far->dst_if);\n            ogs_assert_if_reached();\n        }\n    } else {\n        ogs_error(\"[DROP] Invalid GTPU Type [%d]\", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}\n\nint upf_gtp_init(void)\n{\n    ogs_pkbuf_config_t config;\n    memset(&config, 0, sizeof config);\n\n    config.cluster_2048_pool = ogs_app()->pool.packet;\n\n    packet_pool = ogs_pkbuf_pool_create(&config);\n\n    return OGS_OK;\n}\n\nvoid upf_gtp_final(void)\n{\n    ogs_pkbuf_pool_destroy(packet_pool);\n}\n\nstatic void _get_dev_mac_addr(char *ifname, uint8_t *mac_addr)\n{\n#ifdef SIOCGIFHWADDR\n    int fd = socket(PF_INET, SOCK_DGRAM, 0);\n    ogs_assert(fd);\n    struct ifreq req;\n    memset(&req, 0, sizeof(req));\n    strncpy(req.ifr_name, ifname, IF_NAMESIZE-1);\n    ogs_assert(ioctl(fd, SIOCGIFHWADDR, &req) == 0);\n    memcpy(mac_addr, req.ifr_hwaddr.sa_data, ETHER_ADDR_LEN);\n#else\n    struct ifaddrs *ifap;\n    ogs_assert(getifaddrs(&ifap) == 0);\n    struct ifaddrs *p;\n    for (p = ifap; p; p = p->ifa_next) {\n        if (strncmp(ifname, p->ifa_name, IF_NAMESIZE-1) == 0) {\n            struct sockaddr_dl* sdp = (struct sockaddr_dl*) p->ifa_addr;\n            memcpy(mac_addr, sdp->sdl_data + sdp->sdl_nlen, ETHER_ADDR_LEN);\n            freeifaddrs(ifap);\n            return;\n        }\n    }\n    ogs_assert(0); /* interface not found. */\n#endif\n}\n\nint upf_gtp_open(void)\n{\n    ogs_pfcp_dev_t *dev = NULL;\n    ogs_pfcp_subnet_t *subnet = NULL;\n    ogs_socknode_t *node = NULL;\n    ogs_sock_t *sock = NULL;\n    int rc;\n\n    ogs_list_for_each(&ogs_gtp_self()->gtpu_list, node) {\n        sock = ogs_gtp_server(node);\n        if (!sock) return OGS_ERROR;\n\n        if (sock->family == AF_INET)\n            ogs_gtp_self()->gtpu_sock = sock;\n        else if (sock->family == AF_INET6)\n            ogs_gtp_self()->gtpu_sock6 = sock;\n\n        node->poll = ogs_pollset_add(ogs_app()->pollset,\n                OGS_POLLIN, sock->fd, _gtpv1_u_recv_cb, sock);\n        ogs_assert(node->poll);\n    }\n\n    OGS_SETUP_GTPU_SERVER;\n\n    /* NOTE : tun device can be created via following command.\n     *\n     * $ sudo ip tuntap add name ogstun mode tun\n     *\n     * Also, before running upf, assign the one IP from IP pool of UE \n     * to ogstun. The IP should not be assigned to UE\n     *\n     * $ sudo ifconfig ogstun 45.45.0.1/16 up\n     *\n     */\n\n    /* Open Tun interface */\n    ogs_list_for_each(&ogs_pfcp_self()->dev_list, dev) {\n        dev->is_tap = strstr(dev->ifname, \"tap\");\n        dev->fd = ogs_tun_open(dev->ifname, OGS_MAX_IFNAME_LEN, dev->is_tap);\n        if (dev->fd == INVALID_SOCKET) {\n            ogs_error(\"tun_open(dev:%s) failed\", dev->ifname);\n            return OGS_ERROR;\n        }\n\n        if (dev->is_tap) {\n            _get_dev_mac_addr(dev->ifname, dev->mac_addr);\n            dev->poll = ogs_pollset_add(ogs_app()->pollset,\n                    OGS_POLLIN, dev->fd, _gtpv1_tun_recv_eth_cb, NULL);\n            ogs_assert(dev->poll);\n        } else {\n            dev->poll = ogs_pollset_add(ogs_app()->pollset,\n                    OGS_POLLIN, dev->fd, _gtpv1_tun_recv_cb, NULL);\n            ogs_assert(dev->poll);\n        }\n\n        ogs_assert(dev->poll);\n    }\n\n    /* \n     * On Linux, it is possible to create a persistent tun/tap \n     * interface which will continue to exist even if open5gs quit, \n     * although this is normally not required. \n     * It can be useful to set up a tun/tap interface owned \n     * by a non-root user, so open5gs can be started without \n     * needing any root privileges at all.\n     */\n\n    /* Set P-to-P IP address with Netmask\n     * Note that Linux will skip this configuration */\n    ogs_list_for_each(&ogs_pfcp_self()->subnet_list, subnet) {\n        ogs_assert(subnet->dev);\n        rc = ogs_tun_set_ip(subnet->dev->ifname, &subnet->gw, &subnet->sub);\n        if (rc != OGS_OK) {\n            ogs_error(\"ogs_tun_set_ip(dev:%s) failed\", subnet->dev->ifname);\n            return OGS_ERROR;\n        }\n    }\n\n    return OGS_OK;\n}\n\nvoid upf_gtp_close(void)\n{\n    ogs_pfcp_dev_t *dev = NULL;\n\n    ogs_socknode_remove_all(&ogs_gtp_self()->gtpu_list);\n\n    ogs_list_for_each(&ogs_pfcp_self()->dev_list, dev) {\n        if (dev->poll)\n            ogs_pollset_remove(dev->poll);\n        ogs_closesocket(dev->fd);\n    }\n}\n\nstatic void upf_gtp_handle_multicast(ogs_pkbuf_t *recvbuf)\n{\n    struct ip *ip_h =  NULL;\n    struct ip6_hdr *ip6_h =  NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    ip_h = (struct ip *)recvbuf->data;\n    if (ip_h->ip_v == 6) {\n#if COMPILE_ERROR_IN_MAC_OS_X  /* Compiler error in Mac OS X platform */\n        ip6_h = (struct ip6_hdr *)recvbuf->data;\n        if (IN6_IS_ADDR_MULTICAST(&ip6_h->ip6_dst))\n#else\n        struct in6_addr ip6_dst;\n        ip6_h = (struct ip6_hdr *)recvbuf->data;\n        memcpy(&ip6_dst, &ip6_h->ip6_dst, sizeof(struct in6_addr));\n        if (IN6_IS_ADDR_MULTICAST(&ip6_dst))\n#endif\n        {\n            upf_sess_t *sess = NULL;\n\n            /* IPv6 Multicast */\n            ogs_list_for_each(&upf_self()->sess_list, sess) {\n                if (sess->ipv6) {\n                    /* PDN IPv6 is avaiable */\n                    ogs_pfcp_pdr_t *pdr = NULL;\n\n                    ogs_list_for_each(&sess->pfcp.pdr_list, pdr) {\n                        if (pdr->src_if == OGS_PFCP_INTERFACE_CORE) {\n                            ogs_assert(true ==\n                                ogs_pfcp_up_handle_pdr(pdr, recvbuf, &report));\n                            break;\n                        }\n                    }\n\n                    return;\n                }\n            }\n        }\n    }\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2019 by Sukchan Lee <acetcom@gmail.com>\n *\n * This file is part of Open5GS.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"gtp-path.h\"\n#include \"pfcp-path.h\"\n\n#define SGWU_GTP_HANDLED     1\n\nstatic ogs_pkbuf_pool_t *packet_pool = NULL;\n\nstatic void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    sgwu_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recv() failed\");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\"[DROP] Invalid GTPU version [%d]\", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\"[RECV] Echo Request from [%s]\", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\"[SEND] Echo Response to [%s]\", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \"ogs_sendto() failed\");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\"[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\"   QFI [0x%x]\",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to peer NF */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\"[DROP] Cannot decode GTPU packet\");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    if (gtp_h->type != OGS_GTPU_MSGTYPE_END_MARKER &&\n        pkbuf->len <= len) {\n        ogs_error(\"[DROP] Small GTPU packet(type:%d len:%d)\", gtp_h->type, len);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {\n        /* Nothing */\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) {\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_error_indication(pkbuf);\n        if (far) {\n            ogs_assert(true ==\n                ogs_pfcp_up_handle_error_indication(far, &report));\n\n            if (report.type.error_indication_report) {\n                ogs_assert(far->sess);\n                sess = SGWU_SESS(far->sess);\n                ogs_assert(sess);\n\n                ogs_assert(OGS_OK ==\n                    sgwu_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else {\n            ogs_error(\"[DROP] Cannot find FAR by Error-Indication\");\n            ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        }\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        struct ip *ip_h = NULL;\n        ogs_pfcp_object_t *pfcp_object = NULL;\n        ogs_pfcp_sess_t *pfcp_sess = NULL;\n        ogs_pfcp_pdr_t *pdr = NULL;\n\n        ip_h = (struct ip *)pkbuf->data;\n        ogs_assert(ip_h);\n\n        pfcp_object = ogs_pfcp_object_find_by_teid(teid);\n        if (!pfcp_object) {\n            /* TODO : Send Error Indication */\n            goto cleanup;\n        }\n\n        switch(pfcp_object->type) {\n        case OGS_PFCP_OBJ_PDR_TYPE:\n            pdr = (ogs_pfcp_pdr_t *)pfcp_object;\n            ogs_assert(pdr);\n            break;\n        case OGS_PFCP_OBJ_SESS_TYPE:\n            pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object;\n            ogs_assert(pfcp_sess);\n\n            ogs_list_for_each(&pfcp_sess->pdr_list, pdr) {\n                /* Check if Source Interface */\n                if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS &&\n                    pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION)\n                    continue;\n\n                /* Check if TEID */\n                if (teid != pdr->f_teid.teid)\n                    continue;\n\n                /* Check if QFI */\n                if (qfi && pdr->qfi != qfi)\n                    continue;\n\n                /* Check if Rule List in PDR */\n                if (ogs_list_first(&pdr->rule_list) &&\n                    ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL)\n                    continue;\n\n                break;\n            }\n\n            if (!pdr) {\n                /* TODO : Send Error Indication */\n                goto cleanup;\n            }\n\n            break;\n        default:\n            ogs_fatal(\"Unknown type [%d]\", pfcp_object->type);\n            ogs_assert_if_reached();\n        }\n\n        ogs_assert(pdr);\n        ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n        if (report.type.downlink_data_report) {\n            ogs_assert(pdr->sess);\n            ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE);\n            sess = SGWU_SESS(pdr->sess);\n            ogs_assert(sess);\n\n            report.downlink_data.pdr_id = pdr->id;\n            report.downlink_data.qfi = qfi; /* for 5GC */\n\n            ogs_assert(OGS_OK ==\n                sgwu_pfcp_send_session_report_request(sess, &report));\n        }\n    } else {\n        ogs_error(\"[DROP] Invalid GTPU Type [%d]\", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}\n\nint sgwu_gtp_init(void)\n{\n    ogs_pkbuf_config_t config;\n    memset(&config, 0, sizeof config);\n\n    config.cluster_2048_pool = ogs_app()->pool.packet;\n\n    packet_pool = ogs_pkbuf_pool_create(&config);\n\n    return OGS_OK;\n}\n\nvoid sgwu_gtp_final(void)\n{\n    ogs_pkbuf_pool_destroy(packet_pool);\n}\n\nint sgwu_gtp_open(void)\n{\n    ogs_socknode_t *node = NULL;\n    ogs_sock_t *sock = NULL;\n\n    ogs_list_for_each(&ogs_gtp_self()->gtpu_list, node) {\n        sock = ogs_gtp_server(node);\n        if (!sock) return OGS_ERROR;\n\n        if (sock->family == AF_INET)\n            ogs_gtp_self()->gtpu_sock = sock;\n        else if (sock->family == AF_INET6)\n            ogs_gtp_self()->gtpu_sock6 = sock;\n\n        node->poll = ogs_pollset_add(ogs_app()->pollset,\n                OGS_POLLIN, sock->fd, _gtpv1_u_recv_cb, sock);\n        ogs_assert(node->poll);\n    }\n\n    OGS_SETUP_GTPU_SERVER;\n\n    return OGS_OK;\n}\n\nvoid sgwu_gtp_close(void)\n{\n    ogs_socknode_remove_all(&ogs_gtp_self()->gtpu_list);\n}\n", "/*\n * Copyright (C) 2019 by Sukchan Lee <acetcom@gmail.com>\n *\n * This file is part of Open5GS.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"context.h\"\n\n#if HAVE_NETINET_IP_H\n#include <netinet/ip.h>\n#endif\n\n#if HAVE_NETINET_IP6_H\n#include <netinet/ip6.h>\n#endif\n\n#if HAVE_NETINET_IP_ICMP_H\n#include <netinet/ip_icmp.h>\n#endif\n\n#if HAVE_NETINET_ICMP6_H\n#include <netinet/icmp6.h>\n#endif\n\n#include \"event.h\"\n#include \"gtp-path.h\"\n#include \"pfcp-path.h\"\n#include \"s5c-build.h\"\n\nstatic bool check_if_router_solicit(ogs_pkbuf_t *pkbuf);\nstatic void send_router_advertisement(smf_sess_t *sess, uint8_t *ip6_dst);\n\nstatic void bearer_timeout(ogs_gtp_xact_t *xact, void *data);\n\nstatic void _gtpv2_c_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    smf_event_t *e = NULL;\n    int rv;\n    ssize_t size;\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n    ogs_gtp_node_t *gnode = NULL;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recvfrom() failed\");\n        ogs_pkbuf_free(pkbuf);\n        return;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    e = smf_event_new(SMF_EVT_S5C_MESSAGE);\n    gnode = ogs_gtp_node_find_by_addr(&smf_self()->sgw_s5c_list, &from);\n    if (!gnode) {\n        gnode = ogs_gtp_node_add_by_addr(&smf_self()->sgw_s5c_list, &from);\n        ogs_assert(gnode);\n        gnode->sock = data;\n    }\n    ogs_assert(e);\n    e->gnode = gnode;\n    e->pkbuf = pkbuf;\n\n    rv = ogs_queue_push(ogs_app()->queue, e);\n    if (rv != OGS_OK) {\n        ogs_warn(\"ogs_queue_push() failed:%d\", (int)rv);\n        ogs_pkbuf_free(e->pkbuf);\n        smf_event_free(e);\n    }\n}\n\nstatic void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recv() failed\");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\"[DROP] Invalid GTPU version [%d]\", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\"[RECV] Echo Request from [%s]\", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\"[SEND] Echo Response to [%s]\", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \"ogs_sendto() failed\");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\"[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\"   QFI [0x%x]\",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to TUN interface */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\"[DROP] Cannot decode GTPU packet\");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    if (gtp_h->type != OGS_GTPU_MSGTYPE_END_MARKER &&\n        pkbuf->len <= len) {\n        ogs_error(\"[DROP] Small GTPU packet(type:%d len:%d)\", gtp_h->type, len);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        smf_sess_t *sess = NULL;\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_teid(teid);\n        if (!far) {\n            ogs_error(\"No FAR for TEID [%d]\", teid);\n            goto cleanup;\n        }\n\n        if (far->dst_if != OGS_PFCP_INTERFACE_CP_FUNCTION) {\n            ogs_error(\"Invalid Destination Interface [%d]\", far->dst_if);\n            goto cleanup;\n        }\n\n        if (qfi) {\n            ogs_error(\"QFI[%d] Found\", qfi);\n            goto cleanup;\n        }\n\n        ogs_assert(far->sess);\n        sess = SMF_SESS(far->sess);\n        ogs_assert(sess);\n\n        if (sess->ipv6 && check_if_router_solicit(pkbuf) == true) {\n            struct ip6_hdr *ip6_h = (struct ip6_hdr *)pkbuf->data;\n            ogs_assert(ip6_h);\n            send_router_advertisement(sess, ip6_h->ip6_src.s6_addr);\n        }\n    } else {\n        ogs_error(\"[DROP] Invalid GTPU Type [%d]\", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}\n\nint smf_gtp_open(void)\n{\n    ogs_socknode_t *node = NULL;\n    ogs_sock_t *sock = NULL;\n\n    ogs_list_for_each(&ogs_gtp_self()->gtpc_list, node) {\n        sock = ogs_gtp_server(node);\n        if (!sock) return OGS_ERROR;\n        \n        node->poll = ogs_pollset_add(ogs_app()->pollset,\n                OGS_POLLIN, sock->fd, _gtpv2_c_recv_cb, sock);\n        ogs_assert(node->poll);\n    }\n    ogs_list_for_each(&ogs_gtp_self()->gtpc_list6, node) {\n        sock = ogs_gtp_server(node);\n        if (!sock) return OGS_ERROR;\n\n        node->poll = ogs_pollset_add(ogs_app()->pollset,\n                OGS_POLLIN, sock->fd, _gtpv2_c_recv_cb, sock);\n        ogs_assert(node->poll);\n    }\n\n    OGS_SETUP_GTPC_SERVER;\n\n    ogs_list_for_each(&ogs_gtp_self()->gtpu_list, node) {\n        sock = ogs_gtp_server(node);\n        if (!sock) return OGS_ERROR;\n\n        if (sock->family == AF_INET)\n            ogs_gtp_self()->gtpu_sock = sock;\n        else if (sock->family == AF_INET6)\n            ogs_gtp_self()->gtpu_sock6 = sock;\n\n        node->poll = ogs_pollset_add(ogs_app()->pollset,\n                OGS_POLLIN, sock->fd, _gtpv1_u_recv_cb, sock);\n        ogs_assert(node->poll);\n    }\n\n    OGS_SETUP_GTPU_SERVER;\n\n    /* Fetch link-local address for router advertisement */\n    if (ogs_gtp_self()->link_local_addr)\n        ogs_freeaddrinfo(ogs_gtp_self()->link_local_addr);\n    if (ogs_gtp_self()->gtpu_addr6)\n        ogs_gtp_self()->link_local_addr =\n            ogs_link_local_addr_by_sa(ogs_gtp_self()->gtpu_addr6);\n\n    return OGS_OK;\n}\n\nvoid smf_gtp_close(void)\n{\n    if (ogs_gtp_self()->link_local_addr)\n        ogs_freeaddrinfo(ogs_gtp_self()->link_local_addr);\n\n    ogs_socknode_remove_all(&ogs_gtp_self()->gtpc_list);\n    ogs_socknode_remove_all(&ogs_gtp_self()->gtpc_list6);\n\n    ogs_socknode_remove_all(&ogs_gtp_self()->gtpu_list);\n}\n\nint smf_gtp_send_create_session_response(\n        smf_sess_t *sess, ogs_gtp_xact_t *xact)\n{\n    int rv;\n    ogs_gtp_header_t h;\n    ogs_pkbuf_t *pkbuf = NULL;\n\n    ogs_assert(sess);\n    ogs_assert(xact);\n\n    memset(&h, 0, sizeof(ogs_gtp_header_t));\n    h.type = OGS_GTP_CREATE_SESSION_RESPONSE_TYPE;\n    h.teid = sess->sgw_s5c_teid;\n\n    pkbuf = smf_s5c_build_create_session_response(h.type, sess);\n    ogs_expect_or_return_val(pkbuf, OGS_ERROR);\n\n    rv = ogs_gtp_xact_update_tx(xact, &h, pkbuf);\n    ogs_expect_or_return_val(rv == OGS_OK, OGS_ERROR);\n\n    rv = ogs_gtp_xact_commit(xact);\n    ogs_expect(rv == OGS_OK);\n\n    return rv;\n}\n\nint smf_gtp_send_delete_session_response(\n        smf_sess_t *sess, ogs_gtp_xact_t *xact)\n{\n    int rv;\n    ogs_gtp_header_t h;\n    ogs_pkbuf_t *pkbuf = NULL;\n\n    ogs_assert(xact);\n    ogs_assert(sess);\n\n    memset(&h, 0, sizeof(ogs_gtp_header_t));\n    h.type = OGS_GTP_DELETE_SESSION_RESPONSE_TYPE;\n    h.teid = sess->sgw_s5c_teid;\n\n    pkbuf = smf_s5c_build_delete_session_response(h.type, sess);\n    ogs_expect_or_return_val(pkbuf, OGS_ERROR);\n\n    rv = ogs_gtp_xact_update_tx(xact, &h, pkbuf);\n    ogs_expect_or_return_val(rv == OGS_OK, OGS_ERROR);\n\n    rv = ogs_gtp_xact_commit(xact);\n    ogs_expect(rv == OGS_OK);\n\n    return rv;\n}\n\nint smf_gtp_send_delete_bearer_request(\n        smf_bearer_t *bearer, uint8_t pti, uint8_t cause_value)\n{\n    int rv;\n\n    ogs_gtp_xact_t *xact = NULL;\n    ogs_gtp_header_t h;\n    ogs_pkbuf_t *pkbuf = NULL;\n\n    smf_sess_t *sess = NULL;\n\n    ogs_assert(bearer);\n    sess = bearer->sess;\n    ogs_assert(sess);\n\n    memset(&h, 0, sizeof(ogs_gtp_header_t));\n    h.type = OGS_GTP_DELETE_BEARER_REQUEST_TYPE;\n    h.teid = sess->sgw_s5c_teid;\n\n    pkbuf = smf_s5c_build_delete_bearer_request(\n                h.type, bearer, pti, cause_value);\n    ogs_expect_or_return_val(pkbuf, OGS_ERROR);\n\n    xact = ogs_gtp_xact_local_create(\n            sess->gnode, &h, pkbuf, bearer_timeout, bearer);\n    ogs_expect_or_return_val(xact, OGS_ERROR);\n\n    rv = ogs_gtp_xact_commit(xact);\n    ogs_expect(rv == OGS_OK);\n\n    return rv;\n}\n\nstatic bool check_if_router_solicit(ogs_pkbuf_t *pkbuf)\n{\n    struct ip *ip_h = NULL;\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n    ogs_assert(pkbuf->data);\n\n    ip_h = (struct ip *)pkbuf->data;\n    if (ip_h->ip_v == 6) {\n        struct ip6_hdr *ip6_h = (struct ip6_hdr *)pkbuf->data;\n        if (ip6_h->ip6_nxt == IPPROTO_ICMPV6) {\n            struct icmp6_hdr *icmp_h =\n                (struct icmp6_hdr *)(pkbuf->data + sizeof(struct ip6_hdr));\n            if (icmp_h->icmp6_type == ND_ROUTER_SOLICIT) {\n                ogs_debug(\"      Router Solict\");\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nstatic void send_router_advertisement(smf_sess_t *sess, uint8_t *ip6_dst)\n{\n    int rv;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n\n    ogs_pfcp_pdr_t *pdr = NULL;\n    ogs_pfcp_ue_ip_t *ue_ip = NULL;\n    ogs_pfcp_subnet_t *subnet = NULL;\n    char ipstr[OGS_ADDRSTRLEN];\n\n    ogs_ipsubnet_t src_ipsub;\n    uint16_t plen = 0;\n    uint8_t nxt = 0;\n    uint8_t *p = NULL;\n    struct ip6_hdr *ip6_h =  NULL;\n    struct nd_router_advert *advert_h = NULL;\n    struct nd_opt_prefix_info *prefix = NULL;\n\n    ogs_assert(sess);\n    ue_ip = sess->ipv6;\n    ogs_assert(ue_ip);\n    subnet = ue_ip->subnet;\n    ogs_assert(subnet);\n\n    /* Fetch link-local address for router advertisement */\n    if (ogs_gtp_self()->link_local_addr) {\n        OGS_ADDR(ogs_gtp_self()->link_local_addr, ipstr);\n        rv = ogs_ipsubnet(&src_ipsub, ipstr, NULL);\n        ogs_expect_or_return(rv == OGS_OK);\n    } else {\n        /* For the case of loopback used for GTPU link-local address is not\n         * available, hence set the source IP to fe80::1\n        */\n        memset(src_ipsub.sub, 0, sizeof(src_ipsub.sub));\n        src_ipsub.sub[0] = htobe32(0xfe800000);\n        src_ipsub.sub[3] = htobe32(0x00000001);\n    }\n\n    ogs_debug(\"      Build Router Advertisement\");\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_GTPV1U_5GC_HEADER_LEN+200);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_reserve(pkbuf, OGS_GTPV1U_5GC_HEADER_LEN);\n    ogs_pkbuf_put(pkbuf, 200);\n    pkbuf->len = sizeof *ip6_h + sizeof *advert_h + sizeof *prefix;\n    memset(pkbuf->data, 0, pkbuf->len);\n\n    p = (uint8_t *)pkbuf->data;\n    ip6_h = (struct ip6_hdr *)p;\n    advert_h = (struct nd_router_advert *)((uint8_t *)ip6_h + sizeof *ip6_h);\n    prefix = (struct nd_opt_prefix_info *)\n        ((uint8_t*)advert_h + sizeof *advert_h);\n\n    advert_h->nd_ra_type = ND_ROUTER_ADVERT;\n    advert_h->nd_ra_code = 0;\n    advert_h->nd_ra_curhoplimit = 64;\n    advert_h->nd_ra_flags_reserved = 0;\n    advert_h->nd_ra_router_lifetime = htobe16(64800);  /* 64800s */\n    advert_h->nd_ra_reachable = 0;\n    advert_h->nd_ra_retransmit = 0;\n\n    prefix->nd_opt_pi_type = ND_OPT_PREFIX_INFORMATION;\n    prefix->nd_opt_pi_len = 4; /* 32bytes */\n    prefix->nd_opt_pi_prefix_len = OGS_IPV6_DEFAULT_PREFIX_LEN;\n    prefix->nd_opt_pi_flags_reserved =\n        ND_OPT_PI_FLAG_ONLINK|ND_OPT_PI_FLAG_AUTO;\n    prefix->nd_opt_pi_valid_time = htobe32(0xffffffff); /* Infinite */\n    prefix->nd_opt_pi_preferred_time = htobe32(0xffffffff); /* Infinite */\n    memcpy(prefix->nd_opt_pi_prefix.s6_addr,\n            ue_ip->addr, (OGS_IPV6_DEFAULT_PREFIX_LEN >> 3));\n\n    /* For IPv6 Pseudo-Header */\n    plen = htobe16(sizeof *advert_h + sizeof *prefix);\n    nxt = IPPROTO_ICMPV6;\n\n    memcpy(p, src_ipsub.sub, sizeof src_ipsub.sub);\n    p += sizeof src_ipsub.sub;\n    memcpy(p, ip6_dst, OGS_IPV6_LEN);\n    p += OGS_IPV6_LEN;\n    p += 2; memcpy(p, &plen, 2); p += 2;\n    p += 3; *p = nxt; p += 1;\n    advert_h->nd_ra_cksum = ogs_in_cksum((uint16_t *)pkbuf->data, pkbuf->len);\n\n    ip6_h->ip6_flow = htobe32(0x60000001);\n    ip6_h->ip6_plen = plen;\n    ip6_h->ip6_nxt = nxt;  /* ICMPv6 */\n    ip6_h->ip6_hlim = 0xff;\n    memcpy(ip6_h->ip6_src.s6_addr, src_ipsub.sub, sizeof src_ipsub.sub);\n    memcpy(ip6_h->ip6_dst.s6_addr, ip6_dst, OGS_IPV6_LEN);\n\n    ogs_list_for_each(&sess->pfcp.pdr_list, pdr) {\n        if (pdr->src_if == OGS_PFCP_INTERFACE_CP_FUNCTION && pdr->gnode) {\n            ogs_gtp_header_t gtp_hdesc;\n            ogs_gtp_extension_header_t ext_hdesc;\n\n            memset(&gtp_hdesc, 0, sizeof(gtp_hdesc));\n            memset(&ext_hdesc, 0, sizeof(ext_hdesc));\n\n            gtp_hdesc.type = OGS_GTPU_MSGTYPE_GPDU;\n            gtp_hdesc.teid = pdr->f_teid.teid;\n\n            ogs_gtp_send_user_plane(pdr->gnode, &gtp_hdesc, &ext_hdesc, pkbuf);\n\n            ogs_debug(\"      Send Router Advertisement\");\n            break;\n        }\n    }\n\n    ogs_pkbuf_free(pkbuf);\n}\n\nstatic void bearer_timeout(ogs_gtp_xact_t *xact, void *data)\n{\n    smf_bearer_t *bearer = data;\n    smf_sess_t *sess = NULL;\n    smf_ue_t *smf_ue = NULL;\n    uint8_t type = 0;\n\n    ogs_assert(bearer);\n    sess = bearer->sess;\n    ogs_assert(sess);\n    smf_ue = sess->smf_ue;\n    ogs_assert(smf_ue);\n\n    type = xact->seq[0].type;\n\n    switch (type) {\n    case OGS_GTP_DELETE_BEARER_REQUEST_TYPE:\n        ogs_error(\"[%s] No Delete Bearer Response\", smf_ue->imsi_bcd);\n        if (!smf_bearer_cycle(bearer)) {\n            ogs_warn(\"[%s] Bearer has already been removed\", smf_ue->imsi_bcd);\n            break;\n        }\n\n        ogs_assert(OGS_OK ==\n            smf_epc_pfcp_send_bearer_modification_request(\n                bearer, NULL, OGS_PFCP_MODIFY_REMOVE,\n                OGS_NAS_PROCEDURE_TRANSACTION_IDENTITY_UNASSIGNED,\n                OGS_GTP_CAUSE_UNDEFINED_VALUE));\n        break;\n    default:\n        ogs_error(\"GTP Timeout : IMSI[%s] Message-Type[%d]\",\n                smf_ue->imsi_bcd, type);\n        break;\n    }\n}\n", "/*\n * Copyright (C) 2019 by Sukchan Lee <acetcom@gmail.com>\n *\n * This file is part of Open5GS.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"context.h\"\n\n#if HAVE_NETINET_IP_H\n#include <netinet/ip.h>\n#endif\n\n#if HAVE_NETINET_IP6_H\n#include <netinet/ip6.h>\n#endif\n\n#if HAVE_NETINET_IP_ICMP_H\n#include <netinet/ip_icmp.h>\n#endif\n\n#if HAVE_NETINET_ICMP6_H\n#include <netinet/icmp6.h>\n#endif\n\n#if HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n\n#if HAVE_NET_IF_DL_H\n#include <net/if_dl.h>\n#endif\n\n#if HAVE_IFADDRS_H\n#include <ifaddrs.h>\n#endif\n\n#include \"arp-nd.h\"\n#include \"event.h\"\n#include \"gtp-path.h\"\n#include \"pfcp-path.h\"\n#include \"rule-match.h\"\n\n#define UPF_GTP_HANDLED     1\n\nconst uint8_t proxy_mac_addr[] = { 0x0e, 0x00, 0x00, 0x00, 0x00, 0x01 };\n\nstatic ogs_pkbuf_pool_t *packet_pool = NULL;\n\nstatic void upf_gtp_handle_multicast(ogs_pkbuf_t *recvbuf);\n\nstatic uint16_t _get_eth_type(uint8_t *data, uint len) {\n    if (len > ETHER_HDR_LEN) {\n        struct ether_header *hdr = (struct ether_header*)data;\n        return htobe16(hdr->ether_type);\n    }\n    return 0;\n}\n\nstatic void _gtpv1_tun_recv_common_cb(\n        short when, ogs_socket_t fd, bool has_eth, void *data)\n{\n    ogs_pkbuf_t *recvbuf = NULL;\n\n    upf_sess_t *sess = NULL;\n    ogs_pfcp_pdr_t *pdr = NULL;\n    ogs_pfcp_pdr_t *fallback_pdr = NULL;\n    ogs_pfcp_far_t *far = NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    recvbuf = ogs_tun_read(fd, packet_pool);\n    if (!recvbuf) {\n        ogs_warn(\"ogs_tun_read() failed\");\n        return;\n    }\n\n    if (has_eth) {\n        ogs_pkbuf_t *replybuf = NULL;\n        uint16_t eth_type = _get_eth_type(recvbuf->data, recvbuf->len);\n        uint8_t size;\n\n        if (eth_type == ETHERTYPE_ARP) {\n            if (is_arp_req(recvbuf->data, recvbuf->len)) {\n                replybuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN);\n                ogs_assert(replybuf);\n                ogs_pkbuf_reserve(replybuf, OGS_TUN_MAX_HEADROOM);\n                ogs_pkbuf_put(replybuf, OGS_MAX_PKT_LEN-OGS_TUN_MAX_HEADROOM);\n                size = arp_reply(replybuf->data, recvbuf->data, recvbuf->len,\n                    proxy_mac_addr);\n                ogs_pkbuf_trim(replybuf, size);\n                ogs_info(\"[SEND] reply to ARP request: %u\", size);\n            } else {\n                goto cleanup;\n            }\n        } else if (eth_type == ETHERTYPE_IPV6 &&\n                    is_nd_req(recvbuf->data, recvbuf->len)) {\n            replybuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN);\n            ogs_assert(replybuf);\n            ogs_pkbuf_reserve(replybuf, OGS_TUN_MAX_HEADROOM);\n            ogs_pkbuf_put(replybuf, OGS_MAX_PKT_LEN-OGS_TUN_MAX_HEADROOM);\n            size = nd_reply(replybuf->data, recvbuf->data, recvbuf->len,\n                proxy_mac_addr);\n            ogs_pkbuf_trim(replybuf, size);\n            ogs_info(\"[SEND] reply to ND solicit: %u\", size);\n        }\n        if (replybuf) {\n            if (ogs_tun_write(fd, replybuf) != OGS_OK)\n                ogs_warn(\"ogs_tun_write() for reply failed\");\n            goto cleanup;\n        }\n        if (eth_type != ETHERTYPE_IP && eth_type != ETHERTYPE_IPV6) {\n            ogs_error(\"[DROP] Invalid eth_type [%x]]\", eth_type);\n            ogs_log_hexdump(OGS_LOG_ERROR, recvbuf->data, recvbuf->len);\n            goto cleanup;\n        }\n        ogs_pkbuf_pull(recvbuf, ETHER_HDR_LEN);\n    }\n\n    sess = upf_sess_find_by_ue_ip_address(recvbuf);\n    if (!sess)\n        goto cleanup;\n\n    ogs_list_for_each(&sess->pfcp.pdr_list, pdr) {\n        far = pdr->far;\n        ogs_assert(far);\n\n        /* Check if PDR is Downlink */\n        if (pdr->src_if != OGS_PFCP_INTERFACE_CORE)\n            continue;\n\n        /* Save the Fallback PDR : Lowest precedence downlink PDR */\n        fallback_pdr = pdr;\n\n        /* Check if FAR is Downlink */\n        if (far->dst_if != OGS_PFCP_INTERFACE_ACCESS)\n            continue;\n\n        /* Check if Outer header creation */\n        if (far->outer_header_creation.ip4 == 0 &&\n            far->outer_header_creation.ip6 == 0 &&\n            far->outer_header_creation.udp4 == 0 &&\n            far->outer_header_creation.udp6 == 0 &&\n            far->outer_header_creation.gtpu4 == 0 &&\n            far->outer_header_creation.gtpu6 == 0)\n            continue;\n\n        /* Check if Rule List in PDR */\n        if (ogs_list_first(&pdr->rule_list) &&\n            ogs_pfcp_pdr_rule_find_by_packet(pdr, recvbuf) == NULL)\n            continue;\n\n        break;\n    }\n\n    if (!pdr)\n        pdr = fallback_pdr;\n\n    if (!pdr) {\n        if (ogs_app()->parameter.multicast) {\n            upf_gtp_handle_multicast(recvbuf);\n        }\n        goto cleanup;\n    }\n\n    ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, recvbuf, &report));\n\n    if (report.type.downlink_data_report) {\n        ogs_assert(pdr->sess);\n        sess = UPF_SESS(pdr->sess);\n        ogs_assert(sess);\n\n        report.downlink_data.pdr_id = pdr->id;\n        if (pdr->qer && pdr->qer->qfi)\n            report.downlink_data.qfi = pdr->qer->qfi; /* for 5GC */\n\n        ogs_assert(OGS_OK ==\n            upf_pfcp_send_session_report_request(sess, &report));\n    }\n\ncleanup:\n    ogs_pkbuf_free(recvbuf);\n}\n\nstatic void _gtpv1_tun_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    _gtpv1_tun_recv_common_cb(when, fd, false, data);\n}\n\nstatic void _gtpv1_tun_recv_eth_cb(short when, ogs_socket_t fd, void *data)\n{\n    _gtpv1_tun_recv_common_cb(when, fd, true, data);\n}\n\nstatic void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    upf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_reserve(pkbuf, OGS_TUN_MAX_HEADROOM);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN-OGS_TUN_MAX_HEADROOM);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recv() failed\");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\"[DROP] Invalid GTPU version [%d]\", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\"[RECV] Echo Request from [%s]\", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\"[SEND] Echo Response to [%s]\", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \"ogs_sendto() failed\");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\"[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\"   QFI [0x%x]\",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to TUN interface */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\"[DROP] Cannot decode GTPU packet\");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    if (gtp_h->type != OGS_GTPU_MSGTYPE_END_MARKER &&\n        pkbuf->len <= len) {\n        ogs_error(\"[DROP] Small GTPU packet(type:%d len:%d)\", gtp_h->type, len);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {\n        /* Nothing */\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) {\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_error_indication(pkbuf);\n        if (far) {\n            ogs_assert(true ==\n                ogs_pfcp_up_handle_error_indication(far, &report));\n\n            if (report.type.error_indication_report) {\n                ogs_assert(far->sess);\n                sess = UPF_SESS(far->sess);\n                ogs_assert(sess);\n\n                ogs_assert(OGS_OK ==\n                    upf_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else {\n            ogs_error(\"[DROP] Cannot find FAR by Error-Indication\");\n            ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        }\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        struct ip *ip_h = NULL;\n        ogs_pfcp_object_t *pfcp_object = NULL;\n        ogs_pfcp_sess_t *pfcp_sess = NULL;\n        ogs_pfcp_pdr_t *pdr = NULL;\n        ogs_pfcp_far_t *far = NULL;\n\n        ogs_pfcp_subnet_t *subnet = NULL;\n        ogs_pfcp_dev_t *dev = NULL;\n\n        ip_h = (struct ip *)pkbuf->data;\n        ogs_assert(ip_h);\n\n        pfcp_object = ogs_pfcp_object_find_by_teid(teid);\n        if (!pfcp_object) {\n            /* TODO : Send Error Indication */\n            goto cleanup;\n        }\n\n        switch(pfcp_object->type) {\n        case OGS_PFCP_OBJ_PDR_TYPE:\n            pdr = (ogs_pfcp_pdr_t *)pfcp_object;\n            ogs_assert(pdr);\n            break;\n        case OGS_PFCP_OBJ_SESS_TYPE:\n            pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object;\n            ogs_assert(pfcp_sess);\n\n            ogs_list_for_each(&pfcp_sess->pdr_list, pdr) {\n\n                /* Check if Source Interface */\n                if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS &&\n                    pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION)\n                    continue;\n\n                /* Check if TEID */\n                if (teid != pdr->f_teid.teid)\n                    continue;\n\n                /* Check if QFI */\n                if (qfi && pdr->qfi != qfi)\n                    continue;\n\n                /* Check if Rule List in PDR */\n                if (ogs_list_first(&pdr->rule_list) &&\n                    ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL)\n                    continue;\n\n                break;\n            }\n\n            if (!pdr) {\n                /* TODO : Send Error Indication */\n                goto cleanup;\n            }\n\n            break;\n        default:\n            ogs_fatal(\"Unknown type [%d]\", pfcp_object->type);\n            ogs_assert_if_reached();\n        }\n\n        ogs_assert(pdr);\n        ogs_assert(pdr->sess);\n        ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE);\n\n        sess = UPF_SESS(pdr->sess);\n        ogs_assert(sess);\n\n        far = pdr->far;\n        ogs_assert(far);\n\n        if (far->dst_if == OGS_PFCP_INTERFACE_CORE) {\n            uint16_t eth_type = 0;\n\n            if (ip_h->ip_v == 4 && sess->ipv4) {\n                subnet = sess->ipv4->subnet;\n                eth_type = ETHERTYPE_IP;\n            } else if (ip_h->ip_v == 6 && sess->ipv6) {\n                subnet = sess->ipv6->subnet;\n                eth_type = ETHERTYPE_IPV6;\n            }\n\n            if (!subnet) {\n#if 0 /* It's redundant log message */\n                ogs_error(\"[DROP] Cannot find subnet V:%d, IPv4:%p, IPv6:%p\",\n                        ip_h->ip_v, sess->ipv4, sess->ipv6);\n                ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n#endif\n                goto cleanup;\n            }\n\n            dev = subnet->dev;\n            ogs_assert(dev);\n\n            if (dev->is_tap) {\n                ogs_assert(eth_type);\n                eth_type = htobe16(eth_type);\n                ogs_pkbuf_push(pkbuf, sizeof(eth_type));\n                memcpy(pkbuf->data, &eth_type, sizeof(eth_type));\n                ogs_pkbuf_push(pkbuf, ETHER_ADDR_LEN);\n                memcpy(pkbuf->data, proxy_mac_addr, ETHER_ADDR_LEN);\n                ogs_pkbuf_push(pkbuf, ETHER_ADDR_LEN);\n                memcpy(pkbuf->data, dev->mac_addr, ETHER_ADDR_LEN);\n            }\n\n            /* TODO: if destined to another UE, hairpin back out. */\n            if (ogs_tun_write(dev->fd, pkbuf) != OGS_OK)\n                ogs_warn(\"ogs_tun_write() failed\");\n\n        } else if (far->dst_if == OGS_PFCP_INTERFACE_ACCESS) {\n            ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n            if (report.type.downlink_data_report) {\n                ogs_error(\"Indirect Data Fowarding Buffered\");\n\n                report.downlink_data.pdr_id = pdr->id;\n                if (pdr->qer && pdr->qer->qfi)\n                    report.downlink_data.qfi = pdr->qer->qfi; /* for 5GC */\n\n                ogs_assert(OGS_OK ==\n                    upf_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else if (far->dst_if == OGS_PFCP_INTERFACE_CP_FUNCTION) {\n\n            if (!far->gnode) {\n                ogs_error(\"No Outer Header Creation in FAR\");\n                goto cleanup;\n            }\n\n            if ((far->apply_action & OGS_PFCP_APPLY_ACTION_FORW) == 0) {\n                ogs_error(\"Not supported Apply Action [0x%x]\",\n                            far->apply_action);\n                goto cleanup;\n            }\n\n            ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n            ogs_assert(report.type.downlink_data_report == 0);\n\n        } else {\n            ogs_fatal(\"Not implemented : FAR-DST_IF[%d]\", far->dst_if);\n            ogs_assert_if_reached();\n        }\n    } else {\n        ogs_error(\"[DROP] Invalid GTPU Type [%d]\", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}\n\nint upf_gtp_init(void)\n{\n    ogs_pkbuf_config_t config;\n    memset(&config, 0, sizeof config);\n\n    config.cluster_2048_pool = ogs_app()->pool.packet;\n\n    packet_pool = ogs_pkbuf_pool_create(&config);\n\n    return OGS_OK;\n}\n\nvoid upf_gtp_final(void)\n{\n    ogs_pkbuf_pool_destroy(packet_pool);\n}\n\nstatic void _get_dev_mac_addr(char *ifname, uint8_t *mac_addr)\n{\n#ifdef SIOCGIFHWADDR\n    int fd = socket(PF_INET, SOCK_DGRAM, 0);\n    ogs_assert(fd);\n    struct ifreq req;\n    memset(&req, 0, sizeof(req));\n    strncpy(req.ifr_name, ifname, IF_NAMESIZE-1);\n    ogs_assert(ioctl(fd, SIOCGIFHWADDR, &req) == 0);\n    memcpy(mac_addr, req.ifr_hwaddr.sa_data, ETHER_ADDR_LEN);\n#else\n    struct ifaddrs *ifap;\n    ogs_assert(getifaddrs(&ifap) == 0);\n    struct ifaddrs *p;\n    for (p = ifap; p; p = p->ifa_next) {\n        if (strncmp(ifname, p->ifa_name, IF_NAMESIZE-1) == 0) {\n            struct sockaddr_dl* sdp = (struct sockaddr_dl*) p->ifa_addr;\n            memcpy(mac_addr, sdp->sdl_data + sdp->sdl_nlen, ETHER_ADDR_LEN);\n            freeifaddrs(ifap);\n            return;\n        }\n    }\n    ogs_assert(0); /* interface not found. */\n#endif\n}\n\nint upf_gtp_open(void)\n{\n    ogs_pfcp_dev_t *dev = NULL;\n    ogs_pfcp_subnet_t *subnet = NULL;\n    ogs_socknode_t *node = NULL;\n    ogs_sock_t *sock = NULL;\n    int rc;\n\n    ogs_list_for_each(&ogs_gtp_self()->gtpu_list, node) {\n        sock = ogs_gtp_server(node);\n        if (!sock) return OGS_ERROR;\n\n        if (sock->family == AF_INET)\n            ogs_gtp_self()->gtpu_sock = sock;\n        else if (sock->family == AF_INET6)\n            ogs_gtp_self()->gtpu_sock6 = sock;\n\n        node->poll = ogs_pollset_add(ogs_app()->pollset,\n                OGS_POLLIN, sock->fd, _gtpv1_u_recv_cb, sock);\n        ogs_assert(node->poll);\n    }\n\n    OGS_SETUP_GTPU_SERVER;\n\n    /* NOTE : tun device can be created via following command.\n     *\n     * $ sudo ip tuntap add name ogstun mode tun\n     *\n     * Also, before running upf, assign the one IP from IP pool of UE \n     * to ogstun. The IP should not be assigned to UE\n     *\n     * $ sudo ifconfig ogstun 45.45.0.1/16 up\n     *\n     */\n\n    /* Open Tun interface */\n    ogs_list_for_each(&ogs_pfcp_self()->dev_list, dev) {\n        dev->is_tap = strstr(dev->ifname, \"tap\");\n        dev->fd = ogs_tun_open(dev->ifname, OGS_MAX_IFNAME_LEN, dev->is_tap);\n        if (dev->fd == INVALID_SOCKET) {\n            ogs_error(\"tun_open(dev:%s) failed\", dev->ifname);\n            return OGS_ERROR;\n        }\n\n        if (dev->is_tap) {\n            _get_dev_mac_addr(dev->ifname, dev->mac_addr);\n            dev->poll = ogs_pollset_add(ogs_app()->pollset,\n                    OGS_POLLIN, dev->fd, _gtpv1_tun_recv_eth_cb, NULL);\n            ogs_assert(dev->poll);\n        } else {\n            dev->poll = ogs_pollset_add(ogs_app()->pollset,\n                    OGS_POLLIN, dev->fd, _gtpv1_tun_recv_cb, NULL);\n            ogs_assert(dev->poll);\n        }\n\n        ogs_assert(dev->poll);\n    }\n\n    /* \n     * On Linux, it is possible to create a persistent tun/tap \n     * interface which will continue to exist even if open5gs quit, \n     * although this is normally not required. \n     * It can be useful to set up a tun/tap interface owned \n     * by a non-root user, so open5gs can be started without \n     * needing any root privileges at all.\n     */\n\n    /* Set P-to-P IP address with Netmask\n     * Note that Linux will skip this configuration */\n    ogs_list_for_each(&ogs_pfcp_self()->subnet_list, subnet) {\n        ogs_assert(subnet->dev);\n        rc = ogs_tun_set_ip(subnet->dev->ifname, &subnet->gw, &subnet->sub);\n        if (rc != OGS_OK) {\n            ogs_error(\"ogs_tun_set_ip(dev:%s) failed\", subnet->dev->ifname);\n            return OGS_ERROR;\n        }\n    }\n\n    return OGS_OK;\n}\n\nvoid upf_gtp_close(void)\n{\n    ogs_pfcp_dev_t *dev = NULL;\n\n    ogs_socknode_remove_all(&ogs_gtp_self()->gtpu_list);\n\n    ogs_list_for_each(&ogs_pfcp_self()->dev_list, dev) {\n        if (dev->poll)\n            ogs_pollset_remove(dev->poll);\n        ogs_closesocket(dev->fd);\n    }\n}\n\nstatic void upf_gtp_handle_multicast(ogs_pkbuf_t *recvbuf)\n{\n    struct ip *ip_h =  NULL;\n    struct ip6_hdr *ip6_h =  NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    ip_h = (struct ip *)recvbuf->data;\n    if (ip_h->ip_v == 6) {\n#if COMPILE_ERROR_IN_MAC_OS_X  /* Compiler error in Mac OS X platform */\n        ip6_h = (struct ip6_hdr *)recvbuf->data;\n        if (IN6_IS_ADDR_MULTICAST(&ip6_h->ip6_dst))\n#else\n        struct in6_addr ip6_dst;\n        ip6_h = (struct ip6_hdr *)recvbuf->data;\n        memcpy(&ip6_dst, &ip6_h->ip6_dst, sizeof(struct in6_addr));\n        if (IN6_IS_ADDR_MULTICAST(&ip6_dst))\n#endif\n        {\n            upf_sess_t *sess = NULL;\n\n            /* IPv6 Multicast */\n            ogs_list_for_each(&upf_self()->sess_list, sess) {\n                if (sess->ipv6) {\n                    /* PDN IPv6 is avaiable */\n                    ogs_pfcp_pdr_t *pdr = NULL;\n\n                    ogs_list_for_each(&sess->pfcp.pdr_list, pdr) {\n                        if (pdr->src_if == OGS_PFCP_INTERFACE_CORE) {\n                            ogs_assert(true ==\n                                ogs_pfcp_up_handle_pdr(pdr, recvbuf, &report));\n                            break;\n                        }\n                    }\n\n                    return;\n                }\n            }\n        }\n    }\n}\n"], "filenames": ["src/sgwu/gtp-path.c", "src/smf/gtp-path.c", "src/upf/gtp-path.c"], "buggy_code_start_loc": [126, 188, 306], "buggy_code_end_loc": [126, 188, 306], "fixing_code_start_loc": [127, 189, 307], "fixing_code_end_loc": [133, 195, 313], "type": "CWE-20", "message": "In Open5GS 2.4.0, a crafted packet from UE can crash SGW-U/UPF.", "other": {"cve": {"id": "CVE-2021-45462", "sourceIdentifier": "cve@mitre.org", "published": "2021-12-23T04:15:09.573", "lastModified": "2022-01-04T19:33:30.017", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Open5GS 2.4.0, a crafted packet from UE can crash SGW-U/UPF."}, {"lang": "es", "value": "En Open5GS versi\u00f3n 2.4.0, un paquete dise\u00f1ado desde el UE puede bloquear SGW-U/UPF"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "cve@mitre.org", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:open5gs:open5gs:2.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "AF94B032-E068-4A54-9F7F-A02342C90E13"}]}]}], "references": [{"url": "https://github.com/open5gs/open5gs/commit/a0f2535cb5a29bba6dbbccdb90c74ccd770cc700", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/open5gs/open5gs/commit/a0f2535cb5a29bba6dbbccdb90c74ccd770cc700"}}