{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * File System Virtual Channel\n *\n * Copyright 2010-2011 Vic Lee\n * Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n * Copyright 2016 David PHAM-VAN <d.phamvan@inuvika.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n#include <winpr/path.h>\n#include <winpr/file.h>\n#include <winpr/string.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/stream.h>\n#include <winpr/environment.h>\n#include <winpr/interlocked.h>\n#include <winpr/collections.h>\n#include <winpr/shell.h>\n\n#include <freerdp/channels/rdpdr.h>\n\n#include \"drive_file.h\"\n\ntypedef struct _DRIVE_DEVICE DRIVE_DEVICE;\n\nstruct _DRIVE_DEVICE\n{\n\tDEVICE device;\n\n\tWCHAR* path;\n\tBOOL automount;\n\tUINT32 PathLength;\n\twListDictionary* files;\n\n\tHANDLE thread;\n\twMessageQueue* IrpQueue;\n\n\tDEVMAN* devman;\n\n\trdpContext* rdpcontext;\n};\n\nstatic UINT sys_code_page = 0;\n\nstatic DWORD drive_map_windows_err(DWORD fs_errno)\n{\n\tDWORD rc;\n\n\t/* try to return NTSTATUS version of error code */\n\n\tswitch (fs_errno)\n\t{\n\t\tcase STATUS_SUCCESS:\n\t\t\trc = STATUS_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase ERROR_ACCESS_DENIED:\n\t\tcase ERROR_SHARING_VIOLATION:\n\t\t\trc = STATUS_ACCESS_DENIED;\n\t\t\tbreak;\n\n\t\tcase ERROR_FILE_NOT_FOUND:\n\t\t\trc = STATUS_NO_SUCH_FILE;\n\t\t\tbreak;\n\n\t\tcase ERROR_BUSY_DRIVE:\n\t\t\trc = STATUS_DEVICE_BUSY;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_DRIVE:\n\t\t\trc = STATUS_NO_SUCH_DEVICE;\n\t\t\tbreak;\n\n\t\tcase ERROR_NOT_READY:\n\t\t\trc = STATUS_NO_SUCH_DEVICE;\n\t\t\tbreak;\n\n\t\tcase ERROR_FILE_EXISTS:\n\t\tcase ERROR_ALREADY_EXISTS:\n\t\t\trc = STATUS_OBJECT_NAME_COLLISION;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_NAME:\n\t\t\trc = STATUS_NO_SUCH_FILE;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_HANDLE:\n\t\t\trc = STATUS_INVALID_HANDLE;\n\t\t\tbreak;\n\n\t\tcase ERROR_NO_MORE_FILES:\n\t\t\trc = STATUS_NO_MORE_FILES;\n\t\t\tbreak;\n\n\t\tcase ERROR_DIRECTORY:\n\t\t\trc = STATUS_NOT_A_DIRECTORY;\n\t\t\tbreak;\n\n\t\tcase ERROR_PATH_NOT_FOUND:\n\t\t\trc = STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trc = STATUS_UNSUCCESSFUL;\n\t\t\tWLog_ERR(TAG, \"Error code not found: %\" PRIu32 \"\", fs_errno);\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic DRIVE_FILE* drive_get_file_by_id(DRIVE_DEVICE* drive, UINT32 id)\n{\n\tDRIVE_FILE* file = NULL;\n\tvoid* key = (void*)(size_t)id;\n\n\tif (!drive)\n\t\treturn NULL;\n\n\tfile = (DRIVE_FILE*)ListDictionary_GetItemValue(drive->files, key);\n\treturn file;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_create(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FileId;\n\tDRIVE_FILE* file;\n\tBYTE Information;\n\tUINT32 FileAttributes;\n\tUINT32 SharedAccess;\n\tUINT32 DesiredAccess;\n\tUINT32 CreateDisposition;\n\tUINT32 CreateOptions;\n\tUINT32 PathLength;\n\tUINT64 allocationSize;\n\tconst WCHAR* path;\n\n\tif (!drive || !irp || !irp->devman || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 6 * 4 + 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);\n\tStream_Read_UINT64(irp->input, allocationSize);\n\tStream_Read_UINT32(irp->input, FileAttributes);\n\tStream_Read_UINT32(irp->input, SharedAccess);\n\tStream_Read_UINT32(irp->input, CreateDisposition);\n\tStream_Read_UINT32(irp->input, CreateOptions);\n\tStream_Read_UINT32(irp->input, PathLength);\n\n\tif (Stream_GetRemainingLength(irp->input) < PathLength)\n\t\treturn ERROR_INVALID_DATA;\n\n\tpath = (const WCHAR*)Stream_Pointer(irp->input);\n\tFileId = irp->devman->id_sequence++;\n\tfile = drive_file_new(drive->path, path, PathLength, FileId, DesiredAccess, CreateDisposition,\n\t                      CreateOptions, FileAttributes, SharedAccess);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tFileId = 0;\n\t\tInformation = 0;\n\t}\n\telse\n\t{\n\t\tvoid* key = (void*)(size_t)file->id;\n\n\t\tif (!ListDictionary_Add(drive->files, key, file))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_Add failed!\");\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\n\t\tswitch (CreateDisposition)\n\t\t{\n\t\t\tcase FILE_SUPERSEDE:\n\t\t\tcase FILE_OPEN:\n\t\t\tcase FILE_CREATE:\n\t\t\tcase FILE_OVERWRITE:\n\t\t\t\tInformation = FILE_SUPERSEDED;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OPEN_IF:\n\t\t\t\tInformation = FILE_OPENED;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OVERWRITE_IF:\n\t\t\t\tInformation = FILE_OVERWRITTEN;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tInformation = 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tStream_Write_UINT32(irp->output, FileId);\n\tStream_Write_UINT8(irp->output, Information);\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_close(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tvoid* key;\n\tDRIVE_FILE* file;\n\n\tif (!drive || !irp || !irp->Complete || !irp->output)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tkey = (void*)(size_t)irp->FileId;\n\n\tif (!file)\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\telse\n\t{\n\t\tListDictionary_Remove(drive->files, key);\n\n\t\tif (drive_file_free(file))\n\t\t\tirp->IoStatus = STATUS_SUCCESS;\n\t\telse\n\t\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\tStream_Zero(irp->output, 5); /* Padding(5) */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_read(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\n\tif (!drive || !irp || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tif (!Stream_EnsureRemainingCapacity(irp->output, Length + 4))\n\t{\n\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\telse if (Length == 0)\n\t\tStream_Write_UINT32(irp->output, 0);\n\telse\n\t{\n\t\tBYTE* buffer = Stream_Pointer(irp->output) + sizeof(UINT32);\n\n\t\tif (!drive_file_read(file, buffer, &Length))\n\t\t{\n\t\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\t\tStream_Write_UINT32(irp->output, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT32(irp->output, Length);\n\t\t\tStream_Seek(irp->output, Length);\n\t\t}\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\tvoid* ptr;\n\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); /* Padding */\n\tptr = Stream_Pointer(irp->input);\n\tif (!Stream_SafeSeek(irp->input, Length))\n\t\treturn ERROR_INVALID_DATA;\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, ptr, Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); /* Padding */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t}\n\telse if (!drive_file_query_information(file, FsInformationClass, irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_set_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 FsInformationClass;\n\tUINT32 Length;\n\n\tif (!drive || !irp || !irp->Complete || !irp->input || !irp->output)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Seek(irp->input, 24); /* Padding */\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t}\n\telse if (!drive_file_set_information(file, FsInformationClass, Length, irp->input))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\tif (file && file->is_dir && !PathIsDirectoryEmptyW(file->fullpath))\n\t\tirp->IoStatus = STATUS_DIRECTORY_NOT_EMPTY;\n\n\tStream_Write_UINT32(irp->output, Length);\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_volume_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FsInformationClass;\n\twStream* output = NULL;\n\tchar* volumeLabel = { \"FREERDP\" };\n\tchar* diskType = { \"FAT32\" };\n\tWCHAR* outStr = NULL;\n\tint length;\n\tDWORD lpSectorsPerCluster;\n\tDWORD lpBytesPerSector;\n\tDWORD lpNumberOfFreeClusters;\n\tDWORD lpTotalNumberOfClusters;\n\tWIN32_FILE_ATTRIBUTE_DATA wfad;\n\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\toutput = irp->output;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tGetDiskFreeSpaceW(drive->path, &lpSectorsPerCluster, &lpBytesPerSector, &lpNumberOfFreeClusters,\n\t                  &lpTotalNumberOfClusters);\n\n\tswitch (FsInformationClass)\n\t{\n\t\tcase FileFsVolumeInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232108.aspx */\n\t\t\tif ((length = ConvertToUnicode(sys_code_page, 0, volumeLabel, -1, &outStr, 0) * 2) <= 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, 17 + length); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 17 + length))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\tfree(outStr);\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tGetFileAttributesExW(drive->path, GetFileExInfoStandard, &wfad);\n\t\t\tStream_Write_UINT32(output, wfad.ftCreationTime.dwLowDateTime); /* VolumeCreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    wfad.ftCreationTime.dwHighDateTime);      /* VolumeCreationTime */\n\t\t\tStream_Write_UINT32(output, lpNumberOfFreeClusters & 0xffff); /* VolumeSerialNumber */\n\t\t\tStream_Write_UINT32(output, length);                          /* VolumeLabelLength */\n\t\t\tStream_Write_UINT8(output, 0);                                /* SupportsObjects */\n\t\t\t/* Reserved(1), MUST NOT be added! */\n\t\t\tStream_Write(output, outStr, length); /* VolumeLabel (Unicode) */\n\t\t\tfree(outStr);\n\t\t\tbreak;\n\n\t\tcase FileFsSizeInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232107.aspx */\n\t\t\tStream_Write_UINT32(output, 24); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 24))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT64(output, lpTotalNumberOfClusters); /* TotalAllocationUnits */\n\t\t\tStream_Write_UINT64(output, lpNumberOfFreeClusters);  /* AvailableAllocationUnits */\n\t\t\tStream_Write_UINT32(output, lpSectorsPerCluster);     /* SectorsPerAllocationUnit */\n\t\t\tStream_Write_UINT32(output, lpBytesPerSector);        /* BytesPerSector */\n\t\t\tbreak;\n\n\t\tcase FileFsAttributeInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232101.aspx */\n\t\t\tif ((length = ConvertToUnicode(sys_code_page, 0, diskType, -1, &outStr, 0) * 2) <= 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, 12 + length); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 12 + length))\n\t\t\t{\n\t\t\t\tfree(outStr);\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, FILE_CASE_SENSITIVE_SEARCH | FILE_CASE_PRESERVED_NAMES |\n\t\t\t                                FILE_UNICODE_ON_DISK); /* FileSystemAttributes */\n\t\t\tStream_Write_UINT32(output, MAX_PATH);                 /* MaximumComponentNameLength */\n\t\t\tStream_Write_UINT32(output, length);                   /* FileSystemNameLength */\n\t\t\tStream_Write(output, outStr, length);                  /* FileSystemName (Unicode) */\n\t\t\tfree(outStr);\n\t\t\tbreak;\n\n\t\tcase FileFsFullSizeInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232104.aspx */\n\t\t\tStream_Write_UINT32(output, 32); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 32))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT64(output, lpTotalNumberOfClusters); /* TotalAllocationUnits */\n\t\t\tStream_Write_UINT64(output,\n\t\t\t                    lpNumberOfFreeClusters); /* CallerAvailableAllocationUnits */\n\t\t\tStream_Write_UINT64(output, lpNumberOfFreeClusters); /* AvailableAllocationUnits */\n\t\t\tStream_Write_UINT32(output, lpSectorsPerCluster);    /* SectorsPerAllocationUnit */\n\t\t\tStream_Write_UINT32(output, lpBytesPerSector);       /* BytesPerSector */\n\t\t\tbreak;\n\n\t\tcase FileFsDeviceInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232109.aspx */\n\t\t\tStream_Write_UINT32(output, 8); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 8))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, FILE_DEVICE_DISK); /* DeviceType */\n\t\t\tStream_Write_UINT32(output, 0);                /* Characteristics */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\t\tStream_Write_UINT32(output, 0); /* Length */\n\t\t\tbreak;\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/* http://msdn.microsoft.com/en-us/library/cc241518.aspx */\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_silent_ignore(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Write_UINT32(irp->output, 0); /* Length */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tconst WCHAR* path;\n\tDRIVE_FILE* file;\n\tBYTE InitialQuery;\n\tUINT32 PathLength;\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT8(irp->input, InitialQuery);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tStream_Seek(irp->input, 23); /* Padding */\n\tpath = (WCHAR*)Stream_Pointer(irp->input);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (file == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tStream_Write_UINT32(irp->output, 0); /* Length */\n\t}\n\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path, PathLength,\n\t                                     irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_directory_control(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tswitch (irp->MinorFunction)\n\t{\n\t\tcase IRP_MN_QUERY_DIRECTORY:\n\t\t\treturn drive_process_irp_query_directory(drive, irp);\n\n\t\tcase IRP_MN_NOTIFY_CHANGE_DIRECTORY: /* TODO */\n\t\t\treturn irp->Discard(irp);\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\tStream_Write_UINT32(irp->output, 0); /* Length */\n\t\t\treturn irp->Complete(irp);\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_device_control(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tStream_Write_UINT32(irp->output, 0); /* OutputBufferLength */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT error;\n\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tirp->IoStatus = STATUS_SUCCESS;\n\n\tswitch (irp->MajorFunction)\n\t{\n\t\tcase IRP_MJ_CREATE:\n\t\t\terror = drive_process_irp_create(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_CLOSE:\n\t\t\terror = drive_process_irp_close(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_READ:\n\t\t\terror = drive_process_irp_read(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_WRITE:\n\t\t\terror = drive_process_irp_write(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_INFORMATION:\n\t\t\terror = drive_process_irp_query_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_SET_INFORMATION:\n\t\t\terror = drive_process_irp_set_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_VOLUME_INFORMATION:\n\t\t\terror = drive_process_irp_query_volume_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_LOCK_CONTROL:\n\t\t\terror = drive_process_irp_silent_ignore(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DIRECTORY_CONTROL:\n\t\t\terror = drive_process_irp_directory_control(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\terror = drive_process_irp_device_control(drive, irp);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\terror = irp->Complete(irp);\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\n\nstatic DWORD WINAPI drive_thread_func(LPVOID arg)\n{\n\tIRP* irp;\n\twMessage message;\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)arg;\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t{\n\t\terror = ERROR_INVALID_PARAMETER;\n\t\tgoto fail;\n\t}\n\n\twhile (1)\n\t{\n\t\tif (!MessageQueue_Wait(drive->IrpQueue))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Wait failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!MessageQueue_Peek(drive->IrpQueue, &message, TRUE))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Peek failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (message.id == WMQ_QUIT)\n\t\t\tbreak;\n\n\t\tirp = (IRP*)message.wParam;\n\n\t\tif (irp)\n\t\t{\n\t\t\tif ((error = drive_process_irp(drive, irp)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"drive_process_irp failed with error %\" PRIu32 \"!\", error);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nfail:\n\n\tif (error && drive && drive->rdpcontext)\n\t\tsetChannelError(drive->rdpcontext, error, \"drive_thread_func reported an error\");\n\n\tExitThread(error);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_irp_request(DEVICE* device, IRP* irp)\n{\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)device;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (!MessageQueue_Post(drive->IrpQueue, NULL, 0, (void*)irp, NULL))\n\t{\n\t\tWLog_ERR(TAG, \"MessageQueue_Post failed!\");\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\nstatic UINT drive_free_int(DRIVE_DEVICE* drive)\n{\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tCloseHandle(drive->thread);\n\tListDictionary_Free(drive->files);\n\tMessageQueue_Free(drive->IrpQueue);\n\tStream_Free(drive->device.data, TRUE);\n\tfree(drive->path);\n\tfree(drive);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_free(DEVICE* device)\n{\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)device;\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (MessageQueue_PostQuit(drive->IrpQueue, 0) &&\n\t    (WaitForSingleObject(drive->thread, INFINITE) == WAIT_FAILED))\n\t{\n\t\terror = GetLastError();\n\t\tWLog_ERR(TAG, \"WaitForSingleObject failed with error %\" PRIu32 \"\", error);\n\t\treturn error;\n\t}\n\n\treturn drive_free_int(drive);\n}\n\n/**\n * Helper function used for freeing list dictionary value object\n */\nstatic void drive_file_objfree(void* obj)\n{\n\tdrive_file_free((DRIVE_FILE*)obj);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_register_drive_path(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints, const char* name,\n                                      const char* path, BOOL automount)\n{\n\tsize_t i, length;\n\tDRIVE_DEVICE* drive;\n\tUINT error = ERROR_INTERNAL_ERROR;\n\n\tif (!pEntryPoints || !name || !path)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Invalid parameters: pEntryPoints=%p, name=%p, path=%p\", pEntryPoints,\n\t\t         name, path);\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tif (name[0] && path[0])\n\t{\n\t\tsize_t pathLength = strnlen(path, MAX_PATH);\n\t\tdrive = (DRIVE_DEVICE*)calloc(1, sizeof(DRIVE_DEVICE));\n\n\t\tif (!drive)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tdrive->device.type = RDPDR_DTYP_FILESYSTEM;\n\t\tdrive->device.IRPRequest = drive_irp_request;\n\t\tdrive->device.Free = drive_free;\n\t\tdrive->rdpcontext = pEntryPoints->rdpcontext;\n\t\tdrive->automount = automount;\n\t\tlength = strlen(name);\n\t\tdrive->device.data = Stream_New(NULL, length + 1);\n\n\t\tif (!drive->device.data)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tfor (i = 0; i < length; i++)\n\t\t{\n\t\t\t/* Filter 2.2.1.3 Device Announce Header (DEVICE_ANNOUNCE) forbidden symbols */\n\t\t\tswitch (name[i])\n\t\t\t{\n\t\t\t\tcase ':':\n\t\t\t\tcase '<':\n\t\t\t\tcase '>':\n\t\t\t\tcase '\\\"':\n\t\t\t\tcase '/':\n\t\t\t\tcase '\\\\':\n\t\t\t\tcase '|':\n\t\t\t\tcase ' ':\n\t\t\t\t\tStream_Write_UINT8(drive->device.data, '_');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tStream_Write_UINT8(drive->device.data, (BYTE)name[i]);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tStream_Write_UINT8(drive->device.data, '\\0');\n\n\t\tdrive->device.name = (const char*)Stream_Buffer(drive->device.data);\n\t\tif (!drive->device.name)\n\t\t\tgoto out_error;\n\n\t\tif ((pathLength > 1) && (path[pathLength - 1] == '/'))\n\t\t\tpathLength--;\n\n\t\tif (ConvertToUnicode(sys_code_page, 0, path, pathLength, &drive->path, 0) <= 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tdrive->files = ListDictionary_New(TRUE);\n\n\t\tif (!drive->files)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tListDictionary_ValueObject(drive->files)->fnObjectFree = drive_file_objfree;\n\t\tdrive->IrpQueue = MessageQueue_New(NULL);\n\n\t\tif (!drive->IrpQueue)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif ((error = pEntryPoints->RegisterDevice(pEntryPoints->devman, (DEVICE*)drive)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"RegisterDevice failed with error %\" PRIu32 \"!\", error);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (!(drive->thread =\n\t\t          CreateThread(NULL, 0, drive_thread_func, drive, CREATE_SUSPENDED, NULL)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"CreateThread failed!\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tResumeThread(drive->thread);\n\t}\n\n\treturn CHANNEL_RC_OK;\nout_error:\n\tdrive_free_int(drive);\n\treturn error;\n}\n\n#ifdef BUILTIN_CHANNELS\n#define DeviceServiceEntry drive_DeviceServiceEntry\n#else\n#define DeviceServiceEntry FREERDP_API DeviceServiceEntry\n#endif\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nUINT DeviceServiceEntry(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints)\n{\n\tRDPDR_DRIVE* drive;\n\tUINT error;\n#ifdef WIN32\n\tchar* dev;\n\tint len;\n\tchar devlist[512], buf[512];\n\tchar* bufdup;\n\tchar* devdup;\n#endif\n\tdrive = (RDPDR_DRIVE*)pEntryPoints->device;\n#ifndef WIN32\n\tsys_code_page = CP_UTF8;\n\n\tif (strcmp(drive->Path, \"*\") == 0)\n\t{\n\t\t/* all drives */\n\t\tfree(drive->Path);\n\t\tdrive->Path = _strdup(\"/\");\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\t}\n\telse if (strcmp(drive->Path, \"%\") == 0)\n\t{\n\t\tfree(drive->Path);\n\t\tdrive->Path = GetKnownPath(KNOWN_PATH_HOME);\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\t}\n\n\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n#else\n\tsys_code_page = GetACP();\n\n\t/* Special case: path[0] == '*' -> export all drives */\n\t/* Special case: path[0] == '%' -> user home dir */\n\tif (strcmp(drive->Path, \"%\") == 0)\n\t{\n\t\tGetEnvironmentVariableA(\"USERPROFILE\", buf, sizeof(buf));\n\t\tPathCchAddBackslashA(buf, sizeof(buf));\n\t\tfree(drive->Path);\n\t\tdrive->Path = _strdup(buf);\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n\t}\n\telse if (strcmp(drive->Path, \"*\") == 0)\n\t{\n\t\tint i;\n\t\t/* Enumerate all devices: */\n\t\tGetLogicalDriveStringsA(sizeof(devlist) - 1, devlist);\n\n\t\tfor (dev = devlist, i = 0; *dev; dev += 4, i++)\n\t\t{\n\t\t\tif (*dev > 'B')\n\t\t\t{\n\t\t\t\t/* Suppress disk drives A and B to avoid pesty messages */\n\t\t\t\tlen = sprintf_s(buf, sizeof(buf) - 4, \"%s\", drive->Name);\n\t\t\t\tbuf[len] = '_';\n\t\t\t\tbuf[len + 1] = dev[0];\n\t\t\t\tbuf[len + 2] = 0;\n\t\t\t\tbuf[len + 3] = 0;\n\n\t\t\t\tif (!(bufdup = _strdup(buf)))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tif (!(devdup = _strdup(dev)))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tif ((error = drive_register_drive_path(pEntryPoints, bufdup, devdup, TRUE)))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n\t}\n\n#endif\n\treturn error;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * File System Virtual Channel\n *\n * Copyright 2010-2011 Vic Lee\n * Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n * Copyright 2016 David PHAM-VAN <d.phamvan@inuvika.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n#include <winpr/path.h>\n#include <winpr/file.h>\n#include <winpr/string.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/stream.h>\n#include <winpr/environment.h>\n#include <winpr/interlocked.h>\n#include <winpr/collections.h>\n#include <winpr/shell.h>\n\n#include <freerdp/channels/rdpdr.h>\n\n#include \"drive_file.h\"\n\ntypedef struct _DRIVE_DEVICE DRIVE_DEVICE;\n\nstruct _DRIVE_DEVICE\n{\n\tDEVICE device;\n\n\tWCHAR* path;\n\tBOOL automount;\n\tUINT32 PathLength;\n\twListDictionary* files;\n\n\tHANDLE thread;\n\twMessageQueue* IrpQueue;\n\n\tDEVMAN* devman;\n\n\trdpContext* rdpcontext;\n};\n\nstatic UINT sys_code_page = 0;\n\nstatic DWORD drive_map_windows_err(DWORD fs_errno)\n{\n\tDWORD rc;\n\n\t/* try to return NTSTATUS version of error code */\n\n\tswitch (fs_errno)\n\t{\n\t\tcase STATUS_SUCCESS:\n\t\t\trc = STATUS_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase ERROR_ACCESS_DENIED:\n\t\tcase ERROR_SHARING_VIOLATION:\n\t\t\trc = STATUS_ACCESS_DENIED;\n\t\t\tbreak;\n\n\t\tcase ERROR_FILE_NOT_FOUND:\n\t\t\trc = STATUS_NO_SUCH_FILE;\n\t\t\tbreak;\n\n\t\tcase ERROR_BUSY_DRIVE:\n\t\t\trc = STATUS_DEVICE_BUSY;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_DRIVE:\n\t\t\trc = STATUS_NO_SUCH_DEVICE;\n\t\t\tbreak;\n\n\t\tcase ERROR_NOT_READY:\n\t\t\trc = STATUS_NO_SUCH_DEVICE;\n\t\t\tbreak;\n\n\t\tcase ERROR_FILE_EXISTS:\n\t\tcase ERROR_ALREADY_EXISTS:\n\t\t\trc = STATUS_OBJECT_NAME_COLLISION;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_NAME:\n\t\t\trc = STATUS_NO_SUCH_FILE;\n\t\t\tbreak;\n\n\t\tcase ERROR_INVALID_HANDLE:\n\t\t\trc = STATUS_INVALID_HANDLE;\n\t\t\tbreak;\n\n\t\tcase ERROR_NO_MORE_FILES:\n\t\t\trc = STATUS_NO_MORE_FILES;\n\t\t\tbreak;\n\n\t\tcase ERROR_DIRECTORY:\n\t\t\trc = STATUS_NOT_A_DIRECTORY;\n\t\t\tbreak;\n\n\t\tcase ERROR_PATH_NOT_FOUND:\n\t\t\trc = STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trc = STATUS_UNSUCCESSFUL;\n\t\t\tWLog_ERR(TAG, \"Error code not found: %\" PRIu32 \"\", fs_errno);\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic DRIVE_FILE* drive_get_file_by_id(DRIVE_DEVICE* drive, UINT32 id)\n{\n\tDRIVE_FILE* file = NULL;\n\tvoid* key = (void*)(size_t)id;\n\n\tif (!drive)\n\t\treturn NULL;\n\n\tfile = (DRIVE_FILE*)ListDictionary_GetItemValue(drive->files, key);\n\treturn file;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_create(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FileId;\n\tDRIVE_FILE* file;\n\tBYTE Information;\n\tUINT32 FileAttributes;\n\tUINT32 SharedAccess;\n\tUINT32 DesiredAccess;\n\tUINT32 CreateDisposition;\n\tUINT32 CreateOptions;\n\tUINT32 PathLength;\n\tUINT64 allocationSize;\n\tconst WCHAR* path;\n\n\tif (!drive || !irp || !irp->devman || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 6 * 4 + 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);\n\tStream_Read_UINT64(irp->input, allocationSize);\n\tStream_Read_UINT32(irp->input, FileAttributes);\n\tStream_Read_UINT32(irp->input, SharedAccess);\n\tStream_Read_UINT32(irp->input, CreateDisposition);\n\tStream_Read_UINT32(irp->input, CreateOptions);\n\tStream_Read_UINT32(irp->input, PathLength);\n\n\tif (Stream_GetRemainingLength(irp->input) < PathLength)\n\t\treturn ERROR_INVALID_DATA;\n\n\tpath = (const WCHAR*)Stream_Pointer(irp->input);\n\tFileId = irp->devman->id_sequence++;\n\tfile = drive_file_new(drive->path, path, PathLength, FileId, DesiredAccess, CreateDisposition,\n\t                      CreateOptions, FileAttributes, SharedAccess);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tFileId = 0;\n\t\tInformation = 0;\n\t}\n\telse\n\t{\n\t\tvoid* key = (void*)(size_t)file->id;\n\n\t\tif (!ListDictionary_Add(drive->files, key, file))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_Add failed!\");\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\n\t\tswitch (CreateDisposition)\n\t\t{\n\t\t\tcase FILE_SUPERSEDE:\n\t\t\tcase FILE_OPEN:\n\t\t\tcase FILE_CREATE:\n\t\t\tcase FILE_OVERWRITE:\n\t\t\t\tInformation = FILE_SUPERSEDED;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OPEN_IF:\n\t\t\t\tInformation = FILE_OPENED;\n\t\t\t\tbreak;\n\n\t\t\tcase FILE_OVERWRITE_IF:\n\t\t\t\tInformation = FILE_OVERWRITTEN;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tInformation = 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tStream_Write_UINT32(irp->output, FileId);\n\tStream_Write_UINT8(irp->output, Information);\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_close(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tvoid* key;\n\tDRIVE_FILE* file;\n\n\tif (!drive || !irp || !irp->Complete || !irp->output)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tkey = (void*)(size_t)irp->FileId;\n\n\tif (!file)\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\telse\n\t{\n\t\tListDictionary_Remove(drive->files, key);\n\n\t\tif (drive_file_free(file))\n\t\t\tirp->IoStatus = STATUS_SUCCESS;\n\t\telse\n\t\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\tStream_Zero(irp->output, 5); /* Padding(5) */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_read(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\n\tif (!drive || !irp || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tif (!Stream_EnsureRemainingCapacity(irp->output, Length + 4))\n\t{\n\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\telse if (Length == 0)\n\t\tStream_Write_UINT32(irp->output, 0);\n\telse\n\t{\n\t\tBYTE* buffer = Stream_Pointer(irp->output) + sizeof(UINT32);\n\n\t\tif (!drive_file_read(file, buffer, &Length))\n\t\t{\n\t\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\t\tStream_Write_UINT32(irp->output, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT32(irp->output, Length);\n\t\t\tStream_Seek(irp->output, Length);\n\t\t}\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\tvoid* ptr;\n\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); /* Padding */\n\tptr = Stream_Pointer(irp->input);\n\tif (!Stream_SafeSeek(irp->input, Length))\n\t\treturn ERROR_INVALID_DATA;\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, ptr, Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); /* Padding */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t}\n\telse if (!drive_file_query_information(file, FsInformationClass, irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_set_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 FsInformationClass;\n\tUINT32 Length;\n\n\tif (!drive || !irp || !irp->Complete || !irp->input || !irp->output)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Seek(irp->input, 24); /* Padding */\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t}\n\telse if (!drive_file_set_information(file, FsInformationClass, Length, irp->input))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\tif (file && file->is_dir && !PathIsDirectoryEmptyW(file->fullpath))\n\t\tirp->IoStatus = STATUS_DIRECTORY_NOT_EMPTY;\n\n\tStream_Write_UINT32(irp->output, Length);\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_volume_information(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FsInformationClass;\n\twStream* output = NULL;\n\tchar* volumeLabel = { \"FREERDP\" };\n\tchar* diskType = { \"FAT32\" };\n\tWCHAR* outStr = NULL;\n\tint length;\n\tDWORD lpSectorsPerCluster;\n\tDWORD lpBytesPerSector;\n\tDWORD lpNumberOfFreeClusters;\n\tDWORD lpTotalNumberOfClusters;\n\tWIN32_FILE_ATTRIBUTE_DATA wfad;\n\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\toutput = irp->output;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tGetDiskFreeSpaceW(drive->path, &lpSectorsPerCluster, &lpBytesPerSector, &lpNumberOfFreeClusters,\n\t                  &lpTotalNumberOfClusters);\n\n\tswitch (FsInformationClass)\n\t{\n\t\tcase FileFsVolumeInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232108.aspx */\n\t\t\tif ((length = ConvertToUnicode(sys_code_page, 0, volumeLabel, -1, &outStr, 0) * 2) <= 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, 17 + length); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 17 + length))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\tfree(outStr);\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tGetFileAttributesExW(drive->path, GetFileExInfoStandard, &wfad);\n\t\t\tStream_Write_UINT32(output, wfad.ftCreationTime.dwLowDateTime); /* VolumeCreationTime */\n\t\t\tStream_Write_UINT32(output,\n\t\t\t                    wfad.ftCreationTime.dwHighDateTime);      /* VolumeCreationTime */\n\t\t\tStream_Write_UINT32(output, lpNumberOfFreeClusters & 0xffff); /* VolumeSerialNumber */\n\t\t\tStream_Write_UINT32(output, length);                          /* VolumeLabelLength */\n\t\t\tStream_Write_UINT8(output, 0);                                /* SupportsObjects */\n\t\t\t/* Reserved(1), MUST NOT be added! */\n\t\t\tStream_Write(output, outStr, length); /* VolumeLabel (Unicode) */\n\t\t\tfree(outStr);\n\t\t\tbreak;\n\n\t\tcase FileFsSizeInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232107.aspx */\n\t\t\tStream_Write_UINT32(output, 24); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 24))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT64(output, lpTotalNumberOfClusters); /* TotalAllocationUnits */\n\t\t\tStream_Write_UINT64(output, lpNumberOfFreeClusters);  /* AvailableAllocationUnits */\n\t\t\tStream_Write_UINT32(output, lpSectorsPerCluster);     /* SectorsPerAllocationUnit */\n\t\t\tStream_Write_UINT32(output, lpBytesPerSector);        /* BytesPerSector */\n\t\t\tbreak;\n\n\t\tcase FileFsAttributeInformation:\n\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232101.aspx */\n\t\t\tif ((length = ConvertToUnicode(sys_code_page, 0, diskType, -1, &outStr, 0) * 2) <= 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, 12 + length); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 12 + length))\n\t\t\t{\n\t\t\t\tfree(outStr);\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, FILE_CASE_SENSITIVE_SEARCH | FILE_CASE_PRESERVED_NAMES |\n\t\t\t                                FILE_UNICODE_ON_DISK); /* FileSystemAttributes */\n\t\t\tStream_Write_UINT32(output, MAX_PATH);                 /* MaximumComponentNameLength */\n\t\t\tStream_Write_UINT32(output, length);                   /* FileSystemNameLength */\n\t\t\tStream_Write(output, outStr, length);                  /* FileSystemName (Unicode) */\n\t\t\tfree(outStr);\n\t\t\tbreak;\n\n\t\tcase FileFsFullSizeInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232104.aspx */\n\t\t\tStream_Write_UINT32(output, 32); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 32))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT64(output, lpTotalNumberOfClusters); /* TotalAllocationUnits */\n\t\t\tStream_Write_UINT64(output,\n\t\t\t                    lpNumberOfFreeClusters); /* CallerAvailableAllocationUnits */\n\t\t\tStream_Write_UINT64(output, lpNumberOfFreeClusters); /* AvailableAllocationUnits */\n\t\t\tStream_Write_UINT32(output, lpSectorsPerCluster);    /* SectorsPerAllocationUnit */\n\t\t\tStream_Write_UINT32(output, lpBytesPerSector);       /* BytesPerSector */\n\t\t\tbreak;\n\n\t\tcase FileFsDeviceInformation:\n\t\t\t/* http://msdn.microsoft.com/en-us/library/cc232109.aspx */\n\t\t\tStream_Write_UINT32(output, 8); /* Length */\n\n\t\t\tif (!Stream_EnsureRemainingCapacity(output, 8))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t}\n\n\t\t\tStream_Write_UINT32(output, FILE_DEVICE_DISK); /* DeviceType */\n\t\t\tStream_Write_UINT32(output, 0);                /* Characteristics */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\t\tStream_Write_UINT32(output, 0); /* Length */\n\t\t\tbreak;\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/* http://msdn.microsoft.com/en-us/library/cc241518.aspx */\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_silent_ignore(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Write_UINT32(irp->output, 0); /* Length */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tconst WCHAR* path;\n\tDRIVE_FILE* file;\n\tBYTE InitialQuery;\n\tUINT32 PathLength;\n\tUINT32 FsInformationClass;\n\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT8(irp->input, InitialQuery);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tStream_Seek(irp->input, 23); /* Padding */\n\tpath = (WCHAR*)Stream_Pointer(irp->input);\n\tif (!Stream_CheckAndLogRequiredLength(TAG, irp->input, PathLength))\n\t\treturn ERROR_INVALID_DATA;\n\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (file == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tStream_Write_UINT32(irp->output, 0); /* Length */\n\t}\n\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path, PathLength,\n\t                                     irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_directory_control(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tswitch (irp->MinorFunction)\n\t{\n\t\tcase IRP_MN_QUERY_DIRECTORY:\n\t\t\treturn drive_process_irp_query_directory(drive, irp);\n\n\t\tcase IRP_MN_NOTIFY_CHANGE_DIRECTORY: /* TODO */\n\t\t\treturn irp->Discard(irp);\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\tStream_Write_UINT32(irp->output, 0); /* Length */\n\t\t\treturn irp->Complete(irp);\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp_device_control(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tStream_Write_UINT32(irp->output, 0); /* OutputBufferLength */\n\treturn irp->Complete(irp);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_process_irp(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tUINT error;\n\n\tif (!drive || !irp)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tirp->IoStatus = STATUS_SUCCESS;\n\n\tswitch (irp->MajorFunction)\n\t{\n\t\tcase IRP_MJ_CREATE:\n\t\t\terror = drive_process_irp_create(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_CLOSE:\n\t\t\terror = drive_process_irp_close(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_READ:\n\t\t\terror = drive_process_irp_read(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_WRITE:\n\t\t\terror = drive_process_irp_write(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_INFORMATION:\n\t\t\terror = drive_process_irp_query_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_SET_INFORMATION:\n\t\t\terror = drive_process_irp_set_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_VOLUME_INFORMATION:\n\t\t\terror = drive_process_irp_query_volume_information(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_LOCK_CONTROL:\n\t\t\terror = drive_process_irp_silent_ignore(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DIRECTORY_CONTROL:\n\t\t\terror = drive_process_irp_directory_control(drive, irp);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\terror = drive_process_irp_device_control(drive, irp);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tirp->IoStatus = STATUS_NOT_SUPPORTED;\n\t\t\terror = irp->Complete(irp);\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\n\nstatic DWORD WINAPI drive_thread_func(LPVOID arg)\n{\n\tIRP* irp;\n\twMessage message;\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)arg;\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t{\n\t\terror = ERROR_INVALID_PARAMETER;\n\t\tgoto fail;\n\t}\n\n\twhile (1)\n\t{\n\t\tif (!MessageQueue_Wait(drive->IrpQueue))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Wait failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!MessageQueue_Peek(drive->IrpQueue, &message, TRUE))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"MessageQueue_Peek failed!\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (message.id == WMQ_QUIT)\n\t\t\tbreak;\n\n\t\tirp = (IRP*)message.wParam;\n\n\t\tif (irp)\n\t\t{\n\t\t\tif ((error = drive_process_irp(drive, irp)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"drive_process_irp failed with error %\" PRIu32 \"!\", error);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nfail:\n\n\tif (error && drive && drive->rdpcontext)\n\t\tsetChannelError(drive->rdpcontext, error, \"drive_thread_func reported an error\");\n\n\tExitThread(error);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_irp_request(DEVICE* device, IRP* irp)\n{\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)device;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (!MessageQueue_Post(drive->IrpQueue, NULL, 0, (void*)irp, NULL))\n\t{\n\t\tWLog_ERR(TAG, \"MessageQueue_Post failed!\");\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn CHANNEL_RC_OK;\n}\n\nstatic UINT drive_free_int(DRIVE_DEVICE* drive)\n{\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tCloseHandle(drive->thread);\n\tListDictionary_Free(drive->files);\n\tMessageQueue_Free(drive->IrpQueue);\n\tStream_Free(drive->device.data, TRUE);\n\tfree(drive->path);\n\tfree(drive);\n\treturn error;\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_free(DEVICE* device)\n{\n\tDRIVE_DEVICE* drive = (DRIVE_DEVICE*)device;\n\tUINT error = CHANNEL_RC_OK;\n\n\tif (!drive)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (MessageQueue_PostQuit(drive->IrpQueue, 0) &&\n\t    (WaitForSingleObject(drive->thread, INFINITE) == WAIT_FAILED))\n\t{\n\t\terror = GetLastError();\n\t\tWLog_ERR(TAG, \"WaitForSingleObject failed with error %\" PRIu32 \"\", error);\n\t\treturn error;\n\t}\n\n\treturn drive_free_int(drive);\n}\n\n/**\n * Helper function used for freeing list dictionary value object\n */\nstatic void drive_file_objfree(void* obj)\n{\n\tdrive_file_free((DRIVE_FILE*)obj);\n}\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nstatic UINT drive_register_drive_path(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints, const char* name,\n                                      const char* path, BOOL automount)\n{\n\tsize_t i, length;\n\tDRIVE_DEVICE* drive;\n\tUINT error = ERROR_INTERNAL_ERROR;\n\n\tif (!pEntryPoints || !name || !path)\n\t{\n\t\tWLog_ERR(TAG, \"[%s] Invalid parameters: pEntryPoints=%p, name=%p, path=%p\", pEntryPoints,\n\t\t         name, path);\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tif (name[0] && path[0])\n\t{\n\t\tsize_t pathLength = strnlen(path, MAX_PATH);\n\t\tdrive = (DRIVE_DEVICE*)calloc(1, sizeof(DRIVE_DEVICE));\n\n\t\tif (!drive)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tdrive->device.type = RDPDR_DTYP_FILESYSTEM;\n\t\tdrive->device.IRPRequest = drive_irp_request;\n\t\tdrive->device.Free = drive_free;\n\t\tdrive->rdpcontext = pEntryPoints->rdpcontext;\n\t\tdrive->automount = automount;\n\t\tlength = strlen(name);\n\t\tdrive->device.data = Stream_New(NULL, length + 1);\n\n\t\tif (!drive->device.data)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tfor (i = 0; i < length; i++)\n\t\t{\n\t\t\t/* Filter 2.2.1.3 Device Announce Header (DEVICE_ANNOUNCE) forbidden symbols */\n\t\t\tswitch (name[i])\n\t\t\t{\n\t\t\t\tcase ':':\n\t\t\t\tcase '<':\n\t\t\t\tcase '>':\n\t\t\t\tcase '\\\"':\n\t\t\t\tcase '/':\n\t\t\t\tcase '\\\\':\n\t\t\t\tcase '|':\n\t\t\t\tcase ' ':\n\t\t\t\t\tStream_Write_UINT8(drive->device.data, '_');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tStream_Write_UINT8(drive->device.data, (BYTE)name[i]);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tStream_Write_UINT8(drive->device.data, '\\0');\n\n\t\tdrive->device.name = (const char*)Stream_Buffer(drive->device.data);\n\t\tif (!drive->device.name)\n\t\t\tgoto out_error;\n\n\t\tif ((pathLength > 1) && (path[pathLength - 1] == '/'))\n\t\t\tpathLength--;\n\n\t\tif (ConvertToUnicode(sys_code_page, 0, path, pathLength, &drive->path, 0) <= 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ConvertToUnicode failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tdrive->files = ListDictionary_New(TRUE);\n\n\t\tif (!drive->files)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tListDictionary_ValueObject(drive->files)->fnObjectFree = drive_file_objfree;\n\t\tdrive->IrpQueue = MessageQueue_New(NULL);\n\n\t\tif (!drive->IrpQueue)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"ListDictionary_New failed!\");\n\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif ((error = pEntryPoints->RegisterDevice(pEntryPoints->devman, (DEVICE*)drive)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"RegisterDevice failed with error %\" PRIu32 \"!\", error);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (!(drive->thread =\n\t\t          CreateThread(NULL, 0, drive_thread_func, drive, CREATE_SUSPENDED, NULL)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"CreateThread failed!\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tResumeThread(drive->thread);\n\t}\n\n\treturn CHANNEL_RC_OK;\nout_error:\n\tdrive_free_int(drive);\n\treturn error;\n}\n\n#ifdef BUILTIN_CHANNELS\n#define DeviceServiceEntry drive_DeviceServiceEntry\n#else\n#define DeviceServiceEntry FREERDP_API DeviceServiceEntry\n#endif\n\n/**\n * Function description\n *\n * @return 0 on success, otherwise a Win32 error code\n */\nUINT DeviceServiceEntry(PDEVICE_SERVICE_ENTRY_POINTS pEntryPoints)\n{\n\tRDPDR_DRIVE* drive;\n\tUINT error;\n#ifdef WIN32\n\tchar* dev;\n\tint len;\n\tchar devlist[512], buf[512];\n\tchar* bufdup;\n\tchar* devdup;\n#endif\n\tdrive = (RDPDR_DRIVE*)pEntryPoints->device;\n#ifndef WIN32\n\tsys_code_page = CP_UTF8;\n\n\tif (strcmp(drive->Path, \"*\") == 0)\n\t{\n\t\t/* all drives */\n\t\tfree(drive->Path);\n\t\tdrive->Path = _strdup(\"/\");\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\t}\n\telse if (strcmp(drive->Path, \"%\") == 0)\n\t{\n\t\tfree(drive->Path);\n\t\tdrive->Path = GetKnownPath(KNOWN_PATH_HOME);\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\t}\n\n\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n#else\n\tsys_code_page = GetACP();\n\n\t/* Special case: path[0] == '*' -> export all drives */\n\t/* Special case: path[0] == '%' -> user home dir */\n\tif (strcmp(drive->Path, \"%\") == 0)\n\t{\n\t\tGetEnvironmentVariableA(\"USERPROFILE\", buf, sizeof(buf));\n\t\tPathCchAddBackslashA(buf, sizeof(buf));\n\t\tfree(drive->Path);\n\t\tdrive->Path = _strdup(buf);\n\n\t\tif (!drive->Path)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n\t}\n\telse if (strcmp(drive->Path, \"*\") == 0)\n\t{\n\t\tint i;\n\t\t/* Enumerate all devices: */\n\t\tGetLogicalDriveStringsA(sizeof(devlist) - 1, devlist);\n\n\t\tfor (dev = devlist, i = 0; *dev; dev += 4, i++)\n\t\t{\n\t\t\tif (*dev > 'B')\n\t\t\t{\n\t\t\t\t/* Suppress disk drives A and B to avoid pesty messages */\n\t\t\t\tlen = sprintf_s(buf, sizeof(buf) - 4, \"%s\", drive->Name);\n\t\t\t\tbuf[len] = '_';\n\t\t\t\tbuf[len + 1] = dev[0];\n\t\t\t\tbuf[len + 2] = 0;\n\t\t\t\tbuf[len + 3] = 0;\n\n\t\t\t\tif (!(bufdup = _strdup(buf)))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tif (!(devdup = _strdup(dev)))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"_strdup failed!\");\n\t\t\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tif ((error = drive_register_drive_path(pEntryPoints, bufdup, devdup, TRUE)))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\terror = drive_register_drive_path(pEntryPoints, drive->Name, drive->Path, drive->automount);\n\t}\n\n#endif\n\treturn error;\n}\n"], "filenames": ["channels/drive/client/drive_main.c"], "buggy_code_start_loc": [631], "buggy_code_end_loc": [631], "fixing_code_start_loc": [632], "fixing_code_end_loc": [635], "type": "CWE-119", "message": "FreeRDP is a free remote desktop protocol library and clients. Affected versions of FreeRDP are missing input length validation in `drive` channel. A malicious server can trick a FreeRDP based client to read out of bound data and send it back to the server. This issue has been addressed in version 2.9.0 and all users are advised to upgrade. Users unable to upgrade should not use the drive redirection channel - command line options `/drive`, `+drives` or `+home-drive`.", "other": {"cve": {"id": "CVE-2022-41877", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-16T20:15:10.507", "lastModified": "2023-01-25T19:56:41.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FreeRDP is a free remote desktop protocol library and clients. Affected versions of FreeRDP are missing input length validation in `drive` channel. A malicious server can trick a FreeRDP based client to read out of bound data and send it back to the server. This issue has been addressed in version 2.9.0 and all users are advised to upgrade. Users unable to upgrade should not use the drive redirection channel - command line options `/drive`, `+drives` or `+home-drive`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.9.0", "matchCriteriaId": "AF273D61-AA72-44FE-937E-D5749D565AEE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/6655841cf2a00b764f855040aecb8803cfc5eaba", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-pmv3-wpw4-pw5h", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UDOTAOJBCZKREZJPT6VZ25GESI5T6RBG/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YGQN3OWQNHSMWKOF4D35PF5ASKNLC74B/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/6655841cf2a00b764f855040aecb8803cfc5eaba"}}