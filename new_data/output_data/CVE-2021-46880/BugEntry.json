{"buggy_code": ["/* $OpenBSD: x509_internal.h,v 1.15 2021/11/04 23:52:34 beck Exp $ */\n/*\n * Copyright (c) 2020 Bob Beck <beck@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n#ifndef HEADER_X509_INTERNAL_H\n#define HEADER_X509_INTERNAL_H\n\n/* Internal use only, not public API */\n#include <netinet/in.h>\n\n#include <openssl/x509_verify.h>\n\n#include \"x509_lcl.h\"\n\n/* Hard limits on structure size and number of signature checks. */\n#define X509_VERIFY_MAX_CHAINS\t\t8\t/* Max validated chains */\n#define X509_VERIFY_MAX_CHAIN_CERTS\t32\t/* Max depth of a chain */\n#define X509_VERIFY_MAX_SIGCHECKS\t256\t/* Max signature checks */\n\n/*\n * Limit the number of names and constraints we will check in a chain\n * to avoid a hostile input DOS\n */\n#define X509_VERIFY_MAX_CHAIN_NAMES\t\t512\n#define X509_VERIFY_MAX_CHAIN_CONSTRAINTS\t512\n\n/*\n * Hold the parsed and validated result of names from a certificate.\n * these typically come from a GENERALNAME, but we store the parsed\n * and validated results, not the ASN1 bytes.\n */\nstruct x509_constraints_name {\n\tint type;\t\t\t/* GEN_* types from GENERAL_NAME */\n\tchar *name;\t\t\t/* Name to check */\n\tchar *local;\t\t\t/* holds the local part of GEN_EMAIL */\n\tuint8_t *der;\t\t\t/* DER encoded value or NULL*/\n\tsize_t der_len;\n\tint af;\t\t\t\t/* INET and INET6 are supported */\n\tuint8_t address[32];\t\t/* Must hold ipv6 + mask */\n};\n\nstruct x509_constraints_names {\n\tstruct x509_constraints_name **names;\n\tsize_t names_count;\n\tsize_t names_len;\n\tsize_t names_max;\n};\n\nstruct x509_verify_chain {\n\tSTACK_OF(X509) *certs;\t\t/* Kept in chain order, includes leaf */\n\tint *cert_errors;\t\t/* Verify error for each cert in chain. */\n\tstruct x509_constraints_names *names;\t/* All names from all certs */\n};\n\nstruct x509_verify_ctx {\n\tX509_STORE_CTX *xsc;\n\tstruct x509_verify_chain **chains;\t/* Validated chains */\n\tSTACK_OF(X509) *saved_error_chain;\n\tint saved_error;\n\tint saved_error_depth;\n\tsize_t chains_count;\n\tSTACK_OF(X509) *roots;\t\t/* Trusted roots for this validation */\n\tSTACK_OF(X509) *intermediates;\t/* Intermediates provided by peer */\n\ttime_t *check_time;\t\t/* Time for validity checks */\n\tint purpose;\t\t\t/* Cert purpose we are validating */\n\tsize_t max_chains;\t\t/* Max chains to return */\n\tsize_t max_depth;\t\t/* Max chain depth for validation */\n\tsize_t max_sigs;\t\t/* Max number of signature checks */\n\tsize_t sig_checks;\t\t/* Number of signature checks done */\n\tsize_t error_depth;\t\t/* Depth of last error seen */\n\tint error;\t\t\t/* Last error seen */\n};\n\nint ASN1_time_tm_clamp_notafter(struct tm *tm);\n\n__BEGIN_HIDDEN_DECLS\n\nint x509_vfy_check_id(X509_STORE_CTX *ctx);\nint x509_vfy_check_revocation(X509_STORE_CTX *ctx);\nint x509_vfy_check_policy(X509_STORE_CTX *ctx);\nint x509_vfy_check_trust(X509_STORE_CTX *ctx);\nint x509_vfy_check_chain_extensions(X509_STORE_CTX *ctx);\nint x509_vfy_callback_indicate_success(X509_STORE_CTX *ctx);\nvoid x509v3_cache_extensions(X509 *x);\nX509 *x509_vfy_lookup_cert_match(X509_STORE_CTX *ctx, X509 *x);\n\ntime_t x509_verify_asn1_time_to_time_t(const ASN1_TIME *atime, int notafter);\n\nstruct x509_verify_ctx *x509_verify_ctx_new_from_xsc(X509_STORE_CTX *xsc);\n\nvoid x509_constraints_name_clear(struct x509_constraints_name *name);\nint x509_constraints_names_add(struct x509_constraints_names *names,\n    struct x509_constraints_name *name);\nstruct x509_constraints_names *x509_constraints_names_dup(\n    struct x509_constraints_names *names);\nvoid x509_constraints_names_clear(struct x509_constraints_names *names);\nstruct x509_constraints_names *x509_constraints_names_new(size_t names_max);\nint x509_constraints_general_to_bytes(GENERAL_NAME *name, uint8_t **bytes,\n    size_t *len);\nvoid x509_constraints_names_free(struct x509_constraints_names *names);\nint x509_constraints_valid_host(uint8_t *name, size_t len);\nint x509_constraints_valid_sandns(uint8_t *name, size_t len);\nint x509_constraints_domain(char *domain, size_t dlen, char *constraint,\n    size_t len);\nint x509_constraints_parse_mailbox(uint8_t *candidate, size_t len,\n    struct x509_constraints_name *name);\nint x509_constraints_valid_domain_constraint(uint8_t *constraint,\n    size_t len);\nint x509_constraints_uri_host(uint8_t *uri, size_t len, char **hostp);\nint x509_constraints_uri(uint8_t *uri, size_t ulen, uint8_t *constraint,\n    size_t len, int *error);\nint x509_constraints_extract_names(struct x509_constraints_names *names,\n    X509 *cert, int include_cn, int *error);\nint x509_constraints_extract_constraints(X509 *cert,\n    struct x509_constraints_names *permitted,\n    struct x509_constraints_names *excluded, int *error);\nint x509_constraints_check(struct x509_constraints_names *names,\n    struct x509_constraints_names *permitted,\n    struct x509_constraints_names *excluded, int *error);\nint x509_constraints_chain(STACK_OF(X509) *chain, int *error,\n    int *depth);\nvoid x509_verify_cert_info_populate(X509 *cert);\n\n__END_HIDDEN_DECLS\n\n#endif\n", "/* $OpenBSD: x509_verify.c,v 1.53 2021/11/14 08:21:47 jsing Exp $ */\n/*\n * Copyright (c) 2020-2021 Bob Beck <beck@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/* x509_verify - inspired by golang's crypto/x509.Verify */\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <openssl/safestack.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n\n#include \"x509_internal.h\"\n#include \"x509_issuer_cache.h\"\n\nstatic int x509_verify_cert_valid(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain);\nstatic void x509_verify_build_chains(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain, int full_chain);\nstatic int x509_verify_cert_error(struct x509_verify_ctx *ctx, X509 *cert,\n    size_t depth, int error, int ok);\nstatic void x509_verify_chain_free(struct x509_verify_chain *chain);\n\n/*\n * Parse an asn1 to a representable time_t as per RFC 5280 rules.\n * Returns -1 if that can't be done for any reason.\n */\ntime_t\nx509_verify_asn1_time_to_time_t(const ASN1_TIME *atime, int notAfter)\n{\n\tstruct tm tm = { 0 };\n\tint type;\n\n\ttype = ASN1_time_parse(atime->data, atime->length, &tm, atime->type);\n\tif (type == -1)\n\t\treturn -1;\n\n\t/* RFC 5280 section 4.1.2.5 */\n\tif (tm.tm_year < 150 && type != V_ASN1_UTCTIME)\n\t\treturn -1;\n\tif (tm.tm_year >= 150 && type != V_ASN1_GENERALIZEDTIME)\n\t\treturn -1;\n\n\tif (notAfter) {\n\t\t/*\n\t\t * If we are a completely broken operating system with a\n\t\t * 32 bit time_t, and we have been told this is a notAfter\n\t\t * date, limit the date to a 32 bit representable value.\n\t\t */\n\t\tif (!ASN1_time_tm_clamp_notafter(&tm))\n\t\t\treturn -1;\n\t}\n\n\t/*\n\t * Defensively fail if the time string is not representable as\n\t * a time_t. A time_t must be sane if you care about times after\n\t * Jan 19 2038.\n\t */\n\treturn timegm(&tm);\n}\n\n/*\n * Cache certificate hash, and values parsed out of an X509.\n * called from cache_extensions()\n */\nvoid\nx509_verify_cert_info_populate(X509 *cert)\n{\n\t/*\n\t * Parse and save the cert times, or remember that they\n\t * are unacceptable/unparsable.\n\t */\n\tcert->not_before = x509_verify_asn1_time_to_time_t(X509_get_notBefore(cert), 0);\n\tcert->not_after = x509_verify_asn1_time_to_time_t(X509_get_notAfter(cert), 1);\n}\n\nstruct x509_verify_chain *\nx509_verify_chain_new(void)\n{\n\tstruct x509_verify_chain *chain;\n\n\tif ((chain = calloc(1, sizeof(*chain))) == NULL)\n\t\tgoto err;\n\tif ((chain->certs = sk_X509_new_null()) == NULL)\n\t\tgoto err;\n\tif ((chain->cert_errors = calloc(X509_VERIFY_MAX_CHAIN_CERTS,\n\t    sizeof(int))) == NULL)\n\t\tgoto err;\n\tif ((chain->names =\n\t    x509_constraints_names_new(X509_VERIFY_MAX_CHAIN_NAMES)) == NULL)\n\t\tgoto err;\n\n\treturn chain;\n err:\n\tx509_verify_chain_free(chain);\n\treturn NULL;\n}\n\nstatic void\nx509_verify_chain_clear(struct x509_verify_chain *chain)\n{\n\tsk_X509_pop_free(chain->certs, X509_free);\n\tchain->certs = NULL;\n\tfree(chain->cert_errors);\n\tchain->cert_errors = NULL;\n\tx509_constraints_names_free(chain->names);\n\tchain->names = NULL;\n}\n\nstatic void\nx509_verify_chain_free(struct x509_verify_chain *chain)\n{\n\tif (chain == NULL)\n\t\treturn;\n\tx509_verify_chain_clear(chain);\n\tfree(chain);\n}\n\nstatic struct x509_verify_chain *\nx509_verify_chain_dup(struct x509_verify_chain *chain)\n{\n\tstruct x509_verify_chain *new_chain;\n\n\tif ((new_chain = calloc(1, sizeof(*chain))) == NULL)\n\t\tgoto err;\n\tif ((new_chain->certs = X509_chain_up_ref(chain->certs)) == NULL)\n\t\tgoto err;\n\tif ((new_chain->cert_errors = calloc(X509_VERIFY_MAX_CHAIN_CERTS,\n\t    sizeof(int))) == NULL)\n\t\tgoto err;\n\tmemcpy(new_chain->cert_errors, chain->cert_errors,\n\t    X509_VERIFY_MAX_CHAIN_CERTS * sizeof(int));\n\tif ((new_chain->names =\n\t    x509_constraints_names_dup(chain->names)) == NULL)\n\t\tgoto err;\n\treturn(new_chain);\n err:\n\tx509_verify_chain_free(new_chain);\n\treturn NULL;\n}\n\nstatic int\nx509_verify_chain_append(struct x509_verify_chain *chain, X509 *cert,\n    int *error)\n{\n\tint verify_err = X509_V_ERR_UNSPECIFIED;\n\tsize_t idx;\n\n\tif (!x509_constraints_extract_names(chain->names, cert,\n\t    sk_X509_num(chain->certs) == 0, &verify_err)) {\n\t\t*error = verify_err;\n\t\treturn 0;\n\t}\n\n\tX509_up_ref(cert);\n\tif (!sk_X509_push(chain->certs, cert)) {\n\t\tX509_free(cert);\n\t\t*error = X509_V_ERR_OUT_OF_MEM;\n\t\treturn 0;\n\t}\n\n\tidx = sk_X509_num(chain->certs) - 1;\n\tchain->cert_errors[idx] = *error;\n\n\t/*\n\t * We've just added the issuer for the previous certificate,\n\t * clear its error if appropriate.\n\t */\n\tif (idx > 1 && chain->cert_errors[idx - 1] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[idx - 1] = X509_V_OK;\n\n\treturn 1;\n}\n\nstatic X509 *\nx509_verify_chain_last(struct x509_verify_chain *chain)\n{\n\tint last;\n\n\tif (chain->certs == NULL)\n\t\treturn NULL;\n\tif ((last = sk_X509_num(chain->certs) - 1) < 0)\n\t\treturn NULL;\n\treturn sk_X509_value(chain->certs, last);\n}\n\nX509 *\nx509_verify_chain_leaf(struct x509_verify_chain *chain)\n{\n\tif (chain->certs == NULL)\n\t\treturn NULL;\n\treturn sk_X509_value(chain->certs, 0);\n}\n\nstatic void\nx509_verify_ctx_reset(struct x509_verify_ctx *ctx)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ctx->chains_count; i++)\n\t\tx509_verify_chain_free(ctx->chains[i]);\n\tsk_X509_pop_free(ctx->saved_error_chain, X509_free);\n\tctx->saved_error = 0;\n\tctx->saved_error_depth = 0;\n\tctx->error = 0;\n\tctx->error_depth = 0;\n\tctx->chains_count = 0;\n\tctx->sig_checks = 0;\n\tctx->check_time = NULL;\n}\n\nstatic void\nx509_verify_ctx_clear(struct x509_verify_ctx *ctx)\n{\n\tx509_verify_ctx_reset(ctx);\n\tsk_X509_pop_free(ctx->intermediates, X509_free);\n\tfree(ctx->chains);\n\tmemset(ctx, 0, sizeof(*ctx));\n}\n\nstatic int\nx509_verify_cert_cache_extensions(X509 *cert) {\n\tif (!(cert->ex_flags & EXFLAG_SET)) {\n\t\tCRYPTO_w_lock(CRYPTO_LOCK_X509);\n\t\tx509v3_cache_extensions(cert);\n\t\tCRYPTO_w_unlock(CRYPTO_LOCK_X509);\n\t}\n\tif (cert->ex_flags & EXFLAG_INVALID)\n\t\treturn 0;\n\n\treturn (cert->ex_flags & EXFLAG_SET);\n}\n\nstatic int\nx509_verify_cert_self_signed(X509 *cert)\n{\n\treturn (cert->ex_flags & EXFLAG_SS) ? 1 : 0;\n}\n\nstatic int\nx509_verify_ctx_cert_is_root(struct x509_verify_ctx *ctx, X509 *cert,\n    int full_chain)\n{\n\tX509 *match = NULL;\n\tint i;\n\n\tif (!x509_verify_cert_cache_extensions(cert))\n\t\treturn 0;\n\n\t/* Check by lookup if we have a legacy xsc */\n\tif (ctx->xsc != NULL) {\n\t\tif ((match = x509_vfy_lookup_cert_match(ctx->xsc,\n\t\t    cert)) != NULL) {\n\t\t\tX509_free(match);\n\t\t\treturn !full_chain ||\n\t\t\t    x509_verify_cert_self_signed(cert);\n\t\t}\n\t} else {\n\t\t/* Check the provided roots */\n\t\tfor (i = 0; i < sk_X509_num(ctx->roots); i++) {\n\t\t\tif (X509_cmp(sk_X509_value(ctx->roots, i), cert) == 0)\n\t\t\t\treturn !full_chain ||\n\t\t\t\t    x509_verify_cert_self_signed(cert);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nx509_verify_ctx_set_xsc_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, int set_error, int is_trusted)\n{\n\tsize_t num_untrusted;\n\tint i;\n\n\tif (ctx->xsc == NULL)\n\t\treturn 1;\n\n\t/*\n\t * XXX num_untrusted is the number of untrusted certs at the\n\t * bottom of the chain. This works now since we stop at the first\n\t * trusted cert. This will need fixing once we allow more than one\n\t * trusted certificate.\n\t */\n\tnum_untrusted = sk_X509_num(chain->certs);\n\tif (is_trusted && num_untrusted > 0)\n\t\tnum_untrusted--;\n\tctx->xsc->num_untrusted = num_untrusted;\n\n\tsk_X509_pop_free(ctx->xsc->chain, X509_free);\n\tctx->xsc->chain = X509_chain_up_ref(chain->certs);\n\tif (ctx->xsc->chain == NULL)\n\t\treturn x509_verify_cert_error(ctx, NULL, 0,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\n\tif (set_error) {\n\t\tctx->xsc->error = X509_V_OK;\n\t\tctx->xsc->error_depth = 0;\n\t\tfor (i = 0; i < sk_X509_num(chain->certs); i++) {\n\t\t\tif (chain->cert_errors[i] != X509_V_OK) {\n\t\t\t\tctx->xsc->error = chain->cert_errors[i];\n\t\t\t\tctx->xsc->error_depth = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\n/*\n * Save the error state and unvalidated chain off of the xsc for\n * later.\n */\nstatic int\nx509_verify_ctx_save_xsc_error(struct x509_verify_ctx *ctx)\n{\n\tif (ctx->xsc != NULL && ctx->xsc->chain != NULL) {\n\t\tsk_X509_pop_free(ctx->saved_error_chain, X509_free);\n\t\tctx->saved_error_chain = X509_chain_up_ref(ctx->xsc->chain);\n\t\tif (ctx->saved_error_chain == NULL)\n\t\t\treturn x509_verify_cert_error(ctx, NULL, 0,\n\t\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t\tctx->saved_error = ctx->xsc->error;\n\t\tctx->saved_error_depth = ctx->xsc->error_depth;\n\t}\n\treturn 1;\n}\n\n/*\n * Restore the saved error state and unvalidated chain to the xsc\n * if we do not have a validated chain.\n */\nstatic int\nx509_verify_ctx_restore_xsc_error(struct x509_verify_ctx *ctx)\n{\n\tif (ctx->xsc != NULL && ctx->chains_count == 0 &&\n\t    ctx->saved_error_chain != NULL) {\n\t\tsk_X509_pop_free(ctx->xsc->chain, X509_free);\n\t\tctx->xsc->chain = X509_chain_up_ref(ctx->saved_error_chain);\n\t\tif (ctx->xsc->chain == NULL)\n\t\t\treturn x509_verify_cert_error(ctx, NULL, 0,\n\t\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t\tctx->xsc->error = ctx->saved_error;\n\t\tctx->xsc->error_depth = ctx->saved_error_depth;\n\t}\n\treturn 1;\n}\n\n/* Perform legacy style validation of a chain */\nstatic int\nx509_verify_ctx_validate_legacy_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, size_t depth)\n{\n\tint ret = 0, trust;\n\n\tif (ctx->xsc == NULL)\n\t\treturn 1;\n\n\t/*\n\t * If we have a legacy xsc, choose a validated chain, and\n\t * apply the extensions, revocation, and policy checks just\n\t * like the legacy code did. We do this here instead of as\n\t * building the chains to more easily support the callback and\n\t * the bewildering array of VERIFY_PARAM knobs that are there\n\t * for the fiddling.\n\t */\n\n\t/* These may be set in one of the following calls. */\n\tctx->xsc->error = X509_V_OK;\n\tctx->xsc->error_depth = 0;\n\n\ttrust = x509_vfy_check_trust(ctx->xsc);\n\tif (trust == X509_TRUST_REJECTED)\n\t\tgoto err;\n\n\tif (!x509_verify_ctx_set_xsc_chain(ctx, chain, 0, 1))\n\t\tgoto err;\n\n\t/*\n\t * XXX currently this duplicates some work done in chain\n\t * build, but we keep it here until we have feature parity\n\t */\n\tif (!x509_vfy_check_chain_extensions(ctx->xsc))\n\t\tgoto err;\n\n#ifndef OPENSSL_NO_RFC3779\n\tif (!X509v3_asid_validate_path(ctx->xsc))\n\t\tgoto err;\n\n\tif (!X509v3_addr_validate_path(ctx->xsc))\n\t\tgoto err;\n#endif\n\n\tif (!x509_constraints_chain(ctx->xsc->chain,\n\t\t&ctx->xsc->error, &ctx->xsc->error_depth)) {\n\t\tX509 *cert = sk_X509_value(ctx->xsc->chain, depth);\n\t\tif (!x509_verify_cert_error(ctx, cert,\n\t\t\tctx->xsc->error_depth, ctx->xsc->error, 0))\n\t\t\tgoto err;\n\t}\n\n\tif (!x509_vfy_check_revocation(ctx->xsc))\n\t\tgoto err;\n\n\tif (!x509_vfy_check_policy(ctx->xsc))\n\t\tgoto err;\n\n\tif ((!(ctx->xsc->param->flags & X509_V_FLAG_PARTIAL_CHAIN)) &&\n\t    trust != X509_TRUST_TRUSTED)\n\t\tgoto err;\n\n\tret = 1;\n\n err:\n\t/*\n\t * The above checks may have set ctx->xsc->error and\n\t * ctx->xsc->error_depth - save these for later on.\n\t */\n\tif (ctx->xsc->error != X509_V_OK) {\n\t\tif (ctx->xsc->error_depth < 0 ||\n\t\t    ctx->xsc->error_depth >= X509_VERIFY_MAX_CHAIN_CERTS)\n\t\t\treturn 0;\n\t\tchain->cert_errors[ctx->xsc->error_depth] =\n\t\t    ctx->xsc->error;\n\t\tctx->error_depth = ctx->xsc->error_depth;\n\t}\n\n\treturn ret;\n}\n\n/* Add a validated chain to our list of valid chains */\nstatic int\nx509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\n\t/* Clear a get issuer failure for a root certificate. */\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\n\t/*\n\t * In the non-legacy code, extensions and purpose are dealt\n\t * with as the chain is built.\n\t *\n\t * The non-legacy api returns multiple chains but does not do\n\t * any revocation checking (it must be done by the caller on\n\t * any chain they wish to use)\n\t */\n\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\tctx->chains_count++;\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\treturn 1;\n}\n\nstatic int\nx509_verify_potential_parent(struct x509_verify_ctx *ctx, X509 *parent,\n    X509 *child)\n{\n\tif (!x509_verify_cert_cache_extensions(parent))\n\t\treturn 0;\n\tif (ctx->xsc != NULL)\n\t\treturn (ctx->xsc->check_issued(ctx->xsc, child, parent));\n\n\t/* XXX key usage */\n\treturn X509_check_issued(child, parent) != X509_V_OK;\n}\n\nstatic int\nx509_verify_parent_signature(X509 *parent, X509 *child, int *error)\n{\n\tEVP_PKEY *pkey;\n\tint cached;\n\tint ret = 0;\n\n\t/* Use cached value if we have it */\n\tif ((cached = x509_issuer_cache_find(parent->hash, child->hash)) >= 0)\n\t\treturn cached;\n\n\t/* Check signature. Did parent sign child? */\n\tif ((pkey = X509_get_pubkey(parent)) == NULL) {\n\t\t*error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\n\t\treturn 0;\n\t}\n\tif (X509_verify(child, pkey) <= 0)\n\t\t*error = X509_V_ERR_CERT_SIGNATURE_FAILURE;\n\telse\n\t\tret = 1;\n\n\t/* Add result to cache */\n\tx509_issuer_cache_add(parent->hash, child->hash, ret);\n\n\tEVP_PKEY_free(pkey);\n\n\treturn ret;\n}\n\nstatic int\nx509_verify_consider_candidate(struct x509_verify_ctx *ctx, X509 *cert,\n    int is_root_cert, X509 *candidate, struct x509_verify_chain *current_chain,\n    int full_chain)\n{\n\tint depth = sk_X509_num(current_chain->certs);\n\tstruct x509_verify_chain *new_chain;\n\tint i;\n\n\t/* Fail if the certificate is already in the chain */\n\tfor (i = 0; i < sk_X509_num(current_chain->certs); i++) {\n\t\tif (X509_cmp(sk_X509_value(current_chain->certs, i),\n\t\t    candidate) == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx->sig_checks++ > X509_VERIFY_MAX_SIGCHECKS) {\n\t\t/* don't allow callback to override safety check */\n\t\t(void) x509_verify_cert_error(ctx, candidate, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\t\treturn 0;\n\t}\n\n\tif (!x509_verify_parent_signature(candidate, cert, &ctx->error)) {\n\t\tif (!x509_verify_cert_error(ctx, candidate, depth,\n\t\t    ctx->error, 0))\n\t\t\treturn 0;\n\t}\n\n\tif (!x509_verify_cert_valid(ctx, candidate, current_chain))\n\t\treturn 0;\n\n\t/* candidate is good, add it to a copy of the current chain */\n\tif ((new_chain = x509_verify_chain_dup(current_chain)) == NULL) {\n\t\tx509_verify_cert_error(ctx, candidate, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t\treturn 0;\n\t}\n\tif (!x509_verify_chain_append(new_chain, candidate, &ctx->error)) {\n\t\tx509_verify_cert_error(ctx, candidate, depth, ctx->error, 0);\n\t\tx509_verify_chain_free(new_chain);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If candidate is a trusted root, we have a validated chain,\n\t * so we save it.  Otherwise, recurse until we find a root or\n\t * give up.\n\t */\n\tif (is_root_cert) {\n\t\tif (!x509_verify_ctx_set_xsc_chain(ctx, new_chain, 0, 1)) {\n\t\t\tx509_verify_chain_free(new_chain);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!x509_verify_ctx_add_chain(ctx, new_chain)) {\n\t\t\tx509_verify_chain_free(new_chain);\n\t\t\treturn 0;\n\t\t}\n\t\tgoto done;\n\t}\n\n\tx509_verify_build_chains(ctx, candidate, new_chain, full_chain);\n\n done:\n\tx509_verify_chain_free(new_chain);\n\treturn 1;\n}\n\nstatic int\nx509_verify_cert_error(struct x509_verify_ctx *ctx, X509 *cert, size_t depth,\n    int error, int ok)\n{\n\tctx->error = error;\n\tctx->error_depth = depth;\n\tif (ctx->xsc != NULL) {\n\t\tctx->xsc->error = error;\n\t\tctx->xsc->error_depth = depth;\n\t\tctx->xsc->current_cert = cert;\n\t\treturn ctx->xsc->verify_cb(ok, ctx->xsc);\n\t}\n\treturn ok;\n}\n\nstatic void\nx509_verify_build_chains(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain, int full_chain)\n{\n\tX509 *candidate;\n\tint i, depth, count, ret, is_root;\n\n\t/*\n\t * If we are finding chains with an xsc, just stop after we have\n\t * one chain, there's no point in finding more, it just exercises\n\t * the potentially buggy callback processing in the calling software.\n\t */\n\tif (ctx->xsc != NULL && ctx->chains_count > 0)\n\t\treturn;\n\n\tdepth = sk_X509_num(current_chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\n\tif (depth >= ctx->max_depth &&\n\t    !x509_verify_cert_error(ctx, cert, depth,\n\t\tX509_V_ERR_CERT_CHAIN_TOO_LONG, 0))\n\t\treturn;\n\n\tcount = ctx->chains_count;\n\n\tctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n\tctx->error_depth = depth;\n\n\tif (ctx->saved_error != 0)\n\t\tctx->error = ctx->saved_error;\n\tif (ctx->saved_error_depth != 0)\n\t\tctx->error_depth = ctx->saved_error_depth;\n\n\tif (ctx->xsc != NULL) {\n\t\t/*\n\t\t * Long ago experiments at Muppet labs resulted in a\n\t\t * situation where software not only sees these errors\n\t\t * but forced developers to expect them in certain cases.\n\t\t * so we must mimic this awfulness for the legacy case.\n\t\t */\n\t\tif (cert->ex_flags & EXFLAG_SS)\n\t\t\tctx->error = (depth == 0) ?\n\t\t\t    X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n\t\t\t    X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n\t}\n\n\t/* Check for legacy mode roots */\n\tif (ctx->xsc != NULL) {\n\t\tif ((ret = ctx->xsc->get_issuer(&candidate, ctx->xsc, cert)) < 0) {\n\t\t\tx509_verify_cert_error(ctx, cert, depth,\n\t\t\t    X509_V_ERR_STORE_LOOKUP, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (x509_verify_potential_parent(ctx, candidate, cert)) {\n\t\t\t\tis_root = !full_chain ||\n\t\t\t\t    x509_verify_cert_self_signed(candidate);\n\t\t\t\tx509_verify_consider_candidate(ctx, cert,\n\t\t\t\t    is_root, candidate, current_chain,\n\t\t\t\t    full_chain);\n\t\t\t}\n\t\t\tX509_free(candidate);\n\t\t}\n\t} else {\n\t\t/* Check to see if we have a trusted root issuer. */\n\t\tfor (i = 0; i < sk_X509_num(ctx->roots); i++) {\n\t\t\tcandidate = sk_X509_value(ctx->roots, i);\n\t\t\tif (x509_verify_potential_parent(ctx, candidate, cert)) {\n\t\t\t\tis_root = !full_chain ||\n\t\t\t\t    x509_verify_cert_self_signed(candidate);\n\t\t\t\tx509_verify_consider_candidate(ctx, cert,\n\t\t\t\t    is_root, candidate, current_chain,\n\t\t\t\t    full_chain);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check intermediates after checking roots */\n\tif (ctx->intermediates != NULL) {\n\t\tfor (i = 0; i < sk_X509_num(ctx->intermediates); i++) {\n\t\t\tcandidate = sk_X509_value(ctx->intermediates, i);\n\t\t\tif (x509_verify_potential_parent(ctx, candidate, cert)) {\n\t\t\t\tx509_verify_consider_candidate(ctx, cert,\n\t\t\t\t    0, candidate, current_chain,\n\t\t\t\t    full_chain);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctx->chains_count > count) {\n\t\tif (ctx->xsc != NULL) {\n\t\t\tctx->xsc->error = X509_V_OK;\n\t\t\tctx->xsc->error_depth = depth;\n\t\t\tctx->xsc->current_cert = cert;\n\t\t}\n\t} else if (ctx->error_depth == depth) {\n\t\tif (!x509_verify_ctx_set_xsc_chain(ctx, current_chain, 0, 0))\n\t\t\treturn;\n\t}\n}\n\nstatic int\nx509_verify_cert_hostname(struct x509_verify_ctx *ctx, X509 *cert, char *name)\n{\n\tchar *candidate;\n\tsize_t len;\n\n\tif (name == NULL) {\n\t\tif (ctx->xsc != NULL) {\n\t\t\tint ret;\n\n\t\t\tif ((ret = x509_vfy_check_id(ctx->xsc)) == 0)\n\t\t\t\tctx->error = ctx->xsc->error;\n\t\t\treturn ret;\n\t\t}\n\t\treturn 1;\n\t}\n\tif ((candidate = strdup(name)) == NULL) {\n\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\tgoto err;\n\t}\n\tif ((len = strlen(candidate)) < 1) {\n\t\tctx->error = X509_V_ERR_UNSPECIFIED; /* XXX */\n\t\tgoto err;\n\t}\n\n\t/* IP addresses may be written in [ ]. */\n\tif (candidate[0] == '[' && candidate[len - 1] == ']') {\n\t\tcandidate[len - 1] = '\\0';\n\t\tif (X509_check_ip_asc(cert, candidate + 1, 0) <= 0) {\n\t\t\tctx->error = X509_V_ERR_IP_ADDRESS_MISMATCH;\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tint flags = 0;\n\n\t\tif (ctx->xsc == NULL)\n\t\t\tflags = X509_CHECK_FLAG_NEVER_CHECK_SUBJECT;\n\n\t\tif (X509_check_host(cert, candidate, len, flags, NULL) <= 0) {\n\t\t\tctx->error = X509_V_ERR_HOSTNAME_MISMATCH;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfree(candidate);\n\treturn 1;\n err:\n\tfree(candidate);\n\treturn x509_verify_cert_error(ctx, cert, 0, ctx->error, 0);\n}\n\nstatic int\nx509_verify_set_check_time(struct x509_verify_ctx *ctx)\n{\n\tif (ctx->xsc != NULL)  {\n\t\tif (ctx->xsc->param->flags & X509_V_FLAG_USE_CHECK_TIME) {\n\t\t\tctx->check_time = &ctx->xsc->param->check_time;\n\t\t\treturn 1;\n\t\t}\n\t\tif (ctx->xsc->param->flags & X509_V_FLAG_NO_CHECK_TIME)\n\t\t\treturn 0;\n\t}\n\n\tctx->check_time = NULL;\n\treturn 1;\n}\n\nstatic int\nx509_verify_cert_times(X509 *cert, time_t *cmp_time, int *error)\n{\n\ttime_t when;\n\n\tif (cmp_time == NULL)\n\t\twhen = time(NULL);\n\telse\n\t\twhen = *cmp_time;\n\n\tif (cert->not_before == -1) {\n\t\t*error = X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;\n\t\treturn 0;\n\t}\n\tif (when < cert->not_before) {\n\t\t*error = X509_V_ERR_CERT_NOT_YET_VALID;\n\t\treturn 0;\n\t}\n\tif (cert->not_after == -1) {\n\t\t*error = X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;\n\t\treturn 0;\n\t}\n\tif (when > cert->not_after) {\n\t\t*error = X509_V_ERR_CERT_HAS_EXPIRED;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nx509_verify_validate_constraints(X509 *cert,\n    struct x509_verify_chain *current_chain, int *error)\n{\n\tstruct x509_constraints_names *excluded = NULL;\n\tstruct x509_constraints_names *permitted = NULL;\n\tint err = X509_V_ERR_UNSPECIFIED;\n\n\tif (current_chain == NULL)\n\t\treturn 1;\n\n\tif (cert->nc != NULL) {\n\t\tif ((permitted = x509_constraints_names_new(\n\t\t    X509_VERIFY_MAX_CHAIN_CONSTRAINTS)) == NULL) {\n\t\t\terr = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif ((excluded = x509_constraints_names_new(\n\t\t    X509_VERIFY_MAX_CHAIN_CONSTRAINTS)) == NULL) {\n\t\t\terr = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (!x509_constraints_extract_constraints(cert,\n\t\t    permitted, excluded, &err))\n\t\t\tgoto err;\n\t\tif (!x509_constraints_check(current_chain->names,\n\t\t    permitted, excluded, &err))\n\t\t\tgoto err;\n\t\tx509_constraints_names_free(excluded);\n\t\tx509_constraints_names_free(permitted);\n\t}\n\n\treturn 1;\n err:\n\t*error = err;\n\tx509_constraints_names_free(excluded);\n\tx509_constraints_names_free(permitted);\n\treturn 0;\n}\n\nstatic int\nx509_verify_cert_extensions(struct x509_verify_ctx *ctx, X509 *cert, int need_ca)\n{\n\tif (!x509_verify_cert_cache_extensions(cert)) {\n\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\t\treturn 0;\n\t}\n\n\tif (ctx->xsc != NULL)\n\t\treturn 1;\t/* legacy is checked after chain is built */\n\n\tif (cert->ex_flags & EXFLAG_CRITICAL) {\n\t\tctx->error = X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;\n\t\treturn 0;\n\t}\n\t/* No we don't care about v1, netscape, and other ancient silliness */\n\tif (need_ca && (!(cert->ex_flags & EXFLAG_BCONS) &&\n\t    (cert->ex_flags & EXFLAG_CA))) {\n\t\tctx->error = X509_V_ERR_INVALID_CA;\n\t\treturn 0;\n\t}\n\tif (ctx->purpose > 0 && X509_check_purpose(cert, ctx->purpose, need_ca)) {\n\t\tctx->error = X509_V_ERR_INVALID_PURPOSE;\n\t\treturn 0;\n\t}\n\n\t/* XXX support proxy certs later in new api */\n\tif (ctx->xsc == NULL && cert->ex_flags & EXFLAG_PROXY) {\n\t\tctx->error = X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/* Validate that cert is a possible candidate to append to current_chain */\nstatic int\nx509_verify_cert_valid(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain)\n{\n\tX509 *issuer_candidate;\n\tint should_be_ca = current_chain != NULL;\n\tsize_t depth = 0;\n\n\tif (current_chain != NULL)\n\t\tdepth = sk_X509_num(current_chain->certs);\n\n\tif (!x509_verify_cert_extensions(ctx, cert, should_be_ca))\n\t\treturn 0;\n\n\tif (should_be_ca) {\n\t\tissuer_candidate = x509_verify_chain_last(current_chain);\n\t\tif (issuer_candidate != NULL &&\n\t\t    !X509_check_issued(issuer_candidate, cert))\n\t\t\tif (!x509_verify_cert_error(ctx, cert, depth,\n\t\t\t    X509_V_ERR_SUBJECT_ISSUER_MISMATCH, 0))\n\t\t\t\treturn 0;\n\t}\n\n\tif (x509_verify_set_check_time(ctx)) {\n\t\tif (!x509_verify_cert_times(cert, ctx->check_time,\n\t\t    &ctx->error)) {\n\t\t\tif (!x509_verify_cert_error(ctx, cert, depth,\n\t\t\t    ctx->error, 0))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!x509_verify_validate_constraints(cert, current_chain,\n\t    &ctx->error) && !x509_verify_cert_error(ctx, cert, depth,\n\t    ctx->error, 0))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstruct x509_verify_ctx *\nx509_verify_ctx_new_from_xsc(X509_STORE_CTX *xsc)\n{\n\tstruct x509_verify_ctx *ctx;\n\tsize_t max_depth;\n\n\tif (xsc == NULL)\n\t\treturn NULL;\n\n\tif ((ctx = x509_verify_ctx_new(NULL)) == NULL)\n\t\treturn NULL;\n\n\tctx->xsc = xsc;\n\n\tif (xsc->untrusted &&\n\t    (ctx->intermediates = X509_chain_up_ref(xsc->untrusted)) == NULL)\n\t\tgoto err;\n\n\tmax_depth = X509_VERIFY_MAX_CHAIN_CERTS;\n\tif (xsc->param->depth > 0 && xsc->param->depth < X509_VERIFY_MAX_CHAIN_CERTS)\n\t\tmax_depth = xsc->param->depth;\n\tif (!x509_verify_ctx_set_max_depth(ctx, max_depth))\n\t\tgoto err;\n\n\treturn ctx;\n err:\n\tx509_verify_ctx_free(ctx);\n\treturn NULL;\n}\n\n/* Public API */\n\nstruct x509_verify_ctx *\nx509_verify_ctx_new(STACK_OF(X509) *roots)\n{\n\tstruct x509_verify_ctx *ctx;\n\n\tif ((ctx = calloc(1, sizeof(struct x509_verify_ctx))) == NULL)\n\t\treturn NULL;\n\n\tif (roots != NULL) {\n\t\tif  ((ctx->roots = X509_chain_up_ref(roots)) == NULL)\n\t\t\tgoto err;\n\t} else {\n\t\tif ((ctx->roots = sk_X509_new_null()) == NULL)\n\t\t\tgoto err;\n\t}\n\n\tctx->max_depth = X509_VERIFY_MAX_CHAIN_CERTS;\n\tctx->max_chains = X509_VERIFY_MAX_CHAINS;\n\tctx->max_sigs = X509_VERIFY_MAX_SIGCHECKS;\n\n\tif ((ctx->chains = calloc(X509_VERIFY_MAX_CHAINS,\n\t    sizeof(*ctx->chains))) == NULL)\n\t\tgoto err;\n\n\treturn ctx;\n err:\n\tx509_verify_ctx_free(ctx);\n\treturn NULL;\n}\n\nvoid\nx509_verify_ctx_free(struct x509_verify_ctx *ctx)\n{\n\tif (ctx == NULL)\n\t\treturn;\n\tsk_X509_pop_free(ctx->roots, X509_free);\n\tx509_verify_ctx_clear(ctx);\n\tfree(ctx);\n}\n\nint\nx509_verify_ctx_set_max_depth(struct x509_verify_ctx *ctx, size_t max)\n{\n\tif (max < 1 || max > X509_VERIFY_MAX_CHAIN_CERTS)\n\t\treturn 0;\n\tctx->max_depth = max;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_max_chains(struct x509_verify_ctx *ctx, size_t max)\n{\n\tif (max < 1 || max > X509_VERIFY_MAX_CHAINS)\n\t\treturn 0;\n\tctx->max_chains = max;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_max_signatures(struct x509_verify_ctx *ctx, size_t max)\n{\n\tif (max < 1 || max > 100000)\n\t\treturn 0;\n\tctx->max_sigs = max;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_purpose(struct x509_verify_ctx *ctx, int purpose)\n{\n\tif (purpose < X509_PURPOSE_MIN || purpose > X509_PURPOSE_MAX)\n\t\treturn 0;\n\tctx->purpose = purpose;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_intermediates(struct x509_verify_ctx *ctx,\n    STACK_OF(X509) *intermediates)\n{\n\tif ((ctx->intermediates = X509_chain_up_ref(intermediates)) == NULL)\n\t\treturn 0;\n\treturn 1;\n}\n\nconst char *\nx509_verify_ctx_error_string(struct x509_verify_ctx *ctx)\n{\n\treturn X509_verify_cert_error_string(ctx->error);\n}\n\nsize_t\nx509_verify_ctx_error_depth(struct x509_verify_ctx *ctx)\n{\n\treturn ctx->error_depth;\n}\n\nSTACK_OF(X509) *\nx509_verify_ctx_chain(struct x509_verify_ctx *ctx, size_t i)\n{\n\tif (i >= ctx->chains_count)\n\t\treturn NULL;\n\treturn ctx->chains[i]->certs;\n}\n\nsize_t\nx509_verify(struct x509_verify_ctx *ctx, X509 *leaf, char *name)\n{\n\tstruct x509_verify_chain *current_chain;\n\tint retry_chain_build, full_chain = 0;\n\n\tif (ctx->roots == NULL || ctx->max_depth == 0) {\n\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\tgoto err;\n\t}\n\n\tif (ctx->xsc != NULL) {\n\t\tif (leaf != NULL || name != NULL) {\n\t\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\t\tgoto err;\n\t\t}\n\t\tleaf = ctx->xsc->cert;\n\n\t\t/* XXX */\n\t\tfull_chain = 1;\n\t\tif (ctx->xsc->param->flags & X509_V_FLAG_PARTIAL_CHAIN)\n\t\t\tfull_chain = 0;\n\t\t/*\n\t\t * XXX\n\t\t * The legacy code expects the top level cert to be\n\t\t * there, even if we didn't find a chain. So put it\n\t\t * there, we will clobber it later if we find a valid\n\t\t * chain.\n\t\t */\n\t\tif ((ctx->xsc->chain = sk_X509_new_null()) == NULL) {\n\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (!X509_up_ref(leaf)) {\n\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (!sk_X509_push(ctx->xsc->chain, leaf)) {\n\t\t\tX509_free(leaf);\n\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tctx->xsc->error_depth = 0;\n\t\tctx->xsc->current_cert = leaf;\n\t}\n\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\tgoto err;\n\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\tgoto err;\n\n\tif ((current_chain = x509_verify_chain_new()) == NULL) {\n\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\tgoto err;\n\t}\n\tif (!x509_verify_chain_append(current_chain, leaf, &ctx->error)) {\n\t\tx509_verify_chain_free(current_chain);\n\t\tgoto err;\n\t}\n\tdo {\n\t\tretry_chain_build = 0;\n\t\tif (x509_verify_ctx_cert_is_root(ctx, leaf, full_chain)) {\n\t\t\tif (!x509_verify_ctx_add_chain(ctx, current_chain)) {\n\t\t\t\tx509_verify_chain_free(current_chain);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\tx509_verify_build_chains(ctx, leaf, current_chain,\n\t\t\t    full_chain);\n\t\t\tif (full_chain && ctx->chains_count == 0) {\n\t\t\t\t/*\n\t\t\t\t * Save the error state from the xsc\n\t\t\t\t * at this point to put back on the\n\t\t\t\t * xsc in case we do not find a chain\n\t\t\t\t * that is trusted but not a full\n\t\t\t\t * chain to a self signed root. This\n\t\t\t\t * is because the unvalidated chain is\n\t\t\t\t * used by the autochain batshittery\n\t\t\t\t * on failure and will be needed for\n\t\t\t\t * that.\n\t\t\t\t */\n\t\t\t\tif (!x509_verify_ctx_save_xsc_error(ctx)) {\n\t\t\t\t\tx509_verify_chain_free(current_chain);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tfull_chain = 0;\n\t\t\t\tretry_chain_build = 1;\n\t\t\t}\n\t\t}\n\t} while (retry_chain_build);\n\n\tx509_verify_chain_free(current_chain);\n\n\t/*\n\t * Bring back the failure case we wanted to the xsc if\n\t * we saved one.\n\t */\n\tif (!x509_verify_ctx_restore_xsc_error(ctx))\n\t\tgoto err;\n\n\t/*\n\t * Safety net:\n\t * We could not find a validated chain, and for some reason do not\n\t * have an error set.\n\t */\n\tif (ctx->chains_count == 0 && ctx->error == X509_V_OK) {\n\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\t\tif (ctx->xsc != NULL && ctx->xsc->error != X509_V_OK)\n\t\t\tctx->error = ctx->xsc->error;\n\t}\n\n\t/* Clear whatever errors happened if we have any validated chain */\n\tif (ctx->chains_count > 0)\n\t\tctx->error = X509_V_OK;\n\n\tif (ctx->xsc != NULL) {\n\t\tctx->xsc->error = ctx->error;\n\t\tif (ctx->chains_count > 0) {\n\t\t\t/* Take the first chain we found. */\n\t\t\tif (!x509_verify_ctx_set_xsc_chain(ctx, ctx->chains[0],\n\t\t\t    1, 1))\n\t\t\t\tgoto err;\n\t\t\tctx->xsc->error = X509_V_OK;\n\t\t\t/*\n\t\t\t * Call the callback indicating success up our already\n\t\t\t * verified chain. The callback could still tell us to\n\t\t\t * fail.\n\t\t\t */\n\t\t\tif(!x509_vfy_callback_indicate_success(ctx->xsc)) {\n\t\t\t\t/* The callback can change the error code */\n\t\t\t\tctx->error = ctx->xsc->error;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * We had a failure, indicate the failure, but\n\t\t\t * allow the callback to override at depth 0\n\t\t\t */\n\t\t\tif (ctx->xsc->verify_cb(0, ctx->xsc)) {\n\t\t\t\tctx->xsc->error = X509_V_OK;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn (ctx->chains_count);\n\n err:\n\tif (ctx->error == X509_V_OK)\n\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\tif (ctx->xsc != NULL)\n\t\tctx->xsc->error = ctx->error;\n\treturn 0;\n}\n", "/* $OpenBSD: x509_vfy.c,v 1.97 2021/11/13 18:24:45 schwarze Exp $ */\n/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n * All rights reserved.\n *\n * This package is an SSL implementation written\n * by Eric Young (eay@cryptsoft.com).\n * The implementation was written so as to conform with Netscapes SSL.\n *\n * This library is free for commercial and non-commercial use as long as\n * the following conditions are aheared to.  The following conditions\n * apply to all code found in this distribution, be it the RC4, RSA,\n * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n * included with this distribution is covered by the same copyright terms\n * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n *\n * Copyright remains Eric Young's, and as such any Copyright notices in\n * the code are not to be removed.\n * If this package is used in a product, Eric Young should be given attribution\n * as the author of the parts of the library used.\n * This can be in the form of a textual message at program startup or\n * in documentation (online or textual) provided with the package.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *    \"This product includes cryptographic software written by\n *     Eric Young (eay@cryptsoft.com)\"\n *    The word 'cryptographic' can be left out if the rouines from the library\n *    being used are not cryptographic related :-).\n * 4. If you include any Windows specific code (or a derivative thereof) from\n *    the apps directory (application code) you must include an acknowledgement:\n *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n *\n * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * The licence and distribution terms for any publically available version or\n * derivative of this code cannot be changed.  i.e. this code cannot simply be\n * copied and put under another distribution licence\n * [including the GNU Public Licence.]\n */\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <openssl/opensslconf.h>\n\n#include <openssl/asn1.h>\n#include <openssl/buffer.h>\n#include <openssl/crypto.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include <openssl/objects.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n#include \"asn1_locl.h\"\n#include \"vpm_int.h\"\n#include \"x509_internal.h\"\n\n/* CRL score values */\n\n/* No unhandled critical extensions */\n\n#define CRL_SCORE_NOCRITICAL\t0x100\n\n/* certificate is within CRL scope */\n\n#define CRL_SCORE_SCOPE\t\t0x080\n\n/* CRL times valid */\n\n#define CRL_SCORE_TIME\t\t0x040\n\n/* Issuer name matches certificate */\n\n#define CRL_SCORE_ISSUER_NAME\t0x020\n\n/* If this score or above CRL is probably valid */\n\n#define CRL_SCORE_VALID (CRL_SCORE_NOCRITICAL|CRL_SCORE_TIME|CRL_SCORE_SCOPE)\n\n/* CRL issuer is certificate issuer */\n\n#define CRL_SCORE_ISSUER_CERT\t0x018\n\n/* CRL issuer is on certificate path */\n\n#define CRL_SCORE_SAME_PATH\t0x008\n\n/* CRL issuer matches CRL AKID */\n\n#define CRL_SCORE_AKID\t\t0x004\n\n/* Have a delta CRL with valid times */\n\n#define CRL_SCORE_TIME_DELTA\t0x002\n\nstatic int null_callback(int ok, X509_STORE_CTX *e);\nstatic int check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer);\nstatic X509 *find_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x,\n    int allow_expired);\nstatic int check_chain_extensions(X509_STORE_CTX *ctx);\nstatic int check_name_constraints(X509_STORE_CTX *ctx);\nstatic int check_trust(X509_STORE_CTX *ctx);\nstatic int check_revocation(X509_STORE_CTX *ctx);\nstatic int check_cert(X509_STORE_CTX *ctx, STACK_OF(X509) *chain, int depth);\nstatic int check_policy(X509_STORE_CTX *ctx);\n\nstatic int get_crl_score(X509_STORE_CTX *ctx, X509 **pissuer,\n    unsigned int *preasons, X509_CRL *crl, X509 *x);\nstatic int get_crl_delta(X509_STORE_CTX *ctx,\n    X509_CRL **pcrl, X509_CRL **pdcrl, X509 *x);\nstatic void get_delta_sk(X509_STORE_CTX *ctx, X509_CRL **dcrl, int *pcrl_score,\n    X509_CRL *base, STACK_OF(X509_CRL) *crls);\nstatic void crl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl, X509 **pissuer,\n    int *pcrl_score);\nstatic int crl_crldp_check(X509 *x, X509_CRL *crl, int crl_score,\n    unsigned int *preasons);\nstatic int check_crl_path(X509_STORE_CTX *ctx, X509 *x);\nstatic int check_crl_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *cert_path,\n    STACK_OF(X509) *crl_path);\nstatic int X509_cmp_time_internal(const ASN1_TIME *ctm, time_t *cmp_time,\n    int clamp_notafter);\n\nstatic int internal_verify(X509_STORE_CTX *ctx);\nstatic int get_issuer_sk(X509 **issuer, X509_STORE_CTX *ctx, X509 *x);\n\nint ASN1_time_tm_clamp_notafter(struct tm *tm);\n\nstatic int\nnull_callback(int ok, X509_STORE_CTX *e)\n{\n\treturn ok;\n}\n\n#if 0\nstatic int\nx509_subject_cmp(X509 **a, X509 **b)\n{\n\treturn X509_subject_name_cmp(*a, *b);\n}\n#endif\n\n/* Return 1 if a certificate is self signed */\nstatic int\ncert_self_signed(X509 *x)\n{\n\tX509_check_purpose(x, -1, 0);\n\tif (x->ex_flags & EXFLAG_SS)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int\ncheck_id_error(X509_STORE_CTX *ctx, int errcode)\n{\n\tctx->error = errcode;\n\tctx->current_cert = ctx->cert;\n\tctx->error_depth = 0;\n\treturn ctx->verify_cb(0, ctx);\n}\n\nstatic int\ncheck_hosts(X509 *x, X509_VERIFY_PARAM_ID *id)\n{\n\tsize_t i, n;\n\tchar *name;\n\n\tn = sk_OPENSSL_STRING_num(id->hosts);\n\tfree(id->peername);\n\tid->peername = NULL;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tname = sk_OPENSSL_STRING_value(id->hosts, i);\n\t\tif (X509_check_host(x, name, strlen(name), id->hostflags,\n\t\t    &id->peername) > 0)\n\t\t\treturn 1;\n\t}\n\treturn n == 0;\n}\n\nstatic int\ncheck_id(X509_STORE_CTX *ctx)\n{\n\tX509_VERIFY_PARAM *vpm = ctx->param;\n\tX509_VERIFY_PARAM_ID *id = vpm->id;\n\tX509 *x = ctx->cert;\n\n\tif (id->hosts && check_hosts(x, id) <= 0) {\n\t\tif (!check_id_error(ctx, X509_V_ERR_HOSTNAME_MISMATCH))\n\t\t\treturn 0;\n\t}\n\tif (id->email != NULL && X509_check_email(x, id->email, id->emaillen, 0)\n\t    <= 0) {\n\t\tif (!check_id_error(ctx, X509_V_ERR_EMAIL_MISMATCH))\n\t\t\treturn 0;\n\t}\n\tif (id->ip != NULL && X509_check_ip(x, id->ip, id->iplen, 0) <= 0) {\n\t\tif (!check_id_error(ctx, X509_V_ERR_IP_ADDRESS_MISMATCH))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint\nx509_vfy_check_id(X509_STORE_CTX *ctx) {\n\treturn check_id(ctx);\n}\n\n/*\n * This is the effectively broken legacy OpenSSL chain builder. It\n * might find an unvalidated chain and leave it sitting in\n * ctx->chain. It does not correctly handle many cases where multiple\n * chains could exist.\n *\n * Oh no.. I know a dirty word...\n * Oooooooh..\n */\nstatic int\nX509_verify_cert_legacy_build_chain(X509_STORE_CTX *ctx, int *bad, int *out_ok)\n{\n\tX509 *x, *xtmp, *xtmp2, *chain_ss = NULL;\n\tint bad_chain = 0;\n\tX509_VERIFY_PARAM *param = ctx->param;\n\tint ok = 0, ret = 0;\n\tint depth, i;\n\tint num, j, retry, trust;\n\tint (*cb) (int xok, X509_STORE_CTX *xctx);\n\tSTACK_OF(X509) *sktmp = NULL;\n\n\tcb = ctx->verify_cb;\n\n\t/*\n\t * First we make sure the chain we are going to build is\n\t * present and that the first entry is in place.\n\t */\n\tctx->chain = sk_X509_new_null();\n\tif (ctx->chain == NULL || !sk_X509_push(ctx->chain, ctx->cert)) {\n\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\tgoto end;\n\t}\n\tX509_up_ref(ctx->cert);\n\tctx->num_untrusted = 1;\n\n\t/* We use a temporary STACK so we can chop and hack at it */\n\tif (ctx->untrusted != NULL &&\n\t    (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {\n\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\tgoto end;\n\t}\n\n\tnum = sk_X509_num(ctx->chain);\n\tx = sk_X509_value(ctx->chain, num - 1);\n\tdepth = param->depth;\n\n\tfor (;;) {\n\t\t/* If we have enough, we break */\n\t\t/* FIXME: If this happens, we should take\n\t\t * note of it and, if appropriate, use the\n\t\t * X509_V_ERR_CERT_CHAIN_TOO_LONG error code\n\t\t * later.\n\t\t */\n\t\tif (depth < num)\n\t\t\tbreak;\n\t\t/* If we are self signed, we break */\n\t\tif (cert_self_signed(x))\n\t\t\tbreak;\n\t\t/*\n\t\t * If asked see if we can find issuer in trusted store first\n\t\t */\n\t\tif (ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) {\n\t\t\tok = ctx->get_issuer(&xtmp, ctx, x);\n\t\t\tif (ok < 0) {\n\t\t\t\tctx->error = X509_V_ERR_STORE_LOOKUP;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If successful for now free up cert so it\n\t\t\t * will be picked up again later.\n\t\t\t */\n\t\t\tif (ok > 0) {\n\t\t\t\tX509_free(xtmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* If we were passed a cert chain, use it first */\n\t\tif (ctx->untrusted != NULL) {\n\t\t\t/*\n\t\t\t * If we do not find a non-expired untrusted cert, peek\n\t\t\t * ahead and see if we can satisify this from the trusted\n\t\t\t * store. If not, see if we have an expired untrusted cert.\n\t\t\t */\n\t\t\txtmp = find_issuer(ctx, sktmp, x, 0);\n\t\t\tif (xtmp == NULL &&\n\t\t\t    !(ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST)) {\n\t\t\t\tok = ctx->get_issuer(&xtmp, ctx, x);\n\t\t\t\tif (ok < 0) {\n\t\t\t\t\tctx->error = X509_V_ERR_STORE_LOOKUP;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tif (ok > 0) {\n\t\t\t\t\tX509_free(xtmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\txtmp = find_issuer(ctx, sktmp, x, 1);\n\t\t\t}\n\t\t\tif (xtmp != NULL) {\n\t\t\t\tif (!sk_X509_push(ctx->chain, xtmp)) {\n\t\t\t\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\t\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\t\t\tok = 0;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tX509_up_ref(xtmp);\n\t\t\t\t(void)sk_X509_delete_ptr(sktmp, xtmp);\n\t\t\t\tctx->num_untrusted++;\n\t\t\t\tx = xtmp;\n\t\t\t\tnum++;\n\t\t\t\t/*\n\t\t\t\t * reparse the full chain for the next one\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t/* Remember how many untrusted certs we have */\n\tj = num;\n\n\t/*\n\t * At this point, chain should contain a list of untrusted\n\t * certificates.  We now need to add at least one trusted one,\n\t * if possible, otherwise we complain.\n\t */\n\n\tdo {\n\t\t/*\n\t\t * Examine last certificate in chain and see if it is\n\t\t * self signed.\n\t\t */\n\t\ti = sk_X509_num(ctx->chain);\n\t\tx = sk_X509_value(ctx->chain, i - 1);\n\t\tif (cert_self_signed(x)) {\n\t\t\t/* we have a self signed certificate */\n\t\t\tif (i == 1) {\n\t\t\t\t/*\n\t\t\t\t * We have a single self signed\n\t\t\t\t * certificate: see if we can find it\n\t\t\t\t * in the store. We must have an exact\n\t\t\t\t * match to avoid possible\n\t\t\t\t * impersonation.\n\t\t\t\t */\n\t\t\t\tok = ctx->get_issuer(&xtmp, ctx, x);\n\t\t\t\tif ((ok <= 0) || X509_cmp(x, xtmp)) {\n\t\t\t\t\tctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\n\t\t\t\t\tctx->current_cert = x;\n\t\t\t\t\tctx->error_depth = i - 1;\n\t\t\t\t\tif (ok == 1)\n\t\t\t\t\t\tX509_free(xtmp);\n\t\t\t\t\tbad_chain = 1;\n\t\t\t\t\tok = cb(0, ctx);\n\t\t\t\t\tif (!ok)\n\t\t\t\t\t\tgoto end;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a match: replace\n\t\t\t\t\t * certificate with store\n\t\t\t\t\t * version so we get any trust\n\t\t\t\t\t * settings.\n\t\t\t\t\t */\n\t\t\t\t\tX509_free(x);\n\t\t\t\t\tx = xtmp;\n\t\t\t\t\t(void)sk_X509_set(ctx->chain, i - 1, x);\n\t\t\t\t\tctx->num_untrusted = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * extract and save self signed\n\t\t\t\t * certificate for later use\n\t\t\t\t */\n\t\t\t\tchain_ss = sk_X509_pop(ctx->chain);\n\t\t\t\tctx->num_untrusted--;\n\t\t\t\tnum--;\n\t\t\t\tj--;\n\t\t\t\tx = sk_X509_value(ctx->chain, num - 1);\n\t\t\t}\n\t\t}\n\t\t/* We now lookup certs from the certificate store */\n\t\tfor (;;) {\n\t\t\t/* If we have enough, we break */\n\t\t\tif (depth < num)\n\t\t\t\tbreak;\n\t\t\t/* If we are self signed, we break */\n\t\t\tif (cert_self_signed(x))\n\t\t\t\tbreak;\n\t\t\tok = ctx->get_issuer(&xtmp, ctx, x);\n\n\t\t\tif (ok < 0) {\n\t\t\t\tctx->error = X509_V_ERR_STORE_LOOKUP;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif (ok == 0)\n\t\t\t\tbreak;\n\t\t\tx = xtmp;\n\t\t\tif (!sk_X509_push(ctx->chain, x)) {\n\t\t\t\tX509_free(xtmp);\n\t\t\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\t\tok = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tnum++;\n\t\t}\n\n\t\t/* we now have our chain, lets check it... */\n\t\ttrust = check_trust(ctx);\n\n\t\t/* If explicitly rejected error */\n\t\tif (trust == X509_TRUST_REJECTED) {\n\t\t\tok = 0;\n\t\t\tgoto end;\n\t\t}\n\t\t/*\n\t\t * If it's not explicitly trusted then check if there\n\t\t * is an alternative chain that could be used. We only\n\t\t * do this if we haven't already checked via\n\t\t * TRUSTED_FIRST and the user hasn't switched off\n\t\t * alternate chain checking\n\t\t */\n\t\tretry = 0;\n\t\tif (trust != X509_TRUST_TRUSTED &&\n\t\t    !(ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) &&\n\t\t    !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {\n\t\t\twhile (j-- > 1) {\n\t\t\t\txtmp2 = sk_X509_value(ctx->chain, j - 1);\n\t\t\t\tok = ctx->get_issuer(&xtmp, ctx, xtmp2);\n\t\t\t\tif (ok < 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t/* Check if we found an alternate chain */\n\t\t\t\tif (ok > 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Free up the found cert\n\t\t\t\t\t * we'll add it again later\n\t\t\t\t\t */\n\t\t\t\t\tX509_free(xtmp);\n\t\t\t\t\t/*\n\t\t\t\t\t * Dump all the certs above\n\t\t\t\t\t * this point - we've found an\n\t\t\t\t\t * alternate chain\n\t\t\t\t\t */\n\t\t\t\t\twhile (num > j) {\n\t\t\t\t\t\txtmp = sk_X509_pop(ctx->chain);\n\t\t\t\t\t\tX509_free(xtmp);\n\t\t\t\t\t\tnum--;\n\t\t\t\t\t}\n\t\t\t\t\tctx->num_untrusted = sk_X509_num(ctx->chain);\n\t\t\t\t\tretry = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (retry);\n\n\t/*\n\t * If not explicitly trusted then indicate error unless it's a single\n\t * self signed certificate in which case we've indicated an error already\n\t * and set bad_chain == 1\n\t */\n\tif (trust != X509_TRUST_TRUSTED && !bad_chain) {\n\t\tif ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {\n\t\t\tif (ctx->num_untrusted >= num)\n\t\t\t\tctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n\t\t\telse\n\t\t\t\tctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\n\t\t\tctx->current_cert = x;\n\t\t} else {\n\t\t\tif (!sk_X509_push(ctx->chain, chain_ss)) {\n\t\t\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\t\tok = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tnum++;\n\t\t\tctx->num_untrusted = num;\n\t\t\tctx->current_cert = chain_ss;\n\t\t\tctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n\t\t\tchain_ss = NULL;\n\t\t}\n\n\t\tctx->error_depth = num - 1;\n\t\tbad_chain = 1;\n\t\tok = cb(0, ctx);\n\t\tif (!ok)\n\t\t\tgoto end;\n\t}\n\n\tret = 1;\n end:\n\tsk_X509_free(sktmp);\n\tX509_free(chain_ss);\n\t*bad = bad_chain;\n\t*out_ok = ok;\n\n\treturn ret;\n}\n\nstatic int\nX509_verify_cert_legacy(X509_STORE_CTX *ctx)\n{\n\tint ok = 0, bad_chain;\n\n\tctx->error = X509_V_OK; /* Initialize to OK */\n\n\tif (!X509_verify_cert_legacy_build_chain(ctx, &bad_chain, &ok))\n\t\tgoto end;\n\n\t/* We have the chain complete: now we need to check its purpose */\n\tok = check_chain_extensions(ctx);\n\tif (!ok)\n\t\tgoto end;\n\n\t/* Check name constraints */\n\tok = check_name_constraints(ctx);\n\tif (!ok)\n\t\tgoto end;\n\n#ifndef OPENSSL_NO_RFC3779\n\tok = X509v3_asid_validate_path(ctx);\n\tif (!ok)\n\t\tgoto end;\n\n\tok = X509v3_addr_validate_path(ctx);\n\tif (!ok)\n\t\tgoto end;\n#endif\n\n\tok = check_id(ctx);\n\tif (!ok)\n\t\tgoto end;\n\n\t/*\n\t * Check revocation status: we do this after copying parameters because\n\t * they may be needed for CRL signature verification.\n\t */\n\tok = ctx->check_revocation(ctx);\n\tif (!ok)\n\t\tgoto end;\n\n\t/* At this point, we have a chain and need to verify it */\n\tif (ctx->verify != NULL)\n\t\tok = ctx->verify(ctx);\n\telse\n\t\tok = internal_verify(ctx);\n\tif (!ok)\n\t\tgoto end;\n\n\t/* If we get this far evaluate policies */\n\tif (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))\n\t\tok = ctx->check_policy(ctx);\n\n end:\n\t/* Safety net, error returns must set ctx->error */\n\tif (ok <= 0 && ctx->error == X509_V_OK)\n\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\n\treturn ok;\n}\n\nint\nX509_verify_cert(X509_STORE_CTX *ctx)\n{\n\tSTACK_OF(X509) *roots = NULL;\n\tstruct x509_verify_ctx *vctx = NULL;\n\tint chain_count = 0;\n\n\tif (ctx->cert == NULL) {\n\t\tX509error(X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);\n\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\treturn -1;\n\t}\n\tif (ctx->chain != NULL) {\n\t\t/*\n\t\t * This X509_STORE_CTX has already been used to verify\n\t\t * a cert. We cannot do another one.\n\t\t */\n\t\tX509error(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\treturn -1;\n\t}\n\tif (ctx->param->id->poisoned) {\n\t\t/*\n\t\t * This X509_STORE_CTX had failures setting\n\t\t * up verify parameters. We can not use it.\n\t\t */\n\t\tX509error(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\treturn -1;\n\t}\n\tif (ctx->error != X509_V_ERR_INVALID_CALL) {\n\t\t/*\n\t\t * This X509_STORE_CTX has not been properly initialized.\n\t\t */\n\t\tX509error(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\treturn -1;\n\t}\n\n\t/*\n\t * If flags request legacy, use the legacy verifier. If we\n\t * requested \"no alt chains\" from the age of hammer pants, use\n\t * the legacy verifier because the multi chain verifier really\n\t * does find all the \"alt chains\".\n\t *\n\t * XXX deprecate the NO_ALT_CHAINS flag?\n\t */\n\tif ((ctx->param->flags & X509_V_FLAG_LEGACY_VERIFY) ||\n\t    (ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS))\n\t\treturn X509_verify_cert_legacy(ctx);\n\n\t/* Use the modern multi-chain verifier from x509_verify_cert */\n\n\tif ((vctx = x509_verify_ctx_new_from_xsc(ctx)) != NULL) {\n\t\tctx->error = X509_V_OK; /* Initialize to OK */\n\t\tchain_count = x509_verify(vctx, NULL, NULL);\n\t}\n\tx509_verify_ctx_free(vctx);\n\n\tsk_X509_pop_free(roots, X509_free);\n\n\t/* if we succeed we have a chain in ctx->chain */\n\treturn (chain_count > 0 && ctx->chain != NULL);\n}\n\n/* Given a STACK_OF(X509) find the issuer of cert (if any)\n */\n\nstatic X509 *\nfind_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x,\n    int allow_expired)\n{\n\tint i;\n\tX509 *issuer, *rv = NULL;\n\n\tfor (i = 0; i < sk_X509_num(sk); i++) {\n\t\tissuer = sk_X509_value(sk, i);\n\t\tif (ctx->check_issued(ctx, x, issuer)) {\n\t\t\tif (x509_check_cert_time(ctx, issuer, -1))\n\t\t\t\treturn issuer;\n\t\t\tif (allow_expired)\n\t\t\t\trv = issuer;\n\t\t}\n\t}\n\treturn rv;\n}\n\n/* Given a possible certificate and issuer check them */\n\nstatic int\ncheck_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer)\n{\n\tint ret;\n\n\tret = X509_check_issued(issuer, x);\n\tif (ret == X509_V_OK)\n\t\treturn 1;\n\t/* If we haven't asked for issuer errors don't set ctx */\n\tif (!(ctx->param->flags & X509_V_FLAG_CB_ISSUER_CHECK))\n\t\treturn 0;\n\n\tctx->error = ret;\n\tctx->current_cert = x;\n\tctx->current_issuer = issuer;\n\treturn ctx->verify_cb(0, ctx);\n}\n\n/* Alternative lookup method: look from a STACK stored in other_ctx */\n\nstatic int\nget_issuer_sk(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)\n{\n\t*issuer = find_issuer(ctx, ctx->other_ctx, x, 1);\n\tif (*issuer) {\n\t\tCRYPTO_add(&(*issuer)->references, 1, CRYPTO_LOCK_X509);\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}\n\n/* Check a certificate chains extensions for consistency\n * with the supplied purpose\n */\n\nint\nx509_vfy_check_chain_extensions(X509_STORE_CTX *ctx)\n{\n#ifdef OPENSSL_NO_CHAIN_VERIFY\n\treturn 1;\n#else\n\tint i, ok = 0, must_be_ca, plen = 0;\n\tX509 *x;\n\tint (*cb)(int xok, X509_STORE_CTX *xctx);\n\tint proxy_path_length = 0;\n\tint purpose;\n\tint allow_proxy_certs;\n\n\tcb = ctx->verify_cb;\n\n\t/* must_be_ca can have 1 of 3 values:\n\t   -1: we accept both CA and non-CA certificates, to allow direct\n\t       use of self-signed certificates (which are marked as CA).\n\t   0:  we only accept non-CA certificates.  This is currently not\n\t       used, but the possibility is present for future extensions.\n\t   1:  we only accept CA certificates.  This is currently used for\n\t       all certificates in the chain except the leaf certificate.\n\t*/\n\tmust_be_ca = -1;\n\n\t/* CRL path validation */\n\tif (ctx->parent) {\n\t\tallow_proxy_certs = 0;\n\t\tpurpose = X509_PURPOSE_CRL_SIGN;\n\t} else {\n\t\tallow_proxy_certs =\n\t\t    !!(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);\n\t\tpurpose = ctx->param->purpose;\n\t}\n\n\t/* Check all untrusted certificates */\n\tfor (i = 0; i < ctx->num_untrusted; i++) {\n\t\tint ret;\n\t\tx = sk_X509_value(ctx->chain, i);\n\t\tif (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL) &&\n\t\t    (x->ex_flags & EXFLAG_CRITICAL)) {\n\t\t\tctx->error = X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;\n\t\t\tctx->error_depth = i;\n\t\t\tctx->current_cert = x;\n\t\t\tok = cb(0, ctx);\n\t\t\tif (!ok)\n\t\t\t\tgoto end;\n\t\t}\n\t\tif (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY)) {\n\t\t\tctx->error = X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;\n\t\t\tctx->error_depth = i;\n\t\t\tctx->current_cert = x;\n\t\t\tok = cb(0, ctx);\n\t\t\tif (!ok)\n\t\t\t\tgoto end;\n\t\t}\n\t\tret = X509_check_ca(x);\n\t\tswitch (must_be_ca) {\n\t\tcase -1:\n\t\t\tif ((ctx->param->flags & X509_V_FLAG_X509_STRICT) &&\n\t\t\t    (ret != 1) && (ret != 0)) {\n\t\t\t\tret = 0;\n\t\t\t\tctx->error = X509_V_ERR_INVALID_CA;\n\t\t\t} else\n\t\t\t\tret = 1;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tif (ret != 0) {\n\t\t\t\tret = 0;\n\t\t\t\tctx->error = X509_V_ERR_INVALID_NON_CA;\n\t\t\t} else\n\t\t\t\tret = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((ret == 0) ||\n\t\t\t    ((ctx->param->flags & X509_V_FLAG_X509_STRICT) &&\n\t\t\t    (ret != 1))) {\n\t\t\t\tret = 0;\n\t\t\t\tctx->error = X509_V_ERR_INVALID_CA;\n\t\t\t} else\n\t\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tctx->error_depth = i;\n\t\t\tctx->current_cert = x;\n\t\t\tok = cb(0, ctx);\n\t\t\tif (!ok)\n\t\t\t\tgoto end;\n\t\t}\n\t\tif (ctx->param->purpose > 0) {\n\t\t\tret = X509_check_purpose(x, purpose, must_be_ca > 0);\n\t\t\tif ((ret == 0) ||\n\t\t\t    ((ctx->param->flags & X509_V_FLAG_X509_STRICT) &&\n\t\t\t    (ret != 1))) {\n\t\t\t\tctx->error = X509_V_ERR_INVALID_PURPOSE;\n\t\t\t\tctx->error_depth = i;\n\t\t\t\tctx->current_cert = x;\n\t\t\t\tok = cb(0, ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\t/* Check pathlen if not self issued */\n\t\tif ((i > 1) && !(x->ex_flags & EXFLAG_SI) &&\n\t\t    (x->ex_pathlen != -1) &&\n\t\t    (plen > (x->ex_pathlen + proxy_path_length + 1))) {\n\t\t\tctx->error = X509_V_ERR_PATH_LENGTH_EXCEEDED;\n\t\t\tctx->error_depth = i;\n\t\t\tctx->current_cert = x;\n\t\t\tok = cb(0, ctx);\n\t\t\tif (!ok)\n\t\t\t\tgoto end;\n\t\t}\n\t\t/* Increment path length if not self issued */\n\t\tif (!(x->ex_flags & EXFLAG_SI))\n\t\t\tplen++;\n\t\t/* If this certificate is a proxy certificate, the next\n\t\t   certificate must be another proxy certificate or a EE\n\t\t   certificate.  If not, the next certificate must be a\n\t\t   CA certificate.  */\n\t\tif (x->ex_flags & EXFLAG_PROXY) {\n\t\t\tif (x->ex_pcpathlen != -1 && i > x->ex_pcpathlen) {\n\t\t\t\tctx->error =\n\t\t\t\t    X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;\n\t\t\t\tctx->error_depth = i;\n\t\t\t\tctx->current_cert = x;\n\t\t\t\tok = cb(0, ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tproxy_path_length++;\n\t\t\tmust_be_ca = 0;\n\t\t} else\n\t\t\tmust_be_ca = 1;\n\t}\n\tok = 1;\n\nend:\n\treturn ok;\n#endif\n}\n\nstatic int\ncheck_chain_extensions(X509_STORE_CTX *ctx) {\n\treturn x509_vfy_check_chain_extensions(ctx);\n}\n\nstatic int\ncheck_name_constraints(X509_STORE_CTX *ctx)\n{\n\tif (!x509_constraints_chain(ctx->chain, &ctx->error,\n\t    &ctx->error_depth)) {\n\t\tctx->current_cert = sk_X509_value(ctx->chain, ctx->error_depth);\n\t\tif (!ctx->verify_cb(0, ctx))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* Given a certificate try and find an exact match in the store */\n\nstatic X509 *\nlookup_cert_match(X509_STORE_CTX *ctx, X509 *x)\n{\n\tSTACK_OF(X509) *certs;\n\tX509 *xtmp = NULL;\n\tsize_t i;\n\n\t/* Lookup all certs with matching subject name */\n\tcerts = ctx->lookup_certs(ctx, X509_get_subject_name(x));\n\tif (certs == NULL)\n\t\treturn NULL;\n\n\t/* Look for exact match */\n\tfor (i = 0; i < sk_X509_num(certs); i++) {\n\t\txtmp = sk_X509_value(certs, i);\n\t\tif (!X509_cmp(xtmp, x))\n\t\t\tbreak;\n\t}\n\n\tif (i < sk_X509_num(certs))\n\t\tX509_up_ref(xtmp);\n\telse\n\t\txtmp = NULL;\n\n\tsk_X509_pop_free(certs, X509_free);\n\treturn xtmp;\n}\n\nX509 *\nx509_vfy_lookup_cert_match(X509_STORE_CTX *ctx, X509 *x)\n{\n\tif (ctx->lookup_certs == NULL || ctx->store == NULL ||\n\t    ctx->store->objs == NULL)\n\t\treturn NULL;\n\treturn lookup_cert_match(ctx, x);\n}\n\nstatic int\ncheck_trust(X509_STORE_CTX *ctx)\n{\n\tsize_t i;\n\tint ok;\n\tX509 *x = NULL;\n\tint (*cb) (int xok, X509_STORE_CTX *xctx);\n\n\tcb = ctx->verify_cb;\n\t/* Check all trusted certificates in chain */\n\tfor (i = ctx->num_untrusted; i < sk_X509_num(ctx->chain); i++) {\n\t\tx = sk_X509_value(ctx->chain, i);\n\t\tok = X509_check_trust(x, ctx->param->trust, 0);\n\n\t\t/* If explicitly trusted return trusted */\n\t\tif (ok == X509_TRUST_TRUSTED)\n\t\t\treturn X509_TRUST_TRUSTED;\n\t\t/*\n\t\t * If explicitly rejected notify callback and reject if not\n\t\t * overridden.\n\t\t */\n\t\tif (ok == X509_TRUST_REJECTED) {\n\t\t\tctx->error_depth = i;\n\t\t\tctx->current_cert = x;\n\t\t\tctx->error = X509_V_ERR_CERT_REJECTED;\n\t\t\tok = cb(0, ctx);\n\t\t\tif (!ok)\n\t\t\t\treturn X509_TRUST_REJECTED;\n\t\t}\n\t}\n\t/*\n\t * If we accept partial chains and have at least one trusted certificate\n\t * return success.\n\t */\n\tif (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {\n\t\tX509 *mx;\n\t\tif (ctx->num_untrusted < (int)sk_X509_num(ctx->chain))\n\t\t\treturn X509_TRUST_TRUSTED;\n\t\tx = sk_X509_value(ctx->chain, 0);\n\t\tmx = lookup_cert_match(ctx, x);\n\t\tif (mx) {\n\t\t\t(void)sk_X509_set(ctx->chain, 0, mx);\n\t\t\tX509_free(x);\n\t\t\tctx->num_untrusted = 0;\n\t\t\treturn X509_TRUST_TRUSTED;\n\t\t}\n\t}\n\n\t/*\n\t * If no trusted certs in chain at all return untrusted and allow\n\t * standard (no issuer cert) etc errors to be indicated.\n\t */\n\treturn X509_TRUST_UNTRUSTED;\n}\n\nint\nx509_vfy_check_trust(X509_STORE_CTX *ctx)\n{\n\treturn check_trust(ctx);\n}\n\nstatic int\ncheck_revocation(X509_STORE_CTX *ctx)\n{\n\tint i, last, ok;\n\n\tif (!(ctx->param->flags & X509_V_FLAG_CRL_CHECK))\n\t\treturn 1;\n\tif (ctx->param->flags & X509_V_FLAG_CRL_CHECK_ALL)\n\t\tlast = sk_X509_num(ctx->chain) - 1;\n\telse {\n\t\t/* If checking CRL paths this isn't the EE certificate */\n\t\tif (ctx->parent)\n\t\t\treturn 1;\n\t\tlast = 0;\n\t}\n\tfor (i = 0; i <= last; i++) {\n\t\tok = check_cert(ctx, ctx->chain, i);\n\t\tif (!ok)\n\t\t\treturn ok;\n\t}\n\treturn 1;\n}\n\nint\nx509_vfy_check_revocation(X509_STORE_CTX *ctx)\n{\n\treturn check_revocation(ctx);\n}\n\nstatic int\ncheck_cert(X509_STORE_CTX *ctx, STACK_OF(X509) *chain, int depth)\n{\n\tX509_CRL *crl = NULL, *dcrl = NULL;\n\tX509 *x;\n\tint ok = 0, cnum;\n\tunsigned int last_reasons;\n\n\tcnum = ctx->error_depth = depth;\n\tx = sk_X509_value(chain, cnum);\n\tctx->current_cert = x;\n\tctx->current_issuer = NULL;\n\tctx->current_crl_score = 0;\n\tctx->current_reasons = 0;\n\twhile (ctx->current_reasons != CRLDP_ALL_REASONS) {\n\t\tlast_reasons = ctx->current_reasons;\n\t\t/* Try to retrieve relevant CRL */\n\t\tif (ctx->get_crl)\n\t\t\tok = ctx->get_crl(ctx, &crl, x);\n\t\telse\n\t\t\tok = get_crl_delta(ctx, &crl, &dcrl, x);\n\t\t/* If error looking up CRL, nothing we can do except\n\t\t * notify callback\n\t\t */\n\t\tif (!ok) {\n\t\t\tctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\tgoto err;\n\t\t}\n\t\tctx->current_crl = crl;\n\t\tok = ctx->check_crl(ctx, crl);\n\t\tif (!ok)\n\t\t\tgoto err;\n\n\t\tif (dcrl) {\n\t\t\tok = ctx->check_crl(ctx, dcrl);\n\t\t\tif (!ok)\n\t\t\t\tgoto err;\n\t\t\tok = ctx->cert_crl(ctx, dcrl, x);\n\t\t\tif (!ok)\n\t\t\t\tgoto err;\n\t\t} else\n\t\t\tok = 1;\n\n\t\t/* Don't look in full CRL if delta reason is removefromCRL */\n\t\tif (ok != 2) {\n\t\t\tok = ctx->cert_crl(ctx, crl, x);\n\t\t\tif (!ok)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tctx->current_crl = NULL;\n\t\tX509_CRL_free(crl);\n\t\tX509_CRL_free(dcrl);\n\t\tcrl = NULL;\n\t\tdcrl = NULL;\n\t\t/* If reasons not updated we wont get anywhere by\n\t\t * another iteration, so exit loop.\n\t\t */\n\t\tif (last_reasons == ctx->current_reasons) {\n\t\t\tctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\tctx->current_crl = NULL;\n\tX509_CRL_free(crl);\n\tX509_CRL_free(dcrl);\n\treturn ok;\n}\n\n/* Check CRL times against values in X509_STORE_CTX */\n\nstatic int\ncheck_crl_time(X509_STORE_CTX *ctx, X509_CRL *crl, int notify)\n{\n\ttime_t *ptime;\n\tint i;\n\n\tif (notify)\n\t\tctx->current_crl = crl;\n\tif (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)\n\t\tptime = &ctx->param->check_time;\n\telse if (ctx->param->flags & X509_V_FLAG_NO_CHECK_TIME)\n\t\treturn (1);\n\telse\n\t\tptime = NULL;\n\n\ti = X509_cmp_time(X509_CRL_get_lastUpdate(crl), ptime);\n\tif (i == 0) {\n\t\tif (!notify)\n\t\t\treturn 0;\n\t\tctx->error = X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;\n\t\tif (!ctx->verify_cb(0, ctx))\n\t\t\treturn 0;\n\t}\n\n\tif (i > 0) {\n\t\tif (!notify)\n\t\t\treturn 0;\n\t\tctx->error = X509_V_ERR_CRL_NOT_YET_VALID;\n\t\tif (!ctx->verify_cb(0, ctx))\n\t\t\treturn 0;\n\t}\n\n\tif (X509_CRL_get_nextUpdate(crl)) {\n\t\ti = X509_cmp_time(X509_CRL_get_nextUpdate(crl), ptime);\n\n\t\tif (i == 0) {\n\t\t\tif (!notify)\n\t\t\t\treturn 0;\n\t\t\tctx->error = X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;\n\t\t\tif (!ctx->verify_cb(0, ctx))\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* Ignore expiry of base CRL is delta is valid */\n\t\tif ((i < 0) &&\n\t\t    !(ctx->current_crl_score & CRL_SCORE_TIME_DELTA)) {\n\t\t\tif (!notify)\n\t\t\t\treturn 0;\n\t\t\tctx->error = X509_V_ERR_CRL_HAS_EXPIRED;\n\t\t\tif (!ctx->verify_cb(0, ctx))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (notify)\n\t\tctx->current_crl = NULL;\n\n\treturn 1;\n}\n\nstatic int\nget_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,\n    X509 **pissuer, int *pscore, unsigned int *preasons,\n    STACK_OF(X509_CRL) *crls)\n{\n\tint i, crl_score, best_score = *pscore;\n\tunsigned int reasons, best_reasons = 0;\n\tX509 *x = ctx->current_cert;\n\tX509_CRL *crl, *best_crl = NULL;\n\tX509 *crl_issuer = NULL, *best_crl_issuer = NULL;\n\n\tfor (i = 0; i < sk_X509_CRL_num(crls); i++) {\n\t\tcrl = sk_X509_CRL_value(crls, i);\n\t\treasons = *preasons;\n\t\tcrl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n\n\t\tif (crl_score > best_score) {\n\t\t\tbest_crl = crl;\n\t\t\tbest_crl_issuer = crl_issuer;\n\t\t\tbest_score = crl_score;\n\t\t\tbest_reasons = reasons;\n\t\t}\n\t}\n\n\tif (best_crl) {\n\t\tif (*pcrl)\n\t\t\tX509_CRL_free(*pcrl);\n\t\t*pcrl = best_crl;\n\t\t*pissuer = best_crl_issuer;\n\t\t*pscore = best_score;\n\t\t*preasons = best_reasons;\n\t\tCRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);\n\t\tif (*pdcrl) {\n\t\t\tX509_CRL_free(*pdcrl);\n\t\t\t*pdcrl = NULL;\n\t\t}\n\t\tget_delta_sk(ctx, pdcrl, pscore, best_crl, crls);\n\t}\n\n\tif (best_score >= CRL_SCORE_VALID)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/* Compare two CRL extensions for delta checking purposes. They should be\n * both present or both absent. If both present all fields must be identical.\n */\n\nstatic int\ncrl_extension_match(X509_CRL *a, X509_CRL *b, int nid)\n{\n\tASN1_OCTET_STRING *exta, *extb;\n\tint i;\n\n\ti = X509_CRL_get_ext_by_NID(a, nid, -1);\n\tif (i >= 0) {\n\t\t/* Can't have multiple occurrences */\n\t\tif (X509_CRL_get_ext_by_NID(a, nid, i) != -1)\n\t\t\treturn 0;\n\t\texta = X509_EXTENSION_get_data(X509_CRL_get_ext(a, i));\n\t} else\n\t\texta = NULL;\n\n\ti = X509_CRL_get_ext_by_NID(b, nid, -1);\n\n\tif (i >= 0) {\n\t\tif (X509_CRL_get_ext_by_NID(b, nid, i) != -1)\n\t\t\treturn 0;\n\t\textb = X509_EXTENSION_get_data(X509_CRL_get_ext(b, i));\n\t} else\n\t\textb = NULL;\n\n\tif (!exta && !extb)\n\t\treturn 1;\n\n\tif (!exta || !extb)\n\t\treturn 0;\n\n\tif (ASN1_OCTET_STRING_cmp(exta, extb))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/* See if a base and delta are compatible */\n\nstatic int\ncheck_delta_base(X509_CRL *delta, X509_CRL *base)\n{\n\t/* Delta CRL must be a delta */\n\tif (!delta->base_crl_number)\n\t\treturn 0;\n\t/* Base must have a CRL number */\n\tif (!base->crl_number)\n\t\treturn 0;\n\t/* Issuer names must match */\n\tif (X509_NAME_cmp(X509_CRL_get_issuer(base),\n\t    X509_CRL_get_issuer(delta)))\n\t\treturn 0;\n\t/* AKID and IDP must match */\n\tif (!crl_extension_match(delta, base, NID_authority_key_identifier))\n\t\treturn 0;\n\tif (!crl_extension_match(delta, base, NID_issuing_distribution_point))\n\t\treturn 0;\n\t/* Delta CRL base number must not exceed Full CRL number. */\n\tif (ASN1_INTEGER_cmp(delta->base_crl_number, base->crl_number) > 0)\n\t\treturn 0;\n\t/* Delta CRL number must exceed full CRL number */\n\tif (ASN1_INTEGER_cmp(delta->crl_number, base->crl_number) > 0)\n\t\treturn 1;\n\treturn 0;\n}\n\n/* For a given base CRL find a delta... maybe extend to delta scoring\n * or retrieve a chain of deltas...\n */\n\nstatic void\nget_delta_sk(X509_STORE_CTX *ctx, X509_CRL **dcrl, int *pscore, X509_CRL *base,\n    STACK_OF(X509_CRL) *crls)\n{\n\tX509_CRL *delta;\n\tint i;\n\n\tif (!(ctx->param->flags & X509_V_FLAG_USE_DELTAS))\n\t\treturn;\n\tif (!((ctx->current_cert->ex_flags | base->flags) & EXFLAG_FRESHEST))\n\t\treturn;\n\tfor (i = 0; i < sk_X509_CRL_num(crls); i++) {\n\t\tdelta = sk_X509_CRL_value(crls, i);\n\t\tif (check_delta_base(delta, base)) {\n\t\t\tif (check_crl_time(ctx, delta, 0))\n\t\t\t\t*pscore |= CRL_SCORE_TIME_DELTA;\n\t\t\tCRYPTO_add(&delta->references, 1, CRYPTO_LOCK_X509_CRL);\n\t\t\t*dcrl = delta;\n\t\t\treturn;\n\t\t}\n\t}\n\t*dcrl = NULL;\n}\n\n/* For a given CRL return how suitable it is for the supplied certificate 'x'.\n * The return value is a mask of several criteria.\n * If the issuer is not the certificate issuer this is returned in *pissuer.\n * The reasons mask is also used to determine if the CRL is suitable: if\n * no new reasons the CRL is rejected, otherwise reasons is updated.\n */\n\nstatic int\nget_crl_score(X509_STORE_CTX *ctx, X509 **pissuer, unsigned int *preasons,\n    X509_CRL *crl, X509 *x)\n{\n\tint crl_score = 0;\n\tunsigned int tmp_reasons = *preasons, crl_reasons;\n\n\t/* First see if we can reject CRL straight away */\n\n\t/* Invalid IDP cannot be processed */\n\tif (crl->idp_flags & IDP_INVALID)\n\t\treturn 0;\n\t/* Reason codes or indirect CRLs need extended CRL support */\n\tif (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT)) {\n\t\tif (crl->idp_flags & (IDP_INDIRECT | IDP_REASONS))\n\t\t\treturn 0;\n\t} else if (crl->idp_flags & IDP_REASONS) {\n\t\t/* If no new reasons reject */\n\t\tif (!(crl->idp_reasons & ~tmp_reasons))\n\t\t\treturn 0;\n\t}\n\t/* Don't process deltas at this stage */\n\telse if (crl->base_crl_number)\n\t\treturn 0;\n\t/* If issuer name doesn't match certificate need indirect CRL */\n\tif (X509_NAME_cmp(X509_get_issuer_name(x), X509_CRL_get_issuer(crl))) {\n\t\tif (!(crl->idp_flags & IDP_INDIRECT))\n\t\t\treturn 0;\n\t} else\n\t\tcrl_score |= CRL_SCORE_ISSUER_NAME;\n\n\tif (!(crl->flags & EXFLAG_CRITICAL))\n\t\tcrl_score |= CRL_SCORE_NOCRITICAL;\n\n\t/* Check expiry */\n\tif (check_crl_time(ctx, crl, 0))\n\t\tcrl_score |= CRL_SCORE_TIME;\n\n\t/* Check authority key ID and locate certificate issuer */\n\tcrl_akid_check(ctx, crl, pissuer, &crl_score);\n\n\t/* If we can't locate certificate issuer at this point forget it */\n\n\tif (!(crl_score & CRL_SCORE_AKID))\n\t\treturn 0;\n\n\t/* Check cert for matching CRL distribution points */\n\n\tif (crl_crldp_check(x, crl, crl_score, &crl_reasons)) {\n\t\t/* If no new reasons reject */\n\t\tif (!(crl_reasons & ~tmp_reasons))\n\t\t\treturn 0;\n\t\ttmp_reasons |= crl_reasons;\n\t\tcrl_score |= CRL_SCORE_SCOPE;\n\t}\n\n\t*preasons = tmp_reasons;\n\n\treturn crl_score;\n}\n\nstatic void\ncrl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl, X509 **pissuer,\n    int *pcrl_score)\n{\n\tX509 *crl_issuer = NULL;\n\tX509_NAME *cnm = X509_CRL_get_issuer(crl);\n\tint cidx = ctx->error_depth;\n\tint i;\n\n\tif (cidx != sk_X509_num(ctx->chain) - 1)\n\t\tcidx++;\n\n\tcrl_issuer = sk_X509_value(ctx->chain, cidx);\n\n\tif (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {\n\t\tif (*pcrl_score & CRL_SCORE_ISSUER_NAME) {\n\t\t\t*pcrl_score |= CRL_SCORE_AKID|CRL_SCORE_ISSUER_CERT;\n\t\t\t*pissuer = crl_issuer;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (cidx++; cidx < sk_X509_num(ctx->chain); cidx++) {\n\t\tcrl_issuer = sk_X509_value(ctx->chain, cidx);\n\t\tif (X509_NAME_cmp(X509_get_subject_name(crl_issuer), cnm))\n\t\t\tcontinue;\n\t\tif (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {\n\t\t\t*pcrl_score |= CRL_SCORE_AKID|CRL_SCORE_SAME_PATH;\n\t\t\t*pissuer = crl_issuer;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Anything else needs extended CRL support */\n\n\tif (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT))\n\t\treturn;\n\n\t/* Otherwise the CRL issuer is not on the path. Look for it in the\n\t * set of untrusted certificates.\n\t */\n\tfor (i = 0; i < sk_X509_num(ctx->untrusted); i++) {\n\t\tcrl_issuer = sk_X509_value(ctx->untrusted, i);\n\t\tif (X509_NAME_cmp(X509_get_subject_name(crl_issuer), cnm))\n\t\t\tcontinue;\n\t\tif (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {\n\t\t\t*pissuer = crl_issuer;\n\t\t\t*pcrl_score |= CRL_SCORE_AKID;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/* Check the path of a CRL issuer certificate. This creates a new\n * X509_STORE_CTX and populates it with most of the parameters from the\n * parent. This could be optimised somewhat since a lot of path checking\n * will be duplicated by the parent, but this will rarely be used in\n * practice.\n */\n\nstatic int\ncheck_crl_path(X509_STORE_CTX *ctx, X509 *x)\n{\n\tX509_STORE_CTX crl_ctx;\n\tint ret;\n\n\t/* Don't allow recursive CRL path validation */\n\tif (ctx->parent)\n\t\treturn 0;\n\tif (!X509_STORE_CTX_init(&crl_ctx, ctx->store, x, ctx->untrusted)) {\n\t\tret = -1;\n\t\tgoto err;\n\t}\n\n\tcrl_ctx.crls = ctx->crls;\n\t/* Copy verify params across */\n\tX509_STORE_CTX_set0_param(&crl_ctx, ctx->param);\n\n\tcrl_ctx.parent = ctx;\n\tcrl_ctx.verify_cb = ctx->verify_cb;\n\n\t/* Verify CRL issuer */\n\tret = X509_verify_cert(&crl_ctx);\n\n\tif (ret <= 0)\n\t\tgoto err;\n\n\t/* Check chain is acceptable */\n\tret = check_crl_chain(ctx, ctx->chain, crl_ctx.chain);\n\nerr:\n\tX509_STORE_CTX_cleanup(&crl_ctx);\n\treturn ret;\n}\n\n/* RFC3280 says nothing about the relationship between CRL path\n * and certificate path, which could lead to situations where a\n * certificate could be revoked or validated by a CA not authorised\n * to do so. RFC5280 is more strict and states that the two paths must\n * end in the same trust anchor, though some discussions remain...\n * until this is resolved we use the RFC5280 version\n */\n\nstatic int\ncheck_crl_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *cert_path,\n    STACK_OF(X509) *crl_path)\n{\n\tX509 *cert_ta, *crl_ta;\n\n\tcert_ta = sk_X509_value(cert_path, sk_X509_num(cert_path) - 1);\n\tcrl_ta = sk_X509_value(crl_path, sk_X509_num(crl_path) - 1);\n\tif (!X509_cmp(cert_ta, crl_ta))\n\t\treturn 1;\n\treturn 0;\n}\n\n/* Check for match between two dist point names: three separate cases.\n * 1. Both are relative names and compare X509_NAME types.\n * 2. One full, one relative. Compare X509_NAME to GENERAL_NAMES.\n * 3. Both are full names and compare two GENERAL_NAMES.\n * 4. One is NULL: automatic match.\n */\n\nstatic int\nidp_check_dp(DIST_POINT_NAME *a, DIST_POINT_NAME *b)\n{\n\tX509_NAME *nm = NULL;\n\tGENERAL_NAMES *gens = NULL;\n\tGENERAL_NAME *gena, *genb;\n\tint i, j;\n\n\tif (!a || !b)\n\t\treturn 1;\n\tif (a->type == 1) {\n\t\tif (!a->dpname)\n\t\t\treturn 0;\n\t\t/* Case 1: two X509_NAME */\n\t\tif (b->type == 1) {\n\t\t\tif (!b->dpname)\n\t\t\t\treturn 0;\n\t\t\tif (!X509_NAME_cmp(a->dpname, b->dpname))\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* Case 2: set name and GENERAL_NAMES appropriately */\n\t\tnm = a->dpname;\n\t\tgens = b->name.fullname;\n\t} else if (b->type == 1) {\n\t\tif (!b->dpname)\n\t\t\treturn 0;\n\t\t/* Case 2: set name and GENERAL_NAMES appropriately */\n\t\tgens = a->name.fullname;\n\t\tnm = b->dpname;\n\t}\n\n\t/* Handle case 2 with one GENERAL_NAMES and one X509_NAME */\n\tif (nm) {\n\t\tfor (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {\n\t\t\tgena = sk_GENERAL_NAME_value(gens, i);\n\t\t\tif (gena->type != GEN_DIRNAME)\n\t\t\t\tcontinue;\n\t\t\tif (!X509_NAME_cmp(nm, gena->d.directoryName))\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Else case 3: two GENERAL_NAMES */\n\n\tfor (i = 0; i < sk_GENERAL_NAME_num(a->name.fullname); i++) {\n\t\tgena = sk_GENERAL_NAME_value(a->name.fullname, i);\n\t\tfor (j = 0; j < sk_GENERAL_NAME_num(b->name.fullname); j++) {\n\t\t\tgenb = sk_GENERAL_NAME_value(b->name.fullname, j);\n\t\t\tif (!GENERAL_NAME_cmp(gena, genb))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\ncrldp_check_crlissuer(DIST_POINT *dp, X509_CRL *crl, int crl_score)\n{\n\tint i;\n\tX509_NAME *nm = X509_CRL_get_issuer(crl);\n\n\t/* If no CRLissuer return is successful iff don't need a match */\n\tif (!dp->CRLissuer)\n\t\treturn !!(crl_score & CRL_SCORE_ISSUER_NAME);\n\tfor (i = 0; i < sk_GENERAL_NAME_num(dp->CRLissuer); i++) {\n\t\tGENERAL_NAME *gen = sk_GENERAL_NAME_value(dp->CRLissuer, i);\n\t\tif (gen->type != GEN_DIRNAME)\n\t\t\tcontinue;\n\t\tif (!X509_NAME_cmp(gen->d.directoryName, nm))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* Check CRLDP and IDP */\n\nstatic int\ncrl_crldp_check(X509 *x, X509_CRL *crl, int crl_score, unsigned int *preasons)\n{\n\tint i;\n\n\tif (crl->idp_flags & IDP_ONLYATTR)\n\t\treturn 0;\n\tif (x->ex_flags & EXFLAG_CA) {\n\t\tif (crl->idp_flags & IDP_ONLYUSER)\n\t\t\treturn 0;\n\t} else {\n\t\tif (crl->idp_flags & IDP_ONLYCA)\n\t\t\treturn 0;\n\t}\n\t*preasons = crl->idp_reasons;\n\tfor (i = 0; i < sk_DIST_POINT_num(x->crldp); i++) {\n\t\tDIST_POINT *dp = sk_DIST_POINT_value(x->crldp, i);\n\t\tif (crldp_check_crlissuer(dp, crl, crl_score)) {\n\t\t\tif (!crl->idp ||\n\t\t\t    idp_check_dp(dp->distpoint, crl->idp->distpoint)) {\n\t\t\t\t*preasons &= dp->dp_reasons;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif ((!crl->idp || !crl->idp->distpoint) &&\n\t    (crl_score & CRL_SCORE_ISSUER_NAME))\n\t\treturn 1;\n\treturn 0;\n}\n\n/* Retrieve CRL corresponding to current certificate.\n * If deltas enabled try to find a delta CRL too\n */\n\nstatic int\nget_crl_delta(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl, X509 *x)\n{\n\tint ok;\n\tX509 *issuer = NULL;\n\tint crl_score = 0;\n\tunsigned int reasons;\n\tX509_CRL *crl = NULL, *dcrl = NULL;\n\tSTACK_OF(X509_CRL) *skcrl;\n\tX509_NAME *nm = X509_get_issuer_name(x);\n\n\treasons = ctx->current_reasons;\n\tok = get_crl_sk(ctx, &crl, &dcrl, &issuer, &crl_score, &reasons,\n\t    ctx->crls);\n\tif (ok)\n\t\tgoto done;\n\n\t/* Lookup CRLs from store */\n\tskcrl = ctx->lookup_crls(ctx, nm);\n\n\t/* If no CRLs found and a near match from get_crl_sk use that */\n\tif (!skcrl && crl)\n\t\tgoto done;\n\n\tget_crl_sk(ctx, &crl, &dcrl, &issuer, &crl_score, &reasons, skcrl);\n\n\tsk_X509_CRL_pop_free(skcrl, X509_CRL_free);\n\ndone:\n\n\t/* If we got any kind of CRL use it and return success */\n\tif (crl) {\n\t\tctx->current_issuer = issuer;\n\t\tctx->current_crl_score = crl_score;\n\t\tctx->current_reasons = reasons;\n\t\t*pcrl = crl;\n\t\t*pdcrl = dcrl;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/* Check CRL validity */\nstatic int\ncheck_crl(X509_STORE_CTX *ctx, X509_CRL *crl)\n{\n\tX509 *issuer = NULL;\n\tEVP_PKEY *ikey = NULL;\n\tint ok = 0, chnum, cnum;\n\n\tcnum = ctx->error_depth;\n\tchnum = sk_X509_num(ctx->chain) - 1;\n\t/* if we have an alternative CRL issuer cert use that */\n\tif (ctx->current_issuer) {\n\t\tissuer = ctx->current_issuer;\n\t} else if (cnum < chnum) {\n\t\t/*\n\t\t * Else find CRL issuer: if not last certificate then issuer\n\t\t * is next certificate in chain.\n\t\t */\n\t\tissuer = sk_X509_value(ctx->chain, cnum + 1);\n\t} else {\n\t\tissuer = sk_X509_value(ctx->chain, chnum);\n\t\t/* If not self signed, can't check signature */\n\t\tif (!ctx->check_issued(ctx, issuer, issuer)) {\n\t\t\tctx->error = X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER;\n\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\tif (!ok)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (issuer) {\n\t\t/* Skip most tests for deltas because they have already\n\t\t * been done\n\t\t */\n\t\tif (!crl->base_crl_number) {\n\t\t\t/* Check for cRLSign bit if keyUsage present */\n\t\t\tif ((issuer->ex_flags & EXFLAG_KUSAGE) &&\n\t\t\t    !(issuer->ex_kusage & KU_CRL_SIGN)) {\n\t\t\t\tctx->error = X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;\n\t\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (!(ctx->current_crl_score & CRL_SCORE_SCOPE)) {\n\t\t\t\tctx->error = X509_V_ERR_DIFFERENT_CRL_SCOPE;\n\t\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (!(ctx->current_crl_score & CRL_SCORE_SAME_PATH)) {\n\t\t\t\tif (check_crl_path(ctx,\n\t\t\t\t    ctx->current_issuer) <= 0) {\n\t\t\t\t\tctx->error = X509_V_ERR_CRL_PATH_VALIDATION_ERROR;\n\t\t\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\t\t\tif (!ok)\n\t\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (crl->idp_flags & IDP_INVALID) {\n\t\t\t\tctx->error = X509_V_ERR_INVALID_EXTENSION;\n\t\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\n\n\t\t}\n\n\t\tif (!(ctx->current_crl_score & CRL_SCORE_TIME)) {\n\t\t\tok = check_crl_time(ctx, crl, 1);\n\t\t\tif (!ok)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\t/* Attempt to get issuer certificate public key */\n\t\tikey = X509_get_pubkey(issuer);\n\n\t\tif (!ikey) {\n\t\t\tctx->error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\n\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\tif (!ok)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\t/* Verify CRL signature */\n\t\t\tif (X509_CRL_verify(crl, ikey) <= 0) {\n\t\t\t\tctx->error = X509_V_ERR_CRL_SIGNATURE_FAILURE;\n\t\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tok = 1;\n\nerr:\n\tEVP_PKEY_free(ikey);\n\treturn ok;\n}\n\n/* Check certificate against CRL */\nstatic int\ncert_crl(X509_STORE_CTX *ctx, X509_CRL *crl, X509 *x)\n{\n\tint ok;\n\tX509_REVOKED *rev;\n\n\t/* The rules changed for this... previously if a CRL contained\n\t * unhandled critical extensions it could still be used to indicate\n\t * a certificate was revoked. This has since been changed since\n\t * critical extension can change the meaning of CRL entries.\n\t */\n\tif (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL) &&\n\t    (crl->flags & EXFLAG_CRITICAL)) {\n\t\tctx->error = X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;\n\t\tok = ctx->verify_cb(0, ctx);\n\t\tif (!ok)\n\t\t\treturn 0;\n\t}\n\t/* Look for serial number of certificate in CRL\n\t * If found make sure reason is not removeFromCRL.\n\t */\n\tif (X509_CRL_get0_by_cert(crl, &rev, x)) {\n\t\tif (rev->reason == CRL_REASON_REMOVE_FROM_CRL)\n\t\t\treturn 2;\n\t\tctx->error = X509_V_ERR_CERT_REVOKED;\n\t\tok = ctx->verify_cb(0, ctx);\n\t\tif (!ok)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nint\nx509_vfy_check_policy(X509_STORE_CTX *ctx)\n{\n\tint ret;\n\n\tif (ctx->parent)\n\t\treturn 1;\n\n\t/* X509_policy_check always allocates a new tree. */\n\tX509_policy_tree_free(ctx->tree);\n\tctx->tree = NULL;\n\n\tret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,\n\t    ctx->param->policies, ctx->param->flags);\n\tif (ret == 0) {\n\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t}\n\t/* Invalid or inconsistent extensions */\n\tif (ret == -1) {\n\t\t/* Locate certificates with bad extensions and notify\n\t\t * callback.\n\t\t */\n\t\tX509 *x;\n\t\tint i;\n\t\tfor (i = 1; i < sk_X509_num(ctx->chain); i++) {\n\t\t\tx = sk_X509_value(ctx->chain, i);\n\t\t\tif (!(x->ex_flags & EXFLAG_INVALID_POLICY))\n\t\t\t\tcontinue;\n\t\t\tctx->current_cert = x;\n\t\t\tctx->error = X509_V_ERR_INVALID_POLICY_EXTENSION;\n\t\t\tif (!ctx->verify_cb(0, ctx))\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tif (ret == -2) {\n\t\tctx->current_cert = NULL;\n\t\tctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;\n\t\treturn ctx->verify_cb(0, ctx);\n\t}\n\n\tif (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) {\n\t\tctx->current_cert = NULL;\n\t\tctx->error = X509_V_OK;\n\t\tif (!ctx->verify_cb(2, ctx))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\ncheck_policy(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_check_policy(ctx);\n}\n\n/*\n * Inform the verify callback of an error.\n *\n * If x is not NULL it is the error cert, otherwise use the chain cert\n * at depth.\n *\n * If err is not X509_V_OK, that's the error value, otherwise leave\n * unchanged (presumably set by the caller).\n *\n * Returns 0 to abort verification with an error, non-zero to continue.\n */\nstatic int\nverify_cb_cert(X509_STORE_CTX *ctx, X509 *x, int depth, int err)\n{\n\tctx->error_depth = depth;\n\tctx->current_cert = (x != NULL) ? x : sk_X509_value(ctx->chain, depth);\n\tif (err != X509_V_OK)\n\t\tctx->error = err;\n\treturn ctx->verify_cb(0, ctx);\n}\n\n\n/* Mimic OpenSSL '0 for failure' ick */\nstatic int\ntime_t_bogocmp(time_t a, time_t b)\n{\n\tif (a == -1 || b == -1)\n\t\treturn 0;\n\tif (a <= b)\n\t\treturn -1;\n\treturn 1;\n}\n\n/*\n * Check certificate validity times.\n *\n * If depth >= 0, invoke verification callbacks on error, otherwise just return\n * the validation status.\n *\n * Return 1 on success, 0 otherwise.\n */\nint\nx509_check_cert_time(X509_STORE_CTX *ctx, X509 *x, int depth)\n{\n\ttime_t ptime;\n\tint i;\n\n\tif (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)\n\t\tptime = ctx->param->check_time;\n\telse if (ctx->param->flags & X509_V_FLAG_NO_CHECK_TIME)\n\t\treturn 1;\n\telse\n\t\tptime = time(NULL);\n\n\tif (x->ex_flags & EXFLAG_SET)\n\t\ti = time_t_bogocmp(x->not_before, ptime);\n\telse\n\t\ti = X509_cmp_time(X509_get_notBefore(x), &ptime);\n\n\tif (i >= 0 && depth < 0)\n\t\treturn 0;\n\tif (i == 0 && !verify_cb_cert(ctx, x, depth,\n\t    X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD))\n\t\treturn 0;\n\tif (i > 0 && !verify_cb_cert(ctx, x, depth,\n\t    X509_V_ERR_CERT_NOT_YET_VALID))\n\t\treturn 0;\n\n\tif (x->ex_flags & EXFLAG_SET)\n\t\ti = time_t_bogocmp(x->not_after, ptime);\n\telse\n\t\ti = X509_cmp_time_internal(X509_get_notAfter(x), &ptime, 1);\n\n\tif (i <= 0 && depth < 0)\n\t\treturn 0;\n\tif (i == 0 && !verify_cb_cert(ctx, x, depth,\n\t    X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD))\n\t\treturn 0;\n\tif (i < 0 && !verify_cb_cert(ctx, x, depth,\n\t    X509_V_ERR_CERT_HAS_EXPIRED))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int\nx509_vfy_internal_verify(X509_STORE_CTX *ctx, int chain_verified)\n{\n\tint n = sk_X509_num(ctx->chain) - 1;\n\tX509 *xi = sk_X509_value(ctx->chain, n);\n\tX509 *xs;\n\n\tif (ctx->check_issued(ctx, xi, xi))\n\t\txs = xi;\n\telse {\n\t\tif (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {\n\t\t\txs = xi;\n\t\t\tgoto check_cert;\n\t\t}\n\t\tif (n <= 0)\n\t\t\treturn verify_cb_cert(ctx, xi, 0,\n\t\t\t    X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE);\n\t\tn--;\n\t\tctx->error_depth = n;\n\t\txs = sk_X509_value(ctx->chain, n);\n\t}\n\n\t/*\n\t * Do not clear ctx->error=0, it must be \"sticky\", only the\n\t * user's callback is allowed to reset errors (at its own\n\t * peril).\n\t */\n\twhile (n >= 0) {\n\n\t\t/*\n\t\t * Skip signature check for self signed certificates\n\t\t * unless explicitly asked for.  It doesn't add any\n\t\t * security and just wastes time.  If the issuer's\n\t\t * public key is unusable, report the issuer\n\t\t * certificate and its depth (rather than the depth of\n\t\t * the subject).\n\t\t */\n\t\tif (!chain_verified && ( xs != xi ||\n\t\t    (ctx->param->flags & X509_V_FLAG_CHECK_SS_SIGNATURE))) {\n\t\t\tEVP_PKEY *pkey;\n\t\t\tif ((pkey = X509_get_pubkey(xi)) == NULL) {\n\t\t\t\tif (!verify_cb_cert(ctx, xi, xi != xs ? n+1 : n,\n\t\t\t\t    X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY))\n\t\t\t\t\treturn 0;\n\t\t\t} else if (X509_verify(xs, pkey) <= 0) {\n\t\t\t\tif (!verify_cb_cert(ctx, xs, n,\n\t\t\t\t    X509_V_ERR_CERT_SIGNATURE_FAILURE)) {\n\t\t\t\t\tEVP_PKEY_free(pkey);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tEVP_PKEY_free(pkey);\n\t\t}\ncheck_cert:\n\t\t/* Calls verify callback as needed */\n\t\tif (!chain_verified && !x509_check_cert_time(ctx, xs, n))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Signal success at this depth.  However, the\n\t\t * previous error (if any) is retained.\n\t\t */\n\t\tctx->current_issuer = xi;\n\t\tctx->current_cert = xs;\n\t\tctx->error_depth = n;\n\t\tif (!ctx->verify_cb(1, ctx))\n\t\t\treturn 0;\n\n\t\tif (--n >= 0) {\n\t\t\txi = xs;\n\t\t\txs = sk_X509_value(ctx->chain, n);\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int\ninternal_verify(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_internal_verify(ctx, 0);\n}\n\nint\nx509_vfy_callback_indicate_success(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_internal_verify(ctx, 1);\n}\n\nint\nX509_cmp_current_time(const ASN1_TIME *ctm)\n{\n\treturn X509_cmp_time(ctm, NULL);\n}\n\n/*\n * Compare a possibly unvalidated ASN1_TIME string against a time_t\n * using RFC 5280 rules for the time string. If *cmp_time is NULL\n * the current system time is used.\n *\n * XXX NOTE that unlike what you expect a \"cmp\" function to do in C,\n * XXX this one is \"special\", and returns 0 for error.\n *\n * Returns:\n * -1 if the ASN1_time is earlier than OR the same as *cmp_time.\n * 1 if the ASN1_time is later than *cmp_time.\n * 0 on error.\n */\nstatic int\nX509_cmp_time_internal(const ASN1_TIME *ctm, time_t *cmp_time, int is_notafter)\n{\n\ttime_t compare, cert_time;\n\n\tif (cmp_time == NULL)\n\t\tcompare = time(NULL);\n\telse\n\t\tcompare = *cmp_time;\n\n\tif ((cert_time = x509_verify_asn1_time_to_time_t(ctm, is_notafter)) ==\n\t    -1)\n\t\treturn 0; /* invalid time */\n\n\tif (cert_time <= compare)\n\t\treturn -1; /* 0 is used for error, so map same to less than */\n\n\treturn 1;\n}\n\nint\nX509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n\treturn X509_cmp_time_internal(ctm, cmp_time, 0);\n}\n\n\nASN1_TIME *\nX509_gmtime_adj(ASN1_TIME *s, long adj)\n{\n\treturn X509_time_adj(s, adj, NULL);\n}\n\nASN1_TIME *\nX509_time_adj(ASN1_TIME *s, long offset_sec, time_t *in_time)\n{\n\treturn X509_time_adj_ex(s, 0, offset_sec, in_time);\n}\n\nASN1_TIME *\nX509_time_adj_ex(ASN1_TIME *s, int offset_day, long offset_sec, time_t *in_time)\n{\n\ttime_t t;\n\tif (in_time == NULL)\n\t\tt = time(NULL);\n\telse\n\t\tt = *in_time;\n\n\treturn ASN1_TIME_adj(s, t, offset_day, offset_sec);\n}\n\nint\nX509_get_pubkey_parameters(EVP_PKEY *pkey, STACK_OF(X509) *chain)\n{\n\tEVP_PKEY *ktmp = NULL, *ktmp2;\n\tint i, j;\n\n\tif ((pkey != NULL) && !EVP_PKEY_missing_parameters(pkey))\n\t\treturn 1;\n\n\tfor (i = 0; i < sk_X509_num(chain); i++) {\n\t\tktmp = X509_get_pubkey(sk_X509_value(chain, i));\n\t\tif (ktmp == NULL) {\n\t\t\tX509error(X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!EVP_PKEY_missing_parameters(ktmp))\n\t\t\tbreak;\n\t\telse {\n\t\t\tEVP_PKEY_free(ktmp);\n\t\t\tktmp = NULL;\n\t\t}\n\t}\n\tif (ktmp == NULL) {\n\t\tX509error(X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN);\n\t\treturn 0;\n\t}\n\n\t/* first, populate the other certs */\n\tfor (j = i - 1; j >= 0; j--) {\n\t\tktmp2 = X509_get_pubkey(sk_X509_value(chain, j));\n\t\tEVP_PKEY_copy_parameters(ktmp2, ktmp);\n\t\tEVP_PKEY_free(ktmp2);\n\t}\n\n\tif (pkey != NULL)\n\t\tEVP_PKEY_copy_parameters(pkey, ktmp);\n\tEVP_PKEY_free(ktmp);\n\treturn 1;\n}\n\nint\nX509_STORE_CTX_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\n    CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\n{\n\t/* This function is (usually) called only once, by\n\t * SSL_get_ex_data_X509_STORE_CTX_idx (ssl/ssl_cert.c). */\n\treturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX,\n\t    argl, argp, new_func, dup_func, free_func);\n}\n\nint\nX509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data)\n{\n\treturn CRYPTO_set_ex_data(&ctx->ex_data, idx, data);\n}\n\nvoid *\nX509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx, int idx)\n{\n\treturn CRYPTO_get_ex_data(&ctx->ex_data, idx);\n}\n\nint\nX509_STORE_CTX_get_error(X509_STORE_CTX *ctx)\n{\n\treturn ctx->error;\n}\n\nvoid\nX509_STORE_CTX_set_error(X509_STORE_CTX *ctx, int err)\n{\n\tctx->error = err;\n}\n\nint\nX509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx)\n{\n\treturn ctx->error_depth;\n}\n\nvoid\nX509_STORE_CTX_set_error_depth(X509_STORE_CTX *ctx, int depth)\n{\n\tctx->error_depth = depth;\n}\n\nX509 *\nX509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx)\n{\n\treturn ctx->current_cert;\n}\n\nvoid\nX509_STORE_CTX_set_current_cert(X509_STORE_CTX *ctx, X509 *x)\n{\n\tctx->current_cert = x;\n}\n\nSTACK_OF(X509) *\nX509_STORE_CTX_get_chain(X509_STORE_CTX *ctx)\n{\n\treturn ctx->chain;\n}\n\nSTACK_OF(X509) *\nX509_STORE_CTX_get0_chain(X509_STORE_CTX *xs)\n{\n\treturn xs->chain;\n}\n\nSTACK_OF(X509) *\nX509_STORE_CTX_get1_chain(X509_STORE_CTX *ctx)\n{\n\tint i;\n\tX509 *x;\n\tSTACK_OF(X509) *chain;\n\n\tif (!ctx->chain || !(chain = sk_X509_dup(ctx->chain)))\n\t\treturn NULL;\n\tfor (i = 0; i < sk_X509_num(chain); i++) {\n\t\tx = sk_X509_value(chain, i);\n\t\tCRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);\n\t}\n\treturn chain;\n}\n\nX509 *\nX509_STORE_CTX_get0_current_issuer(X509_STORE_CTX *ctx)\n{\n\treturn ctx->current_issuer;\n}\n\nX509_CRL *\nX509_STORE_CTX_get0_current_crl(X509_STORE_CTX *ctx)\n{\n\treturn ctx->current_crl;\n}\n\nX509_STORE_CTX *\nX509_STORE_CTX_get0_parent_ctx(X509_STORE_CTX *ctx)\n{\n\treturn ctx->parent;\n}\n\nX509_STORE *\nX509_STORE_CTX_get0_store(X509_STORE_CTX *xs)\n{\n\treturn xs->store;\n}\n\nvoid\nX509_STORE_CTX_set_cert(X509_STORE_CTX *ctx, X509 *x)\n{\n\tctx->cert = x;\n}\n\nvoid\nX509_STORE_CTX_set_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)\n{\n\tctx->untrusted = sk;\n}\n\nvoid\nX509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx, STACK_OF(X509_CRL) *sk)\n{\n\tctx->crls = sk;\n}\n\nint\nX509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose)\n{\n\treturn X509_STORE_CTX_purpose_inherit(ctx, 0, purpose, 0);\n}\n\nint\nX509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust)\n{\n\treturn X509_STORE_CTX_purpose_inherit(ctx, 0, 0, trust);\n}\n\n/* This function is used to set the X509_STORE_CTX purpose and trust\n * values. This is intended to be used when another structure has its\n * own trust and purpose values which (if set) will be inherited by\n * the ctx. If they aren't set then we will usually have a default\n * purpose in mind which should then be used to set the trust value.\n * An example of this is SSL use: an SSL structure will have its own\n * purpose and trust settings which the application can set: if they\n * aren't set then we use the default of SSL client/server.\n */\n\nint\nX509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,\n    int purpose, int trust)\n{\n\tint idx;\n\n\t/* If purpose not set use default */\n\tif (!purpose)\n\t\tpurpose = def_purpose;\n\t/* If we have a purpose then check it is valid */\n\tif (purpose) {\n\t\tX509_PURPOSE *ptmp;\n\t\tidx = X509_PURPOSE_get_by_id(purpose);\n\t\tif (idx == -1) {\n\t\t\tX509error(X509_R_UNKNOWN_PURPOSE_ID);\n\t\t\treturn 0;\n\t\t}\n\t\tptmp = X509_PURPOSE_get0(idx);\n\t\tif (ptmp->trust == X509_TRUST_DEFAULT) {\n\t\t\tidx = X509_PURPOSE_get_by_id(def_purpose);\n\t\t\tif (idx == -1) {\n\t\t\t\tX509error(X509_R_UNKNOWN_PURPOSE_ID);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tptmp = X509_PURPOSE_get0(idx);\n\t\t}\n\t\t/* If trust not set then get from purpose default */\n\t\tif (!trust)\n\t\t\ttrust = ptmp->trust;\n\t}\n\tif (trust) {\n\t\tidx = X509_TRUST_get_by_id(trust);\n\t\tif (idx == -1) {\n\t\t\tX509error(X509_R_UNKNOWN_TRUST_ID);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (purpose && !ctx->param->purpose)\n\t\tctx->param->purpose = purpose;\n\tif (trust && !ctx->param->trust)\n\t\tctx->param->trust = trust;\n\treturn 1;\n}\n\nX509_STORE_CTX *\nX509_STORE_CTX_new(void)\n{\n\tX509_STORE_CTX *ctx;\n\n\tctx = calloc(1, sizeof(X509_STORE_CTX));\n\tif (!ctx) {\n\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\treturn NULL;\n\t}\n\treturn ctx;\n}\n\nvoid\nX509_STORE_CTX_free(X509_STORE_CTX *ctx)\n{\n\tif (ctx == NULL)\n\t\treturn;\n\n\tX509_STORE_CTX_cleanup(ctx);\n\tfree(ctx);\n}\n\nint\nX509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509,\n    STACK_OF(X509) *chain)\n{\n\tint param_ret = 1;\n\n\t/*\n\t * Make sure everything is initialized properly even in case of an\n\t * early return due to an error.\n\t *\n\t * While this 'ctx' can be reused, X509_STORE_CTX_cleanup() will have\n\t * freed everything and memset ex_data anyway.  This also allows us\n\t * to safely use X509_STORE_CTX variables from the stack which will\n\t * have uninitialized data.\n\t */\n\tmemset(ctx, 0, sizeof(*ctx));\n\n\t/*\n\t * Start with this set to not valid - it will be set to valid\n\t * in X509_verify_cert.\n\t */\n\tctx->error = X509_V_ERR_INVALID_CALL;\n\n\t/*\n\t * Set values other than 0.  Keep this in the same order as\n\t * X509_STORE_CTX except for values that may fail.  All fields that\n\t * may fail should go last to make sure 'ctx' is as consistent as\n\t * possible even on early exits.\n\t */\n\tctx->store = store;\n\tctx->cert = x509;\n\tctx->untrusted = chain;\n\n\tif (store && store->verify)\n\t\tctx->verify = store->verify;\n\telse\n\t\tctx->verify = internal_verify;\n\n\tif (store && store->verify_cb)\n\t\tctx->verify_cb = store->verify_cb;\n\telse\n\t\tctx->verify_cb = null_callback;\n\n\tif (store && store->get_issuer)\n\t\tctx->get_issuer = store->get_issuer;\n\telse\n\t\tctx->get_issuer = X509_STORE_CTX_get1_issuer;\n\n\tif (store && store->check_issued)\n\t\tctx->check_issued = store->check_issued;\n\telse\n\t\tctx->check_issued = check_issued;\n\n\tif (store && store->check_revocation)\n\t\tctx->check_revocation = store->check_revocation;\n\telse\n\t\tctx->check_revocation = check_revocation;\n\n\tif (store && store->get_crl)\n\t\tctx->get_crl = store->get_crl;\n\telse\n\t\tctx->get_crl = NULL;\n\n\tif (store && store->check_crl)\n\t\tctx->check_crl = store->check_crl;\n\telse\n\t\tctx->check_crl = check_crl;\n\n\tif (store && store->cert_crl)\n\t\tctx->cert_crl = store->cert_crl;\n\telse\n\t\tctx->cert_crl = cert_crl;\n\n\tctx->check_policy = check_policy;\n\n\tif (store && store->lookup_certs)\n\t\tctx->lookup_certs = store->lookup_certs;\n\telse\n\t\tctx->lookup_certs = X509_STORE_get1_certs;\n\n\tif (store && store->lookup_crls)\n\t\tctx->lookup_crls = store->lookup_crls;\n\telse\n\t\tctx->lookup_crls = X509_STORE_get1_crls;\n\n\tif (store && store->cleanup)\n\t\tctx->cleanup = store->cleanup;\n\telse\n\t\tctx->cleanup = NULL;\n\n\tctx->param = X509_VERIFY_PARAM_new();\n\tif (!ctx->param) {\n\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t}\n\n\t/* Inherit callbacks and flags from X509_STORE if not set\n\t * use defaults.\n\t */\n\tif (store)\n\t\tparam_ret = X509_VERIFY_PARAM_inherit(ctx->param, store->param);\n\telse\n\t\tctx->param->inh_flags |= X509_VP_FLAG_DEFAULT|X509_VP_FLAG_ONCE;\n\n\tif (param_ret)\n\t\tparam_ret = X509_VERIFY_PARAM_inherit(ctx->param,\n\t\t    X509_VERIFY_PARAM_lookup(\"default\"));\n\n\tif (param_ret == 0) {\n\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t}\n\n\tif (CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx,\n\t    &(ctx->ex_data)) == 0) {\n\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* Set alternative lookup method: just a STACK of trusted certificates.\n * This avoids X509_STORE nastiness where it isn't needed.\n */\n\nvoid\nX509_STORE_CTX_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)\n{\n\tctx->other_ctx = sk;\n\tctx->get_issuer = get_issuer_sk;\n}\n\nvoid\nX509_STORE_CTX_set0_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)\n{\n\tX509_STORE_CTX_trusted_stack(ctx, sk);\n}\n\nvoid\nX509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)\n{\n\tif (ctx->cleanup)\n\t\tctx->cleanup(ctx);\n\tif (ctx->param != NULL) {\n\t\tif (ctx->parent == NULL)\n\t\t\tX509_VERIFY_PARAM_free(ctx->param);\n\t\tctx->param = NULL;\n\t}\n\tif (ctx->tree != NULL) {\n\t\tX509_policy_tree_free(ctx->tree);\n\t\tctx->tree = NULL;\n\t}\n\tif (ctx->chain != NULL) {\n\t\tsk_X509_pop_free(ctx->chain, X509_free);\n\t\tctx->chain = NULL;\n\t}\n\tCRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX,\n\t    ctx, &(ctx->ex_data));\n\tmemset(&ctx->ex_data, 0, sizeof(CRYPTO_EX_DATA));\n}\n\nvoid\nX509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth)\n{\n\tX509_VERIFY_PARAM_set_depth(ctx->param, depth);\n}\n\nvoid\nX509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, unsigned long flags)\n{\n\tX509_VERIFY_PARAM_set_flags(ctx->param, flags);\n}\n\nvoid\nX509_STORE_CTX_set_time(X509_STORE_CTX *ctx, unsigned long flags, time_t t)\n{\n\tX509_VERIFY_PARAM_set_time(ctx->param, t);\n}\n\nint\n(*X509_STORE_CTX_get_verify_cb(X509_STORE_CTX *ctx))(int, X509_STORE_CTX *)\n{\n\treturn ctx->verify_cb;\n}\n\nvoid\nX509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,\n    int (*verify_cb)(int, X509_STORE_CTX *))\n{\n\tctx->verify_cb = verify_cb;\n}\n\nint\n(*X509_STORE_CTX_get_verify(X509_STORE_CTX *ctx))(X509_STORE_CTX *)\n{\n\treturn ctx->verify;\n}\n\nvoid\nX509_STORE_CTX_set_verify(X509_STORE_CTX *ctx, int (*verify)(X509_STORE_CTX *))\n{\n\tctx->verify = verify;\n}\n\nX509 *\nX509_STORE_CTX_get0_cert(X509_STORE_CTX *ctx)\n{\n\treturn ctx->cert;\n}\n\nSTACK_OF(X509) *\nX509_STORE_CTX_get0_untrusted(X509_STORE_CTX *ctx)\n{\n\treturn ctx->untrusted;\n}\n\nvoid\nX509_STORE_CTX_set0_untrusted(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)\n{\n\tctx->untrusted = sk;\n}\n\nvoid\nX509_STORE_CTX_set0_verified_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)\n{\n\tsk_X509_pop_free(ctx->chain, X509_free);\n\tctx->chain = sk;\n}\n\nX509_POLICY_TREE *\nX509_STORE_CTX_get0_policy_tree(X509_STORE_CTX *ctx)\n{\n\treturn ctx->tree;\n}\n\nint\nX509_STORE_CTX_get_explicit_policy(X509_STORE_CTX *ctx)\n{\n\treturn ctx->explicit_policy;\n}\n\nint\nX509_STORE_CTX_get_num_untrusted(X509_STORE_CTX *ctx)\n{\n\treturn ctx->num_untrusted;\n}\n\nint\nX509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name)\n{\n\tconst X509_VERIFY_PARAM *param;\n\tparam = X509_VERIFY_PARAM_lookup(name);\n\tif (!param)\n\t\treturn 0;\n\treturn X509_VERIFY_PARAM_inherit(ctx->param, param);\n}\n\nX509_VERIFY_PARAM *\nX509_STORE_CTX_get0_param(X509_STORE_CTX *ctx)\n{\n\treturn ctx->param;\n}\n\nvoid\nX509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param)\n{\n\tif (ctx->param)\n\t\tX509_VERIFY_PARAM_free(ctx->param);\n\tctx->param = param;\n}\n"], "fixing_code": ["/* $OpenBSD: x509_internal.h,v 1.16 2021/11/24 05:38:12 beck Exp $ */\n/*\n * Copyright (c) 2020 Bob Beck <beck@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n#ifndef HEADER_X509_INTERNAL_H\n#define HEADER_X509_INTERNAL_H\n\n/* Internal use only, not public API */\n#include <netinet/in.h>\n\n#include <openssl/x509_verify.h>\n\n#include \"x509_lcl.h\"\n\n/* Hard limits on structure size and number of signature checks. */\n#define X509_VERIFY_MAX_CHAINS\t\t8\t/* Max validated chains */\n#define X509_VERIFY_MAX_CHAIN_CERTS\t32\t/* Max depth of a chain */\n#define X509_VERIFY_MAX_SIGCHECKS\t256\t/* Max signature checks */\n\n/*\n * Limit the number of names and constraints we will check in a chain\n * to avoid a hostile input DOS\n */\n#define X509_VERIFY_MAX_CHAIN_NAMES\t\t512\n#define X509_VERIFY_MAX_CHAIN_CONSTRAINTS\t512\n\n/*\n * Hold the parsed and validated result of names from a certificate.\n * these typically come from a GENERALNAME, but we store the parsed\n * and validated results, not the ASN1 bytes.\n */\nstruct x509_constraints_name {\n\tint type;\t\t\t/* GEN_* types from GENERAL_NAME */\n\tchar *name;\t\t\t/* Name to check */\n\tchar *local;\t\t\t/* holds the local part of GEN_EMAIL */\n\tuint8_t *der;\t\t\t/* DER encoded value or NULL*/\n\tsize_t der_len;\n\tint af;\t\t\t\t/* INET and INET6 are supported */\n\tuint8_t address[32];\t\t/* Must hold ipv6 + mask */\n};\n\nstruct x509_constraints_names {\n\tstruct x509_constraints_name **names;\n\tsize_t names_count;\n\tsize_t names_len;\n\tsize_t names_max;\n};\n\nstruct x509_verify_chain {\n\tSTACK_OF(X509) *certs;\t\t/* Kept in chain order, includes leaf */\n\tint *cert_errors;\t\t/* Verify error for each cert in chain. */\n\tstruct x509_constraints_names *names;\t/* All names from all certs */\n};\n\nstruct x509_verify_ctx {\n\tX509_STORE_CTX *xsc;\n\tstruct x509_verify_chain **chains;\t/* Validated chains */\n\tSTACK_OF(X509) *saved_error_chain;\n\tint saved_error;\n\tint saved_error_depth;\n\tsize_t chains_count;\n\tSTACK_OF(X509) *roots;\t\t/* Trusted roots for this validation */\n\tSTACK_OF(X509) *intermediates;\t/* Intermediates provided by peer */\n\ttime_t *check_time;\t\t/* Time for validity checks */\n\tint purpose;\t\t\t/* Cert purpose we are validating */\n\tsize_t max_chains;\t\t/* Max chains to return */\n\tsize_t max_depth;\t\t/* Max chain depth for validation */\n\tsize_t max_sigs;\t\t/* Max number of signature checks */\n\tsize_t sig_checks;\t\t/* Number of signature checks done */\n\tsize_t error_depth;\t\t/* Depth of last error seen */\n\tint error;\t\t\t/* Last error seen */\n};\n\nint ASN1_time_tm_clamp_notafter(struct tm *tm);\n\n__BEGIN_HIDDEN_DECLS\n\nint x509_vfy_check_id(X509_STORE_CTX *ctx);\nint x509_vfy_check_revocation(X509_STORE_CTX *ctx);\nint x509_vfy_check_policy(X509_STORE_CTX *ctx);\nint x509_vfy_check_trust(X509_STORE_CTX *ctx);\nint x509_vfy_check_chain_extensions(X509_STORE_CTX *ctx);\nint x509_vfy_callback_indicate_completion(X509_STORE_CTX *ctx);\nvoid x509v3_cache_extensions(X509 *x);\nX509 *x509_vfy_lookup_cert_match(X509_STORE_CTX *ctx, X509 *x);\n\ntime_t x509_verify_asn1_time_to_time_t(const ASN1_TIME *atime, int notafter);\n\nstruct x509_verify_ctx *x509_verify_ctx_new_from_xsc(X509_STORE_CTX *xsc);\n\nvoid x509_constraints_name_clear(struct x509_constraints_name *name);\nint x509_constraints_names_add(struct x509_constraints_names *names,\n    struct x509_constraints_name *name);\nstruct x509_constraints_names *x509_constraints_names_dup(\n    struct x509_constraints_names *names);\nvoid x509_constraints_names_clear(struct x509_constraints_names *names);\nstruct x509_constraints_names *x509_constraints_names_new(size_t names_max);\nint x509_constraints_general_to_bytes(GENERAL_NAME *name, uint8_t **bytes,\n    size_t *len);\nvoid x509_constraints_names_free(struct x509_constraints_names *names);\nint x509_constraints_valid_host(uint8_t *name, size_t len);\nint x509_constraints_valid_sandns(uint8_t *name, size_t len);\nint x509_constraints_domain(char *domain, size_t dlen, char *constraint,\n    size_t len);\nint x509_constraints_parse_mailbox(uint8_t *candidate, size_t len,\n    struct x509_constraints_name *name);\nint x509_constraints_valid_domain_constraint(uint8_t *constraint,\n    size_t len);\nint x509_constraints_uri_host(uint8_t *uri, size_t len, char **hostp);\nint x509_constraints_uri(uint8_t *uri, size_t ulen, uint8_t *constraint,\n    size_t len, int *error);\nint x509_constraints_extract_names(struct x509_constraints_names *names,\n    X509 *cert, int include_cn, int *error);\nint x509_constraints_extract_constraints(X509 *cert,\n    struct x509_constraints_names *permitted,\n    struct x509_constraints_names *excluded, int *error);\nint x509_constraints_check(struct x509_constraints_names *names,\n    struct x509_constraints_names *permitted,\n    struct x509_constraints_names *excluded, int *error);\nint x509_constraints_chain(STACK_OF(X509) *chain, int *error,\n    int *depth);\nvoid x509_verify_cert_info_populate(X509 *cert);\n\n__END_HIDDEN_DECLS\n\n#endif\n", "/* $OpenBSD: x509_verify.c,v 1.54 2021/11/24 05:38:12 beck Exp $ */\n/*\n * Copyright (c) 2020-2021 Bob Beck <beck@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/* x509_verify - inspired by golang's crypto/x509.Verify */\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <openssl/safestack.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n\n#include \"x509_internal.h\"\n#include \"x509_issuer_cache.h\"\n\nstatic int x509_verify_cert_valid(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain);\nstatic void x509_verify_build_chains(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain, int full_chain);\nstatic int x509_verify_cert_error(struct x509_verify_ctx *ctx, X509 *cert,\n    size_t depth, int error, int ok);\nstatic void x509_verify_chain_free(struct x509_verify_chain *chain);\n\n/*\n * Parse an asn1 to a representable time_t as per RFC 5280 rules.\n * Returns -1 if that can't be done for any reason.\n */\ntime_t\nx509_verify_asn1_time_to_time_t(const ASN1_TIME *atime, int notAfter)\n{\n\tstruct tm tm = { 0 };\n\tint type;\n\n\ttype = ASN1_time_parse(atime->data, atime->length, &tm, atime->type);\n\tif (type == -1)\n\t\treturn -1;\n\n\t/* RFC 5280 section 4.1.2.5 */\n\tif (tm.tm_year < 150 && type != V_ASN1_UTCTIME)\n\t\treturn -1;\n\tif (tm.tm_year >= 150 && type != V_ASN1_GENERALIZEDTIME)\n\t\treturn -1;\n\n\tif (notAfter) {\n\t\t/*\n\t\t * If we are a completely broken operating system with a\n\t\t * 32 bit time_t, and we have been told this is a notAfter\n\t\t * date, limit the date to a 32 bit representable value.\n\t\t */\n\t\tif (!ASN1_time_tm_clamp_notafter(&tm))\n\t\t\treturn -1;\n\t}\n\n\t/*\n\t * Defensively fail if the time string is not representable as\n\t * a time_t. A time_t must be sane if you care about times after\n\t * Jan 19 2038.\n\t */\n\treturn timegm(&tm);\n}\n\n/*\n * Cache certificate hash, and values parsed out of an X509.\n * called from cache_extensions()\n */\nvoid\nx509_verify_cert_info_populate(X509 *cert)\n{\n\t/*\n\t * Parse and save the cert times, or remember that they\n\t * are unacceptable/unparsable.\n\t */\n\tcert->not_before = x509_verify_asn1_time_to_time_t(X509_get_notBefore(cert), 0);\n\tcert->not_after = x509_verify_asn1_time_to_time_t(X509_get_notAfter(cert), 1);\n}\n\nstruct x509_verify_chain *\nx509_verify_chain_new(void)\n{\n\tstruct x509_verify_chain *chain;\n\n\tif ((chain = calloc(1, sizeof(*chain))) == NULL)\n\t\tgoto err;\n\tif ((chain->certs = sk_X509_new_null()) == NULL)\n\t\tgoto err;\n\tif ((chain->cert_errors = calloc(X509_VERIFY_MAX_CHAIN_CERTS,\n\t    sizeof(int))) == NULL)\n\t\tgoto err;\n\tif ((chain->names =\n\t    x509_constraints_names_new(X509_VERIFY_MAX_CHAIN_NAMES)) == NULL)\n\t\tgoto err;\n\n\treturn chain;\n err:\n\tx509_verify_chain_free(chain);\n\treturn NULL;\n}\n\nstatic void\nx509_verify_chain_clear(struct x509_verify_chain *chain)\n{\n\tsk_X509_pop_free(chain->certs, X509_free);\n\tchain->certs = NULL;\n\tfree(chain->cert_errors);\n\tchain->cert_errors = NULL;\n\tx509_constraints_names_free(chain->names);\n\tchain->names = NULL;\n}\n\nstatic void\nx509_verify_chain_free(struct x509_verify_chain *chain)\n{\n\tif (chain == NULL)\n\t\treturn;\n\tx509_verify_chain_clear(chain);\n\tfree(chain);\n}\n\nstatic struct x509_verify_chain *\nx509_verify_chain_dup(struct x509_verify_chain *chain)\n{\n\tstruct x509_verify_chain *new_chain;\n\n\tif ((new_chain = calloc(1, sizeof(*chain))) == NULL)\n\t\tgoto err;\n\tif ((new_chain->certs = X509_chain_up_ref(chain->certs)) == NULL)\n\t\tgoto err;\n\tif ((new_chain->cert_errors = calloc(X509_VERIFY_MAX_CHAIN_CERTS,\n\t    sizeof(int))) == NULL)\n\t\tgoto err;\n\tmemcpy(new_chain->cert_errors, chain->cert_errors,\n\t    X509_VERIFY_MAX_CHAIN_CERTS * sizeof(int));\n\tif ((new_chain->names =\n\t    x509_constraints_names_dup(chain->names)) == NULL)\n\t\tgoto err;\n\treturn(new_chain);\n err:\n\tx509_verify_chain_free(new_chain);\n\treturn NULL;\n}\n\nstatic int\nx509_verify_chain_append(struct x509_verify_chain *chain, X509 *cert,\n    int *error)\n{\n\tint verify_err = X509_V_ERR_UNSPECIFIED;\n\tsize_t idx;\n\n\tif (!x509_constraints_extract_names(chain->names, cert,\n\t    sk_X509_num(chain->certs) == 0, &verify_err)) {\n\t\t*error = verify_err;\n\t\treturn 0;\n\t}\n\n\tX509_up_ref(cert);\n\tif (!sk_X509_push(chain->certs, cert)) {\n\t\tX509_free(cert);\n\t\t*error = X509_V_ERR_OUT_OF_MEM;\n\t\treturn 0;\n\t}\n\n\tidx = sk_X509_num(chain->certs) - 1;\n\tchain->cert_errors[idx] = *error;\n\n\t/*\n\t * We've just added the issuer for the previous certificate,\n\t * clear its error if appropriate.\n\t */\n\tif (idx > 1 && chain->cert_errors[idx - 1] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[idx - 1] = X509_V_OK;\n\n\treturn 1;\n}\n\nstatic X509 *\nx509_verify_chain_last(struct x509_verify_chain *chain)\n{\n\tint last;\n\n\tif (chain->certs == NULL)\n\t\treturn NULL;\n\tif ((last = sk_X509_num(chain->certs) - 1) < 0)\n\t\treturn NULL;\n\treturn sk_X509_value(chain->certs, last);\n}\n\nX509 *\nx509_verify_chain_leaf(struct x509_verify_chain *chain)\n{\n\tif (chain->certs == NULL)\n\t\treturn NULL;\n\treturn sk_X509_value(chain->certs, 0);\n}\n\nstatic void\nx509_verify_ctx_reset(struct x509_verify_ctx *ctx)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ctx->chains_count; i++)\n\t\tx509_verify_chain_free(ctx->chains[i]);\n\tsk_X509_pop_free(ctx->saved_error_chain, X509_free);\n\tctx->saved_error = 0;\n\tctx->saved_error_depth = 0;\n\tctx->error = 0;\n\tctx->error_depth = 0;\n\tctx->chains_count = 0;\n\tctx->sig_checks = 0;\n\tctx->check_time = NULL;\n}\n\nstatic void\nx509_verify_ctx_clear(struct x509_verify_ctx *ctx)\n{\n\tx509_verify_ctx_reset(ctx);\n\tsk_X509_pop_free(ctx->intermediates, X509_free);\n\tfree(ctx->chains);\n\tmemset(ctx, 0, sizeof(*ctx));\n}\n\nstatic int\nx509_verify_cert_cache_extensions(X509 *cert) {\n\tif (!(cert->ex_flags & EXFLAG_SET)) {\n\t\tCRYPTO_w_lock(CRYPTO_LOCK_X509);\n\t\tx509v3_cache_extensions(cert);\n\t\tCRYPTO_w_unlock(CRYPTO_LOCK_X509);\n\t}\n\tif (cert->ex_flags & EXFLAG_INVALID)\n\t\treturn 0;\n\n\treturn (cert->ex_flags & EXFLAG_SET);\n}\n\nstatic int\nx509_verify_cert_self_signed(X509 *cert)\n{\n\treturn (cert->ex_flags & EXFLAG_SS) ? 1 : 0;\n}\n\nstatic int\nx509_verify_ctx_cert_is_root(struct x509_verify_ctx *ctx, X509 *cert,\n    int full_chain)\n{\n\tX509 *match = NULL;\n\tint i;\n\n\tif (!x509_verify_cert_cache_extensions(cert))\n\t\treturn 0;\n\n\t/* Check by lookup if we have a legacy xsc */\n\tif (ctx->xsc != NULL) {\n\t\tif ((match = x509_vfy_lookup_cert_match(ctx->xsc,\n\t\t    cert)) != NULL) {\n\t\t\tX509_free(match);\n\t\t\treturn !full_chain ||\n\t\t\t    x509_verify_cert_self_signed(cert);\n\t\t}\n\t} else {\n\t\t/* Check the provided roots */\n\t\tfor (i = 0; i < sk_X509_num(ctx->roots); i++) {\n\t\t\tif (X509_cmp(sk_X509_value(ctx->roots, i), cert) == 0)\n\t\t\t\treturn !full_chain ||\n\t\t\t\t    x509_verify_cert_self_signed(cert);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nx509_verify_ctx_set_xsc_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, int set_error, int is_trusted)\n{\n\tsize_t num_untrusted;\n\tint i;\n\n\tif (ctx->xsc == NULL)\n\t\treturn 1;\n\n\t/*\n\t * XXX num_untrusted is the number of untrusted certs at the\n\t * bottom of the chain. This works now since we stop at the first\n\t * trusted cert. This will need fixing once we allow more than one\n\t * trusted certificate.\n\t */\n\tnum_untrusted = sk_X509_num(chain->certs);\n\tif (is_trusted && num_untrusted > 0)\n\t\tnum_untrusted--;\n\tctx->xsc->num_untrusted = num_untrusted;\n\n\tsk_X509_pop_free(ctx->xsc->chain, X509_free);\n\tctx->xsc->chain = X509_chain_up_ref(chain->certs);\n\tif (ctx->xsc->chain == NULL)\n\t\treturn x509_verify_cert_error(ctx, NULL, 0,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\n\tif (set_error) {\n\t\tctx->xsc->error = X509_V_OK;\n\t\tctx->xsc->error_depth = 0;\n\t\tfor (i = 0; i < sk_X509_num(chain->certs); i++) {\n\t\t\tif (chain->cert_errors[i] != X509_V_OK) {\n\t\t\t\tctx->xsc->error = chain->cert_errors[i];\n\t\t\t\tctx->xsc->error_depth = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\n/*\n * Save the error state and unvalidated chain off of the xsc for\n * later.\n */\nstatic int\nx509_verify_ctx_save_xsc_error(struct x509_verify_ctx *ctx)\n{\n\tif (ctx->xsc != NULL && ctx->xsc->chain != NULL) {\n\t\tsk_X509_pop_free(ctx->saved_error_chain, X509_free);\n\t\tctx->saved_error_chain = X509_chain_up_ref(ctx->xsc->chain);\n\t\tif (ctx->saved_error_chain == NULL)\n\t\t\treturn x509_verify_cert_error(ctx, NULL, 0,\n\t\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t\tctx->saved_error = ctx->xsc->error;\n\t\tctx->saved_error_depth = ctx->xsc->error_depth;\n\t}\n\treturn 1;\n}\n\n/*\n * Restore the saved error state and unvalidated chain to the xsc\n * if we do not have a validated chain.\n */\nstatic int\nx509_verify_ctx_restore_xsc_error(struct x509_verify_ctx *ctx)\n{\n\tif (ctx->xsc != NULL && ctx->chains_count == 0 &&\n\t    ctx->saved_error_chain != NULL) {\n\t\tsk_X509_pop_free(ctx->xsc->chain, X509_free);\n\t\tctx->xsc->chain = X509_chain_up_ref(ctx->saved_error_chain);\n\t\tif (ctx->xsc->chain == NULL)\n\t\t\treturn x509_verify_cert_error(ctx, NULL, 0,\n\t\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t\tctx->xsc->error = ctx->saved_error;\n\t\tctx->xsc->error_depth = ctx->saved_error_depth;\n\t}\n\treturn 1;\n}\n\n/* Perform legacy style validation of a chain */\nstatic int\nx509_verify_ctx_validate_legacy_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, size_t depth)\n{\n\tint ret = 0, trust;\n\n\tif (ctx->xsc == NULL)\n\t\treturn 1;\n\n\t/*\n\t * If we have a legacy xsc, choose a validated chain, and\n\t * apply the extensions, revocation, and policy checks just\n\t * like the legacy code did. We do this here instead of as\n\t * building the chains to more easily support the callback and\n\t * the bewildering array of VERIFY_PARAM knobs that are there\n\t * for the fiddling.\n\t */\n\n\t/* These may be set in one of the following calls. */\n\tctx->xsc->error = X509_V_OK;\n\tctx->xsc->error_depth = 0;\n\n\ttrust = x509_vfy_check_trust(ctx->xsc);\n\tif (trust == X509_TRUST_REJECTED)\n\t\tgoto err;\n\n\tif (!x509_verify_ctx_set_xsc_chain(ctx, chain, 0, 1))\n\t\tgoto err;\n\n\t/*\n\t * XXX currently this duplicates some work done in chain\n\t * build, but we keep it here until we have feature parity\n\t */\n\tif (!x509_vfy_check_chain_extensions(ctx->xsc))\n\t\tgoto err;\n\n#ifndef OPENSSL_NO_RFC3779\n\tif (!X509v3_asid_validate_path(ctx->xsc))\n\t\tgoto err;\n\n\tif (!X509v3_addr_validate_path(ctx->xsc))\n\t\tgoto err;\n#endif\n\n\tif (!x509_constraints_chain(ctx->xsc->chain,\n\t\t&ctx->xsc->error, &ctx->xsc->error_depth)) {\n\t\tX509 *cert = sk_X509_value(ctx->xsc->chain, depth);\n\t\tif (!x509_verify_cert_error(ctx, cert,\n\t\t\tctx->xsc->error_depth, ctx->xsc->error, 0))\n\t\t\tgoto err;\n\t}\n\n\tif (!x509_vfy_check_revocation(ctx->xsc))\n\t\tgoto err;\n\n\tif (!x509_vfy_check_policy(ctx->xsc))\n\t\tgoto err;\n\n\tif ((!(ctx->xsc->param->flags & X509_V_FLAG_PARTIAL_CHAIN)) &&\n\t    trust != X509_TRUST_TRUSTED)\n\t\tgoto err;\n\n\tret = 1;\n\n err:\n\t/*\n\t * The above checks may have set ctx->xsc->error and\n\t * ctx->xsc->error_depth - save these for later on.\n\t */\n\tif (ctx->xsc->error != X509_V_OK) {\n\t\tif (ctx->xsc->error_depth < 0 ||\n\t\t    ctx->xsc->error_depth >= X509_VERIFY_MAX_CHAIN_CERTS)\n\t\t\treturn 0;\n\t\tchain->cert_errors[ctx->xsc->error_depth] =\n\t\t    ctx->xsc->error;\n\t\tctx->error_depth = ctx->xsc->error_depth;\n\t}\n\n\treturn ret;\n}\n\n/* Add a validated chain to our list of valid chains */\nstatic int\nx509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\n\t/* Clear a get issuer failure for a root certificate. */\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\n\t/*\n\t * In the non-legacy code, extensions and purpose are dealt\n\t * with as the chain is built.\n\t *\n\t * The non-legacy api returns multiple chains but does not do\n\t * any revocation checking (it must be done by the caller on\n\t * any chain they wish to use)\n\t */\n\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\tctx->chains_count++;\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\treturn 1;\n}\n\nstatic int\nx509_verify_potential_parent(struct x509_verify_ctx *ctx, X509 *parent,\n    X509 *child)\n{\n\tif (!x509_verify_cert_cache_extensions(parent))\n\t\treturn 0;\n\tif (ctx->xsc != NULL)\n\t\treturn (ctx->xsc->check_issued(ctx->xsc, child, parent));\n\n\t/* XXX key usage */\n\treturn X509_check_issued(child, parent) != X509_V_OK;\n}\n\nstatic int\nx509_verify_parent_signature(X509 *parent, X509 *child, int *error)\n{\n\tEVP_PKEY *pkey;\n\tint cached;\n\tint ret = 0;\n\n\t/* Use cached value if we have it */\n\tif ((cached = x509_issuer_cache_find(parent->hash, child->hash)) >= 0)\n\t\treturn cached;\n\n\t/* Check signature. Did parent sign child? */\n\tif ((pkey = X509_get_pubkey(parent)) == NULL) {\n\t\t*error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\n\t\treturn 0;\n\t}\n\tif (X509_verify(child, pkey) <= 0)\n\t\t*error = X509_V_ERR_CERT_SIGNATURE_FAILURE;\n\telse\n\t\tret = 1;\n\n\t/* Add result to cache */\n\tx509_issuer_cache_add(parent->hash, child->hash, ret);\n\n\tEVP_PKEY_free(pkey);\n\n\treturn ret;\n}\n\nstatic int\nx509_verify_consider_candidate(struct x509_verify_ctx *ctx, X509 *cert,\n    int is_root_cert, X509 *candidate, struct x509_verify_chain *current_chain,\n    int full_chain)\n{\n\tint depth = sk_X509_num(current_chain->certs);\n\tstruct x509_verify_chain *new_chain;\n\tint i;\n\n\t/* Fail if the certificate is already in the chain */\n\tfor (i = 0; i < sk_X509_num(current_chain->certs); i++) {\n\t\tif (X509_cmp(sk_X509_value(current_chain->certs, i),\n\t\t    candidate) == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx->sig_checks++ > X509_VERIFY_MAX_SIGCHECKS) {\n\t\t/* don't allow callback to override safety check */\n\t\t(void) x509_verify_cert_error(ctx, candidate, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\t\treturn 0;\n\t}\n\n\tif (!x509_verify_parent_signature(candidate, cert, &ctx->error)) {\n\t\tif (!x509_verify_cert_error(ctx, candidate, depth,\n\t\t    ctx->error, 0))\n\t\t\treturn 0;\n\t}\n\n\tif (!x509_verify_cert_valid(ctx, candidate, current_chain))\n\t\treturn 0;\n\n\t/* candidate is good, add it to a copy of the current chain */\n\tif ((new_chain = x509_verify_chain_dup(current_chain)) == NULL) {\n\t\tx509_verify_cert_error(ctx, candidate, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t\treturn 0;\n\t}\n\tif (!x509_verify_chain_append(new_chain, candidate, &ctx->error)) {\n\t\tx509_verify_cert_error(ctx, candidate, depth, ctx->error, 0);\n\t\tx509_verify_chain_free(new_chain);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If candidate is a trusted root, we have a validated chain,\n\t * so we save it.  Otherwise, recurse until we find a root or\n\t * give up.\n\t */\n\tif (is_root_cert) {\n\t\tif (!x509_verify_ctx_set_xsc_chain(ctx, new_chain, 0, 1)) {\n\t\t\tx509_verify_chain_free(new_chain);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!x509_verify_ctx_add_chain(ctx, new_chain)) {\n\t\t\tx509_verify_chain_free(new_chain);\n\t\t\treturn 0;\n\t\t}\n\t\tgoto done;\n\t}\n\n\tx509_verify_build_chains(ctx, candidate, new_chain, full_chain);\n\n done:\n\tx509_verify_chain_free(new_chain);\n\treturn 1;\n}\n\nstatic int\nx509_verify_cert_error(struct x509_verify_ctx *ctx, X509 *cert, size_t depth,\n    int error, int ok)\n{\n\tctx->error = error;\n\tctx->error_depth = depth;\n\tif (ctx->xsc != NULL) {\n\t\tctx->xsc->error = error;\n\t\tctx->xsc->error_depth = depth;\n\t\tctx->xsc->current_cert = cert;\n\t\treturn ctx->xsc->verify_cb(ok, ctx->xsc);\n\t}\n\treturn ok;\n}\n\nstatic void\nx509_verify_build_chains(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain, int full_chain)\n{\n\tX509 *candidate;\n\tint i, depth, count, ret, is_root;\n\n\t/*\n\t * If we are finding chains with an xsc, just stop after we have\n\t * one chain, there's no point in finding more, it just exercises\n\t * the potentially buggy callback processing in the calling software.\n\t */\n\tif (ctx->xsc != NULL && ctx->chains_count > 0)\n\t\treturn;\n\n\tdepth = sk_X509_num(current_chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\n\tif (depth >= ctx->max_depth &&\n\t    !x509_verify_cert_error(ctx, cert, depth,\n\t\tX509_V_ERR_CERT_CHAIN_TOO_LONG, 0))\n\t\treturn;\n\n\tcount = ctx->chains_count;\n\n\tctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n\tctx->error_depth = depth;\n\n\tif (ctx->saved_error != 0)\n\t\tctx->error = ctx->saved_error;\n\tif (ctx->saved_error_depth != 0)\n\t\tctx->error_depth = ctx->saved_error_depth;\n\n\tif (ctx->xsc != NULL) {\n\t\t/*\n\t\t * Long ago experiments at Muppet labs resulted in a\n\t\t * situation where software not only sees these errors\n\t\t * but forced developers to expect them in certain cases.\n\t\t * so we must mimic this awfulness for the legacy case.\n\t\t */\n\t\tif (cert->ex_flags & EXFLAG_SS)\n\t\t\tctx->error = (depth == 0) ?\n\t\t\t    X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n\t\t\t    X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n\t}\n\n\t/* Check for legacy mode roots */\n\tif (ctx->xsc != NULL) {\n\t\tif ((ret = ctx->xsc->get_issuer(&candidate, ctx->xsc, cert)) < 0) {\n\t\t\tx509_verify_cert_error(ctx, cert, depth,\n\t\t\t    X509_V_ERR_STORE_LOOKUP, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (x509_verify_potential_parent(ctx, candidate, cert)) {\n\t\t\t\tis_root = !full_chain ||\n\t\t\t\t    x509_verify_cert_self_signed(candidate);\n\t\t\t\tx509_verify_consider_candidate(ctx, cert,\n\t\t\t\t    is_root, candidate, current_chain,\n\t\t\t\t    full_chain);\n\t\t\t}\n\t\t\tX509_free(candidate);\n\t\t}\n\t} else {\n\t\t/* Check to see if we have a trusted root issuer. */\n\t\tfor (i = 0; i < sk_X509_num(ctx->roots); i++) {\n\t\t\tcandidate = sk_X509_value(ctx->roots, i);\n\t\t\tif (x509_verify_potential_parent(ctx, candidate, cert)) {\n\t\t\t\tis_root = !full_chain ||\n\t\t\t\t    x509_verify_cert_self_signed(candidate);\n\t\t\t\tx509_verify_consider_candidate(ctx, cert,\n\t\t\t\t    is_root, candidate, current_chain,\n\t\t\t\t    full_chain);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check intermediates after checking roots */\n\tif (ctx->intermediates != NULL) {\n\t\tfor (i = 0; i < sk_X509_num(ctx->intermediates); i++) {\n\t\t\tcandidate = sk_X509_value(ctx->intermediates, i);\n\t\t\tif (x509_verify_potential_parent(ctx, candidate, cert)) {\n\t\t\t\tx509_verify_consider_candidate(ctx, cert,\n\t\t\t\t    0, candidate, current_chain,\n\t\t\t\t    full_chain);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctx->chains_count > count) {\n\t\tif (ctx->xsc != NULL) {\n\t\t\tctx->xsc->error = X509_V_OK;\n\t\t\tctx->xsc->error_depth = depth;\n\t\t\tctx->xsc->current_cert = cert;\n\t\t}\n\t} else if (ctx->error_depth == depth) {\n\t\tif (!x509_verify_ctx_set_xsc_chain(ctx, current_chain, 0, 0))\n\t\t\treturn;\n\t}\n}\n\nstatic int\nx509_verify_cert_hostname(struct x509_verify_ctx *ctx, X509 *cert, char *name)\n{\n\tchar *candidate;\n\tsize_t len;\n\n\tif (name == NULL) {\n\t\tif (ctx->xsc != NULL) {\n\t\t\tint ret;\n\n\t\t\tif ((ret = x509_vfy_check_id(ctx->xsc)) == 0)\n\t\t\t\tctx->error = ctx->xsc->error;\n\t\t\treturn ret;\n\t\t}\n\t\treturn 1;\n\t}\n\tif ((candidate = strdup(name)) == NULL) {\n\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\tgoto err;\n\t}\n\tif ((len = strlen(candidate)) < 1) {\n\t\tctx->error = X509_V_ERR_UNSPECIFIED; /* XXX */\n\t\tgoto err;\n\t}\n\n\t/* IP addresses may be written in [ ]. */\n\tif (candidate[0] == '[' && candidate[len - 1] == ']') {\n\t\tcandidate[len - 1] = '\\0';\n\t\tif (X509_check_ip_asc(cert, candidate + 1, 0) <= 0) {\n\t\t\tctx->error = X509_V_ERR_IP_ADDRESS_MISMATCH;\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tint flags = 0;\n\n\t\tif (ctx->xsc == NULL)\n\t\t\tflags = X509_CHECK_FLAG_NEVER_CHECK_SUBJECT;\n\n\t\tif (X509_check_host(cert, candidate, len, flags, NULL) <= 0) {\n\t\t\tctx->error = X509_V_ERR_HOSTNAME_MISMATCH;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfree(candidate);\n\treturn 1;\n err:\n\tfree(candidate);\n\treturn x509_verify_cert_error(ctx, cert, 0, ctx->error, 0);\n}\n\nstatic int\nx509_verify_set_check_time(struct x509_verify_ctx *ctx)\n{\n\tif (ctx->xsc != NULL)  {\n\t\tif (ctx->xsc->param->flags & X509_V_FLAG_USE_CHECK_TIME) {\n\t\t\tctx->check_time = &ctx->xsc->param->check_time;\n\t\t\treturn 1;\n\t\t}\n\t\tif (ctx->xsc->param->flags & X509_V_FLAG_NO_CHECK_TIME)\n\t\t\treturn 0;\n\t}\n\n\tctx->check_time = NULL;\n\treturn 1;\n}\n\nstatic int\nx509_verify_cert_times(X509 *cert, time_t *cmp_time, int *error)\n{\n\ttime_t when;\n\n\tif (cmp_time == NULL)\n\t\twhen = time(NULL);\n\telse\n\t\twhen = *cmp_time;\n\n\tif (cert->not_before == -1) {\n\t\t*error = X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;\n\t\treturn 0;\n\t}\n\tif (when < cert->not_before) {\n\t\t*error = X509_V_ERR_CERT_NOT_YET_VALID;\n\t\treturn 0;\n\t}\n\tif (cert->not_after == -1) {\n\t\t*error = X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;\n\t\treturn 0;\n\t}\n\tif (when > cert->not_after) {\n\t\t*error = X509_V_ERR_CERT_HAS_EXPIRED;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nx509_verify_validate_constraints(X509 *cert,\n    struct x509_verify_chain *current_chain, int *error)\n{\n\tstruct x509_constraints_names *excluded = NULL;\n\tstruct x509_constraints_names *permitted = NULL;\n\tint err = X509_V_ERR_UNSPECIFIED;\n\n\tif (current_chain == NULL)\n\t\treturn 1;\n\n\tif (cert->nc != NULL) {\n\t\tif ((permitted = x509_constraints_names_new(\n\t\t    X509_VERIFY_MAX_CHAIN_CONSTRAINTS)) == NULL) {\n\t\t\terr = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif ((excluded = x509_constraints_names_new(\n\t\t    X509_VERIFY_MAX_CHAIN_CONSTRAINTS)) == NULL) {\n\t\t\terr = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (!x509_constraints_extract_constraints(cert,\n\t\t    permitted, excluded, &err))\n\t\t\tgoto err;\n\t\tif (!x509_constraints_check(current_chain->names,\n\t\t    permitted, excluded, &err))\n\t\t\tgoto err;\n\t\tx509_constraints_names_free(excluded);\n\t\tx509_constraints_names_free(permitted);\n\t}\n\n\treturn 1;\n err:\n\t*error = err;\n\tx509_constraints_names_free(excluded);\n\tx509_constraints_names_free(permitted);\n\treturn 0;\n}\n\nstatic int\nx509_verify_cert_extensions(struct x509_verify_ctx *ctx, X509 *cert, int need_ca)\n{\n\tif (!x509_verify_cert_cache_extensions(cert)) {\n\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\t\treturn 0;\n\t}\n\n\tif (ctx->xsc != NULL)\n\t\treturn 1;\t/* legacy is checked after chain is built */\n\n\tif (cert->ex_flags & EXFLAG_CRITICAL) {\n\t\tctx->error = X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;\n\t\treturn 0;\n\t}\n\t/* No we don't care about v1, netscape, and other ancient silliness */\n\tif (need_ca && (!(cert->ex_flags & EXFLAG_BCONS) &&\n\t    (cert->ex_flags & EXFLAG_CA))) {\n\t\tctx->error = X509_V_ERR_INVALID_CA;\n\t\treturn 0;\n\t}\n\tif (ctx->purpose > 0 && X509_check_purpose(cert, ctx->purpose, need_ca)) {\n\t\tctx->error = X509_V_ERR_INVALID_PURPOSE;\n\t\treturn 0;\n\t}\n\n\t/* XXX support proxy certs later in new api */\n\tif (ctx->xsc == NULL && cert->ex_flags & EXFLAG_PROXY) {\n\t\tctx->error = X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/* Validate that cert is a possible candidate to append to current_chain */\nstatic int\nx509_verify_cert_valid(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain)\n{\n\tX509 *issuer_candidate;\n\tint should_be_ca = current_chain != NULL;\n\tsize_t depth = 0;\n\n\tif (current_chain != NULL)\n\t\tdepth = sk_X509_num(current_chain->certs);\n\n\tif (!x509_verify_cert_extensions(ctx, cert, should_be_ca))\n\t\treturn 0;\n\n\tif (should_be_ca) {\n\t\tissuer_candidate = x509_verify_chain_last(current_chain);\n\t\tif (issuer_candidate != NULL &&\n\t\t    !X509_check_issued(issuer_candidate, cert))\n\t\t\tif (!x509_verify_cert_error(ctx, cert, depth,\n\t\t\t    X509_V_ERR_SUBJECT_ISSUER_MISMATCH, 0))\n\t\t\t\treturn 0;\n\t}\n\n\tif (x509_verify_set_check_time(ctx)) {\n\t\tif (!x509_verify_cert_times(cert, ctx->check_time,\n\t\t    &ctx->error)) {\n\t\t\tif (!x509_verify_cert_error(ctx, cert, depth,\n\t\t\t    ctx->error, 0))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!x509_verify_validate_constraints(cert, current_chain,\n\t    &ctx->error) && !x509_verify_cert_error(ctx, cert, depth,\n\t    ctx->error, 0))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstruct x509_verify_ctx *\nx509_verify_ctx_new_from_xsc(X509_STORE_CTX *xsc)\n{\n\tstruct x509_verify_ctx *ctx;\n\tsize_t max_depth;\n\n\tif (xsc == NULL)\n\t\treturn NULL;\n\n\tif ((ctx = x509_verify_ctx_new(NULL)) == NULL)\n\t\treturn NULL;\n\n\tctx->xsc = xsc;\n\n\tif (xsc->untrusted &&\n\t    (ctx->intermediates = X509_chain_up_ref(xsc->untrusted)) == NULL)\n\t\tgoto err;\n\n\tmax_depth = X509_VERIFY_MAX_CHAIN_CERTS;\n\tif (xsc->param->depth > 0 && xsc->param->depth < X509_VERIFY_MAX_CHAIN_CERTS)\n\t\tmax_depth = xsc->param->depth;\n\tif (!x509_verify_ctx_set_max_depth(ctx, max_depth))\n\t\tgoto err;\n\n\treturn ctx;\n err:\n\tx509_verify_ctx_free(ctx);\n\treturn NULL;\n}\n\n/* Public API */\n\nstruct x509_verify_ctx *\nx509_verify_ctx_new(STACK_OF(X509) *roots)\n{\n\tstruct x509_verify_ctx *ctx;\n\n\tif ((ctx = calloc(1, sizeof(struct x509_verify_ctx))) == NULL)\n\t\treturn NULL;\n\n\tif (roots != NULL) {\n\t\tif  ((ctx->roots = X509_chain_up_ref(roots)) == NULL)\n\t\t\tgoto err;\n\t} else {\n\t\tif ((ctx->roots = sk_X509_new_null()) == NULL)\n\t\t\tgoto err;\n\t}\n\n\tctx->max_depth = X509_VERIFY_MAX_CHAIN_CERTS;\n\tctx->max_chains = X509_VERIFY_MAX_CHAINS;\n\tctx->max_sigs = X509_VERIFY_MAX_SIGCHECKS;\n\n\tif ((ctx->chains = calloc(X509_VERIFY_MAX_CHAINS,\n\t    sizeof(*ctx->chains))) == NULL)\n\t\tgoto err;\n\n\treturn ctx;\n err:\n\tx509_verify_ctx_free(ctx);\n\treturn NULL;\n}\n\nvoid\nx509_verify_ctx_free(struct x509_verify_ctx *ctx)\n{\n\tif (ctx == NULL)\n\t\treturn;\n\tsk_X509_pop_free(ctx->roots, X509_free);\n\tx509_verify_ctx_clear(ctx);\n\tfree(ctx);\n}\n\nint\nx509_verify_ctx_set_max_depth(struct x509_verify_ctx *ctx, size_t max)\n{\n\tif (max < 1 || max > X509_VERIFY_MAX_CHAIN_CERTS)\n\t\treturn 0;\n\tctx->max_depth = max;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_max_chains(struct x509_verify_ctx *ctx, size_t max)\n{\n\tif (max < 1 || max > X509_VERIFY_MAX_CHAINS)\n\t\treturn 0;\n\tctx->max_chains = max;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_max_signatures(struct x509_verify_ctx *ctx, size_t max)\n{\n\tif (max < 1 || max > 100000)\n\t\treturn 0;\n\tctx->max_sigs = max;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_purpose(struct x509_verify_ctx *ctx, int purpose)\n{\n\tif (purpose < X509_PURPOSE_MIN || purpose > X509_PURPOSE_MAX)\n\t\treturn 0;\n\tctx->purpose = purpose;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_intermediates(struct x509_verify_ctx *ctx,\n    STACK_OF(X509) *intermediates)\n{\n\tif ((ctx->intermediates = X509_chain_up_ref(intermediates)) == NULL)\n\t\treturn 0;\n\treturn 1;\n}\n\nconst char *\nx509_verify_ctx_error_string(struct x509_verify_ctx *ctx)\n{\n\treturn X509_verify_cert_error_string(ctx->error);\n}\n\nsize_t\nx509_verify_ctx_error_depth(struct x509_verify_ctx *ctx)\n{\n\treturn ctx->error_depth;\n}\n\nSTACK_OF(X509) *\nx509_verify_ctx_chain(struct x509_verify_ctx *ctx, size_t i)\n{\n\tif (i >= ctx->chains_count)\n\t\treturn NULL;\n\treturn ctx->chains[i]->certs;\n}\n\nsize_t\nx509_verify(struct x509_verify_ctx *ctx, X509 *leaf, char *name)\n{\n\tstruct x509_verify_chain *current_chain;\n\tint retry_chain_build, full_chain = 0;\n\n\tif (ctx->roots == NULL || ctx->max_depth == 0) {\n\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\tgoto err;\n\t}\n\n\tif (ctx->xsc != NULL) {\n\t\tif (leaf != NULL || name != NULL) {\n\t\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\t\tgoto err;\n\t\t}\n\t\tleaf = ctx->xsc->cert;\n\n\t\t/* XXX */\n\t\tfull_chain = 1;\n\t\tif (ctx->xsc->param->flags & X509_V_FLAG_PARTIAL_CHAIN)\n\t\t\tfull_chain = 0;\n\t\t/*\n\t\t * XXX\n\t\t * The legacy code expects the top level cert to be\n\t\t * there, even if we didn't find a chain. So put it\n\t\t * there, we will clobber it later if we find a valid\n\t\t * chain.\n\t\t */\n\t\tif ((ctx->xsc->chain = sk_X509_new_null()) == NULL) {\n\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (!X509_up_ref(leaf)) {\n\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (!sk_X509_push(ctx->xsc->chain, leaf)) {\n\t\t\tX509_free(leaf);\n\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tctx->xsc->error_depth = 0;\n\t\tctx->xsc->current_cert = leaf;\n\t}\n\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\tgoto err;\n\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\tgoto err;\n\n\tif ((current_chain = x509_verify_chain_new()) == NULL) {\n\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\tgoto err;\n\t}\n\tif (!x509_verify_chain_append(current_chain, leaf, &ctx->error)) {\n\t\tx509_verify_chain_free(current_chain);\n\t\tgoto err;\n\t}\n\tdo {\n\t\tretry_chain_build = 0;\n\t\tif (x509_verify_ctx_cert_is_root(ctx, leaf, full_chain)) {\n\t\t\tif (!x509_verify_ctx_add_chain(ctx, current_chain)) {\n\t\t\t\tx509_verify_chain_free(current_chain);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\tx509_verify_build_chains(ctx, leaf, current_chain,\n\t\t\t    full_chain);\n\t\t\tif (full_chain && ctx->chains_count == 0) {\n\t\t\t\t/*\n\t\t\t\t * Save the error state from the xsc\n\t\t\t\t * at this point to put back on the\n\t\t\t\t * xsc in case we do not find a chain\n\t\t\t\t * that is trusted but not a full\n\t\t\t\t * chain to a self signed root. This\n\t\t\t\t * is because the unvalidated chain is\n\t\t\t\t * used by the autochain batshittery\n\t\t\t\t * on failure and will be needed for\n\t\t\t\t * that.\n\t\t\t\t */\n\t\t\t\tif (!x509_verify_ctx_save_xsc_error(ctx)) {\n\t\t\t\t\tx509_verify_chain_free(current_chain);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tfull_chain = 0;\n\t\t\t\tretry_chain_build = 1;\n\t\t\t}\n\t\t}\n\t} while (retry_chain_build);\n\n\tx509_verify_chain_free(current_chain);\n\n\t/*\n\t * Do the new verifier style return, where we don't have an xsc\n\t * that allows a crazy callback to turn invalid things into valid.\n\t */\n\tif (ctx->xsc == NULL) {\n\t\t/*\n\t\t * Safety net:\n\t\t * We could not find a validated chain, and for some reason do not\n\t\t * have an error set.\n\t\t */\n\t\tif (ctx->chains_count == 0 && ctx->error == X509_V_OK)\n\t\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\n\t\t/*\n\t\t * If we are not using an xsc, and have no possibility for the\n\t\t * crazy OpenSSL callback API changing the results of\n\t\t * validation steps (because the callback can make validation\n\t\t * proceed in the presence of invalid certs), any chains we\n\t\t * have here are correctly built and verified.\n\t\t */\n\t\tif (ctx->chains_count > 0)\n\t\t\tctx->error = X509_V_OK;\n\n\t\treturn ctx->chains_count;\n\t}\n\n\t/*\n\t * Otherwise we are doing compatibility with an xsc, which means that we\n\t * will have one chain, which might actually be a bogus chain because\n\t * the callback told us to ignore errors and proceed to build an invalid\n\t * chain. Possible return values from this include returning 1 with an\n\t * invalid chain and a value of xsc->error != X509_V_OK (It's tradition\n\t * that makes it ok).\n\t */\n\n\tif (ctx->chains_count > 0) {\n\t\t/*\n\t\t * The chain we have using an xsc might not be a verified chain\n\t\t * if the callback perverted things while we built it to ignore\n\t\t * failures and proceed with chain building. We put this chain\n\t\t * and the error associated with it on the xsc.\n\t\t */\n\t\tif (!x509_verify_ctx_set_xsc_chain(ctx, ctx->chains[0], 1, 1))\n\t\t\tgoto err;\n\n\t\t/*\n\t\t * Call the callback for completion up our built\n\t\t * chain. The callback could still tell us to\n\t\t * fail. Since this chain might exist as the result of\n\t\t * callback doing perversions, we could still return\n\t\t * \"success\" with something other than X509_V_OK set\n\t\t * as the error.\n\t\t */\n\t\tif (!x509_vfy_callback_indicate_completion(ctx->xsc))\n\t\t\tgoto err;\n\t} else {\n\t\t/*\n\t\t * We did not find a chain. Bring back the failure\n\t\t * case we wanted to the xsc if we saved one. If we\n\t\t * did not we should have just the leaf on the xsc.\n\t\t */\n\t\tif (!x509_verify_ctx_restore_xsc_error(ctx))\n\t\t\tgoto err;\n\n\t\t/*\n\t\t * Safety net, ensure we have an error set in the\n\t\t * failing case.\n\t\t */\n\t\tif (ctx->xsc->error == X509_V_OK) {\n\t\t\tif (ctx->error == X509_V_OK)\n\t\t\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\t\t\tctx->xsc->error = ctx->error;\n\t\t}\n\n\t\t/*\n\t\t * Let the callback override the return value\n\t\t * at depth 0 if it chooses to\n\t\t */\n\t\treturn ctx->xsc->verify_cb(0, ctx->xsc);\n\t}\n\n\t/* We only ever find one chain in compat mode with an xsc. */\n\treturn 1;\n\n err:\n\tif (ctx->error == X509_V_OK)\n\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\n\tif (ctx->xsc != NULL) {\n\t\tif (ctx->xsc->error == X509_V_OK)\n\t\t\tctx->xsc->error = X509_V_ERR_UNSPECIFIED;\n\t\tctx->error = ctx->xsc->error;\n\t}\n\n\treturn 0;\n}\n\n", "/* $OpenBSD: x509_vfy.c,v 1.98 2021/11/24 05:38:12 beck Exp $ */\n/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n * All rights reserved.\n *\n * This package is an SSL implementation written\n * by Eric Young (eay@cryptsoft.com).\n * The implementation was written so as to conform with Netscapes SSL.\n *\n * This library is free for commercial and non-commercial use as long as\n * the following conditions are aheared to.  The following conditions\n * apply to all code found in this distribution, be it the RC4, RSA,\n * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n * included with this distribution is covered by the same copyright terms\n * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n *\n * Copyright remains Eric Young's, and as such any Copyright notices in\n * the code are not to be removed.\n * If this package is used in a product, Eric Young should be given attribution\n * as the author of the parts of the library used.\n * This can be in the form of a textual message at program startup or\n * in documentation (online or textual) provided with the package.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *    \"This product includes cryptographic software written by\n *     Eric Young (eay@cryptsoft.com)\"\n *    The word 'cryptographic' can be left out if the rouines from the library\n *    being used are not cryptographic related :-).\n * 4. If you include any Windows specific code (or a derivative thereof) from\n *    the apps directory (application code) you must include an acknowledgement:\n *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n *\n * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * The licence and distribution terms for any publically available version or\n * derivative of this code cannot be changed.  i.e. this code cannot simply be\n * copied and put under another distribution licence\n * [including the GNU Public Licence.]\n */\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <openssl/opensslconf.h>\n\n#include <openssl/asn1.h>\n#include <openssl/buffer.h>\n#include <openssl/crypto.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include <openssl/objects.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n#include \"asn1_locl.h\"\n#include \"vpm_int.h\"\n#include \"x509_internal.h\"\n\n/* CRL score values */\n\n/* No unhandled critical extensions */\n\n#define CRL_SCORE_NOCRITICAL\t0x100\n\n/* certificate is within CRL scope */\n\n#define CRL_SCORE_SCOPE\t\t0x080\n\n/* CRL times valid */\n\n#define CRL_SCORE_TIME\t\t0x040\n\n/* Issuer name matches certificate */\n\n#define CRL_SCORE_ISSUER_NAME\t0x020\n\n/* If this score or above CRL is probably valid */\n\n#define CRL_SCORE_VALID (CRL_SCORE_NOCRITICAL|CRL_SCORE_TIME|CRL_SCORE_SCOPE)\n\n/* CRL issuer is certificate issuer */\n\n#define CRL_SCORE_ISSUER_CERT\t0x018\n\n/* CRL issuer is on certificate path */\n\n#define CRL_SCORE_SAME_PATH\t0x008\n\n/* CRL issuer matches CRL AKID */\n\n#define CRL_SCORE_AKID\t\t0x004\n\n/* Have a delta CRL with valid times */\n\n#define CRL_SCORE_TIME_DELTA\t0x002\n\nstatic int null_callback(int ok, X509_STORE_CTX *e);\nstatic int check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer);\nstatic X509 *find_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x,\n    int allow_expired);\nstatic int check_chain_extensions(X509_STORE_CTX *ctx);\nstatic int check_name_constraints(X509_STORE_CTX *ctx);\nstatic int check_trust(X509_STORE_CTX *ctx);\nstatic int check_revocation(X509_STORE_CTX *ctx);\nstatic int check_cert(X509_STORE_CTX *ctx, STACK_OF(X509) *chain, int depth);\nstatic int check_policy(X509_STORE_CTX *ctx);\n\nstatic int get_crl_score(X509_STORE_CTX *ctx, X509 **pissuer,\n    unsigned int *preasons, X509_CRL *crl, X509 *x);\nstatic int get_crl_delta(X509_STORE_CTX *ctx,\n    X509_CRL **pcrl, X509_CRL **pdcrl, X509 *x);\nstatic void get_delta_sk(X509_STORE_CTX *ctx, X509_CRL **dcrl, int *pcrl_score,\n    X509_CRL *base, STACK_OF(X509_CRL) *crls);\nstatic void crl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl, X509 **pissuer,\n    int *pcrl_score);\nstatic int crl_crldp_check(X509 *x, X509_CRL *crl, int crl_score,\n    unsigned int *preasons);\nstatic int check_crl_path(X509_STORE_CTX *ctx, X509 *x);\nstatic int check_crl_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *cert_path,\n    STACK_OF(X509) *crl_path);\nstatic int X509_cmp_time_internal(const ASN1_TIME *ctm, time_t *cmp_time,\n    int clamp_notafter);\n\nstatic int internal_verify(X509_STORE_CTX *ctx);\nstatic int get_issuer_sk(X509 **issuer, X509_STORE_CTX *ctx, X509 *x);\n\nint ASN1_time_tm_clamp_notafter(struct tm *tm);\n\nstatic int\nnull_callback(int ok, X509_STORE_CTX *e)\n{\n\treturn ok;\n}\n\n#if 0\nstatic int\nx509_subject_cmp(X509 **a, X509 **b)\n{\n\treturn X509_subject_name_cmp(*a, *b);\n}\n#endif\n\n/* Return 1 if a certificate is self signed */\nstatic int\ncert_self_signed(X509 *x)\n{\n\tX509_check_purpose(x, -1, 0);\n\tif (x->ex_flags & EXFLAG_SS)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int\ncheck_id_error(X509_STORE_CTX *ctx, int errcode)\n{\n\tctx->error = errcode;\n\tctx->current_cert = ctx->cert;\n\tctx->error_depth = 0;\n\treturn ctx->verify_cb(0, ctx);\n}\n\nstatic int\ncheck_hosts(X509 *x, X509_VERIFY_PARAM_ID *id)\n{\n\tsize_t i, n;\n\tchar *name;\n\n\tn = sk_OPENSSL_STRING_num(id->hosts);\n\tfree(id->peername);\n\tid->peername = NULL;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tname = sk_OPENSSL_STRING_value(id->hosts, i);\n\t\tif (X509_check_host(x, name, strlen(name), id->hostflags,\n\t\t    &id->peername) > 0)\n\t\t\treturn 1;\n\t}\n\treturn n == 0;\n}\n\nstatic int\ncheck_id(X509_STORE_CTX *ctx)\n{\n\tX509_VERIFY_PARAM *vpm = ctx->param;\n\tX509_VERIFY_PARAM_ID *id = vpm->id;\n\tX509 *x = ctx->cert;\n\n\tif (id->hosts && check_hosts(x, id) <= 0) {\n\t\tif (!check_id_error(ctx, X509_V_ERR_HOSTNAME_MISMATCH))\n\t\t\treturn 0;\n\t}\n\tif (id->email != NULL && X509_check_email(x, id->email, id->emaillen, 0)\n\t    <= 0) {\n\t\tif (!check_id_error(ctx, X509_V_ERR_EMAIL_MISMATCH))\n\t\t\treturn 0;\n\t}\n\tif (id->ip != NULL && X509_check_ip(x, id->ip, id->iplen, 0) <= 0) {\n\t\tif (!check_id_error(ctx, X509_V_ERR_IP_ADDRESS_MISMATCH))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint\nx509_vfy_check_id(X509_STORE_CTX *ctx) {\n\treturn check_id(ctx);\n}\n\n/*\n * This is the effectively broken legacy OpenSSL chain builder. It\n * might find an unvalidated chain and leave it sitting in\n * ctx->chain. It does not correctly handle many cases where multiple\n * chains could exist.\n *\n * Oh no.. I know a dirty word...\n * Oooooooh..\n */\nstatic int\nX509_verify_cert_legacy_build_chain(X509_STORE_CTX *ctx, int *bad, int *out_ok)\n{\n\tX509 *x, *xtmp, *xtmp2, *chain_ss = NULL;\n\tint bad_chain = 0;\n\tX509_VERIFY_PARAM *param = ctx->param;\n\tint ok = 0, ret = 0;\n\tint depth, i;\n\tint num, j, retry, trust;\n\tint (*cb) (int xok, X509_STORE_CTX *xctx);\n\tSTACK_OF(X509) *sktmp = NULL;\n\n\tcb = ctx->verify_cb;\n\n\t/*\n\t * First we make sure the chain we are going to build is\n\t * present and that the first entry is in place.\n\t */\n\tctx->chain = sk_X509_new_null();\n\tif (ctx->chain == NULL || !sk_X509_push(ctx->chain, ctx->cert)) {\n\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\tgoto end;\n\t}\n\tX509_up_ref(ctx->cert);\n\tctx->num_untrusted = 1;\n\n\t/* We use a temporary STACK so we can chop and hack at it */\n\tif (ctx->untrusted != NULL &&\n\t    (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {\n\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\tgoto end;\n\t}\n\n\tnum = sk_X509_num(ctx->chain);\n\tx = sk_X509_value(ctx->chain, num - 1);\n\tdepth = param->depth;\n\n\tfor (;;) {\n\t\t/* If we have enough, we break */\n\t\t/* FIXME: If this happens, we should take\n\t\t * note of it and, if appropriate, use the\n\t\t * X509_V_ERR_CERT_CHAIN_TOO_LONG error code\n\t\t * later.\n\t\t */\n\t\tif (depth < num)\n\t\t\tbreak;\n\t\t/* If we are self signed, we break */\n\t\tif (cert_self_signed(x))\n\t\t\tbreak;\n\t\t/*\n\t\t * If asked see if we can find issuer in trusted store first\n\t\t */\n\t\tif (ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) {\n\t\t\tok = ctx->get_issuer(&xtmp, ctx, x);\n\t\t\tif (ok < 0) {\n\t\t\t\tctx->error = X509_V_ERR_STORE_LOOKUP;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If successful for now free up cert so it\n\t\t\t * will be picked up again later.\n\t\t\t */\n\t\t\tif (ok > 0) {\n\t\t\t\tX509_free(xtmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* If we were passed a cert chain, use it first */\n\t\tif (ctx->untrusted != NULL) {\n\t\t\t/*\n\t\t\t * If we do not find a non-expired untrusted cert, peek\n\t\t\t * ahead and see if we can satisify this from the trusted\n\t\t\t * store. If not, see if we have an expired untrusted cert.\n\t\t\t */\n\t\t\txtmp = find_issuer(ctx, sktmp, x, 0);\n\t\t\tif (xtmp == NULL &&\n\t\t\t    !(ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST)) {\n\t\t\t\tok = ctx->get_issuer(&xtmp, ctx, x);\n\t\t\t\tif (ok < 0) {\n\t\t\t\t\tctx->error = X509_V_ERR_STORE_LOOKUP;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tif (ok > 0) {\n\t\t\t\t\tX509_free(xtmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\txtmp = find_issuer(ctx, sktmp, x, 1);\n\t\t\t}\n\t\t\tif (xtmp != NULL) {\n\t\t\t\tif (!sk_X509_push(ctx->chain, xtmp)) {\n\t\t\t\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\t\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\t\t\tok = 0;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tX509_up_ref(xtmp);\n\t\t\t\t(void)sk_X509_delete_ptr(sktmp, xtmp);\n\t\t\t\tctx->num_untrusted++;\n\t\t\t\tx = xtmp;\n\t\t\t\tnum++;\n\t\t\t\t/*\n\t\t\t\t * reparse the full chain for the next one\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t/* Remember how many untrusted certs we have */\n\tj = num;\n\n\t/*\n\t * At this point, chain should contain a list of untrusted\n\t * certificates.  We now need to add at least one trusted one,\n\t * if possible, otherwise we complain.\n\t */\n\n\tdo {\n\t\t/*\n\t\t * Examine last certificate in chain and see if it is\n\t\t * self signed.\n\t\t */\n\t\ti = sk_X509_num(ctx->chain);\n\t\tx = sk_X509_value(ctx->chain, i - 1);\n\t\tif (cert_self_signed(x)) {\n\t\t\t/* we have a self signed certificate */\n\t\t\tif (i == 1) {\n\t\t\t\t/*\n\t\t\t\t * We have a single self signed\n\t\t\t\t * certificate: see if we can find it\n\t\t\t\t * in the store. We must have an exact\n\t\t\t\t * match to avoid possible\n\t\t\t\t * impersonation.\n\t\t\t\t */\n\t\t\t\tok = ctx->get_issuer(&xtmp, ctx, x);\n\t\t\t\tif ((ok <= 0) || X509_cmp(x, xtmp)) {\n\t\t\t\t\tctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\n\t\t\t\t\tctx->current_cert = x;\n\t\t\t\t\tctx->error_depth = i - 1;\n\t\t\t\t\tif (ok == 1)\n\t\t\t\t\t\tX509_free(xtmp);\n\t\t\t\t\tbad_chain = 1;\n\t\t\t\t\tok = cb(0, ctx);\n\t\t\t\t\tif (!ok)\n\t\t\t\t\t\tgoto end;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a match: replace\n\t\t\t\t\t * certificate with store\n\t\t\t\t\t * version so we get any trust\n\t\t\t\t\t * settings.\n\t\t\t\t\t */\n\t\t\t\t\tX509_free(x);\n\t\t\t\t\tx = xtmp;\n\t\t\t\t\t(void)sk_X509_set(ctx->chain, i - 1, x);\n\t\t\t\t\tctx->num_untrusted = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * extract and save self signed\n\t\t\t\t * certificate for later use\n\t\t\t\t */\n\t\t\t\tchain_ss = sk_X509_pop(ctx->chain);\n\t\t\t\tctx->num_untrusted--;\n\t\t\t\tnum--;\n\t\t\t\tj--;\n\t\t\t\tx = sk_X509_value(ctx->chain, num - 1);\n\t\t\t}\n\t\t}\n\t\t/* We now lookup certs from the certificate store */\n\t\tfor (;;) {\n\t\t\t/* If we have enough, we break */\n\t\t\tif (depth < num)\n\t\t\t\tbreak;\n\t\t\t/* If we are self signed, we break */\n\t\t\tif (cert_self_signed(x))\n\t\t\t\tbreak;\n\t\t\tok = ctx->get_issuer(&xtmp, ctx, x);\n\n\t\t\tif (ok < 0) {\n\t\t\t\tctx->error = X509_V_ERR_STORE_LOOKUP;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif (ok == 0)\n\t\t\t\tbreak;\n\t\t\tx = xtmp;\n\t\t\tif (!sk_X509_push(ctx->chain, x)) {\n\t\t\t\tX509_free(xtmp);\n\t\t\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\t\tok = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tnum++;\n\t\t}\n\n\t\t/* we now have our chain, lets check it... */\n\t\ttrust = check_trust(ctx);\n\n\t\t/* If explicitly rejected error */\n\t\tif (trust == X509_TRUST_REJECTED) {\n\t\t\tok = 0;\n\t\t\tgoto end;\n\t\t}\n\t\t/*\n\t\t * If it's not explicitly trusted then check if there\n\t\t * is an alternative chain that could be used. We only\n\t\t * do this if we haven't already checked via\n\t\t * TRUSTED_FIRST and the user hasn't switched off\n\t\t * alternate chain checking\n\t\t */\n\t\tretry = 0;\n\t\tif (trust != X509_TRUST_TRUSTED &&\n\t\t    !(ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) &&\n\t\t    !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {\n\t\t\twhile (j-- > 1) {\n\t\t\t\txtmp2 = sk_X509_value(ctx->chain, j - 1);\n\t\t\t\tok = ctx->get_issuer(&xtmp, ctx, xtmp2);\n\t\t\t\tif (ok < 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t/* Check if we found an alternate chain */\n\t\t\t\tif (ok > 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Free up the found cert\n\t\t\t\t\t * we'll add it again later\n\t\t\t\t\t */\n\t\t\t\t\tX509_free(xtmp);\n\t\t\t\t\t/*\n\t\t\t\t\t * Dump all the certs above\n\t\t\t\t\t * this point - we've found an\n\t\t\t\t\t * alternate chain\n\t\t\t\t\t */\n\t\t\t\t\twhile (num > j) {\n\t\t\t\t\t\txtmp = sk_X509_pop(ctx->chain);\n\t\t\t\t\t\tX509_free(xtmp);\n\t\t\t\t\t\tnum--;\n\t\t\t\t\t}\n\t\t\t\t\tctx->num_untrusted = sk_X509_num(ctx->chain);\n\t\t\t\t\tretry = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (retry);\n\n\t/*\n\t * If not explicitly trusted then indicate error unless it's a single\n\t * self signed certificate in which case we've indicated an error already\n\t * and set bad_chain == 1\n\t */\n\tif (trust != X509_TRUST_TRUSTED && !bad_chain) {\n\t\tif ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {\n\t\t\tif (ctx->num_untrusted >= num)\n\t\t\t\tctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n\t\t\telse\n\t\t\t\tctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\n\t\t\tctx->current_cert = x;\n\t\t} else {\n\t\t\tif (!sk_X509_push(ctx->chain, chain_ss)) {\n\t\t\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\t\tok = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tnum++;\n\t\t\tctx->num_untrusted = num;\n\t\t\tctx->current_cert = chain_ss;\n\t\t\tctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n\t\t\tchain_ss = NULL;\n\t\t}\n\n\t\tctx->error_depth = num - 1;\n\t\tbad_chain = 1;\n\t\tok = cb(0, ctx);\n\t\tif (!ok)\n\t\t\tgoto end;\n\t}\n\n\tret = 1;\n end:\n\tsk_X509_free(sktmp);\n\tX509_free(chain_ss);\n\t*bad = bad_chain;\n\t*out_ok = ok;\n\n\treturn ret;\n}\n\nstatic int\nX509_verify_cert_legacy(X509_STORE_CTX *ctx)\n{\n\tint ok = 0, bad_chain;\n\n\tctx->error = X509_V_OK; /* Initialize to OK */\n\n\tif (!X509_verify_cert_legacy_build_chain(ctx, &bad_chain, &ok))\n\t\tgoto end;\n\n\t/* We have the chain complete: now we need to check its purpose */\n\tok = check_chain_extensions(ctx);\n\tif (!ok)\n\t\tgoto end;\n\n\t/* Check name constraints */\n\tok = check_name_constraints(ctx);\n\tif (!ok)\n\t\tgoto end;\n\n#ifndef OPENSSL_NO_RFC3779\n\tok = X509v3_asid_validate_path(ctx);\n\tif (!ok)\n\t\tgoto end;\n\n\tok = X509v3_addr_validate_path(ctx);\n\tif (!ok)\n\t\tgoto end;\n#endif\n\n\tok = check_id(ctx);\n\tif (!ok)\n\t\tgoto end;\n\n\t/*\n\t * Check revocation status: we do this after copying parameters because\n\t * they may be needed for CRL signature verification.\n\t */\n\tok = ctx->check_revocation(ctx);\n\tif (!ok)\n\t\tgoto end;\n\n\t/* At this point, we have a chain and need to verify it */\n\tif (ctx->verify != NULL)\n\t\tok = ctx->verify(ctx);\n\telse\n\t\tok = internal_verify(ctx);\n\tif (!ok)\n\t\tgoto end;\n\n\t/* If we get this far evaluate policies */\n\tif (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))\n\t\tok = ctx->check_policy(ctx);\n\n end:\n\t/* Safety net, error returns must set ctx->error */\n\tif (ok <= 0 && ctx->error == X509_V_OK)\n\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\n\treturn ok;\n}\n\nint\nX509_verify_cert(X509_STORE_CTX *ctx)\n{\n\tSTACK_OF(X509) *roots = NULL;\n\tstruct x509_verify_ctx *vctx = NULL;\n\tint chain_count = 0;\n\n\tif (ctx->cert == NULL) {\n\t\tX509error(X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);\n\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\treturn -1;\n\t}\n\tif (ctx->chain != NULL) {\n\t\t/*\n\t\t * This X509_STORE_CTX has already been used to verify\n\t\t * a cert. We cannot do another one.\n\t\t */\n\t\tX509error(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\treturn -1;\n\t}\n\tif (ctx->param->id->poisoned) {\n\t\t/*\n\t\t * This X509_STORE_CTX had failures setting\n\t\t * up verify parameters. We can not use it.\n\t\t */\n\t\tX509error(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\treturn -1;\n\t}\n\tif (ctx->error != X509_V_ERR_INVALID_CALL) {\n\t\t/*\n\t\t * This X509_STORE_CTX has not been properly initialized.\n\t\t */\n\t\tX509error(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\treturn -1;\n\t}\n\n\t/*\n\t * If flags request legacy, use the legacy verifier. If we\n\t * requested \"no alt chains\" from the age of hammer pants, use\n\t * the legacy verifier because the multi chain verifier really\n\t * does find all the \"alt chains\".\n\t *\n\t * XXX deprecate the NO_ALT_CHAINS flag?\n\t */\n\tif ((ctx->param->flags & X509_V_FLAG_LEGACY_VERIFY) ||\n\t    (ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS))\n\t\treturn X509_verify_cert_legacy(ctx);\n\n\t/* Use the modern multi-chain verifier from x509_verify_cert */\n\n\tif ((vctx = x509_verify_ctx_new_from_xsc(ctx)) != NULL) {\n\t\tctx->error = X509_V_OK; /* Initialize to OK */\n\t\tchain_count = x509_verify(vctx, NULL, NULL);\n\t}\n\tx509_verify_ctx_free(vctx);\n\n\tsk_X509_pop_free(roots, X509_free);\n\n\t/* if we succeed we have a chain in ctx->chain */\n\treturn (chain_count > 0 && ctx->chain != NULL);\n}\n\n/* Given a STACK_OF(X509) find the issuer of cert (if any)\n */\n\nstatic X509 *\nfind_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x,\n    int allow_expired)\n{\n\tint i;\n\tX509 *issuer, *rv = NULL;\n\n\tfor (i = 0; i < sk_X509_num(sk); i++) {\n\t\tissuer = sk_X509_value(sk, i);\n\t\tif (ctx->check_issued(ctx, x, issuer)) {\n\t\t\tif (x509_check_cert_time(ctx, issuer, -1))\n\t\t\t\treturn issuer;\n\t\t\tif (allow_expired)\n\t\t\t\trv = issuer;\n\t\t}\n\t}\n\treturn rv;\n}\n\n/* Given a possible certificate and issuer check them */\n\nstatic int\ncheck_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer)\n{\n\tint ret;\n\n\tret = X509_check_issued(issuer, x);\n\tif (ret == X509_V_OK)\n\t\treturn 1;\n\t/* If we haven't asked for issuer errors don't set ctx */\n\tif (!(ctx->param->flags & X509_V_FLAG_CB_ISSUER_CHECK))\n\t\treturn 0;\n\n\tctx->error = ret;\n\tctx->current_cert = x;\n\tctx->current_issuer = issuer;\n\treturn ctx->verify_cb(0, ctx);\n}\n\n/* Alternative lookup method: look from a STACK stored in other_ctx */\n\nstatic int\nget_issuer_sk(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)\n{\n\t*issuer = find_issuer(ctx, ctx->other_ctx, x, 1);\n\tif (*issuer) {\n\t\tCRYPTO_add(&(*issuer)->references, 1, CRYPTO_LOCK_X509);\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}\n\n/* Check a certificate chains extensions for consistency\n * with the supplied purpose\n */\n\nint\nx509_vfy_check_chain_extensions(X509_STORE_CTX *ctx)\n{\n#ifdef OPENSSL_NO_CHAIN_VERIFY\n\treturn 1;\n#else\n\tint i, ok = 0, must_be_ca, plen = 0;\n\tX509 *x;\n\tint (*cb)(int xok, X509_STORE_CTX *xctx);\n\tint proxy_path_length = 0;\n\tint purpose;\n\tint allow_proxy_certs;\n\n\tcb = ctx->verify_cb;\n\n\t/* must_be_ca can have 1 of 3 values:\n\t   -1: we accept both CA and non-CA certificates, to allow direct\n\t       use of self-signed certificates (which are marked as CA).\n\t   0:  we only accept non-CA certificates.  This is currently not\n\t       used, but the possibility is present for future extensions.\n\t   1:  we only accept CA certificates.  This is currently used for\n\t       all certificates in the chain except the leaf certificate.\n\t*/\n\tmust_be_ca = -1;\n\n\t/* CRL path validation */\n\tif (ctx->parent) {\n\t\tallow_proxy_certs = 0;\n\t\tpurpose = X509_PURPOSE_CRL_SIGN;\n\t} else {\n\t\tallow_proxy_certs =\n\t\t    !!(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);\n\t\tpurpose = ctx->param->purpose;\n\t}\n\n\t/* Check all untrusted certificates */\n\tfor (i = 0; i < ctx->num_untrusted; i++) {\n\t\tint ret;\n\t\tx = sk_X509_value(ctx->chain, i);\n\t\tif (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL) &&\n\t\t    (x->ex_flags & EXFLAG_CRITICAL)) {\n\t\t\tctx->error = X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;\n\t\t\tctx->error_depth = i;\n\t\t\tctx->current_cert = x;\n\t\t\tok = cb(0, ctx);\n\t\t\tif (!ok)\n\t\t\t\tgoto end;\n\t\t}\n\t\tif (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY)) {\n\t\t\tctx->error = X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;\n\t\t\tctx->error_depth = i;\n\t\t\tctx->current_cert = x;\n\t\t\tok = cb(0, ctx);\n\t\t\tif (!ok)\n\t\t\t\tgoto end;\n\t\t}\n\t\tret = X509_check_ca(x);\n\t\tswitch (must_be_ca) {\n\t\tcase -1:\n\t\t\tif ((ctx->param->flags & X509_V_FLAG_X509_STRICT) &&\n\t\t\t    (ret != 1) && (ret != 0)) {\n\t\t\t\tret = 0;\n\t\t\t\tctx->error = X509_V_ERR_INVALID_CA;\n\t\t\t} else\n\t\t\t\tret = 1;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tif (ret != 0) {\n\t\t\t\tret = 0;\n\t\t\t\tctx->error = X509_V_ERR_INVALID_NON_CA;\n\t\t\t} else\n\t\t\t\tret = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((ret == 0) ||\n\t\t\t    ((ctx->param->flags & X509_V_FLAG_X509_STRICT) &&\n\t\t\t    (ret != 1))) {\n\t\t\t\tret = 0;\n\t\t\t\tctx->error = X509_V_ERR_INVALID_CA;\n\t\t\t} else\n\t\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tctx->error_depth = i;\n\t\t\tctx->current_cert = x;\n\t\t\tok = cb(0, ctx);\n\t\t\tif (!ok)\n\t\t\t\tgoto end;\n\t\t}\n\t\tif (ctx->param->purpose > 0) {\n\t\t\tret = X509_check_purpose(x, purpose, must_be_ca > 0);\n\t\t\tif ((ret == 0) ||\n\t\t\t    ((ctx->param->flags & X509_V_FLAG_X509_STRICT) &&\n\t\t\t    (ret != 1))) {\n\t\t\t\tctx->error = X509_V_ERR_INVALID_PURPOSE;\n\t\t\t\tctx->error_depth = i;\n\t\t\t\tctx->current_cert = x;\n\t\t\t\tok = cb(0, ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\t/* Check pathlen if not self issued */\n\t\tif ((i > 1) && !(x->ex_flags & EXFLAG_SI) &&\n\t\t    (x->ex_pathlen != -1) &&\n\t\t    (plen > (x->ex_pathlen + proxy_path_length + 1))) {\n\t\t\tctx->error = X509_V_ERR_PATH_LENGTH_EXCEEDED;\n\t\t\tctx->error_depth = i;\n\t\t\tctx->current_cert = x;\n\t\t\tok = cb(0, ctx);\n\t\t\tif (!ok)\n\t\t\t\tgoto end;\n\t\t}\n\t\t/* Increment path length if not self issued */\n\t\tif (!(x->ex_flags & EXFLAG_SI))\n\t\t\tplen++;\n\t\t/* If this certificate is a proxy certificate, the next\n\t\t   certificate must be another proxy certificate or a EE\n\t\t   certificate.  If not, the next certificate must be a\n\t\t   CA certificate.  */\n\t\tif (x->ex_flags & EXFLAG_PROXY) {\n\t\t\tif (x->ex_pcpathlen != -1 && i > x->ex_pcpathlen) {\n\t\t\t\tctx->error =\n\t\t\t\t    X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;\n\t\t\t\tctx->error_depth = i;\n\t\t\t\tctx->current_cert = x;\n\t\t\t\tok = cb(0, ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tproxy_path_length++;\n\t\t\tmust_be_ca = 0;\n\t\t} else\n\t\t\tmust_be_ca = 1;\n\t}\n\tok = 1;\n\nend:\n\treturn ok;\n#endif\n}\n\nstatic int\ncheck_chain_extensions(X509_STORE_CTX *ctx) {\n\treturn x509_vfy_check_chain_extensions(ctx);\n}\n\nstatic int\ncheck_name_constraints(X509_STORE_CTX *ctx)\n{\n\tif (!x509_constraints_chain(ctx->chain, &ctx->error,\n\t    &ctx->error_depth)) {\n\t\tctx->current_cert = sk_X509_value(ctx->chain, ctx->error_depth);\n\t\tif (!ctx->verify_cb(0, ctx))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* Given a certificate try and find an exact match in the store */\n\nstatic X509 *\nlookup_cert_match(X509_STORE_CTX *ctx, X509 *x)\n{\n\tSTACK_OF(X509) *certs;\n\tX509 *xtmp = NULL;\n\tsize_t i;\n\n\t/* Lookup all certs with matching subject name */\n\tcerts = ctx->lookup_certs(ctx, X509_get_subject_name(x));\n\tif (certs == NULL)\n\t\treturn NULL;\n\n\t/* Look for exact match */\n\tfor (i = 0; i < sk_X509_num(certs); i++) {\n\t\txtmp = sk_X509_value(certs, i);\n\t\tif (!X509_cmp(xtmp, x))\n\t\t\tbreak;\n\t}\n\n\tif (i < sk_X509_num(certs))\n\t\tX509_up_ref(xtmp);\n\telse\n\t\txtmp = NULL;\n\n\tsk_X509_pop_free(certs, X509_free);\n\treturn xtmp;\n}\n\nX509 *\nx509_vfy_lookup_cert_match(X509_STORE_CTX *ctx, X509 *x)\n{\n\tif (ctx->lookup_certs == NULL || ctx->store == NULL ||\n\t    ctx->store->objs == NULL)\n\t\treturn NULL;\n\treturn lookup_cert_match(ctx, x);\n}\n\nstatic int\ncheck_trust(X509_STORE_CTX *ctx)\n{\n\tsize_t i;\n\tint ok;\n\tX509 *x = NULL;\n\tint (*cb) (int xok, X509_STORE_CTX *xctx);\n\n\tcb = ctx->verify_cb;\n\t/* Check all trusted certificates in chain */\n\tfor (i = ctx->num_untrusted; i < sk_X509_num(ctx->chain); i++) {\n\t\tx = sk_X509_value(ctx->chain, i);\n\t\tok = X509_check_trust(x, ctx->param->trust, 0);\n\n\t\t/* If explicitly trusted return trusted */\n\t\tif (ok == X509_TRUST_TRUSTED)\n\t\t\treturn X509_TRUST_TRUSTED;\n\t\t/*\n\t\t * If explicitly rejected notify callback and reject if not\n\t\t * overridden.\n\t\t */\n\t\tif (ok == X509_TRUST_REJECTED) {\n\t\t\tctx->error_depth = i;\n\t\t\tctx->current_cert = x;\n\t\t\tctx->error = X509_V_ERR_CERT_REJECTED;\n\t\t\tok = cb(0, ctx);\n\t\t\tif (!ok)\n\t\t\t\treturn X509_TRUST_REJECTED;\n\t\t}\n\t}\n\t/*\n\t * If we accept partial chains and have at least one trusted certificate\n\t * return success.\n\t */\n\tif (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {\n\t\tX509 *mx;\n\t\tif (ctx->num_untrusted < (int)sk_X509_num(ctx->chain))\n\t\t\treturn X509_TRUST_TRUSTED;\n\t\tx = sk_X509_value(ctx->chain, 0);\n\t\tmx = lookup_cert_match(ctx, x);\n\t\tif (mx) {\n\t\t\t(void)sk_X509_set(ctx->chain, 0, mx);\n\t\t\tX509_free(x);\n\t\t\tctx->num_untrusted = 0;\n\t\t\treturn X509_TRUST_TRUSTED;\n\t\t}\n\t}\n\n\t/*\n\t * If no trusted certs in chain at all return untrusted and allow\n\t * standard (no issuer cert) etc errors to be indicated.\n\t */\n\treturn X509_TRUST_UNTRUSTED;\n}\n\nint\nx509_vfy_check_trust(X509_STORE_CTX *ctx)\n{\n\treturn check_trust(ctx);\n}\n\nstatic int\ncheck_revocation(X509_STORE_CTX *ctx)\n{\n\tint i, last, ok;\n\n\tif (!(ctx->param->flags & X509_V_FLAG_CRL_CHECK))\n\t\treturn 1;\n\tif (ctx->param->flags & X509_V_FLAG_CRL_CHECK_ALL)\n\t\tlast = sk_X509_num(ctx->chain) - 1;\n\telse {\n\t\t/* If checking CRL paths this isn't the EE certificate */\n\t\tif (ctx->parent)\n\t\t\treturn 1;\n\t\tlast = 0;\n\t}\n\tfor (i = 0; i <= last; i++) {\n\t\tok = check_cert(ctx, ctx->chain, i);\n\t\tif (!ok)\n\t\t\treturn ok;\n\t}\n\treturn 1;\n}\n\nint\nx509_vfy_check_revocation(X509_STORE_CTX *ctx)\n{\n\treturn check_revocation(ctx);\n}\n\nstatic int\ncheck_cert(X509_STORE_CTX *ctx, STACK_OF(X509) *chain, int depth)\n{\n\tX509_CRL *crl = NULL, *dcrl = NULL;\n\tX509 *x;\n\tint ok = 0, cnum;\n\tunsigned int last_reasons;\n\n\tcnum = ctx->error_depth = depth;\n\tx = sk_X509_value(chain, cnum);\n\tctx->current_cert = x;\n\tctx->current_issuer = NULL;\n\tctx->current_crl_score = 0;\n\tctx->current_reasons = 0;\n\twhile (ctx->current_reasons != CRLDP_ALL_REASONS) {\n\t\tlast_reasons = ctx->current_reasons;\n\t\t/* Try to retrieve relevant CRL */\n\t\tif (ctx->get_crl)\n\t\t\tok = ctx->get_crl(ctx, &crl, x);\n\t\telse\n\t\t\tok = get_crl_delta(ctx, &crl, &dcrl, x);\n\t\t/* If error looking up CRL, nothing we can do except\n\t\t * notify callback\n\t\t */\n\t\tif (!ok) {\n\t\t\tctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\tgoto err;\n\t\t}\n\t\tctx->current_crl = crl;\n\t\tok = ctx->check_crl(ctx, crl);\n\t\tif (!ok)\n\t\t\tgoto err;\n\n\t\tif (dcrl) {\n\t\t\tok = ctx->check_crl(ctx, dcrl);\n\t\t\tif (!ok)\n\t\t\t\tgoto err;\n\t\t\tok = ctx->cert_crl(ctx, dcrl, x);\n\t\t\tif (!ok)\n\t\t\t\tgoto err;\n\t\t} else\n\t\t\tok = 1;\n\n\t\t/* Don't look in full CRL if delta reason is removefromCRL */\n\t\tif (ok != 2) {\n\t\t\tok = ctx->cert_crl(ctx, crl, x);\n\t\t\tif (!ok)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tctx->current_crl = NULL;\n\t\tX509_CRL_free(crl);\n\t\tX509_CRL_free(dcrl);\n\t\tcrl = NULL;\n\t\tdcrl = NULL;\n\t\t/* If reasons not updated we wont get anywhere by\n\t\t * another iteration, so exit loop.\n\t\t */\n\t\tif (last_reasons == ctx->current_reasons) {\n\t\t\tctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\tctx->current_crl = NULL;\n\tX509_CRL_free(crl);\n\tX509_CRL_free(dcrl);\n\treturn ok;\n}\n\n/* Check CRL times against values in X509_STORE_CTX */\n\nstatic int\ncheck_crl_time(X509_STORE_CTX *ctx, X509_CRL *crl, int notify)\n{\n\ttime_t *ptime;\n\tint i;\n\n\tif (notify)\n\t\tctx->current_crl = crl;\n\tif (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)\n\t\tptime = &ctx->param->check_time;\n\telse if (ctx->param->flags & X509_V_FLAG_NO_CHECK_TIME)\n\t\treturn (1);\n\telse\n\t\tptime = NULL;\n\n\ti = X509_cmp_time(X509_CRL_get_lastUpdate(crl), ptime);\n\tif (i == 0) {\n\t\tif (!notify)\n\t\t\treturn 0;\n\t\tctx->error = X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;\n\t\tif (!ctx->verify_cb(0, ctx))\n\t\t\treturn 0;\n\t}\n\n\tif (i > 0) {\n\t\tif (!notify)\n\t\t\treturn 0;\n\t\tctx->error = X509_V_ERR_CRL_NOT_YET_VALID;\n\t\tif (!ctx->verify_cb(0, ctx))\n\t\t\treturn 0;\n\t}\n\n\tif (X509_CRL_get_nextUpdate(crl)) {\n\t\ti = X509_cmp_time(X509_CRL_get_nextUpdate(crl), ptime);\n\n\t\tif (i == 0) {\n\t\t\tif (!notify)\n\t\t\t\treturn 0;\n\t\t\tctx->error = X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;\n\t\t\tif (!ctx->verify_cb(0, ctx))\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* Ignore expiry of base CRL is delta is valid */\n\t\tif ((i < 0) &&\n\t\t    !(ctx->current_crl_score & CRL_SCORE_TIME_DELTA)) {\n\t\t\tif (!notify)\n\t\t\t\treturn 0;\n\t\t\tctx->error = X509_V_ERR_CRL_HAS_EXPIRED;\n\t\t\tif (!ctx->verify_cb(0, ctx))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (notify)\n\t\tctx->current_crl = NULL;\n\n\treturn 1;\n}\n\nstatic int\nget_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,\n    X509 **pissuer, int *pscore, unsigned int *preasons,\n    STACK_OF(X509_CRL) *crls)\n{\n\tint i, crl_score, best_score = *pscore;\n\tunsigned int reasons, best_reasons = 0;\n\tX509 *x = ctx->current_cert;\n\tX509_CRL *crl, *best_crl = NULL;\n\tX509 *crl_issuer = NULL, *best_crl_issuer = NULL;\n\n\tfor (i = 0; i < sk_X509_CRL_num(crls); i++) {\n\t\tcrl = sk_X509_CRL_value(crls, i);\n\t\treasons = *preasons;\n\t\tcrl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n\n\t\tif (crl_score > best_score) {\n\t\t\tbest_crl = crl;\n\t\t\tbest_crl_issuer = crl_issuer;\n\t\t\tbest_score = crl_score;\n\t\t\tbest_reasons = reasons;\n\t\t}\n\t}\n\n\tif (best_crl) {\n\t\tif (*pcrl)\n\t\t\tX509_CRL_free(*pcrl);\n\t\t*pcrl = best_crl;\n\t\t*pissuer = best_crl_issuer;\n\t\t*pscore = best_score;\n\t\t*preasons = best_reasons;\n\t\tCRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);\n\t\tif (*pdcrl) {\n\t\t\tX509_CRL_free(*pdcrl);\n\t\t\t*pdcrl = NULL;\n\t\t}\n\t\tget_delta_sk(ctx, pdcrl, pscore, best_crl, crls);\n\t}\n\n\tif (best_score >= CRL_SCORE_VALID)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/* Compare two CRL extensions for delta checking purposes. They should be\n * both present or both absent. If both present all fields must be identical.\n */\n\nstatic int\ncrl_extension_match(X509_CRL *a, X509_CRL *b, int nid)\n{\n\tASN1_OCTET_STRING *exta, *extb;\n\tint i;\n\n\ti = X509_CRL_get_ext_by_NID(a, nid, -1);\n\tif (i >= 0) {\n\t\t/* Can't have multiple occurrences */\n\t\tif (X509_CRL_get_ext_by_NID(a, nid, i) != -1)\n\t\t\treturn 0;\n\t\texta = X509_EXTENSION_get_data(X509_CRL_get_ext(a, i));\n\t} else\n\t\texta = NULL;\n\n\ti = X509_CRL_get_ext_by_NID(b, nid, -1);\n\n\tif (i >= 0) {\n\t\tif (X509_CRL_get_ext_by_NID(b, nid, i) != -1)\n\t\t\treturn 0;\n\t\textb = X509_EXTENSION_get_data(X509_CRL_get_ext(b, i));\n\t} else\n\t\textb = NULL;\n\n\tif (!exta && !extb)\n\t\treturn 1;\n\n\tif (!exta || !extb)\n\t\treturn 0;\n\n\tif (ASN1_OCTET_STRING_cmp(exta, extb))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/* See if a base and delta are compatible */\n\nstatic int\ncheck_delta_base(X509_CRL *delta, X509_CRL *base)\n{\n\t/* Delta CRL must be a delta */\n\tif (!delta->base_crl_number)\n\t\treturn 0;\n\t/* Base must have a CRL number */\n\tif (!base->crl_number)\n\t\treturn 0;\n\t/* Issuer names must match */\n\tif (X509_NAME_cmp(X509_CRL_get_issuer(base),\n\t    X509_CRL_get_issuer(delta)))\n\t\treturn 0;\n\t/* AKID and IDP must match */\n\tif (!crl_extension_match(delta, base, NID_authority_key_identifier))\n\t\treturn 0;\n\tif (!crl_extension_match(delta, base, NID_issuing_distribution_point))\n\t\treturn 0;\n\t/* Delta CRL base number must not exceed Full CRL number. */\n\tif (ASN1_INTEGER_cmp(delta->base_crl_number, base->crl_number) > 0)\n\t\treturn 0;\n\t/* Delta CRL number must exceed full CRL number */\n\tif (ASN1_INTEGER_cmp(delta->crl_number, base->crl_number) > 0)\n\t\treturn 1;\n\treturn 0;\n}\n\n/* For a given base CRL find a delta... maybe extend to delta scoring\n * or retrieve a chain of deltas...\n */\n\nstatic void\nget_delta_sk(X509_STORE_CTX *ctx, X509_CRL **dcrl, int *pscore, X509_CRL *base,\n    STACK_OF(X509_CRL) *crls)\n{\n\tX509_CRL *delta;\n\tint i;\n\n\tif (!(ctx->param->flags & X509_V_FLAG_USE_DELTAS))\n\t\treturn;\n\tif (!((ctx->current_cert->ex_flags | base->flags) & EXFLAG_FRESHEST))\n\t\treturn;\n\tfor (i = 0; i < sk_X509_CRL_num(crls); i++) {\n\t\tdelta = sk_X509_CRL_value(crls, i);\n\t\tif (check_delta_base(delta, base)) {\n\t\t\tif (check_crl_time(ctx, delta, 0))\n\t\t\t\t*pscore |= CRL_SCORE_TIME_DELTA;\n\t\t\tCRYPTO_add(&delta->references, 1, CRYPTO_LOCK_X509_CRL);\n\t\t\t*dcrl = delta;\n\t\t\treturn;\n\t\t}\n\t}\n\t*dcrl = NULL;\n}\n\n/* For a given CRL return how suitable it is for the supplied certificate 'x'.\n * The return value is a mask of several criteria.\n * If the issuer is not the certificate issuer this is returned in *pissuer.\n * The reasons mask is also used to determine if the CRL is suitable: if\n * no new reasons the CRL is rejected, otherwise reasons is updated.\n */\n\nstatic int\nget_crl_score(X509_STORE_CTX *ctx, X509 **pissuer, unsigned int *preasons,\n    X509_CRL *crl, X509 *x)\n{\n\tint crl_score = 0;\n\tunsigned int tmp_reasons = *preasons, crl_reasons;\n\n\t/* First see if we can reject CRL straight away */\n\n\t/* Invalid IDP cannot be processed */\n\tif (crl->idp_flags & IDP_INVALID)\n\t\treturn 0;\n\t/* Reason codes or indirect CRLs need extended CRL support */\n\tif (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT)) {\n\t\tif (crl->idp_flags & (IDP_INDIRECT | IDP_REASONS))\n\t\t\treturn 0;\n\t} else if (crl->idp_flags & IDP_REASONS) {\n\t\t/* If no new reasons reject */\n\t\tif (!(crl->idp_reasons & ~tmp_reasons))\n\t\t\treturn 0;\n\t}\n\t/* Don't process deltas at this stage */\n\telse if (crl->base_crl_number)\n\t\treturn 0;\n\t/* If issuer name doesn't match certificate need indirect CRL */\n\tif (X509_NAME_cmp(X509_get_issuer_name(x), X509_CRL_get_issuer(crl))) {\n\t\tif (!(crl->idp_flags & IDP_INDIRECT))\n\t\t\treturn 0;\n\t} else\n\t\tcrl_score |= CRL_SCORE_ISSUER_NAME;\n\n\tif (!(crl->flags & EXFLAG_CRITICAL))\n\t\tcrl_score |= CRL_SCORE_NOCRITICAL;\n\n\t/* Check expiry */\n\tif (check_crl_time(ctx, crl, 0))\n\t\tcrl_score |= CRL_SCORE_TIME;\n\n\t/* Check authority key ID and locate certificate issuer */\n\tcrl_akid_check(ctx, crl, pissuer, &crl_score);\n\n\t/* If we can't locate certificate issuer at this point forget it */\n\n\tif (!(crl_score & CRL_SCORE_AKID))\n\t\treturn 0;\n\n\t/* Check cert for matching CRL distribution points */\n\n\tif (crl_crldp_check(x, crl, crl_score, &crl_reasons)) {\n\t\t/* If no new reasons reject */\n\t\tif (!(crl_reasons & ~tmp_reasons))\n\t\t\treturn 0;\n\t\ttmp_reasons |= crl_reasons;\n\t\tcrl_score |= CRL_SCORE_SCOPE;\n\t}\n\n\t*preasons = tmp_reasons;\n\n\treturn crl_score;\n}\n\nstatic void\ncrl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl, X509 **pissuer,\n    int *pcrl_score)\n{\n\tX509 *crl_issuer = NULL;\n\tX509_NAME *cnm = X509_CRL_get_issuer(crl);\n\tint cidx = ctx->error_depth;\n\tint i;\n\n\tif (cidx != sk_X509_num(ctx->chain) - 1)\n\t\tcidx++;\n\n\tcrl_issuer = sk_X509_value(ctx->chain, cidx);\n\n\tif (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {\n\t\tif (*pcrl_score & CRL_SCORE_ISSUER_NAME) {\n\t\t\t*pcrl_score |= CRL_SCORE_AKID|CRL_SCORE_ISSUER_CERT;\n\t\t\t*pissuer = crl_issuer;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (cidx++; cidx < sk_X509_num(ctx->chain); cidx++) {\n\t\tcrl_issuer = sk_X509_value(ctx->chain, cidx);\n\t\tif (X509_NAME_cmp(X509_get_subject_name(crl_issuer), cnm))\n\t\t\tcontinue;\n\t\tif (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {\n\t\t\t*pcrl_score |= CRL_SCORE_AKID|CRL_SCORE_SAME_PATH;\n\t\t\t*pissuer = crl_issuer;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Anything else needs extended CRL support */\n\n\tif (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT))\n\t\treturn;\n\n\t/* Otherwise the CRL issuer is not on the path. Look for it in the\n\t * set of untrusted certificates.\n\t */\n\tfor (i = 0; i < sk_X509_num(ctx->untrusted); i++) {\n\t\tcrl_issuer = sk_X509_value(ctx->untrusted, i);\n\t\tif (X509_NAME_cmp(X509_get_subject_name(crl_issuer), cnm))\n\t\t\tcontinue;\n\t\tif (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {\n\t\t\t*pissuer = crl_issuer;\n\t\t\t*pcrl_score |= CRL_SCORE_AKID;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/* Check the path of a CRL issuer certificate. This creates a new\n * X509_STORE_CTX and populates it with most of the parameters from the\n * parent. This could be optimised somewhat since a lot of path checking\n * will be duplicated by the parent, but this will rarely be used in\n * practice.\n */\n\nstatic int\ncheck_crl_path(X509_STORE_CTX *ctx, X509 *x)\n{\n\tX509_STORE_CTX crl_ctx;\n\tint ret;\n\n\t/* Don't allow recursive CRL path validation */\n\tif (ctx->parent)\n\t\treturn 0;\n\tif (!X509_STORE_CTX_init(&crl_ctx, ctx->store, x, ctx->untrusted)) {\n\t\tret = -1;\n\t\tgoto err;\n\t}\n\n\tcrl_ctx.crls = ctx->crls;\n\t/* Copy verify params across */\n\tX509_STORE_CTX_set0_param(&crl_ctx, ctx->param);\n\n\tcrl_ctx.parent = ctx;\n\tcrl_ctx.verify_cb = ctx->verify_cb;\n\n\t/* Verify CRL issuer */\n\tret = X509_verify_cert(&crl_ctx);\n\n\tif (ret <= 0)\n\t\tgoto err;\n\n\t/* Check chain is acceptable */\n\tret = check_crl_chain(ctx, ctx->chain, crl_ctx.chain);\n\nerr:\n\tX509_STORE_CTX_cleanup(&crl_ctx);\n\treturn ret;\n}\n\n/* RFC3280 says nothing about the relationship between CRL path\n * and certificate path, which could lead to situations where a\n * certificate could be revoked or validated by a CA not authorised\n * to do so. RFC5280 is more strict and states that the two paths must\n * end in the same trust anchor, though some discussions remain...\n * until this is resolved we use the RFC5280 version\n */\n\nstatic int\ncheck_crl_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *cert_path,\n    STACK_OF(X509) *crl_path)\n{\n\tX509 *cert_ta, *crl_ta;\n\n\tcert_ta = sk_X509_value(cert_path, sk_X509_num(cert_path) - 1);\n\tcrl_ta = sk_X509_value(crl_path, sk_X509_num(crl_path) - 1);\n\tif (!X509_cmp(cert_ta, crl_ta))\n\t\treturn 1;\n\treturn 0;\n}\n\n/* Check for match between two dist point names: three separate cases.\n * 1. Both are relative names and compare X509_NAME types.\n * 2. One full, one relative. Compare X509_NAME to GENERAL_NAMES.\n * 3. Both are full names and compare two GENERAL_NAMES.\n * 4. One is NULL: automatic match.\n */\n\nstatic int\nidp_check_dp(DIST_POINT_NAME *a, DIST_POINT_NAME *b)\n{\n\tX509_NAME *nm = NULL;\n\tGENERAL_NAMES *gens = NULL;\n\tGENERAL_NAME *gena, *genb;\n\tint i, j;\n\n\tif (!a || !b)\n\t\treturn 1;\n\tif (a->type == 1) {\n\t\tif (!a->dpname)\n\t\t\treturn 0;\n\t\t/* Case 1: two X509_NAME */\n\t\tif (b->type == 1) {\n\t\t\tif (!b->dpname)\n\t\t\t\treturn 0;\n\t\t\tif (!X509_NAME_cmp(a->dpname, b->dpname))\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* Case 2: set name and GENERAL_NAMES appropriately */\n\t\tnm = a->dpname;\n\t\tgens = b->name.fullname;\n\t} else if (b->type == 1) {\n\t\tif (!b->dpname)\n\t\t\treturn 0;\n\t\t/* Case 2: set name and GENERAL_NAMES appropriately */\n\t\tgens = a->name.fullname;\n\t\tnm = b->dpname;\n\t}\n\n\t/* Handle case 2 with one GENERAL_NAMES and one X509_NAME */\n\tif (nm) {\n\t\tfor (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {\n\t\t\tgena = sk_GENERAL_NAME_value(gens, i);\n\t\t\tif (gena->type != GEN_DIRNAME)\n\t\t\t\tcontinue;\n\t\t\tif (!X509_NAME_cmp(nm, gena->d.directoryName))\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Else case 3: two GENERAL_NAMES */\n\n\tfor (i = 0; i < sk_GENERAL_NAME_num(a->name.fullname); i++) {\n\t\tgena = sk_GENERAL_NAME_value(a->name.fullname, i);\n\t\tfor (j = 0; j < sk_GENERAL_NAME_num(b->name.fullname); j++) {\n\t\t\tgenb = sk_GENERAL_NAME_value(b->name.fullname, j);\n\t\t\tif (!GENERAL_NAME_cmp(gena, genb))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\ncrldp_check_crlissuer(DIST_POINT *dp, X509_CRL *crl, int crl_score)\n{\n\tint i;\n\tX509_NAME *nm = X509_CRL_get_issuer(crl);\n\n\t/* If no CRLissuer return is successful iff don't need a match */\n\tif (!dp->CRLissuer)\n\t\treturn !!(crl_score & CRL_SCORE_ISSUER_NAME);\n\tfor (i = 0; i < sk_GENERAL_NAME_num(dp->CRLissuer); i++) {\n\t\tGENERAL_NAME *gen = sk_GENERAL_NAME_value(dp->CRLissuer, i);\n\t\tif (gen->type != GEN_DIRNAME)\n\t\t\tcontinue;\n\t\tif (!X509_NAME_cmp(gen->d.directoryName, nm))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* Check CRLDP and IDP */\n\nstatic int\ncrl_crldp_check(X509 *x, X509_CRL *crl, int crl_score, unsigned int *preasons)\n{\n\tint i;\n\n\tif (crl->idp_flags & IDP_ONLYATTR)\n\t\treturn 0;\n\tif (x->ex_flags & EXFLAG_CA) {\n\t\tif (crl->idp_flags & IDP_ONLYUSER)\n\t\t\treturn 0;\n\t} else {\n\t\tif (crl->idp_flags & IDP_ONLYCA)\n\t\t\treturn 0;\n\t}\n\t*preasons = crl->idp_reasons;\n\tfor (i = 0; i < sk_DIST_POINT_num(x->crldp); i++) {\n\t\tDIST_POINT *dp = sk_DIST_POINT_value(x->crldp, i);\n\t\tif (crldp_check_crlissuer(dp, crl, crl_score)) {\n\t\t\tif (!crl->idp ||\n\t\t\t    idp_check_dp(dp->distpoint, crl->idp->distpoint)) {\n\t\t\t\t*preasons &= dp->dp_reasons;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif ((!crl->idp || !crl->idp->distpoint) &&\n\t    (crl_score & CRL_SCORE_ISSUER_NAME))\n\t\treturn 1;\n\treturn 0;\n}\n\n/* Retrieve CRL corresponding to current certificate.\n * If deltas enabled try to find a delta CRL too\n */\n\nstatic int\nget_crl_delta(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl, X509 *x)\n{\n\tint ok;\n\tX509 *issuer = NULL;\n\tint crl_score = 0;\n\tunsigned int reasons;\n\tX509_CRL *crl = NULL, *dcrl = NULL;\n\tSTACK_OF(X509_CRL) *skcrl;\n\tX509_NAME *nm = X509_get_issuer_name(x);\n\n\treasons = ctx->current_reasons;\n\tok = get_crl_sk(ctx, &crl, &dcrl, &issuer, &crl_score, &reasons,\n\t    ctx->crls);\n\tif (ok)\n\t\tgoto done;\n\n\t/* Lookup CRLs from store */\n\tskcrl = ctx->lookup_crls(ctx, nm);\n\n\t/* If no CRLs found and a near match from get_crl_sk use that */\n\tif (!skcrl && crl)\n\t\tgoto done;\n\n\tget_crl_sk(ctx, &crl, &dcrl, &issuer, &crl_score, &reasons, skcrl);\n\n\tsk_X509_CRL_pop_free(skcrl, X509_CRL_free);\n\ndone:\n\n\t/* If we got any kind of CRL use it and return success */\n\tif (crl) {\n\t\tctx->current_issuer = issuer;\n\t\tctx->current_crl_score = crl_score;\n\t\tctx->current_reasons = reasons;\n\t\t*pcrl = crl;\n\t\t*pdcrl = dcrl;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/* Check CRL validity */\nstatic int\ncheck_crl(X509_STORE_CTX *ctx, X509_CRL *crl)\n{\n\tX509 *issuer = NULL;\n\tEVP_PKEY *ikey = NULL;\n\tint ok = 0, chnum, cnum;\n\n\tcnum = ctx->error_depth;\n\tchnum = sk_X509_num(ctx->chain) - 1;\n\t/* if we have an alternative CRL issuer cert use that */\n\tif (ctx->current_issuer) {\n\t\tissuer = ctx->current_issuer;\n\t} else if (cnum < chnum) {\n\t\t/*\n\t\t * Else find CRL issuer: if not last certificate then issuer\n\t\t * is next certificate in chain.\n\t\t */\n\t\tissuer = sk_X509_value(ctx->chain, cnum + 1);\n\t} else {\n\t\tissuer = sk_X509_value(ctx->chain, chnum);\n\t\t/* If not self signed, can't check signature */\n\t\tif (!ctx->check_issued(ctx, issuer, issuer)) {\n\t\t\tctx->error = X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER;\n\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\tif (!ok)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (issuer) {\n\t\t/* Skip most tests for deltas because they have already\n\t\t * been done\n\t\t */\n\t\tif (!crl->base_crl_number) {\n\t\t\t/* Check for cRLSign bit if keyUsage present */\n\t\t\tif ((issuer->ex_flags & EXFLAG_KUSAGE) &&\n\t\t\t    !(issuer->ex_kusage & KU_CRL_SIGN)) {\n\t\t\t\tctx->error = X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;\n\t\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (!(ctx->current_crl_score & CRL_SCORE_SCOPE)) {\n\t\t\t\tctx->error = X509_V_ERR_DIFFERENT_CRL_SCOPE;\n\t\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (!(ctx->current_crl_score & CRL_SCORE_SAME_PATH)) {\n\t\t\t\tif (check_crl_path(ctx,\n\t\t\t\t    ctx->current_issuer) <= 0) {\n\t\t\t\t\tctx->error = X509_V_ERR_CRL_PATH_VALIDATION_ERROR;\n\t\t\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\t\t\tif (!ok)\n\t\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (crl->idp_flags & IDP_INVALID) {\n\t\t\t\tctx->error = X509_V_ERR_INVALID_EXTENSION;\n\t\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\n\n\t\t}\n\n\t\tif (!(ctx->current_crl_score & CRL_SCORE_TIME)) {\n\t\t\tok = check_crl_time(ctx, crl, 1);\n\t\t\tif (!ok)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\t/* Attempt to get issuer certificate public key */\n\t\tikey = X509_get_pubkey(issuer);\n\n\t\tif (!ikey) {\n\t\t\tctx->error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\n\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\tif (!ok)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\t/* Verify CRL signature */\n\t\t\tif (X509_CRL_verify(crl, ikey) <= 0) {\n\t\t\t\tctx->error = X509_V_ERR_CRL_SIGNATURE_FAILURE;\n\t\t\t\tok = ctx->verify_cb(0, ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tok = 1;\n\nerr:\n\tEVP_PKEY_free(ikey);\n\treturn ok;\n}\n\n/* Check certificate against CRL */\nstatic int\ncert_crl(X509_STORE_CTX *ctx, X509_CRL *crl, X509 *x)\n{\n\tint ok;\n\tX509_REVOKED *rev;\n\n\t/* The rules changed for this... previously if a CRL contained\n\t * unhandled critical extensions it could still be used to indicate\n\t * a certificate was revoked. This has since been changed since\n\t * critical extension can change the meaning of CRL entries.\n\t */\n\tif (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL) &&\n\t    (crl->flags & EXFLAG_CRITICAL)) {\n\t\tctx->error = X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;\n\t\tok = ctx->verify_cb(0, ctx);\n\t\tif (!ok)\n\t\t\treturn 0;\n\t}\n\t/* Look for serial number of certificate in CRL\n\t * If found make sure reason is not removeFromCRL.\n\t */\n\tif (X509_CRL_get0_by_cert(crl, &rev, x)) {\n\t\tif (rev->reason == CRL_REASON_REMOVE_FROM_CRL)\n\t\t\treturn 2;\n\t\tctx->error = X509_V_ERR_CERT_REVOKED;\n\t\tok = ctx->verify_cb(0, ctx);\n\t\tif (!ok)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nint\nx509_vfy_check_policy(X509_STORE_CTX *ctx)\n{\n\tint ret;\n\n\tif (ctx->parent)\n\t\treturn 1;\n\n\t/* X509_policy_check always allocates a new tree. */\n\tX509_policy_tree_free(ctx->tree);\n\tctx->tree = NULL;\n\n\tret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,\n\t    ctx->param->policies, ctx->param->flags);\n\tif (ret == 0) {\n\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t}\n\t/* Invalid or inconsistent extensions */\n\tif (ret == -1) {\n\t\t/* Locate certificates with bad extensions and notify\n\t\t * callback.\n\t\t */\n\t\tX509 *x;\n\t\tint i;\n\t\tfor (i = 1; i < sk_X509_num(ctx->chain); i++) {\n\t\t\tx = sk_X509_value(ctx->chain, i);\n\t\t\tif (!(x->ex_flags & EXFLAG_INVALID_POLICY))\n\t\t\t\tcontinue;\n\t\t\tctx->current_cert = x;\n\t\t\tctx->error = X509_V_ERR_INVALID_POLICY_EXTENSION;\n\t\t\tif (!ctx->verify_cb(0, ctx))\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tif (ret == -2) {\n\t\tctx->current_cert = NULL;\n\t\tctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;\n\t\treturn ctx->verify_cb(0, ctx);\n\t}\n\n\tif (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) {\n\t\tctx->current_cert = NULL;\n\t\tctx->error = X509_V_OK;\n\t\tif (!ctx->verify_cb(2, ctx))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\ncheck_policy(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_check_policy(ctx);\n}\n\n/*\n * Inform the verify callback of an error.\n *\n * If x is not NULL it is the error cert, otherwise use the chain cert\n * at depth.\n *\n * If err is not X509_V_OK, that's the error value, otherwise leave\n * unchanged (presumably set by the caller).\n *\n * Returns 0 to abort verification with an error, non-zero to continue.\n */\nstatic int\nverify_cb_cert(X509_STORE_CTX *ctx, X509 *x, int depth, int err)\n{\n\tctx->error_depth = depth;\n\tctx->current_cert = (x != NULL) ? x : sk_X509_value(ctx->chain, depth);\n\tif (err != X509_V_OK)\n\t\tctx->error = err;\n\treturn ctx->verify_cb(0, ctx);\n}\n\n\n/* Mimic OpenSSL '0 for failure' ick */\nstatic int\ntime_t_bogocmp(time_t a, time_t b)\n{\n\tif (a == -1 || b == -1)\n\t\treturn 0;\n\tif (a <= b)\n\t\treturn -1;\n\treturn 1;\n}\n\n/*\n * Check certificate validity times.\n *\n * If depth >= 0, invoke verification callbacks on error, otherwise just return\n * the validation status.\n *\n * Return 1 on success, 0 otherwise.\n */\nint\nx509_check_cert_time(X509_STORE_CTX *ctx, X509 *x, int depth)\n{\n\ttime_t ptime;\n\tint i;\n\n\tif (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)\n\t\tptime = ctx->param->check_time;\n\telse if (ctx->param->flags & X509_V_FLAG_NO_CHECK_TIME)\n\t\treturn 1;\n\telse\n\t\tptime = time(NULL);\n\n\tif (x->ex_flags & EXFLAG_SET)\n\t\ti = time_t_bogocmp(x->not_before, ptime);\n\telse\n\t\ti = X509_cmp_time(X509_get_notBefore(x), &ptime);\n\n\tif (i >= 0 && depth < 0)\n\t\treturn 0;\n\tif (i == 0 && !verify_cb_cert(ctx, x, depth,\n\t    X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD))\n\t\treturn 0;\n\tif (i > 0 && !verify_cb_cert(ctx, x, depth,\n\t    X509_V_ERR_CERT_NOT_YET_VALID))\n\t\treturn 0;\n\n\tif (x->ex_flags & EXFLAG_SET)\n\t\ti = time_t_bogocmp(x->not_after, ptime);\n\telse\n\t\ti = X509_cmp_time_internal(X509_get_notAfter(x), &ptime, 1);\n\n\tif (i <= 0 && depth < 0)\n\t\treturn 0;\n\tif (i == 0 && !verify_cb_cert(ctx, x, depth,\n\t    X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD))\n\t\treturn 0;\n\tif (i < 0 && !verify_cb_cert(ctx, x, depth,\n\t    X509_V_ERR_CERT_HAS_EXPIRED))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int\nx509_vfy_internal_verify(X509_STORE_CTX *ctx, int chain_verified)\n{\n\tint n = sk_X509_num(ctx->chain) - 1;\n\tX509 *xi = sk_X509_value(ctx->chain, n);\n\tX509 *xs;\n\n\tif (ctx->check_issued(ctx, xi, xi))\n\t\txs = xi;\n\telse {\n\t\tif (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {\n\t\t\txs = xi;\n\t\t\tgoto check_cert;\n\t\t}\n\t\tif (n <= 0)\n\t\t\treturn verify_cb_cert(ctx, xi, 0,\n\t\t\t    X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE);\n\t\tn--;\n\t\tctx->error_depth = n;\n\t\txs = sk_X509_value(ctx->chain, n);\n\t}\n\n\t/*\n\t * Do not clear ctx->error=0, it must be \"sticky\", only the\n\t * user's callback is allowed to reset errors (at its own\n\t * peril).\n\t */\n\twhile (n >= 0) {\n\n\t\t/*\n\t\t * Skip signature check for self signed certificates\n\t\t * unless explicitly asked for.  It doesn't add any\n\t\t * security and just wastes time.  If the issuer's\n\t\t * public key is unusable, report the issuer\n\t\t * certificate and its depth (rather than the depth of\n\t\t * the subject).\n\t\t */\n\t\tif (!chain_verified && ( xs != xi ||\n\t\t    (ctx->param->flags & X509_V_FLAG_CHECK_SS_SIGNATURE))) {\n\t\t\tEVP_PKEY *pkey;\n\t\t\tif ((pkey = X509_get_pubkey(xi)) == NULL) {\n\t\t\t\tif (!verify_cb_cert(ctx, xi, xi != xs ? n+1 : n,\n\t\t\t\t    X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY))\n\t\t\t\t\treturn 0;\n\t\t\t} else if (X509_verify(xs, pkey) <= 0) {\n\t\t\t\tif (!verify_cb_cert(ctx, xs, n,\n\t\t\t\t    X509_V_ERR_CERT_SIGNATURE_FAILURE)) {\n\t\t\t\t\tEVP_PKEY_free(pkey);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tEVP_PKEY_free(pkey);\n\t\t}\ncheck_cert:\n\t\t/* Calls verify callback as needed */\n\t\tif (!chain_verified && !x509_check_cert_time(ctx, xs, n))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Signal success at this depth.  However, the\n\t\t * previous error (if any) is retained.\n\t\t */\n\t\tctx->current_issuer = xi;\n\t\tctx->current_cert = xs;\n\t\tctx->error_depth = n;\n\t\tif (!ctx->verify_cb(1, ctx))\n\t\t\treturn 0;\n\n\t\tif (--n >= 0) {\n\t\t\txi = xs;\n\t\t\txs = sk_X509_value(ctx->chain, n);\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int\ninternal_verify(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_internal_verify(ctx, 0);\n}\n\n/*\n * Internal verify, but with a chain where the verification\n * math has already been performed.\n */\nint\nx509_vfy_callback_indicate_completion(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_internal_verify(ctx, 1);\n}\n\nint\nX509_cmp_current_time(const ASN1_TIME *ctm)\n{\n\treturn X509_cmp_time(ctm, NULL);\n}\n\n/*\n * Compare a possibly unvalidated ASN1_TIME string against a time_t\n * using RFC 5280 rules for the time string. If *cmp_time is NULL\n * the current system time is used.\n *\n * XXX NOTE that unlike what you expect a \"cmp\" function to do in C,\n * XXX this one is \"special\", and returns 0 for error.\n *\n * Returns:\n * -1 if the ASN1_time is earlier than OR the same as *cmp_time.\n * 1 if the ASN1_time is later than *cmp_time.\n * 0 on error.\n */\nstatic int\nX509_cmp_time_internal(const ASN1_TIME *ctm, time_t *cmp_time, int is_notafter)\n{\n\ttime_t compare, cert_time;\n\n\tif (cmp_time == NULL)\n\t\tcompare = time(NULL);\n\telse\n\t\tcompare = *cmp_time;\n\n\tif ((cert_time = x509_verify_asn1_time_to_time_t(ctm, is_notafter)) ==\n\t    -1)\n\t\treturn 0; /* invalid time */\n\n\tif (cert_time <= compare)\n\t\treturn -1; /* 0 is used for error, so map same to less than */\n\n\treturn 1;\n}\n\nint\nX509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n\treturn X509_cmp_time_internal(ctm, cmp_time, 0);\n}\n\n\nASN1_TIME *\nX509_gmtime_adj(ASN1_TIME *s, long adj)\n{\n\treturn X509_time_adj(s, adj, NULL);\n}\n\nASN1_TIME *\nX509_time_adj(ASN1_TIME *s, long offset_sec, time_t *in_time)\n{\n\treturn X509_time_adj_ex(s, 0, offset_sec, in_time);\n}\n\nASN1_TIME *\nX509_time_adj_ex(ASN1_TIME *s, int offset_day, long offset_sec, time_t *in_time)\n{\n\ttime_t t;\n\tif (in_time == NULL)\n\t\tt = time(NULL);\n\telse\n\t\tt = *in_time;\n\n\treturn ASN1_TIME_adj(s, t, offset_day, offset_sec);\n}\n\nint\nX509_get_pubkey_parameters(EVP_PKEY *pkey, STACK_OF(X509) *chain)\n{\n\tEVP_PKEY *ktmp = NULL, *ktmp2;\n\tint i, j;\n\n\tif ((pkey != NULL) && !EVP_PKEY_missing_parameters(pkey))\n\t\treturn 1;\n\n\tfor (i = 0; i < sk_X509_num(chain); i++) {\n\t\tktmp = X509_get_pubkey(sk_X509_value(chain, i));\n\t\tif (ktmp == NULL) {\n\t\t\tX509error(X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!EVP_PKEY_missing_parameters(ktmp))\n\t\t\tbreak;\n\t\telse {\n\t\t\tEVP_PKEY_free(ktmp);\n\t\t\tktmp = NULL;\n\t\t}\n\t}\n\tif (ktmp == NULL) {\n\t\tX509error(X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN);\n\t\treturn 0;\n\t}\n\n\t/* first, populate the other certs */\n\tfor (j = i - 1; j >= 0; j--) {\n\t\tktmp2 = X509_get_pubkey(sk_X509_value(chain, j));\n\t\tEVP_PKEY_copy_parameters(ktmp2, ktmp);\n\t\tEVP_PKEY_free(ktmp2);\n\t}\n\n\tif (pkey != NULL)\n\t\tEVP_PKEY_copy_parameters(pkey, ktmp);\n\tEVP_PKEY_free(ktmp);\n\treturn 1;\n}\n\nint\nX509_STORE_CTX_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\n    CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\n{\n\t/* This function is (usually) called only once, by\n\t * SSL_get_ex_data_X509_STORE_CTX_idx (ssl/ssl_cert.c). */\n\treturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX,\n\t    argl, argp, new_func, dup_func, free_func);\n}\n\nint\nX509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data)\n{\n\treturn CRYPTO_set_ex_data(&ctx->ex_data, idx, data);\n}\n\nvoid *\nX509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx, int idx)\n{\n\treturn CRYPTO_get_ex_data(&ctx->ex_data, idx);\n}\n\nint\nX509_STORE_CTX_get_error(X509_STORE_CTX *ctx)\n{\n\treturn ctx->error;\n}\n\nvoid\nX509_STORE_CTX_set_error(X509_STORE_CTX *ctx, int err)\n{\n\tctx->error = err;\n}\n\nint\nX509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx)\n{\n\treturn ctx->error_depth;\n}\n\nvoid\nX509_STORE_CTX_set_error_depth(X509_STORE_CTX *ctx, int depth)\n{\n\tctx->error_depth = depth;\n}\n\nX509 *\nX509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx)\n{\n\treturn ctx->current_cert;\n}\n\nvoid\nX509_STORE_CTX_set_current_cert(X509_STORE_CTX *ctx, X509 *x)\n{\n\tctx->current_cert = x;\n}\n\nSTACK_OF(X509) *\nX509_STORE_CTX_get_chain(X509_STORE_CTX *ctx)\n{\n\treturn ctx->chain;\n}\n\nSTACK_OF(X509) *\nX509_STORE_CTX_get0_chain(X509_STORE_CTX *xs)\n{\n\treturn xs->chain;\n}\n\nSTACK_OF(X509) *\nX509_STORE_CTX_get1_chain(X509_STORE_CTX *ctx)\n{\n\tint i;\n\tX509 *x;\n\tSTACK_OF(X509) *chain;\n\n\tif (!ctx->chain || !(chain = sk_X509_dup(ctx->chain)))\n\t\treturn NULL;\n\tfor (i = 0; i < sk_X509_num(chain); i++) {\n\t\tx = sk_X509_value(chain, i);\n\t\tCRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);\n\t}\n\treturn chain;\n}\n\nX509 *\nX509_STORE_CTX_get0_current_issuer(X509_STORE_CTX *ctx)\n{\n\treturn ctx->current_issuer;\n}\n\nX509_CRL *\nX509_STORE_CTX_get0_current_crl(X509_STORE_CTX *ctx)\n{\n\treturn ctx->current_crl;\n}\n\nX509_STORE_CTX *\nX509_STORE_CTX_get0_parent_ctx(X509_STORE_CTX *ctx)\n{\n\treturn ctx->parent;\n}\n\nX509_STORE *\nX509_STORE_CTX_get0_store(X509_STORE_CTX *xs)\n{\n\treturn xs->store;\n}\n\nvoid\nX509_STORE_CTX_set_cert(X509_STORE_CTX *ctx, X509 *x)\n{\n\tctx->cert = x;\n}\n\nvoid\nX509_STORE_CTX_set_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)\n{\n\tctx->untrusted = sk;\n}\n\nvoid\nX509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx, STACK_OF(X509_CRL) *sk)\n{\n\tctx->crls = sk;\n}\n\nint\nX509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose)\n{\n\treturn X509_STORE_CTX_purpose_inherit(ctx, 0, purpose, 0);\n}\n\nint\nX509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust)\n{\n\treturn X509_STORE_CTX_purpose_inherit(ctx, 0, 0, trust);\n}\n\n/* This function is used to set the X509_STORE_CTX purpose and trust\n * values. This is intended to be used when another structure has its\n * own trust and purpose values which (if set) will be inherited by\n * the ctx. If they aren't set then we will usually have a default\n * purpose in mind which should then be used to set the trust value.\n * An example of this is SSL use: an SSL structure will have its own\n * purpose and trust settings which the application can set: if they\n * aren't set then we use the default of SSL client/server.\n */\n\nint\nX509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,\n    int purpose, int trust)\n{\n\tint idx;\n\n\t/* If purpose not set use default */\n\tif (!purpose)\n\t\tpurpose = def_purpose;\n\t/* If we have a purpose then check it is valid */\n\tif (purpose) {\n\t\tX509_PURPOSE *ptmp;\n\t\tidx = X509_PURPOSE_get_by_id(purpose);\n\t\tif (idx == -1) {\n\t\t\tX509error(X509_R_UNKNOWN_PURPOSE_ID);\n\t\t\treturn 0;\n\t\t}\n\t\tptmp = X509_PURPOSE_get0(idx);\n\t\tif (ptmp->trust == X509_TRUST_DEFAULT) {\n\t\t\tidx = X509_PURPOSE_get_by_id(def_purpose);\n\t\t\tif (idx == -1) {\n\t\t\t\tX509error(X509_R_UNKNOWN_PURPOSE_ID);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tptmp = X509_PURPOSE_get0(idx);\n\t\t}\n\t\t/* If trust not set then get from purpose default */\n\t\tif (!trust)\n\t\t\ttrust = ptmp->trust;\n\t}\n\tif (trust) {\n\t\tidx = X509_TRUST_get_by_id(trust);\n\t\tif (idx == -1) {\n\t\t\tX509error(X509_R_UNKNOWN_TRUST_ID);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (purpose && !ctx->param->purpose)\n\t\tctx->param->purpose = purpose;\n\tif (trust && !ctx->param->trust)\n\t\tctx->param->trust = trust;\n\treturn 1;\n}\n\nX509_STORE_CTX *\nX509_STORE_CTX_new(void)\n{\n\tX509_STORE_CTX *ctx;\n\n\tctx = calloc(1, sizeof(X509_STORE_CTX));\n\tif (!ctx) {\n\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\treturn NULL;\n\t}\n\treturn ctx;\n}\n\nvoid\nX509_STORE_CTX_free(X509_STORE_CTX *ctx)\n{\n\tif (ctx == NULL)\n\t\treturn;\n\n\tX509_STORE_CTX_cleanup(ctx);\n\tfree(ctx);\n}\n\nint\nX509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509,\n    STACK_OF(X509) *chain)\n{\n\tint param_ret = 1;\n\n\t/*\n\t * Make sure everything is initialized properly even in case of an\n\t * early return due to an error.\n\t *\n\t * While this 'ctx' can be reused, X509_STORE_CTX_cleanup() will have\n\t * freed everything and memset ex_data anyway.  This also allows us\n\t * to safely use X509_STORE_CTX variables from the stack which will\n\t * have uninitialized data.\n\t */\n\tmemset(ctx, 0, sizeof(*ctx));\n\n\t/*\n\t * Start with this set to not valid - it will be set to valid\n\t * in X509_verify_cert.\n\t */\n\tctx->error = X509_V_ERR_INVALID_CALL;\n\n\t/*\n\t * Set values other than 0.  Keep this in the same order as\n\t * X509_STORE_CTX except for values that may fail.  All fields that\n\t * may fail should go last to make sure 'ctx' is as consistent as\n\t * possible even on early exits.\n\t */\n\tctx->store = store;\n\tctx->cert = x509;\n\tctx->untrusted = chain;\n\n\tif (store && store->verify)\n\t\tctx->verify = store->verify;\n\telse\n\t\tctx->verify = internal_verify;\n\n\tif (store && store->verify_cb)\n\t\tctx->verify_cb = store->verify_cb;\n\telse\n\t\tctx->verify_cb = null_callback;\n\n\tif (store && store->get_issuer)\n\t\tctx->get_issuer = store->get_issuer;\n\telse\n\t\tctx->get_issuer = X509_STORE_CTX_get1_issuer;\n\n\tif (store && store->check_issued)\n\t\tctx->check_issued = store->check_issued;\n\telse\n\t\tctx->check_issued = check_issued;\n\n\tif (store && store->check_revocation)\n\t\tctx->check_revocation = store->check_revocation;\n\telse\n\t\tctx->check_revocation = check_revocation;\n\n\tif (store && store->get_crl)\n\t\tctx->get_crl = store->get_crl;\n\telse\n\t\tctx->get_crl = NULL;\n\n\tif (store && store->check_crl)\n\t\tctx->check_crl = store->check_crl;\n\telse\n\t\tctx->check_crl = check_crl;\n\n\tif (store && store->cert_crl)\n\t\tctx->cert_crl = store->cert_crl;\n\telse\n\t\tctx->cert_crl = cert_crl;\n\n\tctx->check_policy = check_policy;\n\n\tif (store && store->lookup_certs)\n\t\tctx->lookup_certs = store->lookup_certs;\n\telse\n\t\tctx->lookup_certs = X509_STORE_get1_certs;\n\n\tif (store && store->lookup_crls)\n\t\tctx->lookup_crls = store->lookup_crls;\n\telse\n\t\tctx->lookup_crls = X509_STORE_get1_crls;\n\n\tif (store && store->cleanup)\n\t\tctx->cleanup = store->cleanup;\n\telse\n\t\tctx->cleanup = NULL;\n\n\tctx->param = X509_VERIFY_PARAM_new();\n\tif (!ctx->param) {\n\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t}\n\n\t/* Inherit callbacks and flags from X509_STORE if not set\n\t * use defaults.\n\t */\n\tif (store)\n\t\tparam_ret = X509_VERIFY_PARAM_inherit(ctx->param, store->param);\n\telse\n\t\tctx->param->inh_flags |= X509_VP_FLAG_DEFAULT|X509_VP_FLAG_ONCE;\n\n\tif (param_ret)\n\t\tparam_ret = X509_VERIFY_PARAM_inherit(ctx->param,\n\t\t    X509_VERIFY_PARAM_lookup(\"default\"));\n\n\tif (param_ret == 0) {\n\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t}\n\n\tif (CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx,\n\t    &(ctx->ex_data)) == 0) {\n\t\tX509error(ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* Set alternative lookup method: just a STACK of trusted certificates.\n * This avoids X509_STORE nastiness where it isn't needed.\n */\n\nvoid\nX509_STORE_CTX_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)\n{\n\tctx->other_ctx = sk;\n\tctx->get_issuer = get_issuer_sk;\n}\n\nvoid\nX509_STORE_CTX_set0_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)\n{\n\tX509_STORE_CTX_trusted_stack(ctx, sk);\n}\n\nvoid\nX509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)\n{\n\tif (ctx->cleanup)\n\t\tctx->cleanup(ctx);\n\tif (ctx->param != NULL) {\n\t\tif (ctx->parent == NULL)\n\t\t\tX509_VERIFY_PARAM_free(ctx->param);\n\t\tctx->param = NULL;\n\t}\n\tif (ctx->tree != NULL) {\n\t\tX509_policy_tree_free(ctx->tree);\n\t\tctx->tree = NULL;\n\t}\n\tif (ctx->chain != NULL) {\n\t\tsk_X509_pop_free(ctx->chain, X509_free);\n\t\tctx->chain = NULL;\n\t}\n\tCRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX,\n\t    ctx, &(ctx->ex_data));\n\tmemset(&ctx->ex_data, 0, sizeof(CRYPTO_EX_DATA));\n}\n\nvoid\nX509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth)\n{\n\tX509_VERIFY_PARAM_set_depth(ctx->param, depth);\n}\n\nvoid\nX509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, unsigned long flags)\n{\n\tX509_VERIFY_PARAM_set_flags(ctx->param, flags);\n}\n\nvoid\nX509_STORE_CTX_set_time(X509_STORE_CTX *ctx, unsigned long flags, time_t t)\n{\n\tX509_VERIFY_PARAM_set_time(ctx->param, t);\n}\n\nint\n(*X509_STORE_CTX_get_verify_cb(X509_STORE_CTX *ctx))(int, X509_STORE_CTX *)\n{\n\treturn ctx->verify_cb;\n}\n\nvoid\nX509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,\n    int (*verify_cb)(int, X509_STORE_CTX *))\n{\n\tctx->verify_cb = verify_cb;\n}\n\nint\n(*X509_STORE_CTX_get_verify(X509_STORE_CTX *ctx))(X509_STORE_CTX *)\n{\n\treturn ctx->verify;\n}\n\nvoid\nX509_STORE_CTX_set_verify(X509_STORE_CTX *ctx, int (*verify)(X509_STORE_CTX *))\n{\n\tctx->verify = verify;\n}\n\nX509 *\nX509_STORE_CTX_get0_cert(X509_STORE_CTX *ctx)\n{\n\treturn ctx->cert;\n}\n\nSTACK_OF(X509) *\nX509_STORE_CTX_get0_untrusted(X509_STORE_CTX *ctx)\n{\n\treturn ctx->untrusted;\n}\n\nvoid\nX509_STORE_CTX_set0_untrusted(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)\n{\n\tctx->untrusted = sk;\n}\n\nvoid\nX509_STORE_CTX_set0_verified_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)\n{\n\tsk_X509_pop_free(ctx->chain, X509_free);\n\tctx->chain = sk;\n}\n\nX509_POLICY_TREE *\nX509_STORE_CTX_get0_policy_tree(X509_STORE_CTX *ctx)\n{\n\treturn ctx->tree;\n}\n\nint\nX509_STORE_CTX_get_explicit_policy(X509_STORE_CTX *ctx)\n{\n\treturn ctx->explicit_policy;\n}\n\nint\nX509_STORE_CTX_get_num_untrusted(X509_STORE_CTX *ctx)\n{\n\treturn ctx->num_untrusted;\n}\n\nint\nX509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name)\n{\n\tconst X509_VERIFY_PARAM *param;\n\tparam = X509_VERIFY_PARAM_lookup(name);\n\tif (!param)\n\t\treturn 0;\n\treturn X509_VERIFY_PARAM_inherit(ctx->param, param);\n}\n\nX509_VERIFY_PARAM *\nX509_STORE_CTX_get0_param(X509_STORE_CTX *ctx)\n{\n\treturn ctx->param;\n}\n\nvoid\nX509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param)\n{\n\tif (ctx->param)\n\t\tX509_VERIFY_PARAM_free(ctx->param);\n\tctx->param = param;\n}\n"], "filenames": ["lib/libcrypto/x509/x509_internal.h", "lib/libcrypto/x509/x509_verify.c", "lib/libcrypto/x509/x509_vfy.c"], "buggy_code_start_loc": [1, 1, 1], "buggy_code_end_loc": [96, 1225, 1994], "fixing_code_start_loc": [1, 1, 1], "fixing_code_end_loc": [96, 1263, 1998], "type": "CWE-295", "message": "x509/x509_verify.c in LibreSSL before 3.4.2, and OpenBSD before 7.0 errata 006, allows authentication bypass because an error for an unverified certificate chain is sometimes discarded.", "other": {"cve": {"id": "CVE-2021-46880", "sourceIdentifier": "cve@mitre.org", "published": "2023-04-15T00:15:07.410", "lastModified": "2023-05-17T20:15:09.333", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "x509/x509_verify.c in LibreSSL before 3.4.2, and OpenBSD before 7.0 errata 006, allows authentication bypass because an error for an unverified certificate chain is sometimes discarded."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:libressl:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.4.2", "matchCriteriaId": "FAD1B673-A6C5-4673-8ACC-FF31DA3A0531"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.0", "matchCriteriaId": "450E9581-FED9-4CFC-B636-170E52A5071F"}]}]}], "references": [{"url": "https://ftp.openbsd.org/pub/OpenBSD/LibreSSL/libressl-3.4.2-relnotes.txt", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://ftp.openbsd.org/pub/OpenBSD/patches/7.0/common/006_x509.patch.sig", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/openbsd/src/commit/3f851282810fa0ab4b90b3b1ecec2e8717ef16f8", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security.netapp.com/advisory/ntap-20230517-0006/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/openbsd/src/commit/3f851282810fa0ab4b90b3b1ecec2e8717ef16f8"}}