{"buggy_code": ["package server\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v4\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/usememos/memos/common\"\n\t\"github.com/usememos/memos/server/auth\"\n\t\"github.com/usememos/memos/store\"\n)\n\nconst (\n\t// Context section\n\t// The key name used to store user id in the context\n\t// user id is extracted from the jwt token subject field.\n\tuserIDContextKey = \"user-id\"\n)\n\nfunc getUserIDContextKey() string {\n\treturn userIDContextKey\n}\n\n// Claims creates a struct that will be encoded to a JWT.\n// We add jwt.RegisteredClaims as an embedded type, to provide fields such as name.\ntype Claims struct {\n\tName string `json:\"name\"`\n\tjwt.RegisteredClaims\n}\n\nfunc extractTokenFromHeader(c echo.Context) (string, error) {\n\tauthHeader := c.Request().Header.Get(\"Authorization\")\n\tif authHeader == \"\" {\n\t\treturn \"\", nil\n\t}\n\n\tauthHeaderParts := strings.Fields(authHeader)\n\tif len(authHeaderParts) != 2 || strings.ToLower(authHeaderParts[0]) != \"bearer\" {\n\t\treturn \"\", errors.New(\"Authorization header format must be Bearer {token}\")\n\t}\n\n\treturn authHeaderParts[1], nil\n}\n\nfunc findAccessToken(c echo.Context) string {\n\taccessToken := \"\"\n\tcookie, _ := c.Cookie(auth.AccessTokenCookieName)\n\tif cookie != nil {\n\t\taccessToken = cookie.Value\n\t}\n\tif accessToken == \"\" {\n\t\taccessToken, _ = extractTokenFromHeader(c)\n\t}\n\n\treturn accessToken\n}\n\nfunc audienceContains(audience jwt.ClaimStrings, token string) bool {\n\tfor _, v := range audience {\n\t\tif v == token {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// JWTMiddleware validates the access token.\n// If the access token is about to expire or has expired and the request has a valid refresh token, it\n// will try to generate new access token and refresh token.\nfunc JWTMiddleware(server *Server, next echo.HandlerFunc, secret string) echo.HandlerFunc {\n\treturn func(c echo.Context) error {\n\t\tpath := c.Request().URL.Path\n\t\tmethod := c.Request().Method\n\n\t\tif server.defaultAuthSkipper(c) {\n\t\t\treturn next(c)\n\t\t}\n\n\t\t// Skip validation for server status endpoints.\n\t\tif common.HasPrefixes(path, \"/api/ping\", \"/api/v1/idp\", \"/api/user/:id\") && method == http.MethodGet {\n\t\t\treturn next(c)\n\t\t}\n\n\t\ttoken := findAccessToken(c)\n\t\tif token == \"\" {\n\t\t\t// Allow the user to access the public endpoints.\n\t\t\tif common.HasPrefixes(path, \"/o\") {\n\t\t\t\treturn next(c)\n\t\t\t}\n\t\t\t// When the request is not authenticated, we allow the user to access the memo endpoints for those public memos.\n\t\t\tif common.HasPrefixes(path, \"/api/status\", \"/api/memo\") && method == http.MethodGet {\n\t\t\t\treturn next(c)\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing access token\")\n\t\t}\n\n\t\tclaims := &Claims{}\n\t\taccessToken, err := jwt.ParseWithClaims(token, claims, func(t *jwt.Token) (any, error) {\n\t\t\tif t.Method.Alg() != jwt.SigningMethodHS256.Name {\n\t\t\t\treturn nil, errors.Errorf(\"unexpected access token signing method=%v, expect %v\", t.Header[\"alg\"], jwt.SigningMethodHS256)\n\t\t\t}\n\t\t\tif kid, ok := t.Header[\"kid\"].(string); ok {\n\t\t\t\tif kid == \"v1\" {\n\t\t\t\t\treturn []byte(secret), nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, errors.Errorf(\"unexpected access token kid=%v\", t.Header[\"kid\"])\n\t\t})\n\t\tif !audienceContains(claims.Audience, auth.AccessTokenAudienceName) {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(\"Invalid access token, audience mismatch, got %q, expected %q.\", claims.Audience, auth.AccessTokenAudienceName))\n\t\t}\n\t\tgenerateToken := time.Until(claims.ExpiresAt.Time) < auth.RefreshThresholdDuration\n\t\tif err != nil {\n\t\t\tvar ve *jwt.ValidationError\n\t\t\tif errors.As(err, &ve) {\n\t\t\t\t// If expiration error is the only error, we will clear the err\n\t\t\t\t// and generate new access token and refresh token\n\t\t\t\tif ve.Errors == jwt.ValidationErrorExpired {\n\t\t\t\t\tgenerateToken = true\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, errors.Wrap(err, \"Invalid or expired access token\"))\n\t\t\t}\n\t\t}\n\n\t\t// We either have a valid access token or we will attempt to generate new access token and refresh token\n\t\tctx := c.Request().Context()\n\t\tuserID, err := strconv.Atoi(claims.Subject)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Malformed ID in the token.\")\n\t\t}\n\n\t\t// Even if there is no error, we still need to make sure the user still exists.\n\t\tuser, err := server.Store.GetUser(ctx, &store.FindUserMessage{\n\t\t\tID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Server error to find user ID: %d\", userID)).SetInternal(err)\n\t\t}\n\t\tif user == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(\"Failed to find user ID: %d\", userID))\n\t\t}\n\n\t\tif generateToken {\n\t\t\tgenerateTokenFunc := func() error {\n\t\t\t\trc, err := c.Cookie(auth.RefreshTokenCookieName)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Failed to generate access token. Missing refresh token.\")\n\t\t\t\t}\n\n\t\t\t\t// Parses token and checks if it's valid.\n\t\t\t\trefreshTokenClaims := &Claims{}\n\t\t\t\trefreshToken, err := jwt.ParseWithClaims(rc.Value, refreshTokenClaims, func(t *jwt.Token) (any, error) {\n\t\t\t\t\tif t.Method.Alg() != jwt.SigningMethodHS256.Name {\n\t\t\t\t\t\treturn nil, errors.Errorf(\"unexpected refresh token signing method=%v, expected %v\", t.Header[\"alg\"], jwt.SigningMethodHS256)\n\t\t\t\t\t}\n\n\t\t\t\t\tif kid, ok := t.Header[\"kid\"].(string); ok {\n\t\t\t\t\t\tif kid == \"v1\" {\n\t\t\t\t\t\t\treturn []byte(secret), nil\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn nil, errors.Errorf(\"unexpected refresh token kid=%v\", t.Header[\"kid\"])\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\tif err == jwt.ErrSignatureInvalid {\n\t\t\t\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Failed to generate access token. Invalid refresh token signature.\")\n\t\t\t\t\t}\n\t\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Server error to refresh expired token. User Id %d\", userID)).SetInternal(err)\n\t\t\t\t}\n\n\t\t\t\tif !audienceContains(refreshTokenClaims.Audience, auth.RefreshTokenAudienceName) {\n\t\t\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized,\n\t\t\t\t\t\tfmt.Sprintf(\"Invalid refresh token, audience mismatch, got %q, expected %q. you may send request to the wrong environment\",\n\t\t\t\t\t\t\trefreshTokenClaims.Audience,\n\t\t\t\t\t\t\tauth.RefreshTokenAudienceName,\n\t\t\t\t\t\t))\n\t\t\t\t}\n\n\t\t\t\t// If we have a valid refresh token, we will generate new access token and refresh token\n\t\t\t\tif refreshToken != nil && refreshToken.Valid {\n\t\t\t\t\tif err := auth.GenerateTokensAndSetCookies(c, user, secret); err != nil {\n\t\t\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Server error to refresh expired token. User Id %d\", userID)).SetInternal(err)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// It may happen that we still have a valid access token, but we encounter issue when trying to generate new token\n\t\t\t// In such case, we won't return the error.\n\t\t\tif err := generateTokenFunc(); err != nil && !accessToken.Valid {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// Stores userID into context.\n\t\tc.Set(getUserIDContextKey(), userID)\n\t\treturn next(c)\n\t}\n}\n"], "fixing_code": ["package server\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v4\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/usememos/memos/common\"\n\t\"github.com/usememos/memos/server/auth\"\n\t\"github.com/usememos/memos/store\"\n)\n\nconst (\n\t// Context section\n\t// The key name used to store user id in the context\n\t// user id is extracted from the jwt token subject field.\n\tuserIDContextKey = \"user-id\"\n)\n\nfunc getUserIDContextKey() string {\n\treturn userIDContextKey\n}\n\n// Claims creates a struct that will be encoded to a JWT.\n// We add jwt.RegisteredClaims as an embedded type, to provide fields such as name.\ntype Claims struct {\n\tName string `json:\"name\"`\n\tjwt.RegisteredClaims\n}\n\nfunc extractTokenFromHeader(c echo.Context) (string, error) {\n\tauthHeader := c.Request().Header.Get(\"Authorization\")\n\tif authHeader == \"\" {\n\t\treturn \"\", nil\n\t}\n\n\tauthHeaderParts := strings.Fields(authHeader)\n\tif len(authHeaderParts) != 2 || strings.ToLower(authHeaderParts[0]) != \"bearer\" {\n\t\treturn \"\", errors.New(\"Authorization header format must be Bearer {token}\")\n\t}\n\n\treturn authHeaderParts[1], nil\n}\n\nfunc findAccessToken(c echo.Context) string {\n\taccessToken := \"\"\n\tcookie, _ := c.Cookie(auth.AccessTokenCookieName)\n\tif cookie != nil {\n\t\taccessToken = cookie.Value\n\t}\n\tif accessToken == \"\" {\n\t\taccessToken, _ = extractTokenFromHeader(c)\n\t}\n\n\treturn accessToken\n}\n\nfunc audienceContains(audience jwt.ClaimStrings, token string) bool {\n\tfor _, v := range audience {\n\t\tif v == token {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// JWTMiddleware validates the access token.\n// If the access token is about to expire or has expired and the request has a valid refresh token, it\n// will try to generate new access token and refresh token.\nfunc JWTMiddleware(server *Server, next echo.HandlerFunc, secret string) echo.HandlerFunc {\n\treturn func(c echo.Context) error {\n\t\tpath := c.Request().URL.Path\n\t\tmethod := c.Request().Method\n\n\t\tif server.defaultAuthSkipper(c) {\n\t\t\treturn next(c)\n\t\t}\n\n\t\t// Skip validation for server status endpoints.\n\t\tif common.HasPrefixes(path, \"/api/ping\", \"/api/v1/idp\", \"/api/user/:id\") && method == http.MethodGet {\n\t\t\treturn next(c)\n\t\t}\n\n\t\ttoken := findAccessToken(c)\n\t\tif token == \"\" {\n\t\t\t// Allow the user to access the public endpoints.\n\t\t\tif common.HasPrefixes(path, \"/o\") {\n\t\t\t\treturn next(c)\n\t\t\t}\n\t\t\t// When the request is not authenticated, we allow the user to access the memo endpoints for those public memos.\n\t\t\tif common.HasPrefixes(path, \"/api/status\", \"/api/memo\") && method == http.MethodGet {\n\t\t\t\treturn next(c)\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing access token\")\n\t\t}\n\n\t\tclaims := &Claims{}\n\t\taccessToken, err := jwt.ParseWithClaims(token, claims, func(t *jwt.Token) (any, error) {\n\t\t\tif t.Method.Alg() != jwt.SigningMethodHS256.Name {\n\t\t\t\treturn nil, errors.Errorf(\"unexpected access token signing method=%v, expect %v\", t.Header[\"alg\"], jwt.SigningMethodHS256)\n\t\t\t}\n\t\t\tif kid, ok := t.Header[\"kid\"].(string); ok {\n\t\t\t\tif kid == \"v1\" {\n\t\t\t\t\treturn []byte(secret), nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, errors.Errorf(\"unexpected access token kid=%v\", t.Header[\"kid\"])\n\t\t})\n\n\t\tif !accessToken.Valid {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Invalid access token.\")\n\t\t}\n\n\t\tif !audienceContains(claims.Audience, auth.AccessTokenAudienceName) {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(\"Invalid access token, audience mismatch, got %q, expected %q.\", claims.Audience, auth.AccessTokenAudienceName))\n\t\t}\n\t\tgenerateToken := time.Until(claims.ExpiresAt.Time) < auth.RefreshThresholdDuration\n\t\tif err != nil {\n\t\t\tvar ve *jwt.ValidationError\n\t\t\tif errors.As(err, &ve) {\n\t\t\t\t// If expiration error is the only error, we will clear the err\n\t\t\t\t// and generate new access token and refresh token\n\t\t\t\tif ve.Errors == jwt.ValidationErrorExpired {\n\t\t\t\t\tgenerateToken = true\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, errors.Wrap(err, \"Invalid or expired access token\"))\n\t\t\t}\n\t\t}\n\n\t\t// We either have a valid access token or we will attempt to generate new access token and refresh token\n\t\tctx := c.Request().Context()\n\t\tuserID, err := strconv.Atoi(claims.Subject)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Malformed ID in the token.\")\n\t\t}\n\n\t\t// Even if there is no error, we still need to make sure the user still exists.\n\t\tuser, err := server.Store.GetUser(ctx, &store.FindUserMessage{\n\t\t\tID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Server error to find user ID: %d\", userID)).SetInternal(err)\n\t\t}\n\t\tif user == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(\"Failed to find user ID: %d\", userID))\n\t\t}\n\n\t\tif generateToken {\n\t\t\tgenerateTokenFunc := func() error {\n\t\t\t\trc, err := c.Cookie(auth.RefreshTokenCookieName)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Failed to generate access token. Missing refresh token.\")\n\t\t\t\t}\n\n\t\t\t\t// Parses token and checks if it's valid.\n\t\t\t\trefreshTokenClaims := &Claims{}\n\t\t\t\trefreshToken, err := jwt.ParseWithClaims(rc.Value, refreshTokenClaims, func(t *jwt.Token) (any, error) {\n\t\t\t\t\tif t.Method.Alg() != jwt.SigningMethodHS256.Name {\n\t\t\t\t\t\treturn nil, errors.Errorf(\"unexpected refresh token signing method=%v, expected %v\", t.Header[\"alg\"], jwt.SigningMethodHS256)\n\t\t\t\t\t}\n\n\t\t\t\t\tif kid, ok := t.Header[\"kid\"].(string); ok {\n\t\t\t\t\t\tif kid == \"v1\" {\n\t\t\t\t\t\t\treturn []byte(secret), nil\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn nil, errors.Errorf(\"unexpected refresh token kid=%v\", t.Header[\"kid\"])\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\tif err == jwt.ErrSignatureInvalid {\n\t\t\t\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Failed to generate access token. Invalid refresh token signature.\")\n\t\t\t\t\t}\n\t\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Server error to refresh expired token. User Id %d\", userID)).SetInternal(err)\n\t\t\t\t}\n\n\t\t\t\tif !audienceContains(refreshTokenClaims.Audience, auth.RefreshTokenAudienceName) {\n\t\t\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized,\n\t\t\t\t\t\tfmt.Sprintf(\"Invalid refresh token, audience mismatch, got %q, expected %q. you may send request to the wrong environment\",\n\t\t\t\t\t\t\trefreshTokenClaims.Audience,\n\t\t\t\t\t\t\tauth.RefreshTokenAudienceName,\n\t\t\t\t\t\t))\n\t\t\t\t}\n\n\t\t\t\t// If we have a valid refresh token, we will generate new access token and refresh token\n\t\t\t\tif refreshToken != nil && refreshToken.Valid {\n\t\t\t\t\tif err := auth.GenerateTokensAndSetCookies(c, user, secret); err != nil {\n\t\t\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Server error to refresh expired token. User Id %d\", userID)).SetInternal(err)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// It may happen that we still have a valid access token, but we encounter issue when trying to generate new token\n\t\t\t// In such case, we won't return the error.\n\t\t\tif err := generateTokenFunc(); err != nil && !accessToken.Valid {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// Stores userID into context.\n\t\tc.Set(getUserIDContextKey(), userID)\n\t\treturn next(c)\n\t}\n}\n"], "filenames": ["server/jwt.go"], "buggy_code_start_loc": [113], "buggy_code_end_loc": [113], "fixing_code_start_loc": [114], "fixing_code_end_loc": [119], "type": "CWE-20", "message": "Improper Input Validation in GitHub repository usememos/memos prior to 0.13.2.", "other": {"cve": {"id": "CVE-2023-4698", "sourceIdentifier": "security@huntr.dev", "published": "2023-09-01T01:15:09.437", "lastModified": "2023-09-01T13:07:30.360", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Input Validation in GitHub repository usememos/memos prior to 0.13.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:usememos:memos:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.13.2", "matchCriteriaId": "F64C568E-3AC2-440A-894D-5946C0AD9C3D"}]}]}], "references": [{"url": "https://github.com/usememos/memos/commit/c9aa2eeb9852047e4f41915eb30726bd25f07ecd", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/e1107d79-1d63-4238-90b7-5cc150512654", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/usememos/memos/commit/c9aa2eeb9852047e4f41915eb30726bd25f07ecd"}}