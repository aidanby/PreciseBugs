{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki;\n\nimport java.io.UnsupportedEncodingException;\nimport java.io.File;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.net.InetAddress;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.InvocationTargetException;\nimport java.io.IOException;\n\nimport org.apache.commons.net.smtp.SMTPClient;\nimport org.apache.commons.net.smtp.SMTPReply;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.reflect.MethodUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.xwiki.cache.CacheException;\nimport org.xwiki.cache.CacheFactory;\nimport org.xwiki.cache.CacheManager;\nimport org.xwiki.cache.config.CacheConfiguration;\nimport org.xwiki.cache.eviction.LRUEvictionConfiguration;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.environment.Environment;\nimport org.xwiki.rendering.configuration.ExtendedRenderingConfiguration;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.xml.XMLUtils;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.url.XWikiEntityURL;\nimport org.xwiki.wiki.manager.WikiManagerException;\nimport org.xwiki.wiki.descriptor.WikiDescriptor;\nimport org.xwiki.wiki.descriptor.WikiDescriptorManager;\n\nimport com.xpn.xwiki.cache.api.XWikiCache;\nimport com.xpn.xwiki.cache.api.XWikiCacheService;\nimport com.xpn.xwiki.cache.api.internal.XWikiCacheServiceStub;\nimport com.xpn.xwiki.cache.api.internal.XWikiCacheStub;\nimport com.xpn.xwiki.cache.api.internal.XWikiInitializedWikiCacheStub;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.notify.XWikiNotificationManager;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.plugin.query.XWikiCriteria;\nimport com.xpn.xwiki.plugin.query.XWikiQuery;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiMessageTool;\nimport com.xpn.xwiki.web.XWikiRequest;\n\n/**\n * Add a backward compatibility layer to the {@link com.xpn.xwiki.XWiki} class.\n * \n * @version $Id$\n */\npublic privileged aspect XWikiCompatibilityAspect\n{\n    private static Map XWiki.threadMap = new HashMap();\n\n    private XWikiNotificationManager XWiki.notificationManager;\n\n    private EntityReferenceResolver<EntityReference> XWiki.defaultReferenceEntityReferenceResolver = Utils.getComponent(\n        EntityReferenceResolver.TYPE_REFERENCE);\n    \n    /**\n     * Used to get the temporary and permanent directory.\n     */\n    private Environment XWiki.environment = Utils.getComponent((Type) Environment.class);\n\n    /** Is the wiki running in test mode? Deprecated, was used when running Cactus tests. */\n    private boolean XWiki.test = false;\n\n    /** List of configured syntax ids. */\n    private List<String> XWiki.configuredSyntaxes;\n\n    /**\n     * Transform a text in a URL compatible text\n     *\n     * @param content text to transform\n     * @return encoded result\n     * @deprecated replaced by Util#encodeURI since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.getURLEncoded(String content)\n    {\n        try {\n            return URLEncoder.encode(content, this.getEncoding());\n        } catch (UnsupportedEncodingException e) {\n            return content;\n        }\n    }\n\n    /**\n     * @return true for multi-wiki/false for mono-wiki\n     * @deprecated replaced by {@link XWiki#isVirtualMode()} since 1.4M1.\n     */\n    @Deprecated\n    public boolean XWiki.isVirtual()\n    {\n        return isVirtualMode();\n    }\n\n    /**\n     * @deprecated Virtual mode is on by default, starting with XWiki 5.0M2. Use\n     *             {@link #getVirtualWikisDatabaseNames(XWikiContext)} to get the list of wikis if needed.\n     * @return true for multi-wiki/false for mono-wiki\n     */\n    @Deprecated\n    public boolean XWiki.isVirtualMode()\n    {\n        return true;\n    }\n\n    /**\n     * @deprecated Removed since it isn't used; since 1.5M1.\n     */\n    @Deprecated\n    public static Map XWiki.getThreadMap()\n    {\n        return XWiki.threadMap;\n    }\n\n    /**\n     * @deprecated Removed since it isn't used; since 1.5M1.\n     */\n    @Deprecated\n    public static void XWiki.setThreadMap(Map threadMap)\n    {\n        XWiki.threadMap = threadMap;\n    }\n\n    /**\n     * @return the cache service.\n     * @deprecated replaced by {@link XWiki#getCacheFactory(XWikiContext)} or\n     *             {@link XWiki#getLocalCacheFactory(XWikiContext)} since 1.5M2.\n     */\n    @Deprecated\n    public XWikiCacheService XWiki.getCacheService()\n    {\n        return new XWikiCacheServiceStub(getCacheFactory(), getLocalCacheFactory());\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getVirtualWikiCache(XWikiContext)} since 1.5M2.\n     */\n    @Deprecated\n    public XWikiCache XWiki.getVirtualWikiMap()\n    {\n        return new XWikiInitializedWikiCacheStub(this.initializedWikis);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpaceCopyright(XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebCopyright(XWikiContext context)\n    {\n        return this.getSpaceCopyright(context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreference(String, XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebPreference(String preference, XWikiContext context)\n    {\n        return this.getSpacePreference(preference, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreference(String, String, XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebPreference(String preference, String defaultValue, XWikiContext context)\n    {\n        return this.getSpacePreference(preference, defaultValue, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreference(String, String, String, XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebPreference(String preference, String space, String defaultValue, XWikiContext context)\n    {\n        return this.getSpacePreference(preference, space, defaultValue, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsLong(String, XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public long XWiki.getWebPreferenceAsLong(String preference, XWikiContext context)\n    {\n        return this.getSpacePreferenceAsLong(preference, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsLong(String, long, XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public long XWiki.getWebPreferenceAsLong(String preference, long defaultValue, XWikiContext context)\n    {\n        return this.getSpacePreferenceAsLong(preference, defaultValue, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsInt(String, XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public int XWiki.getWebPreferenceAsInt(String preference, XWikiContext context)\n    {\n        return this.getSpacePreferenceAsInt(preference, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsInt(String, int, XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public int XWiki.getWebPreferenceAsInt(String preference, int defaultValue, XWikiContext context)\n    {\n        return this.getSpacePreferenceAsInt(preference, defaultValue, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#copySpaceBetweenWikis(String, String, String, String, XWikiContext)} since\n     *             2.3M1\n     */\n    @Deprecated\n    public int XWiki.copyWikiWeb(String space, String sourceWiki, String targetWiki, String language, XWikiContext context)\n        throws XWikiException\n    {\n        return this.copySpaceBetweenWikis(space, sourceWiki, targetWiki, language, context);\n    }\n\n    /**\n     * @deprecated replaced by\n     *             {@link XWiki#copySpaceBetweenWikis(String, String, String, String, boolean, XWikiContext)} since\n     *             2.3M1\n     */\n    @Deprecated\n    public int XWiki.copyWikiWeb(String space, String sourceWiki, String targetWiki, String language, boolean clean,\n        XWikiContext context) throws XWikiException\n    {\n        return this.copySpaceBetweenWikis(space, sourceWiki, targetWiki, language, clean, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getDefaultSpace(XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getDefaultWeb(XWikiContext context)\n    {\n        return this.getDefaultSpace(context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#skipDefaultSpaceInURLs(XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public boolean XWiki.useDefaultWeb(XWikiContext context)\n    {\n        return this.skipDefaultSpaceInURLs(context);\n    }\n\n    /**\n     * @deprecated use {@link XWikiMessageTool#get(String, List)} instead. You can access message tool using\n     *             {@link XWikiContext#getMessageTool()}.\n     */\n    @Deprecated\n    public String XWiki.getMessage(String item, XWikiContext context)\n    {\n        XWikiMessageTool msg = context.getMessageTool();\n        if (msg == null) {\n            return item;\n        } else {\n            return msg.get(item);\n        }\n    }\n\n    /**\n     * @deprecated Removed since it isn't used; since 3.1M2.\n     */\n    @Deprecated\n    public String XWiki.getHTMLArea(String content, XWikiContext context)\n    {\n        StringBuilder result = new StringBuilder();\n\n        String scontent = XMLUtils.escape(content);\n        scontent = scontent.replaceAll(\"\\r?+\\n\", \"<br class=\\\"htmlarea\\\"/>\");\n\n        result.append(\"<textarea name=\\\"content\\\" id=\\\"content\\\" rows=\\\"25\\\" cols=\\\"80\\\">\");\n        result.append(scontent);\n        result.append(\"</textarea>\");\n\n        return result.toString();\n    }\n\n    @Deprecated\n    public XWikiNotificationManager XWiki.getNotificationManager()\n    {\n        if (this.notificationManager == null) {\n          this.notificationManager = new XWikiNotificationManager();\n        }\n\n        return this.notificationManager;\n    }\n\n    @Deprecated\n    public void XWiki.setNotificationManager(XWikiNotificationManager notificationManager)\n    {\n        this.notificationManager = notificationManager;\n    }\n    \n    @Deprecated\n    public String XWiki.displaySearch(String fieldname, String className, XWikiCriteria criteria, XWikiContext context)\n        throws XWikiException\n    {\n        return displaySearch(fieldname, className, \"\", criteria, context);\n    }\n\n    @Deprecated\n    public String XWiki.displaySearch(String fieldname, String className, XWikiContext context) throws XWikiException\n    {\n        return displaySearch(fieldname, className, \"\", new XWikiCriteria(), context);\n    }\n\n    @Deprecated\n    public String XWiki.displaySearch(String fieldname, String className, String prefix, XWikiCriteria criteria,\n        XWikiContext context) throws XWikiException\n    {\n        BaseClass bclass = getDocument(className, context).getXClass();\n        PropertyClass pclass = (PropertyClass) bclass.get(fieldname);\n        if (criteria == null) {\n            criteria = new XWikiCriteria();\n        }\n\n        if (pclass == null) {\n            return \"\";\n        } else {\n            return pclass.displaySearch(fieldname, prefix + className + \"_\", criteria, context);\n        }\n    }\n\n    @Deprecated\n    public String XWiki.displaySearchColumns(String className, XWikiQuery query, XWikiContext context) throws XWikiException\n    {\n        return displaySearchColumns(className, \"\", query, context);\n    }\n\n    @Deprecated\n    public String XWiki.displaySearchColumns(String className, String prefix, XWikiQuery query, XWikiContext context)\n        throws XWikiException\n    {\n        BaseClass bclass = getDocument(className, context).getXClass();\n\n        if (query == null) {\n            query = new XWikiQuery();\n        }\n\n        return bclass.displaySearchColumns(className + \"_\" + prefix, query, context);\n    }\n\n    @Deprecated\n    public String XWiki.displaySearchOrder(String className, XWikiQuery query, XWikiContext context) throws XWikiException\n    {\n        return displaySearchOrder(className, \"\", query, context);\n    }\n\n    @Deprecated\n    public String XWiki.displaySearchOrder(String className, String prefix, XWikiQuery query, XWikiContext context)\n        throws XWikiException\n    {\n        BaseClass bclass = getDocument(className, context).getXClass();\n\n        if (query == null) {\n            query = new XWikiQuery();\n        }\n\n        return bclass.displaySearchOrder(className + \"_\" + prefix, query, context);\n    }\n\n    @Deprecated\n    public <T> List<T> XWiki.search(XWikiQuery query, XWikiContext context) throws XWikiException\n    {\n        Object qp = getPlugin(\"query\", context);\n        if (qp == null) {\n            return null;\n        }\n\n        try {\n            return (List<T>) MethodUtils.invokeMethod(qp, \"search\", query);\n        } catch (Exception e) {\n            throw new XWikiException(\"Failed to execute search\", e);\n        }\n    }\n\n    @Deprecated\n    public XWikiQuery XWiki.createQueryFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return new XWikiQuery(context.getRequest(), className, context);\n    }\n\n    @Deprecated\n    public String XWiki.searchAsTable(XWikiQuery query, XWikiContext context) throws XWikiException\n    {\n        Object qp = getPlugin(\"query\", context);\n        if (qp == null) {\n            return null;\n        }\n\n        List<String> list;\n        try {\n            list = (List<String>) MethodUtils.invokeMethod(qp, \"search\", query);\n        } catch (Exception e) {\n            throw new XWikiException(\"Failed to execute search\", e);\n        }\n\n        String result = \"{table}\\r\\n\";\n        List<String> headerColumns = new ArrayList<String>();\n        List<String> displayProperties = query.getDisplayProperties();\n        for (String propname : displayProperties) {\n            PropertyClass pclass = getPropertyClassFromName(propname, context);\n            if (pclass != null) {\n                headerColumns.add(pclass.getPrettyName());\n            } else {\n                if (propname.startsWith(\"doc.\")) {\n                    propname = propname.substring(4);\n                    headerColumns.add(XWikiDocument.getInternalPropertyName(propname, context));\n                } else {\n                    headerColumns.add(propname);\n                }\n\n            }\n        }\n\n        result += StringUtils.join(headerColumns.toArray(), \" | \") + \"\\r\\n\";\n        for (String docname : list) {\n            List<String> rowColumns = new ArrayList<String>();\n            XWikiDocument doc = getDocument(docname, context);\n            for (String propname : displayProperties) {\n                PropertyClass pclass = getPropertyClassFromName(propname, context);\n                if (pclass == null) {\n                    if (propname.startsWith(\"doc.\")) {\n                        propname = propname.substring(4);\n                    }\n                    String value = doc.getInternalProperty(propname);\n                    rowColumns.add((value == null) ? \" \" : value);\n                } else {\n                    BaseObject bobj = doc.getObject(pclass.getObject().getName());\n                    rowColumns.add(doc.display(pclass.getName(), \"view\", bobj, context));\n                }\n            }\n            result += StringUtils.join(rowColumns.toArray(), \" | \") + \"\\r\\n\";\n        }\n\n        result += \"{table}\\r\\n\";\n\n        return result;\n    }\n\n    @Deprecated\n    public String XWiki.getDocLanguagePreference(XWikiContext context)\n    {\n        return getLanguagePreference(context);\n    }\n\n    @Deprecated\n    public void XWiki.flushCache()\n    {\n        Execution execution = Utils.getComponent(Execution.class);\n\n        ExecutionContext ec = execution.getContext();\n\n        flushCache(ec != null ? (XWikiContext) ec.getProperty(\"xwikicontext\") : null);\n    }\n\n    /**\n     * @deprecated use WikiManager plugin instead\n     */\n    @Deprecated\n    public int XWiki.createNewWiki(String wikiName, String wikiUrl, String wikiAdmin, String baseWikiName,\n        String description, String wikilanguage, boolean failOnExist, XWikiContext context) throws XWikiException\n    {\n        String database = context.getDatabase();\n        wikiName = wikiName.toLowerCase();\n\n        try {\n            XWikiDocument userdoc = getDocument(wikiAdmin, context);\n\n            // User does not exist\n            if (userdoc.isNew()) {\n                if (LOGGER.isErrorEnabled()) {\n                    LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                        + \"user does not exist\");\n                }\n                return -2;\n            }\n\n            // User is not active\n            if (!(userdoc.getIntValue(\"XWiki.XWikiUsers\", \"active\") == 1)) {\n                if (LOGGER.isErrorEnabled()) {\n                    LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                        + \"user is not active\");\n                }\n                return -3;\n            }\n\n            String wikiForbiddenList = Param(\"xwiki.virtual.reserved_wikis\");\n            if (Util.contains(wikiName, wikiForbiddenList, \", \")) {\n                if (LOGGER.isErrorEnabled()) {\n                    LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                        + \"wiki name is forbidden\");\n                }\n                return -4;\n            }\n\n            String wikiServerPage = \"XWikiServer\" + wikiName.substring(0, 1).toUpperCase() + wikiName.substring(1);\n            // Verify is server page already exist\n            XWikiDocument serverdoc = getDocument(SYSTEM_SPACE, wikiServerPage, context);\n            if (serverdoc.isNew()) {\n                // Create Wiki Server page\n                serverdoc.setStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"server\", wikiUrl);\n                serverdoc.setStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"owner\", wikiAdmin);\n                if (description != null) {\n                    serverdoc.setLargeStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"description\", description);\n                }\n                if (wikilanguage != null) {\n                    serverdoc.setStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"language\", wikilanguage);\n                }\n                if (!getDefaultDocumentSyntax().equals(Syntax.XWIKI_1_0.toIdString())) {\n                    serverdoc.setContent(\"{{include document=\\\"XWiki.XWikiServerForm\\\"/}}\\n\");\n                    serverdoc.setSyntax(Syntax.XWIKI_2_0);\n                } else {\n                    serverdoc.setContent(\"#includeForm(\\\"XWiki.XWikiServerForm\\\")\\n\");\n                    serverdoc.setSyntax(Syntax.XWIKI_1_0);\n                }\n                serverdoc.setParentReference(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE);\n                saveDocument(serverdoc, context);\n            } else {\n                // If we are not allowed to continue if server page already exists\n                if (failOnExist) {\n                    if (LOGGER.isErrorEnabled()) {\n                        LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                            + \"wiki server page already exists\");\n                    }\n                    return -5;\n                } else if (LOGGER.isWarnEnabled()) {\n                    LOGGER.warn(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                        + \"wiki server page already exists\");\n                }\n            }\n\n            // Create wiki database\n            try {\n                context.setDatabase(getDatabase());\n                getStore().createWiki(wikiName, context);\n            } catch (XWikiException e) {\n                if (LOGGER.isErrorEnabled()) {\n                    if (e.getCode() == 10010) {\n                        LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                            + \"wiki database already exists\");\n                    } else if (e.getCode() == 10011) {\n                        LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                            + \"wiki database creation failed\");\n                    } else {\n                        LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                            + \"wiki database creation threw exception\", e);\n                    }\n                }\n            } catch (Exception e) {\n                LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                    + \"wiki database creation threw exception\", e);\n            }\n\n            try {\n                updateDatabase(wikiName, true, false, context);\n            } catch (Exception e) {\n                LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                    + \"wiki database shema update threw exception\", e);\n                return -6;\n            }\n\n            // Copy base wiki\n            int nb = copyWiki(baseWikiName, wikiName, wikilanguage, context);\n            // Save the number of docs copied in the context\n            context.put(\"nbdocs\", Integer.valueOf(nb));\n\n            // Create user page in his wiki\n            // Let's not create it anymore.. this makes the creator loose\n            // super admin rights on his wiki\n            // copyDocument(wikiAdmin, getDatabase(), wikiName, wikilanguage, context);\n\n            // Modify rights in user wiki\n            context.setDatabase(wikiName);\n            /*\n             * XWikiDocument wikiprefdoc = getDocument(\"XWiki.XWikiPreferences\", context);\n             * wikiprefdoc.setStringValue(\"XWiki.XWikiGlobalRights\", \"users\", wikiAdmin);\n             * wikiprefdoc.setStringValue(\"XWiki.XWikiGlobalRights\", \"levels\", \"admin, edit\");\n             * wikiprefdoc.setIntValue(\"XWiki.XWikiGlobalRights\", \"allow\", 1); saveDocument(wikiprefdoc, context);\n             */\n            return 1;\n        } catch (Exception e) {\n            LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                + \"wiki creation threw exception\", e);\n            return -10;\n        } finally {\n            context.setDatabase(database);\n        }\n    }\n\n    /**\n     * Get the XWiki temporary filesystem directory (cleaned up automatically by XWiki).\n     *\n     * @param context\n     * @return temporary directory\n     * @since 1.1 Milestone 4\n     * @deprecated starting with 4.2M1 use {@link org.xwiki.environment.Environment#getTemporaryDirectory()}\n     */\n    @Deprecated\n    public File XWiki.getTempDirectory(XWikiContext context)\n    {\n        return this.environment.getTemporaryDirectory();\n    }\n\n    /**\n     * Get a new directory in the xwiki work directory\n     *\n     * @param subdir desired directory name\n     * @param context\n     * @return work subdirectory\n     * @since 1.1 Milestone 4\n     * @deprecated starting with 4.2M1 use {@link org.xwiki.environment.Environment#getPermanentDirectory()}\n     */\n    @Deprecated\n    public File XWiki.getWorkSubdirectory(String subdir, XWikiContext context)\n    {\n        File fdir = new File(this.environment.getPermanentDirectory().getAbsolutePath(), subdir);\n        if (!fdir.exists()) {\n            fdir.mkdir();\n        }\n\n        return fdir;\n    }\n\n    /**\n     * Get the XWiki work directory\n     *\n     * @param context\n     * @return work directory\n     * @since 1.1 Milestone 4\n     * @deprecated starting with 4.2M1 use {@link org.xwiki.environment.Environment#getPermanentDirectory()}\n     */\n    @Deprecated\n    public File XWiki.getWorkDirectory(XWikiContext context)\n    {\n        return this.environment.getPermanentDirectory();\n    }\n\n    /**\n     * @deprecated starting with 5.1M1 use {@code org.xwiki.url.XWikiURLFactory} instead and starting with 5.3M1 use\n     *             {@link ResourceFactory} and since 6.1M2 use {@link org.xwiki.resource.ResourceReferenceResolver}\n     */\n    @Deprecated\n    public XWikiDocument XWiki.getDocumentFromPath(String path, XWikiContext context) throws XWikiException\n    {\n        return getDocument(getDocumentReferenceFromPath(path, context), context);\n    }\n\n    /**\n     * @since 2.3M1\n     * @deprecated starting with 5.1M1 use {@code org.xwiki.url.XWikiURLFactory} instead and starting with 5.3M1 use\n     *             {@link ResourceFactory} and since 6.1M2 use {@link org.xwiki.resource.ResourceReferenceResolver}\n     */\n    @Deprecated\n    public DocumentReference XWiki.getDocumentReferenceFromPath(String path, XWikiContext context)\n    {\n        // TODO: Remove this and use XWikiURLFactory instead in XWikiAction and all entry points.\n        List<String> segments = new ArrayList<String>();\n        for (String segment : path.split(\"/\", -1)) {\n            segments.add(Util.decodeURI(segment, context));\n        }\n        // Remove the first segment if it's empty to cater for cases when the path starts with \"/\"\n        if (segments.size() > 0 && segments.get(0).length() == 0) {\n            segments.remove(0);\n        }\n\n        XWikiEntityURL entityURL = buildEntityURLFromPathSegments(new WikiReference(context.getDatabase()), segments);\n\n        return new DocumentReference(entityURL.getEntityReference().extractReference(EntityType.DOCUMENT));\n    }\n\n    /**\n     * @deprecated since 2.3M1 use {@link #getDocumentReferenceFromPath(String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String XWiki.getDocumentNameFromPath(String path, XWikiContext context)\n    {\n        return getLocalStringEntityReferenceSerializer().serialize(getDocumentReferenceFromPath(path, context));\n    }\n\n    /**\n     * @deprecated since 2.3M1 use {@link #getDocumentReferenceFromPath(String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String XWiki.getDocumentName(XWikiRequest request, XWikiContext context)\n    {\n        return getLocalStringEntityReferenceSerializer().serialize(getDocumentReference(request, context));\n    }\n\n    /**\n     * @deprecated starting with 5.1M1 use {@code org.xwiki.url.XWikiURLFactory} instead and starting with 5.3M1 use\n     *             {@link ResourceFactory} and since 6.1M2 use {@link org.xwiki.resource.ResourceReferenceResolver}\n     */\n    @Deprecated\n    private XWikiEntityURL XWiki.buildEntityURLFromPathSegments(WikiReference wikiReference, List<String> pathSegments)\n    {\n        XWikiEntityURL entityURL;\n\n        // Rules based on counting the url segments:\n        // - 0 segments (e.g. \"\"): default document reference, \"view\" action\n        // - 1 segment (e.g. \"/\", \"/Document\"): default space, specified document (and default if empty), \"view\" action\n        // - 2 segments (e.g. \"/Space/\", \"/Space/Document\"): specified space, document (and default doc if empty),\n        //   \"view\" action\n        // - 3 segments (e.g. \"/action/Space/Document\"): specified space, document (and default doc if empty),\n        //   specified action\n        // - 4 segments (e.g. \"/download/Space/Document/attachment\"): specified space, document and attachment (and\n        //   default doc if empty), \"download\" action\n        // - 4 segments or more (e.g. \"/action/Space/Document/whatever/else\"): specified space, document (and default\n        //     doc if empty), specified \"action\" (if action != \"download\"), trailing segments ignored\n\n        String spaceName = null;\n        String pageName = null;\n        String attachmentName = null;\n        String action = \"view\";\n\n        if (pathSegments.size() == 1) {\n            pageName = pathSegments.get(0);\n        } else if (pathSegments.size() == 2) {\n            spaceName = pathSegments.get(0);\n            pageName = pathSegments.get(1);\n        } else if (pathSegments.size() >= 3) {\n            action = pathSegments.get(0);\n            spaceName = pathSegments.get(1);\n            pageName = pathSegments.get(2);\n            if (action.equals(\"download\") && pathSegments.size() >= 4) {\n                attachmentName = pathSegments.get(3);\n            }\n        }\n\n        // Normalize the extracted space/page to resolve empty/null values and replace them with default values.\n        EntityReference reference = wikiReference;\n        EntityType entityType = EntityType.DOCUMENT;\n        if (!StringUtils.isEmpty(spaceName)) {\n            reference = new EntityReference(spaceName, EntityType.SPACE, reference);\n        }\n        if (!StringUtils.isEmpty(pageName)) {\n            reference = new EntityReference(pageName, EntityType.DOCUMENT, reference);\n        }\n        if (!StringUtils.isEmpty(attachmentName)) {\n            reference = new EntityReference(attachmentName, EntityType.ATTACHMENT, reference);\n            entityType = EntityType.ATTACHMENT;\n        }\n        reference = this.defaultReferenceEntityReferenceResolver.resolve(reference, entityType);\n\n        entityURL = new XWikiEntityURL(reference);\n        entityURL.setAction(action);\n\n        return entityURL;\n    }\n\n    /**\n     * Extracts the name of the wiki from a context's request. In some cases, including autowww, the main wiki may be\n     * returned instead of what was requested, as a result of some assumptions. Even so, the resulting wiki name is not\n     * guaranteed to exist, it is just what XWiki understood from the request.\n     *\n     * @param context the context which contains the request\n     * @return the name of the wiki that was requested\n     * @throws XWikiException if problems occur\n     * @deprecated starting with 5.2M1 use  use {@link ResourceFactory} instead and since 6.1M2 use\n     *             {@link org.xwiki.resource.ResourceReferenceResolver} instead\n     */\n    @Deprecated\n    public String XWiki.getRequestWikiName(XWikiContext context) throws XWikiException\n    {\n        // Host is full.host.name in DNS-based multiwiki, and wikiname in path-based multiwiki.\n        String host = \"\";\n        // Canonical name of the wiki (database).\n        String wikiName = \"\";\n        // wikiDefinition should be the document holding the definition of the virtual wiki, a document in the main\n        // wiki with a XWiki.XWikiServerClass object attached to it\n        DocumentReference wikiDefinition;\n\n        XWikiRequest request = context.getRequest();\n        try {\n            URL requestURL = context.getURL();\n            host = requestURL.getHost();\n        } catch (Exception e) {\n        }\n\n        // In path-based multi-wiki, the wiki name is an element of the request path.\n        // The url is in the form /xwiki (app name)/wiki (servlet name)/wikiname/\n        if (\"1\".equals(this.Param(\"xwiki.virtual.usepath\", \"1\"))) {\n            String uri = request.getRequestURI();\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Request uri is: \" + uri);\n            }\n            // Remove the (eventual) context path from the URI, usually /xwiki\n            uri = stripSegmentFromPath(uri, request.getContextPath());\n            // Remove the (eventual) servlet path from the URI, usually /wiki\n            String servletPath = request.getServletPath();\n            uri = stripSegmentFromPath(uri, servletPath);\n\n            if (servletPath.equals(\"/\" + this.Param(\"xwiki.virtual.usepath.servletpath\", \"wiki\"))) {\n                // Requested path corresponds to a path-based wiki, now the wiki name is between the first and\n                // second \"/\"\n                host = StringUtils.substringBefore(StringUtils.removeStart(uri, \"/\"), \"/\");\n            }\n        }\n\n        if (StringUtils.isEmpty(host) || host.equals(context.getMainXWiki())) {\n            // Can't find any wiki name, return the main wiki\n            return context.getMainXWiki();\n        }\n\n        // Try to use the full domain name/path wiki name and see if it corresponds to any existing wiki descriptors\n        wikiDefinition = this.findWikiServer(host, context);\n\n        if (wikiDefinition == null) {\n            // No definition found based on the full domain name/path wiki name, try to use the first part of the domain\n            // name as the wiki name\n            String servername = StringUtils.substringBefore(host, \".\");\n\n            // Note: Starting 5.0M2, the autowww behavior is default and the ability to disable it is now removed.\n            if (\"0\".equals(this.Param(\"xwiki.virtual.autowww\"))) {\n                LOGGER.warn(String.format(\"%s %s\", \"'xwiki.virtual.autowww' is no longer supported.\",\n                    \"Please update your configuration and/or see XWIKI-8877 for more details.\"));\n            }\n\n            // As a convenience, we do not require the creation of an xwiki:XWiki.XWikiServerXwiki page for the main\n            // wiki and automatically go to the main wiki in certain cases:\n            // - \"www.<anyDomain>.<domainExtension>\" - if it starts with www, we first check if a subwiki with that\n            // name exists; if yes, the go to the \"www\" subwiki, if not, go to the main wiki\n            // - \"localhost\"\n            // - IP address\n            if (\"www\".equals(servername)) {\n                // Check that \"www\" is not actually the name of an existing subwiki.\n                wikiDefinition = this.findWikiServer(servername, context);\n                if (wikiDefinition == null) {\n                    // Not the case, use the main wiki.\n                    return context.getMainXWiki();\n                }\n            } else if (\"localhost\".equals(host) || host.matches(\"[0-9]{1,3}(?:\\\\.[0-9]{1,3}){3}\")) {\n                // Direct access to the main wiki.\n                return context.getMainXWiki();\n            }\n\n            // Use the name from the subdomain\n            wikiName = servername;\n\n            if (!context.isMainWiki(wikiName)\n                && !\"1\".equals(context.getWiki().Param(\"xwiki.virtual.failOnWikiDoesNotExist\", \"0\"))) {\n                // Check if the wiki really exists\n                if (!exists(getServerWikiPage(wikiName), context)) {\n                    // Fallback on main wiki\n                    wikiName = context.getMainXWiki();\n                }\n            }\n        } else {\n            // Use the name from the located wiki descriptor\n            wikiName = StringUtils.removeStart(wikiDefinition.getName(), \"XWikiServer\").toLowerCase();\n        }\n\n        return wikiName;\n    }\n\n    /**\n     * Searches for the document containing the definition of the virtual wiki corresponding to the specified hostname.\n     *\n     * @param host the hostname, as specified in the request (for example: {@code forge.xwiki.org})\n     * @param context the current context\n     * @return the name of the document containing the wiki definition, or {@code null} if no wiki corresponds to the\n     *         hostname\n     * @throws XWikiException if a problem occurs while searching the storage\n     */\n    private DocumentReference XWiki.findWikiServer(String host, XWikiContext context) throws XWikiException\n    {\n        try {\n          WikiDescriptor descriptor = Utils.getComponent(WikiDescriptorManager.class).getByAlias(host);\n\n          if (descriptor != null) {\n              return new DocumentReference(context.getMainXWiki(), \"XWiki\",\n                  \"XWikiServer\" + StringUtils.capitalize(descriptor.getId()));\n          }\n        } catch (WikiManagerException e) {\n            LOGGER.warn(\"Error when searching for wiki name from URL host [\" + host + \"]\", e);\n        }\n\n        return null;\n    }\n\n    /**\n     * @deprecated replaced by {@link #setUserDefaultGroup(String fullwikiname, XWikiContext context)}\n     * @param context\n     * @param fullwikiname\n     * @throws XWikiException\n     */\n    @Deprecated\n    public void XWiki.SetUserDefaultGroup(XWikiContext context, String fullwikiname) throws XWikiException\n    {\n        this.setUserDefaultGroup(fullwikiname, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link #protectUserPage(String,String,XWikiDocument,XWikiContext)}\n     * @param context\n     * @param fullwikiname\n     * @param userRights\n     * @param doc\n     * @throws XWikiException\n     */\n    @Deprecated\n    public void XWiki.ProtectUserPage(XWikiContext context, String fullwikiname, String userRights, XWikiDocument doc)\n        throws XWikiException\n    {\n        this.protectUserPage(fullwikiname, userRights, doc, context);\n    }\n\n    /**\n     * @return the cache factory.\n     * @since 1.5M2.\n     * @deprecated Since 1.7M1, use {@link CacheManager} component instead using {@link Utils#getComponent(Class)}\n     */\n    @Deprecated\n    public CacheFactory XWiki.getCacheFactory()\n    {\n        CacheFactory cacheFactory;\n\n        String cacheHint = Param(\"xwiki.cache.cachefactory.hint\", null);\n\n        if (StringUtils.isEmpty(cacheHint) || Utils.getComponent(CacheFactory.class, cacheHint) == null) {\n            CacheManager cacheManager = Utils.getComponent(CacheManager.class);\n            try {\n                cacheFactory = cacheManager.getCacheFactory();\n            } catch (ComponentLookupException e) {\n                throw new RuntimeException(\"Failed to get cache factory component\", e);\n            }\n        } else {\n            cacheFactory = Utils.getComponent(CacheFactory.class, cacheHint);\n        }\n\n        return cacheFactory;\n    }\n\n    /**\n     * @return the cache factory creating local caches.\n     * @since 1.5M2.\n     * @deprecated Since 1.7M1, use {@link CacheManager} component instead using {@link Utils#getComponent(Class)}\n     */\n    @Deprecated\n    public CacheFactory XWiki.getLocalCacheFactory()\n    {\n        CacheFactory localCacheFactory;\n\n        String localCacheHint = Param(\"xwiki.cache.cachefactory.local.hint\", null);\n\n        if (StringUtils.isEmpty(localCacheHint) || Utils.getComponent(CacheFactory.class, localCacheHint) == null) {\n            CacheManager cacheManager = Utils.getComponent(CacheManager.class);\n            try {\n                localCacheFactory = cacheManager.getLocalCacheFactory();\n            } catch (ComponentLookupException e) {\n                throw new RuntimeException(\"Failed to get local cache factory component\", e);\n            }\n        } else {\n            localCacheFactory = Utils.getComponent(CacheFactory.class, localCacheHint);\n        }\n\n        return localCacheFactory;\n    }\n\n    /**\n     * @deprecated since 2.3M1 use {@link #hasVersioning(XWikiContext)} instead\n     */\n    @Deprecated\n    public boolean XWiki.hasVersioning(String fullName, XWikiContext context)\n    {\n        return hasVersioning(context);\n    }\n\n    /**\n     * @deprecated replaced by {@link #include(String topic, boolean isForm, XWikiContext context)}\n     * @param topic\n     * @param context\n     * @param isForm\n     * @return\n     * @throws XWikiException\n     */\n    @Deprecated\n    public String XWiki.include(String topic, XWikiContext context, boolean isForm) throws XWikiException\n    {\n        return include(topic, isForm, context);\n    }\n    \n    /**\n     * Checks if the wiki is running in test mode.\n     * \n     * @return {@code true} if the wiki is running Cactus tests, {@code false} otherwise\n     * @deprecated No longer used.\n     */\n    @Deprecated\n    public boolean XWiki.isTest()\n    {\n        return this.test;\n    }\n\n    /**\n     * Marks that the wiki is running in test mode.\n     * \n     * @param test whether tests are being executed\n     * @deprecated No longer used.\n     */\n    @Deprecated\n    public void XWiki.setTest(boolean test)\n    {\n        this.test = test;\n    }\n\n    /**\n     * @deprecated use {@link org.xwiki.localization.LocalizationManager} instead. From velocity you can access it using\n     *             the {@code $services.localization} binding, see {@code LocalizationScriptService}\n     */\n    @Deprecated\n    public String XWiki.parseMessage(XWikiContext context)\n    {\n        String message = (String) context.get(\"message\");\n        if (message == null) {\n            return null;\n        }\n\n        return parseMessage(message, context);\n    }\n\n    /**\n     * @deprecated use {@link org.xwiki.localization.LocalizationManager} instead. From velocity you can access it using\n     *             the {@code $services.localization} binding, see {@code LocalizationScriptService}\n     */\n    @Deprecated\n    public String XWiki.parseMessage(String id, XWikiContext context)\n    {\n        XWikiMessageTool msg = context.getMessageTool();\n\n        List<?> parameters = (List<?>) context.get(\"messageParameters\");\n\n        String translatedMessage;\n        if (parameters != null) {\n            translatedMessage = msg.get(id, parameters);\n        } else {\n            translatedMessage = msg.get(id);\n        }\n\n        return parseContent(translatedMessage, context);\n    }\n\n    /**\n     * @deprecated starting with 6.1M2 this method shouldn't be used. There's no replacement, it's just not the right\n     *             way to do this anymore and the flash.vm template doesn't exist anymore\n     */\n    @Deprecated\n    public String XWiki.getFlash(String url, String width, String height, XWikiContext context)\n    {\n        VelocityContext vorigcontext = ((VelocityContext) context.get(\"vcontext\"));\n        try {\n            VelocityContext vcontext = (VelocityContext) vorigcontext.clone();\n            vcontext.put(\"flashurl\", url);\n            vcontext.put(\"width\", width);\n            vcontext.put(\"height\", height);\n            context.put(\"vcontext\", vcontext);\n\n            return parseTemplate(\"flash.vm\", context);\n        } finally {\n            context.put(\"vcontext\", vorigcontext);\n        }\n    }\n\n    /**\n     * @deprecated replaced by the <a href=\"http://code.xwiki.org/xwiki/bin/view/Plugins/MailSenderPlugin\">Mail Sender\n     *             Plugin</a>\n     */\n    @Deprecated\n    public void XWiki.sendMessage(String sender, String[] recipients, String rawMessage, XWikiContext context)\n        throws XWikiException\n    {\n        LOGGER.trace(\"Entering sendMessage()\");\n\n        // We'll be using the MailSender plugin, which has much more advanced capabilities (authentication, TLS).\n        // Since the plugin is in another module, and it depends on the core, we have to use it through reflection in\n        // order to avoid cyclic dependencies. This should be fixed once the mailsender becomes a clean component\n        // instead of a plugin.\n        Object mailSender;\n        Class mailSenderClass;\n        Method mailSenderSendRaw;\n\n        try {\n            mailSender = getPluginApi(\"mailsender\", context);\n            mailSenderClass = Class.forName(\"com.xpn.xwiki.plugin.mailsender.MailSenderPluginApi\");\n\n            // public int sendRawMessage(String from, String to, String rawMessage)\n            mailSenderSendRaw =\n                mailSenderClass.getMethod(\"sendRawMessage\", new Class[] {String.class, String.class, String.class});\n        } catch (Exception e) {\n            LOGGER.error(\"Problem getting MailSender via Reflection. Using the old sendMessage mechanism.\", e);\n            sendMessageOld(sender, recipients, rawMessage, context);\n            return;\n        }\n\n        if (LOGGER.isTraceEnabled()) {\n            LOGGER.trace(\"Sending message = \\\"\" + rawMessage + \"\\\"\");\n        }\n\n        String messageRecipients = StringUtils.join(recipients, ',');\n\n        try {\n            mailSenderSendRaw.invoke(mailSender, sender, messageRecipients, rawMessage);\n        } catch (InvocationTargetException ite) {\n            Throwable cause = ite.getCause();\n            if (cause instanceof XWikiException) {\n                throw (XWikiException) cause;\n            } else {\n                throw new RuntimeException(cause);\n            }\n        } catch (Exception e) {\n            // Probably either IllegalAccessException or IllegalArgumentException\n            // Shouldn't happen unless there were an incompatible code change\n            throw new RuntimeException(e);\n        }\n\n        LOGGER.info(\"Exiting sendMessage(). It seems everything went ok.\");\n    }\n\n    /**\n     * @deprecated replaced by the <a href=\"http://code.xwiki.org/xwiki/bin/view/Plugins/MailSenderPlugin\">Mail Sender\n     *             Plugin</a>\n     */\n    @Deprecated\n    private void XWiki.sendMessageOld(String sender, String[] recipient, String message, XWikiContext context)\n        throws XWikiException\n    {\n        SMTPClient smtpc = null;\n        try {\n            String server = getXWikiPreference(\"smtp_server\", context);\n            String port = getXWikiPreference(\"smtp_port\", context);\n            String login = getXWikiPreference(\"smtp_login\", context);\n\n            if (context.get(\"debugMail\") != null) {\n                StringBuffer msg = new StringBuffer(message);\n                msg.append(\"\\n Recipient: \");\n                msg.append(recipient);\n                recipient = ((String) context.get(\"debugMail\")).split(\",\");\n                message = msg.toString();\n            }\n\n            if ((server == null) || server.equals(\"\")) {\n                server = \"127.0.0.1\";\n            }\n            if ((port == null) || (port.equals(\"\"))) {\n                port = \"25\";\n            }\n            if ((login == null) || login.equals(\"\")) {\n                login = InetAddress.getLocalHost().getHostName();\n            }\n\n            smtpc = new SMTPClient();\n            smtpc.connect(server, Integer.parseInt(port));\n            int reply = smtpc.getReplyCode();\n            if (!SMTPReply.isPositiveCompletion(reply)) {\n                Object[] args = {server, port, Integer.valueOf(reply), smtpc.getReplyString()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                    XWikiException.ERROR_XWIKI_EMAIL_CONNECT_FAILED,\n                    \"Could not connect to server {0} port {1} error code {2} ({3})\", null, args);\n            }\n\n            if (smtpc.login(login) == false) {\n                reply = smtpc.getReplyCode();\n                Object[] args = {server, port, Integer.valueOf(reply), smtpc.getReplyString()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                    XWikiException.ERROR_XWIKI_EMAIL_LOGIN_FAILED,\n                    \"Could not login to mail server {0} port {1} error code {2} ({3})\", null, args);\n            }\n\n            if (smtpc.sendSimpleMessage(sender, recipient, message) == false) {\n                reply = smtpc.getReplyCode();\n                Object[] args = {server, port, Integer.valueOf(reply), smtpc.getReplyString()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                    XWikiException.ERROR_XWIKI_EMAIL_SEND_FAILED,\n                    \"Could not send mail to server {0} port {1} error code {2} ({3})\", null, args);\n            }\n\n        } catch (IOException e) {\n            Object[] args = {sender, recipient};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_ERROR_SENDING_EMAIL, \"Exception while sending email from {0} to {1}\",\n                e, args);\n        } finally {\n            if ((smtpc != null) && (smtpc.isConnected())) {\n                try {\n                    smtpc.disconnect();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    /**\n     * @deprecated replaced by the <a href=\"http://code.xwiki.org/xwiki/bin/view/Plugins/MailSenderPlugin\">Mail Sender\n     *             Plugin</a>\n     */\n    @Deprecated\n    public void XWiki.sendMessage(String sender, String recipient, String message, XWikiContext context)\n        throws XWikiException\n    {\n        String[] recip = recipient.split(\",\");\n        sendMessage(sender, recip, message, context);\n    }\n\n    /**\n     * @deprecated since 7.0M1. This method should have actually been deprecated since 2.3M1, but it was left forgotten\n     *             and unused.\n     */\n    @Deprecated\n    public boolean XWiki.hasCaptcha(XWikiContext context)\n    {\n        return (this.getXWikiPreferenceAsInt(\"captcha_enabled\", \"xwiki.plugin.captcha\", 0, context) == 1);\n    }\n\n    /**\n     * @deprecated since 6.1M2, directly lookup default {@link com.xpn.xwiki.render.XWikiRenderingEngine} component\n     *             instead\n     */\n    @Deprecated\n    public Object XWiki.getRenderingEngine()\n    {\n        try {\n            return Utils.getComponent(getClass().forName(\"com.xpn.xwiki.render.XWikiRenderingEngine\"));\n        } catch (ClassNotFoundException e) {\n            return null;\n        }\n    }\n\n    @Deprecated\n    public void XWiki.resetRenderingEngine(XWikiContext context) throws XWikiException\n    {\n        getOldRendering().resetRenderingEngine(context);\n    }\n\n    /**\n     * @deprecated use {@link EntityReferenceResolver} instead\n     */\n    @Deprecated\n    public String XWiki.getDocName(String fullName)\n    {\n        return fullName.substring(fullName.indexOf('.') + 1);\n    }\n\n    /**\n     * @deprecated use {@link Date#Date()} instead...\n     */\n    @Deprecated\n    public Date XWiki.getCurrentDate()\n    {\n        return new Date();\n    }\n\n    /**\n     * @deprecated use {@link Date#Date(long)} instead...\n     */\n    @Deprecated\n    public Date XWiki.getDate(long time)\n    {\n        return new Date(time);\n    }\n\n    /**\n     * @deprecated removed to support referencing a top level Nested Page easily. This method is there to prevent\n     *             any existing extension from breaking but the XWiki core code doesn't use call this method anymore\n     *             and thus it has not effect anymore\n     */\n    @Deprecated\n    public boolean XWiki.skipDefaultSpaceInURLs(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"usedefaultweb\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.usedefaultweb\", \"0\"));\n    }\n\n    /**\n     * @deprecated use {@link XWikiDocument#rename(String, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument XWiki.renamePage(XWikiDocument doc, XWikiContext context, String newFullName)\n        throws XWikiException\n    {\n        return renamePage(doc, newFullName, context);\n    }\n\n    /**\n     * @deprecated Since 12.0RC1: Use {@link XWikiDocument#rename(DocumentReference, XWikiContext)} instead.\n     */\n    @Deprecated\n    public void XWiki.renamePage(String fullName, String newFullName, XWikiContext context) throws XWikiException\n    {\n        renamePage(context.getWiki().getDocument(fullName, context), newFullName, context);\n    }\n\n    /**\n     * @deprecated use {@link XWikiDocument#rename(String, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument XWiki.renamePage(XWikiDocument doc, String newFullName, XWikiContext context)\n        throws XWikiException\n    {\n        if (context.getWiki().exists(newFullName, context)) {\n            XWikiDocument delDoc = context.getWiki().getDocument(newFullName, context);\n            context.getWiki().deleteDocument(delDoc, context);\n        }\n\n        XWikiDocument renamedDoc = doc.copyDocument(newFullName, context);\n        saveDocument(renamedDoc, context);\n        renamedDoc.saveAllAttachments(context);\n        deleteDocument(doc, context);\n\n        return renamedDoc;\n    }\n\n    /**\n     * @return the ids of configured syntaxes for this wiki (e.g. {@code xwiki/2.0}, {@code xwiki/2.1},\n     *         {@code mediawiki/1.0}, etc), taken only from {@code xwiki.cfg} (using the\n     *         {@code xwiki.rendering.syntaxes} property)\n     * @deprecated since 8.2M1, use the XWiki Rendering Configuration component or the Rendering Script Service one\n     *             instead (they use a more elaborate algorithm to find out the supported syntaxes)\n     */\n    @Deprecated\n    public List<String> XWiki.getConfiguredSyntaxes()\n    {\n        if (this.configuredSyntaxes == null) {\n            ExtendedRenderingConfiguration extendedRenderingConfiguration =\n                Utils.getComponent(ExtendedRenderingConfiguration.class);\n            String syntaxes = getConfiguration().getProperty(\"xwiki.rendering.syntaxes\",\n                extendedRenderingConfiguration.getDefaultContentSyntax().toIdString());\n            this.configuredSyntaxes = Arrays.asList(StringUtils.split(syntaxes, \" ,\"));\n        }\n        return this.configuredSyntaxes;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.api;\n\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.query.QueryManager;\nimport org.xwiki.xml.XMLUtils;\nimport org.suigeneris.jrcs.diff.delta.Chunk;\n\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.plugin.query.XWikiCriteria;\nimport com.xpn.xwiki.plugin.query.XWikiQuery;\nimport com.xpn.xwiki.stats.api.XWikiStatsService;\nimport com.xpn.xwiki.stats.impl.DocumentStats;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiMessageTool;\nimport com.xpn.xwiki.internal.render.OldRendering;\n\n/**\n * Add a backward compatibility layer to the {@link com.xpn.xwiki.api.XWiki} class.\n *\n * @version $Id$\n */\npublic privileged aspect XWikiCompatibilityAspect\n{\n    /**\n     * Utility methods have been moved in version 1.3 Milestone 2 to the {@link Util} class.\n     * However to preserve backward compatibility we have deprecated them in this class and\n     * not removed them yet. All calls are funnelled through this class variable.\n     */\n    private Util XWiki.util;\n\n    /**\n     * Capture the api.XWiki constructor so that we can initialize this.util.\n     */\n    private pointcut xwikiCreation(XWiki x): this(x) && execution( public com.xpn.xwiki.api.XWiki.new(..) );\n\n    after(XWiki x): xwikiCreation(x)\n    {\n        x.util = new Util(x.xwiki, x.context);\n    }\n\n    /**\n     * API to protect Text from Wiki transformation\n     * @param text\n     * @return escaped text\n     * @deprecated replaced by Util#escapeText since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.escapeText(String text)\n    {\n        return this.util.escapeText(text);\n    }\n\n    /**\n     * API to protect URLs from Wiki transformation\n     * @param url\n     * @return encoded URL\n     * @deprecated replaced by Util#escapeURL since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.escapeURL(String url)\n    {\n        return this.util.escapeURL(url);\n    }\n\n    /**\n     * @deprecated use {@link #getLanguagePreference()} instead\n     */\n    @Deprecated\n    public String XWiki.getDocLanguagePreference()\n    {\n        return xwiki.getDocLanguagePreference(getXWikiContext());\n    }\n\n    /**\n     * Privileged API to send a message to an email address\n     *\n     * @param sender email of the sender of the message\n     * @param recipient email of the recipient of the message\n     * @param message Message to send\n     * @throws XWikiException if the mail was not send successfully\n     * @deprecated replaced by the\n     *   <a href=\"http://code.xwiki.org/xwiki/bin/view/Plugins/MailSenderPlugin\">Mail Sender\n     *   Plugin</a> since 1.3M2\n     */\n    @Deprecated\n    public void XWiki.sendMessage(String sender, String recipient, String message)\n        throws XWikiException\n    {\n        if (hasProgrammingRights())\n            xwiki.sendMessage(sender, recipient, message, getXWikiContext());\n    }\n\n    /**\n     * Privileged API to send a message to an email address\n     *\n     * @param sender email of the sender of the message\n     * @param recipient emails of the recipients of the message\n     * @param message Message to send\n     * @throws XWikiException if the mail was not send successfully\n     * @deprecated replaced by the\n     *   <a href=\"http://code.xwiki.org/xwiki/bin/view/Plugins/MailSenderPlugin\">Mail Sender\n     *   Plugin</a> since 1.3M2\n     */\n    @Deprecated\n    public void XWiki.sendMessage(String sender, String[] recipient, String message)\n        throws XWikiException\n    {\n        if (hasProgrammingRights())\n            xwiki.sendMessage(sender, recipient, message, getXWikiContext());\n    }\n\n    /**\n     * @return the current date\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#getDate()} since 1.3M2\n     */\n    @Deprecated\n    public Date XWiki.getCurrentDate()\n    {\n        return this.util.getDate();\n    }\n\n    /**\n     * @return the current date\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#getDate()} since 1.3M2\n     */\n    @Deprecated\n    public Date XWiki.getDate()\n    {\n        return this.util.getDate();\n    }\n\n    /**\n     * @param time the time in milliseconds\n     * @return the time delta in milliseconds between the current date and the time passed\n     *         as parameter\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#getTimeDelta(long)} since 1.3M2\n     */\n    @Deprecated\n    public int XWiki.getTimeDelta(long time)\n    {\n        return this.util.getTimeDelta(time);\n    }\n\n    /**\n     * @param time time in milliseconds since 1970, 00:00:00 GMT\n     * @return Date a date from a time in milliseconds since 01/01/1970 as a\n     *         Java {@link Date} Object\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#getDate(long)} since 1.3M2\n     */\n    @Deprecated\n    public Date XWiki.getDate(long time)\n    {\n        return this.util.getDate(time);\n    }\n\n    /**\n     * Split a text to an array of texts, according to a separator.\n     *\n     * @param text the original text\n     * @param sep the separator characters. The separator is one or more of the\n     *        separator characters\n     * @return An array containing the split text\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#split(String, String)} since 1.3M2\n     */\n    @Deprecated\n    public String[] XWiki.split(String text, String sep)\n    {\n        return this.util.split(text, sep);\n    }\n\n    /**\n     * Get a stack trace as a String\n     *\n     * @param e the exception to convert to a String\n     * @return the exception stack trace as a String\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#printStrackTrace(Throwable)}\n     *             since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.printStrackTrace(Throwable e)\n    {\n        return this.util.printStrackTrace(e);\n    }\n\n    /**\n     * Get a Null object. This is useful in Velocity where there is no real null object\n     * for comparaisons.\n     *\n     * @return a Null Object\n     * @deprecated replaced by {@link Util#getNull()} since 1.3M2\n     */\n    @Deprecated\n    public Object XWiki.getNull()\n    {\n        return this.util.getNull();\n    }\n\n    /**\n     * Get a New Line character. This is useful in Velocity where there is no real new\n     * line character for inclusion in texts.\n     *\n     * @return a new line character\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#getNewline()} since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.getNl()\n    {\n        return this.util.getNewline();\n    }\n\n    /**\n     * Creates an Array List. This is useful from Velocity since you cannot\n     * create Object from Velocity with our secure uberspector.\n     *\n     * @return a {@link ArrayList} object\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#getArrayList()} since 1.3M2\n     */\n    @Deprecated\n    public List XWiki.getArrayList()\n    {\n        return this.util.getArrayList();\n    }\n\n    /**\n     * Creates a Hash Map. This is useful from Velocity since you cannot\n     * create Object from Velocity with our secure uberspector.\n     *\n     * @return a {@link HashMap} object\n     * @deprecated replaced by {@link Util#getHashMap()} since 1.3M2\n     */\n    @Deprecated\n    public Map XWiki.getHashMap()\n    {\n        return this.util.getHashMap();\n    }\n\n    /**\n     * Creates a Tree Map. This is useful from Velocity since you cannot\n     * create Object from Velocity with our secure uberspector.\n     *\n     * @return a {@link TreeMap} object\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#getTreeMap()} since 1.3M2\n     */\n    @Deprecated\n    public Map XWiki.getTreeMap()\n    {\n        return this.util.getTreeMap();\n    }\n\n    /**\n     * Sort a list using a standard comparator. Elements need to be mutally comparable and\n     * implement the Comparable interface.\n     *\n     * @param list the list to sort\n     * @return the sorted list (as the same oject reference)\n     * @see {@link java.util.Collections#sort(java.util.List)}\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#sort(java.util.List)} since 1.3M2\n     */\n    @Deprecated\n    public List XWiki.sort(List list)\n    {\n        return this.util.sort(list);\n    }\n\n    /**\n     * Convert an Object to a number and return null if the object is not a Number.\n     *\n     * @param object the object to convert\n     * @return the object as a {@link Number}\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#toNumber(Object)} since 1.3M2\n     */\n    @Deprecated\n    public Number XWiki.toNumber(Object object)\n    {\n        return this.util.toNumber(object);\n    }\n\n    /**\n     * Generate a random string.\n     *\n     * @param size the desired size of the string\n     * @return the randomly generated string\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#generateRandomString(int)}\n                   since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.generateRandomString(int size)\n    {\n        return this.util.generateRandomString(size);\n    }\n\n    /**\n     * Output a BufferedImage object into the response outputstream.\n     * Once this method has been called, not further action is possible.\n     * Users should set $context.setFinished(true) to\n     * avoid template output The image is outpout as image/jpeg.\n     *\n     * @param image the BufferedImage to output\n     * @throws java.io.IOException if the output fails\n     * @deprecated replaced by\n     *             {@link com.xpn.xwiki.api.Util#outputImage(java.awt.image.BufferedImage)}\n     *             since 1.3M2\n     */\n    @Deprecated\n    public void XWiki.outputImage(BufferedImage image) throws IOException\n    {\n        this.util.outputImage(image);\n    }\n\n    /**\n     * Returns the recently visited pages for a specific action\n     *\n     * @param action (\"view\" or \"edit\")\n     * @param size how many recent actions to retrieve\n     * @return a ArrayList of document names\n     * @deprecated use {@link #getStatsService()} instead\n     */\n    @Deprecated\n    public java.util.Collection XWiki.getRecentActions(String action, int size)\n    {\n        XWikiStatsService stats = getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        if (stats == null)\n            return Collections.EMPTY_LIST;\n        return stats.getRecentActions(action, size, getXWikiContext());\n    }\n\n    /**\n     * @param str the String to convert to an integer\n     * @return the parsed integer or zero in case of exception\n     * @deprecated replaced by {@link Util#parseInt(String)} since 1.3M2\n     */\n    @Deprecated\n    public int XWiki.parseInt(String str)\n    {\n        return this.util.parseInt(str);\n    }\n\n    /**\n     * @param str the String to convert to an Integer Object\n     * @return the parsed integer or zero in case of exception\n     * @deprecated replaced by {@link Util#parseInteger(String)} since 1.3M2\n     */\n    @Deprecated\n    public Integer XWiki.parseInteger(String str)\n    {\n        return this.util.parseInteger(str);\n    }\n\n    /**\n     * @param str the String to convert to a long\n     * @return the parsed long or zero in case of exception\n     * @deprecated replaced by {@link Util#parseLong(String)} since 1.3M2\n     */\n    @Deprecated\n    public long XWiki.parseLong(String str)\n    {\n        return this.util.parseLong(str);\n    }\n\n    /**\n     * @param str the String to convert to a float\n     * @return the parsed float or zero in case of exception\n     * @deprecated replaced by {@link Util#parseFloat(String)} since 1.3M2\n     */\n    @Deprecated\n    public float XWiki.parseFloat(String str)\n    {\n        return this.util.parseFloat(str);\n    }\n\n    /**\n     * @param str the String to convert to a double\n     * @return the parsed double or zero in case of exception\n     * @deprecated replaced by {@link Util#parseDouble(String)} since 1.3M2\n     */\n    @Deprecated\n    public double XWiki.parseDouble(String str)\n    {\n        return this.util.parseDouble(str);\n    }\n\n    /**\n     * Escape text so that it can be used in a like clause or in a test for equality clause.\n     * For example it escapes single quote characters.\n     *\n     * @param text the text to escape\n     * @return filtered text\n     * @deprecated replaced by {@link Util#escapeSQL(String)} since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.sqlfilter(String text)\n    {\n        return this.util.escapeSQL(text);\n    }\n\n    /**\n     * Cleans up the passed text by removing all accents and special characters to make it\n     * a valid page name.\n     *\n     * @param name the page name to normalize\n     * @return the valid page name\n     * @deprecated replaced by {@link Util#clearName(String)} since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.clearName(String name)\n    {\n        return this.util.clearName(name);\n    }\n\n    /**\n     * Replace all accents by their alpha equivalent.\n     *\n     * @param text the text to parse\n     * @return a string with accents replaced with their alpha equivalent\n     * @deprecated replaced by {@link Util#clearAccents(String)} since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.clearAccents(String text)\n    {\n        return this.util.clearAccents(text);\n    }\n\n    /**\n     * Add a and b because Velocity operations are not always working.\n     *\n     * @param a an integer to add\n     * @param b an integer to add\n     * @return the sum of a and b\n     * @deprecated replaced by {@link Util#add(int, int)} since 1.3M2\n     */\n    @Deprecated\n    public int XWiki.add(int a, int b)\n    {\n        return this.util.add(a, b);\n    }\n\n    /**\n     * Add a and b because Velocity operations are not working with longs.\n     *\n     * @param a a long to add\n     * @param b a long to add\n     * @return the sum of a and b\n     * @deprecated replaced by {@link Util#add(long, long)} since 1.3M2\n     */\n    @Deprecated\n    public long XWiki.add(long a, long b)\n    {\n        return this.util.add(a, b);\n    }\n\n    /**\n     * Add a and b where a and b are non decimal numbers specified as Strings.\n     *\n     * @param a a string representing a non decimal number\n     * @param b a string representing a non decimal number\n     * @return the sum of a and b as a String\n     * @deprecated replaced by {@link Util#add(String, String)} since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.add(String a, String b)\n    {\n        return this.util.add(a,  b);\n    }\n\n    /**\n     * Transform a text in a URL compatible text\n     * \n     * @param content text to transform\n     * @return encoded result\n     * @deprecated replaced by {@link Util#encodeURI(String)} since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.getURLEncoded(String content)\n    {\n        return this.util.encodeURI(content);\n    }\n    \n    /**\n     * @return true for multi-wiki/false for mono-wiki\n     * @deprecated replaced by {@link XWiki#isVirtualMode()} since 1.4M1.\n     */\n    @Deprecated\n    public boolean XWiki.isVirtual()\n    {\n        return this.isVirtualMode();\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpaceCopyright()} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebCopyright()\n    {\n        return this.getSpaceCopyright();\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreference(String)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebPreference(String preference)\n    {\n        return this.getSpacePreference(preference);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceFor(String, String)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebPreferenceFor(String preference, String space)\n    {\n        return this.getSpacePreferenceFor(preference, space);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceFor(String, String, String)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebPreferenceFor(String preference, String space, String defaultValue)\n    {\n        return this.getSpacePreferenceFor(preference, space, defaultValue);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsLong(String, long)} since 2.3M1\n     */\n    @Deprecated\n    public long XWiki.getWebPreferenceAsLong(String preference, long defaultValue)\n    {\n        return this.getSpacePreferenceAsLong(preference, defaultValue);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsLong(String)} since 2.3M1\n     */\n    @Deprecated\n    public long XWiki.getWebPreferenceAsLong(String preference)\n    {\n        return this.getSpacePreferenceAsLong(preference);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsInt(String, int)} since 2.3M1\n     */\n    @Deprecated\n    public int XWiki.getWebPreferenceAsInt(String preference, int defaultValue)\n    {\n        return this.getSpacePreferenceAsInt(preference, defaultValue);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreference(String, String)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebPreference(String preference, String defaultValue)\n    {\n        return this.getSpacePreference(preference, defaultValue);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsInt(String)} since 2.3M1\n     */\n    @Deprecated\n    public int XWiki.getWebPreferenceAsInt(String preference)\n    {\n        return this.getSpacePreferenceAsInt(preference);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#copySpaceBetweenWikis(String, String, String, String, boolean)} since 2.3M1\n     */\n    @Deprecated\n    public int XWiki.copyWikiWeb(String space, String sourceWiki, String targetWiki, String language, boolean clean)\n        throws XWikiException\n    {\n        return this.copySpaceBetweenWikis(space, sourceWiki, targetWiki, language, clean);\n    }\n\n    /**\n     * API to parse a message. A message can be an error message or an information message either as text or as a message\n     * ID pointing to ApplicationResources. The message is also parse for velocity scripts\n     * \n     * @return Final message\n     * @param id\n     * @return the result of the parsed message\n     * @deprecated use {@link XWikiMessageTool#get(String, List)} instead. From velocity you can access XWikiMessageTool\n     *             with $msg binding.\n     */\n    @Deprecated\n    public String XWiki.parseMessage(String id)\n    {\n        return this.xwiki.parseMessage(id, getXWikiContext());\n    }\n\n    /**\n     * API to get a message. A message can be an error message or an information message either as text or as a message\n     * ID pointing to ApplicationResources. The message is also parsed for velocity scripts\n     * \n     * @return Final message\n     * @param id\n     * @return the result of the parsed message\n     * @deprecated use {@link XWikiMessageTool#get(String, List)} instead. From velocity you can access XWikiMessageTool\n     *             with $msg binding.\n     */\n    @Deprecated\n    public String XWiki.getMessage(String id)\n    {\n        return this.xwiki.getMessage(id, getXWikiContext());\n    }\n\n    /**\n     * Transform a text in a form compatible text\n     * \n     * @param content text to transform\n     * @return encoded result\n     * @deprecated Use $escapetool.xml\n     */\n    @Deprecated\n    public String XWiki.getFormEncoded(String content)\n    {\n        return XMLUtils.escape(content);\n    }\n\n    /**\n     * Transform a text in a XML compatible text This method uses Apache CharacterFilter which swaps single quote\n     * (&#39;) for left single quotation mark (&#8217;)\n     * \n     * @param content text to transform\n     * @return encoded result\n     * @deprecated Use $escapetool.xml\n     */\n    @Deprecated\n    public String XWiki.getXMLEncoded(String content)\n    {\n        return XMLUtils.escape(content);\n    }\n\n    /**\n     * Output content in the edit content htmlarea\n     * \n     * @param content content to output\n     * @return the htmlarea text content\n     * @deprecated Removed since it isn't used; since 3.1M2.\n     */\n    @Deprecated\n    public String XWiki.getHTMLArea(String content)\n    {\n        return this.xwiki.getHTMLArea(content, getXWikiContext());\n    }\n    \n\n    /**\n     * API to display a select box for the list of available field for a specific class This field data can then be used\n     * to generate an XWiki Query showing a table with the relevant data\n     * \n     * @param className XWiki Class Name to display the list of columns for\n     * @param query Query to pre-select the currently selected columns\n     * @return text of the select field\n     * @throws XWikiException exception is a failure occured\n     */\n    @Deprecated\n    public String XWiki.displaySearchColumns(String className, XWikiQuery query) throws XWikiException\n    {\n        return this.xwiki.displaySearchColumns(className, \"\", query, getXWikiContext());\n    }\n\n    /**\n     * API to display a select box for the list of available field for a specific class, optionally adding a prefix This\n     * field data can then be used to generate an XWiki Query showing a table with the relevant data\n     * \n     * @param className XWiki Class Name to display the list of columns for\n     * @param prefix Prefix to add to the field name\n     * @param query Query to pre-select the currently selected columns\n     * @return text of the select field\n     * @throws XWikiException exception is a failure occured\n     */\n    @Deprecated\n    public String XWiki.displaySearchColumns(String className, String prefix, XWikiQuery query) throws XWikiException\n    {\n        return this.xwiki.displaySearchColumns(className, prefix, query, getXWikiContext());\n    }\n\n    /**\n     * API to display a select box for the list of available field for a specific class This field data can then be used\n     * to generate the order element of an XWiki Query showing a table with the relevant data\n     * \n     * @param className XWiki Class Name to display the list of columns for\n     * @param query Query to pre-select the currently selected columns\n     * @return text of the select field\n     * @throws XWikiException exception is a failure occured\n     */\n    @Deprecated\n    public String XWiki.displaySearchOrder(String className, XWikiQuery query) throws XWikiException\n    {\n        return this.xwiki.displaySearchOrder(className, \"\", query, getXWikiContext());\n    }\n\n    /**\n     * API to display a select box for the list of available field for a specific class, optionally adding a prefix This\n     * field data can then be used to generate the order element of an XWiki Query showing a table with the relevant\n     * data\n     * \n     * @param className XWiki Class Name to display the list of columns for\n     * @param prefix Prefix to add to the field name\n     * @param query Query to pre-select the currently selected columns\n     * @return text of the select field\n     * @throws XWikiException exception is a failure occured\n     */\n    @Deprecated\n    public String XWiki.displaySearchOrder(String className, String prefix, XWikiQuery query) throws XWikiException\n    {\n        return this.xwiki.displaySearchOrder(className, prefix, query, getXWikiContext());\n    }\n\n    /**\n     * API to run a search from an XWikiQuery Object An XWikiQuery object can be created from a request using the\n     * createQueryFromRequest function\n     * \n     * @param query query to run the search for\n     * @return A list of document names matching the query\n     * @throws XWikiException exception is a failure occured\n     */\n    public <T> List<T> XWiki.search(XWikiQuery query) throws XWikiException\n    {\n        return this.xwiki.search(query, getXWikiContext());\n    }\n\n    /**\n     * API to create a query from a request Object The request object is the result of a form created from the\n     * displaySearch() and displaySearchColumns() functions\n     * \n     * @param className class name to create the query from\n     * @return an XWikiQuery object matching the selected values in the request object\n     * @throws XWikiException exception is a failure occured\n     */\n    public XWikiQuery XWiki.createQueryFromRequest(String className) throws XWikiException\n    {\n        return this.xwiki.createQueryFromRequest(className, getXWikiContext());\n    }\n\n    /**\n     * API to run a search from an XWikiQuery Object and display it as a HTML table An XWikiQuery object can be created\n     * from a request using the createQueryFromRequest function\n     * \n     * @param query query to run the search for\n     * @return An HTML table showing the result\n     * @throws XWikiException exception is a failure occured\n     */\n    public String XWiki.searchAsTable(XWikiQuery query) throws XWikiException\n    {\n        return this.xwiki.searchAsTable(query, getXWikiContext());\n    }\n\n    /**\n     * API to display a field in search mode for a specific class with preselected values This field data can then be\n     * used to generate an XWiki Query showing a table with the relevant data\n     * \n     * @param fieldname field name in the class\n     * @param className class name to display the field from\n     * @param criteria XWikiCriteria object (usually the XWikiQuery object) to take the preselected values from\n     * @return text of the select field\n     * @throws XWikiException exception is a failure occured\n     */\n    public String XWiki.displaySearch(String fieldname, String className, XWikiCriteria criteria) throws XWikiException\n    {\n        return this.xwiki.displaySearch(fieldname, className, criteria, getXWikiContext());\n    }\n\n    /**\n     * API to display a field in search mode for a specific class with preselected values, optionally adding a prefix to\n     * the field name This field data can then be used to generate an XWiki Query showing a table with the relevant data\n     * \n     * @param fieldname field name in the class\n     * @param className class name to display the field from\n     * @param prefix prefix to add to the field name\n     * @param criteria XWikiCriteria object (usually the XWikiQuery object) to take the preselected values from\n     * @return text of the select field\n     * @throws XWikiException exception is a failure occured\n     */\n    public String XWiki.displaySearch(String fieldname, String className, String prefix, XWikiCriteria criteria)\n        throws XWikiException\n    {\n        return this.xwiki.displaySearch(fieldname, className, prefix, criteria, getXWikiContext());\n    }\n\n    /**\n     * API to display a field in search mode for a specific class without preselected values This field data can then be\n     * used to generate an XWiki Query showing a table with the relevant data\n     * \n     * @param fieldname field name in the class\n     * @param className class name to display the field from\n     * @return text of the select field\n     * @throws XWikiException exception is a failure occured\n     */\n    public String XWiki.displaySearch(String fieldname, String className) throws XWikiException\n    {\n        return this.xwiki.displaySearch(fieldname, className, getXWikiContext());\n    }\n\n    /**\n     * Priviledged API to create a new Wiki from an existing wiki This creates the database, copies to documents from a\n     * existing wiki Assigns the admin rights, creates the Wiki identification page in the main wiki\n     * \n     * @param wikiName Wiki Name to create\n     * @param wikiUrl Wiki URL to accept requests from\n     * @param wikiAdmin Wiki admin user\n     * @param baseWikiName Wiki to copy documents from\n     * @param failOnExist true to fail if the wiki already exists, false to overwrite\n     * @return Success of Failure code (0 for success, -1 for missing programming rights, > 0 for other errors\n     * @throws XWikiException\n     * @deprecated use WikiManager plugin instead\n     */\n    @Deprecated\n    public int XWiki.createNewWiki(String wikiName, String wikiUrl, String wikiAdmin, String baseWikiName, boolean failOnExist)\n        throws XWikiException\n    {\n        return createNewWiki(wikiName, wikiUrl, wikiAdmin, baseWikiName, \"\", null, failOnExist);\n    }\n\n    /**\n     * Priviledged API to create a new Wiki from an existing wiki This creates the database, copies to documents from a\n     * existing wiki Assigns the admin rights, creates the Wiki identification page in the main wiki\n     * \n     * @param wikiName Wiki Name to create\n     * @param wikiUrl Wiki URL to accept requests from\n     * @param wikiAdmin Wiki admin user\n     * @param baseWikiName Wiki to copy documents from\n     * @param description Description of the Wiki\n     * @param failOnExist true to fail if the wiki already exists, false to overwrite\n     * @return Success of Failure code (0 for success, -1 for missing programming rights, > 0 for other errors\n     * @throws XWikiException\n     * @deprecated use WikiManager plugin instead\n     */\n    @Deprecated\n    public int XWiki.createNewWiki(String wikiName, String wikiUrl, String wikiAdmin, String baseWikiName,\n        String description, boolean failOnExist) throws XWikiException\n    {\n        return createNewWiki(wikiName, wikiUrl, wikiAdmin, baseWikiName, description, null, failOnExist);\n    }\n\n    /**\n     * Priviledged API to create a new Wiki from an existing wiki This creates the database, copies to documents from a\n     * existing wiki Assigns the admin rights, creates the Wiki identification page in the main wiki Copy is limited to\n     * documents of a specified language. If a document for the language is not found, the default language document is\n     * used\n     * \n     * @param wikiName Wiki Name to create\n     * @param wikiUrl Wiki URL to accept requests from\n     * @param wikiAdmin Wiki admin user\n     * @param baseWikiName Wiki to copy documents from\n     * @param description Description of the Wiki\n     * @param language Language to copy\n     * @param failOnExist true to fail if the wiki already exists, false to overwrite\n     * @return Success of Failure code (0 for success, -1 for missing programming rights, > 0 for other errors\n     * @throws XWikiException\n     * @deprecated use WikiManager plugin instead\n     */\n    @Deprecated\n    public int XWiki.createNewWiki(String wikiName, String wikiUrl, String wikiAdmin, String baseWikiName,\n        String description, String language, boolean failOnExist) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.createNewWiki(wikiName, wikiUrl, wikiAdmin, baseWikiName, description, language,\n                failOnExist, getXWikiContext());\n        }\n\n        return -1;\n    }\n\n    /**\n     * API to parse the message being stored in the Context. A message can be an error message or an information message\n     * either as text or as a message ID pointing to ApplicationResources. The message is also parse for velocity\n     * scripts\n     * \n     * @return Final message\n     * @deprecated use {@link org.xwiki.localization.LocalizationManager} instead. From velocity you can access it\n     *             using the {@code $services.localization} binding, see {@code LocalizationScriptService}\n     */\n    @Deprecated\n    public String XWiki.parseMessage()\n    {\n        return this.xwiki.parseMessage(getXWikiContext());\n    }\n\n    /**\n     * API allowing to count the total number of documents that would be returned by a query.\n     * \n     * @param wheresql Query to use, similar to the ones accepted by {@link #searchDocuments(String)}. If possible, it\n     *            should not contain <code>order by</code> or <code>group</code> clauses, since this kind of queries are\n     *            not portable.\n     * @return The number of documents that matched the query.\n     * @throws XWikiException if there was a problem executing the query.\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public int XWiki.countDocuments(String wheresql) throws XWikiException\n    {\n        return this.xwiki.getStore().countDocuments(wheresql, getXWikiContext());\n    }\n\n    /**\n     * API allowing to count the total number of documents that would be returned by a parameterized query.\n     * \n     * @param parameterizedWhereClause the parameterized query to use, similar to the ones accepted by\n     *            {@link #searchDocuments(String, List)}. If possible, it should not contain <code>order by</code> or\n     *            <code>group</code> clauses, since this kind of queries are not portable.\n     * @param parameterValues The parameter values that replace the question marks.\n     * @return The number of documents that matched the query.\n     * @throws XWikiException if there was a problem executing the query.\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public int XWiki.countDocuments(String parameterizedWhereClause, List< ? > parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().countDocuments(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }\n    \n\n    /**\n     * Privileged API allowing to run a search on the database returning a list of data This search is send to the store\n     * engine (Hibernate HQL, JCR XPATH or other).\n     * \n     * @param wheresql Query to be run (HQL, XPath)\n     * @return A list of rows (Object[])\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public <T> List<T> XWiki.search(String wheresql) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.search(wheresql, getXWikiContext());\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Privileged API allowing to run a search on the database returning a list of data. The HQL where clause uses\n     * parameters (question marks) instead of values, and the actual values are passed in the parameters list. This\n     * allows generating a query which will automatically encode the passed values (like escaping single quotes). This\n     * API is recommended to be used over the other similar methods where the values are passed inside the where clause\n     * and for which manual encoding/escaping is needed to avoid SQL injections or bad queries.\n     * \n     * @param parameterizedWhereClause query to be run (HQL)\n     * @param parameterValues the where clause values that replace the question marks\n     * @return a list of rows, where each row has either the selected data type ({@link XWikiDocument}, {@code String},\n     *         {@code Integer}, etc.), or {@code Object[]} if more than one column was selected\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public <T> List<T> XWiki.search(String parameterizedWhereClause, List< ? > parameterValues) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.getStore().search(parameterizedWhereClause, 0, 0, parameterValues, getXWikiContext());\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Privileged API allowing to run a search on the database returning a list of data. This search is sent to the\n     * store engine (Hibernate HQL, JCR XPATH or other)\n     * \n     * @param wheresql Query to be run (HQL, XPath)\n     * @param nb return only 'nb' rows\n     * @param start skip the 'start' first elements\n     * @return A list of rows (Object[])\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public <T> List<T> XWiki.search(String wheresql, int nb, int start) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.search(wheresql, nb, start, getXWikiContext());\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Privileged API allowing to run a search on the database returning a list of data. The HQL where clause uses\n     * parameters (question marks) instead of values, and the actual values are passed in the paremeters list. This\n     * allows generating a query which will automatically encode the passed values (like escaping single quotes). This\n     * API is recommended to be used over the other similar methods where the values are passed inside the where clause\n     * and for which manual encoding/escaping is needed to avoid sql injections or bad queries.\n     * \n     * @param parameterizedWhereClause query to be run (HQL)\n     * @param maxResults maximum number of results to return; if 0 all results are returned\n     * @param startOffset skip the first N results; if 0 no items are skipped\n     * @param parameterValues the where clause values that replace the question marks\n     * @return a list of rows, where each row has either the selected data type ({@link XWikiDocument}, {@code String},\n     *         {@code Integer}, etc.), or {@code Object[]} if more than one column was selected\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public <T> List<T> XWiki.search(String parameterizedWhereClause, int maxResults, int startOffset,\n        List< ? > parameterValues) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.getStore().search(parameterizedWhereClause, maxResults, startOffset, parameterValues,\n                getXWikiContext());\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Deprecated API which was retrieving the SQL to represent the fullName Document field depending on the database\n     * used This is not needed anymore and returns 'doc.fullName' for all databases\n     * \n     * @deprecated\n     * @return \"doc.fullName\"\n     */\n    @Deprecated\n    public String XWiki.getFullNameSQL()\n    {\n        return this.xwiki.getFullNameSQL();\n    }\n\n    /**\n     * @return secure {@link QueryManager} for execute queries to store.\n     * @deprecated since XE 2.4M2 use the Query Manager Script Service\n     */\n    @Deprecated\n    public QueryManager XWiki.getQueryManager()\n    {\n        return Utils.getComponent(QueryManager.class, \"secure\");\n    }\n\n    /**\n     * API to check if wiki is in multi-wiki mode (virtual)\n     * \n     * @deprecated Virtual mode is on by default, starting with XWiki 5.0M2.\n     * @return true for multi-wiki/false for mono-wiki\n     */\n    @Deprecated\n    public boolean XWiki.isVirtualMode()\n    {\n        return this.xwiki.isVirtualMode();\n    }\n\n    /**\n     * API to access the current starts for the Wiki for a specific action It retrieves the number of times the action\n     * was performed for the whole wiki The statistics module need to be activated (xwiki.stats=1 in xwiki.cfg)\n     * \n     * @param action action for which to retrieve statistics (view/save/download)\n     * @return A DocumentStats object with number of actions performed, unique visitors, number of visits\n     * @deprecated use {@link #getStatsService()} instead\n     */\n    @Deprecated\n    public DocumentStats XWiki.getCurrentMonthXWikiStats(String action)\n    {\n        return this.xwiki.getStatsService(getXWikiContext())\n            .getDocMonthStats(\"\", action, new Date(), getXWikiContext());\n    }\n\n    /**\n     * Privileged API to reset the rendering engine This would restore the rendering engine evaluation loop and take\n     * into account new configuration parameters\n     * \n     * @deprecated\n     */\n    @Deprecated\n    public void XWiki.resetRenderingEngine()\n    {\n        if (hasProgrammingRights()) {\n            try {\n                this.xwiki.resetRenderingEngine(getXWikiContext());\n            } catch (XWikiException e) {\n            }\n        }\n    }\n\n    /**\n     * API to render a text in the context of a document. Only works for xwiki/1.0 content.\n     *\n     * @param text text to render\n     * @param doc the text is evaluated in the content of this document\n     * @return evaluated content\n     * @throws XWikiException if the evaluation went wrong\n     * @deprecated\n     */\n    @Deprecated\n    public String XWiki.renderText(String text, Document doc) throws XWikiException\n    {\n        return Utils.getComponent(OldRendering.class).renderText(text, doc.getDoc(), getXWikiContext());\n    }\n\n    /**\n     * API to render a chunk (difference between two versions\n     *\n     * @param chunk difference between versions to render\n     * @param doc document to use as a context for rendering\n     * @return resuilt of the rendering\n     * @deprecated\n     */\n    @Deprecated\n    public String XWiki.renderChunk(Chunk chunk, Document doc)\n    {\n        return renderChunk(chunk, false, doc);\n    }\n\n    /**\n     * API to render a chunk (difference between two versions\n     *\n     * @param chunk difference between versions to render\n     * @param doc document to use as a context for rendering\n     * @param source true to render the difference as wiki source and not as wiki rendered text\n     * @return resuilt of the rendering\n     * @deprecated\n     */\n    @Deprecated\n    public String XWiki.renderChunk(Chunk chunk, boolean source, Document doc)\n    {\n        StringBuffer buf = new StringBuffer();\n        chunk.toString(buf, \"\", \"\\n\");\n        if (source == true) {\n            return buf.toString();\n        }\n\n        try {\n            return renderText(buf.toString(), doc);\n        } catch (Exception e) {\n            return buf.toString();\n        }\n    }\n\n    /**\n     * API to rename a page (experimental) Rights are necessary to edit the source and target page All objects and\n     * attachments ID are modified in the process to link to the new page name\n     *\n     * @param doc page to rename\n     * @param newFullName target page name to move the information to\n     * @deprecated since 12.0RC1. Use {@link Document#rename(DocumentReference)}.\n     */\n    @Deprecated\n    public boolean XWiki.renamePage(Document doc, String newFullName)\n    {\n        try {\n            if (this.xwiki.exists(newFullName, getXWikiContext()) && !this.xwiki.getRightService()\n                .hasAccessLevel(\"delete\", getXWikiContext().getUser(), newFullName, getXWikiContext())) {\n                return false;\n            }\n            if (this.xwiki.getRightService().hasAccessLevel(\"edit\", getXWikiContext().getUser(), doc.getFullName(),\n                getXWikiContext())) {\n                this.xwiki.renamePage(doc.getFullName(), newFullName, getXWikiContext());\n            }\n        } catch (XWikiException e) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @return the ids of configured syntaxes for this wiki (e.g. {@code xwiki/2.0}, {@code xwiki/2.1},\n     *         {@code mediawiki/1.0}, etc), taken only from {@code xwiki.cfg} (using the\n     *         {@code xwiki.rendering.syntaxes} property)\n     * @deprecated since 8.2M1, use the XWiki Rendering Configuration component or the Rendering Script Service one\n     *             instead (they use a more elaborate algorithm to find out the supported syntaxes)\n     */\n    @Deprecated\n    public List<String> XWiki.getConfiguredSyntaxes()\n    {\n        return this.xwiki.getConfiguredSyntaxes();\n    }\n}", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.FileTime;\nimport java.text.DateFormatSymbols;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.Vector;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.zip.ZipOutputStream;\n\nimport javax.annotation.Priority;\nimport javax.inject.Provider;\nimport javax.mail.Message;\nimport javax.mail.Session;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport javax.naming.NamingException;\nimport javax.script.ScriptContext;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.httpclient.Credentials;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.URIException;\nimport org.apache.commons.httpclient.UsernamePasswordCredentials;\nimport org.apache.commons.httpclient.auth.AuthScope;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.util.URIUtil;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.hibernate.HibernateException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.bridge.event.DocumentCreatedEvent;\nimport org.xwiki.bridge.event.DocumentCreatingEvent;\nimport org.xwiki.bridge.event.DocumentDeletedEvent;\nimport org.xwiki.bridge.event.DocumentDeletingEvent;\nimport org.xwiki.bridge.event.DocumentRolledBackEvent;\nimport org.xwiki.bridge.event.DocumentRollingBackEvent;\nimport org.xwiki.bridge.event.DocumentUpdatedEvent;\nimport org.xwiki.bridge.event.DocumentUpdatingEvent;\nimport org.xwiki.bridge.event.DocumentVersionRangeDeletedEvent;\nimport org.xwiki.bridge.event.DocumentVersionRangeDeletingEvent;\nimport org.xwiki.bridge.event.WikiCopiedEvent;\nimport org.xwiki.bridge.event.WikiDeletedEvent;\nimport org.xwiki.cache.Cache;\nimport org.xwiki.classloader.ClassLoaderManager;\nimport org.xwiki.component.event.ComponentDescriptorAddedEvent;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.manager.NamespacedComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.container.servlet.HttpServletUtils;\nimport org.xwiki.context.Execution;\nimport org.xwiki.edit.EditConfiguration;\nimport org.xwiki.extension.job.internal.InstallJob;\nimport org.xwiki.job.Job;\nimport org.xwiki.job.JobException;\nimport org.xwiki.job.JobExecutor;\nimport org.xwiki.job.annotation.Serializable;\nimport org.xwiki.job.event.JobFinishedEvent;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.job.event.status.JobStatus.State;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.mail.MailListener;\nimport org.xwiki.mail.MailSender;\nimport org.xwiki.mail.MailSenderConfiguration;\nimport org.xwiki.mail.MailStatusResultSerializer;\nimport org.xwiki.mail.XWikiAuthenticator;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.AttachmentReferenceResolver;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.PageReferenceResolver;\nimport org.xwiki.model.reference.RegexEntityReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.observation.EventListener;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.event.CancelableEvent;\nimport org.xwiki.observation.event.Event;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryFilter;\nimport org.xwiki.refactoring.ReferenceRenamer;\nimport org.xwiki.refactoring.batch.BatchOperationExecutor;\nimport org.xwiki.rendering.async.AsyncContext;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.Block.Axes;\nimport org.xwiki.rendering.block.MetaDataBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.MetadataBlockMatcher;\nimport org.xwiki.rendering.internal.transformation.MutableRenderingContext;\nimport org.xwiki.rendering.listener.MetaData;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.renderer.BlockRenderer;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxContent;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.resource.ResourceReference;\nimport org.xwiki.resource.ResourceReferenceManager;\nimport org.xwiki.resource.ResourceReferenceResolver;\nimport org.xwiki.resource.ResourceType;\nimport org.xwiki.resource.ResourceTypeResolver;\nimport org.xwiki.resource.entity.EntityResourceReference;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.skin.Resource;\nimport org.xwiki.skin.Skin;\nimport org.xwiki.skin.SkinManager;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.template.TemplateManager;\nimport org.xwiki.url.ExtendedURL;\nimport org.xwiki.url.URLConfiguration;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserPropertiesResolver;\nimport org.xwiki.velocity.VelocityContextFactory;\nimport org.xwiki.velocity.VelocityManager;\nimport org.xwiki.velocity.XWikiVelocityContext;\nimport org.xwiki.velocity.XWikiVelocityException;\nimport org.xwiki.wiki.descriptor.WikiDescriptor;\nimport org.xwiki.wiki.descriptor.WikiDescriptorManager;\nimport org.xwiki.wiki.manager.WikiManager;\nimport org.xwiki.wiki.manager.WikiManagerException;\nimport org.xwiki.xml.XMLUtils;\n\nimport com.xpn.xwiki.api.Api;\nimport com.xpn.xwiki.api.Document;\nimport com.xpn.xwiki.api.User;\nimport com.xpn.xwiki.criteria.api.XWikiCriteriaService;\nimport com.xpn.xwiki.doc.DeletedAttachment;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.MandatoryDocumentInitializer;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiAttachmentArchive;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocument.XWikiAttachmentToRemove;\nimport com.xpn.xwiki.doc.XWikiDocumentArchive;\nimport com.xpn.xwiki.internal.WikiInitializerJob;\nimport com.xpn.xwiki.internal.WikiInitializerRequest;\nimport com.xpn.xwiki.internal.XWikiCfgConfigurationSource;\nimport com.xpn.xwiki.internal.XWikiConfigDelegate;\nimport com.xpn.xwiki.internal.XWikiInitializerJob;\nimport com.xpn.xwiki.internal.debug.DebugConfiguration;\nimport com.xpn.xwiki.internal.event.MandatoryDocumentsInitializedEvent;\nimport com.xpn.xwiki.internal.event.MandatoryDocumentsInitializingEvent;\nimport com.xpn.xwiki.internal.event.UserCreatingDocumentEvent;\nimport com.xpn.xwiki.internal.event.UserDeletingDocumentEvent;\nimport com.xpn.xwiki.internal.event.UserUpdatingDocumentEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyAddedEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyDeletedEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyUpdatedEvent;\nimport com.xpn.xwiki.internal.mandatory.XWikiPreferencesDocumentInitializer;\nimport com.xpn.xwiki.internal.render.OldRendering;\nimport com.xpn.xwiki.internal.render.groovy.ParseGroovyFromString;\nimport com.xpn.xwiki.internal.skin.InternalSkinConfiguration;\nimport com.xpn.xwiki.internal.skin.InternalSkinManager;\nimport com.xpn.xwiki.internal.skin.WikiSkin;\nimport com.xpn.xwiki.internal.skin.WikiSkinUtils;\nimport com.xpn.xwiki.internal.store.StoreConfiguration;\nimport com.xpn.xwiki.internal.store.hibernate.HibernateConfiguration;\nimport com.xpn.xwiki.internal.velocity.VelocityEvaluator;\nimport com.xpn.xwiki.job.JobRequestContext;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.PropertyInterface;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.PasswordClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.objects.meta.MetaClass;\nimport com.xpn.xwiki.plugin.XWikiPluginInterface;\nimport com.xpn.xwiki.plugin.XWikiPluginManager;\nimport com.xpn.xwiki.render.groovy.XWikiPageClassLoader;\nimport com.xpn.xwiki.stats.api.XWikiStatsService;\nimport com.xpn.xwiki.stats.impl.SearchEngineRule;\nimport com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl;\nimport com.xpn.xwiki.store.AttachmentRecycleBinStore;\nimport com.xpn.xwiki.store.AttachmentVersioningStore;\nimport com.xpn.xwiki.store.XWikiAttachmentStoreInterface;\nimport com.xpn.xwiki.store.XWikiCacheStoreInterface;\nimport com.xpn.xwiki.store.XWikiHibernateStore;\nimport com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;\nimport com.xpn.xwiki.store.XWikiStoreInterface;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.user.api.XWikiAuthService;\nimport com.xpn.xwiki.user.api.XWikiGroupService;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiRightServiceImpl;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.util.XWikiStubContextProvider;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiEngineContext;\nimport com.xpn.xwiki.web.XWikiMessageTool;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiServletRequestStub;\nimport com.xpn.xwiki.web.XWikiURLFactory;\nimport com.xpn.xwiki.web.XWikiURLFactoryService;\nimport com.xpn.xwiki.web.XWikiURLFactoryServiceImpl;\nimport com.xpn.xwiki.web.includeservletasstring.IncludeServletAsString;\n\n@Serializable(false)\npublic class XWiki implements EventListener\n{\n    /** Name of the default wiki. */\n    public static final String DEFAULT_MAIN_WIKI = \"xwiki\";\n\n    /** Name of the default home space. */\n    public static final String DEFAULT_HOME_SPACE = \"Main\";\n\n    /** Name of the default system space. */\n    public static final String SYSTEM_SPACE = \"XWiki\";\n\n    /**\n     * Name of the default system space as an EntityReference.\n     * \n     * @since 13.2RC1\n     */\n    public static final EntityReference SYSTEM_SPACE_REFERENCE = new EntityReference(\"XWiki\", EntityType.SPACE);\n\n    /** Name of the default space homepage. */\n    public static final String DEFAULT_SPACE_HOMEPAGE = \"WebHome\";\n\n    public static final String CKEY_SKIN = InternalSkinManager.CKEY_SKIN;\n\n    public static final String CKEY_BASESKIN = InternalSkinManager.CKEY_PARENTSKIN;\n\n    public static final String DEFAULT_SKIN = InternalSkinConfiguration.DEFAULT_SKIN;\n\n    /**\n     * Query parameters used to control the browser cache version of a resource.\n     */\n    public static final String CACHE_VERSION = \"cache-version\";\n\n    /** Logging helper object. */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);\n\n    /** Frequently used Document reference, the class which holds virtual wiki definitions. */\n    private static final DocumentReference VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE =\n        new DocumentReference(DEFAULT_MAIN_WIKI, SYSTEM_SPACE, \"XWikiServerClass\");\n\n    /** The default encoding, and the internally used encoding when dealing with byte representation of strings. */\n    public static final String DEFAULT_ENCODING = \"UTF-8\";\n\n    /** Represents no value (ie the default value will be used) in xproperties */\n    private static final String NO_VALUE = \"---\";\n\n    /**\n     * List of top level space names that can be used in the fake context document created when accessing a resource\n     * with the 'skin' action.\n     */\n    private static final List<String> SKIN_RESOURCE_SPACE_NAMES = Arrays.asList(\"skins\", \"resources\");\n\n    /** The main document storage. */\n    private XWikiStoreInterface store;\n\n    /** The attachment content storage. */\n    private XWikiAttachmentStoreInterface defaultAttachmentContentStore;\n\n    /** The attachment archive storage. */\n    private AttachmentVersioningStore defaultAttachmentArchiveStore;\n\n    /** Document versioning storage. */\n    private XWikiVersioningStoreInterface versioningStore;\n\n    /** Deleted documents storage. */\n    private XWikiRecycleBinStoreInterface recycleBinStore;\n\n    private AttachmentRecycleBinStore attachmentRecycleBinStore;\n\n    private XWikiPluginManager pluginManager;\n\n    private XWikiAuthService authService;\n\n    private XWikiRightService rightService;\n\n    private XWikiGroupService groupService;\n\n    private XWikiStatsService statsService;\n\n    private XWikiURLFactoryService urlFactoryService;\n\n    private XWikiCriteriaService criteriaService;\n\n    /** Lock object used for the lazy initialization of the authentication service. */\n    private final Object AUTH_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the authorization service. */\n    private final Object RIGHT_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the group management service. */\n    private final Object GROUP_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the statistics service. */\n    private final Object STATS_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the URL Factory service. */\n    private final Object URLFACTORY_SERVICE_LOCK = new Object();\n\n    private MetaClass metaclass;\n\n    private String version;\n\n    private XWikiEngineContext engine_context;\n\n    private String database;\n\n    private String fullNameSQL;\n\n    /**\n     * The list of initialized wikis.\n     */\n    private Map<String, WikiInitializerJob> initializedWikis = new ConcurrentHashMap<>();\n\n    private boolean isReadOnly = false;\n\n    /**\n     * @deprecated since 6.1M2, use {@link XWikiCfgConfigurationSource#CFG_ENV_NAME} instead\n     */\n    @Deprecated\n    public static final String CFG_ENV_NAME = XWikiCfgConfigurationSource.CFG_ENV_NAME;\n\n    public static final String MACROS_FILE = \"/templates/macros.txt\";\n\n    /**\n     * File containing XWiki's version, in the format: <version name>.<SVN revision number>.\n     */\n    private static final String VERSION_FILE = \"/WEB-INF/version.properties\";\n\n    /**\n     * Property containing the version value in the {@link #VERSION_FILE} file.\n     */\n    private static final String VERSION_FILE_PROPERTY = \"version\";\n\n    private static XWikiInitializerJob job;\n\n    /** Used to convert a proper Document Reference to string (standard form). */\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead.\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    private DocumentReferenceResolver<EntityReference> currentReferenceDocumentReferenceResolver;\n\n    private EntityReferenceResolver<String> currentMixedEntityReferenceResolver;\n\n    private EntityReferenceResolver<String> relativeEntityReferenceResolver;\n\n    private EntityReferenceSerializer<String> localStringEntityReferenceSerializer;\n\n    private ResourceReferenceManager resourceReferenceManager;\n\n    private JobExecutor jobExecutor;\n\n    private InternalSkinManager internalSkinManager;\n\n    private TemplateManager templateManager;\n\n    private RenderingContext renderingContext;\n\n    private VelocityEvaluator velocityEvaluator;\n\n    /**\n     * Whether backlinks are enabled or not (cached for performance).\n     *\n     * @since 3.2M2\n     */\n    private Boolean hasBacklinks;\n\n    private ConfigurationSource xwikicfg;\n\n    private ConfigurationSource wikiConfiguration;\n\n    private UserPropertiesResolver userPropertiesResolver;\n\n    private ConfigurationSource spaceConfiguration;\n\n    private EditConfiguration editConfiguration;\n\n    private URLConfiguration urlConfiguration;\n\n    private StoreConfiguration storeConfiguration;\n\n    private HibernateConfiguration hibernateConfiguration;\n\n    private ObservationManager observationManager;\n\n    private Provider<XWikiContext> xcontextProvider;\n\n    private ContextualLocalizationManager localization;\n\n    private Provider<OldRendering> oldRenderingProvider;\n\n    private ParseGroovyFromString parseGroovyFromString;\n\n    private JobProgressManager progress;\n\n    private Provider<DocumentReference> defaultDocumentReferenceProvider;\n\n    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;\n\n    private PageReferenceResolver<EntityReference> currentgetpageResolver;\n\n    private AttachmentReferenceResolver<EntityReference> currentAttachmentReferenceResolver;\n\n    private WikiSkinUtils wikiSkinUtils;\n\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private VelocityContextFactory velocityContextFactory;\n\n    private WikiDescriptorManager wikiDescriptorManager;\n\n    private AsyncContext asyncContext;\n\n    private ConfigurationSource getConfiguration()\n    {\n        if (this.xwikicfg == null) {\n            this.xwikicfg = Utils.getComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT);\n        }\n\n        return this.xwikicfg;\n    }\n\n    private ConfigurationSource getWikiConfiguration()\n    {\n        if (this.wikiConfiguration == null) {\n            this.wikiConfiguration = Utils.getComponent(ConfigurationSource.class, \"wiki\");\n        }\n\n        return this.wikiConfiguration;\n    }\n\n    private ConfigurationSource getSpaceConfiguration()\n    {\n        if (this.spaceConfiguration == null) {\n            this.spaceConfiguration = Utils.getComponent(ConfigurationSource.class, \"space\");\n        }\n\n        return this.spaceConfiguration;\n    }\n\n    private UserPropertiesResolver getAllUserPropertiesResolver()\n    {\n        if (this.userPropertiesResolver == null) {\n            this.userPropertiesResolver = Utils.getComponent(UserPropertiesResolver.class, \"all\");\n        }\n\n        return this.userPropertiesResolver;\n    }\n\n    private EditConfiguration getEditConfiguration()\n    {\n        if (this.editConfiguration == null) {\n            this.editConfiguration = Utils.getComponent(EditConfiguration.class);\n        }\n\n        return this.editConfiguration;\n    }\n\n    private URLConfiguration getURLConfiguration()\n    {\n        if (this.urlConfiguration == null) {\n            this.urlConfiguration = Utils.getComponent(URLConfiguration.class);\n        }\n\n        return this.urlConfiguration;\n    }\n\n    private StoreConfiguration getStoreConfiguration()\n    {\n        if (this.storeConfiguration == null) {\n            this.storeConfiguration = Utils.getComponent(StoreConfiguration.class);\n        }\n\n        return this.storeConfiguration;\n    }\n\n    private HibernateConfiguration getHibernateConfiguration()\n    {\n        if (this.hibernateConfiguration == null) {\n            this.hibernateConfiguration = Utils.getComponent(HibernateConfiguration.class);\n        }\n\n        return this.hibernateConfiguration;\n    }\n\n    private InternalSkinManager getInternalSkinManager()\n    {\n        if (this.internalSkinManager == null) {\n            this.internalSkinManager = Utils.getComponent(InternalSkinManager.class);\n        }\n\n        return this.internalSkinManager;\n    }\n\n    private TemplateManager getTemplateManager()\n    {\n        if (this.templateManager == null) {\n            this.templateManager = Utils.getComponent(TemplateManager.class);\n        }\n\n        return this.templateManager;\n    }\n\n    private RenderingContext getRenderingContext()\n    {\n        if (this.renderingContext == null) {\n            this.renderingContext = Utils.getComponent(RenderingContext.class);\n        }\n\n        return this.renderingContext;\n    }\n\n    private MutableRenderingContext getMutableRenderingContext()\n    {\n        return getRenderingContext() instanceof MutableRenderingContext\n            ? (MutableRenderingContext) getRenderingContext() : null;\n    }\n\n    private VelocityEvaluator getVelocityEvaluator()\n    {\n        if (this.velocityEvaluator == null) {\n            this.velocityEvaluator = Utils.getComponent(VelocityEvaluator.class);\n        }\n\n        return this.velocityEvaluator;\n    }\n\n    private ObservationManager getObservationManager()\n    {\n        if (this.observationManager == null) {\n            this.observationManager = Utils.getComponent(ObservationManager.class);\n        }\n\n        return this.observationManager;\n    }\n\n    private XWikiContext getXWikiContext()\n    {\n        if (this.xcontextProvider == null) {\n            this.xcontextProvider = Utils.getComponent(XWikiContext.TYPE_PROVIDER);\n        }\n\n        return this.xcontextProvider.get();\n    }\n\n    private ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    private OldRendering getOldRendering()\n    {\n        if (this.oldRenderingProvider == null) {\n            this.oldRenderingProvider = Utils.getComponent(OldRendering.TYPE_PROVIDER);\n        }\n\n        return this.oldRenderingProvider.get();\n    }\n\n    private ParseGroovyFromString getParseGroovyFromString()\n    {\n        if (this.parseGroovyFromString == null) {\n            this.parseGroovyFromString = Utils.getComponent(ParseGroovyFromString.class);\n        }\n\n        return this.parseGroovyFromString;\n    }\n\n    private JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    private Provider<DocumentReference> getDefaultDocumentReferenceProvider()\n    {\n        if (this.defaultDocumentReferenceProvider == null) {\n            this.defaultDocumentReferenceProvider = Utils.getComponent(DocumentReference.TYPE_PROVIDER);\n        }\n\n        return this.defaultDocumentReferenceProvider;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentGetDocumentResolver()\n    {\n        if (this.currentgetdocumentResolver == null) {\n            this.currentgetdocumentResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");\n        }\n\n        return this.currentgetdocumentResolver;\n    }\n\n    private PageReferenceResolver<EntityReference> getCurrentGetPageResolver()\n    {\n        if (this.currentgetpageResolver == null) {\n            this.currentgetpageResolver = Utils.getComponent(PageReferenceResolver.TYPE_REFERENCE, \"currentgetpage\");\n        }\n\n        return this.currentgetpageResolver;\n    }\n\n    private AttachmentReferenceResolver<EntityReference> getCurrentAttachmentResolver()\n    {\n        if (this.currentAttachmentReferenceResolver == null) {\n            this.currentAttachmentReferenceResolver =\n                Utils.getComponent(AttachmentReferenceResolver.TYPE_REFERENCE, \"current\");\n        }\n\n        return this.currentAttachmentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()\n    {\n        if (this.defaultEntityReferenceSerializer == null) {\n            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultEntityReferenceSerializer;\n    }\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (this.currentMixedDocumentReferenceResolver == null) {\n            this.currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedDocumentReferenceResolver;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentReferenceDocumentReferenceResolver()\n    {\n        if (this.currentReferenceDocumentReferenceResolver == null) {\n            this.currentReferenceDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n        }\n\n        return this.currentReferenceDocumentReferenceResolver;\n    }\n\n    private EntityReferenceResolver<String> getCurrentMixedEntityReferenceResolver()\n    {\n        if (this.currentMixedEntityReferenceResolver == null) {\n            this.currentMixedEntityReferenceResolver =\n                Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedEntityReferenceResolver;\n    }\n\n    private EntityReferenceResolver<String> getRelativeEntityReferenceResolver()\n    {\n        if (this.relativeEntityReferenceResolver == null) {\n            this.relativeEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"relative\");\n        }\n\n        return this.relativeEntityReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getLocalStringEntityReferenceSerializer()\n    {\n        if (this.localStringEntityReferenceSerializer == null) {\n            this.localStringEntityReferenceSerializer =\n                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n\n        return this.localStringEntityReferenceSerializer;\n    }\n\n    private ResourceReferenceManager getResourceReferenceManager()\n    {\n        if (this.resourceReferenceManager == null) {\n            this.resourceReferenceManager = Utils.getComponent(ResourceReferenceManager.class);\n        }\n\n        return this.resourceReferenceManager;\n    }\n\n    private JobExecutor getJobExecutor()\n    {\n        if (this.jobExecutor == null) {\n            this.jobExecutor = Utils.getComponent(JobExecutor.class);\n        }\n\n        return this.jobExecutor;\n    }\n\n    private DocumentReference getDefaultDocumentReference()\n    {\n        return getDefaultDocumentReferenceProvider().get();\n    }\n\n    private WikiSkinUtils getWikiSkinUtils()\n    {\n        if (this.wikiSkinUtils == null) {\n            this.wikiSkinUtils = Utils.getComponent(WikiSkinUtils.class);\n        }\n\n        return this.wikiSkinUtils;\n    }\n\n    private DocumentRevisionProvider getDocumentRevisionProvider()\n    {\n        if (this.documentRevisionProvider == null) {\n            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);\n        }\n\n        return this.documentRevisionProvider;\n    }\n\n    private VelocityContextFactory getVelocityContextFactory()\n    {\n        if (this.velocityContextFactory == null) {\n            this.velocityContextFactory = Utils.getComponent(VelocityContextFactory.class);\n        }\n\n        return this.velocityContextFactory;\n    }\n\n    private WikiDescriptorManager getWikiDescriptorManager()\n    {\n        if (this.wikiDescriptorManager == null) {\n            this.wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n        }\n\n        return this.wikiDescriptorManager;\n    }\n\n    private AsyncContext getAsyncContext()\n    {\n        if (this.asyncContext == null) {\n            this.asyncContext = Utils.getComponent(AsyncContext.class);\n        }\n\n        return this.asyncContext;\n    }\n\n    private String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public static XWiki getMainXWiki(XWikiContext context) throws XWikiException\n    {\n        return getMainXWiki(true, context);\n    }\n\n    /**\n     * @param wait true if the method should way for {@link XWiki} instance to be initialized\n     * @param context see {@link XWikiContext}\n     */\n    public static XWiki getMainXWiki(boolean wait, XWikiContext context) throws XWikiException\n    {\n        String xwikiname = DEFAULT_MAIN_WIKI;\n\n        context.setMainXWiki(xwikiname);\n\n        XWiki xwiki;\n\n        try {\n            XWikiEngineContext econtext = context.getEngineContext();\n\n            xwiki = (XWiki) econtext.getAttribute(xwikiname);\n            if (xwiki == null) {\n                // Start XWiki initialization\n                synchronized (XWiki.class) {\n                    xwiki = (XWiki) econtext.getAttribute(xwikiname);\n                    if (xwiki == null && job == null) {\n                        job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);\n\n                        if (job.getStatus() == null) {\n                            // \"Pre-initialize\" XWikiStubContextProvider so that XWiki initializer can find one\n                            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class)\n                                .initialize(context);\n\n                            job.startAsync();\n                        }\n                    }\n                }\n\n                // Wait until XWiki is initialized\n                if (wait) {\n                    job.join();\n                    xwiki = (XWiki) econtext.getAttribute(xwikiname);\n                }\n            }\n\n            context.setWiki(xwiki);\n\n            return xwiki;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                \"Could not initialize main XWiki instance\", e);\n        }\n    }\n\n    public static boolean isInitializing(XWikiContext xcontext)\n    {\n        return Boolean.TRUE.equals(xcontext.getEngineContext().getAttribute(\"xwiki.init\"));\n    }\n\n    /**\n     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.\n     *\n     * @param context see {@link XWikiContext}\n     * @return an XWiki object configured for the wiki corresponding to the current request\n     * @throws XWikiException if the requested URL does not correspond to a real wiki, or if there's an error in the\n     *             storage\n     */\n    public static XWiki getXWiki(XWikiContext context) throws XWikiException\n    {\n        return getXWiki(true, context);\n    }\n\n    /**\n     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.\n     * <p>\n     * Unless <code>wait</code> is false the method return right away null if XWiki is not yet initialized.\n     *\n     * @param wait wait until XWiki is initialized\n     * @param xcontext see {@link XWikiContext}\n     * @return an XWiki object configured for the wiki corresponding to the current request\n     * @throws XWikiException if the requested URL does not correspond to a real wiki, or if there's an error in the\n     *             storage\n     */\n    public static XWiki getXWiki(boolean wait, XWikiContext xcontext) throws XWikiException\n    {\n        XWiki xwiki = getMainXWiki(wait, xcontext);\n\n        if (xwiki == null) {\n            return null;\n        }\n\n        // Extract Entity Resource from URL and put it in the Execution Context\n        EntityResourceReference entityResourceReference = initializeResourceFromURL(xcontext);\n\n        // If not an entity resource reference assume main wiki\n        if (entityResourceReference == null) {\n            return xwiki;\n        }\n\n        // Get the wiki id\n        String wikiId = entityResourceReference.getEntityReference().extractReference(EntityType.WIKI).getName();\n        if (wikiId.equals(xcontext.getMainXWiki())) {\n            // The main wiki was requested.\n            return xwiki;\n        }\n\n        // Check if the wiki exists by checking if a descriptor exists for the wiki id.\n        WikiDescriptorManager wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n        WikiDescriptor descriptor;\n        try {\n            descriptor = wikiDescriptorManager.getById(wikiId);\n        } catch (WikiManagerException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_STORE_MISC,\n                String.format(\"Failed find wiki descriptor for wiki id [%s]\", wikiId), e);\n        }\n        if (descriptor == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_DOES_NOT_EXIST,\n                String.format(\"The wiki [%s] does not exist\", wikiId));\n        }\n\n        // Initialize wiki\n\n        xcontext.setWikiId(wikiId);\n        xcontext.setOriginalWikiId(wikiId);\n\n        if (!xwiki.initializeWiki(wikiId, wait, xcontext)) {\n            // The wiki is still initializing\n            return null;\n        }\n\n        return xwiki;\n    }\n\n    /**\n     * @param wikiId the identifier of the wiki\n     * @return the current {@link WikiInitializerJob} associated to the passed wiki or null if there is none\n     */\n    public Job getWikiInitializerJob(String wikiId)\n    {\n        return this.initializedWikis.get(wikiId);\n    }\n\n    /**\n     * Make sure the wiki is initializing or wait for it.\n     * \n     * @param wikiId the identifier of the wiki to initialize\n     * @param wait true if the method should return only when the wiki is fully initialized\n     * @return true if the wiki is fully initialized\n     * @param xcontext the XWiki context\n     * @throws XWikiException when the initialization failed\n     * @since 8.4RC1\n     */\n    public boolean initializeWiki(String wikiId, boolean wait, XWikiContext xcontext) throws XWikiException\n    {\n        Job wikiJob = this.initializedWikis.get(wikiId);\n\n        // Create and start the job if it does not exist\n        if (wikiJob == null) {\n            try {\n                wikiJob = initializeWiki(wikiId, xcontext);\n            } catch (JobException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Could not start [\" + wikiId + \"] wiki initialization\", e);\n            }\n        }\n\n        // Check if the job is done\n        if (wikiJob.getStatus().getState() == State.FINISHED) {\n            return true;\n        }\n\n        // Wait until the job is finished if asked to\n        if (wait) {\n            try {\n                wikiJob.join();\n            } catch (InterruptedException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Wiki [\" + wikiId + \"] initialization was interrupted unexpectedly\", e);\n            }\n\n            if (wikiJob.getStatus().getError() != null) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Wiki [\" + wikiId + \"] initialization failed\", wikiJob.getStatus().getError());\n            }\n\n            return true;\n        }\n\n        // Still initializing\n        return false;\n    }\n\n    private Job initializeWiki(String wikiId, XWikiContext xcontext) throws JobException\n    {\n        synchronized (this.initializedWikis) {\n            WikiInitializerJob wikiJob = this.initializedWikis.get(wikiId);\n\n            if (wikiJob == null) {\n                WikiInitializerRequest request = new WikiInitializerRequest(wikiId);\n\n                JobRequestContext.set(request, xcontext);\n\n                wikiJob = (WikiInitializerJob) getJobExecutor().execute(WikiInitializerJob.JOBTYPE, request);\n                this.initializedWikis.put(wikiId, wikiJob);\n            }\n\n            return wikiJob;\n        }\n    }\n\n    private static EntityResourceReference initializeResourceFromURL(XWikiContext context) throws XWikiException\n    {\n        // Extract the Entity Resource from the URL\n        // TODO: This code should be put in an ExecutionContextInitializer but we couldn't do yet since this code\n        // requires that the XWiki object be initialized first (the line above). Thus we'll be able to to move it only\n        // after the XWiki init is done also in an ExecutionContextInitializer (and with priorities).\n        @SuppressWarnings(\"deprecation\")\n        EntityResourceReference entityResourceReference;\n        URL url = context.getURL();\n        try {\n            ExtendedURL extendedURL = new ExtendedURL(url, context.getRequest().getContextPath());\n            ResourceTypeResolver<ExtendedURL> typeResolver =\n                Utils.getComponent(new DefaultParameterizedType(null, ResourceTypeResolver.class, ExtendedURL.class));\n            ResourceType type = typeResolver.resolve(extendedURL, Collections.<String, Object>emptyMap());\n            ResourceReferenceResolver<ExtendedURL> resourceResolver = Utils\n                .getComponent(new DefaultParameterizedType(null, ResourceReferenceResolver.class, ExtendedURL.class));\n            ResourceReference reference =\n                resourceResolver.resolve(extendedURL, type, Collections.<String, Object>emptyMap());\n            entityResourceReference =\n                reference instanceof EntityResourceReference ? (EntityResourceReference) reference : null;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION,\n                String.format(\"Failed to extract Entity Resource Reference from URL [%s]\", url), e);\n        }\n        Utils.getComponent(Execution.class).getContext().setProperty(ResourceReferenceManager.RESOURCE_CONTEXT_PROPERTY,\n            entityResourceReference);\n\n        return entityResourceReference;\n    }\n\n    public static URL getRequestURL(XWikiRequest request) throws XWikiException\n    {\n        return HttpServletUtils.getSourceURL(request);\n    }\n\n    public static Object callPrivateMethod(Object obj, String methodName)\n    {\n        return callPrivateMethod(obj, methodName, null, null);\n    }\n\n    public static Object callPrivateMethod(Object obj, String methodName, Class<?>[] classes, Object[] args)\n    {\n        try {\n            Method method = obj.getClass().getDeclaredMethod(methodName, classes);\n            method.setAccessible(true);\n            return method.invoke(obj, args);\n        } catch (IllegalAccessException e) {\n            LOGGER.error(\"Failed to call private method [{}]: [{}]\", methodName, e);\n\n            return null;\n        } catch (NoSuchMethodException e) {\n            return null;\n        } catch (InvocationTargetException e) {\n            LOGGER.error(\"Private method [{}] failed: [{}]\", methodName, e);\n\n            return null;\n        }\n    }\n\n    public static HttpClient getHttpClient(int timeout, String userAgent)\n    {\n        HttpClient client = new HttpClient();\n\n        if (timeout != 0) {\n            client.getParams().setSoTimeout(timeout);\n            client.getParams().setParameter(\"http.connection.timeout\", Integer.valueOf(timeout));\n        }\n\n        client.getParams().setParameter(\"http.useragent\", userAgent);\n\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if ((proxyHost != null) && (!proxyHost.equals(\"\"))) {\n            int port = 3128;\n            if ((proxyPort != null) && (!proxyPort.equals(\"\"))) {\n                port = Integer.parseInt(proxyPort);\n            }\n            client.getHostConfiguration().setProxy(proxyHost, port);\n        }\n\n        String proxyUser = System.getProperty(\"http.proxyUser\");\n        if ((proxyUser != null) && (!proxyUser.equals(\"\"))) {\n            String proxyPassword = System.getProperty(\"http.proxyPassword\");\n            Credentials defaultcreds = new UsernamePasswordCredentials(proxyUser, proxyPassword);\n            client.getState().setProxyCredentials(AuthScope.ANY, defaultcreds);\n        }\n\n        return client;\n    }\n\n    /**\n     * Using reflection, read the private value of the passed field name for the passed object.\n     *\n     * @param obj the java object on which to read the private field value\n     * @param fieldName the object member field for which to read the value\n     * @return the private value for the field\n     * @deprecated use {@link FieldUtils#readDeclaredField(Object, String, boolean)} instead\n     */\n    @Deprecated\n    public static Object getPrivateField(Object obj, String fieldName)\n    {\n        try {\n            Field field = obj.getClass().getDeclaredField(fieldName);\n            field.setAccessible(true);\n            return field.get(obj);\n        } catch (NoSuchFieldException e) {\n            return null;\n        } catch (IllegalAccessException e) {\n            LOGGER.error(\"Failed to get private field with name [{}]: [{}]\", fieldName, e);\n\n            return null;\n        } finally {\n        }\n    }\n\n    public static String getServerWikiPage(String servername)\n    {\n        return \"XWiki.XWikiServer\" + StringUtils.capitalize(servername);\n    }\n\n    /**\n     * @param content the content of the text area\n     * @param context see {@link XWikiContext}\n     */\n    public static String getTextArea(String content, XWikiContext context)\n    {\n        StringBuilder result = new StringBuilder();\n\n        // Forcing a new line after the <textarea> tag, as\n        // http://www.w3.org/TR/html4/appendix/notes.html#h-B.3.1 causes an empty line at the start\n        // of the document content to be trimmed.\n        result.append(\"<textarea name=\\\"content\\\" id=\\\"content\\\" rows=\\\"25\\\" cols=\\\"80\\\">\\n\");\n        result.append(XMLUtils.escape(content));\n        result.append(\"</textarea>\");\n\n        return result.toString();\n    }\n\n    /**\n     * This provide a way to create an XWiki object without initializing the whole XWiki (including plugins, storage,\n     * etc.).\n     * <p>\n     * Needed for tools or tests which need XWiki because it is used everywhere in the API.\n     */\n    public XWiki()\n    {\n        // Empty voluntarily\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public XWiki(XWikiContext context, XWikiEngineContext engineContext, boolean noupdate) throws XWikiException\n    {\n        initXWiki(context, engineContext, noupdate);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public XWiki(XWikiContext context) throws XWikiException\n    {\n        this(context, null, false);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public void initXWiki(XWikiContext context, XWikiEngineContext engineContext, boolean noupdate)\n        throws XWikiException\n    {\n        initXWiki(null, context, engineContext, noupdate);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param config the object holding the XWiki configuration read from {@code xwiki.cfg}\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     * @deprecated since 6.1M2, use {@link #initXWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public void initXWiki(XWikiConfig config, XWikiContext context, XWikiEngineContext engineContext, boolean noupdate)\n        throws XWikiException\n    {\n        getProgress().pushLevelProgress(4, this);\n\n        try {\n            getProgress().startStep(this);\n\n            setDatabase(context.getMainXWiki());\n\n            setEngineContext(engineContext);\n            context.setWiki(this);\n\n            // \"Pre-initialize\" XWikiStubContextProvider with a XWikiContext containing a XWiki instance as soon as\n            // possible\n            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class).initialize(context);\n\n            // Prepare the store\n            if (config != null) {\n                setConfig(config);\n            }\n\n            try {\n                initializeStores();\n            } catch (ComponentLookupException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                    \"Failed to initialize stores\", e);\n            }\n\n            setCriteriaService((XWikiCriteriaService) createClassFromConfig(\"xwiki.criteria.class\",\n                \"com.xpn.xwiki.criteria.impl.XWikiCriteriaServiceImpl\", context));\n\n            // \"Pre-initialize\" XWikiStubContextProvider so that rendering engine, plugins or listeners reacting to\n            // potential document changes can use it\n            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class).initialize(context);\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            // Make sure these classes exists\n            if (noupdate) {\n                getProgress().pushLevelProgress(2, this);\n\n                try {\n                    getProgress().startStep(this);\n\n                    initializeMandatoryDocuments(context);\n\n                    getProgress().startStep(this);\n\n                    getStatsService(context);\n                } finally {\n                    getProgress().popLevelProgress(this);\n                }\n            }\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            // Prepare the Plugin Engine\n            preparePlugins(context);\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            String ro = getConfiguration().getProperty(\"xwiki.readonly\", \"no\");\n            this.isReadOnly = (\"yes\".equalsIgnoreCase(ro) || \"true\".equalsIgnoreCase(ro) || \"1\".equalsIgnoreCase(ro));\n\n            getObservationManager().addListener(this);\n        } finally {\n            getProgress().popLevelProgress(this);\n        }\n    }\n\n    private void initializeStores() throws ComponentLookupException\n    {\n        XWikiStoreInterface mainStore = getStoreConfiguration().getXWikiStore();\n\n        // Check if we need to use the cache store..\n        if (getStoreConfiguration().isStoreCacheEnabled()) {\n            XWikiCacheStoreInterface cachestore =\n                (XWikiCacheStoreInterface) Utils.getComponent(XWikiStoreInterface.class, \"cache\");\n            cachestore.setStore(mainStore);\n            setStore(cachestore);\n        } else {\n            setStore(mainStore);\n        }\n\n        setDefaultAttachmentContentStore(getStoreConfiguration().getXWikiAttachmentStore());\n        setVersioningStore(getStoreConfiguration().getXWikiVersioningStore());\n        setDefaultAttachmentArchiveStore(getStoreConfiguration().getAttachmentVersioningStore());\n        setRecycleBinStore(getStoreConfiguration().getXWikiRecycleBinStore());\n        setAttachmentRecycleBinStore(getStoreConfiguration().getAttachmentRecycleBinStore());\n    }\n\n    /**\n     * Ensure that mandatory classes (ie classes XWiki needs to work properly) exist and create them if they don't\n     * exist.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public void initializeMandatoryDocuments(XWikiContext context)\n    {\n        if (context.get(\"initdone\") == null) {\n            @SuppressWarnings(\"deprecation\")\n            List<MandatoryDocumentInitializer> initializers =\n                Utils.getComponentList(MandatoryDocumentInitializer.class);\n\n            // Sort the initializers based on priority. Lower priority values are first.\n            Collections.sort(initializers, new Comparator<MandatoryDocumentInitializer>()\n            {\n                @Override\n                public int compare(MandatoryDocumentInitializer left, MandatoryDocumentInitializer right)\n                {\n                    Priority leftPriority = left.getClass().getAnnotation(Priority.class);\n                    int leftPriorityValue =\n                        leftPriority != null ? leftPriority.value() : MandatoryDocumentInitializer.DEFAULT_PRIORITY;\n\n                    Priority rightPriority = right.getClass().getAnnotation(Priority.class);\n                    int rightPriorityValue =\n                        rightPriority != null ? rightPriority.value() : MandatoryDocumentInitializer.DEFAULT_PRIORITY;\n\n                    // Compare the two.\n                    return leftPriorityValue - rightPriorityValue;\n                }\n            });\n\n            getObservationManager().notify(MandatoryDocumentsInitializingEvent.EVENT, null);\n\n            getProgress().pushLevelProgress(initializers.size(), this);\n\n            try {\n                for (MandatoryDocumentInitializer initializer : initializers) {\n                    getProgress().startStep(this);\n\n                    initializeMandatoryDocument(initializer, context);\n\n                    getProgress().endStep(this);\n                }\n            } finally {\n                getProgress().popLevelProgress(this);\n            }\n\n            getObservationManager().notify(MandatoryDocumentsInitializedEvent.EVENT, null);\n        }\n    }\n\n    private void initializeMandatoryDocument(String wiki, MandatoryDocumentInitializer initializer,\n        XWikiContext context)\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            context.setWikiId(wiki);\n\n            initializeMandatoryDocument(initializer, context);\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    private void initializeMandatoryDocument(MandatoryDocumentInitializer initializer, XWikiContext context)\n    {\n        try {\n            DocumentReference documentReference =\n                getCurrentReferenceDocumentReferenceResolver().resolve(initializer.getDocumentReference());\n\n            if (documentReference.getWikiReference().getName().equals(context.getWikiId())) {\n                XWikiDocument document = context.getWiki().getDocument(documentReference, context);\n\n                if (initializer.updateDocument(document)) {\n                    saveDocument(document,\n                        localizePlainOrKey(\"core.model.xclass.mandatoryUpdateProperty.versionSummary\"), context);\n                }\n            }\n        } catch (XWikiException e) {\n            LOGGER.error(\"Failed to initialize mandatory document [{}]\", initializer.getDocumentReference(), e);\n        }\n    }\n\n    public XWikiStoreInterface getNotCacheStore()\n    {\n        XWikiStoreInterface store = getStore();\n        if (store instanceof XWikiCacheStoreInterface) {\n            store = ((XWikiCacheStoreInterface) store).getStore();\n        }\n        return store;\n    }\n\n    public XWikiHibernateStore getHibernateStore()\n    {\n        XWikiStoreInterface store = getStore();\n        if (store instanceof XWikiHibernateStore) {\n            return (XWikiHibernateStore) store;\n        } else if (store instanceof XWikiCacheStoreInterface) {\n            store = ((XWikiCacheStoreInterface) store).getStore();\n            if (store instanceof XWikiHibernateStore) {\n                return (XWikiHibernateStore) store;\n            } else {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, XWikiContext context) throws HibernateException, XWikiException\n    {\n        updateDatabase(wikiId, false, context);\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, boolean force, XWikiContext context)\n        throws HibernateException, XWikiException\n    {\n        updateDatabase(wikiId, force, true, context);\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param force if the update of the databse should be forced\n     * @param initDocuments if mandatory document and plugin should be initialized for passed wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, boolean force, boolean initDocuments, XWikiContext context)\n        throws HibernateException, XWikiException\n    {\n        initializeWiki(wikiId, true, context);\n    }\n\n    /**\n     * @return a cached list of all active virtual wikis (i.e. wikis who have been hit by a user request). To get a full\n     *         list of all virtual wikis database names use {@link WikiDescriptorManager#getAllIds()}.\n     * @deprecated\n     */\n    @Deprecated\n    public List<String> getVirtualWikiList()\n    {\n        return new ArrayList<>(this.initializedWikis.keySet());\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     * @return the full list of all wiki names of all defined wikis. The wiki names are computed from the names of\n     *         documents having a {@code XWiki.XWikiServerClass} object attached to them by removing the\n     *         {@code XWiki.XWikiServer} prefix and making it lower case. For example a page named\n     *         {@code XWiki.XWikiServerMyDatabase} would return {@code mydatabase} as the wiki name. This list will also\n     *         contain the main wiki.\n     *         <p>\n     *         Note: the wiki name is commonly also the name of the database where the wiki's data is stored. However,\n     *         if configured accordingly, the database can be diferent from the wiki name, like for example when setting\n     *         a wiki database prefix.\n     * @deprecated since 5.3, use {@link WikiDescriptorManager#getAllIds()} instead\n     */\n    @Deprecated\n    public List<String> getVirtualWikisDatabaseNames(XWikiContext context) throws XWikiException\n    {\n        WikiDescriptorManager descriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n\n        try {\n            return new ArrayList<String>(descriptorManager.getAllIds());\n        } catch (WikiManagerException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to get the list of wikis\", e);\n        }\n    }\n\n    /**\n     * @return the cache containing the names of the wikis already initialized.\n     * @since 1.5M2.\n     * @deprecated\n     */\n    @Deprecated\n    public Cache<DocumentReference> getVirtualWikiCache()\n    {\n        return null;\n    }\n\n    /**\n     * Get the reference of the owner for the provider wiki.\n     *\n     * @param wikiName the technical name of the wiki\n     * @param context see {@link XWikiContext}\n     * @return the wiki owner or null if none is set\n     * @throws XWikiException failed to get wiki descriptor document\n     */\n    public String getWikiOwner(String wikiName, XWikiContext context) throws XWikiException\n    {\n        String wikiOwner;\n\n        String currentdatabase = context.getWikiId();\n        try {\n            context.setWikiId(context.getMainXWiki());\n\n            String serverwikipage = getServerWikiPage(wikiName);\n            XWikiDocument doc = getDocument(serverwikipage, context);\n\n            if (doc.isNew()) {\n                if (!context.isMainWiki(wikiName)) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_DOES_NOT_EXIST,\n                        \"The wiki \" + wikiName + \" does not exist\");\n                } else {\n                    wikiOwner = null;\n                }\n            } else {\n                wikiOwner = doc.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"owner\");\n                if (wikiOwner.indexOf(':') == -1) {\n                    wikiOwner = context.getMainXWiki() + \":\" + wikiOwner;\n                }\n            }\n        } finally {\n            context.setWikiId(currentdatabase);\n        }\n\n        return wikiOwner;\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    protected Object createClassFromConfig(String param, String defClass, XWikiContext context) throws XWikiException\n    {\n        String storeclass = getConfiguration().getProperty(param, defClass);\n        try {\n            Class<?>[] classes = new Class<?>[] { XWikiContext.class };\n            Object[] args = new Object[] { context };\n            Object result = Class.forName(storeclass).getConstructor(classes).newInstance(args);\n            return result;\n        } catch (Exception e) {\n            Throwable ecause = e;\n            if (e instanceof InvocationTargetException) {\n                ecause = ((InvocationTargetException) e).getTargetException();\n            }\n            Object[] args = { param, storeclass };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_CLASSINVOCATIONERROR, \"Cannot load class {1} from param {0}\", ecause,\n                args);\n        }\n    }\n\n    private void preparePlugins(XWikiContext context)\n    {\n        setPluginManager(new XWikiPluginManager(getXWikiPreference(\"plugins\", context), context));\n        String plugins = getConfiguration().getProperty(\"xwiki.plugins\", \"\");\n        if (!plugins.equals(\"\")) {\n            getPluginManager().addPlugins(StringUtils.split(plugins, \" ,\"), context);\n        }\n    }\n\n    /**\n     * @return the XWiki core version as specified in the {@link #VERSION_FILE} file\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String getVersion()\n    {\n        if (this.version == null) {\n            try {\n                InputStream is = getResourceAsStream(VERSION_FILE);\n                try {\n                    XWikiConfig properties = new XWikiConfig(is);\n                    this.version = properties.getProperty(VERSION_FILE_PROPERTY);\n                } finally {\n                    IOUtils.closeQuietly(is);\n                }\n            } catch (Exception e) {\n                // Failed to retrieve the version, log a warning and default to \"Unknown\"\n                LOGGER.warn(\"Failed to retrieve XWiki's version from [\" + VERSION_FILE + \"], using the [\"\n                    + VERSION_FILE_PROPERTY + \"] property.\", e);\n                this.version = \"Unknown version\";\n            }\n        }\n        return this.version;\n    }\n\n    public URL getResource(String s) throws MalformedURLException\n    {\n        return getEngineContext().getResource(s);\n    }\n\n    public InputStream getResourceAsStream(String s) throws MalformedURLException\n    {\n        InputStream is = getEngineContext().getResourceAsStream(s);\n        if (is == null) {\n            is = getEngineContext().getResourceAsStream(\"/\" + s);\n        }\n        return is;\n    }\n\n    public String getResourceContent(String name) throws IOException\n    {\n        if (getEngineContext() != null) {\n            try (InputStream is = getResourceAsStream(name)) {\n                if (is != null) {\n                    return IOUtils.toString(is, DEFAULT_ENCODING);\n                }\n            }\n        }\n        // Resources should always be encoded as UTF-8, to reduce the dependency on the system encoding\n        return FileUtils.readFileToString(new File(name), DEFAULT_ENCODING);\n    }\n\n    public Date getResourceLastModificationDate(String name)\n    {\n        try {\n            if (getEngineContext() != null) {\n                return Util.getFileLastModificationDate(getEngineContext().getRealPath(name));\n            }\n        } catch (Exception ex) {\n            // Probably a SecurityException or the file is not accessible (inside a war)\n            LOGGER.info(\"Failed to get file modification date: \" + ex.getMessage());\n        }\n        return new Date();\n    }\n\n    public byte[] getResourceContentAsBytes(String name) throws IOException\n    {\n        if (getEngineContext() != null) {\n            try (InputStream is = getResourceAsStream(name)) {\n                if (is != null) {\n                    return IOUtils.toByteArray(is);\n                }\n            } catch (Exception e) {\n            }\n        }\n        return FileUtils.readFileToByteArray(new File(name));\n    }\n\n    public boolean resourceExists(String name)\n    {\n        if (getEngineContext() != null) {\n            try {\n                if (getResource(name) != null) {\n                    return true;\n                }\n            } catch (IOException e) {\n            }\n        }\n        try {\n            File file = new File(name);\n            return file.exists();\n        } catch (Exception e) {\n            // Could be running under -security, which prevents calling file.exists().\n        }\n        return false;\n    }\n\n    public String getRealPath(String path)\n    {\n        return getEngineContext().getRealPath(path);\n    }\n\n    public String ParamAsRealPath(String key)\n    {\n        String param = getConfiguration().getProperty(key);\n        try {\n            return getRealPath(param);\n        } catch (Exception e) {\n            return param;\n        }\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public String ParamAsRealPath(String key, XWikiContext context)\n    {\n        return ParamAsRealPath(key);\n    }\n\n    public String ParamAsRealPathVerified(String param)\n    {\n        String path;\n        File fpath;\n\n        path = getConfiguration().getProperty(param);\n        if (path == null) {\n            return null;\n        }\n\n        fpath = new File(path);\n        if (fpath.exists()) {\n            return path;\n        }\n\n        path = getRealPath(path);\n        if (path == null) {\n            return null;\n        }\n\n        fpath = new File(path);\n        if (fpath.exists()) {\n            return path;\n        } else {\n        }\n        return null;\n    }\n\n    public XWikiStoreInterface getStore()\n    {\n        return this.store;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #getDefaultAttachmentContentStore()} instead\n     */\n    @Deprecated\n    public XWikiAttachmentStoreInterface getAttachmentStore()\n    {\n        return getDefaultAttachmentContentStore();\n    }\n\n    /**\n     * @return the store to use by default when saving a new attachment content\n     * @since 9.10RC1\n     */\n    public XWikiAttachmentStoreInterface getDefaultAttachmentContentStore()\n    {\n        return this.defaultAttachmentContentStore;\n    }\n\n    /**\n     * @return the store to use by default when saving a new attachment archive\n     * @since 9.10RC1\n     */\n    public AttachmentVersioningStore getDefaultAttachmentArchiveStore()\n    {\n        return this.defaultAttachmentArchiveStore;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #getDefaultAttachmentArchiveStore()} instead\n     */\n    @Deprecated\n    public AttachmentVersioningStore getAttachmentVersioningStore()\n    {\n        return getDefaultAttachmentArchiveStore();\n    }\n\n    public XWikiVersioningStoreInterface getVersioningStore()\n    {\n        return this.versioningStore;\n    }\n\n    public XWikiRecycleBinStoreInterface getRecycleBinStore()\n    {\n        return this.recycleBinStore;\n    }\n\n    public AttachmentRecycleBinStore getAttachmentRecycleBinStore()\n    {\n        return this.attachmentRecycleBinStore;\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, String comment,\n        XWikiContext context) throws XWikiException\n    {\n        checkSavingDocument(userReference, document, comment, false, context);\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, XWikiContext context)\n        throws XWikiException\n    {\n        checkSavingDocument(userReference, document, \"\", false, context);\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param isMinorEdit true if the new version is a minor version\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, String comment,\n        boolean isMinorEdit, XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            // Switch to document wiki\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            // Make sure the document is ready to be saved\n            XWikiDocument originalDocument = prepareDocumentForSave(document, comment, isMinorEdit, context);\n\n            ObservationManager om = getObservationManager();\n\n            // Notify listeners about the document about to be created or updated\n\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n\n            if (om != null) {\n                CancelableEvent documentEvent;\n                if (originalDocument.isNew()) {\n                    documentEvent = new UserCreatingDocumentEvent(userReference, document.getDocumentReference());\n                } else {\n                    documentEvent = new UserUpdatingDocumentEvent(userReference, document.getDocumentReference());\n                }\n                om.notify(documentEvent, document, context);\n\n                // If the action has been canceled by the user then don't perform any save and throw an exception\n                if (documentEvent.isCanceled()) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                        String.format(\"User [%s] has been denied the right to save the document [%s]. Reason: [%s]\",\n                            userReference, document.getDocumentReference(), documentEvent.getReason()));\n                }\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    private XWikiDocument prepareDocumentForSave(XWikiDocument document, String comment, boolean isMinorEdit,\n        XWikiContext context) throws XWikiException\n    {\n        // Set the store so we can use it for checking the max length.\n        if (document.getStore() == null) {\n            document.setStore(this.getStore());\n        }\n        String fullName = getLocalStringEntityReferenceSerializer().serialize(document.getDocumentReference());\n        // If it's a new doc we check its name length to avoid a nasty SQL error.\n        if (document.isNew() && fullName.length() > document.getLocalReferenceMaxLength()) {\n            java.lang.Object[] args = { fullName, document.getLocalReferenceMaxLength(), fullName.length() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_APP_DOCUMENT_PATH_TOO_LONG,\n                \"Cannot create document {0} because its full path is too long: only {1} characters are allowed and \"\n                    + \"current length is {2}.\",\n                null, args);\n        }\n\n        // Setting comment & minor edit before saving\n        document.setComment(StringUtils.defaultString(comment));\n        document.setMinorEdit(isMinorEdit);\n\n        // We need to save the original document since saveXWikiDoc() will reset it and we\n        // need that original document for the notification below.\n        XWikiDocument originalDocument = document.getOriginalDocument();\n\n        // Make sure to always have an original document for listeners that need to compare with it.\n        // The only case where we have a null original document is supposedly when the document\n        // instance has been crafted and passed #saveDocument without using #getDocument\n        // (which is not a good practice)\n        // Also for document indicated as new make sure the previous document is accurate.\n        if (originalDocument == null || document.isNew()) {\n            XWikiDocument existing = getDocument(document.getDocumentReferenceWithLocale(), context);\n            // Switch the original document only if we actually find an existing document or if there is no original\n            // document in the first place\n            if (originalDocument == null || !existing.isNew()) {\n                originalDocument = existing;\n                document.setOriginalDocument(originalDocument);\n            }\n        }\n\n        return originalDocument;\n    }\n\n    /**\n     * @param doc the document to save\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        // If no comment is provided we should use an empty comment\n        saveDocument(doc, \"\", context);\n    }\n\n    /**\n     * @param doc the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument doc, String comment, XWikiContext context) throws XWikiException\n    {\n        saveDocument(doc, comment, false, context);\n    }\n\n    private void beforeSave(XWikiDocument document, XWikiContext context) throws XWikiException\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            CancelableEvent documentEvent;\n            if (document.getOriginalDocument().isNew()) {\n                documentEvent = new DocumentCreatingEvent(document.getDocumentReference());\n            } else {\n                documentEvent = new DocumentUpdatingEvent(document.getDocumentReference());\n            }\n            om.notify(documentEvent, document, context);\n\n            // If the action has been canceled by the user then don't perform any save and throw an exception\n            if (documentEvent.isCanceled()) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_DOC,\n                    String.format(\"An Event Listener has cancelled the document save for [%s]. Reason: [%s]\",\n                        document.getDocumentReference(), documentEvent.getReason()));\n            }\n        }\n    }\n\n    private void afterSave(XWikiDocument document, XWikiContext context)\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            if (document.getOriginalDocument().isNew()) {\n                om.notify(new DocumentCreatedEvent(document.getDocumentReference()), document, context);\n            } else {\n                om.notify(new DocumentUpdatedEvent(document.getDocumentReference()), document, context);\n            }\n        }\n    }\n\n    /**\n     * Save the passed document in the store.\n     * <p>\n     * If document is not new and metadata and content dirty flags are false, the version/history won't be incremented\n     * (only the current state will be updated).\n     * <p>\n     * Since 11.1, if document#isNew() return true, any pre existing document will be backuped in the deleted documents\n     * store automatically and completely replaced.\n     * \n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param isMinorEdit true if the new version is a minor version\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument document, String comment, boolean isMinorEdit, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            // Switch to document wiki\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            // Make sure the document is ready to be saved\n            XWikiDocument originalDocument = prepareDocumentForSave(document, comment, isMinorEdit, context);\n\n            // Notify listeners about the document about to be created or updated\n\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            beforeSave(document, context);\n\n            // Delete existing document if we replace with a new one\n            if (document.isNew()) {\n                if (!originalDocument.isNew()) {\n                    // We don't want to notify about this delete since from outside world point of view it's an update\n                    // and not a delete+create\n                    deleteDocument(originalDocument, true, false, context);\n                }\n            } else {\n                // Put attachments to remove in recycle bin\n                if (hasAttachmentRecycleBin(context)) {\n                    for (XWikiAttachmentToRemove attachment : document.getAttachmentsToRemove()) {\n                        if (attachment.isToRecycleBin()) {\n                            // Make sure the attachment will be deleted with its history\n                            attachment.getAttachment().loadArchive(context);\n                            getAttachmentRecycleBinStore().saveToRecycleBin(attachment.getAttachment(),\n                                context.getUser(), new Date(), context, true);\n                        }\n                    }\n                }\n            }\n\n            // Actually save the document.\n            getStore().saveXWikiDoc(document, context);\n\n            // Since the store#saveXWikiDoc resets originalDocument, we need to temporarily put it\n            // back to send notifications.\n            XWikiDocument newOriginal = document.getOriginalDocument();\n\n            try {\n                document.setOriginalDocument(originalDocument);\n\n                // Notify listeners about the document having been created or updated\n\n                // First the legacy notification mechanism\n\n                // Then the new observation module\n                // Note that for the moment the event being send is a bridge event, as we are still passing around\n                // an XWikiDocument as source and an XWikiContext as data.\n                // The old version is made available using doc.getOriginalDocument()\n                afterSave(document, context);\n            } catch (Exception ex) {\n                LOGGER.error(\"Failed to send document save notification for document [\"\n                    + getDefaultEntityReferenceSerializer().serialize(document.getDocumentReference()) + \"]\", ex);\n            } finally {\n                document.setOriginalDocument(newOriginal);\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Loads a XWikiDocument from the store.\n     * <p>\n     * Before 7.2M1 the reference is assumed to be a complete or incomplete document reference.\n     * <p>\n     * Since 7.2M1, the passed reference can be anything. If if a document child, the document reference will be\n     * extracted from it. If it's a document parent it will be completed with the necessary default references (for\n     * example if it's a space reference it will load the space home page).\n     *\n     * @param reference the reference of the document\n     * @param context see {@link XWikiContext}\n     * @since 5.0M1\n     */\n    public XWikiDocument getDocument(EntityReference reference, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument document;\n\n        if (reference.getType() == EntityType.PAGE || reference.getType().isAllowedAncestor(EntityType.PAGE)) {\n            document = getDocument(getCurrentGetPageResolver().resolve(reference), context);\n        } else {\n            document = getDocument(getCurrentGetDocumentResolver().resolve(reference), context);\n        }\n\n        return document;\n    }\n\n    /**\n     * Loads a XWikiDocument from the store.\n     *\n     * @param reference the reference of the document to be loaded\n     * @param type the type of the reference\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 10.6RC1\n     */\n    public XWikiDocument getDocument(String reference, EntityType type, XWikiContext xcontext) throws XWikiException\n    {\n        return getDocument(getRelativeEntityReferenceResolver().resolve(reference, type), xcontext);\n    }\n\n    /**\n     * @param doc the document\n     * @param context see {@link XWikiContext}\n     */\n    public XWikiDocument getDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(doc.getDocumentReference().getWikiReference().getName());\n\n            try {\n                // Indicate the the async context manipulated documents\n                getAsyncContext().useEntity(doc.getDocumentReferenceWithLocale());\n            } catch (Exception e) {\n                // If the AsyncContext component does not work then we are not in an asynchronous context anyway\n                LOGGER.debug(\"Failed to register the document in the asynchronous context\", e);\n            }\n\n            return getStore().loadXWikiDoc(doc, context);\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * @param reference the reference of the document to load\n     * @param revision the revision of the document to load\n     * @param context the XWiki context\n     * @return the document corresponding to the passed revision or a new XWikiDocument instance if none can be found\n     * @throws XWikiException when failing to load the document revision\n     * @since 9.4RC1\n     * @deprecated sine 9.10RC1, use {@link DocumentRevisionProvider#getRevision(DocumentReference, String)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(DocumentReference reference, String revision, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument revisionDocument = getDocumentRevisionProvider().getRevision(reference, revision);\n\n        if (revisionDocument == null && (revision.equals(\"1.1\") || revision.equals(\"1.0\"))) {\n            revisionDocument = new XWikiDocument(reference);\n        }\n\n        return revisionDocument;\n    }\n\n    /**\n     * @param document the reference document\n     * @param revision the revision of the document to load\n     * @param context the XWiki context\n     * @return the document corresponding to the passed revision or a new XWikiDocument instance if none can be found\n     * @throws XWikiException when failing to load the document revision\n     * @deprecated sine 9.10RC1, use {@link DocumentRevisionProvider#getRevision(XWikiDocument, String)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(XWikiDocument document, String revision, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument revisionDocument = getDocumentRevisionProvider().getRevision(document, revision);\n\n        if (revisionDocument == null && (revision.equals(\"1.1\") || revision.equals(\"1.0\"))) {\n            revisionDocument = new XWikiDocument(document.getDocumentReference());\n        }\n\n        return revisionDocument;\n    }\n\n    /**\n     * @param reference the reference of the document\n     * @param context see {@link XWikiContext}\n     * @since 2.2M1\n     */\n    public XWikiDocument getDocument(DocumentReference reference, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(\n            reference.getLocale() != null ? new DocumentReference(reference, (Locale) null) : reference,\n            reference.getLocale());\n\n        doc.setContentDirty(true);\n\n        return getDocument(doc, context);\n    }\n\n    /**\n     * @param reference the reference of the page\n     * @param context see {@link XWikiContext}\n     * @since 10.6RC1\n     */\n    public XWikiDocument getDocument(PageReference reference, XWikiContext context) throws XWikiException\n    {\n        DocumentReference documentReference = getCurrentReferenceDocumentReferenceResolver().resolve(reference);\n\n        XWikiDocument document = getDocument(documentReference, context);\n\n        if (document.isNew() && documentReference.getParent().getParent().getType() == EntityType.SPACE) {\n            // Try final page\n            XWikiDocument finalDocument = getDocument(new DocumentReference(documentReference.getParent().getName(),\n                documentReference.getParent().getParent(), documentReference.getParameters()), context);\n\n            if (!finalDocument.isNew()) {\n                document = finalDocument;\n            }\n        }\n\n        return document;\n    }\n\n    /**\n     * Find the document reference corresponding to the entity reference based on what exist in the database (page\n     * reference can means two different documents for example).\n     * \n     * @param reference the reference to resolve\n     * @param context the XWiki context\n     * @return the document reference\n     * @since 10.6RC1\n     */\n    public DocumentReference getDocumentReference(EntityReference reference, XWikiContext context)\n    {\n        DocumentReference documentReference = getCurrentGetDocumentResolver().resolve(reference);\n\n        // If the document has been found or it's top level space, return the reference\n        if (documentReference.getParent().getParent().getType() != EntityType.SPACE\n            || exists(documentReference, context)) {\n            return documentReference;\n        }\n\n        // Try final page\n        DocumentReference finalPageReference = new DocumentReference(documentReference.getParent().getName(),\n            documentReference.getParent().getParent(), documentReference.getParameters());\n\n        return exists(finalPageReference, context) ? finalPageReference : documentReference;\n    }\n\n    /**\n     * @param fullname the reference of the document as String\n     * @param context see {@link XWikiContext}\n     * @deprecated since 2.2M1 use {@link #getDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(String fullname, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument();\n        doc.setFullName(fullname, context);\n        return getDocument(doc, context);\n    }\n\n    /**\n     * @param spaces the reference of the space as String\n     * @param fullname the reference of the document as String\n     * @param context see {@link XWikiContext}\n     * @deprecated since 2.2M1 use {@link #getDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(String spaces, String fullname, XWikiContext context) throws XWikiException\n    {\n        int dotPosition = fullname.lastIndexOf('.');\n        if (dotPosition != -1) {\n            String spaceFromFullname = fullname.substring(0, dotPosition);\n            String name = fullname.substring(dotPosition + 1);\n            if (name.equals(\"\")) {\n                name = getDefaultPage(context);\n            }\n            return getDocument(spaceFromFullname + \".\" + name, context);\n        } else {\n            return getDocument(spaces + \".\" + fullname, context);\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocuments(String, String)\n     */\n    public XWikiDeletedDocument[] getDeletedDocuments(String fullname, String locale, XWikiContext context)\n        throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n            doc.setLanguage(locale);\n            return getRecycleBinStore().getAllDeletedDocuments(doc, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocuments(String)\n     * @since 9.4RC1\n     */\n    public XWikiDeletedDocument[] getDeletedDocuments(String batchId, XWikiContext context) throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            return getRecycleBinStore().getAllDeletedDocuments(batchId, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocument(String, String, String)\n     * @deprecated since 9.4RC1. Use {@link #getDeletedDocument(long, XWikiContext)} instead.\n     */\n    @Deprecated\n    public XWikiDeletedDocument getDeletedDocument(String fullname, String locale, int index, XWikiContext context)\n        throws XWikiException\n    {\n        return getDeletedDocument(index, context);\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocument(String)\n     * @since 9.4RC1\n     */\n    public XWikiDeletedDocument getDeletedDocument(long index, XWikiContext context) throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            return getRecycleBinStore().getDeletedDocument(index, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document. Note that this does not distinguish\n     * between different incarnations of a document name, and it does not require that the document still exists, it\n     * returns all the attachments that at the time of their deletion had a document with the specified name as their\n     * owner.\n     *\n     * @param docName the {@link XWikiDocument#getFullName() name} of the owner document\n     * @param context see {@link XWikiContext}\n     * @return A list with all the deleted attachments which belonged to the specified document. If no such attachments\n     *         are found in the trash, an empty list is returned.\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, XWikiContext context) throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName));\n            return getAttachmentRecycleBinStore().getAllDeletedAttachments(doc, context, true);\n        }\n        return null;\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document and had the specified name. Multiple\n     * versions can be returned since the same file can be uploaded and deleted several times, creating different\n     * instances in the trash. Note that this does not distinguish between different incarnations of a document name,\n     * and it does not require that the document still exists, it returns all the attachments that at the time of their\n     * deletion had a document with the specified name as their owner.\n     *\n     * @param docName the {@link DeletedAttachment#getDocName() name of the document} the attachment belonged to\n     * @param filename the {@link DeletedAttachment#getFilename() name} of the attachment to search for\n     * @param context see {@link XWikiContext}\n     * @return A list with all the deleted attachments which belonged to the specified document and had the specified\n     *         filename. If no such attachments are found in the trash, an empty list is returned.\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, String filename, XWikiContext context)\n        throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName));\n            XWikiAttachment attachment = new XWikiAttachment(doc, filename);\n            return getAttachmentRecycleBinStore().getAllDeletedAttachments(attachment, context, true);\n        }\n        return null;\n    }\n\n    /**\n     * Retrieve a specific attachment from the trash.\n     *\n     * @param id the unique identifier of the entry in the trash\n     * @param context the XWiki context\n     * @return specified attachment from the trash, {@code null} if not found\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public DeletedAttachment getDeletedAttachment(String id, XWikiContext context) throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            return getAttachmentRecycleBinStore().getDeletedAttachment(NumberUtils.toLong(id), context, true);\n        }\n        return null;\n    }\n\n    public MetaClass getMetaclass()\n    {\n        if (this.metaclass == null) {\n            this.metaclass = MetaClass.getMetaClass();\n        }\n        return this.metaclass;\n    }\n\n    public void setMetaclass(MetaClass metaclass)\n    {\n        this.metaclass = metaclass;\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public List<String> getClassList(XWikiContext context) throws XWikiException\n    {\n        List<String> result = getStore().getClassList(context);\n        Collections.sort(result);\n        return result;\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, 0, 0, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param nb limit the number of results to return\n     * @param start the offset from which to start return results\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, int nb, int start, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, nb, start, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, Object[][] whereParams, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, 0, 0, whereParams, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param nb limit the number of results to return\n     * @param start the offset from which to start return results\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, int nb, int start, Object[][] whereParams, XWikiContext context)\n        throws XWikiException\n    {\n        return getStore().search(sql, nb, start, whereParams, context);\n    }\n\n    /**\n     * @param content the content to parse\n     * @param context see {@link XWikiContext}\n     * @deprecated Since 7.2M1. Use specific rendering/parsing options for the content type you want to parse/render.\n     */\n    @Deprecated\n    public String parseContent(String content, XWikiContext context)\n    {\n        return getOldRendering().parseContent(content, context);\n    }\n\n    /**\n     * @param template the name of the template\n     * @param context see {@link XWikiContext}\n     * @deprecated use {@link #evaluateTemplate(String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String parseTemplate(String template, XWikiContext context)\n    {\n        String result = \"\";\n\n        try {\n            result = evaluateTemplate(template, context);\n        } catch (Exception e) {\n            LOGGER.debug(\"Exception while parsing template [{}] from /templates/\", template, e);\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate provided template content using velocity engine.\n     *\n     * @param template the template to evaluate\n     * @param context see {@link XWikiContext}\n     * @return the return of the velocity script\n     * @throws IOException failed to get the template content\n     * @since 2.2.2\n     * @deprecated since 7.0M1, use {@link TemplateManager#render(String)} instead\n     */\n    @Deprecated\n    public String evaluateTemplate(String template, XWikiContext context) throws IOException\n    {\n        try {\n            return getTemplateManager().render(template);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while evaluating velocity template [{}]\", template, e);\n\n            Object[] args = { template };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while evaluating velocity template {0}\",\n                e, args);\n\n            return Util.getHTMLExceptionMessage(xe, context);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param skinId the id of the skin from which to load the template\n     * @param context see {@link XWikiContext}\n     * @deprecated since 7.0M1, use {@link TemplateManager#renderFromSkin} instead\n     */\n    @Deprecated\n    public String parseTemplate(String template, String skinId, XWikiContext context)\n    {\n        MutableRenderingContext mutableRenderingContext = getMutableRenderingContext();\n\n        Syntax currentTargetSyntax = mutableRenderingContext.getTargetSyntax();\n        try {\n            // Force rendering with XHTML 1.0 syntax for retro-compatibility\n            mutableRenderingContext.setTargetSyntax(Syntax.XHTML_1_0);\n\n            Skin skin = getInternalSkinManager().getSkin(skinId);\n            return getTemplateManager().renderFromSkin(template, skin);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while evaluating velocity template [{}] skin [{}]\", template, skinId, e);\n\n            Object[] args = { template, skinId };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION,\n                \"Error while evaluating velocity template [{0}] from skin [{1}]\", e, args);\n\n            return Util.getHTMLExceptionMessage(xe, context);\n        } finally {\n            mutableRenderingContext.setTargetSyntax(currentTargetSyntax);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param skin the id of the skin from which to load the template\n     * @param context see {@link XWikiContext}\n     */\n    public String renderTemplate(String template, String skin, XWikiContext context)\n    {\n        try {\n            return getOldRendering().renderTemplate(template, skin, context);\n        } catch (Exception ex) {\n            LOGGER.error(\"Failed to render template [\" + template + \"] for skin [\" + skin + \"]\", ex);\n            return parseTemplate(template, skin, context);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param context see {@link XWikiContext}\n     */\n    public String renderTemplate(String template, XWikiContext context)\n    {\n        try {\n            return getOldRendering().renderTemplate(template, context);\n        } catch (Exception ex) {\n            LOGGER.error(\"Failed to render template [\" + template + \"]\", ex);\n            return parseTemplate(template, context);\n        }\n    }\n\n    /**\n     * Designed to include dynamic content, such as Servlets or JSPs, inside Velocity templates; works by creating a\n     * RequestDispatcher, buffering the output, then returning it as a string.\n     */\n    public String invokeServletAndReturnAsString(String url, XWikiContext xwikiContext)\n    {\n\n        HttpServletRequest servletRequest = xwikiContext.getRequest();\n        HttpServletResponse servletResponse = xwikiContext.getResponse();\n\n        try {\n            return IncludeServletAsString.invokeServletAndReturnAsString(url, servletRequest, servletResponse);\n        } catch (Exception e) {\n            LOGGER.warn(\"Exception including url: \" + url, e);\n            return \"Exception including \\\"\" + url + \"\\\", see logs for details.\";\n        }\n\n    }\n\n    /**\n     * @param iconName the standard name of an icon (it's not the name of the file on the filesystem, it's a generic\n     *            name, for example \"success\" for a success icon\n     * @param context see {@link XWikiContext}\n     * @return the URL to the icon resource\n     * @since 2.6M1\n     */\n    public String getIconURL(String iconName, XWikiContext context)\n    {\n        // TODO: Do a better mapping between generic icon name and physical resource name, especially to be independent\n        // of the underlying icon library. Right now we assume it's the Silk icon library.\n        return getSkinFile(\"icons/silk/\" + iconName + \".png\", context);\n    }\n\n    public String getSkinFile(String filename, XWikiContext context)\n    {\n        return getSkinFile(filename, false, context);\n    }\n\n    /**\n     * Build and return a skin file url based on the given parameters.\n     * \n     * @param filename the file name of the skin file wanted\n     * @param forceSkinAction if true force the usage of directory /skins/ in the URL\n     * @param context current context for the request\n     * @return a resource URL for the asked filename\n     */\n    public String getSkinFile(String filename, boolean forceSkinAction, XWikiContext context)\n    {\n        String skinFile = getSkinFile(filename, null, forceSkinAction, context);\n\n        if (skinFile == null) {\n            // Use the default base skin even if the URL could be invalid.\n            XWikiURLFactory urlf = context.getURLFactory();\n            URL url;\n            if (forceSkinAction) {\n                url = urlf.createSkinURL(filename, \"skins\", getDefaultBaseSkin(context), context);\n            } else {\n                url = urlf.createSkinURL(filename, getDefaultBaseSkin(context), context);\n            }\n            skinFile = urlf.getURL(url, context);\n        }\n\n        return skinFile;\n    }\n\n    private String getSkinFileInternal(String fileName, String skinId, boolean forceSkinAction, XWikiContext context)\n    {\n        try {\n            if (skinId != null) {\n                // Try only in the specified skin.\n                Skin skin = getInternalSkinManager().getSkin(skinId);\n                if (skin != null) {\n                    Resource<?> resource = skin.getLocalResource(fileName);\n                    if (resource != null) {\n                        return resource.getURL(forceSkinAction);\n                    }\n                }\n            } else {\n                // Try in the current skin.\n                Skin skin = getInternalSkinManager().getCurrentSkin(true);\n                if (skin != null) {\n                    Resource<?> resource = skin.getResource(fileName);\n                    if (resource != null) {\n                        return resource.getURL(forceSkinAction);\n                    }\n                } else {\n                    // Try in the current parent skin.\n                    Skin parentSkin = getInternalSkinManager().getCurrentParentSkin(true);\n                    if (parentSkin != null) {\n                        Resource<?> resource = parentSkin.getResource(fileName);\n                        if (resource != null) {\n                            return resource.getURL(forceSkinAction);\n                        }\n                    }\n                }\n            }\n\n            // Look for a resource file.\n            String resourceFilePath = \"/resources/\" + fileName;\n            XWikiURLFactory urlFactory = context.getURLFactory();\n            if (resourceExists(resourceFilePath)) {\n                URL url = urlFactory.createResourceURL(fileName, forceSkinAction, context,\n                    getResourceURLCacheParameters(resourceFilePath));\n                return urlFactory.getURL(url, context);\n            }\n        } catch (Exception e) {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Exception while getting skin file [{}] from skin [{}]\", fileName, skinId, e);\n            }\n        }\n\n        return null;\n    }\n\n    private Map<String, Object> getResourceURLCacheParameters(String resourceFilePath)\n    {\n        try {\n            URL resourceUrl = getResource(resourceFilePath);\n            return getResourceURLCacheParameters(resourceUrl);\n        } catch (MalformedURLException e) {\n            LOGGER.debug(\"Error while getting URL for resource path [{}]\", resourceFilePath, e);\n            return Collections.singletonMap(CACHE_VERSION, getVersion());\n        }\n    }\n\n    private Map<String, Object> getResourceURLCacheParameters(URL resourceUrl)\n    {\n        Map<String, Object> parameters = new LinkedHashMap<>();\n\n        if (getURLConfiguration().useResourceLastModificationDate()) {\n            try {\n                Path resourcePath = Paths.get(resourceUrl.toURI());\n                FileTime lastModifiedTime = Files.getLastModifiedTime(resourcePath);\n                parameters.put(CACHE_VERSION, String.valueOf(lastModifiedTime.toMillis()));\n            } catch (Exception e) {\n                LOGGER.debug(\"Error when trying to access properties of resource URL [{}]\", resourceUrl, e);\n                parameters.put(CACHE_VERSION, getVersion());\n            }\n        } else {\n            parameters.put(CACHE_VERSION, getVersion());\n        }\n\n        return parameters;\n    }\n\n    public String getSkinFile(String filename, String skin, XWikiContext context)\n    {\n        return getSkinFile(filename, skin, false, context);\n    }\n\n    public String getSkinFile(String fileName, String skinId, boolean forceSkinAction, XWikiContext context)\n    {\n        if (StringUtils.endsWithAny(fileName, \".js\", \".css\")) {\n            String extension = StringUtils.substringAfterLast(fileName, '.');\n            String shortFileName = StringUtils.substringBeforeLast(fileName, \".\");\n            if (StringUtils.endsWith(shortFileName, \".min\")) {\n                shortFileName = StringUtils.substringBeforeLast(shortFileName, \".\");\n            }\n            String fileNameSource = String.format(\"%s.%s\", shortFileName, extension);\n            String fileNameMinified = String.format(\"%s.min.%s\", shortFileName, extension);\n            DebugConfiguration debugConfig = Utils.getComponent(DebugConfiguration.class);\n            String[] fileNames = debugConfig.isMinify() ? new String[] {fileNameMinified, fileNameSource}\n                : new String[] {fileNameSource, fileNameMinified};\n            String skinFile = null;\n            for (String name : fileNames) {\n                skinFile = getSkinFileInternal(name, skinId, forceSkinAction, context);\n                if (skinFile != null) {\n                    break;\n                }\n            }\n            return skinFile;\n        } else {\n            return getSkinFileInternal(fileName, skinId, forceSkinAction, context);\n        }\n    }\n\n    /**\n     * @deprecated since 7.0M1, use {@link SkinManager#getCurrentSkin(boolean)} instead\n     */\n    @Deprecated\n    public String getSkin(XWikiContext context)\n    {\n        String skin;\n\n        try {\n            skin = getInternalSkinManager().getCurrentSkinId(true);\n        } catch (Exception e) {\n            LOGGER.debug(\"Exception while determining current skin\", e);\n            skin = getDefaultBaseSkin(context);\n        }\n\n        return skin;\n    }\n\n    public String getSkinPreference(String prefname, XWikiContext context)\n    {\n        return getSkinPreference(prefname, \"\", context);\n    }\n\n    public String getSkinPreference(String prefname, String defaultValue, XWikiContext context)\n    {\n        for (Skin skin = getInternalSkinManager().getCurrentSkin(true); skin != null; skin = skin.getParent()) {\n            if (skin instanceof WikiSkin) {\n                String value = getWikiSkinUtils().getSkinProperty(skin.getId(), prefname);\n\n                // TODO: remove the NO_VALUE test when XWIKI-10853 is fixed\n                if (!StringUtils.isEmpty(value) && !NO_VALUE.equals(value)) {\n                    return value;\n                }\n            }\n        }\n\n        return defaultValue;\n    }\n\n    /**\n     * @deprecated since 7.0M1, use {@link SkinManager#getDefaultParentSkin()} instead\n     */\n    @Deprecated\n    public String getDefaultBaseSkin(XWikiContext context)\n    {\n        return getInternalSkinManager().getDefaultParentSkinId();\n    }\n\n    /**\n     * @deprecated since 7.0M1\n     */\n    @Deprecated\n    public String getBaseSkin(XWikiContext context)\n    {\n        return getBaseSkin(context, false);\n    }\n\n    /**\n     * @deprecated since 7.0M1\n     */\n    @Deprecated\n    public String getBaseSkin(XWikiContext context, boolean fromRenderSkin)\n    {\n        String baseskin = \"\";\n        try {\n            return getInternalSkinManager().getCurrentParentSkinId(false);\n        } catch (Exception e) {\n            baseskin = getDefaultBaseSkin(context);\n\n            LOGGER.debug(\"Exception while determining base skin\", e);\n        }\n\n        return baseskin;\n    }\n\n    /**\n     * @param skin the name of the skin for which to return the base skin. For example : <tt>XWiki.DefaultSkin</tt>\n     * @param context see {@link XWikiContext}\n     * @return if found, the name of the base skin the asked skin inherits from. If not found, returns an empty string.\n     * @since 2.0.2\n     * @since 2.1M1\n     * @deprecated since 7.0M1, use {@link SkinManager#getCurrentSkin(boolean)} and {@link Skin#getParent()} instead\n     */\n    @Deprecated\n    public String getBaseSkin(String skin, XWikiContext context)\n    {\n        String baseSkin = getInternalSkinManager().getParentSkin(skin);\n\n        return baseSkin != null ? baseSkin : \"\";\n    }\n\n    public String getSpaceCopyright(XWikiContext context)\n    {\n        return getSpacePreference(\"webcopyright\", \"\", context);\n    }\n\n    public String getXWikiPreference(String prefname, XWikiContext context)\n    {\n        return getXWikiPreference(prefname, \"\", context);\n    }\n\n    /**\n     * Obtain a preference value for the wiki, looking up first in the XWiki.XWikiPreferences document, then fallbacking\n     * on a config parameter when the first lookup gives an empty string, then returning the default value if the config\n     * parameter returned itself an empty string.\n     *\n     * @param prefname the parameter to look for in the XWiki.XWikiPreferences object in the XWiki.XWikiPreferences\n     *            document of the wiki.\n     * @param fallbackParam the parameter in xwiki.cfg to fallback on, in case the XWiki.XWikiPreferences object gave no\n     *            result\n     * @param defaultValue the default value to fallback on, in case both XWiki.XWikiPreferences and the fallback\n     *            xwiki.cfg parameter gave no result\n     */\n    public String getXWikiPreference(String prefname, String fallbackParam, String defaultValue, XWikiContext context)\n    {\n        String result = getWikiConfiguration().getProperty(prefname, String.class);\n\n        if (StringUtils.isEmpty(result)) {\n            result = getConfiguration().getProperty(fallbackParam, defaultValue);\n        }\n\n        return result != null ? result : \"\";\n    }\n\n    /**\n     * Obtain a preference value for the wiki, looking up first in the XWiki.XWikiPreferences document, then fallbacking\n     * on a config parameter when the first lookup gives an empty string, then returning the default value if the config\n     * parameter returned itself an empty string.\n     *\n     * @param prefname the parameter to look for in the XWiki.XWikiPreferences object in the XWiki.XWikiPreferences\n     *            document of the wiki.\n     * @param wiki the wiki to get preference from\n     * @param fallbackParam the parameter in xwiki.cfg to fallback on, in case the XWiki.XWikiPreferences object gave no\n     *            result\n     * @param defaultValue the default value to fallback on, in case both XWiki.XWikiPreferences and the fallback\n     *            xwiki.cfg parameter gave no result\n     * @since 7.4M1\n     */\n    public String getXWikiPreference(String prefname, String wiki, String fallbackParam, String defaultValue,\n        XWikiContext xcontext)\n    {\n        String currentWiki = xcontext.getWikiId();\n\n        try {\n            xcontext.setWikiId(wiki);\n\n            return getXWikiPreference(prefname, fallbackParam, defaultValue, xcontext);\n        } finally {\n            xcontext.setWikiId(currentWiki);\n        }\n    }\n\n    public String getXWikiPreference(String prefname, String defaultValue, XWikiContext context)\n    {\n        return getXWikiPreference(prefname, \"\", defaultValue, context);\n    }\n\n    public String getSpacePreference(String preference, XWikiContext context)\n    {\n        return getSpacePreference(preference, \"\", context);\n    }\n\n    public String getSpacePreference(String preference, String defaultValue, XWikiContext context)\n    {\n        return getSpacePreference(preference, (SpaceReference) null, defaultValue, context);\n    }\n\n    /**\n     * @deprecated since 7.4M1, use {@link #getSpacePreference(String, SpaceReference, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String getSpacePreference(String preference, String space, String defaultValue, XWikiContext context)\n    {\n        return getSpacePreference(preference, new SpaceReference(space, context.getWikiReference()), defaultValue,\n            context);\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then empty String is returned.\n     * \n     * @param preferenceKey the name of the preference key\n     * @param spaceReference the reference of the space\n     * @param context see {@link XWikiContext}\n     * @return the value of the preference or empty String if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreference(String preferenceKey, SpaceReference spaceReference, XWikiContext context)\n    {\n        return getSpacePreference(preferenceKey, spaceReference, \"\", context);\n    }\n\n    /**\n     * Get the preference key for the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then <code>defaultValue</code> is returned.\n     * \n     * @param preferenceKey the name of the preference key\n     * @param spaceReference the reference of the space. If null and there's a current document then the current space\n     *                       is used. If null and there's no current document then fall back to the wiki preferences.\n     * @param defaultValue the value to return if the preference can't be found\n     * @param context see {@link XWikiContext}\n     * @return the value of the preference or <code>defaultValue</code> if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreference(String preferenceKey, SpaceReference spaceReference, String defaultValue,\n        XWikiContext context)\n    {\n        XWikiDocument currentDocument = context.getDoc();\n\n        try {\n            if (spaceReference != null) {\n                context.setDoc(new XWikiDocument(new DocumentReference(\"WebPreferences\", spaceReference)));\n            } else if (currentDocument != null) {\n                spaceReference = currentDocument.getDocumentReference().getLastSpaceReference();\n            }\n\n            String result = getSpaceConfiguration().getProperty(preferenceKey, String.class);\n\n            if (StringUtils.isEmpty(result)) {\n                if (spaceReference == null) {\n                    result = getXWikiPreference(preferenceKey, defaultValue, context);\n                } else if (spaceReference.getParent() instanceof SpaceReference) {\n                    result = getSpacePreference(preferenceKey, (SpaceReference) spaceReference.getParent(),\n                        defaultValue, context);\n                } else if (spaceReference.getParent() instanceof WikiReference) {\n                    result =\n                        getXWikiPreference(preferenceKey, spaceReference.getParent().getName(), defaultValue, context);\n                }\n            }\n\n            return result != null ? result : defaultValue;\n        } finally {\n            context.setDoc(currentDocument);\n        }\n    }\n\n    public String getUserPreference(String prefname, XWikiContext context)\n    {\n        String result =\n            getAllUserPropertiesResolver().resolve(CurrentUserReference.INSTANCE).getProperty(prefname, String.class);\n\n        return result != null ? result : \"\";\n    }\n\n    public String getUserPreferenceFromCookie(String prefname, XWikiContext context)\n    {\n        Cookie[] cookies = context.getRequest().getCookies();\n        if (cookies == null) {\n            return null;\n        }\n        for (Cookie cookie : cookies) {\n            String name = cookie.getName();\n            if (name.equals(prefname)) {\n                String value = cookie.getValue();\n                if (!value.trim().equals(\"\")) {\n                    return value;\n                } else {\n                    break;\n                }\n            }\n        }\n        return null;\n    }\n\n    public String getUserPreference(String prefname, boolean useCookie, XWikiContext context)\n    {\n        // First we look in the cookies\n        if (useCookie) {\n            String result = Util.normalizeLanguage(getUserPreferenceFromCookie(prefname, context));\n            if (result != null) {\n                return result;\n            }\n        }\n        return getUserPreference(prefname, context);\n    }\n\n    /**\n     * Set the locale in the given context.\n     * <p>\n     * If {@code forceSupported} is true, then the locale will be set only if it is in the {@see availableLocales}. Note\n     * that all the parent locales are checked.\n     *\n     * @param locale the locale to use\n     * @param context the context\n     * @param availableLocales the accepted locales. Used only if {@see forceSupported} is true\n     * @param forceSupported determine if the {@see locale} should be checked against the {@see availableLocales}\n     * @return the locale that has been set or null\n     */\n    private Locale setLocale(Locale locale, XWikiContext context, Set<Locale> availableLocales, boolean forceSupported)\n    {\n        while (locale != null) {\n            if (!forceSupported || availableLocales.contains(locale)) {\n                context.setLocale(locale);\n                break;\n            }\n            locale = LocaleUtils.getParentLocale(locale);\n        }\n\n        return locale;\n    }\n\n    /**\n     * The algorithm to find the locale to use is the following, in this order:\n     *\n     * <ul>\n     *   <li>Try to find the current locale in use from the XWiki contex</li>\n     *   <li>If the wiki is not multilingual use the wiki default locale ({@code default_language} xproperty in\n     *   {@code XWikiPreferences} xobject or English if not found)</li>\n     *   <li>If the wiki is multilingual<ul>\n     *     <li>Try to get the locale passed in the request (looking for a {@code language} query string parameter).\n     *     If the language value is {@code default} use the wiki default locale. If a parameter is found sets a\n     *     {@code language} cookie to remember the language in use.</li>\n     *     <li>Try to get the locale from the {@code language} cookie</li>\n     *     <li>If the default language is preferred ({@code xwiki.language.preferDefault} from {@code xwiki.cfg}\n     *     or {@code preferDefaultLanguage} property from the space preferences ({@code WebPreferences} xobject) or\n     *     wiki preferences ({@code XWikiPreferences} xobject})), and since the user didn't explicitly ask for a\n     *     language already, then use the wiki default locale.</li>\n     *     <li>Try to use the browser's {@code Accept-Language} header sent in HTTP request.<li>\n     *     <li>Fallback to the wiki default locale</li>\n     *   </ul></li>\n     * </ul>\n     *\n     * In addition the {code xwiki.language.forceSupported} configuration property is enabled by default and means that\n     * if at any step above the locale found is not in the list of supported locales, then the locale is not set and\n     * the algorithm moves to the next step.\n     *\n     * @return the locale to use\n     * @since 8.0M1\n     */\n    public Locale getLocalePreference(XWikiContext context)\n    {\n        Locale defaultLocale = this.getDefaultLocale(context);\n        Set<Locale> availableLocales = new HashSet<>(this.getAvailableLocales(context));\n        boolean forceSupported = getConfiguration().getProperty(\"xwiki.language.forceSupported\", \"1\").equals(\"1\");\n\n        // First we try to get the language from the XWiki Context. This is the current language\n        // being used.\n        Locale locale = context.getLocale();\n        if (locale != null) {\n            return locale;\n        }\n\n        // If the wiki is non multilingual then the language is the default language.\n        if (!isMultiLingual(context)) {\n            locale = defaultLocale;\n            context.setLocale(locale);\n            return locale;\n        }\n\n        // As the wiki is multilingual try to find the language to use from the request by looking\n        // for a language parameter. If the language value is \"default\" use the default language\n        // from the XWiki preferences settings. Otherwise set a cookie to remember the language\n        // in use.\n        try {\n            String language = Util.normalizeLanguage(context.getRequest().getParameter(\"language\"));\n            if (language != null) {\n                if (\"default\".equals(language)) {\n                    // forgetting language cookie\n                    Cookie cookie = new Cookie(\"language\", \"\");\n                    cookie.setMaxAge(0);\n                    cookie.setPath(\"/\");\n                    context.getResponse().addCookie(cookie);\n                    context.setLocale(defaultLocale);\n                    return defaultLocale;\n                } else {\n                    locale = setLocale(LocaleUtils.toLocale(language), context, availableLocales, forceSupported);\n                    if (LocaleUtils.isAvailableLocale(locale)) {\n                        // setting language cookie\n                        Cookie cookie = new Cookie(\"language\", context.getLocale().toString());\n                        cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                        cookie.setPath(\"/\");\n                        context.getResponse().addCookie(cookie);\n                        return locale;\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        // As no language parameter was passed in the request, try to get the language to use from a cookie.\n        try {\n            // First we get the language from the cookie\n            String language = Util.normalizeLanguage(getUserPreferenceFromCookie(\"language\", context));\n            if (StringUtils.isNotEmpty(language)) {\n                locale = setLocale(LocaleUtils.toLocale(language), context, availableLocales, forceSupported);\n                if (LocaleUtils.isAvailableLocale(locale)) {\n                    return locale;\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        // If the default language is preferred, and since the user didn't explicitly ask for a\n        // language already, then use the default wiki language.\n        if (getConfiguration().getProperty(\"xwiki.language.preferDefault\", \"0\").equals(\"1\")\n            || getSpacePreference(\"preferDefaultLanguage\", \"0\", context).equals(\"1\")) {\n            locale = defaultLocale;\n            context.setLocale(locale);\n            return locale;\n        }\n\n        // Then from the navigator language setting\n        if (context.getRequest() != null && context.getRequest().getLocales() != null) {\n            for (Locale acceptedLocale : Collections.list(context.getRequest().getLocales())) {\n                locale = setLocale(acceptedLocale, context, availableLocales, forceSupported);\n                if (LocaleUtils.isAvailableLocale(locale)) {\n                    return locale;\n                }\n            }\n            // If none of the languages requested by the client is acceptable, skip to next\n            // phase (use default language).\n        }\n\n        // Finally, use the default language from the global preferences.\n        context.setLocale(defaultLocale);\n        return defaultLocale;\n    }\n\n    /**\n     * First try to find the current locale in use from the XWiki context. If none is used and if the wiki is not\n     * multilingual use the default locale defined in the XWiki preferences. If the wiki is multilingual try to get the\n     * locale passed in the request. If none was passed try to get it from a cookie. If no locale cookie exists then use\n     * the user default locale and barring that use the browser's \"Accept-Language\" header sent in HTTP request. If none\n     * is defined use the default locale.\n     *\n     * @return the locale to use\n     * @deprecated since 8.0M1, use {@link #getLocalePreference(XWikiContext)} instead\n     */\n    @Deprecated\n    public String getLanguagePreference(XWikiContext context)\n    {\n        return getLocalePreference(context).toString();\n    }\n\n    /**\n     * Construct a list of language codes (ISO 639-1) from the Accept-Languages header. This method filters out some\n     * bugs in different browsers or containers, like returning '*' as a language (Jetty) or using '_' as a\n     * language--country delimiter (some versions of Opera).\n     *\n     * @param request The client request.\n     * @return A list of language codes, in the client preference order; might be empty if the header is not well\n     *         formed.\n     */\n    private List<String> getAcceptedLanguages(XWikiRequest request)\n    {\n        List<String> result = new ArrayList<String>();\n        Enumeration<Locale> e = request.getLocales();\n        while (e.hasMoreElements()) {\n            String language = e.nextElement().getLanguage().toLowerCase();\n            // All language codes should have 2 letters.\n            if (StringUtils.isAlpha(language)) {\n                result.add(language);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @deprecated since 5.1M2 use {@link #getDefaultLocale(XWikiContext)} instead\n     */\n    @Deprecated\n    public String getDefaultLanguage(XWikiContext xcontext)\n    {\n        return getDefaultLocale(xcontext).toString();\n    }\n\n    /**\n     * The default locale in the preferences.\n     *\n     * @param xcontext the XWiki context.\n     * @return the default locale\n     * @since 5.1M2\n     */\n    public Locale getDefaultLocale(XWikiContext xcontext)\n    {\n        // Find out what is the default language from the XWiki preferences settings.\n        String defaultLanguage = xcontext.getWiki().getXWikiPreference(\"default_language\", \"\", xcontext);\n\n        Locale defaultLocale;\n\n        if (StringUtils.isBlank(defaultLanguage)) {\n            defaultLocale = Locale.ENGLISH;\n        } else {\n            try {\n                defaultLocale = LocaleUtils.toLocale(Util.normalizeLanguage(defaultLanguage));\n            } catch (Exception e) {\n                LOGGER.warn(\"Invalid locale [{}] set as default locale in the preferences\", defaultLanguage);\n                defaultLocale = Locale.ENGLISH;\n            }\n        }\n\n        return defaultLocale;\n    }\n\n    /**\n     * Get the available locales according to the preferences.\n     *\n     * @param xcontext the XWiki context\n     * @return all the available locales\n     * @since 5.1M2\n     */\n    public List<Locale> getAvailableLocales(XWikiContext xcontext)\n    {\n        String[] languages = StringUtils.split(xcontext.getWiki().getXWikiPreference(\"languages\", xcontext), \", |\");\n\n        List<Locale> locales = new ArrayList<Locale>(languages.length);\n\n        for (String language : languages) {\n            if (StringUtils.isNotBlank(language)) {\n                try {\n                    locales.add(LocaleUtils.toLocale(language));\n                } catch (Exception e) {\n                    LOGGER.warn(\"Invalid locale [{}] listed as available in the preferences\", language);\n                }\n            }\n        }\n\n        // Add default language in case it's not listed as available (which is wrong but it happen)\n        Locale defaultocale = getDefaultLocale(xcontext);\n        if (!locales.contains(defaultocale)) {\n            locales.add(defaultocale);\n        }\n\n        return locales;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public Locale getDocLocalePreferenceNew(XWikiContext context)\n    {\n        String language = getDocLanguagePreferenceNew(context);\n\n        return LocaleUtils.toLocale(language);\n    }\n\n    /**\n     * @deprecated since 8.0M1, use {@link #getDocLocalePreferenceNew(XWikiContext)} instead\n     */\n    @Deprecated\n    // TODO: move implementation to #getDocLocalePreferenceNew\n    public String getDocLanguagePreferenceNew(XWikiContext context)\n    {\n        // Get context language\n        String contextLanguage = context.getLanguage();\n        // If the language exists in the context, it was previously set by another call\n        if (!StringUtils.isEmpty(contextLanguage)) {\n            return contextLanguage;\n        }\n\n        String language = \"\", requestLanguage = \"\", userPreferenceLanguage = \"\", navigatorLanguage = \"\",\n            cookieLanguage = \"\";\n        boolean setCookie = false;\n\n        if (!context.getWiki().isMultiLingual(context)) {\n            language = context.getWiki().getXWikiPreference(\"default_language\", \"\", context);\n            context.setLanguage(language);\n            return language;\n        }\n\n        // Get request language\n        try {\n            requestLanguage = Util.normalizeLanguage(context.getRequest().getParameter(\"language\"));\n        } catch (Exception ex) {\n        }\n\n        // Get user preference\n        try {\n            String user = context.getUser();\n            XWikiDocument userdoc = getDocument(user, context);\n            if (userdoc != null) {\n                userPreferenceLanguage = userdoc.getStringValue(\"XWiki.XWikiUsers\", \"default_language\");\n            }\n        } catch (XWikiException e) {\n        }\n\n        // Get navigator language setting\n        if (context.getRequest() != null) {\n            String accept = context.getRequest().getHeader(\"Accept-Language\");\n            if ((accept != null) && (!accept.equals(\"\"))) {\n                String[] alist = StringUtils.split(accept, \",;-\");\n                if ((alist != null) && !(alist.length == 0)) {\n                    context.setLanguage(alist[0]);\n                    navigatorLanguage = alist[0];\n                }\n            }\n        }\n\n        // Get language from cookie\n        try {\n            cookieLanguage = Util.normalizeLanguage(getUserPreferenceFromCookie(\"language\", context));\n        } catch (Exception e) {\n        }\n\n        // Determine which language to use\n        // First we get the language from the request\n        if (StringUtils.isNotEmpty(requestLanguage)) {\n            if (requestLanguage.equals(\"default\")) {\n                setCookie = true;\n            } else {\n                language = requestLanguage;\n                context.setLanguage(language);\n                Cookie cookie = new Cookie(\"language\", language);\n                cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                cookie.setPath(\"/\");\n                context.getResponse().addCookie(cookie);\n                return language;\n            }\n        }\n        // Next we get the language from the cookie\n        if (StringUtils.isNotEmpty(cookieLanguage)) {\n            language = cookieLanguage;\n        }\n        // Next from the default user preference\n        else if (StringUtils.isNotEmpty(userPreferenceLanguage)) {\n            language = userPreferenceLanguage;\n        }\n        // Then from the navigator language setting\n        else if (StringUtils.isNotEmpty(navigatorLanguage)) {\n            language = navigatorLanguage;\n        }\n        context.setLanguage(language);\n        if (setCookie) {\n            Cookie cookie = new Cookie(\"language\", language);\n            cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n            cookie.setPath(\"/\");\n            context.getResponse().addCookie(cookie);\n        }\n        return language;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public Locale getInterfaceLocalePreference(XWikiContext context)\n    {\n        String language = getInterfaceLanguagePreference(context);\n\n        return LocaleUtils.toLocale(language);\n    }\n\n    /**\n     * @deprecated since 8.0M1, use {@link #getInterfaceLocalePreference(XWikiContext)} instead\n     */\n    @Deprecated\n    // TODO: move implementation to #getInterfaceLocalePreference\n    public String getInterfaceLanguagePreference(XWikiContext context)\n    {\n        String language = \"\", requestLanguage = \"\", userPreferenceLanguage = \"\", navigatorLanguage = \"\",\n            cookieLanguage = \"\", contextLanguage = \"\";\n        boolean setCookie = false;\n\n        if (!context.getWiki().isMultiLingual(context)) {\n            language = Util.normalizeLanguage(context.getWiki().getXWikiPreference(\"default_language\", \"\", context));\n            context.setInterfaceLocale(LocaleUtils.toLocale(language));\n            return language;\n        }\n\n        // Get request language\n        try {\n            requestLanguage = Util.normalizeLanguage(context.getRequest().getParameter(\"interfacelanguage\"));\n        } catch (Exception ex) {\n        }\n\n        // Get context language\n        contextLanguage = context.getInterfaceLanguage();\n\n        // Get user preference\n        try {\n            String user = context.getUser();\n            XWikiDocument userdoc = null;\n            userdoc = getDocument(user, context);\n            if (userdoc != null) {\n                userPreferenceLanguage = userdoc.getStringValue(\"XWiki.XWikiUsers\", \"default_interface_language\");\n            }\n        } catch (XWikiException e) {\n        }\n\n        // Get navigator language setting\n        if (context.getRequest() != null) {\n            String accept = context.getRequest().getHeader(\"Accept-Language\");\n            if ((accept != null) && (!accept.equals(\"\"))) {\n                String[] alist = StringUtils.split(accept, \",;-\");\n                if ((alist != null) && !(alist.length == 0)) {\n                    context.setLanguage(alist[0]);\n                    navigatorLanguage = alist[0];\n                }\n            }\n        }\n\n        // Get language from cookie\n        try {\n            cookieLanguage = Util.normalizeLanguage(getUserPreferenceFromCookie(\"interfacelanguage\", context));\n        } catch (Exception e) {\n        }\n\n        // Determine which language to use\n        // First we get the language from the request\n        if ((requestLanguage != null) && (!requestLanguage.equals(\"\"))) {\n            if (requestLanguage.equals(\"default\")) {\n                setCookie = true;\n            } else {\n                language = requestLanguage;\n                context.setLanguage(language);\n                Cookie cookie = new Cookie(\"interfacelanguage\", language);\n                cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                cookie.setPath(\"/\");\n                context.getResponse().addCookie(cookie);\n                return language;\n            }\n        }\n        // Next we get the language from the context\n        if (!StringUtils.isEmpty(contextLanguage)) {\n            language = contextLanguage;\n        }\n        // Next we get the language from the cookie\n        else if (StringUtils.isNotEmpty(cookieLanguage)) {\n            language = cookieLanguage;\n        }\n        // Next from the default user preference\n        else if (StringUtils.isNotEmpty(userPreferenceLanguage)) {\n            language = userPreferenceLanguage;\n        }\n        // Then from the navigator language setting\n        else if (StringUtils.isNotEmpty(navigatorLanguage)) {\n            language = navigatorLanguage;\n        }\n        context.setLanguage(language);\n        if (setCookie) {\n            Cookie cookie = new Cookie(\"interfacelanguage\", language);\n            cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n            cookie.setPath(\"/\");\n            context.getResponse().addCookie(cookie);\n        }\n        return language;\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getXWikiPreference(preference, context));\n    }\n\n    public long getSpacePreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getSpacePreference(preference, context));\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, long defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toLong((getXWikiPreference(preference, context)), defaultValue);\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, String fallbackParameter, long defaultValue,\n        XWikiContext context)\n    {\n        return NumberUtils.toLong(getXWikiPreference(preference, fallbackParameter, \"\", context), defaultValue);\n    }\n\n    public long getSpacePreferenceAsLong(String preference, long defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toLong(getSpacePreference(preference, context), defaultValue);\n    }\n\n    public long getUserPreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getUserPreference(preference, context));\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, XWikiContext context)\n    {\n        return Integer.parseInt(getXWikiPreference(preference, context));\n    }\n\n    public int getSpacePreferenceAsInt(String preference, XWikiContext context)\n    {\n        return Integer.parseInt(getSpacePreference(preference, context));\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, int defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toInt(getXWikiPreference(preference, context), defaultValue);\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, String fallbackParameter, int defaultValue,\n        XWikiContext context)\n    {\n        return NumberUtils.toInt(getXWikiPreference(preference, fallbackParameter, \"\", context), defaultValue);\n    }\n\n    public int getSpacePreferenceAsInt(String preference, int defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toInt(getSpacePreference(preference, context), defaultValue);\n    }\n\n    public int getUserPreferenceAsInt(String prefname, XWikiContext context)\n    {\n        return Integer.parseInt(getUserPreference(prefname, context));\n    }\n\n    public void flushCache(XWikiContext context)\n    {\n        // We need to flush the virtual wiki list\n        this.initializedWikis = new ConcurrentHashMap<>();\n\n        // We need to flush the group service cache\n        if (this.groupService != null) {\n            this.groupService.flushCache();\n        }\n\n        // If we use the Cache Store layer.. we need to flush it\n        XWikiStoreInterface store = getStore();\n        if ((store != null) && (store instanceof XWikiCacheStoreInterface)) {\n            ((XWikiCacheStoreInterface) getStore()).flushCache();\n        }\n        // Flush renderers.. Groovy renderer has a cache\n        getOldRendering().flushCache();\n        getParseGroovyFromString().flushCache();\n\n        XWikiPluginManager pmanager = getPluginManager();\n        if (pmanager != null) {\n            pmanager.flushCache(context);\n        }\n\n        // Make sure we call all classes flushCache function\n        try {\n            List<String> classes = getClassList(context);\n            for (int i = 0; i < classes.size(); i++) {\n                String className = classes.get(i);\n                try {\n                    getClass(className, context).flushCache();\n                } catch (Exception e) {\n                }\n            }\n        } catch (Exception e) {\n        }\n\n    }\n\n    public XWikiPluginManager getPluginManager()\n    {\n        return this.pluginManager;\n    }\n\n    public void setPluginManager(XWikiPluginManager pluginManager)\n    {\n        this.pluginManager = pluginManager;\n    }\n\n    public void setStore(XWikiStoreInterface store)\n    {\n        this.store = store;\n    }\n\n    /**\n     * @param attachmentContentStore the store to use by default when saving a new attachment content\n     * @since 9.10RC1\n     */\n    public void setDefaultAttachmentContentStore(XWikiAttachmentStoreInterface attachmentContentStore)\n    {\n        this.defaultAttachmentContentStore = attachmentContentStore;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #setDefaultAttachmentContentStore(XWikiAttachmentStoreInterface)} instead\n     */\n    @Deprecated\n    public void setAttachmentStore(XWikiAttachmentStoreInterface attachmentStore)\n    {\n        this.defaultAttachmentContentStore = attachmentStore;\n    }\n\n    /**\n     * @param attachmentArchiveStore the store to use by default when saving a new attachment archive\n     * @since 9.10RC1\n     */\n    public void setDefaultAttachmentArchiveStore(AttachmentVersioningStore attachmentArchiveStore)\n    {\n        this.defaultAttachmentArchiveStore = attachmentArchiveStore;\n    }\n\n    /**\n     * @deprecated since 9.10RC1, use {@link #setDefaultAttachmentArchiveStore(AttachmentVersioningStore)} instead\n     */\n    @Deprecated\n    public void setAttachmentVersioningStore(AttachmentVersioningStore attachmentArchiveStore)\n    {\n        setDefaultAttachmentArchiveStore(attachmentArchiveStore);\n    }\n\n    public void setVersioningStore(XWikiVersioningStoreInterface versioningStore)\n    {\n        this.versioningStore = versioningStore;\n    }\n\n    public void setRecycleBinStore(XWikiRecycleBinStoreInterface recycleBinStore)\n    {\n        this.recycleBinStore = recycleBinStore;\n    }\n\n    public void setAttachmentRecycleBinStore(AttachmentRecycleBinStore attachmentRecycleBinStore)\n    {\n        this.attachmentRecycleBinStore = attachmentRecycleBinStore;\n    }\n\n    public void setCriteriaService(XWikiCriteriaService criteriaService)\n    {\n        this.criteriaService = criteriaService;\n    }\n\n    public void setVersion(String version)\n    {\n        this.version = version;\n    }\n\n    /**\n     * Verify if the provided xclass page exists and that it contains all the required configuration properties to make\n     * the tag feature work properly. If some properties are missing they are created and saved in the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @param classReference the reference of the document containing the class\n     * @return the Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     */\n    private BaseClass getMandatoryClass(XWikiContext context, DocumentReference classReference) throws XWikiException\n    {\n        XWikiDocument document = getDocument(classReference, context);\n\n        if (context.get(\"initdone\") == null) {\n            @SuppressWarnings(\"deprecation\")\n            MandatoryDocumentInitializer initializer =\n                Utils.getComponent(MandatoryDocumentInitializer.class, document.getFullName());\n\n            if (initializer.updateDocument(document)) {\n                saveDocument(document, localizePlainOrKey(\"core.model.xclass.mandatoryUpdateProperty.versionSummary\"),\n                    context);\n            }\n        }\n\n        return document.getXClass();\n    }\n\n    /**\n     * Verify if the <code>XWiki.TagClass</code> page exists and that it contains all the required configuration\n     * properties to make the tag feature work properly. If some properties are missing they are created and saved in\n     * the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the TagClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getTagClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"TagClass\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.SheetClass</code> page exists and that it contains all the required configuration\n     * properties to make the sheet feature work properly. If some properties are missing they are created and saved in\n     * the database. SheetClass is used to a page as a sheet. When a page is tagged as a sheet and that page is included\n     * in another page using the include macro then editing it triggers automatic inline edition (for XWiki Syntax 2.0\n     * only - for XWiki Syntax 1.0 automatic inline edition is triggered using #includeForm).\n     *\n     * @param context see {@link XWikiContext}\n     * @return the SheetClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     * @deprecated since 3.1M2 edit mode class should be used for this purpose, not the sheet class\n     * @see #getEditModeClass(XWikiContext)\n     */\n    @Deprecated\n    public BaseClass getSheetClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"SheetClass\"));\n    }\n\n    /**\n     * Verify if the {@code XWiki.EditModeClass} page exists and that it contains all the required configuration\n     * properties to make the edit mode feature work properly. If some properties are missing they are created and saved\n     * in the database. EditModeClass is used to specify the default edit mode of a page. It can also be used to mark a\n     * page as a sheet. When a page is marked as a sheet and that page is included in another page using the include\n     * macro then editing it triggers automatic inline edition (for XWiki Syntax 2.0 only - for XWiki Syntax 1.0\n     * automatic inline edition is triggered using #includeForm). It replaces and enhances the SheetClass mechanism (see\n     * {@link #getSheetClass(XWikiContext)}).\n     *\n     * @param context see {@link XWikiContext}\n     * @return the EditModeClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     * @since 3.1M2\n     */\n    public BaseClass getEditModeClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(\n            new LocalDocumentReference(XWikiConstant.EDIT_MODE_CLASS), new WikiReference(context.getWikiId())));\n    }\n\n    /**\n     * Verify if the <code>XWiki.XWikiUsers</code> page exists and that it contains all the required configuration\n     * properties to make the user feature work properly. If some properties are missing they are created and saved in\n     * the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the XWikiUsers Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getUserClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiUsers\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.GlobalRedirect</code> page exists and that it contains all the required configuration\n     * properties to make the redirection feature work properly. If some properties are missing they are created and\n     * saved in the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the GlobalRedirect Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getRedirectClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"GlobalRedirect\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.XWikiPreferences</code> page exists and that it contains all the required configuration\n     * properties to make XWiki work properly. If some properties are missing they are created and saved in the\n     * database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the XWiki Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getPrefsClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, getPreferencesDocumentReference(context));\n    }\n\n    public BaseClass getGroupClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiGroups\"));\n    }\n\n    public BaseClass getRightsClass(String pagename, XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, pagename));\n    }\n\n    public BaseClass getRightsClass(XWikiContext context) throws XWikiException\n    {\n        return getRightsClass(\"XWikiRights\", context);\n    }\n\n    public BaseClass getGlobalRightsClass(XWikiContext context) throws XWikiException\n    {\n        return getRightsClass(\"XWikiGlobalRights\", context);\n    }\n\n    public BaseClass getCommentsClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiComments\"));\n    }\n\n    public BaseClass getSkinClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiSkins\"));\n    }\n\n    public int createUser(XWikiContext context) throws XWikiException\n    {\n        return createUser(false, \"edit\", context);\n    }\n\n    public int validateUser(boolean withConfirmEmail, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            // Get the user document\n            String username = convertUsername(request.getParameter(\"xwikiname\"), context);\n            if (username.indexOf('.') == -1) {\n                username = \"XWiki.\" + username;\n            }\n            XWikiDocument userDocument = getDocument(username, context);\n\n            // Get the stored validation key\n            BaseObject userObject = userDocument.getObject(\"XWiki.XWikiUsers\", 0);\n            String storedKey = userObject.getStringValue(\"validkey\");\n\n            // Get the validation key from the URL\n            String validationKey = request.getParameter(\"validkey\");\n            PropertyInterface validationKeyClass = getClass(\"XWiki.XWikiUsers\", context).get(\"validkey\");\n            if (validationKeyClass instanceof PasswordClass) {\n                validationKey = ((PasswordClass) validationKeyClass).getEquivalentPassword(storedKey, validationKey);\n            }\n\n            // Compare the two keys\n            if ((!storedKey.equals(\"\") && (storedKey.equals(validationKey)))) {\n                // Ensure to remove the validation key value, so it cannot be used afterwards to enable back\n                // a disabled user.\n                userObject.setStringValue(\"validkey\", \"\");\n                saveDocument(userDocument, context);\n\n                XWikiUser xWikiUser = new XWikiUser(userDocument.getDocumentReference());\n                xWikiUser.setDisabled(false, context);\n                xWikiUser.setEmailChecked(true, context);\n\n                if (withConfirmEmail) {\n                    String email = userObject.getStringValue(\"email\");\n                    String password = userObject.getStringValue(\"password\");\n                    sendValidationEmail(username, password, email, request.getParameter(\"validkey\"),\n                        \"confirmation_email_content\", context);\n                }\n\n                return 0;\n            } else {\n                return -1;\n            }\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_VALIDATE_USER,\n                \"Exception while validating user\", e, null);\n        }\n    }\n\n    public int createUser(boolean withValidation, String userRights, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            Map<String, String[]> map = Util.getObject(request, \"register\");\n\n            String content = \"\";\n            Syntax syntax = getDefaultDocumentSyntaxInternal();\n\n            // Read the values from the request.\n            String xwikiname = request.getParameter(\"xwikiname\");\n            String password2 = request.getParameter(\"register2_password\");\n            String password = (map.get(\"password\"))[0];\n            String email = (map.get(\"email\"))[0];\n            String template = request.getParameter(\"template\");\n            String parent = request.getParameter(\"parent\");\n            String validkey = null;\n\n            // Validate the values.\n            if (XWikiRightService.SUPERADMIN_USER.equalsIgnoreCase(xwikiname)) {\n                return -8;\n            }\n            try {\n                if (!context.getUtil().match(getConfiguration().getProperty(\"xwiki.validusername\", \"/^[a-zA-Z0-9_]+$/\"),\n                    xwikiname)) {\n                    return -4;\n                }\n            } catch (RuntimeException ex) {\n                LOGGER.warn(\"Invalid regular expression for xwiki.validusername\", ex);\n                if (!context.getUtil().match(\"/^[a-zA-Z0-9_]+$/\", xwikiname)) {\n                    return -4;\n                }\n            }\n\n            if ((!password.equals(password2))) {\n                // TODO: throw wrong password exception\n                return -2;\n            }\n\n            if ((template != null) && (!template.equals(\"\"))) {\n                XWikiDocument tdoc = getDocument(template, context);\n                if ((!tdoc.isNew())) {\n                    // FIXME: This ignores template objects, attachments, etc.\n                    content = tdoc.getContent();\n                    syntax = tdoc.getSyntax();\n                }\n            }\n\n            if ((parent == null) || (parent.equals(\"\"))) {\n                parent = \"XWiki.XWikiUsers\";\n            }\n\n            // Mark the user as active or waiting email validation.\n            if (withValidation) {\n                map.put(XWikiUser.ACTIVE_PROPERTY, new String[] { \"0\" });\n                map.put(XWikiUser.EMAIL_CHECKED_PROPERTY, new String[] { \"0\" });\n\n                validkey = generateValidationKey(16);\n                map.put(\"validkey\", new String[] { validkey });\n\n            } else {\n                // Mark user active\n                map.put(XWikiUser.ACTIVE_PROPERTY, new String[] { \"1\" });\n                map.put(XWikiUser.EMAIL_CHECKED_PROPERTY, new String[] { \"1\" });\n            }\n\n            // Create the user.\n            int result =\n                createUser(xwikiname, map, getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT),\n                    content, syntax, userRights, context);\n\n            // Send validation mail, if needed.\n            if ((result > 0) && (withValidation)) {\n                // Send the validation email\n                try {\n                    sendValidationEmail(xwikiname, password, email, validkey, \"validation_email_content\", context);\n                } catch (XWikiException e) {\n                    LOGGER.warn(\"User created. Failed to send the mail to the created user.\", e);\n                    return -11;\n                }\n\n            }\n\n            return result;\n        } catch (XWikiException e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw e;\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_CREATE_USER,\n                \"Exception while creating user\", e, null);\n        }\n    }\n\n    /**\n     * Method allows to create an empty user with no password (he won't be able to login) This method is usefull for\n     * authentication like LDAP or App Server trusted\n     *\n     * @param xwikiname\n     * @param userRights\n     * @param context see {@link XWikiContext}\n     * @return true if success\n     * @throws XWikiException\n     */\n    public boolean createEmptyUser(String xwikiname, String userRights, XWikiContext context) throws XWikiException\n    {\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"active\", \"1\");\n        map.put(\"first_name\", xwikiname);\n\n        if (createUser(xwikiname, map, userRights, context) == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void sendConfirmationEmail(String xwikiname, String password, String email, String message,\n        String contentfield, XWikiContext context) throws XWikiException\n    {\n        sendValidationEmail(xwikiname, password, email, \"message\", message, contentfield, context);\n    }\n\n    public void sendValidationEmail(String xwikiname, String password, String email, String validkey,\n        String contentfield, XWikiContext context) throws XWikiException\n    {\n        sendValidationEmail(xwikiname, password, email, \"validkey\", validkey, contentfield, context);\n    }\n\n    public void sendValidationEmail(String xwikiname, String password, String email, String addfieldname,\n        String addfieldvalue, String contentfield, XWikiContext context) throws XWikiException\n    {\n        MailSenderConfiguration configuration = Utils.getComponent(MailSenderConfiguration.class);\n\n        String sender;\n        String content;\n        try {\n            sender = configuration.getFromAddress();\n            if (StringUtils.isBlank(sender)) {\n                String server = context.getRequest().getServerName();\n                if (server.matches(\"\\\\[.*\\\\]|(\\\\d{1,3}+\\\\.){3}+\\\\d{1,3}+\")) {\n                    sender = \"noreply@domain.net\";\n                } else {\n                    sender = \"noreply@\" + server;\n                }\n            }\n            content = getXWikiPreference(contentfield, context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_CANNOT_GET_VALIDATION_CONFIG,\n                \"Exception while reading the validation email config\", e, null);\n\n        }\n\n        try {\n            VelocityContext vcontext = (VelocityContext) context.get(\"vcontext\");\n            vcontext.put(addfieldname, addfieldvalue);\n            vcontext.put(\"email\", email);\n            vcontext.put(\"password\", password);\n            vcontext.put(\"sender\", sender);\n            vcontext.put(\"xwikiname\", xwikiname);\n            content = parseContent(content, context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_CANNOT_PREPARE_VALIDATION_EMAIL,\n                \"Exception while preparing the validation email\", e, null);\n\n        }\n\n        // Let's now send the message\n        try {\n            Session session =\n                Session.getInstance(configuration.getAllProperties(), new XWikiAuthenticator(configuration));\n            InputStream is = new ByteArrayInputStream(content.getBytes());\n            MimeMessage message = new MimeMessage(session, is);\n            message.setFrom(new InternetAddress(sender));\n            message.setRecipients(Message.RecipientType.TO, email);\n            message.setHeader(\"X-MailType\", \"Account Validation\");\n            MailSender mailSender = Utils.getComponent(MailSender.class);\n            MailListener mailListener = Utils.getComponent(MailListener.class, \"database\");\n            mailSender.sendAsynchronously(Arrays.asList(message), session, mailListener);\n            mailListener.getMailStatusResult().waitTillProcessed(Long.MAX_VALUE);\n            String errorMessage = MailStatusResultSerializer.serializeErrors(mailListener.getMailStatusResult());\n            if (errorMessage != null) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                    XWikiException.ERROR_XWIKI_EMAIL_ERROR_SENDING_EMAIL,\n                    String.format(\"Error while sending the validation email. %s\", errorMessage));\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_ERROR_SENDING_EMAIL, \"Error while sending the validation email\", e);\n        }\n    }\n\n    public String generateRandomString(int size)\n    {\n        return RandomStringUtils.randomAlphanumeric(size);\n    }\n\n    public String generateValidationKey(int size)\n    {\n        return generateRandomString(size);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, XWikiContext context) throws XWikiException\n    {\n        return createUser(userName, map, \"edit\", context);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param userRights the right of the user on his own profile page\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, String userRights, XWikiContext context)\n        throws XWikiException\n    {\n        BaseClass userClass = getUserClass(context);\n\n        String content = \"\";\n        Syntax syntax = getDefaultDocumentSyntaxInternal();\n\n        return createUser(userName, map,\n            new EntityReference(userClass.getDocumentReference().getName(), EntityType.DOCUMENT), content, syntax,\n            userRights, context);\n    }\n\n    /**\n     * @deprecated since 2.4RC1 use\n     *             {@link #createUser(String, Map, EntityReference, String, Syntax, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public int createUser(String userName, Map<String, ?> map, String parent, String content, String syntaxId,\n        String userRights, XWikiContext context) throws XWikiException\n    {\n        Syntax syntax;\n\n        try {\n            syntax = Syntax.valueOf(syntaxId);\n        } catch (ParseException e) {\n            syntax = getDefaultDocumentSyntaxInternal();\n        }\n\n        return createUser(userName, map, getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT),\n            content, syntax, userRights, context);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param parentReference the parent of the user profile\n     * @param content the content of the user profile\n     * @param syntax the syntax of the provided content\n     * @param userRights the right of the user on his own profile page\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, EntityReference parentReference, String content,\n        Syntax syntax, String userRights, XWikiContext context) throws XWikiException\n    {\n        BaseClass userClass = getUserClass(context);\n\n        try {\n            // TODO: Verify existing user\n            XWikiDocument doc = getDocument(new DocumentReference(context.getWikiId(), \"XWiki\", userName), context);\n\n            if (!doc.isNew()) {\n                // TODO: throws Exception\n                return -3;\n            }\n\n            DocumentReference userClassReference = userClass.getDocumentReference();\n            BaseObject userObject =\n                doc.newXObject(userClassReference.removeParent(userClassReference.getWikiReference()), context);\n            userClass.fromMap(map, userObject);\n\n            doc.setParentReference(parentReference);\n            doc.setContent(content);\n            doc.setSyntax(syntax);\n\n            // Set the user itself as the creator of the document, so that she has the CREATOR right on her user page.\n            doc.setCreatorReference(doc.getDocumentReference());\n\n            // However, we use the context user for the author to see in the history who has really created the user\n            // (it may be an administrator).\n            if (context.getUserReference() != null) {\n                doc.setAuthorReference(context.getUserReference());\n            } else {\n                // Except if the current user is guest (which means the user registered herself)\n                doc.setAuthorReference(doc.getDocumentReference());\n            }\n\n            // The information from the user profile needs to be indexed using the proper locale. If multilingual is\n            // enabled then the user can choose the desired locale (from the list of supported locales) before\n            // registering. An administrator registering users can do the same. Otherwise, if there is only one locale\n            // supported then that langage will be used.\n            doc.setDefaultLocale(context.getLocale());\n\n            protectUserPage(doc.getFullName(), userRights, doc, context);\n\n            saveDocument(doc, localizePlainOrKey(\"core.comment.createdUser\"), context);\n\n            // Now let's add the user to XWiki.XWikiAllGroup\n            setUserDefaultGroup(doc.getFullName(), context);\n\n            return 1;\n        } catch (Exception e) {\n            Object[] args = { \"XWiki.\" + userName };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_CREATE,\n                \"Cannot create user {0}\", e, args);\n        }\n    }\n\n    /**\n     * @deprecated starting with XE 1.8.1 use\n     *             {@link #createUser(String, Map, String, String, String, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public int createUser(String xwikiname, Map<String, ?> map, String parent, String content, String userRights,\n        XWikiContext context) throws XWikiException\n    {\n        return createUser(xwikiname, map, parent, content, Syntax.XWIKI_1_0.toIdString(), userRights, context);\n    }\n\n    public void setUserDefaultGroup(String fullwikiname, XWikiContext context) throws XWikiException\n    {\n        String groupsPreference = isAllGroupImplicit() ? getConfiguration().getProperty(\"xwiki.users.initialGroups\")\n            : getConfiguration().getProperty(\"xwiki.users.initialGroups\", \"XWiki.XWikiAllGroup\");\n\n        if (groupsPreference != null) {\n            String[] groups = groupsPreference.split(\",\");\n            for (String groupName : groups) {\n                if (StringUtils.isNotBlank(groupName)) {\n                    addUserToGroup(fullwikiname, groupName.trim(), context);\n                }\n            }\n        }\n    }\n\n    protected void addUserToGroup(String userName, String groupName, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groupDoc = getDocument(groupName, context);\n\n        DocumentReference groupClassReference = getGroupClass(context).getDocumentReference();\n        BaseObject memberObject =\n            groupDoc.newXObject(groupClassReference.removeParent(groupClassReference.getWikiReference()), context);\n\n        memberObject.setStringValue(\"member\", userName);\n\n        this.saveDocument(groupDoc, localizePlainOrKey(\"core.comment.addedUserToGroup\"), context);\n    }\n\n    public void protectUserPage(String userName, String userRights, XWikiDocument doc, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference rightClassReference = getRightsClass(context).getDocumentReference();\n\n        EntityReference relativeRightClassReference =\n            rightClassReference.removeParent(rightClassReference.getWikiReference());\n\n        // Allow users to edit their own profiles\n        BaseObject newuserrightsobject = doc.newXObject(relativeRightClassReference, context);\n        newuserrightsobject.setLargeStringValue(\"users\", userName);\n        newuserrightsobject.setStringValue(\"levels\", userRights);\n        newuserrightsobject.setIntValue(\"allow\", 1);\n    }\n\n    public User getUser(XWikiContext context)\n    {\n        return getUser(context.getUserReference(), context);\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link #getUser(DocumentReference, XWikiContext)}.\n     */\n    @Deprecated\n    public User getUser(String username, XWikiContext context)\n    {\n        XWikiUser xwikiUser = new XWikiUser(username);\n        User user = new User(xwikiUser, context);\n        return user;\n    }\n\n    /**\n     * Retrieve a user from its document reference.\n     *\n     * @param userReference the reference of the user.\n     * @param context the current context.\n     * @return the user corresponding to that document reference.\n     * @since 11.8RC1\n     */\n    public User getUser(DocumentReference userReference, XWikiContext context)\n    {\n        XWikiUser xwikiUser = new XWikiUser(userReference);\n        User user = new User(xwikiUser, context);\n        return user;\n    }\n\n    /**\n     * Prepares the localized resources, according to the selected locale. Set context \"msg\" and locale.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public void prepareResources(XWikiContext context)\n    {\n        if (context.get(\"msg\") == null) {\n            Locale locale = getLocalePreference(context);\n            context.setLocale(locale);\n            if (context.getResponse() != null) {\n                context.getResponse().setLocale(locale);\n            }\n            XWikiMessageTool msg = new XWikiMessageTool(Utils.getComponent(ContextualLocalizationManager.class));\n            context.put(\"msg\", msg);\n        }\n    }\n\n    public XWikiUser checkAuth(XWikiContext context) throws XWikiException\n    {\n        return getAuthService().checkAuth(context);\n    }\n\n    public boolean checkAccess(String action, XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        // Handle the 'skin' action specially so that resources don`t require special (or even 'view') rights.\n        String firstSpaceName = doc.getDocumentReference().getSpaceReferences().get(0).getName();\n        if (action.equals(\"skin\") && SKIN_RESOURCE_SPACE_NAMES.contains(firstSpaceName)) {\n            // We still need to call checkAuth to set the proper user.\n            XWikiUser user = checkAuth(context);\n            if (user != null) {\n                context.setUser(user.getUser());\n            }\n\n            // Always allow.\n            return true;\n        }\n\n        return getRightService().checkAccess(action, doc, context);\n    }\n\n    public String include(String topic, boolean isForm, XWikiContext context) throws XWikiException\n    {\n        String database = null, incdatabase = null;\n        String prefixedTopic, localTopic;\n\n        // Save current documents in script context\n        Document currentAPIdoc = null, currentAPIcdoc = null, currentAPItdoc = null;\n        ScriptContextManager scritContextManager = Utils.getComponent(ScriptContextManager.class);\n        ScriptContext scontext = scritContextManager.getScriptContext();\n        String currentDocName = context.getWikiId() + \":\" + context.getDoc().getFullName();\n        if (scontext != null) {\n            currentAPIdoc = (Document) scontext.getAttribute(\"doc\");\n            currentAPIcdoc = (Document) scontext.getAttribute(\"cdoc\");\n            currentAPItdoc = (Document) scontext.getAttribute(\"tdoc\");\n        }\n\n        try {\n            int i0 = topic.indexOf(':');\n            if (i0 != -1) {\n                incdatabase = topic.substring(0, i0);\n                database = context.getWikiId();\n                context.setWikiId(incdatabase);\n                prefixedTopic = topic;\n                localTopic = topic.substring(i0 + 1);\n            } else {\n                prefixedTopic = context.getWikiId() + \":\" + topic;\n                localTopic = topic;\n            }\n\n            XWikiDocument doc = null;\n            try {\n                LOGGER.debug(\"Including Topic \" + topic);\n                try {\n                    @SuppressWarnings(\"unchecked\")\n                    Set<String> includedDocs = (Set<String>) context.get(\"included_docs\");\n                    if (includedDocs == null) {\n                        includedDocs = new HashSet<String>();\n                        context.put(\"included_docs\", includedDocs);\n                    }\n\n                    if (includedDocs.contains(prefixedTopic) || currentDocName.equals(prefixedTopic)) {\n                        LOGGER.warn(\"Error on too many recursive includes for topic \" + topic);\n                        return \"Cannot make recursive include\";\n                    }\n                    includedDocs.add(prefixedTopic);\n                } catch (Exception e) {\n                }\n\n                // Get document to include\n                DocumentReference targetDocumentReference =\n                    getCurrentMixedDocumentReferenceResolver().resolve(localTopic);\n                doc = getDocument(targetDocumentReference, context);\n\n                if (checkAccess(\"view\", doc, context) == false) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED, \"Access to this document is denied: \" + doc);\n                }\n            } catch (XWikiException e) {\n                LOGGER.warn(\"Exception Including Topic \" + topic, e);\n                return \"Topic \" + topic + \" does not exist\";\n            }\n\n            XWikiDocument contentdoc = doc.getTranslatedDocument(context);\n\n            String result;\n            if (isForm) {\n                // We do everything in the context of the including document\n                if (database != null) {\n                    context.setWikiId(database);\n                }\n\n                // Note: the Script macro in the new rendering checks for programming rights for the document in\n                // the xwiki context.\n                result = getRenderedContent(contentdoc, (XWikiDocument) context.get(\"doc\"), context);\n            } else {\n                // We stay in the included document context\n\n                // Since the Script macro checks for programming rights in the current document, we need to\n                // temporarily set the contentdoc as the current doc before rendering it.\n                XWikiDocument originalDoc = null;\n                try {\n                    originalDoc = context.getDoc();\n                    context.put(\"doc\", doc);\n                    result = getRenderedContent(contentdoc, doc, context);\n                } finally {\n                    context.put(\"doc\", originalDoc);\n                }\n            }\n            try {\n                @SuppressWarnings(\"unchecked\")\n                Set<String> includedDocs = (Set<String>) context.get(\"included_docs\");\n                if (includedDocs != null) {\n                    includedDocs.remove(prefixedTopic);\n                }\n            } catch (Exception e) {\n            }\n            return result;\n        } finally {\n            if (database != null) {\n                context.setWikiId(database);\n            }\n\n            if (currentAPIdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"doc\", currentAPIdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n            if (currentAPIcdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"cdoc\", currentAPIcdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n            if (currentAPItdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"tdoc\", currentAPItdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n        }\n    }\n\n    /**\n     * Render content from the passed included document, setting the correct security doc (sdoc) and including doc\n     * (idoc).\n     *\n     * @since 2.2M2\n     */\n    private String getRenderedContent(XWikiDocument includedDoc, XWikiDocument includingDoc, XWikiContext context)\n        throws XWikiException\n    {\n        String result;\n        XWikiDocument idoc = (XWikiDocument) context.get(\"idoc\");\n        XWikiDocument sdoc = (XWikiDocument) context.get(\"sdoc\");\n\n        context.put(\"idoc\", includingDoc);\n        context.put(\"sdoc\", includedDoc);\n        try {\n            result = includedDoc.getRenderedContent(Utils.getComponent(RenderingContext.class).getTargetSyntax(), false,\n                context);\n        } finally {\n            // Remove including doc or set the previous one\n            if (idoc == null) {\n                context.remove(\"idoc\");\n            } else {\n                context.put(\"idoc\", idoc);\n            }\n\n            // Remove security doc or set the previous one\n            if (sdoc == null) {\n                context.remove(\"sdoc\");\n            } else {\n                context.put(\"sdoc\", sdoc);\n            }\n        }\n\n        return result;\n    }\n\n    public void deleteDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        deleteDocument(doc, true, context);\n    }\n\n    public void deleteDocument(XWikiDocument doc, boolean totrash, XWikiContext context) throws XWikiException\n    {\n        deleteDocument(doc, totrash, true, context);\n    }\n\n    private XWikiDocument prepareDocumentDelete(XWikiDocument doc, XWikiContext context)\n    {\n        // The source document is a new empty XWikiDocument to follow\n        // DocumentUpdatedEvent policy: source document in new document and the old version is available using\n        // doc.getOriginalDocument()\n        XWikiDocument blankDoc = new XWikiDocument(doc.getDocumentReference());\n        // Again to follow general event policy, new document author is the user who modified the document\n        // (here the modification is delete)\n        blankDoc.setOriginalDocument(doc.getOriginalDocument());\n        blankDoc.setAuthorReference(context.getUserReference());\n        blankDoc.setContentAuthorReference(context.getUserReference());\n\n        return blankDoc;\n    }\n\n    private XWikiDocument beforeDelete(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument blankDoc = prepareDocumentDelete(doc, context);\n\n        ObservationManager om = getObservationManager();\n\n        // Inform notification mechanisms that a document is about to be deleted\n        // Note that for the moment the event being send is a bridge event, as we are still passing around\n        // an XWikiDocument as source and an XWikiContext as data.\n        if (om != null) {\n            CancelableEvent documentEvent = new DocumentDeletingEvent(doc.getDocumentReference());\n            om.notify(documentEvent, blankDoc, context);\n\n            // If the action has been canceled by the user then don't perform any deletion and throw an exception\n            if (documentEvent.isCanceled()) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_DOC,\n                    String.format(\"An Event Listener has cancelled the document deletion for [%s]. Reason: [%s]\",\n                        doc.getDocumentReference(), documentEvent.getReason()));\n            }\n        }\n\n        return blankDoc;\n    }\n\n    private void afterDelete(XWikiDocument blankDoc, XWikiContext context)\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            om.notify(new DocumentDeletedEvent(blankDoc.getDocumentReference()), blankDoc, context);\n        }\n    }\n\n    private void deleteDocument(XWikiDocument doc, boolean totrash, boolean notify, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = null;\n\n        currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(doc.getDocumentReference().getWikiReference().getName());\n\n            XWikiDocument blankDoc = null;\n\n            // Inform notification mechanisms that a document is about to be deleted\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            if (notify) {\n                blankDoc = beforeDelete(doc, context);\n            }\n\n            if (hasRecycleBin(context) && totrash) {\n                // Extract any existing batchId from the context.\n                String batchId = Utils.getComponent(BatchOperationExecutor.class).getCurrentBatchId();\n\n                // Save to recycle bin together with any determined batch ID.\n                getRecycleBinStore().saveToRecycleBin(doc, context.getUser(), new Date(), batchId, context, true);\n            }\n\n            getStore().deleteXWikiDoc(doc, context);\n\n            try {\n                // Inform notification mechanisms that a document has been deleted\n                // Note that for the moment the event being send is a bridge event, as we are still passing around\n                // an XWikiDocument as source and an XWikiContext as data.\n                if (notify) {\n                    afterDelete(blankDoc, context);\n                }\n            } catch (Exception ex) {\n                LOGGER.error(\"Failed to send document delete notifications for document [{}]\",\n                    doc.getDocumentReference(), ex);\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Check if the user is allowed to delete the document.\n     * \n     * @param userReference the user responsible for the delete\n     * @param document the document to delete\n     * @param context the XWiki context\n     * @throws XWikiException when failing to delete\n     * @since 11.6\n     * @since 10.11.10\n     */\n    public void checkDeletingDocument(DocumentReference userReference, XWikiDocument document, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = null;\n\n        currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            XWikiDocument blankDoc = prepareDocumentDelete(document, context);\n\n            ObservationManager om = getObservationManager();\n\n            // Inform notification mechanisms that a document is about to be deleted\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            if (om != null) {\n                CancelableEvent documentEvent =\n                    new UserDeletingDocumentEvent(userReference, document.getDocumentReference());\n                om.notify(documentEvent, blankDoc, context);\n\n                // If the action has been canceled by the user then don't perform any deletion and throw an exception\n                if (documentEvent.isCanceled()) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                        String.format(\"User [%s] has been denied the right to delete the document [%s]. Reason: [%s]\",\n                            userReference, document.getDocumentReference(), documentEvent.getReason()));\n                }\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Delete a range of versions from a document history.\n     * \n     * @param document the document from which to delete versions\n     * @param version1 one end of the versions range to remove\n     * @param version2 the other end of the versions range to remove\n     * @param context the XWiki context\n     * @throws XWikiException\n     * @since 13.6RC1\n     */\n    @Unstable\n    public void deleteDocumentVersions(XWikiDocument document, String version1, String version2, XWikiContext context)\n        throws XWikiException\n    {\n        Version v1 = new Version(version1);\n        Version v2 = new Version(version2);\n\n        // Find the lower and upper bounds\n        Version upperBound = v1;\n        Version lowerBound = v2;\n        if (upperBound.compareVersions(lowerBound) < 0) {\n            Version tmp = upperBound;\n            upperBound = lowerBound;\n            lowerBound = tmp;\n        }\n\n        XWikiDocumentArchive archive = document.getDocumentArchive(context);\n\n        // Remove the versions\n        archive.removeVersions(upperBound, lowerBound, context);\n\n        // Is this the last remaining version? If so, then recycle the document.\n        if (archive.getLatestVersion() == null) {\n            // Wrap the work as a batch operation.\n            BatchOperationExecutor batchOperationExecutor = Utils.getComponent(BatchOperationExecutor.class);\n            batchOperationExecutor.execute(() -> {\n                if (document.getLocale().equals(Locale.ROOT)) {\n                    context.getWiki().deleteAllDocuments(document, context);\n                } else {\n                    // Only delete the translation\n                    context.getWiki().deleteDocument(document, context);\n                }\n            });\n        } else {\n            // Notify before versions delete\n            getObservationManager()\n                .notify(new DocumentVersionRangeDeletingEvent(document.getDocumentReferenceWithLocale(),\n                    lowerBound.toString(), upperBound.toString()), document, context);\n\n            // Update the archive\n            context.getWiki().getVersioningStore().saveXWikiDocArchive(archive, true, context);\n            document.setDocumentArchive(archive);\n\n            // There are still some versions left.\n            // If we delete the most recent (current) version, then rollback to latest undeleted version.\n            Version previousVersion = archive.getLatestVersion();\n            if (!document.getRCSVersion().equals(previousVersion)) {\n                context.getWiki().rollback(document, previousVersion.toString(), false, context);\n            }\n\n            // Notify after versions delete\n            getObservationManager()\n                .notify(new DocumentVersionRangeDeletedEvent(document.getDocumentReferenceWithLocale(),\n                    lowerBound.toString(), upperBound.toString()), document, context);\n        }\n    }\n\n    public String getDatabase()\n    {\n        return this.database;\n    }\n\n    public void setDatabase(String database)\n    {\n        this.database = database;\n    }\n\n    public void gc()\n    {\n        System.gc();\n    }\n\n    public long freeMemory()\n    {\n        return Runtime.getRuntime().freeMemory();\n    }\n\n    public long totalMemory()\n    {\n        return Runtime.getRuntime().totalMemory();\n    }\n\n    public long maxMemory()\n    {\n        return Runtime.getRuntime().maxMemory();\n    }\n\n    public String[] split(String str, String sep)\n    {\n        return StringUtils.split(str, sep);\n    }\n\n    /**\n     * @deprecated use {@link ExceptionUtils#getStackTrace(Throwable)} instead\n     */\n    @Deprecated\n    public String printStrackTrace(Throwable e)\n    {\n        StringWriter strwriter = new StringWriter();\n        PrintWriter writer = new PrintWriter(strwriter);\n        e.printStackTrace(writer);\n\n        return strwriter.toString();\n    }\n\n    /**\n     * API to rename a document to another document.\n     *\n     * @param sourceDocumentReference the source document to rename.\n     * @param targetDocumentReference the target reference to rename the document to.\n     * @param overwrite if {@code true} the target document reference will be overwritten if it exists\n     *                  (deleted to the recycle bin before the rename). If {@code false} and the target document exist\n     *                  the rename won't be performed.\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *                                  modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *                                 document reference\n     * @return {@code true} if the rename succeeded. {@code false} if there was any issue.\n     * @throws XWikiException if the document cannot be renamed properly.\n     * @since 12.5RC1\n     */\n    @Unstable\n    public boolean renameDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean overwrite, List<DocumentReference> backlinkDocumentReferences,\n        List<DocumentReference> childDocumentReferences, XWikiContext context)\n        throws XWikiException\n    {\n        boolean result = false;\n\n        // if source and destination are same, no need to perform the rename.\n        if (!sourceDocumentReference.equals(targetDocumentReference)) {\n            XWikiDocument sourceDocument = this.getDocument(sourceDocumentReference, context);\n            XWikiDocument targetDocument = this.getDocument(targetDocumentReference, context);\n\n            ConfigurationSource xwikiproperties = Utils.getComponent(ConfigurationSource.class, \"xwikiproperties\");\n            boolean useAtomicRename = xwikiproperties.getProperty(\"refactoring.rename.useAtomicRename\", Boolean.TRUE);\n\n            // Proceed on the rename only if the source document exists and if either the targetDoc does not exist or\n            // the overwritten is accepted.\n            if (!sourceDocument.isNew() && (overwrite || targetDocument.isNew())) {\n                if (!useAtomicRename) {\n                    this.renameByCopyAndDelete(sourceDocument, targetDocumentReference, backlinkDocumentReferences,\n                        childDocumentReferences, context);\n                    result = true;\n                } else {\n                    // Ensure that the current context contains the wiki reference of the source document.\n                    WikiReference wikiReference = context.getWikiReference();\n                    context.setWikiReference(sourceDocumentReference.getWikiReference());\n\n                    try {\n                        // rename main document\n                        this.atomicRenameDocument(sourceDocument, targetDocumentReference, context);\n\n                        // handle translations\n                        List<Locale> translationLocales = sourceDocument.getTranslationLocales(context);\n                        for (Locale translationLocale : translationLocales) {\n                            DocumentReference translatedSourceReference =\n                                new DocumentReference(sourceDocumentReference, translationLocale);\n                            DocumentReference translatedTargetReference =\n                                new DocumentReference(targetDocumentReference, translationLocale);\n                            XWikiDocument translatedSourceDoc = this.getDocument(translatedSourceReference, context);\n                            this.atomicRenameDocument(translatedSourceDoc, translatedTargetReference, context);\n                        }\n                    } finally {\n                        context.setWikiReference(wikiReference);\n                    }\n\n                    // Step 4: For each child document, update its parent reference.\n                    // Step 5: For each backlink to rename, parse the backlink document and replace the links with\n                    // the new name.\n                    // Step 6: Refactor the relative links contained in the document to make sure they are relative\n                    // to the new document's location.\n                    this.updateLinksForRename(sourceDocument, targetDocumentReference, backlinkDocumentReferences,\n                        childDocumentReferences, context);\n                    result = true;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private void atomicRenameDocument(XWikiDocument sourceDocument, DocumentReference targetDocumentReference,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 1: Simulate creating a document and deleting a document from listeners point of view\n        // FIXME: currently modifications made by listeners won't be applied\n        XWikiDocument futureTargetDocument = sourceDocument.cloneRename(targetDocumentReference, context);\n        futureTargetDocument.setOriginalDocument(new XWikiDocument(targetDocumentReference));\n        beforeSave(futureTargetDocument, context);\n        XWikiDocument deletedDocument = beforeDelete(sourceDocument, context);\n\n        // Step 2: Perform atomic rename in DB\n        this.getStore().renameXWikiDoc(sourceDocument, targetDocumentReference, context);\n\n        // Step 3: Simulate a created document and a deleted document from listeners point of view\n        afterDelete(deletedDocument, context);\n        afterSave(futureTargetDocument, context);\n    }\n\n    private void updateLinksForRename(XWikiDocument sourceDoc, DocumentReference newDocumentReference,\n        List<DocumentReference> backlinkDocumentReferences, List<DocumentReference> childDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 2: For each child document, update its parent reference.\n        if (childDocumentReferences != null) {\n            for (DocumentReference childDocumentReference : childDocumentReferences) {\n                XWikiDocument childDocument = getDocument(childDocumentReference, context);\n                String compactReference = getCompactEntityReferenceSerializer().serialize(newDocumentReference);\n                childDocument.setParent(compactReference);\n                String saveMessage = localizePlainOrKey(\"core.comment.renameParent\", compactReference);\n                childDocument.setAuthorReference(context.getUserReference());\n                saveDocument(childDocument, saveMessage, true, context);\n            }\n        }\n\n        // Step 3: For each backlink to rename, parse the backlink document and replace the links with the new name.\n        for (DocumentReference backlinkDocumentReference : backlinkDocumentReferences) {\n            XWikiDocument backlinkRootDocument = getDocument(backlinkDocumentReference, context);\n\n            // Update default locale instance\n            renameLinks(backlinkRootDocument, sourceDoc.getDocumentReference(), newDocumentReference, context);\n\n            // Update translations\n            for (Locale locale : backlinkRootDocument.getTranslationLocales(context)) {\n                XWikiDocument backlinkDocument = backlinkRootDocument.getTranslatedDocument(locale, context);\n\n                renameLinks(backlinkDocument, sourceDoc.getDocumentReference(), newDocumentReference, context);\n            }\n        }\n\n        // Get new document\n        XWikiDocument newDocument = getDocument(newDocumentReference, context);\n\n        // Step 4: Refactor the relative links contained in the document to make sure they are relative to the new\n        // document's location.\n        if (Utils.getContextComponentManager().hasComponent(BlockRenderer.class, sourceDoc.getSyntax().toIdString())) {\n            // Only support syntax for which a renderer is provided\n\n            ReferenceRenamer referenceRenamer = Utils.getComponent(ReferenceRenamer.class);\n\n            DocumentReference oldDocumentReference = sourceDoc.getDocumentReference();\n            XDOM newDocumentXDOM = newDocument.getXDOM();\n            boolean modified = referenceRenamer\n                .renameReferences(newDocumentXDOM, newDocumentReference, oldDocumentReference, newDocumentReference,\n                    false);\n\n            // Set the new content and save document if needed\n            if (modified) {\n                newDocument.setContent(newDocumentXDOM);\n                newDocument.setAuthorReference(context.getUserReference());\n                saveDocument(newDocument, context);\n            }\n        }\n    }\n\n    /**\n     * Perform a rename of document by copying the document and deleting the old one.\n     * This operation must be used only in case of document rename from one wiki to another, since it's not supported\n     * by the atomic store operation.\n     *\n     * @param newDocumentReference the new document reference\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *            modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *            document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 12.5\n     * @deprecated Old implementation of the rename by copy and delete. Since 12.5 the implementation using\n     * {@link XWikiStoreInterface#renameXWikiDoc(XWikiDocument, DocumentReference, XWikiContext)} should be preferred.\n     */\n    @Deprecated\n    @Unstable\n    public void renameByCopyAndDelete(XWikiDocument sourceDoc, DocumentReference newDocumentReference,\n        List<DocumentReference> backlinkDocumentReferences, List<DocumentReference> childDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 1: Copy the document and all its translations under a new document with the new reference.\n        copyDocument(sourceDoc.getDocumentReference(), newDocumentReference, false, context);\n\n        // Step 2: For each child document, update its parent reference.\n        // Step 3: For each backlink to rename, parse the backlink document and replace the links with the new name.\n        // Step 4: Refactor the relative links contained in the document to make sure they are relative to the new\n        // document's location.\n        updateLinksForRename(sourceDoc, newDocumentReference, backlinkDocumentReferences, childDocumentReferences,\n            context);\n\n        // Step 5: Delete the old document\n        deleteDocument(sourceDoc, context);\n\n        // Get new document\n        XWikiDocument newDocument = getDocument(newDocumentReference, context);\n\n        // Step 6: The current document needs to point to the renamed document as otherwise it's pointing to an\n        // invalid XWikiDocument object as it's been deleted...\n        sourceDoc.clone(newDocument);\n    }\n\n    /**\n     * Rename links in passed document and save it if needed.\n     */\n    private void renameLinks(XWikiDocument backlinkDocument, DocumentReference oldLink, DocumentReference newLink,\n        XWikiContext context) throws XWikiException\n    {\n        // FIXME: Duplicate code. See org.xwiki.refactoring.internal.DefaultLinkRefactoring#renameLinks in\n        // xwiki-platform-refactoring-default\n        getOldRendering().renameLinks(backlinkDocument, oldLink, newLink, context);\n\n        // Save if content changed\n        if (backlinkDocument.isContentDirty()) {\n            String saveMessage =\n                localizePlainOrKey(\"core.comment.renameLink\", getCompactEntityReferenceSerializer().serialize(newLink));\n            backlinkDocument.setAuthorReference(context.getUserReference());\n            context.getWiki().saveDocument(backlinkDocument, saveMessage, true, context);\n        }\n    }\n\n    /**\n     * Used to convert a Document Reference to string (compact form without the wiki part if it matches the current\n     * wiki).\n     */\n    private static EntityReferenceSerializer<String> getCompactWikiEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n    }\n\n    /**\n     * Used to convert a proper Document Reference to string (compact form).\n     */\n    private static EntityReferenceSerializer<String> getCompactEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compact\");\n    }\n\n    /**\n     * Used to resolve a ResourceReference into a proper Entity Reference using the current document to fill the blanks.\n     */\n    private static EntityReferenceResolver<org.xwiki.rendering.listener.reference.ResourceReference>\n        getResourceReferenceEntityReferenceResolver()\n    {\n        return Utils\n            .getComponent(new DefaultParameterizedType(null, EntityReferenceResolver.class,\n                org.xwiki.rendering.listener.reference.ResourceReference.class));\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, true, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean reset, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, reset, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean reset, boolean force, boolean resetCreationData, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, reset, force, resetCreationData,\n            context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, true, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, false, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, boolean force, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, force, false, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, boolean force, boolean resetCreationData, XWikiContext context)\n        throws XWikiException\n    {\n        String db = context.getWikiId();\n        String sourceWiki = sourceDocumentReference.getWikiReference().getName();\n        String targetWiki = targetDocumentReference.getWikiReference().getName();\n\n        String sourceStringReference = getDefaultEntityReferenceSerializer().serialize(sourceDocumentReference);\n\n        try {\n            context.setWikiId(sourceWiki);\n            XWikiDocument sdoc = getDocument(sourceDocumentReference, context);\n            if (!sdoc.isNew()) {\n                LOGGER.info(\"Copying document [{}] to [{}]\", sourceDocumentReference, targetDocumentReference);\n\n                // Let's switch to the other database to verify if the document already exists\n                context.setWikiId(targetWiki);\n                XWikiDocument previoustdoc = getDocument(targetDocumentReference, context);\n                // There is already an existing document\n                if (!previoustdoc.isNew()) {\n                    if (!force) {\n                        return false;\n                    }\n                }\n\n                // Let's switch back again to the original db\n                context.setWikiId(sourceWiki);\n\n                if (wikilocale == null) {\n                    XWikiDocument tdoc = sdoc.copyDocument(targetDocumentReference, context);\n\n                    // Make sure to replace the existing document if any\n                    tdoc.setNew(true);\n\n                    // forget past versions\n                    if (reset) {\n                        tdoc.setVersion(\"1.1\");\n                    }\n                    if (resetCreationData) {\n                        Date now = new Date();\n                        tdoc.setCreationDate(now);\n                        tdoc.setContentUpdateDate(now);\n                        tdoc.setDate(now);\n                        tdoc.setCreatorReference(context.getUserReference());\n                        tdoc.setAuthorReference(context.getUserReference());\n                    }\n\n                    // We don't want to trigger a new version otherwise the version number will be wrong.\n                    tdoc.setMetaDataDirty(false);\n                    tdoc.setContentDirty(false);\n\n                    saveDocument(tdoc, \"Copied from \" + sourceStringReference, context);\n\n                    if (!reset) {\n                        context.setWikiId(sourceWiki);\n                        XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                        context.setWikiId(targetWiki);\n                        txda = txda.clone(tdoc.getId(), context);\n                        getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                    } else {\n                        context.setWikiId(targetWiki);\n                        getVersioningStore().resetRCSArchive(tdoc, true, context);\n                    }\n\n                    // Now we need to copy the translations\n                    context.setWikiId(sourceWiki);\n                    List<String> tlist = sdoc.getTranslationList(context);\n                    for (String clanguage : tlist) {\n                        XWikiDocument stdoc = sdoc.getTranslatedDocument(clanguage, context);\n                        LOGGER.info(\"Copying document [{}], language [{}] to [{}]\", sourceWiki, clanguage,\n                            targetDocumentReference);\n\n                        context.setWikiId(targetWiki);\n                        XWikiDocument ttdoc = tdoc.getTranslatedDocument(clanguage, context);\n\n                        // There is already an existing document\n                        if (ttdoc != tdoc) {\n                            return false;\n                        }\n\n                        // Let's switch back again to the original db\n                        context.setWikiId(sourceWiki);\n\n                        ttdoc = stdoc.copyDocument(targetDocumentReference, context);\n\n                        // Make sure to replace the existing document if any\n                        ttdoc.setNew(true);\n\n                        // forget past versions\n                        if (reset) {\n                            ttdoc.setNew(true);\n                            ttdoc.setVersion(\"1.1\");\n                        }\n                        if (resetCreationData) {\n                            Date now = new Date();\n                            ttdoc.setCreationDate(now);\n                            ttdoc.setContentUpdateDate(now);\n                            ttdoc.setDate(now);\n                            ttdoc.setCreatorReference(context.getUserReference());\n                            ttdoc.setAuthorReference(context.getUserReference());\n                        }\n\n                        // we don't want to trigger a new version\n                        // otherwise the version number will be wrong\n                        tdoc.setMetaDataDirty(false);\n                        tdoc.setContentDirty(false);\n\n                        saveDocument(ttdoc, \"Copied from \" + sourceStringReference, context);\n\n                        if (!reset) {\n                            context.setWikiId(sourceWiki);\n                            XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                            context.setWikiId(targetWiki);\n                            txda = txda.clone(tdoc.getId(), context);\n                            getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                        } else {\n                            getVersioningStore().resetRCSArchive(tdoc, true, context);\n                        }\n                    }\n                } else {\n                    // We want only one language in the end\n                    XWikiDocument stdoc = sdoc.getTranslatedDocument(wikilocale, context);\n\n                    XWikiDocument tdoc = stdoc.copyDocument(targetDocumentReference, context);\n\n                    // Make sure to replace the existing document if any\n                    tdoc.setNew(true);\n\n                    // forget language\n                    tdoc.setDefaultLanguage(wikilocale);\n                    tdoc.setLanguage(\"\");\n                    // forget past versions\n                    if (reset) {\n                        tdoc.setVersion(\"1.1\");\n                    }\n                    if (resetCreationData) {\n                        Date now = new Date();\n                        tdoc.setCreationDate(now);\n                        tdoc.setContentUpdateDate(now);\n                        tdoc.setDate(now);\n                        tdoc.setCreatorReference(context.getUserReference());\n                        tdoc.setAuthorReference(context.getUserReference());\n                    }\n\n                    // we don't want to trigger a new version\n                    // otherwise the version number will be wrong\n                    tdoc.setMetaDataDirty(false);\n                    tdoc.setContentDirty(false);\n\n                    saveDocument(tdoc, \"Copied from \" + sourceStringReference, context);\n\n                    if (!reset) {\n                        context.setWikiId(sourceWiki);\n                        XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                        context.setWikiId(targetWiki);\n                        txda = txda.clone(tdoc.getId(), context);\n                        getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                    } else {\n                        getVersioningStore().resetRCSArchive(tdoc, true, context);\n                    }\n                }\n            }\n            return true;\n        } finally {\n            context.setWikiId(db);\n        }\n    }\n\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale,\n        XWikiContext context) throws XWikiException\n    {\n        return copySpaceBetweenWikis(space, sourceWiki, targetWiki, locale, false, context);\n    }\n\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale, boolean clean,\n        XWikiContext context) throws XWikiException\n    {\n        String db = context.getWikiId();\n        int nb = 0;\n        // Workaround for XWIKI-3915: Do not use XWikiStoreInterface#searchDocumentNames since currently it has the\n        // side effect of hidding hidden documents and no other workaround exists than directly using\n        // XWikiStoreInterface#search directly\n        String sql = \"select distinct doc.fullName from XWikiDocument as doc\";\n        List<String> parameters = new ArrayList<>();\n        if (space != null) {\n            parameters.add(space);\n            sql += \" where doc.space = ?\" + parameters.size();\n        }\n\n        if (clean) {\n            try {\n                context.setWikiId(targetWiki);\n                List<String> list = getStore().search(sql, 0, 0, parameters, context);\n\n                LOGGER.info(\"Deleting [{}] documents from wiki [{}]\", list.size(), targetWiki);\n\n                for (String docname : list) {\n                    XWikiDocument doc = getDocument(docname, context);\n                    deleteDocument(doc, context);\n                }\n            } finally {\n                context.setWikiId(db);\n            }\n        }\n\n        try {\n            context.setWikiId(sourceWiki);\n            List<String> list = getStore().search(sql, 0, 0, parameters, context);\n\n            LOGGER.info(\"Copying [{}] documents from wiki [{}] to wiki [{}]\", list.size(), sourceWiki, targetWiki);\n\n            WikiReference sourceWikiReference = new WikiReference(sourceWiki);\n            WikiReference targetWikiReference = new WikiReference(targetWiki);\n            for (String docname : list) {\n                DocumentReference sourceDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);\n                sourceDocumentReference = sourceDocumentReference\n                    .replaceParent(sourceDocumentReference.getWikiReference(), sourceWikiReference);\n                DocumentReference targetDocumentReference =\n                    sourceDocumentReference.replaceParent(sourceWikiReference, targetWikiReference);\n                copyDocument(sourceDocumentReference, targetDocumentReference, locale, context);\n                nb++;\n            }\n            return nb;\n        } finally {\n            context.setWikiId(db);\n        }\n    }\n\n    /**\n     * Copy an entire wiki to a target wiki.\n     * <p>\n     * It does not override document already existing in target wiki.\n     *\n     * @param sourceWiki the source wiki identifier\n     * @param targetWiki the target wiki identifier\n     * @param locale the locale to copy\n     * @param context see {@link XWikiContext}\n     * @return the number of copied documents\n     * @throws XWikiException failed to copy wiki\n     * @deprecated since 5.3, use {@link WikiManager#copy(String, String, String, boolean, boolean, boolean)} instead\n     */\n    @Deprecated\n    public int copyWiki(String sourceWiki, String targetWiki, String locale, XWikiContext context) throws XWikiException\n    {\n        return copyWiki(sourceWiki, targetWiki, locale, false, context);\n    }\n\n    /**\n     * Copy an entire wiki to a target wiki.\n     *\n     * @param sourceWiki the source wiki identifier\n     * @param targetWiki the target wiki identifier\n     * @param locale the locale to copy\n     * @param clean clean the target wiki before copying\n     * @param context see {@link XWikiContext}\n     * @return the number of copied documents\n     * @throws XWikiException failed to copy wiki\n     * @deprecated since 5.3, use {@link WikiManager#copy(String, String, String, boolean, boolean, boolean)} instead\n     */\n    @Deprecated\n    public int copyWiki(String sourceWiki, String targetWiki, String locale, boolean clean, XWikiContext context)\n        throws XWikiException\n    {\n        int documents = copySpaceBetweenWikis(null, sourceWiki, targetWiki, locale, clean, context);\n\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            om.notify(new WikiCopiedEvent(sourceWiki, targetWiki), sourceWiki, context);\n        }\n\n        return documents;\n    }\n\n    public String getEncoding()\n    {\n        return getConfiguration().getProperty(\"xwiki.encoding\", \"UTF-8\");\n    }\n\n    public URL getServerURL(String wikiId, XWikiContext xcontext) throws MalformedURLException\n    {\n        // In path based the base URL is the same for all wikis\n        if (!xcontext.isMainWiki(wikiId) && isPathBased()) {\n            return getServerURL(xcontext.getMainXWiki(), xcontext);\n        }\n\n        // If main wiki check the main wiki home page configuration\n        if (xcontext.isMainWiki(wikiId)) {\n            String homepage = getConfiguration().getProperty(\"xwiki.home\");\n            if (StringUtils.isNotEmpty(homepage)) {\n                try {\n                    return new URL(homepage);\n                } catch (MalformedURLException e) {\n                    LOGGER.warn(\"Invalid main wiki home page URL [{}] configured: {}\", homepage,\n                        ExceptionUtils.getRootCauseMessage(e));\n                }\n            }\n        }\n\n        if (wikiId != null) {\n            try {\n                WikiDescriptor wikiDescriptor = getWikiDescriptorManager().getById(wikiId);\n                if (wikiDescriptor != null) {\n                    String server = wikiDescriptor.getDefaultAlias();\n                    if (server != null) {\n                        String protocol = getWikiProtocol(wikiDescriptor);\n                        int port = getWikiPort(wikiDescriptor, xcontext);\n\n                        if (protocol == null && port == -1) {\n                            // If request is a \"real\" one keep using the same protocol/port (if asking for the same wiki)\n                            XWikiRequest request = xcontext.getRequest();\n                            if (request != null && wikiDescriptor.getId().equals(xcontext.getOriginalWikiId())\n                                && !isDaemon(request)) {\n                                URL sourceURL = HttpServletUtils.getSourceBaseURL(xcontext.getRequest());\n\n                                protocol = sourceURL.getProtocol();\n                                port = sourceURL.getPort();\n                            } else {\n                                // Default to HTTP\n                                protocol = \"http\";\n                            }\n                        }\n\n                        return new URL(protocol != null ? protocol : (port == 443 ? \"https\" : \"http\"), server, port,\n                            \"\");\n                    }\n                }\n            } catch (WikiManagerException e) {\n                LOGGER.error(\"Failed to get descriptor for wiki [{}]\", wikiId, e);\n            }\n        }\n\n        return null;\n    }\n\n    private boolean isDaemon(XWikiRequest request)\n    {\n        return request.getHttpServletRequest() instanceof XWikiServletRequestStub\n            && ((XWikiServletRequestStub) request.getHttpServletRequest()).isDaemon();\n    }\n\n    private String getWikiProtocol(WikiDescriptor wikiDescriptor)\n    {\n        // Try wiki descriptor\n        Boolean secure = wikiDescriptor.isSecure();\n        if (secure != null) {\n            return wikiDescriptor.isSecure() == Boolean.TRUE ? \"https\" : \"http\";\n        }\n\n        // Try configuration\n        String protocol = getConfiguration().getProperty(\"xwiki.url.protocol\");\n        if (protocol != null) {\n            return protocol;\n        }\n\n        // Try main wiki\n        try {\n            secure = getWikiDescriptorManager().getMainWikiDescriptor().isSecure();\n\n            if (secure != null) {\n                return secure ? \"https\" : \"http\";\n            }\n        } catch (WikiManagerException e) {\n            LOGGER.error(\"Failed to get main wiki descriptor\", e);\n        }\n\n        return null;\n    }\n\n    private int getWikiPort(WikiDescriptor wikiDescriptor, XWikiContext context)\n    {\n        // Try wiki descriptor\n        int port = wikiDescriptor.getPort();\n        if (port != -1) {\n            return port;\n        }\n\n        // Try main wiki\n        try {\n            port = getWikiDescriptorManager().getMainWikiDescriptor().getPort();\n\n            if (port != -1) {\n                return port;\n            }\n        } catch (WikiManagerException e) {\n            LOGGER.error(\"Failed to get main wiki descriptor\", e);\n        }\n\n        return -1;\n    }\n\n    public String getServletPath(String wikiName, XWikiContext context)\n    {\n        // unless we are in virtual wiki path mode we should return null\n        if (!context.isMainWiki(wikiName) && isPathBased()) {\n            try {\n                WikiDescriptor wikiDescriptor = getWikiDescriptorManager().getById(wikiName);\n                if (wikiDescriptor != null) {\n                    return \"wiki/\" + wikiDescriptor.getDefaultAlias() + \"/\";\n                }\n            } catch (Exception e) {\n                LOGGER.error(\"Failed to get URL for provided wiki [\" + wikiName + \"]\", e);\n            }\n        }\n\n        String servletPath = getConfiguration().getProperty(\"xwiki.servletpath\", \"\");\n\n        if (context.getRequest() != null) {\n            if (StringUtils.isEmpty(servletPath)) {\n                String currentServletpath = context.getRequest().getServletPath();\n                if (currentServletpath != null && currentServletpath.startsWith(\"/bin\")) {\n                    servletPath = \"bin/\";\n                } else {\n                    servletPath = getConfiguration().getProperty(\"xwiki.defaultservletpath\", \"bin/\");\n                }\n            }\n        }\n\n        return servletPath;\n    }\n\n    public String getWebAppPath(XWikiContext context)\n    {\n        String contextPath = getConfiguration().getProperty(\"xwiki.webapppath\");\n        if (contextPath == null) {\n            // Try getting the context path by asking the request for it (if a request exists!) and if it doesn't\n            // work try extracting it from the context URL.\n            // TODO: Instead of trying to extract from the URL, save the context path at webapp init (using a\n            // ServlettContextListener for example).\n            XWikiRequest request = context.getRequest();\n            if (request != null) {\n                contextPath = request.getContextPath();\n            }\n            if (contextPath == null) {\n                // Extract the context by getting the first path segment\n                contextPath = StringUtils.substringBefore(StringUtils.stripStart(context.getURL().getPath(), \"/\"), \"/\");\n            }\n        }\n\n        // Remove any leading or trailing slashes\n        contextPath = StringUtils.strip(contextPath, \"/\");\n\n        // TODO We're using URL parts in a wrong way, since contextPath and servletPath are returned with a leading /,\n        // while we need a trailing /. This code ensure we always have CONTEXTNAME + \"/\".\n        return contextPath + \"/\";\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference entityReference, String action, String queryString, String anchor,\n        XWikiContext context)\n    {\n        // TODO: replace this API with a clean implementation of EntityResourceReferenceSerializer\n\n        // Handle attachment URL\n        if (EntityType.ATTACHMENT.equals(entityReference.getType())) {\n            // Get the full attachment reference\n            AttachmentReference attachmentReference = getCurrentAttachmentResolver().resolve(entityReference);\n            return getAttachmentURL(attachmentReference, action, queryString, context);\n        }\n\n        // For all other types, we return the URL of the default corresponding document.\n        DocumentReference documentReference = getDocumentReference(entityReference, context);\n        return getURL(documentReference, action, queryString, anchor, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference reference, String action, XWikiContext context)\n    {\n        return getURL(reference, action, null, null, context);\n    }\n\n    /**\n     * @since 7.2RC1\n     */\n    public String getURL(EntityReference reference, XWikiContext context)\n    {\n        String action = \"view\";\n        if (reference.getType() == EntityType.ATTACHMENT) {\n            action = \"download\";\n        }\n        return getURL(reference, action, context);\n    }\n\n    /**\n     * @since 2.2.1\n     */\n    public String getURL(DocumentReference documentReference, String action, String queryString, String anchor,\n        XWikiContext context)\n    {\n        // We need to serialize the space reference because the old createURL() API doesn't accept a DocumentReference.\n        String spaces = getLocalStringEntityReferenceSerializer().serialize(documentReference.getLastSpaceReference());\n\n        // Take into account the specified document locale.\n        Locale documentLocale = documentReference.getLocale();\n        String actualQueryString = queryString;\n        if (documentLocale != null && documentLocale != Locale.ROOT) {\n            String localeQueryString = \"language=\" + documentLocale;\n            if (StringUtils.isEmpty(queryString)) {\n                actualQueryString = localeQueryString;\n            } else {\n                // Note: if the locale is already specified on the given query string then it won't be overwriten\n                // because the first parameter value is taken into account.\n                actualQueryString += '&' + localeQueryString;\n            }\n        }\n\n        URL url = context.getURLFactory().createURL(spaces, documentReference.getName(), action, actualQueryString,\n            anchor, documentReference.getWikiReference().getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    /**\n     * @deprecated since 2.2.1 use {@link #getURL(DocumentReference, String, String, String, XWikiContext)}\n     */\n    @Deprecated\n    public String getURL(String fullname, String action, String queryString, String anchor, XWikiContext context)\n    {\n        return getURL(getCurrentMixedDocumentReferenceResolver().resolve(fullname), action, queryString, anchor,\n            context);\n    }\n\n    public String getURL(String fullname, String action, String querystring, XWikiContext context)\n    {\n        return getURL(fullname, action, querystring, null, context);\n    }\n\n    /**\n     * @since 2.3M2\n     */\n    public String getURL(DocumentReference reference, String action, XWikiContext context)\n    {\n        return getURL(reference, action, null, null, context);\n    }\n\n    /**\n     * @deprecated since 2.3M2 use {@link #getURL(DocumentReference, String, XWikiContext)}\n     */\n    @Deprecated\n    public String getURL(String fullname, String action, XWikiContext context)\n    {\n        return getURL(fullname, action, null, null, context);\n    }\n\n    public String getExternalURL(String fullname, String action, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        URL url = context.getURLFactory().createExternalURL(doc.getSpace(), doc.getName(), action, null, null,\n            doc.getDatabase(), context);\n        return url.toString();\n    }\n\n    public String getExternalURL(String fullname, String action, String querystring, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        URL url = context.getURLFactory().createExternalURL(doc.getSpace(), doc.getName(), action, querystring, null,\n            doc.getDatabase(), context);\n        return url.toString();\n    }\n\n    /**\n     * Get the full URL of the given {@link DocumentReference}. This also includes the server name of the wiki.\n     *\n     * @param documentReference the document that should be resolved\n     * @param action the action of the URL\n     * @param querystring the URL parameters\n     * @param anchor the anchor of the document\n     * @param context the current XWikiContext\n     * @return the full URL of the given reference\n     * @since 9.6RC1\n     */\n    public String getExternalURL(DocumentReference documentReference, String action, String querystring, String anchor,\n        XWikiContext context)\n    {\n        URL url = context.getURLFactory().createExternalURL(\n            this.getLocalStringEntityReferenceSerializer().serialize(documentReference.getLastSpaceReference()),\n            documentReference.getName(), action, querystring, anchor, documentReference.getWikiReference().getName(),\n            context);\n        return url.toString();\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentURL(AttachmentReference attachmentReference, String action, String queryString,\n        XWikiContext context)\n    {\n        DocumentReference documentReference = attachmentReference.getDocumentReference();\n        SpaceReference spaceReference = documentReference.getLastSpaceReference();\n        WikiReference wikiReference = spaceReference.getWikiReference();\n\n        // We need to serialize the space reference because the old URLFactory has no method to create an Attachment URL\n        // from an AttachmentReference...\n        String serializedSpace = getLocalStringEntityReferenceSerializer().serialize(spaceReference);\n\n        URL url = context.getURLFactory().createAttachmentURL(attachmentReference.getName(), serializedSpace,\n            documentReference.getName(), action, queryString, wikiReference.getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentURL(AttachmentReference attachmentReference, String queryString, XWikiContext context)\n    {\n        return getAttachmentURL(attachmentReference, \"download\", queryString, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentRevisionURL(AttachmentReference attachmentReference, String revision, String queryString,\n        XWikiContext context)\n    {\n        DocumentReference documentReference = attachmentReference.getDocumentReference();\n        SpaceReference spaceReference = documentReference.getLastSpaceReference();\n        WikiReference wikiReference = spaceReference.getWikiReference();\n\n        // We need to serialize the space reference because the old URLFactory has no method to create an Attachment URL\n        // from an AttachmentReference...\n        String serializedSpace = getLocalStringEntityReferenceSerializer().serialize(spaceReference);\n\n        URL url = context.getURLFactory().createAttachmentRevisionURL(attachmentReference.getName(), serializedSpace,\n            documentReference.getName(), revision, queryString, wikiReference.getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public String getAttachmentURL(String fullname, String filename, XWikiContext context) throws XWikiException\n    {\n        return getAttachmentURL(fullname, filename, null, context);\n    }\n\n    /**\n     * @since 2.5RC1\n     */\n    public String getAttachmentURL(String fullname, String filename, String queryString, XWikiContext context)\n        throws XWikiException\n    {\n        AttachmentReference attachmentReference =\n            new AttachmentReference(filename, getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        return getAttachmentURL(attachmentReference, queryString, context);\n    }\n\n    // Usefull date functions\n\n    public int getTimeDelta(long time)\n    {\n        Date ctime = new Date();\n        return (int) (ctime.getTime() - time);\n    }\n\n    public boolean isMultiLingual(XWikiContext context)\n    {\n        return \"1\".equals(getXWikiPreference(\"multilingual\", \"0\", context));\n    }\n\n    public boolean isLDAP()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.ldap\"));\n    }\n\n    /**\n     * @return true if XWikiAllGroup group should be seen as virtual group containing all users, false to use it as any\n     *         other group\n     * @since 9.3RC1\n     */\n    public boolean isAllGroupImplicit()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.group.allgroupimplicit\"));\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link XWikiUser#isDisabled(XWikiContext)}.\n     */\n    @Deprecated\n    public int checkActive(XWikiContext context) throws XWikiException\n    {\n        return checkActive(context.getUser(), context);\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link XWikiUser#isDisabled(XWikiContext)}.\n     */\n    @Deprecated\n    public int checkActive(String user, XWikiContext context) throws XWikiException\n    {\n        XWikiUser xWikiUser = new XWikiUser(user);\n        return xWikiUser.isDisabled(context) ? 0 : 1;\n    }\n\n    /**\n     * @since 2.3M1\n     */\n    public DocumentReference getDocumentReference(XWikiRequest request, XWikiContext context)\n    {\n        DocumentReference reference;\n        if (context.getMode() == XWikiContext.MODE_PORTLET) {\n            if (request.getParameter(\"topic\") != null) {\n                reference = getCurrentMixedDocumentReferenceResolver().resolve(request.getParameter(\"topic\"));\n            } else {\n                // Point to this wiki's home page\n                reference = getDefaultDocumentReference().setWikiReference(new WikiReference(context.getWikiId()));\n            }\n        } else if (context.getMode() == XWikiContext.MODE_XMLRPC) {\n            reference = new DocumentReference(context.getWikiId(),\n                context.getDoc().getDocumentReference().getLastSpaceReference().getName(),\n                context.getDoc().getDocumentReference().getName());\n        } else {\n            ResourceReference resourceReference = getResourceReferenceManager().getResourceReference();\n            if (resourceReference instanceof EntityResourceReference) {\n                EntityResourceReference entityResource = (EntityResourceReference) resourceReference;\n                String action = entityResource.getAction().getActionName();\n                if ((request.getParameter(\"topic\") != null) && (action.equals(\"edit\") || action.equals(\"inline\"))) {\n                    reference = getCurrentMixedDocumentReferenceResolver().resolve(request.getParameter(\"topic\"));\n                } else {\n                    reference = new DocumentReference(\n                        entityResource.getEntityReference().extractReference(EntityType.DOCUMENT));\n                }\n            } else {\n                // TODO: Handle references not pointing to a document...\n                // Big problem we don't have an Entity URL!\n                throw new RuntimeException(\n                    String.format(\"Resource Reference [%s] isn't an Entity Resource Reference!\", resourceReference));\n            }\n        }\n\n        return reference;\n    }\n\n    /**\n     * Helper method, removes a predefined path segment (the context path or the servel path) from the start of the\n     * requested URI and returns the remainder. This method is needed because special characters in the path can be\n     * URL-encoded, depending on whether the request is forwarded through the request dispatcher or not, and also\n     * depending on the client (some browsers encode -, while some don't).\n     *\n     * @param path the path, as taken from the requested URI\n     * @param segment the segment to remove, as reported by the container\n     * @return the path with the specified segment trimmed from its start\n     */\n    public static String stripSegmentFromPath(String path, String segment)\n    {\n        if (!path.startsWith(segment)) {\n            // The context path probably contains special characters that are encoded in the URL\n            try {\n                segment = URIUtil.encodePath(segment);\n            } catch (URIException e) {\n                LOGGER.warn(\"Invalid path: [\" + segment + \"]\");\n            }\n        }\n        if (!path.startsWith(segment)) {\n            // Some clients also encode -, although it's allowed in the path\n            segment = segment.replaceAll(\"-\", \"%2D\");\n        }\n        if (!path.startsWith(segment)) {\n            // Can't find the context path in the URL (shouldn't happen), just skip to the next path segment\n            return path.substring(path.indexOf('/', 1));\n        }\n        return path.substring(segment.length());\n    }\n\n    public boolean prepareDocuments(XWikiRequest request, XWikiContext context, VelocityContext vcontext)\n        throws XWikiException\n    {\n        XWikiDocument doc;\n        context.getWiki().prepareResources(context);\n        DocumentReference reference = getDocumentReference(request, context);\n        if (context.getAction().equals(\"register\")) {\n            setPhonyDocument(reference, context, vcontext);\n            doc = context.getDoc();\n        } else {\n            try {\n                doc = getDocument(reference, context);\n            } catch (XWikiException e) {\n                doc = context.getDoc();\n                if (context.getAction().equals(\"delete\")) {\n                    if (doc == null) {\n                        setPhonyDocument(reference, context, vcontext);\n                        doc = context.getDoc();\n                    }\n                    if (!checkAccess(\"admin\", doc, context)) {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // the user is set after the access is checked.\n        boolean hasAccess = checkAccess(context.getAction(), doc, context);\n\n        XWikiUser user;\n        if (context.getUserReference() != null) {\n            user = new XWikiUser(context.getUserReference());\n        } else {\n            user = new XWikiUser(context.getUser());\n        }\n\n        // We need to check rights before we look for translations\n        // Otherwise we don't have the user language\n        if (!hasAccess) {\n            Object[] args = { doc.getFullName(), user.getUser() };\n            setPhonyDocument(reference, context, vcontext);\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access to document {0} has been denied to user {1}\", null, args);\n        // User is disabled: the mail address is marked as checked\n        } else if (user.isDisabled(context) && user.isEmailChecked(context)) {\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if (!((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\"))))) {\n                Object[] args = { user.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_DISABLED,\n                    \"User {0} account is disabled\", null, args);\n            }\n        // User actually needs to activate his mail address.\n        } else if (user.isDisabled(context) && !user.isEmailChecked(context)) {\n            boolean allow = false;\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if ((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\")))) {\n                allow = true;\n            } else {\n                String allowed = getConfiguration().getProperty(\"xwiki.inactiveuser.allowedpages\", \"\");\n                if (context.getAction().equals(\"view\") && !allowed.equals(\"\")) {\n                    String[] allowedList = StringUtils.split(allowed, \" ,\");\n                    for (String element : allowedList) {\n                        if (element.equals(doc.getFullName())) {\n                            allow = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!allow) {\n                Object[] args = { context.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_INACTIVE,\n                    \"User {0} account is inactive\", null, args);\n            }\n        }\n\n        context.put(\"doc\", doc);\n        context.put(\"cdoc\", doc);\n        vcontext.put(\"doc\", doc.newDocument(context));\n        vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n        XWikiDocument tdoc;\n\n        // If the parameter language exists and is empty, it means we want to force loading the regular document\n        // not a translation. This should be handled later by doing a better separation between locale used in the UI\n        // and for loading the documents.\n        if (\"\".equals(context.getRequest().getParameter(\"language\"))) {\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(context);\n        }\n\n        try {\n            String rev = (String) context.get(\"rev\");\n            if (StringUtils.isNotEmpty(rev)) {\n                tdoc = getDocument(tdoc, rev, context);\n            }\n        } catch (Exception ex) {\n            // Invalid version, just use the most recent one\n        }\n        context.put(\"tdoc\", tdoc);\n        vcontext.put(\"tdoc\", tdoc.newDocument(context));\n\n        return true;\n    }\n\n    /**\n     * @since 8.3M1\n     */\n    public void setPhonyDocument(DocumentReference reference, XWikiContext context)\n    {\n        XWikiDocument doc = new XWikiDocument(reference);\n        doc.setElements(XWikiDocument.HAS_ATTACHMENTS | XWikiDocument.HAS_OBJECTS);\n        doc.setStore(getStore());\n        context.put(\"doc\", doc);\n    }\n\n    /**\n     * @since 2.3M1\n     * @deprecated since 8.3M1, use {@link #setPhonyDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public void setPhonyDocument(DocumentReference reference, XWikiContext context, VelocityContext vcontext)\n    {\n        setPhonyDocument(reference, context);\n\n        vcontext.put(\"doc\", context.getDoc().newDocument(context));\n        vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n        vcontext.put(\"tdoc\", vcontext.get(\"doc\"));\n    }\n\n    /**\n     * @deprecated since 2.3M1 use {@link #setPhonyDocument(DocumentReference, XWikiContext, VelocityContext)}\n     */\n    @Deprecated\n    public void setPhonyDocument(String docName, XWikiContext context, VelocityContext vcontext)\n    {\n        setPhonyDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName), context, vcontext);\n    }\n\n    public XWikiEngineContext getEngineContext()\n    {\n        return this.engine_context;\n    }\n\n    public void setEngineContext(XWikiEngineContext engine_context)\n    {\n        this.engine_context = engine_context;\n    }\n\n    public void setAuthService(XWikiAuthService authService)\n    {\n        this.authService = authService;\n    }\n\n    public void setRightService(XWikiRightService rightService)\n    {\n        this.rightService = rightService;\n    }\n\n    public XWikiGroupService getGroupService(XWikiContext context) throws XWikiException\n    {\n        synchronized (this.GROUP_SERVICE_LOCK) {\n            if (this.groupService == null) {\n                String groupClass = getConfiguration().getProperty(\"xwiki.authentication.groupclass\",\n                    \"com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl\");\n\n                try {\n                    this.groupService = (XWikiGroupService) Class.forName(groupClass).newInstance();\n                } catch (Exception e) {\n                    LOGGER.error(\"Failed to instantiate custom group service class: \" + e.getMessage(), e);\n                    this.groupService = new XWikiGroupServiceImpl();\n                }\n                this.groupService.init(this, context);\n            }\n\n            return this.groupService;\n        }\n    }\n\n    public void setGroupService(XWikiGroupService groupService)\n    {\n        this.groupService = groupService;\n    }\n\n    private Class<? extends XWikiAuthService> getAuthServiceClass() throws ClassNotFoundException\n    {\n        String authClass = getConfiguration().getProperty(\"xwiki.authentication.authclass\");\n        if (StringUtils.isEmpty(authClass)) {\n            if (isLDAP()) {\n                authClass = \"com.xpn.xwiki.user.impl.LDAP.XWikiLDAPAuthServiceImpl\";\n            } else {\n                authClass = \"com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl\";\n            }\n        }\n\n        // Get main wiki ClassLoader\n        ClassLoaderManager clManager = Utils.getComponent(ClassLoaderManager.class);\n        ClassLoader classloader = null;\n        if (clManager != null) {\n            classloader = clManager.getURLClassLoader(\"wiki:xwiki\", false);\n        }\n\n        // Get the class\n        if (classloader != null) {\n            return (Class<? extends XWikiAuthService>) Class.forName(authClass, true, classloader);\n        } else {\n            return (Class<? extends XWikiAuthService>) Class.forName(authClass);\n        }\n    }\n\n    public XWikiAuthService getAuthService()\n    {\n        synchronized (this.AUTH_SERVICE_LOCK) {\n            if (this.authService == null) {\n                LOGGER.info(\"Initializing AuthService...\");\n\n                try {\n                    Class<? extends XWikiAuthService> authClass = getAuthServiceClass();\n\n                    setAuthService(authClass);\n                } catch (Exception e) {\n                    LOGGER.warn(\"Failed to get the configured AuthService class, fallbacking on standard authenticator\",\n                        e);\n\n                    this.authService = new XWikiAuthServiceImpl();\n\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Initialized AuthService {} using 'new'.\", this.authService.getClass().getName());\n                    }\n                }\n            }\n\n            return this.authService;\n        }\n    }\n\n    private void setAuthService(Class<? extends XWikiAuthService> authClass)\n    {\n        try {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Using AuthClass {}\", authClass.getName());\n            }\n\n            this.authService = authClass.newInstance();\n\n            LOGGER.debug(\"Initialized AuthService using Reflection.\");\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to initialize the AuthService from class [{}], fallbacking on standard authenticator\",\n                authClass.getName(), e);\n\n            this.authService = new XWikiAuthServiceImpl();\n\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Initialized AuthService {} using 'new'.\", this.authService.getClass().getName());\n            }\n        }\n    }\n\n    private static final String DEFAULT_RIGHT_SERVICE_CLASS =\n        \"org.xwiki.security.authorization.internal.XWikiCachingRightService\";\n\n    public XWikiRightService getRightService()\n    {\n        synchronized (this.RIGHT_SERVICE_LOCK) {\n            if (this.rightService == null) {\n                LOGGER.info(\"Initializing RightService...\");\n\n                String rightsClass = getConfiguration().getProperty(\"xwiki.authentication.rightsclass\");\n                if (rightsClass != null && !rightsClass.equals(DEFAULT_RIGHT_SERVICE_CLASS)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.warn(\"Using custom Right Service [{}].\", rightsClass);\n                    }\n                } else {\n                    rightsClass = DEFAULT_RIGHT_SERVICE_CLASS;\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Using default Right Service [{}].\", rightsClass);\n                    }\n                }\n\n                try {\n                    this.rightService = (XWikiRightService) Class.forName(rightsClass).newInstance();\n                    LOGGER.debug(\"Initialized RightService using Reflection.\");\n                } catch (Exception e) {\n                    Exception lastException = e;\n\n                    if (!rightsClass.equals(DEFAULT_RIGHT_SERVICE_CLASS)) {\n                        LOGGER.warn(String.format(\n                            \"Failed to initialize custom RightService [%s]\"\n                                + \" by Reflection, using default implementation [%s].\",\n                            rightsClass, DEFAULT_RIGHT_SERVICE_CLASS), e);\n                        rightsClass = DEFAULT_RIGHT_SERVICE_CLASS;\n                        try {\n                            this.rightService = (XWikiRightService) Class.forName(rightsClass).newInstance();\n                            LOGGER.debug(\"Initialized default RightService using Reflection.\");\n                        } catch (Exception e1) {\n                            lastException = e1;\n                        }\n                    }\n\n                    if (this.rightService == null) {\n                        LOGGER.warn(String.format(\n                            \"Failed to initialize RightService [%s]\"\n                                + \" by Reflection, using OLD implementation [%s] with 'new'.\",\n                            rightsClass, XWikiRightServiceImpl.class.getCanonicalName()), lastException);\n\n                        this.rightService = new XWikiRightServiceImpl();\n\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"Initialized old RightService implementation \"\n                                + this.rightService.getClass().getName() + \" using 'new'.\");\n                        }\n                    }\n                }\n            }\n            return this.rightService;\n        }\n    }\n\n    public XWikiStatsService getStatsService(XWikiContext context)\n    {\n        synchronized (this.STATS_SERVICE_LOCK) {\n            if (this.statsService == null) {\n                if (\"1\".equals(getConfiguration().getProperty(\"xwiki.stats\", \"1\"))) {\n                    String storeClass = getConfiguration().getProperty(\"xwiki.stats.class\",\n                        \"com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl\");\n                    try {\n                        this.statsService = (XWikiStatsService) Class.forName(storeClass).newInstance();\n                    } catch (Exception e) {\n                        LOGGER.error(e.getMessage(), e);\n\n                        this.statsService = new XWikiStatsServiceImpl();\n                    }\n\n                    this.statsService.init(context);\n                }\n            }\n\n            return this.statsService;\n        }\n    }\n\n    public XWikiURLFactoryService getURLFactoryService()\n    {\n        if (this.urlFactoryService == null) {\n            synchronized (this.URLFACTORY_SERVICE_LOCK) {\n                if (this.urlFactoryService == null) {\n                    LOGGER.info(\"Initializing URLFactory Service...\");\n\n                    XWikiURLFactoryService factoryService = null;\n\n                    String urlFactoryServiceClass = getConfiguration().getProperty(\"xwiki.urlfactory.serviceclass\");\n                    if (urlFactoryServiceClass != null) {\n                        try {\n                            if (LOGGER.isDebugEnabled()) {\n                                LOGGER.debug(\"Using custom URLFactory Service Class [\" + urlFactoryServiceClass + \"]\");\n                            }\n                            factoryService = (XWikiURLFactoryService) Class.forName(urlFactoryServiceClass)\n                                .getConstructor(new Class<?>[] { XWiki.class }).newInstance(new Object[] { this });\n                        } catch (Exception e) {\n                            factoryService = null;\n                            LOGGER.warn(\"Failed to initialize URLFactory Service [\" + urlFactoryServiceClass + \"]\", e);\n                        }\n                    }\n                    if (factoryService == null) {\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"Using default URLFactory Service Class [\" + urlFactoryServiceClass + \"]\");\n                        }\n                        factoryService = new XWikiURLFactoryServiceImpl(this);\n                    }\n\n                    // Set the urlFactoryService object in one assignment to prevent threading\n                    // issues when checking for\n                    // null above.\n                    this.urlFactoryService = factoryService;\n                }\n            }\n        }\n\n        return this.urlFactoryService;\n    }\n\n    public XWikiCriteriaService getCriteriaService(XWikiContext context)\n    {\n        return this.criteriaService;\n    }\n\n    public ZipOutputStream getZipOutputStream(XWikiContext context) throws IOException\n    {\n        return new ZipOutputStream(context.getResponse().getOutputStream());\n    }\n\n    private Map<String, SearchEngineRule> getSearchEngineRules(XWikiContext context)\n    {\n        // We currently hardcode the rules\n        // We will put them in the preferences soon\n        Map<String, SearchEngineRule> map = new HashMap<String, SearchEngineRule>();\n        map.put(\"Google\", new SearchEngineRule(\"google.\", \"s/(^|.*&)q=(.*?)(&.*|$)/$2/\"));\n        map.put(\"MSN\", new SearchEngineRule(\"search.msn.\", \"s/(^|.*&)q=(.*?)(&.*|$)/$2/\"));\n        map.put(\"Yahoo\", new SearchEngineRule(\"search.yahoo.\", \"s/(^|.*&)p=(.*?)(&.*|$)/$2/\"));\n        map.put(\"Voila\", new SearchEngineRule(\"voila.fr\", \"s/(^|.*&)kw=(.*?)(&.*|$)/$2/\"));\n\n        return map;\n    }\n\n    public String getRefererText(String referer, XWikiContext context)\n    {\n        try {\n            URL url = new URL(referer);\n            Map<String, SearchEngineRule> searchengines = getSearchEngineRules(context);\n            if (searchengines != null) {\n                for (SearchEngineRule senginerule : searchengines.values()) {\n                    String host = url.getHost();\n                    int i1 = host.indexOf(senginerule.getHost());\n                    if (i1 != -1) {\n                        String query = context.getUtil().substitute(senginerule.getRegEx(), url.getQuery());\n                        if ((query != null) && (!query.equals(\"\"))) {\n                            // We return the query text instead of the full referer\n                            return host.substring(i1) + \":\" + query;\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        String result = referer.substring(referer.indexOf(\"://\") + 3);\n        if (result.endsWith(\"/\")) {\n            return result.substring(0, result.length() - 1);\n        } else {\n            return result;\n        }\n    }\n\n    public boolean isMySQL()\n    {\n        if (getHibernateStore() == null) {\n            return false;\n        }\n\n        Object dialect = getHibernateStore().getConfiguration().getProperties().get(\"dialect\");\n        return \"org.hibernate.dialect.MySQLDialect\".equals(dialect)\n            || \"net.sf.hibernate.dialect.MySQLDialect\".equals(dialect);\n    }\n\n    public String getFullNameSQL()\n    {\n        return getFullNameSQL(true);\n    }\n\n    public String getFullNameSQL(boolean newFullName)\n    {\n        if (newFullName) {\n            return \"doc.fullName\";\n        }\n\n        if (this.fullNameSQL == null) {\n            if (isMySQL()) {\n                this.fullNameSQL = \"CONCAT(doc.space,'.',doc.name)\";\n            } else {\n                this.fullNameSQL = \"doc.space||'.'||doc.name\";\n            }\n        }\n\n        return this.fullNameSQL;\n    }\n\n    public String getUserName(String user, XWikiContext context)\n    {\n        return getUserName(user, null, true, context);\n    }\n\n    public String getUserName(String user, String format, XWikiContext context)\n    {\n        return getUserName(user, format, true, context);\n    }\n\n    /**\n     * @return a formatted and pretty printed user name for displaying\n     */\n    public String getUserName(String user, String format, boolean link, XWikiContext context)\n    {\n        if (StringUtils.isBlank(user)) {\n            return localizePlainOrKey(\"core.users.unknownUser\");\n        }\n\n        DocumentReference userReference = getCurrentMixedDocumentReferenceResolver().resolve(user);\n\n        return getUserName(userReference, format, link, true, context);\n    }\n\n    /**\n     * Generate a display user name and return it.\n     *\n     * @param userReference\n     * @param format a Velocity scnippet used to format the user name\n     * @param link true if a full html link snippet should be returned\n     * @param escapeXML true if the returned name should be escaped (forced true if {@code link} is true)\n     * @param context see {@link XWikiContext}\n     * @return the display user name or a html snippet with the link to the passed user\n     * @since 6.4RC1\n     */\n    public String getUserName(DocumentReference userReference, String format, boolean link, boolean escapeXML,\n        XWikiContext context)\n    {\n        if (userReference == null) {\n            return localizePlainOrKey(\"core.users.unknownUser\");\n        }\n\n        XWikiDocument userdoc = null;\n        try {\n            userdoc = getDocument(userReference, context);\n            if (userdoc == null) {\n                return escapeXML ? XMLUtils.escape(userReference.getName()) : userReference.getName();\n            }\n\n            BaseObject userobj = userdoc.getObject(\"XWiki.XWikiUsers\");\n            if (userobj == null) {\n                return escapeXML ? XMLUtils.escape(userdoc.getDocumentReference().getName())\n                    : userdoc.getDocumentReference().getName();\n            }\n\n            String text;\n\n            if (format == null) {\n                text = userobj.getStringValue(\"first_name\");\n                String lastName = userobj.getStringValue(\"last_name\");\n                if (!text.isEmpty() && !lastName.isEmpty()) {\n                    text += ' ';\n                }\n                text += userobj.getStringValue(\"last_name\");\n                if (StringUtils.isBlank(text)) {\n                    text = userdoc.getDocumentReference().getName();\n                }\n            } else {\n                VelocityContext vcontext;\n                try {\n                    vcontext = getVelocityContextFactory().createContext();\n                } catch (XWikiVelocityException e) {\n                    LOGGER.error(\"Failed to create standard VelocityContext\", e);\n\n                    vcontext = new XWikiVelocityContext();\n                }\n\n                for (String propname : userobj.getPropertyList()) {\n                    vcontext.put(propname, userobj.getStringValue(propname));\n                }\n                text = evaluateVelocity(format,\n                    \"<username formatting code in \" + context.getDoc().getDocumentReference() + \">\", vcontext);\n            }\n\n            if (escapeXML || link) {\n                text = XMLUtils.escape(text.trim());\n            }\n\n            if (link) {\n                text = \"<span class=\\\"wikilink\\\"><a href=\\\"\" + userdoc.getURL(\"view\", context) + \"\\\">\" + text\n                    + \"</a></span>\";\n            }\n            return text;\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to display the user name of [{}]. Root cause is [{}]. Falling back on the user id.\",\n                userReference, ExceptionUtils.getRootCauseMessage(e));\n\n            return escapeXML ? XMLUtils.escape(userReference.getName()) : userReference.getName();\n        }\n    }\n\n    /**\n     * @param content the Velocity content to evaluate\n     * @param namespace the namespace under which to evaluate it (used for isolation)\n     * @param vcontext the Velocity context to use when evaluating. If {@code null}, then a new context will be created,\n     *            initialized and used.\n     * @return the evaluated content\n     * @since 7.2M1\n     */\n    public String evaluateVelocity(String content, String namespace, VelocityContext vcontext)\n    {\n        try {\n            return getVelocityEvaluator().evaluateVelocity(content, namespace, vcontext);\n        } catch (XWikiException xe) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}] with content:\\n[{}]\", namespace, content,\n                xe.getCause());\n            return Util.getHTMLExceptionMessage(xe, null);\n        }\n    }\n\n    /**\n     * @param content the Velocity content to evaluate\n     * @param name the namespace under which to evaluate it (used for isolation)\n     * @return the evaluated content\n     * @since 7.2M1\n     */\n    public String evaluateVelocity(String content, String name)\n    {\n        try {\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            VelocityContext velocityContext = velocityManager.getVelocityContext();\n            return evaluateVelocity(content, name, velocityContext);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}] with content:\\n[{}]\", name, content, e);\n            Object[] args = { name };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while parsing velocity page {0}\", e,\n                args);\n            return Util.getHTMLExceptionMessage(xe, null);\n        }\n    }\n\n    /**\n     * Generate and return an unescaped user display name.\n     *\n     * @param userReference the user reference\n     * @param context see {@link XWikiContext}\n     * @return the unescaped display user name\n     * @since 6.4RC1\n     */\n    public String getPlainUserName(DocumentReference userReference, XWikiContext context)\n    {\n        return getUserName(userReference, null, false, false, context);\n    }\n\n    public boolean hasCentralizedAuthentication(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"authentication_centralized\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.centralized\", \"0\"));\n    }\n\n    public String getLocalUserName(String user, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, null, true, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), null, true, context);\n        }\n    }\n\n    public String getLocalUserName(String user, String format, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, format, true, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), format, true, context);\n        }\n    }\n\n    public String getLocalUserName(String user, String format, boolean link, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, format, link, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), format, link, context);\n        }\n    }\n\n    public String formatDate(Date date, String format, XWikiContext context)\n    {\n        if (date == null) {\n            return \"\";\n        }\n        String xformat = format;\n        String defaultFormat = \"yyyy/MM/dd HH:mm\";\n\n        if (format == null) {\n            xformat = getXWikiPreference(\"dateformat\", defaultFormat, context);\n        }\n\n        try {\n            DateFormatSymbols formatSymbols = null;\n            try {\n                String language = getLanguagePreference(context);\n                formatSymbols = new DateFormatSymbols(new Locale(language));\n            } catch (Exception e2) {\n                String language = getXWikiPreference(\"default_language\", context);\n                if ((language != null) && (!language.equals(\"\"))) {\n                    formatSymbols = new DateFormatSymbols(new Locale(language));\n                }\n            }\n\n            SimpleDateFormat sdf;\n            if (formatSymbols != null) {\n                sdf = new SimpleDateFormat(xformat, formatSymbols);\n            } else {\n                sdf = new SimpleDateFormat(xformat);\n            }\n\n            try {\n                sdf.setTimeZone(TimeZone.getTimeZone(getUserTimeZone(context)));\n            } catch (Exception e) {\n            }\n\n            return sdf.format(date);\n        } catch (Exception e) {\n            LOGGER.info(\"Failed to format date [\" + date + \"] with pattern [\" + xformat + \"]: \" + e.getMessage());\n            if (format == null) {\n                if (xformat.equals(defaultFormat)) {\n                    return date.toString();\n                } else {\n                    return formatDate(date, defaultFormat, context);\n                }\n            } else {\n                return formatDate(date, null, context);\n            }\n        }\n    }\n\n    /*\n     * Allow to read user setting providing the user timezone All dates will be expressed with this timezone\n     */\n    public String getUserTimeZone(XWikiContext context)\n    {\n        String tz = getUserPreference(\"timezone\", context);\n        // We perform this verification ourselves since TimeZone#getTimeZone(String) with an invalid parameter returns\n        // GMT and not the system default.\n        if (!ArrayUtils.contains(TimeZone.getAvailableIDs(), tz)) {\n            String defaultTz = TimeZone.getDefault().getID();\n            return getConfiguration().getProperty(\"xwiki.timezone\", defaultTz);\n        } else {\n            return tz;\n        }\n    }\n\n    /**\n     * @deprecated since 2.2.1 use {@link #exists(DocumentReference, XWikiContext)}\n     */\n    @Deprecated\n    public boolean exists(String fullname, XWikiContext context)\n    {\n        return exists(getCurrentMixedDocumentReferenceResolver().resolve(fullname), context);\n    }\n\n    public boolean exists(DocumentReference documentReference, XWikiContext context)\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            XWikiDocument doc = new XWikiDocument(documentReference, documentReference.getLocale());\n\n            context.setWikiId(documentReference.getWikiReference().getName());\n\n            return getStore().exists(doc, context);\n        } catch (XWikiException e) {\n            return false;\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Returns whether a page exists or not.\n     * \n     * @param reference the reference of the page to check for its existence\n     * @return true if the page exists, false if not\n     * @since 13.3RC1\n     * @since 12.10.7\n     */\n    @Unstable\n    public boolean exists(PageReference reference, XWikiContext context)\n    {\n        // Try as space\n        DocumentReference documentReference = getCurrentReferenceDocumentReferenceResolver().resolve(reference);\n        if (exists(documentReference, context)) {\n            return true;\n        }\n\n        // Try as document\n        if (documentReference.getParent().getParent().getType() == EntityType.SPACE) {\n            return exists(new DocumentReference(documentReference.getParent().getName(),\n                documentReference.getParent().getParent(), documentReference.getParameters()), context);\n        }\n\n        return false;\n    }\n\n    public String getAdType(XWikiContext context)\n    {\n        String adtype = \"\";\n        XWikiDocument wikiServer = context.getWikiServer();\n        if (wikiServer != null) {\n            adtype = wikiServer.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"adtype\");\n        }\n\n        if (adtype.equals(\"\")) {\n            adtype = getConfiguration().getProperty(\"xwiki.ad.type\", \"\");\n        }\n\n        return adtype;\n    }\n\n    public String getAdClientId(XWikiContext context)\n    {\n        final String defaultadclientid = \"pub-2778691407285481\";\n        String adclientid = \"\";\n        XWikiDocument wikiServer = context.getWikiServer();\n        if (wikiServer != null) {\n            adclientid = wikiServer.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"adclientid\");\n        }\n\n        if (adclientid.equals(\"\")) {\n            adclientid = getConfiguration().getProperty(\"xwiki.ad.clientid\", \"\");\n        }\n\n        if (adclientid.equals(\"\")) {\n            adclientid = defaultadclientid;\n        }\n\n        return adclientid;\n    }\n\n    /**\n     * @deprecated\n     */\n    @Deprecated\n    public XWikiPluginInterface getPlugin(String name, XWikiContext context)\n    {\n        XWikiPluginManager plugins = getPluginManager();\n        Vector<String> pluginlist = plugins.getPlugins();\n        for (String pluginname : pluginlist) {\n            if (pluginname.equals(name)) {\n                return plugins.getPlugin(pluginname);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @deprecated\n     */\n    @Deprecated\n    public Api getPluginApi(String name, XWikiContext context)\n    {\n        XWikiPluginInterface plugin = getPlugin(name, context);\n        if (plugin != null) {\n            return plugin.getPluginApi(plugin, context);\n        }\n\n        return null;\n    }\n\n    public int getHttpTimeout(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.http.timeout\", 60000);\n    }\n\n    public String getHttpUserAgent(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.http.useragent\", \"XWikiBot/1.0\");\n    }\n\n    public String getURLContent(String surl, XWikiContext context) throws IOException\n    {\n        return getURLContent(surl, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public String getURLContent(String surl, int timeout, String userAgent) throws IOException\n    {\n        String content;\n        HttpClient client = getHttpClient(timeout, userAgent);\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            client.executeMethod(get);\n            content = get.getResponseBodyAsString();\n        } finally {\n            // Release any connection resources used by the method\n            get.releaseConnection();\n        }\n\n        return content;\n    }\n\n    public String getURLContent(String surl, String username, String password, XWikiContext context) throws IOException\n    {\n        return getURLContent(surl, username, password, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public String getURLContent(String surl, String username, String password, int timeout, String userAgent)\n        throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // pass our credentials to HttpClient, they will only be used for\n        // authenticating to servers with realm \"realm\", to authenticate agains\n        // an arbitrary realm change this to null.\n        client.getState().setCredentials(new AuthScope(null, -1, null),\n            new UsernamePasswordCredentials(username, password));\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // Tell the GET method to automatically handle authentication. The\n            // method will use any appropriate credentials to handle basic\n            // authentication requests. Setting this value to false will cause\n            // any request for authentication to return with a status of 401.\n            // It will then be up to the client to handle the authentication.\n            get.setDoAuthentication(true);\n\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBodyAsString();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    public byte[] getURLContentAsBytes(String surl, XWikiContext context) throws IOException\n    {\n        return getURLContentAsBytes(surl, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public byte[] getURLContentAsBytes(String surl, int timeout, String userAgent) throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBody();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    public byte[] getURLContentAsBytes(String surl, String username, String password, XWikiContext context)\n        throws IOException\n    {\n        return getURLContentAsBytes(surl, username, password, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public byte[] getURLContentAsBytes(String surl, String username, String password, int timeout, String userAgent)\n        throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // pass our credentials to HttpClient, they will only be used for\n        // authenticating to servers with realm \"realm\", to authenticate agains\n        // an arbitrary realm change this to null.\n        client.getState().setCredentials(new AuthScope(null, -1, null),\n            new UsernamePasswordCredentials(username, password));\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // Tell the GET method to automatically handle authentication. The\n            // method will use any appropriate credentials to handle basic\n            // authentication requests. Setting this value to false will cause\n            // any request for authentication to return with a status of 401.\n            // It will then be up to the client to handle the authentication.\n            get.setDoAuthentication(true);\n\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBody();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    /**\n     * API to list all spaces in the current wiki.\n     * <p>\n     * Hidden spaces are filtered unless current user enabled them.\n     *\n     * @return a list of string representing all non-hidden spaces (ie spaces that have non-hidden pages) for the\n     *         current wiki\n     * @throws XWikiException if something went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaces(XWikiContext context) throws XWikiException\n    {\n        try {\n            return getStore().getQueryManager().getNamedQuery(\"getSpaces\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\")).execute();\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    /**\n     * API to list all non-hidden documents in a space.\n     *\n     * @param spaceReference the local reference of the space for which to return all non-hidden documents\n     * @return the list of document names (in the format {@code Space.Page}) for non-hidden documents in the specified\n     *         space\n     * @throws XWikiException if the loading went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaceDocsName(String spaceReference, XWikiContext context) throws XWikiException\n    {\n        try {\n            return getStore().getQueryManager().getNamedQuery(\"getSpaceDocsName\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\"))\n                .bindValue(\"space\", spaceReference).execute();\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    public List<String> getIncludedMacros(String defaultSpace, String content, XWikiContext context)\n    {\n        List<String> list;\n\n        try {\n            String pattern = \"#includeMacros[ ]*\\\\([ ]*([\\\"'])(.*?)\\\\1[ ]*\\\\)\";\n            list = context.getUtil().getUniqueMatches(content, pattern, 2);\n            for (int i = 0; i < list.size(); i++) {\n                String name = list.get(i);\n                if (name.indexOf('.') == -1) {\n                    list.set(i, defaultSpace + \".\" + name);\n                }\n            }\n        } catch (Exception e) {\n            // This should never happen\n            LOGGER.error(\"Failed to extract #includeMacros targets from provided content [\" + content + \"]\", e);\n\n            list = Collections.emptyList();\n        }\n\n        return list;\n    }\n\n    /**\n     * accessor for the isReadOnly instance var.\n     *\n     * @see #isReadOnly\n     */\n    public boolean isReadOnly()\n    {\n        return this.isReadOnly;\n    }\n\n    public void setReadOnly(boolean readOnly)\n    {\n        this.isReadOnly = readOnly;\n    }\n\n    public void deleteAllDocuments(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        deleteAllDocuments(doc, true, context);\n    }\n\n    public void deleteAllDocuments(XWikiDocument doc, boolean toTrash, XWikiContext context) throws XWikiException\n    {\n        // Wrap the work as a batch operation.\n        BatchOperationExecutor batchOperationExecutor = Utils.getComponent(BatchOperationExecutor.class);\n        batchOperationExecutor.execute(() -> {\n            // Delete all translation documents\n            for (Locale locale : doc.getTranslationLocales(context)) {\n                XWikiDocument tdoc = doc.getTranslatedDocument(locale, context);\n                deleteDocument(tdoc, toTrash, context);\n            }\n\n            // Delete the default document\n            deleteDocument(doc, toTrash, context);\n        });\n    }\n\n    public void refreshLinks(XWikiContext context) throws XWikiException\n    {\n        try {\n            // refreshes all Links of each doc of the wiki\n            @SuppressWarnings(\"deprecation\")\n            List<String> docs = getStore().getQueryManager().getNamedQuery(\"getAllDocuments\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\")).execute();\n            for (int i = 0; i < docs.size(); i++) {\n                XWikiDocument myDoc = this.getDocument(docs.get(i), context);\n                myDoc.getStore().saveLinks(myDoc, context, true);\n            }\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    public boolean hasBacklinks(XWikiContext context)\n    {\n        if (this.hasBacklinks == null) {\n            this.hasBacklinks = \"1\".equals(getXWikiPreference(\"backlinks\", \"xwiki.backlinks\", \"0\", context));\n        }\n        return this.hasBacklinks;\n    }\n\n    public boolean hasTags(XWikiContext context)\n    {\n        return \"1\".equals(getXWikiPreference(\"tags\", \"xwiki.tags\", \"0\", context));\n    }\n\n    public boolean hasCustomMappings()\n    {\n        return getHibernateConfiguration().hasCustomMappings();\n    }\n\n    public boolean hasDynamicCustomMappings()\n    {\n        return getHibernateConfiguration().hasDynamicCustomMappings();\n    }\n\n    public String getDefaultSpace(XWikiContext context)\n    {\n        String defaultSpace = getXWikiPreference(\"defaultweb\", \"\", context);\n        if (StringUtils.isEmpty(defaultSpace)) {\n            return getConfiguration().getProperty(\"xwiki.defaultweb\", DEFAULT_HOME_SPACE);\n        }\n        return defaultSpace;\n    }\n\n    public boolean showViewAction(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"showviewaction\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        } else if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.showviewaction\", \"1\"));\n    }\n\n    public boolean useDefaultAction(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"usedefaultaction\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.usedefaultaction\", \"0\"));\n    }\n\n    public String getDefaultPage(XWikiContext context)\n    {\n        String defaultPage = getXWikiPreference(\"defaultpage\", \"\", context);\n        if (StringUtils.isEmpty(defaultPage)) {\n            return getConfiguration().getProperty(\"xwiki.defaultpage\", DEFAULT_SPACE_HOMEPAGE);\n        }\n        return defaultPage;\n    }\n\n    public boolean hasEditComment(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment\", \"0\"));\n    }\n\n    public boolean isEditCommentFieldHidden(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_hidden\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.hidden\", \"0\"));\n    }\n\n    public boolean isEditCommentSuggested(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_suggested\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.suggested\", \"0\"));\n    }\n\n    public boolean isEditCommentMandatory(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_mandatory\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.mandatory\", \"0\"));\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#hasMinorEdit()\n     */\n    public boolean hasMinorEdit(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"minoredit\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.minoredit\", \"1\"));\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#hasRecycleBin()\n     * @param context see {@link XWikiContext}\n     */\n    public boolean hasRecycleBin(XWikiContext context)\n    {\n        return getStoreConfiguration().isRecycleBinEnabled();\n    }\n\n    /**\n     * Indicates whether deleted attachments are stored in a recycle bin or not. This can be configured using the key\n     * <var>storage.attachment.recyclebin</var>.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public boolean hasAttachmentRecycleBin(XWikiContext context)\n    {\n        return getStoreConfiguration().isAttachmentRecycleBinEnabled();\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public BaseClass getXClass(DocumentReference documentReference, XWikiContext context) throws XWikiException\n    {\n        // Used to avoid recursive loading of documents if there are recursives usage of classes\n        BaseClass bclass = context.getBaseClass(documentReference);\n        if (bclass != null) {\n            return bclass;\n        }\n\n        return getDocument(documentReference, context).getXClass();\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #getXClass(DocumentReference, XWikiContext)}\n     */\n    @Deprecated\n    public BaseClass getClass(String fullName, XWikiContext context) throws XWikiException\n    {\n        DocumentReference reference = null;\n        if (StringUtils.isNotEmpty(fullName)) {\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);\n        }\n        return getXClass(reference, context);\n    }\n\n    public String getEditorPreference(XWikiContext context)\n    {\n        String defaultSyntaxContentEditor = getEditConfiguration().getDefaultEditor(SyntaxContent.class);\n\n        return defaultSyntaxContentEditor == null ? \"\" : defaultSyntaxContentEditor.toLowerCase();\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String. Note that Groovy scripts\n     * compilation is cached.\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public Object parseGroovyFromString(String script, XWikiContext xcontext) throws XWikiException\n    {\n        return getParseGroovyFromString().parseGroovyFromString(script, xcontext);\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String, using a classloader including all\n     * JAR files located in the passed page as attachments. Note that Groovy scripts compilation is cached\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public Object parseGroovyFromString(String script, String jarWikiPage, XWikiContext xcontext) throws XWikiException\n    {\n        XWikiPageClassLoader pcl = new XWikiPageClassLoader(jarWikiPage, xcontext);\n        Object prevParentClassLoader = xcontext.get(\"parentclassloader\");\n        try {\n            xcontext.put(\"parentclassloader\", pcl);\n\n            return parseGroovyFromString(script, xcontext);\n        } finally {\n            if (prevParentClassLoader == null) {\n                xcontext.remove(\"parentclassloader\");\n            } else {\n                xcontext.put(\"parentclassloader\", prevParentClassLoader);\n            }\n        }\n    }\n\n    public Object parseGroovyFromPage(String fullName, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groovyDocument = context.getWiki().getDocument(fullName, context);\n\n        Object sdoc = context.get(XWikiDocument.CKEY_SDOC);\n        context.put(XWikiDocument.CKEY_SDOC, groovyDocument);\n\n        try {\n            return parseGroovyFromString(groovyDocument.getContent(), context);\n        } finally {\n            context.put(XWikiDocument.CKEY_SDOC, sdoc);\n        }\n    }\n\n    public Object parseGroovyFromPage(String fullName, String jarWikiPage, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groovyDocument = context.getWiki().getDocument(fullName, context);\n\n        Object sdoc = context.get(XWikiDocument.CKEY_SDOC);\n        context.put(XWikiDocument.CKEY_SDOC, groovyDocument);\n\n        try {\n            return parseGroovyFromString(groovyDocument.getContent(), jarWikiPage, context);\n        } finally {\n            context.put(XWikiDocument.CKEY_SDOC, sdoc);\n        }\n    }\n\n    public String getMacroList(XWikiContext context)\n    {\n        String macrosmapping = \"\";\n        XWiki xwiki = context.getWiki();\n\n        try {\n            macrosmapping = getResourceContent(MACROS_FILE);\n        } catch (IOException e) {\n        }\n\n        macrosmapping += \"\\r\\n\" + xwiki.getXWikiPreference(\"macros_mapping\", \"\", context);\n\n        return macrosmapping;\n    }\n\n    // This functions adds an object from an new object creation form\n    public BaseObject getObjectFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        Map<String, String[]> map = Util.getObject(context.getRequest(), className);\n        BaseClass bclass = context.getWiki().getClass(className, context);\n        BaseObject newobject = (BaseObject) bclass.fromMap(map, context);\n\n        return newobject;\n    }\n\n    public String getConvertingUserNameType(XWikiContext context)\n    {\n        if (StringUtils.isNotBlank(context.getWiki().getXWikiPreference(\"convertmail\", context))) {\n            return context.getWiki().getXWikiPreference(\"convertmail\", \"0\", context);\n        }\n\n        return getConfiguration().getProperty(\"xwiki.authentication.convertemail\", \"0\");\n    }\n\n    public String convertUsername(String username, XWikiContext context)\n    {\n        if (username == null) {\n            return null;\n        }\n\n        if (getConvertingUserNameType(context).equals(\"1\") && (username.indexOf('@') != -1)) {\n            String id = \"\" + username.hashCode();\n            id = id.replace(\"-\", \"\");\n            if (username.length() > 1) {\n                int i1 = username.indexOf('@');\n                id = \"\" + username.charAt(0) + username.substring(i1 + 1, i1 + 2)\n                    + username.charAt(username.length() - 1) + id;\n            }\n\n            return id;\n        } else if (getConvertingUserNameType(context).equals(\"2\")) {\n            return username.replaceAll(\"[\\\\.\\\\@]\", \"_\");\n        } else {\n            return username;\n        }\n    }\n\n    public boolean hasSectionEdit(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.section.edit\", 0) == 1;\n    }\n\n    /**\n     * @return The maximum section depth for which section editing is available. This can be customized through the\n     *         {@code xwiki.section.depth} configuration property. Defaults to 2 when not defined.\n     */\n    public long getSectionEditingDepth()\n    {\n        return getConfiguration().getProperty(\"xwiki.section.depth\", 2L);\n    }\n\n    public String getWysiwygToolbars(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.wysiwyg.toolbars\", \"\");\n    }\n\n    public String clearName(String name, XWikiContext context)\n    {\n        return clearName(name, true, true, context);\n    }\n\n    public String clearName(String name, boolean stripDots, boolean ascii, XWikiContext context)\n    {\n        String temp = name;\n        temp = temp.replaceAll(\n            \"[\\u00c0\\u00c1\\u00c2\\u00c3\\u00c4\\u00c5\\u0100\\u0102\\u0104\\u01cd\\u01de\\u01e0\\u01fa\\u0200\\u0202\\u0226]\", \"A\");\n        temp = temp.replaceAll(\n            \"[\\u00e0\\u00e1\\u00e2\\u00e3\\u00e4\\u00e5\\u0101\\u0103\\u0105\\u01ce\\u01df\\u01e1\\u01fb\\u0201\\u0203\\u0227]\", \"a\");\n        temp = temp.replaceAll(\"[\\u00c6\\u01e2\\u01fc]\", \"AE\");\n        temp = temp.replaceAll(\"[\\u00e6\\u01e3\\u01fd]\", \"ae\");\n        temp = temp.replaceAll(\"[\\u008c\\u0152]\", \"OE\");\n        temp = temp.replaceAll(\"[\\u009c\\u0153]\", \"oe\");\n        temp = temp.replaceAll(\"[\\u00c7\\u0106\\u0108\\u010a\\u010c]\", \"C\");\n        temp = temp.replaceAll(\"[\\u00e7\\u0107\\u0109\\u010b\\u010d]\", \"c\");\n        temp = temp.replaceAll(\"[\\u00d0\\u010e\\u0110]\", \"D\");\n        temp = temp.replaceAll(\"[\\u00f0\\u010f\\u0111]\", \"d\");\n        temp = temp.replaceAll(\"[\\u00c8\\u00c9\\u00ca\\u00cb\\u0112\\u0114\\u0116\\u0118\\u011a\\u0204\\u0206\\u0228]\", \"E\");\n        temp = temp.replaceAll(\"[\\u00e8\\u00e9\\u00ea\\u00eb\\u0113\\u0115\\u0117\\u0119\\u011b\\u01dd\\u0205\\u0207\\u0229]\", \"e\");\n        temp = temp.replaceAll(\"[\\u011c\\u011e\\u0120\\u0122\\u01e4\\u01e6\\u01f4]\", \"G\");\n        temp = temp.replaceAll(\"[\\u011d\\u011f\\u0121\\u0123\\u01e5\\u01e7\\u01f5]\", \"g\");\n        temp = temp.replaceAll(\"[\\u0124\\u0126\\u021e]\", \"H\");\n        temp = temp.replaceAll(\"[\\u0125\\u0127\\u021f]\", \"h\");\n        temp = temp.replaceAll(\"[\\u00cc\\u00cd\\u00ce\\u00cf\\u0128\\u012a\\u012c\\u012e\\u0130\\u01cf\\u0208\\u020a]\", \"I\");\n        temp = temp.replaceAll(\"[\\u00ec\\u00ed\\u00ee\\u00ef\\u0129\\u012b\\u012d\\u012f\\u0131\\u01d0\\u0209\\u020b]\", \"i\");\n        temp = temp.replaceAll(\"[\\u0132]\", \"IJ\");\n        temp = temp.replaceAll(\"[\\u0133]\", \"ij\");\n        temp = temp.replaceAll(\"[\\u0134]\", \"J\");\n        temp = temp.replaceAll(\"[\\u0135]\", \"j\");\n        temp = temp.replaceAll(\"[\\u0136\\u01e8]\", \"K\");\n        temp = temp.replaceAll(\"[\\u0137\\u0138\\u01e9]\", \"k\");\n        temp = temp.replaceAll(\"[\\u0139\\u013b\\u013d\\u013f\\u0141]\", \"L\");\n        temp = temp.replaceAll(\"[\\u013a\\u013c\\u013e\\u0140\\u0142\\u0234]\", \"l\");\n        temp = temp.replaceAll(\"[\\u00d1\\u0143\\u0145\\u0147\\u014a\\u01f8]\", \"N\");\n        temp = temp.replaceAll(\"[\\u00f1\\u0144\\u0146\\u0148\\u0149\\u014b\\u01f9\\u0235]\", \"n\");\n        temp = temp.replaceAll(\n            \"[\\u00d2\\u00d3\\u00d4\\u00d5\\u00d6\\u00d8\\u014c\\u014e\\u0150\\u01d1\\u01ea\\u01ec\\u01fe\\u020c\\u020e\\u022a\\u022c\"\n                + \"\\u022e\\u0230]\",\n            \"O\");\n        temp = temp.replaceAll(\n            \"[\\u00f2\\u00f3\\u00f4\\u00f5\\u00f6\\u00f8\\u014d\\u014f\\u0151\\u01d2\\u01eb\\u01ed\\u01ff\\u020d\\u020f\\u022b\\u022d\"\n                + \"\\u022f\\u0231]\",\n            \"o\");\n        temp = temp.replaceAll(\"[\\u0156\\u0158\\u0210\\u0212]\", \"R\");\n        temp = temp.replaceAll(\"[\\u0157\\u0159\\u0211\\u0213]\", \"r\");\n        temp = temp.replaceAll(\"[\\u015a\\u015c\\u015e\\u0160\\u0218]\", \"S\");\n        temp = temp.replaceAll(\"[\\u015b\\u015d\\u015f\\u0161\\u0219]\", \"s\");\n        temp = temp.replaceAll(\"[\\u00de\\u0162\\u0164\\u0166\\u021a]\", \"T\");\n        temp = temp.replaceAll(\"[\\u00fe\\u0163\\u0165\\u0167\\u021b\\u0236]\", \"t\");\n        temp = temp.replaceAll(\n            \"[\\u00d9\\u00da\\u00db\\u00dc\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u0214\\u0216]\",\n            \"U\");\n        temp = temp.replaceAll(\n            \"[\\u00f9\\u00fa\\u00fb\\u00fc\\u0169\\u016b\\u016d\\u016f\\u0171\\u0173\\u01d4\\u01d6\\u01d8\\u01da\\u01dc\\u0215\\u0217]\",\n            \"u\");\n        temp = temp.replaceAll(\"[\\u0174]\", \"W\");\n        temp = temp.replaceAll(\"[\\u0175]\", \"w\");\n        temp = temp.replaceAll(\"[\\u00dd\\u0176\\u0178\\u0232]\", \"Y\");\n        temp = temp.replaceAll(\"[\\u00fd\\u00ff\\u0177\\u0233]\", \"y\");\n        temp = temp.replaceAll(\"[\\u0179\\u017b\\u017d]\", \"Z\");\n        temp = temp.replaceAll(\"[\\u017a\\u017c\\u017e]\", \"z\");\n        temp = temp.replaceAll(\"[\\u00df]\", \"SS\");\n        temp = temp.replaceAll(\"[_':,;\\\\\\\\/]\", \" \");\n        name = temp;\n        name = name.replaceAll(\"\\\\s+\", \"\");\n        name = name.replaceAll(\"[\\\\(\\\\)]\", \" \");\n\n        if (stripDots) {\n            name = name.replaceAll(\"[\\\\.]\", \"\");\n        }\n\n        if (ascii) {\n            name = name.replaceAll(\"[^a-zA-Z0-9\\\\-_\\\\.]\", \"\");\n        }\n\n        if (name.length() > 250) {\n            name = name.substring(0, 250);\n        }\n\n        return name;\n\n    }\n\n    public String getUniquePageName(String space, XWikiContext context)\n    {\n        String pageName = generateRandomString(16);\n\n        return getUniquePageName(space, pageName, context);\n    }\n\n    public String getUniquePageName(String space, String name, XWikiContext context)\n    {\n        String pageName = clearName(name, context);\n        if (exists(space + \".\" + pageName, context)) {\n            int i = 0;\n            while (exists(space + \".\" + pageName + \"_\" + i, context)) {\n                i++;\n            }\n\n            return pageName + \"_\" + i;\n        }\n\n        return pageName;\n    }\n\n    public PropertyClass getPropertyClassFromName(String propPath, XWikiContext context)\n    {\n        int i1 = propPath.indexOf('_');\n        if (i1 == -1) {\n            return null;\n        } else {\n            String className = propPath.substring(0, i1);\n            String propName = propPath.substring(i1 + 1);\n            try {\n                return (PropertyClass) getDocument(className, context).getXClass().get(propName);\n            } catch (XWikiException e) {\n                return null;\n            }\n        }\n    }\n\n    public boolean validateDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        return doc.validate(context);\n    }\n\n    public String addTooltip(String html, String message, String params, XWikiContext context)\n    {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(\"<span class=\\\"tooltip_span\\\" onmouseover=\\\"\");\n        buffer.append(params);\n        buffer.append(\"; return escape('\");\n        buffer.append(message.replaceAll(\"'\", \"\\\\'\"));\n        buffer.append(\"');\\\">\");\n        buffer.append(html);\n        buffer.append(\"</span>\");\n\n        return buffer.toString();\n    }\n\n    public String addTooltipJS(XWikiContext context)\n    {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(\"<script src=\\\"\");\n        buffer.append(getSkinFile(\"ajax/wzToolTip.js\", context));\n        buffer.append(\"\\\"></script>\");\n        // buffer.append(\"<div id=\\\"dhtmltooltip\\\"></div>\");\n\n        return buffer.toString();\n    }\n\n    public String addTooltip(String html, String message, XWikiContext context)\n    {\n        return addTooltip(html, message, \"this.WIDTH='300'\", context);\n    }\n\n    public String addMandatory(XWikiContext context)\n    {\n        String star =\n            \"<span class=\\\"mandatoryParenthesis\\\">&nbsp;(</span><span class=\\\"mandatoryDot\\\">&lowast;</span><span class=\\\"mandatoryParenthesis\\\">)&nbsp;</span>\";\n        return context.getWiki().getXWikiPreference(\"mandatory_display\", star, context);\n    }\n\n    /**\n     * @since 2.3M1\n     */\n    public boolean hasVersioning(XWikiContext context)\n    {\n        return getStoreConfiguration().isVersioningEnabled();\n    }\n\n    public boolean hasAttachmentVersioning(XWikiContext context)\n    {\n        return getStoreConfiguration().isAttachmentVersioningEnabled();\n    }\n\n    public String getExternalAttachmentURL(String fullName, String filename, XWikiContext context)\n    {\n        XWikiDocument doc = new XWikiDocument();\n        doc.setFullName(fullName, context);\n\n        return doc.getExternalAttachmentURL(filename, \"download\", context);\n    }\n\n    public int getMaxRecursiveSpaceChecks(XWikiContext context)\n    {\n        int max = getXWikiPreferenceAsInt(\"rights_maxrecursivespacechecks\", -1, context);\n        if (max == -1) {\n            return getConfiguration().getProperty(\"xwiki.rights.maxrecursivespacechecks\", 0);\n        } else {\n            return max;\n        }\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param doc the document to restore\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 5.4RC1\n     */\n    public void restoreFromRecycleBin(final XWikiDocument doc, String comment, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = getRecycleBinStore().getAllDeletedDocuments(doc, context, true);\n        if (deletedDocuments != null && deletedDocuments.length > 0) {\n            long index = deletedDocuments[0].getId();\n            restoreFromRecycleBin(doc, index, comment, context);\n        }\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param doc the document to restore\n     * @param index the index of the document in the recycle bin\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 5.4RC1\n     * @deprecated since 9.4RC1. Use {@link #restoreFromRecycleBin(long, String, XWikiContext)} instead.\n     */\n    @Deprecated\n    public void restoreFromRecycleBin(final XWikiDocument doc, long index, String comment, XWikiContext context)\n        throws XWikiException\n    {\n        restoreFromRecycleBin(index, comment, context);\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param index the index of the document in the recycle bin\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 9.4RC1\n     */\n    public void restoreFromRecycleBin(long index, String comment, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument newdoc = getRecycleBinStore().restoreFromRecycleBin(index, context, true);\n        saveDocument(newdoc, comment, context);\n        getRecycleBinStore().deleteFromRecycleBin(index, context, true);\n    }\n\n    public XWikiDocument rollback(final XWikiDocument tdoc, String rev, XWikiContext context) throws XWikiException\n    {\n        return rollback(tdoc, rev, true, context);\n    }\n\n    private void restoreDeletedAttachment(XWikiAttachment rolledbackAttachment, XWikiContext context)\n        throws XWikiException\n    {\n        // Restore deleted attachments from the trash\n        if (getAttachmentRecycleBinStore() != null) {\n            // There might be multiple versions of the attachment in the trash, search for the right one\n            List<DeletedAttachment> deletedVariants =\n                getAttachmentRecycleBinStore().getAllDeletedAttachments(rolledbackAttachment, context, true);\n\n            DeletedAttachment correctVariant = null;\n            for (DeletedAttachment variant : deletedVariants) { // Reverse chronological order\n                if (variant.getDate().before(rolledbackAttachment.getDate())) {\n                    break;\n                }\n\n                correctVariant = variant;\n            }\n\n            if (correctVariant != null) {\n                XWikiAttachment restoredAttachment = correctVariant.restoreAttachment();\n\n                boolean updateArchive = false;\n\n                if (!restoredAttachment.getVersion().equals(rolledbackAttachment.getVersion())) {\n                    XWikiAttachment restoredAttachmentRevision =\n                        restoredAttachment.getAttachmentRevision(rolledbackAttachment.getVersion(), context);\n\n                    if (restoredAttachmentRevision != null) {\n                        // Update the archive since it won't be done by the store (it's a new attachment)\n                        // TODO: Remove from the archive the versions greater than the rollbacked one instead (they\n                        // would not be lost since they would still be in the recycle bin) ?\n                        rolledbackAttachment.setVersion(restoredAttachment.getVersion());\n                        updateArchive = true;\n\n                        restoredAttachment = restoredAttachmentRevision;\n                    }\n                }\n\n                rolledbackAttachment.apply(restoredAttachment);\n\n                // Restore the deleted archive\n                rolledbackAttachment\n                    .setAttachment_archive((XWikiAttachmentArchive) restoredAttachment.getAttachment_archive().clone());\n                rolledbackAttachment.getAttachment_archive().setAttachment(rolledbackAttachment);\n\n                if (updateArchive) {\n                    rolledbackAttachment.updateContentArchive(context);\n                }\n            } else {\n                // Not found in the trash, set an empty content to avoid errors\n                try {\n                    rolledbackAttachment.setContent(new ByteArrayInputStream(new byte[0]));\n                } catch (IOException e) {\n                    // The content we pass cannot fail\n                }\n            }\n        }\n    }\n\n    /**\n     * @param tdoc the document to rollback\n     * @param rev the revision to rollback to\n     * @param addRevision true if a new revision should be created\n     * @param xcontext the XWiki context\n     * @return the new document\n     * @throws XWikiException when failing to rollback the document\n     * @since 10.7RC1\n     * @since 9.11.8\n     */\n    public XWikiDocument rollback(final XWikiDocument tdoc, String rev, boolean addRevision, XWikiContext xcontext)\n        throws XWikiException\n    {\n        LOGGER.debug(\"Rolling back [{}] to version [{}]\", tdoc, rev);\n\n        // Clone the document before modifying to avoid concurrency issues\n        XWikiDocument document = tdoc.clone();\n\n        XWikiDocument rolledbackDoc = getDocumentRevisionProvider().getRevision(tdoc, rev);\n\n        // Restore attachments\n        if (\"1\".equals(getConfiguration().getProperty(\"xwiki.store.rollbackattachmentwithdocuments\", \"1\"))) {\n            LOGGER.debug(\"Checking attachments\");\n\n            for (XWikiAttachment rolledbackAttachment : rolledbackDoc.getAttachmentList()) {\n                String filename = rolledbackAttachment.getFilename();\n                XWikiAttachment attachment = document.getAttachment(filename);\n\n                if (attachment == null) {\n                    // The attachment has been deleted, search and restore it\n                    LOGGER.debug(\"Deleted attachment: [{}]\", filename);\n\n                    // Restore content and archive from the recycle bin\n                    restoreDeletedAttachment(rolledbackAttachment, xcontext);\n                } else {\n                    XWikiAttachment attachmentRevision =\n                        attachment.getAttachmentRevision(rolledbackAttachment.getVersion(), xcontext);\n\n                    // We compare the number of milliseconds instead of the date objects directly because Hibernate can\n                    // return java.sql.Timestamp for date fields and the JavaDoc says that Timestamp.equals(Object)\n                    // doesn't return true if the passed value is a java.util.Date object with the same number of\n                    // milliseconds because the nanoseconds component of the passed date is unknown.\n                    if (attachmentRevision == null\n                        || attachmentRevision.getDate().getTime() != rolledbackAttachment.getDate().getTime()) {\n                        // Recreated attachment\n                        LOGGER.debug(\"Recreated attachment: [{}]\", filename);\n\n                        // Mark current attachment for deletion to not loose it\n                        document.removeAttachment(attachment);\n\n                        // Search and restore previously deleted one\n                        // If the attachment trash is not available, don't lose the existing attachment\n                        if (getAttachmentRecycleBinStore() != null) {\n                            // Restore in the right version\n                            restoreDeletedAttachment(rolledbackAttachment, xcontext);\n                        }\n                    } else {\n                        // Restore content and archive from the recycle bin\n                        rolledbackAttachment.apply(attachmentRevision);\n                    }\n                }\n            }\n        }\n\n        document.apply(rolledbackDoc);\n\n        // Prepare the XWikiDocument before save\n        document.setAuthorReference(xcontext.getUserReference());\n        document.setContentAuthorReference(xcontext.getUserReference());\n\n        // Make sure the history is not modified if addRevision is disabled\n        String message;\n        if (!addRevision) {\n            document.setVersion(rev);\n            document.setMetaDataDirty(false);\n            document.setContentDirty(false);\n            message = document.getComment();\n        } else {\n            // Make sure to save a new version even if nothing changed\n            document.setMetaDataDirty(true);\n            message = localizePlainOrKey(\"core.comment.rollback\", rev);\n        }\n\n        ObservationManager om = getObservationManager();\n        if (om != null) {\n            // Notify listeners about the document that is going to be rolled back.\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            om.notify(new DocumentRollingBackEvent(document.getDocumentReference(), rev), document, xcontext);\n        }\n\n        XWikiDocument originalDocument = document.getOriginalDocument();\n\n        saveDocument(document, message, xcontext);\n\n        // Since XWiki#saveDocument resets the original document, we need to temporarily put it back to send\n        // notifications.\n        XWikiDocument newOriginalDocument = document.getOriginalDocument();\n        document.setOriginalDocument(originalDocument);\n\n        try {\n            if (om != null) {\n                // Notify listeners about the document that was rolled back.\n                // Note that for the moment the event being send is a bridge event, as we are still passing around an\n                // XWikiDocument as source and an XWikiContext as data.\n                om.notify(new DocumentRolledBackEvent(document.getDocumentReference(), rev), document, xcontext);\n            }\n        } finally {\n            document.setOriginalDocument(newOriginalDocument);\n        }\n\n        return document;\n    }\n\n    /**\n     * @return the syntax id of the syntax to use when creating new documents\n     */\n    public String getDefaultDocumentSyntax()\n    {\n        // TODO: Fix this method to return a Syntax object instead of a String\n        return getDefaultDocumentSyntaxInternal().toIdString();\n    }\n\n    /**\n     * @return the syntax to use when creating new documents\n     */\n    private Syntax getDefaultDocumentSyntaxInternal()\n    {\n        return Utils.getComponent(CoreConfiguration.class).getDefaultDocumentSyntax();\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @param defaultSyntaxId the default value to return if no document can be found\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId(String defaultSyntaxId, XWikiContext context)\n    {\n        String syntaxId = getCurrentContentSyntaxIdInternal(context);\n\n        if (syntaxId == null) {\n            syntaxId = defaultSyntaxId;\n        }\n\n        return syntaxId;\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId(XWikiContext context)\n    {\n        String syntaxId = getCurrentContentSyntaxIdInternal(context);\n\n        if (syntaxId == null) {\n            throw new RuntimeException(\"Cannot get the current syntax since there's no current document set\");\n        }\n\n        return syntaxId;\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    private String getCurrentContentSyntaxIdInternal(XWikiContext context)\n    {\n        Syntax syntax = getCurrentContentSyntaxInternal(context);\n\n        return syntax != null ? syntax.toIdString() : null;\n    }\n\n    /**\n     * Get the syntax of the code currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax\n     */\n    private Syntax getCurrentContentSyntaxInternal(XWikiContext context)\n    {\n        Syntax syntax = null;\n\n        // Try to find the current syntax\n        if (getRenderingContext() != null) {\n            Block curentBlock = getRenderingContext().getCurrentBlock();\n\n            if (curentBlock != null) {\n                MetaDataBlock metaDataBlock =\n                    curentBlock.getFirstBlock(new MetadataBlockMatcher(MetaData.SYNTAX), Axes.ANCESTOR_OR_SELF);\n\n                if (metaDataBlock != null) {\n                    return (Syntax) metaDataBlock.getMetaData().getMetaData(MetaData.SYNTAX);\n                }\n            }\n        }\n\n        // Fallback on secure and current document in the context\n        if (context.get(\"sdoc\") != null) {\n            // The content document\n            syntax = ((XWikiDocument) context.get(\"sdoc\")).getSyntax();\n        } else if (context.getDoc() != null) {\n            // The context document\n            syntax = context.getDoc().getSyntax();\n        }\n\n        return syntax;\n    }\n\n    /**\n     * @return true if title handling should be using the compatibility mode or not. When the compatibility mode is\n     *         active, if the document's content first header (level 1 or level 2) matches the document's title the\n     *         first header is stripped.\n     */\n    public boolean isTitleInCompatibilityMode()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.title.compatibility\", \"0\"));\n    }\n\n    @Override\n    public void onEvent(Event event, Object source, Object data)\n    {\n        if (event instanceof JobFinishedEvent) {\n            // An extension just been initialized (after an install or upgrade for example)\n            onJobFinished((JobFinishedEvent) event);\n        } else if (event instanceof WikiDeletedEvent) {\n            // A wiki has been deleted\n            onWikiDeletedEvent((WikiDeletedEvent) event);\n        } else if (event instanceof ComponentDescriptorAddedEvent) {\n            // A new mandatory document initializer has been installed\n            onMandatoryDocumentInitializerAdded((ComponentDescriptorAddedEvent) event, (ComponentManager) source);\n        } else {\n            // Document modifications\n\n            XWikiDocument doc = (XWikiDocument) source;\n\n            if (event instanceof XObjectPropertyEvent) {\n                EntityReference reference = ((XObjectPropertyEvent) event).getReference();\n                String modifiedProperty = reference.getName();\n                if (\"backlinks\".equals(modifiedProperty)) {\n                    this.hasBacklinks = doc.getXObject((ObjectReference) reference.getParent()).getIntValue(\"backlinks\",\n                        getConfiguration().getProperty(\"xwiki.backlinks\", 0)) == 1;\n                }\n            }\n        }\n    }\n\n    private void onJobFinished(JobFinishedEvent event)\n    {\n        // Skip it if:\n        // * the authenticator was not yet initialized\n        // * we are using the standard authenticator\n        // * the event is not related to an install job\n        if (this.authService == null || this.authService.getClass() == XWikiAuthServiceImpl.class\n            || !event.getJobType().equals(InstallJob.JOBTYPE)) {\n            return;\n        }\n\n        try {\n            // Get the class corresponding to the configuration\n            Class<? extends XWikiAuthService> authClass = getAuthServiceClass();\n\n            // If the class does not have the same reference anymore it means it's coming from a different classloader\n            // which generally imply that it's coming from an extension which has been reloaded or upgraded\n            if (this.authService.getClass() != authClass) {\n                setAuthService(authClass);\n            }\n        } catch (ClassNotFoundException e) {\n            LOGGER.error(\"Failed to get the class of the configured authenticator, setting standard authenticator.\", e);\n        }\n    }\n\n    private void onWikiDeletedEvent(WikiDeletedEvent event)\n    {\n        this.initializedWikis.remove(event.getWikiId());\n    }\n\n    private void onMandatoryDocumentInitializerAdded(ComponentDescriptorAddedEvent event,\n        ComponentManager componentManager)\n    {\n        String namespace;\n        if (componentManager instanceof NamespacedComponentManager) {\n            namespace = ((NamespacedComponentManager) componentManager).getNamespace();\n        } else {\n            namespace = null;\n        }\n\n        MandatoryDocumentInitializer initializer;\n        try {\n            initializer = componentManager.getInstance(MandatoryDocumentInitializer.class, event.getRoleHint());\n\n            XWikiContext context = getXWikiContext();\n            if (namespace == null) {\n                // Initialize in main wiki\n                initializeMandatoryDocument(context.getMainXWiki(), initializer, context);\n                // Initialize in already initialized sub wikis (will be initialized in others when they are initialized)\n                for (String wiki : this.initializedWikis.keySet()) {\n                    initializeMandatoryDocument(wiki, initializer, context);\n                }\n            } else if (namespace.startsWith(\"wiki:\")) {\n                // Initialize in the wiki where the extension is installed\n                initializeMandatoryDocument(namespace.substring(\"wiki:\".length()), initializer, context);\n            }\n        } catch (ComponentLookupException e) {\n            LOGGER.error(\"Failed to lookup mandatory document initializer\", e);\n        }\n    }\n\n    /**\n     * The reference to match properties \"plugins\" and \"backlinks\" of class XWiki.XWikiPreference on whatever wiki.\n     */\n    private static final RegexEntityReference XWIKIPREFERENCE_PROPERTY_REFERENCE =\n        XWikiPreferencesDocumentInitializer.OBJECT_REFERENCE;\n\n    private static final List<Event> LISTENER_EVENTS =\n        Arrays.<Event>asList(new XObjectPropertyAddedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE),\n            new XObjectPropertyDeletedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE),\n            new XObjectPropertyUpdatedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE), new WikiDeletedEvent(),\n            new ComponentDescriptorAddedEvent(MandatoryDocumentInitializer.class), new JobFinishedEvent());\n\n    @Override\n    public List<Event> getEvents()\n    {\n        return LISTENER_EVENTS;\n    }\n\n    @Override\n    public String getName()\n    {\n        return \"xwiki-core\";\n    }\n\n    /**\n     * Return the document reference to the wiki preferences.\n     *\n     * @param context see {@link XWikiContext}\n     * @since 4.3M2\n     */\n    private DocumentReference getPreferencesDocumentReference(XWikiContext context)\n    {\n        String database = context.getWikiId();\n        EntityReference spaceReference;\n        if (database != null) {\n            spaceReference = new EntityReference(SYSTEM_SPACE, EntityType.SPACE, new WikiReference(database));\n        } else {\n            spaceReference = getCurrentMixedEntityReferenceResolver().resolve(SYSTEM_SPACE, EntityType.SPACE);\n        }\n        return new DocumentReference(\"XWikiPreferences\", new SpaceReference(spaceReference));\n    }\n\n    /**\n     * Search attachments by passing HQL where clause values as parameters. You can specify properties of the \"attach\"\n     * (the attachment) or \"doc\" (the document it is attached to)\n     *\n     * @param parametrizedSqlClause The HQL where clause. For example {@code where doc.fullName\n     *        <> ?1 and (attach.author = ?2 or (attach.filename = ?3 and doc.space = ?4))}\n     * @param checkRight if true, only return attachments in documents which the \"current user\" has permission to view.\n     * @param nb The number of rows to return. If 0 then all rows are returned\n     * @param start The number of rows to skip at the beginning.\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @param context see {@link XWikiContext}\n     * @return A List of {@link XWikiAttachment} objects.\n     * @throws XWikiException in case of error while performing the query\n     * @see com.xpn.xwiki.store.XWikiStoreInterface#searchDocuments(String, int, int, java.util.List, XWikiContext)\n     * @since 5.0M2\n     * @deprecated since 9.7RC1, use the QueryManager instead along with the \"attachment\" query filter\n     */\n    @Deprecated\n    public List<XWikiAttachment> searchAttachments(String parametrizedSqlClause, boolean checkRight, int nb, int start,\n        List<?> parameterValues, XWikiContext context) throws XWikiException\n    {\n        parametrizedSqlClause = parametrizedSqlClause.trim().replaceFirst(\"^and \", \"\").replaceFirst(\"^where \", \"\");\n\n        // Get the attachment filenames and document fullNames\n        List<java.lang.Object[]> results = this.getStore().search(\n            \"select attach.filename, doc.fullName from XWikiAttachment attach, XWikiDocument doc where doc.id = attach.docId and \"\n                + parametrizedSqlClause,\n            nb, start, parameterValues, context);\n\n        HashMap<String, List<String>> filenamesByDocFullName = new HashMap<>();\n\n        // Put each attachment name with the document name it belongs to\n        for (int i = 0; i < results.size(); i++) {\n            String filename = (String) results.get(i)[0];\n            String docFullName = (String) results.get(i)[1];\n            if (!filenamesByDocFullName.containsKey(docFullName)) {\n                filenamesByDocFullName.put(docFullName, new ArrayList<String>());\n            }\n            filenamesByDocFullName.get(docFullName).add(filename);\n        }\n\n        List<XWikiAttachment> out = new ArrayList<>();\n\n        // Index through the document names, get relivent attachments\n        for (Map.Entry<String, List<String>> entry : filenamesByDocFullName.entrySet()) {\n            String fullName = entry.getKey();\n\n            XWikiDocument doc = getDocument(fullName, context);\n            if (checkRight) {\n                if (!context.getWiki().getRightService().hasAccessLevel(\"view\", context.getUser(), doc.getFullName(),\n                    context)) {\n                    continue;\n                }\n            }\n            List<String> returnedAttachmentNames = entry.getValue();\n            for (XWikiAttachment attach : doc.getAttachmentList()) {\n                if (returnedAttachmentNames.contains(attach.getFilename())) {\n                    out.add(attach);\n                }\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Count attachments returned by a given parameterized query\n     *\n     * @param parametrizedSqlClause Everything which would follow the \"WHERE\" in HQL\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @param context see {@link XWikiContext}\n     * @return int number of attachments found.\n     * @throws XWikiException in event of an exception querying the database\n     * @see #searchAttachments(String, boolean, int, int, java.util.List, XWikiContext)\n     * @since 5.0M2\n     */\n    public int countAttachments(String parametrizedSqlClause, List<?> parameterValues, XWikiContext context)\n        throws XWikiException\n    {\n        parametrizedSqlClause = parametrizedSqlClause.trim().replaceFirst(\"^and \", \"\").replaceFirst(\"^where \", \"\");\n\n        List l = getStore().search(\"select count(attach) from XWikiAttachment attach, XWikiDocument doc where \"\n            + \"attach.docId=doc.id and \" + parametrizedSqlClause, 0, 0, parameterValues, context);\n        return ((Number) l.get(0)).intValue();\n    }\n\n    // Deprecated\n\n    /**\n     * @deprecated since 6.1M2, use {@link XWikiCfgConfigurationSource#getConfigPath()} instead\n     */\n    @Deprecated\n    public static String getConfigPath() throws NamingException\n    {\n        return XWikiCfgConfigurationSource.getConfigPath();\n    }\n\n    /**\n     * @deprecated since 6.1M3, use {@link #XWiki(XWikiContext)} instead\n     */\n    @Deprecated\n    public XWiki(XWikiConfig config, XWikiContext context) throws XWikiException\n    {\n        this(config, context, null, false);\n    }\n\n    /**\n     * @deprecated since 6.1M3, use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(XWikiConfig config, XWikiContext context, XWikiEngineContext engine_context, boolean noupdate)\n        throws XWikiException\n    {\n        initXWiki(config, context, engine_context, noupdate);\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext)} instead\n     */\n    @Deprecated\n    public XWiki(String xwikicfgpath, XWikiContext context) throws XWikiException\n    {\n        this(xwikicfgpath, context, null, false);\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(String xwikicfgpath, XWikiContext context, XWikiEngineContext engine_context, boolean noupdate)\n        throws XWikiException\n    {\n        try {\n            initXWiki(new XWikiConfig(new FileInputStream(xwikicfgpath)), context, engine_context, noupdate);\n        } catch (FileNotFoundException e) {\n            Object[] args = { xwikicfgpath };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_CONFIG, XWikiException.ERROR_XWIKI_CONFIG_FILENOTFOUND,\n                \"Configuration file {0} not found\", e, args);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(InputStream is, XWikiContext context, XWikiEngineContext engine_context) throws XWikiException\n    {\n        initXWiki(new XWikiConfig(is), context, engine_context, true);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public XWikiConfig getConfig()\n    {\n        return new XWikiConfigDelegate(getConfiguration());\n    }\n\n    /**\n     * @deprecated since 6.1M2\n     */\n    @Deprecated\n    public void setConfig(XWikiConfig config)\n    {\n        ConfigurationSource configuration = getConfiguration();\n\n        if (configuration instanceof XWikiCfgConfigurationSource) {\n            ((XWikiCfgConfigurationSource) configuration).set(config);\n        }\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public String Param(String key)\n    {\n        return Param(key, null);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public String Param(String key, String default_value)\n    {\n        if (getConfiguration() != null) {\n            return getConfiguration().getProperty(key, default_value);\n        }\n\n        return default_value;\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public long ParamAsLong(String key)\n    {\n        return getConfiguration().getProperty(key, long.class);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public long ParamAsLong(String key, long default_value)\n    {\n        return getConfiguration().getProperty(key, default_value);\n    }\n\n    /**\n     * @return true if the wiki is in path based mode, fale otherwise\n     * @since 11.9RC1\n     */\n    public boolean isPathBased()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.virtual.usepath\", \"1\"));\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.api;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.job.Job;\nimport org.xwiki.job.event.status.JobStatus;\nimport org.xwiki.job.event.status.JobStatus.State;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.rendering.renderer.PrintRendererFactory;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.XWikiInitializerJob;\nimport com.xpn.xwiki.internal.XWikiInitializerJobStatus;\nimport com.xpn.xwiki.objects.meta.MetaClass;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.util.Programming;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiEngineContext;\nimport com.xpn.xwiki.web.XWikiURLFactory;\n\npublic class XWiki extends Api\n{\n    /** Logging helper object. */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);\n\n    /** The internal object wrapped by this API. */\n    private com.xpn.xwiki.XWiki xwiki;\n\n    /**\n     * @see #getStatsService()\n     */\n    private StatsService statsService;\n\n    /**\n     * @see #getCriteriaService()\n     */\n    private CriteriaService criteriaService;\n\n    /**\n     * @see com.xpn.xwiki.internal.model.reference.CurrentMixedStringDocumentReferenceResolver\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    /**\n     * @see org.xwiki.model.internal.reference.DefaultStringDocumentReferenceResolver\n     */\n    private DocumentReferenceResolver<String> defaultDocumentReferenceResolver;\n\n    /**\n     * The object used to serialize entity references into strings. We need it because we have script APIs that work\n     * with entity references but have to call older, often internal, methods that still use string references.\n     */\n    private EntityReferenceSerializer<String> defaultStringEntityReferenceSerializer;\n\n    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;\n\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private ContextualAuthorizationManager contextualAuthorizationManager;\n\n    /**\n     * XWiki API Constructor\n     *\n     * @param xwiki XWiki Main Object to wrap\n     * @param context XWikiContext to wrap\n     */\n    public XWiki(com.xpn.xwiki.XWiki xwiki, XWikiContext context)\n    {\n        super(context);\n\n        this.xwiki = xwiki;\n        this.statsService = new StatsService(context);\n        this.criteriaService = new CriteriaService(context);\n    }\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (this.currentMixedDocumentReferenceResolver == null) {\n            this.currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedDocumentReferenceResolver;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentgetdocumentResolver()\n    {\n        if (this.currentgetdocumentResolver == null) {\n            this.currentgetdocumentResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");\n        }\n\n        return this.currentgetdocumentResolver;\n    }\n\n    private DocumentReferenceResolver<String> getDefaultDocumentReferenceResolver()\n    {\n        if (this.defaultDocumentReferenceResolver == null) {\n            this.defaultDocumentReferenceResolver = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING);\n        }\n\n        return this.defaultDocumentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getDefaultStringEntityReferenceSerializer()\n    {\n        if (this.defaultStringEntityReferenceSerializer == null) {\n            this.defaultStringEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultStringEntityReferenceSerializer;\n    }\n\n    private DocumentRevisionProvider getDocumentRevisionProvider()\n    {\n        if (this.documentRevisionProvider == null) {\n            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);\n        }\n\n        return this.documentRevisionProvider;\n    }\n\n    /**\n     * Privileged API allowing to access the underlying main XWiki Object\n     *\n     * @return Privileged Main XWiki Object\n     */\n    @Programming\n    public com.xpn.xwiki.XWiki getXWiki()\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki;\n        }\n\n        return null;\n    }\n\n    /**\n     * @return the status of the job initializing {@link com.xpn.xwiki.XWiki} instance\n     * @since 6.1M1\n     */\n    public XWikiInitializerJobStatus getJobStatus()\n    {\n        XWikiInitializerJob job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);\n\n        return job != null ? job.getStatus() : null;\n    }\n\n    /**\n     * @return the status of the job initializing the instance or the current wiki\n     * @since 8.4RC1\n     */\n    public JobStatus getCurrentInitializerJobStatus()\n    {\n        // Get XWiki initializer job\n        JobStatus jobStatus = getJobStatus();\n\n        if (jobStatus == null) {\n            return null;\n        }\n\n        // The XWiki initialization is not done yet\n        if (jobStatus.getState() != State.FINISHED) {\n            return jobStatus;\n        }\n\n        // If XWiki initialization did not failed\n        if (this.xwiki != null) {\n            // Get current wiki initializer job\n            Job wikiJob = this.xwiki.getWikiInitializerJob(this.context.getWikiId());\n\n            jobStatus = wikiJob != null ? wikiJob.getStatus() : null;\n        }\n\n        return jobStatus;\n    }\n\n    /**\n     * @return XWiki's version in the format <code>(version).(SVN build number)</code>, or \"Unknown version\" if it\n     *         failed to be retrieved\n     */\n    public String getVersion()\n    {\n        return this.xwiki.getVersion();\n    }\n\n    /**\n     * API Allowing to access the current request URL being requested.\n     *\n     * @return the URL\n     * @throws XWikiException failed to create the URL\n     */\n    public String getRequestURL() throws XWikiException\n    {\n        return getXWikiContext().getURLFactory().getRequestURL(getXWikiContext()).toString();\n    }\n\n    /**\n     * API Allowing to access the current request URL being requested as a relative URL.\n     *\n     * @return the URL\n     * @throws XWikiException failed to create the URL\n     * @since 4.0M1\n     */\n    public String getRelativeRequestURL() throws XWikiException\n    {\n        XWikiURLFactory urlFactory = getXWikiContext().getURLFactory();\n\n        return urlFactory.getURL(urlFactory.getRequestURL(getXWikiContext()), getXWikiContext());\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked before sending back the document.\n     * <p>\n     * This is a helper for document reference but you can use {@link #getEntityDocument(String, EntityType)} for any\n     * other kind of reference.\n     *\n     * @param documentReference the reference of the document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @see #getEntityDocument(String, EntityType)\n     */\n    public Document getDocument(String documentReference) throws XWikiException\n    {\n        DocumentReference reference;\n\n        // We ignore the passed full name if it's null to be backward compatible with previous behaviors.\n        if (documentReference != null) {\n            // Note: We use the CurrentMixed Resolver since we want to use the default page name if the page isn't\n            // specified in the passed string, rather than use the current document's page name.\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(documentReference);\n        } else {\n            reference = getDefaultDocumentReferenceResolver().resolve(\"\");\n        }\n\n        return getDocument(reference);\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked before sending back the document.\n     *\n     * @param reference the reference of the document to be loaded\n     * @param type the type of the reference\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 10.6RC1\n     */\n    public Document getEntityDocument(String reference, EntityType type) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(reference, type, getXWikiContext());\n        if (!getContextualAuthorizationManager().hasAccess(Right.VIEW, doc.getDocumentReference())) {\n            return null;\n        }\n\n        return doc.newDocument(getXWikiContext());\n    }\n\n    /**\n     * Loads a Document from the database. Rights are checked before sending back the document.\n     *\n     * @param reference the reference of the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 2.3M1\n     */\n    public Document getDocument(DocumentReference reference) throws XWikiException\n    {\n        try {\n            XWikiDocument doc = this.xwiki.getDocument(reference, getXWikiContext());\n            if (this.xwiki.getRightService().hasAccessLevel(\"view\", getXWikiContext().getUser(),\n                doc.getPrefixedFullName(), getXWikiContext()) == false) {\n                return null;\n            }\n\n            return doc.newDocument(getXWikiContext());\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to access document [{}]. Root reason: [{}]\", reference,\n                ExceptionUtils.getRootCauseMessage(ex));\n            return new Document(new XWikiDocument(reference), getXWikiContext());\n        }\n    }\n\n    /**\n     * Loads a Document from the store. Rights are checked before sending back the document.\n     * <p>\n     * The passed reference can be anything. If if a document child, the document reference will be extracted from it.\n     * If it's a document parent it will be completed with the necessary default references (for example if it's a space\n     * reference it will load the space home page).\n     *\n     * @param reference the reference close to the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 7.1M2\n     */\n    public Document getDocument(EntityReference reference) throws XWikiException\n    {\n        return getDocument(this.xwiki.getDocumentReference(reference, getXWikiContext()));\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked on the author (contentAuthor) of the document containing\n     * the currently executing script before sending back the loaded document.\n     *\n     * @param fullName the full name of the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 2.3M2\n     */\n    public Document getDocumentAsAuthor(String fullName) throws XWikiException\n    {\n        DocumentReference reference;\n\n        // We ignore the passed full name if it's null to match behavior of getDocument\n        if (fullName != null) {\n            // Note: We use the CurrentMixed Resolver since we want to use the default page name if the page isn't\n            // specified in the passed string, rather than use the current document's page name.\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);\n        } else {\n            reference = getDefaultDocumentReferenceResolver().resolve(\"\");\n        }\n\n        return getDocumentAsAuthor(reference);\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked on the author (contentAuthor) of the document containing\n     * the currently executing script before sending back the loaded document.\n     *\n     * @param reference the reference of the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 2.3M2\n     */\n    public Document getDocumentAsAuthor(DocumentReference reference) throws XWikiException\n    {\n        if (!getAuthorizationManager().hasAccess(Right.VIEW, getEffectiveAuthorReference(), reference)) {\n            return null;\n        }\n\n        return this.xwiki.getDocument(reference, getXWikiContext()).newDocument(getXWikiContext());\n    }\n\n    /**\n     * @param fullname the {@link XWikiDocument#getFullName() name} of the document to search for.\n     * @param locale an optional {@link XWikiDocument#getLocale() locale} to filter results.\n     * @return A list with all the deleted versions of a document in the recycle bin.\n     * @throws XWikiException if any error\n     */\n    public List<DeletedDocument> getDeletedDocuments(String fullname, String locale) throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = this.xwiki.getDeletedDocuments(fullname, locale, this.context);\n        List<DeletedDocument> result = wrapDeletedDocuments(deletedDocuments);\n        return result;\n    }\n\n    /**\n     * @param batchId id of the operation that deleted multiple documents at the same time; useful when trying to revert\n     *            the operation\n     * @return a list of all document versions that were deleted in the same batch, as part of the same operation\n     * @throws XWikiException if any error\n     * @since 9.4RC1\n     */\n    public List<DeletedDocument> getDeletedDocuments(String batchId) throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = this.xwiki.getDeletedDocuments(batchId, this.context);\n        List<DeletedDocument> result = wrapDeletedDocuments(deletedDocuments);\n        return result;\n    }\n\n    private List<DeletedDocument> wrapDeletedDocuments(XWikiDeletedDocument[] deletedDocuments)\n    {\n        if (deletedDocuments == null || deletedDocuments.length == 0) {\n            return Collections.emptyList();\n        }\n\n        List<DeletedDocument> result = new ArrayList<>(deletedDocuments.length);\n        for (XWikiDeletedDocument deletedDocument : deletedDocuments) {\n            result.add(new DeletedDocument(deletedDocument, this.context));\n        }\n\n        return result;\n    }\n\n    /**\n     * @param fullname - {@link XWikiDocument#getFullName()}\n     * @param locale - {@link XWikiDocument#getLocale()}\n     * @param index - {@link XWikiDocument#getId()}\n     * @return the specified document from the recycle bin\n     * @throws XWikiException if any error\n     * @deprecated since 9.4RC1. Use {@link #getDeletedDocument(String)} instead.\n     */\n    @Deprecated\n    public DeletedDocument getDeletedDocument(String fullname, String locale, String index) throws XWikiException\n    {\n        return getDeletedDocument(index);\n    }\n\n    /**\n     * @return the specified document from the recycle bin\n     * @throws XWikiException if any error\n     * @since 9.4RC1\n     */\n    public DeletedDocument getDeletedDocument(String index) throws XWikiException\n    {\n        if (!NumberUtils.isDigits(index)) {\n            return null;\n        }\n\n        XWikiDeletedDocument dd = this.xwiki.getDeletedDocument(Long.parseLong(index), this.context);\n        if (dd == null) {\n            return null;\n        }\n\n        return new DeletedDocument(dd, this.context);\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document. Note that this does not distinguish\n     * between different incarnations of a document name, and it does not require that the document still exists, it\n     * returns all the attachments that at the time of their deletion had a document with the specified name as their\n     * owner.\n     *\n     * @param docName the {@link XWikiDocument#getFullName() name} of the owner document\n     * @return A list with all the deleted attachments which belonged to the specified document. If no such attachments\n     *         are found in the trash, an empty list is returned.\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName)\n    {\n        try {\n            List<com.xpn.xwiki.doc.DeletedAttachment> attachments =\n                this.xwiki.getDeletedAttachments(docName, this.context);\n            if (attachments == null || attachments.isEmpty()) {\n                attachments = Collections.emptyList();\n            }\n            List<DeletedAttachment> result = new ArrayList<DeletedAttachment>(attachments.size());\n            for (com.xpn.xwiki.doc.DeletedAttachment attachment : attachments) {\n                result.add(new DeletedAttachment(attachment, this.context));\n            }\n            return result;\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to retrieve deleted attachments\", ex);\n        }\n        return Collections.emptyList();\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document and had the specified name. Multiple\n     * versions can be returned since the same file can be uploaded and deleted several times, creating different\n     * instances in the trash. Note that this does not distinguish between different incarnations of a document name,\n     * and it does not require that the document still exists, it returns all the attachments that at the time of their\n     * deletion had a document with the specified name as their owner.\n     *\n     * @param docName the {@link DeletedAttachment#getDocName() name of the document} the attachment belonged to\n     * @param filename the {@link DeletedAttachment#getFilename() name} of the attachment to search for\n     * @return A list with all the deleted attachments which belonged to the specified document and had the specified\n     *         filename. If no such attachments are found in the trash, an empty list is returned.\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, String filename)\n    {\n        try {\n            List<com.xpn.xwiki.doc.DeletedAttachment> attachments =\n                this.xwiki.getDeletedAttachments(docName, filename, this.context);\n            if (attachments == null) {\n                attachments = Collections.emptyList();\n            }\n            List<DeletedAttachment> result = new ArrayList<DeletedAttachment>(attachments.size());\n            for (com.xpn.xwiki.doc.DeletedAttachment attachment : attachments) {\n                result.add(new DeletedAttachment(attachment, this.context));\n            }\n            return result;\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to retrieve deleted attachments\", ex);\n        }\n        return Collections.emptyList();\n    }\n\n    /**\n     * Retrieve a specific attachment from the trash.\n     *\n     * @param id the unique identifier of the entry in the trash\n     * @return specified attachment from the trash, {@code null} if not found\n     */\n    public DeletedAttachment getDeletedAttachment(String id)\n    {\n        try {\n            com.xpn.xwiki.doc.DeletedAttachment attachment = this.xwiki.getDeletedAttachment(id, this.context);\n            if (attachment != null) {\n                return new DeletedAttachment(attachment, this.context);\n            }\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to retrieve deleted attachment\", ex);\n        }\n        return null;\n    }\n\n    /**\n     * Returns whether a document exists or not\n     *\n     * @param fullname Fullname of the XWiki document to be loaded\n     * @return true if the document exists, false if not\n     * @throws XWikiException\n     */\n    public boolean exists(String fullname) throws XWikiException\n    {\n        return this.xwiki.exists(fullname, getXWikiContext());\n    }\n\n    /**\n     * Returns whether a document exists or not\n     *\n     * @param reference the reference of the document to check for its existence\n     * @return true if the document exists, false if not\n     * @since 2.3M2\n     */\n    public boolean exists(DocumentReference reference) throws XWikiException\n    {\n        return this.xwiki.exists(reference, getXWikiContext());\n    }\n\n    /**\n     * Returns whether a page exists or not.\n     *\n     * @param reference the reference of the page to check for its existence\n     * @return true if the page exists, false if not\n     * @since 13.3RC1\n     * @since 12.10.7\n     */\n    @Unstable\n    public boolean exists(PageReference reference)\n    {\n        return this.xwiki.exists(reference, getXWikiContext());\n    }\n\n    /**\n     * Verify the rights the current user has on a document. If the document requires rights and the user is not\n     * authenticated he will be redirected to the login page.\n     *\n     * @param docname fullname of the document\n     * @param right right to check (\"view\", \"edit\", \"admin\", \"delete\")\n     * @return true if it exists\n     */\n    public boolean checkAccess(String docname, String right)\n    {\n        try {\n            DocumentReference docReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);\n            XWikiDocument doc = getXWikiContext().getWiki().getDocument(docReference, this.context);\n            return getXWikiContext().getWiki().checkAccess(right, doc, getXWikiContext());\n        } catch (XWikiException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked before sending back the document.\n     *\n     * @param space Space to use in case no space is defined in the provided <code>fullname</code>\n     * @param fullname the full name or relative name of the document to load\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     */\n    public Document getDocument(String space, String fullname) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(space, fullname, getXWikiContext());\n        if (this.xwiki.getRightService().hasAccessLevel(\"view\", getXWikiContext().getUser(), doc.getFullName(),\n            getXWikiContext()) == false) {\n            return null;\n        }\n\n        return doc.newDocument(getXWikiContext());\n    }\n\n    /**\n     * Load a specific revision of a document\n     *\n     * @param doc Document for which to load a specific revision\n     * @param rev Revision number\n     * @return Specific revision of a document\n     * @throws XWikiException is never thrown\n     */\n    public Document getDocument(Document doc, String rev) throws XWikiException\n    {\n        if (doc == null || doc.getDoc() == null) {\n            return null;\n        }\n\n        if (!getContextualAuthorizationManager().hasAccess(Right.VIEW, doc.getDocumentReference())) {\n            // Finally we return null, otherwise showing search result is a real pain\n            return null;\n        }\n\n        return doc.getDocumentRevision(rev);\n    }\n\n    /**\n     * Load a specific revision of a document\n     *\n     * @param reference Document for which to load a specific revision\n     * @param revision Revision number\n     * @return Specific revision of a document\n     * @throws XWikiException is never thrown\n     * @since 9.4RC1\n     */\n    public Document getDocument(DocumentReference reference, String revision) throws XWikiException\n    {\n        try {\n            if (reference != null && getContextualAuthorizationManager().hasAccess(Right.VIEW, reference)) {\n                XWikiDocument documentRevision = getDocumentRevisionProvider().getRevision(reference, revision);\n\n                if (documentRevision != null) {\n                    return new Document(documentRevision, this.context);\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to access revision [{}] of document {}\", revision, reference, e);\n        }\n\n        return null;\n    }\n\n    /**\n     * Output content in the edit content textarea\n     *\n     * @param content content to output\n     * @return the textarea text content\n     */\n    public String getTextArea(String content)\n    {\n        return com.xpn.xwiki.XWiki.getTextArea(content, getXWikiContext());\n    }\n\n    /**\n     * Get the list of available classes in the wiki\n     *\n     * @return list of classes names\n     * @throws XWikiException\n     */\n    public List<String> getClassList() throws XWikiException\n    {\n        return this.xwiki.getClassList(getXWikiContext());\n    }\n\n    /**\n     * Get the global MetaClass object\n     *\n     * @return MetaClass object\n     */\n    public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }\n\n    /**\n     * API allowing to search for document names matching a query. Examples:\n     * <ul>\n     * <li>Query: <code>where doc.space='Main' order by doc.creationDate desc</code>. Result: All the documents in space\n     * 'Main' ordered by the creation date from the most recent</li>\n     * <li>Query: <code>where doc.name like '%sport%' order by doc.name asc</code>. Result: All the documents containing\n     * 'sport' in their name ordered by document name</li>\n     * <li>Query: <code>where doc.content like '%sport%' order by doc.author</code> Result: All the documents containing\n     * 'sport' in their content ordered by the author</li>\n     * <li>Query: <code>where doc.creator = 'XWiki.LudovicDubost' order by doc.creationDate\n     *       desc</code>. Result: All the documents with creator LudovicDubost ordered by the creation date from the\n     * most recent</li>\n     * <li>Query: <code>where doc.author = 'XWiki.LudovicDubost' order by doc.date desc</code>. Result: All the\n     * documents with last author LudovicDubost ordered by the last modification date from the most recent.</li>\n     * <li>Query: <code>,BaseObject as obj where doc.fullName=obj.name and\n     *       obj.className='XWiki.XWikiComments' order by doc.date desc</code>. Result: All the documents with at least\n     * one comment ordered by the last modification date from the most recent</li>\n     * <li>Query: <code>,BaseObject as obj, StringProperty as prop where\n     *       doc.fullName=obj.name and obj.className='XWiki.XWikiComments' and obj.id=prop.id.id\n     *       and prop.id.name='author' and prop.value='XWiki.LudovicDubost' order by doc.date\n     *       desc</code>. Result: All the documents with at least one comment from LudovicDubost ordered by the last\n     * modification date from the most recent</li>\n     * </ul>\n     *\n     * @param wheresql Query to be run (either starting with \", BaseObject as obj where..\" or by \"where ...\"\n     * @return List of document names matching (Main.Page1, Main.Page2)\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String wheresql) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(wheresql, getXWikiContext());\n    }\n\n    /**\n     * API allowing to search for document names matching a query return only a limited number of elements and skipping\n     * the first rows. The query part is the same as searchDocuments\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param nb return only 'nb' rows\n     * @param start skip the first 'start' rows\n     * @return List of document names matching\n     * @throws XWikiException\n     * @see List searchDocuments(String where sql)\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String wheresql, int nb, int start) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(wheresql, nb, start, getXWikiContext());\n    }\n\n    /**\n     * Privileged API allowing to search for document names matching a query return only a limited number of elements\n     * and skipping the first rows. The return values contain the list of columns specified in addition to the document\n     * space and name The query part is the same as searchDocuments\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param nb return only 'nb' rows\n     * @param start skip the first 'start' rows\n     * @param selectColumns List of columns to add to the result\n     * @return List of Object[] with the column values of the matching rows\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String wheresql, int nb, int start, String selectColumns) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.getStore().searchDocumentsNames(wheresql, nb, start, selectColumns, getXWikiContext());\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * API allowing to search for documents allowing to have mutliple entries per locale\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param distinctbylocale true to return multiple rows per locale\n     * @return List of Document object matching\n     * @throws XWikiException\n     */\n    public List<Document> searchDocuments(String wheresql, boolean distinctbylocale) throws XWikiException\n    {\n        return convert(this.xwiki.getStore().searchDocuments(wheresql, distinctbylocale, getXWikiContext()));\n    }\n\n    /**\n     * API allowing to search for documents allowing to have multiple entries per locale\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param distinctbylocale true to return multiple rows per locale\n     * @return List of Document object matching\n     * @param nb return only 'nb' rows\n     * @param start skip the first 'start' rows\n     * @throws XWikiException\n     */\n    public List<Document> searchDocuments(String wheresql, boolean distinctbylocale, int nb, int start)\n        throws XWikiException\n    {\n        return convert(this.xwiki.getStore().searchDocuments(wheresql, distinctbylocale, nb, start, getXWikiContext()));\n    }\n\n    /**\n     * Search documents by passing HQL where clause values as parameters. This allows generating a Named HQL query which\n     * will automatically encode the passed values (like escaping single quotes). This API is recommended to be used\n     * over the other similar methods where the values are passed inside the where clause and for which you'll need to\n     * do the encoding/escaping yourself before calling them.\n     * <p>\n     * Example\n     * </p>\n     *\n     * <pre>\n     * &lt;code&gt;\n     * #set($orphans = $xwiki.searchDocuments(&quot; where doc.fullName &lt;&gt; ?1 and (doc.parent = ?2 or &quot;\n     *     + &quot;(doc.parent = ?3 and doc.space = ?4))&quot;,\n     *     [&quot;${doc.fullName}as&quot;, ${doc.fullName}, ${doc.name}, ${doc.space}]))\n     * &lt;/code&gt;\n     * </pre>\n     *\n     * @param parameterizedWhereClause the HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param maxResults the number of rows to return. If 0 then all rows are returned\n     * @param startOffset the number of rows to skip. If 0 don't skip any row\n     * @param parameterValues the where clause values that replace the question marks (?1, ?2, etc.)\n     * @return a list of document names\n     * @throws XWikiException in case of error while performing the query\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, int maxResults, int startOffset,\n        List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, maxResults, startOffset,\n            parameterValues, getXWikiContext());\n    }\n\n    /**\n     * Same as {@link #searchDocuments(String, int, int, java.util.List)} but returns all rows.\n     *\n     * @see #searchDocuments(String, int, int, java.util.List)\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }\n\n    /**\n     * Search documents in the provided wiki by passing HQL where clause values as parameters. See\n     * {@link #searchDocuments(String, int, int, java.util.List)} for more details.\n     *\n     * @param wikiName the name of the wiki where to search.\n     * @param parameterizedWhereClause the HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param maxResults the number of rows to return. If 0 then all rows are returned\n     * @param startOffset the number of rows to skip. If 0 don't skip any row\n     * @param parameterValues the where clause values that replace the question marks (?)\n     * @return a list of document full names (Space.Name).\n     * @see #searchDocuments(String, int, int, java.util.List)\n     * @throws XWikiException in case of error while performing the query\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }\n\n    /**\n     * Search spaces by passing HQL where clause values as parameters. See\n     * {@link #searchDocuments(String, int, int, List)} for more about parameterized hql clauses.\n     *\n     * @param parametrizedSqlClause the HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param nb the number of rows to return. If 0 then all rows are returned\n     * @param start the number of rows to skip. If 0 don't skip any row\n     * @param parameterValues the where clause values that replace the question marks (?)\n     * @return a list of spaces names.\n     * @throws XWikiException in case of error while performing the query\n     */\n    public List<String> searchSpacesNames(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parametrizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }\n\n    /**\n     * Search attachments by passing HQL where clause values as parameters. See\n     * {@link #searchDocuments(String, int, int, List)} for more about parameterized hql clauses. You can specify\n     * properties of attach (the attachment) or doc (the document it is attached to)\n     *\n     * @param parametrizedSqlClause The HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param nb The number of rows to return. If 0 then all rows are returned\n     * @param start The number of rows to skip at the beginning.\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @return A List of {@link Attachment} objects.\n     * @throws XWikiException in case of error while performing the query\n     * @since 5.0M2\n     */\n    public List<Attachment> searchAttachments(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return convertAttachments(\n            this.xwiki.searchAttachments(parametrizedSqlClause, true, nb, start, parameterValues, this.context));\n    }\n\n    /**\n     * Count attachments returned by a given parameterized query\n     *\n     * @param parametrizedSqlClause Everything which would follow the \"WHERE\" in HQL see:\n     *            {@link #searchDocuments(String, int, int, List)}\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @return int number of attachments found.\n     * @throws XWikiException\n     * @see #searchAttachments(String, int, int, List)\n     * @since 5.0M2\n     */\n    public int countAttachments(String parametrizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.countAttachments(parametrizedSqlClause, parameterValues, this.context);\n    }\n\n    /**\n     * Function to wrap a list of XWikiDocument into Document objects\n     *\n     * @param docs list of XWikiDocument\n     * @return list of Document objects\n     */\n    public List<Document> wrapDocs(List<?> docs)\n    {\n        List<Document> result = new ArrayList<Document>();\n        if (docs != null) {\n            for (java.lang.Object obj : docs) {\n                try {\n                    if (obj instanceof XWikiDocument) {\n                        XWikiDocument doc = (XWikiDocument) obj;\n                        Document wrappedDoc = doc.newDocument(getXWikiContext());\n                        result.add(wrappedDoc);\n                    } else if (obj instanceof Document) {\n                        result.add((Document) obj);\n                    } else if (obj instanceof String) {\n                        Document doc = getDocument(obj.toString());\n                        if (doc != null) {\n                            result.add(doc);\n                        }\n                    }\n                } catch (XWikiException ex) {\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * API allowing to parse a text content to evaluate velocity scripts\n     *\n     * @param content\n     * @return evaluated content if the content contains velocity scripts\n     * @deprecated Since 7.2M1. Use specific rendering/parsing options for the content type you want to parse/render.\n     */\n    @Deprecated\n    public String parseContent(String content)\n    {\n        return this.xwiki.parseContent(content, getXWikiContext());\n    }\n\n    /**\n     * API to parse a velocity template provided by the current Skin The template is first looked in the skin active for\n     * the user, the space or the wiki. If the template does not exist in that skin, the template is looked up in the\n     * \"parent skin\" of the skin\n     *\n     * @param template Template name (\"view\", \"edit\", \"comment\")\n     * @return Evaluated content from the template\n     */\n    public String parseTemplate(String template)\n    {\n        return this.xwiki.parseTemplate(template, getXWikiContext());\n    }\n\n    /**\n     * API to render a velocity template provided by the current Skin The template is first looked in the skin active\n     * for the user, the space or the wiki. If the template does not exist in that skin, the template is looked up in\n     * the \"parent skin\" of the skin\n     *\n     * @param template Template name (\"view\", \"edit\", \"comment\")\n     * @return Evaluated content from the template\n     */\n    public String renderTemplate(String template)\n    {\n        return this.xwiki.renderTemplate(template, getXWikiContext());\n    }\n\n    /**\n     * Designed to include dynamic content, such as Servlets or JSPs, inside Velocity templates; works by creating a\n     * RequestDispatcher, buffering the output, then returning it as a string.\n     *\n     * @param url URL of the servlet\n     * @return text result of the servlet\n     */\n    public String invokeServletAndReturnAsString(String url)\n    {\n        return this.xwiki.invokeServletAndReturnAsString(url, getXWikiContext());\n    }\n\n    /**\n     * Return the URL of the static file provided by the current skin The file is first looked in the skin active for\n     * the user, the space or the wiki. If the file does not exist in that skin, the file is looked up in the \"parent\n     * skin\" of the skin. The file can be a CSS file, an image file, a javascript file, etc.\n     *\n     * @param filename Filename to be looked up in the skin (logo.gif, style.css)\n     * @return URL to access this file\n     */\n    public String getSkinFile(String filename)\n    {\n        return this.xwiki.getSkinFile(filename, getXWikiContext());\n    }\n\n    /**\n     * Return the URL of the static file provided by the current skin The file is first looked in the skin active for\n     * the user, the space or the wiki. If the file does not exist in that skin, the file is looked up in the \"parent\n     * skin\" of the skin. The file can be a CSS file, an image file, a javascript file, etc.\n     *\n     * @param filename Filename to be looked up in the skin (logo.gif, style.css)\n     * @param forceSkinAction true to make sure that static files are retrieved through the skin action, to allow\n     *            parsing of velocity on CSS files\n     * @return URL to access this file\n     */\n    public String getSkinFile(String filename, boolean forceSkinAction)\n    {\n        return this.xwiki.getSkinFile(filename, forceSkinAction, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the current skin for this request and user The skin is first derived from the request \"skin\"\n     * parameter If this parameter does not exist, the user preference \"skin\" is looked up If this parameter does not\n     * exist or is empty, the space preference \"skin\" is looked up If this parameter does not exist or is empty, the\n     * XWiki preference \"skin\" is looked up If this parameter does not exist or is empty, the xwiki.cfg parameter\n     * xwiki.defaultskin is looked up If this parameter does not exist or is empty, the xwiki.cfg parameter\n     * xwiki.defaultbaseskin is looked up If this parameter does not exist or is empty, the skin is \"colibri\"\n     *\n     * @return The current skin for this request and user\n     */\n    public String getSkin()\n    {\n        return this.xwiki.getSkin(getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the current skin for this request and user. Each skin has a skin it is based on. If not the base\n     * skin is the xwiki.cfg parameter \"xwiki.defaultbaseskin\". If this parameter does not exist or is empty, the base\n     * skin is \"colibri\".\n     *\n     * @return The current baseskin for this request and user\n     */\n    public String getBaseSkin()\n    {\n        return this.xwiki.getBaseSkin(getXWikiContext());\n    }\n\n    /**\n     * API to access the copyright for this space. The copyright is read in the space preferences. If it does not exist\n     * or is empty it is read from the XWiki preferences.\n     *\n     * @return the text for the copyright\n     */\n    public String getSpaceCopyright()\n    {\n        return this.xwiki.getSpaceCopyright(getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getXWikiPreference(String preference)\n    {\n        return this.xwiki.getXWikiPreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale\n     */\n    public String getXWikiPreference(String preference, String defaultValue)\n    {\n        return this.xwiki.getXWikiPreference(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an Space Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale If no preference is found it will look in the XWiki\n     * Preferences\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getSpacePreference(String preference)\n    {\n        return this.xwiki.getSpacePreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access an Space Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale If no preference is found it will look in the XWiki\n     * Preferences\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale\n     */\n    public String getSpacePreference(String preference, String defaultValue)\n    {\n        return this.xwiki.getSpacePreference(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access a Skin Preference The skin object is the current user's skin\n     *\n     * @param preference Preference name\n     * @return The preference for the current skin\n     */\n    public String getSkinPreference(String preference)\n    {\n        return this.xwiki.getSkinPreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a Skin Preference The skin object is the current user's skin\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for the current skin\n     */\n    public String getSkinPreference(String preference, String defaultValue)\n    {\n        return this.xwiki.getSkinPreference(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then empty String is returned.\n     *\n     * @param preference Preference name\n     * @param space The space for which this preference is requested\n     * @return The preference for this wiki and the current locale\n     */\n    public String getSpacePreferenceFor(String preference, String space)\n    {\n        return getSpacePreferenceFor(preference, space, \"\");\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then <code>defaultValue</code> is returned.\n     *\n     * @param preference Preference name\n     * @param space The space for which this preference is requested\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public String getSpacePreferenceFor(String preference, String space, String defaultValue)\n    {\n        return this.xwiki.getSpacePreference(preference, space, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then empty String is returned.\n     * \n     * @param preference the name of the preference key\n     * @param spaceReference the reference of the space\n     * @return the value of the preference or empty String if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreferenceFor(String preference, SpaceReference spaceReference)\n    {\n        return this.xwiki.getSpacePreference(preference, spaceReference, getXWikiContext());\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then <code>defaultValue</code> is returned.\n     * \n     * @param preference the name of the preference key\n     * @param spaceReference the reference of the space\n     * @param defaultValue the value to return if the preference can't be found\n     * @return the value of the preference or <code>defaultValue</code> if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreferenceFor(String preference, SpaceReference spaceReference, String defaultValue)\n    {\n        return this.xwiki.getSpacePreference(preference, spaceReference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getXWikiPreferenceAsLong(String preference, long defaultValue)\n    {\n        return this.xwiki.getXWikiPreferenceAsLong(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getXWikiPreferenceAsLong(String preference)\n    {\n        return this.xwiki.getXWikiPreferenceAsLong(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a Space Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale If no preference is found it will\n     * look for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the prefenrece does not exist or is empty\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getSpacePreferenceAsLong(String preference, long defaultValue)\n    {\n        return this.xwiki.getSpacePreferenceAsLong(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access a Space Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale If no preference is found it will\n     * look for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getSpacePreferenceAsLong(String preference)\n    {\n        return this.xwiki.getSpacePreferenceAsLong(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as an int number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the prefenrece does not exist or is empty\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getXWikiPreferenceAsInt(String preference, int defaultValue)\n    {\n        return this.xwiki.getXWikiPreferenceAsInt(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as a int number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getXWikiPreferenceAsInt(String preference)\n    {\n        return this.xwiki.getXWikiPreferenceAsInt(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a space Preference as a int number There can be one preference object per locale This function will\n     * find the right preference object associated to the current active locale If no preference is found it will look\n     * for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the prefenrece does not exist or is empty\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getSpacePreferenceAsInt(String preference, int defaultValue)\n    {\n        return this.xwiki.getSpacePreferenceAsInt(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access a Space Preference as a int number There can be one preference object per locale This function will\n     * find the right preference object associated to the current active locale If no preference is found it will look\n     * for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getSpacePreferenceAsInt(String preference)\n    {\n        return this.xwiki.getSpacePreferenceAsInt(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a User Preference This function will look in the User profile for the preference If no preference\n     * is found it will look in the Space Preferences If no preference is found it will look in the XWiki Preferences\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getUserPreference(String preference)\n    {\n        return this.xwiki.getUserPreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a User Preference from cookie This function will look in the session cookie for the preference\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getUserPreferenceFromCookie(String preference)\n    {\n        return this.xwiki.getUserPreferenceFromCookie(preference, getXWikiContext());\n    }\n\n    /**\n     * Same as {@link #getLocalePreference()} but as a String.\n     *\n     * @return the locale to use\n     * @deprecated since 8.0M1, use {@link #getLocalePreference()} instead\n     */\n    @Deprecated\n    public String getLanguagePreference()\n    {\n        return this.xwiki.getLanguagePreference(getXWikiContext());\n    }\n\n    /**\n     * First try to find the current locale in use from the XWiki context. If none is used and if the wiki is not\n     * multilingual use the default locale defined in the XWiki preferences. If the wiki is multilingual try to get the\n     * locale passed in the request. If none was passed try to get it from a cookie. If no locale cookie exists then use\n     * the user default locale and barring that use the browser's \"Accept-Language\" header sent in HTTP request. If none\n     * is defined use the default locale.\n     *\n     * @return the locale to use\n     * @since 8.0M1\n     */\n    public Locale getLocalePreference()\n    {\n        return this.xwiki.getLocalePreference(getXWikiContext());\n    }\n\n    /**\n     * Same as {@link #getInterfaceLocalePreference()} but as a String.\n     *\n     * @return the document locale preference for the request\n     * @deprecated since 8.0M1, use {@link #getInterfaceLocalePreference()} instead\n     */\n    @Deprecated\n    public String getInterfaceLanguagePreference()\n    {\n        return this.xwiki.getInterfaceLanguagePreference(getXWikiContext());\n    }\n\n    /**\n     * API to access the interface locale preference for the request Order of evaluation is: locale of the wiki in\n     * mono-lingual mode locale request parameter locale in context locale user preference locale in cookie locale\n     * accepted by the navigator\n     *\n     * @return the document locale preference for the request\n     */\n    public Locale getInterfaceLocalePreference()\n    {\n        return this.xwiki.getInterfaceLocalePreference(getXWikiContext());\n    }\n\n    /**\n     * Get the available locales according to the preferences.\n     *\n     * @return the list of available locales\n     * @since 12.4RC1\n     */\n    @Unstable\n    public List<Locale> getAvailableLocales()\n    {\n        return this.xwiki.getAvailableLocales(getXWikiContext());\n    }\n\n    /**\n     * @return the list of all wiki names, including the main wiki, corresponding to the available wiki descriptors.\n     *         Example: the descriptor for the wiki <i>wikiname</i> is a document in the main wiki, named\n     *         <i>XWiki.XWikiServerWikiname</i>, containing an XWiki.XWikiServerClass object.\n     * @see com.xpn.xwiki.XWiki#getVirtualWikisDatabaseNames(XWikiContext)\n     */\n    public List<String> getWikiNames()\n    {\n        List<String> result = new ArrayList<String>();\n\n        try {\n            result = this.xwiki.getVirtualWikisDatabaseNames(getXWikiContext());\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to get the list of all wiki names\", e);\n        }\n\n        return result;\n    }\n\n    /**\n     * Convenience method to ask if the current XWiki instance contains subwikis (in addition to the main wiki)\n     *\n     * @return true if at least 1 subwiki exists; false otherwise\n     * @see #getWikiNames()\n     */\n    public boolean hasSubWikis()\n    {\n        return getWikiNames().size() > 1;\n    }\n\n    /**\n     * API to check is wiki is multi-lingual\n     *\n     * @return true for multi-lingual/false for mono-lingual\n     */\n    public boolean isMultiLingual()\n    {\n        return this.xwiki.isMultiLingual(getXWikiContext());\n    }\n\n    /**\n     * Privileged API to flush the cache of the Wiki installation This flushed the cache of all wikis, all plugins, all\n     * renderers\n     */\n    public void flushCache()\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.flushCache(getXWikiContext());\n        }\n    }\n\n    /**\n     * Privileged API to create a new user from the request This API is used by RegisterNewUser wiki page\n     *\n     * @return the integer status code\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-2: passwords are different or password is empty</li>\n     *         <li>-3: user already exists</li>\n     *         <li>-4: invalid username provided</li>\n     *         <li>-8: user already exists</li>\n     *         </ul>\n     * @throws XWikiException\n     */\n    public int createUser() throws XWikiException\n    {\n        return createUser(false, \"edit\");\n    }\n\n    /**\n     * Privileged API to create a new user from the request This API is used by RegisterNewUser wiki page This version\n     * sends a validation email to the user Configuration of validation email is in the XWiki Preferences\n     *\n     * @param withValidation true to send the validationemail\n     * @return the integer status code\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-2: passwords are different or password is empty</li>\n     *         <li>-3: user already exists</li>\n     *         <li>-4: invalid username provided</li>\n     *         <li>-8: user already exists</li>\n     *         </ul>\n     * @throws XWikiException\n     */\n    public int createUser(boolean withValidation) throws XWikiException\n    {\n        return createUser(withValidation, \"edit\");\n    }\n\n    /**\n     * Privileged API to create a new user from the request.\n     * <p>\n     * This API is used by the RegisterNewUser wiki page.\n     * <p>\n     * This version sends a validation email to the user. Configuration of validation email is in the XWiki Preferences.\n     *\n     * @param withValidation true to send the validation email\n     * @param userRights Rights to set for the user for it's own page(defaults to \"edit\")\n     * @return the integer status code\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-2: passwords are different or password is empty</li>\n     *         <li>-3: user already exists</li>\n     *         <li>-4: invalid username provided</li>\n     *         <li>-8: user already exists</li>\n     *         </ul>\n     * @throws XWikiException\n     */\n    public int createUser(boolean withValidation, String userRights) throws XWikiException\n    {\n        boolean registerRight;\n        try {\n            // So, what's the register right for? This says that if the creator of the page\n            // (Admin) has programming rights, anybody can register. Is this OK?\n            if (hasProgrammingRights()) {\n                registerRight = true;\n            } else {\n                registerRight = this.xwiki.getRightService().hasAccessLevel(\"register\", getXWikiContext().getUser(),\n                    \"XWiki.XWikiPreferences\", getXWikiContext());\n            }\n\n            if (registerRight) {\n                return this.xwiki.createUser(withValidation, userRights, getXWikiContext());\n            }\n\n            return -1;\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to create user\", e);\n\n            return -10;\n        }\n\n    }\n\n    /**\n     * Privileged API to validate the return code given by a user in response to an email validation email The\n     * validation information are taken from the request object\n     *\n     * @param withConfirmEmail true to send a account confirmation email/false to not send it\n     * @return Success of Failure code (0 for success, -1 for missing programming rights, &gt; 0 for other errors\n     * @throws XWikiException\n     */\n    public int validateUser(boolean withConfirmEmail) throws XWikiException\n    {\n        return this.xwiki.validateUser(withConfirmEmail, getXWikiContext());\n    }\n\n    /**\n     * Privileged API to add a user to the XWiki.XWikiAllGroup\n     *\n     * @param fullwikiname user name to add\n     * @throws XWikiException\n     */\n    public void addToAllGroup(String fullwikiname) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.setUserDefaultGroup(fullwikiname, getXWikiContext());\n        }\n    }\n\n    /**\n     * Privileged API to send a confirmation email to a user\n     *\n     * @param xwikiname user to send the email to\n     * @param password password to put in the mail\n     * @param email email to send to\n     * @param add_message Additional message to send to the user\n     * @param contentfield Preference field to use as a mail template\n     * @throws XWikiException if the mail was not send successfully\n     */\n    public void sendConfirmationMail(String xwikiname, String password, String email, String add_message,\n        String contentfield) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.sendConfirmationEmail(xwikiname, password, email, add_message, contentfield, getXWikiContext());\n        }\n    }\n\n    /**\n     * Privileged API to send a confirmation email to a user\n     *\n     * @param xwikiname user to send the email to\n     * @param password password to put in the mail\n     * @param email email to send to\n     * @param contentfield Preference field to use as a mail template\n     * @throws XWikiException if the mail was not send successfully\n     */\n    public void sendConfirmationMail(String xwikiname, String password, String email, String contentfield)\n        throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.sendConfirmationEmail(xwikiname, password, email, \"\", contentfield, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to rename a document to another document.\n     * Note that the list of backlinks can be retrieved with {@link Document#getBackLinkedReferences()}\n     * and the list of children with {@link Document#getChildrenReferences()}.\n     *\n     * <strong>Warning:</strong> Be aware that this method never triggers any event related to the rename\n     * of the document. If you want the right events to be sent for the event, please use the dedicated Refactoring\n     * Module API (see\n     * {@link org.xwiki.refactoring.script.RequestFactory#createRenameRequest(EntityReference, EntityReference)}\n     * and {@link org.xwiki.refactoring.job.MoveRequest}).\n     *\n     * @param sourceDocumentReference the source document to rename.\n     * @param targetDocumentReference the target reference to rename the document to.\n     * @param overwrite if {@code true} the target document reference will be overwritten if it exists\n     *                  (deleted to the recycle bin before the rename). If {@code false} and the target document exist\n     *                  the rename won't be performed.\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *                                  modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *                                 document reference\n     * @return {@code true} if the rename succeeded. {@code false} if there was any issue.\n     * @throws XWikiException if the document cannot be renamed properly.\n     * @since 12.5RC1\n     */\n    @Unstable\n    public boolean renameDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean overwrite, List<DocumentReference> backlinkDocumentReferences,\n        List<DocumentReference> childDocumentReferences) throws XWikiException\n    {\n        if (hasAccess(Right.DELETE, sourceDocumentReference)\n            && ((overwrite && hasAccess(Right.DELETE, targetDocumentReference))\n            || (!overwrite && hasAccess(Right.EDIT, targetDocumentReference)))) {\n            return this.xwiki.renameDocument(sourceDocumentReference, targetDocumentReference, overwrite,\n                backlinkDocumentReferences, childDocumentReferences, getXWikiContext());\n        }\n        return false;\n    }\n\n    /**\n     * API to copy a document to another document in the same wiki\n     *\n     * @param docname source document\n     * @param targetdocname target document\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname) throws XWikiException\n    {\n        return this.copyDocument(docname, targetdocname, null, null, null, false, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document in the same wiki\n     *\n     * @param docname source document\n     * @param targetdocname target document\n     * @param wikilocale locale to copy\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname, String wikilocale) throws XWikiException\n    {\n        return this.copyDocument(docname, targetdocname, null, null, wikilocale, false, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki\n     *\n     * @param docname source document\n     * @param sourceWiki source wiki\n     * @param targetWiki target wiki\n     * @param wikilocale locale to copy\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String sourceWiki, String targetWiki, String wikilocale)\n        throws XWikiException\n    {\n        return this.copyDocument(docname, docname, sourceWiki, targetWiki, wikilocale, true, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki additionally\n     * resetting the version\n     *\n     * @param docname source document\n     * @param sourceWiki source wiki\n     * @param targetWiki target wiki\n     * @param wikilocale locale to copy\n     * @param reset true to reset versions\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname, String sourceWiki, String targetWiki,\n        String wikilocale, boolean reset) throws XWikiException\n    {\n        return this.copyDocument(docname, targetdocname, sourceWiki, targetWiki, wikilocale, reset, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki additionally\n     * resetting the version and overwriting the previous document\n     *\n     * @param docname source document name\n     * @param targetdocname target document name\n     * @param sourceWiki source wiki\n     * @param targetWiki target wiki\n     * @param wikilocale locale to copy\n     * @param reset true to reset versions\n     * @param force true to overwrite the previous document\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname, String sourceWiki, String targetWiki,\n        String wikilocale, boolean reset, boolean force) throws XWikiException\n    {\n        DocumentReference sourceDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);\n        if (!StringUtils.isEmpty(sourceWiki)) {\n            sourceDocumentReference = sourceDocumentReference.replaceParent(sourceDocumentReference.getWikiReference(),\n                new WikiReference(sourceWiki));\n        }\n\n        DocumentReference targetDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(targetdocname);\n        if (!StringUtils.isEmpty(targetWiki)) {\n            targetDocumentReference = targetDocumentReference.replaceParent(targetDocumentReference.getWikiReference(),\n                new WikiReference(targetWiki));\n        }\n\n        return this.copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, force);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki additionally\n     * resetting the version and overwriting the previous document\n     *\n     * @param sourceDocumentReference the reference to the document to copy\n     * @param targetDocumentReference the reference to the document to create\n     * @param wikilocale locale to copy\n     * @param resetHistory {@code true} to reset versions\n     * @param overwrite {@code true} to overwrite the previous document\n     * @return {@code true} if the copy was sucessful\n     * @throws XWikiException if the document was not copied properly\n     * @since 3.0M3\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean resetHistory, boolean overwrite) throws XWikiException\n    {\n        // In order to copy the source document the user must have at least the right to view it.\n        if (hasAccessLevel(\"view\", getDefaultStringEntityReferenceSerializer().serialize(sourceDocumentReference))) {\n            String targetDocStringRef = getDefaultStringEntityReferenceSerializer().serialize(targetDocumentReference);\n            // To create the target document the user must have edit rights. If the target document exists and the user\n            // wants to overwrite it then he needs delete right.\n            // Note: We have to check if the target document exists before checking the delete right because delete\n            // right is denied if not explicitly specified.\n            if (hasAccessLevel(\"edit\", targetDocStringRef)\n                && (!overwrite || !exists(targetDocumentReference) || hasAccessLevel(\"delete\", targetDocStringRef))) {\n                // Reset creation data otherwise the required rights for page copy need to be reconsidered.\n                return this.xwiki.copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale,\n                    resetHistory, overwrite, true, getXWikiContext());\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Privileged API to copy a space to another wiki, optionally deleting all document of the target space\n     *\n     * @param space source Space\n     * @param sourceWiki source Wiki\n     * @param targetWiki target Wiki\n     * @param locale locale to copy\n     * @param clean true to delete all document of the target space\n     * @return number of copied documents\n     * @throws XWikiException if the space was not copied properly\n     */\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale, boolean clean)\n        throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.copySpaceBetweenWikis(space, sourceWiki, targetWiki, locale, clean, getXWikiContext());\n        }\n\n        return -1;\n    }\n\n    /**\n     * API to include a topic into another The topic is rendered fully in the context of itself\n     *\n     * @param topic page name of the topic to include\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeTopic(String topic) throws XWikiException\n    {\n        return includeTopic(topic, true);\n    }\n\n    /**\n     * API to execute a form in the context of an including topic The rendering is evaluated in the context of the\n     * including topic All velocity variables are the one of the including topic This api is usually called using\n     * #includeForm in a page, which modifies the behavior of \"Edit this page\" button to direct for Form mode (inline)\n     *\n     * @param topic page name of the form to execute\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeForm(String topic) throws XWikiException\n    {\n        return includeForm(topic, true);\n    }\n\n    /**\n     * API to include a topic into another, optionally surrounding the content with {pre}{/pre} to avoid future wiki\n     * rendering. The topic is rendered fully in the context of itself.\n     *\n     * @param topic page name of the topic to include\n     * @param pre true to add {pre} {/pre} (only if includer document is 1.0 syntax)\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeTopic(String topic, boolean pre) throws XWikiException\n    {\n        String result = this.xwiki.include(topic, false, getXWikiContext());\n\n        if (pre) {\n            String includerSyntax = this.xwiki.getCurrentContentSyntaxId(null, this.context);\n\n            if (includerSyntax != null && Syntax.XWIKI_1_0.toIdString().equals(includerSyntax)) {\n                result = \"{pre}\" + result + \"{/pre}\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * API to execute a form in the context of an including topic, optionnaly surrounding the content with {pre}{/pre}\n     * to avoid future wiki rendering The rendering is evaluated in the context of the including topic All velocity\n     * variables are the one of the including topic This api is usually called using #includeForm in a page, which\n     * modifies the behavior of \"Edit this page\" button to direct for Form mode (inline).\n     *\n     * @param topic page name of the form to execute\n     * @param pre true to add {pre} {/pre} (only if includer document is 1.0 syntax)\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeForm(String topic, boolean pre) throws XWikiException\n    {\n        String result = this.xwiki.include(topic, true, getXWikiContext());\n\n        if (pre) {\n            String includerSyntax = this.xwiki.getCurrentContentSyntaxId(null, this.context);\n\n            if (includerSyntax != null && Syntax.XWIKI_1_0.toIdString().equals(includerSyntax)) {\n                result = \"{pre}\" + result + \"{/pre}\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * API to check rights on the current document for the current user\n     *\n     * @param level right to check (view, edit, comment, delete)\n     * @return true if right is granted/false if not\n     */\n    public boolean hasAccessLevel(String level)\n    {\n        return hasAccessLevel(level, getXWikiContext().getUser(), getXWikiContext().getDoc().getFullName());\n    }\n\n    /**\n     * API to check rights on a document for a given user\n     *\n     * @param level right to check (view, edit, comment, delete)\n     * @param user user for which to check the right\n     * @param docname document on which to check the rights\n     * @return true if right is granted/false if not\n     */\n    public boolean hasAccessLevel(String level, String user, String docname)\n    {\n        try {\n            return this.xwiki.getRightService().hasAccessLevel(level, user, docname, getXWikiContext());\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    /**\n     * API to list all spaces in the current wiki.\n     * <p>\n     * Hidden spaces are filtered unless current user enabled them.\n     *\n     * @return a list of string representing all non-hidden spaces (ie spaces that have non-hidden pages) for the\n     *         current wiki\n     * @throws XWikiException if something went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaces() throws XWikiException\n    {\n        return this.xwiki.getSpaces(getXWikiContext());\n    }\n\n    /**\n     * API to list all documents in a space.\n     * <p>\n     * Hidden spaces are filtered unless current user enabled them.\n     *\n     * @param spaceReference the local reference of the space for which to return all non-hidden documents\n     * @return the list of document names (in the format {@code Space.Page}) for non-hidden documents in the specified\n     *         space\n     * @throws XWikiException if the loading went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaceDocsName(String spaceReference) throws XWikiException\n    {\n        return this.xwiki.getSpaceDocsName(spaceReference, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the current encoding of the wiki engine The encoding is stored in xwiki.cfg Default encoding is\n     * ISO-8891-1\n     *\n     * @return encoding active in this wiki\n     */\n    public String getEncoding()\n    {\n        return this.xwiki.getEncoding();\n    }\n\n    /**\n     * API to retrieve the URL of an attached file in a Wiki Document The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment) It\n     * is important to always use the URL functions to generate URL and never hardcode URLs\n     *\n     * @param fullname page name which includes the attached file\n     * @param filename attached filename to create a link for\n     * @return a URL as a string pointing to the filename\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getAttachmentURL(String fullname, String filename) throws XWikiException\n    {\n        if (StringUtils.isAnyEmpty(fullname, filename)) {\n            return \"\";\n        }\n\n        return this.xwiki.getAttachmentURL(fullname, filename, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in view mode The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment) It\n     * is important to always use the URL functions to generate URL and never hardcode URLs\n     *\n     * @param fullname the name of the document for which to return the URL for\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, \"view\", getXWikiContext());\n    }\n\n    /**\n     * Retrieve the URL of an entity using the default mode/action for that entity type. The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..). The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. For compatibility with any target environment (and especially the\n     * portlet environment) it is important to always use the URL functions to generate URLs and never hardcode URLs.\n     *\n     * @param reference the reference to the entity for which to return the URL\n     * @return a URL as a string pointing to the specified entity, using the default mode/action for that entity type\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference reference) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an entity in any mode, optionally adding a query string The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The query string will be modified to be added in the way the\n     * environment needs it. It is important to not add the query string parameter manually after a URL. Some\n     * environments will not accept this (like the Portlet environment).\n     *\n     * @param reference the reference to the entity for which to return the URL for\n     * @param action the mode in which to access the entity (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @return a URL as a string pointing to the entity\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference reference, String action, String querystring) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, action, querystring, null, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in view mode The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment) It\n     * is important to always use the URL functions to generate URL and never hardcode URLs\n     *\n     * @param reference the reference to the document for which to return the URL for\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 2.3M2\n     */\n    public String getURL(DocumentReference reference) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, \"view\", getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in any mode. The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..). The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment). It\n     * is important to always use the URL functions to generate URL and never hardcode URLs.\n     *\n     * @param fullname the page name which includes the attached file\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible.\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname, String action) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, action, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of a Wiki Document in any mode, optionally adding a query string The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The query string will be modified to be added in the way the\n     * environment needs it. It is important to not add the query string parameter manually after a URL. Some\n     * environments will not accept this (like the Portlet environment).\n     *\n     * @param fullname the page name which includes the attached file\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname, String action, String querystring) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, action, querystring, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of a Wiki Document in any mode, optionally adding a query string The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The query string will be modified to be added in the way the\n     * environment needs it. It is important to not add the query string parameter manually after a URL. Some\n     * environments will not accept this (like the Portlet environment).\n     *\n     * @param reference the reference to the document for which to return the URL for\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 3.0M3\n     */\n    public String getURL(DocumentReference reference, String action, String querystring) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, action, querystring, null, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in any mode, optionally adding an anchor. The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The anchor will be modified to be added in the way the environment\n     * needs it. It is important to not add the anchor parameter manually after a URL. Some environments will not accept\n     * this (like the Portlet environment).\n     *\n     * @param fullname the page name which includes the attached file\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @param anchor the anchor that points at a location within the passed document name\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname, String action, String querystring, String anchor) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, action, querystring, anchor, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a viewable referer text for a referer Referers are URL where users have clicked on a link to an\n     * XWiki page Search engine referer URLs are transformed to a nicer view (Google: search query string) For other URL\n     * the http:// part is stripped\n     *\n     * @param referer referer URL to transform\n     * @return A viewable string\n     */\n    public String getRefererText(String referer)\n    {\n        try {\n            return this.xwiki.getRefererText(referer, getXWikiContext());\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * API to retrieve a viewable referer text for a referer with a maximum length Referers are URL where users have\n     * clicked on a link to an XWiki page Search engine referer URLs are transformed to a nicer view (Google: search\n     * query string) For other URL the http:// part is stripped\n     *\n     * @param referer referer URL to transform\n     * @param length Maximum length. \"...\" is added to the end of the text\n     * @return A viewable string\n     */\n    public String getShortRefererText(String referer, int length)\n    {\n        try {\n            return this.xwiki.getRefererText(referer, getXWikiContext()).substring(0, length);\n        } catch (Exception e) {\n            return this.xwiki.getRefererText(referer, getXWikiContext());\n        }\n    }\n\n    /**\n     * Generate and return an unescaped user display name.\n     *\n     * @param userReference the user reference\n     * @return the unescaped display user name\n     * @since 6.4RC1\n     */\n    public String getPlainUserName(DocumentReference userReference)\n    {\n        return this.xwiki.getPlainUserName(userReference, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed for the first name and last name of the user. The link\n     * will link to the page on the wiki where the user is registered\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user)\n    {\n        return this.xwiki.getUserName(user, null, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed with a custom view. The link will link to the page on the\n     * wiki where the user is registered. The formating is done using the format parameter which can contain velocity\n     * scripting and access all properties of the User profile using variables ($first_name $last_name $email $city)\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user, String format)\n    {\n        return this.xwiki.getUserName(user, format, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed for the first name and last name of the user. The link\n     * will link to the page on the local wiki even if the user is registered on a different wiki.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), null, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, null, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed with a custom view. The link will link to the page on the\n     * local wiki even if the user is registered on a different wiki. The formating is done using the format parameter\n     * which can contain velocity scripting and access all properties of the User profile using variables ($first_name\n     * $last_name $email $city)\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user, String format)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), format, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, format, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to retrieve a text representing the user with the first name and last name of the user. With the link param\n     * set to false it will not link to the user page With the link param set to true, the link will link to the page on\n     * the wiki where the user was registered.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user, boolean link)\n    {\n        return this.xwiki.getUserName(user, null, link, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a text representing the user with a custom view With the link param set to false it will not link\n     * to the user page. With the link param set to true, the link will link to the page on the wiki where the user was\n     * registered. The formating is done using the format parameter which can contain velocity scripting and access all\n     * properties of the User profile using variables ($first_name $last_name $email $city)\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user, String format, boolean link)\n    {\n        return this.xwiki.getUserName(user, format, link, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a text representing the user with the first name and last name of the user. With the link param\n     * set to false it will not link to the user page. With the link param set to true, the link will link to the page\n     * on the local wiki even if the user is registered on a different wiki.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user, boolean link)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), null, link, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, null, link, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to retrieve a text representing the user with a custom view. The formating is done using the format parameter\n     * which can contain velocity scripting and access all properties of the User profile using variables ($first_name\n     * $last_name $email $city). With the link param set to false it will not link to the user page. With the link param\n     * set to true, the link will link to the page on the local wiki even if the user is registered on a different wiki.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user, String format, boolean link)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), format, link, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, format, link, getXWikiContext());\n        }\n    }\n\n    public User getUser()\n    {\n        return this.xwiki.getUser(getXWikiContext());\n    }\n\n    public User getUser(String username)\n    {\n        return this.xwiki.getUser(username, getXWikiContext());\n    }\n\n    /**\n     * Retrieve a user from its document reference.\n     *\n     * @param userReference the reference of the user.\n     * @return the user corresponding to the reference.\n     * @since 11.8RC1\n     */\n    public User getUser(DocumentReference userReference)\n    {\n        return this.xwiki.getUser(userReference, getXWikiContext());\n    }\n\n    /**\n     * API allowing to format a date according to the default Wiki setting The date format is provided in the\n     * 'dateformat' parameter of the XWiki Preferences\n     *\n     * @param date date object to format\n     * @return A string with the date formating from the default Wiki setting\n     */\n    public String formatDate(Date date)\n    {\n        return this.xwiki.formatDate(date, null, getXWikiContext());\n    }\n\n    /**\n     * API allowing to format a date according to a custom format The date format is from java.text.SimpleDateFormat\n     * Example: \"dd/MM/yyyy HH:mm:ss\" or \"d MMM yyyy\" If the format is invalid the default format will be used to show\n     * the date\n     *\n     * @param date date to format\n     * @param format format of the date to be used\n     * @return the formatted date\n     * @see java.text.SimpleDateFormat\n     */\n    public String formatDate(Date date, String format)\n    {\n        return this.xwiki.formatDate(date, format, getXWikiContext());\n    }\n\n    /*\n     * Allow to read user setting providing the user timezone All dates will be expressed with this timezone @return the\n     * timezone\n     */\n    public String getUserTimeZone()\n    {\n        return this.xwiki.getUserTimeZone(this.context);\n    }\n\n    /**\n     * Returns a plugin from the plugin API. Plugin Rights can be verified. Note that although this API is a duplicate\n     * of {@link #getPlugin(String)} it used to provide an easy access from Velocity to XWiki plugins. Indeed Velocity\n     * has a feature in that if a class has a get method, using the dot notation will automatically call the get method\n     * for the class. See http://velocity.apache.org/engine/releases/velocity-1.5/user-guide.html#propertylookuprules.\n     * This this allows the following constructs: <code>$xwiki.pluginName.somePluginMethod()</code>\n     *\n     * @param name Name of the plugin to retrieve (either short of full class name)\n     * @return a plugin object\n     */\n    public Api get(String name)\n    {\n        return getPlugin(name);\n    }\n\n    /**\n     * Returns a plugin from the plugin API. Plugin Rights can be verified.\n     *\n     * @param name Name of the plugin to retrieve (either short of full class name)\n     * @return a plugin object\n     */\n    public Api getPlugin(String name)\n    {\n        return this.xwiki != null ? this.xwiki.getPluginApi(name, getXWikiContext()) : null;\n    }\n\n    /**\n     * Returns the Advertisement system from the preferences\n     *\n     * @return \"google\" or \"none\"\n     */\n    public String getAdType()\n    {\n        return this.xwiki.getAdType(getXWikiContext());\n    }\n\n    /**\n     * Returns the Advertisement client ID from the preferences\n     *\n     * @return an Ad affiliate ID\n     */\n    public String getAdClientId()\n    {\n        return this.xwiki.getAdClientId(getXWikiContext());\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL protected using Basic Authentication\n     *\n     * @param surl url to retrieve\n     * @param username username for the basic authentication\n     * @param password password for the basic authentication\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl, String username, String password) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, username, password, this.context);\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to retrieve content from [\" + surl + \"]\", e);\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL\n     *\n     * @param surl url to retrieve\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, this.context);\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to retrieve content from [\" + surl + \"]\", e);\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL protected using Basic Authentication\n     *\n     * @param surl url to retrieve\n     * @param username username for the basic authentication\n     * @param password password for the basic authentication\n     * @param timeout manuel timeout in milliseconds\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl, String username, String password, int timeout) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, username, password, timeout,\n                this.xwiki.getHttpUserAgent(this.context));\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL\n     *\n     * @param surl url to retrieve\n     * @param timeout manuel timeout in milliseconds\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl, int timeout) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, timeout, this.xwiki.getHttpUserAgent(this.context));\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL protected using Basic Authentication as Bytes\n     *\n     * @param surl url to retrieve\n     * @param username username for the basic authentication\n     * @param password password for the basic authentication\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public byte[] getURLContentAsBytes(String surl, String username, String password) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return null;\n        }\n\n        try {\n            return this.xwiki.getURLContentAsBytes(surl, username, password, this.context);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL as Bytes\n     *\n     * @param surl url to retrieve\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public byte[] getURLContentAsBytes(String surl) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return null;\n        }\n\n        try {\n            return this.xwiki.getURLContentAsBytes(surl, this.context);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the list of Macros documents in the specified content\n     *\n     * @param defaultSpace Default space to use for relative path names\n     * @param content Content to parse\n     * @return ArrayList of document names\n     */\n    public List<String> getIncludedMacros(String defaultSpace, String content)\n    {\n        return this.xwiki.getIncludedMacros(defaultSpace, content, getXWikiContext());\n    }\n\n    /**\n     * returns true if xwiki.readonly is set in the configuration file\n     *\n     * @return the value of xwiki.isReadOnly()\n     * @see com.xpn.xwiki.XWiki\n     */\n    public boolean isReadOnly()\n    {\n        return this.xwiki.isReadOnly();\n    }\n\n    /**\n     * Privileged API to set/unset the readonly status of the Wiki After setting this to true no writing to the database\n     * will be performed All Edit buttons will be removed and save actions disabled This is used for maintenance\n     * purposes\n     *\n     * @param ro true to set read-only mode/false to unset\n     */\n    public void setReadOnly(boolean ro)\n    {\n        if (hasAdminRights()) {\n            this.xwiki.setReadOnly(ro);\n        }\n    }\n\n    /**\n     * Priviledge API to regenerate the links/backlinks table Normally links and backlinks are stored when a page is\n     * modified This function will regenerate all the backlinks This function can be long to run\n     *\n     * @throws XWikiException exception if the generation fails\n     */\n    public void refreshLinks() throws XWikiException\n    {\n        if (hasAdminRights()) {\n            this.xwiki.refreshLinks(getXWikiContext());\n        }\n    }\n\n    /**\n     * API to check if the backlinks feature is active Backlinks are activated in xwiki.cfg or in the XWiki Preferences\n     *\n     * @return true if the backlinks feature is active\n     * @throws XWikiException exception if the preference could not be retrieved\n     */\n    public boolean hasBacklinks() throws XWikiException\n    {\n        return this.xwiki.hasBacklinks(getXWikiContext());\n    }\n\n    /**\n     * API to check if the tags feature is active. Tags are activated in xwiki.cfg or in the XWiki Preferences\n     *\n     * @return true if the tags feature is active, false otherwise\n     * @throws XWikiException exception if the preference could not be retrieved\n     */\n    public boolean hasTags() throws XWikiException\n    {\n        return this.xwiki.hasTags(getXWikiContext());\n    }\n\n    /**\n     * API to check if the edit comment feature is active Edit comments are activated in xwiki.cfg or in the XWiki\n     * Preferences\n     *\n     * @return\n     */\n    public boolean hasEditComment()\n    {\n        return this.xwiki.hasEditComment(this.context);\n    }\n\n    /**\n     * API to check if the edit comment field is shown in the edit form Edit comments are activated in xwiki.cfg or in\n     * the XWiki Preferences\n     *\n     * @return\n     */\n    public boolean isEditCommentFieldHidden()\n    {\n        return this.xwiki.isEditCommentFieldHidden(this.context);\n    }\n\n    /**\n     * API to check if the edit comment is suggested (prompted once by Javascript if empty) Edit comments are activated\n     * in xwiki.cfg or in the XWiki Preferences\n     *\n     * @return\n     */\n    public boolean isEditCommentSuggested()\n    {\n        return this.xwiki.isEditCommentSuggested(this.context);\n    }\n\n    /**\n     * API to check if the edit comment is mandatory (prompted by Javascript if empty) Edit comments are activated in\n     * xwiki.cfg or in the XWiki Preferences\n     *\n     * @return\n     */\n    public boolean isEditCommentMandatory()\n    {\n        return this.xwiki.isEditCommentMandatory(this.context);\n    }\n\n    /**\n     * API to check if the minor edit feature is active minor edit is activated in xwiki.cfg or in the XWiki Preferences\n     */\n    public boolean hasMinorEdit()\n    {\n        return this.xwiki.hasMinorEdit(this.context);\n    }\n\n    /**\n     * API to check if the recycle bin feature is active recycle bin is activated in xwiki.cfg or in the XWiki\n     * Preferences\n     */\n    public boolean hasRecycleBin()\n    {\n        return this.xwiki.hasRecycleBin(this.context);\n    }\n\n    /**\n     * Retrieves the current editor preference for the request The preference is first looked up in the user preference\n     * and then in the space and wiki preference\n     *\n     * @return \"wysiwyg\" or \"text\"\n     */\n    public String getEditorPreference()\n    {\n        return this.xwiki.getEditorPreference(getXWikiContext());\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String. Note that Groovy scripts\n     * compilation is cached.\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public java.lang.Object parseGroovyFromString(String script) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.parseGroovyFromString(script, getXWikiContext());\n        }\n        return \"groovy_missingrights\";\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String, using a classloader including all\n     * JAR files located in the passed page as attachments. Note that Groovy scripts compilation is cached\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public java.lang.Object parseGroovyFromPage(String script, String jarWikiPage) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(script, getXWikiContext());\n        if (this.xwiki.getRightService().hasProgrammingRights(doc, getXWikiContext())) {\n            return this.xwiki.parseGroovyFromString(doc.getContent(), jarWikiPage, getXWikiContext());\n        }\n        return \"groovy_missingrights\";\n    }\n\n    /**\n     * Privileged API to retrieve an object instanciated from groovy code in a String Groovy scripts compilation is\n     * cached\n     *\n     * @param fullname // script containing a Groovy class definition (public class MyClass { ... })\n     * @return An object instanciating this class\n     * @throws XWikiException\n     */\n    public java.lang.Object parseGroovyFromPage(String fullname) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(fullname, getXWikiContext());\n        if (this.xwiki.getRightService().hasProgrammingRights(doc, getXWikiContext())) {\n            return this.xwiki.parseGroovyFromString(doc.getContent(), getXWikiContext());\n        }\n        return \"groovy_missingrights\";\n    }\n\n    /**\n     * API to get the macro list from the XWiki Preferences The macro list are the macros available from the Macro\n     * Mapping System\n     *\n     * @return String with each macro on each line\n     */\n    public String getMacroList()\n    {\n        return this.xwiki.getMacroList(getXWikiContext());\n    }\n\n    /**\n     * API to check if using which toolbars in Wysiwyg editor\n     *\n     * @return a string value\n     */\n    public String getWysiwygToolbars()\n    {\n        return this.xwiki.getWysiwygToolbars(getXWikiContext());\n    }\n\n    /**\n     * API to create an object from the request The parameters are the ones that are created from\n     * doc.display(\"field\",\"edit\") calls\n     *\n     * @param className XWiki Class Name to create the object from\n     * @return a BaseObject wrapped in an Object\n     * @throws XWikiException exception if the object could not be read\n     */\n    public com.xpn.xwiki.api.Object getObjectFromRequest(String className) throws XWikiException\n    {\n        return new com.xpn.xwiki.api.Object(this.xwiki.getObjectFromRequest(className, getXWikiContext()),\n            getXWikiContext());\n    }\n\n    /**\n     * API to create an empty document\n     *\n     * @return an XWikiDocument wrapped in a Document\n     */\n    public Document createDocument()\n    {\n        return new XWikiDocument().newDocument(getXWikiContext());\n    }\n\n    /**\n     * API to convert the username depending on the configuration The username can be converted from email to a valid\n     * XWiki page name hidding the email address The username can be then used to login and link to the right user page\n     *\n     * @param username username to use for login\n     * @return converted wiki page name for this username\n     */\n    public String convertUsername(String username)\n    {\n        return this.xwiki.convertUsername(username, getXWikiContext());\n    }\n\n    /**\n     * API to get the Property object from a class based on a property path A property path looks like\n     * XWiki.ArticleClass_fieldname\n     *\n     * @param propPath Property path\n     * @return a PropertyClass object from a BaseClass object\n     */\n    public com.xpn.xwiki.api.PropertyClass getPropertyClassFromName(String propPath)\n    {\n        return new PropertyClass(this.xwiki.getPropertyClassFromName(propPath, getXWikiContext()), getXWikiContext());\n    }\n\n    /**\n     * Generates a unique page name based on initial page name and already existing pages\n     *\n     * @param name\n     * @return a unique page name\n     */\n    public String getUniquePageName(String name)\n    {\n        return this.xwiki.getUniquePageName(name, getXWikiContext());\n    }\n\n    /**\n     * Generates a unique page name based on initial page name and already existing pages\n     *\n     * @param space\n     * @param name\n     * @return a unique page name\n     */\n    public String getUniquePageName(String space, String name)\n    {\n        return this.xwiki.getUniquePageName(space, name, getXWikiContext());\n    }\n\n    /**\n     * Inserts a tooltip using toolTip.js\n     *\n     * @param html HTML viewed\n     * @param message HTML Tooltip message\n     * @param params Parameters in Javascropt added to the tooltip config\n     * @return HTML with working tooltip\n     */\n    public String addTooltip(String html, String message, String params)\n    {\n        return this.xwiki.addTooltip(html, message, params, getXWikiContext());\n    }\n\n    /**\n     * Inserts a tooltip using toolTip.js\n     *\n     * @param html HTML viewed\n     * @param message HTML Tooltip message\n     * @return HTML with working tooltip\n     */\n    public String addTooltip(String html, String message)\n    {\n        return this.xwiki.addTooltip(html, message, getXWikiContext());\n    }\n\n    /**\n     * Inserts the tooltip Javascript\n     *\n     * @return\n     */\n    public String addTooltipJS()\n    {\n        return this.xwiki.addTooltipJS(getXWikiContext());\n    }\n\n    /*\n     * Inserts a Mandatory asterix\n     */\n    public String addMandatory()\n    {\n        return this.xwiki.addMandatory(getXWikiContext());\n    }\n\n    /**\n     * Get the XWiki Class object defined in the passed Document name.\n     * <p>\n     * Note: This method doesn't require any rights for accessing the passed Document (as opposed to the\n     * {@link com.xpn.xwiki.api.Document#getClass()} method which does require to get a Document object first. This is\n     * thus useful in cases where the calling code doesn't have the access right to the specified Document. It is safe\n     * because there are no sensitive data stored in a Class definition.\n     * </p>\n     *\n     * @param documentName the name of the document for which to get the Class object. For example\n     *            \"XWiki.XWikiPreferences\"\n     * @return the XWiki Class object defined in the passed Document name. If the passed Document name points to a\n     *         Document with no Class defined then an empty Class object is returned (i.e. a Class object with no\n     *         properties).\n     * @throws XWikiException if the passed document name doesn't point to a valid Document\n     */\n    public Class getClass(String documentName) throws XWikiException\n    {\n        // TODO: The implementation should be done in com.xpn.xwiki.XWiki as this class should\n        // delegate all implementations to that Class.\n        DocumentReference docReference = getCurrentMixedDocumentReferenceResolver().resolve(documentName);\n        return getClass(docReference);\n    }\n\n    /**\n     * Get the XWiki Class object defined in the passed Document name.\n     * <p>\n     * Note: This method doesn't require any rights for accessing the passed Document (as opposed to the\n     * {@link com.xpn.xwiki.api.Document#getClass()} method which does require to get a Document object first. This is\n     * thus useful in cases where the calling code doesn't have the access right to the specified Document. It is safe\n     * because there are no sensitive data stored in a Class definition.\n     * </p>\n     *\n     * @param docReference the reference of the document for which to get the Class object.\n     * @return the XWiki Class object defined in the passed Document reference. If the passed Document name points to a\n     *         Document with no Class defined then an empty Class object is returned (i.e. a Class object with no\n     *         properties).\n     * @throws XWikiException if the reference doesn't exist.\n     * @since 10.11.10\n     * @since 11.8RC1\n     * @since 11.3.4\n     */\n    public Class getClass(EntityReference docReference) throws XWikiException\n    {\n        return new Class(this.xwiki.getDocument(docReference, this.context).getXClass(), this.context);\n    }\n\n    /**\n     * Provides an absolute counter\n     *\n     * @param name Counter name\n     * @return String\n     */\n    public String getCounter(String name)\n    {\n        XWikiEngineContext econtext = this.context.getEngineContext();\n        Integer counter = (Integer) econtext.getAttribute(name);\n        if (counter == null) {\n            counter = 0;\n        }\n        counter = counter.intValue() + 1;\n        econtext.setAttribute(name, counter);\n\n        return counter.toString();\n    }\n\n    /**\n     * Check authentication from request and set according persitent login information If it fails user is unlogged\n     *\n     * @return null if failed, non null XWikiUser if sucess\n     * @throws XWikiException\n     */\n    public XWikiUser checkAuth() throws XWikiException\n    {\n        return this.context.getWiki().getAuthService().checkAuth(this.context);\n    }\n\n    /**\n     * Check authentication from username and password and set according persitent login information If it fails user is\n     * unlogged\n     *\n     * @param username username to check\n     * @param password password to check\n     * @param rememberme \"1\" if you want to remember the login accross navigator restart\n     * @return null if failed, non null XWikiUser if sucess\n     * @throws XWikiException\n     */\n    public XWikiUser checkAuth(String username, String password, String rememberme) throws XWikiException\n    {\n        return this.context.getWiki().getAuthService().checkAuth(username, password, rememberme, this.context);\n    }\n\n    /**\n     * Access statistics api\n     *\n     * @return a StatsService instance that can be used to retrieve different xwiki statistics\n     */\n    public StatsService getStatsService()\n    {\n        return this.statsService;\n    }\n\n    /**\n     * API to get the xwiki criteria service which allow to create various criteria : integer ranges, date periods, date\n     * intervals, etc.\n     *\n     * @return the xwiki criteria service\n     */\n    public CriteriaService getCriteriaService()\n    {\n        return this.criteriaService;\n    }\n\n    /**\n     * API to get the Servlet path for a given wiki. In mono wiki this is \"bin/\" or \"xwiki/\". In virtual mode and if\n     * <tt>xwiki.virtual.usepath</tt> is enabled in xwiki.cfg, it is \"wiki/wikiname/\".\n     *\n     * @param wikiName wiki for which to get the path\n     * @return The servlet path\n     */\n    public String getServletPath(String wikiName)\n    {\n        return this.xwiki.getServletPath(wikiName, this.context);\n    }\n\n    /**\n     * API to get the Servlet path for the current wiki. In mono wiki this is \"bin/\" or \"xwiki/\". In virtual mode and if\n     * <tt>xwiki.virtual.usepath</tt> is enabled in xwiki.cfg, it is \"wiki/wikiname/\".\n     *\n     * @return The servlet path\n     */\n    public String getServletPath()\n    {\n        return this.xwiki.getServletPath(this.context.getWikiId(), this.context);\n    }\n\n    /**\n     * API to get the webapp path for the current wiki. This usually is \"xwiki/\". It can be configured in xwiki.cfg with\n     * the config <tt>xwiki.webapppath</tt>.\n     *\n     * @return The servlet path\n     */\n    public String getWebAppPath()\n    {\n        return this.xwiki.getWebAppPath(this.context);\n    }\n\n    /**\n     * @return the syntax id of the syntax to use when creating new documents.\n     */\n    public String getDefaultDocumentSyntax()\n    {\n        return this.xwiki.getDefaultDocumentSyntax();\n    }\n\n    /**\n     * Find the corresponding available renderer syntax.\n     * <p>\n     * If <code>syntaxVersion</code> is null the last version of the available provided syntax type is returned.\n     *\n     * @param syntaxType the syntax type\n     * @param syntaxVersion the syntax version\n     * @return the available corresponding {@link Syntax}. Null if no available renderer can be found.\n     */\n    public Syntax getAvailableRendererSyntax(String syntaxType, String syntaxVersion)\n    {\n        Syntax syntax = null;\n\n        try {\n            List<PrintRendererFactory> factories =\n                Utils.getContextComponentManager().getInstanceList((Type) PrintRendererFactory.class);\n            for (PrintRendererFactory factory : factories) {\n                Syntax factorySyntax = factory.getSyntax();\n                if (syntaxVersion != null) {\n                    if (factorySyntax.getType().getId().equalsIgnoreCase(syntaxType)\n                        && factorySyntax.getVersion().equals(syntaxVersion)) {\n                        syntax = factorySyntax;\n                        break;\n                    }\n                } else {\n                    // TODO: improve version comparaison since it does not work when comparing 2.0 and 10.0 for example.\n                    // We\n                    // should have a Version which implements Comparable like we have SyntaxId in Syntax\n                    if (factorySyntax.getType().getId().equalsIgnoreCase(syntaxType)\n                        && (syntax == null || factorySyntax.getVersion().compareTo(syntax.getVersion()) > 0)) {\n                        syntax = factorySyntax;\n                    }\n                }\n            }\n        } catch (ComponentLookupException e) {\n            LOGGER.error(\"Failed to lookup available renderer syntaxes\", e);\n        }\n\n        return syntax;\n    }\n\n    /**\n     * @return true if section editing is enabled (can be configured through the {@code xwiki.section.edit}\n     *         configuration property. Defaults to 1 (=enabled) when not defined\n     */\n    public boolean hasSectionEdit()\n    {\n        return this.xwiki.hasSectionEdit(getXWikiContext());\n    }\n\n    /**\n     * @return the section depth for which section editing is available (can be configured through\n     *         {@code xwiki.section.depth} configuration property. Defaults to 2 when not defined\n     */\n    public long getSectionEditingDepth()\n    {\n        return this.xwiki.getSectionEditingDepth();\n    }\n\n    /**\n     * @return true if title handling should be using the compatibility mode or not. When the compatibility mode is\n     *         active, if the document's content first header (level 1 or level 2) matches the document's title the\n     *         first header is stripped.\n     */\n    public boolean isTitleInCompatibilityMode()\n    {\n        return this.xwiki.isTitleInCompatibilityMode();\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId()\n    {\n        return this.xwiki.getCurrentContentSyntaxId(getXWikiContext());\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki;\n\nimport java.io.UnsupportedEncodingException;\nimport java.io.File;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.net.InetAddress;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.InvocationTargetException;\nimport java.io.IOException;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.net.smtp.SMTPClient;\nimport org.apache.commons.net.smtp.SMTPReply;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.reflect.MethodUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.xwiki.cache.CacheException;\nimport org.xwiki.cache.CacheFactory;\nimport org.xwiki.cache.CacheManager;\nimport org.xwiki.cache.config.CacheConfiguration;\nimport org.xwiki.cache.eviction.LRUEvictionConfiguration;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.environment.Environment;\nimport org.xwiki.rendering.configuration.ExtendedRenderingConfiguration;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.xml.XMLUtils;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.url.XWikiEntityURL;\nimport org.xwiki.wiki.manager.WikiManagerException;\nimport org.xwiki.wiki.descriptor.WikiDescriptor;\nimport org.xwiki.wiki.descriptor.WikiDescriptorManager;\n\nimport com.xpn.xwiki.cache.api.XWikiCache;\nimport com.xpn.xwiki.cache.api.XWikiCacheService;\nimport com.xpn.xwiki.cache.api.internal.XWikiCacheServiceStub;\nimport com.xpn.xwiki.cache.api.internal.XWikiCacheStub;\nimport com.xpn.xwiki.cache.api.internal.XWikiInitializedWikiCacheStub;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.notify.XWikiNotificationManager;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.plugin.query.XWikiCriteria;\nimport com.xpn.xwiki.plugin.query.XWikiQuery;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiMessageTool;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.includeservletasstring.IncludeServletAsString;\n\n/**\n * Add a backward compatibility layer to the {@link com.xpn.xwiki.XWiki} class.\n * \n * @version $Id$\n */\npublic privileged aspect XWikiCompatibilityAspect\n{\n    private static Map XWiki.threadMap = new HashMap();\n\n    private XWikiNotificationManager XWiki.notificationManager;\n\n    private EntityReferenceResolver<EntityReference> XWiki.defaultReferenceEntityReferenceResolver = Utils.getComponent(\n        EntityReferenceResolver.TYPE_REFERENCE);\n    \n    /**\n     * Used to get the temporary and permanent directory.\n     */\n    private Environment XWiki.environment = Utils.getComponent((Type) Environment.class);\n\n    /** Is the wiki running in test mode? Deprecated, was used when running Cactus tests. */\n    private boolean XWiki.test = false;\n\n    /** List of configured syntax ids. */\n    private List<String> XWiki.configuredSyntaxes;\n\n    /**\n     * Transform a text in a URL compatible text\n     *\n     * @param content text to transform\n     * @return encoded result\n     * @deprecated replaced by Util#encodeURI since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.getURLEncoded(String content)\n    {\n        try {\n            return URLEncoder.encode(content, this.getEncoding());\n        } catch (UnsupportedEncodingException e) {\n            return content;\n        }\n    }\n\n    /**\n     * @return true for multi-wiki/false for mono-wiki\n     * @deprecated replaced by {@link XWiki#isVirtualMode()} since 1.4M1.\n     */\n    @Deprecated\n    public boolean XWiki.isVirtual()\n    {\n        return isVirtualMode();\n    }\n\n    /**\n     * @deprecated Virtual mode is on by default, starting with XWiki 5.0M2. Use\n     *             {@link #getVirtualWikisDatabaseNames(XWikiContext)} to get the list of wikis if needed.\n     * @return true for multi-wiki/false for mono-wiki\n     */\n    @Deprecated\n    public boolean XWiki.isVirtualMode()\n    {\n        return true;\n    }\n\n    /**\n     * @deprecated Removed since it isn't used; since 1.5M1.\n     */\n    @Deprecated\n    public static Map XWiki.getThreadMap()\n    {\n        return XWiki.threadMap;\n    }\n\n    /**\n     * @deprecated Removed since it isn't used; since 1.5M1.\n     */\n    @Deprecated\n    public static void XWiki.setThreadMap(Map threadMap)\n    {\n        XWiki.threadMap = threadMap;\n    }\n\n    /**\n     * @return the cache service.\n     * @deprecated replaced by {@link XWiki#getCacheFactory(XWikiContext)} or\n     *             {@link XWiki#getLocalCacheFactory(XWikiContext)} since 1.5M2.\n     */\n    @Deprecated\n    public XWikiCacheService XWiki.getCacheService()\n    {\n        return new XWikiCacheServiceStub(getCacheFactory(), getLocalCacheFactory());\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getVirtualWikiCache(XWikiContext)} since 1.5M2.\n     */\n    @Deprecated\n    public XWikiCache XWiki.getVirtualWikiMap()\n    {\n        return new XWikiInitializedWikiCacheStub(this.initializedWikis);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpaceCopyright(XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebCopyright(XWikiContext context)\n    {\n        return this.getSpaceCopyright(context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreference(String, XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebPreference(String preference, XWikiContext context)\n    {\n        return this.getSpacePreference(preference, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreference(String, String, XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebPreference(String preference, String defaultValue, XWikiContext context)\n    {\n        return this.getSpacePreference(preference, defaultValue, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreference(String, String, String, XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebPreference(String preference, String space, String defaultValue, XWikiContext context)\n    {\n        return this.getSpacePreference(preference, space, defaultValue, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsLong(String, XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public long XWiki.getWebPreferenceAsLong(String preference, XWikiContext context)\n    {\n        return this.getSpacePreferenceAsLong(preference, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsLong(String, long, XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public long XWiki.getWebPreferenceAsLong(String preference, long defaultValue, XWikiContext context)\n    {\n        return this.getSpacePreferenceAsLong(preference, defaultValue, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsInt(String, XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public int XWiki.getWebPreferenceAsInt(String preference, XWikiContext context)\n    {\n        return this.getSpacePreferenceAsInt(preference, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsInt(String, int, XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public int XWiki.getWebPreferenceAsInt(String preference, int defaultValue, XWikiContext context)\n    {\n        return this.getSpacePreferenceAsInt(preference, defaultValue, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#copySpaceBetweenWikis(String, String, String, String, XWikiContext)} since\n     *             2.3M1\n     */\n    @Deprecated\n    public int XWiki.copyWikiWeb(String space, String sourceWiki, String targetWiki, String language, XWikiContext context)\n        throws XWikiException\n    {\n        return this.copySpaceBetweenWikis(space, sourceWiki, targetWiki, language, context);\n    }\n\n    /**\n     * @deprecated replaced by\n     *             {@link XWiki#copySpaceBetweenWikis(String, String, String, String, boolean, XWikiContext)} since\n     *             2.3M1\n     */\n    @Deprecated\n    public int XWiki.copyWikiWeb(String space, String sourceWiki, String targetWiki, String language, boolean clean,\n        XWikiContext context) throws XWikiException\n    {\n        return this.copySpaceBetweenWikis(space, sourceWiki, targetWiki, language, clean, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getDefaultSpace(XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getDefaultWeb(XWikiContext context)\n    {\n        return this.getDefaultSpace(context);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#skipDefaultSpaceInURLs(XWikiContext)} since 2.3M1\n     */\n    @Deprecated\n    public boolean XWiki.useDefaultWeb(XWikiContext context)\n    {\n        return this.skipDefaultSpaceInURLs(context);\n    }\n\n    /**\n     * @deprecated use {@link XWikiMessageTool#get(String, List)} instead. You can access message tool using\n     *             {@link XWikiContext#getMessageTool()}.\n     */\n    @Deprecated\n    public String XWiki.getMessage(String item, XWikiContext context)\n    {\n        XWikiMessageTool msg = context.getMessageTool();\n        if (msg == null) {\n            return item;\n        } else {\n            return msg.get(item);\n        }\n    }\n\n    /**\n     * @deprecated Removed since it isn't used; since 3.1M2.\n     */\n    @Deprecated\n    public String XWiki.getHTMLArea(String content, XWikiContext context)\n    {\n        StringBuilder result = new StringBuilder();\n\n        String scontent = XMLUtils.escape(content);\n        scontent = scontent.replaceAll(\"\\r?+\\n\", \"<br class=\\\"htmlarea\\\"/>\");\n\n        result.append(\"<textarea name=\\\"content\\\" id=\\\"content\\\" rows=\\\"25\\\" cols=\\\"80\\\">\");\n        result.append(scontent);\n        result.append(\"</textarea>\");\n\n        return result.toString();\n    }\n\n    @Deprecated\n    public XWikiNotificationManager XWiki.getNotificationManager()\n    {\n        if (this.notificationManager == null) {\n          this.notificationManager = new XWikiNotificationManager();\n        }\n\n        return this.notificationManager;\n    }\n\n    @Deprecated\n    public void XWiki.setNotificationManager(XWikiNotificationManager notificationManager)\n    {\n        this.notificationManager = notificationManager;\n    }\n    \n    @Deprecated\n    public String XWiki.displaySearch(String fieldname, String className, XWikiCriteria criteria, XWikiContext context)\n        throws XWikiException\n    {\n        return displaySearch(fieldname, className, \"\", criteria, context);\n    }\n\n    @Deprecated\n    public String XWiki.displaySearch(String fieldname, String className, XWikiContext context) throws XWikiException\n    {\n        return displaySearch(fieldname, className, \"\", new XWikiCriteria(), context);\n    }\n\n    @Deprecated\n    public String XWiki.displaySearch(String fieldname, String className, String prefix, XWikiCriteria criteria,\n        XWikiContext context) throws XWikiException\n    {\n        BaseClass bclass = getDocument(className, context).getXClass();\n        PropertyClass pclass = (PropertyClass) bclass.get(fieldname);\n        if (criteria == null) {\n            criteria = new XWikiCriteria();\n        }\n\n        if (pclass == null) {\n            return \"\";\n        } else {\n            return pclass.displaySearch(fieldname, prefix + className + \"_\", criteria, context);\n        }\n    }\n\n    @Deprecated\n    public String XWiki.displaySearchColumns(String className, XWikiQuery query, XWikiContext context) throws XWikiException\n    {\n        return displaySearchColumns(className, \"\", query, context);\n    }\n\n    @Deprecated\n    public String XWiki.displaySearchColumns(String className, String prefix, XWikiQuery query, XWikiContext context)\n        throws XWikiException\n    {\n        BaseClass bclass = getDocument(className, context).getXClass();\n\n        if (query == null) {\n            query = new XWikiQuery();\n        }\n\n        return bclass.displaySearchColumns(className + \"_\" + prefix, query, context);\n    }\n\n    @Deprecated\n    public String XWiki.displaySearchOrder(String className, XWikiQuery query, XWikiContext context) throws XWikiException\n    {\n        return displaySearchOrder(className, \"\", query, context);\n    }\n\n    @Deprecated\n    public String XWiki.displaySearchOrder(String className, String prefix, XWikiQuery query, XWikiContext context)\n        throws XWikiException\n    {\n        BaseClass bclass = getDocument(className, context).getXClass();\n\n        if (query == null) {\n            query = new XWikiQuery();\n        }\n\n        return bclass.displaySearchOrder(className + \"_\" + prefix, query, context);\n    }\n\n    @Deprecated\n    public <T> List<T> XWiki.search(XWikiQuery query, XWikiContext context) throws XWikiException\n    {\n        Object qp = getPlugin(\"query\", context);\n        if (qp == null) {\n            return null;\n        }\n\n        try {\n            return (List<T>) MethodUtils.invokeMethod(qp, \"search\", query);\n        } catch (Exception e) {\n            throw new XWikiException(\"Failed to execute search\", e);\n        }\n    }\n\n    @Deprecated\n    public XWikiQuery XWiki.createQueryFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return new XWikiQuery(context.getRequest(), className, context);\n    }\n\n    @Deprecated\n    public String XWiki.searchAsTable(XWikiQuery query, XWikiContext context) throws XWikiException\n    {\n        Object qp = getPlugin(\"query\", context);\n        if (qp == null) {\n            return null;\n        }\n\n        List<String> list;\n        try {\n            list = (List<String>) MethodUtils.invokeMethod(qp, \"search\", query);\n        } catch (Exception e) {\n            throw new XWikiException(\"Failed to execute search\", e);\n        }\n\n        String result = \"{table}\\r\\n\";\n        List<String> headerColumns = new ArrayList<String>();\n        List<String> displayProperties = query.getDisplayProperties();\n        for (String propname : displayProperties) {\n            PropertyClass pclass = getPropertyClassFromName(propname, context);\n            if (pclass != null) {\n                headerColumns.add(pclass.getPrettyName());\n            } else {\n                if (propname.startsWith(\"doc.\")) {\n                    propname = propname.substring(4);\n                    headerColumns.add(XWikiDocument.getInternalPropertyName(propname, context));\n                } else {\n                    headerColumns.add(propname);\n                }\n\n            }\n        }\n\n        result += StringUtils.join(headerColumns.toArray(), \" | \") + \"\\r\\n\";\n        for (String docname : list) {\n            List<String> rowColumns = new ArrayList<String>();\n            XWikiDocument doc = getDocument(docname, context);\n            for (String propname : displayProperties) {\n                PropertyClass pclass = getPropertyClassFromName(propname, context);\n                if (pclass == null) {\n                    if (propname.startsWith(\"doc.\")) {\n                        propname = propname.substring(4);\n                    }\n                    String value = doc.getInternalProperty(propname);\n                    rowColumns.add((value == null) ? \" \" : value);\n                } else {\n                    BaseObject bobj = doc.getObject(pclass.getObject().getName());\n                    rowColumns.add(doc.display(pclass.getName(), \"view\", bobj, context));\n                }\n            }\n            result += StringUtils.join(rowColumns.toArray(), \" | \") + \"\\r\\n\";\n        }\n\n        result += \"{table}\\r\\n\";\n\n        return result;\n    }\n\n    @Deprecated\n    public String XWiki.getDocLanguagePreference(XWikiContext context)\n    {\n        return getLanguagePreference(context);\n    }\n\n    @Deprecated\n    public void XWiki.flushCache()\n    {\n        Execution execution = Utils.getComponent(Execution.class);\n\n        ExecutionContext ec = execution.getContext();\n\n        flushCache(ec != null ? (XWikiContext) ec.getProperty(\"xwikicontext\") : null);\n    }\n\n    /**\n     * @deprecated use WikiManager plugin instead\n     */\n    @Deprecated\n    public int XWiki.createNewWiki(String wikiName, String wikiUrl, String wikiAdmin, String baseWikiName,\n        String description, String wikilanguage, boolean failOnExist, XWikiContext context) throws XWikiException\n    {\n        String database = context.getDatabase();\n        wikiName = wikiName.toLowerCase();\n\n        try {\n            XWikiDocument userdoc = getDocument(wikiAdmin, context);\n\n            // User does not exist\n            if (userdoc.isNew()) {\n                if (LOGGER.isErrorEnabled()) {\n                    LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                        + \"user does not exist\");\n                }\n                return -2;\n            }\n\n            // User is not active\n            if (!(userdoc.getIntValue(\"XWiki.XWikiUsers\", \"active\") == 1)) {\n                if (LOGGER.isErrorEnabled()) {\n                    LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                        + \"user is not active\");\n                }\n                return -3;\n            }\n\n            String wikiForbiddenList = Param(\"xwiki.virtual.reserved_wikis\");\n            if (Util.contains(wikiName, wikiForbiddenList, \", \")) {\n                if (LOGGER.isErrorEnabled()) {\n                    LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                        + \"wiki name is forbidden\");\n                }\n                return -4;\n            }\n\n            String wikiServerPage = \"XWikiServer\" + wikiName.substring(0, 1).toUpperCase() + wikiName.substring(1);\n            // Verify is server page already exist\n            XWikiDocument serverdoc = getDocument(SYSTEM_SPACE, wikiServerPage, context);\n            if (serverdoc.isNew()) {\n                // Create Wiki Server page\n                serverdoc.setStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"server\", wikiUrl);\n                serverdoc.setStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"owner\", wikiAdmin);\n                if (description != null) {\n                    serverdoc.setLargeStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"description\", description);\n                }\n                if (wikilanguage != null) {\n                    serverdoc.setStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"language\", wikilanguage);\n                }\n                if (!getDefaultDocumentSyntax().equals(Syntax.XWIKI_1_0.toIdString())) {\n                    serverdoc.setContent(\"{{include document=\\\"XWiki.XWikiServerForm\\\"/}}\\n\");\n                    serverdoc.setSyntax(Syntax.XWIKI_2_0);\n                } else {\n                    serverdoc.setContent(\"#includeForm(\\\"XWiki.XWikiServerForm\\\")\\n\");\n                    serverdoc.setSyntax(Syntax.XWIKI_1_0);\n                }\n                serverdoc.setParentReference(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE);\n                saveDocument(serverdoc, context);\n            } else {\n                // If we are not allowed to continue if server page already exists\n                if (failOnExist) {\n                    if (LOGGER.isErrorEnabled()) {\n                        LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                            + \"wiki server page already exists\");\n                    }\n                    return -5;\n                } else if (LOGGER.isWarnEnabled()) {\n                    LOGGER.warn(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                        + \"wiki server page already exists\");\n                }\n            }\n\n            // Create wiki database\n            try {\n                context.setDatabase(getDatabase());\n                getStore().createWiki(wikiName, context);\n            } catch (XWikiException e) {\n                if (LOGGER.isErrorEnabled()) {\n                    if (e.getCode() == 10010) {\n                        LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                            + \"wiki database already exists\");\n                    } else if (e.getCode() == 10011) {\n                        LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                            + \"wiki database creation failed\");\n                    } else {\n                        LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                            + \"wiki database creation threw exception\", e);\n                    }\n                }\n            } catch (Exception e) {\n                LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                    + \"wiki database creation threw exception\", e);\n            }\n\n            try {\n                updateDatabase(wikiName, true, false, context);\n            } catch (Exception e) {\n                LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                    + \"wiki database shema update threw exception\", e);\n                return -6;\n            }\n\n            // Copy base wiki\n            int nb = copyWiki(baseWikiName, wikiName, wikilanguage, context);\n            // Save the number of docs copied in the context\n            context.put(\"nbdocs\", Integer.valueOf(nb));\n\n            // Create user page in his wiki\n            // Let's not create it anymore.. this makes the creator loose\n            // super admin rights on his wiki\n            // copyDocument(wikiAdmin, getDatabase(), wikiName, wikilanguage, context);\n\n            // Modify rights in user wiki\n            context.setDatabase(wikiName);\n            /*\n             * XWikiDocument wikiprefdoc = getDocument(\"XWiki.XWikiPreferences\", context);\n             * wikiprefdoc.setStringValue(\"XWiki.XWikiGlobalRights\", \"users\", wikiAdmin);\n             * wikiprefdoc.setStringValue(\"XWiki.XWikiGlobalRights\", \"levels\", \"admin, edit\");\n             * wikiprefdoc.setIntValue(\"XWiki.XWikiGlobalRights\", \"allow\", 1); saveDocument(wikiprefdoc, context);\n             */\n            return 1;\n        } catch (Exception e) {\n            LOGGER.error(\"Wiki creation (\" + wikiName + \",\" + wikiUrl + \",\" + wikiAdmin + \") failed: \"\n                + \"wiki creation threw exception\", e);\n            return -10;\n        } finally {\n            context.setDatabase(database);\n        }\n    }\n\n    /**\n     * Get the XWiki temporary filesystem directory (cleaned up automatically by XWiki).\n     *\n     * @param context\n     * @return temporary directory\n     * @since 1.1 Milestone 4\n     * @deprecated starting with 4.2M1 use {@link org.xwiki.environment.Environment#getTemporaryDirectory()}\n     */\n    @Deprecated\n    public File XWiki.getTempDirectory(XWikiContext context)\n    {\n        return this.environment.getTemporaryDirectory();\n    }\n\n    /**\n     * Get a new directory in the xwiki work directory\n     *\n     * @param subdir desired directory name\n     * @param context\n     * @return work subdirectory\n     * @since 1.1 Milestone 4\n     * @deprecated starting with 4.2M1 use {@link org.xwiki.environment.Environment#getPermanentDirectory()}\n     */\n    @Deprecated\n    public File XWiki.getWorkSubdirectory(String subdir, XWikiContext context)\n    {\n        File fdir = new File(this.environment.getPermanentDirectory().getAbsolutePath(), subdir);\n        if (!fdir.exists()) {\n            fdir.mkdir();\n        }\n\n        return fdir;\n    }\n\n    /**\n     * Get the XWiki work directory\n     *\n     * @param context\n     * @return work directory\n     * @since 1.1 Milestone 4\n     * @deprecated starting with 4.2M1 use {@link org.xwiki.environment.Environment#getPermanentDirectory()}\n     */\n    @Deprecated\n    public File XWiki.getWorkDirectory(XWikiContext context)\n    {\n        return this.environment.getPermanentDirectory();\n    }\n\n    /**\n     * @deprecated starting with 5.1M1 use {@code org.xwiki.url.XWikiURLFactory} instead and starting with 5.3M1 use\n     *             {@link ResourceFactory} and since 6.1M2 use {@link org.xwiki.resource.ResourceReferenceResolver}\n     */\n    @Deprecated\n    public XWikiDocument XWiki.getDocumentFromPath(String path, XWikiContext context) throws XWikiException\n    {\n        return getDocument(getDocumentReferenceFromPath(path, context), context);\n    }\n\n    /**\n     * @since 2.3M1\n     * @deprecated starting with 5.1M1 use {@code org.xwiki.url.XWikiURLFactory} instead and starting with 5.3M1 use\n     *             {@link ResourceFactory} and since 6.1M2 use {@link org.xwiki.resource.ResourceReferenceResolver}\n     */\n    @Deprecated\n    public DocumentReference XWiki.getDocumentReferenceFromPath(String path, XWikiContext context)\n    {\n        // TODO: Remove this and use XWikiURLFactory instead in XWikiAction and all entry points.\n        List<String> segments = new ArrayList<String>();\n        for (String segment : path.split(\"/\", -1)) {\n            segments.add(Util.decodeURI(segment, context));\n        }\n        // Remove the first segment if it's empty to cater for cases when the path starts with \"/\"\n        if (segments.size() > 0 && segments.get(0).length() == 0) {\n            segments.remove(0);\n        }\n\n        XWikiEntityURL entityURL = buildEntityURLFromPathSegments(new WikiReference(context.getDatabase()), segments);\n\n        return new DocumentReference(entityURL.getEntityReference().extractReference(EntityType.DOCUMENT));\n    }\n\n    /**\n     * @deprecated since 2.3M1 use {@link #getDocumentReferenceFromPath(String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String XWiki.getDocumentNameFromPath(String path, XWikiContext context)\n    {\n        return getLocalStringEntityReferenceSerializer().serialize(getDocumentReferenceFromPath(path, context));\n    }\n\n    /**\n     * @deprecated since 2.3M1 use {@link #getDocumentReferenceFromPath(String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String XWiki.getDocumentName(XWikiRequest request, XWikiContext context)\n    {\n        return getLocalStringEntityReferenceSerializer().serialize(getDocumentReference(request, context));\n    }\n\n    /**\n     * @deprecated starting with 5.1M1 use {@code org.xwiki.url.XWikiURLFactory} instead and starting with 5.3M1 use\n     *             {@link ResourceFactory} and since 6.1M2 use {@link org.xwiki.resource.ResourceReferenceResolver}\n     */\n    @Deprecated\n    private XWikiEntityURL XWiki.buildEntityURLFromPathSegments(WikiReference wikiReference, List<String> pathSegments)\n    {\n        XWikiEntityURL entityURL;\n\n        // Rules based on counting the url segments:\n        // - 0 segments (e.g. \"\"): default document reference, \"view\" action\n        // - 1 segment (e.g. \"/\", \"/Document\"): default space, specified document (and default if empty), \"view\" action\n        // - 2 segments (e.g. \"/Space/\", \"/Space/Document\"): specified space, document (and default doc if empty),\n        //   \"view\" action\n        // - 3 segments (e.g. \"/action/Space/Document\"): specified space, document (and default doc if empty),\n        //   specified action\n        // - 4 segments (e.g. \"/download/Space/Document/attachment\"): specified space, document and attachment (and\n        //   default doc if empty), \"download\" action\n        // - 4 segments or more (e.g. \"/action/Space/Document/whatever/else\"): specified space, document (and default\n        //     doc if empty), specified \"action\" (if action != \"download\"), trailing segments ignored\n\n        String spaceName = null;\n        String pageName = null;\n        String attachmentName = null;\n        String action = \"view\";\n\n        if (pathSegments.size() == 1) {\n            pageName = pathSegments.get(0);\n        } else if (pathSegments.size() == 2) {\n            spaceName = pathSegments.get(0);\n            pageName = pathSegments.get(1);\n        } else if (pathSegments.size() >= 3) {\n            action = pathSegments.get(0);\n            spaceName = pathSegments.get(1);\n            pageName = pathSegments.get(2);\n            if (action.equals(\"download\") && pathSegments.size() >= 4) {\n                attachmentName = pathSegments.get(3);\n            }\n        }\n\n        // Normalize the extracted space/page to resolve empty/null values and replace them with default values.\n        EntityReference reference = wikiReference;\n        EntityType entityType = EntityType.DOCUMENT;\n        if (!StringUtils.isEmpty(spaceName)) {\n            reference = new EntityReference(spaceName, EntityType.SPACE, reference);\n        }\n        if (!StringUtils.isEmpty(pageName)) {\n            reference = new EntityReference(pageName, EntityType.DOCUMENT, reference);\n        }\n        if (!StringUtils.isEmpty(attachmentName)) {\n            reference = new EntityReference(attachmentName, EntityType.ATTACHMENT, reference);\n            entityType = EntityType.ATTACHMENT;\n        }\n        reference = this.defaultReferenceEntityReferenceResolver.resolve(reference, entityType);\n\n        entityURL = new XWikiEntityURL(reference);\n        entityURL.setAction(action);\n\n        return entityURL;\n    }\n\n    /**\n     * Extracts the name of the wiki from a context's request. In some cases, including autowww, the main wiki may be\n     * returned instead of what was requested, as a result of some assumptions. Even so, the resulting wiki name is not\n     * guaranteed to exist, it is just what XWiki understood from the request.\n     *\n     * @param context the context which contains the request\n     * @return the name of the wiki that was requested\n     * @throws XWikiException if problems occur\n     * @deprecated starting with 5.2M1 use  use {@link ResourceFactory} instead and since 6.1M2 use\n     *             {@link org.xwiki.resource.ResourceReferenceResolver} instead\n     */\n    @Deprecated\n    public String XWiki.getRequestWikiName(XWikiContext context) throws XWikiException\n    {\n        // Host is full.host.name in DNS-based multiwiki, and wikiname in path-based multiwiki.\n        String host = \"\";\n        // Canonical name of the wiki (database).\n        String wikiName = \"\";\n        // wikiDefinition should be the document holding the definition of the virtual wiki, a document in the main\n        // wiki with a XWiki.XWikiServerClass object attached to it\n        DocumentReference wikiDefinition;\n\n        XWikiRequest request = context.getRequest();\n        try {\n            URL requestURL = context.getURL();\n            host = requestURL.getHost();\n        } catch (Exception e) {\n        }\n\n        // In path-based multi-wiki, the wiki name is an element of the request path.\n        // The url is in the form /xwiki (app name)/wiki (servlet name)/wikiname/\n        if (\"1\".equals(this.Param(\"xwiki.virtual.usepath\", \"1\"))) {\n            String uri = request.getRequestURI();\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Request uri is: \" + uri);\n            }\n            // Remove the (eventual) context path from the URI, usually /xwiki\n            uri = stripSegmentFromPath(uri, request.getContextPath());\n            // Remove the (eventual) servlet path from the URI, usually /wiki\n            String servletPath = request.getServletPath();\n            uri = stripSegmentFromPath(uri, servletPath);\n\n            if (servletPath.equals(\"/\" + this.Param(\"xwiki.virtual.usepath.servletpath\", \"wiki\"))) {\n                // Requested path corresponds to a path-based wiki, now the wiki name is between the first and\n                // second \"/\"\n                host = StringUtils.substringBefore(StringUtils.removeStart(uri, \"/\"), \"/\");\n            }\n        }\n\n        if (StringUtils.isEmpty(host) || host.equals(context.getMainXWiki())) {\n            // Can't find any wiki name, return the main wiki\n            return context.getMainXWiki();\n        }\n\n        // Try to use the full domain name/path wiki name and see if it corresponds to any existing wiki descriptors\n        wikiDefinition = this.findWikiServer(host, context);\n\n        if (wikiDefinition == null) {\n            // No definition found based on the full domain name/path wiki name, try to use the first part of the domain\n            // name as the wiki name\n            String servername = StringUtils.substringBefore(host, \".\");\n\n            // Note: Starting 5.0M2, the autowww behavior is default and the ability to disable it is now removed.\n            if (\"0\".equals(this.Param(\"xwiki.virtual.autowww\"))) {\n                LOGGER.warn(String.format(\"%s %s\", \"'xwiki.virtual.autowww' is no longer supported.\",\n                    \"Please update your configuration and/or see XWIKI-8877 for more details.\"));\n            }\n\n            // As a convenience, we do not require the creation of an xwiki:XWiki.XWikiServerXwiki page for the main\n            // wiki and automatically go to the main wiki in certain cases:\n            // - \"www.<anyDomain>.<domainExtension>\" - if it starts with www, we first check if a subwiki with that\n            // name exists; if yes, the go to the \"www\" subwiki, if not, go to the main wiki\n            // - \"localhost\"\n            // - IP address\n            if (\"www\".equals(servername)) {\n                // Check that \"www\" is not actually the name of an existing subwiki.\n                wikiDefinition = this.findWikiServer(servername, context);\n                if (wikiDefinition == null) {\n                    // Not the case, use the main wiki.\n                    return context.getMainXWiki();\n                }\n            } else if (\"localhost\".equals(host) || host.matches(\"[0-9]{1,3}(?:\\\\.[0-9]{1,3}){3}\")) {\n                // Direct access to the main wiki.\n                return context.getMainXWiki();\n            }\n\n            // Use the name from the subdomain\n            wikiName = servername;\n\n            if (!context.isMainWiki(wikiName)\n                && !\"1\".equals(context.getWiki().Param(\"xwiki.virtual.failOnWikiDoesNotExist\", \"0\"))) {\n                // Check if the wiki really exists\n                if (!exists(getServerWikiPage(wikiName), context)) {\n                    // Fallback on main wiki\n                    wikiName = context.getMainXWiki();\n                }\n            }\n        } else {\n            // Use the name from the located wiki descriptor\n            wikiName = StringUtils.removeStart(wikiDefinition.getName(), \"XWikiServer\").toLowerCase();\n        }\n\n        return wikiName;\n    }\n\n    /**\n     * Searches for the document containing the definition of the virtual wiki corresponding to the specified hostname.\n     *\n     * @param host the hostname, as specified in the request (for example: {@code forge.xwiki.org})\n     * @param context the current context\n     * @return the name of the document containing the wiki definition, or {@code null} if no wiki corresponds to the\n     *         hostname\n     * @throws XWikiException if a problem occurs while searching the storage\n     */\n    private DocumentReference XWiki.findWikiServer(String host, XWikiContext context) throws XWikiException\n    {\n        try {\n          WikiDescriptor descriptor = Utils.getComponent(WikiDescriptorManager.class).getByAlias(host);\n\n          if (descriptor != null) {\n              return new DocumentReference(context.getMainXWiki(), \"XWiki\",\n                  \"XWikiServer\" + StringUtils.capitalize(descriptor.getId()));\n          }\n        } catch (WikiManagerException e) {\n            LOGGER.warn(\"Error when searching for wiki name from URL host [\" + host + \"]\", e);\n        }\n\n        return null;\n    }\n\n    /**\n     * @deprecated replaced by {@link #setUserDefaultGroup(String fullwikiname, XWikiContext context)}\n     * @param context\n     * @param fullwikiname\n     * @throws XWikiException\n     */\n    @Deprecated\n    public void XWiki.SetUserDefaultGroup(XWikiContext context, String fullwikiname) throws XWikiException\n    {\n        this.setUserDefaultGroup(fullwikiname, context);\n    }\n\n    /**\n     * @deprecated replaced by {@link #protectUserPage(String,String,XWikiDocument,XWikiContext)}\n     * @param context\n     * @param fullwikiname\n     * @param userRights\n     * @param doc\n     * @throws XWikiException\n     */\n    @Deprecated\n    public void XWiki.ProtectUserPage(XWikiContext context, String fullwikiname, String userRights, XWikiDocument doc)\n        throws XWikiException\n    {\n        this.protectUserPage(fullwikiname, userRights, doc, context);\n    }\n\n    /**\n     * @return the cache factory.\n     * @since 1.5M2.\n     * @deprecated Since 1.7M1, use {@link CacheManager} component instead using {@link Utils#getComponent(Class)}\n     */\n    @Deprecated\n    public CacheFactory XWiki.getCacheFactory()\n    {\n        CacheFactory cacheFactory;\n\n        String cacheHint = Param(\"xwiki.cache.cachefactory.hint\", null);\n\n        if (StringUtils.isEmpty(cacheHint) || Utils.getComponent(CacheFactory.class, cacheHint) == null) {\n            CacheManager cacheManager = Utils.getComponent(CacheManager.class);\n            try {\n                cacheFactory = cacheManager.getCacheFactory();\n            } catch (ComponentLookupException e) {\n                throw new RuntimeException(\"Failed to get cache factory component\", e);\n            }\n        } else {\n            cacheFactory = Utils.getComponent(CacheFactory.class, cacheHint);\n        }\n\n        return cacheFactory;\n    }\n\n    /**\n     * @return the cache factory creating local caches.\n     * @since 1.5M2.\n     * @deprecated Since 1.7M1, use {@link CacheManager} component instead using {@link Utils#getComponent(Class)}\n     */\n    @Deprecated\n    public CacheFactory XWiki.getLocalCacheFactory()\n    {\n        CacheFactory localCacheFactory;\n\n        String localCacheHint = Param(\"xwiki.cache.cachefactory.local.hint\", null);\n\n        if (StringUtils.isEmpty(localCacheHint) || Utils.getComponent(CacheFactory.class, localCacheHint) == null) {\n            CacheManager cacheManager = Utils.getComponent(CacheManager.class);\n            try {\n                localCacheFactory = cacheManager.getLocalCacheFactory();\n            } catch (ComponentLookupException e) {\n                throw new RuntimeException(\"Failed to get local cache factory component\", e);\n            }\n        } else {\n            localCacheFactory = Utils.getComponent(CacheFactory.class, localCacheHint);\n        }\n\n        return localCacheFactory;\n    }\n\n    /**\n     * @deprecated since 2.3M1 use {@link #hasVersioning(XWikiContext)} instead\n     */\n    @Deprecated\n    public boolean XWiki.hasVersioning(String fullName, XWikiContext context)\n    {\n        return hasVersioning(context);\n    }\n\n    /**\n     * @deprecated replaced by {@link #include(String topic, boolean isForm, XWikiContext context)}\n     * @param topic\n     * @param context\n     * @param isForm\n     * @return\n     * @throws XWikiException\n     */\n    @Deprecated\n    public String XWiki.include(String topic, XWikiContext context, boolean isForm) throws XWikiException\n    {\n        return include(topic, isForm, context);\n    }\n    \n    /**\n     * Checks if the wiki is running in test mode.\n     * \n     * @return {@code true} if the wiki is running Cactus tests, {@code false} otherwise\n     * @deprecated No longer used.\n     */\n    @Deprecated\n    public boolean XWiki.isTest()\n    {\n        return this.test;\n    }\n\n    /**\n     * Marks that the wiki is running in test mode.\n     * \n     * @param test whether tests are being executed\n     * @deprecated No longer used.\n     */\n    @Deprecated\n    public void XWiki.setTest(boolean test)\n    {\n        this.test = test;\n    }\n\n    /**\n     * @deprecated use {@link org.xwiki.localization.LocalizationManager} instead. From velocity you can access it using\n     *             the {@code $services.localization} binding, see {@code LocalizationScriptService}\n     */\n    @Deprecated\n    public String XWiki.parseMessage(XWikiContext context)\n    {\n        String message = (String) context.get(\"message\");\n        if (message == null) {\n            return null;\n        }\n\n        return parseMessage(message, context);\n    }\n\n    /**\n     * @deprecated use {@link org.xwiki.localization.LocalizationManager} instead. From velocity you can access it using\n     *             the {@code $services.localization} binding, see {@code LocalizationScriptService}\n     */\n    @Deprecated\n    public String XWiki.parseMessage(String id, XWikiContext context)\n    {\n        XWikiMessageTool msg = context.getMessageTool();\n\n        List<?> parameters = (List<?>) context.get(\"messageParameters\");\n\n        String translatedMessage;\n        if (parameters != null) {\n            translatedMessage = msg.get(id, parameters);\n        } else {\n            translatedMessage = msg.get(id);\n        }\n\n        return parseContent(translatedMessage, context);\n    }\n\n    /**\n     * @deprecated starting with 6.1M2 this method shouldn't be used. There's no replacement, it's just not the right\n     *             way to do this anymore and the flash.vm template doesn't exist anymore\n     */\n    @Deprecated\n    public String XWiki.getFlash(String url, String width, String height, XWikiContext context)\n    {\n        VelocityContext vorigcontext = ((VelocityContext) context.get(\"vcontext\"));\n        try {\n            VelocityContext vcontext = (VelocityContext) vorigcontext.clone();\n            vcontext.put(\"flashurl\", url);\n            vcontext.put(\"width\", width);\n            vcontext.put(\"height\", height);\n            context.put(\"vcontext\", vcontext);\n\n            return parseTemplate(\"flash.vm\", context);\n        } finally {\n            context.put(\"vcontext\", vorigcontext);\n        }\n    }\n\n    /**\n     * @deprecated replaced by the <a href=\"http://code.xwiki.org/xwiki/bin/view/Plugins/MailSenderPlugin\">Mail Sender\n     *             Plugin</a>\n     */\n    @Deprecated\n    public void XWiki.sendMessage(String sender, String[] recipients, String rawMessage, XWikiContext context)\n        throws XWikiException\n    {\n        LOGGER.trace(\"Entering sendMessage()\");\n\n        // We'll be using the MailSender plugin, which has much more advanced capabilities (authentication, TLS).\n        // Since the plugin is in another module, and it depends on the core, we have to use it through reflection in\n        // order to avoid cyclic dependencies. This should be fixed once the mailsender becomes a clean component\n        // instead of a plugin.\n        Object mailSender;\n        Class mailSenderClass;\n        Method mailSenderSendRaw;\n\n        try {\n            mailSender = getPluginApi(\"mailsender\", context);\n            mailSenderClass = Class.forName(\"com.xpn.xwiki.plugin.mailsender.MailSenderPluginApi\");\n\n            // public int sendRawMessage(String from, String to, String rawMessage)\n            mailSenderSendRaw =\n                mailSenderClass.getMethod(\"sendRawMessage\", new Class[] {String.class, String.class, String.class});\n        } catch (Exception e) {\n            LOGGER.error(\"Problem getting MailSender via Reflection. Using the old sendMessage mechanism.\", e);\n            sendMessageOld(sender, recipients, rawMessage, context);\n            return;\n        }\n\n        if (LOGGER.isTraceEnabled()) {\n            LOGGER.trace(\"Sending message = \\\"\" + rawMessage + \"\\\"\");\n        }\n\n        String messageRecipients = StringUtils.join(recipients, ',');\n\n        try {\n            mailSenderSendRaw.invoke(mailSender, sender, messageRecipients, rawMessage);\n        } catch (InvocationTargetException ite) {\n            Throwable cause = ite.getCause();\n            if (cause instanceof XWikiException) {\n                throw (XWikiException) cause;\n            } else {\n                throw new RuntimeException(cause);\n            }\n        } catch (Exception e) {\n            // Probably either IllegalAccessException or IllegalArgumentException\n            // Shouldn't happen unless there were an incompatible code change\n            throw new RuntimeException(e);\n        }\n\n        LOGGER.info(\"Exiting sendMessage(). It seems everything went ok.\");\n    }\n\n    /**\n     * @deprecated replaced by the <a href=\"http://code.xwiki.org/xwiki/bin/view/Plugins/MailSenderPlugin\">Mail Sender\n     *             Plugin</a>\n     */\n    @Deprecated\n    private void XWiki.sendMessageOld(String sender, String[] recipient, String message, XWikiContext context)\n        throws XWikiException\n    {\n        SMTPClient smtpc = null;\n        try {\n            String server = getXWikiPreference(\"smtp_server\", context);\n            String port = getXWikiPreference(\"smtp_port\", context);\n            String login = getXWikiPreference(\"smtp_login\", context);\n\n            if (context.get(\"debugMail\") != null) {\n                StringBuffer msg = new StringBuffer(message);\n                msg.append(\"\\n Recipient: \");\n                msg.append(recipient);\n                recipient = ((String) context.get(\"debugMail\")).split(\",\");\n                message = msg.toString();\n            }\n\n            if ((server == null) || server.equals(\"\")) {\n                server = \"127.0.0.1\";\n            }\n            if ((port == null) || (port.equals(\"\"))) {\n                port = \"25\";\n            }\n            if ((login == null) || login.equals(\"\")) {\n                login = InetAddress.getLocalHost().getHostName();\n            }\n\n            smtpc = new SMTPClient();\n            smtpc.connect(server, Integer.parseInt(port));\n            int reply = smtpc.getReplyCode();\n            if (!SMTPReply.isPositiveCompletion(reply)) {\n                Object[] args = {server, port, Integer.valueOf(reply), smtpc.getReplyString()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                    XWikiException.ERROR_XWIKI_EMAIL_CONNECT_FAILED,\n                    \"Could not connect to server {0} port {1} error code {2} ({3})\", null, args);\n            }\n\n            if (smtpc.login(login) == false) {\n                reply = smtpc.getReplyCode();\n                Object[] args = {server, port, Integer.valueOf(reply), smtpc.getReplyString()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                    XWikiException.ERROR_XWIKI_EMAIL_LOGIN_FAILED,\n                    \"Could not login to mail server {0} port {1} error code {2} ({3})\", null, args);\n            }\n\n            if (smtpc.sendSimpleMessage(sender, recipient, message) == false) {\n                reply = smtpc.getReplyCode();\n                Object[] args = {server, port, Integer.valueOf(reply), smtpc.getReplyString()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                    XWikiException.ERROR_XWIKI_EMAIL_SEND_FAILED,\n                    \"Could not send mail to server {0} port {1} error code {2} ({3})\", null, args);\n            }\n\n        } catch (IOException e) {\n            Object[] args = {sender, recipient};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_ERROR_SENDING_EMAIL, \"Exception while sending email from {0} to {1}\",\n                e, args);\n        } finally {\n            if ((smtpc != null) && (smtpc.isConnected())) {\n                try {\n                    smtpc.disconnect();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    /**\n     * @deprecated replaced by the <a href=\"http://code.xwiki.org/xwiki/bin/view/Plugins/MailSenderPlugin\">Mail Sender\n     *             Plugin</a>\n     */\n    @Deprecated\n    public void XWiki.sendMessage(String sender, String recipient, String message, XWikiContext context)\n        throws XWikiException\n    {\n        String[] recip = recipient.split(\",\");\n        sendMessage(sender, recip, message, context);\n    }\n\n    /**\n     * @deprecated since 7.0M1. This method should have actually been deprecated since 2.3M1, but it was left forgotten\n     *             and unused.\n     */\n    @Deprecated\n    public boolean XWiki.hasCaptcha(XWikiContext context)\n    {\n        return (this.getXWikiPreferenceAsInt(\"captcha_enabled\", \"xwiki.plugin.captcha\", 0, context) == 1);\n    }\n\n    /**\n     * @deprecated since 6.1M2, directly lookup default {@link com.xpn.xwiki.render.XWikiRenderingEngine} component\n     *             instead\n     */\n    @Deprecated\n    public Object XWiki.getRenderingEngine()\n    {\n        try {\n            return Utils.getComponent(getClass().forName(\"com.xpn.xwiki.render.XWikiRenderingEngine\"));\n        } catch (ClassNotFoundException e) {\n            return null;\n        }\n    }\n\n    @Deprecated\n    public void XWiki.resetRenderingEngine(XWikiContext context) throws XWikiException\n    {\n        getOldRendering().resetRenderingEngine(context);\n    }\n\n    /**\n     * @deprecated use {@link EntityReferenceResolver} instead\n     */\n    @Deprecated\n    public String XWiki.getDocName(String fullName)\n    {\n        return fullName.substring(fullName.indexOf('.') + 1);\n    }\n\n    /**\n     * @deprecated use {@link Date#Date()} instead...\n     */\n    @Deprecated\n    public Date XWiki.getCurrentDate()\n    {\n        return new Date();\n    }\n\n    /**\n     * @deprecated use {@link Date#Date(long)} instead...\n     */\n    @Deprecated\n    public Date XWiki.getDate(long time)\n    {\n        return new Date(time);\n    }\n\n    /**\n     * @deprecated removed to support referencing a top level Nested Page easily. This method is there to prevent\n     *             any existing extension from breaking but the XWiki core code doesn't use call this method anymore\n     *             and thus it has not effect anymore\n     */\n    @Deprecated\n    public boolean XWiki.skipDefaultSpaceInURLs(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"usedefaultweb\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.usedefaultweb\", \"0\"));\n    }\n\n    /**\n     * @deprecated use {@link XWikiDocument#rename(String, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument XWiki.renamePage(XWikiDocument doc, XWikiContext context, String newFullName)\n        throws XWikiException\n    {\n        return renamePage(doc, newFullName, context);\n    }\n\n    /**\n     * @deprecated Since 12.0RC1: Use {@link XWikiDocument#rename(DocumentReference, XWikiContext)} instead.\n     */\n    @Deprecated\n    public void XWiki.renamePage(String fullName, String newFullName, XWikiContext context) throws XWikiException\n    {\n        renamePage(context.getWiki().getDocument(fullName, context), newFullName, context);\n    }\n\n    /**\n     * @deprecated use {@link XWikiDocument#rename(String, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument XWiki.renamePage(XWikiDocument doc, String newFullName, XWikiContext context)\n        throws XWikiException\n    {\n        if (context.getWiki().exists(newFullName, context)) {\n            XWikiDocument delDoc = context.getWiki().getDocument(newFullName, context);\n            context.getWiki().deleteDocument(delDoc, context);\n        }\n\n        XWikiDocument renamedDoc = doc.copyDocument(newFullName, context);\n        saveDocument(renamedDoc, context);\n        renamedDoc.saveAllAttachments(context);\n        deleteDocument(doc, context);\n\n        return renamedDoc;\n    }\n\n    /**\n     * @return the ids of configured syntaxes for this wiki (e.g. {@code xwiki/2.0}, {@code xwiki/2.1},\n     *         {@code mediawiki/1.0}, etc), taken only from {@code xwiki.cfg} (using the\n     *         {@code xwiki.rendering.syntaxes} property)\n     * @deprecated since 8.2M1, use the XWiki Rendering Configuration component or the Rendering Script Service one\n     *             instead (they use a more elaborate algorithm to find out the supported syntaxes)\n     */\n    @Deprecated\n    public List<String> XWiki.getConfiguredSyntaxes()\n    {\n        if (this.configuredSyntaxes == null) {\n            ExtendedRenderingConfiguration extendedRenderingConfiguration =\n                Utils.getComponent(ExtendedRenderingConfiguration.class);\n            String syntaxes = getConfiguration().getProperty(\"xwiki.rendering.syntaxes\",\n                extendedRenderingConfiguration.getDefaultContentSyntax().toIdString());\n            this.configuredSyntaxes = Arrays.asList(StringUtils.split(syntaxes, \" ,\"));\n        }\n        return this.configuredSyntaxes;\n    }\n\n    /**\n     * Designed to include dynamic content, such as Servlets or JSPs, inside Velocity templates; works by creating a\n     * RequestDispatcher, buffering the output, then returning it as a string.\n     * \n     * @deprecated since 12.10.9, 13.4.3, 13.7RC1\n     */\n    @Deprecated\n    public String XWiki.invokeServletAndReturnAsString(String url, XWikiContext xwikiContext)\n    {\n        HttpServletRequest servletRequest = xwikiContext.getRequest();\n        HttpServletResponse servletResponse = xwikiContext.getResponse();\n\n        try {\n            return IncludeServletAsString.invokeServletAndReturnAsString(url, servletRequest, servletResponse);\n        } catch (Exception e) {\n            LOGGER.warn(\"Exception including url: \" + url, e);\n            return \"Exception including \\\"\" + url + \"\\\", see logs for details.\";\n        }\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.api;\n\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.query.QueryManager;\nimport org.xwiki.xml.XMLUtils;\nimport org.suigeneris.jrcs.diff.delta.Chunk;\n\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.plugin.query.XWikiCriteria;\nimport com.xpn.xwiki.plugin.query.XWikiQuery;\nimport com.xpn.xwiki.stats.api.XWikiStatsService;\nimport com.xpn.xwiki.stats.impl.DocumentStats;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiMessageTool;\nimport com.xpn.xwiki.internal.render.OldRendering;\n\n/**\n * Add a backward compatibility layer to the {@link com.xpn.xwiki.api.XWiki} class.\n *\n * @version $Id$\n */\npublic privileged aspect XWikiCompatibilityAspect\n{\n    /**\n     * Utility methods have been moved in version 1.3 Milestone 2 to the {@link Util} class.\n     * However to preserve backward compatibility we have deprecated them in this class and\n     * not removed them yet. All calls are funnelled through this class variable.\n     */\n    private Util XWiki.util;\n\n    /**\n     * Capture the api.XWiki constructor so that we can initialize this.util.\n     */\n    private pointcut xwikiCreation(XWiki x): this(x) && execution( public com.xpn.xwiki.api.XWiki.new(..) );\n\n    after(XWiki x): xwikiCreation(x)\n    {\n        x.util = new Util(x.xwiki, x.context);\n    }\n\n    /**\n     * API to protect Text from Wiki transformation\n     * @param text\n     * @return escaped text\n     * @deprecated replaced by Util#escapeText since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.escapeText(String text)\n    {\n        return this.util.escapeText(text);\n    }\n\n    /**\n     * API to protect URLs from Wiki transformation\n     * @param url\n     * @return encoded URL\n     * @deprecated replaced by Util#escapeURL since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.escapeURL(String url)\n    {\n        return this.util.escapeURL(url);\n    }\n\n    /**\n     * @deprecated use {@link #getLanguagePreference()} instead\n     */\n    @Deprecated\n    public String XWiki.getDocLanguagePreference()\n    {\n        return xwiki.getDocLanguagePreference(getXWikiContext());\n    }\n\n    /**\n     * Privileged API to send a message to an email address\n     *\n     * @param sender email of the sender of the message\n     * @param recipient email of the recipient of the message\n     * @param message Message to send\n     * @throws XWikiException if the mail was not send successfully\n     * @deprecated replaced by the\n     *   <a href=\"http://code.xwiki.org/xwiki/bin/view/Plugins/MailSenderPlugin\">Mail Sender\n     *   Plugin</a> since 1.3M2\n     */\n    @Deprecated\n    public void XWiki.sendMessage(String sender, String recipient, String message)\n        throws XWikiException\n    {\n        if (hasProgrammingRights())\n            xwiki.sendMessage(sender, recipient, message, getXWikiContext());\n    }\n\n    /**\n     * Privileged API to send a message to an email address\n     *\n     * @param sender email of the sender of the message\n     * @param recipient emails of the recipients of the message\n     * @param message Message to send\n     * @throws XWikiException if the mail was not send successfully\n     * @deprecated replaced by the\n     *   <a href=\"http://code.xwiki.org/xwiki/bin/view/Plugins/MailSenderPlugin\">Mail Sender\n     *   Plugin</a> since 1.3M2\n     */\n    @Deprecated\n    public void XWiki.sendMessage(String sender, String[] recipient, String message)\n        throws XWikiException\n    {\n        if (hasProgrammingRights())\n            xwiki.sendMessage(sender, recipient, message, getXWikiContext());\n    }\n\n    /**\n     * @return the current date\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#getDate()} since 1.3M2\n     */\n    @Deprecated\n    public Date XWiki.getCurrentDate()\n    {\n        return this.util.getDate();\n    }\n\n    /**\n     * @return the current date\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#getDate()} since 1.3M2\n     */\n    @Deprecated\n    public Date XWiki.getDate()\n    {\n        return this.util.getDate();\n    }\n\n    /**\n     * @param time the time in milliseconds\n     * @return the time delta in milliseconds between the current date and the time passed\n     *         as parameter\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#getTimeDelta(long)} since 1.3M2\n     */\n    @Deprecated\n    public int XWiki.getTimeDelta(long time)\n    {\n        return this.util.getTimeDelta(time);\n    }\n\n    /**\n     * @param time time in milliseconds since 1970, 00:00:00 GMT\n     * @return Date a date from a time in milliseconds since 01/01/1970 as a\n     *         Java {@link Date} Object\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#getDate(long)} since 1.3M2\n     */\n    @Deprecated\n    public Date XWiki.getDate(long time)\n    {\n        return this.util.getDate(time);\n    }\n\n    /**\n     * Split a text to an array of texts, according to a separator.\n     *\n     * @param text the original text\n     * @param sep the separator characters. The separator is one or more of the\n     *        separator characters\n     * @return An array containing the split text\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#split(String, String)} since 1.3M2\n     */\n    @Deprecated\n    public String[] XWiki.split(String text, String sep)\n    {\n        return this.util.split(text, sep);\n    }\n\n    /**\n     * Get a stack trace as a String\n     *\n     * @param e the exception to convert to a String\n     * @return the exception stack trace as a String\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#printStrackTrace(Throwable)}\n     *             since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.printStrackTrace(Throwable e)\n    {\n        return this.util.printStrackTrace(e);\n    }\n\n    /**\n     * Get a Null object. This is useful in Velocity where there is no real null object\n     * for comparaisons.\n     *\n     * @return a Null Object\n     * @deprecated replaced by {@link Util#getNull()} since 1.3M2\n     */\n    @Deprecated\n    public Object XWiki.getNull()\n    {\n        return this.util.getNull();\n    }\n\n    /**\n     * Get a New Line character. This is useful in Velocity where there is no real new\n     * line character for inclusion in texts.\n     *\n     * @return a new line character\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#getNewline()} since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.getNl()\n    {\n        return this.util.getNewline();\n    }\n\n    /**\n     * Creates an Array List. This is useful from Velocity since you cannot\n     * create Object from Velocity with our secure uberspector.\n     *\n     * @return a {@link ArrayList} object\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#getArrayList()} since 1.3M2\n     */\n    @Deprecated\n    public List XWiki.getArrayList()\n    {\n        return this.util.getArrayList();\n    }\n\n    /**\n     * Creates a Hash Map. This is useful from Velocity since you cannot\n     * create Object from Velocity with our secure uberspector.\n     *\n     * @return a {@link HashMap} object\n     * @deprecated replaced by {@link Util#getHashMap()} since 1.3M2\n     */\n    @Deprecated\n    public Map XWiki.getHashMap()\n    {\n        return this.util.getHashMap();\n    }\n\n    /**\n     * Creates a Tree Map. This is useful from Velocity since you cannot\n     * create Object from Velocity with our secure uberspector.\n     *\n     * @return a {@link TreeMap} object\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#getTreeMap()} since 1.3M2\n     */\n    @Deprecated\n    public Map XWiki.getTreeMap()\n    {\n        return this.util.getTreeMap();\n    }\n\n    /**\n     * Sort a list using a standard comparator. Elements need to be mutally comparable and\n     * implement the Comparable interface.\n     *\n     * @param list the list to sort\n     * @return the sorted list (as the same oject reference)\n     * @see {@link java.util.Collections#sort(java.util.List)}\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#sort(java.util.List)} since 1.3M2\n     */\n    @Deprecated\n    public List XWiki.sort(List list)\n    {\n        return this.util.sort(list);\n    }\n\n    /**\n     * Convert an Object to a number and return null if the object is not a Number.\n     *\n     * @param object the object to convert\n     * @return the object as a {@link Number}\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#toNumber(Object)} since 1.3M2\n     */\n    @Deprecated\n    public Number XWiki.toNumber(Object object)\n    {\n        return this.util.toNumber(object);\n    }\n\n    /**\n     * Generate a random string.\n     *\n     * @param size the desired size of the string\n     * @return the randomly generated string\n     * @deprecated replaced by {@link com.xpn.xwiki.api.Util#generateRandomString(int)}\n                   since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.generateRandomString(int size)\n    {\n        return this.util.generateRandomString(size);\n    }\n\n    /**\n     * Output a BufferedImage object into the response outputstream.\n     * Once this method has been called, not further action is possible.\n     * Users should set $context.setFinished(true) to\n     * avoid template output The image is outpout as image/jpeg.\n     *\n     * @param image the BufferedImage to output\n     * @throws java.io.IOException if the output fails\n     * @deprecated replaced by\n     *             {@link com.xpn.xwiki.api.Util#outputImage(java.awt.image.BufferedImage)}\n     *             since 1.3M2\n     */\n    @Deprecated\n    public void XWiki.outputImage(BufferedImage image) throws IOException\n    {\n        this.util.outputImage(image);\n    }\n\n    /**\n     * Returns the recently visited pages for a specific action\n     *\n     * @param action (\"view\" or \"edit\")\n     * @param size how many recent actions to retrieve\n     * @return a ArrayList of document names\n     * @deprecated use {@link #getStatsService()} instead\n     */\n    @Deprecated\n    public java.util.Collection XWiki.getRecentActions(String action, int size)\n    {\n        XWikiStatsService stats = getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        if (stats == null)\n            return Collections.EMPTY_LIST;\n        return stats.getRecentActions(action, size, getXWikiContext());\n    }\n\n    /**\n     * @param str the String to convert to an integer\n     * @return the parsed integer or zero in case of exception\n     * @deprecated replaced by {@link Util#parseInt(String)} since 1.3M2\n     */\n    @Deprecated\n    public int XWiki.parseInt(String str)\n    {\n        return this.util.parseInt(str);\n    }\n\n    /**\n     * @param str the String to convert to an Integer Object\n     * @return the parsed integer or zero in case of exception\n     * @deprecated replaced by {@link Util#parseInteger(String)} since 1.3M2\n     */\n    @Deprecated\n    public Integer XWiki.parseInteger(String str)\n    {\n        return this.util.parseInteger(str);\n    }\n\n    /**\n     * @param str the String to convert to a long\n     * @return the parsed long or zero in case of exception\n     * @deprecated replaced by {@link Util#parseLong(String)} since 1.3M2\n     */\n    @Deprecated\n    public long XWiki.parseLong(String str)\n    {\n        return this.util.parseLong(str);\n    }\n\n    /**\n     * @param str the String to convert to a float\n     * @return the parsed float or zero in case of exception\n     * @deprecated replaced by {@link Util#parseFloat(String)} since 1.3M2\n     */\n    @Deprecated\n    public float XWiki.parseFloat(String str)\n    {\n        return this.util.parseFloat(str);\n    }\n\n    /**\n     * @param str the String to convert to a double\n     * @return the parsed double or zero in case of exception\n     * @deprecated replaced by {@link Util#parseDouble(String)} since 1.3M2\n     */\n    @Deprecated\n    public double XWiki.parseDouble(String str)\n    {\n        return this.util.parseDouble(str);\n    }\n\n    /**\n     * Escape text so that it can be used in a like clause or in a test for equality clause.\n     * For example it escapes single quote characters.\n     *\n     * @param text the text to escape\n     * @return filtered text\n     * @deprecated replaced by {@link Util#escapeSQL(String)} since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.sqlfilter(String text)\n    {\n        return this.util.escapeSQL(text);\n    }\n\n    /**\n     * Cleans up the passed text by removing all accents and special characters to make it\n     * a valid page name.\n     *\n     * @param name the page name to normalize\n     * @return the valid page name\n     * @deprecated replaced by {@link Util#clearName(String)} since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.clearName(String name)\n    {\n        return this.util.clearName(name);\n    }\n\n    /**\n     * Replace all accents by their alpha equivalent.\n     *\n     * @param text the text to parse\n     * @return a string with accents replaced with their alpha equivalent\n     * @deprecated replaced by {@link Util#clearAccents(String)} since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.clearAccents(String text)\n    {\n        return this.util.clearAccents(text);\n    }\n\n    /**\n     * Add a and b because Velocity operations are not always working.\n     *\n     * @param a an integer to add\n     * @param b an integer to add\n     * @return the sum of a and b\n     * @deprecated replaced by {@link Util#add(int, int)} since 1.3M2\n     */\n    @Deprecated\n    public int XWiki.add(int a, int b)\n    {\n        return this.util.add(a, b);\n    }\n\n    /**\n     * Add a and b because Velocity operations are not working with longs.\n     *\n     * @param a a long to add\n     * @param b a long to add\n     * @return the sum of a and b\n     * @deprecated replaced by {@link Util#add(long, long)} since 1.3M2\n     */\n    @Deprecated\n    public long XWiki.add(long a, long b)\n    {\n        return this.util.add(a, b);\n    }\n\n    /**\n     * Add a and b where a and b are non decimal numbers specified as Strings.\n     *\n     * @param a a string representing a non decimal number\n     * @param b a string representing a non decimal number\n     * @return the sum of a and b as a String\n     * @deprecated replaced by {@link Util#add(String, String)} since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.add(String a, String b)\n    {\n        return this.util.add(a,  b);\n    }\n\n    /**\n     * Transform a text in a URL compatible text\n     * \n     * @param content text to transform\n     * @return encoded result\n     * @deprecated replaced by {@link Util#encodeURI(String)} since 1.3M2\n     */\n    @Deprecated\n    public String XWiki.getURLEncoded(String content)\n    {\n        return this.util.encodeURI(content);\n    }\n    \n    /**\n     * @return true for multi-wiki/false for mono-wiki\n     * @deprecated replaced by {@link XWiki#isVirtualMode()} since 1.4M1.\n     */\n    @Deprecated\n    public boolean XWiki.isVirtual()\n    {\n        return this.isVirtualMode();\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpaceCopyright()} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebCopyright()\n    {\n        return this.getSpaceCopyright();\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreference(String)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebPreference(String preference)\n    {\n        return this.getSpacePreference(preference);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceFor(String, String)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebPreferenceFor(String preference, String space)\n    {\n        return this.getSpacePreferenceFor(preference, space);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceFor(String, String, String)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebPreferenceFor(String preference, String space, String defaultValue)\n    {\n        return this.getSpacePreferenceFor(preference, space, defaultValue);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsLong(String, long)} since 2.3M1\n     */\n    @Deprecated\n    public long XWiki.getWebPreferenceAsLong(String preference, long defaultValue)\n    {\n        return this.getSpacePreferenceAsLong(preference, defaultValue);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsLong(String)} since 2.3M1\n     */\n    @Deprecated\n    public long XWiki.getWebPreferenceAsLong(String preference)\n    {\n        return this.getSpacePreferenceAsLong(preference);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsInt(String, int)} since 2.3M1\n     */\n    @Deprecated\n    public int XWiki.getWebPreferenceAsInt(String preference, int defaultValue)\n    {\n        return this.getSpacePreferenceAsInt(preference, defaultValue);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreference(String, String)} since 2.3M1\n     */\n    @Deprecated\n    public String XWiki.getWebPreference(String preference, String defaultValue)\n    {\n        return this.getSpacePreference(preference, defaultValue);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#getSpacePreferenceAsInt(String)} since 2.3M1\n     */\n    @Deprecated\n    public int XWiki.getWebPreferenceAsInt(String preference)\n    {\n        return this.getSpacePreferenceAsInt(preference);\n    }\n\n    /**\n     * @deprecated replaced by {@link XWiki#copySpaceBetweenWikis(String, String, String, String, boolean)} since 2.3M1\n     */\n    @Deprecated\n    public int XWiki.copyWikiWeb(String space, String sourceWiki, String targetWiki, String language, boolean clean)\n        throws XWikiException\n    {\n        return this.copySpaceBetweenWikis(space, sourceWiki, targetWiki, language, clean);\n    }\n\n    /**\n     * API to parse a message. A message can be an error message or an information message either as text or as a message\n     * ID pointing to ApplicationResources. The message is also parse for velocity scripts\n     * \n     * @return Final message\n     * @param id\n     * @return the result of the parsed message\n     * @deprecated use {@link XWikiMessageTool#get(String, List)} instead. From velocity you can access XWikiMessageTool\n     *             with $msg binding.\n     */\n    @Deprecated\n    public String XWiki.parseMessage(String id)\n    {\n        return this.xwiki.parseMessage(id, getXWikiContext());\n    }\n\n    /**\n     * API to get a message. A message can be an error message or an information message either as text or as a message\n     * ID pointing to ApplicationResources. The message is also parsed for velocity scripts\n     * \n     * @return Final message\n     * @param id\n     * @return the result of the parsed message\n     * @deprecated use {@link XWikiMessageTool#get(String, List)} instead. From velocity you can access XWikiMessageTool\n     *             with $msg binding.\n     */\n    @Deprecated\n    public String XWiki.getMessage(String id)\n    {\n        return this.xwiki.getMessage(id, getXWikiContext());\n    }\n\n    /**\n     * Transform a text in a form compatible text\n     * \n     * @param content text to transform\n     * @return encoded result\n     * @deprecated Use $escapetool.xml\n     */\n    @Deprecated\n    public String XWiki.getFormEncoded(String content)\n    {\n        return XMLUtils.escape(content);\n    }\n\n    /**\n     * Transform a text in a XML compatible text This method uses Apache CharacterFilter which swaps single quote\n     * (&#39;) for left single quotation mark (&#8217;)\n     * \n     * @param content text to transform\n     * @return encoded result\n     * @deprecated Use $escapetool.xml\n     */\n    @Deprecated\n    public String XWiki.getXMLEncoded(String content)\n    {\n        return XMLUtils.escape(content);\n    }\n\n    /**\n     * Output content in the edit content htmlarea\n     * \n     * @param content content to output\n     * @return the htmlarea text content\n     * @deprecated Removed since it isn't used; since 3.1M2.\n     */\n    @Deprecated\n    public String XWiki.getHTMLArea(String content)\n    {\n        return this.xwiki.getHTMLArea(content, getXWikiContext());\n    }\n    \n\n    /**\n     * API to display a select box for the list of available field for a specific class This field data can then be used\n     * to generate an XWiki Query showing a table with the relevant data\n     * \n     * @param className XWiki Class Name to display the list of columns for\n     * @param query Query to pre-select the currently selected columns\n     * @return text of the select field\n     * @throws XWikiException exception is a failure occured\n     */\n    @Deprecated\n    public String XWiki.displaySearchColumns(String className, XWikiQuery query) throws XWikiException\n    {\n        return this.xwiki.displaySearchColumns(className, \"\", query, getXWikiContext());\n    }\n\n    /**\n     * API to display a select box for the list of available field for a specific class, optionally adding a prefix This\n     * field data can then be used to generate an XWiki Query showing a table with the relevant data\n     * \n     * @param className XWiki Class Name to display the list of columns for\n     * @param prefix Prefix to add to the field name\n     * @param query Query to pre-select the currently selected columns\n     * @return text of the select field\n     * @throws XWikiException exception is a failure occured\n     */\n    @Deprecated\n    public String XWiki.displaySearchColumns(String className, String prefix, XWikiQuery query) throws XWikiException\n    {\n        return this.xwiki.displaySearchColumns(className, prefix, query, getXWikiContext());\n    }\n\n    /**\n     * API to display a select box for the list of available field for a specific class This field data can then be used\n     * to generate the order element of an XWiki Query showing a table with the relevant data\n     * \n     * @param className XWiki Class Name to display the list of columns for\n     * @param query Query to pre-select the currently selected columns\n     * @return text of the select field\n     * @throws XWikiException exception is a failure occured\n     */\n    @Deprecated\n    public String XWiki.displaySearchOrder(String className, XWikiQuery query) throws XWikiException\n    {\n        return this.xwiki.displaySearchOrder(className, \"\", query, getXWikiContext());\n    }\n\n    /**\n     * API to display a select box for the list of available field for a specific class, optionally adding a prefix This\n     * field data can then be used to generate the order element of an XWiki Query showing a table with the relevant\n     * data\n     * \n     * @param className XWiki Class Name to display the list of columns for\n     * @param prefix Prefix to add to the field name\n     * @param query Query to pre-select the currently selected columns\n     * @return text of the select field\n     * @throws XWikiException exception is a failure occured\n     */\n    @Deprecated\n    public String XWiki.displaySearchOrder(String className, String prefix, XWikiQuery query) throws XWikiException\n    {\n        return this.xwiki.displaySearchOrder(className, prefix, query, getXWikiContext());\n    }\n\n    /**\n     * API to run a search from an XWikiQuery Object An XWikiQuery object can be created from a request using the\n     * createQueryFromRequest function\n     * \n     * @param query query to run the search for\n     * @return A list of document names matching the query\n     * @throws XWikiException exception is a failure occured\n     */\n    public <T> List<T> XWiki.search(XWikiQuery query) throws XWikiException\n    {\n        return this.xwiki.search(query, getXWikiContext());\n    }\n\n    /**\n     * API to create a query from a request Object The request object is the result of a form created from the\n     * displaySearch() and displaySearchColumns() functions\n     * \n     * @param className class name to create the query from\n     * @return an XWikiQuery object matching the selected values in the request object\n     * @throws XWikiException exception is a failure occured\n     */\n    public XWikiQuery XWiki.createQueryFromRequest(String className) throws XWikiException\n    {\n        return this.xwiki.createQueryFromRequest(className, getXWikiContext());\n    }\n\n    /**\n     * API to run a search from an XWikiQuery Object and display it as a HTML table An XWikiQuery object can be created\n     * from a request using the createQueryFromRequest function\n     * \n     * @param query query to run the search for\n     * @return An HTML table showing the result\n     * @throws XWikiException exception is a failure occured\n     */\n    public String XWiki.searchAsTable(XWikiQuery query) throws XWikiException\n    {\n        return this.xwiki.searchAsTable(query, getXWikiContext());\n    }\n\n    /**\n     * API to display a field in search mode for a specific class with preselected values This field data can then be\n     * used to generate an XWiki Query showing a table with the relevant data\n     * \n     * @param fieldname field name in the class\n     * @param className class name to display the field from\n     * @param criteria XWikiCriteria object (usually the XWikiQuery object) to take the preselected values from\n     * @return text of the select field\n     * @throws XWikiException exception is a failure occured\n     */\n    public String XWiki.displaySearch(String fieldname, String className, XWikiCriteria criteria) throws XWikiException\n    {\n        return this.xwiki.displaySearch(fieldname, className, criteria, getXWikiContext());\n    }\n\n    /**\n     * API to display a field in search mode for a specific class with preselected values, optionally adding a prefix to\n     * the field name This field data can then be used to generate an XWiki Query showing a table with the relevant data\n     * \n     * @param fieldname field name in the class\n     * @param className class name to display the field from\n     * @param prefix prefix to add to the field name\n     * @param criteria XWikiCriteria object (usually the XWikiQuery object) to take the preselected values from\n     * @return text of the select field\n     * @throws XWikiException exception is a failure occured\n     */\n    public String XWiki.displaySearch(String fieldname, String className, String prefix, XWikiCriteria criteria)\n        throws XWikiException\n    {\n        return this.xwiki.displaySearch(fieldname, className, prefix, criteria, getXWikiContext());\n    }\n\n    /**\n     * API to display a field in search mode for a specific class without preselected values This field data can then be\n     * used to generate an XWiki Query showing a table with the relevant data\n     * \n     * @param fieldname field name in the class\n     * @param className class name to display the field from\n     * @return text of the select field\n     * @throws XWikiException exception is a failure occured\n     */\n    public String XWiki.displaySearch(String fieldname, String className) throws XWikiException\n    {\n        return this.xwiki.displaySearch(fieldname, className, getXWikiContext());\n    }\n\n    /**\n     * Priviledged API to create a new Wiki from an existing wiki This creates the database, copies to documents from a\n     * existing wiki Assigns the admin rights, creates the Wiki identification page in the main wiki\n     * \n     * @param wikiName Wiki Name to create\n     * @param wikiUrl Wiki URL to accept requests from\n     * @param wikiAdmin Wiki admin user\n     * @param baseWikiName Wiki to copy documents from\n     * @param failOnExist true to fail if the wiki already exists, false to overwrite\n     * @return Success of Failure code (0 for success, -1 for missing programming rights, > 0 for other errors\n     * @throws XWikiException\n     * @deprecated use WikiManager plugin instead\n     */\n    @Deprecated\n    public int XWiki.createNewWiki(String wikiName, String wikiUrl, String wikiAdmin, String baseWikiName, boolean failOnExist)\n        throws XWikiException\n    {\n        return createNewWiki(wikiName, wikiUrl, wikiAdmin, baseWikiName, \"\", null, failOnExist);\n    }\n\n    /**\n     * Priviledged API to create a new Wiki from an existing wiki This creates the database, copies to documents from a\n     * existing wiki Assigns the admin rights, creates the Wiki identification page in the main wiki\n     * \n     * @param wikiName Wiki Name to create\n     * @param wikiUrl Wiki URL to accept requests from\n     * @param wikiAdmin Wiki admin user\n     * @param baseWikiName Wiki to copy documents from\n     * @param description Description of the Wiki\n     * @param failOnExist true to fail if the wiki already exists, false to overwrite\n     * @return Success of Failure code (0 for success, -1 for missing programming rights, > 0 for other errors\n     * @throws XWikiException\n     * @deprecated use WikiManager plugin instead\n     */\n    @Deprecated\n    public int XWiki.createNewWiki(String wikiName, String wikiUrl, String wikiAdmin, String baseWikiName,\n        String description, boolean failOnExist) throws XWikiException\n    {\n        return createNewWiki(wikiName, wikiUrl, wikiAdmin, baseWikiName, description, null, failOnExist);\n    }\n\n    /**\n     * Priviledged API to create a new Wiki from an existing wiki This creates the database, copies to documents from a\n     * existing wiki Assigns the admin rights, creates the Wiki identification page in the main wiki Copy is limited to\n     * documents of a specified language. If a document for the language is not found, the default language document is\n     * used\n     * \n     * @param wikiName Wiki Name to create\n     * @param wikiUrl Wiki URL to accept requests from\n     * @param wikiAdmin Wiki admin user\n     * @param baseWikiName Wiki to copy documents from\n     * @param description Description of the Wiki\n     * @param language Language to copy\n     * @param failOnExist true to fail if the wiki already exists, false to overwrite\n     * @return Success of Failure code (0 for success, -1 for missing programming rights, > 0 for other errors\n     * @throws XWikiException\n     * @deprecated use WikiManager plugin instead\n     */\n    @Deprecated\n    public int XWiki.createNewWiki(String wikiName, String wikiUrl, String wikiAdmin, String baseWikiName,\n        String description, String language, boolean failOnExist) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.createNewWiki(wikiName, wikiUrl, wikiAdmin, baseWikiName, description, language,\n                failOnExist, getXWikiContext());\n        }\n\n        return -1;\n    }\n\n    /**\n     * API to parse the message being stored in the Context. A message can be an error message or an information message\n     * either as text or as a message ID pointing to ApplicationResources. The message is also parse for velocity\n     * scripts\n     * \n     * @return Final message\n     * @deprecated use {@link org.xwiki.localization.LocalizationManager} instead. From velocity you can access it\n     *             using the {@code $services.localization} binding, see {@code LocalizationScriptService}\n     */\n    @Deprecated\n    public String XWiki.parseMessage()\n    {\n        return this.xwiki.parseMessage(getXWikiContext());\n    }\n\n    /**\n     * API allowing to count the total number of documents that would be returned by a query.\n     * \n     * @param wheresql Query to use, similar to the ones accepted by {@link #searchDocuments(String)}. If possible, it\n     *            should not contain <code>order by</code> or <code>group</code> clauses, since this kind of queries are\n     *            not portable.\n     * @return The number of documents that matched the query.\n     * @throws XWikiException if there was a problem executing the query.\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public int XWiki.countDocuments(String wheresql) throws XWikiException\n    {\n        return this.xwiki.getStore().countDocuments(wheresql, getXWikiContext());\n    }\n\n    /**\n     * API allowing to count the total number of documents that would be returned by a parameterized query.\n     * \n     * @param parameterizedWhereClause the parameterized query to use, similar to the ones accepted by\n     *            {@link #searchDocuments(String, List)}. If possible, it should not contain <code>order by</code> or\n     *            <code>group</code> clauses, since this kind of queries are not portable.\n     * @param parameterValues The parameter values that replace the question marks.\n     * @return The number of documents that matched the query.\n     * @throws XWikiException if there was a problem executing the query.\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public int XWiki.countDocuments(String parameterizedWhereClause, List< ? > parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().countDocuments(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }\n    \n\n    /**\n     * Privileged API allowing to run a search on the database returning a list of data This search is send to the store\n     * engine (Hibernate HQL, JCR XPATH or other).\n     * \n     * @param wheresql Query to be run (HQL, XPath)\n     * @return A list of rows (Object[])\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public <T> List<T> XWiki.search(String wheresql) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.search(wheresql, getXWikiContext());\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Privileged API allowing to run a search on the database returning a list of data. The HQL where clause uses\n     * parameters (question marks) instead of values, and the actual values are passed in the parameters list. This\n     * allows generating a query which will automatically encode the passed values (like escaping single quotes). This\n     * API is recommended to be used over the other similar methods where the values are passed inside the where clause\n     * and for which manual encoding/escaping is needed to avoid SQL injections or bad queries.\n     * \n     * @param parameterizedWhereClause query to be run (HQL)\n     * @param parameterValues the where clause values that replace the question marks\n     * @return a list of rows, where each row has either the selected data type ({@link XWikiDocument}, {@code String},\n     *         {@code Integer}, etc.), or {@code Object[]} if more than one column was selected\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public <T> List<T> XWiki.search(String parameterizedWhereClause, List< ? > parameterValues) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.getStore().search(parameterizedWhereClause, 0, 0, parameterValues, getXWikiContext());\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Privileged API allowing to run a search on the database returning a list of data. This search is sent to the\n     * store engine (Hibernate HQL, JCR XPATH or other)\n     * \n     * @param wheresql Query to be run (HQL, XPath)\n     * @param nb return only 'nb' rows\n     * @param start skip the 'start' first elements\n     * @return A list of rows (Object[])\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public <T> List<T> XWiki.search(String wheresql, int nb, int start) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.search(wheresql, nb, start, getXWikiContext());\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Privileged API allowing to run a search on the database returning a list of data. The HQL where clause uses\n     * parameters (question marks) instead of values, and the actual values are passed in the paremeters list. This\n     * allows generating a query which will automatically encode the passed values (like escaping single quotes). This\n     * API is recommended to be used over the other similar methods where the values are passed inside the where clause\n     * and for which manual encoding/escaping is needed to avoid sql injections or bad queries.\n     * \n     * @param parameterizedWhereClause query to be run (HQL)\n     * @param maxResults maximum number of results to return; if 0 all results are returned\n     * @param startOffset skip the first N results; if 0 no items are skipped\n     * @param parameterValues the where clause values that replace the question marks\n     * @return a list of rows, where each row has either the selected data type ({@link XWikiDocument}, {@code String},\n     *         {@code Integer}, etc.), or {@code Object[]} if more than one column was selected\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public <T> List<T> XWiki.search(String parameterizedWhereClause, int maxResults, int startOffset,\n        List< ? > parameterValues) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.getStore().search(parameterizedWhereClause, maxResults, startOffset, parameterValues,\n                getXWikiContext());\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Deprecated API which was retrieving the SQL to represent the fullName Document field depending on the database\n     * used This is not needed anymore and returns 'doc.fullName' for all databases\n     * \n     * @deprecated\n     * @return \"doc.fullName\"\n     */\n    @Deprecated\n    public String XWiki.getFullNameSQL()\n    {\n        return this.xwiki.getFullNameSQL();\n    }\n\n    /**\n     * @return secure {@link QueryManager} for execute queries to store.\n     * @deprecated since XE 2.4M2 use the Query Manager Script Service\n     */\n    @Deprecated\n    public QueryManager XWiki.getQueryManager()\n    {\n        return Utils.getComponent(QueryManager.class, \"secure\");\n    }\n\n    /**\n     * API to check if wiki is in multi-wiki mode (virtual)\n     * \n     * @deprecated Virtual mode is on by default, starting with XWiki 5.0M2.\n     * @return true for multi-wiki/false for mono-wiki\n     */\n    @Deprecated\n    public boolean XWiki.isVirtualMode()\n    {\n        return this.xwiki.isVirtualMode();\n    }\n\n    /**\n     * API to access the current starts for the Wiki for a specific action It retrieves the number of times the action\n     * was performed for the whole wiki The statistics module need to be activated (xwiki.stats=1 in xwiki.cfg)\n     * \n     * @param action action for which to retrieve statistics (view/save/download)\n     * @return A DocumentStats object with number of actions performed, unique visitors, number of visits\n     * @deprecated use {@link #getStatsService()} instead\n     */\n    @Deprecated\n    public DocumentStats XWiki.getCurrentMonthXWikiStats(String action)\n    {\n        return this.xwiki.getStatsService(getXWikiContext())\n            .getDocMonthStats(\"\", action, new Date(), getXWikiContext());\n    }\n\n    /**\n     * Privileged API to reset the rendering engine This would restore the rendering engine evaluation loop and take\n     * into account new configuration parameters\n     * \n     * @deprecated\n     */\n    @Deprecated\n    public void XWiki.resetRenderingEngine()\n    {\n        if (hasProgrammingRights()) {\n            try {\n                this.xwiki.resetRenderingEngine(getXWikiContext());\n            } catch (XWikiException e) {\n            }\n        }\n    }\n\n    /**\n     * API to render a text in the context of a document. Only works for xwiki/1.0 content.\n     *\n     * @param text text to render\n     * @param doc the text is evaluated in the content of this document\n     * @return evaluated content\n     * @throws XWikiException if the evaluation went wrong\n     * @deprecated\n     */\n    @Deprecated\n    public String XWiki.renderText(String text, Document doc) throws XWikiException\n    {\n        return Utils.getComponent(OldRendering.class).renderText(text, doc.getDoc(), getXWikiContext());\n    }\n\n    /**\n     * API to render a chunk (difference between two versions\n     *\n     * @param chunk difference between versions to render\n     * @param doc document to use as a context for rendering\n     * @return resuilt of the rendering\n     * @deprecated\n     */\n    @Deprecated\n    public String XWiki.renderChunk(Chunk chunk, Document doc)\n    {\n        return renderChunk(chunk, false, doc);\n    }\n\n    /**\n     * API to render a chunk (difference between two versions\n     *\n     * @param chunk difference between versions to render\n     * @param doc document to use as a context for rendering\n     * @param source true to render the difference as wiki source and not as wiki rendered text\n     * @return resuilt of the rendering\n     * @deprecated\n     */\n    @Deprecated\n    public String XWiki.renderChunk(Chunk chunk, boolean source, Document doc)\n    {\n        StringBuffer buf = new StringBuffer();\n        chunk.toString(buf, \"\", \"\\n\");\n        if (source == true) {\n            return buf.toString();\n        }\n\n        try {\n            return renderText(buf.toString(), doc);\n        } catch (Exception e) {\n            return buf.toString();\n        }\n    }\n\n    /**\n     * API to rename a page (experimental) Rights are necessary to edit the source and target page All objects and\n     * attachments ID are modified in the process to link to the new page name\n     *\n     * @param doc page to rename\n     * @param newFullName target page name to move the information to\n     * @deprecated since 12.0RC1. Use {@link Document#rename(DocumentReference)}.\n     */\n    @Deprecated\n    public boolean XWiki.renamePage(Document doc, String newFullName)\n    {\n        try {\n            if (this.xwiki.exists(newFullName, getXWikiContext()) && !this.xwiki.getRightService()\n                .hasAccessLevel(\"delete\", getXWikiContext().getUser(), newFullName, getXWikiContext())) {\n                return false;\n            }\n            if (this.xwiki.getRightService().hasAccessLevel(\"edit\", getXWikiContext().getUser(), doc.getFullName(),\n                getXWikiContext())) {\n                this.xwiki.renamePage(doc.getFullName(), newFullName, getXWikiContext());\n            }\n        } catch (XWikiException e) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @return the ids of configured syntaxes for this wiki (e.g. {@code xwiki/2.0}, {@code xwiki/2.1},\n     *         {@code mediawiki/1.0}, etc), taken only from {@code xwiki.cfg} (using the\n     *         {@code xwiki.rendering.syntaxes} property)\n     * @deprecated since 8.2M1, use the XWiki Rendering Configuration component or the Rendering Script Service one\n     *             instead (they use a more elaborate algorithm to find out the supported syntaxes)\n     */\n    @Deprecated\n    public List<String> XWiki.getConfiguredSyntaxes()\n    {\n        return this.xwiki.getConfiguredSyntaxes();\n    }\n\n    /**\n     * Designed to include dynamic content, such as Servlets or JSPs, inside Velocity templates; works by creating a\n     * RequestDispatcher, buffering the output, then returning it as a string.\n     *\n     * @param url URL of the servlet\n     * @return text result of the servlet\n     * @deprecated since 12.10.9, 13.4.3, 13.7RC1\n     */\n    @Deprecated\n    public String XWiki.invokeServletAndReturnAsString(String url)\n    {\n        return hasProgrammingRights() ? this.xwiki.invokeServletAndReturnAsString(url, getXWikiContext()) : null;\n    }\n}", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.FileTime;\nimport java.text.DateFormatSymbols;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.Vector;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.zip.ZipOutputStream;\n\nimport javax.annotation.Priority;\nimport javax.inject.Provider;\nimport javax.mail.Message;\nimport javax.mail.Session;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport javax.naming.NamingException;\nimport javax.script.ScriptContext;\nimport javax.servlet.http.Cookie;\n\nimport org.apache.commons.httpclient.Credentials;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.URIException;\nimport org.apache.commons.httpclient.UsernamePasswordCredentials;\nimport org.apache.commons.httpclient.auth.AuthScope;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.util.URIUtil;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.hibernate.HibernateException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.bridge.event.DocumentCreatedEvent;\nimport org.xwiki.bridge.event.DocumentCreatingEvent;\nimport org.xwiki.bridge.event.DocumentDeletedEvent;\nimport org.xwiki.bridge.event.DocumentDeletingEvent;\nimport org.xwiki.bridge.event.DocumentRolledBackEvent;\nimport org.xwiki.bridge.event.DocumentRollingBackEvent;\nimport org.xwiki.bridge.event.DocumentUpdatedEvent;\nimport org.xwiki.bridge.event.DocumentUpdatingEvent;\nimport org.xwiki.bridge.event.DocumentVersionRangeDeletedEvent;\nimport org.xwiki.bridge.event.DocumentVersionRangeDeletingEvent;\nimport org.xwiki.bridge.event.WikiCopiedEvent;\nimport org.xwiki.bridge.event.WikiDeletedEvent;\nimport org.xwiki.cache.Cache;\nimport org.xwiki.classloader.ClassLoaderManager;\nimport org.xwiki.component.event.ComponentDescriptorAddedEvent;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.manager.NamespacedComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.container.servlet.HttpServletUtils;\nimport org.xwiki.context.Execution;\nimport org.xwiki.edit.EditConfiguration;\nimport org.xwiki.extension.job.internal.InstallJob;\nimport org.xwiki.job.Job;\nimport org.xwiki.job.JobException;\nimport org.xwiki.job.JobExecutor;\nimport org.xwiki.job.annotation.Serializable;\nimport org.xwiki.job.event.JobFinishedEvent;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.job.event.status.JobStatus.State;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.mail.MailListener;\nimport org.xwiki.mail.MailSender;\nimport org.xwiki.mail.MailSenderConfiguration;\nimport org.xwiki.mail.MailStatusResultSerializer;\nimport org.xwiki.mail.XWikiAuthenticator;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.AttachmentReferenceResolver;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.PageReferenceResolver;\nimport org.xwiki.model.reference.RegexEntityReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.observation.EventListener;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.event.CancelableEvent;\nimport org.xwiki.observation.event.Event;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryFilter;\nimport org.xwiki.refactoring.ReferenceRenamer;\nimport org.xwiki.refactoring.batch.BatchOperationExecutor;\nimport org.xwiki.rendering.async.AsyncContext;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.Block.Axes;\nimport org.xwiki.rendering.block.MetaDataBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.MetadataBlockMatcher;\nimport org.xwiki.rendering.internal.transformation.MutableRenderingContext;\nimport org.xwiki.rendering.listener.MetaData;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.renderer.BlockRenderer;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxContent;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.resource.ResourceReference;\nimport org.xwiki.resource.ResourceReferenceManager;\nimport org.xwiki.resource.ResourceReferenceResolver;\nimport org.xwiki.resource.ResourceType;\nimport org.xwiki.resource.ResourceTypeResolver;\nimport org.xwiki.resource.entity.EntityResourceReference;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.skin.Resource;\nimport org.xwiki.skin.Skin;\nimport org.xwiki.skin.SkinManager;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.template.TemplateManager;\nimport org.xwiki.url.ExtendedURL;\nimport org.xwiki.url.URLConfiguration;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserPropertiesResolver;\nimport org.xwiki.velocity.VelocityContextFactory;\nimport org.xwiki.velocity.VelocityManager;\nimport org.xwiki.velocity.XWikiVelocityContext;\nimport org.xwiki.velocity.XWikiVelocityException;\nimport org.xwiki.wiki.descriptor.WikiDescriptor;\nimport org.xwiki.wiki.descriptor.WikiDescriptorManager;\nimport org.xwiki.wiki.manager.WikiManager;\nimport org.xwiki.wiki.manager.WikiManagerException;\nimport org.xwiki.xml.XMLUtils;\n\nimport com.xpn.xwiki.api.Api;\nimport com.xpn.xwiki.api.Document;\nimport com.xpn.xwiki.api.User;\nimport com.xpn.xwiki.criteria.api.XWikiCriteriaService;\nimport com.xpn.xwiki.doc.DeletedAttachment;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.MandatoryDocumentInitializer;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiAttachmentArchive;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocument.XWikiAttachmentToRemove;\nimport com.xpn.xwiki.doc.XWikiDocumentArchive;\nimport com.xpn.xwiki.internal.WikiInitializerJob;\nimport com.xpn.xwiki.internal.WikiInitializerRequest;\nimport com.xpn.xwiki.internal.XWikiCfgConfigurationSource;\nimport com.xpn.xwiki.internal.XWikiConfigDelegate;\nimport com.xpn.xwiki.internal.XWikiInitializerJob;\nimport com.xpn.xwiki.internal.debug.DebugConfiguration;\nimport com.xpn.xwiki.internal.event.MandatoryDocumentsInitializedEvent;\nimport com.xpn.xwiki.internal.event.MandatoryDocumentsInitializingEvent;\nimport com.xpn.xwiki.internal.event.UserCreatingDocumentEvent;\nimport com.xpn.xwiki.internal.event.UserDeletingDocumentEvent;\nimport com.xpn.xwiki.internal.event.UserUpdatingDocumentEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyAddedEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyDeletedEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyUpdatedEvent;\nimport com.xpn.xwiki.internal.mandatory.XWikiPreferencesDocumentInitializer;\nimport com.xpn.xwiki.internal.render.OldRendering;\nimport com.xpn.xwiki.internal.render.groovy.ParseGroovyFromString;\nimport com.xpn.xwiki.internal.skin.InternalSkinConfiguration;\nimport com.xpn.xwiki.internal.skin.InternalSkinManager;\nimport com.xpn.xwiki.internal.skin.WikiSkin;\nimport com.xpn.xwiki.internal.skin.WikiSkinUtils;\nimport com.xpn.xwiki.internal.store.StoreConfiguration;\nimport com.xpn.xwiki.internal.store.hibernate.HibernateConfiguration;\nimport com.xpn.xwiki.internal.velocity.VelocityEvaluator;\nimport com.xpn.xwiki.job.JobRequestContext;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.PropertyInterface;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.PasswordClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.objects.meta.MetaClass;\nimport com.xpn.xwiki.plugin.XWikiPluginInterface;\nimport com.xpn.xwiki.plugin.XWikiPluginManager;\nimport com.xpn.xwiki.render.groovy.XWikiPageClassLoader;\nimport com.xpn.xwiki.stats.api.XWikiStatsService;\nimport com.xpn.xwiki.stats.impl.SearchEngineRule;\nimport com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl;\nimport com.xpn.xwiki.store.AttachmentRecycleBinStore;\nimport com.xpn.xwiki.store.AttachmentVersioningStore;\nimport com.xpn.xwiki.store.XWikiAttachmentStoreInterface;\nimport com.xpn.xwiki.store.XWikiCacheStoreInterface;\nimport com.xpn.xwiki.store.XWikiHibernateStore;\nimport com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;\nimport com.xpn.xwiki.store.XWikiStoreInterface;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.user.api.XWikiAuthService;\nimport com.xpn.xwiki.user.api.XWikiGroupService;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiRightServiceImpl;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.util.XWikiStubContextProvider;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiEngineContext;\nimport com.xpn.xwiki.web.XWikiMessageTool;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiServletRequestStub;\nimport com.xpn.xwiki.web.XWikiURLFactory;\nimport com.xpn.xwiki.web.XWikiURLFactoryService;\nimport com.xpn.xwiki.web.XWikiURLFactoryServiceImpl;\n\n@Serializable(false)\npublic class XWiki implements EventListener\n{\n    /** Name of the default wiki. */\n    public static final String DEFAULT_MAIN_WIKI = \"xwiki\";\n\n    /** Name of the default home space. */\n    public static final String DEFAULT_HOME_SPACE = \"Main\";\n\n    /** Name of the default system space. */\n    public static final String SYSTEM_SPACE = \"XWiki\";\n\n    /**\n     * Name of the default system space as an EntityReference.\n     * \n     * @since 13.2RC1\n     */\n    public static final EntityReference SYSTEM_SPACE_REFERENCE = new EntityReference(\"XWiki\", EntityType.SPACE);\n\n    /** Name of the default space homepage. */\n    public static final String DEFAULT_SPACE_HOMEPAGE = \"WebHome\";\n\n    public static final String CKEY_SKIN = InternalSkinManager.CKEY_SKIN;\n\n    public static final String CKEY_BASESKIN = InternalSkinManager.CKEY_PARENTSKIN;\n\n    public static final String DEFAULT_SKIN = InternalSkinConfiguration.DEFAULT_SKIN;\n\n    /**\n     * Query parameters used to control the browser cache version of a resource.\n     */\n    public static final String CACHE_VERSION = \"cache-version\";\n\n    /** Logging helper object. */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);\n\n    /** Frequently used Document reference, the class which holds virtual wiki definitions. */\n    private static final DocumentReference VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE =\n        new DocumentReference(DEFAULT_MAIN_WIKI, SYSTEM_SPACE, \"XWikiServerClass\");\n\n    /** The default encoding, and the internally used encoding when dealing with byte representation of strings. */\n    public static final String DEFAULT_ENCODING = \"UTF-8\";\n\n    /** Represents no value (ie the default value will be used) in xproperties */\n    private static final String NO_VALUE = \"---\";\n\n    /**\n     * List of top level space names that can be used in the fake context document created when accessing a resource\n     * with the 'skin' action.\n     */\n    private static final List<String> SKIN_RESOURCE_SPACE_NAMES = Arrays.asList(\"skins\", \"resources\");\n\n    /** The main document storage. */\n    private XWikiStoreInterface store;\n\n    /** The attachment content storage. */\n    private XWikiAttachmentStoreInterface defaultAttachmentContentStore;\n\n    /** The attachment archive storage. */\n    private AttachmentVersioningStore defaultAttachmentArchiveStore;\n\n    /** Document versioning storage. */\n    private XWikiVersioningStoreInterface versioningStore;\n\n    /** Deleted documents storage. */\n    private XWikiRecycleBinStoreInterface recycleBinStore;\n\n    private AttachmentRecycleBinStore attachmentRecycleBinStore;\n\n    private XWikiPluginManager pluginManager;\n\n    private XWikiAuthService authService;\n\n    private XWikiRightService rightService;\n\n    private XWikiGroupService groupService;\n\n    private XWikiStatsService statsService;\n\n    private XWikiURLFactoryService urlFactoryService;\n\n    private XWikiCriteriaService criteriaService;\n\n    /** Lock object used for the lazy initialization of the authentication service. */\n    private final Object AUTH_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the authorization service. */\n    private final Object RIGHT_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the group management service. */\n    private final Object GROUP_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the statistics service. */\n    private final Object STATS_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the URL Factory service. */\n    private final Object URLFACTORY_SERVICE_LOCK = new Object();\n\n    private MetaClass metaclass;\n\n    private String version;\n\n    private XWikiEngineContext engine_context;\n\n    private String database;\n\n    private String fullNameSQL;\n\n    /**\n     * The list of initialized wikis.\n     */\n    private Map<String, WikiInitializerJob> initializedWikis = new ConcurrentHashMap<>();\n\n    private boolean isReadOnly = false;\n\n    /**\n     * @deprecated since 6.1M2, use {@link XWikiCfgConfigurationSource#CFG_ENV_NAME} instead\n     */\n    @Deprecated\n    public static final String CFG_ENV_NAME = XWikiCfgConfigurationSource.CFG_ENV_NAME;\n\n    public static final String MACROS_FILE = \"/templates/macros.txt\";\n\n    /**\n     * File containing XWiki's version, in the format: <version name>.<SVN revision number>.\n     */\n    private static final String VERSION_FILE = \"/WEB-INF/version.properties\";\n\n    /**\n     * Property containing the version value in the {@link #VERSION_FILE} file.\n     */\n    private static final String VERSION_FILE_PROPERTY = \"version\";\n\n    private static XWikiInitializerJob job;\n\n    /** Used to convert a proper Document Reference to string (standard form). */\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead.\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    private DocumentReferenceResolver<EntityReference> currentReferenceDocumentReferenceResolver;\n\n    private EntityReferenceResolver<String> currentMixedEntityReferenceResolver;\n\n    private EntityReferenceResolver<String> relativeEntityReferenceResolver;\n\n    private EntityReferenceSerializer<String> localStringEntityReferenceSerializer;\n\n    private ResourceReferenceManager resourceReferenceManager;\n\n    private JobExecutor jobExecutor;\n\n    private InternalSkinManager internalSkinManager;\n\n    private TemplateManager templateManager;\n\n    private RenderingContext renderingContext;\n\n    private VelocityEvaluator velocityEvaluator;\n\n    /**\n     * Whether backlinks are enabled or not (cached for performance).\n     *\n     * @since 3.2M2\n     */\n    private Boolean hasBacklinks;\n\n    private ConfigurationSource xwikicfg;\n\n    private ConfigurationSource wikiConfiguration;\n\n    private UserPropertiesResolver userPropertiesResolver;\n\n    private ConfigurationSource spaceConfiguration;\n\n    private EditConfiguration editConfiguration;\n\n    private URLConfiguration urlConfiguration;\n\n    private StoreConfiguration storeConfiguration;\n\n    private HibernateConfiguration hibernateConfiguration;\n\n    private ObservationManager observationManager;\n\n    private Provider<XWikiContext> xcontextProvider;\n\n    private ContextualLocalizationManager localization;\n\n    private Provider<OldRendering> oldRenderingProvider;\n\n    private ParseGroovyFromString parseGroovyFromString;\n\n    private JobProgressManager progress;\n\n    private Provider<DocumentReference> defaultDocumentReferenceProvider;\n\n    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;\n\n    private PageReferenceResolver<EntityReference> currentgetpageResolver;\n\n    private AttachmentReferenceResolver<EntityReference> currentAttachmentReferenceResolver;\n\n    private WikiSkinUtils wikiSkinUtils;\n\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private VelocityContextFactory velocityContextFactory;\n\n    private WikiDescriptorManager wikiDescriptorManager;\n\n    private AsyncContext asyncContext;\n\n    private ConfigurationSource getConfiguration()\n    {\n        if (this.xwikicfg == null) {\n            this.xwikicfg = Utils.getComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT);\n        }\n\n        return this.xwikicfg;\n    }\n\n    private ConfigurationSource getWikiConfiguration()\n    {\n        if (this.wikiConfiguration == null) {\n            this.wikiConfiguration = Utils.getComponent(ConfigurationSource.class, \"wiki\");\n        }\n\n        return this.wikiConfiguration;\n    }\n\n    private ConfigurationSource getSpaceConfiguration()\n    {\n        if (this.spaceConfiguration == null) {\n            this.spaceConfiguration = Utils.getComponent(ConfigurationSource.class, \"space\");\n        }\n\n        return this.spaceConfiguration;\n    }\n\n    private UserPropertiesResolver getAllUserPropertiesResolver()\n    {\n        if (this.userPropertiesResolver == null) {\n            this.userPropertiesResolver = Utils.getComponent(UserPropertiesResolver.class, \"all\");\n        }\n\n        return this.userPropertiesResolver;\n    }\n\n    private EditConfiguration getEditConfiguration()\n    {\n        if (this.editConfiguration == null) {\n            this.editConfiguration = Utils.getComponent(EditConfiguration.class);\n        }\n\n        return this.editConfiguration;\n    }\n\n    private URLConfiguration getURLConfiguration()\n    {\n        if (this.urlConfiguration == null) {\n            this.urlConfiguration = Utils.getComponent(URLConfiguration.class);\n        }\n\n        return this.urlConfiguration;\n    }\n\n    private StoreConfiguration getStoreConfiguration()\n    {\n        if (this.storeConfiguration == null) {\n            this.storeConfiguration = Utils.getComponent(StoreConfiguration.class);\n        }\n\n        return this.storeConfiguration;\n    }\n\n    private HibernateConfiguration getHibernateConfiguration()\n    {\n        if (this.hibernateConfiguration == null) {\n            this.hibernateConfiguration = Utils.getComponent(HibernateConfiguration.class);\n        }\n\n        return this.hibernateConfiguration;\n    }\n\n    private InternalSkinManager getInternalSkinManager()\n    {\n        if (this.internalSkinManager == null) {\n            this.internalSkinManager = Utils.getComponent(InternalSkinManager.class);\n        }\n\n        return this.internalSkinManager;\n    }\n\n    private TemplateManager getTemplateManager()\n    {\n        if (this.templateManager == null) {\n            this.templateManager = Utils.getComponent(TemplateManager.class);\n        }\n\n        return this.templateManager;\n    }\n\n    private RenderingContext getRenderingContext()\n    {\n        if (this.renderingContext == null) {\n            this.renderingContext = Utils.getComponent(RenderingContext.class);\n        }\n\n        return this.renderingContext;\n    }\n\n    private MutableRenderingContext getMutableRenderingContext()\n    {\n        return getRenderingContext() instanceof MutableRenderingContext\n            ? (MutableRenderingContext) getRenderingContext() : null;\n    }\n\n    private VelocityEvaluator getVelocityEvaluator()\n    {\n        if (this.velocityEvaluator == null) {\n            this.velocityEvaluator = Utils.getComponent(VelocityEvaluator.class);\n        }\n\n        return this.velocityEvaluator;\n    }\n\n    private ObservationManager getObservationManager()\n    {\n        if (this.observationManager == null) {\n            this.observationManager = Utils.getComponent(ObservationManager.class);\n        }\n\n        return this.observationManager;\n    }\n\n    private XWikiContext getXWikiContext()\n    {\n        if (this.xcontextProvider == null) {\n            this.xcontextProvider = Utils.getComponent(XWikiContext.TYPE_PROVIDER);\n        }\n\n        return this.xcontextProvider.get();\n    }\n\n    private ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    private OldRendering getOldRendering()\n    {\n        if (this.oldRenderingProvider == null) {\n            this.oldRenderingProvider = Utils.getComponent(OldRendering.TYPE_PROVIDER);\n        }\n\n        return this.oldRenderingProvider.get();\n    }\n\n    private ParseGroovyFromString getParseGroovyFromString()\n    {\n        if (this.parseGroovyFromString == null) {\n            this.parseGroovyFromString = Utils.getComponent(ParseGroovyFromString.class);\n        }\n\n        return this.parseGroovyFromString;\n    }\n\n    private JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    private Provider<DocumentReference> getDefaultDocumentReferenceProvider()\n    {\n        if (this.defaultDocumentReferenceProvider == null) {\n            this.defaultDocumentReferenceProvider = Utils.getComponent(DocumentReference.TYPE_PROVIDER);\n        }\n\n        return this.defaultDocumentReferenceProvider;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentGetDocumentResolver()\n    {\n        if (this.currentgetdocumentResolver == null) {\n            this.currentgetdocumentResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");\n        }\n\n        return this.currentgetdocumentResolver;\n    }\n\n    private PageReferenceResolver<EntityReference> getCurrentGetPageResolver()\n    {\n        if (this.currentgetpageResolver == null) {\n            this.currentgetpageResolver = Utils.getComponent(PageReferenceResolver.TYPE_REFERENCE, \"currentgetpage\");\n        }\n\n        return this.currentgetpageResolver;\n    }\n\n    private AttachmentReferenceResolver<EntityReference> getCurrentAttachmentResolver()\n    {\n        if (this.currentAttachmentReferenceResolver == null) {\n            this.currentAttachmentReferenceResolver =\n                Utils.getComponent(AttachmentReferenceResolver.TYPE_REFERENCE, \"current\");\n        }\n\n        return this.currentAttachmentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()\n    {\n        if (this.defaultEntityReferenceSerializer == null) {\n            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultEntityReferenceSerializer;\n    }\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (this.currentMixedDocumentReferenceResolver == null) {\n            this.currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedDocumentReferenceResolver;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentReferenceDocumentReferenceResolver()\n    {\n        if (this.currentReferenceDocumentReferenceResolver == null) {\n            this.currentReferenceDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n        }\n\n        return this.currentReferenceDocumentReferenceResolver;\n    }\n\n    private EntityReferenceResolver<String> getCurrentMixedEntityReferenceResolver()\n    {\n        if (this.currentMixedEntityReferenceResolver == null) {\n            this.currentMixedEntityReferenceResolver =\n                Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedEntityReferenceResolver;\n    }\n\n    private EntityReferenceResolver<String> getRelativeEntityReferenceResolver()\n    {\n        if (this.relativeEntityReferenceResolver == null) {\n            this.relativeEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"relative\");\n        }\n\n        return this.relativeEntityReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getLocalStringEntityReferenceSerializer()\n    {\n        if (this.localStringEntityReferenceSerializer == null) {\n            this.localStringEntityReferenceSerializer =\n                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n\n        return this.localStringEntityReferenceSerializer;\n    }\n\n    private ResourceReferenceManager getResourceReferenceManager()\n    {\n        if (this.resourceReferenceManager == null) {\n            this.resourceReferenceManager = Utils.getComponent(ResourceReferenceManager.class);\n        }\n\n        return this.resourceReferenceManager;\n    }\n\n    private JobExecutor getJobExecutor()\n    {\n        if (this.jobExecutor == null) {\n            this.jobExecutor = Utils.getComponent(JobExecutor.class);\n        }\n\n        return this.jobExecutor;\n    }\n\n    private DocumentReference getDefaultDocumentReference()\n    {\n        return getDefaultDocumentReferenceProvider().get();\n    }\n\n    private WikiSkinUtils getWikiSkinUtils()\n    {\n        if (this.wikiSkinUtils == null) {\n            this.wikiSkinUtils = Utils.getComponent(WikiSkinUtils.class);\n        }\n\n        return this.wikiSkinUtils;\n    }\n\n    private DocumentRevisionProvider getDocumentRevisionProvider()\n    {\n        if (this.documentRevisionProvider == null) {\n            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);\n        }\n\n        return this.documentRevisionProvider;\n    }\n\n    private VelocityContextFactory getVelocityContextFactory()\n    {\n        if (this.velocityContextFactory == null) {\n            this.velocityContextFactory = Utils.getComponent(VelocityContextFactory.class);\n        }\n\n        return this.velocityContextFactory;\n    }\n\n    private WikiDescriptorManager getWikiDescriptorManager()\n    {\n        if (this.wikiDescriptorManager == null) {\n            this.wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n        }\n\n        return this.wikiDescriptorManager;\n    }\n\n    private AsyncContext getAsyncContext()\n    {\n        if (this.asyncContext == null) {\n            this.asyncContext = Utils.getComponent(AsyncContext.class);\n        }\n\n        return this.asyncContext;\n    }\n\n    private String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public static XWiki getMainXWiki(XWikiContext context) throws XWikiException\n    {\n        return getMainXWiki(true, context);\n    }\n\n    /**\n     * @param wait true if the method should way for {@link XWiki} instance to be initialized\n     * @param context see {@link XWikiContext}\n     */\n    public static XWiki getMainXWiki(boolean wait, XWikiContext context) throws XWikiException\n    {\n        String xwikiname = DEFAULT_MAIN_WIKI;\n\n        context.setMainXWiki(xwikiname);\n\n        XWiki xwiki;\n\n        try {\n            XWikiEngineContext econtext = context.getEngineContext();\n\n            xwiki = (XWiki) econtext.getAttribute(xwikiname);\n            if (xwiki == null) {\n                // Start XWiki initialization\n                synchronized (XWiki.class) {\n                    xwiki = (XWiki) econtext.getAttribute(xwikiname);\n                    if (xwiki == null && job == null) {\n                        job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);\n\n                        if (job.getStatus() == null) {\n                            // \"Pre-initialize\" XWikiStubContextProvider so that XWiki initializer can find one\n                            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class)\n                                .initialize(context);\n\n                            job.startAsync();\n                        }\n                    }\n                }\n\n                // Wait until XWiki is initialized\n                if (wait) {\n                    job.join();\n                    xwiki = (XWiki) econtext.getAttribute(xwikiname);\n                }\n            }\n\n            context.setWiki(xwiki);\n\n            return xwiki;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                \"Could not initialize main XWiki instance\", e);\n        }\n    }\n\n    public static boolean isInitializing(XWikiContext xcontext)\n    {\n        return Boolean.TRUE.equals(xcontext.getEngineContext().getAttribute(\"xwiki.init\"));\n    }\n\n    /**\n     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.\n     *\n     * @param context see {@link XWikiContext}\n     * @return an XWiki object configured for the wiki corresponding to the current request\n     * @throws XWikiException if the requested URL does not correspond to a real wiki, or if there's an error in the\n     *             storage\n     */\n    public static XWiki getXWiki(XWikiContext context) throws XWikiException\n    {\n        return getXWiki(true, context);\n    }\n\n    /**\n     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.\n     * <p>\n     * Unless <code>wait</code> is false the method return right away null if XWiki is not yet initialized.\n     *\n     * @param wait wait until XWiki is initialized\n     * @param xcontext see {@link XWikiContext}\n     * @return an XWiki object configured for the wiki corresponding to the current request\n     * @throws XWikiException if the requested URL does not correspond to a real wiki, or if there's an error in the\n     *             storage\n     */\n    public static XWiki getXWiki(boolean wait, XWikiContext xcontext) throws XWikiException\n    {\n        XWiki xwiki = getMainXWiki(wait, xcontext);\n\n        if (xwiki == null) {\n            return null;\n        }\n\n        // Extract Entity Resource from URL and put it in the Execution Context\n        EntityResourceReference entityResourceReference = initializeResourceFromURL(xcontext);\n\n        // If not an entity resource reference assume main wiki\n        if (entityResourceReference == null) {\n            return xwiki;\n        }\n\n        // Get the wiki id\n        String wikiId = entityResourceReference.getEntityReference().extractReference(EntityType.WIKI).getName();\n        if (wikiId.equals(xcontext.getMainXWiki())) {\n            // The main wiki was requested.\n            return xwiki;\n        }\n\n        // Check if the wiki exists by checking if a descriptor exists for the wiki id.\n        WikiDescriptorManager wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n        WikiDescriptor descriptor;\n        try {\n            descriptor = wikiDescriptorManager.getById(wikiId);\n        } catch (WikiManagerException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_STORE_MISC,\n                String.format(\"Failed find wiki descriptor for wiki id [%s]\", wikiId), e);\n        }\n        if (descriptor == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_DOES_NOT_EXIST,\n                String.format(\"The wiki [%s] does not exist\", wikiId));\n        }\n\n        // Initialize wiki\n\n        xcontext.setWikiId(wikiId);\n        xcontext.setOriginalWikiId(wikiId);\n\n        if (!xwiki.initializeWiki(wikiId, wait, xcontext)) {\n            // The wiki is still initializing\n            return null;\n        }\n\n        return xwiki;\n    }\n\n    /**\n     * @param wikiId the identifier of the wiki\n     * @return the current {@link WikiInitializerJob} associated to the passed wiki or null if there is none\n     */\n    public Job getWikiInitializerJob(String wikiId)\n    {\n        return this.initializedWikis.get(wikiId);\n    }\n\n    /**\n     * Make sure the wiki is initializing or wait for it.\n     * \n     * @param wikiId the identifier of the wiki to initialize\n     * @param wait true if the method should return only when the wiki is fully initialized\n     * @return true if the wiki is fully initialized\n     * @param xcontext the XWiki context\n     * @throws XWikiException when the initialization failed\n     * @since 8.4RC1\n     */\n    public boolean initializeWiki(String wikiId, boolean wait, XWikiContext xcontext) throws XWikiException\n    {\n        Job wikiJob = this.initializedWikis.get(wikiId);\n\n        // Create and start the job if it does not exist\n        if (wikiJob == null) {\n            try {\n                wikiJob = initializeWiki(wikiId, xcontext);\n            } catch (JobException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Could not start [\" + wikiId + \"] wiki initialization\", e);\n            }\n        }\n\n        // Check if the job is done\n        if (wikiJob.getStatus().getState() == State.FINISHED) {\n            return true;\n        }\n\n        // Wait until the job is finished if asked to\n        if (wait) {\n            try {\n                wikiJob.join();\n            } catch (InterruptedException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Wiki [\" + wikiId + \"] initialization was interrupted unexpectedly\", e);\n            }\n\n            if (wikiJob.getStatus().getError() != null) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Wiki [\" + wikiId + \"] initialization failed\", wikiJob.getStatus().getError());\n            }\n\n            return true;\n        }\n\n        // Still initializing\n        return false;\n    }\n\n    private Job initializeWiki(String wikiId, XWikiContext xcontext) throws JobException\n    {\n        synchronized (this.initializedWikis) {\n            WikiInitializerJob wikiJob = this.initializedWikis.get(wikiId);\n\n            if (wikiJob == null) {\n                WikiInitializerRequest request = new WikiInitializerRequest(wikiId);\n\n                JobRequestContext.set(request, xcontext);\n\n                wikiJob = (WikiInitializerJob) getJobExecutor().execute(WikiInitializerJob.JOBTYPE, request);\n                this.initializedWikis.put(wikiId, wikiJob);\n            }\n\n            return wikiJob;\n        }\n    }\n\n    private static EntityResourceReference initializeResourceFromURL(XWikiContext context) throws XWikiException\n    {\n        // Extract the Entity Resource from the URL\n        // TODO: This code should be put in an ExecutionContextInitializer but we couldn't do yet since this code\n        // requires that the XWiki object be initialized first (the line above). Thus we'll be able to to move it only\n        // after the XWiki init is done also in an ExecutionContextInitializer (and with priorities).\n        @SuppressWarnings(\"deprecation\")\n        EntityResourceReference entityResourceReference;\n        URL url = context.getURL();\n        try {\n            ExtendedURL extendedURL = new ExtendedURL(url, context.getRequest().getContextPath());\n            ResourceTypeResolver<ExtendedURL> typeResolver =\n                Utils.getComponent(new DefaultParameterizedType(null, ResourceTypeResolver.class, ExtendedURL.class));\n            ResourceType type = typeResolver.resolve(extendedURL, Collections.<String, Object>emptyMap());\n            ResourceReferenceResolver<ExtendedURL> resourceResolver = Utils\n                .getComponent(new DefaultParameterizedType(null, ResourceReferenceResolver.class, ExtendedURL.class));\n            ResourceReference reference =\n                resourceResolver.resolve(extendedURL, type, Collections.<String, Object>emptyMap());\n            entityResourceReference =\n                reference instanceof EntityResourceReference ? (EntityResourceReference) reference : null;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION,\n                String.format(\"Failed to extract Entity Resource Reference from URL [%s]\", url), e);\n        }\n        Utils.getComponent(Execution.class).getContext().setProperty(ResourceReferenceManager.RESOURCE_CONTEXT_PROPERTY,\n            entityResourceReference);\n\n        return entityResourceReference;\n    }\n\n    public static URL getRequestURL(XWikiRequest request) throws XWikiException\n    {\n        return HttpServletUtils.getSourceURL(request);\n    }\n\n    public static Object callPrivateMethod(Object obj, String methodName)\n    {\n        return callPrivateMethod(obj, methodName, null, null);\n    }\n\n    public static Object callPrivateMethod(Object obj, String methodName, Class<?>[] classes, Object[] args)\n    {\n        try {\n            Method method = obj.getClass().getDeclaredMethod(methodName, classes);\n            method.setAccessible(true);\n            return method.invoke(obj, args);\n        } catch (IllegalAccessException e) {\n            LOGGER.error(\"Failed to call private method [{}]: [{}]\", methodName, e);\n\n            return null;\n        } catch (NoSuchMethodException e) {\n            return null;\n        } catch (InvocationTargetException e) {\n            LOGGER.error(\"Private method [{}] failed: [{}]\", methodName, e);\n\n            return null;\n        }\n    }\n\n    public static HttpClient getHttpClient(int timeout, String userAgent)\n    {\n        HttpClient client = new HttpClient();\n\n        if (timeout != 0) {\n            client.getParams().setSoTimeout(timeout);\n            client.getParams().setParameter(\"http.connection.timeout\", Integer.valueOf(timeout));\n        }\n\n        client.getParams().setParameter(\"http.useragent\", userAgent);\n\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if ((proxyHost != null) && (!proxyHost.equals(\"\"))) {\n            int port = 3128;\n            if ((proxyPort != null) && (!proxyPort.equals(\"\"))) {\n                port = Integer.parseInt(proxyPort);\n            }\n            client.getHostConfiguration().setProxy(proxyHost, port);\n        }\n\n        String proxyUser = System.getProperty(\"http.proxyUser\");\n        if ((proxyUser != null) && (!proxyUser.equals(\"\"))) {\n            String proxyPassword = System.getProperty(\"http.proxyPassword\");\n            Credentials defaultcreds = new UsernamePasswordCredentials(proxyUser, proxyPassword);\n            client.getState().setProxyCredentials(AuthScope.ANY, defaultcreds);\n        }\n\n        return client;\n    }\n\n    /**\n     * Using reflection, read the private value of the passed field name for the passed object.\n     *\n     * @param obj the java object on which to read the private field value\n     * @param fieldName the object member field for which to read the value\n     * @return the private value for the field\n     * @deprecated use {@link FieldUtils#readDeclaredField(Object, String, boolean)} instead\n     */\n    @Deprecated\n    public static Object getPrivateField(Object obj, String fieldName)\n    {\n        try {\n            Field field = obj.getClass().getDeclaredField(fieldName);\n            field.setAccessible(true);\n            return field.get(obj);\n        } catch (NoSuchFieldException e) {\n            return null;\n        } catch (IllegalAccessException e) {\n            LOGGER.error(\"Failed to get private field with name [{}]: [{}]\", fieldName, e);\n\n            return null;\n        } finally {\n        }\n    }\n\n    public static String getServerWikiPage(String servername)\n    {\n        return \"XWiki.XWikiServer\" + StringUtils.capitalize(servername);\n    }\n\n    /**\n     * @param content the content of the text area\n     * @param context see {@link XWikiContext}\n     */\n    public static String getTextArea(String content, XWikiContext context)\n    {\n        StringBuilder result = new StringBuilder();\n\n        // Forcing a new line after the <textarea> tag, as\n        // http://www.w3.org/TR/html4/appendix/notes.html#h-B.3.1 causes an empty line at the start\n        // of the document content to be trimmed.\n        result.append(\"<textarea name=\\\"content\\\" id=\\\"content\\\" rows=\\\"25\\\" cols=\\\"80\\\">\\n\");\n        result.append(XMLUtils.escape(content));\n        result.append(\"</textarea>\");\n\n        return result.toString();\n    }\n\n    /**\n     * This provide a way to create an XWiki object without initializing the whole XWiki (including plugins, storage,\n     * etc.).\n     * <p>\n     * Needed for tools or tests which need XWiki because it is used everywhere in the API.\n     */\n    public XWiki()\n    {\n        // Empty voluntarily\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public XWiki(XWikiContext context, XWikiEngineContext engineContext, boolean noupdate) throws XWikiException\n    {\n        initXWiki(context, engineContext, noupdate);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public XWiki(XWikiContext context) throws XWikiException\n    {\n        this(context, null, false);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public void initXWiki(XWikiContext context, XWikiEngineContext engineContext, boolean noupdate)\n        throws XWikiException\n    {\n        initXWiki(null, context, engineContext, noupdate);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param config the object holding the XWiki configuration read from {@code xwiki.cfg}\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     * @deprecated since 6.1M2, use {@link #initXWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public void initXWiki(XWikiConfig config, XWikiContext context, XWikiEngineContext engineContext, boolean noupdate)\n        throws XWikiException\n    {\n        getProgress().pushLevelProgress(4, this);\n\n        try {\n            getProgress().startStep(this);\n\n            setDatabase(context.getMainXWiki());\n\n            setEngineContext(engineContext);\n            context.setWiki(this);\n\n            // \"Pre-initialize\" XWikiStubContextProvider with a XWikiContext containing a XWiki instance as soon as\n            // possible\n            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class).initialize(context);\n\n            // Prepare the store\n            if (config != null) {\n                setConfig(config);\n            }\n\n            try {\n                initializeStores();\n            } catch (ComponentLookupException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                    \"Failed to initialize stores\", e);\n            }\n\n            setCriteriaService((XWikiCriteriaService) createClassFromConfig(\"xwiki.criteria.class\",\n                \"com.xpn.xwiki.criteria.impl.XWikiCriteriaServiceImpl\", context));\n\n            // \"Pre-initialize\" XWikiStubContextProvider so that rendering engine, plugins or listeners reacting to\n            // potential document changes can use it\n            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class).initialize(context);\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            // Make sure these classes exists\n            if (noupdate) {\n                getProgress().pushLevelProgress(2, this);\n\n                try {\n                    getProgress().startStep(this);\n\n                    initializeMandatoryDocuments(context);\n\n                    getProgress().startStep(this);\n\n                    getStatsService(context);\n                } finally {\n                    getProgress().popLevelProgress(this);\n                }\n            }\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            // Prepare the Plugin Engine\n            preparePlugins(context);\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            String ro = getConfiguration().getProperty(\"xwiki.readonly\", \"no\");\n            this.isReadOnly = (\"yes\".equalsIgnoreCase(ro) || \"true\".equalsIgnoreCase(ro) || \"1\".equalsIgnoreCase(ro));\n\n            getObservationManager().addListener(this);\n        } finally {\n            getProgress().popLevelProgress(this);\n        }\n    }\n\n    private void initializeStores() throws ComponentLookupException\n    {\n        XWikiStoreInterface mainStore = getStoreConfiguration().getXWikiStore();\n\n        // Check if we need to use the cache store..\n        if (getStoreConfiguration().isStoreCacheEnabled()) {\n            XWikiCacheStoreInterface cachestore =\n                (XWikiCacheStoreInterface) Utils.getComponent(XWikiStoreInterface.class, \"cache\");\n            cachestore.setStore(mainStore);\n            setStore(cachestore);\n        } else {\n            setStore(mainStore);\n        }\n\n        setDefaultAttachmentContentStore(getStoreConfiguration().getXWikiAttachmentStore());\n        setVersioningStore(getStoreConfiguration().getXWikiVersioningStore());\n        setDefaultAttachmentArchiveStore(getStoreConfiguration().getAttachmentVersioningStore());\n        setRecycleBinStore(getStoreConfiguration().getXWikiRecycleBinStore());\n        setAttachmentRecycleBinStore(getStoreConfiguration().getAttachmentRecycleBinStore());\n    }\n\n    /**\n     * Ensure that mandatory classes (ie classes XWiki needs to work properly) exist and create them if they don't\n     * exist.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public void initializeMandatoryDocuments(XWikiContext context)\n    {\n        if (context.get(\"initdone\") == null) {\n            @SuppressWarnings(\"deprecation\")\n            List<MandatoryDocumentInitializer> initializers =\n                Utils.getComponentList(MandatoryDocumentInitializer.class);\n\n            // Sort the initializers based on priority. Lower priority values are first.\n            Collections.sort(initializers, new Comparator<MandatoryDocumentInitializer>()\n            {\n                @Override\n                public int compare(MandatoryDocumentInitializer left, MandatoryDocumentInitializer right)\n                {\n                    Priority leftPriority = left.getClass().getAnnotation(Priority.class);\n                    int leftPriorityValue =\n                        leftPriority != null ? leftPriority.value() : MandatoryDocumentInitializer.DEFAULT_PRIORITY;\n\n                    Priority rightPriority = right.getClass().getAnnotation(Priority.class);\n                    int rightPriorityValue =\n                        rightPriority != null ? rightPriority.value() : MandatoryDocumentInitializer.DEFAULT_PRIORITY;\n\n                    // Compare the two.\n                    return leftPriorityValue - rightPriorityValue;\n                }\n            });\n\n            getObservationManager().notify(MandatoryDocumentsInitializingEvent.EVENT, null);\n\n            getProgress().pushLevelProgress(initializers.size(), this);\n\n            try {\n                for (MandatoryDocumentInitializer initializer : initializers) {\n                    getProgress().startStep(this);\n\n                    initializeMandatoryDocument(initializer, context);\n\n                    getProgress().endStep(this);\n                }\n            } finally {\n                getProgress().popLevelProgress(this);\n            }\n\n            getObservationManager().notify(MandatoryDocumentsInitializedEvent.EVENT, null);\n        }\n    }\n\n    private void initializeMandatoryDocument(String wiki, MandatoryDocumentInitializer initializer,\n        XWikiContext context)\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            context.setWikiId(wiki);\n\n            initializeMandatoryDocument(initializer, context);\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    private void initializeMandatoryDocument(MandatoryDocumentInitializer initializer, XWikiContext context)\n    {\n        try {\n            DocumentReference documentReference =\n                getCurrentReferenceDocumentReferenceResolver().resolve(initializer.getDocumentReference());\n\n            if (documentReference.getWikiReference().getName().equals(context.getWikiId())) {\n                XWikiDocument document = context.getWiki().getDocument(documentReference, context);\n\n                if (initializer.updateDocument(document)) {\n                    saveDocument(document,\n                        localizePlainOrKey(\"core.model.xclass.mandatoryUpdateProperty.versionSummary\"), context);\n                }\n            }\n        } catch (XWikiException e) {\n            LOGGER.error(\"Failed to initialize mandatory document [{}]\", initializer.getDocumentReference(), e);\n        }\n    }\n\n    public XWikiStoreInterface getNotCacheStore()\n    {\n        XWikiStoreInterface store = getStore();\n        if (store instanceof XWikiCacheStoreInterface) {\n            store = ((XWikiCacheStoreInterface) store).getStore();\n        }\n        return store;\n    }\n\n    public XWikiHibernateStore getHibernateStore()\n    {\n        XWikiStoreInterface store = getStore();\n        if (store instanceof XWikiHibernateStore) {\n            return (XWikiHibernateStore) store;\n        } else if (store instanceof XWikiCacheStoreInterface) {\n            store = ((XWikiCacheStoreInterface) store).getStore();\n            if (store instanceof XWikiHibernateStore) {\n                return (XWikiHibernateStore) store;\n            } else {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, XWikiContext context) throws HibernateException, XWikiException\n    {\n        updateDatabase(wikiId, false, context);\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, boolean force, XWikiContext context)\n        throws HibernateException, XWikiException\n    {\n        updateDatabase(wikiId, force, true, context);\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param force if the update of the databse should be forced\n     * @param initDocuments if mandatory document and plugin should be initialized for passed wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, boolean force, boolean initDocuments, XWikiContext context)\n        throws HibernateException, XWikiException\n    {\n        initializeWiki(wikiId, true, context);\n    }\n\n    /**\n     * @return a cached list of all active virtual wikis (i.e. wikis who have been hit by a user request). To get a full\n     *         list of all virtual wikis database names use {@link WikiDescriptorManager#getAllIds()}.\n     * @deprecated\n     */\n    @Deprecated\n    public List<String> getVirtualWikiList()\n    {\n        return new ArrayList<>(this.initializedWikis.keySet());\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     * @return the full list of all wiki names of all defined wikis. The wiki names are computed from the names of\n     *         documents having a {@code XWiki.XWikiServerClass} object attached to them by removing the\n     *         {@code XWiki.XWikiServer} prefix and making it lower case. For example a page named\n     *         {@code XWiki.XWikiServerMyDatabase} would return {@code mydatabase} as the wiki name. This list will also\n     *         contain the main wiki.\n     *         <p>\n     *         Note: the wiki name is commonly also the name of the database where the wiki's data is stored. However,\n     *         if configured accordingly, the database can be diferent from the wiki name, like for example when setting\n     *         a wiki database prefix.\n     * @deprecated since 5.3, use {@link WikiDescriptorManager#getAllIds()} instead\n     */\n    @Deprecated\n    public List<String> getVirtualWikisDatabaseNames(XWikiContext context) throws XWikiException\n    {\n        WikiDescriptorManager descriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n\n        try {\n            return new ArrayList<String>(descriptorManager.getAllIds());\n        } catch (WikiManagerException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to get the list of wikis\", e);\n        }\n    }\n\n    /**\n     * @return the cache containing the names of the wikis already initialized.\n     * @since 1.5M2.\n     * @deprecated\n     */\n    @Deprecated\n    public Cache<DocumentReference> getVirtualWikiCache()\n    {\n        return null;\n    }\n\n    /**\n     * Get the reference of the owner for the provider wiki.\n     *\n     * @param wikiName the technical name of the wiki\n     * @param context see {@link XWikiContext}\n     * @return the wiki owner or null if none is set\n     * @throws XWikiException failed to get wiki descriptor document\n     */\n    public String getWikiOwner(String wikiName, XWikiContext context) throws XWikiException\n    {\n        String wikiOwner;\n\n        String currentdatabase = context.getWikiId();\n        try {\n            context.setWikiId(context.getMainXWiki());\n\n            String serverwikipage = getServerWikiPage(wikiName);\n            XWikiDocument doc = getDocument(serverwikipage, context);\n\n            if (doc.isNew()) {\n                if (!context.isMainWiki(wikiName)) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_DOES_NOT_EXIST,\n                        \"The wiki \" + wikiName + \" does not exist\");\n                } else {\n                    wikiOwner = null;\n                }\n            } else {\n                wikiOwner = doc.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"owner\");\n                if (wikiOwner.indexOf(':') == -1) {\n                    wikiOwner = context.getMainXWiki() + \":\" + wikiOwner;\n                }\n            }\n        } finally {\n            context.setWikiId(currentdatabase);\n        }\n\n        return wikiOwner;\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    protected Object createClassFromConfig(String param, String defClass, XWikiContext context) throws XWikiException\n    {\n        String storeclass = getConfiguration().getProperty(param, defClass);\n        try {\n            Class<?>[] classes = new Class<?>[] { XWikiContext.class };\n            Object[] args = new Object[] { context };\n            Object result = Class.forName(storeclass).getConstructor(classes).newInstance(args);\n            return result;\n        } catch (Exception e) {\n            Throwable ecause = e;\n            if (e instanceof InvocationTargetException) {\n                ecause = ((InvocationTargetException) e).getTargetException();\n            }\n            Object[] args = { param, storeclass };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_CLASSINVOCATIONERROR, \"Cannot load class {1} from param {0}\", ecause,\n                args);\n        }\n    }\n\n    private void preparePlugins(XWikiContext context)\n    {\n        setPluginManager(new XWikiPluginManager(getXWikiPreference(\"plugins\", context), context));\n        String plugins = getConfiguration().getProperty(\"xwiki.plugins\", \"\");\n        if (!plugins.equals(\"\")) {\n            getPluginManager().addPlugins(StringUtils.split(plugins, \" ,\"), context);\n        }\n    }\n\n    /**\n     * @return the XWiki core version as specified in the {@link #VERSION_FILE} file\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String getVersion()\n    {\n        if (this.version == null) {\n            try {\n                InputStream is = getResourceAsStream(VERSION_FILE);\n                try {\n                    XWikiConfig properties = new XWikiConfig(is);\n                    this.version = properties.getProperty(VERSION_FILE_PROPERTY);\n                } finally {\n                    IOUtils.closeQuietly(is);\n                }\n            } catch (Exception e) {\n                // Failed to retrieve the version, log a warning and default to \"Unknown\"\n                LOGGER.warn(\"Failed to retrieve XWiki's version from [\" + VERSION_FILE + \"], using the [\"\n                    + VERSION_FILE_PROPERTY + \"] property.\", e);\n                this.version = \"Unknown version\";\n            }\n        }\n        return this.version;\n    }\n\n    public URL getResource(String s) throws MalformedURLException\n    {\n        return getEngineContext().getResource(s);\n    }\n\n    public InputStream getResourceAsStream(String s) throws MalformedURLException\n    {\n        InputStream is = getEngineContext().getResourceAsStream(s);\n        if (is == null) {\n            is = getEngineContext().getResourceAsStream(\"/\" + s);\n        }\n        return is;\n    }\n\n    public String getResourceContent(String name) throws IOException\n    {\n        if (getEngineContext() != null) {\n            try (InputStream is = getResourceAsStream(name)) {\n                if (is != null) {\n                    return IOUtils.toString(is, DEFAULT_ENCODING);\n                }\n            }\n        }\n        // Resources should always be encoded as UTF-8, to reduce the dependency on the system encoding\n        return FileUtils.readFileToString(new File(name), DEFAULT_ENCODING);\n    }\n\n    public Date getResourceLastModificationDate(String name)\n    {\n        try {\n            if (getEngineContext() != null) {\n                return Util.getFileLastModificationDate(getEngineContext().getRealPath(name));\n            }\n        } catch (Exception ex) {\n            // Probably a SecurityException or the file is not accessible (inside a war)\n            LOGGER.info(\"Failed to get file modification date: \" + ex.getMessage());\n        }\n        return new Date();\n    }\n\n    public byte[] getResourceContentAsBytes(String name) throws IOException\n    {\n        if (getEngineContext() != null) {\n            try (InputStream is = getResourceAsStream(name)) {\n                if (is != null) {\n                    return IOUtils.toByteArray(is);\n                }\n            } catch (Exception e) {\n            }\n        }\n        return FileUtils.readFileToByteArray(new File(name));\n    }\n\n    public boolean resourceExists(String name)\n    {\n        if (getEngineContext() != null) {\n            try {\n                if (getResource(name) != null) {\n                    return true;\n                }\n            } catch (IOException e) {\n            }\n        }\n        try {\n            File file = new File(name);\n            return file.exists();\n        } catch (Exception e) {\n            // Could be running under -security, which prevents calling file.exists().\n        }\n        return false;\n    }\n\n    public String getRealPath(String path)\n    {\n        return getEngineContext().getRealPath(path);\n    }\n\n    public String ParamAsRealPath(String key)\n    {\n        String param = getConfiguration().getProperty(key);\n        try {\n            return getRealPath(param);\n        } catch (Exception e) {\n            return param;\n        }\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public String ParamAsRealPath(String key, XWikiContext context)\n    {\n        return ParamAsRealPath(key);\n    }\n\n    public String ParamAsRealPathVerified(String param)\n    {\n        String path;\n        File fpath;\n\n        path = getConfiguration().getProperty(param);\n        if (path == null) {\n            return null;\n        }\n\n        fpath = new File(path);\n        if (fpath.exists()) {\n            return path;\n        }\n\n        path = getRealPath(path);\n        if (path == null) {\n            return null;\n        }\n\n        fpath = new File(path);\n        if (fpath.exists()) {\n            return path;\n        } else {\n        }\n        return null;\n    }\n\n    public XWikiStoreInterface getStore()\n    {\n        return this.store;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #getDefaultAttachmentContentStore()} instead\n     */\n    @Deprecated\n    public XWikiAttachmentStoreInterface getAttachmentStore()\n    {\n        return getDefaultAttachmentContentStore();\n    }\n\n    /**\n     * @return the store to use by default when saving a new attachment content\n     * @since 9.10RC1\n     */\n    public XWikiAttachmentStoreInterface getDefaultAttachmentContentStore()\n    {\n        return this.defaultAttachmentContentStore;\n    }\n\n    /**\n     * @return the store to use by default when saving a new attachment archive\n     * @since 9.10RC1\n     */\n    public AttachmentVersioningStore getDefaultAttachmentArchiveStore()\n    {\n        return this.defaultAttachmentArchiveStore;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #getDefaultAttachmentArchiveStore()} instead\n     */\n    @Deprecated\n    public AttachmentVersioningStore getAttachmentVersioningStore()\n    {\n        return getDefaultAttachmentArchiveStore();\n    }\n\n    public XWikiVersioningStoreInterface getVersioningStore()\n    {\n        return this.versioningStore;\n    }\n\n    public XWikiRecycleBinStoreInterface getRecycleBinStore()\n    {\n        return this.recycleBinStore;\n    }\n\n    public AttachmentRecycleBinStore getAttachmentRecycleBinStore()\n    {\n        return this.attachmentRecycleBinStore;\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, String comment,\n        XWikiContext context) throws XWikiException\n    {\n        checkSavingDocument(userReference, document, comment, false, context);\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, XWikiContext context)\n        throws XWikiException\n    {\n        checkSavingDocument(userReference, document, \"\", false, context);\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param isMinorEdit true if the new version is a minor version\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, String comment,\n        boolean isMinorEdit, XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            // Switch to document wiki\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            // Make sure the document is ready to be saved\n            XWikiDocument originalDocument = prepareDocumentForSave(document, comment, isMinorEdit, context);\n\n            ObservationManager om = getObservationManager();\n\n            // Notify listeners about the document about to be created or updated\n\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n\n            if (om != null) {\n                CancelableEvent documentEvent;\n                if (originalDocument.isNew()) {\n                    documentEvent = new UserCreatingDocumentEvent(userReference, document.getDocumentReference());\n                } else {\n                    documentEvent = new UserUpdatingDocumentEvent(userReference, document.getDocumentReference());\n                }\n                om.notify(documentEvent, document, context);\n\n                // If the action has been canceled by the user then don't perform any save and throw an exception\n                if (documentEvent.isCanceled()) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                        String.format(\"User [%s] has been denied the right to save the document [%s]. Reason: [%s]\",\n                            userReference, document.getDocumentReference(), documentEvent.getReason()));\n                }\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    private XWikiDocument prepareDocumentForSave(XWikiDocument document, String comment, boolean isMinorEdit,\n        XWikiContext context) throws XWikiException\n    {\n        // Set the store so we can use it for checking the max length.\n        if (document.getStore() == null) {\n            document.setStore(this.getStore());\n        }\n        String fullName = getLocalStringEntityReferenceSerializer().serialize(document.getDocumentReference());\n        // If it's a new doc we check its name length to avoid a nasty SQL error.\n        if (document.isNew() && fullName.length() > document.getLocalReferenceMaxLength()) {\n            java.lang.Object[] args = { fullName, document.getLocalReferenceMaxLength(), fullName.length() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_APP_DOCUMENT_PATH_TOO_LONG,\n                \"Cannot create document {0} because its full path is too long: only {1} characters are allowed and \"\n                    + \"current length is {2}.\",\n                null, args);\n        }\n\n        // Setting comment & minor edit before saving\n        document.setComment(StringUtils.defaultString(comment));\n        document.setMinorEdit(isMinorEdit);\n\n        // We need to save the original document since saveXWikiDoc() will reset it and we\n        // need that original document for the notification below.\n        XWikiDocument originalDocument = document.getOriginalDocument();\n\n        // Make sure to always have an original document for listeners that need to compare with it.\n        // The only case where we have a null original document is supposedly when the document\n        // instance has been crafted and passed #saveDocument without using #getDocument\n        // (which is not a good practice)\n        // Also for document indicated as new make sure the previous document is accurate.\n        if (originalDocument == null || document.isNew()) {\n            XWikiDocument existing = getDocument(document.getDocumentReferenceWithLocale(), context);\n            // Switch the original document only if we actually find an existing document or if there is no original\n            // document in the first place\n            if (originalDocument == null || !existing.isNew()) {\n                originalDocument = existing;\n                document.setOriginalDocument(originalDocument);\n            }\n        }\n\n        return originalDocument;\n    }\n\n    /**\n     * @param doc the document to save\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        // If no comment is provided we should use an empty comment\n        saveDocument(doc, \"\", context);\n    }\n\n    /**\n     * @param doc the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument doc, String comment, XWikiContext context) throws XWikiException\n    {\n        saveDocument(doc, comment, false, context);\n    }\n\n    private void beforeSave(XWikiDocument document, XWikiContext context) throws XWikiException\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            CancelableEvent documentEvent;\n            if (document.getOriginalDocument().isNew()) {\n                documentEvent = new DocumentCreatingEvent(document.getDocumentReference());\n            } else {\n                documentEvent = new DocumentUpdatingEvent(document.getDocumentReference());\n            }\n            om.notify(documentEvent, document, context);\n\n            // If the action has been canceled by the user then don't perform any save and throw an exception\n            if (documentEvent.isCanceled()) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_DOC,\n                    String.format(\"An Event Listener has cancelled the document save for [%s]. Reason: [%s]\",\n                        document.getDocumentReference(), documentEvent.getReason()));\n            }\n        }\n    }\n\n    private void afterSave(XWikiDocument document, XWikiContext context)\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            if (document.getOriginalDocument().isNew()) {\n                om.notify(new DocumentCreatedEvent(document.getDocumentReference()), document, context);\n            } else {\n                om.notify(new DocumentUpdatedEvent(document.getDocumentReference()), document, context);\n            }\n        }\n    }\n\n    /**\n     * Save the passed document in the store.\n     * <p>\n     * If document is not new and metadata and content dirty flags are false, the version/history won't be incremented\n     * (only the current state will be updated).\n     * <p>\n     * Since 11.1, if document#isNew() return true, any pre existing document will be backuped in the deleted documents\n     * store automatically and completely replaced.\n     * \n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param isMinorEdit true if the new version is a minor version\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument document, String comment, boolean isMinorEdit, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            // Switch to document wiki\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            // Make sure the document is ready to be saved\n            XWikiDocument originalDocument = prepareDocumentForSave(document, comment, isMinorEdit, context);\n\n            // Notify listeners about the document about to be created or updated\n\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            beforeSave(document, context);\n\n            // Delete existing document if we replace with a new one\n            if (document.isNew()) {\n                if (!originalDocument.isNew()) {\n                    // We don't want to notify about this delete since from outside world point of view it's an update\n                    // and not a delete+create\n                    deleteDocument(originalDocument, true, false, context);\n                }\n            } else {\n                // Put attachments to remove in recycle bin\n                if (hasAttachmentRecycleBin(context)) {\n                    for (XWikiAttachmentToRemove attachment : document.getAttachmentsToRemove()) {\n                        if (attachment.isToRecycleBin()) {\n                            // Make sure the attachment will be deleted with its history\n                            attachment.getAttachment().loadArchive(context);\n                            getAttachmentRecycleBinStore().saveToRecycleBin(attachment.getAttachment(),\n                                context.getUser(), new Date(), context, true);\n                        }\n                    }\n                }\n            }\n\n            // Actually save the document.\n            getStore().saveXWikiDoc(document, context);\n\n            // Since the store#saveXWikiDoc resets originalDocument, we need to temporarily put it\n            // back to send notifications.\n            XWikiDocument newOriginal = document.getOriginalDocument();\n\n            try {\n                document.setOriginalDocument(originalDocument);\n\n                // Notify listeners about the document having been created or updated\n\n                // First the legacy notification mechanism\n\n                // Then the new observation module\n                // Note that for the moment the event being send is a bridge event, as we are still passing around\n                // an XWikiDocument as source and an XWikiContext as data.\n                // The old version is made available using doc.getOriginalDocument()\n                afterSave(document, context);\n            } catch (Exception ex) {\n                LOGGER.error(\"Failed to send document save notification for document [\"\n                    + getDefaultEntityReferenceSerializer().serialize(document.getDocumentReference()) + \"]\", ex);\n            } finally {\n                document.setOriginalDocument(newOriginal);\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Loads a XWikiDocument from the store.\n     * <p>\n     * Before 7.2M1 the reference is assumed to be a complete or incomplete document reference.\n     * <p>\n     * Since 7.2M1, the passed reference can be anything. If if a document child, the document reference will be\n     * extracted from it. If it's a document parent it will be completed with the necessary default references (for\n     * example if it's a space reference it will load the space home page).\n     *\n     * @param reference the reference of the document\n     * @param context see {@link XWikiContext}\n     * @since 5.0M1\n     */\n    public XWikiDocument getDocument(EntityReference reference, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument document;\n\n        if (reference.getType() == EntityType.PAGE || reference.getType().isAllowedAncestor(EntityType.PAGE)) {\n            document = getDocument(getCurrentGetPageResolver().resolve(reference), context);\n        } else {\n            document = getDocument(getCurrentGetDocumentResolver().resolve(reference), context);\n        }\n\n        return document;\n    }\n\n    /**\n     * Loads a XWikiDocument from the store.\n     *\n     * @param reference the reference of the document to be loaded\n     * @param type the type of the reference\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 10.6RC1\n     */\n    public XWikiDocument getDocument(String reference, EntityType type, XWikiContext xcontext) throws XWikiException\n    {\n        return getDocument(getRelativeEntityReferenceResolver().resolve(reference, type), xcontext);\n    }\n\n    /**\n     * @param doc the document\n     * @param context see {@link XWikiContext}\n     */\n    public XWikiDocument getDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(doc.getDocumentReference().getWikiReference().getName());\n\n            try {\n                // Indicate the the async context manipulated documents\n                getAsyncContext().useEntity(doc.getDocumentReferenceWithLocale());\n            } catch (Exception e) {\n                // If the AsyncContext component does not work then we are not in an asynchronous context anyway\n                LOGGER.debug(\"Failed to register the document in the asynchronous context\", e);\n            }\n\n            return getStore().loadXWikiDoc(doc, context);\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * @param reference the reference of the document to load\n     * @param revision the revision of the document to load\n     * @param context the XWiki context\n     * @return the document corresponding to the passed revision or a new XWikiDocument instance if none can be found\n     * @throws XWikiException when failing to load the document revision\n     * @since 9.4RC1\n     * @deprecated sine 9.10RC1, use {@link DocumentRevisionProvider#getRevision(DocumentReference, String)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(DocumentReference reference, String revision, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument revisionDocument = getDocumentRevisionProvider().getRevision(reference, revision);\n\n        if (revisionDocument == null && (revision.equals(\"1.1\") || revision.equals(\"1.0\"))) {\n            revisionDocument = new XWikiDocument(reference);\n        }\n\n        return revisionDocument;\n    }\n\n    /**\n     * @param document the reference document\n     * @param revision the revision of the document to load\n     * @param context the XWiki context\n     * @return the document corresponding to the passed revision or a new XWikiDocument instance if none can be found\n     * @throws XWikiException when failing to load the document revision\n     * @deprecated sine 9.10RC1, use {@link DocumentRevisionProvider#getRevision(XWikiDocument, String)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(XWikiDocument document, String revision, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument revisionDocument = getDocumentRevisionProvider().getRevision(document, revision);\n\n        if (revisionDocument == null && (revision.equals(\"1.1\") || revision.equals(\"1.0\"))) {\n            revisionDocument = new XWikiDocument(document.getDocumentReference());\n        }\n\n        return revisionDocument;\n    }\n\n    /**\n     * @param reference the reference of the document\n     * @param context see {@link XWikiContext}\n     * @since 2.2M1\n     */\n    public XWikiDocument getDocument(DocumentReference reference, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(\n            reference.getLocale() != null ? new DocumentReference(reference, (Locale) null) : reference,\n            reference.getLocale());\n\n        doc.setContentDirty(true);\n\n        return getDocument(doc, context);\n    }\n\n    /**\n     * @param reference the reference of the page\n     * @param context see {@link XWikiContext}\n     * @since 10.6RC1\n     */\n    public XWikiDocument getDocument(PageReference reference, XWikiContext context) throws XWikiException\n    {\n        DocumentReference documentReference = getCurrentReferenceDocumentReferenceResolver().resolve(reference);\n\n        XWikiDocument document = getDocument(documentReference, context);\n\n        if (document.isNew() && documentReference.getParent().getParent().getType() == EntityType.SPACE) {\n            // Try final page\n            XWikiDocument finalDocument = getDocument(new DocumentReference(documentReference.getParent().getName(),\n                documentReference.getParent().getParent(), documentReference.getParameters()), context);\n\n            if (!finalDocument.isNew()) {\n                document = finalDocument;\n            }\n        }\n\n        return document;\n    }\n\n    /**\n     * Find the document reference corresponding to the entity reference based on what exist in the database (page\n     * reference can means two different documents for example).\n     * \n     * @param reference the reference to resolve\n     * @param context the XWiki context\n     * @return the document reference\n     * @since 10.6RC1\n     */\n    public DocumentReference getDocumentReference(EntityReference reference, XWikiContext context)\n    {\n        DocumentReference documentReference = getCurrentGetDocumentResolver().resolve(reference);\n\n        // If the document has been found or it's top level space, return the reference\n        if (documentReference.getParent().getParent().getType() != EntityType.SPACE\n            || exists(documentReference, context)) {\n            return documentReference;\n        }\n\n        // Try final page\n        DocumentReference finalPageReference = new DocumentReference(documentReference.getParent().getName(),\n            documentReference.getParent().getParent(), documentReference.getParameters());\n\n        return exists(finalPageReference, context) ? finalPageReference : documentReference;\n    }\n\n    /**\n     * @param fullname the reference of the document as String\n     * @param context see {@link XWikiContext}\n     * @deprecated since 2.2M1 use {@link #getDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(String fullname, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument();\n        doc.setFullName(fullname, context);\n        return getDocument(doc, context);\n    }\n\n    /**\n     * @param spaces the reference of the space as String\n     * @param fullname the reference of the document as String\n     * @param context see {@link XWikiContext}\n     * @deprecated since 2.2M1 use {@link #getDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(String spaces, String fullname, XWikiContext context) throws XWikiException\n    {\n        int dotPosition = fullname.lastIndexOf('.');\n        if (dotPosition != -1) {\n            String spaceFromFullname = fullname.substring(0, dotPosition);\n            String name = fullname.substring(dotPosition + 1);\n            if (name.equals(\"\")) {\n                name = getDefaultPage(context);\n            }\n            return getDocument(spaceFromFullname + \".\" + name, context);\n        } else {\n            return getDocument(spaces + \".\" + fullname, context);\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocuments(String, String)\n     */\n    public XWikiDeletedDocument[] getDeletedDocuments(String fullname, String locale, XWikiContext context)\n        throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n            doc.setLanguage(locale);\n            return getRecycleBinStore().getAllDeletedDocuments(doc, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocuments(String)\n     * @since 9.4RC1\n     */\n    public XWikiDeletedDocument[] getDeletedDocuments(String batchId, XWikiContext context) throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            return getRecycleBinStore().getAllDeletedDocuments(batchId, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocument(String, String, String)\n     * @deprecated since 9.4RC1. Use {@link #getDeletedDocument(long, XWikiContext)} instead.\n     */\n    @Deprecated\n    public XWikiDeletedDocument getDeletedDocument(String fullname, String locale, int index, XWikiContext context)\n        throws XWikiException\n    {\n        return getDeletedDocument(index, context);\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocument(String)\n     * @since 9.4RC1\n     */\n    public XWikiDeletedDocument getDeletedDocument(long index, XWikiContext context) throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            return getRecycleBinStore().getDeletedDocument(index, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document. Note that this does not distinguish\n     * between different incarnations of a document name, and it does not require that the document still exists, it\n     * returns all the attachments that at the time of their deletion had a document with the specified name as their\n     * owner.\n     *\n     * @param docName the {@link XWikiDocument#getFullName() name} of the owner document\n     * @param context see {@link XWikiContext}\n     * @return A list with all the deleted attachments which belonged to the specified document. If no such attachments\n     *         are found in the trash, an empty list is returned.\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, XWikiContext context) throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName));\n            return getAttachmentRecycleBinStore().getAllDeletedAttachments(doc, context, true);\n        }\n        return null;\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document and had the specified name. Multiple\n     * versions can be returned since the same file can be uploaded and deleted several times, creating different\n     * instances in the trash. Note that this does not distinguish between different incarnations of a document name,\n     * and it does not require that the document still exists, it returns all the attachments that at the time of their\n     * deletion had a document with the specified name as their owner.\n     *\n     * @param docName the {@link DeletedAttachment#getDocName() name of the document} the attachment belonged to\n     * @param filename the {@link DeletedAttachment#getFilename() name} of the attachment to search for\n     * @param context see {@link XWikiContext}\n     * @return A list with all the deleted attachments which belonged to the specified document and had the specified\n     *         filename. If no such attachments are found in the trash, an empty list is returned.\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, String filename, XWikiContext context)\n        throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName));\n            XWikiAttachment attachment = new XWikiAttachment(doc, filename);\n            return getAttachmentRecycleBinStore().getAllDeletedAttachments(attachment, context, true);\n        }\n        return null;\n    }\n\n    /**\n     * Retrieve a specific attachment from the trash.\n     *\n     * @param id the unique identifier of the entry in the trash\n     * @param context the XWiki context\n     * @return specified attachment from the trash, {@code null} if not found\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public DeletedAttachment getDeletedAttachment(String id, XWikiContext context) throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            return getAttachmentRecycleBinStore().getDeletedAttachment(NumberUtils.toLong(id), context, true);\n        }\n        return null;\n    }\n\n    public MetaClass getMetaclass()\n    {\n        if (this.metaclass == null) {\n            this.metaclass = MetaClass.getMetaClass();\n        }\n        return this.metaclass;\n    }\n\n    public void setMetaclass(MetaClass metaclass)\n    {\n        this.metaclass = metaclass;\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public List<String> getClassList(XWikiContext context) throws XWikiException\n    {\n        List<String> result = getStore().getClassList(context);\n        Collections.sort(result);\n        return result;\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, 0, 0, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param nb limit the number of results to return\n     * @param start the offset from which to start return results\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, int nb, int start, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, nb, start, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, Object[][] whereParams, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, 0, 0, whereParams, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param nb limit the number of results to return\n     * @param start the offset from which to start return results\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, int nb, int start, Object[][] whereParams, XWikiContext context)\n        throws XWikiException\n    {\n        return getStore().search(sql, nb, start, whereParams, context);\n    }\n\n    /**\n     * @param content the content to parse\n     * @param context see {@link XWikiContext}\n     * @deprecated Since 7.2M1. Use specific rendering/parsing options for the content type you want to parse/render.\n     */\n    @Deprecated\n    public String parseContent(String content, XWikiContext context)\n    {\n        return getOldRendering().parseContent(content, context);\n    }\n\n    /**\n     * @param template the name of the template\n     * @param context see {@link XWikiContext}\n     * @deprecated use {@link #evaluateTemplate(String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String parseTemplate(String template, XWikiContext context)\n    {\n        String result = \"\";\n\n        try {\n            result = evaluateTemplate(template, context);\n        } catch (Exception e) {\n            LOGGER.debug(\"Exception while parsing template [{}] from /templates/\", template, e);\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate provided template content using velocity engine.\n     *\n     * @param template the template to evaluate\n     * @param context see {@link XWikiContext}\n     * @return the return of the velocity script\n     * @throws IOException failed to get the template content\n     * @since 2.2.2\n     * @deprecated since 7.0M1, use {@link TemplateManager#render(String)} instead\n     */\n    @Deprecated\n    public String evaluateTemplate(String template, XWikiContext context) throws IOException\n    {\n        try {\n            return getTemplateManager().render(template);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while evaluating velocity template [{}]\", template, e);\n\n            Object[] args = { template };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while evaluating velocity template {0}\",\n                e, args);\n\n            return Util.getHTMLExceptionMessage(xe, context);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param skinId the id of the skin from which to load the template\n     * @param context see {@link XWikiContext}\n     * @deprecated since 7.0M1, use {@link TemplateManager#renderFromSkin} instead\n     */\n    @Deprecated\n    public String parseTemplate(String template, String skinId, XWikiContext context)\n    {\n        MutableRenderingContext mutableRenderingContext = getMutableRenderingContext();\n\n        Syntax currentTargetSyntax = mutableRenderingContext.getTargetSyntax();\n        try {\n            // Force rendering with XHTML 1.0 syntax for retro-compatibility\n            mutableRenderingContext.setTargetSyntax(Syntax.XHTML_1_0);\n\n            Skin skin = getInternalSkinManager().getSkin(skinId);\n            return getTemplateManager().renderFromSkin(template, skin);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while evaluating velocity template [{}] skin [{}]\", template, skinId, e);\n\n            Object[] args = { template, skinId };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION,\n                \"Error while evaluating velocity template [{0}] from skin [{1}]\", e, args);\n\n            return Util.getHTMLExceptionMessage(xe, context);\n        } finally {\n            mutableRenderingContext.setTargetSyntax(currentTargetSyntax);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param skin the id of the skin from which to load the template\n     * @param context see {@link XWikiContext}\n     */\n    public String renderTemplate(String template, String skin, XWikiContext context)\n    {\n        try {\n            return getOldRendering().renderTemplate(template, skin, context);\n        } catch (Exception ex) {\n            LOGGER.error(\"Failed to render template [\" + template + \"] for skin [\" + skin + \"]\", ex);\n            return parseTemplate(template, skin, context);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param context see {@link XWikiContext}\n     */\n    public String renderTemplate(String template, XWikiContext context)\n    {\n        try {\n            return getOldRendering().renderTemplate(template, context);\n        } catch (Exception ex) {\n            LOGGER.error(\"Failed to render template [\" + template + \"]\", ex);\n            return parseTemplate(template, context);\n        }\n    }\n\n    /**\n     * @param iconName the standard name of an icon (it's not the name of the file on the filesystem, it's a generic\n     *            name, for example \"success\" for a success icon\n     * @param context see {@link XWikiContext}\n     * @return the URL to the icon resource\n     * @since 2.6M1\n     */\n    public String getIconURL(String iconName, XWikiContext context)\n    {\n        // TODO: Do a better mapping between generic icon name and physical resource name, especially to be independent\n        // of the underlying icon library. Right now we assume it's the Silk icon library.\n        return getSkinFile(\"icons/silk/\" + iconName + \".png\", context);\n    }\n\n    public String getSkinFile(String filename, XWikiContext context)\n    {\n        return getSkinFile(filename, false, context);\n    }\n\n    /**\n     * Build and return a skin file url based on the given parameters.\n     * \n     * @param filename the file name of the skin file wanted\n     * @param forceSkinAction if true force the usage of directory /skins/ in the URL\n     * @param context current context for the request\n     * @return a resource URL for the asked filename\n     */\n    public String getSkinFile(String filename, boolean forceSkinAction, XWikiContext context)\n    {\n        String skinFile = getSkinFile(filename, null, forceSkinAction, context);\n\n        if (skinFile == null) {\n            // Use the default base skin even if the URL could be invalid.\n            XWikiURLFactory urlf = context.getURLFactory();\n            URL url;\n            if (forceSkinAction) {\n                url = urlf.createSkinURL(filename, \"skins\", getDefaultBaseSkin(context), context);\n            } else {\n                url = urlf.createSkinURL(filename, getDefaultBaseSkin(context), context);\n            }\n            skinFile = urlf.getURL(url, context);\n        }\n\n        return skinFile;\n    }\n\n    private String getSkinFileInternal(String fileName, String skinId, boolean forceSkinAction, XWikiContext context)\n    {\n        try {\n            if (skinId != null) {\n                // Try only in the specified skin.\n                Skin skin = getInternalSkinManager().getSkin(skinId);\n                if (skin != null) {\n                    Resource<?> resource = skin.getLocalResource(fileName);\n                    if (resource != null) {\n                        return resource.getURL(forceSkinAction);\n                    }\n                }\n            } else {\n                // Try in the current skin.\n                Skin skin = getInternalSkinManager().getCurrentSkin(true);\n                if (skin != null) {\n                    Resource<?> resource = skin.getResource(fileName);\n                    if (resource != null) {\n                        return resource.getURL(forceSkinAction);\n                    }\n                } else {\n                    // Try in the current parent skin.\n                    Skin parentSkin = getInternalSkinManager().getCurrentParentSkin(true);\n                    if (parentSkin != null) {\n                        Resource<?> resource = parentSkin.getResource(fileName);\n                        if (resource != null) {\n                            return resource.getURL(forceSkinAction);\n                        }\n                    }\n                }\n            }\n\n            // Look for a resource file.\n            String resourceFilePath = \"/resources/\" + fileName;\n            XWikiURLFactory urlFactory = context.getURLFactory();\n            if (resourceExists(resourceFilePath)) {\n                URL url = urlFactory.createResourceURL(fileName, forceSkinAction, context,\n                    getResourceURLCacheParameters(resourceFilePath));\n                return urlFactory.getURL(url, context);\n            }\n        } catch (Exception e) {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Exception while getting skin file [{}] from skin [{}]\", fileName, skinId, e);\n            }\n        }\n\n        return null;\n    }\n\n    private Map<String, Object> getResourceURLCacheParameters(String resourceFilePath)\n    {\n        try {\n            URL resourceUrl = getResource(resourceFilePath);\n            return getResourceURLCacheParameters(resourceUrl);\n        } catch (MalformedURLException e) {\n            LOGGER.debug(\"Error while getting URL for resource path [{}]\", resourceFilePath, e);\n            return Collections.singletonMap(CACHE_VERSION, getVersion());\n        }\n    }\n\n    private Map<String, Object> getResourceURLCacheParameters(URL resourceUrl)\n    {\n        Map<String, Object> parameters = new LinkedHashMap<>();\n\n        if (getURLConfiguration().useResourceLastModificationDate()) {\n            try {\n                Path resourcePath = Paths.get(resourceUrl.toURI());\n                FileTime lastModifiedTime = Files.getLastModifiedTime(resourcePath);\n                parameters.put(CACHE_VERSION, String.valueOf(lastModifiedTime.toMillis()));\n            } catch (Exception e) {\n                LOGGER.debug(\"Error when trying to access properties of resource URL [{}]\", resourceUrl, e);\n                parameters.put(CACHE_VERSION, getVersion());\n            }\n        } else {\n            parameters.put(CACHE_VERSION, getVersion());\n        }\n\n        return parameters;\n    }\n\n    public String getSkinFile(String filename, String skin, XWikiContext context)\n    {\n        return getSkinFile(filename, skin, false, context);\n    }\n\n    public String getSkinFile(String fileName, String skinId, boolean forceSkinAction, XWikiContext context)\n    {\n        if (StringUtils.endsWithAny(fileName, \".js\", \".css\")) {\n            String extension = StringUtils.substringAfterLast(fileName, '.');\n            String shortFileName = StringUtils.substringBeforeLast(fileName, \".\");\n            if (StringUtils.endsWith(shortFileName, \".min\")) {\n                shortFileName = StringUtils.substringBeforeLast(shortFileName, \".\");\n            }\n            String fileNameSource = String.format(\"%s.%s\", shortFileName, extension);\n            String fileNameMinified = String.format(\"%s.min.%s\", shortFileName, extension);\n            DebugConfiguration debugConfig = Utils.getComponent(DebugConfiguration.class);\n            String[] fileNames = debugConfig.isMinify() ? new String[] {fileNameMinified, fileNameSource}\n                : new String[] {fileNameSource, fileNameMinified};\n            String skinFile = null;\n            for (String name : fileNames) {\n                skinFile = getSkinFileInternal(name, skinId, forceSkinAction, context);\n                if (skinFile != null) {\n                    break;\n                }\n            }\n            return skinFile;\n        } else {\n            return getSkinFileInternal(fileName, skinId, forceSkinAction, context);\n        }\n    }\n\n    /**\n     * @deprecated since 7.0M1, use {@link SkinManager#getCurrentSkin(boolean)} instead\n     */\n    @Deprecated\n    public String getSkin(XWikiContext context)\n    {\n        String skin;\n\n        try {\n            skin = getInternalSkinManager().getCurrentSkinId(true);\n        } catch (Exception e) {\n            LOGGER.debug(\"Exception while determining current skin\", e);\n            skin = getDefaultBaseSkin(context);\n        }\n\n        return skin;\n    }\n\n    public String getSkinPreference(String prefname, XWikiContext context)\n    {\n        return getSkinPreference(prefname, \"\", context);\n    }\n\n    public String getSkinPreference(String prefname, String defaultValue, XWikiContext context)\n    {\n        for (Skin skin = getInternalSkinManager().getCurrentSkin(true); skin != null; skin = skin.getParent()) {\n            if (skin instanceof WikiSkin) {\n                String value = getWikiSkinUtils().getSkinProperty(skin.getId(), prefname);\n\n                // TODO: remove the NO_VALUE test when XWIKI-10853 is fixed\n                if (!StringUtils.isEmpty(value) && !NO_VALUE.equals(value)) {\n                    return value;\n                }\n            }\n        }\n\n        return defaultValue;\n    }\n\n    /**\n     * @deprecated since 7.0M1, use {@link SkinManager#getDefaultParentSkin()} instead\n     */\n    @Deprecated\n    public String getDefaultBaseSkin(XWikiContext context)\n    {\n        return getInternalSkinManager().getDefaultParentSkinId();\n    }\n\n    /**\n     * @deprecated since 7.0M1\n     */\n    @Deprecated\n    public String getBaseSkin(XWikiContext context)\n    {\n        return getBaseSkin(context, false);\n    }\n\n    /**\n     * @deprecated since 7.0M1\n     */\n    @Deprecated\n    public String getBaseSkin(XWikiContext context, boolean fromRenderSkin)\n    {\n        String baseskin = \"\";\n        try {\n            return getInternalSkinManager().getCurrentParentSkinId(false);\n        } catch (Exception e) {\n            baseskin = getDefaultBaseSkin(context);\n\n            LOGGER.debug(\"Exception while determining base skin\", e);\n        }\n\n        return baseskin;\n    }\n\n    /**\n     * @param skin the name of the skin for which to return the base skin. For example : <tt>XWiki.DefaultSkin</tt>\n     * @param context see {@link XWikiContext}\n     * @return if found, the name of the base skin the asked skin inherits from. If not found, returns an empty string.\n     * @since 2.0.2\n     * @since 2.1M1\n     * @deprecated since 7.0M1, use {@link SkinManager#getCurrentSkin(boolean)} and {@link Skin#getParent()} instead\n     */\n    @Deprecated\n    public String getBaseSkin(String skin, XWikiContext context)\n    {\n        String baseSkin = getInternalSkinManager().getParentSkin(skin);\n\n        return baseSkin != null ? baseSkin : \"\";\n    }\n\n    public String getSpaceCopyright(XWikiContext context)\n    {\n        return getSpacePreference(\"webcopyright\", \"\", context);\n    }\n\n    public String getXWikiPreference(String prefname, XWikiContext context)\n    {\n        return getXWikiPreference(prefname, \"\", context);\n    }\n\n    /**\n     * Obtain a preference value for the wiki, looking up first in the XWiki.XWikiPreferences document, then fallbacking\n     * on a config parameter when the first lookup gives an empty string, then returning the default value if the config\n     * parameter returned itself an empty string.\n     *\n     * @param prefname the parameter to look for in the XWiki.XWikiPreferences object in the XWiki.XWikiPreferences\n     *            document of the wiki.\n     * @param fallbackParam the parameter in xwiki.cfg to fallback on, in case the XWiki.XWikiPreferences object gave no\n     *            result\n     * @param defaultValue the default value to fallback on, in case both XWiki.XWikiPreferences and the fallback\n     *            xwiki.cfg parameter gave no result\n     */\n    public String getXWikiPreference(String prefname, String fallbackParam, String defaultValue, XWikiContext context)\n    {\n        String result = getWikiConfiguration().getProperty(prefname, String.class);\n\n        if (StringUtils.isEmpty(result)) {\n            result = getConfiguration().getProperty(fallbackParam, defaultValue);\n        }\n\n        return result != null ? result : \"\";\n    }\n\n    /**\n     * Obtain a preference value for the wiki, looking up first in the XWiki.XWikiPreferences document, then fallbacking\n     * on a config parameter when the first lookup gives an empty string, then returning the default value if the config\n     * parameter returned itself an empty string.\n     *\n     * @param prefname the parameter to look for in the XWiki.XWikiPreferences object in the XWiki.XWikiPreferences\n     *            document of the wiki.\n     * @param wiki the wiki to get preference from\n     * @param fallbackParam the parameter in xwiki.cfg to fallback on, in case the XWiki.XWikiPreferences object gave no\n     *            result\n     * @param defaultValue the default value to fallback on, in case both XWiki.XWikiPreferences and the fallback\n     *            xwiki.cfg parameter gave no result\n     * @since 7.4M1\n     */\n    public String getXWikiPreference(String prefname, String wiki, String fallbackParam, String defaultValue,\n        XWikiContext xcontext)\n    {\n        String currentWiki = xcontext.getWikiId();\n\n        try {\n            xcontext.setWikiId(wiki);\n\n            return getXWikiPreference(prefname, fallbackParam, defaultValue, xcontext);\n        } finally {\n            xcontext.setWikiId(currentWiki);\n        }\n    }\n\n    public String getXWikiPreference(String prefname, String defaultValue, XWikiContext context)\n    {\n        return getXWikiPreference(prefname, \"\", defaultValue, context);\n    }\n\n    public String getSpacePreference(String preference, XWikiContext context)\n    {\n        return getSpacePreference(preference, \"\", context);\n    }\n\n    public String getSpacePreference(String preference, String defaultValue, XWikiContext context)\n    {\n        return getSpacePreference(preference, (SpaceReference) null, defaultValue, context);\n    }\n\n    /**\n     * @deprecated since 7.4M1, use {@link #getSpacePreference(String, SpaceReference, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String getSpacePreference(String preference, String space, String defaultValue, XWikiContext context)\n    {\n        return getSpacePreference(preference, new SpaceReference(space, context.getWikiReference()), defaultValue,\n            context);\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then empty String is returned.\n     * \n     * @param preferenceKey the name of the preference key\n     * @param spaceReference the reference of the space\n     * @param context see {@link XWikiContext}\n     * @return the value of the preference or empty String if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreference(String preferenceKey, SpaceReference spaceReference, XWikiContext context)\n    {\n        return getSpacePreference(preferenceKey, spaceReference, \"\", context);\n    }\n\n    /**\n     * Get the preference key for the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then <code>defaultValue</code> is returned.\n     * \n     * @param preferenceKey the name of the preference key\n     * @param spaceReference the reference of the space. If null and there's a current document then the current space\n     *                       is used. If null and there's no current document then fall back to the wiki preferences.\n     * @param defaultValue the value to return if the preference can't be found\n     * @param context see {@link XWikiContext}\n     * @return the value of the preference or <code>defaultValue</code> if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreference(String preferenceKey, SpaceReference spaceReference, String defaultValue,\n        XWikiContext context)\n    {\n        XWikiDocument currentDocument = context.getDoc();\n\n        try {\n            if (spaceReference != null) {\n                context.setDoc(new XWikiDocument(new DocumentReference(\"WebPreferences\", spaceReference)));\n            } else if (currentDocument != null) {\n                spaceReference = currentDocument.getDocumentReference().getLastSpaceReference();\n            }\n\n            String result = getSpaceConfiguration().getProperty(preferenceKey, String.class);\n\n            if (StringUtils.isEmpty(result)) {\n                if (spaceReference == null) {\n                    result = getXWikiPreference(preferenceKey, defaultValue, context);\n                } else if (spaceReference.getParent() instanceof SpaceReference) {\n                    result = getSpacePreference(preferenceKey, (SpaceReference) spaceReference.getParent(),\n                        defaultValue, context);\n                } else if (spaceReference.getParent() instanceof WikiReference) {\n                    result =\n                        getXWikiPreference(preferenceKey, spaceReference.getParent().getName(), defaultValue, context);\n                }\n            }\n\n            return result != null ? result : defaultValue;\n        } finally {\n            context.setDoc(currentDocument);\n        }\n    }\n\n    public String getUserPreference(String prefname, XWikiContext context)\n    {\n        String result =\n            getAllUserPropertiesResolver().resolve(CurrentUserReference.INSTANCE).getProperty(prefname, String.class);\n\n        return result != null ? result : \"\";\n    }\n\n    public String getUserPreferenceFromCookie(String prefname, XWikiContext context)\n    {\n        Cookie[] cookies = context.getRequest().getCookies();\n        if (cookies == null) {\n            return null;\n        }\n        for (Cookie cookie : cookies) {\n            String name = cookie.getName();\n            if (name.equals(prefname)) {\n                String value = cookie.getValue();\n                if (!value.trim().equals(\"\")) {\n                    return value;\n                } else {\n                    break;\n                }\n            }\n        }\n        return null;\n    }\n\n    public String getUserPreference(String prefname, boolean useCookie, XWikiContext context)\n    {\n        // First we look in the cookies\n        if (useCookie) {\n            String result = Util.normalizeLanguage(getUserPreferenceFromCookie(prefname, context));\n            if (result != null) {\n                return result;\n            }\n        }\n        return getUserPreference(prefname, context);\n    }\n\n    /**\n     * Set the locale in the given context.\n     * <p>\n     * If {@code forceSupported} is true, then the locale will be set only if it is in the {@see availableLocales}. Note\n     * that all the parent locales are checked.\n     *\n     * @param locale the locale to use\n     * @param context the context\n     * @param availableLocales the accepted locales. Used only if {@see forceSupported} is true\n     * @param forceSupported determine if the {@see locale} should be checked against the {@see availableLocales}\n     * @return the locale that has been set or null\n     */\n    private Locale setLocale(Locale locale, XWikiContext context, Set<Locale> availableLocales, boolean forceSupported)\n    {\n        while (locale != null) {\n            if (!forceSupported || availableLocales.contains(locale)) {\n                context.setLocale(locale);\n                break;\n            }\n            locale = LocaleUtils.getParentLocale(locale);\n        }\n\n        return locale;\n    }\n\n    /**\n     * The algorithm to find the locale to use is the following, in this order:\n     *\n     * <ul>\n     *   <li>Try to find the current locale in use from the XWiki contex</li>\n     *   <li>If the wiki is not multilingual use the wiki default locale ({@code default_language} xproperty in\n     *   {@code XWikiPreferences} xobject or English if not found)</li>\n     *   <li>If the wiki is multilingual<ul>\n     *     <li>Try to get the locale passed in the request (looking for a {@code language} query string parameter).\n     *     If the language value is {@code default} use the wiki default locale. If a parameter is found sets a\n     *     {@code language} cookie to remember the language in use.</li>\n     *     <li>Try to get the locale from the {@code language} cookie</li>\n     *     <li>If the default language is preferred ({@code xwiki.language.preferDefault} from {@code xwiki.cfg}\n     *     or {@code preferDefaultLanguage} property from the space preferences ({@code WebPreferences} xobject) or\n     *     wiki preferences ({@code XWikiPreferences} xobject})), and since the user didn't explicitly ask for a\n     *     language already, then use the wiki default locale.</li>\n     *     <li>Try to use the browser's {@code Accept-Language} header sent in HTTP request.<li>\n     *     <li>Fallback to the wiki default locale</li>\n     *   </ul></li>\n     * </ul>\n     *\n     * In addition the {code xwiki.language.forceSupported} configuration property is enabled by default and means that\n     * if at any step above the locale found is not in the list of supported locales, then the locale is not set and\n     * the algorithm moves to the next step.\n     *\n     * @return the locale to use\n     * @since 8.0M1\n     */\n    public Locale getLocalePreference(XWikiContext context)\n    {\n        Locale defaultLocale = this.getDefaultLocale(context);\n        Set<Locale> availableLocales = new HashSet<>(this.getAvailableLocales(context));\n        boolean forceSupported = getConfiguration().getProperty(\"xwiki.language.forceSupported\", \"1\").equals(\"1\");\n\n        // First we try to get the language from the XWiki Context. This is the current language\n        // being used.\n        Locale locale = context.getLocale();\n        if (locale != null) {\n            return locale;\n        }\n\n        // If the wiki is non multilingual then the language is the default language.\n        if (!isMultiLingual(context)) {\n            locale = defaultLocale;\n            context.setLocale(locale);\n            return locale;\n        }\n\n        // As the wiki is multilingual try to find the language to use from the request by looking\n        // for a language parameter. If the language value is \"default\" use the default language\n        // from the XWiki preferences settings. Otherwise set a cookie to remember the language\n        // in use.\n        try {\n            String language = Util.normalizeLanguage(context.getRequest().getParameter(\"language\"));\n            if (language != null) {\n                if (\"default\".equals(language)) {\n                    // forgetting language cookie\n                    Cookie cookie = new Cookie(\"language\", \"\");\n                    cookie.setMaxAge(0);\n                    cookie.setPath(\"/\");\n                    context.getResponse().addCookie(cookie);\n                    context.setLocale(defaultLocale);\n                    return defaultLocale;\n                } else {\n                    locale = setLocale(LocaleUtils.toLocale(language), context, availableLocales, forceSupported);\n                    if (LocaleUtils.isAvailableLocale(locale)) {\n                        // setting language cookie\n                        Cookie cookie = new Cookie(\"language\", context.getLocale().toString());\n                        cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                        cookie.setPath(\"/\");\n                        context.getResponse().addCookie(cookie);\n                        return locale;\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        // As no language parameter was passed in the request, try to get the language to use from a cookie.\n        try {\n            // First we get the language from the cookie\n            String language = Util.normalizeLanguage(getUserPreferenceFromCookie(\"language\", context));\n            if (StringUtils.isNotEmpty(language)) {\n                locale = setLocale(LocaleUtils.toLocale(language), context, availableLocales, forceSupported);\n                if (LocaleUtils.isAvailableLocale(locale)) {\n                    return locale;\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        // If the default language is preferred, and since the user didn't explicitly ask for a\n        // language already, then use the default wiki language.\n        if (getConfiguration().getProperty(\"xwiki.language.preferDefault\", \"0\").equals(\"1\")\n            || getSpacePreference(\"preferDefaultLanguage\", \"0\", context).equals(\"1\")) {\n            locale = defaultLocale;\n            context.setLocale(locale);\n            return locale;\n        }\n\n        // Then from the navigator language setting\n        if (context.getRequest() != null && context.getRequest().getLocales() != null) {\n            for (Locale acceptedLocale : Collections.list(context.getRequest().getLocales())) {\n                locale = setLocale(acceptedLocale, context, availableLocales, forceSupported);\n                if (LocaleUtils.isAvailableLocale(locale)) {\n                    return locale;\n                }\n            }\n            // If none of the languages requested by the client is acceptable, skip to next\n            // phase (use default language).\n        }\n\n        // Finally, use the default language from the global preferences.\n        context.setLocale(defaultLocale);\n        return defaultLocale;\n    }\n\n    /**\n     * First try to find the current locale in use from the XWiki context. If none is used and if the wiki is not\n     * multilingual use the default locale defined in the XWiki preferences. If the wiki is multilingual try to get the\n     * locale passed in the request. If none was passed try to get it from a cookie. If no locale cookie exists then use\n     * the user default locale and barring that use the browser's \"Accept-Language\" header sent in HTTP request. If none\n     * is defined use the default locale.\n     *\n     * @return the locale to use\n     * @deprecated since 8.0M1, use {@link #getLocalePreference(XWikiContext)} instead\n     */\n    @Deprecated\n    public String getLanguagePreference(XWikiContext context)\n    {\n        return getLocalePreference(context).toString();\n    }\n\n    /**\n     * Construct a list of language codes (ISO 639-1) from the Accept-Languages header. This method filters out some\n     * bugs in different browsers or containers, like returning '*' as a language (Jetty) or using '_' as a\n     * language--country delimiter (some versions of Opera).\n     *\n     * @param request The client request.\n     * @return A list of language codes, in the client preference order; might be empty if the header is not well\n     *         formed.\n     */\n    private List<String> getAcceptedLanguages(XWikiRequest request)\n    {\n        List<String> result = new ArrayList<String>();\n        Enumeration<Locale> e = request.getLocales();\n        while (e.hasMoreElements()) {\n            String language = e.nextElement().getLanguage().toLowerCase();\n            // All language codes should have 2 letters.\n            if (StringUtils.isAlpha(language)) {\n                result.add(language);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @deprecated since 5.1M2 use {@link #getDefaultLocale(XWikiContext)} instead\n     */\n    @Deprecated\n    public String getDefaultLanguage(XWikiContext xcontext)\n    {\n        return getDefaultLocale(xcontext).toString();\n    }\n\n    /**\n     * The default locale in the preferences.\n     *\n     * @param xcontext the XWiki context.\n     * @return the default locale\n     * @since 5.1M2\n     */\n    public Locale getDefaultLocale(XWikiContext xcontext)\n    {\n        // Find out what is the default language from the XWiki preferences settings.\n        String defaultLanguage = xcontext.getWiki().getXWikiPreference(\"default_language\", \"\", xcontext);\n\n        Locale defaultLocale;\n\n        if (StringUtils.isBlank(defaultLanguage)) {\n            defaultLocale = Locale.ENGLISH;\n        } else {\n            try {\n                defaultLocale = LocaleUtils.toLocale(Util.normalizeLanguage(defaultLanguage));\n            } catch (Exception e) {\n                LOGGER.warn(\"Invalid locale [{}] set as default locale in the preferences\", defaultLanguage);\n                defaultLocale = Locale.ENGLISH;\n            }\n        }\n\n        return defaultLocale;\n    }\n\n    /**\n     * Get the available locales according to the preferences.\n     *\n     * @param xcontext the XWiki context\n     * @return all the available locales\n     * @since 5.1M2\n     */\n    public List<Locale> getAvailableLocales(XWikiContext xcontext)\n    {\n        String[] languages = StringUtils.split(xcontext.getWiki().getXWikiPreference(\"languages\", xcontext), \", |\");\n\n        List<Locale> locales = new ArrayList<Locale>(languages.length);\n\n        for (String language : languages) {\n            if (StringUtils.isNotBlank(language)) {\n                try {\n                    locales.add(LocaleUtils.toLocale(language));\n                } catch (Exception e) {\n                    LOGGER.warn(\"Invalid locale [{}] listed as available in the preferences\", language);\n                }\n            }\n        }\n\n        // Add default language in case it's not listed as available (which is wrong but it happen)\n        Locale defaultocale = getDefaultLocale(xcontext);\n        if (!locales.contains(defaultocale)) {\n            locales.add(defaultocale);\n        }\n\n        return locales;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public Locale getDocLocalePreferenceNew(XWikiContext context)\n    {\n        String language = getDocLanguagePreferenceNew(context);\n\n        return LocaleUtils.toLocale(language);\n    }\n\n    /**\n     * @deprecated since 8.0M1, use {@link #getDocLocalePreferenceNew(XWikiContext)} instead\n     */\n    @Deprecated\n    // TODO: move implementation to #getDocLocalePreferenceNew\n    public String getDocLanguagePreferenceNew(XWikiContext context)\n    {\n        // Get context language\n        String contextLanguage = context.getLanguage();\n        // If the language exists in the context, it was previously set by another call\n        if (!StringUtils.isEmpty(contextLanguage)) {\n            return contextLanguage;\n        }\n\n        String language = \"\", requestLanguage = \"\", userPreferenceLanguage = \"\", navigatorLanguage = \"\",\n            cookieLanguage = \"\";\n        boolean setCookie = false;\n\n        if (!context.getWiki().isMultiLingual(context)) {\n            language = context.getWiki().getXWikiPreference(\"default_language\", \"\", context);\n            context.setLanguage(language);\n            return language;\n        }\n\n        // Get request language\n        try {\n            requestLanguage = Util.normalizeLanguage(context.getRequest().getParameter(\"language\"));\n        } catch (Exception ex) {\n        }\n\n        // Get user preference\n        try {\n            String user = context.getUser();\n            XWikiDocument userdoc = getDocument(user, context);\n            if (userdoc != null) {\n                userPreferenceLanguage = userdoc.getStringValue(\"XWiki.XWikiUsers\", \"default_language\");\n            }\n        } catch (XWikiException e) {\n        }\n\n        // Get navigator language setting\n        if (context.getRequest() != null) {\n            String accept = context.getRequest().getHeader(\"Accept-Language\");\n            if ((accept != null) && (!accept.equals(\"\"))) {\n                String[] alist = StringUtils.split(accept, \",;-\");\n                if ((alist != null) && !(alist.length == 0)) {\n                    context.setLanguage(alist[0]);\n                    navigatorLanguage = alist[0];\n                }\n            }\n        }\n\n        // Get language from cookie\n        try {\n            cookieLanguage = Util.normalizeLanguage(getUserPreferenceFromCookie(\"language\", context));\n        } catch (Exception e) {\n        }\n\n        // Determine which language to use\n        // First we get the language from the request\n        if (StringUtils.isNotEmpty(requestLanguage)) {\n            if (requestLanguage.equals(\"default\")) {\n                setCookie = true;\n            } else {\n                language = requestLanguage;\n                context.setLanguage(language);\n                Cookie cookie = new Cookie(\"language\", language);\n                cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                cookie.setPath(\"/\");\n                context.getResponse().addCookie(cookie);\n                return language;\n            }\n        }\n        // Next we get the language from the cookie\n        if (StringUtils.isNotEmpty(cookieLanguage)) {\n            language = cookieLanguage;\n        }\n        // Next from the default user preference\n        else if (StringUtils.isNotEmpty(userPreferenceLanguage)) {\n            language = userPreferenceLanguage;\n        }\n        // Then from the navigator language setting\n        else if (StringUtils.isNotEmpty(navigatorLanguage)) {\n            language = navigatorLanguage;\n        }\n        context.setLanguage(language);\n        if (setCookie) {\n            Cookie cookie = new Cookie(\"language\", language);\n            cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n            cookie.setPath(\"/\");\n            context.getResponse().addCookie(cookie);\n        }\n        return language;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public Locale getInterfaceLocalePreference(XWikiContext context)\n    {\n        String language = getInterfaceLanguagePreference(context);\n\n        return LocaleUtils.toLocale(language);\n    }\n\n    /**\n     * @deprecated since 8.0M1, use {@link #getInterfaceLocalePreference(XWikiContext)} instead\n     */\n    @Deprecated\n    // TODO: move implementation to #getInterfaceLocalePreference\n    public String getInterfaceLanguagePreference(XWikiContext context)\n    {\n        String language = \"\", requestLanguage = \"\", userPreferenceLanguage = \"\", navigatorLanguage = \"\",\n            cookieLanguage = \"\", contextLanguage = \"\";\n        boolean setCookie = false;\n\n        if (!context.getWiki().isMultiLingual(context)) {\n            language = Util.normalizeLanguage(context.getWiki().getXWikiPreference(\"default_language\", \"\", context));\n            context.setInterfaceLocale(LocaleUtils.toLocale(language));\n            return language;\n        }\n\n        // Get request language\n        try {\n            requestLanguage = Util.normalizeLanguage(context.getRequest().getParameter(\"interfacelanguage\"));\n        } catch (Exception ex) {\n        }\n\n        // Get context language\n        contextLanguage = context.getInterfaceLanguage();\n\n        // Get user preference\n        try {\n            String user = context.getUser();\n            XWikiDocument userdoc = null;\n            userdoc = getDocument(user, context);\n            if (userdoc != null) {\n                userPreferenceLanguage = userdoc.getStringValue(\"XWiki.XWikiUsers\", \"default_interface_language\");\n            }\n        } catch (XWikiException e) {\n        }\n\n        // Get navigator language setting\n        if (context.getRequest() != null) {\n            String accept = context.getRequest().getHeader(\"Accept-Language\");\n            if ((accept != null) && (!accept.equals(\"\"))) {\n                String[] alist = StringUtils.split(accept, \",;-\");\n                if ((alist != null) && !(alist.length == 0)) {\n                    context.setLanguage(alist[0]);\n                    navigatorLanguage = alist[0];\n                }\n            }\n        }\n\n        // Get language from cookie\n        try {\n            cookieLanguage = Util.normalizeLanguage(getUserPreferenceFromCookie(\"interfacelanguage\", context));\n        } catch (Exception e) {\n        }\n\n        // Determine which language to use\n        // First we get the language from the request\n        if ((requestLanguage != null) && (!requestLanguage.equals(\"\"))) {\n            if (requestLanguage.equals(\"default\")) {\n                setCookie = true;\n            } else {\n                language = requestLanguage;\n                context.setLanguage(language);\n                Cookie cookie = new Cookie(\"interfacelanguage\", language);\n                cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                cookie.setPath(\"/\");\n                context.getResponse().addCookie(cookie);\n                return language;\n            }\n        }\n        // Next we get the language from the context\n        if (!StringUtils.isEmpty(contextLanguage)) {\n            language = contextLanguage;\n        }\n        // Next we get the language from the cookie\n        else if (StringUtils.isNotEmpty(cookieLanguage)) {\n            language = cookieLanguage;\n        }\n        // Next from the default user preference\n        else if (StringUtils.isNotEmpty(userPreferenceLanguage)) {\n            language = userPreferenceLanguage;\n        }\n        // Then from the navigator language setting\n        else if (StringUtils.isNotEmpty(navigatorLanguage)) {\n            language = navigatorLanguage;\n        }\n        context.setLanguage(language);\n        if (setCookie) {\n            Cookie cookie = new Cookie(\"interfacelanguage\", language);\n            cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n            cookie.setPath(\"/\");\n            context.getResponse().addCookie(cookie);\n        }\n        return language;\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getXWikiPreference(preference, context));\n    }\n\n    public long getSpacePreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getSpacePreference(preference, context));\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, long defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toLong((getXWikiPreference(preference, context)), defaultValue);\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, String fallbackParameter, long defaultValue,\n        XWikiContext context)\n    {\n        return NumberUtils.toLong(getXWikiPreference(preference, fallbackParameter, \"\", context), defaultValue);\n    }\n\n    public long getSpacePreferenceAsLong(String preference, long defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toLong(getSpacePreference(preference, context), defaultValue);\n    }\n\n    public long getUserPreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getUserPreference(preference, context));\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, XWikiContext context)\n    {\n        return Integer.parseInt(getXWikiPreference(preference, context));\n    }\n\n    public int getSpacePreferenceAsInt(String preference, XWikiContext context)\n    {\n        return Integer.parseInt(getSpacePreference(preference, context));\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, int defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toInt(getXWikiPreference(preference, context), defaultValue);\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, String fallbackParameter, int defaultValue,\n        XWikiContext context)\n    {\n        return NumberUtils.toInt(getXWikiPreference(preference, fallbackParameter, \"\", context), defaultValue);\n    }\n\n    public int getSpacePreferenceAsInt(String preference, int defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toInt(getSpacePreference(preference, context), defaultValue);\n    }\n\n    public int getUserPreferenceAsInt(String prefname, XWikiContext context)\n    {\n        return Integer.parseInt(getUserPreference(prefname, context));\n    }\n\n    public void flushCache(XWikiContext context)\n    {\n        // We need to flush the virtual wiki list\n        this.initializedWikis = new ConcurrentHashMap<>();\n\n        // We need to flush the group service cache\n        if (this.groupService != null) {\n            this.groupService.flushCache();\n        }\n\n        // If we use the Cache Store layer.. we need to flush it\n        XWikiStoreInterface store = getStore();\n        if ((store != null) && (store instanceof XWikiCacheStoreInterface)) {\n            ((XWikiCacheStoreInterface) getStore()).flushCache();\n        }\n        // Flush renderers.. Groovy renderer has a cache\n        getOldRendering().flushCache();\n        getParseGroovyFromString().flushCache();\n\n        XWikiPluginManager pmanager = getPluginManager();\n        if (pmanager != null) {\n            pmanager.flushCache(context);\n        }\n\n        // Make sure we call all classes flushCache function\n        try {\n            List<String> classes = getClassList(context);\n            for (int i = 0; i < classes.size(); i++) {\n                String className = classes.get(i);\n                try {\n                    getClass(className, context).flushCache();\n                } catch (Exception e) {\n                }\n            }\n        } catch (Exception e) {\n        }\n\n    }\n\n    public XWikiPluginManager getPluginManager()\n    {\n        return this.pluginManager;\n    }\n\n    public void setPluginManager(XWikiPluginManager pluginManager)\n    {\n        this.pluginManager = pluginManager;\n    }\n\n    public void setStore(XWikiStoreInterface store)\n    {\n        this.store = store;\n    }\n\n    /**\n     * @param attachmentContentStore the store to use by default when saving a new attachment content\n     * @since 9.10RC1\n     */\n    public void setDefaultAttachmentContentStore(XWikiAttachmentStoreInterface attachmentContentStore)\n    {\n        this.defaultAttachmentContentStore = attachmentContentStore;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #setDefaultAttachmentContentStore(XWikiAttachmentStoreInterface)} instead\n     */\n    @Deprecated\n    public void setAttachmentStore(XWikiAttachmentStoreInterface attachmentStore)\n    {\n        this.defaultAttachmentContentStore = attachmentStore;\n    }\n\n    /**\n     * @param attachmentArchiveStore the store to use by default when saving a new attachment archive\n     * @since 9.10RC1\n     */\n    public void setDefaultAttachmentArchiveStore(AttachmentVersioningStore attachmentArchiveStore)\n    {\n        this.defaultAttachmentArchiveStore = attachmentArchiveStore;\n    }\n\n    /**\n     * @deprecated since 9.10RC1, use {@link #setDefaultAttachmentArchiveStore(AttachmentVersioningStore)} instead\n     */\n    @Deprecated\n    public void setAttachmentVersioningStore(AttachmentVersioningStore attachmentArchiveStore)\n    {\n        setDefaultAttachmentArchiveStore(attachmentArchiveStore);\n    }\n\n    public void setVersioningStore(XWikiVersioningStoreInterface versioningStore)\n    {\n        this.versioningStore = versioningStore;\n    }\n\n    public void setRecycleBinStore(XWikiRecycleBinStoreInterface recycleBinStore)\n    {\n        this.recycleBinStore = recycleBinStore;\n    }\n\n    public void setAttachmentRecycleBinStore(AttachmentRecycleBinStore attachmentRecycleBinStore)\n    {\n        this.attachmentRecycleBinStore = attachmentRecycleBinStore;\n    }\n\n    public void setCriteriaService(XWikiCriteriaService criteriaService)\n    {\n        this.criteriaService = criteriaService;\n    }\n\n    public void setVersion(String version)\n    {\n        this.version = version;\n    }\n\n    /**\n     * Verify if the provided xclass page exists and that it contains all the required configuration properties to make\n     * the tag feature work properly. If some properties are missing they are created and saved in the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @param classReference the reference of the document containing the class\n     * @return the Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     */\n    private BaseClass getMandatoryClass(XWikiContext context, DocumentReference classReference) throws XWikiException\n    {\n        XWikiDocument document = getDocument(classReference, context);\n\n        if (context.get(\"initdone\") == null) {\n            @SuppressWarnings(\"deprecation\")\n            MandatoryDocumentInitializer initializer =\n                Utils.getComponent(MandatoryDocumentInitializer.class, document.getFullName());\n\n            if (initializer.updateDocument(document)) {\n                saveDocument(document, localizePlainOrKey(\"core.model.xclass.mandatoryUpdateProperty.versionSummary\"),\n                    context);\n            }\n        }\n\n        return document.getXClass();\n    }\n\n    /**\n     * Verify if the <code>XWiki.TagClass</code> page exists and that it contains all the required configuration\n     * properties to make the tag feature work properly. If some properties are missing they are created and saved in\n     * the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the TagClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getTagClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"TagClass\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.SheetClass</code> page exists and that it contains all the required configuration\n     * properties to make the sheet feature work properly. If some properties are missing they are created and saved in\n     * the database. SheetClass is used to a page as a sheet. When a page is tagged as a sheet and that page is included\n     * in another page using the include macro then editing it triggers automatic inline edition (for XWiki Syntax 2.0\n     * only - for XWiki Syntax 1.0 automatic inline edition is triggered using #includeForm).\n     *\n     * @param context see {@link XWikiContext}\n     * @return the SheetClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     * @deprecated since 3.1M2 edit mode class should be used for this purpose, not the sheet class\n     * @see #getEditModeClass(XWikiContext)\n     */\n    @Deprecated\n    public BaseClass getSheetClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"SheetClass\"));\n    }\n\n    /**\n     * Verify if the {@code XWiki.EditModeClass} page exists and that it contains all the required configuration\n     * properties to make the edit mode feature work properly. If some properties are missing they are created and saved\n     * in the database. EditModeClass is used to specify the default edit mode of a page. It can also be used to mark a\n     * page as a sheet. When a page is marked as a sheet and that page is included in another page using the include\n     * macro then editing it triggers automatic inline edition (for XWiki Syntax 2.0 only - for XWiki Syntax 1.0\n     * automatic inline edition is triggered using #includeForm). It replaces and enhances the SheetClass mechanism (see\n     * {@link #getSheetClass(XWikiContext)}).\n     *\n     * @param context see {@link XWikiContext}\n     * @return the EditModeClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     * @since 3.1M2\n     */\n    public BaseClass getEditModeClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(\n            new LocalDocumentReference(XWikiConstant.EDIT_MODE_CLASS), new WikiReference(context.getWikiId())));\n    }\n\n    /**\n     * Verify if the <code>XWiki.XWikiUsers</code> page exists and that it contains all the required configuration\n     * properties to make the user feature work properly. If some properties are missing they are created and saved in\n     * the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the XWikiUsers Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getUserClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiUsers\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.GlobalRedirect</code> page exists and that it contains all the required configuration\n     * properties to make the redirection feature work properly. If some properties are missing they are created and\n     * saved in the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the GlobalRedirect Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getRedirectClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"GlobalRedirect\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.XWikiPreferences</code> page exists and that it contains all the required configuration\n     * properties to make XWiki work properly. If some properties are missing they are created and saved in the\n     * database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the XWiki Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getPrefsClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, getPreferencesDocumentReference(context));\n    }\n\n    public BaseClass getGroupClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiGroups\"));\n    }\n\n    public BaseClass getRightsClass(String pagename, XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, pagename));\n    }\n\n    public BaseClass getRightsClass(XWikiContext context) throws XWikiException\n    {\n        return getRightsClass(\"XWikiRights\", context);\n    }\n\n    public BaseClass getGlobalRightsClass(XWikiContext context) throws XWikiException\n    {\n        return getRightsClass(\"XWikiGlobalRights\", context);\n    }\n\n    public BaseClass getCommentsClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiComments\"));\n    }\n\n    public BaseClass getSkinClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiSkins\"));\n    }\n\n    public int createUser(XWikiContext context) throws XWikiException\n    {\n        return createUser(false, \"edit\", context);\n    }\n\n    public int validateUser(boolean withConfirmEmail, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            // Get the user document\n            String username = convertUsername(request.getParameter(\"xwikiname\"), context);\n            if (username.indexOf('.') == -1) {\n                username = \"XWiki.\" + username;\n            }\n            XWikiDocument userDocument = getDocument(username, context);\n\n            // Get the stored validation key\n            BaseObject userObject = userDocument.getObject(\"XWiki.XWikiUsers\", 0);\n            String storedKey = userObject.getStringValue(\"validkey\");\n\n            // Get the validation key from the URL\n            String validationKey = request.getParameter(\"validkey\");\n            PropertyInterface validationKeyClass = getClass(\"XWiki.XWikiUsers\", context).get(\"validkey\");\n            if (validationKeyClass instanceof PasswordClass) {\n                validationKey = ((PasswordClass) validationKeyClass).getEquivalentPassword(storedKey, validationKey);\n            }\n\n            // Compare the two keys\n            if ((!storedKey.equals(\"\") && (storedKey.equals(validationKey)))) {\n                // Ensure to remove the validation key value, so it cannot be used afterwards to enable back\n                // a disabled user.\n                userObject.setStringValue(\"validkey\", \"\");\n                saveDocument(userDocument, context);\n\n                XWikiUser xWikiUser = new XWikiUser(userDocument.getDocumentReference());\n                xWikiUser.setDisabled(false, context);\n                xWikiUser.setEmailChecked(true, context);\n\n                if (withConfirmEmail) {\n                    String email = userObject.getStringValue(\"email\");\n                    String password = userObject.getStringValue(\"password\");\n                    sendValidationEmail(username, password, email, request.getParameter(\"validkey\"),\n                        \"confirmation_email_content\", context);\n                }\n\n                return 0;\n            } else {\n                return -1;\n            }\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_VALIDATE_USER,\n                \"Exception while validating user\", e, null);\n        }\n    }\n\n    public int createUser(boolean withValidation, String userRights, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            Map<String, String[]> map = Util.getObject(request, \"register\");\n\n            String content = \"\";\n            Syntax syntax = getDefaultDocumentSyntaxInternal();\n\n            // Read the values from the request.\n            String xwikiname = request.getParameter(\"xwikiname\");\n            String password2 = request.getParameter(\"register2_password\");\n            String password = (map.get(\"password\"))[0];\n            String email = (map.get(\"email\"))[0];\n            String template = request.getParameter(\"template\");\n            String parent = request.getParameter(\"parent\");\n            String validkey = null;\n\n            // Validate the values.\n            if (XWikiRightService.SUPERADMIN_USER.equalsIgnoreCase(xwikiname)) {\n                return -8;\n            }\n            try {\n                if (!context.getUtil().match(getConfiguration().getProperty(\"xwiki.validusername\", \"/^[a-zA-Z0-9_]+$/\"),\n                    xwikiname)) {\n                    return -4;\n                }\n            } catch (RuntimeException ex) {\n                LOGGER.warn(\"Invalid regular expression for xwiki.validusername\", ex);\n                if (!context.getUtil().match(\"/^[a-zA-Z0-9_]+$/\", xwikiname)) {\n                    return -4;\n                }\n            }\n\n            if ((!password.equals(password2))) {\n                // TODO: throw wrong password exception\n                return -2;\n            }\n\n            if ((template != null) && (!template.equals(\"\"))) {\n                XWikiDocument tdoc = getDocument(template, context);\n                if ((!tdoc.isNew())) {\n                    // FIXME: This ignores template objects, attachments, etc.\n                    content = tdoc.getContent();\n                    syntax = tdoc.getSyntax();\n                }\n            }\n\n            if ((parent == null) || (parent.equals(\"\"))) {\n                parent = \"XWiki.XWikiUsers\";\n            }\n\n            // Mark the user as active or waiting email validation.\n            if (withValidation) {\n                map.put(XWikiUser.ACTIVE_PROPERTY, new String[] { \"0\" });\n                map.put(XWikiUser.EMAIL_CHECKED_PROPERTY, new String[] { \"0\" });\n\n                validkey = generateValidationKey(16);\n                map.put(\"validkey\", new String[] { validkey });\n\n            } else {\n                // Mark user active\n                map.put(XWikiUser.ACTIVE_PROPERTY, new String[] { \"1\" });\n                map.put(XWikiUser.EMAIL_CHECKED_PROPERTY, new String[] { \"1\" });\n            }\n\n            // Create the user.\n            int result =\n                createUser(xwikiname, map, getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT),\n                    content, syntax, userRights, context);\n\n            // Send validation mail, if needed.\n            if ((result > 0) && (withValidation)) {\n                // Send the validation email\n                try {\n                    sendValidationEmail(xwikiname, password, email, validkey, \"validation_email_content\", context);\n                } catch (XWikiException e) {\n                    LOGGER.warn(\"User created. Failed to send the mail to the created user.\", e);\n                    return -11;\n                }\n\n            }\n\n            return result;\n        } catch (XWikiException e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw e;\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_CREATE_USER,\n                \"Exception while creating user\", e, null);\n        }\n    }\n\n    /**\n     * Method allows to create an empty user with no password (he won't be able to login) This method is usefull for\n     * authentication like LDAP or App Server trusted\n     *\n     * @param xwikiname\n     * @param userRights\n     * @param context see {@link XWikiContext}\n     * @return true if success\n     * @throws XWikiException\n     */\n    public boolean createEmptyUser(String xwikiname, String userRights, XWikiContext context) throws XWikiException\n    {\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"active\", \"1\");\n        map.put(\"first_name\", xwikiname);\n\n        if (createUser(xwikiname, map, userRights, context) == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void sendConfirmationEmail(String xwikiname, String password, String email, String message,\n        String contentfield, XWikiContext context) throws XWikiException\n    {\n        sendValidationEmail(xwikiname, password, email, \"message\", message, contentfield, context);\n    }\n\n    public void sendValidationEmail(String xwikiname, String password, String email, String validkey,\n        String contentfield, XWikiContext context) throws XWikiException\n    {\n        sendValidationEmail(xwikiname, password, email, \"validkey\", validkey, contentfield, context);\n    }\n\n    public void sendValidationEmail(String xwikiname, String password, String email, String addfieldname,\n        String addfieldvalue, String contentfield, XWikiContext context) throws XWikiException\n    {\n        MailSenderConfiguration configuration = Utils.getComponent(MailSenderConfiguration.class);\n\n        String sender;\n        String content;\n        try {\n            sender = configuration.getFromAddress();\n            if (StringUtils.isBlank(sender)) {\n                String server = context.getRequest().getServerName();\n                if (server.matches(\"\\\\[.*\\\\]|(\\\\d{1,3}+\\\\.){3}+\\\\d{1,3}+\")) {\n                    sender = \"noreply@domain.net\";\n                } else {\n                    sender = \"noreply@\" + server;\n                }\n            }\n            content = getXWikiPreference(contentfield, context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_CANNOT_GET_VALIDATION_CONFIG,\n                \"Exception while reading the validation email config\", e, null);\n\n        }\n\n        try {\n            VelocityContext vcontext = (VelocityContext) context.get(\"vcontext\");\n            vcontext.put(addfieldname, addfieldvalue);\n            vcontext.put(\"email\", email);\n            vcontext.put(\"password\", password);\n            vcontext.put(\"sender\", sender);\n            vcontext.put(\"xwikiname\", xwikiname);\n            content = parseContent(content, context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_CANNOT_PREPARE_VALIDATION_EMAIL,\n                \"Exception while preparing the validation email\", e, null);\n\n        }\n\n        // Let's now send the message\n        try {\n            Session session =\n                Session.getInstance(configuration.getAllProperties(), new XWikiAuthenticator(configuration));\n            InputStream is = new ByteArrayInputStream(content.getBytes());\n            MimeMessage message = new MimeMessage(session, is);\n            message.setFrom(new InternetAddress(sender));\n            message.setRecipients(Message.RecipientType.TO, email);\n            message.setHeader(\"X-MailType\", \"Account Validation\");\n            MailSender mailSender = Utils.getComponent(MailSender.class);\n            MailListener mailListener = Utils.getComponent(MailListener.class, \"database\");\n            mailSender.sendAsynchronously(Arrays.asList(message), session, mailListener);\n            mailListener.getMailStatusResult().waitTillProcessed(Long.MAX_VALUE);\n            String errorMessage = MailStatusResultSerializer.serializeErrors(mailListener.getMailStatusResult());\n            if (errorMessage != null) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                    XWikiException.ERROR_XWIKI_EMAIL_ERROR_SENDING_EMAIL,\n                    String.format(\"Error while sending the validation email. %s\", errorMessage));\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_ERROR_SENDING_EMAIL, \"Error while sending the validation email\", e);\n        }\n    }\n\n    public String generateRandomString(int size)\n    {\n        return RandomStringUtils.randomAlphanumeric(size);\n    }\n\n    public String generateValidationKey(int size)\n    {\n        return generateRandomString(size);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, XWikiContext context) throws XWikiException\n    {\n        return createUser(userName, map, \"edit\", context);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param userRights the right of the user on his own profile page\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, String userRights, XWikiContext context)\n        throws XWikiException\n    {\n        BaseClass userClass = getUserClass(context);\n\n        String content = \"\";\n        Syntax syntax = getDefaultDocumentSyntaxInternal();\n\n        return createUser(userName, map,\n            new EntityReference(userClass.getDocumentReference().getName(), EntityType.DOCUMENT), content, syntax,\n            userRights, context);\n    }\n\n    /**\n     * @deprecated since 2.4RC1 use\n     *             {@link #createUser(String, Map, EntityReference, String, Syntax, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public int createUser(String userName, Map<String, ?> map, String parent, String content, String syntaxId,\n        String userRights, XWikiContext context) throws XWikiException\n    {\n        Syntax syntax;\n\n        try {\n            syntax = Syntax.valueOf(syntaxId);\n        } catch (ParseException e) {\n            syntax = getDefaultDocumentSyntaxInternal();\n        }\n\n        return createUser(userName, map, getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT),\n            content, syntax, userRights, context);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param parentReference the parent of the user profile\n     * @param content the content of the user profile\n     * @param syntax the syntax of the provided content\n     * @param userRights the right of the user on his own profile page\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, EntityReference parentReference, String content,\n        Syntax syntax, String userRights, XWikiContext context) throws XWikiException\n    {\n        BaseClass userClass = getUserClass(context);\n\n        try {\n            // TODO: Verify existing user\n            XWikiDocument doc = getDocument(new DocumentReference(context.getWikiId(), \"XWiki\", userName), context);\n\n            if (!doc.isNew()) {\n                // TODO: throws Exception\n                return -3;\n            }\n\n            DocumentReference userClassReference = userClass.getDocumentReference();\n            BaseObject userObject =\n                doc.newXObject(userClassReference.removeParent(userClassReference.getWikiReference()), context);\n            userClass.fromMap(map, userObject);\n\n            doc.setParentReference(parentReference);\n            doc.setContent(content);\n            doc.setSyntax(syntax);\n\n            // Set the user itself as the creator of the document, so that she has the CREATOR right on her user page.\n            doc.setCreatorReference(doc.getDocumentReference());\n\n            // However, we use the context user for the author to see in the history who has really created the user\n            // (it may be an administrator).\n            if (context.getUserReference() != null) {\n                doc.setAuthorReference(context.getUserReference());\n            } else {\n                // Except if the current user is guest (which means the user registered herself)\n                doc.setAuthorReference(doc.getDocumentReference());\n            }\n\n            // The information from the user profile needs to be indexed using the proper locale. If multilingual is\n            // enabled then the user can choose the desired locale (from the list of supported locales) before\n            // registering. An administrator registering users can do the same. Otherwise, if there is only one locale\n            // supported then that langage will be used.\n            doc.setDefaultLocale(context.getLocale());\n\n            protectUserPage(doc.getFullName(), userRights, doc, context);\n\n            saveDocument(doc, localizePlainOrKey(\"core.comment.createdUser\"), context);\n\n            // Now let's add the user to XWiki.XWikiAllGroup\n            setUserDefaultGroup(doc.getFullName(), context);\n\n            return 1;\n        } catch (Exception e) {\n            Object[] args = { \"XWiki.\" + userName };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_CREATE,\n                \"Cannot create user {0}\", e, args);\n        }\n    }\n\n    /**\n     * @deprecated starting with XE 1.8.1 use\n     *             {@link #createUser(String, Map, String, String, String, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public int createUser(String xwikiname, Map<String, ?> map, String parent, String content, String userRights,\n        XWikiContext context) throws XWikiException\n    {\n        return createUser(xwikiname, map, parent, content, Syntax.XWIKI_1_0.toIdString(), userRights, context);\n    }\n\n    public void setUserDefaultGroup(String fullwikiname, XWikiContext context) throws XWikiException\n    {\n        String groupsPreference = isAllGroupImplicit() ? getConfiguration().getProperty(\"xwiki.users.initialGroups\")\n            : getConfiguration().getProperty(\"xwiki.users.initialGroups\", \"XWiki.XWikiAllGroup\");\n\n        if (groupsPreference != null) {\n            String[] groups = groupsPreference.split(\",\");\n            for (String groupName : groups) {\n                if (StringUtils.isNotBlank(groupName)) {\n                    addUserToGroup(fullwikiname, groupName.trim(), context);\n                }\n            }\n        }\n    }\n\n    protected void addUserToGroup(String userName, String groupName, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groupDoc = getDocument(groupName, context);\n\n        DocumentReference groupClassReference = getGroupClass(context).getDocumentReference();\n        BaseObject memberObject =\n            groupDoc.newXObject(groupClassReference.removeParent(groupClassReference.getWikiReference()), context);\n\n        memberObject.setStringValue(\"member\", userName);\n\n        this.saveDocument(groupDoc, localizePlainOrKey(\"core.comment.addedUserToGroup\"), context);\n    }\n\n    public void protectUserPage(String userName, String userRights, XWikiDocument doc, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference rightClassReference = getRightsClass(context).getDocumentReference();\n\n        EntityReference relativeRightClassReference =\n            rightClassReference.removeParent(rightClassReference.getWikiReference());\n\n        // Allow users to edit their own profiles\n        BaseObject newuserrightsobject = doc.newXObject(relativeRightClassReference, context);\n        newuserrightsobject.setLargeStringValue(\"users\", userName);\n        newuserrightsobject.setStringValue(\"levels\", userRights);\n        newuserrightsobject.setIntValue(\"allow\", 1);\n    }\n\n    public User getUser(XWikiContext context)\n    {\n        return getUser(context.getUserReference(), context);\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link #getUser(DocumentReference, XWikiContext)}.\n     */\n    @Deprecated\n    public User getUser(String username, XWikiContext context)\n    {\n        XWikiUser xwikiUser = new XWikiUser(username);\n        User user = new User(xwikiUser, context);\n        return user;\n    }\n\n    /**\n     * Retrieve a user from its document reference.\n     *\n     * @param userReference the reference of the user.\n     * @param context the current context.\n     * @return the user corresponding to that document reference.\n     * @since 11.8RC1\n     */\n    public User getUser(DocumentReference userReference, XWikiContext context)\n    {\n        XWikiUser xwikiUser = new XWikiUser(userReference);\n        User user = new User(xwikiUser, context);\n        return user;\n    }\n\n    /**\n     * Prepares the localized resources, according to the selected locale. Set context \"msg\" and locale.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public void prepareResources(XWikiContext context)\n    {\n        if (context.get(\"msg\") == null) {\n            Locale locale = getLocalePreference(context);\n            context.setLocale(locale);\n            if (context.getResponse() != null) {\n                context.getResponse().setLocale(locale);\n            }\n            XWikiMessageTool msg = new XWikiMessageTool(Utils.getComponent(ContextualLocalizationManager.class));\n            context.put(\"msg\", msg);\n        }\n    }\n\n    public XWikiUser checkAuth(XWikiContext context) throws XWikiException\n    {\n        return getAuthService().checkAuth(context);\n    }\n\n    public boolean checkAccess(String action, XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        // Handle the 'skin' action specially so that resources don`t require special (or even 'view') rights.\n        String firstSpaceName = doc.getDocumentReference().getSpaceReferences().get(0).getName();\n        if (action.equals(\"skin\") && SKIN_RESOURCE_SPACE_NAMES.contains(firstSpaceName)) {\n            // We still need to call checkAuth to set the proper user.\n            XWikiUser user = checkAuth(context);\n            if (user != null) {\n                context.setUser(user.getUser());\n            }\n\n            // Always allow.\n            return true;\n        }\n\n        return getRightService().checkAccess(action, doc, context);\n    }\n\n    public String include(String topic, boolean isForm, XWikiContext context) throws XWikiException\n    {\n        String database = null, incdatabase = null;\n        String prefixedTopic, localTopic;\n\n        // Save current documents in script context\n        Document currentAPIdoc = null, currentAPIcdoc = null, currentAPItdoc = null;\n        ScriptContextManager scritContextManager = Utils.getComponent(ScriptContextManager.class);\n        ScriptContext scontext = scritContextManager.getScriptContext();\n        String currentDocName = context.getWikiId() + \":\" + context.getDoc().getFullName();\n        if (scontext != null) {\n            currentAPIdoc = (Document) scontext.getAttribute(\"doc\");\n            currentAPIcdoc = (Document) scontext.getAttribute(\"cdoc\");\n            currentAPItdoc = (Document) scontext.getAttribute(\"tdoc\");\n        }\n\n        try {\n            int i0 = topic.indexOf(':');\n            if (i0 != -1) {\n                incdatabase = topic.substring(0, i0);\n                database = context.getWikiId();\n                context.setWikiId(incdatabase);\n                prefixedTopic = topic;\n                localTopic = topic.substring(i0 + 1);\n            } else {\n                prefixedTopic = context.getWikiId() + \":\" + topic;\n                localTopic = topic;\n            }\n\n            XWikiDocument doc = null;\n            try {\n                LOGGER.debug(\"Including Topic \" + topic);\n                try {\n                    @SuppressWarnings(\"unchecked\")\n                    Set<String> includedDocs = (Set<String>) context.get(\"included_docs\");\n                    if (includedDocs == null) {\n                        includedDocs = new HashSet<String>();\n                        context.put(\"included_docs\", includedDocs);\n                    }\n\n                    if (includedDocs.contains(prefixedTopic) || currentDocName.equals(prefixedTopic)) {\n                        LOGGER.warn(\"Error on too many recursive includes for topic \" + topic);\n                        return \"Cannot make recursive include\";\n                    }\n                    includedDocs.add(prefixedTopic);\n                } catch (Exception e) {\n                }\n\n                // Get document to include\n                DocumentReference targetDocumentReference =\n                    getCurrentMixedDocumentReferenceResolver().resolve(localTopic);\n                doc = getDocument(targetDocumentReference, context);\n\n                if (checkAccess(\"view\", doc, context) == false) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED, \"Access to this document is denied: \" + doc);\n                }\n            } catch (XWikiException e) {\n                LOGGER.warn(\"Exception Including Topic \" + topic, e);\n                return \"Topic \" + topic + \" does not exist\";\n            }\n\n            XWikiDocument contentdoc = doc.getTranslatedDocument(context);\n\n            String result;\n            if (isForm) {\n                // We do everything in the context of the including document\n                if (database != null) {\n                    context.setWikiId(database);\n                }\n\n                // Note: the Script macro in the new rendering checks for programming rights for the document in\n                // the xwiki context.\n                result = getRenderedContent(contentdoc, (XWikiDocument) context.get(\"doc\"), context);\n            } else {\n                // We stay in the included document context\n\n                // Since the Script macro checks for programming rights in the current document, we need to\n                // temporarily set the contentdoc as the current doc before rendering it.\n                XWikiDocument originalDoc = null;\n                try {\n                    originalDoc = context.getDoc();\n                    context.put(\"doc\", doc);\n                    result = getRenderedContent(contentdoc, doc, context);\n                } finally {\n                    context.put(\"doc\", originalDoc);\n                }\n            }\n            try {\n                @SuppressWarnings(\"unchecked\")\n                Set<String> includedDocs = (Set<String>) context.get(\"included_docs\");\n                if (includedDocs != null) {\n                    includedDocs.remove(prefixedTopic);\n                }\n            } catch (Exception e) {\n            }\n            return result;\n        } finally {\n            if (database != null) {\n                context.setWikiId(database);\n            }\n\n            if (currentAPIdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"doc\", currentAPIdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n            if (currentAPIcdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"cdoc\", currentAPIcdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n            if (currentAPItdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"tdoc\", currentAPItdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n        }\n    }\n\n    /**\n     * Render content from the passed included document, setting the correct security doc (sdoc) and including doc\n     * (idoc).\n     *\n     * @since 2.2M2\n     */\n    private String getRenderedContent(XWikiDocument includedDoc, XWikiDocument includingDoc, XWikiContext context)\n        throws XWikiException\n    {\n        String result;\n        XWikiDocument idoc = (XWikiDocument) context.get(\"idoc\");\n        XWikiDocument sdoc = (XWikiDocument) context.get(\"sdoc\");\n\n        context.put(\"idoc\", includingDoc);\n        context.put(\"sdoc\", includedDoc);\n        try {\n            result = includedDoc.getRenderedContent(Utils.getComponent(RenderingContext.class).getTargetSyntax(), false,\n                context);\n        } finally {\n            // Remove including doc or set the previous one\n            if (idoc == null) {\n                context.remove(\"idoc\");\n            } else {\n                context.put(\"idoc\", idoc);\n            }\n\n            // Remove security doc or set the previous one\n            if (sdoc == null) {\n                context.remove(\"sdoc\");\n            } else {\n                context.put(\"sdoc\", sdoc);\n            }\n        }\n\n        return result;\n    }\n\n    public void deleteDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        deleteDocument(doc, true, context);\n    }\n\n    public void deleteDocument(XWikiDocument doc, boolean totrash, XWikiContext context) throws XWikiException\n    {\n        deleteDocument(doc, totrash, true, context);\n    }\n\n    private XWikiDocument prepareDocumentDelete(XWikiDocument doc, XWikiContext context)\n    {\n        // The source document is a new empty XWikiDocument to follow\n        // DocumentUpdatedEvent policy: source document in new document and the old version is available using\n        // doc.getOriginalDocument()\n        XWikiDocument blankDoc = new XWikiDocument(doc.getDocumentReference());\n        // Again to follow general event policy, new document author is the user who modified the document\n        // (here the modification is delete)\n        blankDoc.setOriginalDocument(doc.getOriginalDocument());\n        blankDoc.setAuthorReference(context.getUserReference());\n        blankDoc.setContentAuthorReference(context.getUserReference());\n\n        return blankDoc;\n    }\n\n    private XWikiDocument beforeDelete(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument blankDoc = prepareDocumentDelete(doc, context);\n\n        ObservationManager om = getObservationManager();\n\n        // Inform notification mechanisms that a document is about to be deleted\n        // Note that for the moment the event being send is a bridge event, as we are still passing around\n        // an XWikiDocument as source and an XWikiContext as data.\n        if (om != null) {\n            CancelableEvent documentEvent = new DocumentDeletingEvent(doc.getDocumentReference());\n            om.notify(documentEvent, blankDoc, context);\n\n            // If the action has been canceled by the user then don't perform any deletion and throw an exception\n            if (documentEvent.isCanceled()) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_DOC,\n                    String.format(\"An Event Listener has cancelled the document deletion for [%s]. Reason: [%s]\",\n                        doc.getDocumentReference(), documentEvent.getReason()));\n            }\n        }\n\n        return blankDoc;\n    }\n\n    private void afterDelete(XWikiDocument blankDoc, XWikiContext context)\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            om.notify(new DocumentDeletedEvent(blankDoc.getDocumentReference()), blankDoc, context);\n        }\n    }\n\n    private void deleteDocument(XWikiDocument doc, boolean totrash, boolean notify, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = null;\n\n        currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(doc.getDocumentReference().getWikiReference().getName());\n\n            XWikiDocument blankDoc = null;\n\n            // Inform notification mechanisms that a document is about to be deleted\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            if (notify) {\n                blankDoc = beforeDelete(doc, context);\n            }\n\n            if (hasRecycleBin(context) && totrash) {\n                // Extract any existing batchId from the context.\n                String batchId = Utils.getComponent(BatchOperationExecutor.class).getCurrentBatchId();\n\n                // Save to recycle bin together with any determined batch ID.\n                getRecycleBinStore().saveToRecycleBin(doc, context.getUser(), new Date(), batchId, context, true);\n            }\n\n            getStore().deleteXWikiDoc(doc, context);\n\n            try {\n                // Inform notification mechanisms that a document has been deleted\n                // Note that for the moment the event being send is a bridge event, as we are still passing around\n                // an XWikiDocument as source and an XWikiContext as data.\n                if (notify) {\n                    afterDelete(blankDoc, context);\n                }\n            } catch (Exception ex) {\n                LOGGER.error(\"Failed to send document delete notifications for document [{}]\",\n                    doc.getDocumentReference(), ex);\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Check if the user is allowed to delete the document.\n     * \n     * @param userReference the user responsible for the delete\n     * @param document the document to delete\n     * @param context the XWiki context\n     * @throws XWikiException when failing to delete\n     * @since 11.6\n     * @since 10.11.10\n     */\n    public void checkDeletingDocument(DocumentReference userReference, XWikiDocument document, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = null;\n\n        currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            XWikiDocument blankDoc = prepareDocumentDelete(document, context);\n\n            ObservationManager om = getObservationManager();\n\n            // Inform notification mechanisms that a document is about to be deleted\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            if (om != null) {\n                CancelableEvent documentEvent =\n                    new UserDeletingDocumentEvent(userReference, document.getDocumentReference());\n                om.notify(documentEvent, blankDoc, context);\n\n                // If the action has been canceled by the user then don't perform any deletion and throw an exception\n                if (documentEvent.isCanceled()) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                        String.format(\"User [%s] has been denied the right to delete the document [%s]. Reason: [%s]\",\n                            userReference, document.getDocumentReference(), documentEvent.getReason()));\n                }\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Delete a range of versions from a document history.\n     * \n     * @param document the document from which to delete versions\n     * @param version1 one end of the versions range to remove\n     * @param version2 the other end of the versions range to remove\n     * @param context the XWiki context\n     * @throws XWikiException\n     * @since 13.6RC1\n     */\n    @Unstable\n    public void deleteDocumentVersions(XWikiDocument document, String version1, String version2, XWikiContext context)\n        throws XWikiException\n    {\n        Version v1 = new Version(version1);\n        Version v2 = new Version(version2);\n\n        // Find the lower and upper bounds\n        Version upperBound = v1;\n        Version lowerBound = v2;\n        if (upperBound.compareVersions(lowerBound) < 0) {\n            Version tmp = upperBound;\n            upperBound = lowerBound;\n            lowerBound = tmp;\n        }\n\n        XWikiDocumentArchive archive = document.getDocumentArchive(context);\n\n        // Remove the versions\n        archive.removeVersions(upperBound, lowerBound, context);\n\n        // Is this the last remaining version? If so, then recycle the document.\n        if (archive.getLatestVersion() == null) {\n            // Wrap the work as a batch operation.\n            BatchOperationExecutor batchOperationExecutor = Utils.getComponent(BatchOperationExecutor.class);\n            batchOperationExecutor.execute(() -> {\n                if (document.getLocale().equals(Locale.ROOT)) {\n                    context.getWiki().deleteAllDocuments(document, context);\n                } else {\n                    // Only delete the translation\n                    context.getWiki().deleteDocument(document, context);\n                }\n            });\n        } else {\n            // Notify before versions delete\n            getObservationManager()\n                .notify(new DocumentVersionRangeDeletingEvent(document.getDocumentReferenceWithLocale(),\n                    lowerBound.toString(), upperBound.toString()), document, context);\n\n            // Update the archive\n            context.getWiki().getVersioningStore().saveXWikiDocArchive(archive, true, context);\n            document.setDocumentArchive(archive);\n\n            // There are still some versions left.\n            // If we delete the most recent (current) version, then rollback to latest undeleted version.\n            Version previousVersion = archive.getLatestVersion();\n            if (!document.getRCSVersion().equals(previousVersion)) {\n                context.getWiki().rollback(document, previousVersion.toString(), false, context);\n            }\n\n            // Notify after versions delete\n            getObservationManager()\n                .notify(new DocumentVersionRangeDeletedEvent(document.getDocumentReferenceWithLocale(),\n                    lowerBound.toString(), upperBound.toString()), document, context);\n        }\n    }\n\n    public String getDatabase()\n    {\n        return this.database;\n    }\n\n    public void setDatabase(String database)\n    {\n        this.database = database;\n    }\n\n    public void gc()\n    {\n        System.gc();\n    }\n\n    public long freeMemory()\n    {\n        return Runtime.getRuntime().freeMemory();\n    }\n\n    public long totalMemory()\n    {\n        return Runtime.getRuntime().totalMemory();\n    }\n\n    public long maxMemory()\n    {\n        return Runtime.getRuntime().maxMemory();\n    }\n\n    public String[] split(String str, String sep)\n    {\n        return StringUtils.split(str, sep);\n    }\n\n    /**\n     * @deprecated use {@link ExceptionUtils#getStackTrace(Throwable)} instead\n     */\n    @Deprecated\n    public String printStrackTrace(Throwable e)\n    {\n        StringWriter strwriter = new StringWriter();\n        PrintWriter writer = new PrintWriter(strwriter);\n        e.printStackTrace(writer);\n\n        return strwriter.toString();\n    }\n\n    /**\n     * API to rename a document to another document.\n     *\n     * @param sourceDocumentReference the source document to rename.\n     * @param targetDocumentReference the target reference to rename the document to.\n     * @param overwrite if {@code true} the target document reference will be overwritten if it exists\n     *                  (deleted to the recycle bin before the rename). If {@code false} and the target document exist\n     *                  the rename won't be performed.\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *                                  modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *                                 document reference\n     * @return {@code true} if the rename succeeded. {@code false} if there was any issue.\n     * @throws XWikiException if the document cannot be renamed properly.\n     * @since 12.5RC1\n     */\n    @Unstable\n    public boolean renameDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean overwrite, List<DocumentReference> backlinkDocumentReferences,\n        List<DocumentReference> childDocumentReferences, XWikiContext context)\n        throws XWikiException\n    {\n        boolean result = false;\n\n        // if source and destination are same, no need to perform the rename.\n        if (!sourceDocumentReference.equals(targetDocumentReference)) {\n            XWikiDocument sourceDocument = this.getDocument(sourceDocumentReference, context);\n            XWikiDocument targetDocument = this.getDocument(targetDocumentReference, context);\n\n            ConfigurationSource xwikiproperties = Utils.getComponent(ConfigurationSource.class, \"xwikiproperties\");\n            boolean useAtomicRename = xwikiproperties.getProperty(\"refactoring.rename.useAtomicRename\", Boolean.TRUE);\n\n            // Proceed on the rename only if the source document exists and if either the targetDoc does not exist or\n            // the overwritten is accepted.\n            if (!sourceDocument.isNew() && (overwrite || targetDocument.isNew())) {\n                if (!useAtomicRename) {\n                    this.renameByCopyAndDelete(sourceDocument, targetDocumentReference, backlinkDocumentReferences,\n                        childDocumentReferences, context);\n                    result = true;\n                } else {\n                    // Ensure that the current context contains the wiki reference of the source document.\n                    WikiReference wikiReference = context.getWikiReference();\n                    context.setWikiReference(sourceDocumentReference.getWikiReference());\n\n                    try {\n                        // rename main document\n                        this.atomicRenameDocument(sourceDocument, targetDocumentReference, context);\n\n                        // handle translations\n                        List<Locale> translationLocales = sourceDocument.getTranslationLocales(context);\n                        for (Locale translationLocale : translationLocales) {\n                            DocumentReference translatedSourceReference =\n                                new DocumentReference(sourceDocumentReference, translationLocale);\n                            DocumentReference translatedTargetReference =\n                                new DocumentReference(targetDocumentReference, translationLocale);\n                            XWikiDocument translatedSourceDoc = this.getDocument(translatedSourceReference, context);\n                            this.atomicRenameDocument(translatedSourceDoc, translatedTargetReference, context);\n                        }\n                    } finally {\n                        context.setWikiReference(wikiReference);\n                    }\n\n                    // Step 4: For each child document, update its parent reference.\n                    // Step 5: For each backlink to rename, parse the backlink document and replace the links with\n                    // the new name.\n                    // Step 6: Refactor the relative links contained in the document to make sure they are relative\n                    // to the new document's location.\n                    this.updateLinksForRename(sourceDocument, targetDocumentReference, backlinkDocumentReferences,\n                        childDocumentReferences, context);\n                    result = true;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private void atomicRenameDocument(XWikiDocument sourceDocument, DocumentReference targetDocumentReference,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 1: Simulate creating a document and deleting a document from listeners point of view\n        // FIXME: currently modifications made by listeners won't be applied\n        XWikiDocument futureTargetDocument = sourceDocument.cloneRename(targetDocumentReference, context);\n        futureTargetDocument.setOriginalDocument(new XWikiDocument(targetDocumentReference));\n        beforeSave(futureTargetDocument, context);\n        XWikiDocument deletedDocument = beforeDelete(sourceDocument, context);\n\n        // Step 2: Perform atomic rename in DB\n        this.getStore().renameXWikiDoc(sourceDocument, targetDocumentReference, context);\n\n        // Step 3: Simulate a created document and a deleted document from listeners point of view\n        afterDelete(deletedDocument, context);\n        afterSave(futureTargetDocument, context);\n    }\n\n    private void updateLinksForRename(XWikiDocument sourceDoc, DocumentReference newDocumentReference,\n        List<DocumentReference> backlinkDocumentReferences, List<DocumentReference> childDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 2: For each child document, update its parent reference.\n        if (childDocumentReferences != null) {\n            for (DocumentReference childDocumentReference : childDocumentReferences) {\n                XWikiDocument childDocument = getDocument(childDocumentReference, context);\n                String compactReference = getCompactEntityReferenceSerializer().serialize(newDocumentReference);\n                childDocument.setParent(compactReference);\n                String saveMessage = localizePlainOrKey(\"core.comment.renameParent\", compactReference);\n                childDocument.setAuthorReference(context.getUserReference());\n                saveDocument(childDocument, saveMessage, true, context);\n            }\n        }\n\n        // Step 3: For each backlink to rename, parse the backlink document and replace the links with the new name.\n        for (DocumentReference backlinkDocumentReference : backlinkDocumentReferences) {\n            XWikiDocument backlinkRootDocument = getDocument(backlinkDocumentReference, context);\n\n            // Update default locale instance\n            renameLinks(backlinkRootDocument, sourceDoc.getDocumentReference(), newDocumentReference, context);\n\n            // Update translations\n            for (Locale locale : backlinkRootDocument.getTranslationLocales(context)) {\n                XWikiDocument backlinkDocument = backlinkRootDocument.getTranslatedDocument(locale, context);\n\n                renameLinks(backlinkDocument, sourceDoc.getDocumentReference(), newDocumentReference, context);\n            }\n        }\n\n        // Get new document\n        XWikiDocument newDocument = getDocument(newDocumentReference, context);\n\n        // Step 4: Refactor the relative links contained in the document to make sure they are relative to the new\n        // document's location.\n        if (Utils.getContextComponentManager().hasComponent(BlockRenderer.class, sourceDoc.getSyntax().toIdString())) {\n            // Only support syntax for which a renderer is provided\n\n            ReferenceRenamer referenceRenamer = Utils.getComponent(ReferenceRenamer.class);\n\n            DocumentReference oldDocumentReference = sourceDoc.getDocumentReference();\n            XDOM newDocumentXDOM = newDocument.getXDOM();\n            boolean modified = referenceRenamer\n                .renameReferences(newDocumentXDOM, newDocumentReference, oldDocumentReference, newDocumentReference,\n                    false);\n\n            // Set the new content and save document if needed\n            if (modified) {\n                newDocument.setContent(newDocumentXDOM);\n                newDocument.setAuthorReference(context.getUserReference());\n                saveDocument(newDocument, context);\n            }\n        }\n    }\n\n    /**\n     * Perform a rename of document by copying the document and deleting the old one.\n     * This operation must be used only in case of document rename from one wiki to another, since it's not supported\n     * by the atomic store operation.\n     *\n     * @param newDocumentReference the new document reference\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *            modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *            document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 12.5\n     * @deprecated Old implementation of the rename by copy and delete. Since 12.5 the implementation using\n     * {@link XWikiStoreInterface#renameXWikiDoc(XWikiDocument, DocumentReference, XWikiContext)} should be preferred.\n     */\n    @Deprecated\n    @Unstable\n    public void renameByCopyAndDelete(XWikiDocument sourceDoc, DocumentReference newDocumentReference,\n        List<DocumentReference> backlinkDocumentReferences, List<DocumentReference> childDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 1: Copy the document and all its translations under a new document with the new reference.\n        copyDocument(sourceDoc.getDocumentReference(), newDocumentReference, false, context);\n\n        // Step 2: For each child document, update its parent reference.\n        // Step 3: For each backlink to rename, parse the backlink document and replace the links with the new name.\n        // Step 4: Refactor the relative links contained in the document to make sure they are relative to the new\n        // document's location.\n        updateLinksForRename(sourceDoc, newDocumentReference, backlinkDocumentReferences, childDocumentReferences,\n            context);\n\n        // Step 5: Delete the old document\n        deleteDocument(sourceDoc, context);\n\n        // Get new document\n        XWikiDocument newDocument = getDocument(newDocumentReference, context);\n\n        // Step 6: The current document needs to point to the renamed document as otherwise it's pointing to an\n        // invalid XWikiDocument object as it's been deleted...\n        sourceDoc.clone(newDocument);\n    }\n\n    /**\n     * Rename links in passed document and save it if needed.\n     */\n    private void renameLinks(XWikiDocument backlinkDocument, DocumentReference oldLink, DocumentReference newLink,\n        XWikiContext context) throws XWikiException\n    {\n        // FIXME: Duplicate code. See org.xwiki.refactoring.internal.DefaultLinkRefactoring#renameLinks in\n        // xwiki-platform-refactoring-default\n        getOldRendering().renameLinks(backlinkDocument, oldLink, newLink, context);\n\n        // Save if content changed\n        if (backlinkDocument.isContentDirty()) {\n            String saveMessage =\n                localizePlainOrKey(\"core.comment.renameLink\", getCompactEntityReferenceSerializer().serialize(newLink));\n            backlinkDocument.setAuthorReference(context.getUserReference());\n            context.getWiki().saveDocument(backlinkDocument, saveMessage, true, context);\n        }\n    }\n\n    /**\n     * Used to convert a Document Reference to string (compact form without the wiki part if it matches the current\n     * wiki).\n     */\n    private static EntityReferenceSerializer<String> getCompactWikiEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n    }\n\n    /**\n     * Used to convert a proper Document Reference to string (compact form).\n     */\n    private static EntityReferenceSerializer<String> getCompactEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compact\");\n    }\n\n    /**\n     * Used to resolve a ResourceReference into a proper Entity Reference using the current document to fill the blanks.\n     */\n    private static EntityReferenceResolver<org.xwiki.rendering.listener.reference.ResourceReference>\n        getResourceReferenceEntityReferenceResolver()\n    {\n        return Utils\n            .getComponent(new DefaultParameterizedType(null, EntityReferenceResolver.class,\n                org.xwiki.rendering.listener.reference.ResourceReference.class));\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, true, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean reset, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, reset, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean reset, boolean force, boolean resetCreationData, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, reset, force, resetCreationData,\n            context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, true, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, false, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, boolean force, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, force, false, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, boolean force, boolean resetCreationData, XWikiContext context)\n        throws XWikiException\n    {\n        String db = context.getWikiId();\n        String sourceWiki = sourceDocumentReference.getWikiReference().getName();\n        String targetWiki = targetDocumentReference.getWikiReference().getName();\n\n        String sourceStringReference = getDefaultEntityReferenceSerializer().serialize(sourceDocumentReference);\n\n        try {\n            context.setWikiId(sourceWiki);\n            XWikiDocument sdoc = getDocument(sourceDocumentReference, context);\n            if (!sdoc.isNew()) {\n                LOGGER.info(\"Copying document [{}] to [{}]\", sourceDocumentReference, targetDocumentReference);\n\n                // Let's switch to the other database to verify if the document already exists\n                context.setWikiId(targetWiki);\n                XWikiDocument previoustdoc = getDocument(targetDocumentReference, context);\n                // There is already an existing document\n                if (!previoustdoc.isNew()) {\n                    if (!force) {\n                        return false;\n                    }\n                }\n\n                // Let's switch back again to the original db\n                context.setWikiId(sourceWiki);\n\n                if (wikilocale == null) {\n                    XWikiDocument tdoc = sdoc.copyDocument(targetDocumentReference, context);\n\n                    // Make sure to replace the existing document if any\n                    tdoc.setNew(true);\n\n                    // forget past versions\n                    if (reset) {\n                        tdoc.setVersion(\"1.1\");\n                    }\n                    if (resetCreationData) {\n                        Date now = new Date();\n                        tdoc.setCreationDate(now);\n                        tdoc.setContentUpdateDate(now);\n                        tdoc.setDate(now);\n                        tdoc.setCreatorReference(context.getUserReference());\n                        tdoc.setAuthorReference(context.getUserReference());\n                    }\n\n                    // We don't want to trigger a new version otherwise the version number will be wrong.\n                    tdoc.setMetaDataDirty(false);\n                    tdoc.setContentDirty(false);\n\n                    saveDocument(tdoc, \"Copied from \" + sourceStringReference, context);\n\n                    if (!reset) {\n                        context.setWikiId(sourceWiki);\n                        XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                        context.setWikiId(targetWiki);\n                        txda = txda.clone(tdoc.getId(), context);\n                        getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                    } else {\n                        context.setWikiId(targetWiki);\n                        getVersioningStore().resetRCSArchive(tdoc, true, context);\n                    }\n\n                    // Now we need to copy the translations\n                    context.setWikiId(sourceWiki);\n                    List<String> tlist = sdoc.getTranslationList(context);\n                    for (String clanguage : tlist) {\n                        XWikiDocument stdoc = sdoc.getTranslatedDocument(clanguage, context);\n                        LOGGER.info(\"Copying document [{}], language [{}] to [{}]\", sourceWiki, clanguage,\n                            targetDocumentReference);\n\n                        context.setWikiId(targetWiki);\n                        XWikiDocument ttdoc = tdoc.getTranslatedDocument(clanguage, context);\n\n                        // There is already an existing document\n                        if (ttdoc != tdoc) {\n                            return false;\n                        }\n\n                        // Let's switch back again to the original db\n                        context.setWikiId(sourceWiki);\n\n                        ttdoc = stdoc.copyDocument(targetDocumentReference, context);\n\n                        // Make sure to replace the existing document if any\n                        ttdoc.setNew(true);\n\n                        // forget past versions\n                        if (reset) {\n                            ttdoc.setNew(true);\n                            ttdoc.setVersion(\"1.1\");\n                        }\n                        if (resetCreationData) {\n                            Date now = new Date();\n                            ttdoc.setCreationDate(now);\n                            ttdoc.setContentUpdateDate(now);\n                            ttdoc.setDate(now);\n                            ttdoc.setCreatorReference(context.getUserReference());\n                            ttdoc.setAuthorReference(context.getUserReference());\n                        }\n\n                        // we don't want to trigger a new version\n                        // otherwise the version number will be wrong\n                        tdoc.setMetaDataDirty(false);\n                        tdoc.setContentDirty(false);\n\n                        saveDocument(ttdoc, \"Copied from \" + sourceStringReference, context);\n\n                        if (!reset) {\n                            context.setWikiId(sourceWiki);\n                            XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                            context.setWikiId(targetWiki);\n                            txda = txda.clone(tdoc.getId(), context);\n                            getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                        } else {\n                            getVersioningStore().resetRCSArchive(tdoc, true, context);\n                        }\n                    }\n                } else {\n                    // We want only one language in the end\n                    XWikiDocument stdoc = sdoc.getTranslatedDocument(wikilocale, context);\n\n                    XWikiDocument tdoc = stdoc.copyDocument(targetDocumentReference, context);\n\n                    // Make sure to replace the existing document if any\n                    tdoc.setNew(true);\n\n                    // forget language\n                    tdoc.setDefaultLanguage(wikilocale);\n                    tdoc.setLanguage(\"\");\n                    // forget past versions\n                    if (reset) {\n                        tdoc.setVersion(\"1.1\");\n                    }\n                    if (resetCreationData) {\n                        Date now = new Date();\n                        tdoc.setCreationDate(now);\n                        tdoc.setContentUpdateDate(now);\n                        tdoc.setDate(now);\n                        tdoc.setCreatorReference(context.getUserReference());\n                        tdoc.setAuthorReference(context.getUserReference());\n                    }\n\n                    // we don't want to trigger a new version\n                    // otherwise the version number will be wrong\n                    tdoc.setMetaDataDirty(false);\n                    tdoc.setContentDirty(false);\n\n                    saveDocument(tdoc, \"Copied from \" + sourceStringReference, context);\n\n                    if (!reset) {\n                        context.setWikiId(sourceWiki);\n                        XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                        context.setWikiId(targetWiki);\n                        txda = txda.clone(tdoc.getId(), context);\n                        getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                    } else {\n                        getVersioningStore().resetRCSArchive(tdoc, true, context);\n                    }\n                }\n            }\n            return true;\n        } finally {\n            context.setWikiId(db);\n        }\n    }\n\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale,\n        XWikiContext context) throws XWikiException\n    {\n        return copySpaceBetweenWikis(space, sourceWiki, targetWiki, locale, false, context);\n    }\n\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale, boolean clean,\n        XWikiContext context) throws XWikiException\n    {\n        String db = context.getWikiId();\n        int nb = 0;\n        // Workaround for XWIKI-3915: Do not use XWikiStoreInterface#searchDocumentNames since currently it has the\n        // side effect of hidding hidden documents and no other workaround exists than directly using\n        // XWikiStoreInterface#search directly\n        String sql = \"select distinct doc.fullName from XWikiDocument as doc\";\n        List<String> parameters = new ArrayList<>();\n        if (space != null) {\n            parameters.add(space);\n            sql += \" where doc.space = ?\" + parameters.size();\n        }\n\n        if (clean) {\n            try {\n                context.setWikiId(targetWiki);\n                List<String> list = getStore().search(sql, 0, 0, parameters, context);\n\n                LOGGER.info(\"Deleting [{}] documents from wiki [{}]\", list.size(), targetWiki);\n\n                for (String docname : list) {\n                    XWikiDocument doc = getDocument(docname, context);\n                    deleteDocument(doc, context);\n                }\n            } finally {\n                context.setWikiId(db);\n            }\n        }\n\n        try {\n            context.setWikiId(sourceWiki);\n            List<String> list = getStore().search(sql, 0, 0, parameters, context);\n\n            LOGGER.info(\"Copying [{}] documents from wiki [{}] to wiki [{}]\", list.size(), sourceWiki, targetWiki);\n\n            WikiReference sourceWikiReference = new WikiReference(sourceWiki);\n            WikiReference targetWikiReference = new WikiReference(targetWiki);\n            for (String docname : list) {\n                DocumentReference sourceDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);\n                sourceDocumentReference = sourceDocumentReference\n                    .replaceParent(sourceDocumentReference.getWikiReference(), sourceWikiReference);\n                DocumentReference targetDocumentReference =\n                    sourceDocumentReference.replaceParent(sourceWikiReference, targetWikiReference);\n                copyDocument(sourceDocumentReference, targetDocumentReference, locale, context);\n                nb++;\n            }\n            return nb;\n        } finally {\n            context.setWikiId(db);\n        }\n    }\n\n    /**\n     * Copy an entire wiki to a target wiki.\n     * <p>\n     * It does not override document already existing in target wiki.\n     *\n     * @param sourceWiki the source wiki identifier\n     * @param targetWiki the target wiki identifier\n     * @param locale the locale to copy\n     * @param context see {@link XWikiContext}\n     * @return the number of copied documents\n     * @throws XWikiException failed to copy wiki\n     * @deprecated since 5.3, use {@link WikiManager#copy(String, String, String, boolean, boolean, boolean)} instead\n     */\n    @Deprecated\n    public int copyWiki(String sourceWiki, String targetWiki, String locale, XWikiContext context) throws XWikiException\n    {\n        return copyWiki(sourceWiki, targetWiki, locale, false, context);\n    }\n\n    /**\n     * Copy an entire wiki to a target wiki.\n     *\n     * @param sourceWiki the source wiki identifier\n     * @param targetWiki the target wiki identifier\n     * @param locale the locale to copy\n     * @param clean clean the target wiki before copying\n     * @param context see {@link XWikiContext}\n     * @return the number of copied documents\n     * @throws XWikiException failed to copy wiki\n     * @deprecated since 5.3, use {@link WikiManager#copy(String, String, String, boolean, boolean, boolean)} instead\n     */\n    @Deprecated\n    public int copyWiki(String sourceWiki, String targetWiki, String locale, boolean clean, XWikiContext context)\n        throws XWikiException\n    {\n        int documents = copySpaceBetweenWikis(null, sourceWiki, targetWiki, locale, clean, context);\n\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            om.notify(new WikiCopiedEvent(sourceWiki, targetWiki), sourceWiki, context);\n        }\n\n        return documents;\n    }\n\n    public String getEncoding()\n    {\n        return getConfiguration().getProperty(\"xwiki.encoding\", \"UTF-8\");\n    }\n\n    public URL getServerURL(String wikiId, XWikiContext xcontext) throws MalformedURLException\n    {\n        // In path based the base URL is the same for all wikis\n        if (!xcontext.isMainWiki(wikiId) && isPathBased()) {\n            return getServerURL(xcontext.getMainXWiki(), xcontext);\n        }\n\n        // If main wiki check the main wiki home page configuration\n        if (xcontext.isMainWiki(wikiId)) {\n            String homepage = getConfiguration().getProperty(\"xwiki.home\");\n            if (StringUtils.isNotEmpty(homepage)) {\n                try {\n                    return new URL(homepage);\n                } catch (MalformedURLException e) {\n                    LOGGER.warn(\"Invalid main wiki home page URL [{}] configured: {}\", homepage,\n                        ExceptionUtils.getRootCauseMessage(e));\n                }\n            }\n        }\n\n        if (wikiId != null) {\n            try {\n                WikiDescriptor wikiDescriptor = getWikiDescriptorManager().getById(wikiId);\n                if (wikiDescriptor != null) {\n                    String server = wikiDescriptor.getDefaultAlias();\n                    if (server != null) {\n                        String protocol = getWikiProtocol(wikiDescriptor);\n                        int port = getWikiPort(wikiDescriptor, xcontext);\n\n                        if (protocol == null && port == -1) {\n                            // If request is a \"real\" one keep using the same protocol/port (if asking for the same wiki)\n                            XWikiRequest request = xcontext.getRequest();\n                            if (request != null && wikiDescriptor.getId().equals(xcontext.getOriginalWikiId())\n                                && !isDaemon(request)) {\n                                URL sourceURL = HttpServletUtils.getSourceBaseURL(xcontext.getRequest());\n\n                                protocol = sourceURL.getProtocol();\n                                port = sourceURL.getPort();\n                            } else {\n                                // Default to HTTP\n                                protocol = \"http\";\n                            }\n                        }\n\n                        return new URL(protocol != null ? protocol : (port == 443 ? \"https\" : \"http\"), server, port,\n                            \"\");\n                    }\n                }\n            } catch (WikiManagerException e) {\n                LOGGER.error(\"Failed to get descriptor for wiki [{}]\", wikiId, e);\n            }\n        }\n\n        return null;\n    }\n\n    private boolean isDaemon(XWikiRequest request)\n    {\n        return request.getHttpServletRequest() instanceof XWikiServletRequestStub\n            && ((XWikiServletRequestStub) request.getHttpServletRequest()).isDaemon();\n    }\n\n    private String getWikiProtocol(WikiDescriptor wikiDescriptor)\n    {\n        // Try wiki descriptor\n        Boolean secure = wikiDescriptor.isSecure();\n        if (secure != null) {\n            return wikiDescriptor.isSecure() == Boolean.TRUE ? \"https\" : \"http\";\n        }\n\n        // Try configuration\n        String protocol = getConfiguration().getProperty(\"xwiki.url.protocol\");\n        if (protocol != null) {\n            return protocol;\n        }\n\n        // Try main wiki\n        try {\n            secure = getWikiDescriptorManager().getMainWikiDescriptor().isSecure();\n\n            if (secure != null) {\n                return secure ? \"https\" : \"http\";\n            }\n        } catch (WikiManagerException e) {\n            LOGGER.error(\"Failed to get main wiki descriptor\", e);\n        }\n\n        return null;\n    }\n\n    private int getWikiPort(WikiDescriptor wikiDescriptor, XWikiContext context)\n    {\n        // Try wiki descriptor\n        int port = wikiDescriptor.getPort();\n        if (port != -1) {\n            return port;\n        }\n\n        // Try main wiki\n        try {\n            port = getWikiDescriptorManager().getMainWikiDescriptor().getPort();\n\n            if (port != -1) {\n                return port;\n            }\n        } catch (WikiManagerException e) {\n            LOGGER.error(\"Failed to get main wiki descriptor\", e);\n        }\n\n        return -1;\n    }\n\n    public String getServletPath(String wikiName, XWikiContext context)\n    {\n        // unless we are in virtual wiki path mode we should return null\n        if (!context.isMainWiki(wikiName) && isPathBased()) {\n            try {\n                WikiDescriptor wikiDescriptor = getWikiDescriptorManager().getById(wikiName);\n                if (wikiDescriptor != null) {\n                    return \"wiki/\" + wikiDescriptor.getDefaultAlias() + \"/\";\n                }\n            } catch (Exception e) {\n                LOGGER.error(\"Failed to get URL for provided wiki [\" + wikiName + \"]\", e);\n            }\n        }\n\n        String servletPath = getConfiguration().getProperty(\"xwiki.servletpath\", \"\");\n\n        if (context.getRequest() != null) {\n            if (StringUtils.isEmpty(servletPath)) {\n                String currentServletpath = context.getRequest().getServletPath();\n                if (currentServletpath != null && currentServletpath.startsWith(\"/bin\")) {\n                    servletPath = \"bin/\";\n                } else {\n                    servletPath = getConfiguration().getProperty(\"xwiki.defaultservletpath\", \"bin/\");\n                }\n            }\n        }\n\n        return servletPath;\n    }\n\n    public String getWebAppPath(XWikiContext context)\n    {\n        String contextPath = getConfiguration().getProperty(\"xwiki.webapppath\");\n        if (contextPath == null) {\n            // Try getting the context path by asking the request for it (if a request exists!) and if it doesn't\n            // work try extracting it from the context URL.\n            // TODO: Instead of trying to extract from the URL, save the context path at webapp init (using a\n            // ServlettContextListener for example).\n            XWikiRequest request = context.getRequest();\n            if (request != null) {\n                contextPath = request.getContextPath();\n            }\n            if (contextPath == null) {\n                // Extract the context by getting the first path segment\n                contextPath = StringUtils.substringBefore(StringUtils.stripStart(context.getURL().getPath(), \"/\"), \"/\");\n            }\n        }\n\n        // Remove any leading or trailing slashes\n        contextPath = StringUtils.strip(contextPath, \"/\");\n\n        // TODO We're using URL parts in a wrong way, since contextPath and servletPath are returned with a leading /,\n        // while we need a trailing /. This code ensure we always have CONTEXTNAME + \"/\".\n        return contextPath + \"/\";\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference entityReference, String action, String queryString, String anchor,\n        XWikiContext context)\n    {\n        // TODO: replace this API with a clean implementation of EntityResourceReferenceSerializer\n\n        // Handle attachment URL\n        if (EntityType.ATTACHMENT.equals(entityReference.getType())) {\n            // Get the full attachment reference\n            AttachmentReference attachmentReference = getCurrentAttachmentResolver().resolve(entityReference);\n            return getAttachmentURL(attachmentReference, action, queryString, context);\n        }\n\n        // For all other types, we return the URL of the default corresponding document.\n        DocumentReference documentReference = getDocumentReference(entityReference, context);\n        return getURL(documentReference, action, queryString, anchor, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference reference, String action, XWikiContext context)\n    {\n        return getURL(reference, action, null, null, context);\n    }\n\n    /**\n     * @since 7.2RC1\n     */\n    public String getURL(EntityReference reference, XWikiContext context)\n    {\n        String action = \"view\";\n        if (reference.getType() == EntityType.ATTACHMENT) {\n            action = \"download\";\n        }\n        return getURL(reference, action, context);\n    }\n\n    /**\n     * @since 2.2.1\n     */\n    public String getURL(DocumentReference documentReference, String action, String queryString, String anchor,\n        XWikiContext context)\n    {\n        // We need to serialize the space reference because the old createURL() API doesn't accept a DocumentReference.\n        String spaces = getLocalStringEntityReferenceSerializer().serialize(documentReference.getLastSpaceReference());\n\n        // Take into account the specified document locale.\n        Locale documentLocale = documentReference.getLocale();\n        String actualQueryString = queryString;\n        if (documentLocale != null && documentLocale != Locale.ROOT) {\n            String localeQueryString = \"language=\" + documentLocale;\n            if (StringUtils.isEmpty(queryString)) {\n                actualQueryString = localeQueryString;\n            } else {\n                // Note: if the locale is already specified on the given query string then it won't be overwriten\n                // because the first parameter value is taken into account.\n                actualQueryString += '&' + localeQueryString;\n            }\n        }\n\n        URL url = context.getURLFactory().createURL(spaces, documentReference.getName(), action, actualQueryString,\n            anchor, documentReference.getWikiReference().getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    /**\n     * @deprecated since 2.2.1 use {@link #getURL(DocumentReference, String, String, String, XWikiContext)}\n     */\n    @Deprecated\n    public String getURL(String fullname, String action, String queryString, String anchor, XWikiContext context)\n    {\n        return getURL(getCurrentMixedDocumentReferenceResolver().resolve(fullname), action, queryString, anchor,\n            context);\n    }\n\n    public String getURL(String fullname, String action, String querystring, XWikiContext context)\n    {\n        return getURL(fullname, action, querystring, null, context);\n    }\n\n    /**\n     * @since 2.3M2\n     */\n    public String getURL(DocumentReference reference, String action, XWikiContext context)\n    {\n        return getURL(reference, action, null, null, context);\n    }\n\n    /**\n     * @deprecated since 2.3M2 use {@link #getURL(DocumentReference, String, XWikiContext)}\n     */\n    @Deprecated\n    public String getURL(String fullname, String action, XWikiContext context)\n    {\n        return getURL(fullname, action, null, null, context);\n    }\n\n    public String getExternalURL(String fullname, String action, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        URL url = context.getURLFactory().createExternalURL(doc.getSpace(), doc.getName(), action, null, null,\n            doc.getDatabase(), context);\n        return url.toString();\n    }\n\n    public String getExternalURL(String fullname, String action, String querystring, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        URL url = context.getURLFactory().createExternalURL(doc.getSpace(), doc.getName(), action, querystring, null,\n            doc.getDatabase(), context);\n        return url.toString();\n    }\n\n    /**\n     * Get the full URL of the given {@link DocumentReference}. This also includes the server name of the wiki.\n     *\n     * @param documentReference the document that should be resolved\n     * @param action the action of the URL\n     * @param querystring the URL parameters\n     * @param anchor the anchor of the document\n     * @param context the current XWikiContext\n     * @return the full URL of the given reference\n     * @since 9.6RC1\n     */\n    public String getExternalURL(DocumentReference documentReference, String action, String querystring, String anchor,\n        XWikiContext context)\n    {\n        URL url = context.getURLFactory().createExternalURL(\n            this.getLocalStringEntityReferenceSerializer().serialize(documentReference.getLastSpaceReference()),\n            documentReference.getName(), action, querystring, anchor, documentReference.getWikiReference().getName(),\n            context);\n        return url.toString();\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentURL(AttachmentReference attachmentReference, String action, String queryString,\n        XWikiContext context)\n    {\n        DocumentReference documentReference = attachmentReference.getDocumentReference();\n        SpaceReference spaceReference = documentReference.getLastSpaceReference();\n        WikiReference wikiReference = spaceReference.getWikiReference();\n\n        // We need to serialize the space reference because the old URLFactory has no method to create an Attachment URL\n        // from an AttachmentReference...\n        String serializedSpace = getLocalStringEntityReferenceSerializer().serialize(spaceReference);\n\n        URL url = context.getURLFactory().createAttachmentURL(attachmentReference.getName(), serializedSpace,\n            documentReference.getName(), action, queryString, wikiReference.getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentURL(AttachmentReference attachmentReference, String queryString, XWikiContext context)\n    {\n        return getAttachmentURL(attachmentReference, \"download\", queryString, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentRevisionURL(AttachmentReference attachmentReference, String revision, String queryString,\n        XWikiContext context)\n    {\n        DocumentReference documentReference = attachmentReference.getDocumentReference();\n        SpaceReference spaceReference = documentReference.getLastSpaceReference();\n        WikiReference wikiReference = spaceReference.getWikiReference();\n\n        // We need to serialize the space reference because the old URLFactory has no method to create an Attachment URL\n        // from an AttachmentReference...\n        String serializedSpace = getLocalStringEntityReferenceSerializer().serialize(spaceReference);\n\n        URL url = context.getURLFactory().createAttachmentRevisionURL(attachmentReference.getName(), serializedSpace,\n            documentReference.getName(), revision, queryString, wikiReference.getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public String getAttachmentURL(String fullname, String filename, XWikiContext context) throws XWikiException\n    {\n        return getAttachmentURL(fullname, filename, null, context);\n    }\n\n    /**\n     * @since 2.5RC1\n     */\n    public String getAttachmentURL(String fullname, String filename, String queryString, XWikiContext context)\n        throws XWikiException\n    {\n        AttachmentReference attachmentReference =\n            new AttachmentReference(filename, getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        return getAttachmentURL(attachmentReference, queryString, context);\n    }\n\n    // Usefull date functions\n\n    public int getTimeDelta(long time)\n    {\n        Date ctime = new Date();\n        return (int) (ctime.getTime() - time);\n    }\n\n    public boolean isMultiLingual(XWikiContext context)\n    {\n        return \"1\".equals(getXWikiPreference(\"multilingual\", \"0\", context));\n    }\n\n    public boolean isLDAP()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.ldap\"));\n    }\n\n    /**\n     * @return true if XWikiAllGroup group should be seen as virtual group containing all users, false to use it as any\n     *         other group\n     * @since 9.3RC1\n     */\n    public boolean isAllGroupImplicit()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.group.allgroupimplicit\"));\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link XWikiUser#isDisabled(XWikiContext)}.\n     */\n    @Deprecated\n    public int checkActive(XWikiContext context) throws XWikiException\n    {\n        return checkActive(context.getUser(), context);\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link XWikiUser#isDisabled(XWikiContext)}.\n     */\n    @Deprecated\n    public int checkActive(String user, XWikiContext context) throws XWikiException\n    {\n        XWikiUser xWikiUser = new XWikiUser(user);\n        return xWikiUser.isDisabled(context) ? 0 : 1;\n    }\n\n    /**\n     * @since 2.3M1\n     */\n    public DocumentReference getDocumentReference(XWikiRequest request, XWikiContext context)\n    {\n        DocumentReference reference;\n        if (context.getMode() == XWikiContext.MODE_PORTLET) {\n            if (request.getParameter(\"topic\") != null) {\n                reference = getCurrentMixedDocumentReferenceResolver().resolve(request.getParameter(\"topic\"));\n            } else {\n                // Point to this wiki's home page\n                reference = getDefaultDocumentReference().setWikiReference(new WikiReference(context.getWikiId()));\n            }\n        } else if (context.getMode() == XWikiContext.MODE_XMLRPC) {\n            reference = new DocumentReference(context.getWikiId(),\n                context.getDoc().getDocumentReference().getLastSpaceReference().getName(),\n                context.getDoc().getDocumentReference().getName());\n        } else {\n            ResourceReference resourceReference = getResourceReferenceManager().getResourceReference();\n            if (resourceReference instanceof EntityResourceReference) {\n                EntityResourceReference entityResource = (EntityResourceReference) resourceReference;\n                String action = entityResource.getAction().getActionName();\n                if ((request.getParameter(\"topic\") != null) && (action.equals(\"edit\") || action.equals(\"inline\"))) {\n                    reference = getCurrentMixedDocumentReferenceResolver().resolve(request.getParameter(\"topic\"));\n                } else {\n                    reference = new DocumentReference(\n                        entityResource.getEntityReference().extractReference(EntityType.DOCUMENT));\n                }\n            } else {\n                // TODO: Handle references not pointing to a document...\n                // Big problem we don't have an Entity URL!\n                throw new RuntimeException(\n                    String.format(\"Resource Reference [%s] isn't an Entity Resource Reference!\", resourceReference));\n            }\n        }\n\n        return reference;\n    }\n\n    /**\n     * Helper method, removes a predefined path segment (the context path or the servel path) from the start of the\n     * requested URI and returns the remainder. This method is needed because special characters in the path can be\n     * URL-encoded, depending on whether the request is forwarded through the request dispatcher or not, and also\n     * depending on the client (some browsers encode -, while some don't).\n     *\n     * @param path the path, as taken from the requested URI\n     * @param segment the segment to remove, as reported by the container\n     * @return the path with the specified segment trimmed from its start\n     */\n    public static String stripSegmentFromPath(String path, String segment)\n    {\n        if (!path.startsWith(segment)) {\n            // The context path probably contains special characters that are encoded in the URL\n            try {\n                segment = URIUtil.encodePath(segment);\n            } catch (URIException e) {\n                LOGGER.warn(\"Invalid path: [\" + segment + \"]\");\n            }\n        }\n        if (!path.startsWith(segment)) {\n            // Some clients also encode -, although it's allowed in the path\n            segment = segment.replaceAll(\"-\", \"%2D\");\n        }\n        if (!path.startsWith(segment)) {\n            // Can't find the context path in the URL (shouldn't happen), just skip to the next path segment\n            return path.substring(path.indexOf('/', 1));\n        }\n        return path.substring(segment.length());\n    }\n\n    public boolean prepareDocuments(XWikiRequest request, XWikiContext context, VelocityContext vcontext)\n        throws XWikiException\n    {\n        XWikiDocument doc;\n        context.getWiki().prepareResources(context);\n        DocumentReference reference = getDocumentReference(request, context);\n        if (context.getAction().equals(\"register\")) {\n            setPhonyDocument(reference, context, vcontext);\n            doc = context.getDoc();\n        } else {\n            try {\n                doc = getDocument(reference, context);\n            } catch (XWikiException e) {\n                doc = context.getDoc();\n                if (context.getAction().equals(\"delete\")) {\n                    if (doc == null) {\n                        setPhonyDocument(reference, context, vcontext);\n                        doc = context.getDoc();\n                    }\n                    if (!checkAccess(\"admin\", doc, context)) {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // the user is set after the access is checked.\n        boolean hasAccess = checkAccess(context.getAction(), doc, context);\n\n        XWikiUser user;\n        if (context.getUserReference() != null) {\n            user = new XWikiUser(context.getUserReference());\n        } else {\n            user = new XWikiUser(context.getUser());\n        }\n\n        // We need to check rights before we look for translations\n        // Otherwise we don't have the user language\n        if (!hasAccess) {\n            Object[] args = { doc.getFullName(), user.getUser() };\n            setPhonyDocument(reference, context, vcontext);\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access to document {0} has been denied to user {1}\", null, args);\n        // User is disabled: the mail address is marked as checked\n        } else if (user.isDisabled(context) && user.isEmailChecked(context)) {\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if (!((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\"))))) {\n                Object[] args = { user.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_DISABLED,\n                    \"User {0} account is disabled\", null, args);\n            }\n        // User actually needs to activate his mail address.\n        } else if (user.isDisabled(context) && !user.isEmailChecked(context)) {\n            boolean allow = false;\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if ((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\")))) {\n                allow = true;\n            } else {\n                String allowed = getConfiguration().getProperty(\"xwiki.inactiveuser.allowedpages\", \"\");\n                if (context.getAction().equals(\"view\") && !allowed.equals(\"\")) {\n                    String[] allowedList = StringUtils.split(allowed, \" ,\");\n                    for (String element : allowedList) {\n                        if (element.equals(doc.getFullName())) {\n                            allow = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!allow) {\n                Object[] args = { context.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_INACTIVE,\n                    \"User {0} account is inactive\", null, args);\n            }\n        }\n\n        context.put(\"doc\", doc);\n        context.put(\"cdoc\", doc);\n        vcontext.put(\"doc\", doc.newDocument(context));\n        vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n        XWikiDocument tdoc;\n\n        // If the parameter language exists and is empty, it means we want to force loading the regular document\n        // not a translation. This should be handled later by doing a better separation between locale used in the UI\n        // and for loading the documents.\n        if (\"\".equals(context.getRequest().getParameter(\"language\"))) {\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(context);\n        }\n\n        try {\n            String rev = (String) context.get(\"rev\");\n            if (StringUtils.isNotEmpty(rev)) {\n                tdoc = getDocument(tdoc, rev, context);\n            }\n        } catch (Exception ex) {\n            // Invalid version, just use the most recent one\n        }\n        context.put(\"tdoc\", tdoc);\n        vcontext.put(\"tdoc\", tdoc.newDocument(context));\n\n        return true;\n    }\n\n    /**\n     * @since 8.3M1\n     */\n    public void setPhonyDocument(DocumentReference reference, XWikiContext context)\n    {\n        XWikiDocument doc = new XWikiDocument(reference);\n        doc.setElements(XWikiDocument.HAS_ATTACHMENTS | XWikiDocument.HAS_OBJECTS);\n        doc.setStore(getStore());\n        context.put(\"doc\", doc);\n    }\n\n    /**\n     * @since 2.3M1\n     * @deprecated since 8.3M1, use {@link #setPhonyDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public void setPhonyDocument(DocumentReference reference, XWikiContext context, VelocityContext vcontext)\n    {\n        setPhonyDocument(reference, context);\n\n        vcontext.put(\"doc\", context.getDoc().newDocument(context));\n        vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n        vcontext.put(\"tdoc\", vcontext.get(\"doc\"));\n    }\n\n    /**\n     * @deprecated since 2.3M1 use {@link #setPhonyDocument(DocumentReference, XWikiContext, VelocityContext)}\n     */\n    @Deprecated\n    public void setPhonyDocument(String docName, XWikiContext context, VelocityContext vcontext)\n    {\n        setPhonyDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName), context, vcontext);\n    }\n\n    public XWikiEngineContext getEngineContext()\n    {\n        return this.engine_context;\n    }\n\n    public void setEngineContext(XWikiEngineContext engine_context)\n    {\n        this.engine_context = engine_context;\n    }\n\n    public void setAuthService(XWikiAuthService authService)\n    {\n        this.authService = authService;\n    }\n\n    public void setRightService(XWikiRightService rightService)\n    {\n        this.rightService = rightService;\n    }\n\n    public XWikiGroupService getGroupService(XWikiContext context) throws XWikiException\n    {\n        synchronized (this.GROUP_SERVICE_LOCK) {\n            if (this.groupService == null) {\n                String groupClass = getConfiguration().getProperty(\"xwiki.authentication.groupclass\",\n                    \"com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl\");\n\n                try {\n                    this.groupService = (XWikiGroupService) Class.forName(groupClass).newInstance();\n                } catch (Exception e) {\n                    LOGGER.error(\"Failed to instantiate custom group service class: \" + e.getMessage(), e);\n                    this.groupService = new XWikiGroupServiceImpl();\n                }\n                this.groupService.init(this, context);\n            }\n\n            return this.groupService;\n        }\n    }\n\n    public void setGroupService(XWikiGroupService groupService)\n    {\n        this.groupService = groupService;\n    }\n\n    private Class<? extends XWikiAuthService> getAuthServiceClass() throws ClassNotFoundException\n    {\n        String authClass = getConfiguration().getProperty(\"xwiki.authentication.authclass\");\n        if (StringUtils.isEmpty(authClass)) {\n            if (isLDAP()) {\n                authClass = \"com.xpn.xwiki.user.impl.LDAP.XWikiLDAPAuthServiceImpl\";\n            } else {\n                authClass = \"com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl\";\n            }\n        }\n\n        // Get main wiki ClassLoader\n        ClassLoaderManager clManager = Utils.getComponent(ClassLoaderManager.class);\n        ClassLoader classloader = null;\n        if (clManager != null) {\n            classloader = clManager.getURLClassLoader(\"wiki:xwiki\", false);\n        }\n\n        // Get the class\n        if (classloader != null) {\n            return (Class<? extends XWikiAuthService>) Class.forName(authClass, true, classloader);\n        } else {\n            return (Class<? extends XWikiAuthService>) Class.forName(authClass);\n        }\n    }\n\n    public XWikiAuthService getAuthService()\n    {\n        synchronized (this.AUTH_SERVICE_LOCK) {\n            if (this.authService == null) {\n                LOGGER.info(\"Initializing AuthService...\");\n\n                try {\n                    Class<? extends XWikiAuthService> authClass = getAuthServiceClass();\n\n                    setAuthService(authClass);\n                } catch (Exception e) {\n                    LOGGER.warn(\"Failed to get the configured AuthService class, fallbacking on standard authenticator\",\n                        e);\n\n                    this.authService = new XWikiAuthServiceImpl();\n\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Initialized AuthService {} using 'new'.\", this.authService.getClass().getName());\n                    }\n                }\n            }\n\n            return this.authService;\n        }\n    }\n\n    private void setAuthService(Class<? extends XWikiAuthService> authClass)\n    {\n        try {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Using AuthClass {}\", authClass.getName());\n            }\n\n            this.authService = authClass.newInstance();\n\n            LOGGER.debug(\"Initialized AuthService using Reflection.\");\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to initialize the AuthService from class [{}], fallbacking on standard authenticator\",\n                authClass.getName(), e);\n\n            this.authService = new XWikiAuthServiceImpl();\n\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Initialized AuthService {} using 'new'.\", this.authService.getClass().getName());\n            }\n        }\n    }\n\n    private static final String DEFAULT_RIGHT_SERVICE_CLASS =\n        \"org.xwiki.security.authorization.internal.XWikiCachingRightService\";\n\n    public XWikiRightService getRightService()\n    {\n        synchronized (this.RIGHT_SERVICE_LOCK) {\n            if (this.rightService == null) {\n                LOGGER.info(\"Initializing RightService...\");\n\n                String rightsClass = getConfiguration().getProperty(\"xwiki.authentication.rightsclass\");\n                if (rightsClass != null && !rightsClass.equals(DEFAULT_RIGHT_SERVICE_CLASS)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.warn(\"Using custom Right Service [{}].\", rightsClass);\n                    }\n                } else {\n                    rightsClass = DEFAULT_RIGHT_SERVICE_CLASS;\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Using default Right Service [{}].\", rightsClass);\n                    }\n                }\n\n                try {\n                    this.rightService = (XWikiRightService) Class.forName(rightsClass).newInstance();\n                    LOGGER.debug(\"Initialized RightService using Reflection.\");\n                } catch (Exception e) {\n                    Exception lastException = e;\n\n                    if (!rightsClass.equals(DEFAULT_RIGHT_SERVICE_CLASS)) {\n                        LOGGER.warn(String.format(\n                            \"Failed to initialize custom RightService [%s]\"\n                                + \" by Reflection, using default implementation [%s].\",\n                            rightsClass, DEFAULT_RIGHT_SERVICE_CLASS), e);\n                        rightsClass = DEFAULT_RIGHT_SERVICE_CLASS;\n                        try {\n                            this.rightService = (XWikiRightService) Class.forName(rightsClass).newInstance();\n                            LOGGER.debug(\"Initialized default RightService using Reflection.\");\n                        } catch (Exception e1) {\n                            lastException = e1;\n                        }\n                    }\n\n                    if (this.rightService == null) {\n                        LOGGER.warn(String.format(\n                            \"Failed to initialize RightService [%s]\"\n                                + \" by Reflection, using OLD implementation [%s] with 'new'.\",\n                            rightsClass, XWikiRightServiceImpl.class.getCanonicalName()), lastException);\n\n                        this.rightService = new XWikiRightServiceImpl();\n\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"Initialized old RightService implementation \"\n                                + this.rightService.getClass().getName() + \" using 'new'.\");\n                        }\n                    }\n                }\n            }\n            return this.rightService;\n        }\n    }\n\n    public XWikiStatsService getStatsService(XWikiContext context)\n    {\n        synchronized (this.STATS_SERVICE_LOCK) {\n            if (this.statsService == null) {\n                if (\"1\".equals(getConfiguration().getProperty(\"xwiki.stats\", \"1\"))) {\n                    String storeClass = getConfiguration().getProperty(\"xwiki.stats.class\",\n                        \"com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl\");\n                    try {\n                        this.statsService = (XWikiStatsService) Class.forName(storeClass).newInstance();\n                    } catch (Exception e) {\n                        LOGGER.error(e.getMessage(), e);\n\n                        this.statsService = new XWikiStatsServiceImpl();\n                    }\n\n                    this.statsService.init(context);\n                }\n            }\n\n            return this.statsService;\n        }\n    }\n\n    public XWikiURLFactoryService getURLFactoryService()\n    {\n        if (this.urlFactoryService == null) {\n            synchronized (this.URLFACTORY_SERVICE_LOCK) {\n                if (this.urlFactoryService == null) {\n                    LOGGER.info(\"Initializing URLFactory Service...\");\n\n                    XWikiURLFactoryService factoryService = null;\n\n                    String urlFactoryServiceClass = getConfiguration().getProperty(\"xwiki.urlfactory.serviceclass\");\n                    if (urlFactoryServiceClass != null) {\n                        try {\n                            if (LOGGER.isDebugEnabled()) {\n                                LOGGER.debug(\"Using custom URLFactory Service Class [\" + urlFactoryServiceClass + \"]\");\n                            }\n                            factoryService = (XWikiURLFactoryService) Class.forName(urlFactoryServiceClass)\n                                .getConstructor(new Class<?>[] { XWiki.class }).newInstance(new Object[] { this });\n                        } catch (Exception e) {\n                            factoryService = null;\n                            LOGGER.warn(\"Failed to initialize URLFactory Service [\" + urlFactoryServiceClass + \"]\", e);\n                        }\n                    }\n                    if (factoryService == null) {\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"Using default URLFactory Service Class [\" + urlFactoryServiceClass + \"]\");\n                        }\n                        factoryService = new XWikiURLFactoryServiceImpl(this);\n                    }\n\n                    // Set the urlFactoryService object in one assignment to prevent threading\n                    // issues when checking for\n                    // null above.\n                    this.urlFactoryService = factoryService;\n                }\n            }\n        }\n\n        return this.urlFactoryService;\n    }\n\n    public XWikiCriteriaService getCriteriaService(XWikiContext context)\n    {\n        return this.criteriaService;\n    }\n\n    public ZipOutputStream getZipOutputStream(XWikiContext context) throws IOException\n    {\n        return new ZipOutputStream(context.getResponse().getOutputStream());\n    }\n\n    private Map<String, SearchEngineRule> getSearchEngineRules(XWikiContext context)\n    {\n        // We currently hardcode the rules\n        // We will put them in the preferences soon\n        Map<String, SearchEngineRule> map = new HashMap<String, SearchEngineRule>();\n        map.put(\"Google\", new SearchEngineRule(\"google.\", \"s/(^|.*&)q=(.*?)(&.*|$)/$2/\"));\n        map.put(\"MSN\", new SearchEngineRule(\"search.msn.\", \"s/(^|.*&)q=(.*?)(&.*|$)/$2/\"));\n        map.put(\"Yahoo\", new SearchEngineRule(\"search.yahoo.\", \"s/(^|.*&)p=(.*?)(&.*|$)/$2/\"));\n        map.put(\"Voila\", new SearchEngineRule(\"voila.fr\", \"s/(^|.*&)kw=(.*?)(&.*|$)/$2/\"));\n\n        return map;\n    }\n\n    public String getRefererText(String referer, XWikiContext context)\n    {\n        try {\n            URL url = new URL(referer);\n            Map<String, SearchEngineRule> searchengines = getSearchEngineRules(context);\n            if (searchengines != null) {\n                for (SearchEngineRule senginerule : searchengines.values()) {\n                    String host = url.getHost();\n                    int i1 = host.indexOf(senginerule.getHost());\n                    if (i1 != -1) {\n                        String query = context.getUtil().substitute(senginerule.getRegEx(), url.getQuery());\n                        if ((query != null) && (!query.equals(\"\"))) {\n                            // We return the query text instead of the full referer\n                            return host.substring(i1) + \":\" + query;\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        String result = referer.substring(referer.indexOf(\"://\") + 3);\n        if (result.endsWith(\"/\")) {\n            return result.substring(0, result.length() - 1);\n        } else {\n            return result;\n        }\n    }\n\n    public boolean isMySQL()\n    {\n        if (getHibernateStore() == null) {\n            return false;\n        }\n\n        Object dialect = getHibernateStore().getConfiguration().getProperties().get(\"dialect\");\n        return \"org.hibernate.dialect.MySQLDialect\".equals(dialect)\n            || \"net.sf.hibernate.dialect.MySQLDialect\".equals(dialect);\n    }\n\n    public String getFullNameSQL()\n    {\n        return getFullNameSQL(true);\n    }\n\n    public String getFullNameSQL(boolean newFullName)\n    {\n        if (newFullName) {\n            return \"doc.fullName\";\n        }\n\n        if (this.fullNameSQL == null) {\n            if (isMySQL()) {\n                this.fullNameSQL = \"CONCAT(doc.space,'.',doc.name)\";\n            } else {\n                this.fullNameSQL = \"doc.space||'.'||doc.name\";\n            }\n        }\n\n        return this.fullNameSQL;\n    }\n\n    public String getUserName(String user, XWikiContext context)\n    {\n        return getUserName(user, null, true, context);\n    }\n\n    public String getUserName(String user, String format, XWikiContext context)\n    {\n        return getUserName(user, format, true, context);\n    }\n\n    /**\n     * @return a formatted and pretty printed user name for displaying\n     */\n    public String getUserName(String user, String format, boolean link, XWikiContext context)\n    {\n        if (StringUtils.isBlank(user)) {\n            return localizePlainOrKey(\"core.users.unknownUser\");\n        }\n\n        DocumentReference userReference = getCurrentMixedDocumentReferenceResolver().resolve(user);\n\n        return getUserName(userReference, format, link, true, context);\n    }\n\n    /**\n     * Generate a display user name and return it.\n     *\n     * @param userReference\n     * @param format a Velocity scnippet used to format the user name\n     * @param link true if a full html link snippet should be returned\n     * @param escapeXML true if the returned name should be escaped (forced true if {@code link} is true)\n     * @param context see {@link XWikiContext}\n     * @return the display user name or a html snippet with the link to the passed user\n     * @since 6.4RC1\n     */\n    public String getUserName(DocumentReference userReference, String format, boolean link, boolean escapeXML,\n        XWikiContext context)\n    {\n        if (userReference == null) {\n            return localizePlainOrKey(\"core.users.unknownUser\");\n        }\n\n        XWikiDocument userdoc = null;\n        try {\n            userdoc = getDocument(userReference, context);\n            if (userdoc == null) {\n                return escapeXML ? XMLUtils.escape(userReference.getName()) : userReference.getName();\n            }\n\n            BaseObject userobj = userdoc.getObject(\"XWiki.XWikiUsers\");\n            if (userobj == null) {\n                return escapeXML ? XMLUtils.escape(userdoc.getDocumentReference().getName())\n                    : userdoc.getDocumentReference().getName();\n            }\n\n            String text;\n\n            if (format == null) {\n                text = userobj.getStringValue(\"first_name\");\n                String lastName = userobj.getStringValue(\"last_name\");\n                if (!text.isEmpty() && !lastName.isEmpty()) {\n                    text += ' ';\n                }\n                text += userobj.getStringValue(\"last_name\");\n                if (StringUtils.isBlank(text)) {\n                    text = userdoc.getDocumentReference().getName();\n                }\n            } else {\n                VelocityContext vcontext;\n                try {\n                    vcontext = getVelocityContextFactory().createContext();\n                } catch (XWikiVelocityException e) {\n                    LOGGER.error(\"Failed to create standard VelocityContext\", e);\n\n                    vcontext = new XWikiVelocityContext();\n                }\n\n                for (String propname : userobj.getPropertyList()) {\n                    vcontext.put(propname, userobj.getStringValue(propname));\n                }\n                text = evaluateVelocity(format,\n                    \"<username formatting code in \" + context.getDoc().getDocumentReference() + \">\", vcontext);\n            }\n\n            if (escapeXML || link) {\n                text = XMLUtils.escape(text.trim());\n            }\n\n            if (link) {\n                text = \"<span class=\\\"wikilink\\\"><a href=\\\"\" + userdoc.getURL(\"view\", context) + \"\\\">\" + text\n                    + \"</a></span>\";\n            }\n            return text;\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to display the user name of [{}]. Root cause is [{}]. Falling back on the user id.\",\n                userReference, ExceptionUtils.getRootCauseMessage(e));\n\n            return escapeXML ? XMLUtils.escape(userReference.getName()) : userReference.getName();\n        }\n    }\n\n    /**\n     * @param content the Velocity content to evaluate\n     * @param namespace the namespace under which to evaluate it (used for isolation)\n     * @param vcontext the Velocity context to use when evaluating. If {@code null}, then a new context will be created,\n     *            initialized and used.\n     * @return the evaluated content\n     * @since 7.2M1\n     */\n    public String evaluateVelocity(String content, String namespace, VelocityContext vcontext)\n    {\n        try {\n            return getVelocityEvaluator().evaluateVelocity(content, namespace, vcontext);\n        } catch (XWikiException xe) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}] with content:\\n[{}]\", namespace, content,\n                xe.getCause());\n            return Util.getHTMLExceptionMessage(xe, null);\n        }\n    }\n\n    /**\n     * @param content the Velocity content to evaluate\n     * @param name the namespace under which to evaluate it (used for isolation)\n     * @return the evaluated content\n     * @since 7.2M1\n     */\n    public String evaluateVelocity(String content, String name)\n    {\n        try {\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            VelocityContext velocityContext = velocityManager.getVelocityContext();\n            return evaluateVelocity(content, name, velocityContext);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}] with content:\\n[{}]\", name, content, e);\n            Object[] args = { name };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while parsing velocity page {0}\", e,\n                args);\n            return Util.getHTMLExceptionMessage(xe, null);\n        }\n    }\n\n    /**\n     * Generate and return an unescaped user display name.\n     *\n     * @param userReference the user reference\n     * @param context see {@link XWikiContext}\n     * @return the unescaped display user name\n     * @since 6.4RC1\n     */\n    public String getPlainUserName(DocumentReference userReference, XWikiContext context)\n    {\n        return getUserName(userReference, null, false, false, context);\n    }\n\n    public boolean hasCentralizedAuthentication(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"authentication_centralized\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.centralized\", \"0\"));\n    }\n\n    public String getLocalUserName(String user, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, null, true, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), null, true, context);\n        }\n    }\n\n    public String getLocalUserName(String user, String format, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, format, true, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), format, true, context);\n        }\n    }\n\n    public String getLocalUserName(String user, String format, boolean link, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, format, link, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), format, link, context);\n        }\n    }\n\n    public String formatDate(Date date, String format, XWikiContext context)\n    {\n        if (date == null) {\n            return \"\";\n        }\n        String xformat = format;\n        String defaultFormat = \"yyyy/MM/dd HH:mm\";\n\n        if (format == null) {\n            xformat = getXWikiPreference(\"dateformat\", defaultFormat, context);\n        }\n\n        try {\n            DateFormatSymbols formatSymbols = null;\n            try {\n                String language = getLanguagePreference(context);\n                formatSymbols = new DateFormatSymbols(new Locale(language));\n            } catch (Exception e2) {\n                String language = getXWikiPreference(\"default_language\", context);\n                if ((language != null) && (!language.equals(\"\"))) {\n                    formatSymbols = new DateFormatSymbols(new Locale(language));\n                }\n            }\n\n            SimpleDateFormat sdf;\n            if (formatSymbols != null) {\n                sdf = new SimpleDateFormat(xformat, formatSymbols);\n            } else {\n                sdf = new SimpleDateFormat(xformat);\n            }\n\n            try {\n                sdf.setTimeZone(TimeZone.getTimeZone(getUserTimeZone(context)));\n            } catch (Exception e) {\n            }\n\n            return sdf.format(date);\n        } catch (Exception e) {\n            LOGGER.info(\"Failed to format date [\" + date + \"] with pattern [\" + xformat + \"]: \" + e.getMessage());\n            if (format == null) {\n                if (xformat.equals(defaultFormat)) {\n                    return date.toString();\n                } else {\n                    return formatDate(date, defaultFormat, context);\n                }\n            } else {\n                return formatDate(date, null, context);\n            }\n        }\n    }\n\n    /*\n     * Allow to read user setting providing the user timezone All dates will be expressed with this timezone\n     */\n    public String getUserTimeZone(XWikiContext context)\n    {\n        String tz = getUserPreference(\"timezone\", context);\n        // We perform this verification ourselves since TimeZone#getTimeZone(String) with an invalid parameter returns\n        // GMT and not the system default.\n        if (!ArrayUtils.contains(TimeZone.getAvailableIDs(), tz)) {\n            String defaultTz = TimeZone.getDefault().getID();\n            return getConfiguration().getProperty(\"xwiki.timezone\", defaultTz);\n        } else {\n            return tz;\n        }\n    }\n\n    /**\n     * @deprecated since 2.2.1 use {@link #exists(DocumentReference, XWikiContext)}\n     */\n    @Deprecated\n    public boolean exists(String fullname, XWikiContext context)\n    {\n        return exists(getCurrentMixedDocumentReferenceResolver().resolve(fullname), context);\n    }\n\n    public boolean exists(DocumentReference documentReference, XWikiContext context)\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            XWikiDocument doc = new XWikiDocument(documentReference, documentReference.getLocale());\n\n            context.setWikiId(documentReference.getWikiReference().getName());\n\n            return getStore().exists(doc, context);\n        } catch (XWikiException e) {\n            return false;\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Returns whether a page exists or not.\n     * \n     * @param reference the reference of the page to check for its existence\n     * @return true if the page exists, false if not\n     * @since 13.3RC1\n     * @since 12.10.7\n     */\n    @Unstable\n    public boolean exists(PageReference reference, XWikiContext context)\n    {\n        // Try as space\n        DocumentReference documentReference = getCurrentReferenceDocumentReferenceResolver().resolve(reference);\n        if (exists(documentReference, context)) {\n            return true;\n        }\n\n        // Try as document\n        if (documentReference.getParent().getParent().getType() == EntityType.SPACE) {\n            return exists(new DocumentReference(documentReference.getParent().getName(),\n                documentReference.getParent().getParent(), documentReference.getParameters()), context);\n        }\n\n        return false;\n    }\n\n    public String getAdType(XWikiContext context)\n    {\n        String adtype = \"\";\n        XWikiDocument wikiServer = context.getWikiServer();\n        if (wikiServer != null) {\n            adtype = wikiServer.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"adtype\");\n        }\n\n        if (adtype.equals(\"\")) {\n            adtype = getConfiguration().getProperty(\"xwiki.ad.type\", \"\");\n        }\n\n        return adtype;\n    }\n\n    public String getAdClientId(XWikiContext context)\n    {\n        final String defaultadclientid = \"pub-2778691407285481\";\n        String adclientid = \"\";\n        XWikiDocument wikiServer = context.getWikiServer();\n        if (wikiServer != null) {\n            adclientid = wikiServer.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"adclientid\");\n        }\n\n        if (adclientid.equals(\"\")) {\n            adclientid = getConfiguration().getProperty(\"xwiki.ad.clientid\", \"\");\n        }\n\n        if (adclientid.equals(\"\")) {\n            adclientid = defaultadclientid;\n        }\n\n        return adclientid;\n    }\n\n    /**\n     * @deprecated\n     */\n    @Deprecated\n    public XWikiPluginInterface getPlugin(String name, XWikiContext context)\n    {\n        XWikiPluginManager plugins = getPluginManager();\n        Vector<String> pluginlist = plugins.getPlugins();\n        for (String pluginname : pluginlist) {\n            if (pluginname.equals(name)) {\n                return plugins.getPlugin(pluginname);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @deprecated\n     */\n    @Deprecated\n    public Api getPluginApi(String name, XWikiContext context)\n    {\n        XWikiPluginInterface plugin = getPlugin(name, context);\n        if (plugin != null) {\n            return plugin.getPluginApi(plugin, context);\n        }\n\n        return null;\n    }\n\n    public int getHttpTimeout(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.http.timeout\", 60000);\n    }\n\n    public String getHttpUserAgent(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.http.useragent\", \"XWikiBot/1.0\");\n    }\n\n    public String getURLContent(String surl, XWikiContext context) throws IOException\n    {\n        return getURLContent(surl, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public String getURLContent(String surl, int timeout, String userAgent) throws IOException\n    {\n        String content;\n        HttpClient client = getHttpClient(timeout, userAgent);\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            client.executeMethod(get);\n            content = get.getResponseBodyAsString();\n        } finally {\n            // Release any connection resources used by the method\n            get.releaseConnection();\n        }\n\n        return content;\n    }\n\n    public String getURLContent(String surl, String username, String password, XWikiContext context) throws IOException\n    {\n        return getURLContent(surl, username, password, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public String getURLContent(String surl, String username, String password, int timeout, String userAgent)\n        throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // pass our credentials to HttpClient, they will only be used for\n        // authenticating to servers with realm \"realm\", to authenticate agains\n        // an arbitrary realm change this to null.\n        client.getState().setCredentials(new AuthScope(null, -1, null),\n            new UsernamePasswordCredentials(username, password));\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // Tell the GET method to automatically handle authentication. The\n            // method will use any appropriate credentials to handle basic\n            // authentication requests. Setting this value to false will cause\n            // any request for authentication to return with a status of 401.\n            // It will then be up to the client to handle the authentication.\n            get.setDoAuthentication(true);\n\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBodyAsString();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    public byte[] getURLContentAsBytes(String surl, XWikiContext context) throws IOException\n    {\n        return getURLContentAsBytes(surl, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public byte[] getURLContentAsBytes(String surl, int timeout, String userAgent) throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBody();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    public byte[] getURLContentAsBytes(String surl, String username, String password, XWikiContext context)\n        throws IOException\n    {\n        return getURLContentAsBytes(surl, username, password, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public byte[] getURLContentAsBytes(String surl, String username, String password, int timeout, String userAgent)\n        throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // pass our credentials to HttpClient, they will only be used for\n        // authenticating to servers with realm \"realm\", to authenticate agains\n        // an arbitrary realm change this to null.\n        client.getState().setCredentials(new AuthScope(null, -1, null),\n            new UsernamePasswordCredentials(username, password));\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // Tell the GET method to automatically handle authentication. The\n            // method will use any appropriate credentials to handle basic\n            // authentication requests. Setting this value to false will cause\n            // any request for authentication to return with a status of 401.\n            // It will then be up to the client to handle the authentication.\n            get.setDoAuthentication(true);\n\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBody();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    /**\n     * API to list all spaces in the current wiki.\n     * <p>\n     * Hidden spaces are filtered unless current user enabled them.\n     *\n     * @return a list of string representing all non-hidden spaces (ie spaces that have non-hidden pages) for the\n     *         current wiki\n     * @throws XWikiException if something went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaces(XWikiContext context) throws XWikiException\n    {\n        try {\n            return getStore().getQueryManager().getNamedQuery(\"getSpaces\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\")).execute();\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    /**\n     * API to list all non-hidden documents in a space.\n     *\n     * @param spaceReference the local reference of the space for which to return all non-hidden documents\n     * @return the list of document names (in the format {@code Space.Page}) for non-hidden documents in the specified\n     *         space\n     * @throws XWikiException if the loading went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaceDocsName(String spaceReference, XWikiContext context) throws XWikiException\n    {\n        try {\n            return getStore().getQueryManager().getNamedQuery(\"getSpaceDocsName\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\"))\n                .bindValue(\"space\", spaceReference).execute();\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    public List<String> getIncludedMacros(String defaultSpace, String content, XWikiContext context)\n    {\n        List<String> list;\n\n        try {\n            String pattern = \"#includeMacros[ ]*\\\\([ ]*([\\\"'])(.*?)\\\\1[ ]*\\\\)\";\n            list = context.getUtil().getUniqueMatches(content, pattern, 2);\n            for (int i = 0; i < list.size(); i++) {\n                String name = list.get(i);\n                if (name.indexOf('.') == -1) {\n                    list.set(i, defaultSpace + \".\" + name);\n                }\n            }\n        } catch (Exception e) {\n            // This should never happen\n            LOGGER.error(\"Failed to extract #includeMacros targets from provided content [\" + content + \"]\", e);\n\n            list = Collections.emptyList();\n        }\n\n        return list;\n    }\n\n    /**\n     * accessor for the isReadOnly instance var.\n     *\n     * @see #isReadOnly\n     */\n    public boolean isReadOnly()\n    {\n        return this.isReadOnly;\n    }\n\n    public void setReadOnly(boolean readOnly)\n    {\n        this.isReadOnly = readOnly;\n    }\n\n    public void deleteAllDocuments(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        deleteAllDocuments(doc, true, context);\n    }\n\n    public void deleteAllDocuments(XWikiDocument doc, boolean toTrash, XWikiContext context) throws XWikiException\n    {\n        // Wrap the work as a batch operation.\n        BatchOperationExecutor batchOperationExecutor = Utils.getComponent(BatchOperationExecutor.class);\n        batchOperationExecutor.execute(() -> {\n            // Delete all translation documents\n            for (Locale locale : doc.getTranslationLocales(context)) {\n                XWikiDocument tdoc = doc.getTranslatedDocument(locale, context);\n                deleteDocument(tdoc, toTrash, context);\n            }\n\n            // Delete the default document\n            deleteDocument(doc, toTrash, context);\n        });\n    }\n\n    public void refreshLinks(XWikiContext context) throws XWikiException\n    {\n        try {\n            // refreshes all Links of each doc of the wiki\n            @SuppressWarnings(\"deprecation\")\n            List<String> docs = getStore().getQueryManager().getNamedQuery(\"getAllDocuments\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\")).execute();\n            for (int i = 0; i < docs.size(); i++) {\n                XWikiDocument myDoc = this.getDocument(docs.get(i), context);\n                myDoc.getStore().saveLinks(myDoc, context, true);\n            }\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    public boolean hasBacklinks(XWikiContext context)\n    {\n        if (this.hasBacklinks == null) {\n            this.hasBacklinks = \"1\".equals(getXWikiPreference(\"backlinks\", \"xwiki.backlinks\", \"0\", context));\n        }\n        return this.hasBacklinks;\n    }\n\n    public boolean hasTags(XWikiContext context)\n    {\n        return \"1\".equals(getXWikiPreference(\"tags\", \"xwiki.tags\", \"0\", context));\n    }\n\n    public boolean hasCustomMappings()\n    {\n        return getHibernateConfiguration().hasCustomMappings();\n    }\n\n    public boolean hasDynamicCustomMappings()\n    {\n        return getHibernateConfiguration().hasDynamicCustomMappings();\n    }\n\n    public String getDefaultSpace(XWikiContext context)\n    {\n        String defaultSpace = getXWikiPreference(\"defaultweb\", \"\", context);\n        if (StringUtils.isEmpty(defaultSpace)) {\n            return getConfiguration().getProperty(\"xwiki.defaultweb\", DEFAULT_HOME_SPACE);\n        }\n        return defaultSpace;\n    }\n\n    public boolean showViewAction(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"showviewaction\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        } else if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.showviewaction\", \"1\"));\n    }\n\n    public boolean useDefaultAction(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"usedefaultaction\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.usedefaultaction\", \"0\"));\n    }\n\n    public String getDefaultPage(XWikiContext context)\n    {\n        String defaultPage = getXWikiPreference(\"defaultpage\", \"\", context);\n        if (StringUtils.isEmpty(defaultPage)) {\n            return getConfiguration().getProperty(\"xwiki.defaultpage\", DEFAULT_SPACE_HOMEPAGE);\n        }\n        return defaultPage;\n    }\n\n    public boolean hasEditComment(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment\", \"0\"));\n    }\n\n    public boolean isEditCommentFieldHidden(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_hidden\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.hidden\", \"0\"));\n    }\n\n    public boolean isEditCommentSuggested(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_suggested\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.suggested\", \"0\"));\n    }\n\n    public boolean isEditCommentMandatory(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_mandatory\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.mandatory\", \"0\"));\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#hasMinorEdit()\n     */\n    public boolean hasMinorEdit(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"minoredit\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.minoredit\", \"1\"));\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#hasRecycleBin()\n     * @param context see {@link XWikiContext}\n     */\n    public boolean hasRecycleBin(XWikiContext context)\n    {\n        return getStoreConfiguration().isRecycleBinEnabled();\n    }\n\n    /**\n     * Indicates whether deleted attachments are stored in a recycle bin or not. This can be configured using the key\n     * <var>storage.attachment.recyclebin</var>.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public boolean hasAttachmentRecycleBin(XWikiContext context)\n    {\n        return getStoreConfiguration().isAttachmentRecycleBinEnabled();\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public BaseClass getXClass(DocumentReference documentReference, XWikiContext context) throws XWikiException\n    {\n        // Used to avoid recursive loading of documents if there are recursives usage of classes\n        BaseClass bclass = context.getBaseClass(documentReference);\n        if (bclass != null) {\n            return bclass;\n        }\n\n        return getDocument(documentReference, context).getXClass();\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #getXClass(DocumentReference, XWikiContext)}\n     */\n    @Deprecated\n    public BaseClass getClass(String fullName, XWikiContext context) throws XWikiException\n    {\n        DocumentReference reference = null;\n        if (StringUtils.isNotEmpty(fullName)) {\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);\n        }\n        return getXClass(reference, context);\n    }\n\n    public String getEditorPreference(XWikiContext context)\n    {\n        String defaultSyntaxContentEditor = getEditConfiguration().getDefaultEditor(SyntaxContent.class);\n\n        return defaultSyntaxContentEditor == null ? \"\" : defaultSyntaxContentEditor.toLowerCase();\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String. Note that Groovy scripts\n     * compilation is cached.\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public Object parseGroovyFromString(String script, XWikiContext xcontext) throws XWikiException\n    {\n        return getParseGroovyFromString().parseGroovyFromString(script, xcontext);\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String, using a classloader including all\n     * JAR files located in the passed page as attachments. Note that Groovy scripts compilation is cached\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public Object parseGroovyFromString(String script, String jarWikiPage, XWikiContext xcontext) throws XWikiException\n    {\n        XWikiPageClassLoader pcl = new XWikiPageClassLoader(jarWikiPage, xcontext);\n        Object prevParentClassLoader = xcontext.get(\"parentclassloader\");\n        try {\n            xcontext.put(\"parentclassloader\", pcl);\n\n            return parseGroovyFromString(script, xcontext);\n        } finally {\n            if (prevParentClassLoader == null) {\n                xcontext.remove(\"parentclassloader\");\n            } else {\n                xcontext.put(\"parentclassloader\", prevParentClassLoader);\n            }\n        }\n    }\n\n    public Object parseGroovyFromPage(String fullName, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groovyDocument = context.getWiki().getDocument(fullName, context);\n\n        Object sdoc = context.get(XWikiDocument.CKEY_SDOC);\n        context.put(XWikiDocument.CKEY_SDOC, groovyDocument);\n\n        try {\n            return parseGroovyFromString(groovyDocument.getContent(), context);\n        } finally {\n            context.put(XWikiDocument.CKEY_SDOC, sdoc);\n        }\n    }\n\n    public Object parseGroovyFromPage(String fullName, String jarWikiPage, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groovyDocument = context.getWiki().getDocument(fullName, context);\n\n        Object sdoc = context.get(XWikiDocument.CKEY_SDOC);\n        context.put(XWikiDocument.CKEY_SDOC, groovyDocument);\n\n        try {\n            return parseGroovyFromString(groovyDocument.getContent(), jarWikiPage, context);\n        } finally {\n            context.put(XWikiDocument.CKEY_SDOC, sdoc);\n        }\n    }\n\n    public String getMacroList(XWikiContext context)\n    {\n        String macrosmapping = \"\";\n        XWiki xwiki = context.getWiki();\n\n        try {\n            macrosmapping = getResourceContent(MACROS_FILE);\n        } catch (IOException e) {\n        }\n\n        macrosmapping += \"\\r\\n\" + xwiki.getXWikiPreference(\"macros_mapping\", \"\", context);\n\n        return macrosmapping;\n    }\n\n    // This functions adds an object from an new object creation form\n    public BaseObject getObjectFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        Map<String, String[]> map = Util.getObject(context.getRequest(), className);\n        BaseClass bclass = context.getWiki().getClass(className, context);\n        BaseObject newobject = (BaseObject) bclass.fromMap(map, context);\n\n        return newobject;\n    }\n\n    public String getConvertingUserNameType(XWikiContext context)\n    {\n        if (StringUtils.isNotBlank(context.getWiki().getXWikiPreference(\"convertmail\", context))) {\n            return context.getWiki().getXWikiPreference(\"convertmail\", \"0\", context);\n        }\n\n        return getConfiguration().getProperty(\"xwiki.authentication.convertemail\", \"0\");\n    }\n\n    public String convertUsername(String username, XWikiContext context)\n    {\n        if (username == null) {\n            return null;\n        }\n\n        if (getConvertingUserNameType(context).equals(\"1\") && (username.indexOf('@') != -1)) {\n            String id = \"\" + username.hashCode();\n            id = id.replace(\"-\", \"\");\n            if (username.length() > 1) {\n                int i1 = username.indexOf('@');\n                id = \"\" + username.charAt(0) + username.substring(i1 + 1, i1 + 2)\n                    + username.charAt(username.length() - 1) + id;\n            }\n\n            return id;\n        } else if (getConvertingUserNameType(context).equals(\"2\")) {\n            return username.replaceAll(\"[\\\\.\\\\@]\", \"_\");\n        } else {\n            return username;\n        }\n    }\n\n    public boolean hasSectionEdit(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.section.edit\", 0) == 1;\n    }\n\n    /**\n     * @return The maximum section depth for which section editing is available. This can be customized through the\n     *         {@code xwiki.section.depth} configuration property. Defaults to 2 when not defined.\n     */\n    public long getSectionEditingDepth()\n    {\n        return getConfiguration().getProperty(\"xwiki.section.depth\", 2L);\n    }\n\n    public String getWysiwygToolbars(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.wysiwyg.toolbars\", \"\");\n    }\n\n    public String clearName(String name, XWikiContext context)\n    {\n        return clearName(name, true, true, context);\n    }\n\n    public String clearName(String name, boolean stripDots, boolean ascii, XWikiContext context)\n    {\n        String temp = name;\n        temp = temp.replaceAll(\n            \"[\\u00c0\\u00c1\\u00c2\\u00c3\\u00c4\\u00c5\\u0100\\u0102\\u0104\\u01cd\\u01de\\u01e0\\u01fa\\u0200\\u0202\\u0226]\", \"A\");\n        temp = temp.replaceAll(\n            \"[\\u00e0\\u00e1\\u00e2\\u00e3\\u00e4\\u00e5\\u0101\\u0103\\u0105\\u01ce\\u01df\\u01e1\\u01fb\\u0201\\u0203\\u0227]\", \"a\");\n        temp = temp.replaceAll(\"[\\u00c6\\u01e2\\u01fc]\", \"AE\");\n        temp = temp.replaceAll(\"[\\u00e6\\u01e3\\u01fd]\", \"ae\");\n        temp = temp.replaceAll(\"[\\u008c\\u0152]\", \"OE\");\n        temp = temp.replaceAll(\"[\\u009c\\u0153]\", \"oe\");\n        temp = temp.replaceAll(\"[\\u00c7\\u0106\\u0108\\u010a\\u010c]\", \"C\");\n        temp = temp.replaceAll(\"[\\u00e7\\u0107\\u0109\\u010b\\u010d]\", \"c\");\n        temp = temp.replaceAll(\"[\\u00d0\\u010e\\u0110]\", \"D\");\n        temp = temp.replaceAll(\"[\\u00f0\\u010f\\u0111]\", \"d\");\n        temp = temp.replaceAll(\"[\\u00c8\\u00c9\\u00ca\\u00cb\\u0112\\u0114\\u0116\\u0118\\u011a\\u0204\\u0206\\u0228]\", \"E\");\n        temp = temp.replaceAll(\"[\\u00e8\\u00e9\\u00ea\\u00eb\\u0113\\u0115\\u0117\\u0119\\u011b\\u01dd\\u0205\\u0207\\u0229]\", \"e\");\n        temp = temp.replaceAll(\"[\\u011c\\u011e\\u0120\\u0122\\u01e4\\u01e6\\u01f4]\", \"G\");\n        temp = temp.replaceAll(\"[\\u011d\\u011f\\u0121\\u0123\\u01e5\\u01e7\\u01f5]\", \"g\");\n        temp = temp.replaceAll(\"[\\u0124\\u0126\\u021e]\", \"H\");\n        temp = temp.replaceAll(\"[\\u0125\\u0127\\u021f]\", \"h\");\n        temp = temp.replaceAll(\"[\\u00cc\\u00cd\\u00ce\\u00cf\\u0128\\u012a\\u012c\\u012e\\u0130\\u01cf\\u0208\\u020a]\", \"I\");\n        temp = temp.replaceAll(\"[\\u00ec\\u00ed\\u00ee\\u00ef\\u0129\\u012b\\u012d\\u012f\\u0131\\u01d0\\u0209\\u020b]\", \"i\");\n        temp = temp.replaceAll(\"[\\u0132]\", \"IJ\");\n        temp = temp.replaceAll(\"[\\u0133]\", \"ij\");\n        temp = temp.replaceAll(\"[\\u0134]\", \"J\");\n        temp = temp.replaceAll(\"[\\u0135]\", \"j\");\n        temp = temp.replaceAll(\"[\\u0136\\u01e8]\", \"K\");\n        temp = temp.replaceAll(\"[\\u0137\\u0138\\u01e9]\", \"k\");\n        temp = temp.replaceAll(\"[\\u0139\\u013b\\u013d\\u013f\\u0141]\", \"L\");\n        temp = temp.replaceAll(\"[\\u013a\\u013c\\u013e\\u0140\\u0142\\u0234]\", \"l\");\n        temp = temp.replaceAll(\"[\\u00d1\\u0143\\u0145\\u0147\\u014a\\u01f8]\", \"N\");\n        temp = temp.replaceAll(\"[\\u00f1\\u0144\\u0146\\u0148\\u0149\\u014b\\u01f9\\u0235]\", \"n\");\n        temp = temp.replaceAll(\n            \"[\\u00d2\\u00d3\\u00d4\\u00d5\\u00d6\\u00d8\\u014c\\u014e\\u0150\\u01d1\\u01ea\\u01ec\\u01fe\\u020c\\u020e\\u022a\\u022c\"\n                + \"\\u022e\\u0230]\",\n            \"O\");\n        temp = temp.replaceAll(\n            \"[\\u00f2\\u00f3\\u00f4\\u00f5\\u00f6\\u00f8\\u014d\\u014f\\u0151\\u01d2\\u01eb\\u01ed\\u01ff\\u020d\\u020f\\u022b\\u022d\"\n                + \"\\u022f\\u0231]\",\n            \"o\");\n        temp = temp.replaceAll(\"[\\u0156\\u0158\\u0210\\u0212]\", \"R\");\n        temp = temp.replaceAll(\"[\\u0157\\u0159\\u0211\\u0213]\", \"r\");\n        temp = temp.replaceAll(\"[\\u015a\\u015c\\u015e\\u0160\\u0218]\", \"S\");\n        temp = temp.replaceAll(\"[\\u015b\\u015d\\u015f\\u0161\\u0219]\", \"s\");\n        temp = temp.replaceAll(\"[\\u00de\\u0162\\u0164\\u0166\\u021a]\", \"T\");\n        temp = temp.replaceAll(\"[\\u00fe\\u0163\\u0165\\u0167\\u021b\\u0236]\", \"t\");\n        temp = temp.replaceAll(\n            \"[\\u00d9\\u00da\\u00db\\u00dc\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u0214\\u0216]\",\n            \"U\");\n        temp = temp.replaceAll(\n            \"[\\u00f9\\u00fa\\u00fb\\u00fc\\u0169\\u016b\\u016d\\u016f\\u0171\\u0173\\u01d4\\u01d6\\u01d8\\u01da\\u01dc\\u0215\\u0217]\",\n            \"u\");\n        temp = temp.replaceAll(\"[\\u0174]\", \"W\");\n        temp = temp.replaceAll(\"[\\u0175]\", \"w\");\n        temp = temp.replaceAll(\"[\\u00dd\\u0176\\u0178\\u0232]\", \"Y\");\n        temp = temp.replaceAll(\"[\\u00fd\\u00ff\\u0177\\u0233]\", \"y\");\n        temp = temp.replaceAll(\"[\\u0179\\u017b\\u017d]\", \"Z\");\n        temp = temp.replaceAll(\"[\\u017a\\u017c\\u017e]\", \"z\");\n        temp = temp.replaceAll(\"[\\u00df]\", \"SS\");\n        temp = temp.replaceAll(\"[_':,;\\\\\\\\/]\", \" \");\n        name = temp;\n        name = name.replaceAll(\"\\\\s+\", \"\");\n        name = name.replaceAll(\"[\\\\(\\\\)]\", \" \");\n\n        if (stripDots) {\n            name = name.replaceAll(\"[\\\\.]\", \"\");\n        }\n\n        if (ascii) {\n            name = name.replaceAll(\"[^a-zA-Z0-9\\\\-_\\\\.]\", \"\");\n        }\n\n        if (name.length() > 250) {\n            name = name.substring(0, 250);\n        }\n\n        return name;\n\n    }\n\n    public String getUniquePageName(String space, XWikiContext context)\n    {\n        String pageName = generateRandomString(16);\n\n        return getUniquePageName(space, pageName, context);\n    }\n\n    public String getUniquePageName(String space, String name, XWikiContext context)\n    {\n        String pageName = clearName(name, context);\n        if (exists(space + \".\" + pageName, context)) {\n            int i = 0;\n            while (exists(space + \".\" + pageName + \"_\" + i, context)) {\n                i++;\n            }\n\n            return pageName + \"_\" + i;\n        }\n\n        return pageName;\n    }\n\n    public PropertyClass getPropertyClassFromName(String propPath, XWikiContext context)\n    {\n        int i1 = propPath.indexOf('_');\n        if (i1 == -1) {\n            return null;\n        } else {\n            String className = propPath.substring(0, i1);\n            String propName = propPath.substring(i1 + 1);\n            try {\n                return (PropertyClass) getDocument(className, context).getXClass().get(propName);\n            } catch (XWikiException e) {\n                return null;\n            }\n        }\n    }\n\n    public boolean validateDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        return doc.validate(context);\n    }\n\n    public String addTooltip(String html, String message, String params, XWikiContext context)\n    {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(\"<span class=\\\"tooltip_span\\\" onmouseover=\\\"\");\n        buffer.append(params);\n        buffer.append(\"; return escape('\");\n        buffer.append(message.replaceAll(\"'\", \"\\\\'\"));\n        buffer.append(\"');\\\">\");\n        buffer.append(html);\n        buffer.append(\"</span>\");\n\n        return buffer.toString();\n    }\n\n    public String addTooltipJS(XWikiContext context)\n    {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(\"<script src=\\\"\");\n        buffer.append(getSkinFile(\"ajax/wzToolTip.js\", context));\n        buffer.append(\"\\\"></script>\");\n        // buffer.append(\"<div id=\\\"dhtmltooltip\\\"></div>\");\n\n        return buffer.toString();\n    }\n\n    public String addTooltip(String html, String message, XWikiContext context)\n    {\n        return addTooltip(html, message, \"this.WIDTH='300'\", context);\n    }\n\n    public String addMandatory(XWikiContext context)\n    {\n        String star =\n            \"<span class=\\\"mandatoryParenthesis\\\">&nbsp;(</span><span class=\\\"mandatoryDot\\\">&lowast;</span><span class=\\\"mandatoryParenthesis\\\">)&nbsp;</span>\";\n        return context.getWiki().getXWikiPreference(\"mandatory_display\", star, context);\n    }\n\n    /**\n     * @since 2.3M1\n     */\n    public boolean hasVersioning(XWikiContext context)\n    {\n        return getStoreConfiguration().isVersioningEnabled();\n    }\n\n    public boolean hasAttachmentVersioning(XWikiContext context)\n    {\n        return getStoreConfiguration().isAttachmentVersioningEnabled();\n    }\n\n    public String getExternalAttachmentURL(String fullName, String filename, XWikiContext context)\n    {\n        XWikiDocument doc = new XWikiDocument();\n        doc.setFullName(fullName, context);\n\n        return doc.getExternalAttachmentURL(filename, \"download\", context);\n    }\n\n    public int getMaxRecursiveSpaceChecks(XWikiContext context)\n    {\n        int max = getXWikiPreferenceAsInt(\"rights_maxrecursivespacechecks\", -1, context);\n        if (max == -1) {\n            return getConfiguration().getProperty(\"xwiki.rights.maxrecursivespacechecks\", 0);\n        } else {\n            return max;\n        }\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param doc the document to restore\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 5.4RC1\n     */\n    public void restoreFromRecycleBin(final XWikiDocument doc, String comment, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = getRecycleBinStore().getAllDeletedDocuments(doc, context, true);\n        if (deletedDocuments != null && deletedDocuments.length > 0) {\n            long index = deletedDocuments[0].getId();\n            restoreFromRecycleBin(doc, index, comment, context);\n        }\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param doc the document to restore\n     * @param index the index of the document in the recycle bin\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 5.4RC1\n     * @deprecated since 9.4RC1. Use {@link #restoreFromRecycleBin(long, String, XWikiContext)} instead.\n     */\n    @Deprecated\n    public void restoreFromRecycleBin(final XWikiDocument doc, long index, String comment, XWikiContext context)\n        throws XWikiException\n    {\n        restoreFromRecycleBin(index, comment, context);\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param index the index of the document in the recycle bin\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 9.4RC1\n     */\n    public void restoreFromRecycleBin(long index, String comment, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument newdoc = getRecycleBinStore().restoreFromRecycleBin(index, context, true);\n        saveDocument(newdoc, comment, context);\n        getRecycleBinStore().deleteFromRecycleBin(index, context, true);\n    }\n\n    public XWikiDocument rollback(final XWikiDocument tdoc, String rev, XWikiContext context) throws XWikiException\n    {\n        return rollback(tdoc, rev, true, context);\n    }\n\n    private void restoreDeletedAttachment(XWikiAttachment rolledbackAttachment, XWikiContext context)\n        throws XWikiException\n    {\n        // Restore deleted attachments from the trash\n        if (getAttachmentRecycleBinStore() != null) {\n            // There might be multiple versions of the attachment in the trash, search for the right one\n            List<DeletedAttachment> deletedVariants =\n                getAttachmentRecycleBinStore().getAllDeletedAttachments(rolledbackAttachment, context, true);\n\n            DeletedAttachment correctVariant = null;\n            for (DeletedAttachment variant : deletedVariants) { // Reverse chronological order\n                if (variant.getDate().before(rolledbackAttachment.getDate())) {\n                    break;\n                }\n\n                correctVariant = variant;\n            }\n\n            if (correctVariant != null) {\n                XWikiAttachment restoredAttachment = correctVariant.restoreAttachment();\n\n                boolean updateArchive = false;\n\n                if (!restoredAttachment.getVersion().equals(rolledbackAttachment.getVersion())) {\n                    XWikiAttachment restoredAttachmentRevision =\n                        restoredAttachment.getAttachmentRevision(rolledbackAttachment.getVersion(), context);\n\n                    if (restoredAttachmentRevision != null) {\n                        // Update the archive since it won't be done by the store (it's a new attachment)\n                        // TODO: Remove from the archive the versions greater than the rollbacked one instead (they\n                        // would not be lost since they would still be in the recycle bin) ?\n                        rolledbackAttachment.setVersion(restoredAttachment.getVersion());\n                        updateArchive = true;\n\n                        restoredAttachment = restoredAttachmentRevision;\n                    }\n                }\n\n                rolledbackAttachment.apply(restoredAttachment);\n\n                // Restore the deleted archive\n                rolledbackAttachment\n                    .setAttachment_archive((XWikiAttachmentArchive) restoredAttachment.getAttachment_archive().clone());\n                rolledbackAttachment.getAttachment_archive().setAttachment(rolledbackAttachment);\n\n                if (updateArchive) {\n                    rolledbackAttachment.updateContentArchive(context);\n                }\n            } else {\n                // Not found in the trash, set an empty content to avoid errors\n                try {\n                    rolledbackAttachment.setContent(new ByteArrayInputStream(new byte[0]));\n                } catch (IOException e) {\n                    // The content we pass cannot fail\n                }\n            }\n        }\n    }\n\n    /**\n     * @param tdoc the document to rollback\n     * @param rev the revision to rollback to\n     * @param addRevision true if a new revision should be created\n     * @param xcontext the XWiki context\n     * @return the new document\n     * @throws XWikiException when failing to rollback the document\n     * @since 10.7RC1\n     * @since 9.11.8\n     */\n    public XWikiDocument rollback(final XWikiDocument tdoc, String rev, boolean addRevision, XWikiContext xcontext)\n        throws XWikiException\n    {\n        LOGGER.debug(\"Rolling back [{}] to version [{}]\", tdoc, rev);\n\n        // Clone the document before modifying to avoid concurrency issues\n        XWikiDocument document = tdoc.clone();\n\n        XWikiDocument rolledbackDoc = getDocumentRevisionProvider().getRevision(tdoc, rev);\n\n        // Restore attachments\n        if (\"1\".equals(getConfiguration().getProperty(\"xwiki.store.rollbackattachmentwithdocuments\", \"1\"))) {\n            LOGGER.debug(\"Checking attachments\");\n\n            for (XWikiAttachment rolledbackAttachment : rolledbackDoc.getAttachmentList()) {\n                String filename = rolledbackAttachment.getFilename();\n                XWikiAttachment attachment = document.getAttachment(filename);\n\n                if (attachment == null) {\n                    // The attachment has been deleted, search and restore it\n                    LOGGER.debug(\"Deleted attachment: [{}]\", filename);\n\n                    // Restore content and archive from the recycle bin\n                    restoreDeletedAttachment(rolledbackAttachment, xcontext);\n                } else {\n                    XWikiAttachment attachmentRevision =\n                        attachment.getAttachmentRevision(rolledbackAttachment.getVersion(), xcontext);\n\n                    // We compare the number of milliseconds instead of the date objects directly because Hibernate can\n                    // return java.sql.Timestamp for date fields and the JavaDoc says that Timestamp.equals(Object)\n                    // doesn't return true if the passed value is a java.util.Date object with the same number of\n                    // milliseconds because the nanoseconds component of the passed date is unknown.\n                    if (attachmentRevision == null\n                        || attachmentRevision.getDate().getTime() != rolledbackAttachment.getDate().getTime()) {\n                        // Recreated attachment\n                        LOGGER.debug(\"Recreated attachment: [{}]\", filename);\n\n                        // Mark current attachment for deletion to not loose it\n                        document.removeAttachment(attachment);\n\n                        // Search and restore previously deleted one\n                        // If the attachment trash is not available, don't lose the existing attachment\n                        if (getAttachmentRecycleBinStore() != null) {\n                            // Restore in the right version\n                            restoreDeletedAttachment(rolledbackAttachment, xcontext);\n                        }\n                    } else {\n                        // Restore content and archive from the recycle bin\n                        rolledbackAttachment.apply(attachmentRevision);\n                    }\n                }\n            }\n        }\n\n        document.apply(rolledbackDoc);\n\n        // Prepare the XWikiDocument before save\n        document.setAuthorReference(xcontext.getUserReference());\n        document.setContentAuthorReference(xcontext.getUserReference());\n\n        // Make sure the history is not modified if addRevision is disabled\n        String message;\n        if (!addRevision) {\n            document.setVersion(rev);\n            document.setMetaDataDirty(false);\n            document.setContentDirty(false);\n            message = document.getComment();\n        } else {\n            // Make sure to save a new version even if nothing changed\n            document.setMetaDataDirty(true);\n            message = localizePlainOrKey(\"core.comment.rollback\", rev);\n        }\n\n        ObservationManager om = getObservationManager();\n        if (om != null) {\n            // Notify listeners about the document that is going to be rolled back.\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            om.notify(new DocumentRollingBackEvent(document.getDocumentReference(), rev), document, xcontext);\n        }\n\n        XWikiDocument originalDocument = document.getOriginalDocument();\n\n        saveDocument(document, message, xcontext);\n\n        // Since XWiki#saveDocument resets the original document, we need to temporarily put it back to send\n        // notifications.\n        XWikiDocument newOriginalDocument = document.getOriginalDocument();\n        document.setOriginalDocument(originalDocument);\n\n        try {\n            if (om != null) {\n                // Notify listeners about the document that was rolled back.\n                // Note that for the moment the event being send is a bridge event, as we are still passing around an\n                // XWikiDocument as source and an XWikiContext as data.\n                om.notify(new DocumentRolledBackEvent(document.getDocumentReference(), rev), document, xcontext);\n            }\n        } finally {\n            document.setOriginalDocument(newOriginalDocument);\n        }\n\n        return document;\n    }\n\n    /**\n     * @return the syntax id of the syntax to use when creating new documents\n     */\n    public String getDefaultDocumentSyntax()\n    {\n        // TODO: Fix this method to return a Syntax object instead of a String\n        return getDefaultDocumentSyntaxInternal().toIdString();\n    }\n\n    /**\n     * @return the syntax to use when creating new documents\n     */\n    private Syntax getDefaultDocumentSyntaxInternal()\n    {\n        return Utils.getComponent(CoreConfiguration.class).getDefaultDocumentSyntax();\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @param defaultSyntaxId the default value to return if no document can be found\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId(String defaultSyntaxId, XWikiContext context)\n    {\n        String syntaxId = getCurrentContentSyntaxIdInternal(context);\n\n        if (syntaxId == null) {\n            syntaxId = defaultSyntaxId;\n        }\n\n        return syntaxId;\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId(XWikiContext context)\n    {\n        String syntaxId = getCurrentContentSyntaxIdInternal(context);\n\n        if (syntaxId == null) {\n            throw new RuntimeException(\"Cannot get the current syntax since there's no current document set\");\n        }\n\n        return syntaxId;\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    private String getCurrentContentSyntaxIdInternal(XWikiContext context)\n    {\n        Syntax syntax = getCurrentContentSyntaxInternal(context);\n\n        return syntax != null ? syntax.toIdString() : null;\n    }\n\n    /**\n     * Get the syntax of the code currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax\n     */\n    private Syntax getCurrentContentSyntaxInternal(XWikiContext context)\n    {\n        Syntax syntax = null;\n\n        // Try to find the current syntax\n        if (getRenderingContext() != null) {\n            Block curentBlock = getRenderingContext().getCurrentBlock();\n\n            if (curentBlock != null) {\n                MetaDataBlock metaDataBlock =\n                    curentBlock.getFirstBlock(new MetadataBlockMatcher(MetaData.SYNTAX), Axes.ANCESTOR_OR_SELF);\n\n                if (metaDataBlock != null) {\n                    return (Syntax) metaDataBlock.getMetaData().getMetaData(MetaData.SYNTAX);\n                }\n            }\n        }\n\n        // Fallback on secure and current document in the context\n        if (context.get(\"sdoc\") != null) {\n            // The content document\n            syntax = ((XWikiDocument) context.get(\"sdoc\")).getSyntax();\n        } else if (context.getDoc() != null) {\n            // The context document\n            syntax = context.getDoc().getSyntax();\n        }\n\n        return syntax;\n    }\n\n    /**\n     * @return true if title handling should be using the compatibility mode or not. When the compatibility mode is\n     *         active, if the document's content first header (level 1 or level 2) matches the document's title the\n     *         first header is stripped.\n     */\n    public boolean isTitleInCompatibilityMode()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.title.compatibility\", \"0\"));\n    }\n\n    @Override\n    public void onEvent(Event event, Object source, Object data)\n    {\n        if (event instanceof JobFinishedEvent) {\n            // An extension just been initialized (after an install or upgrade for example)\n            onJobFinished((JobFinishedEvent) event);\n        } else if (event instanceof WikiDeletedEvent) {\n            // A wiki has been deleted\n            onWikiDeletedEvent((WikiDeletedEvent) event);\n        } else if (event instanceof ComponentDescriptorAddedEvent) {\n            // A new mandatory document initializer has been installed\n            onMandatoryDocumentInitializerAdded((ComponentDescriptorAddedEvent) event, (ComponentManager) source);\n        } else {\n            // Document modifications\n\n            XWikiDocument doc = (XWikiDocument) source;\n\n            if (event instanceof XObjectPropertyEvent) {\n                EntityReference reference = ((XObjectPropertyEvent) event).getReference();\n                String modifiedProperty = reference.getName();\n                if (\"backlinks\".equals(modifiedProperty)) {\n                    this.hasBacklinks = doc.getXObject((ObjectReference) reference.getParent()).getIntValue(\"backlinks\",\n                        getConfiguration().getProperty(\"xwiki.backlinks\", 0)) == 1;\n                }\n            }\n        }\n    }\n\n    private void onJobFinished(JobFinishedEvent event)\n    {\n        // Skip it if:\n        // * the authenticator was not yet initialized\n        // * we are using the standard authenticator\n        // * the event is not related to an install job\n        if (this.authService == null || this.authService.getClass() == XWikiAuthServiceImpl.class\n            || !event.getJobType().equals(InstallJob.JOBTYPE)) {\n            return;\n        }\n\n        try {\n            // Get the class corresponding to the configuration\n            Class<? extends XWikiAuthService> authClass = getAuthServiceClass();\n\n            // If the class does not have the same reference anymore it means it's coming from a different classloader\n            // which generally imply that it's coming from an extension which has been reloaded or upgraded\n            if (this.authService.getClass() != authClass) {\n                setAuthService(authClass);\n            }\n        } catch (ClassNotFoundException e) {\n            LOGGER.error(\"Failed to get the class of the configured authenticator, setting standard authenticator.\", e);\n        }\n    }\n\n    private void onWikiDeletedEvent(WikiDeletedEvent event)\n    {\n        this.initializedWikis.remove(event.getWikiId());\n    }\n\n    private void onMandatoryDocumentInitializerAdded(ComponentDescriptorAddedEvent event,\n        ComponentManager componentManager)\n    {\n        String namespace;\n        if (componentManager instanceof NamespacedComponentManager) {\n            namespace = ((NamespacedComponentManager) componentManager).getNamespace();\n        } else {\n            namespace = null;\n        }\n\n        MandatoryDocumentInitializer initializer;\n        try {\n            initializer = componentManager.getInstance(MandatoryDocumentInitializer.class, event.getRoleHint());\n\n            XWikiContext context = getXWikiContext();\n            if (namespace == null) {\n                // Initialize in main wiki\n                initializeMandatoryDocument(context.getMainXWiki(), initializer, context);\n                // Initialize in already initialized sub wikis (will be initialized in others when they are initialized)\n                for (String wiki : this.initializedWikis.keySet()) {\n                    initializeMandatoryDocument(wiki, initializer, context);\n                }\n            } else if (namespace.startsWith(\"wiki:\")) {\n                // Initialize in the wiki where the extension is installed\n                initializeMandatoryDocument(namespace.substring(\"wiki:\".length()), initializer, context);\n            }\n        } catch (ComponentLookupException e) {\n            LOGGER.error(\"Failed to lookup mandatory document initializer\", e);\n        }\n    }\n\n    /**\n     * The reference to match properties \"plugins\" and \"backlinks\" of class XWiki.XWikiPreference on whatever wiki.\n     */\n    private static final RegexEntityReference XWIKIPREFERENCE_PROPERTY_REFERENCE =\n        XWikiPreferencesDocumentInitializer.OBJECT_REFERENCE;\n\n    private static final List<Event> LISTENER_EVENTS =\n        Arrays.<Event>asList(new XObjectPropertyAddedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE),\n            new XObjectPropertyDeletedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE),\n            new XObjectPropertyUpdatedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE), new WikiDeletedEvent(),\n            new ComponentDescriptorAddedEvent(MandatoryDocumentInitializer.class), new JobFinishedEvent());\n\n    @Override\n    public List<Event> getEvents()\n    {\n        return LISTENER_EVENTS;\n    }\n\n    @Override\n    public String getName()\n    {\n        return \"xwiki-core\";\n    }\n\n    /**\n     * Return the document reference to the wiki preferences.\n     *\n     * @param context see {@link XWikiContext}\n     * @since 4.3M2\n     */\n    private DocumentReference getPreferencesDocumentReference(XWikiContext context)\n    {\n        String database = context.getWikiId();\n        EntityReference spaceReference;\n        if (database != null) {\n            spaceReference = new EntityReference(SYSTEM_SPACE, EntityType.SPACE, new WikiReference(database));\n        } else {\n            spaceReference = getCurrentMixedEntityReferenceResolver().resolve(SYSTEM_SPACE, EntityType.SPACE);\n        }\n        return new DocumentReference(\"XWikiPreferences\", new SpaceReference(spaceReference));\n    }\n\n    /**\n     * Search attachments by passing HQL where clause values as parameters. You can specify properties of the \"attach\"\n     * (the attachment) or \"doc\" (the document it is attached to)\n     *\n     * @param parametrizedSqlClause The HQL where clause. For example {@code where doc.fullName\n     *        <> ?1 and (attach.author = ?2 or (attach.filename = ?3 and doc.space = ?4))}\n     * @param checkRight if true, only return attachments in documents which the \"current user\" has permission to view.\n     * @param nb The number of rows to return. If 0 then all rows are returned\n     * @param start The number of rows to skip at the beginning.\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @param context see {@link XWikiContext}\n     * @return A List of {@link XWikiAttachment} objects.\n     * @throws XWikiException in case of error while performing the query\n     * @see com.xpn.xwiki.store.XWikiStoreInterface#searchDocuments(String, int, int, java.util.List, XWikiContext)\n     * @since 5.0M2\n     * @deprecated since 9.7RC1, use the QueryManager instead along with the \"attachment\" query filter\n     */\n    @Deprecated\n    public List<XWikiAttachment> searchAttachments(String parametrizedSqlClause, boolean checkRight, int nb, int start,\n        List<?> parameterValues, XWikiContext context) throws XWikiException\n    {\n        parametrizedSqlClause = parametrizedSqlClause.trim().replaceFirst(\"^and \", \"\").replaceFirst(\"^where \", \"\");\n\n        // Get the attachment filenames and document fullNames\n        List<java.lang.Object[]> results = this.getStore().search(\n            \"select attach.filename, doc.fullName from XWikiAttachment attach, XWikiDocument doc where doc.id = attach.docId and \"\n                + parametrizedSqlClause,\n            nb, start, parameterValues, context);\n\n        HashMap<String, List<String>> filenamesByDocFullName = new HashMap<>();\n\n        // Put each attachment name with the document name it belongs to\n        for (int i = 0; i < results.size(); i++) {\n            String filename = (String) results.get(i)[0];\n            String docFullName = (String) results.get(i)[1];\n            if (!filenamesByDocFullName.containsKey(docFullName)) {\n                filenamesByDocFullName.put(docFullName, new ArrayList<String>());\n            }\n            filenamesByDocFullName.get(docFullName).add(filename);\n        }\n\n        List<XWikiAttachment> out = new ArrayList<>();\n\n        // Index through the document names, get relivent attachments\n        for (Map.Entry<String, List<String>> entry : filenamesByDocFullName.entrySet()) {\n            String fullName = entry.getKey();\n\n            XWikiDocument doc = getDocument(fullName, context);\n            if (checkRight) {\n                if (!context.getWiki().getRightService().hasAccessLevel(\"view\", context.getUser(), doc.getFullName(),\n                    context)) {\n                    continue;\n                }\n            }\n            List<String> returnedAttachmentNames = entry.getValue();\n            for (XWikiAttachment attach : doc.getAttachmentList()) {\n                if (returnedAttachmentNames.contains(attach.getFilename())) {\n                    out.add(attach);\n                }\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Count attachments returned by a given parameterized query\n     *\n     * @param parametrizedSqlClause Everything which would follow the \"WHERE\" in HQL\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @param context see {@link XWikiContext}\n     * @return int number of attachments found.\n     * @throws XWikiException in event of an exception querying the database\n     * @see #searchAttachments(String, boolean, int, int, java.util.List, XWikiContext)\n     * @since 5.0M2\n     */\n    public int countAttachments(String parametrizedSqlClause, List<?> parameterValues, XWikiContext context)\n        throws XWikiException\n    {\n        parametrizedSqlClause = parametrizedSqlClause.trim().replaceFirst(\"^and \", \"\").replaceFirst(\"^where \", \"\");\n\n        List l = getStore().search(\"select count(attach) from XWikiAttachment attach, XWikiDocument doc where \"\n            + \"attach.docId=doc.id and \" + parametrizedSqlClause, 0, 0, parameterValues, context);\n        return ((Number) l.get(0)).intValue();\n    }\n\n    // Deprecated\n\n    /**\n     * @deprecated since 6.1M2, use {@link XWikiCfgConfigurationSource#getConfigPath()} instead\n     */\n    @Deprecated\n    public static String getConfigPath() throws NamingException\n    {\n        return XWikiCfgConfigurationSource.getConfigPath();\n    }\n\n    /**\n     * @deprecated since 6.1M3, use {@link #XWiki(XWikiContext)} instead\n     */\n    @Deprecated\n    public XWiki(XWikiConfig config, XWikiContext context) throws XWikiException\n    {\n        this(config, context, null, false);\n    }\n\n    /**\n     * @deprecated since 6.1M3, use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(XWikiConfig config, XWikiContext context, XWikiEngineContext engine_context, boolean noupdate)\n        throws XWikiException\n    {\n        initXWiki(config, context, engine_context, noupdate);\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext)} instead\n     */\n    @Deprecated\n    public XWiki(String xwikicfgpath, XWikiContext context) throws XWikiException\n    {\n        this(xwikicfgpath, context, null, false);\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(String xwikicfgpath, XWikiContext context, XWikiEngineContext engine_context, boolean noupdate)\n        throws XWikiException\n    {\n        try {\n            initXWiki(new XWikiConfig(new FileInputStream(xwikicfgpath)), context, engine_context, noupdate);\n        } catch (FileNotFoundException e) {\n            Object[] args = { xwikicfgpath };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_CONFIG, XWikiException.ERROR_XWIKI_CONFIG_FILENOTFOUND,\n                \"Configuration file {0} not found\", e, args);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(InputStream is, XWikiContext context, XWikiEngineContext engine_context) throws XWikiException\n    {\n        initXWiki(new XWikiConfig(is), context, engine_context, true);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public XWikiConfig getConfig()\n    {\n        return new XWikiConfigDelegate(getConfiguration());\n    }\n\n    /**\n     * @deprecated since 6.1M2\n     */\n    @Deprecated\n    public void setConfig(XWikiConfig config)\n    {\n        ConfigurationSource configuration = getConfiguration();\n\n        if (configuration instanceof XWikiCfgConfigurationSource) {\n            ((XWikiCfgConfigurationSource) configuration).set(config);\n        }\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public String Param(String key)\n    {\n        return Param(key, null);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public String Param(String key, String default_value)\n    {\n        if (getConfiguration() != null) {\n            return getConfiguration().getProperty(key, default_value);\n        }\n\n        return default_value;\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public long ParamAsLong(String key)\n    {\n        return getConfiguration().getProperty(key, long.class);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public long ParamAsLong(String key, long default_value)\n    {\n        return getConfiguration().getProperty(key, default_value);\n    }\n\n    /**\n     * @return true if the wiki is in path based mode, fale otherwise\n     * @since 11.9RC1\n     */\n    public boolean isPathBased()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.virtual.usepath\", \"1\"));\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.api;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.job.Job;\nimport org.xwiki.job.event.status.JobStatus;\nimport org.xwiki.job.event.status.JobStatus.State;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.rendering.renderer.PrintRendererFactory;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.XWikiInitializerJob;\nimport com.xpn.xwiki.internal.XWikiInitializerJobStatus;\nimport com.xpn.xwiki.objects.meta.MetaClass;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.util.Programming;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiEngineContext;\nimport com.xpn.xwiki.web.XWikiURLFactory;\n\npublic class XWiki extends Api\n{\n    /** Logging helper object. */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);\n\n    /** The internal object wrapped by this API. */\n    private com.xpn.xwiki.XWiki xwiki;\n\n    /**\n     * @see #getStatsService()\n     */\n    private StatsService statsService;\n\n    /**\n     * @see #getCriteriaService()\n     */\n    private CriteriaService criteriaService;\n\n    /**\n     * @see com.xpn.xwiki.internal.model.reference.CurrentMixedStringDocumentReferenceResolver\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    /**\n     * @see org.xwiki.model.internal.reference.DefaultStringDocumentReferenceResolver\n     */\n    private DocumentReferenceResolver<String> defaultDocumentReferenceResolver;\n\n    /**\n     * The object used to serialize entity references into strings. We need it because we have script APIs that work\n     * with entity references but have to call older, often internal, methods that still use string references.\n     */\n    private EntityReferenceSerializer<String> defaultStringEntityReferenceSerializer;\n\n    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;\n\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private ContextualAuthorizationManager contextualAuthorizationManager;\n\n    /**\n     * XWiki API Constructor\n     *\n     * @param xwiki XWiki Main Object to wrap\n     * @param context XWikiContext to wrap\n     */\n    public XWiki(com.xpn.xwiki.XWiki xwiki, XWikiContext context)\n    {\n        super(context);\n\n        this.xwiki = xwiki;\n        this.statsService = new StatsService(context);\n        this.criteriaService = new CriteriaService(context);\n    }\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (this.currentMixedDocumentReferenceResolver == null) {\n            this.currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedDocumentReferenceResolver;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentgetdocumentResolver()\n    {\n        if (this.currentgetdocumentResolver == null) {\n            this.currentgetdocumentResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");\n        }\n\n        return this.currentgetdocumentResolver;\n    }\n\n    private DocumentReferenceResolver<String> getDefaultDocumentReferenceResolver()\n    {\n        if (this.defaultDocumentReferenceResolver == null) {\n            this.defaultDocumentReferenceResolver = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING);\n        }\n\n        return this.defaultDocumentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getDefaultStringEntityReferenceSerializer()\n    {\n        if (this.defaultStringEntityReferenceSerializer == null) {\n            this.defaultStringEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultStringEntityReferenceSerializer;\n    }\n\n    private DocumentRevisionProvider getDocumentRevisionProvider()\n    {\n        if (this.documentRevisionProvider == null) {\n            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);\n        }\n\n        return this.documentRevisionProvider;\n    }\n\n    /**\n     * Privileged API allowing to access the underlying main XWiki Object\n     *\n     * @return Privileged Main XWiki Object\n     */\n    @Programming\n    public com.xpn.xwiki.XWiki getXWiki()\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki;\n        }\n\n        return null;\n    }\n\n    /**\n     * @return the status of the job initializing {@link com.xpn.xwiki.XWiki} instance\n     * @since 6.1M1\n     */\n    public XWikiInitializerJobStatus getJobStatus()\n    {\n        XWikiInitializerJob job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);\n\n        return job != null ? job.getStatus() : null;\n    }\n\n    /**\n     * @return the status of the job initializing the instance or the current wiki\n     * @since 8.4RC1\n     */\n    public JobStatus getCurrentInitializerJobStatus()\n    {\n        // Get XWiki initializer job\n        JobStatus jobStatus = getJobStatus();\n\n        if (jobStatus == null) {\n            return null;\n        }\n\n        // The XWiki initialization is not done yet\n        if (jobStatus.getState() != State.FINISHED) {\n            return jobStatus;\n        }\n\n        // If XWiki initialization did not failed\n        if (this.xwiki != null) {\n            // Get current wiki initializer job\n            Job wikiJob = this.xwiki.getWikiInitializerJob(this.context.getWikiId());\n\n            jobStatus = wikiJob != null ? wikiJob.getStatus() : null;\n        }\n\n        return jobStatus;\n    }\n\n    /**\n     * @return XWiki's version in the format <code>(version).(SVN build number)</code>, or \"Unknown version\" if it\n     *         failed to be retrieved\n     */\n    public String getVersion()\n    {\n        return this.xwiki.getVersion();\n    }\n\n    /**\n     * API Allowing to access the current request URL being requested.\n     *\n     * @return the URL\n     * @throws XWikiException failed to create the URL\n     */\n    public String getRequestURL() throws XWikiException\n    {\n        return getXWikiContext().getURLFactory().getRequestURL(getXWikiContext()).toString();\n    }\n\n    /**\n     * API Allowing to access the current request URL being requested as a relative URL.\n     *\n     * @return the URL\n     * @throws XWikiException failed to create the URL\n     * @since 4.0M1\n     */\n    public String getRelativeRequestURL() throws XWikiException\n    {\n        XWikiURLFactory urlFactory = getXWikiContext().getURLFactory();\n\n        return urlFactory.getURL(urlFactory.getRequestURL(getXWikiContext()), getXWikiContext());\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked before sending back the document.\n     * <p>\n     * This is a helper for document reference but you can use {@link #getEntityDocument(String, EntityType)} for any\n     * other kind of reference.\n     *\n     * @param documentReference the reference of the document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @see #getEntityDocument(String, EntityType)\n     */\n    public Document getDocument(String documentReference) throws XWikiException\n    {\n        DocumentReference reference;\n\n        // We ignore the passed full name if it's null to be backward compatible with previous behaviors.\n        if (documentReference != null) {\n            // Note: We use the CurrentMixed Resolver since we want to use the default page name if the page isn't\n            // specified in the passed string, rather than use the current document's page name.\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(documentReference);\n        } else {\n            reference = getDefaultDocumentReferenceResolver().resolve(\"\");\n        }\n\n        return getDocument(reference);\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked before sending back the document.\n     *\n     * @param reference the reference of the document to be loaded\n     * @param type the type of the reference\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 10.6RC1\n     */\n    public Document getEntityDocument(String reference, EntityType type) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(reference, type, getXWikiContext());\n        if (!getContextualAuthorizationManager().hasAccess(Right.VIEW, doc.getDocumentReference())) {\n            return null;\n        }\n\n        return doc.newDocument(getXWikiContext());\n    }\n\n    /**\n     * Loads a Document from the database. Rights are checked before sending back the document.\n     *\n     * @param reference the reference of the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 2.3M1\n     */\n    public Document getDocument(DocumentReference reference) throws XWikiException\n    {\n        try {\n            XWikiDocument doc = this.xwiki.getDocument(reference, getXWikiContext());\n            if (this.xwiki.getRightService().hasAccessLevel(\"view\", getXWikiContext().getUser(),\n                doc.getPrefixedFullName(), getXWikiContext()) == false) {\n                return null;\n            }\n\n            return doc.newDocument(getXWikiContext());\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to access document [{}]. Root reason: [{}]\", reference,\n                ExceptionUtils.getRootCauseMessage(ex));\n            return new Document(new XWikiDocument(reference), getXWikiContext());\n        }\n    }\n\n    /**\n     * Loads a Document from the store. Rights are checked before sending back the document.\n     * <p>\n     * The passed reference can be anything. If if a document child, the document reference will be extracted from it.\n     * If it's a document parent it will be completed with the necessary default references (for example if it's a space\n     * reference it will load the space home page).\n     *\n     * @param reference the reference close to the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 7.1M2\n     */\n    public Document getDocument(EntityReference reference) throws XWikiException\n    {\n        return getDocument(this.xwiki.getDocumentReference(reference, getXWikiContext()));\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked on the author (contentAuthor) of the document containing\n     * the currently executing script before sending back the loaded document.\n     *\n     * @param fullName the full name of the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 2.3M2\n     */\n    public Document getDocumentAsAuthor(String fullName) throws XWikiException\n    {\n        DocumentReference reference;\n\n        // We ignore the passed full name if it's null to match behavior of getDocument\n        if (fullName != null) {\n            // Note: We use the CurrentMixed Resolver since we want to use the default page name if the page isn't\n            // specified in the passed string, rather than use the current document's page name.\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);\n        } else {\n            reference = getDefaultDocumentReferenceResolver().resolve(\"\");\n        }\n\n        return getDocumentAsAuthor(reference);\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked on the author (contentAuthor) of the document containing\n     * the currently executing script before sending back the loaded document.\n     *\n     * @param reference the reference of the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 2.3M2\n     */\n    public Document getDocumentAsAuthor(DocumentReference reference) throws XWikiException\n    {\n        if (!getAuthorizationManager().hasAccess(Right.VIEW, getEffectiveAuthorReference(), reference)) {\n            return null;\n        }\n\n        return this.xwiki.getDocument(reference, getXWikiContext()).newDocument(getXWikiContext());\n    }\n\n    /**\n     * @param fullname the {@link XWikiDocument#getFullName() name} of the document to search for.\n     * @param locale an optional {@link XWikiDocument#getLocale() locale} to filter results.\n     * @return A list with all the deleted versions of a document in the recycle bin.\n     * @throws XWikiException if any error\n     */\n    public List<DeletedDocument> getDeletedDocuments(String fullname, String locale) throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = this.xwiki.getDeletedDocuments(fullname, locale, this.context);\n        List<DeletedDocument> result = wrapDeletedDocuments(deletedDocuments);\n        return result;\n    }\n\n    /**\n     * @param batchId id of the operation that deleted multiple documents at the same time; useful when trying to revert\n     *            the operation\n     * @return a list of all document versions that were deleted in the same batch, as part of the same operation\n     * @throws XWikiException if any error\n     * @since 9.4RC1\n     */\n    public List<DeletedDocument> getDeletedDocuments(String batchId) throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = this.xwiki.getDeletedDocuments(batchId, this.context);\n        List<DeletedDocument> result = wrapDeletedDocuments(deletedDocuments);\n        return result;\n    }\n\n    private List<DeletedDocument> wrapDeletedDocuments(XWikiDeletedDocument[] deletedDocuments)\n    {\n        if (deletedDocuments == null || deletedDocuments.length == 0) {\n            return Collections.emptyList();\n        }\n\n        List<DeletedDocument> result = new ArrayList<>(deletedDocuments.length);\n        for (XWikiDeletedDocument deletedDocument : deletedDocuments) {\n            result.add(new DeletedDocument(deletedDocument, this.context));\n        }\n\n        return result;\n    }\n\n    /**\n     * @param fullname - {@link XWikiDocument#getFullName()}\n     * @param locale - {@link XWikiDocument#getLocale()}\n     * @param index - {@link XWikiDocument#getId()}\n     * @return the specified document from the recycle bin\n     * @throws XWikiException if any error\n     * @deprecated since 9.4RC1. Use {@link #getDeletedDocument(String)} instead.\n     */\n    @Deprecated\n    public DeletedDocument getDeletedDocument(String fullname, String locale, String index) throws XWikiException\n    {\n        return getDeletedDocument(index);\n    }\n\n    /**\n     * @return the specified document from the recycle bin\n     * @throws XWikiException if any error\n     * @since 9.4RC1\n     */\n    public DeletedDocument getDeletedDocument(String index) throws XWikiException\n    {\n        if (!NumberUtils.isDigits(index)) {\n            return null;\n        }\n\n        XWikiDeletedDocument dd = this.xwiki.getDeletedDocument(Long.parseLong(index), this.context);\n        if (dd == null) {\n            return null;\n        }\n\n        return new DeletedDocument(dd, this.context);\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document. Note that this does not distinguish\n     * between different incarnations of a document name, and it does not require that the document still exists, it\n     * returns all the attachments that at the time of their deletion had a document with the specified name as their\n     * owner.\n     *\n     * @param docName the {@link XWikiDocument#getFullName() name} of the owner document\n     * @return A list with all the deleted attachments which belonged to the specified document. If no such attachments\n     *         are found in the trash, an empty list is returned.\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName)\n    {\n        try {\n            List<com.xpn.xwiki.doc.DeletedAttachment> attachments =\n                this.xwiki.getDeletedAttachments(docName, this.context);\n            if (attachments == null || attachments.isEmpty()) {\n                attachments = Collections.emptyList();\n            }\n            List<DeletedAttachment> result = new ArrayList<DeletedAttachment>(attachments.size());\n            for (com.xpn.xwiki.doc.DeletedAttachment attachment : attachments) {\n                result.add(new DeletedAttachment(attachment, this.context));\n            }\n            return result;\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to retrieve deleted attachments\", ex);\n        }\n        return Collections.emptyList();\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document and had the specified name. Multiple\n     * versions can be returned since the same file can be uploaded and deleted several times, creating different\n     * instances in the trash. Note that this does not distinguish between different incarnations of a document name,\n     * and it does not require that the document still exists, it returns all the attachments that at the time of their\n     * deletion had a document with the specified name as their owner.\n     *\n     * @param docName the {@link DeletedAttachment#getDocName() name of the document} the attachment belonged to\n     * @param filename the {@link DeletedAttachment#getFilename() name} of the attachment to search for\n     * @return A list with all the deleted attachments which belonged to the specified document and had the specified\n     *         filename. If no such attachments are found in the trash, an empty list is returned.\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, String filename)\n    {\n        try {\n            List<com.xpn.xwiki.doc.DeletedAttachment> attachments =\n                this.xwiki.getDeletedAttachments(docName, filename, this.context);\n            if (attachments == null) {\n                attachments = Collections.emptyList();\n            }\n            List<DeletedAttachment> result = new ArrayList<DeletedAttachment>(attachments.size());\n            for (com.xpn.xwiki.doc.DeletedAttachment attachment : attachments) {\n                result.add(new DeletedAttachment(attachment, this.context));\n            }\n            return result;\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to retrieve deleted attachments\", ex);\n        }\n        return Collections.emptyList();\n    }\n\n    /**\n     * Retrieve a specific attachment from the trash.\n     *\n     * @param id the unique identifier of the entry in the trash\n     * @return specified attachment from the trash, {@code null} if not found\n     */\n    public DeletedAttachment getDeletedAttachment(String id)\n    {\n        try {\n            com.xpn.xwiki.doc.DeletedAttachment attachment = this.xwiki.getDeletedAttachment(id, this.context);\n            if (attachment != null) {\n                return new DeletedAttachment(attachment, this.context);\n            }\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to retrieve deleted attachment\", ex);\n        }\n        return null;\n    }\n\n    /**\n     * Returns whether a document exists or not\n     *\n     * @param fullname Fullname of the XWiki document to be loaded\n     * @return true if the document exists, false if not\n     * @throws XWikiException\n     */\n    public boolean exists(String fullname) throws XWikiException\n    {\n        return this.xwiki.exists(fullname, getXWikiContext());\n    }\n\n    /**\n     * Returns whether a document exists or not\n     *\n     * @param reference the reference of the document to check for its existence\n     * @return true if the document exists, false if not\n     * @since 2.3M2\n     */\n    public boolean exists(DocumentReference reference) throws XWikiException\n    {\n        return this.xwiki.exists(reference, getXWikiContext());\n    }\n\n    /**\n     * Returns whether a page exists or not.\n     *\n     * @param reference the reference of the page to check for its existence\n     * @return true if the page exists, false if not\n     * @since 13.3RC1\n     * @since 12.10.7\n     */\n    @Unstable\n    public boolean exists(PageReference reference)\n    {\n        return this.xwiki.exists(reference, getXWikiContext());\n    }\n\n    /**\n     * Verify the rights the current user has on a document. If the document requires rights and the user is not\n     * authenticated he will be redirected to the login page.\n     *\n     * @param docname fullname of the document\n     * @param right right to check (\"view\", \"edit\", \"admin\", \"delete\")\n     * @return true if it exists\n     */\n    public boolean checkAccess(String docname, String right)\n    {\n        try {\n            DocumentReference docReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);\n            XWikiDocument doc = getXWikiContext().getWiki().getDocument(docReference, this.context);\n            return getXWikiContext().getWiki().checkAccess(right, doc, getXWikiContext());\n        } catch (XWikiException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked before sending back the document.\n     *\n     * @param space Space to use in case no space is defined in the provided <code>fullname</code>\n     * @param fullname the full name or relative name of the document to load\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     */\n    public Document getDocument(String space, String fullname) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(space, fullname, getXWikiContext());\n        if (this.xwiki.getRightService().hasAccessLevel(\"view\", getXWikiContext().getUser(), doc.getFullName(),\n            getXWikiContext()) == false) {\n            return null;\n        }\n\n        return doc.newDocument(getXWikiContext());\n    }\n\n    /**\n     * Load a specific revision of a document\n     *\n     * @param doc Document for which to load a specific revision\n     * @param rev Revision number\n     * @return Specific revision of a document\n     * @throws XWikiException is never thrown\n     */\n    public Document getDocument(Document doc, String rev) throws XWikiException\n    {\n        if (doc == null || doc.getDoc() == null) {\n            return null;\n        }\n\n        if (!getContextualAuthorizationManager().hasAccess(Right.VIEW, doc.getDocumentReference())) {\n            // Finally we return null, otherwise showing search result is a real pain\n            return null;\n        }\n\n        return doc.getDocumentRevision(rev);\n    }\n\n    /**\n     * Load a specific revision of a document\n     *\n     * @param reference Document for which to load a specific revision\n     * @param revision Revision number\n     * @return Specific revision of a document\n     * @throws XWikiException is never thrown\n     * @since 9.4RC1\n     */\n    public Document getDocument(DocumentReference reference, String revision) throws XWikiException\n    {\n        try {\n            if (reference != null && getContextualAuthorizationManager().hasAccess(Right.VIEW, reference)) {\n                XWikiDocument documentRevision = getDocumentRevisionProvider().getRevision(reference, revision);\n\n                if (documentRevision != null) {\n                    return new Document(documentRevision, this.context);\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to access revision [{}] of document {}\", revision, reference, e);\n        }\n\n        return null;\n    }\n\n    /**\n     * Output content in the edit content textarea\n     *\n     * @param content content to output\n     * @return the textarea text content\n     */\n    public String getTextArea(String content)\n    {\n        return com.xpn.xwiki.XWiki.getTextArea(content, getXWikiContext());\n    }\n\n    /**\n     * Get the list of available classes in the wiki\n     *\n     * @return list of classes names\n     * @throws XWikiException\n     */\n    public List<String> getClassList() throws XWikiException\n    {\n        return this.xwiki.getClassList(getXWikiContext());\n    }\n\n    /**\n     * Get the global MetaClass object\n     *\n     * @return MetaClass object\n     */\n    public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }\n\n    /**\n     * API allowing to search for document names matching a query. Examples:\n     * <ul>\n     * <li>Query: <code>where doc.space='Main' order by doc.creationDate desc</code>. Result: All the documents in space\n     * 'Main' ordered by the creation date from the most recent</li>\n     * <li>Query: <code>where doc.name like '%sport%' order by doc.name asc</code>. Result: All the documents containing\n     * 'sport' in their name ordered by document name</li>\n     * <li>Query: <code>where doc.content like '%sport%' order by doc.author</code> Result: All the documents containing\n     * 'sport' in their content ordered by the author</li>\n     * <li>Query: <code>where doc.creator = 'XWiki.LudovicDubost' order by doc.creationDate\n     *       desc</code>. Result: All the documents with creator LudovicDubost ordered by the creation date from the\n     * most recent</li>\n     * <li>Query: <code>where doc.author = 'XWiki.LudovicDubost' order by doc.date desc</code>. Result: All the\n     * documents with last author LudovicDubost ordered by the last modification date from the most recent.</li>\n     * <li>Query: <code>,BaseObject as obj where doc.fullName=obj.name and\n     *       obj.className='XWiki.XWikiComments' order by doc.date desc</code>. Result: All the documents with at least\n     * one comment ordered by the last modification date from the most recent</li>\n     * <li>Query: <code>,BaseObject as obj, StringProperty as prop where\n     *       doc.fullName=obj.name and obj.className='XWiki.XWikiComments' and obj.id=prop.id.id\n     *       and prop.id.name='author' and prop.value='XWiki.LudovicDubost' order by doc.date\n     *       desc</code>. Result: All the documents with at least one comment from LudovicDubost ordered by the last\n     * modification date from the most recent</li>\n     * </ul>\n     *\n     * @param wheresql Query to be run (either starting with \", BaseObject as obj where..\" or by \"where ...\"\n     * @return List of document names matching (Main.Page1, Main.Page2)\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String wheresql) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(wheresql, getXWikiContext());\n    }\n\n    /**\n     * API allowing to search for document names matching a query return only a limited number of elements and skipping\n     * the first rows. The query part is the same as searchDocuments\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param nb return only 'nb' rows\n     * @param start skip the first 'start' rows\n     * @return List of document names matching\n     * @throws XWikiException\n     * @see List searchDocuments(String where sql)\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String wheresql, int nb, int start) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(wheresql, nb, start, getXWikiContext());\n    }\n\n    /**\n     * Privileged API allowing to search for document names matching a query return only a limited number of elements\n     * and skipping the first rows. The return values contain the list of columns specified in addition to the document\n     * space and name The query part is the same as searchDocuments\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param nb return only 'nb' rows\n     * @param start skip the first 'start' rows\n     * @param selectColumns List of columns to add to the result\n     * @return List of Object[] with the column values of the matching rows\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String wheresql, int nb, int start, String selectColumns) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.getStore().searchDocumentsNames(wheresql, nb, start, selectColumns, getXWikiContext());\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * API allowing to search for documents allowing to have mutliple entries per locale\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param distinctbylocale true to return multiple rows per locale\n     * @return List of Document object matching\n     * @throws XWikiException\n     */\n    public List<Document> searchDocuments(String wheresql, boolean distinctbylocale) throws XWikiException\n    {\n        return convert(this.xwiki.getStore().searchDocuments(wheresql, distinctbylocale, getXWikiContext()));\n    }\n\n    /**\n     * API allowing to search for documents allowing to have multiple entries per locale\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param distinctbylocale true to return multiple rows per locale\n     * @return List of Document object matching\n     * @param nb return only 'nb' rows\n     * @param start skip the first 'start' rows\n     * @throws XWikiException\n     */\n    public List<Document> searchDocuments(String wheresql, boolean distinctbylocale, int nb, int start)\n        throws XWikiException\n    {\n        return convert(this.xwiki.getStore().searchDocuments(wheresql, distinctbylocale, nb, start, getXWikiContext()));\n    }\n\n    /**\n     * Search documents by passing HQL where clause values as parameters. This allows generating a Named HQL query which\n     * will automatically encode the passed values (like escaping single quotes). This API is recommended to be used\n     * over the other similar methods where the values are passed inside the where clause and for which you'll need to\n     * do the encoding/escaping yourself before calling them.\n     * <p>\n     * Example\n     * </p>\n     *\n     * <pre>\n     * &lt;code&gt;\n     * #set($orphans = $xwiki.searchDocuments(&quot; where doc.fullName &lt;&gt; ?1 and (doc.parent = ?2 or &quot;\n     *     + &quot;(doc.parent = ?3 and doc.space = ?4))&quot;,\n     *     [&quot;${doc.fullName}as&quot;, ${doc.fullName}, ${doc.name}, ${doc.space}]))\n     * &lt;/code&gt;\n     * </pre>\n     *\n     * @param parameterizedWhereClause the HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param maxResults the number of rows to return. If 0 then all rows are returned\n     * @param startOffset the number of rows to skip. If 0 don't skip any row\n     * @param parameterValues the where clause values that replace the question marks (?1, ?2, etc.)\n     * @return a list of document names\n     * @throws XWikiException in case of error while performing the query\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, int maxResults, int startOffset,\n        List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, maxResults, startOffset,\n            parameterValues, getXWikiContext());\n    }\n\n    /**\n     * Same as {@link #searchDocuments(String, int, int, java.util.List)} but returns all rows.\n     *\n     * @see #searchDocuments(String, int, int, java.util.List)\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }\n\n    /**\n     * Search documents in the provided wiki by passing HQL where clause values as parameters. See\n     * {@link #searchDocuments(String, int, int, java.util.List)} for more details.\n     *\n     * @param wikiName the name of the wiki where to search.\n     * @param parameterizedWhereClause the HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param maxResults the number of rows to return. If 0 then all rows are returned\n     * @param startOffset the number of rows to skip. If 0 don't skip any row\n     * @param parameterValues the where clause values that replace the question marks (?)\n     * @return a list of document full names (Space.Name).\n     * @see #searchDocuments(String, int, int, java.util.List)\n     * @throws XWikiException in case of error while performing the query\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }\n\n    /**\n     * Search spaces by passing HQL where clause values as parameters. See\n     * {@link #searchDocuments(String, int, int, List)} for more about parameterized hql clauses.\n     *\n     * @param parametrizedSqlClause the HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param nb the number of rows to return. If 0 then all rows are returned\n     * @param start the number of rows to skip. If 0 don't skip any row\n     * @param parameterValues the where clause values that replace the question marks (?)\n     * @return a list of spaces names.\n     * @throws XWikiException in case of error while performing the query\n     */\n    public List<String> searchSpacesNames(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parametrizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }\n\n    /**\n     * Search attachments by passing HQL where clause values as parameters. See\n     * {@link #searchDocuments(String, int, int, List)} for more about parameterized hql clauses. You can specify\n     * properties of attach (the attachment) or doc (the document it is attached to)\n     *\n     * @param parametrizedSqlClause The HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param nb The number of rows to return. If 0 then all rows are returned\n     * @param start The number of rows to skip at the beginning.\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @return A List of {@link Attachment} objects.\n     * @throws XWikiException in case of error while performing the query\n     * @since 5.0M2\n     */\n    public List<Attachment> searchAttachments(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return convertAttachments(\n            this.xwiki.searchAttachments(parametrizedSqlClause, true, nb, start, parameterValues, this.context));\n    }\n\n    /**\n     * Count attachments returned by a given parameterized query\n     *\n     * @param parametrizedSqlClause Everything which would follow the \"WHERE\" in HQL see:\n     *            {@link #searchDocuments(String, int, int, List)}\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @return int number of attachments found.\n     * @throws XWikiException\n     * @see #searchAttachments(String, int, int, List)\n     * @since 5.0M2\n     */\n    public int countAttachments(String parametrizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.countAttachments(parametrizedSqlClause, parameterValues, this.context);\n    }\n\n    /**\n     * Function to wrap a list of XWikiDocument into Document objects\n     *\n     * @param docs list of XWikiDocument\n     * @return list of Document objects\n     */\n    public List<Document> wrapDocs(List<?> docs)\n    {\n        List<Document> result = new ArrayList<Document>();\n        if (docs != null) {\n            for (java.lang.Object obj : docs) {\n                try {\n                    if (obj instanceof XWikiDocument) {\n                        XWikiDocument doc = (XWikiDocument) obj;\n                        Document wrappedDoc = doc.newDocument(getXWikiContext());\n                        result.add(wrappedDoc);\n                    } else if (obj instanceof Document) {\n                        result.add((Document) obj);\n                    } else if (obj instanceof String) {\n                        Document doc = getDocument(obj.toString());\n                        if (doc != null) {\n                            result.add(doc);\n                        }\n                    }\n                } catch (XWikiException ex) {\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * API allowing to parse a text content to evaluate velocity scripts\n     *\n     * @param content\n     * @return evaluated content if the content contains velocity scripts\n     * @deprecated Since 7.2M1. Use specific rendering/parsing options for the content type you want to parse/render.\n     */\n    @Deprecated\n    public String parseContent(String content)\n    {\n        return this.xwiki.parseContent(content, getXWikiContext());\n    }\n\n    /**\n     * API to parse a velocity template provided by the current Skin The template is first looked in the skin active for\n     * the user, the space or the wiki. If the template does not exist in that skin, the template is looked up in the\n     * \"parent skin\" of the skin\n     *\n     * @param template Template name (\"view\", \"edit\", \"comment\")\n     * @return Evaluated content from the template\n     */\n    public String parseTemplate(String template)\n    {\n        return this.xwiki.parseTemplate(template, getXWikiContext());\n    }\n\n    /**\n     * API to render a velocity template provided by the current Skin The template is first looked in the skin active\n     * for the user, the space or the wiki. If the template does not exist in that skin, the template is looked up in\n     * the \"parent skin\" of the skin\n     *\n     * @param template Template name (\"view\", \"edit\", \"comment\")\n     * @return Evaluated content from the template\n     */\n    public String renderTemplate(String template)\n    {\n        return this.xwiki.renderTemplate(template, getXWikiContext());\n    }\n\n    /**\n     * Return the URL of the static file provided by the current skin The file is first looked in the skin active for\n     * the user, the space or the wiki. If the file does not exist in that skin, the file is looked up in the \"parent\n     * skin\" of the skin. The file can be a CSS file, an image file, a javascript file, etc.\n     *\n     * @param filename Filename to be looked up in the skin (logo.gif, style.css)\n     * @return URL to access this file\n     */\n    public String getSkinFile(String filename)\n    {\n        return this.xwiki.getSkinFile(filename, getXWikiContext());\n    }\n\n    /**\n     * Return the URL of the static file provided by the current skin The file is first looked in the skin active for\n     * the user, the space or the wiki. If the file does not exist in that skin, the file is looked up in the \"parent\n     * skin\" of the skin. The file can be a CSS file, an image file, a javascript file, etc.\n     *\n     * @param filename Filename to be looked up in the skin (logo.gif, style.css)\n     * @param forceSkinAction true to make sure that static files are retrieved through the skin action, to allow\n     *            parsing of velocity on CSS files\n     * @return URL to access this file\n     */\n    public String getSkinFile(String filename, boolean forceSkinAction)\n    {\n        return this.xwiki.getSkinFile(filename, forceSkinAction, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the current skin for this request and user The skin is first derived from the request \"skin\"\n     * parameter If this parameter does not exist, the user preference \"skin\" is looked up If this parameter does not\n     * exist or is empty, the space preference \"skin\" is looked up If this parameter does not exist or is empty, the\n     * XWiki preference \"skin\" is looked up If this parameter does not exist or is empty, the xwiki.cfg parameter\n     * xwiki.defaultskin is looked up If this parameter does not exist or is empty, the xwiki.cfg parameter\n     * xwiki.defaultbaseskin is looked up If this parameter does not exist or is empty, the skin is \"colibri\"\n     *\n     * @return The current skin for this request and user\n     */\n    public String getSkin()\n    {\n        return this.xwiki.getSkin(getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the current skin for this request and user. Each skin has a skin it is based on. If not the base\n     * skin is the xwiki.cfg parameter \"xwiki.defaultbaseskin\". If this parameter does not exist or is empty, the base\n     * skin is \"colibri\".\n     *\n     * @return The current baseskin for this request and user\n     */\n    public String getBaseSkin()\n    {\n        return this.xwiki.getBaseSkin(getXWikiContext());\n    }\n\n    /**\n     * API to access the copyright for this space. The copyright is read in the space preferences. If it does not exist\n     * or is empty it is read from the XWiki preferences.\n     *\n     * @return the text for the copyright\n     */\n    public String getSpaceCopyright()\n    {\n        return this.xwiki.getSpaceCopyright(getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getXWikiPreference(String preference)\n    {\n        return this.xwiki.getXWikiPreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale\n     */\n    public String getXWikiPreference(String preference, String defaultValue)\n    {\n        return this.xwiki.getXWikiPreference(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an Space Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale If no preference is found it will look in the XWiki\n     * Preferences\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getSpacePreference(String preference)\n    {\n        return this.xwiki.getSpacePreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access an Space Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale If no preference is found it will look in the XWiki\n     * Preferences\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale\n     */\n    public String getSpacePreference(String preference, String defaultValue)\n    {\n        return this.xwiki.getSpacePreference(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access a Skin Preference The skin object is the current user's skin\n     *\n     * @param preference Preference name\n     * @return The preference for the current skin\n     */\n    public String getSkinPreference(String preference)\n    {\n        return this.xwiki.getSkinPreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a Skin Preference The skin object is the current user's skin\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for the current skin\n     */\n    public String getSkinPreference(String preference, String defaultValue)\n    {\n        return this.xwiki.getSkinPreference(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then empty String is returned.\n     *\n     * @param preference Preference name\n     * @param space The space for which this preference is requested\n     * @return The preference for this wiki and the current locale\n     */\n    public String getSpacePreferenceFor(String preference, String space)\n    {\n        return getSpacePreferenceFor(preference, space, \"\");\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then <code>defaultValue</code> is returned.\n     *\n     * @param preference Preference name\n     * @param space The space for which this preference is requested\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public String getSpacePreferenceFor(String preference, String space, String defaultValue)\n    {\n        return this.xwiki.getSpacePreference(preference, space, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then empty String is returned.\n     * \n     * @param preference the name of the preference key\n     * @param spaceReference the reference of the space\n     * @return the value of the preference or empty String if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreferenceFor(String preference, SpaceReference spaceReference)\n    {\n        return this.xwiki.getSpacePreference(preference, spaceReference, getXWikiContext());\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then <code>defaultValue</code> is returned.\n     * \n     * @param preference the name of the preference key\n     * @param spaceReference the reference of the space\n     * @param defaultValue the value to return if the preference can't be found\n     * @return the value of the preference or <code>defaultValue</code> if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreferenceFor(String preference, SpaceReference spaceReference, String defaultValue)\n    {\n        return this.xwiki.getSpacePreference(preference, spaceReference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getXWikiPreferenceAsLong(String preference, long defaultValue)\n    {\n        return this.xwiki.getXWikiPreferenceAsLong(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getXWikiPreferenceAsLong(String preference)\n    {\n        return this.xwiki.getXWikiPreferenceAsLong(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a Space Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale If no preference is found it will\n     * look for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the prefenrece does not exist or is empty\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getSpacePreferenceAsLong(String preference, long defaultValue)\n    {\n        return this.xwiki.getSpacePreferenceAsLong(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access a Space Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale If no preference is found it will\n     * look for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getSpacePreferenceAsLong(String preference)\n    {\n        return this.xwiki.getSpacePreferenceAsLong(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as an int number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the prefenrece does not exist or is empty\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getXWikiPreferenceAsInt(String preference, int defaultValue)\n    {\n        return this.xwiki.getXWikiPreferenceAsInt(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as a int number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getXWikiPreferenceAsInt(String preference)\n    {\n        return this.xwiki.getXWikiPreferenceAsInt(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a space Preference as a int number There can be one preference object per locale This function will\n     * find the right preference object associated to the current active locale If no preference is found it will look\n     * for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the prefenrece does not exist or is empty\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getSpacePreferenceAsInt(String preference, int defaultValue)\n    {\n        return this.xwiki.getSpacePreferenceAsInt(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access a Space Preference as a int number There can be one preference object per locale This function will\n     * find the right preference object associated to the current active locale If no preference is found it will look\n     * for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getSpacePreferenceAsInt(String preference)\n    {\n        return this.xwiki.getSpacePreferenceAsInt(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a User Preference This function will look in the User profile for the preference If no preference\n     * is found it will look in the Space Preferences If no preference is found it will look in the XWiki Preferences\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getUserPreference(String preference)\n    {\n        return this.xwiki.getUserPreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a User Preference from cookie This function will look in the session cookie for the preference\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getUserPreferenceFromCookie(String preference)\n    {\n        return this.xwiki.getUserPreferenceFromCookie(preference, getXWikiContext());\n    }\n\n    /**\n     * Same as {@link #getLocalePreference()} but as a String.\n     *\n     * @return the locale to use\n     * @deprecated since 8.0M1, use {@link #getLocalePreference()} instead\n     */\n    @Deprecated\n    public String getLanguagePreference()\n    {\n        return this.xwiki.getLanguagePreference(getXWikiContext());\n    }\n\n    /**\n     * First try to find the current locale in use from the XWiki context. If none is used and if the wiki is not\n     * multilingual use the default locale defined in the XWiki preferences. If the wiki is multilingual try to get the\n     * locale passed in the request. If none was passed try to get it from a cookie. If no locale cookie exists then use\n     * the user default locale and barring that use the browser's \"Accept-Language\" header sent in HTTP request. If none\n     * is defined use the default locale.\n     *\n     * @return the locale to use\n     * @since 8.0M1\n     */\n    public Locale getLocalePreference()\n    {\n        return this.xwiki.getLocalePreference(getXWikiContext());\n    }\n\n    /**\n     * Same as {@link #getInterfaceLocalePreference()} but as a String.\n     *\n     * @return the document locale preference for the request\n     * @deprecated since 8.0M1, use {@link #getInterfaceLocalePreference()} instead\n     */\n    @Deprecated\n    public String getInterfaceLanguagePreference()\n    {\n        return this.xwiki.getInterfaceLanguagePreference(getXWikiContext());\n    }\n\n    /**\n     * API to access the interface locale preference for the request Order of evaluation is: locale of the wiki in\n     * mono-lingual mode locale request parameter locale in context locale user preference locale in cookie locale\n     * accepted by the navigator\n     *\n     * @return the document locale preference for the request\n     */\n    public Locale getInterfaceLocalePreference()\n    {\n        return this.xwiki.getInterfaceLocalePreference(getXWikiContext());\n    }\n\n    /**\n     * Get the available locales according to the preferences.\n     *\n     * @return the list of available locales\n     * @since 12.4RC1\n     */\n    @Unstable\n    public List<Locale> getAvailableLocales()\n    {\n        return this.xwiki.getAvailableLocales(getXWikiContext());\n    }\n\n    /**\n     * @return the list of all wiki names, including the main wiki, corresponding to the available wiki descriptors.\n     *         Example: the descriptor for the wiki <i>wikiname</i> is a document in the main wiki, named\n     *         <i>XWiki.XWikiServerWikiname</i>, containing an XWiki.XWikiServerClass object.\n     * @see com.xpn.xwiki.XWiki#getVirtualWikisDatabaseNames(XWikiContext)\n     */\n    public List<String> getWikiNames()\n    {\n        List<String> result = new ArrayList<String>();\n\n        try {\n            result = this.xwiki.getVirtualWikisDatabaseNames(getXWikiContext());\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to get the list of all wiki names\", e);\n        }\n\n        return result;\n    }\n\n    /**\n     * Convenience method to ask if the current XWiki instance contains subwikis (in addition to the main wiki)\n     *\n     * @return true if at least 1 subwiki exists; false otherwise\n     * @see #getWikiNames()\n     */\n    public boolean hasSubWikis()\n    {\n        return getWikiNames().size() > 1;\n    }\n\n    /**\n     * API to check is wiki is multi-lingual\n     *\n     * @return true for multi-lingual/false for mono-lingual\n     */\n    public boolean isMultiLingual()\n    {\n        return this.xwiki.isMultiLingual(getXWikiContext());\n    }\n\n    /**\n     * Privileged API to flush the cache of the Wiki installation This flushed the cache of all wikis, all plugins, all\n     * renderers\n     */\n    public void flushCache()\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.flushCache(getXWikiContext());\n        }\n    }\n\n    /**\n     * Privileged API to create a new user from the request This API is used by RegisterNewUser wiki page\n     *\n     * @return the integer status code\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-2: passwords are different or password is empty</li>\n     *         <li>-3: user already exists</li>\n     *         <li>-4: invalid username provided</li>\n     *         <li>-8: user already exists</li>\n     *         </ul>\n     * @throws XWikiException\n     */\n    public int createUser() throws XWikiException\n    {\n        return createUser(false, \"edit\");\n    }\n\n    /**\n     * Privileged API to create a new user from the request This API is used by RegisterNewUser wiki page This version\n     * sends a validation email to the user Configuration of validation email is in the XWiki Preferences\n     *\n     * @param withValidation true to send the validationemail\n     * @return the integer status code\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-2: passwords are different or password is empty</li>\n     *         <li>-3: user already exists</li>\n     *         <li>-4: invalid username provided</li>\n     *         <li>-8: user already exists</li>\n     *         </ul>\n     * @throws XWikiException\n     */\n    public int createUser(boolean withValidation) throws XWikiException\n    {\n        return createUser(withValidation, \"edit\");\n    }\n\n    /**\n     * Privileged API to create a new user from the request.\n     * <p>\n     * This API is used by the RegisterNewUser wiki page.\n     * <p>\n     * This version sends a validation email to the user. Configuration of validation email is in the XWiki Preferences.\n     *\n     * @param withValidation true to send the validation email\n     * @param userRights Rights to set for the user for it's own page(defaults to \"edit\")\n     * @return the integer status code\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-2: passwords are different or password is empty</li>\n     *         <li>-3: user already exists</li>\n     *         <li>-4: invalid username provided</li>\n     *         <li>-8: user already exists</li>\n     *         </ul>\n     * @throws XWikiException\n     */\n    public int createUser(boolean withValidation, String userRights) throws XWikiException\n    {\n        boolean registerRight;\n        try {\n            // So, what's the register right for? This says that if the creator of the page\n            // (Admin) has programming rights, anybody can register. Is this OK?\n            if (hasProgrammingRights()) {\n                registerRight = true;\n            } else {\n                registerRight = this.xwiki.getRightService().hasAccessLevel(\"register\", getXWikiContext().getUser(),\n                    \"XWiki.XWikiPreferences\", getXWikiContext());\n            }\n\n            if (registerRight) {\n                return this.xwiki.createUser(withValidation, userRights, getXWikiContext());\n            }\n\n            return -1;\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to create user\", e);\n\n            return -10;\n        }\n\n    }\n\n    /**\n     * Privileged API to validate the return code given by a user in response to an email validation email The\n     * validation information are taken from the request object\n     *\n     * @param withConfirmEmail true to send a account confirmation email/false to not send it\n     * @return Success of Failure code (0 for success, -1 for missing programming rights, &gt; 0 for other errors\n     * @throws XWikiException\n     */\n    public int validateUser(boolean withConfirmEmail) throws XWikiException\n    {\n        return this.xwiki.validateUser(withConfirmEmail, getXWikiContext());\n    }\n\n    /**\n     * Privileged API to add a user to the XWiki.XWikiAllGroup\n     *\n     * @param fullwikiname user name to add\n     * @throws XWikiException\n     */\n    public void addToAllGroup(String fullwikiname) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.setUserDefaultGroup(fullwikiname, getXWikiContext());\n        }\n    }\n\n    /**\n     * Privileged API to send a confirmation email to a user\n     *\n     * @param xwikiname user to send the email to\n     * @param password password to put in the mail\n     * @param email email to send to\n     * @param add_message Additional message to send to the user\n     * @param contentfield Preference field to use as a mail template\n     * @throws XWikiException if the mail was not send successfully\n     */\n    public void sendConfirmationMail(String xwikiname, String password, String email, String add_message,\n        String contentfield) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.sendConfirmationEmail(xwikiname, password, email, add_message, contentfield, getXWikiContext());\n        }\n    }\n\n    /**\n     * Privileged API to send a confirmation email to a user\n     *\n     * @param xwikiname user to send the email to\n     * @param password password to put in the mail\n     * @param email email to send to\n     * @param contentfield Preference field to use as a mail template\n     * @throws XWikiException if the mail was not send successfully\n     */\n    public void sendConfirmationMail(String xwikiname, String password, String email, String contentfield)\n        throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.sendConfirmationEmail(xwikiname, password, email, \"\", contentfield, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to rename a document to another document.\n     * Note that the list of backlinks can be retrieved with {@link Document#getBackLinkedReferences()}\n     * and the list of children with {@link Document#getChildrenReferences()}.\n     *\n     * <strong>Warning:</strong> Be aware that this method never triggers any event related to the rename\n     * of the document. If you want the right events to be sent for the event, please use the dedicated Refactoring\n     * Module API (see\n     * {@link org.xwiki.refactoring.script.RequestFactory#createRenameRequest(EntityReference, EntityReference)}\n     * and {@link org.xwiki.refactoring.job.MoveRequest}).\n     *\n     * @param sourceDocumentReference the source document to rename.\n     * @param targetDocumentReference the target reference to rename the document to.\n     * @param overwrite if {@code true} the target document reference will be overwritten if it exists\n     *                  (deleted to the recycle bin before the rename). If {@code false} and the target document exist\n     *                  the rename won't be performed.\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *                                  modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *                                 document reference\n     * @return {@code true} if the rename succeeded. {@code false} if there was any issue.\n     * @throws XWikiException if the document cannot be renamed properly.\n     * @since 12.5RC1\n     */\n    @Unstable\n    public boolean renameDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean overwrite, List<DocumentReference> backlinkDocumentReferences,\n        List<DocumentReference> childDocumentReferences) throws XWikiException\n    {\n        if (hasAccess(Right.DELETE, sourceDocumentReference)\n            && ((overwrite && hasAccess(Right.DELETE, targetDocumentReference))\n            || (!overwrite && hasAccess(Right.EDIT, targetDocumentReference)))) {\n            return this.xwiki.renameDocument(sourceDocumentReference, targetDocumentReference, overwrite,\n                backlinkDocumentReferences, childDocumentReferences, getXWikiContext());\n        }\n        return false;\n    }\n\n    /**\n     * API to copy a document to another document in the same wiki\n     *\n     * @param docname source document\n     * @param targetdocname target document\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname) throws XWikiException\n    {\n        return this.copyDocument(docname, targetdocname, null, null, null, false, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document in the same wiki\n     *\n     * @param docname source document\n     * @param targetdocname target document\n     * @param wikilocale locale to copy\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname, String wikilocale) throws XWikiException\n    {\n        return this.copyDocument(docname, targetdocname, null, null, wikilocale, false, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki\n     *\n     * @param docname source document\n     * @param sourceWiki source wiki\n     * @param targetWiki target wiki\n     * @param wikilocale locale to copy\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String sourceWiki, String targetWiki, String wikilocale)\n        throws XWikiException\n    {\n        return this.copyDocument(docname, docname, sourceWiki, targetWiki, wikilocale, true, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki additionally\n     * resetting the version\n     *\n     * @param docname source document\n     * @param sourceWiki source wiki\n     * @param targetWiki target wiki\n     * @param wikilocale locale to copy\n     * @param reset true to reset versions\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname, String sourceWiki, String targetWiki,\n        String wikilocale, boolean reset) throws XWikiException\n    {\n        return this.copyDocument(docname, targetdocname, sourceWiki, targetWiki, wikilocale, reset, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki additionally\n     * resetting the version and overwriting the previous document\n     *\n     * @param docname source document name\n     * @param targetdocname target document name\n     * @param sourceWiki source wiki\n     * @param targetWiki target wiki\n     * @param wikilocale locale to copy\n     * @param reset true to reset versions\n     * @param force true to overwrite the previous document\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname, String sourceWiki, String targetWiki,\n        String wikilocale, boolean reset, boolean force) throws XWikiException\n    {\n        DocumentReference sourceDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);\n        if (!StringUtils.isEmpty(sourceWiki)) {\n            sourceDocumentReference = sourceDocumentReference.replaceParent(sourceDocumentReference.getWikiReference(),\n                new WikiReference(sourceWiki));\n        }\n\n        DocumentReference targetDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(targetdocname);\n        if (!StringUtils.isEmpty(targetWiki)) {\n            targetDocumentReference = targetDocumentReference.replaceParent(targetDocumentReference.getWikiReference(),\n                new WikiReference(targetWiki));\n        }\n\n        return this.copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, force);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki additionally\n     * resetting the version and overwriting the previous document\n     *\n     * @param sourceDocumentReference the reference to the document to copy\n     * @param targetDocumentReference the reference to the document to create\n     * @param wikilocale locale to copy\n     * @param resetHistory {@code true} to reset versions\n     * @param overwrite {@code true} to overwrite the previous document\n     * @return {@code true} if the copy was sucessful\n     * @throws XWikiException if the document was not copied properly\n     * @since 3.0M3\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean resetHistory, boolean overwrite) throws XWikiException\n    {\n        // In order to copy the source document the user must have at least the right to view it.\n        if (hasAccessLevel(\"view\", getDefaultStringEntityReferenceSerializer().serialize(sourceDocumentReference))) {\n            String targetDocStringRef = getDefaultStringEntityReferenceSerializer().serialize(targetDocumentReference);\n            // To create the target document the user must have edit rights. If the target document exists and the user\n            // wants to overwrite it then he needs delete right.\n            // Note: We have to check if the target document exists before checking the delete right because delete\n            // right is denied if not explicitly specified.\n            if (hasAccessLevel(\"edit\", targetDocStringRef)\n                && (!overwrite || !exists(targetDocumentReference) || hasAccessLevel(\"delete\", targetDocStringRef))) {\n                // Reset creation data otherwise the required rights for page copy need to be reconsidered.\n                return this.xwiki.copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale,\n                    resetHistory, overwrite, true, getXWikiContext());\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Privileged API to copy a space to another wiki, optionally deleting all document of the target space\n     *\n     * @param space source Space\n     * @param sourceWiki source Wiki\n     * @param targetWiki target Wiki\n     * @param locale locale to copy\n     * @param clean true to delete all document of the target space\n     * @return number of copied documents\n     * @throws XWikiException if the space was not copied properly\n     */\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale, boolean clean)\n        throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.copySpaceBetweenWikis(space, sourceWiki, targetWiki, locale, clean, getXWikiContext());\n        }\n\n        return -1;\n    }\n\n    /**\n     * API to include a topic into another The topic is rendered fully in the context of itself\n     *\n     * @param topic page name of the topic to include\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeTopic(String topic) throws XWikiException\n    {\n        return includeTopic(topic, true);\n    }\n\n    /**\n     * API to execute a form in the context of an including topic The rendering is evaluated in the context of the\n     * including topic All velocity variables are the one of the including topic This api is usually called using\n     * #includeForm in a page, which modifies the behavior of \"Edit this page\" button to direct for Form mode (inline)\n     *\n     * @param topic page name of the form to execute\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeForm(String topic) throws XWikiException\n    {\n        return includeForm(topic, true);\n    }\n\n    /**\n     * API to include a topic into another, optionally surrounding the content with {pre}{/pre} to avoid future wiki\n     * rendering. The topic is rendered fully in the context of itself.\n     *\n     * @param topic page name of the topic to include\n     * @param pre true to add {pre} {/pre} (only if includer document is 1.0 syntax)\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeTopic(String topic, boolean pre) throws XWikiException\n    {\n        String result = this.xwiki.include(topic, false, getXWikiContext());\n\n        if (pre) {\n            String includerSyntax = this.xwiki.getCurrentContentSyntaxId(null, this.context);\n\n            if (includerSyntax != null && Syntax.XWIKI_1_0.toIdString().equals(includerSyntax)) {\n                result = \"{pre}\" + result + \"{/pre}\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * API to execute a form in the context of an including topic, optionnaly surrounding the content with {pre}{/pre}\n     * to avoid future wiki rendering The rendering is evaluated in the context of the including topic All velocity\n     * variables are the one of the including topic This api is usually called using #includeForm in a page, which\n     * modifies the behavior of \"Edit this page\" button to direct for Form mode (inline).\n     *\n     * @param topic page name of the form to execute\n     * @param pre true to add {pre} {/pre} (only if includer document is 1.0 syntax)\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeForm(String topic, boolean pre) throws XWikiException\n    {\n        String result = this.xwiki.include(topic, true, getXWikiContext());\n\n        if (pre) {\n            String includerSyntax = this.xwiki.getCurrentContentSyntaxId(null, this.context);\n\n            if (includerSyntax != null && Syntax.XWIKI_1_0.toIdString().equals(includerSyntax)) {\n                result = \"{pre}\" + result + \"{/pre}\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * API to check rights on the current document for the current user\n     *\n     * @param level right to check (view, edit, comment, delete)\n     * @return true if right is granted/false if not\n     */\n    public boolean hasAccessLevel(String level)\n    {\n        return hasAccessLevel(level, getXWikiContext().getUser(), getXWikiContext().getDoc().getFullName());\n    }\n\n    /**\n     * API to check rights on a document for a given user\n     *\n     * @param level right to check (view, edit, comment, delete)\n     * @param user user for which to check the right\n     * @param docname document on which to check the rights\n     * @return true if right is granted/false if not\n     */\n    public boolean hasAccessLevel(String level, String user, String docname)\n    {\n        try {\n            return this.xwiki.getRightService().hasAccessLevel(level, user, docname, getXWikiContext());\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    /**\n     * API to list all spaces in the current wiki.\n     * <p>\n     * Hidden spaces are filtered unless current user enabled them.\n     *\n     * @return a list of string representing all non-hidden spaces (ie spaces that have non-hidden pages) for the\n     *         current wiki\n     * @throws XWikiException if something went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaces() throws XWikiException\n    {\n        return this.xwiki.getSpaces(getXWikiContext());\n    }\n\n    /**\n     * API to list all documents in a space.\n     * <p>\n     * Hidden spaces are filtered unless current user enabled them.\n     *\n     * @param spaceReference the local reference of the space for which to return all non-hidden documents\n     * @return the list of document names (in the format {@code Space.Page}) for non-hidden documents in the specified\n     *         space\n     * @throws XWikiException if the loading went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaceDocsName(String spaceReference) throws XWikiException\n    {\n        return this.xwiki.getSpaceDocsName(spaceReference, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the current encoding of the wiki engine The encoding is stored in xwiki.cfg Default encoding is\n     * ISO-8891-1\n     *\n     * @return encoding active in this wiki\n     */\n    public String getEncoding()\n    {\n        return this.xwiki.getEncoding();\n    }\n\n    /**\n     * API to retrieve the URL of an attached file in a Wiki Document The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment) It\n     * is important to always use the URL functions to generate URL and never hardcode URLs\n     *\n     * @param fullname page name which includes the attached file\n     * @param filename attached filename to create a link for\n     * @return a URL as a string pointing to the filename\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getAttachmentURL(String fullname, String filename) throws XWikiException\n    {\n        if (StringUtils.isAnyEmpty(fullname, filename)) {\n            return \"\";\n        }\n\n        return this.xwiki.getAttachmentURL(fullname, filename, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in view mode The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment) It\n     * is important to always use the URL functions to generate URL and never hardcode URLs\n     *\n     * @param fullname the name of the document for which to return the URL for\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, \"view\", getXWikiContext());\n    }\n\n    /**\n     * Retrieve the URL of an entity using the default mode/action for that entity type. The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..). The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. For compatibility with any target environment (and especially the\n     * portlet environment) it is important to always use the URL functions to generate URLs and never hardcode URLs.\n     *\n     * @param reference the reference to the entity for which to return the URL\n     * @return a URL as a string pointing to the specified entity, using the default mode/action for that entity type\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference reference) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an entity in any mode, optionally adding a query string The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The query string will be modified to be added in the way the\n     * environment needs it. It is important to not add the query string parameter manually after a URL. Some\n     * environments will not accept this (like the Portlet environment).\n     *\n     * @param reference the reference to the entity for which to return the URL for\n     * @param action the mode in which to access the entity (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @return a URL as a string pointing to the entity\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference reference, String action, String querystring) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, action, querystring, null, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in view mode The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment) It\n     * is important to always use the URL functions to generate URL and never hardcode URLs\n     *\n     * @param reference the reference to the document for which to return the URL for\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 2.3M2\n     */\n    public String getURL(DocumentReference reference) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, \"view\", getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in any mode. The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..). The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment). It\n     * is important to always use the URL functions to generate URL and never hardcode URLs.\n     *\n     * @param fullname the page name which includes the attached file\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible.\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname, String action) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, action, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of a Wiki Document in any mode, optionally adding a query string The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The query string will be modified to be added in the way the\n     * environment needs it. It is important to not add the query string parameter manually after a URL. Some\n     * environments will not accept this (like the Portlet environment).\n     *\n     * @param fullname the page name which includes the attached file\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname, String action, String querystring) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, action, querystring, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of a Wiki Document in any mode, optionally adding a query string The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The query string will be modified to be added in the way the\n     * environment needs it. It is important to not add the query string parameter manually after a URL. Some\n     * environments will not accept this (like the Portlet environment).\n     *\n     * @param reference the reference to the document for which to return the URL for\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 3.0M3\n     */\n    public String getURL(DocumentReference reference, String action, String querystring) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, action, querystring, null, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in any mode, optionally adding an anchor. The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The anchor will be modified to be added in the way the environment\n     * needs it. It is important to not add the anchor parameter manually after a URL. Some environments will not accept\n     * this (like the Portlet environment).\n     *\n     * @param fullname the page name which includes the attached file\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @param anchor the anchor that points at a location within the passed document name\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname, String action, String querystring, String anchor) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, action, querystring, anchor, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a viewable referer text for a referer Referers are URL where users have clicked on a link to an\n     * XWiki page Search engine referer URLs are transformed to a nicer view (Google: search query string) For other URL\n     * the http:// part is stripped\n     *\n     * @param referer referer URL to transform\n     * @return A viewable string\n     */\n    public String getRefererText(String referer)\n    {\n        try {\n            return this.xwiki.getRefererText(referer, getXWikiContext());\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * API to retrieve a viewable referer text for a referer with a maximum length Referers are URL where users have\n     * clicked on a link to an XWiki page Search engine referer URLs are transformed to a nicer view (Google: search\n     * query string) For other URL the http:// part is stripped\n     *\n     * @param referer referer URL to transform\n     * @param length Maximum length. \"...\" is added to the end of the text\n     * @return A viewable string\n     */\n    public String getShortRefererText(String referer, int length)\n    {\n        try {\n            return this.xwiki.getRefererText(referer, getXWikiContext()).substring(0, length);\n        } catch (Exception e) {\n            return this.xwiki.getRefererText(referer, getXWikiContext());\n        }\n    }\n\n    /**\n     * Generate and return an unescaped user display name.\n     *\n     * @param userReference the user reference\n     * @return the unescaped display user name\n     * @since 6.4RC1\n     */\n    public String getPlainUserName(DocumentReference userReference)\n    {\n        return this.xwiki.getPlainUserName(userReference, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed for the first name and last name of the user. The link\n     * will link to the page on the wiki where the user is registered\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user)\n    {\n        return this.xwiki.getUserName(user, null, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed with a custom view. The link will link to the page on the\n     * wiki where the user is registered. The formating is done using the format parameter which can contain velocity\n     * scripting and access all properties of the User profile using variables ($first_name $last_name $email $city)\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user, String format)\n    {\n        return this.xwiki.getUserName(user, format, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed for the first name and last name of the user. The link\n     * will link to the page on the local wiki even if the user is registered on a different wiki.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), null, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, null, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed with a custom view. The link will link to the page on the\n     * local wiki even if the user is registered on a different wiki. The formating is done using the format parameter\n     * which can contain velocity scripting and access all properties of the User profile using variables ($first_name\n     * $last_name $email $city)\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user, String format)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), format, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, format, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to retrieve a text representing the user with the first name and last name of the user. With the link param\n     * set to false it will not link to the user page With the link param set to true, the link will link to the page on\n     * the wiki where the user was registered.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user, boolean link)\n    {\n        return this.xwiki.getUserName(user, null, link, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a text representing the user with a custom view With the link param set to false it will not link\n     * to the user page. With the link param set to true, the link will link to the page on the wiki where the user was\n     * registered. The formating is done using the format parameter which can contain velocity scripting and access all\n     * properties of the User profile using variables ($first_name $last_name $email $city)\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user, String format, boolean link)\n    {\n        return this.xwiki.getUserName(user, format, link, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a text representing the user with the first name and last name of the user. With the link param\n     * set to false it will not link to the user page. With the link param set to true, the link will link to the page\n     * on the local wiki even if the user is registered on a different wiki.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user, boolean link)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), null, link, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, null, link, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to retrieve a text representing the user with a custom view. The formating is done using the format parameter\n     * which can contain velocity scripting and access all properties of the User profile using variables ($first_name\n     * $last_name $email $city). With the link param set to false it will not link to the user page. With the link param\n     * set to true, the link will link to the page on the local wiki even if the user is registered on a different wiki.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user, String format, boolean link)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), format, link, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, format, link, getXWikiContext());\n        }\n    }\n\n    public User getUser()\n    {\n        return this.xwiki.getUser(getXWikiContext());\n    }\n\n    public User getUser(String username)\n    {\n        return this.xwiki.getUser(username, getXWikiContext());\n    }\n\n    /**\n     * Retrieve a user from its document reference.\n     *\n     * @param userReference the reference of the user.\n     * @return the user corresponding to the reference.\n     * @since 11.8RC1\n     */\n    public User getUser(DocumentReference userReference)\n    {\n        return this.xwiki.getUser(userReference, getXWikiContext());\n    }\n\n    /**\n     * API allowing to format a date according to the default Wiki setting The date format is provided in the\n     * 'dateformat' parameter of the XWiki Preferences\n     *\n     * @param date date object to format\n     * @return A string with the date formating from the default Wiki setting\n     */\n    public String formatDate(Date date)\n    {\n        return this.xwiki.formatDate(date, null, getXWikiContext());\n    }\n\n    /**\n     * API allowing to format a date according to a custom format The date format is from java.text.SimpleDateFormat\n     * Example: \"dd/MM/yyyy HH:mm:ss\" or \"d MMM yyyy\" If the format is invalid the default format will be used to show\n     * the date\n     *\n     * @param date date to format\n     * @param format format of the date to be used\n     * @return the formatted date\n     * @see java.text.SimpleDateFormat\n     */\n    public String formatDate(Date date, String format)\n    {\n        return this.xwiki.formatDate(date, format, getXWikiContext());\n    }\n\n    /*\n     * Allow to read user setting providing the user timezone All dates will be expressed with this timezone @return the\n     * timezone\n     */\n    public String getUserTimeZone()\n    {\n        return this.xwiki.getUserTimeZone(this.context);\n    }\n\n    /**\n     * Returns a plugin from the plugin API. Plugin Rights can be verified. Note that although this API is a duplicate\n     * of {@link #getPlugin(String)} it used to provide an easy access from Velocity to XWiki plugins. Indeed Velocity\n     * has a feature in that if a class has a get method, using the dot notation will automatically call the get method\n     * for the class. See http://velocity.apache.org/engine/releases/velocity-1.5/user-guide.html#propertylookuprules.\n     * This this allows the following constructs: <code>$xwiki.pluginName.somePluginMethod()</code>\n     *\n     * @param name Name of the plugin to retrieve (either short of full class name)\n     * @return a plugin object\n     */\n    public Api get(String name)\n    {\n        return getPlugin(name);\n    }\n\n    /**\n     * Returns a plugin from the plugin API. Plugin Rights can be verified.\n     *\n     * @param name Name of the plugin to retrieve (either short of full class name)\n     * @return a plugin object\n     */\n    public Api getPlugin(String name)\n    {\n        return this.xwiki != null ? this.xwiki.getPluginApi(name, getXWikiContext()) : null;\n    }\n\n    /**\n     * Returns the Advertisement system from the preferences\n     *\n     * @return \"google\" or \"none\"\n     */\n    public String getAdType()\n    {\n        return this.xwiki.getAdType(getXWikiContext());\n    }\n\n    /**\n     * Returns the Advertisement client ID from the preferences\n     *\n     * @return an Ad affiliate ID\n     */\n    public String getAdClientId()\n    {\n        return this.xwiki.getAdClientId(getXWikiContext());\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL protected using Basic Authentication\n     *\n     * @param surl url to retrieve\n     * @param username username for the basic authentication\n     * @param password password for the basic authentication\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl, String username, String password) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, username, password, this.context);\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to retrieve content from [\" + surl + \"]\", e);\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL\n     *\n     * @param surl url to retrieve\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, this.context);\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to retrieve content from [\" + surl + \"]\", e);\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL protected using Basic Authentication\n     *\n     * @param surl url to retrieve\n     * @param username username for the basic authentication\n     * @param password password for the basic authentication\n     * @param timeout manuel timeout in milliseconds\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl, String username, String password, int timeout) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, username, password, timeout,\n                this.xwiki.getHttpUserAgent(this.context));\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL\n     *\n     * @param surl url to retrieve\n     * @param timeout manuel timeout in milliseconds\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl, int timeout) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, timeout, this.xwiki.getHttpUserAgent(this.context));\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL protected using Basic Authentication as Bytes\n     *\n     * @param surl url to retrieve\n     * @param username username for the basic authentication\n     * @param password password for the basic authentication\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public byte[] getURLContentAsBytes(String surl, String username, String password) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return null;\n        }\n\n        try {\n            return this.xwiki.getURLContentAsBytes(surl, username, password, this.context);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL as Bytes\n     *\n     * @param surl url to retrieve\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public byte[] getURLContentAsBytes(String surl) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return null;\n        }\n\n        try {\n            return this.xwiki.getURLContentAsBytes(surl, this.context);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the list of Macros documents in the specified content\n     *\n     * @param defaultSpace Default space to use for relative path names\n     * @param content Content to parse\n     * @return ArrayList of document names\n     */\n    public List<String> getIncludedMacros(String defaultSpace, String content)\n    {\n        return this.xwiki.getIncludedMacros(defaultSpace, content, getXWikiContext());\n    }\n\n    /**\n     * returns true if xwiki.readonly is set in the configuration file\n     *\n     * @return the value of xwiki.isReadOnly()\n     * @see com.xpn.xwiki.XWiki\n     */\n    public boolean isReadOnly()\n    {\n        return this.xwiki.isReadOnly();\n    }\n\n    /**\n     * Privileged API to set/unset the readonly status of the Wiki After setting this to true no writing to the database\n     * will be performed All Edit buttons will be removed and save actions disabled This is used for maintenance\n     * purposes\n     *\n     * @param ro true to set read-only mode/false to unset\n     */\n    public void setReadOnly(boolean ro)\n    {\n        if (hasAdminRights()) {\n            this.xwiki.setReadOnly(ro);\n        }\n    }\n\n    /**\n     * Priviledge API to regenerate the links/backlinks table Normally links and backlinks are stored when a page is\n     * modified This function will regenerate all the backlinks This function can be long to run\n     *\n     * @throws XWikiException exception if the generation fails\n     */\n    public void refreshLinks() throws XWikiException\n    {\n        if (hasAdminRights()) {\n            this.xwiki.refreshLinks(getXWikiContext());\n        }\n    }\n\n    /**\n     * API to check if the backlinks feature is active Backlinks are activated in xwiki.cfg or in the XWiki Preferences\n     *\n     * @return true if the backlinks feature is active\n     * @throws XWikiException exception if the preference could not be retrieved\n     */\n    public boolean hasBacklinks() throws XWikiException\n    {\n        return this.xwiki.hasBacklinks(getXWikiContext());\n    }\n\n    /**\n     * API to check if the tags feature is active. Tags are activated in xwiki.cfg or in the XWiki Preferences\n     *\n     * @return true if the tags feature is active, false otherwise\n     * @throws XWikiException exception if the preference could not be retrieved\n     */\n    public boolean hasTags() throws XWikiException\n    {\n        return this.xwiki.hasTags(getXWikiContext());\n    }\n\n    /**\n     * API to check if the edit comment feature is active Edit comments are activated in xwiki.cfg or in the XWiki\n     * Preferences\n     *\n     * @return\n     */\n    public boolean hasEditComment()\n    {\n        return this.xwiki.hasEditComment(this.context);\n    }\n\n    /**\n     * API to check if the edit comment field is shown in the edit form Edit comments are activated in xwiki.cfg or in\n     * the XWiki Preferences\n     *\n     * @return\n     */\n    public boolean isEditCommentFieldHidden()\n    {\n        return this.xwiki.isEditCommentFieldHidden(this.context);\n    }\n\n    /**\n     * API to check if the edit comment is suggested (prompted once by Javascript if empty) Edit comments are activated\n     * in xwiki.cfg or in the XWiki Preferences\n     *\n     * @return\n     */\n    public boolean isEditCommentSuggested()\n    {\n        return this.xwiki.isEditCommentSuggested(this.context);\n    }\n\n    /**\n     * API to check if the edit comment is mandatory (prompted by Javascript if empty) Edit comments are activated in\n     * xwiki.cfg or in the XWiki Preferences\n     *\n     * @return\n     */\n    public boolean isEditCommentMandatory()\n    {\n        return this.xwiki.isEditCommentMandatory(this.context);\n    }\n\n    /**\n     * API to check if the minor edit feature is active minor edit is activated in xwiki.cfg or in the XWiki Preferences\n     */\n    public boolean hasMinorEdit()\n    {\n        return this.xwiki.hasMinorEdit(this.context);\n    }\n\n    /**\n     * API to check if the recycle bin feature is active recycle bin is activated in xwiki.cfg or in the XWiki\n     * Preferences\n     */\n    public boolean hasRecycleBin()\n    {\n        return this.xwiki.hasRecycleBin(this.context);\n    }\n\n    /**\n     * Retrieves the current editor preference for the request The preference is first looked up in the user preference\n     * and then in the space and wiki preference\n     *\n     * @return \"wysiwyg\" or \"text\"\n     */\n    public String getEditorPreference()\n    {\n        return this.xwiki.getEditorPreference(getXWikiContext());\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String. Note that Groovy scripts\n     * compilation is cached.\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public java.lang.Object parseGroovyFromString(String script) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.parseGroovyFromString(script, getXWikiContext());\n        }\n        return \"groovy_missingrights\";\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String, using a classloader including all\n     * JAR files located in the passed page as attachments. Note that Groovy scripts compilation is cached\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public java.lang.Object parseGroovyFromPage(String script, String jarWikiPage) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(script, getXWikiContext());\n        if (this.xwiki.getRightService().hasProgrammingRights(doc, getXWikiContext())) {\n            return this.xwiki.parseGroovyFromString(doc.getContent(), jarWikiPage, getXWikiContext());\n        }\n        return \"groovy_missingrights\";\n    }\n\n    /**\n     * Privileged API to retrieve an object instanciated from groovy code in a String Groovy scripts compilation is\n     * cached\n     *\n     * @param fullname // script containing a Groovy class definition (public class MyClass { ... })\n     * @return An object instanciating this class\n     * @throws XWikiException\n     */\n    public java.lang.Object parseGroovyFromPage(String fullname) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(fullname, getXWikiContext());\n        if (this.xwiki.getRightService().hasProgrammingRights(doc, getXWikiContext())) {\n            return this.xwiki.parseGroovyFromString(doc.getContent(), getXWikiContext());\n        }\n        return \"groovy_missingrights\";\n    }\n\n    /**\n     * API to get the macro list from the XWiki Preferences The macro list are the macros available from the Macro\n     * Mapping System\n     *\n     * @return String with each macro on each line\n     */\n    public String getMacroList()\n    {\n        return this.xwiki.getMacroList(getXWikiContext());\n    }\n\n    /**\n     * API to check if using which toolbars in Wysiwyg editor\n     *\n     * @return a string value\n     */\n    public String getWysiwygToolbars()\n    {\n        return this.xwiki.getWysiwygToolbars(getXWikiContext());\n    }\n\n    /**\n     * API to create an object from the request The parameters are the ones that are created from\n     * doc.display(\"field\",\"edit\") calls\n     *\n     * @param className XWiki Class Name to create the object from\n     * @return a BaseObject wrapped in an Object\n     * @throws XWikiException exception if the object could not be read\n     */\n    public com.xpn.xwiki.api.Object getObjectFromRequest(String className) throws XWikiException\n    {\n        return new com.xpn.xwiki.api.Object(this.xwiki.getObjectFromRequest(className, getXWikiContext()),\n            getXWikiContext());\n    }\n\n    /**\n     * API to create an empty document\n     *\n     * @return an XWikiDocument wrapped in a Document\n     */\n    public Document createDocument()\n    {\n        return new XWikiDocument().newDocument(getXWikiContext());\n    }\n\n    /**\n     * API to convert the username depending on the configuration The username can be converted from email to a valid\n     * XWiki page name hidding the email address The username can be then used to login and link to the right user page\n     *\n     * @param username username to use for login\n     * @return converted wiki page name for this username\n     */\n    public String convertUsername(String username)\n    {\n        return this.xwiki.convertUsername(username, getXWikiContext());\n    }\n\n    /**\n     * API to get the Property object from a class based on a property path A property path looks like\n     * XWiki.ArticleClass_fieldname\n     *\n     * @param propPath Property path\n     * @return a PropertyClass object from a BaseClass object\n     */\n    public com.xpn.xwiki.api.PropertyClass getPropertyClassFromName(String propPath)\n    {\n        return new PropertyClass(this.xwiki.getPropertyClassFromName(propPath, getXWikiContext()), getXWikiContext());\n    }\n\n    /**\n     * Generates a unique page name based on initial page name and already existing pages\n     *\n     * @param name\n     * @return a unique page name\n     */\n    public String getUniquePageName(String name)\n    {\n        return this.xwiki.getUniquePageName(name, getXWikiContext());\n    }\n\n    /**\n     * Generates a unique page name based on initial page name and already existing pages\n     *\n     * @param space\n     * @param name\n     * @return a unique page name\n     */\n    public String getUniquePageName(String space, String name)\n    {\n        return this.xwiki.getUniquePageName(space, name, getXWikiContext());\n    }\n\n    /**\n     * Inserts a tooltip using toolTip.js\n     *\n     * @param html HTML viewed\n     * @param message HTML Tooltip message\n     * @param params Parameters in Javascropt added to the tooltip config\n     * @return HTML with working tooltip\n     */\n    public String addTooltip(String html, String message, String params)\n    {\n        return this.xwiki.addTooltip(html, message, params, getXWikiContext());\n    }\n\n    /**\n     * Inserts a tooltip using toolTip.js\n     *\n     * @param html HTML viewed\n     * @param message HTML Tooltip message\n     * @return HTML with working tooltip\n     */\n    public String addTooltip(String html, String message)\n    {\n        return this.xwiki.addTooltip(html, message, getXWikiContext());\n    }\n\n    /**\n     * Inserts the tooltip Javascript\n     *\n     * @return\n     */\n    public String addTooltipJS()\n    {\n        return this.xwiki.addTooltipJS(getXWikiContext());\n    }\n\n    /*\n     * Inserts a Mandatory asterix\n     */\n    public String addMandatory()\n    {\n        return this.xwiki.addMandatory(getXWikiContext());\n    }\n\n    /**\n     * Get the XWiki Class object defined in the passed Document name.\n     * <p>\n     * Note: This method doesn't require any rights for accessing the passed Document (as opposed to the\n     * {@link com.xpn.xwiki.api.Document#getClass()} method which does require to get a Document object first. This is\n     * thus useful in cases where the calling code doesn't have the access right to the specified Document. It is safe\n     * because there are no sensitive data stored in a Class definition.\n     * </p>\n     *\n     * @param documentName the name of the document for which to get the Class object. For example\n     *            \"XWiki.XWikiPreferences\"\n     * @return the XWiki Class object defined in the passed Document name. If the passed Document name points to a\n     *         Document with no Class defined then an empty Class object is returned (i.e. a Class object with no\n     *         properties).\n     * @throws XWikiException if the passed document name doesn't point to a valid Document\n     */\n    public Class getClass(String documentName) throws XWikiException\n    {\n        // TODO: The implementation should be done in com.xpn.xwiki.XWiki as this class should\n        // delegate all implementations to that Class.\n        DocumentReference docReference = getCurrentMixedDocumentReferenceResolver().resolve(documentName);\n        return getClass(docReference);\n    }\n\n    /**\n     * Get the XWiki Class object defined in the passed Document name.\n     * <p>\n     * Note: This method doesn't require any rights for accessing the passed Document (as opposed to the\n     * {@link com.xpn.xwiki.api.Document#getClass()} method which does require to get a Document object first. This is\n     * thus useful in cases where the calling code doesn't have the access right to the specified Document. It is safe\n     * because there are no sensitive data stored in a Class definition.\n     * </p>\n     *\n     * @param docReference the reference of the document for which to get the Class object.\n     * @return the XWiki Class object defined in the passed Document reference. If the passed Document name points to a\n     *         Document with no Class defined then an empty Class object is returned (i.e. a Class object with no\n     *         properties).\n     * @throws XWikiException if the reference doesn't exist.\n     * @since 10.11.10\n     * @since 11.8RC1\n     * @since 11.3.4\n     */\n    public Class getClass(EntityReference docReference) throws XWikiException\n    {\n        return new Class(this.xwiki.getDocument(docReference, this.context).getXClass(), this.context);\n    }\n\n    /**\n     * Provides an absolute counter\n     *\n     * @param name Counter name\n     * @return String\n     */\n    public String getCounter(String name)\n    {\n        XWikiEngineContext econtext = this.context.getEngineContext();\n        Integer counter = (Integer) econtext.getAttribute(name);\n        if (counter == null) {\n            counter = 0;\n        }\n        counter = counter.intValue() + 1;\n        econtext.setAttribute(name, counter);\n\n        return counter.toString();\n    }\n\n    /**\n     * Check authentication from request and set according persitent login information If it fails user is unlogged\n     *\n     * @return null if failed, non null XWikiUser if sucess\n     * @throws XWikiException\n     */\n    public XWikiUser checkAuth() throws XWikiException\n    {\n        return this.context.getWiki().getAuthService().checkAuth(this.context);\n    }\n\n    /**\n     * Check authentication from username and password and set according persitent login information If it fails user is\n     * unlogged\n     *\n     * @param username username to check\n     * @param password password to check\n     * @param rememberme \"1\" if you want to remember the login accross navigator restart\n     * @return null if failed, non null XWikiUser if sucess\n     * @throws XWikiException\n     */\n    public XWikiUser checkAuth(String username, String password, String rememberme) throws XWikiException\n    {\n        return this.context.getWiki().getAuthService().checkAuth(username, password, rememberme, this.context);\n    }\n\n    /**\n     * Access statistics api\n     *\n     * @return a StatsService instance that can be used to retrieve different xwiki statistics\n     */\n    public StatsService getStatsService()\n    {\n        return this.statsService;\n    }\n\n    /**\n     * API to get the xwiki criteria service which allow to create various criteria : integer ranges, date periods, date\n     * intervals, etc.\n     *\n     * @return the xwiki criteria service\n     */\n    public CriteriaService getCriteriaService()\n    {\n        return this.criteriaService;\n    }\n\n    /**\n     * API to get the Servlet path for a given wiki. In mono wiki this is \"bin/\" or \"xwiki/\". In virtual mode and if\n     * <tt>xwiki.virtual.usepath</tt> is enabled in xwiki.cfg, it is \"wiki/wikiname/\".\n     *\n     * @param wikiName wiki for which to get the path\n     * @return The servlet path\n     */\n    public String getServletPath(String wikiName)\n    {\n        return this.xwiki.getServletPath(wikiName, this.context);\n    }\n\n    /**\n     * API to get the Servlet path for the current wiki. In mono wiki this is \"bin/\" or \"xwiki/\". In virtual mode and if\n     * <tt>xwiki.virtual.usepath</tt> is enabled in xwiki.cfg, it is \"wiki/wikiname/\".\n     *\n     * @return The servlet path\n     */\n    public String getServletPath()\n    {\n        return this.xwiki.getServletPath(this.context.getWikiId(), this.context);\n    }\n\n    /**\n     * API to get the webapp path for the current wiki. This usually is \"xwiki/\". It can be configured in xwiki.cfg with\n     * the config <tt>xwiki.webapppath</tt>.\n     *\n     * @return The servlet path\n     */\n    public String getWebAppPath()\n    {\n        return this.xwiki.getWebAppPath(this.context);\n    }\n\n    /**\n     * @return the syntax id of the syntax to use when creating new documents.\n     */\n    public String getDefaultDocumentSyntax()\n    {\n        return this.xwiki.getDefaultDocumentSyntax();\n    }\n\n    /**\n     * Find the corresponding available renderer syntax.\n     * <p>\n     * If <code>syntaxVersion</code> is null the last version of the available provided syntax type is returned.\n     *\n     * @param syntaxType the syntax type\n     * @param syntaxVersion the syntax version\n     * @return the available corresponding {@link Syntax}. Null if no available renderer can be found.\n     */\n    public Syntax getAvailableRendererSyntax(String syntaxType, String syntaxVersion)\n    {\n        Syntax syntax = null;\n\n        try {\n            List<PrintRendererFactory> factories =\n                Utils.getContextComponentManager().getInstanceList((Type) PrintRendererFactory.class);\n            for (PrintRendererFactory factory : factories) {\n                Syntax factorySyntax = factory.getSyntax();\n                if (syntaxVersion != null) {\n                    if (factorySyntax.getType().getId().equalsIgnoreCase(syntaxType)\n                        && factorySyntax.getVersion().equals(syntaxVersion)) {\n                        syntax = factorySyntax;\n                        break;\n                    }\n                } else {\n                    // TODO: improve version comparaison since it does not work when comparing 2.0 and 10.0 for example.\n                    // We\n                    // should have a Version which implements Comparable like we have SyntaxId in Syntax\n                    if (factorySyntax.getType().getId().equalsIgnoreCase(syntaxType)\n                        && (syntax == null || factorySyntax.getVersion().compareTo(syntax.getVersion()) > 0)) {\n                        syntax = factorySyntax;\n                    }\n                }\n            }\n        } catch (ComponentLookupException e) {\n            LOGGER.error(\"Failed to lookup available renderer syntaxes\", e);\n        }\n\n        return syntax;\n    }\n\n    /**\n     * @return true if section editing is enabled (can be configured through the {@code xwiki.section.edit}\n     *         configuration property. Defaults to 1 (=enabled) when not defined\n     */\n    public boolean hasSectionEdit()\n    {\n        return this.xwiki.hasSectionEdit(getXWikiContext());\n    }\n\n    /**\n     * @return the section depth for which section editing is available (can be configured through\n     *         {@code xwiki.section.depth} configuration property. Defaults to 2 when not defined\n     */\n    public long getSectionEditingDepth()\n    {\n        return this.xwiki.getSectionEditingDepth();\n    }\n\n    /**\n     * @return true if title handling should be using the compatibility mode or not. When the compatibility mode is\n     *         active, if the document's content first header (level 1 or level 2) matches the document's title the\n     *         first header is stripped.\n     */\n    public boolean isTitleInCompatibilityMode()\n    {\n        return this.xwiki.isTitleInCompatibilityMode();\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId()\n    {\n        return this.xwiki.getCurrentContentSyntaxId(getXWikiContext());\n    }\n}\n"], "filenames": ["xwiki-platform-core/xwiki-platform-legacy/xwiki-platform-legacy-oldcore/src/main/aspect/com/xpn/xwiki/XWikiCompatibilityAspect.aj", "xwiki-platform-core/xwiki-platform-legacy/xwiki-platform-legacy-oldcore/src/main/aspect/com/xpn/xwiki/api/XWikiCompatibilityAspect.aj", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/XWiki.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/api/XWiki.java"], "buggy_code_start_loc": [36, 1200, 69, 1011], "buggy_code_end_loc": [1390, 1200, 2598, 1023], "fixing_code_start_loc": [37, 1201, 68, 1010], "fixing_code_end_loc": [1415, 1215, 2575, 1010], "type": "CWE-862", "message": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. In affected versions any user with SCRIPT right can read any file located in the XWiki WAR (for example xwiki.cfg and xwiki.properties) through XWiki#invokeServletAndReturnAsString as `$xwiki.invokeServletAndReturnAsString(\"/WEB-INF/xwiki.cfg\")`. This issue has been patched in XWiki versions 12.10.9, 13.4.3 and 13.7-rc-1. Users are advised to update. The only workaround is to limit SCRIPT right.", "other": {"cve": {"id": "CVE-2022-23621", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-09T22:15:07.483", "lastModified": "2022-02-15T18:35:32.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. In affected versions any user with SCRIPT right can read any file located in the XWiki WAR (for example xwiki.cfg and xwiki.properties) through XWiki#invokeServletAndReturnAsString as `$xwiki.invokeServletAndReturnAsString(\"/WEB-INF/xwiki.cfg\")`. This issue has been patched in XWiki versions 12.10.9, 13.4.3 and 13.7-rc-1. Users are advised to update. The only workaround is to limit SCRIPT right."}, {"lang": "es", "value": "XWiki Platform es una plataforma wiki gen\u00e9rica que ofrece servicios de ejecuci\u00f3n para las aplicaciones construidas sobre ella. En las versiones afectadas cualquier usuario con derecho SCRIPT puede leer cualquier archivo ubicado en el WAR de XWiki (por ejemplo xwiki.cfg y xwiki.properties) mediante XWiki#invokeServletAndReturnAsString como \"$xwiki.invokeServletAndReturnAsString(\"/WEB-INF/xwiki.cfg\")\". Este problema ha sido parcheado en las versiones 12.10.9, 13.4.3 y 13.7-rc-1 de XWiki. Es recomendado a usuarios que actualicen. La \u00fanica medida de mitigaci\u00f3n es limitar el derecho de SCRIPT"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionEndExcluding": "12.10.9", "matchCriteriaId": "390C3DA8-0413-4DE4-B69C-7DC25E25F8BA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.4", "versionEndExcluding": "13.4.3", "matchCriteriaId": "13E0E735-F39F-4F98-8612-007CD6D9A136"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.4.4", "versionEndIncluding": "13.7", "matchCriteriaId": "455C7FEA-F746-49EC-86E7-3232B9EC2E0F"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/df8bd49b5a4d87a427002c6535fb5b1746ff117a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-2jhm-qp48-hv5j", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-18870", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/df8bd49b5a4d87a427002c6535fb5b1746ff117a"}}