{"buggy_code": ["# Development requirements\npip-check-reqs==2.1.1\nsetuptools==53.0.0\npytest==6.2.2\nflake8==3.8.4\nflake8-docstrings==1.5.0\nflake8-import-order==0.18.1\nflake8-unused-arguments==0.0.6\nflake8-sfs==0.0.3\nflake8-builtins==1.5.3\nflake8-commas==2.0.0\nflake8-comprehensions==3.3.1\nflake8-eradicate==1.0.0\nflake8-fixme==1.1.1\nflake8-multiline-containers==0.0.17\nflake8-print==4.0.0\nflake8-pytest-style==1.3.0\nflake8-return==1.1.2\nflake8-quotes==3.2.0\nflake8-simplify==0.13.0\nflake8-pytest==1.3\npipdeptree==2.0.0\npackaging>=20.8\nbuild==0.2.1\nbandit==1.7.0\n", "\"\"\"Set up the package for the plugin.\"\"\"\n\nfrom setuptools import find_packages, setup\n\nwith open('README.md') as readme_file:\n    readme = readme_file.read()\nwith open('requirements.txt') as requirements_file:\n    requirements = list(requirements_file.readlines())\n\n\nsetup(\n    name='sopel_plugins.channelmgnt',\n    version='2.0',\n    description='Channelmgnt plugin for Sopel',\n    long_description=readme,\n    long_description_content_type='text/markdown',  # This is important!\n    author='MirahezeBot Contributors',\n    author_email='bots@miraheze.org',\n    url='https://github.com/MirahezeBots/sopel-channelmgnt',\n    packages=find_packages('.'),\n    include_package_data=True,\n    install_requires=requirements,\n    license='Eiffel Forum License, version 2',\n)\n", "\"\"\"channelmgnt.py - Sopel Channel Management Plugin.\"\"\"\n\nimport re\nimport time\n\nfrom MirahezeBots_jsonparser import jsonparser as jp\n\nfrom sopel import formatting\nfrom sopel.config.types import StaticSection, ValidatedAttribute\nfrom sopel.module import (\n    OP, commands, event, example, priority, require_admin, require_chanmsg,\n)\nfrom sopel.tools import Identifier\nfrom sopel.tools import SopelMemory\n\n\"\"\"\nModified from adminchannel.py - Sopel Channel Admin Module\nCopyright 2010-2011, Michael Yanovich, Alek Rollyson, and Elsie Powell\nCopyright \u00a9 2012, Elad Alfassa <elad@fedoraproject.org>\nLicensed under the Eiffel Forum License 2.\nhttps://sopel.chat\n\"\"\"\n\n\nclass ChannelmgntSection(StaticSection):\n    \"\"\"Configuration class for channelmgnt.\"\"\"\n\n    datafile = ValidatedAttribute('datafile', str)\n    support_channel = ValidatedAttribute('support_channel', str)\n    forwardchan = ValidatedAttribute('forwardchan', str)\n\n\ndef setup(bot):\n    \"\"\"Set up config and bot memory for the plugin.\"\"\"\n    bot.config.define_section('channelmgnt', ChannelmgntSection)\n    bot.memory['channelmgnt'] = SopelMemory()\n    bot.memory['channelmgnt']['jdcache'] = jp.createdict(bot.settings.channelmgnt.datafile)\n\n\ndef configure(config):\n    \"\"\"Define sopel config wizzard questions.\"\"\"\n    config.define_section('channelmgnt', ChannelmgntSection, validate=False)\n    config.channelmgnt.configure_setting('datafile', 'Where is the datafile for channelmgnt?')\n    config.channelmgnt.configure_setting('support_channel', 'What channel should users ask for help in?')\n    config.channelmgnt.configure_setting('forwardchan', 'What channel should users be forwarded to, for fix your connection bans?')\n\n\ndef default_mask(trigger):\n    \"\"\"Build default topic mask.\"\"\"\n    welcome = formatting.color('Welcome to:', formatting.colors.PURPLE)\n    chan = formatting.color(trigger.sender, formatting.colors.TEAL)\n    topic_ = formatting.bold('Topic:')\n    topic_ = formatting.color('| ' + topic_, formatting.colors.PURPLE)\n    arg = formatting.color('{}', formatting.colors.GREEN)\n    return f'{welcome} {chan} {topic_} {arg}'\n\n\ndef chanopget(channeldata, chanopsjson):\n    \"\"\"Get chanop data for the given channel.\"\"\"\n    chanops = []\n    if 'default' in chanopsjson.keys():\n        defaultops = channelparse(channel='default', cachedjson=chanopsjson)\n        if 'chanops' in defaultops[0].keys():\n            chanops = chanops + defaultops[0]['chanops']\n    if 'inherits-from' in channeldata.keys():\n        for x in channeldata['inherits-from']:\n            y = channelparse(channel=x, cachedjson=chanopsjson)\n            chanops = chanops + y[0]['chanops']\n    if 'chanops' in channeldata.keys():\n        chanops = chanops + (channeldata['chanops'])\n    if chanops == []:\n        return False\n    return chanops\n\n\ndef logchanget(channeldata, chanopsjson):\n    \"\"\"Get logging channel for the given channel.\"\"\"\n    log_channel = []\n    if 'default' in chanopsjson.keys():\n        defaultchan = channelparse(channel='default', cachedjson=chanopsjson)\n        if 'log_channel' in defaultchan[0].keys():\n            log_channel = (defaultchan[0]['log_channel'])\n    if 'log_channel' in channeldata.keys():\n        log_channel = (channeldata['log_channel'])\n    if log_channel == []:\n        return False\n    return log_channel\n\n\ndef channelparse(channel, cachedjson):\n    \"\"\"Get json data for a specific channel.\"\"\"\n    if channel in cachedjson.keys():\n        channeldata = cachedjson[channel]\n        return channeldata, cachedjson\n    return False\n\n\ndef get_chanops(channel, cachedjson):\n    \"\"\"Get chanop data for the provided channel.\"\"\"\n    channeldata = channelparse(channel=channel, cachedjson=cachedjson)\n    if not channeldata:\n        defaultops = channelparse(channel='default', cachedjson=cachedjson)\n        if 'chanops' in defaultops[0].keys():\n            return defaultops[0]['chanops']\n        return False\n    return chanopget(channeldata[0], channeldata[1])\n\n\ndef get_log_channel(channel, cachedjson):\n    \"\"\"Get logging channel for the given channel.\"\"\"\n    channeldata = channelparse(channel='default', cachedjson=cachedjson)\n    if not channeldata:\n        defaultchan = channelparse(channel=channel, cachedjson=cachedjson)\n        if 'log_channel' in defaultchan[0].keys():\n            return defaultchan[0]['log_channel']\n        return False\n    return logchanget(channeldata[0], channeldata[1])\n\n\ndef deopbot(chan, bot):\n    \"\"\"Deop the bot in the given channel.\"\"\"\n    bot.write(['MODE', chan, '-o', bot.nick])\n\n\ndef makemodechange(bot, trigger, mode, isusermode=False, isbqmode=False, selfsafe=False):\n    \"\"\"Change the channel mode.\"\"\"\n    chanops = get_chanops(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    dodeop = False\n    if chanops:\n        if bot.channels[trigger.sender].privileges[bot.nick] < OP and trigger.account in chanops:\n            bot.say('Attempting to OP...')\n            bot.say('op ' + trigger.sender, 'ChanServ')\n            time.sleep(1)\n            dodeop = True\n        if (isusermode and not trigger.group(2) and selfsafe\n           or isusermode and not trigger.group(2) and trigger.account in chanops):\n            bot.write(['MODE', trigger.sender, mode, trigger.nick])\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        elif isusermode and trigger.account in chanops:\n            bot.write(['MODE', trigger.sender, mode, trigger.group(2)])\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        elif isbqmode and trigger.account in chanops:\n            bot.write(['MODE', trigger.sender, mode, parse_host_mask(trigger.group().split())])\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        elif trigger.account in chanops:\n            bot.write(['MODE', trigger.sender, mode])\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        else:\n            bot.reply('Access Denied. If in error, please contact the channel founder.')\n\n    else:\n        bot.reply(f'No ChanOps Found. Please ask for assistance in {bot.settings.channelmgnt.support_channel}')\n\n\n@require_chanmsg\n@commands('chanmode')\n@example('.chanmode +mz')\ndef chanmode(bot, trigger):\n    \"\"\"Command to change channel mode.\"\"\"\n    makemodechange(bot, trigger, trigger.group(2), isusermode=False)\n\n\n@require_chanmsg\n@commands('op')\n@example('.op Zppix')\ndef op(bot, trigger):\n    \"\"\"Command to op users in a room. If no nick is given, Sopel will op the nick who sent the command.\"\"\"\n    makemodechange(bot, trigger, '+o', isusermode=True)\n\n\n@require_chanmsg\n@commands('deop')\n@example('.deop Zppix')\ndef deop(bot, trigger):\n    \"\"\"Command to deop users in a room. If no nick is given, Sopel will deop the nick who sent the command.\"\"\"\n    makemodechange(bot, trigger, '-o', isusermode=True, selfsafe=True)\n\n\n@require_chanmsg\n@commands('voice')\n@example('.voice Zppix')\ndef voice(bot, trigger):\n    \"\"\"Command to voice users in a room. If no nick is given, Sopel will voice the nick who sent the command.\"\"\"\n    makemodechange(bot, trigger, '+v', isusermode=True)\n\n\n@require_chanmsg\n@commands('devoice')\n@example('.devoice Zppix')\ndef devoice(bot, trigger):\n    \"\"\"Command to devoice users in a room. If no nick is given, the nick who sent the command will be devoiced.\"\"\"\n    makemodechange(bot, trigger, '-v', isusermode=True, selfsafe=True)\n\n\n@require_chanmsg\n@commands('kick')\n@priority('high')\n@example('.kick Zppix')\ndef kick(bot, trigger):\n    \"\"\"Kick a user from the channel.\"\"\"\n    chanops = get_chanops(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    dodeop = False\n    if chanops:\n        if bot.channels[trigger.sender].privileges[bot.nick] < OP and trigger.account in chanops:\n            bot.say('Please wait...')\n            bot.say('op ' + trigger.sender, 'ChanServ')\n            time.sleep(1)\n            dodeop = True\n        text = trigger.group().split()\n        argc = len(text)\n        if argc < 2:\n            return\n        nick = Identifier(text[1])\n        reason = ' '.join(text[2:])\n        if nick != bot.config.core.nick and trigger.account in chanops:\n            bot.write(['KICK', trigger.sender, nick, ':' + reason])\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        else:\n            bot.reply('Access Denied. If in error, please contact the channel founder.')\n    else:\n        bot.reply(f'No ChanOps Found. Please ask for assistance in {bot.settings.channelmgnt.support_channel}')\n\n\ndef parse_host_mask(text):\n    \"\"\"Identify hostmask.\"\"\"\n    argc = len(text)\n    if argc >= 2:\n        opt = Identifier(text[1])\n        mask = opt\n        if not opt.is_nick() and argc < 3:\n            return None\n        if not opt.is_nick():\n            mask = text[2]\n        if re.match('^[^.@!/]+$', mask) is not None:\n            return f'{mask}!*@*'\n        if re.match('^[^@!]+$', mask) is not None:\n            return f'*!*@{mask}'\n\n        m = re.match('^([^!@]+)@$', mask)\n        if m is not None:\n            return f'*!{m.group(1)}@*'\n\n        m = re.match('^([^!@]+)@([^@!]+)$', mask)\n        if m is not None:\n            return f'*!{m.group(1)}@{m.group(2)}'\n\n        m = re.match('^([^!@]+)!(^[!@]+)@?$', mask)\n        if m is not None:\n            return f'{m.group(1)}!{m.group(2)}@*'\n\n        return ''\n    return None\n\n\n@require_chanmsg\n@commands('ban')\n@priority('high')\n@example('.ban Zppix')\ndef ban(bot, trigger):\n    \"\"\"Ban a user from the channel. The bot must be a channel operator for this command to work.\"\"\"\n    makemodechange(bot, trigger, '+b', isbqmode=True)\n\n\n@require_chanmsg\n@commands('unban')\n@example('.unban Zppix')\ndef unban(bot, trigger):\n    \"\"\"Unban a user from the channel. The bot must be a channel operator for this command to work.\"\"\"\n    makemodechange(bot, trigger, '-b', isbqmode=True)\n\n\n@require_chanmsg\n@commands('quiet')\n@example('.quiet Zppix')\ndef quiet(bot, trigger):\n    \"\"\"Quiet a user. The bot must be a channel operator for this command to work.\"\"\"\n    makemodechange(bot, trigger, '+q', isbqmode=True)\n\n\n@require_chanmsg\n@commands('unquiet')\n@example('.unquiet Zppix')\ndef unquiet(bot, trigger):\n    \"\"\"Unquiet a user. The bot must be a channel operator for this command to work.\"\"\"\n    makemodechange(bot, trigger, '-q', isbqmode=True)\n\n\n@require_chanmsg\n@commands('kickban', 'kb')\n@example('.kickban user1 user!*@* get out of here')\n@priority('high')\ndef kickban(bot, trigger):\n    \"\"\"Kick and ban a user from the channel. The bot must be a channel operator for this command to work.\"\"\"\n    chanops = get_chanops(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    dodeop = False\n    if chanops:\n        if bot.channels[trigger.sender].privileges[bot.nick] < OP and trigger.account in chanops:\n            bot.say('Please wait...')\n            bot.say('op ' + trigger.sender, 'ChanServ')\n            time.sleep(1)\n            dodeop = True\n        text = trigger.group().split()\n        argc = len(text)\n        if argc < 3:\n            bot.reply('Syntax is: .kickban <nick> <reason>')\n            if dodeop:\n                deopbot(trigger.sender, bot)\n            return\n        nick = Identifier(text[1])\n        mask = text[2] if any(s in text[2] for s in '!@*') else ''\n        reasonidx = 3 if mask != '' else 2\n        reason = ' '.join(text[reasonidx:])\n        mask = parse_host_mask(trigger.group().split())\n        if mask == '':\n            mask = nick + '!*@*'\n        if trigger.account in chanops:\n            bot.write(['MODE', trigger.sender, '+b', mask])\n            bot.write(['KICK', trigger.sender, nick, ':' + reason])\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        else:\n            bot.reply('Access Denied. If in error, please contact the channel founder.')\n    else:\n        bot.reply(f'No ChanOps Found. Please ask for assistance in {bot.settings.channelmgnt.support_channel}')\n\n\ndef get_mask(bot, channel, default):\n    \"\"\"Get mask for given channel.\"\"\"\n    return (bot.db.get_channel_value(channel, 'topic_mask') or default).replace('%s', '{}')\n\n\n@require_chanmsg\n@commands('topic')\n@example('.topic Your Great New Topic')\ndef topic(bot, trigger):\n    \"\"\"Change the channel topic. The bot must be a channel operator for this command to work.\"\"\"\n    chanops = get_chanops(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    dodeop = False\n    if chanops:\n        if bot.channels[trigger.sender].privileges[bot.nick] < OP and trigger.account in chanops:\n            bot.say('Please wait...')\n            bot.say('op ' + trigger.sender, 'ChanServ')\n            time.sleep(1)\n            dodeop = True\n        if not trigger.group(2):\n            return None\n        channel = trigger.sender.lower()\n\n        mask = get_mask(bot, channel, default_mask(trigger))\n        narg = len(re.findall('{}', mask))\n\n        top = trigger.group(2)\n        args = []\n        args = top.split('~', narg)\n\n        if len(args) != narg:\n            message = f'Not enough arguments. You gave {args}, it requires {narg}.'\n            if dodeop:\n                deopbot(trigger.sender, bot)\n            return bot.say(message)\n        topictext = mask.format(*args)\n        if trigger.account in chanops:\n            bot.write(('TOPIC', channel + ' :' + topictext))\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        else:\n            return bot.reply('Access Denied. If in error, please contact the channel founder.')\n    return bot.reply(f'No ChanOps Found. Please ask for assistance in {bot.settings.channelmgnt.support_channel}')\n\n\n@require_chanmsg\n@commands('tmask')\n@example('.tmask Welcome to My Channel | Info: {}')\ndef set_mask(bot, trigger):\n    \"\"\"Set the topic mask to use for the current channel.\"\"\"\n    chanops = get_chanops(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    if chanops:\n        if trigger.account in chanops:\n            bot.db.set_channel_value(trigger.sender, 'topic_mask', trigger.group(2))\n            bot.say(f'Gotcha, {trigger.account}')\n        else:\n            bot.reply('Access Denied. If in error, please contact the channel founder.')\n    else:\n        bot.reply(f'No ChanOps Found. Please ask for assistance in {bot.settings.channelmgnt.support_channel}')\n\n\n@require_chanmsg\n@commands('showmask')\n@example('showmask')\ndef show_mask(bot, trigger):\n    \"\"\"Show the topic mask for the current channel.\"\"\"\n    mask = bot.db.get_channel_value(trigger.sender, 'topic_mask')\n    mask = mask or default_mask(trigger)\n    bot.say(mask)\n\n\n@require_chanmsg\n@commands('invite')\ndef invite_user(bot, trigger):\n    \"\"\"Command to invite users to a room.\"\"\"\n    chanops = get_chanops(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    channel = trigger.sender\n    dodeop = False\n    if chanops:\n        if bot.channels[trigger.sender].privileges[bot.nick] < OP and trigger.account in chanops:\n            bot.say('Please wait...')\n            bot.say('op ' + trigger.sender, 'ChanServ')\n            time.sleep(1)\n            dodeop = True\n            nick = trigger.group(2)\n        if not nick:\n            bot.say(f'{trigger.account}: No user specified.', trigger.sender)\n        elif trigger.account in chanops:\n            bot.write(['INVITE', channel, nick])\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        else:\n            bot.reply('Access Denied. If in error, please contact the channel founder.')\n    else:\n        bot.reply(f'No ChanOps Found. Please ask for assistance in {bot.settings.channelmgnt.support_channel}')\n\n\n@require_chanmsg\n@commands('fyc', 'fixconnection')\n@example('.fyc nick')\n@priority('high')\ndef fyckb(bot, trigger):\n    \"\"\"Ban a user from the channel, forwards user to specified channel until unbanned. The bot must be a channel operator for this command to work.\"\"\"\n    chanops = get_chanops(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    dodeop = False\n    if chanops:\n        if bot.channels[trigger.sender].privileges[bot.nick] < OP and trigger.account in chanops:\n            bot.say('Please wait...')\n            bot.say('op ' + trigger.sender, 'ChanServ')\n            time.sleep(1)\n            dodeop = True\n            text = trigger.group().split()\n            nick = Identifier(text[1])\n            mask = parse_host_mask(text)\n            if mask == '':\n                mask = nick + '!*@*'\n            bot.write(['MODE', trigger.sender, '+b', f'{mask}${bot.settings.channelmgnt.forwardchan}'])\n        else:\n            bot.reply('Access Denied. If in error, please contact the channel founder.')\n        if dodeop:\n            deopbot(trigger.sender, bot)\n    else:\n        bot.reply(f'No ChanOps Found. Please ask for assistance in {bot.settings.channelmgnt.support_channel}')\n\n\n@event('KICK')\ndef log_kick(bot, trigger):\n    \"\"\"Log blocks to a certain channel if specified in json.\"\"\"\n    logging_channel = get_log_channel(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    greentext = f'kicked from {trigger.args[0]} by {trigger.nick} ({trigger.args[2]})'\n    if logging_channel:\n        bot.say(f'{formatting.bold(trigger.args[1])} was {formatting.color(text=greentext, fg=\"GREEN\")}', logging_channel)\n\n\n@require_admin(message='Only admins may purge cache.')\n@commands('resetchanopcache')\ndef reset_chanop_cache(bot, trigger):  # noqa: U100\n    \"\"\"Reset the cache of the channel management data file.\"\"\"\n    bot.reply('Refreshing Cache...')\n    bot.memory['channelmgnt']['jdcache'] = jp.createdict(bot.settings.channelmgnt.datafile)\n    bot.reply('Cache refreshed')\n\n\n@require_admin(message='Only admins may check cache')\n@commands('checkchanopcache')\ndef check_chanop_cache(bot, trigger):  # noqa: U100\n    \"\"\"Validate the cache matches the copy on disk.\"\"\"\n    result = jp.validatecache(bot.settings.channelmgnt.datafile, bot.memory['channelmgnt']['jdcache'])\n    if result:\n        return bot.reply('Cache is correct.')\n    return bot.reply('Cache does not match on-disk copy')\n"], "fixing_code": ["# Development requirements\npip-check-reqs==2.1.1\nsetuptools==53.0.0\npytest==6.2.2\nflake8==3.8.4\nflake8-docstrings==1.5.0\nflake8-import-order==0.18.1\nflake8-unused-arguments==0.0.6\nflake8-sfs==0.0.3\nflake8-builtins==1.5.3\nflake8-commas==2.0.0\nflake8-comprehensions==3.3.1\nflake8-eradicate==1.0.0\nflake8-fixme==1.1.1\nflake8-multiline-containers==0.0.17\nflake8-print==4.0.0\nflake8-pytest-style==1.3.0\n#flake8-return==1.1.2\nflake8-quotes==3.2.0\nflake8-simplify==0.13.0\nflake8-pytest==1.3\npipdeptree==2.0.0\npackaging>=20.8\nbuild==0.2.1\nbandit==1.7.0\n", "\"\"\"Set up the package for the plugin.\"\"\"\n\nfrom setuptools import find_packages, setup\n\nwith open('README.md') as readme_file:\n    readme = readme_file.read()\nwith open('requirements.txt') as requirements_file:\n    requirements = list(requirements_file.readlines())\n\n\nsetup(\n    name='sopel_plugins.channelmgnt',\n    version='2.0.1',\n    description='Channelmgnt plugin for Sopel',\n    long_description=readme,\n    long_description_content_type='text/markdown',  # This is important!\n    author='MirahezeBot Contributors',\n    author_email='staff@mirahezebots.org',\n    url='https://github.com/MirahezeBots/sopel-channelmgnt',\n    packages=find_packages('.'),\n    include_package_data=True,\n    install_requires=requirements,\n    license='Eiffel Forum License, version 2',\n)\n", "\"\"\"channelmgnt.py - Sopel Channel Management Plugin.\"\"\"\n\nimport re\nimport time\n\nfrom MirahezeBots_jsonparser import jsonparser as jp\n\nfrom sopel import formatting\nfrom sopel.config.types import StaticSection, ValidatedAttribute\nfrom sopel.module import (\n    OP, commands, event, example, priority, require_admin, require_chanmsg,\n)\nfrom sopel.tools import Identifier\nfrom sopel.tools import SopelMemory\n\n\"\"\"\nModified from adminchannel.py - Sopel Channel Admin Module\nCopyright 2010-2011, Michael Yanovich, Alek Rollyson, and Elsie Powell\nCopyright \u00a9 2012, Elad Alfassa <elad@fedoraproject.org>\nLicensed under the Eiffel Forum License 2.\nhttps://sopel.chat\n\"\"\"\n\n\nclass ChannelmgntSection(StaticSection):\n    \"\"\"Configuration class for channelmgnt.\"\"\"\n\n    datafile = ValidatedAttribute('datafile', str)\n    support_channel = ValidatedAttribute('support_channel', str)\n    forwardchan = ValidatedAttribute('forwardchan', str)\n\n\ndef setup(bot):\n    \"\"\"Set up config and bot memory for the plugin.\"\"\"\n    bot.config.define_section('channelmgnt', ChannelmgntSection)\n    bot.memory['channelmgnt'] = SopelMemory()\n    bot.memory['channelmgnt']['jdcache'] = jp.createdict(bot.settings.channelmgnt.datafile)\n\n\ndef configure(config):\n    \"\"\"Define sopel config wizzard questions.\"\"\"\n    config.define_section('channelmgnt', ChannelmgntSection, validate=False)\n    config.channelmgnt.configure_setting('datafile', 'Where is the datafile for channelmgnt?')\n    config.channelmgnt.configure_setting('support_channel', 'What channel should users ask for help in?')\n    config.channelmgnt.configure_setting('forwardchan', 'What channel should users be forwarded to, for fix your connection bans?')\n\n\ndef default_mask(trigger):\n    \"\"\"Build default topic mask.\"\"\"\n    welcome = formatting.color('Welcome to:', formatting.colors.PURPLE)\n    chan = formatting.color(trigger.sender, formatting.colors.TEAL)\n    topic_ = formatting.bold('Topic:')\n    topic_ = formatting.color('| ' + topic_, formatting.colors.PURPLE)\n    arg = formatting.color('{}', formatting.colors.GREEN)\n    return f'{welcome} {chan} {topic_} {arg}'\n\n\ndef chanopget(channeldata, chanopsjson):\n    \"\"\"Get chanop data for the given channel.\"\"\"\n    chanops = []\n    if 'default' in chanopsjson.keys():\n        defaultops = channelparse(channel='default', cachedjson=chanopsjson)\n        if 'chanops' in defaultops[0].keys():\n            chanops = chanops + defaultops[0]['chanops']\n    if 'inherits-from' in channeldata.keys():\n        for x in channeldata['inherits-from']:\n            y = channelparse(channel=x, cachedjson=chanopsjson)\n            chanops = chanops + y[0]['chanops']\n    if 'chanops' in channeldata.keys():\n        chanops = chanops + (channeldata['chanops'])\n    if chanops == []:\n        return False\n    return chanops\n\n\ndef logchanget(channeldata, chanopsjson):\n    \"\"\"Get logging channel for the given channel.\"\"\"\n    log_channel = []\n    if 'default' in chanopsjson.keys():\n        defaultchan = channelparse(channel='default', cachedjson=chanopsjson)\n        if 'log_channel' in defaultchan[0].keys():\n            log_channel = (defaultchan[0]['log_channel'])\n    if 'log_channel' in channeldata.keys():\n        log_channel = (channeldata['log_channel'])\n    if log_channel == []:\n        return False\n    return log_channel\n\n\ndef channelparse(channel, cachedjson):\n    \"\"\"Get json data for a specific channel.\"\"\"\n    if channel in cachedjson.keys():\n        channeldata = cachedjson[channel]\n        return channeldata, cachedjson\n    return False\n\n\ndef get_chanops(channel, cachedjson):\n    \"\"\"Get chanop data for the provided channel.\"\"\"\n    channeldata = channelparse(channel=channel, cachedjson=cachedjson)\n    if not channeldata:\n        defaultops = channelparse(channel='default', cachedjson=cachedjson)\n        if 'chanops' in defaultops[0].keys():\n            return defaultops[0]['chanops']\n        return False\n    return chanopget(channeldata[0], channeldata[1])\n\n\ndef get_log_channel(channel, cachedjson):\n    \"\"\"Get logging channel for the given channel.\"\"\"\n    channeldata = channelparse(channel='default', cachedjson=cachedjson)\n    if not channeldata:\n        defaultchan = channelparse(channel=channel, cachedjson=cachedjson)\n        if 'log_channel' in defaultchan[0].keys():\n            return defaultchan[0]['log_channel']\n        return False\n    return logchanget(channeldata[0], channeldata[1])\n\n\ndef deopbot(chan, bot):\n    \"\"\"Deop the bot in the given channel.\"\"\"\n    bot.write(['MODE', chan, '-o', bot.nick])\n\n\ndef makemodechange(bot, trigger, mode, isusermode=False, isbqmode=False, selfsafe=False):\n    \"\"\"Change the channel mode.\"\"\"\n    chanops = get_chanops(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    dodeop = False\n    if chanops:\n        if bot.channels[trigger.sender].privileges[bot.nick] < OP and trigger.account in chanops:\n            bot.say('Attempting to OP...')\n            bot.say('op ' + trigger.sender, 'ChanServ')\n            time.sleep(1)\n            dodeop = True\n        if (isusermode and not trigger.group(2) and selfsafe\n           or isusermode and not trigger.group(2) and trigger.account in chanops):\n            bot.write(['MODE', trigger.sender, mode, trigger.nick])\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        elif isusermode and trigger.account in chanops:\n            bot.write(['MODE', trigger.sender, mode, trigger.group(2)])\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        elif isbqmode and trigger.account in chanops:\n            bot.write(['MODE', trigger.sender, mode, parse_host_mask(trigger.group().split())])\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        elif trigger.account in chanops:\n            bot.write(['MODE', trigger.sender, mode])\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        else:\n            bot.reply('Access Denied. If in error, please contact the channel founder.')\n\n    else:\n        bot.reply(f'No ChanOps Found. Please ask for assistance in {bot.settings.channelmgnt.support_channel}')\n\n\n@require_chanmsg\n@commands('chanmode')\n@example('.chanmode +mz')\ndef chanmode(bot, trigger):\n    \"\"\"Command to change channel mode.\"\"\"\n    makemodechange(bot, trigger, trigger.group(2), isusermode=False)\n\n\n@require_chanmsg\n@commands('op')\n@example('.op Zppix')\ndef op(bot, trigger):\n    \"\"\"Command to op users in a room. If no nick is given, Sopel will op the nick who sent the command.\"\"\"\n    makemodechange(bot, trigger, '+o', isusermode=True)\n\n\n@require_chanmsg\n@commands('deop')\n@example('.deop Zppix')\ndef deop(bot, trigger):\n    \"\"\"Command to deop users in a room. If no nick is given, Sopel will deop the nick who sent the command.\"\"\"\n    makemodechange(bot, trigger, '-o', isusermode=True, selfsafe=True)\n\n\n@require_chanmsg\n@commands('voice')\n@example('.voice Zppix')\ndef voice(bot, trigger):\n    \"\"\"Command to voice users in a room. If no nick is given, Sopel will voice the nick who sent the command.\"\"\"\n    makemodechange(bot, trigger, '+v', isusermode=True)\n\n\n@require_chanmsg\n@commands('devoice')\n@example('.devoice Zppix')\ndef devoice(bot, trigger):\n    \"\"\"Command to devoice users in a room. If no nick is given, the nick who sent the command will be devoiced.\"\"\"\n    makemodechange(bot, trigger, '-v', isusermode=True, selfsafe=True)\n\n\n@require_chanmsg\n@commands('kick')\n@priority('high')\n@example('.kick Zppix')\ndef kick(bot, trigger):\n    \"\"\"Kick a user from the channel.\"\"\"\n    chanops = get_chanops(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    dodeop = False\n    if chanops:\n        if bot.channels[trigger.sender].privileges[bot.nick] < OP and trigger.account in chanops:\n            bot.say('Please wait...')\n            bot.say('op ' + trigger.sender, 'ChanServ')\n            time.sleep(1)\n            dodeop = True\n        text = trigger.group().split()\n        argc = len(text)\n        if argc < 2:\n            return\n        nick = Identifier(text[1])\n        reason = ' '.join(text[2:])\n        if ',' in str(nick):\n            return bot.reply('Unable to kick. Kicking multiple users is not allowed.')\n        if '#' in str(nick):\n            return bot.reply('Unable to kick. Use of # when kicking is not expected.')\n        if nick != bot.config.core.nick and trigger.account in chanops:\n            bot.write(['KICK', trigger.sender, nick, ':' + reason])\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        else:\n            bot.reply('Access Denied. If in error, please contact the channel founder.')\n    else:\n        bot.reply(f'No ChanOps Found. Please ask for assistance in {bot.settings.channelmgnt.support_channel}')\n\n\ndef parse_host_mask(text):\n    \"\"\"Identify hostmask.\"\"\"\n    argc = len(text)\n    if argc >= 2:\n        opt = Identifier(text[1])\n        mask = opt\n        if not opt.is_nick() and argc < 3:\n            return None\n        if not opt.is_nick():\n            mask = text[2]\n        if re.match('^[^.@!/]+$', mask) is not None:\n            return f'{mask}!*@*'\n        if re.match('^[^@!]+$', mask) is not None:\n            return f'*!*@{mask}'\n\n        m = re.match('^([^!@]+)@$', mask)\n        if m is not None:\n            return f'*!{m.group(1)}@*'\n\n        m = re.match('^([^!@]+)@([^@!]+)$', mask)\n        if m is not None:\n            return f'*!{m.group(1)}@{m.group(2)}'\n\n        m = re.match('^([^!@]+)!(^[!@]+)@?$', mask)\n        if m is not None:\n            return f'{m.group(1)}!{m.group(2)}@*'\n\n        return ''\n    return None\n\n\n@require_chanmsg\n@commands('ban')\n@priority('high')\n@example('.ban Zppix')\ndef ban(bot, trigger):\n    \"\"\"Ban a user from the channel. The bot must be a channel operator for this command to work.\"\"\"\n    if ',' in str(parse_host_mask(trigger.group().split())):\n        return bot.reply('Unable to ban. Banning multiple users is not allowed.')\n    if '#' in str(parse_host_mask(trigger.group().split())):\n        return bot.reply('Unable to ban. Use of # when banning is not expected.')\n    makemodechange(bot, trigger, '+b', isbqmode=True)\n\n\n@require_chanmsg\n@commands('unban')\n@example('.unban Zppix')\ndef unban(bot, trigger):\n    \"\"\"Unban a user from the channel. The bot must be a channel operator for this command to work.\"\"\"\n    if ',' in str(parse_host_mask(trigger.group().split())):\n        return bot.reply('Unable to ban. Banning multiple users is not allowed.')\n    if '#' in str(parse_host_mask(trigger.group().split())):\n        return bot.reply('Unable to ban. Use of # when banning is not expected.')\n    makemodechange(bot, trigger, '-b', isbqmode=True)\n\n\n@require_chanmsg\n@commands('quiet')\n@example('.quiet Zppix')\ndef quiet(bot, trigger):\n    \"\"\"Quiet a user. The bot must be a channel operator for this command to work.\"\"\"\n    makemodechange(bot, trigger, '+q', isbqmode=True)\n\n\n@require_chanmsg\n@commands('unquiet')\n@example('.unquiet Zppix')\ndef unquiet(bot, trigger):\n    \"\"\"Unquiet a user. The bot must be a channel operator for this command to work.\"\"\"\n    makemodechange(bot, trigger, '-q', isbqmode=True)\n\n\n@require_chanmsg\n@commands('kickban', 'kb')\n@example('.kickban user1 user!*@* get out of here')\n@priority('high')\ndef kickban(bot, trigger):\n    \"\"\"Kick and ban a user from the channel. The bot must be a channel operator for this command to work.\"\"\"\n    chanops = get_chanops(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    dodeop = False\n    if chanops:\n        if bot.channels[trigger.sender].privileges[bot.nick] < OP and trigger.account in chanops:\n            bot.say('Please wait...')\n            bot.say('op ' + trigger.sender, 'ChanServ')\n            time.sleep(1)\n            dodeop = True\n        text = trigger.group().split()\n        argc = len(text)\n        if argc < 3:\n            bot.reply('Syntax is: .kickban <nick> <reason>')\n            if dodeop:\n                deopbot(trigger.sender, bot)\n            return\n        nick = Identifier(text[1])\n        if ',' in str(nick):\n            return bot.reply('Unable to kickban. Kickbanning multiple users is not allowed.')\n        if '#' in str(nick):\n            return bot.reply('Unable to kickban. Use of # when kickbanning is not expected.')\n        mask = text[2] if any(s in text[2] for s in '!@*') else ''\n        reasonidx = 3 if mask != '' else 2\n        reason = ' '.join(text[reasonidx:])\n        mask = parse_host_mask(trigger.group().split())\n        if mask == '':\n            mask = nick + '!*@*'\n        if trigger.account in chanops:\n            bot.write(['MODE', trigger.sender, '+b', mask])\n            bot.write(['KICK', trigger.sender, nick, ':' + reason])\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        else:\n            bot.reply('Access Denied. If in error, please contact the channel founder.')\n    else:\n        bot.reply(f'No ChanOps Found. Please ask for assistance in {bot.settings.channelmgnt.support_channel}')\n\n\ndef get_mask(bot, channel, default):\n    \"\"\"Get mask for given channel.\"\"\"\n    return (bot.db.get_channel_value(channel, 'topic_mask') or default).replace('%s', '{}')\n\n\n@require_chanmsg\n@commands('topic')\n@example('.topic Your Great New Topic')\ndef topic(bot, trigger):\n    \"\"\"Change the channel topic. The bot must be a channel operator for this command to work.\"\"\"\n    chanops = get_chanops(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    dodeop = False\n    if chanops:\n        if bot.channels[trigger.sender].privileges[bot.nick] < OP and trigger.account in chanops:\n            bot.say('Please wait...')\n            bot.say('op ' + trigger.sender, 'ChanServ')\n            time.sleep(1)\n            dodeop = True\n        if not trigger.group(2):\n            return None\n        channel = trigger.sender.lower()\n\n        mask = get_mask(bot, channel, default_mask(trigger))\n        narg = len(re.findall('{}', mask))\n\n        top = trigger.group(2)\n        args = []\n        args = top.split('~', narg)\n\n        if len(args) != narg:\n            message = f'Not enough arguments. You gave {args}, it requires {narg}.'\n            if dodeop:\n                deopbot(trigger.sender, bot)\n            return bot.say(message)\n        topictext = mask.format(*args)\n        if trigger.account in chanops:\n            bot.write(('TOPIC', channel + ' :' + topictext))\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        else:\n            return bot.reply('Access Denied. If in error, please contact the channel founder.')\n    return bot.reply(f'No ChanOps Found. Please ask for assistance in {bot.settings.channelmgnt.support_channel}')\n\n\n@require_chanmsg\n@commands('tmask')\n@example('.tmask Welcome to My Channel | Info: {}')\ndef set_mask(bot, trigger):\n    \"\"\"Set the topic mask to use for the current channel.\"\"\"\n    chanops = get_chanops(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    if chanops:\n        if trigger.account in chanops:\n            bot.db.set_channel_value(trigger.sender, 'topic_mask', trigger.group(2))\n            bot.say(f'Gotcha, {trigger.account}')\n        else:\n            bot.reply('Access Denied. If in error, please contact the channel founder.')\n    else:\n        bot.reply(f'No ChanOps Found. Please ask for assistance in {bot.settings.channelmgnt.support_channel}')\n\n\n@require_chanmsg\n@commands('showmask')\n@example('showmask')\ndef show_mask(bot, trigger):\n    \"\"\"Show the topic mask for the current channel.\"\"\"\n    mask = bot.db.get_channel_value(trigger.sender, 'topic_mask')\n    mask = mask or default_mask(trigger)\n    bot.say(mask)\n\n\n@require_chanmsg\n@commands('invite')\ndef invite_user(bot, trigger):\n    \"\"\"Command to invite users to a room.\"\"\"\n    chanops = get_chanops(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    channel = trigger.sender\n    dodeop = False\n    if chanops:\n        if bot.channels[trigger.sender].privileges[bot.nick] < OP and trigger.account in chanops:\n            bot.say('Please wait...')\n            bot.say('op ' + trigger.sender, 'ChanServ')\n            time.sleep(1)\n            dodeop = True\n            nick = trigger.group(2)\n        if not nick:\n            bot.say(f'{trigger.account}: No user specified.', trigger.sender)\n        elif trigger.account in chanops:\n            bot.write(['INVITE', channel, nick])\n            if dodeop:\n                deopbot(trigger.sender, bot)\n        else:\n            bot.reply('Access Denied. If in error, please contact the channel founder.')\n    else:\n        bot.reply(f'No ChanOps Found. Please ask for assistance in {bot.settings.channelmgnt.support_channel}')\n\n\n@require_chanmsg\n@commands('fyc', 'fixconnection')\n@example('.fyc nick')\n@priority('high')\ndef fyckb(bot, trigger):\n    \"\"\"Ban a user from the channel, forwards user to specified channel until unbanned. The bot must be a channel operator for this command to work.\"\"\"\n    chanops = get_chanops(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    dodeop = False\n    if chanops:\n        if bot.channels[trigger.sender].privileges[bot.nick] < OP and trigger.account in chanops:\n            bot.say('Please wait...')\n            bot.say('op ' + trigger.sender, 'ChanServ')\n            time.sleep(1)\n            dodeop = True\n            text = trigger.group().split()\n            nick = Identifier(text[1])\n            mask = parse_host_mask(text)\n            if mask == '':\n                mask = nick + '!*@*'\n            bot.write(['MODE', trigger.sender, '+b', f'{mask}${bot.settings.channelmgnt.forwardchan}'])\n        else:\n            bot.reply('Access Denied. If in error, please contact the channel founder.')\n        if dodeop:\n            deopbot(trigger.sender, bot)\n    else:\n        bot.reply(f'No ChanOps Found. Please ask for assistance in {bot.settings.channelmgnt.support_channel}')\n\n\n@event('KICK')\ndef log_kick(bot, trigger):\n    \"\"\"Log blocks to a certain channel if specified in json.\"\"\"\n    logging_channel = get_log_channel(str(trigger.sender), bot.memory['channelmgnt']['jdcache'])\n    greentext = f'kicked from {trigger.args[0]} by {trigger.nick} ({trigger.args[2]})'\n    if logging_channel:\n        bot.say(f'{formatting.bold(trigger.args[1])} was {formatting.color(text=greentext, fg=\"GREEN\")}', logging_channel)\n\n\n@require_admin(message='Only admins may purge cache.')\n@commands('resetchanopcache')\ndef reset_chanop_cache(bot, trigger):  # noqa: U100\n    \"\"\"Reset the cache of the channel management data file.\"\"\"\n    bot.reply('Refreshing Cache...')\n    bot.memory['channelmgnt']['jdcache'] = jp.createdict(bot.settings.channelmgnt.datafile)\n    bot.reply('Cache refreshed')\n\n\n@require_admin(message='Only admins may check cache')\n@commands('checkchanopcache')\ndef check_chanop_cache(bot, trigger):  # noqa: U100\n    \"\"\"Validate the cache matches the copy on disk.\"\"\"\n    result = jp.validatecache(bot.settings.channelmgnt.datafile, bot.memory['channelmgnt']['jdcache'])\n    if result:\n        return bot.reply('Cache is correct.')\n    return bot.reply('Cache does not match on-disk copy')\n"], "filenames": ["dev-requirements.txt", "setup.py", "sopel_channelmgnt/channelmgnt/__init__.py"], "buggy_code_start_loc": [18, 13, 218], "buggy_code_end_loc": [19, 19, 314], "fixing_code_start_loc": [18, 13, 219], "fixing_code_end_loc": [19, 19, 331], "type": "NVD-CWE-Other", "message": "sopel-channelmgnt is a channelmgnt plugin for sopel. In versions prior to 2.0.1, on some IRC servers, restrictions around the removal of the bot using the kick/kickban command could be bypassed when kicking multiple users at once. We also believe it may have been possible to remove users from other channels but due to the wonder that is IRC and following RfCs, We have no POC for that. Freenode is not affected. This is fixed in version 2.0.1. As a workaround, do not use this plugin on networks where TARGMAX > 1.", "other": {"cve": {"id": "CVE-2021-21431", "sourceIdentifier": "security-advisories@github.com", "published": "2021-04-09T16:15:11.837", "lastModified": "2022-10-24T20:26:34.920", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "sopel-channelmgnt is a channelmgnt plugin for sopel. In versions prior to 2.0.1, on some IRC servers, restrictions around the removal of the bot using the kick/kickban command could be bypassed when kicking multiple users at once. We also believe it may have been possible to remove users from other channels but due to the wonder that is IRC and following RfCs, We have no POC for that. Freenode is not affected. This is fixed in version 2.0.1. As a workaround, do not use this plugin on networks where TARGMAX > 1."}, {"lang": "es", "value": "sopel-channelmgnt es un plugin de channelmgnt para sopel.&#xa0;En versiones anteriores a 2.0.1, en algunos servidores IRC, unas restricciones sobre la eliminaci\u00f3n del bot usando el comando kick/kickban podr\u00edan omitirse al patear a varios usuarios a la vez.&#xa0;Tambi\u00e9n creemos que puede haber sido posible eliminar usuarios de otros canales, pero debido a la maravilla que es el IRC y los siguientes RfC, no tenemos POC para eso.&#xa0;Freenode no est\u00e1 afectado.&#xa0;Esto es corregido en versi\u00f3n 2.0.1.&#xa0;Como soluci\u00f3n alternativa, no usar este plugin en redes donde TARGMAX versi\u00f3n posterior a 1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.7, "impactScore": 5.8}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:H/UI:R/S:C/C:N/I:H/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mirahezebots:channelmgnt:*:*:*:*:*:sopel:*:*", "versionEndExcluding": "2.0.1", "matchCriteriaId": "F65E996A-D825-4819-BC87-8A0A160A9CAF"}]}]}], "references": [{"url": "https://github.com/MirahezeBots/sopel-channelmgnt/commit/7c96d400358221e59135f0a0be0744f3fad73856", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/MirahezeBots/sopel-channelmgnt/security/advisories/GHSA-23c7-6444-399m", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://pypi.org/project/sopel-plugins.channelmgnt/", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/MirahezeBots/sopel-channelmgnt/commit/7c96d400358221e59135f0a0be0744f3fad73856"}}