{"buggy_code": ["#include \"jsi.h\"\n#include \"jsvalue.h\"\n#include \"jsbuiltin.h\"\n\n#if defined(_MSC_VER) && (_MSC_VER < 1700) /* VS2012 has stdint.h */\ntypedef unsigned __int64 uint64_t;\n#else\n#include <stdint.h>\n#endif\n\nstatic void jsB_new_Number(js_State *J)\n{\n\tjs_newnumber(J, js_gettop(J) > 1 ? js_tonumber(J, 1) : 0);\n}\n\nstatic void jsB_Number(js_State *J)\n{\n\tjs_pushnumber(J, js_gettop(J) > 1 ? js_tonumber(J, 1) : 0);\n}\n\nstatic void Np_valueOf(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tif (self->type != JS_CNUMBER) js_typeerror(J, \"not a number\");\n\tjs_pushnumber(J, self->u.number);\n}\n\nstatic void Np_toString(js_State *J)\n{\n\tchar buf[32];\n\tjs_Object *self = js_toobject(J, 0);\n\tint radix = js_isundefined(J, 1) ? 10 : js_tointeger(J, 1);\n\tif (self->type != JS_CNUMBER)\n\t\tjs_typeerror(J, \"not a number\");\n\tif (radix == 10) {\n\t\tjs_pushstring(J, jsV_numbertostring(J, buf, self->u.number));\n\t\treturn;\n\t}\n\tif (radix < 2 || radix > 36)\n\t\tjs_rangeerror(J, \"invalid radix\");\n\n\t/* lame number to string conversion for any radix from 2 to 36 */\n\t{\n\t\tstatic const char digits[] = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\t\tchar buf[100];\n\t\tdouble number = self->u.number;\n\t\tint sign = self->u.number < 0;\n\t\tjs_Buffer *sb = NULL;\n\t\tuint64_t u, limit = ((uint64_t)1<<52);\n\n\t\tint ndigits, exp, point;\n\n\t\tif (number == 0) { js_pushstring(J, \"0\"); return; }\n\t\tif (isnan(number)) { js_pushstring(J, \"NaN\"); return; }\n\t\tif (isinf(number)) { js_pushstring(J, sign ? \"-Infinity\" : \"Infinity\"); return; }\n\n\t\tif (sign)\n\t\t\tnumber = -number;\n\n\t\t/* fit as many digits as we want in an int */\n\t\texp = 0;\n\t\twhile (number * pow(radix, exp) > limit)\n\t\t\t--exp;\n\t\twhile (number * pow(radix, exp+1) < limit)\n\t\t\t++exp;\n\t\tu = number * pow(radix, exp) + 0.5;\n\n\t\t/* trim trailing zeros */\n\t\twhile (u > 0 && (u % radix) == 0) {\n\t\t\tu /= radix;\n\t\t\t--exp;\n\t\t}\n\n\t\t/* serialize digits */\n\t\tndigits = 0;\n\t\twhile (u > 0) {\n\t\t\tbuf[ndigits++] = digits[u % radix];\n\t\t\tu /= radix;\n\t\t}\n\t\tpoint = ndigits - exp;\n\n\t\tif (js_try(J)) {\n\t\t\tjs_free(J, sb);\n\t\t\tjs_throw(J);\n\t\t}\n\n\t\tif (sign)\n\t\t\tjs_putc(J, &sb, '-');\n\n\t\tif (point <= 0) {\n\t\t\tjs_putc(J, &sb, '0');\n\t\t\tjs_putc(J, &sb, '.');\n\t\t\twhile (point++ < 0)\n\t\t\t\tjs_putc(J, &sb, '0');\n\t\t\twhile (ndigits-- > 0)\n\t\t\t\tjs_putc(J, &sb, buf[ndigits]);\n\t\t} else {\n\t\t\twhile (ndigits-- > 0) {\n\t\t\t\tjs_putc(J, &sb, buf[ndigits]);\n\t\t\t\tif (--point == 0 && ndigits > 0)\n\t\t\t\t\tjs_putc(J, &sb, '.');\n\t\t\t}\n\t\t\twhile (point-- > 0)\n\t\t\t\tjs_putc(J, &sb, '0');\n\t\t}\n\n\t\tjs_putc(J, &sb, 0);\n\t\tjs_pushstring(J, sb->s);\n\n\t\tjs_endtry(J);\n\t\tjs_free(J, sb);\n\t}\n}\n\n/* Customized ToString() on a number */\nstatic void numtostr(js_State *J, const char *fmt, int w, double n)\n{\n\tchar buf[32], *e;\n\tsprintf(buf, fmt, w, n);\n\te = strchr(buf, 'e');\n\tif (e) {\n\t\tint exp = atoi(e+1);\n\t\tsprintf(e, \"e%+d\", exp);\n\t}\n\tjs_pushstring(J, buf);\n}\n\nstatic void Np_toFixed(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tint width = js_tointeger(J, 1);\n\tchar buf[32];\n\tdouble x;\n\tif (self->type != JS_CNUMBER) js_typeerror(J, \"not a number\");\n\tif (width < 0) js_rangeerror(J, \"precision %d out of range\", width);\n\tif (width > 20) js_rangeerror(J, \"precision %d out of range\", width);\n\tx = self->u.number;\n\tif (isnan(x) || isinf(x) || x <= -1e21 || x >= 1e21)\n\t\tjs_pushstring(J, jsV_numbertostring(J, buf, x));\n\telse\n\t\tnumtostr(J, \"%.*f\", width, x);\n}\n\nstatic void Np_toExponential(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tint width = js_tointeger(J, 1);\n\tchar buf[32];\n\tdouble x;\n\tif (self->type != JS_CNUMBER) js_typeerror(J, \"not a number\");\n\tif (width < 0) js_rangeerror(J, \"precision %d out of range\", width);\n\tif (width > 20) js_rangeerror(J, \"precision %d out of range\", width);\n\tx = self->u.number;\n\tif (isnan(x) || isinf(x))\n\t\tjs_pushstring(J, jsV_numbertostring(J, buf, x));\n\telse\n\t\tnumtostr(J, \"%.*e\", width, self->u.number);\n}\n\nstatic void Np_toPrecision(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tint width = js_tointeger(J, 1);\n\tchar buf[32];\n\tdouble x;\n\tif (self->type != JS_CNUMBER) js_typeerror(J, \"not a number\");\n\tif (width < 1) js_rangeerror(J, \"precision %d out of range\", width);\n\tif (width > 21) js_rangeerror(J, \"precision %d out of range\", width);\n\tx = self->u.number;\n\tif (isnan(x) || isinf(x))\n\t\tjs_pushstring(J, jsV_numbertostring(J, buf, x));\n\telse\n\t\tnumtostr(J, \"%.*g\", width, self->u.number);\n}\n\nvoid jsB_initnumber(js_State *J)\n{\n\tJ->Number_prototype->u.number = 0;\n\n\tjs_pushobject(J, J->Number_prototype);\n\t{\n\t\tjsB_propf(J, \"Number.prototype.valueOf\", Np_valueOf, 0);\n\t\tjsB_propf(J, \"Number.prototype.toString\", Np_toString, 1);\n\t\tjsB_propf(J, \"Number.prototype.toLocaleString\", Np_toString, 0);\n\t\tjsB_propf(J, \"Number.prototype.toFixed\", Np_toFixed, 1);\n\t\tjsB_propf(J, \"Number.prototype.toExponential\", Np_toExponential, 1);\n\t\tjsB_propf(J, \"Number.prototype.toPrecision\", Np_toPrecision, 1);\n\t}\n\tjs_newcconstructor(J, jsB_Number, jsB_new_Number, \"Number\", 0); /* 1 */\n\t{\n\t\tjsB_propn(J, \"MAX_VALUE\", 1.7976931348623157e+308);\n\t\tjsB_propn(J, \"MIN_VALUE\", 5e-324);\n\t\tjsB_propn(J, \"NaN\", NAN);\n\t\tjsB_propn(J, \"NEGATIVE_INFINITY\", -INFINITY);\n\t\tjsB_propn(J, \"POSITIVE_INFINITY\", INFINITY);\n\t}\n\tjs_defglobal(J, \"Number\", JS_DONTENUM);\n}\n"], "fixing_code": ["#include \"jsi.h\"\n#include \"jsvalue.h\"\n#include \"jsbuiltin.h\"\n\n#if defined(_MSC_VER) && (_MSC_VER < 1700) /* VS2012 has stdint.h */\ntypedef unsigned __int64 uint64_t;\n#else\n#include <stdint.h>\n#endif\n\nstatic void jsB_new_Number(js_State *J)\n{\n\tjs_newnumber(J, js_gettop(J) > 1 ? js_tonumber(J, 1) : 0);\n}\n\nstatic void jsB_Number(js_State *J)\n{\n\tjs_pushnumber(J, js_gettop(J) > 1 ? js_tonumber(J, 1) : 0);\n}\n\nstatic void Np_valueOf(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tif (self->type != JS_CNUMBER) js_typeerror(J, \"not a number\");\n\tjs_pushnumber(J, self->u.number);\n}\n\nstatic void Np_toString(js_State *J)\n{\n\tchar buf[100];\n\tjs_Object *self = js_toobject(J, 0);\n\tint radix = js_isundefined(J, 1) ? 10 : js_tointeger(J, 1);\n\tif (self->type != JS_CNUMBER)\n\t\tjs_typeerror(J, \"not a number\");\n\tif (radix == 10) {\n\t\tjs_pushstring(J, jsV_numbertostring(J, buf, self->u.number));\n\t\treturn;\n\t}\n\tif (radix < 2 || radix > 36)\n\t\tjs_rangeerror(J, \"invalid radix\");\n\n\t/* lame number to string conversion for any radix from 2 to 36 */\n\t{\n\t\tstatic const char digits[] = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\t\tdouble number = self->u.number;\n\t\tint sign = self->u.number < 0;\n\t\tjs_Buffer *sb = NULL;\n\t\tuint64_t u, limit = ((uint64_t)1<<52);\n\n\t\tint ndigits, exp, point;\n\n\t\tif (number == 0) { js_pushstring(J, \"0\"); return; }\n\t\tif (isnan(number)) { js_pushstring(J, \"NaN\"); return; }\n\t\tif (isinf(number)) { js_pushstring(J, sign ? \"-Infinity\" : \"Infinity\"); return; }\n\n\t\tif (sign)\n\t\t\tnumber = -number;\n\n\t\t/* fit as many digits as we want in an int */\n\t\texp = 0;\n\t\twhile (number * pow(radix, exp) > limit)\n\t\t\t--exp;\n\t\twhile (number * pow(radix, exp+1) < limit)\n\t\t\t++exp;\n\t\tu = number * pow(radix, exp) + 0.5;\n\n\t\t/* trim trailing zeros */\n\t\twhile (u > 0 && (u % radix) == 0) {\n\t\t\tu /= radix;\n\t\t\t--exp;\n\t\t}\n\n\t\t/* serialize digits */\n\t\tndigits = 0;\n\t\twhile (u > 0) {\n\t\t\tbuf[ndigits++] = digits[u % radix];\n\t\t\tu /= radix;\n\t\t}\n\t\tpoint = ndigits - exp;\n\n\t\tif (js_try(J)) {\n\t\t\tjs_free(J, sb);\n\t\t\tjs_throw(J);\n\t\t}\n\n\t\tif (sign)\n\t\t\tjs_putc(J, &sb, '-');\n\n\t\tif (point <= 0) {\n\t\t\tjs_putc(J, &sb, '0');\n\t\t\tjs_putc(J, &sb, '.');\n\t\t\twhile (point++ < 0)\n\t\t\t\tjs_putc(J, &sb, '0');\n\t\t\twhile (ndigits-- > 0)\n\t\t\t\tjs_putc(J, &sb, buf[ndigits]);\n\t\t} else {\n\t\t\twhile (ndigits-- > 0) {\n\t\t\t\tjs_putc(J, &sb, buf[ndigits]);\n\t\t\t\tif (--point == 0 && ndigits > 0)\n\t\t\t\t\tjs_putc(J, &sb, '.');\n\t\t\t}\n\t\t\twhile (point-- > 0)\n\t\t\t\tjs_putc(J, &sb, '0');\n\t\t}\n\n\t\tjs_putc(J, &sb, 0);\n\t\tjs_pushstring(J, sb->s);\n\n\t\tjs_endtry(J);\n\t\tjs_free(J, sb);\n\t}\n}\n\n/* Customized ToString() on a number */\nstatic void numtostr(js_State *J, const char *fmt, int w, double n)\n{\n\t/* buf needs to fit printf(\"%.20f\", 1e20) */\n\tchar buf[50], *e;\n\tsprintf(buf, fmt, w, n);\n\te = strchr(buf, 'e');\n\tif (e) {\n\t\tint exp = atoi(e+1);\n\t\tsprintf(e, \"e%+d\", exp);\n\t}\n\tjs_pushstring(J, buf);\n}\n\nstatic void Np_toFixed(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tint width = js_tointeger(J, 1);\n\tchar buf[32];\n\tdouble x;\n\tif (self->type != JS_CNUMBER) js_typeerror(J, \"not a number\");\n\tif (width < 0) js_rangeerror(J, \"precision %d out of range\", width);\n\tif (width > 20) js_rangeerror(J, \"precision %d out of range\", width);\n\tx = self->u.number;\n\tif (isnan(x) || isinf(x) || x <= -1e21 || x >= 1e21)\n\t\tjs_pushstring(J, jsV_numbertostring(J, buf, x));\n\telse\n\t\tnumtostr(J, \"%.*f\", width, x);\n}\n\nstatic void Np_toExponential(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tint width = js_tointeger(J, 1);\n\tchar buf[32];\n\tdouble x;\n\tif (self->type != JS_CNUMBER) js_typeerror(J, \"not a number\");\n\tif (width < 0) js_rangeerror(J, \"precision %d out of range\", width);\n\tif (width > 20) js_rangeerror(J, \"precision %d out of range\", width);\n\tx = self->u.number;\n\tif (isnan(x) || isinf(x))\n\t\tjs_pushstring(J, jsV_numbertostring(J, buf, x));\n\telse\n\t\tnumtostr(J, \"%.*e\", width, self->u.number);\n}\n\nstatic void Np_toPrecision(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tint width = js_tointeger(J, 1);\n\tchar buf[32];\n\tdouble x;\n\tif (self->type != JS_CNUMBER) js_typeerror(J, \"not a number\");\n\tif (width < 1) js_rangeerror(J, \"precision %d out of range\", width);\n\tif (width > 21) js_rangeerror(J, \"precision %d out of range\", width);\n\tx = self->u.number;\n\tif (isnan(x) || isinf(x))\n\t\tjs_pushstring(J, jsV_numbertostring(J, buf, x));\n\telse\n\t\tnumtostr(J, \"%.*g\", width, self->u.number);\n}\n\nvoid jsB_initnumber(js_State *J)\n{\n\tJ->Number_prototype->u.number = 0;\n\n\tjs_pushobject(J, J->Number_prototype);\n\t{\n\t\tjsB_propf(J, \"Number.prototype.valueOf\", Np_valueOf, 0);\n\t\tjsB_propf(J, \"Number.prototype.toString\", Np_toString, 1);\n\t\tjsB_propf(J, \"Number.prototype.toLocaleString\", Np_toString, 0);\n\t\tjsB_propf(J, \"Number.prototype.toFixed\", Np_toFixed, 1);\n\t\tjsB_propf(J, \"Number.prototype.toExponential\", Np_toExponential, 1);\n\t\tjsB_propf(J, \"Number.prototype.toPrecision\", Np_toPrecision, 1);\n\t}\n\tjs_newcconstructor(J, jsB_Number, jsB_new_Number, \"Number\", 0); /* 1 */\n\t{\n\t\tjsB_propn(J, \"MAX_VALUE\", 1.7976931348623157e+308);\n\t\tjsB_propn(J, \"MIN_VALUE\", 5e-324);\n\t\tjsB_propn(J, \"NaN\", NAN);\n\t\tjsB_propn(J, \"NEGATIVE_INFINITY\", -INFINITY);\n\t\tjsB_propn(J, \"POSITIVE_INFINITY\", INFINITY);\n\t}\n\tjs_defglobal(J, \"Number\", JS_DONTENUM);\n}\n"], "filenames": ["jsnumber.c"], "buggy_code_start_loc": [30], "buggy_code_end_loc": [119], "fixing_code_start_loc": [30], "fixing_code_end_loc": [119], "type": "CWE-787", "message": "An issue was discovered in Artifex MuJS 1.0.5. The Number#toFixed() and numtostr implementations in jsnumber.c have a stack-based buffer overflow.", "other": {"cve": {"id": "CVE-2019-11411", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-22T11:29:04.923", "lastModified": "2020-11-10T03:15:11.397", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in Artifex MuJS 1.0.5. The Number#toFixed() and numtostr implementations in jsnumber.c have a stack-based buffer overflow."}, {"lang": "es", "value": "Se ha descubierto un problema en Artifex MuJS versi\u00f3n 1.0.5. Las implementaciones Number#toFixed() y numtostr en jsnumber.c tienen un desbordamiento de b\u00fafer basado en pila."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:artifex:mujs:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "3FA24B50-E74E-4790-928D-DAD8CC042C09"}]}]}], "references": [{"url": "http://www.ghostscript.com/cgi-bin/findgit.cgi?da632ca08f240590d2dec786722ed08486ce1be6", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/108093", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.ghostscript.com/show_bug.cgi?id=700938", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Permissions Required", "Vendor Advisory"]}, {"url": "https://github.com/ccxvii/mujs/commit/da632ca08f240590d2dec786722ed08486ce1be6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3RQXMWEOWCGLOLFBQSXBM3MBN33T4I5H/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/67PMOZV4DLVL2KGU2SV724QL7Y4PKWKU/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MFCRO74ORRIVWNVAX2MAMRY3THCTWLQI/", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/202007-52", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ccxvii/mujs/commit/da632ca08f240590d2dec786722ed08486ce1be6"}}