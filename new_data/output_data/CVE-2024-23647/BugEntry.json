{"buggy_code": ["\"\"\"authentik OAuth2 Token views\"\"\"\nfrom base64 import urlsafe_b64encode\nfrom dataclasses import InitVar, dataclass\nfrom datetime import datetime\nfrom hashlib import sha256\nfrom re import error as RegexError\nfrom re import fullmatch\nfrom typing import Any, Optional\nfrom urllib.parse import urlparse\n\nfrom django.http import HttpRequest, HttpResponse\nfrom django.utils import timezone\nfrom django.utils.decorators import method_decorator\nfrom django.views import View\nfrom django.views.decorators.csrf import csrf_exempt\nfrom guardian.shortcuts import get_anonymous_user\nfrom jwt import PyJWK, PyJWT, PyJWTError, decode\nfrom sentry_sdk.hub import Hub\nfrom structlog.stdlib import get_logger\n\nfrom authentik.core.middleware import CTX_AUTH_VIA\nfrom authentik.core.models import (\n    USER_ATTRIBUTE_EXPIRES,\n    USER_ATTRIBUTE_GENERATED,\n    Application,\n    Token,\n    TokenIntents,\n    User,\n)\nfrom authentik.events.models import Event, EventAction\nfrom authentik.events.signals import get_login_event\nfrom authentik.flows.planner import PLAN_CONTEXT_APPLICATION\nfrom authentik.lib.utils.time import timedelta_from_string\nfrom authentik.policies.engine import PolicyEngine\nfrom authentik.providers.oauth2.constants import (\n    CLIENT_ASSERTION,\n    CLIENT_ASSERTION_TYPE,\n    CLIENT_ASSERTION_TYPE_JWT,\n    GRANT_TYPE_AUTHORIZATION_CODE,\n    GRANT_TYPE_CLIENT_CREDENTIALS,\n    GRANT_TYPE_DEVICE_CODE,\n    GRANT_TYPE_PASSWORD,\n    GRANT_TYPE_REFRESH_TOKEN,\n    PKCE_METHOD_S256,\n    SCOPE_OFFLINE_ACCESS,\n    TOKEN_TYPE,\n)\nfrom authentik.providers.oauth2.errors import DeviceCodeError, TokenError, UserAuthError\nfrom authentik.providers.oauth2.id_token import IDToken\nfrom authentik.providers.oauth2.models import (\n    AccessToken,\n    AuthorizationCode,\n    ClientTypes,\n    DeviceToken,\n    OAuth2Provider,\n    RefreshToken,\n)\nfrom authentik.providers.oauth2.utils import TokenResponse, cors_allow, extract_client_auth\nfrom authentik.providers.oauth2.views.authorize import FORBIDDEN_URI_SCHEMES\nfrom authentik.sources.oauth.models import OAuthSource\nfrom authentik.stages.password.stage import PLAN_CONTEXT_METHOD, PLAN_CONTEXT_METHOD_ARGS\n\nLOGGER = get_logger()\n\n\n@dataclass(slots=True)\n# pylint: disable=too-many-instance-attributes\nclass TokenParams:\n    \"\"\"Token params\"\"\"\n\n    client_id: str\n    client_secret: str\n    redirect_uri: str\n    grant_type: str\n    state: str\n    scope: list[str]\n\n    provider: OAuth2Provider\n\n    authorization_code: Optional[AuthorizationCode] = None\n    refresh_token: Optional[RefreshToken] = None\n    device_code: Optional[DeviceToken] = None\n    user: Optional[User] = None\n\n    code_verifier: Optional[str] = None\n\n    raw_code: InitVar[str] = \"\"\n    raw_token: InitVar[str] = \"\"\n    request: InitVar[Optional[HttpRequest]] = None\n\n    @staticmethod\n    def parse(\n        request: HttpRequest,\n        provider: OAuth2Provider,\n        client_id: str,\n        client_secret: str,\n    ) -> \"TokenParams\":\n        \"\"\"Parse params for request\"\"\"\n        return TokenParams(\n            # Init vars\n            raw_code=request.POST.get(\"code\", \"\"),\n            raw_token=request.POST.get(\"refresh_token\", \"\"),\n            request=request,\n            # Regular params\n            provider=provider,\n            client_id=client_id,\n            client_secret=client_secret,\n            redirect_uri=request.POST.get(\"redirect_uri\", \"\"),\n            grant_type=request.POST.get(\"grant_type\", \"\"),\n            state=request.POST.get(\"state\", \"\"),\n            scope=request.POST.get(\"scope\", \"\").split(),\n            # PKCE parameter.\n            code_verifier=request.POST.get(\"code_verifier\"),\n        )\n\n    def __check_policy_access(self, app: Application, request: HttpRequest, **kwargs):\n        with Hub.current.start_span(\n            op=\"authentik.providers.oauth2.token.policy\",\n        ):\n            user = self.user if self.user else get_anonymous_user()\n            engine = PolicyEngine(app, user, request)\n            # Don't cache as for client_credentials flows the user will not be set\n            # so we'll get generic cache results\n            engine.use_cache = False\n            engine.request.context[\"oauth_scopes\"] = self.scope\n            engine.request.context[\"oauth_grant_type\"] = self.grant_type\n            engine.request.context[\"oauth_code_verifier\"] = self.code_verifier\n            engine.request.context.update(kwargs)\n            engine.build()\n            result = engine.result\n            if not result.passing:\n                LOGGER.info(\n                    \"User not authenticated for application\", user=self.user, app_slug=app.slug\n                )\n                raise TokenError(\"invalid_grant\")\n\n    def __post_init__(self, raw_code: str, raw_token: str, request: HttpRequest):\n        if self.grant_type in [GRANT_TYPE_AUTHORIZATION_CODE, GRANT_TYPE_REFRESH_TOKEN]:\n            if (\n                self.provider.client_type == ClientTypes.CONFIDENTIAL\n                and self.provider.client_secret != self.client_secret\n            ):\n                LOGGER.warning(\n                    \"Invalid client secret\",\n                    client_id=self.provider.client_id,\n                )\n                raise TokenError(\"invalid_client\")\n\n        if self.grant_type == GRANT_TYPE_AUTHORIZATION_CODE:\n            with Hub.current.start_span(\n                op=\"authentik.providers.oauth2.post.parse.code\",\n            ):\n                self.__post_init_code(raw_code, request)\n        elif self.grant_type == GRANT_TYPE_REFRESH_TOKEN:\n            with Hub.current.start_span(\n                op=\"authentik.providers.oauth2.post.parse.refresh\",\n            ):\n                self.__post_init_refresh(raw_token, request)\n        elif self.grant_type in [GRANT_TYPE_CLIENT_CREDENTIALS, GRANT_TYPE_PASSWORD]:\n            with Hub.current.start_span(\n                op=\"authentik.providers.oauth2.post.parse.client_credentials\",\n            ):\n                self.__post_init_client_credentials(request)\n        elif self.grant_type == GRANT_TYPE_DEVICE_CODE:\n            with Hub.current.start_span(\n                op=\"authentik.providers.oauth2.post.parse.device_code\",\n            ):\n                self.__post_init_device_code(request)\n        else:\n            LOGGER.warning(\"Invalid grant type\", grant_type=self.grant_type)\n            raise TokenError(\"unsupported_grant_type\")\n\n    def __post_init_code(self, raw_code: str, request: HttpRequest):\n        if not raw_code:\n            LOGGER.warning(\"Missing authorization code\")\n            raise TokenError(\"invalid_grant\")\n\n        allowed_redirect_urls = self.provider.redirect_uris.split()\n        # At this point, no provider should have a blank redirect_uri, in case they do\n        # this will check an empty array and raise an error\n        try:\n            if not any(fullmatch(x, self.redirect_uri) for x in allowed_redirect_urls):\n                LOGGER.warning(\n                    \"Invalid redirect uri (regex comparison)\",\n                    redirect_uri=self.redirect_uri,\n                    expected=allowed_redirect_urls,\n                )\n                Event.new(\n                    EventAction.CONFIGURATION_ERROR,\n                    message=\"Invalid redirect URI used by provider\",\n                    provider=self.provider,\n                    redirect_uri=self.redirect_uri,\n                    expected=allowed_redirect_urls,\n                ).from_http(request)\n                raise TokenError(\"invalid_client\")\n        except RegexError as exc:\n            LOGGER.info(\"Failed to parse regular expression, checking directly\", exc=exc)\n            if not any(x == self.redirect_uri for x in allowed_redirect_urls):\n                LOGGER.warning(\n                    \"Invalid redirect uri (strict comparison)\",\n                    redirect_uri=self.redirect_uri,\n                    expected=allowed_redirect_urls,\n                )\n                Event.new(\n                    EventAction.CONFIGURATION_ERROR,\n                    message=\"Invalid redirect_uri configured\",\n                    provider=self.provider,\n                ).from_http(request)\n                raise TokenError(\"invalid_client\")\n\n        # Check against forbidden schemes\n        if urlparse(self.redirect_uri).scheme in FORBIDDEN_URI_SCHEMES:\n            raise TokenError(\"invalid_request\")\n\n        self.authorization_code = AuthorizationCode.objects.filter(code=raw_code).first()\n        if not self.authorization_code:\n            LOGGER.warning(\"Code does not exist\", code=raw_code)\n            raise TokenError(\"invalid_grant\")\n\n        if self.authorization_code.is_expired:\n            LOGGER.warning(\n                \"Code is expired\",\n                token=raw_code,\n            )\n            raise TokenError(\"invalid_grant\")\n\n        if self.authorization_code.provider != self.provider or self.authorization_code.is_expired:\n            LOGGER.warning(\"Invalid code: invalid client or code has expired\")\n            raise TokenError(\"invalid_grant\")\n\n        # Validate PKCE parameters.\n        if self.authorization_code.code_challenge:\n            # Authorization code had PKCE but we didn't get one\n            if not self.code_verifier:\n                raise TokenError(\"invalid_request\")\n            if self.authorization_code.code_challenge_method == PKCE_METHOD_S256:\n                new_code_challenge = (\n                    urlsafe_b64encode(sha256(self.code_verifier.encode(\"ascii\")).digest())\n                    .decode(\"utf-8\")\n                    .replace(\"=\", \"\")\n                )\n            else:\n                new_code_challenge = self.code_verifier\n\n            if new_code_challenge != self.authorization_code.code_challenge:\n                LOGGER.warning(\"Code challenge not matching\")\n                raise TokenError(\"invalid_grant\")\n\n    def __post_init_refresh(self, raw_token: str, request: HttpRequest):\n        if not raw_token:\n            LOGGER.warning(\"Missing refresh token\")\n            raise TokenError(\"invalid_grant\")\n\n        self.refresh_token = RefreshToken.objects.filter(\n            token=raw_token, provider=self.provider\n        ).first()\n        if not self.refresh_token:\n            LOGGER.warning(\n                \"Refresh token does not exist\",\n                token=raw_token,\n            )\n            raise TokenError(\"invalid_grant\")\n        if self.refresh_token.is_expired:\n            LOGGER.warning(\n                \"Refresh token is expired\",\n                token=raw_token,\n            )\n            raise TokenError(\"invalid_grant\")\n        # https://datatracker.ietf.org/doc/html/rfc6749#section-6\n        # Fallback to original token's scopes when none are given\n        if not self.scope:\n            self.scope = self.refresh_token.scope\n        if self.refresh_token.revoked:\n            LOGGER.warning(\"Refresh token is revoked\", token=raw_token)\n            Event.new(\n                action=EventAction.SUSPICIOUS_REQUEST,\n                message=\"Revoked refresh token was used\",\n                token=self.refresh_token,\n                provider=self.refresh_token.provider,\n            ).from_http(request, user=self.refresh_token.user)\n            raise TokenError(\"invalid_grant\")\n\n    def __post_init_client_credentials(self, request: HttpRequest):\n        if request.POST.get(CLIENT_ASSERTION_TYPE, \"\") != \"\":\n            return self.__post_init_client_credentials_jwt(request)\n        # Authenticate user based on credentials\n        username = request.POST.get(\"username\")\n        password = request.POST.get(\"password\")\n        user = User.objects.filter(username=username).first()\n        if not user:\n            raise TokenError(\"invalid_grant\")\n        token: Token = Token.filter_not_expired(\n            key=password, intent=TokenIntents.INTENT_APP_PASSWORD\n        ).first()\n        if not token or token.user.uid != user.uid:\n            raise TokenError(\"invalid_grant\")\n        self.user = user\n        # Authorize user access\n        app = Application.objects.filter(provider=self.provider).first()\n        if not app or not app.provider:\n            raise TokenError(\"invalid_grant\")\n        self.__check_policy_access(app, request)\n\n        Event.new(\n            action=EventAction.LOGIN,\n            **{\n                PLAN_CONTEXT_METHOD: \"token\",\n                PLAN_CONTEXT_METHOD_ARGS: {\n                    \"identifier\": token.identifier,\n                },\n                PLAN_CONTEXT_APPLICATION: app,\n            },\n        ).from_http(request, user=user)\n        return None\n\n    # pylint: disable=too-many-locals\n    def __post_init_client_credentials_jwt(self, request: HttpRequest):\n        assertion_type = request.POST.get(CLIENT_ASSERTION_TYPE, \"\")\n        if assertion_type != CLIENT_ASSERTION_TYPE_JWT:\n            LOGGER.warning(\"Invalid assertion type\", assertion_type=assertion_type)\n            raise TokenError(\"invalid_grant\")\n\n        client_secret = request.POST.get(\"client_secret\", None)\n        assertion = request.POST.get(CLIENT_ASSERTION, client_secret)\n        if not assertion:\n            LOGGER.warning(\"Missing client assertion\")\n            raise TokenError(\"invalid_grant\")\n\n        token = None\n\n        source: Optional[OAuthSource] = None\n        parsed_key: Optional[PyJWK] = None\n\n        # Fully decode the JWT without verifying the signature, so we can get access to\n        # the header.\n        # Get the Key ID from the header, and use that to optimise our source query to only find\n        # sources that have a JWK for that Key ID\n        # The Key ID doesn't have a fixed format, but must match between an issued JWT\n        # and whatever is returned by the JWKS endpoint\n        try:\n            decode_unvalidated = PyJWT().decode_complete(\n                assertion, options={\"verify_signature\": False}\n            )\n        except (PyJWTError, ValueError, TypeError, AttributeError) as exc:\n            LOGGER.warning(\"failed to parse JWT for kid lookup\", exc=exc)\n            raise TokenError(\"invalid_grant\")\n        expected_kid = decode_unvalidated[\"header\"][\"kid\"]\n        for source in self.provider.jwks_sources.filter(\n            oidc_jwks__keys__contains=[{\"kid\": expected_kid}]\n        ):\n            LOGGER.debug(\"verifying JWT with source\", source=source.slug)\n            keys = source.oidc_jwks.get(\"keys\", [])\n            for key in keys:\n                LOGGER.debug(\"verifying JWT with key\", source=source.slug, key=key.get(\"kid\"))\n                try:\n                    parsed_key = PyJWK.from_dict(key)\n                    token = decode(\n                        assertion,\n                        parsed_key.key,\n                        algorithms=[key.get(\"alg\")],\n                        options={\n                            \"verify_aud\": False,\n                        },\n                    )\n                # AttributeError is raised when the configured JWK is a private key\n                # and not a public key\n                except (PyJWTError, ValueError, TypeError, AttributeError) as exc:\n                    LOGGER.warning(\"failed to verify JWT\", exc=exc, source=source.slug)\n\n        if not token:\n            LOGGER.warning(\"No token could be verified\")\n            raise TokenError(\"invalid_grant\")\n\n        LOGGER.info(\"successfully verified JWT with source\", source=source.slug)\n\n        if \"exp\" in token:\n            exp = datetime.fromtimestamp(token[\"exp\"])\n            # Non-timezone aware check since we assume `exp` is in UTC\n            if datetime.now() >= exp:\n                LOGGER.info(\"JWT token expired\")\n                raise TokenError(\"invalid_grant\")\n\n        app = Application.objects.filter(provider=self.provider).first()\n        if not app or not app.provider:\n            LOGGER.info(\"client_credentials grant for provider without application\")\n            raise TokenError(\"invalid_grant\")\n\n        self.__check_policy_access(app, request, oauth_jwt=token)\n        self.__create_user_from_jwt(token, app, source)\n\n        method_args = {\n            \"jwt\": token,\n        }\n        if source:\n            method_args[\"source\"] = source\n        if parsed_key:\n            method_args[\"jwk_id\"] = parsed_key.key_id\n        Event.new(\n            action=EventAction.LOGIN,\n            **{\n                PLAN_CONTEXT_METHOD: \"jwt\",\n                PLAN_CONTEXT_METHOD_ARGS: method_args,\n                PLAN_CONTEXT_APPLICATION: app,\n            },\n        ).from_http(request, user=self.user)\n\n    def __post_init_device_code(self, request: HttpRequest):\n        device_code = request.POST.get(\"device_code\", \"\")\n        code = DeviceToken.objects.filter(device_code=device_code, provider=self.provider).first()\n        if not code:\n            raise TokenError(\"invalid_grant\")\n        self.device_code = code\n\n    def __create_user_from_jwt(self, token: dict[str, Any], app: Application, source: OAuthSource):\n        \"\"\"Create user from JWT\"\"\"\n        exp = token.get(\"exp\")\n        self.user, created = User.objects.update_or_create(\n            username=f\"{self.provider.name}-{token.get('sub')}\",\n            defaults={\n                \"attributes\": {\n                    USER_ATTRIBUTE_GENERATED: True,\n                },\n                \"last_login\": timezone.now(),\n                \"name\": f\"Autogenerated user from application {app.name} (client credentials JWT)\",\n                \"path\": source.get_user_path(),\n            },\n        )\n        if created and exp:\n            self.user.attributes[USER_ATTRIBUTE_EXPIRES] = exp\n            self.user.save()\n\n\n@method_decorator(csrf_exempt, name=\"dispatch\")\nclass TokenView(View):\n    \"\"\"Generate tokens for clients\"\"\"\n\n    provider: Optional[OAuth2Provider] = None\n    params: Optional[TokenParams] = None\n\n    def dispatch(self, request: HttpRequest, *args: Any, **kwargs: Any) -> HttpResponse:\n        response = super().dispatch(request, *args, **kwargs)\n        allowed_origins = []\n        if self.provider:\n            allowed_origins = self.provider.redirect_uris.split(\"\\n\")\n        cors_allow(self.request, response, *allowed_origins)\n        return response\n\n    def options(self, request: HttpRequest) -> HttpResponse:\n        return TokenResponse({})\n\n    def post(self, request: HttpRequest) -> HttpResponse:\n        \"\"\"Generate tokens for clients\"\"\"\n        try:\n            with Hub.current.start_span(\n                op=\"authentik.providers.oauth2.post.parse\",\n            ):\n                client_id, client_secret = extract_client_auth(request)\n                self.provider = OAuth2Provider.objects.filter(client_id=client_id).first()\n                if not self.provider:\n                    LOGGER.warning(\"OAuth2Provider does not exist\", client_id=client_id)\n                    raise TokenError(\"invalid_client\")\n                CTX_AUTH_VIA.set(\"oauth_client_secret\")\n                self.params = TokenParams.parse(request, self.provider, client_id, client_secret)\n\n            with Hub.current.start_span(\n                op=\"authentik.providers.oauth2.post.response\",\n            ):\n                if self.params.grant_type == GRANT_TYPE_AUTHORIZATION_CODE:\n                    LOGGER.debug(\"Converting authorization code to access token\")\n                    return TokenResponse(self.create_code_response())\n                if self.params.grant_type == GRANT_TYPE_REFRESH_TOKEN:\n                    LOGGER.debug(\"Refreshing refresh token\")\n                    return TokenResponse(self.create_refresh_response())\n                if self.params.grant_type in [GRANT_TYPE_CLIENT_CREDENTIALS, GRANT_TYPE_PASSWORD]:\n                    LOGGER.debug(\"Client credentials/password grant\")\n                    return TokenResponse(self.create_client_credentials_response())\n                if self.params.grant_type == GRANT_TYPE_DEVICE_CODE:\n                    LOGGER.debug(\"Device code grant\")\n                    return TokenResponse(self.create_device_code_response())\n                raise TokenError(\"unsupported_grant_type\")\n        except (TokenError, DeviceCodeError) as error:\n            return TokenResponse(error.create_dict(), status=400)\n        except UserAuthError as error:\n            return TokenResponse(error.create_dict(), status=403)\n\n    def create_code_response(self) -> dict[str, Any]:\n        \"\"\"See https://datatracker.ietf.org/doc/html/rfc6749#section-4.1\"\"\"\n        now = timezone.now()\n        access_token_expiry = now + timedelta_from_string(self.provider.access_token_validity)\n        access_token = AccessToken(\n            provider=self.provider,\n            user=self.params.authorization_code.user,\n            expires=access_token_expiry,\n            # Keep same scopes as previous token\n            scope=self.params.authorization_code.scope,\n            auth_time=self.params.authorization_code.auth_time,\n            session_id=self.params.authorization_code.session_id,\n        )\n        access_id_token = IDToken.new(\n            self.provider,\n            access_token,\n            self.request,\n        )\n        access_id_token.nonce = self.params.authorization_code.nonce\n        access_token.id_token = access_id_token\n        access_token.save()\n\n        response = {\n            \"access_token\": access_token.token,\n            \"token_type\": TOKEN_TYPE,\n            \"expires_in\": int(\n                timedelta_from_string(self.provider.access_token_validity).total_seconds()\n            ),\n            \"id_token\": access_token.id_token.to_jwt(self.provider),\n        }\n\n        if SCOPE_OFFLINE_ACCESS in self.params.authorization_code.scope:\n            refresh_token_expiry = now + timedelta_from_string(self.provider.refresh_token_validity)\n            refresh_token = RefreshToken(\n                user=self.params.authorization_code.user,\n                scope=self.params.authorization_code.scope,\n                expires=refresh_token_expiry,\n                provider=self.provider,\n                auth_time=self.params.authorization_code.auth_time,\n                session_id=self.params.authorization_code.session_id,\n            )\n            id_token = IDToken.new(\n                self.provider,\n                refresh_token,\n                self.request,\n            )\n            id_token.nonce = self.params.authorization_code.nonce\n            id_token.at_hash = access_token.at_hash\n            refresh_token.id_token = id_token\n            refresh_token.save()\n            response[\"refresh_token\"] = refresh_token.token\n\n        # Delete old code\n        self.params.authorization_code.delete()\n        return response\n\n    def create_refresh_response(self) -> dict[str, Any]:\n        \"\"\"See https://datatracker.ietf.org/doc/html/rfc6749#section-6\"\"\"\n        unauthorized_scopes = set(self.params.scope) - set(self.params.refresh_token.scope)\n        if unauthorized_scopes:\n            raise TokenError(\"invalid_scope\")\n        if SCOPE_OFFLINE_ACCESS not in self.params.scope:\n            raise TokenError(\"invalid_scope\")\n        now = timezone.now()\n        access_token_expiry = now + timedelta_from_string(self.provider.access_token_validity)\n        access_token = AccessToken(\n            provider=self.provider,\n            user=self.params.refresh_token.user,\n            expires=access_token_expiry,\n            # Keep same scopes as previous token\n            scope=self.params.refresh_token.scope,\n            auth_time=self.params.refresh_token.auth_time,\n            session_id=self.params.refresh_token.session_id,\n        )\n        access_token.id_token = IDToken.new(\n            self.provider,\n            access_token,\n            self.request,\n        )\n        access_token.save()\n\n        refresh_token_expiry = now + timedelta_from_string(self.provider.refresh_token_validity)\n        refresh_token = RefreshToken(\n            user=self.params.refresh_token.user,\n            scope=self.params.refresh_token.scope,\n            expires=refresh_token_expiry,\n            provider=self.provider,\n            auth_time=self.params.refresh_token.auth_time,\n            session_id=self.params.refresh_token.session_id,\n        )\n        id_token = IDToken.new(\n            self.provider,\n            refresh_token,\n            self.request,\n        )\n        id_token.nonce = self.params.refresh_token.id_token.nonce\n        id_token.at_hash = access_token.at_hash\n        refresh_token.id_token = id_token\n        refresh_token.save()\n\n        # Mark old token as revoked\n        self.params.refresh_token.revoked = True\n        self.params.refresh_token.save()\n\n        return {\n            \"access_token\": access_token.token,\n            \"refresh_token\": refresh_token.token,\n            \"token_type\": TOKEN_TYPE,\n            \"expires_in\": int(\n                timedelta_from_string(self.provider.access_token_validity).total_seconds()\n            ),\n            \"id_token\": id_token.to_jwt(self.provider),\n        }\n\n    def create_client_credentials_response(self) -> dict[str, Any]:\n        \"\"\"See https://datatracker.ietf.org/doc/html/rfc6749#section-4.4\"\"\"\n        now = timezone.now()\n        access_token_expiry = now + timedelta_from_string(self.provider.access_token_validity)\n        access_token = AccessToken(\n            provider=self.provider,\n            user=self.params.user,\n            expires=access_token_expiry,\n            scope=self.params.scope,\n            auth_time=now,\n        )\n        access_token.id_token = IDToken.new(\n            self.provider,\n            access_token,\n            self.request,\n        )\n        access_token.save()\n        return {\n            \"access_token\": access_token.token,\n            \"token_type\": TOKEN_TYPE,\n            \"expires_in\": int(\n                timedelta_from_string(self.provider.access_token_validity).total_seconds()\n            ),\n            \"id_token\": access_token.id_token.to_jwt(self.provider),\n        }\n\n    def create_device_code_response(self) -> dict[str, Any]:\n        \"\"\"See https://datatracker.ietf.org/doc/html/rfc8628\"\"\"\n        if not self.params.device_code.user:\n            raise DeviceCodeError(\"authorization_pending\")\n        now = timezone.now()\n        access_token_expiry = now + timedelta_from_string(self.provider.access_token_validity)\n        auth_event = get_login_event(self.request)\n        access_token = AccessToken(\n            provider=self.provider,\n            user=self.params.device_code.user,\n            expires=access_token_expiry,\n            scope=self.params.device_code.scope,\n            auth_time=auth_event.created if auth_event else now,\n        )\n        access_token.id_token = IDToken.new(\n            self.provider,\n            access_token,\n            self.request,\n        )\n        access_token.save()\n\n        response = {\n            \"access_token\": access_token.token,\n            \"token_type\": TOKEN_TYPE,\n            \"expires_in\": int(\n                timedelta_from_string(self.provider.access_token_validity).total_seconds()\n            ),\n            \"id_token\": access_token.id_token.to_jwt(self.provider),\n        }\n\n        if SCOPE_OFFLINE_ACCESS in self.params.scope:\n            refresh_token_expiry = now + timedelta_from_string(self.provider.refresh_token_validity)\n            refresh_token = RefreshToken(\n                user=self.params.device_code.user,\n                scope=self.params.device_code.scope,\n                expires=refresh_token_expiry,\n                provider=self.provider,\n                auth_time=auth_event.created if auth_event else now,\n            )\n            id_token = IDToken.new(\n                self.provider,\n                refresh_token,\n                self.request,\n            )\n            id_token.at_hash = access_token.at_hash\n            refresh_token.id_token = id_token\n            refresh_token.save()\n            response[\"refresh_token\"] = refresh_token.token\n\n        # Delete device code\n        self.params.device_code.delete()\n        return response\n"], "fixing_code": ["\"\"\"authentik OAuth2 Token views\"\"\"\nfrom base64 import urlsafe_b64encode\nfrom dataclasses import InitVar, dataclass\nfrom datetime import datetime\nfrom hashlib import sha256\nfrom re import error as RegexError\nfrom re import fullmatch\nfrom typing import Any, Optional\nfrom urllib.parse import urlparse\n\nfrom django.http import HttpRequest, HttpResponse\nfrom django.utils import timezone\nfrom django.utils.decorators import method_decorator\nfrom django.views import View\nfrom django.views.decorators.csrf import csrf_exempt\nfrom guardian.shortcuts import get_anonymous_user\nfrom jwt import PyJWK, PyJWT, PyJWTError, decode\nfrom sentry_sdk.hub import Hub\nfrom structlog.stdlib import get_logger\n\nfrom authentik.core.middleware import CTX_AUTH_VIA\nfrom authentik.core.models import (\n    USER_ATTRIBUTE_EXPIRES,\n    USER_ATTRIBUTE_GENERATED,\n    Application,\n    Token,\n    TokenIntents,\n    User,\n)\nfrom authentik.events.models import Event, EventAction\nfrom authentik.events.signals import get_login_event\nfrom authentik.flows.planner import PLAN_CONTEXT_APPLICATION\nfrom authentik.lib.utils.time import timedelta_from_string\nfrom authentik.policies.engine import PolicyEngine\nfrom authentik.providers.oauth2.constants import (\n    CLIENT_ASSERTION,\n    CLIENT_ASSERTION_TYPE,\n    CLIENT_ASSERTION_TYPE_JWT,\n    GRANT_TYPE_AUTHORIZATION_CODE,\n    GRANT_TYPE_CLIENT_CREDENTIALS,\n    GRANT_TYPE_DEVICE_CODE,\n    GRANT_TYPE_PASSWORD,\n    GRANT_TYPE_REFRESH_TOKEN,\n    PKCE_METHOD_S256,\n    SCOPE_OFFLINE_ACCESS,\n    TOKEN_TYPE,\n)\nfrom authentik.providers.oauth2.errors import DeviceCodeError, TokenError, UserAuthError\nfrom authentik.providers.oauth2.id_token import IDToken\nfrom authentik.providers.oauth2.models import (\n    AccessToken,\n    AuthorizationCode,\n    ClientTypes,\n    DeviceToken,\n    OAuth2Provider,\n    RefreshToken,\n)\nfrom authentik.providers.oauth2.utils import TokenResponse, cors_allow, extract_client_auth\nfrom authentik.providers.oauth2.views.authorize import FORBIDDEN_URI_SCHEMES\nfrom authentik.sources.oauth.models import OAuthSource\nfrom authentik.stages.password.stage import PLAN_CONTEXT_METHOD, PLAN_CONTEXT_METHOD_ARGS\n\nLOGGER = get_logger()\n\n\n@dataclass(slots=True)\n# pylint: disable=too-many-instance-attributes\nclass TokenParams:\n    \"\"\"Token params\"\"\"\n\n    client_id: str\n    client_secret: str\n    redirect_uri: str\n    grant_type: str\n    state: str\n    scope: list[str]\n\n    provider: OAuth2Provider\n\n    authorization_code: Optional[AuthorizationCode] = None\n    refresh_token: Optional[RefreshToken] = None\n    device_code: Optional[DeviceToken] = None\n    user: Optional[User] = None\n\n    code_verifier: Optional[str] = None\n\n    raw_code: InitVar[str] = \"\"\n    raw_token: InitVar[str] = \"\"\n    request: InitVar[Optional[HttpRequest]] = None\n\n    @staticmethod\n    def parse(\n        request: HttpRequest,\n        provider: OAuth2Provider,\n        client_id: str,\n        client_secret: str,\n    ) -> \"TokenParams\":\n        \"\"\"Parse params for request\"\"\"\n        return TokenParams(\n            # Init vars\n            raw_code=request.POST.get(\"code\", \"\"),\n            raw_token=request.POST.get(\"refresh_token\", \"\"),\n            request=request,\n            # Regular params\n            provider=provider,\n            client_id=client_id,\n            client_secret=client_secret,\n            redirect_uri=request.POST.get(\"redirect_uri\", \"\"),\n            grant_type=request.POST.get(\"grant_type\", \"\"),\n            state=request.POST.get(\"state\", \"\"),\n            scope=request.POST.get(\"scope\", \"\").split(),\n            # PKCE parameter.\n            code_verifier=request.POST.get(\"code_verifier\"),\n        )\n\n    def __check_policy_access(self, app: Application, request: HttpRequest, **kwargs):\n        with Hub.current.start_span(\n            op=\"authentik.providers.oauth2.token.policy\",\n        ):\n            user = self.user if self.user else get_anonymous_user()\n            engine = PolicyEngine(app, user, request)\n            # Don't cache as for client_credentials flows the user will not be set\n            # so we'll get generic cache results\n            engine.use_cache = False\n            engine.request.context[\"oauth_scopes\"] = self.scope\n            engine.request.context[\"oauth_grant_type\"] = self.grant_type\n            engine.request.context[\"oauth_code_verifier\"] = self.code_verifier\n            engine.request.context.update(kwargs)\n            engine.build()\n            result = engine.result\n            if not result.passing:\n                LOGGER.info(\n                    \"User not authenticated for application\", user=self.user, app_slug=app.slug\n                )\n                raise TokenError(\"invalid_grant\")\n\n    def __post_init__(self, raw_code: str, raw_token: str, request: HttpRequest):\n        if self.grant_type in [GRANT_TYPE_AUTHORIZATION_CODE, GRANT_TYPE_REFRESH_TOKEN]:\n            if (\n                self.provider.client_type == ClientTypes.CONFIDENTIAL\n                and self.provider.client_secret != self.client_secret\n            ):\n                LOGGER.warning(\n                    \"Invalid client secret\",\n                    client_id=self.provider.client_id,\n                )\n                raise TokenError(\"invalid_client\")\n\n        if self.grant_type == GRANT_TYPE_AUTHORIZATION_CODE:\n            with Hub.current.start_span(\n                op=\"authentik.providers.oauth2.post.parse.code\",\n            ):\n                self.__post_init_code(raw_code, request)\n        elif self.grant_type == GRANT_TYPE_REFRESH_TOKEN:\n            with Hub.current.start_span(\n                op=\"authentik.providers.oauth2.post.parse.refresh\",\n            ):\n                self.__post_init_refresh(raw_token, request)\n        elif self.grant_type in [GRANT_TYPE_CLIENT_CREDENTIALS, GRANT_TYPE_PASSWORD]:\n            with Hub.current.start_span(\n                op=\"authentik.providers.oauth2.post.parse.client_credentials\",\n            ):\n                self.__post_init_client_credentials(request)\n        elif self.grant_type == GRANT_TYPE_DEVICE_CODE:\n            with Hub.current.start_span(\n                op=\"authentik.providers.oauth2.post.parse.device_code\",\n            ):\n                self.__post_init_device_code(request)\n        else:\n            LOGGER.warning(\"Invalid grant type\", grant_type=self.grant_type)\n            raise TokenError(\"unsupported_grant_type\")\n\n    def __post_init_code(self, raw_code: str, request: HttpRequest):\n        if not raw_code:\n            LOGGER.warning(\"Missing authorization code\")\n            raise TokenError(\"invalid_grant\")\n\n        allowed_redirect_urls = self.provider.redirect_uris.split()\n        # At this point, no provider should have a blank redirect_uri, in case they do\n        # this will check an empty array and raise an error\n        try:\n            if not any(fullmatch(x, self.redirect_uri) for x in allowed_redirect_urls):\n                LOGGER.warning(\n                    \"Invalid redirect uri (regex comparison)\",\n                    redirect_uri=self.redirect_uri,\n                    expected=allowed_redirect_urls,\n                )\n                Event.new(\n                    EventAction.CONFIGURATION_ERROR,\n                    message=\"Invalid redirect URI used by provider\",\n                    provider=self.provider,\n                    redirect_uri=self.redirect_uri,\n                    expected=allowed_redirect_urls,\n                ).from_http(request)\n                raise TokenError(\"invalid_client\")\n        except RegexError as exc:\n            LOGGER.info(\"Failed to parse regular expression, checking directly\", exc=exc)\n            if not any(x == self.redirect_uri for x in allowed_redirect_urls):\n                LOGGER.warning(\n                    \"Invalid redirect uri (strict comparison)\",\n                    redirect_uri=self.redirect_uri,\n                    expected=allowed_redirect_urls,\n                )\n                Event.new(\n                    EventAction.CONFIGURATION_ERROR,\n                    message=\"Invalid redirect_uri configured\",\n                    provider=self.provider,\n                ).from_http(request)\n                raise TokenError(\"invalid_client\")\n\n        # Check against forbidden schemes\n        if urlparse(self.redirect_uri).scheme in FORBIDDEN_URI_SCHEMES:\n            raise TokenError(\"invalid_request\")\n\n        self.authorization_code = AuthorizationCode.objects.filter(code=raw_code).first()\n        if not self.authorization_code:\n            LOGGER.warning(\"Code does not exist\", code=raw_code)\n            raise TokenError(\"invalid_grant\")\n\n        if self.authorization_code.is_expired:\n            LOGGER.warning(\n                \"Code is expired\",\n                token=raw_code,\n            )\n            raise TokenError(\"invalid_grant\")\n\n        if self.authorization_code.provider != self.provider or self.authorization_code.is_expired:\n            LOGGER.warning(\"Invalid code: invalid client or code has expired\")\n            raise TokenError(\"invalid_grant\")\n\n        # Validate PKCE parameters.\n        if self.authorization_code.code_challenge:\n            # Authorization code had PKCE but we didn't get one\n            if not self.code_verifier:\n                raise TokenError(\"invalid_grant\")\n            if self.authorization_code.code_challenge_method == PKCE_METHOD_S256:\n                new_code_challenge = (\n                    urlsafe_b64encode(sha256(self.code_verifier.encode(\"ascii\")).digest())\n                    .decode(\"utf-8\")\n                    .replace(\"=\", \"\")\n                )\n            else:\n                new_code_challenge = self.code_verifier\n\n            if new_code_challenge != self.authorization_code.code_challenge:\n                LOGGER.warning(\"Code challenge not matching\")\n                raise TokenError(\"invalid_grant\")\n        # Token request had a code_verifier but code did not have a code challenge\n        # Prevent downgrade\n        if not self.authorization_code.code_challenge and self.code_verifier:\n            raise TokenError(\"invalid_grant\")\n\n    def __post_init_refresh(self, raw_token: str, request: HttpRequest):\n        if not raw_token:\n            LOGGER.warning(\"Missing refresh token\")\n            raise TokenError(\"invalid_grant\")\n\n        self.refresh_token = RefreshToken.objects.filter(\n            token=raw_token, provider=self.provider\n        ).first()\n        if not self.refresh_token:\n            LOGGER.warning(\n                \"Refresh token does not exist\",\n                token=raw_token,\n            )\n            raise TokenError(\"invalid_grant\")\n        if self.refresh_token.is_expired:\n            LOGGER.warning(\n                \"Refresh token is expired\",\n                token=raw_token,\n            )\n            raise TokenError(\"invalid_grant\")\n        # https://datatracker.ietf.org/doc/html/rfc6749#section-6\n        # Fallback to original token's scopes when none are given\n        if not self.scope:\n            self.scope = self.refresh_token.scope\n        if self.refresh_token.revoked:\n            LOGGER.warning(\"Refresh token is revoked\", token=raw_token)\n            Event.new(\n                action=EventAction.SUSPICIOUS_REQUEST,\n                message=\"Revoked refresh token was used\",\n                token=self.refresh_token,\n                provider=self.refresh_token.provider,\n            ).from_http(request, user=self.refresh_token.user)\n            raise TokenError(\"invalid_grant\")\n\n    def __post_init_client_credentials(self, request: HttpRequest):\n        if request.POST.get(CLIENT_ASSERTION_TYPE, \"\") != \"\":\n            return self.__post_init_client_credentials_jwt(request)\n        # Authenticate user based on credentials\n        username = request.POST.get(\"username\")\n        password = request.POST.get(\"password\")\n        user = User.objects.filter(username=username).first()\n        if not user:\n            raise TokenError(\"invalid_grant\")\n        token: Token = Token.filter_not_expired(\n            key=password, intent=TokenIntents.INTENT_APP_PASSWORD\n        ).first()\n        if not token or token.user.uid != user.uid:\n            raise TokenError(\"invalid_grant\")\n        self.user = user\n        # Authorize user access\n        app = Application.objects.filter(provider=self.provider).first()\n        if not app or not app.provider:\n            raise TokenError(\"invalid_grant\")\n        self.__check_policy_access(app, request)\n\n        Event.new(\n            action=EventAction.LOGIN,\n            **{\n                PLAN_CONTEXT_METHOD: \"token\",\n                PLAN_CONTEXT_METHOD_ARGS: {\n                    \"identifier\": token.identifier,\n                },\n                PLAN_CONTEXT_APPLICATION: app,\n            },\n        ).from_http(request, user=user)\n        return None\n\n    # pylint: disable=too-many-locals\n    def __post_init_client_credentials_jwt(self, request: HttpRequest):\n        assertion_type = request.POST.get(CLIENT_ASSERTION_TYPE, \"\")\n        if assertion_type != CLIENT_ASSERTION_TYPE_JWT:\n            LOGGER.warning(\"Invalid assertion type\", assertion_type=assertion_type)\n            raise TokenError(\"invalid_grant\")\n\n        client_secret = request.POST.get(\"client_secret\", None)\n        assertion = request.POST.get(CLIENT_ASSERTION, client_secret)\n        if not assertion:\n            LOGGER.warning(\"Missing client assertion\")\n            raise TokenError(\"invalid_grant\")\n\n        token = None\n\n        source: Optional[OAuthSource] = None\n        parsed_key: Optional[PyJWK] = None\n\n        # Fully decode the JWT without verifying the signature, so we can get access to\n        # the header.\n        # Get the Key ID from the header, and use that to optimise our source query to only find\n        # sources that have a JWK for that Key ID\n        # The Key ID doesn't have a fixed format, but must match between an issued JWT\n        # and whatever is returned by the JWKS endpoint\n        try:\n            decode_unvalidated = PyJWT().decode_complete(\n                assertion, options={\"verify_signature\": False}\n            )\n        except (PyJWTError, ValueError, TypeError, AttributeError) as exc:\n            LOGGER.warning(\"failed to parse JWT for kid lookup\", exc=exc)\n            raise TokenError(\"invalid_grant\")\n        expected_kid = decode_unvalidated[\"header\"][\"kid\"]\n        for source in self.provider.jwks_sources.filter(\n            oidc_jwks__keys__contains=[{\"kid\": expected_kid}]\n        ):\n            LOGGER.debug(\"verifying JWT with source\", source=source.slug)\n            keys = source.oidc_jwks.get(\"keys\", [])\n            for key in keys:\n                LOGGER.debug(\"verifying JWT with key\", source=source.slug, key=key.get(\"kid\"))\n                try:\n                    parsed_key = PyJWK.from_dict(key)\n                    token = decode(\n                        assertion,\n                        parsed_key.key,\n                        algorithms=[key.get(\"alg\")],\n                        options={\n                            \"verify_aud\": False,\n                        },\n                    )\n                # AttributeError is raised when the configured JWK is a private key\n                # and not a public key\n                except (PyJWTError, ValueError, TypeError, AttributeError) as exc:\n                    LOGGER.warning(\"failed to verify JWT\", exc=exc, source=source.slug)\n\n        if not token:\n            LOGGER.warning(\"No token could be verified\")\n            raise TokenError(\"invalid_grant\")\n\n        LOGGER.info(\"successfully verified JWT with source\", source=source.slug)\n\n        if \"exp\" in token:\n            exp = datetime.fromtimestamp(token[\"exp\"])\n            # Non-timezone aware check since we assume `exp` is in UTC\n            if datetime.now() >= exp:\n                LOGGER.info(\"JWT token expired\")\n                raise TokenError(\"invalid_grant\")\n\n        app = Application.objects.filter(provider=self.provider).first()\n        if not app or not app.provider:\n            LOGGER.info(\"client_credentials grant for provider without application\")\n            raise TokenError(\"invalid_grant\")\n\n        self.__check_policy_access(app, request, oauth_jwt=token)\n        self.__create_user_from_jwt(token, app, source)\n\n        method_args = {\n            \"jwt\": token,\n        }\n        if source:\n            method_args[\"source\"] = source\n        if parsed_key:\n            method_args[\"jwk_id\"] = parsed_key.key_id\n        Event.new(\n            action=EventAction.LOGIN,\n            **{\n                PLAN_CONTEXT_METHOD: \"jwt\",\n                PLAN_CONTEXT_METHOD_ARGS: method_args,\n                PLAN_CONTEXT_APPLICATION: app,\n            },\n        ).from_http(request, user=self.user)\n\n    def __post_init_device_code(self, request: HttpRequest):\n        device_code = request.POST.get(\"device_code\", \"\")\n        code = DeviceToken.objects.filter(device_code=device_code, provider=self.provider).first()\n        if not code:\n            raise TokenError(\"invalid_grant\")\n        self.device_code = code\n\n    def __create_user_from_jwt(self, token: dict[str, Any], app: Application, source: OAuthSource):\n        \"\"\"Create user from JWT\"\"\"\n        exp = token.get(\"exp\")\n        self.user, created = User.objects.update_or_create(\n            username=f\"{self.provider.name}-{token.get('sub')}\",\n            defaults={\n                \"attributes\": {\n                    USER_ATTRIBUTE_GENERATED: True,\n                },\n                \"last_login\": timezone.now(),\n                \"name\": f\"Autogenerated user from application {app.name} (client credentials JWT)\",\n                \"path\": source.get_user_path(),\n            },\n        )\n        if created and exp:\n            self.user.attributes[USER_ATTRIBUTE_EXPIRES] = exp\n            self.user.save()\n\n\n@method_decorator(csrf_exempt, name=\"dispatch\")\nclass TokenView(View):\n    \"\"\"Generate tokens for clients\"\"\"\n\n    provider: Optional[OAuth2Provider] = None\n    params: Optional[TokenParams] = None\n\n    def dispatch(self, request: HttpRequest, *args: Any, **kwargs: Any) -> HttpResponse:\n        response = super().dispatch(request, *args, **kwargs)\n        allowed_origins = []\n        if self.provider:\n            allowed_origins = self.provider.redirect_uris.split(\"\\n\")\n        cors_allow(self.request, response, *allowed_origins)\n        return response\n\n    def options(self, request: HttpRequest) -> HttpResponse:\n        return TokenResponse({})\n\n    def post(self, request: HttpRequest) -> HttpResponse:\n        \"\"\"Generate tokens for clients\"\"\"\n        try:\n            with Hub.current.start_span(\n                op=\"authentik.providers.oauth2.post.parse\",\n            ):\n                client_id, client_secret = extract_client_auth(request)\n                self.provider = OAuth2Provider.objects.filter(client_id=client_id).first()\n                if not self.provider:\n                    LOGGER.warning(\"OAuth2Provider does not exist\", client_id=client_id)\n                    raise TokenError(\"invalid_client\")\n                CTX_AUTH_VIA.set(\"oauth_client_secret\")\n                self.params = TokenParams.parse(request, self.provider, client_id, client_secret)\n\n            with Hub.current.start_span(\n                op=\"authentik.providers.oauth2.post.response\",\n            ):\n                if self.params.grant_type == GRANT_TYPE_AUTHORIZATION_CODE:\n                    LOGGER.debug(\"Converting authorization code to access token\")\n                    return TokenResponse(self.create_code_response())\n                if self.params.grant_type == GRANT_TYPE_REFRESH_TOKEN:\n                    LOGGER.debug(\"Refreshing refresh token\")\n                    return TokenResponse(self.create_refresh_response())\n                if self.params.grant_type in [GRANT_TYPE_CLIENT_CREDENTIALS, GRANT_TYPE_PASSWORD]:\n                    LOGGER.debug(\"Client credentials/password grant\")\n                    return TokenResponse(self.create_client_credentials_response())\n                if self.params.grant_type == GRANT_TYPE_DEVICE_CODE:\n                    LOGGER.debug(\"Device code grant\")\n                    return TokenResponse(self.create_device_code_response())\n                raise TokenError(\"unsupported_grant_type\")\n        except (TokenError, DeviceCodeError) as error:\n            return TokenResponse(error.create_dict(), status=400)\n        except UserAuthError as error:\n            return TokenResponse(error.create_dict(), status=403)\n\n    def create_code_response(self) -> dict[str, Any]:\n        \"\"\"See https://datatracker.ietf.org/doc/html/rfc6749#section-4.1\"\"\"\n        now = timezone.now()\n        access_token_expiry = now + timedelta_from_string(self.provider.access_token_validity)\n        access_token = AccessToken(\n            provider=self.provider,\n            user=self.params.authorization_code.user,\n            expires=access_token_expiry,\n            # Keep same scopes as previous token\n            scope=self.params.authorization_code.scope,\n            auth_time=self.params.authorization_code.auth_time,\n            session_id=self.params.authorization_code.session_id,\n        )\n        access_id_token = IDToken.new(\n            self.provider,\n            access_token,\n            self.request,\n        )\n        access_id_token.nonce = self.params.authorization_code.nonce\n        access_token.id_token = access_id_token\n        access_token.save()\n\n        response = {\n            \"access_token\": access_token.token,\n            \"token_type\": TOKEN_TYPE,\n            \"expires_in\": int(\n                timedelta_from_string(self.provider.access_token_validity).total_seconds()\n            ),\n            \"id_token\": access_token.id_token.to_jwt(self.provider),\n        }\n\n        if SCOPE_OFFLINE_ACCESS in self.params.authorization_code.scope:\n            refresh_token_expiry = now + timedelta_from_string(self.provider.refresh_token_validity)\n            refresh_token = RefreshToken(\n                user=self.params.authorization_code.user,\n                scope=self.params.authorization_code.scope,\n                expires=refresh_token_expiry,\n                provider=self.provider,\n                auth_time=self.params.authorization_code.auth_time,\n                session_id=self.params.authorization_code.session_id,\n            )\n            id_token = IDToken.new(\n                self.provider,\n                refresh_token,\n                self.request,\n            )\n            id_token.nonce = self.params.authorization_code.nonce\n            id_token.at_hash = access_token.at_hash\n            refresh_token.id_token = id_token\n            refresh_token.save()\n            response[\"refresh_token\"] = refresh_token.token\n\n        # Delete old code\n        self.params.authorization_code.delete()\n        return response\n\n    def create_refresh_response(self) -> dict[str, Any]:\n        \"\"\"See https://datatracker.ietf.org/doc/html/rfc6749#section-6\"\"\"\n        unauthorized_scopes = set(self.params.scope) - set(self.params.refresh_token.scope)\n        if unauthorized_scopes:\n            raise TokenError(\"invalid_scope\")\n        if SCOPE_OFFLINE_ACCESS not in self.params.scope:\n            raise TokenError(\"invalid_scope\")\n        now = timezone.now()\n        access_token_expiry = now + timedelta_from_string(self.provider.access_token_validity)\n        access_token = AccessToken(\n            provider=self.provider,\n            user=self.params.refresh_token.user,\n            expires=access_token_expiry,\n            # Keep same scopes as previous token\n            scope=self.params.refresh_token.scope,\n            auth_time=self.params.refresh_token.auth_time,\n            session_id=self.params.refresh_token.session_id,\n        )\n        access_token.id_token = IDToken.new(\n            self.provider,\n            access_token,\n            self.request,\n        )\n        access_token.save()\n\n        refresh_token_expiry = now + timedelta_from_string(self.provider.refresh_token_validity)\n        refresh_token = RefreshToken(\n            user=self.params.refresh_token.user,\n            scope=self.params.refresh_token.scope,\n            expires=refresh_token_expiry,\n            provider=self.provider,\n            auth_time=self.params.refresh_token.auth_time,\n            session_id=self.params.refresh_token.session_id,\n        )\n        id_token = IDToken.new(\n            self.provider,\n            refresh_token,\n            self.request,\n        )\n        id_token.nonce = self.params.refresh_token.id_token.nonce\n        id_token.at_hash = access_token.at_hash\n        refresh_token.id_token = id_token\n        refresh_token.save()\n\n        # Mark old token as revoked\n        self.params.refresh_token.revoked = True\n        self.params.refresh_token.save()\n\n        return {\n            \"access_token\": access_token.token,\n            \"refresh_token\": refresh_token.token,\n            \"token_type\": TOKEN_TYPE,\n            \"expires_in\": int(\n                timedelta_from_string(self.provider.access_token_validity).total_seconds()\n            ),\n            \"id_token\": id_token.to_jwt(self.provider),\n        }\n\n    def create_client_credentials_response(self) -> dict[str, Any]:\n        \"\"\"See https://datatracker.ietf.org/doc/html/rfc6749#section-4.4\"\"\"\n        now = timezone.now()\n        access_token_expiry = now + timedelta_from_string(self.provider.access_token_validity)\n        access_token = AccessToken(\n            provider=self.provider,\n            user=self.params.user,\n            expires=access_token_expiry,\n            scope=self.params.scope,\n            auth_time=now,\n        )\n        access_token.id_token = IDToken.new(\n            self.provider,\n            access_token,\n            self.request,\n        )\n        access_token.save()\n        return {\n            \"access_token\": access_token.token,\n            \"token_type\": TOKEN_TYPE,\n            \"expires_in\": int(\n                timedelta_from_string(self.provider.access_token_validity).total_seconds()\n            ),\n            \"id_token\": access_token.id_token.to_jwt(self.provider),\n        }\n\n    def create_device_code_response(self) -> dict[str, Any]:\n        \"\"\"See https://datatracker.ietf.org/doc/html/rfc8628\"\"\"\n        if not self.params.device_code.user:\n            raise DeviceCodeError(\"authorization_pending\")\n        now = timezone.now()\n        access_token_expiry = now + timedelta_from_string(self.provider.access_token_validity)\n        auth_event = get_login_event(self.request)\n        access_token = AccessToken(\n            provider=self.provider,\n            user=self.params.device_code.user,\n            expires=access_token_expiry,\n            scope=self.params.device_code.scope,\n            auth_time=auth_event.created if auth_event else now,\n        )\n        access_token.id_token = IDToken.new(\n            self.provider,\n            access_token,\n            self.request,\n        )\n        access_token.save()\n\n        response = {\n            \"access_token\": access_token.token,\n            \"token_type\": TOKEN_TYPE,\n            \"expires_in\": int(\n                timedelta_from_string(self.provider.access_token_validity).total_seconds()\n            ),\n            \"id_token\": access_token.id_token.to_jwt(self.provider),\n        }\n\n        if SCOPE_OFFLINE_ACCESS in self.params.scope:\n            refresh_token_expiry = now + timedelta_from_string(self.provider.refresh_token_validity)\n            refresh_token = RefreshToken(\n                user=self.params.device_code.user,\n                scope=self.params.device_code.scope,\n                expires=refresh_token_expiry,\n                provider=self.provider,\n                auth_time=auth_event.created if auth_event else now,\n            )\n            id_token = IDToken.new(\n                self.provider,\n                refresh_token,\n                self.request,\n            )\n            id_token.at_hash = access_token.at_hash\n            refresh_token.id_token = id_token\n            refresh_token.save()\n            response[\"refresh_token\"] = refresh_token.token\n\n        # Delete device code\n        self.params.device_code.delete()\n        return response\n"], "filenames": ["authentik/providers/oauth2/views/token.py"], "buggy_code_start_loc": [235], "buggy_code_end_loc": [247], "fixing_code_start_loc": [235], "fixing_code_end_loc": [252], "type": "CWE-287", "message": "Authentik is an open-source Identity Provider. There is a bug in our implementation of PKCE that allows an attacker to circumvent the protection that PKCE offers. PKCE adds the code_challenge parameter to the authorization request and adds the code_verifier parameter to the token request. Prior to 2023.8.7 and 2023.10.7, a downgrade scenario is possible: if the attacker removes the code_challenge parameter from the authorization request, authentik will not do the PKCE check. Because of this bug, an attacker can circumvent the protection PKCE offers, such as CSRF attacks and code injection attacks.  Versions 2023.8.7 and 2023.10.7 fix the issue.", "other": {"cve": {"id": "CVE-2024-23647", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-30T17:15:10.913", "lastModified": "2024-02-06T18:22:58.250", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Authentik is an open-source Identity Provider. There is a bug in our implementation of PKCE that allows an attacker to circumvent the protection that PKCE offers. PKCE adds the code_challenge parameter to the authorization request and adds the code_verifier parameter to the token request. Prior to 2023.8.7 and 2023.10.7, a downgrade scenario is possible: if the attacker removes the code_challenge parameter from the authorization request, authentik will not do the PKCE check. Because of this bug, an attacker can circumvent the protection PKCE offers, such as CSRF attacks and code injection attacks.  Versions 2023.8.7 and 2023.10.7 fix the issue."}, {"lang": "es", "value": "Authentik es un proveedor de identidades de c\u00f3digo abierto. Hay un error en nuestra implementaci\u00f3n de PKCE que permite a un atacante eludir la protecci\u00f3n que ofrece PKCE. PKCE agrega el par\u00e1metro code_challenge a la solicitud de autorizaci\u00f3n y agrega el par\u00e1metro code_verifier a la solicitud de token. Antes de 2023.8.7 y 2023.10.7, es posible un escenario de degradaci\u00f3n: si el atacante elimina el par\u00e1metro code_challenge de la solicitud de autorizaci\u00f3n, authentik no realizar\u00e1 la verificaci\u00f3n PKCE. Debido a este error, un atacante puede eludir la protecci\u00f3n que ofrece PKCE, como los ataques CSRF y los ataques de inyecci\u00f3n de c\u00f3digo. Las versiones 2023.8.7 y 2023.10.7 solucionan el problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:goauthentik:authentik:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023.8.7", "matchCriteriaId": "026E19BC-D2BB-4B89-916F-565B498F0C87"}, {"vulnerable": true, "criteria": "cpe:2.3:a:goauthentik:authentik:*:*:*:*:*:*:*:*", "versionStartIncluding": "2023.10.0", "versionEndExcluding": "2023.10.7", "matchCriteriaId": "6E579B4B-ACB8-4917-915B-D0FB5FC17F64"}]}]}], "references": [{"url": "https://github.com/goauthentik/authentik/commit/38e04ae12720e5d81b4f7ac77997eb8d1275d31a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/goauthentik/authentik/security/advisories/GHSA-mrx3-gxjx-hjqj", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/goauthentik/authentik/commit/38e04ae12720e5d81b4f7ac77997eb8d1275d31a"}}