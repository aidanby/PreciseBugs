{"buggy_code": ["from fastapi import FastAPI, HTTPException, Request, Form, File, UploadFile, Header\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import FileResponse, JSONResponse\nimport os\nimport yaml\nimport json\nfrom _version import __version__\nfrom utils import db_interface as database\nfrom utils import password_hasher as hasher\nfrom utils import email_checker as email_interface\nfrom utils import access_control as access_control\n\n# Check setup\nprint(\"Checking user images folder...\")\nif os.path.isdir(\"user_images\") == False:\n    os.mkdir(\"user_images\")\n    print(\"Created 'user_images' directory!\")\n\nif os.path.isdir(\"user_images/pfp\") == False:\n    os.mkdir(\"user_images/pfp\")\n    print(\"Created 'user_images/pfp' directory!\")\n\nif os.path.isdir(\"user_images/banner\") == False:\n    os.mkdir(\"user_images/banner\")\n    print(\"Created 'user_images/banner' directory!\")\n\n# Check location of assets folder\nif os.path.isdir(\"assets\"):\n    assets_folder = \"assets\"\n\nelse: \n    assets_folder = \"src/assets\"\n\n# Check location of resources folder\nif os.path.isdir(\"resources\"):\n    resources_folder = \"resources\"\n\nelse: \n    resources_folder = \"src/resources\"\n\n# Check the config.yml to ensure its up-to-date\nprint(\"Checking config...\")\n\nif not os.path.isfile(\"config.yml\"):\n    with open(\"config.yml\", 'x') as config:\n        config.close()\n\nwith open(\"config.yml\", \"r\") as config:\n    contents = config.read()\n    configurations = yaml.safe_load(contents)\n    config.close()\n\n# Ensure the configurations are not None\nif configurations == None:\n    configurations = {}\n\n# Open reference json file for config\nwith open(f\"{resources_folder}/json data/default_config.json\", \"r\") as json_file:\n    json_data = json_file.read()\n    default_config = json.loads(json_data)\n\nif not os.path.isfile('access-control.yml'):\n    with open(\"access-control.yml\", 'x') as config:\n        config.close()\n\n# Compare config with json data\nfor option in default_config:\n    if not option in configurations:\n        configurations[option] = default_config[option]\n        print(f\"Added '{option}' to config!\")\n\n# Open config in write mode to write the updated config\nwith open(\"config.yml\", \"w\") as config:\n    new_config = yaml.safe_dump(configurations)\n    config.write(new_config)\n    config.close()\n\n# Get run environment \n__env__= os.getenv('RUN_ENVIRONMENT')\n\nprint(\"Setup check complete!\")\n\ndatabase.load_config()\n\nprint(__env__)\n\n# Enable/disable developer docs based on env\nif __env__ == 'PRODUCTION':\n    enable_dev_docs = None\nelse:\n    enable_dev_docs = '/docs'\n\napp = FastAPI(\n     title=\"Lif Authentication Server\",\n     description=\"Official API for Lif Platforms authentication services.\",\n     version=__version__,\n     docs_url=enable_dev_docs,\n     redoc_url=None\n)\n\n# Enable CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@app.get(\"/\")\nasync def home():\n    return \"Welcome to Lif Auth Server!\"\n\n@app.get(\"/login/{username}/{password}\")\nasync def login(username: str, password: str):\n    \"\"\"\n    ## Login Route For Lif Accounts (DEPRECIATED)\n    Handles the authentication process for Lif Accounts.\n    \n    ### Parameters:\n    - **username (str):** The username of the account.\n    - **password (str):** The password for the account.\n\n    ### Returns:\n    - **dict:** Status of login and user token.\n    \"\"\"\n    # Gets password hash\n    password_hash = hasher.get_hash_with_database_salt(username=username, password=password)\n\n    # Checks if password hash was successful\n    if not password_hash:\n        return {\"Status\": \"Unsuccessful\", \"Token\": \"None\"}\n\n    # Verifies credentials with database\n    status = database.verify_credentials(username=username, password=password_hash)\n\n    if status == \"Good!\":\n        # Gets token from database\n        token = database.retrieve_user_token(username=username)\n\n        # Returns info to client\n        return {\"Status\": \"Successful\", \"Token\": token}\n    else:\n        # Tells client credentials are incorrect\n        return {\"Status\": \"Unsuccessful\", \"Token\": \"None\"}\n\n@app.post('/lif_login')\nasync def lif_login(username: str = Form(), password: str = Form()):\n    \"\"\"\n    ## Login Route For Lif Accounts (NEW)\n    Handles the authentication process for Lif Accounts.\n\n    ### Parameters:\n    - **username (str):** The username of the account.\n    - **password (str):** The password for the account.\n\n    ### Returns:\n    - **dict:** Token for user account.\n    \"\"\"\n    # Gets password hash\n    password_hash = hasher.get_hash_with_database_salt(username=username, password=password)\n\n    # Checks if password hash was successful\n    if not password_hash:\n        return HTTPException(status_code=401, detail='Invalid Login Credentials!')\n\n    # Verifies credentials with database\n    if database.verify_credentials(username=username, password=password_hash) == 'Good!':\n        # Gets token from database\n        token = database.retrieve_user_token(username=username)\n\n        return {'token': token}\n    else: \n        # Tells client credentials are incorrect\n        raise HTTPException(status_code=401, detail='Incorrect Login Credentials')\n    \n@app.post(\"/update_pfp\")\nasync def update_pfp(file: UploadFile = File(), username: str = Form(), token: str = Form()):\n    \"\"\"\n    ## Update User Avatar (Profile Picture)\n    Allows users to update their avatar (profile picture).\n    \n    ### Parameters:\n    - **file (file):** The image to be set as the avatar.\n    - **username (str):** The username for the account.\n    - **token (str):** The token for the account.\n\n    ### Returns:\n    - **dict:** Status of the operation.\n    \"\"\"\n    # Verify user token\n    status = database.check_token(username=username, token=token)\n\n    if status == True:\n        # Read the contents of the profile image\n        contents = await file.read()\n\n        # Save user avatar\n        with open(f\"user_images/pfp/{username}.png\", \"wb\") as write_file:\n            write_file.write(contents)\n            write_file.close()\n\n        return {'Status': 'Ok'}\n    else:\n        raise HTTPException(status_code=401, detail=\"Invalid Token!\")\n\n@app.post(\"/update_profile_banner\")\nasync def update_banner(file: UploadFile = File(), username: str = Form(), token: str = Form()):\n    \"\"\"\n    ## Update User Banner\n    Allows users to update their account banner.\n    \n    ### Parameters:\n    - **file (file):** The image to be set as the banner.\n    - **username (str):** The username for the account.\n    - **token (str):** The token for the account.\n\n    ### Returns:\n    - **dict:** Status of the operation.\n    \"\"\"\n    # Verify user token\n    status = database.check_token(username=username, token=token)\n\n    if status == True:\n        # Read the contents of the profile image\n        contents = await file.read()\n\n        # Save user avatar\n        with open(f\"user_images/banner/{username}.png\", \"wb\") as write_file:\n            write_file.write(contents)\n            write_file.close()\n\n        return {'Status': 'Ok'}\n    else:\n        raise HTTPException(status_code=401, detail=\"Invalid Token!\")\n\n@app.post('/update_account_info/personalization')\nasync def update_account_info(username: str = Form(), token: str = Form(), bio: str = Form(), pronouns: str = Form()):\n    \"\"\"\n    ## Update User Account Info\n    Allows users to update their account information (bio, pronouns, etc...)\n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n    - **token (str):** The token for the account.\n    - **bio (str):** The bio for the account.\n    - **pronouns (str):** The pronouns for the account.\n\n    ### Returns:\n    - **JSON:** Status of the operation.\n    \"\"\"\n    # Verify user token\n    if database.check_token(username=username, token=token):\n        database.update_user_bio(username=username, data=bio)\n        database.update_user_pronouns(username=username, data=pronouns)\n\n        return JSONResponse(status_code=200, content=\"Updated Successfully\")\n    else:\n        raise HTTPException(status_code=401, detail=\"Invalid Token!\")\n\n@app.get(\"/get_user_bio/{username}\")\nasync def get_user_bio(username: str):\n    \"\"\"\n    ## Get User Account Bio\n    Allows services to get the bio information for a given account\n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n\n    ### Returns:\n    - **str:** Bio for the account.\n    \"\"\"\n    return database.get_bio(username=username)\n\n@app.get(\"/get_user_pronouns/{username}\")\nasync def get_user_pronouns(username: str):\n    return database.get_pronouns(username=username)\n    \n@app.get('/get_account_info/{data}/{account}')\nasync def get_account_data(data, account, request: Request):\n    \"\"\"\n    ## Get Account Info\n    Allows services to access sensitive information on Lif Accounts.\n\n    ### Headers\n    - **access-token (str):** Services access token. \n    \n    ### Parameters:\n    - **data (str):** Type of data being requested.\n    - **account (str):** Account associated with the data.\n\n    ### Returns:\n    - **dict:** Data the service requested.\n    \"\"\"\n    # Get access token from request header\n    access_token = request.headers.get('access-token')\n\n    # Verify access token is valid\n    if access_control.verify_token(access_token):\n        # Check what data the server is requesting\n        if data == \"email\":\n            # Verify server has permission to access the requested information\n            if access_control.has_perms(token=access_token, permission='account.email'): \n                return {\"email\": database.get_user_email(username=account)}\n            else:\n                raise HTTPException(status_code=403, detail=\"No Permission!\")\n        else:\n            raise HTTPException(status_code=400, detail=\"Unknown Data Type!\")\n    else:\n        raise HTTPException(status_code=403, detail=\"Invalid Token!\")\n\n@app.get(\"/verify_token/{username}/{token}\")\nasync def verify_token(username: str, token: str):\n    \"\"\"\n    ## Verify User Token\n    Allows services to verify the authenticity of a token.\n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n    - **token (str):** The token for the account.\n\n    ### Returns:\n    - **dict:** Status of the operation.\n    \"\"\"\n    # Gets token from database\n    database_token = database.retrieve_user_token(username=username)\n\n    if not database_token:\n        return {\"Status\": \"Unsuccessful\"}\n    elif database_token == token:\n        return {\"Status\": \"Successful\"}\n    else:\n        return {\"Status\": \"Unsuccessful\"}\n\n@app.get(\"/get_pfp/{username}\")\nasync def get_pfp(username: str):\n    \"\"\"\n    ## Get User Avatar (Profile Picture)\n    Allows services to get the avatar (profile picture) of a specified account. \n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n\n    ### Returns:\n    - **file:** The avatar the service requested.\n    \"\"\"\n    # Checks if the user has a profile pic uploaded\n    if os.path.isfile(f\"user_images/pfp/{username}\"):\n        return FileResponse(f\"user_images/pfp/{username}\", media_type='image/gif')\n    else:\n        # Returns default image if none is uploaded\n        return FileResponse(f'{assets_folder}/default_pfp.png', media_type='image/gif')\n\n@app.get(\"/get_banner/{username}\")\nasync def get_banner(username: str):\n    \"\"\"\n    ## Get User Banner\n    Allows services to get the account banner of a specified account.\n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n\n    ### Returns:\n    - **file:** The banner the service requested.\n    \"\"\"\n    # Checks if the user has a profile pic uploaded\n    if os.path.isfile(f\"user_images/banner/{username}\"):\n        return FileResponse(f\"user_images/banner/{username}\", media_type='image/gif')\n    else:\n        # Returns default image if none is uploaded\n        return FileResponse(f'{assets_folder}/default_banner.png', media_type='image/gif')\n    \n@app.post(\"/create_lif_account\")\nasync def create_lif_account(request: Request):\n    \"\"\"\n    ## Create Lif Account (NEW)\n    Handles the creation of Lif Accounts\n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n    - **password (str):** The password for the account.\n    - **email (str):** The email for the account.\n\n    ### Returns:\n    - **dict:** Status of the operation.\n    \"\"\"\n    # Get POST data\n    data = await request.json()\n    username = data[\"username\"]\n    password = data[\"password\"]\n    email = data[\"email\"]\n\n    # Check username usage\n    username_status = database.check_username(username)\n    if username_status:\n        raise HTTPException(status_code=409, detail=\"Username Already in Use!\")\n\n    # Check email usage\n    email_status = database.check_email(email)\n    if email_status:\n        raise HTTPException(status_code=409, detail=\"Email Already in Use!\")\n\n    # Check if email is valid\n    email_isValid = email_interface.is_valid_email(email)\n    if not email_isValid:\n        raise HTTPException(status_code=400, detail=\"Invalid Email!\")\n\n    # Hash user password\n    password_hash = hasher.get_hash_gen_salt(password)\n\n    # Create user account\n    database.create_account(username=username, password=password_hash['password'], email=email, password_salt=password_hash['salt'])\n\n    return {\"Status\": \"Ok\"}  \n\n@app.get(\"/check_account_info_usage/{type}/{info}\")\nasync def check_account_info_usage(type: str, info: str):\n    \"\"\"\n    ## Check Account Info Usage\n    Allows services to check the usage of certain account info (username, email, etc.) before requesting the account creation\n    \n    ### Parameters:\n    - **type (str):** Type of info being checked.\n    - **info (str):** The info being checked.\n\n    ### Returns:\n    - **dict:** Status of the operation.\n    \"\"\"\n    if type == \"username\":\n        # Check username usage\n        username_status = database.check_username(info)\n        if username_status:\n            raise HTTPException(status_code=409, detail=\"Username Already in Use!\")\n        else:\n            return {\"Status\": \"Ok\"}\n\n    if type == \"email\":\n        # Check email usage\n        email_status = database.check_email(info)\n        if email_status:\n            raise HTTPException(status_code=409, detail=\"Email Already in Use!\")\n        else:\n            return {\"Status\": \"Ok\"}\n\n    if type == \"emailValid\":\n        # Check if email is valid\n        email_isValid = email_interface.is_valid_email(info)\n        if not email_isValid:\n            raise HTTPException(status_code=400, detail=\"Invalid Email!\")\n        else:\n            return {\"Status\": \"Ok\"}\n\n@app.get(\"/create_account/{username}/{email}/{password}\")\nasync def create_account(username: str, email: str, password: str):\n    \"\"\"\n    ## Create Lif Account (DEPRECIATED)\n    Handles the creation of Lif Accounts. \n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n    - **password (str):** The password for the account.\n    - **email (str):** The email for the account.\n\n    ### Returns:\n    - **dict:** Status of the operation.\n    \"\"\"\n    # Check username usage\n    username_status = database.check_username(username)\n    if username_status:\n        return {\"status\": \"unsuccessful\", \"reason\": \"Username Already in Use!\"}\n\n    # Check email usage\n    email_status = database.check_email(email)\n    if email_status:\n        return {\"status\": \"unsuccessful\", \"reason\": \"Email Already in Use!\"}\n\n    # Check if email is valid\n    email_isValid = email_interface.is_valid_email(email)\n    if not email_isValid:\n        return {\"status\": \"unsuccessful\", \"reason\": \"Email is Invalid!\"}\n\n    # Hash user password\n    password_hash = hasher.get_hash_gen_salt(password)\n\n    # Create user account\n    database.create_account(username=username, password=password_hash['password'], email=email, password_salt=password_hash['salt'])\n\n    return {\"status\": \"ok\"}\n\n@app.post('/lif_password_update')\nasync def lif_password_update(username: str = Form(), current_password: str = Form(), new_password: str = Form()):\n    \"\"\"\n    ## Update Account Password\n    Handles the changing of a users account password. \n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n    - **current_password (str):** The current password for the account.\n    - **new_password (str):** The new password for the account.\n\n    ### Returns:\n    - **JSON:** Status of the operation.\n    \"\"\"\n    # Gets password hash\n    password_hash = hasher.get_hash_with_database_salt(username=username, password=current_password)\n\n    # Verify old credentials before updating password\n    if database.verify_credentials(username=username, password=password_hash) == 'Good!':\n        # Get hashed password and salt\n        new_password_data = hasher.get_hash_gen_salt(new_password)\n\n        # Update user salt in database\n        database.update_user_salt(username=username, salt=new_password_data['salt'])\n\n        # Update user password in database\n        database.update_password(username=username, password=new_password_data['password'])\n\n        return JSONResponse(status_code=200, content='Updated Password')\n    else: \n        raise HTTPException(status_code=401, detail=\"Invalid Password!\")\n    \n@app.get('/get_username/{account_id}')\nasync def get_username(account_id: str):\n    return database.get_username(account_id=account_id)\n\nif __name__ == '__main__':\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8002)\n"], "fixing_code": ["from fastapi import FastAPI, HTTPException, Request, Form, File, UploadFile, Header\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import FileResponse, JSONResponse\nimport os\nimport yaml\nimport json\nfrom _version import __version__\nfrom utils import db_interface as database\nfrom utils import password_hasher as hasher\nfrom utils import email_checker as email_interface\nfrom utils import access_control as access_control\n\n# Check setup\nprint(\"Checking user images folder...\")\nif os.path.isdir(\"user_images\") == False:\n    os.mkdir(\"user_images\")\n    print(\"Created 'user_images' directory!\")\n\nif os.path.isdir(\"user_images/pfp\") == False:\n    os.mkdir(\"user_images/pfp\")\n    print(\"Created 'user_images/pfp' directory!\")\n\nif os.path.isdir(\"user_images/banner\") == False:\n    os.mkdir(\"user_images/banner\")\n    print(\"Created 'user_images/banner' directory!\")\n\n# Check location of assets folder\nif os.path.isdir(\"assets\"):\n    assets_folder = \"assets\"\n\nelse: \n    assets_folder = \"src/assets\"\n\n# Check location of resources folder\nif os.path.isdir(\"resources\"):\n    resources_folder = \"resources\"\n\nelse: \n    resources_folder = \"src/resources\"\n\n# Check the config.yml to ensure its up-to-date\nprint(\"Checking config...\")\n\nif not os.path.isfile(\"config.yml\"):\n    with open(\"config.yml\", 'x') as config:\n        config.close()\n\nwith open(\"config.yml\", \"r\") as config:\n    contents = config.read()\n    configurations = yaml.safe_load(contents)\n    config.close()\n\n# Ensure the configurations are not None\nif configurations == None:\n    configurations = {}\n\n# Open reference json file for config\nwith open(f\"{resources_folder}/json data/default_config.json\", \"r\") as json_file:\n    json_data = json_file.read()\n    default_config = json.loads(json_data)\n\nif not os.path.isfile('access-control.yml'):\n    with open(\"access-control.yml\", 'x') as config:\n        config.close()\n\n# Compare config with json data\nfor option in default_config:\n    if not option in configurations:\n        configurations[option] = default_config[option]\n        print(f\"Added '{option}' to config!\")\n\n# Open config in write mode to write the updated config\nwith open(\"config.yml\", \"w\") as config:\n    new_config = yaml.safe_dump(configurations)\n    config.write(new_config)\n    config.close()\n\n# Get run environment \n__env__= os.getenv('RUN_ENVIRONMENT')\n\nprint(\"Setup check complete!\")\n\ndatabase.load_config()\n\nprint(__env__)\n\n# Enable/disable developer docs based on env\nif __env__ == 'PRODUCTION':\n    enable_dev_docs = None\nelse:\n    enable_dev_docs = '/docs'\n\napp = FastAPI(\n     title=\"Lif Authentication Server\",\n     description=\"Official API for Lif Platforms authentication services.\",\n     version=__version__,\n     docs_url=enable_dev_docs,\n     redoc_url=None\n)\n\n# Enable CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@app.get(\"/\")\nasync def home():\n    return \"Welcome to Lif Auth Server!\"\n\n@app.get(\"/login/{username}/{password}\")\nasync def login(username: str, password: str):\n    \"\"\"\n    ## Login Route For Lif Accounts (DEPRECIATED)\n    Handles the authentication process for Lif Accounts.\n    \n    ### Parameters:\n    - **username (str):** The username of the account.\n    - **password (str):** The password for the account.\n\n    ### Returns:\n    - **dict:** Status of login and user token.\n    \"\"\"\n    # Gets password hash\n    password_hash = hasher.get_hash_with_database_salt(username=username, password=password)\n\n    # Checks if password hash was successful\n    if not password_hash:\n        return {\"Status\": \"Unsuccessful\", \"Token\": \"None\"}\n\n    # Verifies credentials with database\n    status = database.verify_credentials(username=username, password=password_hash)\n\n    if status == \"Good!\":\n        # Gets token from database\n        token = database.retrieve_user_token(username=username)\n\n        # Returns info to client\n        return {\"Status\": \"Successful\", \"Token\": token}\n    else:\n        # Tells client credentials are incorrect\n        return {\"Status\": \"Unsuccessful\", \"Token\": \"None\"}\n\n@app.post('/lif_login')\nasync def lif_login(username: str = Form(), password: str = Form()):\n    \"\"\"\n    ## Login Route For Lif Accounts (NEW)\n    Handles the authentication process for Lif Accounts.\n\n    ### Parameters:\n    - **username (str):** The username of the account.\n    - **password (str):** The password for the account.\n\n    ### Returns:\n    - **dict:** Token for user account.\n    \"\"\"\n    # Gets password hash\n    password_hash = hasher.get_hash_with_database_salt(username=username, password=password)\n\n    # Checks if password hash was successful\n    if not password_hash:\n        return HTTPException(status_code=401, detail='Invalid Login Credentials!')\n\n    # Verifies credentials with database\n    if database.verify_credentials(username=username, password=password_hash) == 'Good!':\n        # Gets token from database\n        token = database.retrieve_user_token(username=username)\n\n        return {'token': token}\n    else: \n        # Tells client credentials are incorrect\n        raise HTTPException(status_code=401, detail='Incorrect Login Credentials')\n    \n@app.post(\"/update_pfp\")\nasync def update_pfp(file: UploadFile = File(), username: str = Form(), token: str = Form()):\n    \"\"\"\n    ## Update User Avatar (Profile Picture)\n    Allows users to update their avatar (profile picture).\n    \n    ### Parameters:\n    - **file (file):** The image to be set as the avatar.\n    - **username (str):** The username for the account.\n    - **token (str):** The token for the account.\n\n    ### Returns:\n    - **dict:** Status of the operation.\n    \"\"\"\n    # Verify user token\n    status = database.check_token(username=username, token=token)\n\n    if status == True:\n        # Read the contents of the profile image\n        contents = await file.read()\n\n        # Save user avatar\n        with open(f\"user_images/pfp/{username}.png\", \"wb\") as write_file:\n            write_file.write(contents)\n            write_file.close()\n\n        return {'Status': 'Ok'}\n    else:\n        raise HTTPException(status_code=401, detail=\"Invalid Token!\")\n\n@app.post(\"/update_profile_banner\")\nasync def update_banner(file: UploadFile = File(), username: str = Form(), token: str = Form()):\n    \"\"\"\n    ## Update User Banner\n    Allows users to update their account banner.\n    \n    ### Parameters:\n    - **file (file):** The image to be set as the banner.\n    - **username (str):** The username for the account.\n    - **token (str):** The token for the account.\n\n    ### Returns:\n    - **dict:** Status of the operation.\n    \"\"\"\n    # Verify user token\n    status = database.check_token(username=username, token=token)\n\n    if status == True:\n        # Read the contents of the profile image\n        contents = await file.read()\n\n        # Save user avatar\n        with open(f\"user_images/banner/{username}.png\", \"wb\") as write_file:\n            write_file.write(contents)\n            write_file.close()\n\n        return {'Status': 'Ok'}\n    else:\n        raise HTTPException(status_code=401, detail=\"Invalid Token!\")\n\n@app.post('/update_account_info/personalization')\nasync def update_account_info(username: str = Form(), token: str = Form(), bio: str = Form(), pronouns: str = Form()):\n    \"\"\"\n    ## Update User Account Info\n    Allows users to update their account information (bio, pronouns, etc...)\n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n    - **token (str):** The token for the account.\n    - **bio (str):** The bio for the account.\n    - **pronouns (str):** The pronouns for the account.\n\n    ### Returns:\n    - **JSON:** Status of the operation.\n    \"\"\"\n    # Verify user token\n    if database.check_token(username=username, token=token):\n        database.update_user_bio(username=username, data=bio)\n        database.update_user_pronouns(username=username, data=pronouns)\n\n        return JSONResponse(status_code=200, content=\"Updated Successfully\")\n    else:\n        raise HTTPException(status_code=401, detail=\"Invalid Token!\")\n\n@app.get(\"/get_user_bio/{username}\")\nasync def get_user_bio(username: str):\n    \"\"\"\n    ## Get User Account Bio\n    Allows services to get the bio information for a given account\n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n\n    ### Returns:\n    - **str:** Bio for the account.\n    \"\"\"\n    return database.get_bio(username=username)\n\n@app.get(\"/get_user_pronouns/{username}\")\nasync def get_user_pronouns(username: str):\n    return database.get_pronouns(username=username)\n    \n@app.get('/get_account_info/{data}/{account}')\nasync def get_account_data(data, account, request: Request):\n    \"\"\"\n    ## Get Account Info\n    Allows services to access sensitive information on Lif Accounts.\n\n    ### Headers\n    - **access-token (str):** Services access token. \n    \n    ### Parameters:\n    - **data (str):** Type of data being requested.\n    - **account (str):** Account associated with the data.\n\n    ### Returns:\n    - **dict:** Data the service requested.\n    \"\"\"\n    # Get access token from request header\n    access_token = request.headers.get('access-token')\n\n    # Verify access token is valid\n    if access_control.verify_token(access_token):\n        # Check what data the server is requesting\n        if data == \"email\":\n            # Verify server has permission to access the requested information\n            if access_control.has_perms(token=access_token, permission='account.email'): \n                return {\"email\": database.get_user_email(username=account)}\n            else:\n                raise HTTPException(status_code=403, detail=\"No Permission!\")\n        else:\n            raise HTTPException(status_code=400, detail=\"Unknown Data Type!\")\n    else:\n        raise HTTPException(status_code=403, detail=\"Invalid Token!\")\n\n@app.get(\"/verify_token/{username}/{token}\")\nasync def verify_token(username: str, token: str):\n    \"\"\"\n    ## Verify User Token\n    Allows services to verify the authenticity of a token.\n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n    - **token (str):** The token for the account.\n\n    ### Returns:\n    - **dict:** Status of the operation.\n    \"\"\"\n    # Gets token from database\n    database_token = database.retrieve_user_token(username=username)\n\n    if not database_token:\n        return {\"Status\": \"Unsuccessful\"}\n    elif database_token == token:\n        return {\"Status\": \"Successful\"}\n    else:\n        return {\"Status\": \"Unsuccessful\"}\n\n@app.get(\"/get_pfp/{username}\")\nasync def get_pfp(username: str):\n    \"\"\"\n    ## Get User Avatar (Profile Picture)\n    Allows services to get the avatar (profile picture) of a specified account. \n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n\n    ### Returns:\n    - **file:** The avatar the service requested.\n    \"\"\"\n    # Sanitize and validate the username variable (Example: alphanumeric characters allowed)\n    if not username.isalnum():\n        # Handle invalid input (username contains non-alphanumeric characters)\n        return FileResponse(f'{assets_folder}/default_pfp.png', media_type='image/gif')\n\n    # Construct the file path using the sanitized username\n    banner_path = f\"user_images/pfp/{username}\"\n\n    # Check if the file exists and is a regular file\n    if os.path.isfile(banner_path):\n        return FileResponse(banner_path, media_type='image/gif')\n    else:\n        # Return default image if the user's banner doesn't exist\n        return FileResponse(f'{assets_folder}/default_pfp.png', media_type='image/gif')\n\n@app.get(\"/get_banner/{username}\")\nasync def get_banner(username: str):\n    \"\"\"\n    ## Get User Banner\n    Allows services to get the account banner of a specified account.\n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n\n    ### Returns:\n    - **file:** The banner the service requested.\n    \"\"\"\n    # Sanitize and validate the username variable (Example: alphanumeric characters allowed)\n    if not username.isalnum():\n        # Handle invalid input (username contains non-alphanumeric characters)\n        return FileResponse(f'{assets_folder}/default_banner.png', media_type='image/gif')\n\n    # Construct the file path using the sanitized username\n    banner_path = f\"user_images/banner/{username}\"\n\n    # Check if the file exists and is a regular file\n    if os.path.isfile(banner_path):\n        return FileResponse(banner_path, media_type='image/gif')\n    else:\n        # Return default image if the user's banner doesn't exist\n        return FileResponse(f'{assets_folder}/default_banner.png', media_type='image/gif')\n    \n@app.post(\"/create_lif_account\")\nasync def create_lif_account(request: Request):\n    \"\"\"\n    ## Create Lif Account (NEW)\n    Handles the creation of Lif Accounts\n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n    - **password (str):** The password for the account.\n    - **email (str):** The email for the account.\n\n    ### Returns:\n    - **dict:** Status of the operation.\n    \"\"\"\n    # Get POST data\n    data = await request.json()\n    username = data[\"username\"]\n    password = data[\"password\"]\n    email = data[\"email\"]\n\n    # Check username usage\n    username_status = database.check_username(username)\n    if username_status:\n        raise HTTPException(status_code=409, detail=\"Username Already in Use!\")\n\n    # Check email usage\n    email_status = database.check_email(email)\n    if email_status:\n        raise HTTPException(status_code=409, detail=\"Email Already in Use!\")\n\n    # Check if email is valid\n    email_isValid = email_interface.is_valid_email(email)\n    if not email_isValid:\n        raise HTTPException(status_code=400, detail=\"Invalid Email!\")\n\n    # Hash user password\n    password_hash = hasher.get_hash_gen_salt(password)\n\n    # Create user account\n    database.create_account(username=username, password=password_hash['password'], email=email, password_salt=password_hash['salt'])\n\n    return {\"Status\": \"Ok\"}  \n\n@app.get(\"/check_account_info_usage/{type}/{info}\")\nasync def check_account_info_usage(type: str, info: str):\n    \"\"\"\n    ## Check Account Info Usage\n    Allows services to check the usage of certain account info (username, email, etc.) before requesting the account creation\n    \n    ### Parameters:\n    - **type (str):** Type of info being checked.\n    - **info (str):** The info being checked.\n\n    ### Returns:\n    - **dict:** Status of the operation.\n    \"\"\"\n    if type == \"username\":\n        # Check username usage\n        username_status = database.check_username(info)\n        if username_status:\n            raise HTTPException(status_code=409, detail=\"Username Already in Use!\")\n        else:\n            return {\"Status\": \"Ok\"}\n\n    if type == \"email\":\n        # Check email usage\n        email_status = database.check_email(info)\n        if email_status:\n            raise HTTPException(status_code=409, detail=\"Email Already in Use!\")\n        else:\n            return {\"Status\": \"Ok\"}\n\n    if type == \"emailValid\":\n        # Check if email is valid\n        email_isValid = email_interface.is_valid_email(info)\n        if not email_isValid:\n            raise HTTPException(status_code=400, detail=\"Invalid Email!\")\n        else:\n            return {\"Status\": \"Ok\"}\n\n@app.get(\"/create_account/{username}/{email}/{password}\")\nasync def create_account(username: str, email: str, password: str):\n    \"\"\"\n    ## Create Lif Account (DEPRECIATED)\n    Handles the creation of Lif Accounts. \n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n    - **password (str):** The password for the account.\n    - **email (str):** The email for the account.\n\n    ### Returns:\n    - **dict:** Status of the operation.\n    \"\"\"\n    # Check username usage\n    username_status = database.check_username(username)\n    if username_status:\n        return {\"status\": \"unsuccessful\", \"reason\": \"Username Already in Use!\"}\n\n    # Check email usage\n    email_status = database.check_email(email)\n    if email_status:\n        return {\"status\": \"unsuccessful\", \"reason\": \"Email Already in Use!\"}\n\n    # Check if email is valid\n    email_isValid = email_interface.is_valid_email(email)\n    if not email_isValid:\n        return {\"status\": \"unsuccessful\", \"reason\": \"Email is Invalid!\"}\n\n    # Hash user password\n    password_hash = hasher.get_hash_gen_salt(password)\n\n    # Create user account\n    database.create_account(username=username, password=password_hash['password'], email=email, password_salt=password_hash['salt'])\n\n    return {\"status\": \"ok\"}\n\n@app.post('/lif_password_update')\nasync def lif_password_update(username: str = Form(), current_password: str = Form(), new_password: str = Form()):\n    \"\"\"\n    ## Update Account Password\n    Handles the changing of a users account password. \n    \n    ### Parameters:\n    - **username (str):** The username for the account.\n    - **current_password (str):** The current password for the account.\n    - **new_password (str):** The new password for the account.\n\n    ### Returns:\n    - **JSON:** Status of the operation.\n    \"\"\"\n    # Gets password hash\n    password_hash = hasher.get_hash_with_database_salt(username=username, password=current_password)\n\n    # Verify old credentials before updating password\n    if database.verify_credentials(username=username, password=password_hash) == 'Good!':\n        # Get hashed password and salt\n        new_password_data = hasher.get_hash_gen_salt(new_password)\n\n        # Update user salt in database\n        database.update_user_salt(username=username, salt=new_password_data['salt'])\n\n        # Update user password in database\n        database.update_password(username=username, password=new_password_data['password'])\n\n        return JSONResponse(status_code=200, content='Updated Password')\n    else: \n        raise HTTPException(status_code=401, detail=\"Invalid Password!\")\n    \n@app.get('/get_username/{account_id}')\nasync def get_username(account_id: str):\n    return database.get_username(account_id=account_id)\n\nif __name__ == '__main__':\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8002)\n"], "filenames": ["src/auth_server.py"], "buggy_code_start_loc": [346], "buggy_code_end_loc": [370], "fixing_code_start_loc": [346], "fixing_code_end_loc": [386], "type": "CWE-22", "message": "Lif Auth Server is a server for validating logins, managing information, and account recovery for Lif Accounts. The issue relates to the `get_pfp` and `get_banner` routes on Auth Server. The issue is that there is no check to ensure that the file that Auth Server is receiving through these URLs is correct. This could allow an attacker access to files they shouldn't have access to. This issue has been patched in version 1.4.0.", "other": {"cve": {"id": "CVE-2023-49801", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-12T21:15:09.943", "lastModified": "2024-01-22T19:49:34.180", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Lif Auth Server is a server for validating logins, managing information, and account recovery for Lif Accounts. The issue relates to the `get_pfp` and `get_banner` routes on Auth Server. The issue is that there is no check to ensure that the file that Auth Server is receiving through these URLs is correct. This could allow an attacker access to files they shouldn't have access to. This issue has been patched in version 1.4.0."}, {"lang": "es", "value": "Lif Auth Server es un servidor para validar inicios de sesi\u00f3n, administrar informaci\u00f3n y recuperar cuentas para cuentas Lif. El problema se relaciona con las rutas `get_pfp` y `get_banner` en Auth Server. El problema es que no hay ninguna verificaci\u00f3n para garantizar que el archivo que recibe el Auth Server a trav\u00e9s de estas URL sea correcto. Esto podr\u00eda permitir que un atacante acceda a archivos a los que no deber\u00eda tener acceso. Este problema se solucion\u00f3 en la versi\u00f3n 1.4.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}, {"lang": "en", "value": "CWE-23"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lifplatforms:lif_auth_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.0", "matchCriteriaId": "2BC6696D-4032-4C27-A31E-EB497683D262"}]}]}], "references": [{"url": "https://github.com/Lif-Platforms/Lif-Auth-Server/commit/c235bcc2ee65e4a0dfb10284cf2cbc750213efeb", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Lif-Platforms/Lif-Auth-Server/security/advisories/GHSA-3v77-pvqq-qg3f", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Lif-Platforms/Lif-Auth-Server/commit/c235bcc2ee65e4a0dfb10284cf2cbc750213efeb"}}