{"buggy_code": ["/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n *  memcached - memory caching daemon\n *\n *       https://www.memcached.org/\n *\n *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.\n *\n *  Use and distribution licensed under the BSD license.  See\n *  the LICENSE file for full text.\n *\n *  Authors:\n *      Anatoly Vorobey <mellon@pobox.com>\n *      Brad Fitzpatrick <brad@danga.com>\n */\n#include \"memcached.h\"\n#ifdef EXTSTORE\n#include \"storage.h\"\n#endif\n#include \"authfile.h\"\n#include \"restart.h\"\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <signal.h>\n#include <sys/param.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <ctype.h>\n#include <stdarg.h>\n\n/* some POSIX systems need the following definition\n * to get mlockall flags out of sys/mman.h.  */\n#ifndef _P1003_1B_VISIBLE\n#define _P1003_1B_VISIBLE\n#endif\n#include <pwd.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <assert.h>\n#include <sysexits.h>\n#include <stddef.h>\n\n#ifdef HAVE_GETOPT_LONG\n#include <getopt.h>\n#endif\n\n#ifdef TLS\n#include \"tls.h\"\n#endif\n\n#if defined(__FreeBSD__)\n#include <sys/sysctl.h>\n#endif\n\n/*\n * forward declarations\n */\nstatic void drive_machine(conn *c);\nstatic int new_socket(struct addrinfo *ai);\nstatic ssize_t tcp_read(conn *arg, void *buf, size_t count);\nstatic ssize_t tcp_sendmsg(conn *arg, struct msghdr *msg, int flags);\nstatic ssize_t tcp_write(conn *arg, void *buf, size_t count);\n\nenum try_read_result {\n    READ_DATA_RECEIVED,\n    READ_NO_DATA_RECEIVED,\n    READ_ERROR,            /** an error occurred (on the socket) (or client closed connection) */\n    READ_MEMORY_ERROR      /** failed to allocate more memory */\n};\n\nstatic int try_read_command_negotiate(conn *c);\nstatic int try_read_command_udp(conn *c);\nstatic int try_read_command_binary(conn *c);\nstatic int try_read_command_ascii(conn *c);\nstatic int try_read_command_asciiauth(conn *c);\n\nstatic enum try_read_result try_read_network(conn *c);\nstatic enum try_read_result try_read_udp(conn *c);\n\nstatic void conn_set_state(conn *c, enum conn_states state);\nstatic int start_conn_timeout_thread();\n\nstatic mc_resp* resp_finish(conn *c, mc_resp *resp);\n\n/* stats */\nstatic void stats_init(void);\nstatic void server_stats(ADD_STAT add_stats, conn *c);\nstatic void process_stat_settings(ADD_STAT add_stats, void *c);\nstatic void conn_to_str(const conn *c, char *addr, char *svr_addr);\n\n/** Return a datum for stats in binary protocol */\nstatic bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c);\n\n/* defaults */\nstatic void settings_init(void);\n\n/* event handling, network IO */\nstatic void event_handler(const int fd, const short which, void *arg);\nstatic void conn_close(conn *c);\nstatic void conn_init(void);\nstatic bool update_event(conn *c, const int new_flags);\nstatic void complete_nread(conn *c);\nstatic void process_command(conn *c, char *command);\nstatic void write_and_free(conn *c, char *buf, int bytes);\nstatic void write_bin_error(conn *c, protocol_binary_response_status err,\n                            const char *errstr, int swallow);\nstatic void write_bin_miss_response(conn *c, char *key, size_t nkey);\n\n#ifdef EXTSTORE\nstatic void _get_extstore_cb(void *e, obj_io *io, int ret);\nstatic inline int _get_extstore(conn *c, item *it, mc_resp *resp);\n#endif\nstatic void conn_free(conn *c);\n\n/** binprot handlers **/\nstatic void process_bin_flush(conn *c, char *extbuf);\nstatic void process_bin_append_prepend(conn *c);\nstatic void process_bin_update(conn *c, char *extbuf);\nstatic void process_bin_get_or_touch(conn *c, char *extbuf);\nstatic void process_bin_delete(conn *c);\nstatic void complete_incr_bin(conn *c, char *extbuf);\nstatic void process_bin_stat(conn *c);\nstatic void process_bin_sasl_auth(conn *c);\n\n/** exported globals **/\nstruct stats stats;\nstruct stats_state stats_state;\nstruct settings settings;\ntime_t process_started;     /* when the process was started */\nconn **conns;\n\nstruct slab_rebalance slab_rebal;\nvolatile int slab_rebalance_signal;\n#ifdef EXTSTORE\n/* hoping this is temporary; I'd prefer to cut globals, but will complete this\n * battle another day.\n */\nvoid *ext_storage = NULL;\n#endif\n/** file scope variables **/\nstatic conn *listen_conn = NULL;\nstatic int max_fds;\nstatic struct event_base *main_base;\n\nenum transmit_result {\n    TRANSMIT_COMPLETE,   /** All done writing. */\n    TRANSMIT_INCOMPLETE, /** More data remaining to write. */\n    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */\n    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */\n};\n\n/* Default methods to read from/ write to a socket */\nssize_t tcp_read(conn *c, void *buf, size_t count) {\n    assert (c != NULL);\n    return read(c->sfd, buf, count);\n}\n\nssize_t tcp_sendmsg(conn *c, struct msghdr *msg, int flags) {\n    assert (c != NULL);\n    return sendmsg(c->sfd, msg, flags);\n}\n\nssize_t tcp_write(conn *c, void *buf, size_t count) {\n    assert (c != NULL);\n    return write(c->sfd, buf, count);\n}\n\nstatic enum transmit_result transmit(conn *c);\n\n/* This reduces the latency without adding lots of extra wiring to be able to\n * notify the listener thread of when to listen again.\n * Also, the clock timer could be broken out into its own thread and we\n * can block the listener via a condition.\n */\nstatic volatile bool allow_new_conns = true;\nstatic bool stop_main_loop = false;\nstatic struct event maxconnsevent;\nstatic void maxconns_handler(const int fd, const short which, void *arg) {\n    struct timeval t = {.tv_sec = 0, .tv_usec = 10000};\n\n    if (fd == -42 || allow_new_conns == false) {\n        /* reschedule in 10ms if we need to keep polling */\n        evtimer_set(&maxconnsevent, maxconns_handler, 0);\n        event_base_set(main_base, &maxconnsevent);\n        evtimer_add(&maxconnsevent, &t);\n    } else {\n        evtimer_del(&maxconnsevent);\n        accept_new_conns(true);\n    }\n}\n\n#define REALTIME_MAXDELTA 60*60*24*30\n\n/* Negative exptimes can underflow and end up immortal. realtime() will\n   immediately expire values that are greater than REALTIME_MAXDELTA, but less\n   than process_started, so lets aim for that. */\n#define EXPTIME_TO_POSITIVE_TIME(exptime) (exptime < 0) ? \\\n        REALTIME_MAXDELTA + 1 : exptime\n\n\n/*\n * given time value that's either unix time or delta from current unix time, return\n * unix time. Use the fact that delta can't exceed one month (and real time value can't\n * be that low).\n */\nstatic rel_time_t realtime(const time_t exptime) {\n    /* no. of seconds in 30 days - largest possible delta exptime */\n\n    if (exptime == 0) return 0; /* 0 means never expire */\n\n    if (exptime > REALTIME_MAXDELTA) {\n        /* if item expiration is at/before the server started, give it an\n           expiration time of 1 second after the server started.\n           (because 0 means don't expire).  without this, we'd\n           underflow and wrap around to some large value way in the\n           future, effectively making items expiring in the past\n           really expiring never */\n        if (exptime <= process_started)\n            return (rel_time_t)1;\n        return (rel_time_t)(exptime - process_started);\n    } else {\n        return (rel_time_t)(exptime + current_time);\n    }\n}\n\nstatic void stats_init(void) {\n    memset(&stats, 0, sizeof(struct stats));\n    memset(&stats_state, 0, sizeof(struct stats_state));\n    stats_state.accepting_conns = true; /* assuming we start in this state. */\n\n    /* make the time we started always be 2 seconds before we really\n       did, so time(0) - time.started is never zero.  if so, things\n       like 'settings.oldest_live' which act as booleans as well as\n       values are now false in boolean context... */\n    process_started = time(0) - ITEM_UPDATE_INTERVAL - 2;\n    stats_prefix_init(settings.prefix_delimiter);\n}\n\nstatic void stats_reset(void) {\n    STATS_LOCK();\n    memset(&stats, 0, sizeof(struct stats));\n    stats_prefix_clear();\n    STATS_UNLOCK();\n    threadlocal_stats_reset();\n    item_stats_reset();\n}\n\nstatic void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 0;\n#ifdef TLS\n    settings.ssl_enabled = false;\n    settings.ssl_ctx = NULL;\n    settings.ssl_chain_cert = NULL;\n    settings.ssl_key = NULL;\n    settings.ssl_verify_mode = SSL_VERIFY_NONE;\n    settings.ssl_keyformat = SSL_FILETYPE_PEM;\n    settings.ssl_ciphers = NULL;\n    settings.ssl_ca_cert = NULL;\n    settings.ssl_last_cert_refresh_time = current_time;\n    settings.ssl_wbuf_size = 16 * 1024; // default is 16KB (SSL max frame size is 17KB)\n#endif\n    /* By default this string should be NULL for getaddrinfo() */\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */\n    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */\n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.oldest_cas = 0;          /* supplements accuracy of oldest_live */\n    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */\n    settings.socketpath = NULL;       /* by default, not using a unix socket */\n    settings.auth_file = NULL;        /* by default, not using ASCII authentication tokens */\n    settings.factor = 1.25;\n    settings.chunk_size = 48;         /* space for a modest key and value */\n    settings.num_threads = 4;         /* N workers */\n    settings.num_threads_per_udp = 0;\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.reqs_per_event = 20;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */\n    settings.slab_page_size = 1024 * 1024; /* chunks are split from 1MB pages. */\n    settings.slab_chunk_size_max = settings.slab_page_size / 2;\n    settings.sasl = false;\n    settings.maxconns_fast = true;\n    settings.lru_crawler = false;\n    settings.lru_crawler_sleep = 100;\n    settings.lru_crawler_tocrawl = 0;\n    settings.lru_maintainer_thread = false;\n    settings.lru_segmented = true;\n    settings.hot_lru_pct = 20;\n    settings.warm_lru_pct = 40;\n    settings.hot_max_factor = 0.2;\n    settings.warm_max_factor = 2.0;\n    settings.temp_lru = false;\n    settings.temporary_ttl = 61;\n    settings.idle_timeout = 0; /* disabled */\n    settings.hashpower_init = 0;\n    settings.slab_reassign = true;\n    settings.slab_automove = 1;\n    settings.slab_automove_ratio = 0.8;\n    settings.slab_automove_window = 30;\n    settings.shutdown_command = false;\n    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;\n    settings.flush_enabled = true;\n    settings.dump_enabled = true;\n    settings.crawls_persleep = 1000;\n    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;\n    settings.logger_buf_size = LOGGER_BUF_SIZE;\n    settings.drop_privileges = false;\n    settings.watch_enabled = true;\n    settings.resp_obj_mem_limit = 0;\n    settings.read_buf_mem_limit = 0;\n#ifdef MEMCACHED_DEBUG\n    settings.relaxed_privileges = false;\n#endif\n}\n\nextern pthread_mutex_t conn_lock;\n\n/* Connection timeout thread bits */\nstatic pthread_t conn_timeout_tid;\nstatic int do_run_conn_timeout_thread;\n\n#define CONNS_PER_SLICE 100\n#define TIMEOUT_MSG_SIZE (1 + sizeof(int))\nstatic void *conn_timeout_thread(void *arg) {\n    int i;\n    conn *c;\n    char buf[TIMEOUT_MSG_SIZE];\n    rel_time_t oldest_last_cmd;\n    int sleep_time;\n    useconds_t timeslice = 1000000 / (max_fds / CONNS_PER_SLICE);\n\n    while(do_run_conn_timeout_thread) {\n        if (settings.verbose > 2)\n            fprintf(stderr, \"idle timeout thread at top of connection list\\n\");\n\n        oldest_last_cmd = current_time;\n\n        for (i = 0; i < max_fds; i++) {\n            if ((i % CONNS_PER_SLICE) == 0) {\n                if (settings.verbose > 2)\n                    fprintf(stderr, \"idle timeout thread sleeping for %ulus\\n\",\n                        (unsigned int)timeslice);\n                usleep(timeslice);\n            }\n\n            if (!conns[i])\n                continue;\n\n            c = conns[i];\n\n            if (!IS_TCP(c->transport))\n                continue;\n\n            if (c->state != conn_new_cmd && c->state != conn_read)\n                continue;\n\n            if ((current_time - c->last_cmd_time) > settings.idle_timeout) {\n                buf[0] = 't';\n                memcpy(&buf[1], &i, sizeof(int));\n                if (write(c->thread->notify_send_fd, buf, TIMEOUT_MSG_SIZE)\n                    != TIMEOUT_MSG_SIZE)\n                    perror(\"Failed to write timeout to notify pipe\");\n            } else {\n                if (c->last_cmd_time < oldest_last_cmd)\n                    oldest_last_cmd = c->last_cmd_time;\n            }\n        }\n\n        /* This is the soonest we could have another connection time out */\n        sleep_time = settings.idle_timeout - (current_time - oldest_last_cmd) + 1;\n        if (sleep_time <= 0)\n            sleep_time = 1;\n\n        if (settings.verbose > 2)\n            fprintf(stderr,\n                    \"idle timeout thread finished pass, sleeping for %ds\\n\",\n                    sleep_time);\n        usleep((useconds_t) sleep_time * 1000000);\n    }\n\n    return NULL;\n}\n\nstatic int start_conn_timeout_thread() {\n    int ret;\n\n    if (settings.idle_timeout == 0)\n        return -1;\n\n    do_run_conn_timeout_thread = 1;\n    if ((ret = pthread_create(&conn_timeout_tid, NULL,\n        conn_timeout_thread, NULL)) != 0) {\n        fprintf(stderr, \"Can't create idle connection timeout thread: %s\\n\",\n            strerror(ret));\n        return -1;\n    }\n\n    return 0;\n}\n\nint stop_conn_timeout_thread(void) {\n    if (!do_run_conn_timeout_thread)\n        return -1;\n    do_run_conn_timeout_thread = 0;\n    pthread_join(conn_timeout_tid, NULL);\n    return 0;\n}\n\n/*\n * read buffer cache helper functions\n */\nstatic void rbuf_release(conn *c) {\n    if (c->rbuf != NULL && c->rbytes == 0 && !IS_UDP(c->transport)) {\n        if (c->rbuf_malloced) {\n            free(c->rbuf);\n            c->rbuf_malloced = false;\n        } else {\n            do_cache_free(c->thread->rbuf_cache, c->rbuf);\n        }\n        c->rsize = 0;\n        c->rbuf = NULL;\n        c->rcurr = NULL;\n    }\n}\n\nstatic bool rbuf_alloc(conn *c) {\n    if (c->rbuf == NULL) {\n        c->rbuf = do_cache_alloc(c->thread->rbuf_cache);\n        if (!c->rbuf) {\n            THR_STATS_LOCK(c);\n            c->thread->stats.read_buf_oom++;\n            THR_STATS_UNLOCK(c);\n            return false;\n        }\n        c->rsize = READ_BUFFER_SIZE;\n        c->rcurr = c->rbuf;\n    }\n    return true;\n}\n\n// Just for handling huge ASCII multigets.\n// The previous system was essentially the same; realloc'ing until big enough,\n// then realloc'ing back down after the request finished.\nstatic bool rbuf_switch_to_malloc(conn *c) {\n    // Might as well start with x2 and work from there.\n    size_t size = c->rsize * 2;\n    char *tmp = malloc(size);\n    if (!tmp)\n        return false;\n\n    do_cache_free(c->thread->rbuf_cache, c->rbuf);\n    memcpy(tmp, c->rcurr, c->rbytes);\n\n    c->rcurr = c->rbuf = tmp;\n    c->rsize = size;\n    c->rbuf_malloced = true;\n    return true;\n}\n\n/*\n * Initializes the connections array. We don't actually allocate connection\n * structures until they're needed, so as to avoid wasting memory when the\n * maximum connection count is much higher than the actual number of\n * connections.\n *\n * This does end up wasting a few pointers' worth of memory for FDs that are\n * used for things other than connections, but that's worth it in exchange for\n * being able to directly index the conns array by FD.\n */\nstatic void conn_init(void) {\n    /* We're unlikely to see an FD much higher than maxconns. */\n    int next_fd = dup(1);\n    if (next_fd < 0) {\n        perror(\"Failed to duplicate file descriptor\\n\");\n        exit(1);\n    }\n    int headroom = 10;      /* account for extra unexpected open FDs */\n    struct rlimit rl;\n\n    max_fds = settings.maxconns + headroom + next_fd;\n\n    /* But if possible, get the actual highest FD we can possibly ever see. */\n    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {\n        max_fds = rl.rlim_max;\n    } else {\n        fprintf(stderr, \"Failed to query maximum file descriptor; \"\n                        \"falling back to maxconns\\n\");\n    }\n\n    close(next_fd);\n\n    if ((conns = calloc(max_fds, sizeof(conn *))) == NULL) {\n        fprintf(stderr, \"Failed to allocate connection structures\\n\");\n        /* This is unrecoverable so bail out early. */\n        exit(1);\n    }\n}\n\nstatic const char *prot_text(enum protocol prot) {\n    char *rv = \"unknown\";\n    switch(prot) {\n        case ascii_prot:\n            rv = \"ascii\";\n            break;\n        case binary_prot:\n            rv = \"binary\";\n            break;\n        case negotiating_prot:\n            rv = \"auto-negotiate\";\n            break;\n    }\n    return rv;\n}\n\nvoid conn_close_idle(conn *c) {\n    if (settings.idle_timeout > 0 &&\n        (current_time - c->last_cmd_time) > settings.idle_timeout) {\n        if (c->state != conn_new_cmd && c->state != conn_read) {\n            if (settings.verbose > 1)\n                fprintf(stderr,\n                    \"fd %d wants to timeout, but isn't in read state\", c->sfd);\n            return;\n        }\n\n        if (settings.verbose > 1)\n            fprintf(stderr, \"Closing idle fd %d\\n\", c->sfd);\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.idle_kicks++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        conn_set_state(c, conn_closing);\n        drive_machine(c);\n    }\n}\n\n/* bring conn back from a sidethread. could have had its event base moved. */\nvoid conn_worker_readd(conn *c) {\n    c->ev_flags = EV_READ | EV_PERSIST;\n    event_set(&c->event, c->sfd, c->ev_flags, event_handler, (void *)c);\n    event_base_set(c->thread->base, &c->event);\n\n    // TODO: call conn_cleanup/fail/etc\n    if (event_add(&c->event, 0) == -1) {\n        perror(\"event_add\");\n    }\n\n    // side thread wanted us to close immediately.\n    if (c->state == conn_closing) {\n        drive_machine(c);\n        return;\n    }\n    c->state = conn_new_cmd;\n\n#ifdef EXTSTORE\n    // If we had IO objects, process\n    if (c->io_wraplist) {\n        //assert(c->io_wrapleft == 0); // assert no more to process\n        conn_set_state(c, conn_mwrite);\n        drive_machine(c);\n    }\n#endif\n}\n\nconn *conn_new(const int sfd, enum conn_states init_state,\n                const int event_flags,\n                const int read_buffer_size, enum network_transport transport,\n                struct event_base *base, void *ssl) {\n    conn *c;\n\n    assert(sfd >= 0 && sfd < max_fds);\n    c = conns[sfd];\n\n    if (NULL == c) {\n        if (!(c = (conn *)calloc(1, sizeof(conn)))) {\n            STATS_LOCK();\n            stats.malloc_fails++;\n            STATS_UNLOCK();\n            fprintf(stderr, \"Failed to allocate connection object\\n\");\n            return NULL;\n        }\n        MEMCACHED_CONN_CREATE(c);\n        c->read = NULL;\n        c->sendmsg = NULL;\n        c->write = NULL;\n        c->rbuf = NULL;\n\n        c->rsize = read_buffer_size;\n\n        // UDP connections use a persistent static buffer.\n        if (c->rsize) {\n            c->rbuf = (char *)malloc((size_t)c->rsize);\n        }\n\n        if (c->rsize && c->rbuf == NULL) {\n            conn_free(c);\n            STATS_LOCK();\n            stats.malloc_fails++;\n            STATS_UNLOCK();\n            fprintf(stderr, \"Failed to allocate buffers for connection\\n\");\n            return NULL;\n        }\n\n        STATS_LOCK();\n        stats_state.conn_structs++;\n        STATS_UNLOCK();\n\n        c->sfd = sfd;\n        conns[sfd] = c;\n    }\n\n    c->transport = transport;\n    c->protocol = settings.binding_protocol;\n\n    /* unix socket mode doesn't need this, so zeroed out.  but why\n     * is this done for every command?  presumably for UDP\n     * mode.  */\n    if (!settings.socketpath) {\n        c->request_addr_size = sizeof(c->request_addr);\n    } else {\n        c->request_addr_size = 0;\n    }\n\n    if (transport == tcp_transport && init_state == conn_new_cmd) {\n        if (getpeername(sfd, (struct sockaddr *) &c->request_addr,\n                        &c->request_addr_size)) {\n            perror(\"getpeername\");\n            memset(&c->request_addr, 0, sizeof(c->request_addr));\n        }\n    }\n\n    if (settings.verbose > 1) {\n        if (init_state == conn_listening) {\n            fprintf(stderr, \"<%d server listening (%s)\\n\", sfd,\n                prot_text(c->protocol));\n        } else if (IS_UDP(transport)) {\n            fprintf(stderr, \"<%d server listening (udp)\\n\", sfd);\n        } else if (c->protocol == negotiating_prot) {\n            fprintf(stderr, \"<%d new auto-negotiating client connection\\n\",\n                    sfd);\n        } else if (c->protocol == ascii_prot) {\n            fprintf(stderr, \"<%d new ascii client connection.\\n\", sfd);\n        } else if (c->protocol == binary_prot) {\n            fprintf(stderr, \"<%d new binary client connection.\\n\", sfd);\n        } else {\n            fprintf(stderr, \"<%d new unknown (%d) client connection\\n\",\n                sfd, c->protocol);\n            assert(false);\n        }\n    }\n\n#ifdef TLS\n    c->ssl = NULL;\n    c->ssl_wbuf = NULL;\n    c->ssl_enabled = false;\n#endif\n    c->state = init_state;\n    c->rlbytes = 0;\n    c->cmd = -1;\n    c->rbytes = 0;\n    c->rcurr = c->rbuf;\n    c->ritem = 0;\n    c->rbuf_malloced = false;\n    c->sasl_started = false;\n    c->set_stale = false;\n    c->mset_res = false;\n    c->close_after_write = false;\n    c->last_cmd_time = current_time; /* initialize for idle kicker */\n#ifdef EXTSTORE\n    c->io_wraplist = NULL;\n    c->io_wrapleft = 0;\n#endif\n\n    c->item = 0;\n\n    c->noreply = false;\n\n#ifdef TLS\n    if (ssl) {\n        c->ssl = (SSL*)ssl;\n        c->read = ssl_read;\n        c->sendmsg = ssl_sendmsg;\n        c->write = ssl_write;\n        c->ssl_enabled = true;\n        SSL_set_info_callback(c->ssl, ssl_callback);\n    } else\n#else\n    // This must be NULL if TLS is not enabled.\n    assert(ssl == NULL);\n#endif\n    {\n        c->read = tcp_read;\n        c->sendmsg = tcp_sendmsg;\n        c->write = tcp_write;\n    }\n\n    if (IS_UDP(transport)) {\n        c->try_read_command = try_read_command_udp;\n    } else {\n        switch (c->protocol) {\n            case ascii_prot:\n                if (settings.auth_file == NULL) {\n                    c->authenticated = true;\n                    c->try_read_command = try_read_command_ascii;\n                } else {\n                    c->authenticated = false;\n                    c->try_read_command = try_read_command_asciiauth;\n                }\n                break;\n            case binary_prot:\n                // binprot handles its own authentication via SASL parsing.\n                c->authenticated = false;\n                c->try_read_command = try_read_command_binary;\n                break;\n            case negotiating_prot:\n                c->try_read_command = try_read_command_negotiate;\n                break;\n        }\n    }\n\n    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = event_flags;\n\n    if (event_add(&c->event, 0) == -1) {\n        perror(\"event_add\");\n        return NULL;\n    }\n\n    STATS_LOCK();\n    stats_state.curr_conns++;\n    stats.total_conns++;\n    STATS_UNLOCK();\n\n    MEMCACHED_CONN_ALLOCATE(c->sfd);\n\n    return c;\n}\n#ifdef EXTSTORE\nstatic void recache_or_free(conn *c, io_wrap *wrap) {\n    item *it;\n    it = (item *)wrap->io.buf;\n    bool do_free = true;\n    if (wrap->active) {\n        // If request never dispatched, free the read buffer but leave the\n        // item header alone.\n        do_free = false;\n        size_t ntotal = ITEM_ntotal(wrap->hdr_it);\n        slabs_free(it, ntotal, slabs_clsid(ntotal));\n        c->io_wrapleft--;\n        assert(c->io_wrapleft >= 0);\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.get_aborted_extstore++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n    } else if (wrap->miss) {\n        // If request was ultimately a miss, unlink the header.\n        do_free = false;\n        size_t ntotal = ITEM_ntotal(wrap->hdr_it);\n        item_unlink(wrap->hdr_it);\n        slabs_free(it, ntotal, slabs_clsid(ntotal));\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.miss_from_extstore++;\n        if (wrap->badcrc)\n            c->thread->stats.badcrc_from_extstore++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n    } else if (settings.ext_recache_rate) {\n        // hashvalue is cuddled during store\n        uint32_t hv = (uint32_t)it->time;\n        // opt to throw away rather than wait on a lock.\n        void *hold_lock = item_trylock(hv);\n        if (hold_lock != NULL) {\n            item *h_it = wrap->hdr_it;\n            uint8_t flags = ITEM_LINKED|ITEM_FETCHED|ITEM_ACTIVE;\n            // Item must be recently hit at least twice to recache.\n            if (((h_it->it_flags & flags) == flags) &&\n                    h_it->time > current_time - ITEM_UPDATE_INTERVAL &&\n                    c->recache_counter++ % settings.ext_recache_rate == 0) {\n                do_free = false;\n                // In case it's been updated.\n                it->exptime = h_it->exptime;\n                it->it_flags &= ~ITEM_LINKED;\n                it->refcount = 0;\n                it->h_next = NULL; // might not be necessary.\n                STORAGE_delete(c->thread->storage, h_it);\n                item_replace(h_it, it, hv);\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.recache_from_extstore++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n            }\n        }\n        if (hold_lock)\n            item_trylock_unlock(hold_lock);\n    }\n    if (do_free)\n        slabs_free(it, ITEM_ntotal(it), ITEM_clsid(it));\n\n    wrap->io.buf = NULL; // sanity.\n    wrap->io.next = NULL;\n    wrap->next = NULL;\n    wrap->active = false;\n\n    // TODO: reuse lock and/or hv.\n    item_remove(wrap->hdr_it);\n}\n#endif\nstatic void conn_release_items(conn *c) {\n    assert(c != NULL);\n\n    if (c->item) {\n        item_remove(c->item);\n        c->item = 0;\n    }\n\n#ifdef EXTSTORE\n    if (c->io_wraplist) {\n        io_wrap *tmp = c->io_wraplist;\n        while (tmp) {\n            io_wrap *next = tmp->next;\n            recache_or_free(c, tmp);\n            // malloc'ed iovec list used for chunked extstore fetches.\n            if (tmp->io.iov) {\n                free(tmp->io.iov);\n                tmp->io.iov = NULL;\n            }\n            do_cache_free(c->thread->io_cache, tmp); // lockless\n            tmp = next;\n        }\n        c->io_wraplist = NULL;\n    }\n#endif\n\n    // Cull any unsent responses.\n    if (c->resp_head) {\n        mc_resp *resp = c->resp_head;\n        // r_f() handles the chain maintenance.\n        while (resp) {\n            // temporary by default. hide behind a debug flag in the future:\n            // double free detection. Transmit loops can drop out early, but\n            // here we could infinite loop.\n            if (resp->free) {\n                fprintf(stderr, \"ERROR: double free detected during conn_release_items(): [%d] [%s]\\n\",\n                        c->sfd, c->protocol == binary_prot ? \"binary\" : \"ascii\");\n                // Since this is a critical failure, just leak the memory.\n                // If these errors are seen, an abort() can be used instead.\n                c->resp_head = NULL;\n                c->resp = NULL;\n                break;\n            }\n            resp = resp_finish(c, resp);\n        }\n    }\n}\n\nstatic void conn_cleanup(conn *c) {\n    assert(c != NULL);\n\n    conn_release_items(c);\n\n    if (c->sasl_conn) {\n        assert(settings.sasl);\n        sasl_dispose(&c->sasl_conn);\n        c->sasl_conn = NULL;\n    }\n\n    if (IS_UDP(c->transport)) {\n        conn_set_state(c, conn_read);\n    }\n}\n\n/*\n * Frees a connection.\n */\nvoid conn_free(conn *c) {\n    if (c) {\n        assert(c != NULL);\n        assert(c->sfd >= 0 && c->sfd < max_fds);\n\n        MEMCACHED_CONN_DESTROY(c);\n        conns[c->sfd] = NULL;\n        if (c->rbuf)\n            free(c->rbuf);\n#ifdef TLS\n        if (c->ssl_wbuf)\n            c->ssl_wbuf = NULL;\n#endif\n\n        free(c);\n    }\n}\n\nstatic void conn_close(conn *c) {\n    assert(c != NULL);\n\n    /* delete the event, the socket and the conn */\n    event_del(&c->event);\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"<%d connection closed.\\n\", c->sfd);\n\n    conn_cleanup(c);\n\n    // force release of read buffer.\n    if (c->thread) {\n        c->rbytes = 0;\n        rbuf_release(c);\n    }\n\n    MEMCACHED_CONN_RELEASE(c->sfd);\n    conn_set_state(c, conn_closed);\n#ifdef TLS\n    if (c->ssl) {\n        SSL_shutdown(c->ssl);\n        SSL_free(c->ssl);\n    }\n#endif\n    close(c->sfd);\n    pthread_mutex_lock(&conn_lock);\n    allow_new_conns = true;\n    pthread_mutex_unlock(&conn_lock);\n\n    STATS_LOCK();\n    stats_state.curr_conns--;\n    STATS_UNLOCK();\n\n    return;\n}\n\n/**\n * Convert a state name to a human readable form.\n */\nstatic const char *state_text(enum conn_states state) {\n    const char* const statenames[] = { \"conn_listening\",\n                                       \"conn_new_cmd\",\n                                       \"conn_waiting\",\n                                       \"conn_read\",\n                                       \"conn_parse_cmd\",\n                                       \"conn_write\",\n                                       \"conn_nread\",\n                                       \"conn_swallow\",\n                                       \"conn_closing\",\n                                       \"conn_mwrite\",\n                                       \"conn_closed\",\n                                       \"conn_watch\" };\n    return statenames[state];\n}\n\n/*\n * Sets a connection's current state in the state machine. Any special\n * processing that needs to happen on certain state transitions can\n * happen here.\n */\nstatic void conn_set_state(conn *c, enum conn_states state) {\n    assert(c != NULL);\n    assert(state >= conn_listening && state < conn_max_state);\n\n    if (state != c->state) {\n        if (settings.verbose > 2) {\n            fprintf(stderr, \"%d: going from %s to %s\\n\",\n                    c->sfd, state_text(c->state),\n                    state_text(state));\n        }\n\n        if (state == conn_write || state == conn_mwrite) {\n            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->resp->wbuf, c->resp->wbytes);\n        }\n        c->state = state;\n    }\n}\n\n/*\n * response object helper functions\n */\nstatic void resp_reset(mc_resp *resp) {\n    if (resp->item) {\n        item_remove(resp->item);\n        resp->item = NULL;\n    }\n    if (resp->write_and_free) {\n        free(resp->write_and_free);\n        resp->write_and_free = NULL;\n    }\n    resp->wbytes = 0;\n    resp->tosend = 0;\n    resp->iovcnt = 0;\n    resp->chunked_data_iov = 0;\n    resp->chunked_total = 0;\n    resp->skip = false;\n}\n\nstatic void resp_add_iov(mc_resp *resp, const void *buf, int len) {\n    assert(resp->iovcnt < MC_RESP_IOVCOUNT);\n    int x = resp->iovcnt;\n    resp->iov[x].iov_base = (void *)buf;\n    resp->iov[x].iov_len = len;\n    resp->iovcnt++;\n    resp->tosend += len;\n}\n\n// Notes that an IOV should be handled as a chunked item header.\n// TODO: I'm hoping this isn't a permanent abstraction while I learn what the\n// API should be.\nstatic void resp_add_chunked_iov(mc_resp *resp, const void *buf, int len) {\n    resp->chunked_data_iov = resp->iovcnt;\n    resp->chunked_total = len;\n    resp_add_iov(resp, buf, len);\n}\n\nstatic bool resp_start(conn *c) {\n    mc_resp *resp = do_cache_alloc(c->thread->resp_cache);\n    if (!resp) {\n        THR_STATS_LOCK(c);\n        c->thread->stats.response_obj_oom++;\n        THR_STATS_UNLOCK(c);\n        return false;\n    }\n    // FIXME: make wbuf indirect or use offsetof to zero up until wbuf\n    memset(resp, 0, sizeof(*resp));\n    if (!c->resp_head) {\n        c->resp_head = resp;\n    }\n    if (!c->resp) {\n        c->resp = resp;\n    } else {\n        c->resp->next = resp;\n        c->resp = resp;\n    }\n    if (IS_UDP(c->transport)) {\n        // need to hold on to some data for async responses.\n        c->resp->request_id = c->request_id;\n        c->resp->request_addr = c->request_addr;\n        c->resp->request_addr_size = c->request_addr_size;\n    }\n    return true;\n}\n\n// returns next response in chain.\nstatic mc_resp* resp_finish(conn *c, mc_resp *resp) {\n    mc_resp *next = resp->next;\n    if (resp->item) {\n        // TODO: cache hash value in resp obj?\n        item_remove(resp->item);\n        resp->item = NULL;\n    }\n    if (resp->write_and_free) {\n        free(resp->write_and_free);\n    }\n    if (c->resp_head == resp) {\n        c->resp_head = next;\n    }\n    if (c->resp == resp) {\n        c->resp = NULL;\n    }\n    resp->free = true;\n    do_cache_free(c->thread->resp_cache, resp);\n    return next;\n}\n\n// tells if connection has a depth of response objects to process.\nstatic bool resp_has_stack(conn *c) {\n    return c->resp_head->next != NULL ? true : false;\n}\n\nstatic void out_string(conn *c, const char *str) {\n    size_t len;\n    mc_resp *resp = c->resp;\n\n    assert(c != NULL);\n    // if response was original filled with something, but we're now writing\n    // out an error or similar, have to reset the object first.\n    // TODO: since this is often redundant with allocation, how many callers\n    // are actually requiring it be reset? Can we fast test by just looking at\n    // tosend and reset if nonzero?\n    resp_reset(resp);\n\n    if (c->noreply) {\n        // TODO: just invalidate the response since nothing's been attempted\n        // to send yet?\n        resp->skip = true;\n        if (settings.verbose > 1)\n            fprintf(stderr, \">%d NOREPLY %s\\n\", c->sfd, str);\n        conn_set_state(c, conn_new_cmd);\n        return;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d %s\\n\", c->sfd, str);\n\n    // Fill response object with static string.\n\n    len = strlen(str);\n    if ((len + 2) > WRITE_BUFFER_SIZE) {\n        /* ought to be always enough. just fail for simplicity */\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n\n    memcpy(resp->wbuf, str, len);\n    memcpy(resp->wbuf + len, \"\\r\\n\", 2);\n    resp_add_iov(resp, resp->wbuf, len + 2);\n\n    conn_set_state(c, conn_new_cmd);\n    return;\n}\n\n// For metaget-style ASCII commands. Ignores noreply, ensuring clients see\n// protocol level errors.\nstatic void out_errstring(conn *c, const char *str) {\n    c->noreply = false;\n    out_string(c, str);\n}\n\n/*\n * Outputs a protocol-specific \"out of memory\" error. For ASCII clients,\n * this is equivalent to out_string().\n */\nstatic void out_of_memory(conn *c, char *ascii_error) {\n    const static char error_prefix[] = \"SERVER_ERROR \";\n    const static int error_prefix_len = sizeof(error_prefix) - 1;\n\n    if (c->protocol == binary_prot) {\n        /* Strip off the generic error prefix; it's irrelevant in binary */\n        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {\n            ascii_error += error_prefix_len;\n        }\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);\n    } else {\n        out_string(c, ascii_error);\n    }\n}\n\n/*\n * we get here after reading the value in set/add/replace commands. The command\n * has been stored in c->cmd, and the item is ready in c->item.\n */\nstatic void complete_nread_ascii(conn *c) {\n    assert(c != NULL);\n\n    item *it = c->item;\n    int comm = c->cmd;\n    enum store_item_type ret;\n    bool is_valid = false;\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    if ((it->it_flags & ITEM_CHUNKED) == 0) {\n        if (strncmp(ITEM_data(it) + it->nbytes - 2, \"\\r\\n\", 2) == 0) {\n            is_valid = true;\n        }\n    } else {\n        char buf[2];\n        /* should point to the final item chunk */\n        item_chunk *ch = (item_chunk *) c->ritem;\n        assert(ch->used != 0);\n        /* :( We need to look at the last two bytes. This could span two\n         * chunks.\n         */\n        if (ch->used > 1) {\n            buf[0] = ch->data[ch->used - 2];\n            buf[1] = ch->data[ch->used - 1];\n        } else {\n            assert(ch->prev);\n            assert(ch->used == 1);\n            buf[0] = ch->prev->data[ch->prev->used - 1];\n            buf[1] = ch->data[ch->used - 1];\n        }\n        if (strncmp(buf, \"\\r\\n\", 2) == 0) {\n            is_valid = true;\n        } else {\n            assert(1 == 0);\n        }\n    }\n\n    if (!is_valid) {\n        // metaset mode always returns errors.\n        if (c->mset_res) {\n            c->noreply = false;\n        }\n        out_string(c, \"CLIENT_ERROR bad data chunk\");\n    } else {\n      ret = store_item(it, comm, c);\n\n#ifdef ENABLE_DTRACE\n      uint64_t cas = ITEM_get_cas(it);\n      switch (c->cmd) {\n      case NREAD_ADD:\n          MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,\n                                (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_REPLACE:\n          MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,\n                                    (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_APPEND:\n          MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,\n                                   (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_PREPEND:\n          MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,\n                                    (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_SET:\n          MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,\n                                (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_CAS:\n          MEMCACHED_COMMAND_CAS(c->sfd, ITEM_key(it), it->nkey, it->nbytes,\n                                cas);\n          break;\n      }\n#endif\n\n      if (c->mset_res) {\n          // Replace the status code in the response.\n          // Rest was prepared during mset parsing.\n          mc_resp *resp = c->resp;\n          conn_set_state(c, conn_new_cmd);\n          switch (ret) {\n          case STORED:\n              memcpy(resp->wbuf, \"OK \", 3);\n              // Only place noreply is used for meta cmds is a nominal response.\n              if (c->noreply) {\n                  resp->skip = true;\n              }\n              break;\n          case EXISTS:\n              memcpy(resp->wbuf, \"EX \", 3);\n              break;\n          case NOT_FOUND:\n              memcpy(resp->wbuf, \"NF \", 3);\n              break;\n          case NOT_STORED:\n              memcpy(resp->wbuf, \"NS \", 3);\n              break;\n          default:\n              c->noreply = false;\n              out_string(c, \"SERVER_ERROR Unhandled storage type.\");\n          }\n      } else {\n          switch (ret) {\n          case STORED:\n              out_string(c, \"STORED\");\n              break;\n          case EXISTS:\n              out_string(c, \"EXISTS\");\n              break;\n          case NOT_FOUND:\n              out_string(c, \"NOT_FOUND\");\n              break;\n          case NOT_STORED:\n              out_string(c, \"NOT_STORED\");\n              break;\n          default:\n              out_string(c, \"SERVER_ERROR Unhandled storage type.\");\n          }\n      }\n\n    }\n\n    c->set_stale = false; /* force flag to be off just in case */\n    c->mset_res = false;\n    item_remove(c->item);       /* release the c->item reference */\n    c->item = 0;\n}\n\n/**\n * get a pointer to the key in this request\n */\nstatic char* binary_get_key(conn *c) {\n    return c->rcurr - (c->binary_header.request.keylen);\n}\n\nstatic void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {\n    protocol_binary_response_header* header;\n    mc_resp *resp = c->resp;\n\n    assert(c);\n\n    resp_reset(resp);\n\n    header = (protocol_binary_response_header *)resp->wbuf;\n\n    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;\n    header->response.opcode = c->binary_header.request.opcode;\n    header->response.keylen = (uint16_t)htons(key_len);\n\n    header->response.extlen = (uint8_t)hdr_len;\n    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;\n    header->response.status = (uint16_t)htons(err);\n\n    header->response.bodylen = htonl(body_len);\n    header->response.opaque = c->opaque;\n    header->response.cas = htonll(c->cas);\n\n    if (settings.verbose > 1) {\n        int ii;\n        fprintf(stderr, \">%d Writing bin response:\", c->sfd);\n        for (ii = 0; ii < sizeof(header->bytes); ++ii) {\n            if (ii % 4 == 0) {\n                fprintf(stderr, \"\\n>%d  \", c->sfd);\n            }\n            fprintf(stderr, \" 0x%02x\", header->bytes[ii]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n\n    resp->wbytes = sizeof(header->response);\n    resp_add_iov(resp, resp->wbuf, resp->wbytes);\n}\n\n/**\n * Writes a binary error response. If errstr is supplied, it is used as the\n * error text; otherwise a generic description of the error status code is\n * included.\n */\nstatic void write_bin_error(conn *c, protocol_binary_response_status err,\n                            const char *errstr, int swallow) {\n    size_t len;\n\n    if (!errstr) {\n        switch (err) {\n        case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n            errstr = \"Out of memory\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n            errstr = \"Unknown command\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n            errstr = \"Not found\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_EINVAL:\n            errstr = \"Invalid arguments\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n            errstr = \"Data exists for key.\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_E2BIG:\n            errstr = \"Too large.\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:\n            errstr = \"Non-numeric server-side value for incr or decr\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n            errstr = \"Not stored.\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n            errstr = \"Auth failure.\";\n            break;\n        default:\n            assert(false);\n            errstr = \"UNHANDLED ERROR\";\n            fprintf(stderr, \">%d UNHANDLED ERROR: %d\\n\", c->sfd, err);\n        }\n    }\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \">%d Writing an error: %s\\n\", c->sfd, errstr);\n    }\n\n    len = strlen(errstr);\n    add_bin_header(c, err, 0, 0, len);\n    if (len > 0) {\n        resp_add_iov(c->resp, errstr, len);\n    }\n    if (swallow > 0) {\n        c->sbytes = swallow;\n        conn_set_state(c, conn_swallow);\n    } else {\n        conn_set_state(c, conn_mwrite);\n    }\n}\n\n/* Form and send a response to a command over the binary protocol */\nstatic void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {\n    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||\n        c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n        add_bin_header(c, 0, hlen, keylen, dlen);\n        mc_resp *resp = c->resp;\n        if (dlen > 0) {\n            resp_add_iov(resp, d, dlen);\n        }\n    }\n\n    conn_set_state(c, conn_new_cmd);\n}\n\nstatic void complete_incr_bin(conn *c, char *extbuf) {\n    item *it;\n    char *key;\n    size_t nkey;\n    /* Weird magic in add_delta forces me to pad here */\n    char tmpbuf[INCR_MAX_STORAGE_LEN];\n    uint64_t cas = 0;\n\n    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->resp->wbuf;\n    protocol_binary_request_incr* req = (void *)extbuf;\n\n    assert(c != NULL);\n    //assert(c->wsize >= sizeof(*rsp));\n\n    /* fix byteorder in the request */\n    req->message.body.delta = ntohll(req->message.body.delta);\n    req->message.body.initial = ntohll(req->message.body.initial);\n    req->message.body.expiration = ntohl(req->message.body.expiration);\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        int i;\n        fprintf(stderr, \"incr \");\n\n        for (i = 0; i < nkey; i++) {\n            fprintf(stderr, \"%c\", key[i]);\n        }\n        fprintf(stderr, \" %lld, %llu, %d\\n\",\n                (long long)req->message.body.delta,\n                (long long)req->message.body.initial,\n                req->message.body.expiration);\n    }\n\n    if (c->binary_header.request.cas != 0) {\n        cas = c->binary_header.request.cas;\n    }\n    switch(add_delta(c, key, nkey, c->cmd == PROTOCOL_BINARY_CMD_INCREMENT,\n                     req->message.body.delta, tmpbuf,\n                     &cas)) {\n    case OK:\n        rsp->message.body.value = htonll(strtoull(tmpbuf, NULL, 10));\n        if (cas) {\n            c->cas = cas;\n        }\n        write_bin_response(c, &rsp->message.body, 0, 0,\n                           sizeof(rsp->message.body.value));\n        break;\n    case NON_NUMERIC:\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, NULL, 0);\n        break;\n    case EOM:\n        out_of_memory(c, \"SERVER_ERROR Out of memory incrementing value\");\n        break;\n    case DELTA_ITEM_NOT_FOUND:\n        if (req->message.body.expiration != 0xffffffff) {\n            /* Save some room for the response */\n            rsp->message.body.value = htonll(req->message.body.initial);\n\n            snprintf(tmpbuf, INCR_MAX_STORAGE_LEN, \"%llu\",\n                (unsigned long long)req->message.body.initial);\n            int res = strlen(tmpbuf);\n            it = item_alloc(key, nkey, 0, realtime(req->message.body.expiration),\n                            res + 2);\n\n            if (it != NULL) {\n                memcpy(ITEM_data(it), tmpbuf, res);\n                memcpy(ITEM_data(it) + res, \"\\r\\n\", 2);\n\n                if (store_item(it, NREAD_ADD, c)) {\n                    c->cas = ITEM_get_cas(it);\n                    write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));\n                } else {\n                    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED,\n                                    NULL, 0);\n                }\n                item_remove(it);         /* release our reference */\n            } else {\n                out_of_memory(c,\n                        \"SERVER_ERROR Out of memory allocating new item\");\n            }\n        } else {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n                c->thread->stats.incr_misses++;\n            } else {\n                c->thread->stats.decr_misses++;\n            }\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);\n        }\n        break;\n    case DELTA_ITEM_CAS_MISMATCH:\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);\n        break;\n    }\n}\n\nstatic void complete_update_bin(conn *c) {\n    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;\n    enum store_item_type ret = NOT_STORED;\n    assert(c != NULL);\n\n    item *it = c->item;\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    /* We don't actually receive the trailing two characters in the bin\n     * protocol, so we're going to just set them here */\n    if ((it->it_flags & ITEM_CHUNKED) == 0) {\n        *(ITEM_data(it) + it->nbytes - 2) = '\\r';\n        *(ITEM_data(it) + it->nbytes - 1) = '\\n';\n    } else {\n        assert(c->ritem);\n        item_chunk *ch = (item_chunk *) c->ritem;\n        if (ch->size == ch->used)\n            ch = ch->next;\n        assert(ch->size - ch->used >= 2);\n        ch->data[ch->used] = '\\r';\n        ch->data[ch->used + 1] = '\\n';\n        ch->used += 2;\n    }\n\n    ret = store_item(it, c->cmd, c);\n\n#ifdef ENABLE_DTRACE\n    uint64_t cas = ITEM_get_cas(it);\n    switch (c->cmd) {\n    case NREAD_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,\n                              (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,\n                                  (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,\n                                 (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,\n                                 (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,\n                              (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case STORED:\n        /* Stored */\n        write_bin_response(c, NULL, 0, 0, 0);\n        break;\n    case EXISTS:\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);\n        break;\n    case NOT_FOUND:\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);\n        break;\n    case NOT_STORED:\n    case TOO_LARGE:\n    case NO_MEMORY:\n        if (c->cmd == NREAD_ADD) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n        } else if(c->cmd == NREAD_REPLACE) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n        } else {\n            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n        }\n        write_bin_error(c, eno, NULL, 0);\n    }\n\n    item_remove(c->item);       /* release the c->item reference */\n    c->item = 0;\n}\n\nstatic void write_bin_miss_response(conn *c, char *key, size_t nkey) {\n    if (nkey) {\n        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,\n                0, nkey, nkey);\n        char *ofs = c->resp->wbuf + sizeof(protocol_binary_response_header);\n        memcpy(ofs, key, nkey);\n        resp_add_iov(c->resp, ofs, nkey);\n        conn_set_state(c, conn_new_cmd);\n    } else {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,\n                        NULL, 0);\n    }\n}\n\nstatic void process_bin_get_or_touch(conn *c, char *extbuf) {\n    item *it;\n\n    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->resp->wbuf;\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n    int should_touch = (c->cmd == PROTOCOL_BINARY_CMD_TOUCH ||\n                        c->cmd == PROTOCOL_BINARY_CMD_GAT ||\n                        c->cmd == PROTOCOL_BINARY_CMD_GATK);\n    int should_return_key = (c->cmd == PROTOCOL_BINARY_CMD_GETK ||\n                             c->cmd == PROTOCOL_BINARY_CMD_GATK);\n    int should_return_value = (c->cmd != PROTOCOL_BINARY_CMD_TOUCH);\n    bool failed = false;\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"<%d %s \", c->sfd, should_touch ? \"TOUCH\" : \"GET\");\n        if (fwrite(key, 1, nkey, stderr)) {}\n        fputc('\\n', stderr);\n    }\n\n    if (should_touch) {\n        protocol_binary_request_touch *t = (void *)extbuf;\n        time_t exptime = ntohl(t->message.body.expiration);\n\n        it = item_touch(key, nkey, realtime(exptime), c);\n    } else {\n        it = item_get(key, nkey, c, DO_UPDATE);\n    }\n\n    if (it) {\n        /* the length has two unnecessary bytes (\"\\r\\n\") */\n        uint16_t keylen = 0;\n        uint32_t bodylen = sizeof(rsp->message.body) + (it->nbytes - 2);\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        if (should_touch) {\n            c->thread->stats.touch_cmds++;\n            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;\n        } else {\n            c->thread->stats.get_cmds++;\n            c->thread->stats.lru_hits[it->slabs_clsid]++;\n        }\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        if (should_touch) {\n            MEMCACHED_COMMAND_TOUCH(c->sfd, ITEM_key(it), it->nkey,\n                                    it->nbytes, ITEM_get_cas(it));\n        } else {\n            MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                  it->nbytes, ITEM_get_cas(it));\n        }\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_TOUCH) {\n            bodylen -= it->nbytes - 2;\n        } else if (should_return_key) {\n            bodylen += nkey;\n            keylen = nkey;\n        }\n\n        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);\n        rsp->message.header.response.cas = htonll(ITEM_get_cas(it));\n\n        // add the flags\n        FLAGS_CONV(it, rsp->message.body.flags);\n        rsp->message.body.flags = htonl(rsp->message.body.flags);\n        resp_add_iov(c->resp, &rsp->message.body, sizeof(rsp->message.body));\n\n        if (should_return_key) {\n            resp_add_iov(c->resp, ITEM_key(it), nkey);\n        }\n\n        if (should_return_value) {\n            /* Add the data minus the CRLF */\n#ifdef EXTSTORE\n            if (it->it_flags & ITEM_HDR) {\n                if (_get_extstore(c, it, c->resp) != 0) {\n                    pthread_mutex_lock(&c->thread->stats.mutex);\n                    c->thread->stats.get_oom_extstore++;\n                    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n                    failed = true;\n                }\n            } else if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                resp_add_iov(c->resp, ITEM_data(it), it->nbytes - 2);\n            } else {\n                // Allow transmit handler to find the item and expand iov's\n                resp_add_chunked_iov(c->resp, it, it->nbytes - 2);\n            }\n#else\n            if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                resp_add_iov(c->resp, ITEM_data(it), it->nbytes - 2);\n            } else {\n                resp_add_chunked_iov(c->resp, it, it->nbytes - 2);\n            }\n#endif\n        }\n\n        if (!failed) {\n            conn_set_state(c, conn_new_cmd);\n            /* Remember this command so we can garbage collect it later */\n#ifdef EXTSTORE\n            if ((it->it_flags & ITEM_HDR) != 0 && should_return_value) {\n                // Only have extstore clean if header and returning value.\n                c->resp->item = NULL;\n            } else {\n                c->resp->item = it;\n            }\n#else\n            c->resp->item = it;\n#endif\n        } else {\n            item_remove(it);\n        }\n    } else {\n        failed = true;\n    }\n\n    if (failed) {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        if (should_touch) {\n            c->thread->stats.touch_cmds++;\n            c->thread->stats.touch_misses++;\n        } else {\n            c->thread->stats.get_cmds++;\n            c->thread->stats.get_misses++;\n        }\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        if (should_touch) {\n            MEMCACHED_COMMAND_TOUCH(c->sfd, key, nkey, -1, 0);\n        } else {\n            MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n        }\n\n        if (c->noreply) {\n            conn_set_state(c, conn_new_cmd);\n        } else {\n            if (should_return_key) {\n                write_bin_miss_response(c, key, nkey);\n            } else {\n                write_bin_miss_response(c, NULL, 0);\n            }\n        }\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_get(key, nkey, NULL != it);\n    }\n}\n\nstatic void append_bin_stats(const char *key, const uint16_t klen,\n                             const char *val, const uint32_t vlen,\n                             conn *c) {\n    char *buf = c->stats.buffer + c->stats.offset;\n    uint32_t bodylen = klen + vlen;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = PROTOCOL_BINARY_CMD_STAT,\n        .response.keylen = (uint16_t)htons(klen),\n        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,\n        .response.bodylen = htonl(bodylen),\n        .response.opaque = c->opaque\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (klen > 0) {\n        memcpy(buf, key, klen);\n        buf += klen;\n\n        if (vlen > 0) {\n            memcpy(buf, val, vlen);\n        }\n    }\n\n    c->stats.offset += sizeof(header.response) + bodylen;\n}\n\nstatic void append_ascii_stats(const char *key, const uint16_t klen,\n                               const char *val, const uint32_t vlen,\n                               conn *c) {\n    char *pos = c->stats.buffer + c->stats.offset;\n    uint32_t nbytes = 0;\n    int remaining = c->stats.size - c->stats.offset;\n    int room = remaining - 1;\n\n    if (klen == 0 && vlen == 0) {\n        nbytes = snprintf(pos, room, \"END\\r\\n\");\n    } else if (vlen == 0) {\n        nbytes = snprintf(pos, room, \"STAT %s\\r\\n\", key);\n    } else {\n        nbytes = snprintf(pos, room, \"STAT %s %s\\r\\n\", key, val);\n    }\n\n    c->stats.offset += nbytes;\n}\n\nstatic bool grow_stats_buf(conn *c, size_t needed) {\n    size_t nsize = c->stats.size;\n    size_t available = nsize - c->stats.offset;\n    bool rv = true;\n\n    /* Special case: No buffer -- need to allocate fresh */\n    if (c->stats.buffer == NULL) {\n        nsize = 1024;\n        available = c->stats.size = c->stats.offset = 0;\n    }\n\n    while (needed > available) {\n        assert(nsize > 0);\n        nsize = nsize << 1;\n        available = nsize - c->stats.offset;\n    }\n\n    if (nsize != c->stats.size) {\n        char *ptr = realloc(c->stats.buffer, nsize);\n        if (ptr) {\n            c->stats.buffer = ptr;\n            c->stats.size = nsize;\n        } else {\n            STATS_LOCK();\n            stats.malloc_fails++;\n            STATS_UNLOCK();\n            rv = false;\n        }\n    }\n\n    return rv;\n}\n\nstatic void append_stats(const char *key, const uint16_t klen,\n                  const char *val, const uint32_t vlen,\n                  const void *cookie)\n{\n    /* value without a key is invalid */\n    if (klen == 0 && vlen > 0) {\n        return;\n    }\n\n    conn *c = (conn*)cookie;\n\n    if (c->protocol == binary_prot) {\n        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);\n        if (!grow_stats_buf(c, needed)) {\n            return;\n        }\n        append_bin_stats(key, klen, val, vlen, c);\n    } else {\n        size_t needed = vlen + klen + 10; // 10 == \"STAT = \\r\\n\"\n        if (!grow_stats_buf(c, needed)) {\n            return;\n        }\n        append_ascii_stats(key, klen, val, vlen, c);\n    }\n\n    assert(c->stats.offset <= c->stats.size);\n}\n\nstatic void process_bin_stat(conn *c) {\n    char *subcommand = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        int ii;\n        fprintf(stderr, \"<%d STATS \", c->sfd);\n        for (ii = 0; ii < nkey; ++ii) {\n            fprintf(stderr, \"%c\", subcommand[ii]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n\n    if (nkey == 0) {\n        /* request all statistics */\n        server_stats(&append_stats, c);\n        (void)get_stats(NULL, 0, &append_stats, c);\n    } else if (strncmp(subcommand, \"reset\", 5) == 0) {\n        stats_reset();\n    } else if (strncmp(subcommand, \"settings\", 8) == 0) {\n        process_stat_settings(&append_stats, c);\n    } else if (strncmp(subcommand, \"detail\", 6) == 0) {\n        char *subcmd_pos = subcommand + 6;\n        if (strncmp(subcmd_pos, \" dump\", 5) == 0) {\n            int len;\n            char *dump_buf = stats_prefix_dump(&len);\n            if (dump_buf == NULL || len <= 0) {\n                out_of_memory(c, \"SERVER_ERROR Out of memory generating stats\");\n                if (dump_buf != NULL)\n                    free(dump_buf);\n                return;\n            } else {\n                append_stats(\"detailed\", strlen(\"detailed\"), dump_buf, len, c);\n                free(dump_buf);\n            }\n        } else if (strncmp(subcmd_pos, \" on\", 3) == 0) {\n            settings.detail_enabled = 1;\n        } else if (strncmp(subcmd_pos, \" off\", 4) == 0) {\n            settings.detail_enabled = 0;\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);\n            return;\n        }\n    } else {\n        if (get_stats(subcommand, nkey, &append_stats, c)) {\n            if (c->stats.buffer == NULL) {\n                out_of_memory(c, \"SERVER_ERROR Out of memory generating stats\");\n            } else {\n                write_and_free(c, c->stats.buffer, c->stats.offset);\n                c->stats.buffer = NULL;\n            }\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);\n        }\n\n        return;\n    }\n\n    /* Append termination package and start the transfer */\n    append_stats(NULL, 0, NULL, 0, c);\n    if (c->stats.buffer == NULL) {\n        out_of_memory(c, \"SERVER_ERROR Out of memory preparing to send stats\");\n    } else {\n        write_and_free(c, c->stats.buffer, c->stats.offset);\n        c->stats.buffer = NULL;\n    }\n}\n\n/* Just write an error message and disconnect the client */\nstatic void handle_binary_protocol_error(conn *c) {\n    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, 0);\n    if (settings.verbose) {\n        fprintf(stderr, \"Protocol error (opcode %02x), close connection %d\\n\",\n                c->binary_header.request.opcode, c->sfd);\n    }\n    c->close_after_write = true;\n}\n\nstatic void init_sasl_conn(conn *c) {\n    assert(c);\n    /* should something else be returned? */\n    if (!settings.sasl)\n        return;\n\n    c->authenticated = false;\n\n    if (!c->sasl_conn) {\n        int result=sasl_server_new(\"memcached\",\n                                   NULL,\n                                   my_sasl_hostname[0] ? my_sasl_hostname : NULL,\n                                   NULL, NULL,\n                                   NULL, 0, &c->sasl_conn);\n        if (result != SASL_OK) {\n            if (settings.verbose) {\n                fprintf(stderr, \"Failed to initialize SASL conn.\\n\");\n            }\n            c->sasl_conn = NULL;\n        }\n    }\n}\n\nstatic void bin_list_sasl_mechs(conn *c) {\n    // Guard against a disabled SASL.\n    if (!settings.sasl) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,\n                        c->binary_header.request.bodylen\n                        - c->binary_header.request.keylen);\n        return;\n    }\n\n    init_sasl_conn(c);\n    const char *result_string = NULL;\n    unsigned int string_length = 0;\n    int result=sasl_listmech(c->sasl_conn, NULL,\n                             \"\",   /* What to prepend the string with */\n                             \" \",  /* What to separate mechanisms with */\n                             \"\",   /* What to append to the string */\n                             &result_string, &string_length,\n                             NULL);\n    if (result != SASL_OK) {\n        /* Perhaps there's a better error for this... */\n        if (settings.verbose) {\n            fprintf(stderr, \"Failed to list SASL mechanisms.\\n\");\n        }\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);\n        return;\n    }\n    write_bin_response(c, (char*)result_string, 0, 0, string_length);\n}\n\nstatic void process_bin_sasl_auth(conn *c) {\n    // Guard for handling disabled SASL on the server.\n    if (!settings.sasl) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,\n                        c->binary_header.request.bodylen\n                        - c->binary_header.request.keylen);\n        return;\n    }\n\n    assert(c->binary_header.request.extlen == 0);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    if (nkey > MAX_SASL_MECH_LEN) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);\n        conn_set_state(c, conn_swallow);\n        return;\n    }\n\n    char *key = binary_get_key(c);\n    assert(key);\n\n    item *it = item_alloc(key, nkey, 0, 0, vlen+2);\n\n    /* Can't use a chunked item for SASL authentication. */\n    if (it == 0 || (it->it_flags & ITEM_CHUNKED)) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, NULL, vlen);\n        conn_set_state(c, conn_swallow);\n        if (it) {\n            do_item_remove(it);\n        }\n        return;\n    }\n\n    c->item = it;\n    c->ritem = ITEM_data(it);\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_reading_sasl_auth_data;\n}\n\nstatic void process_bin_complete_sasl_auth(conn *c) {\n    assert(settings.sasl);\n    const char *out = NULL;\n    unsigned int outlen = 0;\n\n    assert(c->item);\n    init_sasl_conn(c);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    if (nkey > ((item*) c->item)->nkey) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);\n        conn_set_state(c, conn_swallow);\n        return;\n    }\n\n    char mech[nkey+1];\n    memcpy(mech, ITEM_key((item*)c->item), nkey);\n    mech[nkey] = 0x00;\n\n    if (settings.verbose)\n        fprintf(stderr, \"mech:  ``%s'' with %d bytes of data\\n\", mech, vlen);\n\n    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);\n\n    if (vlen > ((item*) c->item)->nbytes) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);\n        conn_set_state(c, conn_swallow);\n        return;\n    }\n\n    int result=-1;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        result = sasl_server_start(c->sasl_conn, mech,\n                                   challenge, vlen,\n                                   &out, &outlen);\n        c->sasl_started = (result == SASL_OK || result == SASL_CONTINUE);\n        break;\n    case PROTOCOL_BINARY_CMD_SASL_STEP:\n        if (!c->sasl_started) {\n            if (settings.verbose) {\n                fprintf(stderr, \"%d: SASL_STEP called but sasl_server_start \"\n                        \"not called for this connection!\\n\", c->sfd);\n            }\n            break;\n        }\n        result = sasl_server_step(c->sasl_conn,\n                                  challenge, vlen,\n                                  &out, &outlen);\n        break;\n    default:\n        assert(false); /* CMD should be one of the above */\n        /* This code is pretty much impossible, but makes the compiler\n           happier */\n        if (settings.verbose) {\n            fprintf(stderr, \"Unhandled command %d with challenge %s\\n\",\n                    c->cmd, challenge);\n        }\n        break;\n    }\n\n    if (settings.verbose) {\n        fprintf(stderr, \"sasl result code:  %d\\n\", result);\n    }\n\n    switch(result) {\n    case SASL_OK:\n        c->authenticated = true;\n        write_bin_response(c, \"Authenticated\", 0, 0, strlen(\"Authenticated\"));\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.auth_cmds++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n        break;\n    case SASL_CONTINUE:\n        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);\n        if (outlen > 0) {\n            resp_add_iov(c->resp, out, outlen);\n        }\n        // Immediately flush our write.\n        conn_set_state(c, conn_mwrite);\n        break;\n    default:\n        if (settings.verbose)\n            fprintf(stderr, \"Unknown sasl response:  %d\\n\", result);\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.auth_cmds++;\n        c->thread->stats.auth_errors++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n    }\n}\n\nstatic bool authenticated(conn *c) {\n    assert(settings.sasl);\n    bool rv = false;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */\n        rv = true;\n        break;\n    default:\n        rv = c->authenticated;\n    }\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"authenticated() in cmd 0x%02x is %s\\n\",\n                c->cmd, rv ? \"true\" : \"false\");\n    }\n\n    return rv;\n}\n\nstatic void dispatch_bin_command(conn *c, char *extbuf) {\n    int protocol_error = 0;\n\n    uint8_t extlen = c->binary_header.request.extlen;\n    uint16_t keylen = c->binary_header.request.keylen;\n    uint32_t bodylen = c->binary_header.request.bodylen;\n\n    if (keylen > bodylen || keylen + extlen > bodylen) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL, 0);\n        c->close_after_write = true;\n        return;\n    }\n\n    if (settings.sasl && !authenticated(c)) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);\n        c->close_after_write = true;\n        return;\n    }\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n    c->noreply = true;\n\n    /* binprot supports 16bit keys, but internals are still 8bit */\n    if (keylen > KEY_MAX_LENGTH) {\n        handle_binary_protocol_error(c);\n        return;\n    }\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_SET;\n        break;\n    case PROTOCOL_BINARY_CMD_ADDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_ADD;\n        break;\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;\n        break;\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DELETE;\n        break;\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_QUITQ:\n        c->cmd = PROTOCOL_BINARY_CMD_QUIT;\n        break;\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;\n        break;\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_APPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_GETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GET;\n        break;\n    case PROTOCOL_BINARY_CMD_GETKQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GETK;\n        break;\n    case PROTOCOL_BINARY_CMD_GATQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GAT;\n        break;\n    case PROTOCOL_BINARY_CMD_GATKQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GATK;\n        break;\n    default:\n        c->noreply = false;\n    }\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_VERSION:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_FLUSH:\n            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {\n                process_bin_flush(c, extbuf);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_NOOP:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n                // NOOP forces pipeline flush.\n                conn_set_state(c, conn_mwrite);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {\n                process_bin_update(c, extbuf);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETK:\n            if (extlen == 0 && bodylen == keylen && keylen > 0) {\n                process_bin_get_or_touch(c, extbuf);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_DELETE:\n            if (keylen > 0 && extlen == 0 && bodylen == keylen) {\n                process_bin_delete(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_INCREMENT:\n        case PROTOCOL_BINARY_CMD_DECREMENT:\n            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {\n                complete_incr_bin(c, extbuf);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_APPEND:\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            if (keylen > 0 && extlen == 0) {\n                process_bin_append_prepend(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_STAT:\n            if (extlen == 0) {\n                process_bin_stat(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_QUIT:\n            if (keylen == 0 && extlen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n                conn_set_state(c, conn_mwrite);\n                c->close_after_write = true;\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                bin_list_sasl_mechs(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        case PROTOCOL_BINARY_CMD_SASL_STEP:\n            if (extlen == 0 && keylen != 0) {\n                process_bin_sasl_auth(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_TOUCH:\n        case PROTOCOL_BINARY_CMD_GAT:\n        case PROTOCOL_BINARY_CMD_GATQ:\n        case PROTOCOL_BINARY_CMD_GATK:\n        case PROTOCOL_BINARY_CMD_GATKQ:\n            if (extlen == 4 && keylen != 0) {\n                process_bin_get_or_touch(c, extbuf);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        default:\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,\n                            bodylen);\n    }\n\n    if (protocol_error)\n        handle_binary_protocol_error(c);\n}\n\nstatic void process_bin_update(conn *c, char *extbuf) {\n    char *key;\n    int nkey;\n    int vlen;\n    item *it;\n    protocol_binary_request_set* req = (void *)extbuf;\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n\n    /* fix byteorder in the request */\n    req->message.body.flags = ntohl(req->message.body.flags);\n    req->message.body.expiration = ntohl(req->message.body.expiration);\n\n    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);\n\n    if (settings.verbose > 1) {\n        int ii;\n        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {\n            fprintf(stderr, \"<%d ADD \", c->sfd);\n        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            fprintf(stderr, \"<%d SET \", c->sfd);\n        } else {\n            fprintf(stderr, \"<%d REPLACE \", c->sfd);\n        }\n        for (ii = 0; ii < nkey; ++ii) {\n            fprintf(stderr, \"%c\", key[ii]);\n        }\n\n        fprintf(stderr, \" Value len is %d\", vlen);\n        fprintf(stderr, \"\\n\");\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    it = item_alloc(key, nkey, req->message.body.flags,\n            realtime(req->message.body.expiration), vlen+2);\n\n    if (it == 0) {\n        enum store_item_type status;\n        if (! item_size_ok(nkey, req->message.body.flags, vlen + 2)) {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);\n            status = TOO_LARGE;\n        } else {\n            out_of_memory(c, \"SERVER_ERROR Out of memory allocating item\");\n            /* This error generating method eats the swallow value. Add here. */\n            c->sbytes = vlen;\n            status = NO_MEMORY;\n        }\n        /* FIXME: losing c->cmd since it's translated below. refactor? */\n        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,\n                NULL, status, 0, key, nkey, req->message.body.expiration,\n                ITEM_clsid(it), c->sfd);\n\n        /* Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET. Anywhere else too? */\n        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            it = item_get(key, nkey, c, DONT_UPDATE);\n            if (it) {\n                item_unlink(it);\n                STORAGE_delete(c->thread->storage, it);\n                item_remove(it);\n            }\n        }\n\n        /* swallow the data line */\n        conn_set_state(c, conn_swallow);\n        return;\n    }\n\n    ITEM_set_cas(it, c->binary_header.request.cas);\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_ADD:\n            c->cmd = NREAD_ADD;\n            break;\n        case PROTOCOL_BINARY_CMD_SET:\n            c->cmd = NREAD_SET;\n            break;\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            c->cmd = NREAD_REPLACE;\n            break;\n        default:\n            assert(0);\n    }\n\n    if (ITEM_get_cas(it) != 0) {\n        c->cmd = NREAD_CAS;\n    }\n\n    c->item = it;\n#ifdef NEED_ALIGN\n    if (it->it_flags & ITEM_CHUNKED) {\n        c->ritem = ITEM_schunk(it);\n    } else {\n        c->ritem = ITEM_data(it);\n    }\n#else\n    c->ritem = ITEM_data(it);\n#endif\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_read_set_value;\n}\n\nstatic void process_bin_append_prepend(conn *c) {\n    char *key;\n    int nkey;\n    int vlen;\n    item *it;\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n    vlen = c->binary_header.request.bodylen - nkey;\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"Value len is %d\\n\", vlen);\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    it = item_alloc(key, nkey, 0, 0, vlen+2);\n\n    if (it == 0) {\n        if (! item_size_ok(nkey, 0, vlen + 2)) {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);\n        } else {\n            out_of_memory(c, \"SERVER_ERROR Out of memory allocating item\");\n            /* OOM calls eat the swallow value. Add here. */\n            c->sbytes = vlen;\n        }\n        /* swallow the data line */\n        conn_set_state(c, conn_swallow);\n        return;\n    }\n\n    ITEM_set_cas(it, c->binary_header.request.cas);\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_APPEND:\n            c->cmd = NREAD_APPEND;\n            break;\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            c->cmd = NREAD_PREPEND;\n            break;\n        default:\n            assert(0);\n    }\n\n    c->item = it;\n#ifdef NEED_ALIGN\n    if (it->it_flags & ITEM_CHUNKED) {\n        c->ritem = ITEM_schunk(it);\n    } else {\n        c->ritem = ITEM_data(it);\n    }\n#else\n    c->ritem = ITEM_data(it);\n#endif\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_read_set_value;\n}\n\nstatic void process_bin_flush(conn *c, char *extbuf) {\n    time_t exptime = 0;\n    protocol_binary_request_flush* req = (void *)extbuf;\n    rel_time_t new_oldest = 0;\n\n    if (!settings.flush_enabled) {\n      // flush_all is not allowed but we log it on stats\n      write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);\n      return;\n    }\n\n    if (c->binary_header.request.extlen == sizeof(req->message.body)) {\n        exptime = ntohl(req->message.body.expiration);\n    }\n\n    if (exptime > 0) {\n        new_oldest = realtime(exptime);\n    } else {\n        new_oldest = current_time;\n    }\n    if (settings.use_cas) {\n        settings.oldest_live = new_oldest - 1;\n        if (settings.oldest_live <= current_time)\n            settings.oldest_cas = get_cas_id();\n    } else {\n        settings.oldest_live = new_oldest;\n    }\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.flush_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    write_bin_response(c, NULL, 0, 0, 0);\n}\n\nstatic void process_bin_delete(conn *c) {\n    item *it;\n    uint32_t hv;\n\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    assert(c != NULL);\n\n    if (settings.verbose > 1) {\n        int ii;\n        fprintf(stderr, \"Deleting \");\n        for (ii = 0; ii < nkey; ++ii) {\n            fprintf(stderr, \"%c\", key[ii]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_delete(key, nkey);\n    }\n\n    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);\n    if (it) {\n        uint64_t cas = c->binary_header.request.cas;\n        if (cas == 0 || cas == ITEM_get_cas(it)) {\n            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n            do_item_unlink(it, hv);\n            STORAGE_delete(c->thread->storage, it);\n            write_bin_response(c, NULL, 0, 0, 0);\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);\n        }\n        do_item_remove(it);      /* release our reference */\n    } else {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.delete_misses++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n    }\n    item_unlock(hv);\n}\n\nstatic void complete_nread_binary(conn *c) {\n    assert(c != NULL);\n    assert(c->cmd >= 0);\n\n    switch(c->substate) {\n    case bin_read_set_value:\n        complete_update_bin(c);\n        break;\n    case bin_reading_sasl_auth_data:\n        process_bin_complete_sasl_auth(c);\n        if (c->item) {\n            do_item_remove(c->item);\n            c->item = NULL;\n        }\n        break;\n    default:\n        fprintf(stderr, \"Not handling substate %d\\n\", c->substate);\n        assert(0);\n    }\n}\n\nstatic void reset_cmd_handler(conn *c) {\n    c->cmd = -1;\n    c->substate = bin_no_state;\n    if (c->item != NULL) {\n        // TODO: Any other way to get here?\n        // SASL auth was mistakenly using it. Nothing else should?\n        item_remove(c->item);\n        c->item = NULL;\n    }\n    if (c->rbytes > 0) {\n        conn_set_state(c, conn_parse_cmd);\n    } else if (c->resp_head) {\n        conn_set_state(c, conn_mwrite);\n    } else {\n        conn_set_state(c, conn_waiting);\n    }\n}\n\nstatic void complete_nread(conn *c) {\n    assert(c != NULL);\n    assert(c->protocol == ascii_prot\n           || c->protocol == binary_prot);\n\n    if (c->protocol == ascii_prot) {\n        complete_nread_ascii(c);\n    } else if (c->protocol == binary_prot) {\n        complete_nread_binary(c);\n    }\n}\n\n/* Destination must always be chunked */\n/* This should be part of item.c */\nstatic int _store_item_copy_chunks(item *d_it, item *s_it, const int len) {\n    item_chunk *dch = (item_chunk *) ITEM_schunk(d_it);\n    /* Advance dch until we find free space */\n    while (dch->size == dch->used) {\n        if (dch->next) {\n            dch = dch->next;\n        } else {\n            break;\n        }\n    }\n\n    if (s_it->it_flags & ITEM_CHUNKED) {\n        int remain = len;\n        item_chunk *sch = (item_chunk *) ITEM_schunk(s_it);\n        int copied = 0;\n        /* Fills dch's to capacity, not straight copy sch in case data is\n         * being added or removed (ie append/prepend)\n         */\n        while (sch && dch && remain) {\n            assert(dch->used <= dch->size);\n            int todo = (dch->size - dch->used < sch->used - copied)\n                ? dch->size - dch->used : sch->used - copied;\n            if (remain < todo)\n                todo = remain;\n            memcpy(dch->data + dch->used, sch->data + copied, todo);\n            dch->used += todo;\n            copied += todo;\n            remain -= todo;\n            assert(dch->used <= dch->size);\n            if (dch->size == dch->used) {\n                item_chunk *tch = do_item_alloc_chunk(dch, remain);\n                if (tch) {\n                    dch = tch;\n                } else {\n                    return -1;\n                }\n            }\n            assert(copied <= sch->used);\n            if (copied == sch->used) {\n                copied = 0;\n                sch = sch->next;\n            }\n        }\n        /* assert that the destination had enough space for the source */\n        assert(remain == 0);\n    } else {\n        int done = 0;\n        /* Fill dch's via a non-chunked item. */\n        while (len > done && dch) {\n            int todo = (dch->size - dch->used < len - done)\n                ? dch->size - dch->used : len - done;\n            //assert(dch->size - dch->used != 0);\n            memcpy(dch->data + dch->used, ITEM_data(s_it) + done, todo);\n            done += todo;\n            dch->used += todo;\n            assert(dch->used <= dch->size);\n            if (dch->size == dch->used) {\n                item_chunk *tch = do_item_alloc_chunk(dch, len - done);\n                if (tch) {\n                    dch = tch;\n                } else {\n                    return -1;\n                }\n            }\n        }\n        assert(len == done);\n    }\n    return 0;\n}\n\nstatic int _store_item_copy_data(int comm, item *old_it, item *new_it, item *add_it) {\n    if (comm == NREAD_APPEND) {\n        if (new_it->it_flags & ITEM_CHUNKED) {\n            if (_store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2) == -1 ||\n                _store_item_copy_chunks(new_it, add_it, add_it->nbytes) == -1) {\n                return -1;\n            }\n        } else {\n            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);\n            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);\n        }\n    } else {\n        /* NREAD_PREPEND */\n        if (new_it->it_flags & ITEM_CHUNKED) {\n            if (_store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2) == -1 ||\n                _store_item_copy_chunks(new_it, old_it, old_it->nbytes) == -1) {\n                return -1;\n            }\n        } else {\n            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);\n            memcpy(ITEM_data(new_it) + add_it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);\n        }\n    }\n    return 0;\n}\n\n/*\n * Stores an item in the cache according to the semantics of one of the set\n * commands. Protected by the item lock.\n *\n * Returns the state of storage.\n */\nenum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {\n    char *key = ITEM_key(it);\n    item *old_it = do_item_get(key, it->nkey, hv, c, DONT_UPDATE);\n    enum store_item_type stored = NOT_STORED;\n\n    enum cas_result { CAS_NONE, CAS_MATCH, CAS_BADVAL, CAS_STALE, CAS_MISS };\n\n    item *new_it = NULL;\n    uint32_t flags;\n\n    /* Do the CAS test up front so we can apply to all store modes */\n    enum cas_result cas_res = CAS_NONE;\n\n    bool do_store = false;\n    if (old_it != NULL) {\n        // Most of the CAS work requires something to compare to.\n        uint64_t it_cas = ITEM_get_cas(it);\n        uint64_t old_cas = ITEM_get_cas(old_it);\n        if (it_cas == 0) {\n            cas_res = CAS_NONE;\n        } else if (it_cas == old_cas) {\n            cas_res = CAS_MATCH;\n        } else if (c->set_stale && it_cas < old_cas) {\n            cas_res = CAS_STALE;\n        } else {\n            cas_res = CAS_BADVAL;\n        }\n\n        switch (comm) {\n            case NREAD_ADD:\n                /* add only adds a nonexistent item, but promote to head of LRU */\n                do_item_update(old_it);\n                break;\n            case NREAD_CAS:\n                if (cas_res == CAS_MATCH) {\n                    // cas validates\n                    // it and old_it may belong to different classes.\n                    // I'm updating the stats for the one that's getting pushed out\n                    pthread_mutex_lock(&c->thread->stats.mutex);\n                    c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;\n                    pthread_mutex_unlock(&c->thread->stats.mutex);\n                    do_store = true;\n                } else if (cas_res == CAS_STALE) {\n                    // if we're allowed to set a stale value, CAS must be lower than\n                    // the current item's CAS.\n                    // This replaces the value, but should preserve TTL, and stale\n                    // item marker bit + token sent if exists.\n                    it->exptime = old_it->exptime;\n                    it->it_flags |= ITEM_STALE;\n                    if (old_it->it_flags & ITEM_TOKEN_SENT) {\n                        it->it_flags |= ITEM_TOKEN_SENT;\n                    }\n\n                    pthread_mutex_lock(&c->thread->stats.mutex);\n                    c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;\n                    pthread_mutex_unlock(&c->thread->stats.mutex);\n                    do_store = true;\n                } else {\n                    // NONE or BADVAL are the same for CAS cmd\n                    pthread_mutex_lock(&c->thread->stats.mutex);\n                    c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_badval++;\n                    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n                    if (settings.verbose > 1) {\n                        fprintf(stderr, \"CAS:  failure: expected %llu, got %llu\\n\",\n                                (unsigned long long)ITEM_get_cas(old_it),\n                                (unsigned long long)ITEM_get_cas(it));\n                    }\n                    stored = EXISTS;\n                }\n                break;\n            case NREAD_APPEND:\n            case NREAD_PREPEND:\n                if (cas_res != CAS_NONE && cas_res != CAS_MATCH) {\n                    stored = EXISTS;\n                    break;\n                }\n#ifdef EXTSTORE\n                if ((old_it->it_flags & ITEM_HDR) != 0) {\n                    /* block append/prepend from working with extstore-d items.\n                     * leave response code to NOT_STORED default */\n                    break;\n                }\n#endif\n                /* we have it and old_it here - alloc memory to hold both */\n                FLAGS_CONV(old_it, flags);\n                new_it = do_item_alloc(key, it->nkey, flags, old_it->exptime, it->nbytes + old_it->nbytes - 2 /* CRLF */);\n\n                // OOM trying to copy.\n                if (new_it == NULL)\n                    break;\n                /* copy data from it and old_it to new_it */\n                if (_store_item_copy_data(comm, old_it, new_it, it) == -1) {\n                    // failed data copy\n                    break;\n                } else {\n                    // refcount of new_it is 1 here. will end up 2 after link.\n                    // it's original ref is managed outside of this function\n                    it = new_it;\n                    do_store = true;\n                }\n                break;\n            case NREAD_REPLACE:\n            case NREAD_SET:\n                do_store = true;\n                break;\n        }\n\n        if (do_store) {\n            STORAGE_delete(c->thread->storage, old_it);\n            item_replace(old_it, it, hv);\n            stored = STORED;\n        }\n\n        do_item_remove(old_it);         /* release our reference */\n        if (new_it != NULL) {\n            // append/prepend end up with an extra reference for new_it.\n            do_item_remove(new_it);\n        }\n    } else {\n        /* No pre-existing item to replace or compare to. */\n        if (ITEM_get_cas(it) != 0) {\n            /* Asked for a CAS match but nothing to compare it to. */\n            cas_res = CAS_MISS;\n        }\n\n        switch (comm) {\n            case NREAD_ADD:\n            case NREAD_SET:\n                do_store = true;\n                break;\n            case NREAD_CAS:\n                // LRU expired\n                stored = NOT_FOUND;\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.cas_misses++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                break;\n            case NREAD_REPLACE:\n            case NREAD_APPEND:\n            case NREAD_PREPEND:\n                /* Requires an existing item. */\n                break;\n        }\n\n        if (do_store) {\n            do_item_link(it, hv);\n            stored = STORED;\n        }\n    }\n\n    if (stored == STORED) {\n        c->cas = ITEM_get_cas(it);\n    }\n    LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE, NULL,\n            stored, comm, ITEM_key(it), it->nkey, it->exptime, ITEM_clsid(it), c->sfd);\n\n    return stored;\n}\n\ntypedef struct token_s {\n    char *value;\n    size_t length;\n} token_t;\n\n#define COMMAND_TOKEN 0\n#define SUBCOMMAND_TOKEN 1\n#define KEY_TOKEN 1\n\n#define MAX_TOKENS 24\n\n/*\n * Tokenize the command string by replacing whitespace with '\\0' and update\n * the token array tokens with pointer to start of each token and length.\n * Returns total number of tokens.  The last valid token is the terminal\n * token (value points to the first unprocessed character of the string and\n * length zero).\n *\n * Usage example:\n *\n *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {\n *      for(int ix = 0; tokens[ix].length != 0; ix++) {\n *          ...\n *      }\n *      ncommand = tokens[ix].value - command;\n *      command  = tokens[ix].value;\n *   }\n */\nstatic size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {\n    char *s, *e;\n    size_t ntokens = 0;\n    size_t len = strlen(command);\n    unsigned int i = 0;\n\n    assert(command != NULL && tokens != NULL && max_tokens > 1);\n\n    s = e = command;\n    for (i = 0; i < len; i++) {\n        if (*e == ' ') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n                *e = '\\0';\n                if (ntokens == max_tokens - 1) {\n                    e++;\n                    s = e; /* so we don't add an extra token */\n                    break;\n                }\n            }\n            s = e + 1;\n        }\n        e++;\n    }\n\n    if (s != e) {\n        tokens[ntokens].value = s;\n        tokens[ntokens].length = e - s;\n        ntokens++;\n    }\n\n    /*\n     * If we scanned the whole string, the terminal value pointer is null,\n     * otherwise it is the first unprocessed character.\n     */\n    tokens[ntokens].value =  *e == '\\0' ? NULL : e;\n    tokens[ntokens].length = 0;\n    ntokens++;\n\n    return ntokens;\n}\n\n/* set up a connection to write a buffer then free it, used for stats */\nstatic void write_and_free(conn *c, char *buf, int bytes) {\n    if (buf) {\n        mc_resp *resp = c->resp;\n        resp->write_and_free = buf;\n        resp_add_iov(resp, buf, bytes);\n        conn_set_state(c, conn_new_cmd);\n    } else {\n        out_of_memory(c, \"SERVER_ERROR out of memory writing stats\");\n    }\n}\n\nstatic inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)\n{\n    int noreply_index = ntokens - 2;\n\n    /*\n      NOTE: this function is not the first place where we are going to\n      send the reply.  We could send it instead from process_command()\n      if the request line has wrong number of tokens.  However parsing\n      malformed line for \"noreply\" option is not reliable anyway, so\n      it can't be helped.\n    */\n    if (tokens[noreply_index].value\n        && strcmp(tokens[noreply_index].value, \"noreply\") == 0) {\n        c->noreply = true;\n    }\n    return c->noreply;\n}\n\nvoid append_stat(const char *name, ADD_STAT add_stats, conn *c,\n                 const char *fmt, ...) {\n    char val_str[STAT_VAL_LEN];\n    int vlen;\n    va_list ap;\n\n    assert(name);\n    assert(add_stats);\n    assert(c);\n    assert(fmt);\n\n    va_start(ap, fmt);\n    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);\n    va_end(ap);\n\n    add_stats(name, strlen(name), val_str, vlen, c);\n}\n\ninline static void process_stats_detail(conn *c, const char *command) {\n    assert(c != NULL);\n\n    if (strcmp(command, \"on\") == 0) {\n        settings.detail_enabled = 1;\n        out_string(c, \"OK\");\n    }\n    else if (strcmp(command, \"off\") == 0) {\n        settings.detail_enabled = 0;\n        out_string(c, \"OK\");\n    }\n    else if (strcmp(command, \"dump\") == 0) {\n        int len;\n        char *stats = stats_prefix_dump(&len);\n        write_and_free(c, stats, len);\n    }\n    else {\n        out_string(c, \"CLIENT_ERROR usage: stats detail on|off|dump\");\n    }\n}\n\n/* return server specific stats only */\nstatic void server_stats(ADD_STAT add_stats, conn *c) {\n    pid_t pid = getpid();\n    rel_time_t now = current_time;\n\n    struct thread_stats thread_stats;\n    threadlocal_stats_aggregate(&thread_stats);\n    struct slab_stats slab_stats;\n    slab_stats_aggregate(&thread_stats, &slab_stats);\n#ifdef EXTSTORE\n    struct extstore_stats st;\n#endif\n#ifndef WIN32\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n#endif /* !WIN32 */\n\n    STATS_LOCK();\n\n    APPEND_STAT(\"pid\", \"%lu\", (long)pid);\n    APPEND_STAT(\"uptime\", \"%u\", now - ITEM_UPDATE_INTERVAL);\n    APPEND_STAT(\"time\", \"%ld\", now + (long)process_started);\n    APPEND_STAT(\"version\", \"%s\", VERSION);\n    APPEND_STAT(\"libevent\", \"%s\", event_get_version());\n    APPEND_STAT(\"pointer_size\", \"%d\", (int)(8 * sizeof(void *)));\n\n#ifndef WIN32\n    append_stat(\"rusage_user\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_utime.tv_sec,\n                (long)usage.ru_utime.tv_usec);\n    append_stat(\"rusage_system\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_stime.tv_sec,\n                (long)usage.ru_stime.tv_usec);\n#endif /* !WIN32 */\n\n    APPEND_STAT(\"max_connections\", \"%d\", settings.maxconns);\n    APPEND_STAT(\"curr_connections\", \"%llu\", (unsigned long long)stats_state.curr_conns - 1);\n    APPEND_STAT(\"total_connections\", \"%llu\", (unsigned long long)stats.total_conns);\n    if (settings.maxconns_fast) {\n        APPEND_STAT(\"rejected_connections\", \"%llu\", (unsigned long long)stats.rejected_conns);\n    }\n    APPEND_STAT(\"connection_structures\", \"%u\", stats_state.conn_structs);\n    APPEND_STAT(\"response_obj_bytes\", \"%llu\", (unsigned long long)thread_stats.response_obj_bytes);\n    APPEND_STAT(\"response_obj_total\", \"%llu\", (unsigned long long)thread_stats.response_obj_total);\n    APPEND_STAT(\"response_obj_free\", \"%llu\", (unsigned long long)thread_stats.response_obj_free);\n    APPEND_STAT(\"response_obj_oom\", \"%llu\", (unsigned long long)thread_stats.response_obj_oom);\n    APPEND_STAT(\"read_buf_bytes\", \"%llu\", (unsigned long long)thread_stats.read_buf_bytes);\n    APPEND_STAT(\"read_buf_bytes_free\", \"%llu\", (unsigned long long)thread_stats.read_buf_bytes_free);\n    APPEND_STAT(\"read_buf_oom\", \"%llu\", (unsigned long long)thread_stats.read_buf_oom);\n    APPEND_STAT(\"reserved_fds\", \"%u\", stats_state.reserved_fds);\n    APPEND_STAT(\"cmd_get\", \"%llu\", (unsigned long long)thread_stats.get_cmds);\n    APPEND_STAT(\"cmd_set\", \"%llu\", (unsigned long long)slab_stats.set_cmds);\n    APPEND_STAT(\"cmd_flush\", \"%llu\", (unsigned long long)thread_stats.flush_cmds);\n    APPEND_STAT(\"cmd_touch\", \"%llu\", (unsigned long long)thread_stats.touch_cmds);\n    APPEND_STAT(\"cmd_meta\", \"%llu\", (unsigned long long)thread_stats.meta_cmds);\n    APPEND_STAT(\"get_hits\", \"%llu\", (unsigned long long)slab_stats.get_hits);\n    APPEND_STAT(\"get_misses\", \"%llu\", (unsigned long long)thread_stats.get_misses);\n    APPEND_STAT(\"get_expired\", \"%llu\", (unsigned long long)thread_stats.get_expired);\n    APPEND_STAT(\"get_flushed\", \"%llu\", (unsigned long long)thread_stats.get_flushed);\n#ifdef EXTSTORE\n    if (c->thread->storage) {\n        APPEND_STAT(\"get_extstore\", \"%llu\", (unsigned long long)thread_stats.get_extstore);\n        APPEND_STAT(\"get_aborted_extstore\", \"%llu\", (unsigned long long)thread_stats.get_aborted_extstore);\n        APPEND_STAT(\"get_oom_extstore\", \"%llu\", (unsigned long long)thread_stats.get_oom_extstore);\n        APPEND_STAT(\"recache_from_extstore\", \"%llu\", (unsigned long long)thread_stats.recache_from_extstore);\n        APPEND_STAT(\"miss_from_extstore\", \"%llu\", (unsigned long long)thread_stats.miss_from_extstore);\n        APPEND_STAT(\"badcrc_from_extstore\", \"%llu\", (unsigned long long)thread_stats.badcrc_from_extstore);\n    }\n#endif\n    APPEND_STAT(\"delete_misses\", \"%llu\", (unsigned long long)thread_stats.delete_misses);\n    APPEND_STAT(\"delete_hits\", \"%llu\", (unsigned long long)slab_stats.delete_hits);\n    APPEND_STAT(\"incr_misses\", \"%llu\", (unsigned long long)thread_stats.incr_misses);\n    APPEND_STAT(\"incr_hits\", \"%llu\", (unsigned long long)slab_stats.incr_hits);\n    APPEND_STAT(\"decr_misses\", \"%llu\", (unsigned long long)thread_stats.decr_misses);\n    APPEND_STAT(\"decr_hits\", \"%llu\", (unsigned long long)slab_stats.decr_hits);\n    APPEND_STAT(\"cas_misses\", \"%llu\", (unsigned long long)thread_stats.cas_misses);\n    APPEND_STAT(\"cas_hits\", \"%llu\", (unsigned long long)slab_stats.cas_hits);\n    APPEND_STAT(\"cas_badval\", \"%llu\", (unsigned long long)slab_stats.cas_badval);\n    APPEND_STAT(\"touch_hits\", \"%llu\", (unsigned long long)slab_stats.touch_hits);\n    APPEND_STAT(\"touch_misses\", \"%llu\", (unsigned long long)thread_stats.touch_misses);\n    APPEND_STAT(\"auth_cmds\", \"%llu\", (unsigned long long)thread_stats.auth_cmds);\n    APPEND_STAT(\"auth_errors\", \"%llu\", (unsigned long long)thread_stats.auth_errors);\n    if (settings.idle_timeout) {\n        APPEND_STAT(\"idle_kicks\", \"%llu\", (unsigned long long)thread_stats.idle_kicks);\n    }\n    APPEND_STAT(\"bytes_read\", \"%llu\", (unsigned long long)thread_stats.bytes_read);\n    APPEND_STAT(\"bytes_written\", \"%llu\", (unsigned long long)thread_stats.bytes_written);\n    APPEND_STAT(\"limit_maxbytes\", \"%llu\", (unsigned long long)settings.maxbytes);\n    APPEND_STAT(\"accepting_conns\", \"%u\", stats_state.accepting_conns);\n    APPEND_STAT(\"listen_disabled_num\", \"%llu\", (unsigned long long)stats.listen_disabled_num);\n    APPEND_STAT(\"time_in_listen_disabled_us\", \"%llu\", stats.time_in_listen_disabled_us);\n    APPEND_STAT(\"threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"conn_yields\", \"%llu\", (unsigned long long)thread_stats.conn_yields);\n    APPEND_STAT(\"hash_power_level\", \"%u\", stats_state.hash_power_level);\n    APPEND_STAT(\"hash_bytes\", \"%llu\", (unsigned long long)stats_state.hash_bytes);\n    APPEND_STAT(\"hash_is_expanding\", \"%u\", stats_state.hash_is_expanding);\n    if (settings.slab_reassign) {\n        APPEND_STAT(\"slab_reassign_rescues\", \"%llu\", stats.slab_reassign_rescues);\n        APPEND_STAT(\"slab_reassign_chunk_rescues\", \"%llu\", stats.slab_reassign_chunk_rescues);\n        APPEND_STAT(\"slab_reassign_evictions_nomem\", \"%llu\", stats.slab_reassign_evictions_nomem);\n        APPEND_STAT(\"slab_reassign_inline_reclaim\", \"%llu\", stats.slab_reassign_inline_reclaim);\n        APPEND_STAT(\"slab_reassign_busy_items\", \"%llu\", stats.slab_reassign_busy_items);\n        APPEND_STAT(\"slab_reassign_busy_deletes\", \"%llu\", stats.slab_reassign_busy_deletes);\n        APPEND_STAT(\"slab_reassign_running\", \"%u\", stats_state.slab_reassign_running);\n        APPEND_STAT(\"slabs_moved\", \"%llu\", stats.slabs_moved);\n    }\n    if (settings.lru_crawler) {\n        APPEND_STAT(\"lru_crawler_running\", \"%u\", stats_state.lru_crawler_running);\n        APPEND_STAT(\"lru_crawler_starts\", \"%u\", stats.lru_crawler_starts);\n    }\n    if (settings.lru_maintainer_thread) {\n        APPEND_STAT(\"lru_maintainer_juggles\", \"%llu\", (unsigned long long)stats.lru_maintainer_juggles);\n    }\n    APPEND_STAT(\"malloc_fails\", \"%llu\",\n                (unsigned long long)stats.malloc_fails);\n    APPEND_STAT(\"log_worker_dropped\", \"%llu\", (unsigned long long)stats.log_worker_dropped);\n    APPEND_STAT(\"log_worker_written\", \"%llu\", (unsigned long long)stats.log_worker_written);\n    APPEND_STAT(\"log_watcher_skipped\", \"%llu\", (unsigned long long)stats.log_watcher_skipped);\n    APPEND_STAT(\"log_watcher_sent\", \"%llu\", (unsigned long long)stats.log_watcher_sent);\n    STATS_UNLOCK();\n#ifdef EXTSTORE\n    if (c->thread->storage) {\n        STATS_LOCK();\n        APPEND_STAT(\"extstore_compact_lost\", \"%llu\", (unsigned long long)stats.extstore_compact_lost);\n        APPEND_STAT(\"extstore_compact_rescues\", \"%llu\", (unsigned long long)stats.extstore_compact_rescues);\n        APPEND_STAT(\"extstore_compact_skipped\", \"%llu\", (unsigned long long)stats.extstore_compact_skipped);\n        STATS_UNLOCK();\n        extstore_get_stats(c->thread->storage, &st);\n        APPEND_STAT(\"extstore_page_allocs\", \"%llu\", (unsigned long long)st.page_allocs);\n        APPEND_STAT(\"extstore_page_evictions\", \"%llu\", (unsigned long long)st.page_evictions);\n        APPEND_STAT(\"extstore_page_reclaims\", \"%llu\", (unsigned long long)st.page_reclaims);\n        APPEND_STAT(\"extstore_pages_free\", \"%llu\", (unsigned long long)st.pages_free);\n        APPEND_STAT(\"extstore_pages_used\", \"%llu\", (unsigned long long)st.pages_used);\n        APPEND_STAT(\"extstore_objects_evicted\", \"%llu\", (unsigned long long)st.objects_evicted);\n        APPEND_STAT(\"extstore_objects_read\", \"%llu\", (unsigned long long)st.objects_read);\n        APPEND_STAT(\"extstore_objects_written\", \"%llu\", (unsigned long long)st.objects_written);\n        APPEND_STAT(\"extstore_objects_used\", \"%llu\", (unsigned long long)st.objects_used);\n        APPEND_STAT(\"extstore_bytes_evicted\", \"%llu\", (unsigned long long)st.bytes_evicted);\n        APPEND_STAT(\"extstore_bytes_written\", \"%llu\", (unsigned long long)st.bytes_written);\n        APPEND_STAT(\"extstore_bytes_read\", \"%llu\", (unsigned long long)st.bytes_read);\n        APPEND_STAT(\"extstore_bytes_used\", \"%llu\", (unsigned long long)st.bytes_used);\n        APPEND_STAT(\"extstore_bytes_fragmented\", \"%llu\", (unsigned long long)st.bytes_fragmented);\n        APPEND_STAT(\"extstore_limit_maxbytes\", \"%llu\", (unsigned long long)(st.page_count * st.page_size));\n        APPEND_STAT(\"extstore_io_queue\", \"%llu\", (unsigned long long)(st.io_queue));\n    }\n#endif\n#ifdef TLS\n    if (settings.ssl_enabled) {\n        APPEND_STAT(\"ssl_handshake_errors\", \"%llu\", (unsigned long long)stats.ssl_handshake_errors);\n        APPEND_STAT(\"time_since_server_cert_refresh\", \"%u\", now - settings.ssl_last_cert_refresh_time);\n    }\n#endif\n}\n\nstatic void process_stat_settings(ADD_STAT add_stats, void *c) {\n    assert(add_stats);\n    APPEND_STAT(\"maxbytes\", \"%llu\", (unsigned long long)settings.maxbytes);\n    APPEND_STAT(\"maxconns\", \"%d\", settings.maxconns);\n    APPEND_STAT(\"tcpport\", \"%d\", settings.port);\n    APPEND_STAT(\"udpport\", \"%d\", settings.udpport);\n    APPEND_STAT(\"inter\", \"%s\", settings.inter ? settings.inter : \"NULL\");\n    APPEND_STAT(\"verbosity\", \"%d\", settings.verbose);\n    APPEND_STAT(\"oldest\", \"%lu\", (unsigned long)settings.oldest_live);\n    APPEND_STAT(\"evictions\", \"%s\", settings.evict_to_free ? \"on\" : \"off\");\n    APPEND_STAT(\"domain_socket\", \"%s\",\n                settings.socketpath ? settings.socketpath : \"NULL\");\n    APPEND_STAT(\"umask\", \"%o\", settings.access);\n    APPEND_STAT(\"growth_factor\", \"%.2f\", settings.factor);\n    APPEND_STAT(\"chunk_size\", \"%d\", settings.chunk_size);\n    APPEND_STAT(\"num_threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"num_threads_per_udp\", \"%d\", settings.num_threads_per_udp);\n    APPEND_STAT(\"stat_key_prefix\", \"%c\", settings.prefix_delimiter);\n    APPEND_STAT(\"detail_enabled\", \"%s\",\n                settings.detail_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"reqs_per_event\", \"%d\", settings.reqs_per_event);\n    APPEND_STAT(\"cas_enabled\", \"%s\", settings.use_cas ? \"yes\" : \"no\");\n    APPEND_STAT(\"tcp_backlog\", \"%d\", settings.backlog);\n    APPEND_STAT(\"binding_protocol\", \"%s\",\n                prot_text(settings.binding_protocol));\n    APPEND_STAT(\"auth_enabled_sasl\", \"%s\", settings.sasl ? \"yes\" : \"no\");\n    APPEND_STAT(\"auth_enabled_ascii\", \"%s\", settings.auth_file ? settings.auth_file : \"no\");\n    APPEND_STAT(\"item_size_max\", \"%d\", settings.item_size_max);\n    APPEND_STAT(\"maxconns_fast\", \"%s\", settings.maxconns_fast ? \"yes\" : \"no\");\n    APPEND_STAT(\"hashpower_init\", \"%d\", settings.hashpower_init);\n    APPEND_STAT(\"slab_reassign\", \"%s\", settings.slab_reassign ? \"yes\" : \"no\");\n    APPEND_STAT(\"slab_automove\", \"%d\", settings.slab_automove);\n    APPEND_STAT(\"slab_automove_ratio\", \"%.2f\", settings.slab_automove_ratio);\n    APPEND_STAT(\"slab_automove_window\", \"%u\", settings.slab_automove_window);\n    APPEND_STAT(\"slab_chunk_max\", \"%d\", settings.slab_chunk_size_max);\n    APPEND_STAT(\"lru_crawler\", \"%s\", settings.lru_crawler ? \"yes\" : \"no\");\n    APPEND_STAT(\"lru_crawler_sleep\", \"%d\", settings.lru_crawler_sleep);\n    APPEND_STAT(\"lru_crawler_tocrawl\", \"%lu\", (unsigned long)settings.lru_crawler_tocrawl);\n    APPEND_STAT(\"tail_repair_time\", \"%d\", settings.tail_repair_time);\n    APPEND_STAT(\"flush_enabled\", \"%s\", settings.flush_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"dump_enabled\", \"%s\", settings.dump_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"hash_algorithm\", \"%s\", settings.hash_algorithm);\n    APPEND_STAT(\"lru_maintainer_thread\", \"%s\", settings.lru_maintainer_thread ? \"yes\" : \"no\");\n    APPEND_STAT(\"lru_segmented\", \"%s\", settings.lru_segmented ? \"yes\" : \"no\");\n    APPEND_STAT(\"hot_lru_pct\", \"%d\", settings.hot_lru_pct);\n    APPEND_STAT(\"warm_lru_pct\", \"%d\", settings.warm_lru_pct);\n    APPEND_STAT(\"hot_max_factor\", \"%.2f\", settings.hot_max_factor);\n    APPEND_STAT(\"warm_max_factor\", \"%.2f\", settings.warm_max_factor);\n    APPEND_STAT(\"temp_lru\", \"%s\", settings.temp_lru ? \"yes\" : \"no\");\n    APPEND_STAT(\"temporary_ttl\", \"%u\", settings.temporary_ttl);\n    APPEND_STAT(\"idle_timeout\", \"%d\", settings.idle_timeout);\n    APPEND_STAT(\"watcher_logbuf_size\", \"%u\", settings.logger_watcher_buf_size);\n    APPEND_STAT(\"worker_logbuf_size\", \"%u\", settings.logger_buf_size);\n    APPEND_STAT(\"resp_obj_mem_limit\", \"%u\", settings.resp_obj_mem_limit);\n    APPEND_STAT(\"read_buf_mem_limit\", \"%u\", settings.read_buf_mem_limit);\n    APPEND_STAT(\"track_sizes\", \"%s\", item_stats_sizes_status() ? \"yes\" : \"no\");\n    APPEND_STAT(\"inline_ascii_response\", \"%s\", \"no\"); // setting is dead, cannot be yes.\n#ifdef HAVE_DROP_PRIVILEGES\n    APPEND_STAT(\"drop_privileges\", \"%s\", settings.drop_privileges ? \"yes\" : \"no\");\n#endif\n#ifdef EXTSTORE\n    APPEND_STAT(\"ext_item_size\", \"%u\", settings.ext_item_size);\n    APPEND_STAT(\"ext_item_age\", \"%u\", settings.ext_item_age);\n    APPEND_STAT(\"ext_low_ttl\", \"%u\", settings.ext_low_ttl);\n    APPEND_STAT(\"ext_recache_rate\", \"%u\", settings.ext_recache_rate);\n    APPEND_STAT(\"ext_wbuf_size\", \"%u\", settings.ext_wbuf_size);\n    APPEND_STAT(\"ext_compact_under\", \"%u\", settings.ext_compact_under);\n    APPEND_STAT(\"ext_drop_under\", \"%u\", settings.ext_drop_under);\n    APPEND_STAT(\"ext_max_frag\", \"%.2f\", settings.ext_max_frag);\n    APPEND_STAT(\"slab_automove_freeratio\", \"%.3f\", settings.slab_automove_freeratio);\n    APPEND_STAT(\"ext_drop_unread\", \"%s\", settings.ext_drop_unread ? \"yes\" : \"no\");\n#endif\n#ifdef TLS\n    APPEND_STAT(\"ssl_enabled\", \"%s\", settings.ssl_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"ssl_chain_cert\", \"%s\", settings.ssl_chain_cert);\n    APPEND_STAT(\"ssl_key\", \"%s\", settings.ssl_key);\n    APPEND_STAT(\"ssl_verify_mode\", \"%d\", settings.ssl_verify_mode);\n    APPEND_STAT(\"ssl_keyformat\", \"%d\", settings.ssl_keyformat);\n    APPEND_STAT(\"ssl_ciphers\", \"%s\", settings.ssl_ciphers ? settings.ssl_ciphers : \"NULL\");\n    APPEND_STAT(\"ssl_ca_cert\", \"%s\", settings.ssl_ca_cert ? settings.ssl_ca_cert : \"NULL\");\n    APPEND_STAT(\"ssl_wbuf_size\", \"%u\", settings.ssl_wbuf_size);\n#endif\n}\n\nstatic int nz_strcmp(int nzlength, const char *nz, const char *z) {\n    int zlength=strlen(z);\n    return (zlength == nzlength) && (strncmp(nz, z, zlength) == 0) ? 0 : -1;\n}\n\nstatic bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c) {\n    bool ret = true;\n\n    if (add_stats != NULL) {\n        if (!stat_type) {\n            /* prepare general statistics for the engine */\n            STATS_LOCK();\n            APPEND_STAT(\"bytes\", \"%llu\", (unsigned long long)stats_state.curr_bytes);\n            APPEND_STAT(\"curr_items\", \"%llu\", (unsigned long long)stats_state.curr_items);\n            APPEND_STAT(\"total_items\", \"%llu\", (unsigned long long)stats.total_items);\n            STATS_UNLOCK();\n            APPEND_STAT(\"slab_global_page_pool\", \"%u\", global_page_pool_size(NULL));\n            item_stats_totals(add_stats, c);\n        } else if (nz_strcmp(nkey, stat_type, \"items\") == 0) {\n            item_stats(add_stats, c);\n        } else if (nz_strcmp(nkey, stat_type, \"slabs\") == 0) {\n            slabs_stats(add_stats, c);\n        } else if (nz_strcmp(nkey, stat_type, \"sizes\") == 0) {\n            item_stats_sizes(add_stats, c);\n        } else if (nz_strcmp(nkey, stat_type, \"sizes_enable\") == 0) {\n            item_stats_sizes_enable(add_stats, c);\n        } else if (nz_strcmp(nkey, stat_type, \"sizes_disable\") == 0) {\n            item_stats_sizes_disable(add_stats, c);\n        } else {\n            ret = false;\n        }\n    } else {\n        ret = false;\n    }\n\n    return ret;\n}\n\nstatic inline void get_conn_text(const conn *c, const int af,\n                char* addr, struct sockaddr *sock_addr) {\n    char addr_text[MAXPATHLEN];\n    addr_text[0] = '\\0';\n    const char *protoname = \"?\";\n    unsigned short port = 0;\n    size_t pathlen = 0;\n\n    switch (af) {\n        case AF_INET:\n            (void) inet_ntop(af,\n                    &((struct sockaddr_in *)sock_addr)->sin_addr,\n                    addr_text,\n                    sizeof(addr_text) - 1);\n            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);\n            protoname = IS_UDP(c->transport) ? \"udp\" : \"tcp\";\n            break;\n\n        case AF_INET6:\n            addr_text[0] = '[';\n            addr_text[1] = '\\0';\n            if (inet_ntop(af,\n                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,\n                    addr_text + 1,\n                    sizeof(addr_text) - 2)) {\n                strcat(addr_text, \"]\");\n            }\n            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);\n            protoname = IS_UDP(c->transport) ? \"udp6\" : \"tcp6\";\n            break;\n\n        case AF_UNIX:\n            // this strncpy call originally could piss off an address\n            // sanitizer; we supplied the size of the dest buf as a limiter,\n            // but optimized versions of strncpy could read past the end of\n            // *src while looking for a null terminator. Since buf and\n            // sun_path here are both on the stack they could even overlap,\n            // which is \"undefined\". In all OSS versions of strncpy I could\n            // find this has no effect; it'll still only copy until the first null\n            // terminator is found. Thus it's possible to get the OS to\n            // examine past the end of sun_path but it's unclear to me if this\n            // can cause any actual problem.\n            //\n            // We need a safe_strncpy util function but I'll punt on figuring\n            // that out for now.\n            pathlen = sizeof(((struct sockaddr_un *)sock_addr)->sun_path);\n            if (MAXPATHLEN <= pathlen) {\n                pathlen = MAXPATHLEN - 1;\n            }\n            strncpy(addr_text,\n                    ((struct sockaddr_un *)sock_addr)->sun_path,\n                    pathlen);\n            addr_text[pathlen] = '\\0';\n            protoname = \"unix\";\n            break;\n    }\n\n    if (strlen(addr_text) < 2) {\n        /* Most likely this is a connected UNIX-domain client which\n         * has no peer socket address, but there's no portable way\n         * to tell for sure.\n         */\n        sprintf(addr_text, \"<AF %d>\", af);\n    }\n\n    if (port) {\n        sprintf(addr, \"%s:%s:%u\", protoname, addr_text, port);\n    } else {\n        sprintf(addr, \"%s:%s\", protoname, addr_text);\n    }\n}\n\nstatic void conn_to_str(const conn *c, char *addr, char *svr_addr) {\n    if (!c) {\n        strcpy(addr, \"<null>\");\n    } else if (c->state == conn_closed) {\n        strcpy(addr, \"<closed>\");\n    } else {\n        struct sockaddr_in6 local_addr;\n        struct sockaddr *sock_addr = (void *)&c->request_addr;\n\n        /* For listen ports and idle UDP ports, show listen address */\n        if (c->state == conn_listening ||\n                (IS_UDP(c->transport) &&\n                 c->state == conn_read)) {\n            socklen_t local_addr_len = sizeof(local_addr);\n\n            if (getsockname(c->sfd,\n                        (struct sockaddr *)&local_addr,\n                        &local_addr_len) == 0) {\n                sock_addr = (struct sockaddr *)&local_addr;\n            }\n        }\n        get_conn_text(c, sock_addr->sa_family, addr, sock_addr);\n\n        if (c->state != conn_listening && !(IS_UDP(c->transport) &&\n                 c->state == conn_read)) {\n            struct sockaddr_storage svr_sock_addr;\n            socklen_t svr_addr_len = sizeof(svr_sock_addr);\n            getsockname(c->sfd, (struct sockaddr *)&svr_sock_addr, &svr_addr_len);\n            get_conn_text(c, svr_sock_addr.ss_family, svr_addr, (struct sockaddr *)&svr_sock_addr);\n        }\n    }\n}\n\nstatic void process_stats_conns(ADD_STAT add_stats, void *c) {\n    int i;\n    char key_str[STAT_KEY_LEN];\n    char val_str[STAT_VAL_LEN];\n    size_t extras_len = sizeof(\"unix:\") + sizeof(\"65535\");\n    char addr[MAXPATHLEN + extras_len];\n    char svr_addr[MAXPATHLEN + extras_len];\n    int klen = 0, vlen = 0;\n\n    assert(add_stats);\n\n    for (i = 0; i < max_fds; i++) {\n        if (conns[i]) {\n            /* This is safe to do unlocked because conns are never freed; the\n             * worst that'll happen will be a minor inconsistency in the\n             * output -- not worth the complexity of the locking that'd be\n             * required to prevent it.\n             */\n            if (IS_UDP(conns[i]->transport)) {\n                APPEND_NUM_STAT(i, \"UDP\", \"%s\", \"UDP\");\n            }\n            if (conns[i]->state != conn_closed) {\n                conn_to_str(conns[i], addr, svr_addr);\n\n                APPEND_NUM_STAT(i, \"addr\", \"%s\", addr);\n                if (conns[i]->state != conn_listening &&\n                    !(IS_UDP(conns[i]->transport) && conns[i]->state == conn_read)) {\n                    APPEND_NUM_STAT(i, \"listen_addr\", \"%s\", svr_addr);\n                }\n                APPEND_NUM_STAT(i, \"state\", \"%s\",\n                        state_text(conns[i]->state));\n                APPEND_NUM_STAT(i, \"secs_since_last_cmd\", \"%d\",\n                        current_time - conns[i]->last_cmd_time);\n            }\n        }\n    }\n}\n#ifdef EXTSTORE\nstatic void process_extstore_stats(ADD_STAT add_stats, conn *c) {\n    int i;\n    char key_str[STAT_KEY_LEN];\n    char val_str[STAT_VAL_LEN];\n    int klen = 0, vlen = 0;\n    struct extstore_stats st;\n\n    assert(add_stats);\n\n    void *storage = c->thread->storage;\n    extstore_get_stats(storage, &st);\n    st.page_data = calloc(st.page_count, sizeof(struct extstore_page_data));\n    extstore_get_page_data(storage, &st);\n\n    for (i = 0; i < st.page_count; i++) {\n        APPEND_NUM_STAT(i, \"version\", \"%llu\",\n                (unsigned long long) st.page_data[i].version);\n        APPEND_NUM_STAT(i, \"bytes\", \"%llu\",\n                (unsigned long long) st.page_data[i].bytes_used);\n        APPEND_NUM_STAT(i, \"bucket\", \"%u\",\n                st.page_data[i].bucket);\n        APPEND_NUM_STAT(i, \"free_bucket\", \"%u\",\n                st.page_data[i].free_bucket);\n    }\n}\n#endif\nstatic void process_stat(conn *c, token_t *tokens, const size_t ntokens) {\n    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;\n    assert(c != NULL);\n\n    if (ntokens < 2) {\n        out_string(c, \"CLIENT_ERROR bad command line\");\n        return;\n    }\n\n    if (ntokens == 2) {\n        server_stats(&append_stats, c);\n        (void)get_stats(NULL, 0, &append_stats, c);\n    } else if (strcmp(subcommand, \"reset\") == 0) {\n        stats_reset();\n        out_string(c, \"RESET\");\n        return;\n    } else if (strcmp(subcommand, \"detail\") == 0) {\n        /* NOTE: how to tackle detail with binary? */\n        if (ntokens < 4)\n            process_stats_detail(c, \"\");  /* outputs the error message */\n        else\n            process_stats_detail(c, tokens[2].value);\n        /* Output already generated */\n        return;\n    } else if (strcmp(subcommand, \"settings\") == 0) {\n        process_stat_settings(&append_stats, c);\n    } else if (strcmp(subcommand, \"cachedump\") == 0) {\n        char *buf;\n        unsigned int bytes, id, limit = 0;\n\n        if (!settings.dump_enabled) {\n            out_string(c, \"CLIENT_ERROR stats cachedump not allowed\");\n            return;\n        }\n\n        if (ntokens < 5) {\n            out_string(c, \"CLIENT_ERROR bad command line\");\n            return;\n        }\n\n        if (!safe_strtoul(tokens[2].value, &id) ||\n            !safe_strtoul(tokens[3].value, &limit)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n\n        if (id >= MAX_NUMBER_OF_SLAB_CLASSES) {\n            out_string(c, \"CLIENT_ERROR Illegal slab id\");\n            return;\n        }\n\n        buf = item_cachedump(id, limit, &bytes);\n        write_and_free(c, buf, bytes);\n        return;\n    } else if (strcmp(subcommand, \"conns\") == 0) {\n        process_stats_conns(&append_stats, c);\n#ifdef EXTSTORE\n    } else if (strcmp(subcommand, \"extstore\") == 0) {\n        process_extstore_stats(&append_stats, c);\n#endif\n    } else {\n        /* getting here means that the subcommand is either engine specific or\n           is invalid. query the engine and see. */\n        if (get_stats(subcommand, strlen(subcommand), &append_stats, c)) {\n            if (c->stats.buffer == NULL) {\n                out_of_memory(c, \"SERVER_ERROR out of memory writing stats\");\n            } else {\n                write_and_free(c, c->stats.buffer, c->stats.offset);\n                c->stats.buffer = NULL;\n            }\n        } else {\n            out_string(c, \"ERROR\");\n        }\n        return;\n    }\n\n    /* append terminator and start the transfer */\n    append_stats(NULL, 0, NULL, 0, c);\n\n    if (c->stats.buffer == NULL) {\n        out_of_memory(c, \"SERVER_ERROR out of memory writing stats\");\n    } else {\n        write_and_free(c, c->stats.buffer, c->stats.offset);\n        c->stats.buffer = NULL;\n    }\n}\n\n/* client flags == 0 means use no storage for client flags */\nstatic inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas, int nbytes) {\n    char *p = suffix;\n    *p = ' ';\n    p++;\n    if (FLAGS_SIZE(it) == 0) {\n        *p = '0';\n        p++;\n    } else {\n        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);\n    }\n    *p = ' ';\n    p = itoa_u32(nbytes-2, p+1);\n\n    if (return_cas) {\n        *p = ' ';\n        p = itoa_u64(ITEM_get_cas(it), p+1);\n    }\n\n    *p = '\\r';\n    *(p+1) = '\\n';\n    *(p+2) = '\\0';\n    return (p - suffix) + 2;\n}\n\n#define IT_REFCOUNT_LIMIT 60000\nstatic inline item* limited_get(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch, bool do_update, bool *overflow) {\n    item *it;\n    if (should_touch) {\n        it = item_touch(key, nkey, exptime, c);\n    } else {\n        it = item_get(key, nkey, c, do_update);\n    }\n    if (it && it->refcount > IT_REFCOUNT_LIMIT) {\n        item_remove(it);\n        it = NULL;\n        *overflow = true;\n    } else {\n        *overflow = false;\n    }\n    return it;\n}\n\n// Semantics are different than limited_get; since the item is returned\n// locked, caller can directly change what it needs.\n// though it might eventually be a better interface to sink it all into\n// items.c.\nstatic inline item* limited_get_locked(char *key, size_t nkey, conn *c, bool do_update, uint32_t *hv, bool *overflow) {\n    item *it;\n    it = item_get_locked(key, nkey, c, do_update, hv);\n    if (it && it->refcount > IT_REFCOUNT_LIMIT) {\n        do_item_remove(it);\n        it = NULL;\n        item_unlock(*hv);\n        *overflow = true;\n    } else {\n        *overflow = false;\n    }\n    return it;\n}\n\n#ifdef EXTSTORE\n// FIXME: This runs in the IO thread. to get better IO performance this should\n// simply mark the io wrapper with the return value and decrement wrapleft, if\n// zero redispatching. Still a bit of work being done in the side thread but\n// minimized at least.\nstatic void _get_extstore_cb(void *e, obj_io *io, int ret) {\n    // FIXME: assumes success\n    io_wrap *wrap = (io_wrap *)io->data;\n    mc_resp *resp = wrap->resp;\n    conn *c = wrap->c;\n    assert(wrap->active == true);\n    item *read_it = (item *)io->buf;\n    bool miss = false;\n\n    // TODO: How to do counters for hit/misses?\n    if (ret < 1) {\n        miss = true;\n    } else {\n        uint32_t crc2;\n        uint32_t crc = (uint32_t) read_it->exptime;\n        int x;\n        // item is chunked, crc the iov's\n        if (io->iov != NULL) {\n            // first iov is the header, which we don't use beyond crc\n            crc2 = crc32c(0, (char *)io->iov[0].iov_base+STORE_OFFSET, io->iov[0].iov_len-STORE_OFFSET);\n            // make sure it's not sent. hack :(\n            io->iov[0].iov_len = 0;\n            for (x = 1; x < io->iovcnt; x++) {\n                crc2 = crc32c(crc2, (char *)io->iov[x].iov_base, io->iov[x].iov_len);\n            }\n        } else {\n            crc2 = crc32c(0, (char *)read_it+STORE_OFFSET, io->len-STORE_OFFSET);\n        }\n\n        if (crc != crc2) {\n            miss = true;\n            wrap->badcrc = true;\n        }\n    }\n\n    if (miss) {\n        if (wrap->noreply) {\n            // In all GET cases, noreply means we send nothing back.\n            resp->skip = true;\n        } else {\n            // TODO: This should be movable to the worker thread.\n            // Convert the binprot response into a miss response.\n            // The header requires knowing a bunch of stateful crap, so rather\n            // than simply writing out a \"new\" miss response we mangle what's\n            // already there.\n            if (c->protocol == binary_prot) {\n                protocol_binary_response_header *header =\n                    (protocol_binary_response_header *)resp->wbuf;\n\n                // cut the extra nbytes off of the body_len\n                uint32_t body_len = ntohl(header->response.bodylen);\n                uint8_t hdr_len = header->response.extlen;\n                body_len -= resp->iov[wrap->iovec_data].iov_len + hdr_len;\n                resp->tosend -= resp->iov[wrap->iovec_data].iov_len + hdr_len;\n                header->response.extlen = 0;\n                header->response.status = (uint16_t)htons(PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n                header->response.bodylen = htonl(body_len);\n\n                // truncate the data response.\n                resp->iov[wrap->iovec_data].iov_len = 0;\n                // wipe the extlen iov... wish it was just a flat buffer.\n                resp->iov[wrap->iovec_data-1].iov_len = 0;\n                resp->chunked_data_iov = 0;\n            } else {\n                int i;\n                // Meta commands have EN status lines for miss, rather than\n                // END as a trailer as per normal ascii.\n                if (resp->iov[0].iov_len >= 3\n                        && memcmp(resp->iov[0].iov_base, \"VA \", 3) == 0) {\n                    // TODO: These miss translators should use specific callback\n                    // functions attached to the io wrap. This is weird :(\n                    resp->iovcnt = 1;\n                    resp->iov[0].iov_len = 4;\n                    resp->iov[0].iov_base = \"EN\\r\\n\";\n                    resp->tosend = 4;\n                } else {\n                    // Wipe the iovecs up through our data injection.\n                    // Allows trailers to be returned (END)\n                    for (i = 0; i <= wrap->iovec_data; i++) {\n                        resp->tosend -= resp->iov[i].iov_len;\n                        resp->iov[i].iov_len = 0;\n                        resp->iov[i].iov_base = NULL;\n                    }\n                }\n                resp->chunked_total = 0;\n                resp->chunked_data_iov = 0;\n            }\n        }\n        wrap->miss = true;\n    } else {\n        assert(read_it->slabs_clsid != 0);\n        // TODO: should always use it instead of ITEM_data to kill more\n        // chunked special casing.\n        if ((read_it->it_flags & ITEM_CHUNKED) == 0) {\n            resp->iov[wrap->iovec_data].iov_base = ITEM_data(read_it);\n        }\n        wrap->miss = false;\n    }\n\n    c->io_wrapleft--;\n    wrap->active = false;\n    //assert(c->io_wrapleft >= 0);\n\n    // All IO's have returned, lets re-attach this connection to our original\n    // thread.\n    if (c->io_wrapleft == 0) {\n        assert(c->io_queued == true);\n        c->io_queued = false;\n        redispatch_conn(c);\n    }\n}\n\nstatic inline int _get_extstore(conn *c, item *it, mc_resp *resp) {\n#ifdef NEED_ALIGN\n    item_hdr hdr;\n    memcpy(&hdr, ITEM_data(it), sizeof(hdr));\n#else\n    item_hdr *hdr = (item_hdr *)ITEM_data(it);\n#endif\n    size_t ntotal = ITEM_ntotal(it);\n    unsigned int clsid = slabs_clsid(ntotal);\n    item *new_it;\n    bool chunked = false;\n    if (ntotal > settings.slab_chunk_size_max) {\n        // Pull a chunked item header.\n        uint32_t flags;\n        FLAGS_CONV(it, flags);\n        new_it = item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, it->nbytes);\n        assert(new_it == NULL || (new_it->it_flags & ITEM_CHUNKED));\n        chunked = true;\n    } else {\n        new_it = do_item_alloc_pull(ntotal, clsid);\n    }\n    if (new_it == NULL)\n        return -1;\n    assert(!c->io_queued); // FIXME: debugging.\n    // so we can free the chunk on a miss\n    new_it->slabs_clsid = clsid;\n\n    io_wrap *io = do_cache_alloc(c->thread->io_cache);\n    io->active = true;\n    io->miss = false;\n    io->badcrc = false;\n    io->noreply = c->noreply;\n    // io_wrap owns the reference for this object now.\n    io->hdr_it = it;\n    io->resp = resp;\n    io->io.iov = NULL;\n\n    // FIXME: error handling.\n    if (chunked) {\n        unsigned int ciovcnt = 0;\n        size_t remain = new_it->nbytes;\n        item_chunk *chunk = (item_chunk *) ITEM_schunk(new_it);\n        // TODO: This might make sense as a _global_ cache vs a per-thread.\n        // but we still can't load objects requiring > IOV_MAX iovs.\n        // In the meantime, these objects are rare/slow enough that\n        // malloc/freeing a statically sized object won't cause us much pain.\n        io->io.iov = malloc(sizeof(struct iovec) * IOV_MAX);\n        if (io->io.iov == NULL) {\n            item_remove(new_it);\n            do_cache_free(c->thread->io_cache, io);\n            return -1;\n        }\n\n        // fill the header so we can get the full data + crc back.\n        io->io.iov[0].iov_base = new_it;\n        io->io.iov[0].iov_len = ITEM_ntotal(new_it) - new_it->nbytes;\n        ciovcnt++;\n\n        while (remain > 0) {\n            chunk = do_item_alloc_chunk(chunk, remain);\n            // FIXME: _pure evil_, silently erroring if item is too large.\n            if (chunk == NULL || ciovcnt > IOV_MAX-1) {\n                item_remove(new_it);\n                free(io->io.iov);\n                // TODO: wrapper function for freeing up an io wrap?\n                io->io.iov = NULL;\n                do_cache_free(c->thread->io_cache, io);\n                return -1;\n            }\n            io->io.iov[ciovcnt].iov_base = chunk->data;\n            io->io.iov[ciovcnt].iov_len = (remain < chunk->size) ? remain : chunk->size;\n            chunk->used = (remain < chunk->size) ? remain : chunk->size;\n            remain -= chunk->size;\n            ciovcnt++;\n        }\n\n        io->io.iovcnt = ciovcnt;\n    }\n\n    // Chunked or non chunked we reserve a response iov here.\n    io->iovec_data = resp->iovcnt;\n    int iovtotal = (c->protocol == binary_prot) ? it->nbytes - 2 : it->nbytes;\n    if (chunked) {\n        resp_add_chunked_iov(resp, new_it, iovtotal);\n    } else {\n        resp_add_iov(resp, \"\", iovtotal);\n    }\n\n    io->io.buf = (void *)new_it;\n    io->c = c;\n\n    // We need to stack the sub-struct IO's together as well.\n    if (c->io_wraplist) {\n        io->io.next = &c->io_wraplist->io;\n    } else {\n        io->io.next = NULL;\n    }\n\n    // IO queue for this connection.\n    io->next = c->io_wraplist;\n    c->io_wraplist = io;\n    assert(c->io_wrapleft >= 0);\n    c->io_wrapleft++;\n    // reference ourselves for the callback.\n    io->io.data = (void *)io;\n\n    // Now, fill in io->io based on what was in our header.\n#ifdef NEED_ALIGN\n    io->io.page_version = hdr.page_version;\n    io->io.page_id = hdr.page_id;\n    io->io.offset = hdr.offset;\n#else\n    io->io.page_version = hdr->page_version;\n    io->io.page_id = hdr->page_id;\n    io->io.offset = hdr->offset;\n#endif\n    io->io.len = ntotal;\n    io->io.mode = OBJ_IO_READ;\n    io->io.cb = _get_extstore_cb;\n\n    //fprintf(stderr, \"EXTSTORE: IO stacked %u\\n\", io->iovec_data);\n    // FIXME: This stat needs to move to reflect # of flash hits vs misses\n    // for now it's a good gauge on how often we request out to flash at\n    // least.\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.get_extstore++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    return 0;\n}\n#endif\n\n/* ntokens is overwritten here... shrug.. */\nstatic inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {\n    char *key;\n    size_t nkey;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    int32_t exptime_int = 0;\n    rel_time_t exptime = 0;\n    bool fail_length = false;\n    assert(c != NULL);\n    mc_resp *resp = c->resp;\n\n    if (should_touch) {\n        // For get and touch commands, use first token as exptime\n        if (!safe_strtol(tokens[1].value, &exptime_int)) {\n            out_string(c, \"CLIENT_ERROR invalid exptime argument\");\n            return;\n        }\n        key_token++;\n        exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));\n    }\n\n    do {\n        while(key_token->length != 0) {\n            bool overflow; // not used here.\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if (nkey > KEY_MAX_LENGTH) {\n                fail_length = true;\n                goto stop;\n            }\n\n            it = limited_get(key, nkey, c, exptime, should_touch, DO_UPDATE, &overflow);\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n            if (it) {\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  int nbytes = it->nbytes;;\n                  nbytes = it->nbytes;\n                  char *p = resp->wbuf;\n                  memcpy(p, \"VALUE \", 6);\n                  p += 6;\n                  memcpy(p, ITEM_key(it), it->nkey);\n                  p += it->nkey;\n                  p += make_ascii_get_suffix(p, it, return_cas, nbytes);\n                  resp_add_iov(resp, resp->wbuf, p - resp->wbuf);\n\n#ifdef EXTSTORE\n                  if (it->it_flags & ITEM_HDR) {\n                      if (_get_extstore(c, it, resp) != 0) {\n                          pthread_mutex_lock(&c->thread->stats.mutex);\n                          c->thread->stats.get_oom_extstore++;\n                          pthread_mutex_unlock(&c->thread->stats.mutex);\n\n                          item_remove(it);\n                          goto stop;\n                      }\n                  } else if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                      resp_add_iov(resp, ITEM_data(it), it->nbytes);\n                  } else {\n                      resp_add_chunked_iov(resp, it, it->nbytes);\n                  }\n#else\n                  if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                      resp_add_iov(resp, ITEM_data(it), it->nbytes);\n                  } else {\n                      resp_add_chunked_iov(resp, it, it->nbytes);\n                  }\n#endif\n                }\n\n                if (settings.verbose > 1) {\n                    int ii;\n                    fprintf(stderr, \">%d sending key \", c->sfd);\n                    for (ii = 0; ii < it->nkey; ++ii) {\n                        fprintf(stderr, \"%c\", key[ii]);\n                    }\n                    fprintf(stderr, \"\\n\");\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                if (should_touch) {\n                    c->thread->stats.touch_cmds++;\n                    c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;\n                } else {\n                    c->thread->stats.lru_hits[it->slabs_clsid]++;\n                    c->thread->stats.get_cmds++;\n                }\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n#ifdef EXTSTORE\n                /* If ITEM_HDR, an io_wrap owns the reference. */\n                if ((it->it_flags & ITEM_HDR) == 0) {\n                    resp->item = it;\n                }\n#else\n                resp->item = it;\n#endif\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                if (should_touch) {\n                    c->thread->stats.touch_cmds++;\n                    c->thread->stats.touch_misses++;\n                } else {\n                    c->thread->stats.get_misses++;\n                    c->thread->stats.get_cmds++;\n                }\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n            }\n\n            key_token++;\n            if (key_token->length != 0) {\n                if (!resp_start(c)) {\n                    goto stop;\n                }\n                resp = c->resp;\n            }\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if (key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n            if (!resp_start(c)) {\n                goto stop;\n            }\n            resp = c->resp;\n        }\n    } while(key_token->value != NULL);\nstop:\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d END\\n\", c->sfd);\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL) {\n        // Kill any stacked responses we had.\n        conn_release_items(c);\n        // Start a new response object for the error message.\n        if (!resp_start(c)) {\n            // severe out of memory error.\n            conn_set_state(c, conn_closing);\n            return;\n        }\n        if (fail_length) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n        } else {\n            out_of_memory(c, \"SERVER_ERROR out of memory writing get response\");\n        }\n    } else {\n        // Tag the end token onto the most recent response object.\n        resp_add_iov(resp, \"END\\r\\n\", 5);\n        conn_set_state(c, conn_mwrite);\n    }\n}\n\n// slow snprintf for debugging purposes.\nstatic void process_meta_command(conn *c, token_t *tokens, const size_t ntokens) {\n    assert(c != NULL);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    char *key = tokens[KEY_TOKEN].value;\n    size_t nkey = tokens[KEY_TOKEN].length;\n\n    bool overflow; // not used here.\n    item *it = limited_get(key, nkey, c, 0, false, DONT_UPDATE, &overflow);\n    if (it) {\n        mc_resp *resp = c->resp;\n        size_t total = 0;\n        size_t ret;\n        // similar to out_string().\n        memcpy(resp->wbuf, \"ME \", 3);\n        total += 3;\n        memcpy(resp->wbuf + total, ITEM_key(it), it->nkey);\n        total += it->nkey;\n        resp->wbuf[total] = ' ';\n        total++;\n\n        ret = snprintf(resp->wbuf + total, WRITE_BUFFER_SIZE - (it->nkey + 12),\n                \"exp=%d la=%llu cas=%llu fetch=%s cls=%u size=%lu\\r\\n\",\n                (it->exptime == 0) ? -1 : (current_time - it->exptime),\n                (unsigned long long)(current_time - it->time),\n                (unsigned long long)ITEM_get_cas(it),\n                (it->it_flags & ITEM_FETCHED) ? \"yes\" : \"no\",\n                ITEM_clsid(it),\n                (unsigned long) ITEM_ntotal(it));\n\n        item_remove(it);\n        resp->wbytes = total + ret;\n        resp_add_iov(resp, resp->wbuf, resp->wbytes);\n        conn_set_state(c, conn_new_cmd);\n    } else {\n        out_string(c, \"EN\");\n    }\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.meta_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n}\n\n#define MFLAG_MAX_OPT_LENGTH 20\n#define MFLAG_MAX_OPAQUE_LENGTH 32\n\nstruct _meta_flags {\n    unsigned int has_error :1; // flipped if we found an error during parsing.\n    unsigned int no_update :1;\n    unsigned int locked :1;\n    unsigned int vivify :1;\n    unsigned int la :1;\n    unsigned int hit :1;\n    unsigned int value :1;\n    unsigned int set_stale :1;\n    unsigned int no_reply :1;\n    unsigned int has_cas :1;\n    unsigned int new_ttl :1;\n    char mode; // single character mode switch, common to ms/ma\n    rel_time_t exptime;\n    rel_time_t autoviv_exptime;\n    rel_time_t recache_time;\n    int32_t value_len;\n    uint32_t client_flags;\n    uint64_t req_cas_id;\n    uint64_t delta; // ma\n    uint64_t initial; // ma\n};\n\nstatic int _meta_flag_preparse(token_t *tokens, const size_t ntokens,\n        struct _meta_flags *of, char **errstr) {\n    unsigned int i;\n    int32_t tmp_int;\n    uint8_t seen[127] = {0};\n    // Start just past the key token. Look at first character of each token.\n    for (i = KEY_TOKEN+1; i < ntokens-1; i++) {\n        uint8_t o = (uint8_t)tokens[i].value[0];\n        // zero out repeat flags so we don't over-parse for return data.\n        if (o >= 127 || seen[o] != 0) {\n            *errstr = \"CLIENT_ERROR duplicate flag\";\n            return -1;\n        }\n        seen[o] = 1;\n        switch (o) {\n            /* Negative exptimes can underflow and end up immortal. realtime() will\n               immediately expire values that are greater than REALTIME_MAXDELTA, but less\n               than process_started, so lets aim for that. */\n            case 'N':\n                of->locked = 1;\n                of->vivify = 1;\n                if (!safe_strtol(tokens[i].value+1, &tmp_int)) {\n                    *errstr = \"CLIENT_ERROR bad token in command line format\";\n                    of->has_error = 1;\n                } else {\n                    of->autoviv_exptime = realtime(EXPTIME_TO_POSITIVE_TIME(tmp_int));\n                }\n                break;\n            case 'T':\n                of->locked = 1;\n                if (!safe_strtol(tokens[i].value+1, &tmp_int)) {\n                    *errstr = \"CLIENT_ERROR bad token in command line format\";\n                    of->has_error = 1;\n                } else {\n                    of->exptime = realtime(EXPTIME_TO_POSITIVE_TIME(tmp_int));\n                    of->new_ttl = true;\n                }\n                break;\n            case 'R':\n                of->locked = 1;\n                if (!safe_strtol(tokens[i].value+1, &tmp_int)) {\n                    *errstr = \"CLIENT_ERROR bad token in command line format\";\n                    of->has_error = 1;\n                } else {\n                    of->recache_time = realtime(EXPTIME_TO_POSITIVE_TIME(tmp_int));\n                }\n                break;\n            case 'l':\n                of->la = 1;\n                of->locked = 1; // need locked to delay LRU bump\n                break;\n            case 'O':\n                break;\n            case 'k': // known but no special handling\n            case 's':\n            case 't':\n            case 'c':\n            case 'f':\n                break;\n            case 'v':\n                of->value = 1;\n                break;\n            case 'h':\n                of->locked = 1; // need locked to delay LRU bump\n                break;\n            case 'u':\n                of->no_update = 1;\n                break;\n            case 'q':\n                of->no_reply = 1;\n                break;\n            // mset-related.\n            case 'F':\n                if (!safe_strtoul(tokens[i].value+1, &of->client_flags)) {\n                    of->has_error = true;\n                }\n                break;\n            case 'S':\n                if (!safe_strtol(tokens[i].value+1, &tmp_int)) {\n                    of->has_error = true;\n                } else {\n                    // Size is adjusted for underflow or overflow once the\n                    // \\r\\n terminator is added.\n                    if (tmp_int < 0 || tmp_int > (INT_MAX - 2)) {\n                        *errstr = \"CLIENT_ERROR invalid length\";\n                        of->has_error = true;\n                    } else {\n                        of->value_len = tmp_int + 2; // \\r\\n\n                    }\n                }\n                break;\n            case 'C': // mset, mdelete, marithmetic\n                if (!safe_strtoull(tokens[i].value+1, &of->req_cas_id)) {\n                    *errstr = \"CLIENT_ERROR bad token in command line format\";\n                    of->has_error = true;\n                } else {\n                    of->has_cas = true;\n                }\n                break;\n            case 'M': // mset and marithmetic mode switch\n                if (tokens[i].length != 2) {\n                    *errstr = \"CLIENT_ERROR incorrect length for M token\";\n                    of->has_error = 1;\n                } else {\n                    of->mode = tokens[i].value[1];\n                }\n                break;\n            case 'J': // marithmetic initial value\n                if (!safe_strtoull(tokens[i].value+1, &of->initial)) {\n                    *errstr = \"CLIENT_ERROR invalid numeric initial value\";\n                    of->has_error = 1;\n                }\n                break;\n            case 'D': // marithmetic delta value\n                if (!safe_strtoull(tokens[i].value+1, &of->delta)) {\n                    *errstr = \"CLIENT_ERROR invalid numeric delta value\";\n                    of->has_error = 1;\n                }\n                break;\n            case 'I':\n                of->set_stale = 1;\n                break;\n            default: // unknown flag, bail.\n                *errstr = \"CLIENT_ERROR invalid flag\";\n                return -1;\n        }\n    }\n\n    return of->has_error ? -1 : 0;\n}\n\n#define META_SPACE(p) { \\\n    *p = ' '; \\\n    p++; \\\n}\n\n#define META_CHAR(p, c) { \\\n    *p = ' '; \\\n    *(p+1) = c; \\\n    p += 2; \\\n}\n\nstatic void process_mget_command(conn *c, token_t *tokens, const size_t ntokens) {\n    char *key;\n    size_t nkey;\n    item *it;\n    unsigned int i = 0;\n    struct _meta_flags of = {0}; // option bitflags.\n    uint32_t hv; // cached hash value for unlocking an item.\n    bool failed = false;\n    bool item_created = false;\n    bool won_token = false;\n    bool ttl_set = false;\n    char *errstr;\n    mc_resp *resp = c->resp;\n    char *p = resp->wbuf;\n\n    assert(c != NULL);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_errstring(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    // NOTE: final token has length == 0.\n    // KEY_TOKEN == 1. 0 is command.\n\n    if (ntokens == 3) {\n        // TODO: any way to fix this?\n        out_errstring(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    } else if (ntokens > MFLAG_MAX_OPT_LENGTH) {\n        // TODO: ensure the command tokenizer gives us at least this many\n        out_errstring(c, \"CLIENT_ERROR options flags are too long\");\n        return;\n    }\n\n    // scrubs duplicated options and sets flags for how to load the item.\n    if (_meta_flag_preparse(tokens, ntokens, &of, &errstr) != 0) {\n        out_errstring(c, errstr);\n        return;\n    }\n    c->noreply = of.no_reply;\n\n    // TODO: need to indicate if the item was overflowed or not?\n    // I think we do, since an overflow shouldn't trigger an alloc/replace.\n    bool overflow = false;\n    if (!of.locked) {\n        it = limited_get(key, nkey, c, 0, false, !of.no_update, &overflow);\n    } else {\n        // If we had to lock the item, we're doing our own bump later.\n        it = limited_get_locked(key, nkey, c, DONT_UPDATE, &hv, &overflow);\n    }\n\n    // Since we're a new protocol, we can actually inform users that refcount\n    // overflow is happening by straight up throwing an error.\n    // We definitely don't want to re-autovivify by accident.\n    if (overflow) {\n        assert(it == NULL);\n        out_errstring(c, \"SERVER_ERROR refcount overflow during fetch\");\n        return;\n    }\n\n    if (it == NULL && of.vivify) {\n        // Fill in the exptime during parsing later.\n        it = item_alloc(key, nkey, 0, realtime(0), 2);\n        // We don't actually need any of do_store_item's logic:\n        // - already fetched and missed an existing item.\n        // - lock is still held.\n        // - not append/prepend/replace\n        // - not testing CAS\n        if (it != NULL) {\n            // I look forward to the day I get rid of this :)\n            memcpy(ITEM_data(it), \"\\r\\n\", 2);\n            // NOTE: This initializes the CAS value.\n            do_item_link(it, hv);\n            item_created = true;\n        }\n    }\n\n    // don't have to check result of add_iov() since the iov size defaults are\n    // enough.\n    if (it) {\n        if (of.value) {\n            memcpy(p, \"VA \", 3);\n            p = itoa_u32(it->nbytes-2, p+3);\n        } else {\n            memcpy(p, \"OK\", 2);\n            p += 2;\n        }\n\n        for (i = KEY_TOKEN+1; i < ntokens-1; i++) {\n            switch (tokens[i].value[0]) {\n                case 'T':\n                    ttl_set = true;\n                    it->exptime = of.exptime;\n                    break;\n                case 'N':\n                    if (item_created) {\n                        it->exptime = of.autoviv_exptime;\n                        won_token = true;\n                    }\n                    break;\n                case 'R':\n                    // If we haven't autovivified and supplied token is less\n                    // than current TTL, mark a win.\n                    if ((it->it_flags & ITEM_TOKEN_SENT) == 0\n                            && !item_created\n                            && it->exptime != 0\n                            && it->exptime < of.recache_time) {\n                        won_token = true;\n                    }\n                    break;\n                case 's':\n                    META_CHAR(p, 's');\n                    p = itoa_u32(it->nbytes-2, p);\n                    break;\n                case 't':\n                    // TTL remaining as of this request.\n                    // needs to be relative because server clocks may not be in sync.\n                    META_CHAR(p, 't');\n                    if (it->exptime == 0) {\n                        *p = '-';\n                        *(p+1) = '1';\n                        p += 2;\n                    } else {\n                        p = itoa_u32(it->exptime - current_time, p);\n                    }\n                    break;\n                case 'c':\n                    META_CHAR(p, 'c');\n                    p = itoa_u64(ITEM_get_cas(it), p);\n                    break;\n                case 'f':\n                    META_CHAR(p, 'f');\n                    if (FLAGS_SIZE(it) == 0) {\n                        *p = '0';\n                        p++;\n                    } else {\n                        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);\n                    }\n                    break;\n                case 'l':\n                    META_CHAR(p, 'l');\n                    p = itoa_u32(current_time - it->time, p);\n                    break;\n                case 'h':\n                    META_CHAR(p, 'h');\n                    if (it->it_flags & ITEM_FETCHED) {\n                        *p = '1';\n                    } else {\n                        *p = '0';\n                    }\n                    p++;\n                    break;\n                case 'O':\n                    if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {\n                        errstr = \"CLIENT_ERROR opaque token too long\";\n                        goto error;\n                    }\n                    META_SPACE(p);\n                    memcpy(p, tokens[i].value, tokens[i].length);\n                    p += tokens[i].length;\n                    break;\n                case 'k':\n                    META_CHAR(p, 'k');\n                    memcpy(p, ITEM_key(it), it->nkey);\n                    p += it->nkey;\n                    break;\n            }\n        }\n\n        // Has this item already sent a token?\n        // Important to do this here so we don't send W with Z.\n        // Isn't critical, but easier for client authors to understand.\n        if (it->it_flags & ITEM_TOKEN_SENT) {\n            META_CHAR(p, 'Z');\n        }\n        if (it->it_flags & ITEM_STALE) {\n            META_CHAR(p, 'X');\n            // FIXME: think hard about this. is this a default, or a flag?\n            if ((it->it_flags & ITEM_TOKEN_SENT) == 0) {\n                // If we're stale but no token already sent, now send one.\n                won_token = true;\n            }\n        }\n\n        if (won_token) {\n            // Mark a win into the flag buffer.\n            META_CHAR(p, 'W');\n            it->it_flags |= ITEM_TOKEN_SENT;\n        }\n\n        *p = '\\r';\n        *(p+1) = '\\n';\n        *(p+2) = '\\0';\n        p += 2;\n        // finally, chain in the buffer.\n        resp_add_iov(resp, resp->wbuf, p - resp->wbuf);\n\n        if (of.value) {\n#ifdef EXTSTORE\n            if (it->it_flags & ITEM_HDR) {\n                if (_get_extstore(c, it, resp) != 0) {\n                    pthread_mutex_lock(&c->thread->stats.mutex);\n                    c->thread->stats.get_oom_extstore++;\n                    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n                    failed = true;\n                }\n            } else if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                resp_add_iov(resp, ITEM_data(it), it->nbytes);\n            } else {\n                resp_add_chunked_iov(resp, it, it->nbytes);\n            }\n#else\n            if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                resp_add_iov(resp, ITEM_data(it), it->nbytes);\n            } else {\n                resp_add_chunked_iov(resp, it, it->nbytes);\n            }\n#endif\n        }\n\n        // need to hold the ref at least because of the key above.\n#ifdef EXTSTORE\n        if (!failed) {\n            if ((it->it_flags & ITEM_HDR) != 0 && of.value) {\n                // Only have extstore clean if header and returning value.\n                resp->item = NULL;\n            } else {\n                resp->item = it;\n            }\n        } else {\n            // Failed to set up extstore fetch.\n            if (of.locked) {\n                do_item_remove(it);\n            } else {\n                item_remove(it);\n            }\n        }\n#else\n        resp->item = it;\n#endif\n    } else {\n        failed = true;\n    }\n\n    if (of.locked) {\n        // Delayed bump so we could get fetched/last access time pre-update.\n        if (!of.no_update && it != NULL) {\n            do_item_bump(c, it, hv);\n        }\n        item_unlock(hv);\n    }\n\n    // we count this command as a normal one if we've gotten this far.\n    // TODO: for autovivify case, miss never happens. Is this okay?\n    if (!failed) {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        if (ttl_set) {\n            c->thread->stats.touch_cmds++;\n            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;\n        } else {\n            c->thread->stats.lru_hits[it->slabs_clsid]++;\n            c->thread->stats.get_cmds++;\n        }\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        conn_set_state(c, conn_new_cmd);\n    } else {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        if (ttl_set) {\n            c->thread->stats.touch_cmds++;\n            c->thread->stats.touch_misses++;\n        } else {\n            c->thread->stats.get_misses++;\n            c->thread->stats.get_cmds++;\n        }\n        MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        // This gets elided in noreply mode.\n        out_string(c, \"EN\");\n    }\n    return;\nerror:\n    if (it) {\n        do_item_remove(it);\n        if (of.locked) {\n            item_unlock(hv);\n        }\n    }\n    out_errstring(c, errstr);\n}\n\nstatic void process_mset_command(conn *c, token_t *tokens, const size_t ntokens) {\n    char *key;\n    size_t nkey;\n    item *it;\n    int i;\n    short comm = NREAD_SET;\n    struct _meta_flags of = {0}; // option bitflags.\n    char *errstr = \"CLIENT_ERROR bad command line format\";\n    uint32_t hv;\n    mc_resp *resp = c->resp;\n    char *p = resp->wbuf;\n\n    assert(c != NULL);\n\n    // TODO: most of this is identical to mget.\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_errstring(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (ntokens == 3) {\n        out_errstring(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    if (ntokens > MFLAG_MAX_OPT_LENGTH) {\n        out_errstring(c, \"CLIENT_ERROR options flags too long\");\n        return;\n    }\n\n    // leave space for the status code.\n    p = resp->wbuf + 3;\n\n    // We need to at least try to get the size to properly slurp bad bytes\n    // after an error.\n    if (_meta_flag_preparse(tokens, ntokens, &of, &errstr) != 0) {\n        goto error;\n    }\n\n    // Set noreply after tokens are understood.\n    c->noreply = of.no_reply;\n\n    bool has_error = false;\n    for (i = KEY_TOKEN+1; i < ntokens-1; i++) {\n        switch (tokens[i].value[0]) {\n            // TODO: macro perhaps?\n            case 'O':\n                if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {\n                    errstr = \"CLIENT_ERROR opaque token too long\";\n                    has_error = true;\n                    break;\n                }\n                META_SPACE(p);\n                memcpy(p, tokens[i].value, tokens[i].length);\n                p += tokens[i].length;\n                break;\n            case 'k':\n                META_CHAR(p, 'k');\n                memcpy(p, key, nkey);\n                p += nkey;\n                break;\n        }\n    }\n\n    // \"mode switch\" to alternative commands\n    switch (of.mode) {\n        case 0:\n            break; // no mode supplied.\n        case 'E': // Add...\n            comm = NREAD_ADD;\n            break;\n        case 'A': // Append.\n            comm = NREAD_APPEND;\n            break;\n        case 'P': // Prepend.\n            comm = NREAD_PREPEND;\n            break;\n        case 'R': // Replace.\n            comm = NREAD_REPLACE;\n            break;\n        case 'S': // Set. Default.\n            comm = NREAD_SET;\n            break;\n        default:\n            errstr = \"CLIENT_ERROR invalid mode for ms M token\";\n            goto error;\n    }\n\n    // The item storage function doesn't exactly map to mset.\n    // If a CAS value is supplied, upgrade default SET mode to CAS mode.\n    // Also allows REPLACE to work, as REPLACE + CAS works the same as CAS.\n    // add-with-cas works the same as add; but could only LRU bump if match..\n    // APPEND/PREPEND allow a simplified CAS check.\n    if (of.has_cas && (comm == NREAD_SET || comm == NREAD_REPLACE)) {\n        comm = NREAD_CAS;\n    }\n\n    // We attempt to process as much as we can in hopes of getting a valid and\n    // adjusted vlen, or else the data swallowed after error will be for 0b.\n    if (has_error)\n        goto error;\n\n    it = item_alloc(key, nkey, of.client_flags, of.exptime, of.value_len);\n\n    if (it == 0) {\n        enum store_item_type status;\n        // TODO: These could be normalized codes (TL and OM). Need to\n        // reorganize the output stuff a bit though.\n        if (! item_size_ok(nkey, of.client_flags, of.value_len)) {\n            errstr = \"SERVER_ERROR object too large for cache\";\n            status = TOO_LARGE;\n        } else {\n            errstr = \"SERVER_ERROR out of memory storing object\";\n            status = NO_MEMORY;\n        }\n        // FIXME: LOGGER_LOG specific to mset, include options.\n        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,\n                NULL, status, comm, key, nkey, 0, 0);\n\n        /* Avoid stale data persisting in cache because we failed alloc. */\n        // NOTE: only if SET mode?\n        it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);\n        if (it) {\n            do_item_unlink(it, hv);\n            STORAGE_delete(c->thread->storage, it);\n            do_item_remove(it);\n        }\n        item_unlock(hv);\n\n        goto error;\n    }\n    ITEM_set_cas(it, of.req_cas_id);\n\n    c->item = it;\n#ifdef NEED_ALIGN\n    if (it->it_flags & ITEM_CHUNKED) {\n        c->ritem = ITEM_schunk(it);\n    } else {\n        c->ritem = ITEM_data(it);\n    }\n#else\n    c->ritem = ITEM_data(it);\n#endif\n    c->rlbytes = it->nbytes;\n    c->cmd = comm;\n    if (of.set_stale && comm == NREAD_CAS) {\n        c->set_stale = true;\n    }\n    resp->wbytes = p - resp->wbuf;\n    memcpy(resp->wbuf + resp->wbytes, \"\\r\\n\", 2);\n    resp->wbytes += 2;\n    // We've written the status line into wbuf, use wbytes to finalize later.\n    resp_add_iov(resp, resp->wbuf, resp->wbytes);\n    c->mset_res = true;\n    conn_set_state(c, conn_nread);\n    return;\nerror:\n    /* swallow the data line */\n    c->sbytes = of.value_len;\n\n    // Note: no errors possible after the item was successfully allocated.\n    // So we're just looking at dumping error codes and returning.\n    out_errstring(c, errstr);\n    // TODO: pass state in? else switching twice meh.\n    conn_set_state(c, conn_swallow);\n}\n\nstatic void process_mdelete_command(conn *c, token_t *tokens, const size_t ntokens) {\n    char *key;\n    size_t nkey;\n    uint64_t req_cas_id = 0;\n    item *it = NULL;\n    int i;\n    uint32_t hv;\n    struct _meta_flags of = {0}; // option bitflags.\n    char *errstr = \"CLIENT_ERROR bad command line format\";\n    mc_resp *resp = c->resp;\n    // reserve 3 bytes for status code\n    char *p = resp->wbuf + 3;\n\n    assert(c != NULL);\n\n    // TODO: most of this is identical to mget.\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (ntokens > MFLAG_MAX_OPT_LENGTH) {\n        out_string(c, \"CLIENT_ERROR options flags too long\");\n        return;\n    }\n\n    // scrubs duplicated options and sets flags for how to load the item.\n    if (_meta_flag_preparse(tokens, ntokens, &of, &errstr) != 0) {\n        out_errstring(c, \"CLIENT_ERROR invalid or duplicate flag\");\n        return;\n    }\n    c->noreply = of.no_reply;\n\n    assert(c != NULL);\n    for (i = KEY_TOKEN+1; i < ntokens-1; i++) {\n        switch (tokens[i].value[0]) {\n            // TODO: macro perhaps?\n            case 'O':\n                if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {\n                    errstr = \"CLIENT_ERROR opaque token too long\";\n                    goto error;\n                }\n                META_SPACE(p);\n                memcpy(p, tokens[i].value, tokens[i].length);\n                p += tokens[i].length;\n                break;\n            case 'k':\n                META_CHAR(p, 'k');\n                memcpy(p, key, nkey);\n                p += nkey;\n                break;\n        }\n    }\n\n    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);\n    if (it) {\n        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);\n\n        // allow only deleting/marking if a CAS value matches.\n        if (of.has_cas && ITEM_get_cas(it) != req_cas_id) {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.delete_misses++;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n\n            memcpy(resp->wbuf, \"EX \", 3);\n            goto cleanup;\n        }\n\n        // If we're to set this item as stale, we don't actually want to\n        // delete it. We mark the stale bit, bump CAS, and update exptime if\n        // we were supplied a new TTL.\n        if (of.set_stale) {\n            if (of.new_ttl) {\n                it->exptime = of.exptime;\n            }\n            it->it_flags |= ITEM_STALE;\n            // Also need to remove TOKEN_SENT, so next client can win.\n            it->it_flags &= ~ITEM_TOKEN_SENT;\n\n            ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);\n\n            // Clients can noreply nominal responses.\n            if (c->noreply)\n                resp->skip = true;\n            memcpy(resp->wbuf, \"OK \", 3);\n        } else {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n\n            do_item_unlink(it, hv);\n            STORAGE_delete(c->thread->storage, it);\n            if (c->noreply)\n                resp->skip = true;\n            memcpy(resp->wbuf, \"OK \", 3);\n        }\n        goto cleanup;\n    } else {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.delete_misses++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        memcpy(resp->wbuf, \"NF \", 3);\n        goto cleanup;\n    }\ncleanup:\n    if (it) {\n        do_item_remove(it);\n    }\n    // Item is always returned locked, even if missing.\n    item_unlock(hv);\n    resp->wbytes = p - resp->wbuf;\n    memcpy(resp->wbuf + resp->wbytes, \"\\r\\n\", 2);\n    resp->wbytes += 2;\n    resp_add_iov(resp, resp->wbuf, resp->wbytes);\n    conn_set_state(c, conn_new_cmd);\n    return;\nerror:\n    out_errstring(c, errstr);\n}\n\nstatic void process_marithmetic_command(conn *c, token_t *tokens, const size_t ntokens) {\n    char *key;\n    size_t nkey;\n    int i;\n    struct _meta_flags of = {0}; // option bitflags.\n    char *errstr = \"CLIENT_ERROR bad command line format\";\n    mc_resp *resp = c->resp;\n    // no reservation (like del/set) since we post-process the status line.\n    char *p = resp->wbuf;\n\n    // If no argument supplied, incr or decr by one.\n    of.delta = 1;\n    of.initial = 0; // redundant, for clarity.\n    bool incr = true; // default mode is to increment.\n    bool locked = false;\n    uint32_t hv = 0;\n    item *it = NULL; // item returned by do_add_delta.\n\n    assert(c != NULL);\n\n    // TODO: most of this is identical to mget.\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (ntokens > MFLAG_MAX_OPT_LENGTH) {\n        out_string(c, \"CLIENT_ERROR options flags too long\");\n        return;\n    }\n\n    // scrubs duplicated options and sets flags for how to load the item.\n    if (_meta_flag_preparse(tokens, ntokens, &of, &errstr) != 0) {\n        out_errstring(c, \"CLIENT_ERROR invalid or duplicate flag\");\n        return;\n    }\n    c->noreply = of.no_reply;\n\n    assert(c != NULL);\n    // \"mode switch\" to alternative commands\n    switch (of.mode) {\n        case 0: // no switch supplied.\n            break;\n        case 'I': // Incr (default)\n        case '+':\n            incr = true;\n            break;\n        case 'D': // Decr.\n        case '-':\n            incr = false;\n            break;\n        default:\n            errstr = \"CLIENT_ERROR invalid mode for ma M token\";\n            goto error;\n            break;\n    }\n\n    // take hash value and manually lock item... hold lock during store phase\n    // on miss and avoid recalculating the hash multiple times.\n    hv = hash(key, nkey);\n    item_lock(hv);\n    locked = true;\n    char tmpbuf[INCR_MAX_STORAGE_LEN];\n\n    // return a referenced item if it exists, so we can modify it here, rather\n    // than adding even more parameters to do_add_delta.\n    bool item_created = false;\n    switch(do_add_delta(c, key, nkey, incr, of.delta, tmpbuf, &of.req_cas_id, hv, &it)) {\n    case OK:\n        if (c->noreply)\n            resp->skip = true;\n        memcpy(resp->wbuf, \"OK \", 3);\n        break;\n    case NON_NUMERIC:\n        errstr = \"CLIENT_ERROR cannot increment or decrement non-numeric value\";\n        goto error;\n        break;\n    case EOM:\n        errstr = \"SERVER_ERROR out of memory\";\n        goto error;\n        break;\n    case DELTA_ITEM_NOT_FOUND:\n        if (of.vivify) {\n            itoa_u64(of.initial, tmpbuf);\n            int vlen = strlen(tmpbuf);\n\n            it = item_alloc(key, nkey, 0, 0, vlen+2);\n            if (it != NULL) {\n                memcpy(ITEM_data(it), tmpbuf, vlen);\n                memcpy(ITEM_data(it) + vlen, \"\\r\\n\", 2);\n                if (do_store_item(it, NREAD_ADD, c, hv)) {\n                    item_created = true;\n                } else {\n                    // Not sure how we can get here if we're holding the lock.\n                    memcpy(resp->wbuf, \"NS \", 3);\n                }\n            } else {\n                errstr = \"SERVER_ERROR Out of memory allocating new item\";\n                goto error;\n            }\n        } else {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            if (incr) {\n                c->thread->stats.incr_misses++;\n            } else {\n                c->thread->stats.decr_misses++;\n            }\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n            // won't have a valid it here.\n            memcpy(p, \"NF \", 3);\n            p += 3;\n        }\n        break;\n    case DELTA_ITEM_CAS_MISMATCH:\n        // also returns without a valid it.\n        memcpy(p, \"EX \", 3);\n        p += 3;\n        break;\n    }\n\n    // final loop\n    // allows building the response with information after vivifying from a\n    // miss, or returning a new CAS value after add_delta().\n    if (it) {\n        size_t vlen = strlen(tmpbuf);\n        if (of.value) {\n            memcpy(p, \"VA \", 3);\n            p = itoa_u32(vlen, p+3);\n        } else {\n            memcpy(p, \"OK\", 2);\n            p += 2;\n        }\n\n        for (i = KEY_TOKEN+1; i < ntokens-1; i++) {\n            switch (tokens[i].value[0]) {\n                case 'c':\n                    META_CHAR(p, 'c');\n                    p = itoa_u64(ITEM_get_cas(it), p);\n                    break;\n                case 't':\n                    META_CHAR(p, 't');\n                    if (it->exptime == 0) {\n                        *p = '-';\n                        *(p+1) = '1';\n                        p += 2;\n                    } else {\n                        p = itoa_u32(it->exptime - current_time, p);\n                    }\n                    break;\n                case 'T':\n                    it->exptime = of.exptime;\n                    break;\n                case 'N':\n                    if (item_created) {\n                        it->exptime = of.autoviv_exptime;\n                    }\n                    break;\n                // TODO: macro perhaps?\n                case 'O':\n                    if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {\n                        errstr = \"CLIENT_ERROR opaque token too long\";\n                        goto error;\n                    }\n                    META_SPACE(p);\n                    memcpy(p, tokens[i].value, tokens[i].length);\n                    p += tokens[i].length;\n                    break;\n                case 'k':\n                    META_CHAR(p, 'k');\n                    memcpy(p, key, nkey);\n                    p += nkey;\n                    break;\n            }\n        }\n\n        if (of.value) {\n            *p = '\\r';\n            *(p+1) = '\\n';\n            p += 2;\n            memcpy(p, tmpbuf, vlen);\n            p += vlen;\n        }\n\n        do_item_remove(it);\n    } else {\n        // No item to handle. still need to return opaque/key tokens\n        for (i = KEY_TOKEN+1; i < ntokens-1; i++) {\n            switch (tokens[i].value[0]) {\n                // TODO: macro perhaps?\n                case 'O':\n                    if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {\n                        errstr = \"CLIENT_ERROR opaque token too long\";\n                        goto error;\n                    }\n                    META_SPACE(p);\n                    memcpy(p, tokens[i].value, tokens[i].length);\n                    p += tokens[i].length;\n                    break;\n                case 'k':\n                    META_CHAR(p, 'k');\n                    memcpy(p, key, nkey);\n                    p += nkey;\n                    break;\n            }\n        }\n    }\n\n    item_unlock(hv);\n\n    resp->wbytes = p - resp->wbuf;\n    memcpy(resp->wbuf + resp->wbytes, \"\\r\\n\", 2);\n    resp->wbytes += 2;\n    resp_add_iov(resp, resp->wbuf, resp->wbytes);\n    conn_set_state(c, conn_new_cmd);\n    return;\nerror:\n    if (it != NULL)\n        do_item_remove(it);\n    if (locked)\n        item_unlock(hv);\n    out_errstring(c, errstr);\n}\n\n\nstatic void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {\n    char *key;\n    size_t nkey;\n    unsigned int flags;\n    int32_t exptime_int = 0;\n    rel_time_t exptime = 0;\n    int vlen;\n    uint64_t req_cas_id=0;\n    item *it;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)\n           && safe_strtol(tokens[3].value, &exptime_int)\n           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));\n\n    // does cas value exist?\n    if (handle_cas) {\n        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n    }\n\n    if (vlen < 0 || vlen > (INT_MAX - 2)) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n    vlen += 2;\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    it = item_alloc(key, nkey, flags, exptime, vlen);\n\n    if (it == 0) {\n        enum store_item_type status;\n        if (! item_size_ok(nkey, flags, vlen)) {\n            out_string(c, \"SERVER_ERROR object too large for cache\");\n            status = TOO_LARGE;\n        } else {\n            out_of_memory(c, \"SERVER_ERROR out of memory storing object\");\n            status = NO_MEMORY;\n        }\n        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,\n                NULL, status, comm, key, nkey, 0, 0, c->sfd);\n        /* swallow the data line */\n        conn_set_state(c, conn_swallow);\n        c->sbytes = vlen;\n\n        /* Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET. Anywhere else too? */\n        if (comm == NREAD_SET) {\n            it = item_get(key, nkey, c, DONT_UPDATE);\n            if (it) {\n                item_unlink(it);\n                STORAGE_delete(c->thread->storage, it);\n                item_remove(it);\n            }\n        }\n\n        return;\n    }\n    ITEM_set_cas(it, req_cas_id);\n\n    c->item = it;\n#ifdef NEED_ALIGN\n    if (it->it_flags & ITEM_CHUNKED) {\n        c->ritem = ITEM_schunk(it);\n    } else {\n        c->ritem = ITEM_data(it);\n    }\n#else\n    c->ritem = ITEM_data(it);\n#endif\n    c->rlbytes = it->nbytes;\n    c->cmd = comm;\n    conn_set_state(c, conn_nread);\n}\n\nstatic void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {\n    char *key;\n    size_t nkey;\n    int32_t exptime_int = 0;\n    rel_time_t exptime = 0;\n    item *it;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (!safe_strtol(tokens[2].value, &exptime_int)) {\n        out_string(c, \"CLIENT_ERROR invalid exptime argument\");\n        return;\n    }\n\n    exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));\n    it = item_touch(key, nkey, exptime, c);\n    if (it) {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.touch_cmds++;\n        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        out_string(c, \"TOUCHED\");\n        item_remove(it);\n    } else {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.touch_cmds++;\n        c->thread->stats.touch_misses++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        out_string(c, \"NOT_FOUND\");\n    }\n}\n\nstatic void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {\n    char temp[INCR_MAX_STORAGE_LEN];\n    uint64_t delta;\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (!safe_strtoull(tokens[2].value, &delta)) {\n        out_string(c, \"CLIENT_ERROR invalid numeric delta argument\");\n        return;\n    }\n\n    switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {\n    case OK:\n        out_string(c, temp);\n        break;\n    case NON_NUMERIC:\n        out_string(c, \"CLIENT_ERROR cannot increment or decrement non-numeric value\");\n        break;\n    case EOM:\n        out_of_memory(c, \"SERVER_ERROR out of memory\");\n        break;\n    case DELTA_ITEM_NOT_FOUND:\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        if (incr) {\n            c->thread->stats.incr_misses++;\n        } else {\n            c->thread->stats.decr_misses++;\n        }\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        out_string(c, \"NOT_FOUND\");\n        break;\n    case DELTA_ITEM_CAS_MISMATCH:\n        break; /* Should never get here */\n    }\n}\n\n/*\n * adds a delta value to a numeric item.\n *\n * c     connection requesting the operation\n * it    item to adjust\n * incr  true to increment value, false to decrement\n * delta amount to adjust value by\n * buf   buffer for response string\n *\n * returns a response string to send back to the client.\n */\nenum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,\n                                    const bool incr, const int64_t delta,\n                                    char *buf, uint64_t *cas,\n                                    const uint32_t hv,\n                                    item **it_ret) {\n    char *ptr;\n    uint64_t value;\n    int res;\n    item *it;\n\n    it = do_item_get(key, nkey, hv, c, DONT_UPDATE);\n    if (!it) {\n        return DELTA_ITEM_NOT_FOUND;\n    }\n\n    /* Can't delta zero byte values. 2-byte are the \"\\r\\n\" */\n    /* Also can't delta for chunked items. Too large to be a number */\n#ifdef EXTSTORE\n    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {\n#else\n    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) != 0) {\n#endif\n        do_item_remove(it);\n        return NON_NUMERIC;\n    }\n\n    if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {\n        do_item_remove(it);\n        return DELTA_ITEM_CAS_MISMATCH;\n    }\n\n    ptr = ITEM_data(it);\n\n    if (!safe_strtoull(ptr, &value)) {\n        do_item_remove(it);\n        return NON_NUMERIC;\n    }\n\n    if (incr) {\n        value += delta;\n        MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);\n    } else {\n        if(delta > value) {\n            value = 0;\n        } else {\n            value -= delta;\n        }\n        MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);\n    }\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    if (incr) {\n        c->thread->stats.slab_stats[ITEM_clsid(it)].incr_hits++;\n    } else {\n        c->thread->stats.slab_stats[ITEM_clsid(it)].decr_hits++;\n    }\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    itoa_u64(value, buf);\n    res = strlen(buf);\n    /* refcount == 2 means we are the only ones holding the item, and it is\n     * linked. We hold the item's lock in this function, so refcount cannot\n     * increase. */\n    if (res + 2 <= it->nbytes && it->refcount == 2) { /* replace in-place */\n        /* When changing the value without replacing the item, we\n           need to update the CAS on the existing item. */\n        /* We also need to fiddle it in the sizes tracker in case the tracking\n         * was enabled at runtime, since it relies on the CAS value to know\n         * whether to remove an item or not. */\n        item_stats_sizes_remove(it);\n        ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);\n        item_stats_sizes_add(it);\n        memcpy(ITEM_data(it), buf, res);\n        memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);\n        do_item_update(it);\n    } else if (it->refcount > 1) {\n        item *new_it;\n        uint32_t flags;\n        FLAGS_CONV(it, flags);\n        new_it = do_item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, res + 2);\n        if (new_it == 0) {\n            do_item_remove(it);\n            return EOM;\n        }\n        memcpy(ITEM_data(new_it), buf, res);\n        memcpy(ITEM_data(new_it) + res, \"\\r\\n\", 2);\n        item_replace(it, new_it, hv);\n        // Overwrite the older item's CAS with our new CAS since we're\n        // returning the CAS of the old item below.\n        ITEM_set_cas(it, (settings.use_cas) ? ITEM_get_cas(new_it) : 0);\n        do_item_remove(new_it);       /* release our reference */\n    } else {\n        /* Should never get here. This means we somehow fetched an unlinked\n         * item. TODO: Add a counter? */\n        if (settings.verbose) {\n            fprintf(stderr, \"Tried to do incr/decr on invalid item\\n\");\n        }\n        if (it->refcount == 1)\n            do_item_remove(it);\n        return DELTA_ITEM_NOT_FOUND;\n    }\n\n    if (cas) {\n        *cas = ITEM_get_cas(it);    /* swap the incoming CAS value */\n    }\n    if (it_ret != NULL) {\n        *it_ret = it;\n    } else {\n        do_item_remove(it);         /* release our reference */\n    }\n    return OK;\n}\n\nstatic void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {\n    char *key;\n    size_t nkey;\n    item *it;\n    uint32_t hv;\n\n    assert(c != NULL);\n\n    if (ntokens > 3) {\n        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, \"0\") == 0;\n        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);\n        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))\n            || (ntokens == 5 && hold_is_zero && sets_noreply);\n        if (!valid) {\n            out_string(c, \"CLIENT_ERROR bad command line format.  \"\n                       \"Usage: delete <key> [noreply]\");\n            return;\n        }\n    }\n\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if(nkey > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_delete(key, nkey);\n    }\n\n    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);\n    if (it) {\n        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        do_item_unlink(it, hv);\n        STORAGE_delete(c->thread->storage, it);\n        do_item_remove(it);      /* release our reference */\n        out_string(c, \"DELETED\");\n    } else {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.delete_misses++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        out_string(c, \"NOT_FOUND\");\n    }\n    item_unlock(hv);\n}\n\nstatic void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {\n    unsigned int level;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    level = strtoul(tokens[1].value, NULL, 10);\n    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;\n    out_string(c, \"OK\");\n    return;\n}\n\n#ifdef MEMCACHED_DEBUG\nstatic void process_misbehave_command(conn *c) {\n    int allowed = 0;\n\n    // try opening new TCP socket\n    int i = socket(AF_INET, SOCK_STREAM, 0);\n    if (i != -1) {\n        allowed++;\n        close(i);\n    }\n\n    // try executing new commands\n    i = system(\"sleep 0\");\n    if (i != -1) {\n        allowed++;\n    }\n\n    if (allowed) {\n        out_string(c, \"ERROR\");\n    } else {\n        out_string(c, \"OK\");\n    }\n}\n#endif\n\nstatic void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {\n    unsigned int level;\n    double ratio;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (strcmp(tokens[2].value, \"ratio\") == 0) {\n        if (ntokens < 5 || !safe_strtod(tokens[3].value, &ratio)) {\n            out_string(c, \"ERROR\");\n            return;\n        }\n        settings.slab_automove_ratio = ratio;\n    } else {\n        level = strtoul(tokens[2].value, NULL, 10);\n        if (level == 0) {\n            settings.slab_automove = 0;\n        } else if (level == 1 || level == 2) {\n            settings.slab_automove = level;\n        } else {\n            out_string(c, \"ERROR\");\n            return;\n        }\n    }\n    out_string(c, \"OK\");\n    return;\n}\n\n/* TODO: decide on syntax for sampling? */\nstatic void process_watch_command(conn *c, token_t *tokens, const size_t ntokens) {\n    uint16_t f = 0;\n    int x;\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n    if (!settings.watch_enabled) {\n        out_string(c, \"CLIENT_ERROR watch commands not allowed\");\n        return;\n    }\n\n    if (ntokens > 2) {\n        for (x = COMMAND_TOKEN + 1; x < ntokens - 1; x++) {\n            if ((strcmp(tokens[x].value, \"rawcmds\") == 0)) {\n                f |= LOG_RAWCMDS;\n            } else if ((strcmp(tokens[x].value, \"evictions\") == 0)) {\n                f |= LOG_EVICTIONS;\n            } else if ((strcmp(tokens[x].value, \"fetchers\") == 0)) {\n                f |= LOG_FETCHERS;\n            } else if ((strcmp(tokens[x].value, \"mutations\") == 0)) {\n                f |= LOG_MUTATIONS;\n            } else if ((strcmp(tokens[x].value, \"sysevents\") == 0)) {\n                f |= LOG_SYSEVENTS;\n            } else {\n                out_string(c, \"ERROR\");\n                return;\n            }\n        }\n    } else {\n        f |= LOG_FETCHERS;\n    }\n\n    switch(logger_add_watcher(c, c->sfd, f)) {\n        case LOGGER_ADD_WATCHER_TOO_MANY:\n            out_string(c, \"WATCHER_TOO_MANY log watcher limit reached\");\n            break;\n        case LOGGER_ADD_WATCHER_FAILED:\n            out_string(c, \"WATCHER_FAILED failed to add log watcher\");\n            break;\n        case LOGGER_ADD_WATCHER_OK:\n            conn_set_state(c, conn_watch);\n            event_del(&c->event);\n            break;\n    }\n}\n\nstatic void process_memlimit_command(conn *c, token_t *tokens, const size_t ntokens) {\n    uint32_t memlimit;\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (!safe_strtoul(tokens[1].value, &memlimit)) {\n        out_string(c, \"ERROR\");\n    } else {\n        if (memlimit < 8) {\n            out_string(c, \"MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m\");\n        } else {\n            if (memlimit > 1000000000) {\n                out_string(c, \"MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes\");\n            } else if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {\n                if (settings.verbose > 0) {\n                    fprintf(stderr, \"maxbytes adjusted to %llum\\n\", (unsigned long long)memlimit);\n                }\n\n                out_string(c, \"OK\");\n            } else {\n                out_string(c, \"MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust\");\n            }\n        }\n    }\n}\n\nstatic void process_lru_command(conn *c, token_t *tokens, const size_t ntokens) {\n    uint32_t pct_hot;\n    uint32_t pct_warm;\n    double hot_factor;\n    int32_t ttl;\n    double factor;\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (strcmp(tokens[1].value, \"tune\") == 0 && ntokens >= 7) {\n        if (!safe_strtoul(tokens[2].value, &pct_hot) ||\n            !safe_strtoul(tokens[3].value, &pct_warm) ||\n            !safe_strtod(tokens[4].value, &hot_factor) ||\n            !safe_strtod(tokens[5].value, &factor)) {\n            out_string(c, \"ERROR\");\n        } else {\n            if (pct_hot + pct_warm > 80) {\n                out_string(c, \"ERROR hot and warm pcts must not exceed 80\");\n            } else if (factor <= 0 || hot_factor <= 0) {\n                out_string(c, \"ERROR hot/warm age factors must be greater than 0\");\n            } else {\n                settings.hot_lru_pct = pct_hot;\n                settings.warm_lru_pct = pct_warm;\n                settings.hot_max_factor = hot_factor;\n                settings.warm_max_factor = factor;\n                out_string(c, \"OK\");\n            }\n        }\n    } else if (strcmp(tokens[1].value, \"mode\") == 0 && ntokens >= 4 &&\n               settings.lru_maintainer_thread) {\n        if (strcmp(tokens[2].value, \"flat\") == 0) {\n            settings.lru_segmented = false;\n            out_string(c, \"OK\");\n        } else if (strcmp(tokens[2].value, \"segmented\") == 0) {\n            settings.lru_segmented = true;\n            out_string(c, \"OK\");\n        } else {\n            out_string(c, \"ERROR\");\n        }\n    } else if (strcmp(tokens[1].value, \"temp_ttl\") == 0 && ntokens >= 4 &&\n               settings.lru_maintainer_thread) {\n        if (!safe_strtol(tokens[2].value, &ttl)) {\n            out_string(c, \"ERROR\");\n        } else {\n            if (ttl < 0) {\n                settings.temp_lru = false;\n            } else {\n                settings.temp_lru = true;\n                settings.temporary_ttl = ttl;\n            }\n            out_string(c, \"OK\");\n        }\n    } else {\n        out_string(c, \"ERROR\");\n    }\n}\n#ifdef EXTSTORE\nstatic void process_extstore_command(conn *c, token_t *tokens, const size_t ntokens) {\n    set_noreply_maybe(c, tokens, ntokens);\n    bool ok = true;\n    if (ntokens < 4) {\n        ok = false;\n    } else if (strcmp(tokens[1].value, \"free_memchunks\") == 0 && ntokens > 4) {\n        /* per-slab-class free chunk setting. */\n        unsigned int clsid = 0;\n        unsigned int limit = 0;\n        if (!safe_strtoul(tokens[2].value, &clsid) ||\n                !safe_strtoul(tokens[3].value, &limit)) {\n            ok = false;\n        } else {\n            if (clsid < MAX_NUMBER_OF_SLAB_CLASSES) {\n                settings.ext_free_memchunks[clsid] = limit;\n            } else {\n                ok = false;\n            }\n        }\n    } else if (strcmp(tokens[1].value, \"item_size\") == 0) {\n        if (!safe_strtoul(tokens[2].value, &settings.ext_item_size))\n            ok = false;\n    } else if (strcmp(tokens[1].value, \"item_age\") == 0) {\n        if (!safe_strtoul(tokens[2].value, &settings.ext_item_age))\n            ok = false;\n    } else if (strcmp(tokens[1].value, \"low_ttl\") == 0) {\n        if (!safe_strtoul(tokens[2].value, &settings.ext_low_ttl))\n            ok = false;\n    } else if (strcmp(tokens[1].value, \"recache_rate\") == 0) {\n        if (!safe_strtoul(tokens[2].value, &settings.ext_recache_rate))\n            ok = false;\n    } else if (strcmp(tokens[1].value, \"compact_under\") == 0) {\n        if (!safe_strtoul(tokens[2].value, &settings.ext_compact_under))\n            ok = false;\n    } else if (strcmp(tokens[1].value, \"drop_under\") == 0) {\n        if (!safe_strtoul(tokens[2].value, &settings.ext_drop_under))\n            ok = false;\n    } else if (strcmp(tokens[1].value, \"max_frag\") == 0) {\n        if (!safe_strtod(tokens[2].value, &settings.ext_max_frag))\n            ok = false;\n    } else if (strcmp(tokens[1].value, \"drop_unread\") == 0) {\n        unsigned int v;\n        if (!safe_strtoul(tokens[2].value, &v)) {\n            ok = false;\n        } else {\n            settings.ext_drop_unread = v == 0 ? false : true;\n        }\n    } else {\n        ok = false;\n    }\n    if (!ok) {\n        out_string(c, \"ERROR\");\n    } else {\n        out_string(c, \"OK\");\n    }\n}\n#endif\n// TODO: pipelined commands are incompatible with shifting connections to a\n// side thread. Given this only happens in two instances (watch and\n// lru_crawler metadump) it should be fine for things to bail. It _should_ be\n// unusual for these commands.\n// This is hard to fix since tokenize_command() mutilates the read buffer, so\n// we can't drop out and back in again.\n// Leaving this note here to spend more time on a fix when necessary, or if an\n// opportunity becomes obvious.\nstatic void process_command(conn *c, char *command) {\n\n    token_t tokens[MAX_TOKENS];\n    size_t ntokens;\n    int comm;\n\n    assert(c != NULL);\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"<%d %s\\n\", c->sfd, command);\n\n    /*\n     * for commands set/add/replace, we build an item and read the data\n     * directly into it, then continue in nread_complete().\n     */\n\n    // Prep the response object for this query.\n    if (!resp_start(c)) {\n        conn_set_state(c, conn_closing);\n        return;\n    }\n\n    ntokens = tokenize_command(command, tokens, MAX_TOKENS);\n    if (ntokens >= 3 &&\n        ((strcmp(tokens[COMMAND_TOKEN].value, \"get\") == 0) ||\n         (strcmp(tokens[COMMAND_TOKEN].value, \"bget\") == 0))) {\n\n        process_get_command(c, tokens, ntokens, false, false);\n\n    } else if ((ntokens == 6 || ntokens == 7) &&\n               ((strcmp(tokens[COMMAND_TOKEN].value, \"add\") == 0 && (comm = NREAD_ADD)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"set\") == 0 && (comm = NREAD_SET)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"replace\") == 0 && (comm = NREAD_REPLACE)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"prepend\") == 0 && (comm = NREAD_PREPEND)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"append\") == 0 && (comm = NREAD_APPEND)) )) {\n\n        process_update_command(c, tokens, ntokens, comm, false);\n\n    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, \"cas\") == 0 && (comm = NREAD_CAS))) {\n\n        process_update_command(c, tokens, ntokens, comm, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"incr\") == 0)) {\n\n        process_arithmetic_command(c, tokens, ntokens, 1);\n\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"gets\") == 0)) {\n\n        process_get_command(c, tokens, ntokens, true, false);\n\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"mg\") == 0)) {\n        process_mget_command(c, tokens, ntokens);\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"ms\") == 0)) {\n        process_mset_command(c, tokens, ntokens);\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"md\") == 0)) {\n        process_mdelete_command(c, tokens, ntokens);\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"mn\") == 0)) {\n        out_string(c, \"MN\");\n        // mn command forces immediate writeback flush.\n        conn_set_state(c, conn_mwrite);\n        return;\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"ma\") == 0)) {\n        process_marithmetic_command(c, tokens, ntokens);\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"me\") == 0)) {\n        process_meta_command(c, tokens, ntokens);\n        return;\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"decr\") == 0)) {\n\n        process_arithmetic_command(c, tokens, ntokens, 0);\n\n    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, \"delete\") == 0)) {\n\n        process_delete_command(c, tokens, ntokens);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"touch\") == 0)) {\n\n        process_touch_command(c, tokens, ntokens);\n\n    } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"gat\") == 0)) {\n\n        process_get_command(c, tokens, ntokens, false, true);\n\n    } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"gats\") == 0)) {\n\n        process_get_command(c, tokens, ntokens, true, true);\n\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"stats\") == 0)) {\n\n        process_stat(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"flush_all\") == 0)) {\n        time_t exptime = 0;\n        rel_time_t new_oldest = 0;\n\n        set_noreply_maybe(c, tokens, ntokens);\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.flush_cmds++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        if (!settings.flush_enabled) {\n            // flush_all is not allowed but we log it on stats\n            out_string(c, \"CLIENT_ERROR flush_all not allowed\");\n            return;\n        }\n\n        if (ntokens != (c->noreply ? 3 : 2)) {\n            exptime = strtol(tokens[1].value, NULL, 10);\n            if(errno == ERANGE) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return;\n            }\n        }\n\n        /*\n          If exptime is zero realtime() would return zero too, and\n          realtime(exptime) - 1 would overflow to the max unsigned\n          value.  So we process exptime == 0 the same way we do when\n          no delay is given at all.\n        */\n        if (exptime > 0) {\n            new_oldest = realtime(exptime);\n        } else { /* exptime == 0 */\n            new_oldest = current_time;\n        }\n\n        if (settings.use_cas) {\n            settings.oldest_live = new_oldest - 1;\n            if (settings.oldest_live <= current_time)\n                settings.oldest_cas = get_cas_id();\n        } else {\n            settings.oldest_live = new_oldest;\n        }\n        out_string(c, \"OK\");\n        return;\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"version\") == 0)) {\n\n        out_string(c, \"VERSION \" VERSION);\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"quit\") == 0)) {\n\n        conn_set_state(c, conn_mwrite);\n        c->close_after_write = true;\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"shutdown\") == 0)) {\n\n        if (settings.shutdown_command) {\n            conn_set_state(c, conn_closing);\n            raise(SIGINT);\n        } else {\n            out_string(c, \"ERROR: shutdown not enabled\");\n        }\n\n    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, \"slabs\") == 0) {\n        if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, \"reassign\") == 0) {\n            int src, dst, rv;\n\n            if (settings.slab_reassign == false) {\n                out_string(c, \"CLIENT_ERROR slab reassignment disabled\");\n                return;\n            }\n\n            src = strtol(tokens[2].value, NULL, 10);\n            dst = strtol(tokens[3].value, NULL, 10);\n\n            if (errno == ERANGE) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return;\n            }\n\n            rv = slabs_reassign(src, dst);\n            switch (rv) {\n            case REASSIGN_OK:\n                out_string(c, \"OK\");\n                break;\n            case REASSIGN_RUNNING:\n                out_string(c, \"BUSY currently processing reassign request\");\n                break;\n            case REASSIGN_BADCLASS:\n                out_string(c, \"BADCLASS invalid src or dst class id\");\n                break;\n            case REASSIGN_NOSPARE:\n                out_string(c, \"NOSPARE source class has no spare pages\");\n                break;\n            case REASSIGN_SRC_DST_SAME:\n                out_string(c, \"SAME src and dst class are identical\");\n                break;\n            }\n            return;\n        } else if (ntokens >= 4 &&\n            (strcmp(tokens[COMMAND_TOKEN + 1].value, \"automove\") == 0)) {\n            process_slabs_automove_command(c, tokens, ntokens);\n        } else {\n            out_string(c, \"ERROR\");\n        }\n    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, \"lru_crawler\") == 0) {\n        if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, \"crawl\") == 0) {\n            int rv;\n            if (settings.lru_crawler == false) {\n                out_string(c, \"CLIENT_ERROR lru crawler disabled\");\n                return;\n            }\n\n            rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0,\n                    settings.lru_crawler_tocrawl);\n            switch(rv) {\n            case CRAWLER_OK:\n                out_string(c, \"OK\");\n                break;\n            case CRAWLER_RUNNING:\n                out_string(c, \"BUSY currently processing crawler request\");\n                break;\n            case CRAWLER_BADCLASS:\n                out_string(c, \"BADCLASS invalid class id\");\n                break;\n            case CRAWLER_NOTSTARTED:\n                out_string(c, \"NOTSTARTED no items to crawl\");\n                break;\n            case CRAWLER_ERROR:\n                out_string(c, \"ERROR an unknown error happened\");\n                break;\n            }\n            return;\n        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, \"metadump\") == 0) {\n            if (settings.lru_crawler == false) {\n                out_string(c, \"CLIENT_ERROR lru crawler disabled\");\n                return;\n            }\n            if (!settings.dump_enabled) {\n                out_string(c, \"ERROR metadump not allowed\");\n                return;\n            }\n            if (resp_has_stack(c)) {\n                out_string(c, \"ERROR cannot pipeline other commands before metadump\");\n                return;\n            }\n\n            int rv = lru_crawler_crawl(tokens[2].value, CRAWLER_METADUMP,\n                    c, c->sfd, LRU_CRAWLER_CAP_REMAINING);\n            switch(rv) {\n                case CRAWLER_OK:\n                    // TODO: documentation says this string is returned, but\n                    // it never was before. We never switch to conn_write so\n                    // this o_s call never worked. Need to talk to users and\n                    // decide if removing the OK from docs is fine.\n                    //out_string(c, \"OK\");\n                    // TODO: Don't reuse conn_watch here.\n                    conn_set_state(c, conn_watch);\n                    event_del(&c->event);\n                    break;\n                case CRAWLER_RUNNING:\n                    out_string(c, \"BUSY currently processing crawler request\");\n                    break;\n                case CRAWLER_BADCLASS:\n                    out_string(c, \"BADCLASS invalid class id\");\n                    break;\n                case CRAWLER_NOTSTARTED:\n                    out_string(c, \"NOTSTARTED no items to crawl\");\n                    break;\n                case CRAWLER_ERROR:\n                    out_string(c, \"ERROR an unknown error happened\");\n                    break;\n            }\n            return;\n        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, \"tocrawl\") == 0) {\n            uint32_t tocrawl;\n             if (!safe_strtoul(tokens[2].value, &tocrawl)) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return;\n            }\n            settings.lru_crawler_tocrawl = tocrawl;\n            out_string(c, \"OK\");\n            return;\n        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, \"sleep\") == 0) {\n            uint32_t tosleep;\n            if (!safe_strtoul(tokens[2].value, &tosleep)) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return;\n            }\n            if (tosleep > 1000000) {\n                out_string(c, \"CLIENT_ERROR sleep must be one second or less\");\n                return;\n            }\n            settings.lru_crawler_sleep = tosleep;\n            out_string(c, \"OK\");\n            return;\n        } else if (ntokens == 3) {\n            if ((strcmp(tokens[COMMAND_TOKEN + 1].value, \"enable\") == 0)) {\n                if (start_item_crawler_thread() == 0) {\n                    out_string(c, \"OK\");\n                } else {\n                    out_string(c, \"ERROR failed to start lru crawler thread\");\n                }\n            } else if ((strcmp(tokens[COMMAND_TOKEN + 1].value, \"disable\") == 0)) {\n                if (stop_item_crawler_thread(CRAWLER_NOWAIT) == 0) {\n                    out_string(c, \"OK\");\n                } else {\n                    out_string(c, \"ERROR failed to stop lru crawler thread\");\n                }\n            } else {\n                out_string(c, \"ERROR\");\n            }\n            return;\n        } else {\n            out_string(c, \"ERROR\");\n        }\n    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, \"watch\") == 0) {\n        if (resp_has_stack(c)) {\n            out_string(c, \"ERROR cannot pipeline other commands before watch\");\n            return;\n        }\n        process_watch_command(c, tokens, ntokens);\n    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, \"cache_memlimit\") == 0)) {\n        process_memlimit_command(c, tokens, ntokens);\n    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, \"verbosity\") == 0)) {\n        process_verbosity_command(c, tokens, ntokens);\n    } else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, \"lru\") == 0) {\n        process_lru_command(c, tokens, ntokens);\n#ifdef MEMCACHED_DEBUG\n    // commands which exist only for testing the memcached's security protection\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"misbehave\") == 0)) {\n        process_misbehave_command(c);\n#endif\n#ifdef EXTSTORE\n    } else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, \"extstore\") == 0) {\n        process_extstore_command(c, tokens, ntokens);\n#endif\n#ifdef TLS\n    } else if (ntokens == 2 && strcmp(tokens[COMMAND_TOKEN].value, \"refresh_certs\") == 0) {\n        set_noreply_maybe(c, tokens, ntokens);\n        char *errmsg = NULL;\n        if (refresh_certs(&errmsg)) {\n            out_string(c, \"OK\");\n        } else {\n            write_and_free(c, errmsg, strlen(errmsg));\n        }\n        return;\n#endif\n    } else {\n        if (ntokens >= 2 && strncmp(tokens[ntokens - 2].value, \"HTTP/\", 5) == 0) {\n            conn_set_state(c, conn_closing);\n        } else {\n            out_string(c, \"ERROR\");\n        }\n    }\n    return;\n}\n\nstatic int try_read_command_negotiate(conn *c) {\n    assert(c->protocol == negotiating_prot);\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n        c->protocol = binary_prot;\n        c->try_read_command = try_read_command_binary;\n    } else {\n        // authentication doesn't work with negotiated protocol.\n        c->protocol = ascii_prot;\n        c->try_read_command = try_read_command_ascii;\n    }\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,\n                prot_text(c->protocol));\n    }\n\n    return c->try_read_command(c);\n}\n\nstatic int try_read_command_udp(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n        c->protocol = binary_prot;\n        return try_read_command_binary(c);\n    } else {\n        c->protocol = ascii_prot;\n        return try_read_command_ascii(c);\n    }\n}\n\nstatic int try_read_command_binary(conn *c) {\n    /* Do we have the complete packet header? */\n    if (c->rbytes < sizeof(c->binary_header)) {\n        /* need more data! */\n        return 0;\n    } else {\n        memcpy(&c->binary_header, c->rcurr, sizeof(c->binary_header));\n        protocol_binary_request_header* req;\n        req = &c->binary_header;\n\n        if (settings.verbose > 1) {\n            /* Dump the packet before we convert it to host order */\n            int ii;\n            fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);\n            for (ii = 0; ii < sizeof(req->bytes); ++ii) {\n                if (ii % 4 == 0) {\n                    fprintf(stderr, \"\\n<%d   \", c->sfd);\n                }\n                fprintf(stderr, \" 0x%02x\", req->bytes[ii]);\n            }\n            fprintf(stderr, \"\\n\");\n        }\n\n        c->binary_header = *req;\n        c->binary_header.request.keylen = ntohs(req->request.keylen);\n        c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n        c->binary_header.request.cas = ntohll(req->request.cas);\n\n        if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {\n            if (settings.verbose) {\n                fprintf(stderr, \"Invalid magic:  %x\\n\",\n                        c->binary_header.request.magic);\n            }\n            conn_set_state(c, conn_closing);\n            return -1;\n        }\n\n        uint8_t extlen = c->binary_header.request.extlen;\n        uint16_t keylen = c->binary_header.request.keylen;\n        if (c->rbytes < keylen + extlen + sizeof(c->binary_header)) {\n            // Still need more bytes. Let try_read_network() realign the\n            // read-buffer and fetch more data as necessary.\n            return 0;\n        }\n\n        if (!resp_start(c)) {\n            conn_set_state(c, conn_closing);\n            return -1;\n        }\n\n        c->cmd = c->binary_header.request.opcode;\n        c->keylen = c->binary_header.request.keylen;\n        c->opaque = c->binary_header.request.opaque;\n        /* clear the returned cas value */\n        c->cas = 0;\n\n        c->last_cmd_time = current_time;\n        // sigh. binprot has no \"largest possible extlen\" define, and I don't\n        // want to refactor a ton of code either. Header is only ever used out\n        // of c->binary_header, but the extlen stuff is used for the latter\n        // bytes. Just wastes 24 bytes on the stack this way.\n        char extbuf[sizeof(c->binary_header) + BIN_MAX_EXTLEN];\n        memcpy(extbuf + sizeof(c->binary_header), c->rcurr + sizeof(c->binary_header), extlen);\n        c->rbytes -= sizeof(c->binary_header) + extlen + keylen;\n        c->rcurr += sizeof(c->binary_header) + extlen + keylen;\n\n        dispatch_bin_command(c, extbuf);\n    }\n\n    return 1;\n}\n\nstatic int try_read_command_asciiauth(conn *c) {\n    token_t tokens[MAX_TOKENS];\n    size_t ntokens;\n    char *cont = NULL;\n\n    if (!c->resp) {\n        if (!resp_start(c)) {\n            conn_set_state(c, conn_closing);\n            return 1;\n        }\n    }\n\n    // TODO: move to another function.\n    if (!c->sasl_started) {\n        char *el;\n        uint32_t size = 0;\n\n        // impossible for the auth command to be this short.\n        if (c->rbytes < 2)\n            return 0;\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n\n        // If no newline after 1k, getting junk data, close out.\n        if (!el) {\n            if (c->rbytes > 1024) {\n                conn_set_state(c, conn_closing);\n                return 1;\n            }\n            return 0;\n        }\n\n        // Looking for: \"set foo 0 0 N\\r\\nuser pass\\r\\n\"\n        // key, flags, and ttl are ignored. N is used to see if we have the rest.\n\n        // so tokenize doesn't walk past into the value.\n        // it's fine to leave the \\r in, as strtoul will stop at it.\n        *el = '\\0';\n\n        ntokens = tokenize_command(c->rcurr, tokens, MAX_TOKENS);\n        // ensure the buffer is consumed.\n        c->rbytes -= (el - c->rcurr) + 1;\n        c->rcurr += (el - c->rcurr) + 1;\n\n        // final token is a NULL ender, so we have one more than expected.\n        if (ntokens < 6\n                || strcmp(tokens[0].value, \"set\") != 0\n                || !safe_strtoul(tokens[4].value, &size)) {\n            out_string(c, \"CLIENT_ERROR unauthenticated\");\n            return 1;\n        }\n\n        // we don't actually care about the key at all; it can be anything.\n        // we do care about the size of the remaining read.\n        c->rlbytes = size + 2;\n\n        c->sasl_started = true; // reuse from binprot sasl, but not sasl :)\n    }\n\n    if (c->rbytes < c->rlbytes) {\n        // need more bytes.\n        return 0;\n    }\n\n    cont = c->rcurr;\n    // advance buffer. no matter what we're stopping.\n    c->rbytes -= c->rlbytes;\n    c->rcurr += c->rlbytes;\n    c->sasl_started = false;\n\n    // must end with \\r\\n\n    // NB: I thought ASCII sets also worked with just \\n, but according to\n    // complete_nread_ascii only \\r\\n is valid.\n    if (strncmp(cont + c->rlbytes - 2, \"\\r\\n\", 2) != 0) {\n        out_string(c, \"CLIENT_ERROR bad command line termination\");\n        return 1;\n    }\n\n    // payload should be \"user pass\", so we can use the tokenizer.\n    cont[c->rlbytes - 2] = '\\0';\n    ntokens = tokenize_command(cont, tokens, MAX_TOKENS);\n\n    if (ntokens < 3) {\n        out_string(c, \"CLIENT_ERROR bad authentication token format\");\n        return 1;\n    }\n\n    if (authfile_check(tokens[0].value, tokens[1].value) == 1) {\n        out_string(c, \"STORED\");\n        c->authenticated = true;\n        c->try_read_command = try_read_command_ascii;\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.auth_cmds++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n    } else {\n        out_string(c, \"CLIENT_ERROR authentication failure\");\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.auth_cmds++;\n        c->thread->stats.auth_errors++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n    }\n\n    return 1;\n}\n\nstatic int try_read_command_ascii(conn *c) {\n    char *el, *cont;\n\n    if (c->rbytes == 0)\n        return 0;\n\n    el = memchr(c->rcurr, '\\n', c->rbytes);\n    if (!el) {\n        if (c->rbytes > 1024) {\n            /*\n             * We didn't have a '\\n' in the first k. This _has_ to be a\n             * large multiget, if not we should just nuke the connection.\n             */\n            char *ptr = c->rcurr;\n            while (*ptr == ' ') { /* ignore leading whitespaces */\n                ++ptr;\n            }\n\n            if (ptr - c->rcurr > 100 ||\n                (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n\n                conn_set_state(c, conn_closing);\n                return 1;\n            }\n\n            // ASCII multigets are unbound, so our fixed size rbuf may not\n            // work for this particular workload... For backcompat we'll use a\n            // malloc/realloc/free routine just for this.\n            if (!c->rbuf_malloced) {\n                if (!rbuf_switch_to_malloc(c)) {\n                    conn_set_state(c, conn_closing);\n                    return 1;\n                }\n            }\n        }\n\n        return 0;\n    }\n    cont = el + 1;\n    if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n        el--;\n    }\n    *el = '\\0';\n\n    assert(cont <= (c->rcurr + c->rbytes));\n\n    c->last_cmd_time = current_time;\n    process_command(c, c->rcurr);\n\n    c->rbytes -= (cont - c->rcurr);\n    c->rcurr = cont;\n\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n\n    return 1;\n}\n\n/*\n * read a UDP request.\n */\nstatic enum try_read_result try_read_udp(conn *c) {\n    int res;\n\n    assert(c != NULL);\n\n    c->request_addr_size = sizeof(c->request_addr);\n    res = recvfrom(c->sfd, c->rbuf, c->rsize,\n                   0, (struct sockaddr *)&c->request_addr,\n                   &c->request_addr_size);\n    if (res > 8) {\n        unsigned char *buf = (unsigned char *)c->rbuf;\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.bytes_read += res;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        /* Beginning of UDP packet is the request ID; save it. */\n        c->request_id = buf[0] * 256 + buf[1];\n\n        /* If this is a multi-packet request, drop it. */\n        if (buf[4] != 0 || buf[5] != 1) {\n            out_string(c, \"SERVER_ERROR multi-packet request not supported\");\n            return READ_NO_DATA_RECEIVED;\n        }\n\n        /* Don't care about any of the rest of the header. */\n        res -= 8;\n        memmove(c->rbuf, c->rbuf + 8, res);\n\n        c->rbytes = res;\n        c->rcurr = c->rbuf;\n        return READ_DATA_RECEIVED;\n    }\n    return READ_NO_DATA_RECEIVED;\n}\n\n/*\n * read from network as much as we can, handle buffer overflow and connection\n * close.\n * before reading, move the remaining incomplete fragment of a command\n * (if any) to the beginning of the buffer.\n *\n * To protect us from someone flooding a connection with bogus data causing\n * the connection to eat up all available memory, break out and start looking\n * at the data I've got after a number of reallocs...\n *\n * @return enum try_read_result\n */\nstatic enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n    int num_allocs = 0;\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) /* otherwise there's nothing to copy */\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        // TODO: move to rbuf_* func?\n        if (c->rbytes >= c->rsize && c->rbuf_malloced) {\n            if (num_allocs == 4) {\n                return gotdata;\n            }\n            ++num_allocs;\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                STATS_LOCK();\n                stats.malloc_fails++;\n                STATS_UNLOCK();\n                if (settings.verbose > 0) {\n                    fprintf(stderr, \"Couldn't realloc input buffer\\n\");\n                }\n                c->rbytes = 0; /* ignore what we read */\n                out_of_memory(c, \"SERVER_ERROR out of memory reading request\");\n                c->close_after_write = true;\n                return READ_MEMORY_ERROR;\n            }\n            c->rcurr = c->rbuf = new_rbuf;\n            c->rsize *= 2;\n        }\n\n        int avail = c->rsize - c->rbytes;\n        res = c->read(c, c->rbuf + c->rbytes, avail);\n        if (res > 0) {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.bytes_read += res;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n            gotdata = READ_DATA_RECEIVED;\n            c->rbytes += res;\n            if (res == avail && c->rbuf_malloced) {\n                // Resize rbuf and try a few times if huge ascii multiget.\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (res == 0) {\n            return READ_ERROR;\n        }\n        if (res == -1) {\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                break;\n            }\n            return READ_ERROR;\n        }\n    }\n    return gotdata;\n}\n\nstatic bool update_event(conn *c, const int new_flags) {\n    assert(c != NULL);\n\n    struct event_base *base = c->event.ev_base;\n    if (c->ev_flags == new_flags)\n        return true;\n    if (event_del(&c->event) == -1) return false;\n    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = new_flags;\n    if (event_add(&c->event, 0) == -1) return false;\n    return true;\n}\n\n/*\n * Sets whether we are listening for new connections or not.\n */\nvoid do_accept_new_conns(const bool do_accept) {\n    conn *next;\n\n    for (next = listen_conn; next; next = next->next) {\n        if (do_accept) {\n            update_event(next, EV_READ | EV_PERSIST);\n            if (listen(next->sfd, settings.backlog) != 0) {\n                perror(\"listen\");\n            }\n        }\n        else {\n            update_event(next, 0);\n            if (listen(next->sfd, 0) != 0) {\n                perror(\"listen\");\n            }\n        }\n    }\n\n    if (do_accept) {\n        struct timeval maxconns_exited;\n        uint64_t elapsed_us;\n        gettimeofday(&maxconns_exited,NULL);\n        STATS_LOCK();\n        elapsed_us =\n            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000\n            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);\n        stats.time_in_listen_disabled_us += elapsed_us;\n        stats_state.accepting_conns = true;\n        STATS_UNLOCK();\n    } else {\n        STATS_LOCK();\n        stats_state.accepting_conns = false;\n        gettimeofday(&stats.maxconns_entered,NULL);\n        stats.listen_disabled_num++;\n        STATS_UNLOCK();\n        allow_new_conns = false;\n        maxconns_handler(-42, 0, 0);\n    }\n}\n\n#define TRANSMIT_ONE_RESP true\n#define TRANSMIT_ALL_RESP false\nstatic int _transmit_pre(conn *c, struct iovec *iovs, int iovused, bool one_resp) {\n    mc_resp *resp = c->resp_head;\n    while (resp && iovused + resp->iovcnt < IOV_MAX-1) {\n        if (resp->skip) {\n            // Don't actually unchain the resp obj here since it's singly-linked.\n            // Just let the post function handle it linearly.\n            resp = resp->next;\n            continue;\n        }\n        if (resp->chunked_data_iov) {\n            // Handle chunked items specially.\n            // They spend much more time in send so we can be a bit wasteful\n            // in rebuilding iovecs for them.\n            item_chunk *ch = (item_chunk *)ITEM_schunk((item *)resp->iov[resp->chunked_data_iov].iov_base);\n            int x;\n            for (x = 0; x < resp->iovcnt; x++) {\n                // This iov is tracking how far we've copied so far.\n                if (x == resp->chunked_data_iov) {\n                    int done = resp->chunked_total - resp->iov[x].iov_len;\n                    // Start from the len to allow binprot to cut the \\r\\n\n                    int todo = resp->iov[x].iov_len;\n                    while (ch && todo > 0 && iovused < IOV_MAX-1) {\n                        int skip = 0;\n                        if (!ch->used) {\n                            ch = ch->next;\n                            continue;\n                        }\n                        // Skip parts we've already sent.\n                        if (done >= ch->used) {\n                            done -= ch->used;\n                            ch = ch->next;\n                            continue;\n                        } else if (done) {\n                            skip = done;\n                            done = 0;\n                        }\n                        iovs[iovused].iov_base = ch->data + skip;\n                        // Stupid binary protocol makes this go negative.\n                        iovs[iovused].iov_len = ch->used - skip > todo ? todo : ch->used - skip;\n                        iovused++;\n                        todo -= ch->used - skip;\n                        ch = ch->next;\n                    }\n                } else {\n                    iovs[iovused].iov_base = resp->iov[x].iov_base;\n                    iovs[iovused].iov_len = resp->iov[x].iov_len;\n                    iovused++;\n                }\n                if (iovused >= IOV_MAX-1)\n                    break;\n            }\n        } else {\n            memcpy(&iovs[iovused], resp->iov, sizeof(struct iovec)*resp->iovcnt);\n            iovused += resp->iovcnt;\n        }\n\n        // done looking at first response, walk down the chain.\n        resp = resp->next;\n        // used for UDP mode: UDP cannot send multiple responses per packet.\n        if (one_resp)\n            break;\n    }\n    return iovused;\n}\n\n/*\n * Decrements and completes responses based on how much data was transmitted.\n * Takes the connection and current result bytes.\n */\nstatic void _transmit_post(conn *c, ssize_t res) {\n    // We've written some of the data. Remove the completed\n    // responses from the list of pending writes.\n    mc_resp *resp = c->resp_head;\n    while (resp) {\n        int x;\n        if (resp->skip) {\n            resp = resp_finish(c, resp);\n            continue;\n        }\n\n        // fastpath check. all small responses should cut here.\n        if (res >= resp->tosend) {\n            res -= resp->tosend;\n            resp = resp_finish(c, resp);\n            continue;\n        }\n\n        // it's fine to re-check iov's that were zeroed out before.\n        for (x = 0; x < resp->iovcnt; x++) {\n            struct iovec *iov = &resp->iov[x];\n            if (res >= iov->iov_len) {\n                resp->tosend -= iov->iov_len;\n                res -= iov->iov_len;\n                iov->iov_len = 0;\n            } else {\n                // Dumb special case for chunked items. Currently tracking\n                // where to inject the chunked item via iov_base.\n                // Extra not-great since chunked items can't be the first\n                // index, so we have to check for non-zero c_d_iov first.\n                if (!resp->chunked_data_iov || x != resp->chunked_data_iov) {\n                    iov->iov_base = (char *)iov->iov_base + res;\n                }\n                iov->iov_len -= res;\n                resp->tosend -= res;\n                res = 0;\n                break;\n            }\n        }\n\n        // are we done with this response object?\n        if (resp->tosend == 0) {\n            resp = resp_finish(c, resp);\n        } else {\n            // Jammed up here. This is the new head.\n            break;\n        }\n    }\n}\n\n/*\n * Transmit the next chunk of data from our list of msgbuf structures.\n *\n * Returns:\n *   TRANSMIT_COMPLETE   All done writing.\n *   TRANSMIT_INCOMPLETE More data remaining to write.\n *   TRANSMIT_SOFT_ERROR Can't write any more right now.\n *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)\n */\nstatic enum transmit_result transmit(conn *c) {\n    assert(c != NULL);\n    struct iovec iovs[IOV_MAX];\n    struct msghdr msg;\n    int iovused = 0;\n\n    // init the msg.\n    memset(&msg, 0, sizeof(struct msghdr));\n    msg.msg_iov = iovs;\n\n    iovused = _transmit_pre(c, iovs, iovused, TRANSMIT_ALL_RESP);\n\n    // Alright, send.\n    ssize_t res;\n    msg.msg_iovlen = iovused;\n    res = c->sendmsg(c, &msg, 0);\n    if (res >= 0) {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.bytes_written += res;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        // Decrement any partial IOV's and complete any finished resp's.\n        _transmit_post(c, res);\n\n        if (c->resp_head) {\n            return TRANSMIT_INCOMPLETE;\n        } else {\n            return TRANSMIT_COMPLETE;\n        }\n    }\n\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n        if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n            if (settings.verbose > 0)\n                fprintf(stderr, \"Couldn't update event\\n\");\n            conn_set_state(c, conn_closing);\n            return TRANSMIT_HARD_ERROR;\n        }\n        return TRANSMIT_SOFT_ERROR;\n    }\n    /* if res == -1 and error is not EAGAIN or EWOULDBLOCK,\n       we have a real error, on which we close the connection */\n    if (settings.verbose > 0)\n        perror(\"Failed to write, and not due to blocking\");\n\n    conn_set_state(c, conn_closing);\n    return TRANSMIT_HARD_ERROR;\n}\n\nstatic void build_udp_header(unsigned char *hdr, mc_resp *resp) {\n    // We need to communicate the total number of packets\n    // If this isn't set, it's the first time this response is building a udp\n    // header, so \"tosend\" must be static.\n    if (!resp->udp_total) {\n        uint32_t total;\n        total = resp->tosend / UDP_MAX_PAYLOAD_SIZE;\n        if (resp->tosend % UDP_MAX_PAYLOAD_SIZE)\n            total++;\n        // The spec doesn't really say what we should do here. It's _probably_\n        // better to bail out?\n        if (total > USHRT_MAX) {\n            total = USHRT_MAX;\n        }\n        resp->udp_total = total;\n    }\n\n    // TODO: why wasn't this hto*'s and casts?\n    // this ends up sending UDP hdr data specifically in host byte order.\n    *hdr++ = resp->request_id / 256;\n    *hdr++ = resp->request_id % 256;\n    *hdr++ = resp->udp_sequence / 256;\n    *hdr++ = resp->udp_sequence % 256;\n    *hdr++ = resp->udp_total / 256;\n    *hdr++ = resp->udp_total % 256;\n    *hdr++ = 0;\n    *hdr++ = 0;\n    resp->udp_sequence++;\n}\n\n/*\n * UDP specific transmit function. Uses its own function rather than check\n * IS_UDP() five times. If we ever implement sendmmsg or similar support they\n * will diverge even more.\n * Does not use TLS.\n *\n * Returns:\n *   TRANSMIT_COMPLETE   All done writing.\n *   TRANSMIT_INCOMPLETE More data remaining to write.\n *   TRANSMIT_SOFT_ERROR Can't write any more right now.\n *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)\n */\nstatic enum transmit_result transmit_udp(conn *c) {\n    assert(c != NULL);\n    struct iovec iovs[IOV_MAX];\n    struct msghdr msg;\n    mc_resp *resp;\n    int iovused = 0;\n    unsigned char udp_hdr[UDP_HEADER_SIZE];\n\n    // We only send one UDP packet per call (ugh), so we can only operate on a\n    // single response at a time.\n    resp = c->resp_head;\n\n    if (!resp) {\n        return TRANSMIT_COMPLETE;\n    }\n\n    if (resp->skip) {\n        resp = resp_finish(c, resp);\n        return TRANSMIT_INCOMPLETE;\n    }\n\n    // clear the message and initialize it.\n    memset(&msg, 0, sizeof(struct msghdr));\n    msg.msg_iov = iovs;\n\n    // the UDP source to return to.\n    msg.msg_name = &resp->request_addr;\n    msg.msg_namelen = resp->request_addr_size;\n\n    // First IOV is the custom UDP header.\n    iovs[0].iov_base = udp_hdr;\n    iovs[0].iov_len = UDP_HEADER_SIZE;\n    build_udp_header(udp_hdr, resp);\n    iovused++;\n\n    // Fill the IOV's the standard way.\n    // TODO: might get a small speedup if we let it break early with a length\n    // limit.\n    iovused = _transmit_pre(c, iovs, iovused, TRANSMIT_ONE_RESP);\n\n    // Clip the IOV's to the max UDP packet size.\n    // If we add support for send_mmsg, this can be where we split msg's.\n    {\n        int x = 0;\n        int len = 0;\n        for (x = 0; x < iovused; x++) {\n            if (len + iovs[x].iov_len >= UDP_MAX_PAYLOAD_SIZE) {\n                iovs[x].iov_len = UDP_MAX_PAYLOAD_SIZE - len;\n                x++;\n                break;\n            } else {\n                len += iovs[x].iov_len;\n            }\n        }\n        iovused = x;\n    }\n\n    ssize_t res;\n    msg.msg_iovlen = iovused;\n    // NOTE: uses system sendmsg since we have no support for indirect UDP.\n    res = sendmsg(c->sfd, &msg, 0);\n    if (res >= 0) {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.bytes_written += res;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        // Ignore the header size from forwarding the IOV's\n        res -= UDP_HEADER_SIZE;\n\n        // Decrement any partial IOV's and complete any finished resp's.\n        _transmit_post(c, res);\n\n        if (c->resp_head) {\n            return TRANSMIT_INCOMPLETE;\n        } else {\n            return TRANSMIT_COMPLETE;\n        }\n    }\n\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n        if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n            if (settings.verbose > 0)\n                fprintf(stderr, \"Couldn't update event\\n\");\n            conn_set_state(c, conn_closing);\n            return TRANSMIT_HARD_ERROR;\n        }\n        return TRANSMIT_SOFT_ERROR;\n    }\n    /* if res == -1 and error is not EAGAIN or EWOULDBLOCK,\n       we have a real error, on which we close the connection */\n    if (settings.verbose > 0)\n        perror(\"Failed to write, and not due to blocking\");\n\n    conn_set_state(c, conn_read);\n    return TRANSMIT_HARD_ERROR;\n}\n\n\n/* Does a looped read to fill data chunks */\n/* TODO: restrict number of times this can loop.\n * Also, benchmark using readv's.\n */\nstatic int read_into_chunked_item(conn *c) {\n    int total = 0;\n    int res;\n    assert(c->rcurr != c->ritem);\n\n    while (c->rlbytes > 0) {\n        item_chunk *ch = (item_chunk *)c->ritem;\n        if (ch->size == ch->used) {\n            // FIXME: ch->next is currently always 0. remove this?\n            if (ch->next) {\n                c->ritem = (char *) ch->next;\n            } else {\n                /* Allocate next chunk. Binary protocol needs 2b for \\r\\n */\n                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +\n                       ((c->protocol == binary_prot) ? 2 : 0));\n                if (!c->ritem) {\n                    // We failed an allocation. Let caller handle cleanup.\n                    total = -2;\n                    break;\n                }\n                // ritem has new chunk, restart the loop.\n                continue;\n                //assert(c->rlbytes == 0);\n            }\n        }\n\n        int unused = ch->size - ch->used;\n        /* first check if we have leftovers in the conn_read buffer */\n        if (c->rbytes > 0) {\n            total = 0;\n            int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;\n            tocopy = tocopy > unused ? unused : tocopy;\n            if (c->ritem != c->rcurr) {\n                memmove(ch->data + ch->used, c->rcurr, tocopy);\n            }\n            total += tocopy;\n            c->rlbytes -= tocopy;\n            c->rcurr += tocopy;\n            c->rbytes -= tocopy;\n            ch->used += tocopy;\n            if (c->rlbytes == 0) {\n                break;\n            }\n        } else {\n            /*  now try reading from the socket */\n            res = c->read(c, ch->data + ch->used,\n                    (unused > c->rlbytes ? c->rlbytes : unused));\n            if (res > 0) {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.bytes_read += res;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                ch->used += res;\n                total += res;\n                c->rlbytes -= res;\n            } else {\n                /* Reset total to the latest result so caller can handle it */\n                total = res;\n                break;\n            }\n        }\n    }\n\n    /* At some point I will be able to ditch the \\r\\n from item storage and\n       remove all of these kludges.\n       The above binprot check ensures inline space for \\r\\n, but if we do\n       exactly enough allocs there will be no additional chunk for \\r\\n.\n     */\n    if (c->rlbytes == 0 && c->protocol == binary_prot && total >= 0) {\n        item_chunk *ch = (item_chunk *)c->ritem;\n        if (ch->size - ch->used < 2) {\n            c->ritem = (char *) do_item_alloc_chunk(ch, 2);\n            if (!c->ritem) {\n                total = -2;\n            }\n        }\n    }\n    return total;\n}\n\nstatic void drive_machine(conn *c) {\n    bool stop = false;\n    int sfd;\n    socklen_t addrlen;\n    struct sockaddr_storage addr;\n    int nreqs = settings.reqs_per_event;\n    int res;\n    const char *str;\n#ifdef HAVE_ACCEPT4\n    static int  use_accept4 = 1;\n#else\n    static int  use_accept4 = 0;\n#endif\n\n    assert(c != NULL);\n\n    while (!stop) {\n\n        switch(c->state) {\n        case conn_listening:\n            addrlen = sizeof(addr);\n#ifdef HAVE_ACCEPT4\n            if (use_accept4) {\n                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);\n            } else {\n                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);\n            }\n#else\n            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);\n#endif\n            if (sfd == -1) {\n                if (use_accept4 && errno == ENOSYS) {\n                    use_accept4 = 0;\n                    continue;\n                }\n                perror(use_accept4 ? \"accept4()\" : \"accept()\");\n                if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                    /* these are transient, so don't log anything */\n                    stop = true;\n                } else if (errno == EMFILE) {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Too many open connections\\n\");\n                    accept_new_conns(false);\n                    stop = true;\n                } else {\n                    perror(\"accept()\");\n                    stop = true;\n                }\n                break;\n            }\n            if (!use_accept4) {\n                if (fcntl(sfd, F_SETFL, fcntl(sfd, F_GETFL) | O_NONBLOCK) < 0) {\n                    perror(\"setting O_NONBLOCK\");\n                    close(sfd);\n                    break;\n                }\n            }\n\n            bool reject;\n            if (settings.maxconns_fast) {\n                STATS_LOCK();\n                reject = stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1;\n                if (reject) {\n                    stats.rejected_conns++;\n                }\n                STATS_UNLOCK();\n            } else {\n                reject = false;\n            }\n\n            if (reject) {\n                str = \"ERROR Too many open connections\\r\\n\";\n                res = write(sfd, str, strlen(str));\n                close(sfd);\n            } else {\n                void *ssl_v = NULL;\n#ifdef TLS\n                SSL *ssl = NULL;\n                if (c->ssl_enabled) {\n                    assert(IS_TCP(c->transport) && settings.ssl_enabled);\n\n                    if (settings.ssl_ctx == NULL) {\n                        if (settings.verbose) {\n                            fprintf(stderr, \"SSL context is not initialized\\n\");\n                        }\n                        close(sfd);\n                        break;\n                    }\n                    SSL_LOCK();\n                    ssl = SSL_new(settings.ssl_ctx);\n                    SSL_UNLOCK();\n                    if (ssl == NULL) {\n                        if (settings.verbose) {\n                            fprintf(stderr, \"Failed to created the SSL object\\n\");\n                        }\n                        close(sfd);\n                        break;\n                    }\n                    SSL_set_fd(ssl, sfd);\n                    int ret = SSL_accept(ssl);\n                    if (ret <= 0) {\n                        int err = SSL_get_error(ssl, ret);\n                        if (err == SSL_ERROR_SYSCALL || err == SSL_ERROR_SSL) {\n                            if (settings.verbose) {\n                                fprintf(stderr, \"SSL connection failed with error code : %d : %s\\n\", err, strerror(errno));\n                            }\n                            SSL_free(ssl);\n                            close(sfd);\n                            STATS_LOCK();\n                            stats.ssl_handshake_errors++;\n                            STATS_UNLOCK();\n                            break;\n                        }\n                    }\n                }\n                ssl_v = (void*) ssl;\n#endif\n\n                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,\n                                     READ_BUFFER_CACHED, c->transport, ssl_v);\n            }\n\n            stop = true;\n            break;\n\n        case conn_waiting:\n            rbuf_release(c);\n            if (!update_event(c, EV_READ | EV_PERSIST)) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't update event\\n\");\n                conn_set_state(c, conn_closing);\n                break;\n            }\n\n            conn_set_state(c, conn_read);\n            stop = true;\n            break;\n\n        case conn_read:\n            if (!IS_UDP(c->transport)) {\n                // Assign a read buffer if necessary.\n                if (!rbuf_alloc(c)) {\n                    // TODO: Some way to allow for temporary failures.\n                    conn_set_state(c, conn_closing);\n                    break;\n                }\n                res = try_read_network(c);\n            } else {\n                // UDP connections always have a static buffer.\n                res = try_read_udp(c);\n            }\n\n            switch (res) {\n            case READ_NO_DATA_RECEIVED:\n                conn_set_state(c, conn_waiting);\n                break;\n            case READ_DATA_RECEIVED:\n                conn_set_state(c, conn_parse_cmd);\n                break;\n            case READ_ERROR:\n                conn_set_state(c, conn_closing);\n                break;\n            case READ_MEMORY_ERROR: /* Failed to allocate more memory */\n                /* State already set by try_read_network */\n                break;\n            }\n            break;\n\n        case conn_parse_cmd:\n            c->noreply = false;\n            if (c->try_read_command(c) == 0) {\n                /* wee need more data! */\n                if (c->resp_head) {\n                    // Buffered responses waiting, flush in the meantime.\n                    conn_set_state(c, conn_mwrite);\n                } else {\n                    conn_set_state(c, conn_waiting);\n                }\n            }\n\n            break;\n\n        case conn_new_cmd:\n            /* Only process nreqs at a time to avoid starving other\n               connections */\n\n            --nreqs;\n            if (nreqs >= 0) {\n                reset_cmd_handler(c);\n            } else if (c->resp_head) {\n                // flush response pipe on yield.\n                conn_set_state(c, conn_mwrite);\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.conn_yields++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                if (c->rbytes > 0) {\n                    /* We have already read in data into the input buffer,\n                       so libevent will most likely not signal read events\n                       on the socket (unless more data is available. As a\n                       hack we should just put in a request to write data,\n                       because that should be possible ;-)\n                    */\n                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                        if (settings.verbose > 0)\n                            fprintf(stderr, \"Couldn't update event\\n\");\n                        conn_set_state(c, conn_closing);\n                        break;\n                    }\n                }\n                stop = true;\n            }\n            break;\n\n        case conn_nread:\n            if (c->rlbytes == 0) {\n                complete_nread(c);\n                break;\n            }\n\n            /* Check if rbytes < 0, to prevent crash */\n            if (c->rlbytes < 0) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"Invalid rlbytes to read: len %d\\n\", c->rlbytes);\n                }\n                conn_set_state(c, conn_closing);\n                break;\n            }\n\n            if ((((item *)c->item)->it_flags & ITEM_CHUNKED) == 0) {\n                /* first check if we have leftovers in the conn_read buffer */\n                if (c->rbytes > 0) {\n                    int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;\n                    memmove(c->ritem, c->rcurr, tocopy);\n                    c->ritem += tocopy;\n                    c->rlbytes -= tocopy;\n                    c->rcurr += tocopy;\n                    c->rbytes -= tocopy;\n                    if (c->rlbytes == 0) {\n                        break;\n                    }\n                }\n\n                /*  now try reading from the socket */\n                res = c->read(c, c->ritem, c->rlbytes);\n                if (res > 0) {\n                    pthread_mutex_lock(&c->thread->stats.mutex);\n                    c->thread->stats.bytes_read += res;\n                    pthread_mutex_unlock(&c->thread->stats.mutex);\n                    if (c->rcurr == c->ritem) {\n                        c->rcurr += res;\n                    }\n                    c->ritem += res;\n                    c->rlbytes -= res;\n                    break;\n                }\n            } else {\n                res = read_into_chunked_item(c);\n                if (res > 0)\n                    break;\n            }\n\n            if (res == 0) { /* end of stream */\n                conn_set_state(c, conn_closing);\n                break;\n            }\n\n            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n                if (!update_event(c, EV_READ | EV_PERSIST)) {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Couldn't update event\\n\");\n                    conn_set_state(c, conn_closing);\n                    break;\n                }\n                stop = true;\n                break;\n            }\n\n            /* Memory allocation failure */\n            if (res == -2) {\n                out_of_memory(c, \"SERVER_ERROR Out of memory during read\");\n                c->sbytes = c->rlbytes;\n                conn_set_state(c, conn_swallow);\n                // Ensure this flag gets cleared. It gets killed on conn_new()\n                // so any conn_closing is fine, calling complete_nread is\n                // fine. This swallow semms to be the only other case.\n                c->set_stale = false;\n                c->mset_res = false;\n                break;\n            }\n            /* otherwise we have a real error, on which we close the connection */\n            if (settings.verbose > 0) {\n                fprintf(stderr, \"Failed to read, and not due to blocking:\\n\"\n                        \"errno: %d %s \\n\"\n                        \"rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\\n\",\n                        errno, strerror(errno),\n                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,\n                        (int)c->rlbytes, (int)c->rsize);\n            }\n            conn_set_state(c, conn_closing);\n            break;\n\n        case conn_swallow:\n            /* we are reading sbytes and throwing them away */\n            if (c->sbytes <= 0) {\n                conn_set_state(c, conn_new_cmd);\n                break;\n            }\n\n            /* first check if we have leftovers in the conn_read buffer */\n            if (c->rbytes > 0) {\n                int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;\n                c->sbytes -= tocopy;\n                c->rcurr += tocopy;\n                c->rbytes -= tocopy;\n                break;\n            }\n\n            /*  now try reading from the socket */\n            res = c->read(c, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);\n            if (res > 0) {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.bytes_read += res;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                c->sbytes -= res;\n                break;\n            }\n            if (res == 0) { /* end of stream */\n                conn_set_state(c, conn_closing);\n                break;\n            }\n            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n                if (!update_event(c, EV_READ | EV_PERSIST)) {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Couldn't update event\\n\");\n                    conn_set_state(c, conn_closing);\n                    break;\n                }\n                stop = true;\n                break;\n            }\n            /* otherwise we have a real error, on which we close the connection */\n            if (settings.verbose > 0)\n                fprintf(stderr, \"Failed to read, and not due to blocking\\n\");\n            conn_set_state(c, conn_closing);\n            break;\n\n        case conn_write:\n        case conn_mwrite:\n#ifdef EXTSTORE\n            /* have side IO's that must process before transmit() can run.\n             * remove the connection from the worker thread and dispatch the\n             * IO queue\n             */\n            if (c->io_wrapleft) {\n                assert(c->io_queued == false);\n                assert(c->io_wraplist != NULL);\n                // TODO: create proper state for this condition\n                conn_set_state(c, conn_watch);\n                event_del(&c->event);\n                c->io_queued = true;\n                extstore_submit(c->thread->storage, &c->io_wraplist->io);\n                stop = true;\n                break;\n            }\n#endif\n            switch (!IS_UDP(c->transport) ? transmit(c) : transmit_udp(c)) {\n            case TRANSMIT_COMPLETE:\n                if (c->state == conn_mwrite) {\n                    // Free up IO wraps and any half-uploaded items.\n                    conn_release_items(c);\n                    conn_set_state(c, conn_new_cmd);\n                    if (c->close_after_write) {\n                        conn_set_state(c, conn_closing);\n                    }\n                } else {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Unexpected state %d\\n\", c->state);\n                    conn_set_state(c, conn_closing);\n                }\n                break;\n\n            case TRANSMIT_INCOMPLETE:\n            case TRANSMIT_HARD_ERROR:\n                break;                   /* Continue in state machine. */\n\n            case TRANSMIT_SOFT_ERROR:\n                stop = true;\n                break;\n            }\n            break;\n\n        case conn_closing:\n            if (IS_UDP(c->transport))\n                conn_cleanup(c);\n            else\n                conn_close(c);\n            stop = true;\n            break;\n\n        case conn_closed:\n            /* This only happens if dormando is an idiot. */\n            abort();\n            break;\n\n        case conn_watch:\n            /* We handed off our connection to the logger thread. */\n            stop = true;\n            break;\n        case conn_max_state:\n            assert(false);\n            break;\n        }\n    }\n\n    return;\n}\n\nvoid event_handler(const int fd, const short which, void *arg) {\n    conn *c;\n\n    c = (conn *)arg;\n    assert(c != NULL);\n\n    c->which = which;\n\n    /* sanity */\n    if (fd != c->sfd) {\n        if (settings.verbose > 0)\n            fprintf(stderr, \"Catastrophic: event fd doesn't match conn fd!\\n\");\n        conn_close(c);\n        return;\n    }\n\n    drive_machine(c);\n\n    /* wait for next event */\n    return;\n}\n\nstatic int new_socket(struct addrinfo *ai) {\n    int sfd;\n    int flags;\n\n    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {\n        return -1;\n    }\n\n    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||\n        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {\n        perror(\"setting O_NONBLOCK\");\n        close(sfd);\n        return -1;\n    }\n    return sfd;\n}\n\n\n/*\n * Sets a socket's send buffer size to the maximum allowed by the system.\n */\nstatic void maximize_sndbuf(const int sfd) {\n    socklen_t intsize = sizeof(int);\n    int last_good = 0;\n    int min, max, avg;\n    int old_size;\n\n    /* Start with the default size. */\n    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {\n        if (settings.verbose > 0)\n            perror(\"getsockopt(SO_SNDBUF)\");\n        return;\n    }\n\n    /* Binary-search for the real maximum. */\n    min = old_size;\n    max = MAX_SENDBUF_SIZE;\n\n    while (min <= max) {\n        avg = ((unsigned int)(min + max)) / 2;\n        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {\n            last_good = avg;\n            min = avg + 1;\n        } else {\n            max = avg - 1;\n        }\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"<%d send buffer was %d, now %d\\n\", sfd, old_size, last_good);\n}\n\n/**\n * Create a socket and bind it to a specific port number\n * @param interface the interface to bind to\n * @param port the port number to bind to\n * @param transport the transport protocol (TCP / UDP)\n * @param portnumber_file A filepointer to write the port numbers to\n *        when they are successfully added to the list of ports we\n *        listen on.\n */\nstatic int server_socket(const char *interface,\n                         int port,\n                         enum network_transport transport,\n                         FILE *portnumber_file, bool ssl_enabled) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct addrinfo *ai;\n    struct addrinfo *next;\n    struct addrinfo hints = { .ai_flags = AI_PASSIVE,\n                              .ai_family = AF_UNSPEC };\n    char port_buf[NI_MAXSERV];\n    int error;\n    int success = 0;\n    int flags =1;\n\n    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;\n\n    if (port == -1) {\n        port = 0;\n    }\n    snprintf(port_buf, sizeof(port_buf), \"%d\", port);\n    error= getaddrinfo(interface, port_buf, &hints, &ai);\n    if (error != 0) {\n        if (error != EAI_SYSTEM)\n          fprintf(stderr, \"getaddrinfo(): %s\\n\", gai_strerror(error));\n        else\n          perror(\"getaddrinfo()\");\n        return 1;\n    }\n\n    for (next= ai; next; next= next->ai_next) {\n        conn *listen_conn_add;\n        if ((sfd = new_socket(next)) == -1) {\n            /* getaddrinfo can return \"junk\" addresses,\n             * we make sure at least one works before erroring.\n             */\n            if (errno == EMFILE) {\n                /* ...unless we're out of fds */\n                perror(\"server_socket\");\n                exit(EX_OSERR);\n            }\n            continue;\n        }\n\n#ifdef IPV6_V6ONLY\n        if (next->ai_family == AF_INET6) {\n            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));\n            if (error != 0) {\n                perror(\"setsockopt\");\n                close(sfd);\n                continue;\n            }\n        }\n#endif\n\n        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n        if (IS_UDP(transport)) {\n            maximize_sndbuf(sfd);\n        } else {\n            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n            if (error != 0)\n                perror(\"setsockopt\");\n\n            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n            if (error != 0)\n                perror(\"setsockopt\");\n\n            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));\n            if (error != 0)\n                perror(\"setsockopt\");\n        }\n\n        if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {\n            if (errno != EADDRINUSE) {\n                perror(\"bind()\");\n                close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            close(sfd);\n            continue;\n        } else {\n            success++;\n            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {\n                perror(\"listen()\");\n                close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            if (portnumber_file != NULL &&\n                (next->ai_addr->sa_family == AF_INET ||\n                 next->ai_addr->sa_family == AF_INET6)) {\n                union {\n                    struct sockaddr_in in;\n                    struct sockaddr_in6 in6;\n                } my_sockaddr;\n                socklen_t len = sizeof(my_sockaddr);\n                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {\n                    if (next->ai_addr->sa_family == AF_INET) {\n                        fprintf(portnumber_file, \"%s INET: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in.sin_port));\n                    } else {\n                        fprintf(portnumber_file, \"%s INET6: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in6.sin6_port));\n                    }\n                }\n            }\n        }\n\n        if (IS_UDP(transport)) {\n            int c;\n\n            for (c = 0; c < settings.num_threads_per_udp; c++) {\n                /* Allocate one UDP file descriptor per worker thread;\n                 * this allows \"stats conns\" to separately list multiple\n                 * parallel UDP requests in progress.\n                 *\n                 * The dispatch code round-robins new connection requests\n                 * among threads, so this is guaranteed to assign one\n                 * FD to each thread.\n                 */\n                int per_thread_fd;\n                if (c == 0) {\n                    per_thread_fd = sfd;\n                } else {\n                    per_thread_fd = dup(sfd);\n                    if (per_thread_fd < 0) {\n                        perror(\"Failed to duplicate file descriptor\");\n                        exit(EXIT_FAILURE);\n                    }\n                }\n                dispatch_conn_new(per_thread_fd, conn_read,\n                                  EV_READ | EV_PERSIST,\n                                  UDP_READ_BUFFER_SIZE, transport, NULL);\n            }\n        } else {\n            if (!(listen_conn_add = conn_new(sfd, conn_listening,\n                                             EV_READ | EV_PERSIST, 1,\n                                             transport, main_base, NULL))) {\n                fprintf(stderr, \"failed to create listening connection\\n\");\n                exit(EXIT_FAILURE);\n            }\n#ifdef TLS\n            listen_conn_add->ssl_enabled = ssl_enabled;\n#else\n            assert(ssl_enabled == false);\n#endif\n            listen_conn_add->next = listen_conn;\n            listen_conn = listen_conn_add;\n        }\n    }\n\n    freeaddrinfo(ai);\n\n    /* Return zero iff we detected no errors in starting up connections */\n    return success == 0;\n}\n\nstatic int server_sockets(int port, enum network_transport transport,\n                          FILE *portnumber_file) {\n    bool ssl_enabled = false;\n\n#ifdef TLS\n    const char *notls = \"notls\";\n    ssl_enabled = settings.ssl_enabled;\n#endif\n\n    if (settings.inter == NULL) {\n        return server_socket(settings.inter, port, transport, portnumber_file, ssl_enabled);\n    } else {\n        // tokenize them and bind to each one of them..\n        char *b;\n        int ret = 0;\n        char *list = strdup(settings.inter);\n\n        if (list == NULL) {\n            fprintf(stderr, \"Failed to allocate memory for parsing server interface string\\n\");\n            return 1;\n        }\n        for (char *p = strtok_r(list, \";,\", &b);\n            p != NULL;\n            p = strtok_r(NULL, \";,\", &b)) {\n            int the_port = port;\n#ifdef TLS\n            ssl_enabled = settings.ssl_enabled;\n            // \"notls\" option is valid only when memcached is run with SSL enabled.\n            if (strncmp(p, notls, strlen(notls)) == 0) {\n                if (!settings.ssl_enabled) {\n                    fprintf(stderr, \"'notls' option is valid only when SSL is enabled\\n\");\n                    free(list);\n                    return 1;\n                }\n                ssl_enabled = false;\n                p += strlen(notls) + 1;\n            }\n#endif\n\n            char *h = NULL;\n            if (*p == '[') {\n                // expecting it to be an IPv6 address enclosed in []\n                // i.e. RFC3986 style recommended by RFC5952\n                char *e = strchr(p, ']');\n                if (e == NULL) {\n                    fprintf(stderr, \"Invalid IPV6 address: \\\"%s\\\"\", p);\n                    free(list);\n                    return 1;\n                }\n                h = ++p; // skip the opening '['\n                *e = '\\0';\n                p = ++e; // skip the closing ']'\n            }\n\n            char *s = strchr(p, ':');\n            if (s != NULL) {\n                // If no more semicolons - attempt to treat as port number.\n                // Otherwise the only valid option is an unenclosed IPv6 without port, until\n                // of course there was an RFC3986 IPv6 address previously specified -\n                // in such a case there is no good option, will just send it to fail as port number.\n                if (strchr(s + 1, ':') == NULL || h != NULL) {\n                    *s = '\\0';\n                    ++s;\n                    if (!safe_strtol(s, &the_port)) {\n                        fprintf(stderr, \"Invalid port number: \\\"%s\\\"\", s);\n                        free(list);\n                        return 1;\n                    }\n                }\n            }\n\n            if (h != NULL)\n                p = h;\n\n            if (strcmp(p, \"*\") == 0) {\n                p = NULL;\n            }\n            ret |= server_socket(p, the_port, transport, portnumber_file, ssl_enabled);\n        }\n        free(list);\n        return ret;\n    }\n}\n\nstatic int new_socket_unix(void) {\n    int sfd;\n    int flags;\n\n    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {\n        perror(\"socket()\");\n        return -1;\n    }\n\n    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||\n        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {\n        perror(\"setting O_NONBLOCK\");\n        close(sfd);\n        return -1;\n    }\n    return sfd;\n}\n\nstatic int server_socket_unix(const char *path, int access_mask) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct sockaddr_un addr;\n    struct stat tstat;\n    int flags =1;\n    int old_umask;\n\n    if (!path) {\n        return 1;\n    }\n\n    if ((sfd = new_socket_unix()) == -1) {\n        return 1;\n    }\n\n    /*\n     * Clean up a previous socket file if we left it around\n     */\n    if (lstat(path, &tstat) == 0) {\n        if (S_ISSOCK(tstat.st_mode))\n            unlink(path);\n    }\n\n    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n\n    /*\n     * the memset call clears nonstandard fields in some implementations\n     * that otherwise mess things up.\n     */\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n    assert(strcmp(addr.sun_path, path) == 0);\n    old_umask = umask( ~(access_mask&0777));\n    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n        perror(\"bind()\");\n        close(sfd);\n        umask(old_umask);\n        return 1;\n    }\n    umask(old_umask);\n    if (listen(sfd, settings.backlog) == -1) {\n        perror(\"listen()\");\n        close(sfd);\n        return 1;\n    }\n    if (!(listen_conn = conn_new(sfd, conn_listening,\n                                 EV_READ | EV_PERSIST, 1,\n                                 local_transport, main_base, NULL))) {\n        fprintf(stderr, \"failed to create listening connection\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    return 0;\n}\n\n/*\n * We keep the current time of day in a global variable that's updated by a\n * timer event. This saves us a bunch of time() system calls (we really only\n * need to get the time once a second, whereas there can be tens of thousands\n * of requests a second) and allows us to use server-start-relative timestamps\n * rather than absolute UNIX timestamps, a space savings on systems where\n * sizeof(time_t) > sizeof(unsigned int).\n */\nvolatile rel_time_t current_time;\nstatic struct event clockevent;\n#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)\nstatic bool monotonic = false;\nstatic int64_t monotonic_start;\n#endif\n\n/* libevent uses a monotonic clock when available for event scheduling. Aside\n * from jitter, simply ticking our internal timer here is accurate enough.\n * Note that users who are setting explicit dates for expiration times *must*\n * ensure their clocks are correct before starting memcached. */\nstatic void clock_handler(const int fd, const short which, void *arg) {\n    struct timeval t = {.tv_sec = 1, .tv_usec = 0};\n    static bool initialized = false;\n\n    if (initialized) {\n        /* only delete the event if it's actually there. */\n        evtimer_del(&clockevent);\n    } else {\n        initialized = true;\n    }\n\n    // While we're here, check for hash table expansion.\n    // This function should be quick to avoid delaying the timer.\n    assoc_start_expand(stats_state.curr_items);\n    // also, if HUP'ed we need to do some maintenance.\n    // for now that's just the authfile reload.\n    if (settings.sig_hup) {\n        settings.sig_hup = false;\n\n        authfile_load(settings.auth_file);\n    }\n\n    evtimer_set(&clockevent, clock_handler, 0);\n    event_base_set(main_base, &clockevent);\n    evtimer_add(&clockevent, &t);\n\n#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)\n    if (monotonic) {\n        struct timespec ts;\n        if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)\n            return;\n        current_time = (rel_time_t) (ts.tv_sec - monotonic_start);\n        return;\n    }\n#endif\n    {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        current_time = (rel_time_t) (tv.tv_sec - process_started);\n    }\n}\n\nstatic const char* flag_enabled_disabled(bool flag) {\n    return (flag ? \"enabled\" : \"disabled\");\n}\n\nstatic void verify_default(const char* param, bool condition) {\n    if (!condition) {\n        printf(\"Default value of [%s] has changed.\"\n            \" Modify the help text and default value check.\\n\", param);\n        exit(EXIT_FAILURE);\n    }\n}\n\nstatic void usage(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\");\n    printf(\"-p, --port=<num>          TCP port to listen on (default: %d)\\n\"\n           \"-U, --udp-port=<num>      UDP port to listen on (default: %d, off)\\n\"\n           \"-s, --unix-socket=<file>  UNIX socket to listen on (disables network support)\\n\"\n           \"-A, --enable-shutdown     enable ascii \\\"shutdown\\\" command\\n\"\n           \"-a, --unix-mask=<mask>    access mask for UNIX socket, in octal (default: %o)\\n\"\n           \"-l, --listen=<addr>       interface to listen on (default: INADDR_ANY)\\n\"\n#ifdef TLS\n           \"                          if TLS/SSL is enabled, 'notls' prefix can be used to\\n\"\n           \"                          disable for specific listeners (-l notls:<ip>:<port>) \\n\"\n#endif\n           \"-d, --daemon              run as a daemon\\n\"\n           \"-r, --enable-coredumps    maximize core file limit\\n\"\n           \"-u, --user=<user>         assume identity of <username> (only when run as root)\\n\"\n           \"-m, --memory-limit=<num>  item memory in megabytes (default: %lu)\\n\"\n           \"-M, --disable-evictions   return error on memory exhausted instead of evicting\\n\"\n           \"-c, --conn-limit=<num>    max simultaneous connections (default: %d)\\n\"\n           \"-k, --lock-memory         lock down all paged memory\\n\"\n           \"-v, --verbose             verbose (print errors/warnings while in event loop)\\n\"\n           \"-vv                       very verbose (also print client commands/responses)\\n\"\n           \"-vvv                      extremely verbose (internal state transitions)\\n\"\n           \"-h, --help                print this help and exit\\n\"\n           \"-i, --license             print memcached and libevent license\\n\"\n           \"-V, --version             print version and exit\\n\"\n           \"-P, --pidfile=<file>      save PID in <file>, only used with -d option\\n\"\n           \"-f, --slab-growth-factor=<num> chunk size growth factor (default: %2.2f)\\n\"\n           \"-n, --slab-min-size=<bytes> min space used for key+value+flags (default: %d)\\n\",\n           settings.port, settings.udpport, settings.access, (unsigned long) settings.maxbytes / (1 << 20),\n           settings.maxconns, settings.factor, settings.chunk_size);\n    verify_default(\"udp-port\",settings.udpport == 0);\n    printf(\"-L, --enable-largepages  try to use large memory pages (if available)\\n\");\n    printf(\"-D <char>     Use <char> as the delimiter between key prefixes and IDs.\\n\"\n           \"              This is used for per-prefix stats reporting. The default is\\n\"\n           \"              \\\"%c\\\" (colon). If this option is specified, stats collection\\n\"\n           \"              is turned on automatically; if not, then it may be turned on\\n\"\n           \"              by sending the \\\"stats detail on\\\" command to the server.\\n\",\n           settings.prefix_delimiter);\n    printf(\"-t, --threads=<num>       number of threads to use (default: %d)\\n\", settings.num_threads);\n    printf(\"-R, --max-reqs-per-event  maximum number of requests per event, limits the\\n\"\n           \"                          requests processed per connection to prevent \\n\"\n           \"                          starvation (default: %d)\\n\", settings.reqs_per_event);\n    printf(\"-C, --disable-cas         disable use of CAS\\n\");\n    printf(\"-b, --listen-backlog=<num> set the backlog queue limit (default: %d)\\n\", settings.backlog);\n    printf(\"-B, --protocol=<name>     protocol - one of ascii, binary, or auto (default: %s)\\n\",\n           prot_text(settings.binding_protocol));\n    printf(\"-I, --max-item-size=<num> adjusts max item size\\n\"\n           \"                          (default: %dm, min: %dk, max: %dm)\\n\",\n           settings.item_size_max/ (1 << 20), ITEM_SIZE_MAX_LOWER_LIMIT / (1 << 10),  ITEM_SIZE_MAX_UPPER_LIMIT / (1 << 20));\n#ifdef ENABLE_SASL\n    printf(\"-S, --enable-sasl         turn on Sasl authentication\\n\");\n#endif\n    printf(\"-F, --disable-flush-all   disable flush_all command\\n\");\n    printf(\"-X, --disable-dumping     disable stats cachedump and lru_crawler metadump\\n\");\n    printf(\"-W  --disable-watch       disable watch commands (live logging)\\n\");\n    printf(\"-Y, --auth-file=<file>    (EXPERIMENTAL) enable ASCII protocol authentication. format:\\n\"\n           \"                          user:pass\\\\nuser2:pass2\\\\n\\n\");\n    printf(\"-e, --memory-file=<file>  (EXPERIMENTAL) mmap a file for item memory.\\n\"\n           \"                          use only in ram disks or persistent memory mounts!\\n\"\n           \"                          enables restartable cache (stop with SIGUSR1)\\n\");\n#ifdef TLS\n    printf(\"-Z, --enable-ssl          enable TLS/SSL\\n\");\n#endif\n    printf(\"-o, --extended            comma separated list of extended options\\n\"\n           \"                          most options have a 'no_' prefix to disable\\n\"\n           \"   - maxconns_fast:       immediately close new connections after limit (default: %s)\\n\"\n           \"   - hashpower:           an integer multiplier for how large the hash\\n\"\n           \"                          table should be. normally grows at runtime. (default starts at: %d)\\n\"\n           \"                          set based on \\\"STAT hash_power_level\\\"\\n\"\n           \"   - tail_repair_time:    time in seconds for how long to wait before\\n\"\n           \"                          forcefully killing LRU tail item.\\n\"\n           \"                          disabled by default; very dangerous option.\\n\"\n           \"   - hash_algorithm:      the hash table algorithm\\n\"\n           \"                          default is murmur3 hash. options: jenkins, murmur3\\n\"\n           \"   - no_lru_crawler:      disable LRU Crawler background thread.\\n\"\n           \"   - lru_crawler_sleep:   microseconds to sleep between items\\n\"\n           \"                          default is %d.\\n\"\n           \"   - lru_crawler_tocrawl: max items to crawl per slab per run\\n\"\n           \"                          default is %u (unlimited)\\n\",\n           flag_enabled_disabled(settings.maxconns_fast), settings.hashpower_init,\n           settings.lru_crawler_sleep, settings.lru_crawler_tocrawl);\n    printf(\"   - resp_obj_mem_limit:  limit in megabytes for connection response objects.\\n\"\n           \"                          do not adjust unless you have high (100k+) conn. limits.\\n\"\n           \"                          0 means unlimited (default: %u)\\n\"\n           \"   - read_buf_mem_limit:  limit in megabytes for connection read buffers.\\n\"\n           \"                          do not adjust unless you have high (100k+) conn. limits.\\n\"\n           \"                          0 means unlimited (default: %u)\\n\",\n           settings.resp_obj_mem_limit,\n           settings.read_buf_mem_limit);\n    verify_default(\"resp_obj_mem_limit\", settings.resp_obj_mem_limit == 0);\n    verify_default(\"read_buf_mem_limit\", settings.read_buf_mem_limit == 0);\n    printf(\"   - no_lru_maintainer:   disable new LRU system + background thread.\\n\"\n           \"   - hot_lru_pct:         pct of slab memory to reserve for hot lru.\\n\"\n           \"                          (requires lru_maintainer, default pct: %d)\\n\"\n           \"   - warm_lru_pct:        pct of slab memory to reserve for warm lru.\\n\"\n           \"                          (requires lru_maintainer, default pct: %d)\\n\"\n           \"   - hot_max_factor:      items idle > cold lru age * drop from hot lru. (default: %.2f)\\n\"\n           \"   - warm_max_factor:     items idle > cold lru age * this drop from warm. (default: %.2f)\\n\"\n           \"   - temporary_ttl:       TTL's below get separate LRU, can't be evicted.\\n\"\n           \"                          (requires lru_maintainer, default: %d)\\n\"\n           \"   - idle_timeout:        timeout for idle connections. (default: %d, no timeout)\\n\",\n           settings.hot_lru_pct, settings.warm_lru_pct, settings.hot_max_factor, settings.warm_max_factor,\n           settings.temporary_ttl, settings.idle_timeout);\n    printf(\"   - slab_chunk_max:      (EXPERIMENTAL) maximum slab size in kilobytes. use extreme care. (default: %d)\\n\"\n           \"   - watcher_logbuf_size: size in kilobytes of per-watcher write buffer. (default: %u)\\n\"\n           \"   - worker_logbuf_size:  size in kilobytes of per-worker-thread buffer\\n\"\n           \"                          read by background thread, then written to watchers. (default: %u)\\n\"\n           \"   - track_sizes:         enable dynamic reports for 'stats sizes' command.\\n\"\n           \"   - no_hashexpand:       disables hash table expansion (dangerous)\\n\"\n           \"   - modern:              enables options which will be default in future.\\n\"\n           \"                          currently: nothing\\n\"\n           \"   - no_modern:           uses defaults of previous major version (1.4.x)\\n\",\n           settings.slab_chunk_size_max / (1 << 10), settings.logger_watcher_buf_size / (1 << 10),\n           settings.logger_buf_size / (1 << 10));\n    verify_default(\"tail_repair_time\", settings.tail_repair_time == TAIL_REPAIR_TIME_DEFAULT);\n    verify_default(\"lru_crawler_tocrawl\", settings.lru_crawler_tocrawl == 0);\n    verify_default(\"idle_timeout\", settings.idle_timeout == 0);\n#ifdef HAVE_DROP_PRIVILEGES\n    printf(\"   - drop_privileges:     enable dropping extra syscall privileges\\n\"\n           \"   - no_drop_privileges:  disable drop_privileges in case it causes issues with\\n\"\n           \"                          some customisation.\\n\"\n           \"                          (default is no_drop_privileges)\\n\");\n    verify_default(\"drop_privileges\", !settings.drop_privileges);\n#ifdef MEMCACHED_DEBUG\n    printf(\"   - relaxed_privileges:  running tests requires extra privileges. (default: %s)\\n\",\n           flag_enabled_disabled(settings.relaxed_privileges));\n#endif\n#endif\n#ifdef EXTSTORE\n    printf(\"\\n   - External storage (ext_*) related options (see: https://memcached.org/extstore)\\n\");\n    printf(\"   - ext_path:            file to write to for external storage.\\n\"\n           \"                          ie: ext_path=/mnt/d1/extstore:1G\\n\"\n           \"   - ext_page_size:       size in megabytes of storage pages. (default: %u)\\n\"\n           \"   - ext_wbuf_size:       size in megabytes of page write buffers. (default: %u)\\n\"\n           \"   - ext_threads:         number of IO threads to run. (default: %u)\\n\"\n           \"   - ext_item_size:       store items larger than this (bytes, default %u)\\n\"\n           \"   - ext_item_age:        store items idle at least this long (seconds, default: no age limit)\\n\"\n           \"   - ext_low_ttl:         consider TTLs lower than this specially (default: %u)\\n\"\n           \"   - ext_drop_unread:     don't re-write unread values during compaction (default: %s)\\n\"\n           \"   - ext_recache_rate:    recache an item every N accesses (default: %u)\\n\"\n           \"   - ext_compact_under:   compact when fewer than this many free pages\\n\"\n           \"                          (default: 1/4th of the assigned storage)\\n\"\n           \"   - ext_drop_under:      drop COLD items when fewer than this many free pages\\n\"\n           \"                          (default: 1/4th of the assigned storage)\\n\"\n           \"   - ext_max_frag:        max page fragmentation to tolerate (default: %.2f)\\n\"\n           \"   - slab_automove_freeratio: ratio of memory to hold free as buffer.\\n\"\n           \"                          (see doc/storage.txt for more info, default: %.3f)\\n\",\n           settings.ext_page_size / (1 << 20), settings.ext_wbuf_size / (1 << 20), settings.ext_io_threadcount,\n           settings.ext_item_size, settings.ext_low_ttl,\n           flag_enabled_disabled(settings.ext_drop_unread), settings.ext_recache_rate,\n           settings.ext_max_frag, settings.slab_automove_freeratio);\n    verify_default(\"ext_item_age\", settings.ext_item_age == UINT_MAX);\n#endif\n#ifdef TLS\n    printf(\"   - ssl_chain_cert:      certificate chain file in PEM format\\n\"\n           \"   - ssl_key:             private key, if not part of the -ssl_chain_cert\\n\"\n           \"   - ssl_keyformat:       private key format (PEM, DER or ENGINE) (default: PEM)\\n\");\n    printf(\"   - ssl_verify_mode:     peer certificate verification mode, default is 0(None).\\n\"\n           \"                          valid values are 0(None), 1(Request), 2(Require)\\n\"\n           \"                          or 3(Once)\\n\");\n    printf(\"   - ssl_ciphers:         specify cipher list to be used\\n\"\n           \"   - ssl_ca_cert:         PEM format file of acceptable client CA's\\n\"\n           \"   - ssl_wbuf_size:       size in kilobytes of per-connection SSL output buffer\\n\"\n           \"                          (default: %u)\\n\", settings.ssl_wbuf_size / (1 << 10));\n    verify_default(\"ssl_keyformat\", settings.ssl_keyformat == SSL_FILETYPE_PEM);\n    verify_default(\"ssl_verify_mode\", settings.ssl_verify_mode == SSL_VERIFY_NONE);\n#endif\n    return;\n}\n\nstatic void usage_license(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\\n\");\n    printf(\n    \"Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions are\\n\"\n    \"met:\\n\"\n    \"\\n\"\n    \"    * Redistributions of source code must retain the above copyright\\n\"\n    \"notice, this list of conditions and the following disclaimer.\\n\"\n    \"\\n\"\n    \"    * Redistributions in binary form must reproduce the above\\n\"\n    \"copyright notice, this list of conditions and the following disclaimer\\n\"\n    \"in the documentation and/or other materials provided with the\\n\"\n    \"distribution.\\n\"\n    \"\\n\"\n    \"    * Neither the name of the Danga Interactive nor the names of its\\n\"\n    \"contributors may be used to endorse or promote products derived from\\n\"\n    \"this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n\"\n    \"\\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n\"\n    \"A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n\"\n    \"OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n\"\n    \"SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\"\n    \"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    \"\\n\"\n    \"\\n\"\n    \"This product includes software developed by Niels Provos.\\n\"\n    \"\\n\"\n    \"[ libevent ]\\n\"\n    \"\\n\"\n    \"Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions\\n\"\n    \"are met:\\n\"\n    \"1. Redistributions of source code must retain the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer.\\n\"\n    \"2. Redistributions in binary form must reproduce the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer in the\\n\"\n    \"   documentation and/or other materials provided with the distribution.\\n\"\n    \"3. All advertising materials mentioning features or use of this software\\n\"\n    \"   must display the following acknowledgement:\\n\"\n    \"      This product includes software developed by Niels Provos.\\n\"\n    \"4. The name of the author may not be used to endorse or promote products\\n\"\n    \"   derived from this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\\n\"\n    \"IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\\n\"\n    \"OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\\n\"\n    \"IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\\n\"\n    \"INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\\n\"\n    \"NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\\n\"\n    \"THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    );\n\n    return;\n}\n\nstatic void save_pid(const char *pid_file) {\n    FILE *fp;\n    if (access(pid_file, F_OK) == 0) {\n        if ((fp = fopen(pid_file, \"r\")) != NULL) {\n            char buffer[1024];\n            if (fgets(buffer, sizeof(buffer), fp) != NULL) {\n                unsigned int pid;\n                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {\n                    fprintf(stderr, \"WARNING: The pid file contained the following (running) pid: %u\\n\", pid);\n                }\n            }\n            fclose(fp);\n        }\n    }\n\n    /* Create the pid file first with a temporary name, then\n     * atomically move the file to the real name to avoid a race with\n     * another process opening the file to read the pid, but finding\n     * it empty.\n     */\n    char tmp_pid_file[1024];\n    snprintf(tmp_pid_file, sizeof(tmp_pid_file), \"%s.tmp\", pid_file);\n\n    if ((fp = fopen(tmp_pid_file, \"w\")) == NULL) {\n        vperror(\"Could not open the pid file %s for writing\", tmp_pid_file);\n        return;\n    }\n\n    fprintf(fp,\"%ld\\n\", (long)getpid());\n    if (fclose(fp) == -1) {\n        vperror(\"Could not close the pid file %s\", tmp_pid_file);\n    }\n\n    if (rename(tmp_pid_file, pid_file) != 0) {\n        vperror(\"Could not rename the pid file from %s to %s\",\n                tmp_pid_file, pid_file);\n    }\n}\n\nstatic void remove_pidfile(const char *pid_file) {\n  if (pid_file == NULL)\n      return;\n\n  if (unlink(pid_file) != 0) {\n      vperror(\"Could not remove the pid file %s\", pid_file);\n  }\n\n}\n\nstatic void sig_handler(const int sig) {\n    printf(\"Signal handled: %s.\\n\", strsignal(sig));\n    exit(EXIT_SUCCESS);\n}\n\nstatic void sighup_handler(const int sig) {\n    settings.sig_hup = true;\n}\n\nstatic void sig_usrhandler(const int sig) {\n    printf(\"Graceful shutdown signal handled: %s.\\n\", strsignal(sig));\n    stop_main_loop = true;\n}\n\n#ifndef HAVE_SIGIGNORE\nstatic int sigignore(int sig) {\n    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {\n        return -1;\n    }\n    return 0;\n}\n#endif\n\n\n/*\n * On systems that supports multiple page sizes we may reduce the\n * number of TLB-misses by using the biggest available page size\n */\nstatic int enable_large_pages(void) {\n#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)\n    int ret = -1;\n    size_t sizes[32];\n    int avail = getpagesizes(sizes, 32);\n    if (avail != -1) {\n        size_t max = sizes[0];\n        struct memcntl_mha arg = {0};\n        int ii;\n\n        for (ii = 1; ii < avail; ++ii) {\n            if (max < sizes[ii]) {\n                max = sizes[ii];\n            }\n        }\n\n        arg.mha_flags   = 0;\n        arg.mha_pagesize = max;\n        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;\n\n        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {\n            fprintf(stderr, \"Failed to set large pages: %s\\n\",\n                    strerror(errno));\n            fprintf(stderr, \"Will use default page size\\n\");\n        } else {\n            ret = 0;\n        }\n    } else {\n        fprintf(stderr, \"Failed to get supported pagesizes: %s\\n\",\n                strerror(errno));\n        fprintf(stderr, \"Will use default page size\\n\");\n    }\n\n    return ret;\n#elif defined(__linux__) && defined(MADV_HUGEPAGE)\n    /* check if transparent hugepages is compiled into the kernel */\n    struct stat st;\n    int ret = stat(\"/sys/kernel/mm/transparent_hugepage/enabled\", &st);\n    if (ret || !(st.st_mode & S_IFREG)) {\n        fprintf(stderr, \"Transparent huge pages support not detected.\\n\");\n        fprintf(stderr, \"Will use default page size.\\n\");\n        return -1;\n    }\n    return 0;\n#elif defined(__FreeBSD__)\n    int spages;\n    size_t spagesl = sizeof(spages);\n\n    if (sysctlbyname(\"vm.pmap.pg_ps_enabled\", &spages,\n    &spagesl, NULL, 0) != 0) {\n        fprintf(stderr, \"Could not evaluate the presence of superpages features.\");\n        return -1;\n    }\n    if (spages != 1) {\n        fprintf(stderr, \"Superpages support not detected.\\n\");\n        fprintf(stderr, \"Will use default page size.\\n\");\n        return -1;\n    }\n    return 0;\n#else\n    return -1;\n#endif\n}\n\n/**\n * Do basic sanity check of the runtime environment\n * @return true if no errors found, false if we can't use this env\n */\nstatic bool sanitycheck(void) {\n    /* One of our biggest problems is old and bogus libevents */\n    const char *ever = event_get_version();\n    if (ever != NULL) {\n        if (strncmp(ever, \"1.\", 2) == 0) {\n            /* Require at least 1.3 (that's still a couple of years old) */\n            if (('0' <= ever[2] && ever[2] < '3') && !isdigit(ever[3])) {\n                fprintf(stderr, \"You are using libevent %s.\\nPlease upgrade to\"\n                        \" a more recent version (1.3 or newer)\\n\",\n                        event_get_version());\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nstatic bool _parse_slab_sizes(char *s, uint32_t *slab_sizes) {\n    char *b = NULL;\n    uint32_t size = 0;\n    int i = 0;\n    uint32_t last_size = 0;\n\n    if (strlen(s) < 1)\n        return false;\n\n    for (char *p = strtok_r(s, \"-\", &b);\n         p != NULL;\n         p = strtok_r(NULL, \"-\", &b)) {\n        if (!safe_strtoul(p, &size) || size < settings.chunk_size\n             || size > settings.slab_chunk_size_max) {\n            fprintf(stderr, \"slab size %u is out of valid range\\n\", size);\n            return false;\n        }\n        if (last_size >= size) {\n            fprintf(stderr, \"slab size %u cannot be lower than or equal to a previous class size\\n\", size);\n            return false;\n        }\n        if (size <= last_size + CHUNK_ALIGN_BYTES) {\n            fprintf(stderr, \"slab size %u must be at least %d bytes larger than previous class\\n\",\n                    size, CHUNK_ALIGN_BYTES);\n            return false;\n        }\n        slab_sizes[i++] = size;\n        last_size = size;\n        if (i >= MAX_NUMBER_OF_SLAB_CLASSES-1) {\n            fprintf(stderr, \"too many slab classes specified\\n\");\n            return false;\n        }\n    }\n\n    slab_sizes[i] = 0;\n    return true;\n}\n\nstruct _mc_meta_data {\n    void *mmap_base;\n    uint64_t old_base;\n    char *slab_config; // string containing either factor or custom slab list.\n    int64_t time_delta;\n    uint64_t process_started;\n    uint32_t current_time;\n};\n\n// We need to remember a combination of configuration settings and global\n// state for restart viability and resumption of internal services.\n// Compared to the number of tunables and state values, relatively little\n// does need to be remembered.\n// Time is the hardest; we have to assume the sys clock is correct and re-sync for\n// the lost time after restart.\nstatic int _mc_meta_save_cb(const char *tag, void *ctx, void *data) {\n    struct _mc_meta_data *meta = (struct _mc_meta_data *)data;\n\n    // Settings to remember.\n    // TODO: should get a version of version which is numeric, else\n    // comparisons for compat reasons are difficult.\n    // it may be possible to punt on this for now; since we can test for the\n    // absense of another key... such as the new numeric version.\n    //restart_set_kv(ctx, \"version\", \"%s\", VERSION);\n    // We hold the original factor or subopts _string_\n    // it can be directly compared without roundtripping through floats or\n    // serializing/deserializing the long options list.\n    restart_set_kv(ctx, \"slab_config\", \"%s\", meta->slab_config);\n    restart_set_kv(ctx, \"maxbytes\", \"%llu\", (unsigned long long) settings.maxbytes);\n    restart_set_kv(ctx, \"chunk_size\", \"%d\", settings.chunk_size);\n    restart_set_kv(ctx, \"item_size_max\", \"%d\", settings.item_size_max);\n    restart_set_kv(ctx, \"slab_chunk_size_max\", \"%d\", settings.slab_chunk_size_max);\n    restart_set_kv(ctx, \"slab_page_size\", \"%d\", settings.slab_page_size);\n    restart_set_kv(ctx, \"use_cas\", \"%s\", settings.use_cas ? \"true\" : \"false\");\n    restart_set_kv(ctx, \"slab_reassign\", \"%s\", settings.slab_reassign ? \"true\" : \"false\");\n\n    // Online state to remember.\n\n    // current time is tough. we need to rely on the clock being correct to\n    // pull the delta between stop and start times. we also need to know the\n    // delta between start time and now to restore monotonic clocks.\n    // for non-monotonic clocks (some OS?), process_started is the only\n    // important one.\n    restart_set_kv(ctx, \"current_time\", \"%u\", current_time);\n    // types are great until... this. some systems time_t could be big, but\n    // I'm assuming never negative.\n    restart_set_kv(ctx, \"process_started\", \"%llu\", (unsigned long long) process_started);\n    {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        restart_set_kv(ctx, \"stop_time\", \"%lu\", tv.tv_sec);\n    }\n\n    // Might as well just fetch the next CAS value to use than tightly\n    // coupling the internal variable into the restart system.\n    restart_set_kv(ctx, \"current_cas\", \"%llu\", (unsigned long long) get_cas_id());\n    restart_set_kv(ctx, \"oldest_cas\", \"%llu\", (unsigned long long) settings.oldest_cas);\n    restart_set_kv(ctx, \"logger_gid\", \"%llu\", logger_get_gid());\n    restart_set_kv(ctx, \"hashpower\", \"%u\", stats_state.hash_power_level);\n    // NOTE: oldest_live is a rel_time_t, which aliases for unsigned int.\n    // should future proof this with a 64bit upcast, or fetch value from a\n    // converter function/macro?\n    restart_set_kv(ctx, \"oldest_live\", \"%u\", settings.oldest_live);\n    // TODO: use uintptr_t etc? is it portable enough?\n    restart_set_kv(ctx, \"mmap_oldbase\", \"%p\", meta->mmap_base);\n\n    return 0;\n}\n\n// We must see at least this number of checked lines. Else empty/missing lines\n// could cause a false-positive.\n// TODO: Once crc32'ing of the metadata file is done this could be ensured better by\n// the restart module itself (crc32 + count of lines must match on the\n// backend)\n#define RESTART_REQUIRED_META 17\n\n// With this callback we make a decision on if the current configuration\n// matches up enough to allow reusing the cache.\n// We also re-load important runtime information.\nstatic int _mc_meta_load_cb(const char *tag, void *ctx, void *data) {\n    struct _mc_meta_data *meta = (struct _mc_meta_data *)data;\n    char *key;\n    char *val;\n    int reuse_mmap = 0;\n    meta->process_started = 0;\n    meta->time_delta = 0;\n    meta->current_time = 0;\n    int lines_seen = 0;\n\n    // TODO: not sure this is any better than just doing an if/else tree with\n    // strcmp's...\n    enum {\n        R_MMAP_OLDBASE = 0,\n        R_MAXBYTES,\n        R_CHUNK_SIZE,\n        R_ITEM_SIZE_MAX,\n        R_SLAB_CHUNK_SIZE_MAX,\n        R_SLAB_PAGE_SIZE,\n        R_SLAB_CONFIG,\n        R_USE_CAS,\n        R_SLAB_REASSIGN,\n        R_CURRENT_CAS,\n        R_OLDEST_CAS,\n        R_OLDEST_LIVE,\n        R_LOGGER_GID,\n        R_CURRENT_TIME,\n        R_STOP_TIME,\n        R_PROCESS_STARTED,\n        R_HASHPOWER,\n    };\n\n    const char *opts[] = {\n        [R_MMAP_OLDBASE] = \"mmap_oldbase\",\n        [R_MAXBYTES] = \"maxbytes\",\n        [R_CHUNK_SIZE] = \"chunk_size\",\n        [R_ITEM_SIZE_MAX] = \"item_size_max\",\n        [R_SLAB_CHUNK_SIZE_MAX] = \"slab_chunk_size_max\",\n        [R_SLAB_PAGE_SIZE] = \"slab_page_size\",\n        [R_SLAB_CONFIG] = \"slab_config\",\n        [R_USE_CAS] = \"use_cas\",\n        [R_SLAB_REASSIGN] = \"slab_reassign\",\n        [R_CURRENT_CAS] = \"current_cas\",\n        [R_OLDEST_CAS] = \"oldest_cas\",\n        [R_OLDEST_LIVE] = \"oldest_live\",\n        [R_LOGGER_GID] = \"logger_gid\",\n        [R_CURRENT_TIME] = \"current_time\",\n        [R_STOP_TIME] = \"stop_time\",\n        [R_PROCESS_STARTED] = \"process_started\",\n        [R_HASHPOWER] = \"hashpower\",\n        NULL\n    };\n\n    while (restart_get_kv(ctx, &key, &val) == RESTART_OK) {\n        int type = 0;\n        int32_t val_int = 0;\n        uint32_t val_uint = 0;\n        int64_t bigval_int = 0;\n        uint64_t bigval_uint = 0;\n\n        while (opts[type] != NULL && strcmp(key, opts[type]) != 0) {\n            type++;\n        }\n        if (opts[type] == NULL) {\n            fprintf(stderr, \"[restart] unknown/unhandled key: %s\\n\", key);\n            continue;\n        }\n        lines_seen++;\n\n        // helper for any boolean checkers.\n        bool val_bool = false;\n        bool is_bool = true;\n        if (strcmp(val, \"false\") == 0) {\n            val_bool = false;\n        } else if (strcmp(val, \"true\") == 0) {\n            val_bool = true;\n        } else {\n            is_bool = false;\n        }\n\n        switch (type) {\n        case R_MMAP_OLDBASE:\n            if (!safe_strtoull_hex(val, &meta->old_base)) {\n                fprintf(stderr, \"[restart] failed to parse %s: %s\\n\", key, val);\n                reuse_mmap = -1;\n            }\n            break;\n        case R_MAXBYTES:\n            if (!safe_strtoll(val, &bigval_int) || settings.maxbytes != bigval_int) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_CHUNK_SIZE:\n            if (!safe_strtol(val, &val_int) || settings.chunk_size != val_int) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_ITEM_SIZE_MAX:\n            if (!safe_strtol(val, &val_int) || settings.item_size_max != val_int) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_SLAB_CHUNK_SIZE_MAX:\n            if (!safe_strtol(val, &val_int) || settings.slab_chunk_size_max != val_int) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_SLAB_PAGE_SIZE:\n            if (!safe_strtol(val, &val_int) || settings.slab_page_size != val_int) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_SLAB_CONFIG:\n            if (strcmp(val, meta->slab_config) != 0) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_USE_CAS:\n            if (!is_bool || settings.use_cas != val_bool) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_SLAB_REASSIGN:\n            if (!is_bool || settings.slab_reassign != val_bool) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_CURRENT_CAS:\n            // FIXME: do we need to fail if these values _aren't_ found?\n            if (!safe_strtoull(val, &bigval_uint)) {\n                reuse_mmap = -1;\n            } else {\n                set_cas_id(bigval_uint);\n            }\n            break;\n        case R_OLDEST_CAS:\n            if (!safe_strtoull(val, &bigval_uint)) {\n                reuse_mmap = -1;\n            } else {\n                settings.oldest_cas = bigval_uint;\n            }\n            break;\n        case R_OLDEST_LIVE:\n            if (!safe_strtoul(val, &val_uint)) {\n                reuse_mmap = -1;\n            } else {\n                settings.oldest_live = val_uint;\n            }\n            break;\n        case R_LOGGER_GID:\n            if (!safe_strtoull(val, &bigval_uint)) {\n                reuse_mmap = -1;\n            } else {\n                logger_set_gid(bigval_uint);\n            }\n            break;\n        case R_PROCESS_STARTED:\n            if (!safe_strtoull(val, &bigval_uint)) {\n                reuse_mmap = -1;\n            } else {\n                meta->process_started = bigval_uint;\n            }\n            break;\n        case R_CURRENT_TIME:\n            if (!safe_strtoul(val, &val_uint)) {\n                reuse_mmap = -1;\n            } else {\n                meta->current_time = val_uint;\n            }\n            break;\n        case R_STOP_TIME:\n            if (!safe_strtoll(val, &bigval_int)) {\n                reuse_mmap = -1;\n            } else {\n                struct timeval t;\n                gettimeofday(&t, NULL);\n                meta->time_delta = t.tv_sec - bigval_int;\n                // clock has done something crazy.\n                // there are _lots_ of ways the clock can go wrong here, but\n                // this is a safe sanity check since there's nothing else we\n                // can realistically do.\n                if (meta->time_delta <= 0) {\n                    reuse_mmap = -1;\n                }\n            }\n            break;\n        case R_HASHPOWER:\n            if (!safe_strtoul(val, &val_uint)) {\n                reuse_mmap = -1;\n            } else {\n                settings.hashpower_init = val_uint;\n            }\n            break;\n        default:\n            fprintf(stderr, \"[restart] unhandled key: %s\\n\", key);\n        }\n\n        if (reuse_mmap != 0) {\n            fprintf(stderr, \"[restart] restart incompatible due to setting for [%s] [old value: %s]\\n\", key, val);\n            break;\n        }\n    }\n\n    if (lines_seen < RESTART_REQUIRED_META) {\n        fprintf(stderr, \"[restart] missing some metadata lines\\n\");\n        reuse_mmap = -1;\n    }\n\n    return reuse_mmap;\n}\n\nint main (int argc, char **argv) {\n    int c;\n    bool lock_memory = false;\n    bool do_daemonize = false;\n    bool preallocate = false;\n    int maxcore = 0;\n    char *username = NULL;\n    char *pid_file = NULL;\n    char *memory_file = NULL;\n    struct passwd *pw;\n    struct rlimit rlim;\n    char *buf;\n    char unit = '\\0';\n    int size_max = 0;\n    int retval = EXIT_SUCCESS;\n    bool protocol_specified = false;\n    bool tcp_specified = false;\n    bool udp_specified = false;\n    bool start_lru_maintainer = true;\n    bool start_lru_crawler = true;\n    bool start_assoc_maint = true;\n    enum hashfunc_type hash_type = MURMUR3_HASH;\n    uint32_t tocrawl;\n    uint32_t slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];\n    bool use_slab_sizes = false;\n    char *slab_sizes_unparsed = NULL;\n    bool slab_chunk_size_changed = false;\n    // struct for restart code. Initialized up here so we can curry\n    // important settings to save or validate.\n    struct _mc_meta_data *meta = malloc(sizeof(struct _mc_meta_data));\n    meta->slab_config = NULL;\n#ifdef EXTSTORE\n    void *storage = NULL;\n    struct extstore_conf_file *storage_file = NULL;\n    struct extstore_conf ext_cf;\n#endif\n    char *subopts, *subopts_orig;\n    char *subopts_value;\n    enum {\n        MAXCONNS_FAST = 0,\n        HASHPOWER_INIT,\n        NO_HASHEXPAND,\n        SLAB_REASSIGN,\n        SLAB_AUTOMOVE,\n        SLAB_AUTOMOVE_RATIO,\n        SLAB_AUTOMOVE_WINDOW,\n        TAIL_REPAIR_TIME,\n        HASH_ALGORITHM,\n        LRU_CRAWLER,\n        LRU_CRAWLER_SLEEP,\n        LRU_CRAWLER_TOCRAWL,\n        LRU_MAINTAINER,\n        HOT_LRU_PCT,\n        WARM_LRU_PCT,\n        HOT_MAX_FACTOR,\n        WARM_MAX_FACTOR,\n        TEMPORARY_TTL,\n        IDLE_TIMEOUT,\n        WATCHER_LOGBUF_SIZE,\n        WORKER_LOGBUF_SIZE,\n        SLAB_SIZES,\n        SLAB_CHUNK_MAX,\n        TRACK_SIZES,\n        NO_INLINE_ASCII_RESP,\n        MODERN,\n        NO_MODERN,\n        NO_CHUNKED_ITEMS,\n        NO_SLAB_REASSIGN,\n        NO_SLAB_AUTOMOVE,\n        NO_MAXCONNS_FAST,\n        INLINE_ASCII_RESP,\n        NO_LRU_CRAWLER,\n        NO_LRU_MAINTAINER,\n        NO_DROP_PRIVILEGES,\n        DROP_PRIVILEGES,\n        RESP_OBJ_MEM_LIMIT,\n        READ_BUF_MEM_LIMIT,\n#ifdef TLS\n        SSL_CERT,\n        SSL_KEY,\n        SSL_VERIFY_MODE,\n        SSL_KEYFORM,\n        SSL_CIPHERS,\n        SSL_CA_CERT,\n        SSL_WBUF_SIZE,\n#endif\n#ifdef MEMCACHED_DEBUG\n        RELAXED_PRIVILEGES,\n#endif\n#ifdef EXTSTORE\n        EXT_PAGE_SIZE,\n        EXT_WBUF_SIZE,\n        EXT_THREADS,\n        EXT_IO_DEPTH,\n        EXT_PATH,\n        EXT_ITEM_SIZE,\n        EXT_ITEM_AGE,\n        EXT_LOW_TTL,\n        EXT_RECACHE_RATE,\n        EXT_COMPACT_UNDER,\n        EXT_DROP_UNDER,\n        EXT_MAX_FRAG,\n        EXT_DROP_UNREAD,\n        SLAB_AUTOMOVE_FREERATIO,\n#endif\n    };\n    char *const subopts_tokens[] = {\n        [MAXCONNS_FAST] = \"maxconns_fast\",\n        [HASHPOWER_INIT] = \"hashpower\",\n        [NO_HASHEXPAND] = \"no_hashexpand\",\n        [SLAB_REASSIGN] = \"slab_reassign\",\n        [SLAB_AUTOMOVE] = \"slab_automove\",\n        [SLAB_AUTOMOVE_RATIO] = \"slab_automove_ratio\",\n        [SLAB_AUTOMOVE_WINDOW] = \"slab_automove_window\",\n        [TAIL_REPAIR_TIME] = \"tail_repair_time\",\n        [HASH_ALGORITHM] = \"hash_algorithm\",\n        [LRU_CRAWLER] = \"lru_crawler\",\n        [LRU_CRAWLER_SLEEP] = \"lru_crawler_sleep\",\n        [LRU_CRAWLER_TOCRAWL] = \"lru_crawler_tocrawl\",\n        [LRU_MAINTAINER] = \"lru_maintainer\",\n        [HOT_LRU_PCT] = \"hot_lru_pct\",\n        [WARM_LRU_PCT] = \"warm_lru_pct\",\n        [HOT_MAX_FACTOR] = \"hot_max_factor\",\n        [WARM_MAX_FACTOR] = \"warm_max_factor\",\n        [TEMPORARY_TTL] = \"temporary_ttl\",\n        [IDLE_TIMEOUT] = \"idle_timeout\",\n        [WATCHER_LOGBUF_SIZE] = \"watcher_logbuf_size\",\n        [WORKER_LOGBUF_SIZE] = \"worker_logbuf_size\",\n        [SLAB_SIZES] = \"slab_sizes\",\n        [SLAB_CHUNK_MAX] = \"slab_chunk_max\",\n        [TRACK_SIZES] = \"track_sizes\",\n        [NO_INLINE_ASCII_RESP] = \"no_inline_ascii_resp\",\n        [MODERN] = \"modern\",\n        [NO_MODERN] = \"no_modern\",\n        [NO_CHUNKED_ITEMS] = \"no_chunked_items\",\n        [NO_SLAB_REASSIGN] = \"no_slab_reassign\",\n        [NO_SLAB_AUTOMOVE] = \"no_slab_automove\",\n        [NO_MAXCONNS_FAST] = \"no_maxconns_fast\",\n        [INLINE_ASCII_RESP] = \"inline_ascii_resp\",\n        [NO_LRU_CRAWLER] = \"no_lru_crawler\",\n        [NO_LRU_MAINTAINER] = \"no_lru_maintainer\",\n        [NO_DROP_PRIVILEGES] = \"no_drop_privileges\",\n        [DROP_PRIVILEGES] = \"drop_privileges\",\n        [RESP_OBJ_MEM_LIMIT] = \"resp_obj_mem_limit\",\n        [READ_BUF_MEM_LIMIT] = \"read_buf_mem_limit\",\n#ifdef TLS\n        [SSL_CERT] = \"ssl_chain_cert\",\n        [SSL_KEY] = \"ssl_key\",\n        [SSL_VERIFY_MODE] = \"ssl_verify_mode\",\n        [SSL_KEYFORM] = \"ssl_keyformat\",\n        [SSL_CIPHERS] = \"ssl_ciphers\",\n        [SSL_CA_CERT] = \"ssl_ca_cert\",\n        [SSL_WBUF_SIZE] = \"ssl_wbuf_size\",\n#endif\n#ifdef MEMCACHED_DEBUG\n        [RELAXED_PRIVILEGES] = \"relaxed_privileges\",\n#endif\n#ifdef EXTSTORE\n        [EXT_PAGE_SIZE] = \"ext_page_size\",\n        [EXT_WBUF_SIZE] = \"ext_wbuf_size\",\n        [EXT_THREADS] = \"ext_threads\",\n        [EXT_IO_DEPTH] = \"ext_io_depth\",\n        [EXT_PATH] = \"ext_path\",\n        [EXT_ITEM_SIZE] = \"ext_item_size\",\n        [EXT_ITEM_AGE] = \"ext_item_age\",\n        [EXT_LOW_TTL] = \"ext_low_ttl\",\n        [EXT_RECACHE_RATE] = \"ext_recache_rate\",\n        [EXT_COMPACT_UNDER] = \"ext_compact_under\",\n        [EXT_DROP_UNDER] = \"ext_drop_under\",\n        [EXT_MAX_FRAG] = \"ext_max_frag\",\n        [EXT_DROP_UNREAD] = \"ext_drop_unread\",\n        [SLAB_AUTOMOVE_FREERATIO] = \"slab_automove_freeratio\",\n#endif\n        NULL\n    };\n\n    if (!sanitycheck()) {\n        free(meta);\n        return EX_OSERR;\n    }\n\n    /* handle SIGINT, SIGTERM */\n    signal(SIGINT, sig_handler);\n    signal(SIGTERM, sig_handler);\n    signal(SIGHUP, sighup_handler);\n    signal(SIGUSR1, sig_usrhandler);\n\n    /* init settings */\n    settings_init();\n    verify_default(\"hash_algorithm\", hash_type == MURMUR3_HASH);\n#ifdef EXTSTORE\n    settings.ext_item_size = 512;\n    settings.ext_item_age = UINT_MAX;\n    settings.ext_low_ttl = 0;\n    settings.ext_recache_rate = 2000;\n    settings.ext_max_frag = 0.8;\n    settings.ext_drop_unread = false;\n    settings.ext_wbuf_size = 1024 * 1024 * 4;\n    settings.ext_compact_under = 0;\n    settings.ext_drop_under = 0;\n    settings.slab_automove_freeratio = 0.01;\n    settings.ext_page_size = 1024 * 1024 * 64;\n    settings.ext_io_threadcount = 1;\n    ext_cf.page_size = settings.ext_page_size;\n    ext_cf.wbuf_size = settings.ext_wbuf_size;\n    ext_cf.io_threadcount = settings.ext_io_threadcount;\n    ext_cf.io_depth = 1;\n    ext_cf.page_buckets = 4;\n    ext_cf.wbuf_count = ext_cf.page_buckets;\n#endif\n\n    /* Run regardless of initializing it later */\n    init_lru_maintainer();\n\n    /* set stderr non-buffering (for running under, say, daemontools) */\n    setbuf(stderr, NULL);\n\n    char *shortopts =\n          \"a:\"  /* access mask for unix socket */\n          \"A\"  /* enable admin shutdown command */\n          \"Z\"   /* enable SSL */\n          \"p:\"  /* TCP port number to listen on */\n          \"s:\"  /* unix socket path to listen on */\n          \"U:\"  /* UDP port number to listen on */\n          \"m:\"  /* max memory to use for items in megabytes */\n          \"M\"   /* return error on memory exhausted */\n          \"c:\"  /* max simultaneous connections */\n          \"k\"   /* lock down all paged memory */\n          \"hiV\" /* help, licence info, version */\n          \"r\"   /* maximize core file limit */\n          \"v\"   /* verbose */\n          \"d\"   /* daemon mode */\n          \"l:\"  /* interface to listen on */\n          \"u:\"  /* user identity to run as */\n          \"P:\"  /* save PID in file */\n          \"f:\"  /* factor? */\n          \"n:\"  /* minimum space allocated for key+value+flags */\n          \"t:\"  /* threads */\n          \"D:\"  /* prefix delimiter? */\n          \"L\"   /* Large memory pages */\n          \"R:\"  /* max requests per event */\n          \"C\"   /* Disable use of CAS */\n          \"b:\"  /* backlog queue limit */\n          \"B:\"  /* Binding protocol */\n          \"I:\"  /* Max item size */\n          \"S\"   /* Sasl ON */\n          \"F\"   /* Disable flush_all */\n          \"X\"   /* Disable dump commands */\n          \"W\"   /* Disable watch commands */\n          \"Y:\"   /* Enable token auth */\n          \"e:\"  /* mmap path for external item memory */\n          \"o:\"  /* Extended generic options */\n          ;\n\n    /* process arguments */\n#ifdef HAVE_GETOPT_LONG\n    const struct option longopts[] = {\n        {\"unix-mask\", required_argument, 0, 'a'},\n        {\"enable-shutdown\", no_argument, 0, 'A'},\n        {\"enable-ssl\", no_argument, 0, 'Z'},\n        {\"port\", required_argument, 0, 'p'},\n        {\"unix-socket\", required_argument, 0, 's'},\n        {\"udp-port\", required_argument, 0, 'U'},\n        {\"memory-limit\", required_argument, 0, 'm'},\n        {\"disable-evictions\", no_argument, 0, 'M'},\n        {\"conn-limit\", required_argument, 0, 'c'},\n        {\"lock-memory\", no_argument, 0, 'k'},\n        {\"help\", no_argument, 0, 'h'},\n        {\"license\", no_argument, 0, 'i'},\n        {\"version\", no_argument, 0, 'V'},\n        {\"enable-coredumps\", no_argument, 0, 'r'},\n        {\"verbose\", optional_argument, 0, 'v'},\n        {\"daemon\", no_argument, 0, 'd'},\n        {\"listen\", required_argument, 0, 'l'},\n        {\"user\", required_argument, 0, 'u'},\n        {\"pidfile\", required_argument, 0, 'P'},\n        {\"slab-growth-factor\", required_argument, 0, 'f'},\n        {\"slab-min-size\", required_argument, 0, 'n'},\n        {\"threads\", required_argument, 0, 't'},\n        {\"enable-largepages\", no_argument, 0, 'L'},\n        {\"max-reqs-per-event\", required_argument, 0, 'R'},\n        {\"disable-cas\", no_argument, 0, 'C'},\n        {\"listen-backlog\", required_argument, 0, 'b'},\n        {\"protocol\", required_argument, 0, 'B'},\n        {\"max-item-size\", required_argument, 0, 'I'},\n        {\"enable-sasl\", no_argument, 0, 'S'},\n        {\"disable-flush-all\", no_argument, 0, 'F'},\n        {\"disable-dumping\", no_argument, 0, 'X'},\n        {\"disable-watch\", no_argument, 0, 'W'},\n        {\"auth-file\", required_argument, 0, 'Y'},\n        {\"memory-file\", required_argument, 0, 'e'},\n        {\"extended\", required_argument, 0, 'o'},\n        {0, 0, 0, 0}\n    };\n    int optindex;\n    while (-1 != (c = getopt_long(argc, argv, shortopts,\n                    longopts, &optindex))) {\n#else\n    while (-1 != (c = getopt(argc, argv, shortopts))) {\n#endif\n        switch (c) {\n        case 'A':\n            /* enables \"shutdown\" command */\n            settings.shutdown_command = true;\n            break;\n        case 'Z':\n            /* enable secure communication*/\n#ifdef TLS\n            settings.ssl_enabled = true;\n#else\n            fprintf(stderr, \"This server is not built with TLS support.\\n\");\n            exit(EX_USAGE);\n#endif\n            break;\n        case 'a':\n            /* access for unix domain socket, as octal mask (like chmod)*/\n            settings.access= strtol(optarg,NULL,8);\n            break;\n        case 'U':\n            settings.udpport = atoi(optarg);\n            udp_specified = true;\n            break;\n        case 'p':\n            settings.port = atoi(optarg);\n            tcp_specified = true;\n            break;\n        case 's':\n            settings.socketpath = optarg;\n            break;\n        case 'm':\n            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n            break;\n        case 'M':\n            settings.evict_to_free = 0;\n            break;\n        case 'c':\n            settings.maxconns = atoi(optarg);\n            if (settings.maxconns <= 0) {\n                fprintf(stderr, \"Maximum connections must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'h':\n            usage();\n            exit(EXIT_SUCCESS);\n        case 'i':\n            usage_license();\n            exit(EXIT_SUCCESS);\n        case 'V':\n            printf(PACKAGE \" \" VERSION \"\\n\");\n            exit(EXIT_SUCCESS);\n        case 'k':\n            lock_memory = true;\n            break;\n        case 'v':\n            settings.verbose++;\n            break;\n        case 'l':\n            if (settings.inter != NULL) {\n                if (strstr(settings.inter, optarg) != NULL) {\n                    break;\n                }\n                size_t len = strlen(settings.inter) + strlen(optarg) + 2;\n                char *p = malloc(len);\n                if (p == NULL) {\n                    fprintf(stderr, \"Failed to allocate memory\\n\");\n                    return 1;\n                }\n                snprintf(p, len, \"%s,%s\", settings.inter, optarg);\n                free(settings.inter);\n                settings.inter = p;\n            } else {\n                settings.inter= strdup(optarg);\n            }\n            break;\n        case 'd':\n            do_daemonize = true;\n            break;\n        case 'r':\n            maxcore = 1;\n            break;\n        case 'R':\n            settings.reqs_per_event = atoi(optarg);\n            if (settings.reqs_per_event == 0) {\n                fprintf(stderr, \"Number of requests per event must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'u':\n            username = optarg;\n            break;\n        case 'P':\n            pid_file = optarg;\n            break;\n        case 'e':\n            memory_file = optarg;\n            break;\n        case 'f':\n            settings.factor = atof(optarg);\n            if (settings.factor <= 1.0) {\n                fprintf(stderr, \"Factor must be greater than 1\\n\");\n                return 1;\n            }\n            meta->slab_config = strdup(optarg);\n            break;\n        case 'n':\n            settings.chunk_size = atoi(optarg);\n            if (settings.chunk_size == 0) {\n                fprintf(stderr, \"Chunk size must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 't':\n            settings.num_threads = atoi(optarg);\n            if (settings.num_threads <= 0) {\n                fprintf(stderr, \"Number of threads must be greater than 0\\n\");\n                return 1;\n            }\n            /* There're other problems when you get above 64 threads.\n             * In the future we should portably detect # of cores for the\n             * default.\n             */\n            if (settings.num_threads > 64) {\n                fprintf(stderr, \"WARNING: Setting a high number of worker\"\n                                \"threads is not recommended.\\n\"\n                                \" Set this value to the number of cores in\"\n                                \" your machine or less.\\n\");\n            }\n            break;\n        case 'D':\n            if (! optarg || ! optarg[0]) {\n                fprintf(stderr, \"No delimiter specified\\n\");\n                return 1;\n            }\n            settings.prefix_delimiter = optarg[0];\n            settings.detail_enabled = 1;\n            break;\n        case 'L' :\n            if (enable_large_pages() == 0) {\n                preallocate = true;\n            } else {\n                fprintf(stderr, \"Cannot enable large pages on this system\\n\"\n                    \"(There is no support as of this version)\\n\");\n                return 1;\n            }\n            break;\n        case 'C' :\n            settings.use_cas = false;\n            break;\n        case 'b' :\n            settings.backlog = atoi(optarg);\n            break;\n        case 'B':\n            protocol_specified = true;\n            if (strcmp(optarg, \"auto\") == 0) {\n                settings.binding_protocol = negotiating_prot;\n            } else if (strcmp(optarg, \"binary\") == 0) {\n                settings.binding_protocol = binary_prot;\n            } else if (strcmp(optarg, \"ascii\") == 0) {\n                settings.binding_protocol = ascii_prot;\n            } else {\n                fprintf(stderr, \"Invalid value for binding protocol: %s\\n\"\n                        \" -- should be one of auto, binary, or ascii\\n\", optarg);\n                exit(EX_USAGE);\n            }\n            break;\n        case 'I':\n            buf = strdup(optarg);\n            unit = buf[strlen(buf)-1];\n            if (unit == 'k' || unit == 'm' ||\n                unit == 'K' || unit == 'M') {\n                buf[strlen(buf)-1] = '\\0';\n                size_max = atoi(buf);\n                if (unit == 'k' || unit == 'K')\n                    size_max *= 1024;\n                if (unit == 'm' || unit == 'M')\n                    size_max *= 1024 * 1024;\n                settings.item_size_max = size_max;\n            } else {\n                settings.item_size_max = atoi(buf);\n            }\n            free(buf);\n            break;\n        case 'S': /* set Sasl authentication to true. Default is false */\n#ifndef ENABLE_SASL\n            fprintf(stderr, \"This server is not built with SASL support.\\n\");\n            exit(EX_USAGE);\n#endif\n            settings.sasl = true;\n            break;\n       case 'F' :\n            settings.flush_enabled = false;\n            break;\n       case 'X' :\n            settings.dump_enabled = false;\n            break;\n       case 'W' :\n            settings.watch_enabled = false;\n            break;\n       case 'Y' :\n            // dupe the file path now just in case the options get mangled.\n            settings.auth_file = strdup(optarg);\n            break;\n        case 'o': /* It's sub-opts time! */\n            subopts_orig = subopts = strdup(optarg); /* getsubopt() changes the original args */\n\n            while (*subopts != '\\0') {\n\n            switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {\n            case MAXCONNS_FAST:\n                settings.maxconns_fast = true;\n                break;\n            case HASHPOWER_INIT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing numeric argument for hashpower\\n\");\n                    return 1;\n                }\n                settings.hashpower_init = atoi(subopts_value);\n                if (settings.hashpower_init < 12) {\n                    fprintf(stderr, \"Initial hashtable multiplier of %d is too low\\n\",\n                        settings.hashpower_init);\n                    return 1;\n                } else if (settings.hashpower_init > 32) {\n                    fprintf(stderr, \"Initial hashtable multiplier of %d is too high\\n\"\n                        \"Choose a value based on \\\"STAT hash_power_level\\\" from a running instance\\n\",\n                        settings.hashpower_init);\n                    return 1;\n                }\n                break;\n            case NO_HASHEXPAND:\n                start_assoc_maint = false;\n                break;\n            case SLAB_REASSIGN:\n                settings.slab_reassign = true;\n                break;\n            case SLAB_AUTOMOVE:\n                if (subopts_value == NULL) {\n                    settings.slab_automove = 1;\n                    break;\n                }\n                settings.slab_automove = atoi(subopts_value);\n                if (settings.slab_automove < 0 || settings.slab_automove > 2) {\n                    fprintf(stderr, \"slab_automove must be between 0 and 2\\n\");\n                    return 1;\n                }\n                break;\n            case SLAB_AUTOMOVE_RATIO:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing slab_automove_ratio argument\\n\");\n                    return 1;\n                }\n                settings.slab_automove_ratio = atof(subopts_value);\n                if (settings.slab_automove_ratio <= 0 || settings.slab_automove_ratio > 1) {\n                    fprintf(stderr, \"slab_automove_ratio must be > 0 and < 1\\n\");\n                    return 1;\n                }\n                break;\n            case SLAB_AUTOMOVE_WINDOW:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing slab_automove_window argument\\n\");\n                    return 1;\n                }\n                settings.slab_automove_window = atoi(subopts_value);\n                if (settings.slab_automove_window < 3) {\n                    fprintf(stderr, \"slab_automove_window must be > 2\\n\");\n                    return 1;\n                }\n                break;\n            case TAIL_REPAIR_TIME:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing numeric argument for tail_repair_time\\n\");\n                    return 1;\n                }\n                settings.tail_repair_time = atoi(subopts_value);\n                if (settings.tail_repair_time < 10) {\n                    fprintf(stderr, \"Cannot set tail_repair_time to less than 10 seconds\\n\");\n                    return 1;\n                }\n                break;\n            case HASH_ALGORITHM:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing hash_algorithm argument\\n\");\n                    return 1;\n                };\n                if (strcmp(subopts_value, \"jenkins\") == 0) {\n                    hash_type = JENKINS_HASH;\n                } else if (strcmp(subopts_value, \"murmur3\") == 0) {\n                    hash_type = MURMUR3_HASH;\n                } else {\n                    fprintf(stderr, \"Unknown hash_algorithm option (jenkins, murmur3)\\n\");\n                    return 1;\n                }\n                break;\n            case LRU_CRAWLER:\n                start_lru_crawler = true;\n                break;\n            case LRU_CRAWLER_SLEEP:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing lru_crawler_sleep value\\n\");\n                    return 1;\n                }\n                settings.lru_crawler_sleep = atoi(subopts_value);\n                if (settings.lru_crawler_sleep > 1000000 || settings.lru_crawler_sleep < 0) {\n                    fprintf(stderr, \"LRU crawler sleep must be between 0 and 1 second\\n\");\n                    return 1;\n                }\n                break;\n            case LRU_CRAWLER_TOCRAWL:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing lru_crawler_tocrawl value\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &tocrawl)) {\n                    fprintf(stderr, \"lru_crawler_tocrawl takes a numeric 32bit value\\n\");\n                    return 1;\n                }\n                settings.lru_crawler_tocrawl = tocrawl;\n                break;\n            case LRU_MAINTAINER:\n                start_lru_maintainer = true;\n                settings.lru_segmented = true;\n                break;\n            case HOT_LRU_PCT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing hot_lru_pct argument\\n\");\n                    return 1;\n                }\n                settings.hot_lru_pct = atoi(subopts_value);\n                if (settings.hot_lru_pct < 1 || settings.hot_lru_pct >= 80) {\n                    fprintf(stderr, \"hot_lru_pct must be > 1 and < 80\\n\");\n                    return 1;\n                }\n                break;\n            case WARM_LRU_PCT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing warm_lru_pct argument\\n\");\n                    return 1;\n                }\n                settings.warm_lru_pct = atoi(subopts_value);\n                if (settings.warm_lru_pct < 1 || settings.warm_lru_pct >= 80) {\n                    fprintf(stderr, \"warm_lru_pct must be > 1 and < 80\\n\");\n                    return 1;\n                }\n                break;\n            case HOT_MAX_FACTOR:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing hot_max_factor argument\\n\");\n                    return 1;\n                }\n                settings.hot_max_factor = atof(subopts_value);\n                if (settings.hot_max_factor <= 0) {\n                    fprintf(stderr, \"hot_max_factor must be > 0\\n\");\n                    return 1;\n                }\n                break;\n            case WARM_MAX_FACTOR:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing warm_max_factor argument\\n\");\n                    return 1;\n                }\n                settings.warm_max_factor = atof(subopts_value);\n                if (settings.warm_max_factor <= 0) {\n                    fprintf(stderr, \"warm_max_factor must be > 0\\n\");\n                    return 1;\n                }\n                break;\n            case TEMPORARY_TTL:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing temporary_ttl argument\\n\");\n                    return 1;\n                }\n                settings.temp_lru = true;\n                settings.temporary_ttl = atoi(subopts_value);\n                break;\n            case IDLE_TIMEOUT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing numeric argument for idle_timeout\\n\");\n                    return 1;\n                }\n                settings.idle_timeout = atoi(subopts_value);\n                break;\n            case WATCHER_LOGBUF_SIZE:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing watcher_logbuf_size argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.logger_watcher_buf_size)) {\n                    fprintf(stderr, \"could not parse argument to watcher_logbuf_size\\n\");\n                    return 1;\n                }\n                settings.logger_watcher_buf_size *= 1024; /* kilobytes */\n                break;\n            case WORKER_LOGBUF_SIZE:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing worker_logbuf_size argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.logger_buf_size)) {\n                    fprintf(stderr, \"could not parse argument to worker_logbuf_size\\n\");\n                    return 1;\n                }\n                settings.logger_buf_size *= 1024; /* kilobytes */\n            case SLAB_SIZES:\n                slab_sizes_unparsed = strdup(subopts_value);\n                break;\n            case SLAB_CHUNK_MAX:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing slab_chunk_max argument\\n\");\n                }\n                if (!safe_strtol(subopts_value, &settings.slab_chunk_size_max)) {\n                    fprintf(stderr, \"could not parse argument to slab_chunk_max\\n\");\n                }\n                slab_chunk_size_changed = true;\n                break;\n            case TRACK_SIZES:\n                item_stats_sizes_init();\n                break;\n            case NO_INLINE_ASCII_RESP:\n                break;\n            case INLINE_ASCII_RESP:\n                break;\n            case NO_CHUNKED_ITEMS:\n                settings.slab_chunk_size_max = settings.slab_page_size;\n                break;\n            case NO_SLAB_REASSIGN:\n                settings.slab_reassign = false;\n                break;\n            case NO_SLAB_AUTOMOVE:\n                settings.slab_automove = 0;\n                break;\n            case NO_MAXCONNS_FAST:\n                settings.maxconns_fast = false;\n                break;\n            case NO_LRU_CRAWLER:\n                settings.lru_crawler = false;\n                start_lru_crawler = false;\n                break;\n            case NO_LRU_MAINTAINER:\n                start_lru_maintainer = false;\n                settings.lru_segmented = false;\n                break;\n#ifdef TLS\n            case SSL_CERT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ssl_chain_cert argument\\n\");\n                    return 1;\n                }\n                settings.ssl_chain_cert = strdup(subopts_value);\n                break;\n            case SSL_KEY:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ssl_key argument\\n\");\n                    return 1;\n                }\n                settings.ssl_key = strdup(subopts_value);\n                break;\n            case SSL_VERIFY_MODE:\n            {\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ssl_verify_mode argument\\n\");\n                    return 1;\n                }\n                int verify  = 0;\n                if (!safe_strtol(subopts_value, &verify)) {\n                    fprintf(stderr, \"could not parse argument to ssl_verify_mode\\n\");\n                    return 1;\n                }\n                switch(verify) {\n                    case 0:\n                        settings.ssl_verify_mode = SSL_VERIFY_NONE;\n                        break;\n                    case 1:\n                        settings.ssl_verify_mode = SSL_VERIFY_PEER;\n                        break;\n                    case 2:\n                        settings.ssl_verify_mode = SSL_VERIFY_PEER |\n                                                    SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n                        break;\n                    case 3:\n                        settings.ssl_verify_mode = SSL_VERIFY_PEER |\n                                                    SSL_VERIFY_FAIL_IF_NO_PEER_CERT |\n                                                    SSL_VERIFY_CLIENT_ONCE;\n                        break;\n                    default:\n                        fprintf(stderr, \"Invalid ssl_verify_mode. Use help to see valid options.\\n\");\n                        return 1;\n                }\n                break;\n            }\n            case SSL_KEYFORM:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ssl_keyformat argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtol(subopts_value, &settings.ssl_keyformat)) {\n                    fprintf(stderr, \"could not parse argument to ssl_keyformat\\n\");\n                    return 1;\n                }\n                break;\n            case SSL_CIPHERS:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ssl_ciphers argument\\n\");\n                    return 1;\n                }\n                settings.ssl_ciphers = strdup(subopts_value);\n                break;\n            case SSL_CA_CERT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ssl_ca_cert argument\\n\");\n                    return 1;\n                }\n                settings.ssl_ca_cert = strdup(subopts_value);\n                break;\n            case SSL_WBUF_SIZE:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ssl_wbuf_size argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.ssl_wbuf_size)) {\n                    fprintf(stderr, \"could not parse argument to ssl_wbuf_size\\n\");\n                    return 1;\n                }\n                settings.ssl_wbuf_size *= 1024; /* kilobytes */\n                break;\n#endif\n#ifdef EXTSTORE\n            case EXT_PAGE_SIZE:\n                if (storage_file) {\n                    fprintf(stderr, \"Must specify ext_page_size before any ext_path arguments\\n\");\n                    return 1;\n                }\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_page_size argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &ext_cf.page_size)) {\n                    fprintf(stderr, \"could not parse argument to ext_page_size\\n\");\n                    return 1;\n                }\n                ext_cf.page_size *= 1024 * 1024; /* megabytes */\n                break;\n            case EXT_WBUF_SIZE:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_wbuf_size argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &ext_cf.wbuf_size)) {\n                    fprintf(stderr, \"could not parse argument to ext_wbuf_size\\n\");\n                    return 1;\n                }\n                ext_cf.wbuf_size *= 1024 * 1024; /* megabytes */\n                settings.ext_wbuf_size = ext_cf.wbuf_size;\n                break;\n            case EXT_THREADS:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_threads argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &ext_cf.io_threadcount)) {\n                    fprintf(stderr, \"could not parse argument to ext_threads\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_IO_DEPTH:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_io_depth argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &ext_cf.io_depth)) {\n                    fprintf(stderr, \"could not parse argument to ext_io_depth\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_ITEM_SIZE:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_item_size argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.ext_item_size)) {\n                    fprintf(stderr, \"could not parse argument to ext_item_size\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_ITEM_AGE:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_item_age argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.ext_item_age)) {\n                    fprintf(stderr, \"could not parse argument to ext_item_age\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_LOW_TTL:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_low_ttl argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.ext_low_ttl)) {\n                    fprintf(stderr, \"could not parse argument to ext_low_ttl\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_RECACHE_RATE:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_recache_rate argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.ext_recache_rate)) {\n                    fprintf(stderr, \"could not parse argument to ext_recache_rate\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_COMPACT_UNDER:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_compact_under argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.ext_compact_under)) {\n                    fprintf(stderr, \"could not parse argument to ext_compact_under\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_DROP_UNDER:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_drop_under argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.ext_drop_under)) {\n                    fprintf(stderr, \"could not parse argument to ext_drop_under\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_MAX_FRAG:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_max_frag argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtod(subopts_value, &settings.ext_max_frag)) {\n                    fprintf(stderr, \"could not parse argument to ext_max_frag\\n\");\n                    return 1;\n                }\n                break;\n            case SLAB_AUTOMOVE_FREERATIO:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing slab_automove_freeratio argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtod(subopts_value, &settings.slab_automove_freeratio)) {\n                    fprintf(stderr, \"could not parse argument to slab_automove_freeratio\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_DROP_UNREAD:\n                settings.ext_drop_unread = true;\n                break;\n            case EXT_PATH:\n                if (subopts_value) {\n                    struct extstore_conf_file *tmp = storage_conf_parse(subopts_value, ext_cf.page_size);\n                    if (tmp == NULL) {\n                        fprintf(stderr, \"failed to parse ext_path argument\\n\");\n                        return 1;\n                    }\n                    if (storage_file != NULL) {\n                        tmp->next = storage_file;\n                    }\n                    storage_file = tmp;\n                } else {\n                    fprintf(stderr, \"missing argument to ext_path, ie: ext_path=/d/file:5G\\n\");\n                    return 1;\n                }\n                break;\n#endif\n            case MODERN:\n                /* currently no new defaults */\n                break;\n            case NO_MODERN:\n                if (!slab_chunk_size_changed) {\n                    settings.slab_chunk_size_max = settings.slab_page_size;\n                }\n                settings.slab_reassign = false;\n                settings.slab_automove = 0;\n                settings.maxconns_fast = false;\n                settings.lru_segmented = false;\n                hash_type = JENKINS_HASH;\n                start_lru_crawler = false;\n                start_lru_maintainer = false;\n                break;\n            case NO_DROP_PRIVILEGES:\n                settings.drop_privileges = false;\n                break;\n            case DROP_PRIVILEGES:\n                settings.drop_privileges = true;\n                break;\n            case RESP_OBJ_MEM_LIMIT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing resp_obj_mem_limit argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.resp_obj_mem_limit)) {\n                    fprintf(stderr, \"could not parse argument to resp_obj_mem_limit\\n\");\n                    return 1;\n                }\n                settings.resp_obj_mem_limit *= 1024 * 1024; /* megabytes */\n                break;\n            case READ_BUF_MEM_LIMIT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing read_buf_mem_limit argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.read_buf_mem_limit)) {\n                    fprintf(stderr, \"could not parse argument to read_buf_mem_limit\\n\");\n                    return 1;\n                }\n                settings.read_buf_mem_limit *= 1024 * 1024; /* megabytes */\n                break;\n#ifdef MEMCACHED_DEBUG\n            case RELAXED_PRIVILEGES:\n                settings.relaxed_privileges = true;\n                break;\n#endif\n            default:\n                printf(\"Illegal suboption \\\"%s\\\"\\n\", subopts_value);\n                return 1;\n            }\n\n            }\n            free(subopts_orig);\n            break;\n        default:\n            fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    if (settings.item_size_max < ITEM_SIZE_MAX_LOWER_LIMIT) {\n        fprintf(stderr, \"Item max size cannot be less than 1024 bytes.\\n\");\n        exit(EX_USAGE);\n    }\n    if (settings.item_size_max > (settings.maxbytes / 2)) {\n        fprintf(stderr, \"Cannot set item size limit higher than 1/2 of memory max.\\n\");\n        exit(EX_USAGE);\n    }\n    if (settings.item_size_max > (ITEM_SIZE_MAX_UPPER_LIMIT)) {\n        fprintf(stderr, \"Cannot set item size limit higher than a gigabyte.\\n\");\n        exit(EX_USAGE);\n    }\n    if (settings.item_size_max > 1024 * 1024) {\n        if (!slab_chunk_size_changed) {\n            // Ideal new default is 16k, but needs stitching.\n            settings.slab_chunk_size_max = settings.slab_page_size / 2;\n        }\n    }\n\n    if (settings.slab_chunk_size_max > settings.item_size_max) {\n        fprintf(stderr, \"slab_chunk_max (bytes: %d) cannot be larger than -I (item_size_max %d)\\n\",\n                settings.slab_chunk_size_max, settings.item_size_max);\n        exit(EX_USAGE);\n    }\n\n    if (settings.item_size_max % settings.slab_chunk_size_max != 0) {\n        fprintf(stderr, \"-I (item_size_max: %d) must be evenly divisible by slab_chunk_max (bytes: %d)\\n\",\n                settings.item_size_max, settings.slab_chunk_size_max);\n        exit(EX_USAGE);\n    }\n\n    if (settings.slab_page_size % settings.slab_chunk_size_max != 0) {\n        fprintf(stderr, \"slab_chunk_max (bytes: %d) must divide evenly into %d (slab_page_size)\\n\",\n                settings.slab_chunk_size_max, settings.slab_page_size);\n        exit(EX_USAGE);\n    }\n#ifdef EXTSTORE\n    if (storage_file) {\n        if (settings.item_size_max > ext_cf.wbuf_size) {\n            fprintf(stderr, \"-I (item_size_max: %d) cannot be larger than ext_wbuf_size: %d\\n\",\n                settings.item_size_max, ext_cf.wbuf_size);\n            exit(EX_USAGE);\n        }\n\n        if (settings.udpport) {\n            fprintf(stderr, \"Cannot use UDP with extstore enabled (-U 0 to disable)\\n\");\n            exit(EX_USAGE);\n        }\n    }\n#endif\n    // Reserve this for the new default. If factor size hasn't changed, use\n    // new default.\n    /*if (settings.slab_chunk_size_max == 16384 && settings.factor == 1.25) {\n        settings.factor = 1.08;\n    }*/\n\n    if (slab_sizes_unparsed != NULL) {\n        // want the unedited string for restart code.\n        char *temp = strdup(slab_sizes_unparsed);\n        if (_parse_slab_sizes(slab_sizes_unparsed, slab_sizes)) {\n            use_slab_sizes = true;\n            if (meta->slab_config) {\n                free(meta->slab_config);\n            }\n            meta->slab_config = temp;\n        } else {\n            exit(EX_USAGE);\n        }\n    } else if (!meta->slab_config) {\n        // using the default factor.\n        meta->slab_config = \"1.25\";\n    }\n\n    if (settings.hot_lru_pct + settings.warm_lru_pct > 80) {\n        fprintf(stderr, \"hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\\n\");\n        exit(EX_USAGE);\n    }\n\n    if (settings.temp_lru && !start_lru_maintainer) {\n        fprintf(stderr, \"temporary_ttl requires lru_maintainer to be enabled\\n\");\n        exit(EX_USAGE);\n    }\n\n    if (hash_init(hash_type) != 0) {\n        fprintf(stderr, \"Failed to initialize hash_algorithm!\\n\");\n        exit(EX_USAGE);\n    }\n\n    /*\n     * Use one workerthread to serve each UDP port if the user specified\n     * multiple ports\n     */\n    if (settings.inter != NULL && strchr(settings.inter, ',')) {\n        settings.num_threads_per_udp = 1;\n    } else {\n        settings.num_threads_per_udp = settings.num_threads;\n    }\n\n    if (settings.sasl) {\n        if (!protocol_specified) {\n            settings.binding_protocol = binary_prot;\n        } else {\n            if (settings.binding_protocol != binary_prot) {\n                fprintf(stderr, \"ERROR: You cannot allow the ASCII protocol while using SASL.\\n\");\n                exit(EX_USAGE);\n            }\n        }\n\n        if (settings.udpport) {\n            fprintf(stderr, \"ERROR: Cannot enable UDP while using binary SASL authentication.\\n\");\n            exit(EX_USAGE);\n        }\n    }\n\n    if (settings.auth_file) {\n        if (!protocol_specified) {\n            settings.binding_protocol = ascii_prot;\n        } else {\n            if (settings.binding_protocol != ascii_prot) {\n                fprintf(stderr, \"ERROR: You cannot allow the BINARY protocol while using ascii authentication tokens.\\n\");\n                exit(EX_USAGE);\n            }\n        }\n    }\n\n    if (udp_specified && settings.udpport != 0 && !tcp_specified) {\n        settings.port = settings.udpport;\n    }\n\n\n#ifdef TLS\n    /*\n     * Setup SSL if enabled\n     */\n    if (settings.ssl_enabled) {\n        if (!settings.port) {\n            fprintf(stderr, \"ERROR: You cannot enable SSL without a TCP port.\\n\");\n            exit(EX_USAGE);\n        }\n        // openssl init methods.\n        SSL_load_error_strings();\n        SSLeay_add_ssl_algorithms();\n        // Initiate the SSL context.\n        ssl_init();\n    }\n#endif\n\n    if (maxcore != 0) {\n        struct rlimit rlim_new;\n        /*\n         * First try raising to infinity; if that fails, try bringing\n         * the soft limit to the hard.\n         */\n        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {\n            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;\n            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {\n                /* failed. try raising just to the old max */\n                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;\n                (void)setrlimit(RLIMIT_CORE, &rlim_new);\n            }\n        }\n        /*\n         * getrlimit again to see what we ended up with. Only fail if\n         * the soft limit ends up 0, because then no core files will be\n         * created at all.\n         */\n\n        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {\n            fprintf(stderr, \"failed to ensure corefile creation\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /*\n     * If needed, increase rlimits to allow as many connections\n     * as needed.\n     */\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n        fprintf(stderr, \"failed to getrlimit number of files\\n\");\n        exit(EX_OSERR);\n    } else {\n        rlim.rlim_cur = settings.maxconns;\n        rlim.rlim_max = settings.maxconns;\n        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n            fprintf(stderr, \"failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /* lose root privileges if we have them */\n    if (getuid() == 0 || geteuid() == 0) {\n        if (username == 0 || *username == '\\0') {\n            fprintf(stderr, \"can't run as root without the -u switch\\n\");\n            exit(EX_USAGE);\n        }\n        if ((pw = getpwnam(username)) == 0) {\n            fprintf(stderr, \"can't find the user %s to switch to\\n\", username);\n            exit(EX_NOUSER);\n        }\n        if (setgroups(0, NULL) < 0) {\n            /* setgroups may fail with EPERM, indicating we are already in a\n             * minimally-privileged state. In that case we continue. For all\n             * other failure codes we exit.\n             *\n             * Note that errno is stored here because fprintf may change it.\n             */\n            bool should_exit = errno != EPERM;\n            fprintf(stderr, \"failed to drop supplementary groups: %s\\n\",\n                    strerror(errno));\n            if (should_exit) {\n                exit(EX_OSERR);\n            }\n        }\n        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {\n            fprintf(stderr, \"failed to assume identity of user %s\\n\", username);\n            exit(EX_OSERR);\n        }\n    }\n\n    /* Initialize Sasl if -S was specified */\n    if (settings.sasl) {\n        init_sasl();\n    }\n\n    /* daemonize if requested */\n    /* if we want to ensure our ability to dump core, don't chdir to / */\n    if (do_daemonize) {\n        if (sigignore(SIGHUP) == -1) {\n            perror(\"Failed to ignore SIGHUP\");\n        }\n        if (daemonize(maxcore, settings.verbose) == -1) {\n            fprintf(stderr, \"failed to daemon() in order to daemonize\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* lock paged memory if needed */\n    if (lock_memory) {\n#ifdef HAVE_MLOCKALL\n        int res = mlockall(MCL_CURRENT | MCL_FUTURE);\n        if (res != 0) {\n            fprintf(stderr, \"warning: -k invalid, mlockall() failed: %s\\n\",\n                    strerror(errno));\n        }\n#else\n        fprintf(stderr, \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");\n#endif\n    }\n\n    /* initialize main thread libevent instance */\n#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101\n    /* If libevent version is larger/equal to 2.0.2-alpha, use newer version */\n    struct event_config *ev_config;\n    ev_config = event_config_new();\n    event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);\n    main_base = event_base_new_with_config(ev_config);\n    event_config_free(ev_config);\n#else\n    /* Otherwise, use older API */\n    main_base = event_init();\n#endif\n\n    /* Load initial auth file if required */\n    if (settings.auth_file) {\n        if (settings.udpport) {\n            fprintf(stderr, \"Cannot use UDP with ascii authentication enabled (-U 0 to disable)\\n\");\n            exit(EX_USAGE);\n        }\n\n        switch (authfile_load(settings.auth_file)) {\n            case AUTHFILE_MISSING: // fall through.\n            case AUTHFILE_OPENFAIL:\n                vperror(\"Could not open authfile [%s] for reading\", settings.auth_file);\n                exit(EXIT_FAILURE);\n                break;\n            case AUTHFILE_OOM:\n                fprintf(stderr, \"Out of memory reading password file: %s\", settings.auth_file);\n                exit(EXIT_FAILURE);\n                break;\n            case AUTHFILE_MALFORMED:\n                fprintf(stderr, \"Authfile [%s] has a malformed entry. Should be 'user:password'\", settings.auth_file);\n                exit(EXIT_FAILURE);\n                break;\n            case AUTHFILE_OK:\n                break;\n        }\n    }\n\n    /* initialize other stuff */\n    stats_init();\n    logger_init();\n    conn_init();\n    bool reuse_mem = false;\n    void *mem_base = NULL;\n    bool prefill = false;\n    if (memory_file != NULL) {\n        preallocate = true;\n        // Easier to manage memory if we prefill the global pool when reusing.\n        prefill = true;\n        restart_register(\"main\", _mc_meta_load_cb, _mc_meta_save_cb, meta);\n        reuse_mem = restart_mmap_open(settings.maxbytes,\n                        memory_file,\n                        &mem_base);\n        // The \"save\" callback gets called when we're closing out the mmap,\n        // but we don't know what the mmap_base is until after we call open.\n        // So we pass the struct above but have to fill it in here so the\n        // data's available during the save routine.\n        meta->mmap_base = mem_base;\n        // Also, the callbacks for load() run before _open returns, so we\n        // should have the old base in 'meta' as of here.\n    }\n    // Initialize the hash table _after_ checking restart metadata.\n    // We override the hash table start argument with what was live\n    // previously, to avoid filling a huge set of items into a tiny hash\n    // table.\n    assoc_init(settings.hashpower_init);\n#ifdef EXTSTORE\n    if (storage_file && reuse_mem) {\n        fprintf(stderr, \"[restart] memory restart with extstore not presently supported.\\n\");\n        reuse_mem = false;\n    }\n#endif\n    slabs_init(settings.maxbytes, settings.factor, preallocate,\n            use_slab_sizes ? slab_sizes : NULL, mem_base, reuse_mem);\n#ifdef EXTSTORE\n    if (storage_file) {\n        enum extstore_res eres;\n        if (settings.ext_compact_under == 0) {\n            // If changing the default fraction (4), change the help text as well.\n            settings.ext_compact_under = storage_file->page_count / 4;\n            /* Only rescues non-COLD items if below this threshold */\n            settings.ext_drop_under = storage_file->page_count / 4;\n        }\n        crc32c_init();\n        /* Init free chunks to zero. */\n        for (int x = 0; x < MAX_NUMBER_OF_SLAB_CLASSES; x++) {\n            settings.ext_free_memchunks[x] = 0;\n        }\n        storage = extstore_init(storage_file, &ext_cf, &eres);\n        if (storage == NULL) {\n            fprintf(stderr, \"Failed to initialize external storage: %s\\n\",\n                    extstore_err(eres));\n            if (eres == EXTSTORE_INIT_OPEN_FAIL) {\n                perror(\"extstore open\");\n            }\n            exit(EXIT_FAILURE);\n        }\n        ext_storage = storage;\n        /* page mover algorithm for extstore needs memory prefilled */\n        prefill = true;\n    }\n#endif\n\n    if (settings.drop_privileges) {\n        setup_privilege_violations_handler();\n    }\n\n    if (prefill)\n        slabs_prefill_global();\n    /* In restartable mode and we've decided to issue a fixup on memory */\n    if (memory_file != NULL && reuse_mem) {\n        mc_ptr_t old_base = meta->old_base;\n        assert(old_base == meta->old_base);\n\n        // should've pulled in process_started from meta file.\n        process_started = meta->process_started;\n        // TODO: must be a more canonical way of serializing/deserializing\n        // pointers? passing through uint64_t should work, and we're not\n        // annotating the pointer with anything, but it's still slightly\n        // insane.\n        restart_fixup((void *)old_base);\n    }\n    /*\n     * ignore SIGPIPE signals; we can use errno == EPIPE if we\n     * need that information\n     */\n    if (sigignore(SIGPIPE) == -1) {\n        perror(\"failed to ignore SIGPIPE; sigaction\");\n        exit(EX_OSERR);\n    }\n    /* start up worker threads if MT mode */\n#ifdef EXTSTORE\n    slabs_set_storage(storage);\n    memcached_thread_init(settings.num_threads, storage);\n    init_lru_crawler(storage);\n#else\n    memcached_thread_init(settings.num_threads, NULL);\n    init_lru_crawler(NULL);\n#endif\n\n    if (start_assoc_maint && start_assoc_maintenance_thread() == -1) {\n        exit(EXIT_FAILURE);\n    }\n    if (start_lru_crawler && start_item_crawler_thread() != 0) {\n        fprintf(stderr, \"Failed to enable LRU crawler thread\\n\");\n        exit(EXIT_FAILURE);\n    }\n#ifdef EXTSTORE\n    if (storage && start_storage_compact_thread(storage) != 0) {\n        fprintf(stderr, \"Failed to start storage compaction thread\\n\");\n        exit(EXIT_FAILURE);\n    }\n    if (storage && start_storage_write_thread(storage) != 0) {\n        fprintf(stderr, \"Failed to start storage writer thread\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (start_lru_maintainer && start_lru_maintainer_thread(storage) != 0) {\n#else\n    if (start_lru_maintainer && start_lru_maintainer_thread(NULL) != 0) {\n#endif\n        fprintf(stderr, \"Failed to enable LRU maintainer thread\\n\");\n        free(meta);\n        return 1;\n    }\n\n    if (settings.slab_reassign &&\n        start_slab_maintenance_thread() == -1) {\n        exit(EXIT_FAILURE);\n    }\n\n    if (settings.idle_timeout && start_conn_timeout_thread() == -1) {\n        exit(EXIT_FAILURE);\n    }\n\n    /* initialise clock event */\n#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)\n    {\n        struct timespec ts;\n        if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0) {\n            monotonic = true;\n            monotonic_start = ts.tv_sec;\n            // Monotonic clock needs special handling for restarts.\n            // We get a start time at an arbitrary place, so we need to\n            // restore the original time delta, which is always \"now\" - _start\n            if (reuse_mem) {\n                // the running timespan at stop time + the time we think we\n                // were stopped.\n                monotonic_start -= meta->current_time + meta->time_delta;\n            } else {\n                monotonic_start -= ITEM_UPDATE_INTERVAL + 2;\n            }\n        }\n    }\n#endif\n    clock_handler(0, 0, 0);\n\n    /* create unix mode sockets after dropping privileges */\n    if (settings.socketpath != NULL) {\n        errno = 0;\n        if (server_socket_unix(settings.socketpath,settings.access)) {\n            vperror(\"failed to listen on UNIX socket: %s\", settings.socketpath);\n            exit(EX_OSERR);\n        }\n    }\n\n    /* create the listening socket, bind it, and init */\n    if (settings.socketpath == NULL) {\n        const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");\n        char *temp_portnumber_filename = NULL;\n        size_t len;\n        FILE *portnumber_file = NULL;\n\n        if (portnumber_filename != NULL) {\n            len = strlen(portnumber_filename)+4+1;\n            temp_portnumber_filename = malloc(len);\n            snprintf(temp_portnumber_filename,\n                     len,\n                     \"%s.lck\", portnumber_filename);\n\n            portnumber_file = fopen(temp_portnumber_filename, \"a\");\n            if (portnumber_file == NULL) {\n                fprintf(stderr, \"Failed to open \\\"%s\\\": %s\\n\",\n                        temp_portnumber_filename, strerror(errno));\n            }\n        }\n\n        errno = 0;\n        if (settings.port && server_sockets(settings.port, tcp_transport,\n                                           portnumber_file)) {\n            vperror(\"failed to listen on TCP port %d\", settings.port);\n            exit(EX_OSERR);\n        }\n\n        /*\n         * initialization order: first create the listening sockets\n         * (may need root on low ports), then drop root if needed,\n         * then daemonize if needed, then init libevent (in some cases\n         * descriptors created by libevent wouldn't survive forking).\n         */\n\n        /* create the UDP listening socket and bind it */\n        errno = 0;\n        if (settings.udpport && server_sockets(settings.udpport, udp_transport,\n                                              portnumber_file)) {\n            vperror(\"failed to listen on UDP port %d\", settings.udpport);\n            exit(EX_OSERR);\n        }\n\n        if (portnumber_file) {\n            fclose(portnumber_file);\n            rename(temp_portnumber_filename, portnumber_filename);\n        }\n        if (temp_portnumber_filename)\n            free(temp_portnumber_filename);\n    }\n\n    /* Give the sockets a moment to open. I know this is dumb, but the error\n     * is only an advisory.\n     */\n    usleep(1000);\n    if (stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {\n        fprintf(stderr, \"Maxconns setting is too low, use -c to increase.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid_file != NULL) {\n        save_pid(pid_file);\n    }\n\n    /* Drop privileges no longer needed */\n    if (settings.drop_privileges) {\n        drop_privileges();\n    }\n\n    /* Initialize the uriencode lookup table. */\n    uriencode_init();\n\n    /* enter the event loop */\n    while (!stop_main_loop) {\n        if (event_base_loop(main_base, EVLOOP_ONCE) != 0) {\n            retval = EXIT_FAILURE;\n            break;\n        }\n    }\n\n    fprintf(stderr, \"Gracefully stopping\\n\");\n    stop_threads();\n    int i;\n    // FIXME: make a function callable from threads.c\n    for (i = 0; i < max_fds; i++) {\n        if (conns[i] && conns[i]->state != conn_closed) {\n            conn_close(conns[i]);\n        }\n    }\n    if (memory_file != NULL) {\n        restart_mmap_close();\n    }\n\n    /* remove the PID file if we're a daemon */\n    if (do_daemonize)\n        remove_pidfile(pid_file);\n    /* Clean up strdup() call for bind() address */\n    if (settings.inter)\n      free(settings.inter);\n\n    /* cleanup base */\n    event_base_free(main_base);\n\n    free(meta);\n\n    return retval;\n}\n"], "fixing_code": ["/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n *  memcached - memory caching daemon\n *\n *       https://www.memcached.org/\n *\n *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.\n *\n *  Use and distribution licensed under the BSD license.  See\n *  the LICENSE file for full text.\n *\n *  Authors:\n *      Anatoly Vorobey <mellon@pobox.com>\n *      Brad Fitzpatrick <brad@danga.com>\n */\n#include \"memcached.h\"\n#ifdef EXTSTORE\n#include \"storage.h\"\n#endif\n#include \"authfile.h\"\n#include \"restart.h\"\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <signal.h>\n#include <sys/param.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <ctype.h>\n#include <stdarg.h>\n\n/* some POSIX systems need the following definition\n * to get mlockall flags out of sys/mman.h.  */\n#ifndef _P1003_1B_VISIBLE\n#define _P1003_1B_VISIBLE\n#endif\n#include <pwd.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <assert.h>\n#include <sysexits.h>\n#include <stddef.h>\n\n#ifdef HAVE_GETOPT_LONG\n#include <getopt.h>\n#endif\n\n#ifdef TLS\n#include \"tls.h\"\n#endif\n\n#if defined(__FreeBSD__)\n#include <sys/sysctl.h>\n#endif\n\n/*\n * forward declarations\n */\nstatic void drive_machine(conn *c);\nstatic int new_socket(struct addrinfo *ai);\nstatic ssize_t tcp_read(conn *arg, void *buf, size_t count);\nstatic ssize_t tcp_sendmsg(conn *arg, struct msghdr *msg, int flags);\nstatic ssize_t tcp_write(conn *arg, void *buf, size_t count);\n\nenum try_read_result {\n    READ_DATA_RECEIVED,\n    READ_NO_DATA_RECEIVED,\n    READ_ERROR,            /** an error occurred (on the socket) (or client closed connection) */\n    READ_MEMORY_ERROR      /** failed to allocate more memory */\n};\n\nstatic int try_read_command_negotiate(conn *c);\nstatic int try_read_command_udp(conn *c);\nstatic int try_read_command_binary(conn *c);\nstatic int try_read_command_ascii(conn *c);\nstatic int try_read_command_asciiauth(conn *c);\n\nstatic enum try_read_result try_read_network(conn *c);\nstatic enum try_read_result try_read_udp(conn *c);\n\nstatic void conn_set_state(conn *c, enum conn_states state);\nstatic int start_conn_timeout_thread();\n\nstatic mc_resp* resp_finish(conn *c, mc_resp *resp);\n\n/* stats */\nstatic void stats_init(void);\nstatic void server_stats(ADD_STAT add_stats, conn *c);\nstatic void process_stat_settings(ADD_STAT add_stats, void *c);\nstatic void conn_to_str(const conn *c, char *addr, char *svr_addr);\n\n/** Return a datum for stats in binary protocol */\nstatic bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c);\n\n/* defaults */\nstatic void settings_init(void);\n\n/* event handling, network IO */\nstatic void event_handler(const int fd, const short which, void *arg);\nstatic void conn_close(conn *c);\nstatic void conn_init(void);\nstatic bool update_event(conn *c, const int new_flags);\nstatic void complete_nread(conn *c);\nstatic void process_command(conn *c, char *command);\nstatic void write_and_free(conn *c, char *buf, int bytes);\nstatic void write_bin_error(conn *c, protocol_binary_response_status err,\n                            const char *errstr, int swallow);\nstatic void write_bin_miss_response(conn *c, char *key, size_t nkey);\n\n#ifdef EXTSTORE\nstatic void _get_extstore_cb(void *e, obj_io *io, int ret);\nstatic inline int _get_extstore(conn *c, item *it, mc_resp *resp);\n#endif\nstatic void conn_free(conn *c);\n\n/** binprot handlers **/\nstatic void process_bin_flush(conn *c, char *extbuf);\nstatic void process_bin_append_prepend(conn *c);\nstatic void process_bin_update(conn *c, char *extbuf);\nstatic void process_bin_get_or_touch(conn *c, char *extbuf);\nstatic void process_bin_delete(conn *c);\nstatic void complete_incr_bin(conn *c, char *extbuf);\nstatic void process_bin_stat(conn *c);\nstatic void process_bin_sasl_auth(conn *c);\n\n/** exported globals **/\nstruct stats stats;\nstruct stats_state stats_state;\nstruct settings settings;\ntime_t process_started;     /* when the process was started */\nconn **conns;\n\nstruct slab_rebalance slab_rebal;\nvolatile int slab_rebalance_signal;\n#ifdef EXTSTORE\n/* hoping this is temporary; I'd prefer to cut globals, but will complete this\n * battle another day.\n */\nvoid *ext_storage = NULL;\n#endif\n/** file scope variables **/\nstatic conn *listen_conn = NULL;\nstatic int max_fds;\nstatic struct event_base *main_base;\n\nenum transmit_result {\n    TRANSMIT_COMPLETE,   /** All done writing. */\n    TRANSMIT_INCOMPLETE, /** More data remaining to write. */\n    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */\n    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */\n};\n\n/* Default methods to read from/ write to a socket */\nssize_t tcp_read(conn *c, void *buf, size_t count) {\n    assert (c != NULL);\n    return read(c->sfd, buf, count);\n}\n\nssize_t tcp_sendmsg(conn *c, struct msghdr *msg, int flags) {\n    assert (c != NULL);\n    return sendmsg(c->sfd, msg, flags);\n}\n\nssize_t tcp_write(conn *c, void *buf, size_t count) {\n    assert (c != NULL);\n    return write(c->sfd, buf, count);\n}\n\nstatic enum transmit_result transmit(conn *c);\n\n/* This reduces the latency without adding lots of extra wiring to be able to\n * notify the listener thread of when to listen again.\n * Also, the clock timer could be broken out into its own thread and we\n * can block the listener via a condition.\n */\nstatic volatile bool allow_new_conns = true;\nstatic bool stop_main_loop = false;\nstatic struct event maxconnsevent;\nstatic void maxconns_handler(const int fd, const short which, void *arg) {\n    struct timeval t = {.tv_sec = 0, .tv_usec = 10000};\n\n    if (fd == -42 || allow_new_conns == false) {\n        /* reschedule in 10ms if we need to keep polling */\n        evtimer_set(&maxconnsevent, maxconns_handler, 0);\n        event_base_set(main_base, &maxconnsevent);\n        evtimer_add(&maxconnsevent, &t);\n    } else {\n        evtimer_del(&maxconnsevent);\n        accept_new_conns(true);\n    }\n}\n\n#define REALTIME_MAXDELTA 60*60*24*30\n\n/* Negative exptimes can underflow and end up immortal. realtime() will\n   immediately expire values that are greater than REALTIME_MAXDELTA, but less\n   than process_started, so lets aim for that. */\n#define EXPTIME_TO_POSITIVE_TIME(exptime) (exptime < 0) ? \\\n        REALTIME_MAXDELTA + 1 : exptime\n\n\n/*\n * given time value that's either unix time or delta from current unix time, return\n * unix time. Use the fact that delta can't exceed one month (and real time value can't\n * be that low).\n */\nstatic rel_time_t realtime(const time_t exptime) {\n    /* no. of seconds in 30 days - largest possible delta exptime */\n\n    if (exptime == 0) return 0; /* 0 means never expire */\n\n    if (exptime > REALTIME_MAXDELTA) {\n        /* if item expiration is at/before the server started, give it an\n           expiration time of 1 second after the server started.\n           (because 0 means don't expire).  without this, we'd\n           underflow and wrap around to some large value way in the\n           future, effectively making items expiring in the past\n           really expiring never */\n        if (exptime <= process_started)\n            return (rel_time_t)1;\n        return (rel_time_t)(exptime - process_started);\n    } else {\n        return (rel_time_t)(exptime + current_time);\n    }\n}\n\nstatic void stats_init(void) {\n    memset(&stats, 0, sizeof(struct stats));\n    memset(&stats_state, 0, sizeof(struct stats_state));\n    stats_state.accepting_conns = true; /* assuming we start in this state. */\n\n    /* make the time we started always be 2 seconds before we really\n       did, so time(0) - time.started is never zero.  if so, things\n       like 'settings.oldest_live' which act as booleans as well as\n       values are now false in boolean context... */\n    process_started = time(0) - ITEM_UPDATE_INTERVAL - 2;\n    stats_prefix_init(settings.prefix_delimiter);\n}\n\nstatic void stats_reset(void) {\n    STATS_LOCK();\n    memset(&stats, 0, sizeof(struct stats));\n    stats_prefix_clear();\n    STATS_UNLOCK();\n    threadlocal_stats_reset();\n    item_stats_reset();\n}\n\nstatic void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 0;\n#ifdef TLS\n    settings.ssl_enabled = false;\n    settings.ssl_ctx = NULL;\n    settings.ssl_chain_cert = NULL;\n    settings.ssl_key = NULL;\n    settings.ssl_verify_mode = SSL_VERIFY_NONE;\n    settings.ssl_keyformat = SSL_FILETYPE_PEM;\n    settings.ssl_ciphers = NULL;\n    settings.ssl_ca_cert = NULL;\n    settings.ssl_last_cert_refresh_time = current_time;\n    settings.ssl_wbuf_size = 16 * 1024; // default is 16KB (SSL max frame size is 17KB)\n#endif\n    /* By default this string should be NULL for getaddrinfo() */\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */\n    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */\n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.oldest_cas = 0;          /* supplements accuracy of oldest_live */\n    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */\n    settings.socketpath = NULL;       /* by default, not using a unix socket */\n    settings.auth_file = NULL;        /* by default, not using ASCII authentication tokens */\n    settings.factor = 1.25;\n    settings.chunk_size = 48;         /* space for a modest key and value */\n    settings.num_threads = 4;         /* N workers */\n    settings.num_threads_per_udp = 0;\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.reqs_per_event = 20;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */\n    settings.slab_page_size = 1024 * 1024; /* chunks are split from 1MB pages. */\n    settings.slab_chunk_size_max = settings.slab_page_size / 2;\n    settings.sasl = false;\n    settings.maxconns_fast = true;\n    settings.lru_crawler = false;\n    settings.lru_crawler_sleep = 100;\n    settings.lru_crawler_tocrawl = 0;\n    settings.lru_maintainer_thread = false;\n    settings.lru_segmented = true;\n    settings.hot_lru_pct = 20;\n    settings.warm_lru_pct = 40;\n    settings.hot_max_factor = 0.2;\n    settings.warm_max_factor = 2.0;\n    settings.temp_lru = false;\n    settings.temporary_ttl = 61;\n    settings.idle_timeout = 0; /* disabled */\n    settings.hashpower_init = 0;\n    settings.slab_reassign = true;\n    settings.slab_automove = 1;\n    settings.slab_automove_ratio = 0.8;\n    settings.slab_automove_window = 30;\n    settings.shutdown_command = false;\n    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;\n    settings.flush_enabled = true;\n    settings.dump_enabled = true;\n    settings.crawls_persleep = 1000;\n    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;\n    settings.logger_buf_size = LOGGER_BUF_SIZE;\n    settings.drop_privileges = false;\n    settings.watch_enabled = true;\n    settings.resp_obj_mem_limit = 0;\n    settings.read_buf_mem_limit = 0;\n#ifdef MEMCACHED_DEBUG\n    settings.relaxed_privileges = false;\n#endif\n}\n\nextern pthread_mutex_t conn_lock;\n\n/* Connection timeout thread bits */\nstatic pthread_t conn_timeout_tid;\nstatic int do_run_conn_timeout_thread;\n\n#define CONNS_PER_SLICE 100\n#define TIMEOUT_MSG_SIZE (1 + sizeof(int))\nstatic void *conn_timeout_thread(void *arg) {\n    int i;\n    conn *c;\n    char buf[TIMEOUT_MSG_SIZE];\n    rel_time_t oldest_last_cmd;\n    int sleep_time;\n    useconds_t timeslice = 1000000 / (max_fds / CONNS_PER_SLICE);\n\n    while(do_run_conn_timeout_thread) {\n        if (settings.verbose > 2)\n            fprintf(stderr, \"idle timeout thread at top of connection list\\n\");\n\n        oldest_last_cmd = current_time;\n\n        for (i = 0; i < max_fds; i++) {\n            if ((i % CONNS_PER_SLICE) == 0) {\n                if (settings.verbose > 2)\n                    fprintf(stderr, \"idle timeout thread sleeping for %ulus\\n\",\n                        (unsigned int)timeslice);\n                usleep(timeslice);\n            }\n\n            if (!conns[i])\n                continue;\n\n            c = conns[i];\n\n            if (!IS_TCP(c->transport))\n                continue;\n\n            if (c->state != conn_new_cmd && c->state != conn_read)\n                continue;\n\n            if ((current_time - c->last_cmd_time) > settings.idle_timeout) {\n                buf[0] = 't';\n                memcpy(&buf[1], &i, sizeof(int));\n                if (write(c->thread->notify_send_fd, buf, TIMEOUT_MSG_SIZE)\n                    != TIMEOUT_MSG_SIZE)\n                    perror(\"Failed to write timeout to notify pipe\");\n            } else {\n                if (c->last_cmd_time < oldest_last_cmd)\n                    oldest_last_cmd = c->last_cmd_time;\n            }\n        }\n\n        /* This is the soonest we could have another connection time out */\n        sleep_time = settings.idle_timeout - (current_time - oldest_last_cmd) + 1;\n        if (sleep_time <= 0)\n            sleep_time = 1;\n\n        if (settings.verbose > 2)\n            fprintf(stderr,\n                    \"idle timeout thread finished pass, sleeping for %ds\\n\",\n                    sleep_time);\n        usleep((useconds_t) sleep_time * 1000000);\n    }\n\n    return NULL;\n}\n\nstatic int start_conn_timeout_thread() {\n    int ret;\n\n    if (settings.idle_timeout == 0)\n        return -1;\n\n    do_run_conn_timeout_thread = 1;\n    if ((ret = pthread_create(&conn_timeout_tid, NULL,\n        conn_timeout_thread, NULL)) != 0) {\n        fprintf(stderr, \"Can't create idle connection timeout thread: %s\\n\",\n            strerror(ret));\n        return -1;\n    }\n\n    return 0;\n}\n\nint stop_conn_timeout_thread(void) {\n    if (!do_run_conn_timeout_thread)\n        return -1;\n    do_run_conn_timeout_thread = 0;\n    pthread_join(conn_timeout_tid, NULL);\n    return 0;\n}\n\n/*\n * read buffer cache helper functions\n */\nstatic void rbuf_release(conn *c) {\n    if (c->rbuf != NULL && c->rbytes == 0 && !IS_UDP(c->transport)) {\n        if (c->rbuf_malloced) {\n            free(c->rbuf);\n            c->rbuf_malloced = false;\n        } else {\n            do_cache_free(c->thread->rbuf_cache, c->rbuf);\n        }\n        c->rsize = 0;\n        c->rbuf = NULL;\n        c->rcurr = NULL;\n    }\n}\n\nstatic bool rbuf_alloc(conn *c) {\n    if (c->rbuf == NULL) {\n        c->rbuf = do_cache_alloc(c->thread->rbuf_cache);\n        if (!c->rbuf) {\n            THR_STATS_LOCK(c);\n            c->thread->stats.read_buf_oom++;\n            THR_STATS_UNLOCK(c);\n            return false;\n        }\n        c->rsize = READ_BUFFER_SIZE;\n        c->rcurr = c->rbuf;\n    }\n    return true;\n}\n\n// Just for handling huge ASCII multigets.\n// The previous system was essentially the same; realloc'ing until big enough,\n// then realloc'ing back down after the request finished.\nstatic bool rbuf_switch_to_malloc(conn *c) {\n    // Might as well start with x2 and work from there.\n    size_t size = c->rsize * 2;\n    char *tmp = malloc(size);\n    if (!tmp)\n        return false;\n\n    do_cache_free(c->thread->rbuf_cache, c->rbuf);\n    memcpy(tmp, c->rcurr, c->rbytes);\n\n    c->rcurr = c->rbuf = tmp;\n    c->rsize = size;\n    c->rbuf_malloced = true;\n    return true;\n}\n\n/*\n * Initializes the connections array. We don't actually allocate connection\n * structures until they're needed, so as to avoid wasting memory when the\n * maximum connection count is much higher than the actual number of\n * connections.\n *\n * This does end up wasting a few pointers' worth of memory for FDs that are\n * used for things other than connections, but that's worth it in exchange for\n * being able to directly index the conns array by FD.\n */\nstatic void conn_init(void) {\n    /* We're unlikely to see an FD much higher than maxconns. */\n    int next_fd = dup(1);\n    if (next_fd < 0) {\n        perror(\"Failed to duplicate file descriptor\\n\");\n        exit(1);\n    }\n    int headroom = 10;      /* account for extra unexpected open FDs */\n    struct rlimit rl;\n\n    max_fds = settings.maxconns + headroom + next_fd;\n\n    /* But if possible, get the actual highest FD we can possibly ever see. */\n    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {\n        max_fds = rl.rlim_max;\n    } else {\n        fprintf(stderr, \"Failed to query maximum file descriptor; \"\n                        \"falling back to maxconns\\n\");\n    }\n\n    close(next_fd);\n\n    if ((conns = calloc(max_fds, sizeof(conn *))) == NULL) {\n        fprintf(stderr, \"Failed to allocate connection structures\\n\");\n        /* This is unrecoverable so bail out early. */\n        exit(1);\n    }\n}\n\nstatic const char *prot_text(enum protocol prot) {\n    char *rv = \"unknown\";\n    switch(prot) {\n        case ascii_prot:\n            rv = \"ascii\";\n            break;\n        case binary_prot:\n            rv = \"binary\";\n            break;\n        case negotiating_prot:\n            rv = \"auto-negotiate\";\n            break;\n    }\n    return rv;\n}\n\nvoid conn_close_idle(conn *c) {\n    if (settings.idle_timeout > 0 &&\n        (current_time - c->last_cmd_time) > settings.idle_timeout) {\n        if (c->state != conn_new_cmd && c->state != conn_read) {\n            if (settings.verbose > 1)\n                fprintf(stderr,\n                    \"fd %d wants to timeout, but isn't in read state\", c->sfd);\n            return;\n        }\n\n        if (settings.verbose > 1)\n            fprintf(stderr, \"Closing idle fd %d\\n\", c->sfd);\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.idle_kicks++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        conn_set_state(c, conn_closing);\n        drive_machine(c);\n    }\n}\n\n/* bring conn back from a sidethread. could have had its event base moved. */\nvoid conn_worker_readd(conn *c) {\n    c->ev_flags = EV_READ | EV_PERSIST;\n    event_set(&c->event, c->sfd, c->ev_flags, event_handler, (void *)c);\n    event_base_set(c->thread->base, &c->event);\n\n    // TODO: call conn_cleanup/fail/etc\n    if (event_add(&c->event, 0) == -1) {\n        perror(\"event_add\");\n    }\n\n    // side thread wanted us to close immediately.\n    if (c->state == conn_closing) {\n        drive_machine(c);\n        return;\n    }\n    c->state = conn_new_cmd;\n\n#ifdef EXTSTORE\n    // If we had IO objects, process\n    if (c->io_wraplist) {\n        //assert(c->io_wrapleft == 0); // assert no more to process\n        conn_set_state(c, conn_mwrite);\n        drive_machine(c);\n    }\n#endif\n}\n\nconn *conn_new(const int sfd, enum conn_states init_state,\n                const int event_flags,\n                const int read_buffer_size, enum network_transport transport,\n                struct event_base *base, void *ssl) {\n    conn *c;\n\n    assert(sfd >= 0 && sfd < max_fds);\n    c = conns[sfd];\n\n    if (NULL == c) {\n        if (!(c = (conn *)calloc(1, sizeof(conn)))) {\n            STATS_LOCK();\n            stats.malloc_fails++;\n            STATS_UNLOCK();\n            fprintf(stderr, \"Failed to allocate connection object\\n\");\n            return NULL;\n        }\n        MEMCACHED_CONN_CREATE(c);\n        c->read = NULL;\n        c->sendmsg = NULL;\n        c->write = NULL;\n        c->rbuf = NULL;\n\n        c->rsize = read_buffer_size;\n\n        // UDP connections use a persistent static buffer.\n        if (c->rsize) {\n            c->rbuf = (char *)malloc((size_t)c->rsize);\n        }\n\n        if (c->rsize && c->rbuf == NULL) {\n            conn_free(c);\n            STATS_LOCK();\n            stats.malloc_fails++;\n            STATS_UNLOCK();\n            fprintf(stderr, \"Failed to allocate buffers for connection\\n\");\n            return NULL;\n        }\n\n        STATS_LOCK();\n        stats_state.conn_structs++;\n        STATS_UNLOCK();\n\n        c->sfd = sfd;\n        conns[sfd] = c;\n    }\n\n    c->transport = transport;\n    c->protocol = settings.binding_protocol;\n\n    /* unix socket mode doesn't need this, so zeroed out.  but why\n     * is this done for every command?  presumably for UDP\n     * mode.  */\n    if (!settings.socketpath) {\n        c->request_addr_size = sizeof(c->request_addr);\n    } else {\n        c->request_addr_size = 0;\n    }\n\n    if (transport == tcp_transport && init_state == conn_new_cmd) {\n        if (getpeername(sfd, (struct sockaddr *) &c->request_addr,\n                        &c->request_addr_size)) {\n            perror(\"getpeername\");\n            memset(&c->request_addr, 0, sizeof(c->request_addr));\n        }\n    }\n\n    if (settings.verbose > 1) {\n        if (init_state == conn_listening) {\n            fprintf(stderr, \"<%d server listening (%s)\\n\", sfd,\n                prot_text(c->protocol));\n        } else if (IS_UDP(transport)) {\n            fprintf(stderr, \"<%d server listening (udp)\\n\", sfd);\n        } else if (c->protocol == negotiating_prot) {\n            fprintf(stderr, \"<%d new auto-negotiating client connection\\n\",\n                    sfd);\n        } else if (c->protocol == ascii_prot) {\n            fprintf(stderr, \"<%d new ascii client connection.\\n\", sfd);\n        } else if (c->protocol == binary_prot) {\n            fprintf(stderr, \"<%d new binary client connection.\\n\", sfd);\n        } else {\n            fprintf(stderr, \"<%d new unknown (%d) client connection\\n\",\n                sfd, c->protocol);\n            assert(false);\n        }\n    }\n\n#ifdef TLS\n    c->ssl = NULL;\n    c->ssl_wbuf = NULL;\n    c->ssl_enabled = false;\n#endif\n    c->state = init_state;\n    c->rlbytes = 0;\n    c->cmd = -1;\n    c->rbytes = 0;\n    c->rcurr = c->rbuf;\n    c->ritem = 0;\n    c->rbuf_malloced = false;\n    c->sasl_started = false;\n    c->set_stale = false;\n    c->mset_res = false;\n    c->close_after_write = false;\n    c->last_cmd_time = current_time; /* initialize for idle kicker */\n#ifdef EXTSTORE\n    c->io_wraplist = NULL;\n    c->io_wrapleft = 0;\n#endif\n\n    c->item = 0;\n\n    c->noreply = false;\n\n#ifdef TLS\n    if (ssl) {\n        c->ssl = (SSL*)ssl;\n        c->read = ssl_read;\n        c->sendmsg = ssl_sendmsg;\n        c->write = ssl_write;\n        c->ssl_enabled = true;\n        SSL_set_info_callback(c->ssl, ssl_callback);\n    } else\n#else\n    // This must be NULL if TLS is not enabled.\n    assert(ssl == NULL);\n#endif\n    {\n        c->read = tcp_read;\n        c->sendmsg = tcp_sendmsg;\n        c->write = tcp_write;\n    }\n\n    if (IS_UDP(transport)) {\n        c->try_read_command = try_read_command_udp;\n    } else {\n        switch (c->protocol) {\n            case ascii_prot:\n                if (settings.auth_file == NULL) {\n                    c->authenticated = true;\n                    c->try_read_command = try_read_command_ascii;\n                } else {\n                    c->authenticated = false;\n                    c->try_read_command = try_read_command_asciiauth;\n                }\n                break;\n            case binary_prot:\n                // binprot handles its own authentication via SASL parsing.\n                c->authenticated = false;\n                c->try_read_command = try_read_command_binary;\n                break;\n            case negotiating_prot:\n                c->try_read_command = try_read_command_negotiate;\n                break;\n        }\n    }\n\n    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = event_flags;\n\n    if (event_add(&c->event, 0) == -1) {\n        perror(\"event_add\");\n        return NULL;\n    }\n\n    STATS_LOCK();\n    stats_state.curr_conns++;\n    stats.total_conns++;\n    STATS_UNLOCK();\n\n    MEMCACHED_CONN_ALLOCATE(c->sfd);\n\n    return c;\n}\n#ifdef EXTSTORE\nstatic void recache_or_free(conn *c, io_wrap *wrap) {\n    item *it;\n    it = (item *)wrap->io.buf;\n    bool do_free = true;\n    if (wrap->active) {\n        // If request never dispatched, free the read buffer but leave the\n        // item header alone.\n        do_free = false;\n        size_t ntotal = ITEM_ntotal(wrap->hdr_it);\n        slabs_free(it, ntotal, slabs_clsid(ntotal));\n        c->io_wrapleft--;\n        assert(c->io_wrapleft >= 0);\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.get_aborted_extstore++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n    } else if (wrap->miss) {\n        // If request was ultimately a miss, unlink the header.\n        do_free = false;\n        size_t ntotal = ITEM_ntotal(wrap->hdr_it);\n        item_unlink(wrap->hdr_it);\n        slabs_free(it, ntotal, slabs_clsid(ntotal));\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.miss_from_extstore++;\n        if (wrap->badcrc)\n            c->thread->stats.badcrc_from_extstore++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n    } else if (settings.ext_recache_rate) {\n        // hashvalue is cuddled during store\n        uint32_t hv = (uint32_t)it->time;\n        // opt to throw away rather than wait on a lock.\n        void *hold_lock = item_trylock(hv);\n        if (hold_lock != NULL) {\n            item *h_it = wrap->hdr_it;\n            uint8_t flags = ITEM_LINKED|ITEM_FETCHED|ITEM_ACTIVE;\n            // Item must be recently hit at least twice to recache.\n            if (((h_it->it_flags & flags) == flags) &&\n                    h_it->time > current_time - ITEM_UPDATE_INTERVAL &&\n                    c->recache_counter++ % settings.ext_recache_rate == 0) {\n                do_free = false;\n                // In case it's been updated.\n                it->exptime = h_it->exptime;\n                it->it_flags &= ~ITEM_LINKED;\n                it->refcount = 0;\n                it->h_next = NULL; // might not be necessary.\n                STORAGE_delete(c->thread->storage, h_it);\n                item_replace(h_it, it, hv);\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.recache_from_extstore++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n            }\n        }\n        if (hold_lock)\n            item_trylock_unlock(hold_lock);\n    }\n    if (do_free)\n        slabs_free(it, ITEM_ntotal(it), ITEM_clsid(it));\n\n    wrap->io.buf = NULL; // sanity.\n    wrap->io.next = NULL;\n    wrap->next = NULL;\n    wrap->active = false;\n\n    // TODO: reuse lock and/or hv.\n    item_remove(wrap->hdr_it);\n}\n#endif\nstatic void conn_release_items(conn *c) {\n    assert(c != NULL);\n\n    if (c->item) {\n        item_remove(c->item);\n        c->item = 0;\n    }\n\n#ifdef EXTSTORE\n    if (c->io_wraplist) {\n        io_wrap *tmp = c->io_wraplist;\n        while (tmp) {\n            io_wrap *next = tmp->next;\n            recache_or_free(c, tmp);\n            // malloc'ed iovec list used for chunked extstore fetches.\n            if (tmp->io.iov) {\n                free(tmp->io.iov);\n                tmp->io.iov = NULL;\n            }\n            do_cache_free(c->thread->io_cache, tmp); // lockless\n            tmp = next;\n        }\n        c->io_wraplist = NULL;\n    }\n#endif\n\n    // Cull any unsent responses.\n    if (c->resp_head) {\n        mc_resp *resp = c->resp_head;\n        // r_f() handles the chain maintenance.\n        while (resp) {\n            // temporary by default. hide behind a debug flag in the future:\n            // double free detection. Transmit loops can drop out early, but\n            // here we could infinite loop.\n            if (resp->free) {\n                fprintf(stderr, \"ERROR: double free detected during conn_release_items(): [%d] [%s]\\n\",\n                        c->sfd, c->protocol == binary_prot ? \"binary\" : \"ascii\");\n                // Since this is a critical failure, just leak the memory.\n                // If these errors are seen, an abort() can be used instead.\n                c->resp_head = NULL;\n                c->resp = NULL;\n                break;\n            }\n            resp = resp_finish(c, resp);\n        }\n    }\n}\n\nstatic void conn_cleanup(conn *c) {\n    assert(c != NULL);\n\n    conn_release_items(c);\n\n    if (c->sasl_conn) {\n        assert(settings.sasl);\n        sasl_dispose(&c->sasl_conn);\n        c->sasl_conn = NULL;\n    }\n\n    if (IS_UDP(c->transport)) {\n        conn_set_state(c, conn_read);\n    }\n}\n\n/*\n * Frees a connection.\n */\nvoid conn_free(conn *c) {\n    if (c) {\n        assert(c != NULL);\n        assert(c->sfd >= 0 && c->sfd < max_fds);\n\n        MEMCACHED_CONN_DESTROY(c);\n        conns[c->sfd] = NULL;\n        if (c->rbuf)\n            free(c->rbuf);\n#ifdef TLS\n        if (c->ssl_wbuf)\n            c->ssl_wbuf = NULL;\n#endif\n\n        free(c);\n    }\n}\n\nstatic void conn_close(conn *c) {\n    assert(c != NULL);\n\n    /* delete the event, the socket and the conn */\n    event_del(&c->event);\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"<%d connection closed.\\n\", c->sfd);\n\n    conn_cleanup(c);\n\n    // force release of read buffer.\n    if (c->thread) {\n        c->rbytes = 0;\n        rbuf_release(c);\n    }\n\n    MEMCACHED_CONN_RELEASE(c->sfd);\n    conn_set_state(c, conn_closed);\n#ifdef TLS\n    if (c->ssl) {\n        SSL_shutdown(c->ssl);\n        SSL_free(c->ssl);\n    }\n#endif\n    close(c->sfd);\n    pthread_mutex_lock(&conn_lock);\n    allow_new_conns = true;\n    pthread_mutex_unlock(&conn_lock);\n\n    STATS_LOCK();\n    stats_state.curr_conns--;\n    STATS_UNLOCK();\n\n    return;\n}\n\n/**\n * Convert a state name to a human readable form.\n */\nstatic const char *state_text(enum conn_states state) {\n    const char* const statenames[] = { \"conn_listening\",\n                                       \"conn_new_cmd\",\n                                       \"conn_waiting\",\n                                       \"conn_read\",\n                                       \"conn_parse_cmd\",\n                                       \"conn_write\",\n                                       \"conn_nread\",\n                                       \"conn_swallow\",\n                                       \"conn_closing\",\n                                       \"conn_mwrite\",\n                                       \"conn_closed\",\n                                       \"conn_watch\" };\n    return statenames[state];\n}\n\n/*\n * Sets a connection's current state in the state machine. Any special\n * processing that needs to happen on certain state transitions can\n * happen here.\n */\nstatic void conn_set_state(conn *c, enum conn_states state) {\n    assert(c != NULL);\n    assert(state >= conn_listening && state < conn_max_state);\n\n    if (state != c->state) {\n        if (settings.verbose > 2) {\n            fprintf(stderr, \"%d: going from %s to %s\\n\",\n                    c->sfd, state_text(c->state),\n                    state_text(state));\n        }\n\n        if (state == conn_write || state == conn_mwrite) {\n            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->resp->wbuf, c->resp->wbytes);\n        }\n        c->state = state;\n    }\n}\n\n/*\n * response object helper functions\n */\nstatic void resp_reset(mc_resp *resp) {\n    if (resp->item) {\n        item_remove(resp->item);\n        resp->item = NULL;\n    }\n    if (resp->write_and_free) {\n        free(resp->write_and_free);\n        resp->write_and_free = NULL;\n    }\n    resp->wbytes = 0;\n    resp->tosend = 0;\n    resp->iovcnt = 0;\n    resp->chunked_data_iov = 0;\n    resp->chunked_total = 0;\n    resp->skip = false;\n}\n\nstatic void resp_add_iov(mc_resp *resp, const void *buf, int len) {\n    assert(resp->iovcnt < MC_RESP_IOVCOUNT);\n    int x = resp->iovcnt;\n    resp->iov[x].iov_base = (void *)buf;\n    resp->iov[x].iov_len = len;\n    resp->iovcnt++;\n    resp->tosend += len;\n}\n\n// Notes that an IOV should be handled as a chunked item header.\n// TODO: I'm hoping this isn't a permanent abstraction while I learn what the\n// API should be.\nstatic void resp_add_chunked_iov(mc_resp *resp, const void *buf, int len) {\n    resp->chunked_data_iov = resp->iovcnt;\n    resp->chunked_total = len;\n    resp_add_iov(resp, buf, len);\n}\n\nstatic bool resp_start(conn *c) {\n    mc_resp *resp = do_cache_alloc(c->thread->resp_cache);\n    if (!resp) {\n        THR_STATS_LOCK(c);\n        c->thread->stats.response_obj_oom++;\n        THR_STATS_UNLOCK(c);\n        return false;\n    }\n    // FIXME: make wbuf indirect or use offsetof to zero up until wbuf\n    memset(resp, 0, sizeof(*resp));\n    if (!c->resp_head) {\n        c->resp_head = resp;\n    }\n    if (!c->resp) {\n        c->resp = resp;\n    } else {\n        c->resp->next = resp;\n        c->resp = resp;\n    }\n    if (IS_UDP(c->transport)) {\n        // need to hold on to some data for async responses.\n        c->resp->request_id = c->request_id;\n        c->resp->request_addr = c->request_addr;\n        c->resp->request_addr_size = c->request_addr_size;\n    }\n    return true;\n}\n\n// returns next response in chain.\nstatic mc_resp* resp_finish(conn *c, mc_resp *resp) {\n    mc_resp *next = resp->next;\n    if (resp->item) {\n        // TODO: cache hash value in resp obj?\n        item_remove(resp->item);\n        resp->item = NULL;\n    }\n    if (resp->write_and_free) {\n        free(resp->write_and_free);\n    }\n    if (c->resp_head == resp) {\n        c->resp_head = next;\n    }\n    if (c->resp == resp) {\n        c->resp = NULL;\n    }\n    resp->free = true;\n    do_cache_free(c->thread->resp_cache, resp);\n    return next;\n}\n\n// tells if connection has a depth of response objects to process.\nstatic bool resp_has_stack(conn *c) {\n    return c->resp_head->next != NULL ? true : false;\n}\n\nstatic void out_string(conn *c, const char *str) {\n    size_t len;\n    mc_resp *resp = c->resp;\n\n    assert(c != NULL);\n    // if response was original filled with something, but we're now writing\n    // out an error or similar, have to reset the object first.\n    // TODO: since this is often redundant with allocation, how many callers\n    // are actually requiring it be reset? Can we fast test by just looking at\n    // tosend and reset if nonzero?\n    resp_reset(resp);\n\n    if (c->noreply) {\n        // TODO: just invalidate the response since nothing's been attempted\n        // to send yet?\n        resp->skip = true;\n        if (settings.verbose > 1)\n            fprintf(stderr, \">%d NOREPLY %s\\n\", c->sfd, str);\n        conn_set_state(c, conn_new_cmd);\n        return;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d %s\\n\", c->sfd, str);\n\n    // Fill response object with static string.\n\n    len = strlen(str);\n    if ((len + 2) > WRITE_BUFFER_SIZE) {\n        /* ought to be always enough. just fail for simplicity */\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n\n    memcpy(resp->wbuf, str, len);\n    memcpy(resp->wbuf + len, \"\\r\\n\", 2);\n    resp_add_iov(resp, resp->wbuf, len + 2);\n\n    conn_set_state(c, conn_new_cmd);\n    return;\n}\n\n// For metaget-style ASCII commands. Ignores noreply, ensuring clients see\n// protocol level errors.\nstatic void out_errstring(conn *c, const char *str) {\n    c->noreply = false;\n    out_string(c, str);\n}\n\n/*\n * Outputs a protocol-specific \"out of memory\" error. For ASCII clients,\n * this is equivalent to out_string().\n */\nstatic void out_of_memory(conn *c, char *ascii_error) {\n    const static char error_prefix[] = \"SERVER_ERROR \";\n    const static int error_prefix_len = sizeof(error_prefix) - 1;\n\n    if (c->protocol == binary_prot) {\n        /* Strip off the generic error prefix; it's irrelevant in binary */\n        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {\n            ascii_error += error_prefix_len;\n        }\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);\n    } else {\n        out_string(c, ascii_error);\n    }\n}\n\n/*\n * we get here after reading the value in set/add/replace commands. The command\n * has been stored in c->cmd, and the item is ready in c->item.\n */\nstatic void complete_nread_ascii(conn *c) {\n    assert(c != NULL);\n\n    item *it = c->item;\n    int comm = c->cmd;\n    enum store_item_type ret;\n    bool is_valid = false;\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    if ((it->it_flags & ITEM_CHUNKED) == 0) {\n        if (strncmp(ITEM_data(it) + it->nbytes - 2, \"\\r\\n\", 2) == 0) {\n            is_valid = true;\n        }\n    } else {\n        char buf[2];\n        /* should point to the final item chunk */\n        item_chunk *ch = (item_chunk *) c->ritem;\n        assert(ch->used != 0);\n        /* :( We need to look at the last two bytes. This could span two\n         * chunks.\n         */\n        if (ch->used > 1) {\n            buf[0] = ch->data[ch->used - 2];\n            buf[1] = ch->data[ch->used - 1];\n        } else {\n            assert(ch->prev);\n            assert(ch->used == 1);\n            buf[0] = ch->prev->data[ch->prev->used - 1];\n            buf[1] = ch->data[ch->used - 1];\n        }\n        if (strncmp(buf, \"\\r\\n\", 2) == 0) {\n            is_valid = true;\n        } else {\n            assert(1 == 0);\n        }\n    }\n\n    if (!is_valid) {\n        // metaset mode always returns errors.\n        if (c->mset_res) {\n            c->noreply = false;\n        }\n        out_string(c, \"CLIENT_ERROR bad data chunk\");\n    } else {\n      ret = store_item(it, comm, c);\n\n#ifdef ENABLE_DTRACE\n      uint64_t cas = ITEM_get_cas(it);\n      switch (c->cmd) {\n      case NREAD_ADD:\n          MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,\n                                (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_REPLACE:\n          MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,\n                                    (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_APPEND:\n          MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,\n                                   (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_PREPEND:\n          MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,\n                                    (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_SET:\n          MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,\n                                (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_CAS:\n          MEMCACHED_COMMAND_CAS(c->sfd, ITEM_key(it), it->nkey, it->nbytes,\n                                cas);\n          break;\n      }\n#endif\n\n      if (c->mset_res) {\n          // Replace the status code in the response.\n          // Rest was prepared during mset parsing.\n          mc_resp *resp = c->resp;\n          conn_set_state(c, conn_new_cmd);\n          switch (ret) {\n          case STORED:\n              memcpy(resp->wbuf, \"OK \", 3);\n              // Only place noreply is used for meta cmds is a nominal response.\n              if (c->noreply) {\n                  resp->skip = true;\n              }\n              break;\n          case EXISTS:\n              memcpy(resp->wbuf, \"EX \", 3);\n              break;\n          case NOT_FOUND:\n              memcpy(resp->wbuf, \"NF \", 3);\n              break;\n          case NOT_STORED:\n              memcpy(resp->wbuf, \"NS \", 3);\n              break;\n          default:\n              c->noreply = false;\n              out_string(c, \"SERVER_ERROR Unhandled storage type.\");\n          }\n      } else {\n          switch (ret) {\n          case STORED:\n              out_string(c, \"STORED\");\n              break;\n          case EXISTS:\n              out_string(c, \"EXISTS\");\n              break;\n          case NOT_FOUND:\n              out_string(c, \"NOT_FOUND\");\n              break;\n          case NOT_STORED:\n              out_string(c, \"NOT_STORED\");\n              break;\n          default:\n              out_string(c, \"SERVER_ERROR Unhandled storage type.\");\n          }\n      }\n\n    }\n\n    c->set_stale = false; /* force flag to be off just in case */\n    c->mset_res = false;\n    item_remove(c->item);       /* release the c->item reference */\n    c->item = 0;\n}\n\n/**\n * get a pointer to the key in this request\n */\nstatic char* binary_get_key(conn *c) {\n    return c->rcurr - (c->binary_header.request.keylen);\n}\n\nstatic void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {\n    protocol_binary_response_header* header;\n    mc_resp *resp = c->resp;\n\n    assert(c);\n\n    resp_reset(resp);\n\n    header = (protocol_binary_response_header *)resp->wbuf;\n\n    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;\n    header->response.opcode = c->binary_header.request.opcode;\n    header->response.keylen = (uint16_t)htons(key_len);\n\n    header->response.extlen = (uint8_t)hdr_len;\n    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;\n    header->response.status = (uint16_t)htons(err);\n\n    header->response.bodylen = htonl(body_len);\n    header->response.opaque = c->opaque;\n    header->response.cas = htonll(c->cas);\n\n    if (settings.verbose > 1) {\n        int ii;\n        fprintf(stderr, \">%d Writing bin response:\", c->sfd);\n        for (ii = 0; ii < sizeof(header->bytes); ++ii) {\n            if (ii % 4 == 0) {\n                fprintf(stderr, \"\\n>%d  \", c->sfd);\n            }\n            fprintf(stderr, \" 0x%02x\", header->bytes[ii]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n\n    resp->wbytes = sizeof(header->response);\n    resp_add_iov(resp, resp->wbuf, resp->wbytes);\n}\n\n/**\n * Writes a binary error response. If errstr is supplied, it is used as the\n * error text; otherwise a generic description of the error status code is\n * included.\n */\nstatic void write_bin_error(conn *c, protocol_binary_response_status err,\n                            const char *errstr, int swallow) {\n    size_t len;\n\n    if (!errstr) {\n        switch (err) {\n        case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n            errstr = \"Out of memory\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n            errstr = \"Unknown command\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n            errstr = \"Not found\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_EINVAL:\n            errstr = \"Invalid arguments\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n            errstr = \"Data exists for key.\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_E2BIG:\n            errstr = \"Too large.\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:\n            errstr = \"Non-numeric server-side value for incr or decr\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n            errstr = \"Not stored.\";\n            break;\n        case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n            errstr = \"Auth failure.\";\n            break;\n        default:\n            assert(false);\n            errstr = \"UNHANDLED ERROR\";\n            fprintf(stderr, \">%d UNHANDLED ERROR: %d\\n\", c->sfd, err);\n        }\n    }\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \">%d Writing an error: %s\\n\", c->sfd, errstr);\n    }\n\n    len = strlen(errstr);\n    add_bin_header(c, err, 0, 0, len);\n    if (len > 0) {\n        resp_add_iov(c->resp, errstr, len);\n    }\n    if (swallow > 0) {\n        c->sbytes = swallow;\n        conn_set_state(c, conn_swallow);\n    } else {\n        conn_set_state(c, conn_mwrite);\n    }\n}\n\n/* Form and send a response to a command over the binary protocol */\nstatic void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {\n    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||\n        c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n        add_bin_header(c, 0, hlen, keylen, dlen);\n        mc_resp *resp = c->resp;\n        if (dlen > 0) {\n            resp_add_iov(resp, d, dlen);\n        }\n    }\n\n    conn_set_state(c, conn_new_cmd);\n}\n\nstatic void complete_incr_bin(conn *c, char *extbuf) {\n    item *it;\n    char *key;\n    size_t nkey;\n    /* Weird magic in add_delta forces me to pad here */\n    char tmpbuf[INCR_MAX_STORAGE_LEN];\n    uint64_t cas = 0;\n\n    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->resp->wbuf;\n    protocol_binary_request_incr* req = (void *)extbuf;\n\n    assert(c != NULL);\n    //assert(c->wsize >= sizeof(*rsp));\n\n    /* fix byteorder in the request */\n    req->message.body.delta = ntohll(req->message.body.delta);\n    req->message.body.initial = ntohll(req->message.body.initial);\n    req->message.body.expiration = ntohl(req->message.body.expiration);\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        int i;\n        fprintf(stderr, \"incr \");\n\n        for (i = 0; i < nkey; i++) {\n            fprintf(stderr, \"%c\", key[i]);\n        }\n        fprintf(stderr, \" %lld, %llu, %d\\n\",\n                (long long)req->message.body.delta,\n                (long long)req->message.body.initial,\n                req->message.body.expiration);\n    }\n\n    if (c->binary_header.request.cas != 0) {\n        cas = c->binary_header.request.cas;\n    }\n    switch(add_delta(c, key, nkey, c->cmd == PROTOCOL_BINARY_CMD_INCREMENT,\n                     req->message.body.delta, tmpbuf,\n                     &cas)) {\n    case OK:\n        rsp->message.body.value = htonll(strtoull(tmpbuf, NULL, 10));\n        if (cas) {\n            c->cas = cas;\n        }\n        write_bin_response(c, &rsp->message.body, 0, 0,\n                           sizeof(rsp->message.body.value));\n        break;\n    case NON_NUMERIC:\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, NULL, 0);\n        break;\n    case EOM:\n        out_of_memory(c, \"SERVER_ERROR Out of memory incrementing value\");\n        break;\n    case DELTA_ITEM_NOT_FOUND:\n        if (req->message.body.expiration != 0xffffffff) {\n            /* Save some room for the response */\n            rsp->message.body.value = htonll(req->message.body.initial);\n\n            snprintf(tmpbuf, INCR_MAX_STORAGE_LEN, \"%llu\",\n                (unsigned long long)req->message.body.initial);\n            int res = strlen(tmpbuf);\n            it = item_alloc(key, nkey, 0, realtime(req->message.body.expiration),\n                            res + 2);\n\n            if (it != NULL) {\n                memcpy(ITEM_data(it), tmpbuf, res);\n                memcpy(ITEM_data(it) + res, \"\\r\\n\", 2);\n\n                if (store_item(it, NREAD_ADD, c)) {\n                    c->cas = ITEM_get_cas(it);\n                    write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));\n                } else {\n                    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED,\n                                    NULL, 0);\n                }\n                item_remove(it);         /* release our reference */\n            } else {\n                out_of_memory(c,\n                        \"SERVER_ERROR Out of memory allocating new item\");\n            }\n        } else {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n                c->thread->stats.incr_misses++;\n            } else {\n                c->thread->stats.decr_misses++;\n            }\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);\n        }\n        break;\n    case DELTA_ITEM_CAS_MISMATCH:\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);\n        break;\n    }\n}\n\nstatic void complete_update_bin(conn *c) {\n    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;\n    enum store_item_type ret = NOT_STORED;\n    assert(c != NULL);\n\n    item *it = c->item;\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    /* We don't actually receive the trailing two characters in the bin\n     * protocol, so we're going to just set them here */\n    if ((it->it_flags & ITEM_CHUNKED) == 0) {\n        *(ITEM_data(it) + it->nbytes - 2) = '\\r';\n        *(ITEM_data(it) + it->nbytes - 1) = '\\n';\n    } else {\n        assert(c->ritem);\n        item_chunk *ch = (item_chunk *) c->ritem;\n        if (ch->size == ch->used)\n            ch = ch->next;\n        assert(ch->size - ch->used >= 2);\n        ch->data[ch->used] = '\\r';\n        ch->data[ch->used + 1] = '\\n';\n        ch->used += 2;\n    }\n\n    ret = store_item(it, c->cmd, c);\n\n#ifdef ENABLE_DTRACE\n    uint64_t cas = ITEM_get_cas(it);\n    switch (c->cmd) {\n    case NREAD_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,\n                              (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,\n                                  (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,\n                                 (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,\n                                 (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,\n                              (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case STORED:\n        /* Stored */\n        write_bin_response(c, NULL, 0, 0, 0);\n        break;\n    case EXISTS:\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);\n        break;\n    case NOT_FOUND:\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);\n        break;\n    case NOT_STORED:\n    case TOO_LARGE:\n    case NO_MEMORY:\n        if (c->cmd == NREAD_ADD) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n        } else if(c->cmd == NREAD_REPLACE) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n        } else {\n            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n        }\n        write_bin_error(c, eno, NULL, 0);\n    }\n\n    item_remove(c->item);       /* release the c->item reference */\n    c->item = 0;\n}\n\nstatic void write_bin_miss_response(conn *c, char *key, size_t nkey) {\n    if (nkey) {\n        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,\n                0, nkey, nkey);\n        char *ofs = c->resp->wbuf + sizeof(protocol_binary_response_header);\n        memcpy(ofs, key, nkey);\n        resp_add_iov(c->resp, ofs, nkey);\n        conn_set_state(c, conn_new_cmd);\n    } else {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,\n                        NULL, 0);\n    }\n}\n\nstatic void process_bin_get_or_touch(conn *c, char *extbuf) {\n    item *it;\n\n    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->resp->wbuf;\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n    int should_touch = (c->cmd == PROTOCOL_BINARY_CMD_TOUCH ||\n                        c->cmd == PROTOCOL_BINARY_CMD_GAT ||\n                        c->cmd == PROTOCOL_BINARY_CMD_GATK);\n    int should_return_key = (c->cmd == PROTOCOL_BINARY_CMD_GETK ||\n                             c->cmd == PROTOCOL_BINARY_CMD_GATK);\n    int should_return_value = (c->cmd != PROTOCOL_BINARY_CMD_TOUCH);\n    bool failed = false;\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"<%d %s \", c->sfd, should_touch ? \"TOUCH\" : \"GET\");\n        if (fwrite(key, 1, nkey, stderr)) {}\n        fputc('\\n', stderr);\n    }\n\n    if (should_touch) {\n        protocol_binary_request_touch *t = (void *)extbuf;\n        time_t exptime = ntohl(t->message.body.expiration);\n\n        it = item_touch(key, nkey, realtime(exptime), c);\n    } else {\n        it = item_get(key, nkey, c, DO_UPDATE);\n    }\n\n    if (it) {\n        /* the length has two unnecessary bytes (\"\\r\\n\") */\n        uint16_t keylen = 0;\n        uint32_t bodylen = sizeof(rsp->message.body) + (it->nbytes - 2);\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        if (should_touch) {\n            c->thread->stats.touch_cmds++;\n            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;\n        } else {\n            c->thread->stats.get_cmds++;\n            c->thread->stats.lru_hits[it->slabs_clsid]++;\n        }\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        if (should_touch) {\n            MEMCACHED_COMMAND_TOUCH(c->sfd, ITEM_key(it), it->nkey,\n                                    it->nbytes, ITEM_get_cas(it));\n        } else {\n            MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                  it->nbytes, ITEM_get_cas(it));\n        }\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_TOUCH) {\n            bodylen -= it->nbytes - 2;\n        } else if (should_return_key) {\n            bodylen += nkey;\n            keylen = nkey;\n        }\n\n        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);\n        rsp->message.header.response.cas = htonll(ITEM_get_cas(it));\n\n        // add the flags\n        FLAGS_CONV(it, rsp->message.body.flags);\n        rsp->message.body.flags = htonl(rsp->message.body.flags);\n        resp_add_iov(c->resp, &rsp->message.body, sizeof(rsp->message.body));\n\n        if (should_return_key) {\n            resp_add_iov(c->resp, ITEM_key(it), nkey);\n        }\n\n        if (should_return_value) {\n            /* Add the data minus the CRLF */\n#ifdef EXTSTORE\n            if (it->it_flags & ITEM_HDR) {\n                if (_get_extstore(c, it, c->resp) != 0) {\n                    pthread_mutex_lock(&c->thread->stats.mutex);\n                    c->thread->stats.get_oom_extstore++;\n                    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n                    failed = true;\n                }\n            } else if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                resp_add_iov(c->resp, ITEM_data(it), it->nbytes - 2);\n            } else {\n                // Allow transmit handler to find the item and expand iov's\n                resp_add_chunked_iov(c->resp, it, it->nbytes - 2);\n            }\n#else\n            if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                resp_add_iov(c->resp, ITEM_data(it), it->nbytes - 2);\n            } else {\n                resp_add_chunked_iov(c->resp, it, it->nbytes - 2);\n            }\n#endif\n        }\n\n        if (!failed) {\n            conn_set_state(c, conn_new_cmd);\n            /* Remember this command so we can garbage collect it later */\n#ifdef EXTSTORE\n            if ((it->it_flags & ITEM_HDR) != 0 && should_return_value) {\n                // Only have extstore clean if header and returning value.\n                c->resp->item = NULL;\n            } else {\n                c->resp->item = it;\n            }\n#else\n            c->resp->item = it;\n#endif\n        } else {\n            item_remove(it);\n        }\n    } else {\n        failed = true;\n    }\n\n    if (failed) {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        if (should_touch) {\n            c->thread->stats.touch_cmds++;\n            c->thread->stats.touch_misses++;\n        } else {\n            c->thread->stats.get_cmds++;\n            c->thread->stats.get_misses++;\n        }\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        if (should_touch) {\n            MEMCACHED_COMMAND_TOUCH(c->sfd, key, nkey, -1, 0);\n        } else {\n            MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n        }\n\n        if (c->noreply) {\n            conn_set_state(c, conn_new_cmd);\n        } else {\n            if (should_return_key) {\n                write_bin_miss_response(c, key, nkey);\n            } else {\n                write_bin_miss_response(c, NULL, 0);\n            }\n        }\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_get(key, nkey, NULL != it);\n    }\n}\n\nstatic void append_bin_stats(const char *key, const uint16_t klen,\n                             const char *val, const uint32_t vlen,\n                             conn *c) {\n    char *buf = c->stats.buffer + c->stats.offset;\n    uint32_t bodylen = klen + vlen;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = PROTOCOL_BINARY_CMD_STAT,\n        .response.keylen = (uint16_t)htons(klen),\n        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,\n        .response.bodylen = htonl(bodylen),\n        .response.opaque = c->opaque\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (klen > 0) {\n        memcpy(buf, key, klen);\n        buf += klen;\n\n        if (vlen > 0) {\n            memcpy(buf, val, vlen);\n        }\n    }\n\n    c->stats.offset += sizeof(header.response) + bodylen;\n}\n\nstatic void append_ascii_stats(const char *key, const uint16_t klen,\n                               const char *val, const uint32_t vlen,\n                               conn *c) {\n    char *pos = c->stats.buffer + c->stats.offset;\n    uint32_t nbytes = 0;\n    int remaining = c->stats.size - c->stats.offset;\n    int room = remaining - 1;\n\n    if (klen == 0 && vlen == 0) {\n        nbytes = snprintf(pos, room, \"END\\r\\n\");\n    } else if (vlen == 0) {\n        nbytes = snprintf(pos, room, \"STAT %s\\r\\n\", key);\n    } else {\n        nbytes = snprintf(pos, room, \"STAT %s %s\\r\\n\", key, val);\n    }\n\n    c->stats.offset += nbytes;\n}\n\nstatic bool grow_stats_buf(conn *c, size_t needed) {\n    size_t nsize = c->stats.size;\n    size_t available = nsize - c->stats.offset;\n    bool rv = true;\n\n    /* Special case: No buffer -- need to allocate fresh */\n    if (c->stats.buffer == NULL) {\n        nsize = 1024;\n        available = c->stats.size = c->stats.offset = 0;\n    }\n\n    while (needed > available) {\n        assert(nsize > 0);\n        nsize = nsize << 1;\n        available = nsize - c->stats.offset;\n    }\n\n    if (nsize != c->stats.size) {\n        char *ptr = realloc(c->stats.buffer, nsize);\n        if (ptr) {\n            c->stats.buffer = ptr;\n            c->stats.size = nsize;\n        } else {\n            STATS_LOCK();\n            stats.malloc_fails++;\n            STATS_UNLOCK();\n            rv = false;\n        }\n    }\n\n    return rv;\n}\n\nstatic void append_stats(const char *key, const uint16_t klen,\n                  const char *val, const uint32_t vlen,\n                  const void *cookie)\n{\n    /* value without a key is invalid */\n    if (klen == 0 && vlen > 0) {\n        return;\n    }\n\n    conn *c = (conn*)cookie;\n\n    if (c->protocol == binary_prot) {\n        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);\n        if (!grow_stats_buf(c, needed)) {\n            return;\n        }\n        append_bin_stats(key, klen, val, vlen, c);\n    } else {\n        size_t needed = vlen + klen + 10; // 10 == \"STAT = \\r\\n\"\n        if (!grow_stats_buf(c, needed)) {\n            return;\n        }\n        append_ascii_stats(key, klen, val, vlen, c);\n    }\n\n    assert(c->stats.offset <= c->stats.size);\n}\n\nstatic void process_bin_stat(conn *c) {\n    char *subcommand = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        int ii;\n        fprintf(stderr, \"<%d STATS \", c->sfd);\n        for (ii = 0; ii < nkey; ++ii) {\n            fprintf(stderr, \"%c\", subcommand[ii]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n\n    if (nkey == 0) {\n        /* request all statistics */\n        server_stats(&append_stats, c);\n        (void)get_stats(NULL, 0, &append_stats, c);\n    } else if (strncmp(subcommand, \"reset\", 5) == 0) {\n        stats_reset();\n    } else if (strncmp(subcommand, \"settings\", 8) == 0) {\n        process_stat_settings(&append_stats, c);\n    } else if (strncmp(subcommand, \"detail\", 6) == 0) {\n        char *subcmd_pos = subcommand + 6;\n        if (strncmp(subcmd_pos, \" dump\", 5) == 0) {\n            int len;\n            char *dump_buf = stats_prefix_dump(&len);\n            if (dump_buf == NULL || len <= 0) {\n                out_of_memory(c, \"SERVER_ERROR Out of memory generating stats\");\n                if (dump_buf != NULL)\n                    free(dump_buf);\n                return;\n            } else {\n                append_stats(\"detailed\", strlen(\"detailed\"), dump_buf, len, c);\n                free(dump_buf);\n            }\n        } else if (strncmp(subcmd_pos, \" on\", 3) == 0) {\n            settings.detail_enabled = 1;\n        } else if (strncmp(subcmd_pos, \" off\", 4) == 0) {\n            settings.detail_enabled = 0;\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);\n            return;\n        }\n    } else {\n        if (get_stats(subcommand, nkey, &append_stats, c)) {\n            if (c->stats.buffer == NULL) {\n                out_of_memory(c, \"SERVER_ERROR Out of memory generating stats\");\n            } else {\n                write_and_free(c, c->stats.buffer, c->stats.offset);\n                c->stats.buffer = NULL;\n            }\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);\n        }\n\n        return;\n    }\n\n    /* Append termination package and start the transfer */\n    append_stats(NULL, 0, NULL, 0, c);\n    if (c->stats.buffer == NULL) {\n        out_of_memory(c, \"SERVER_ERROR Out of memory preparing to send stats\");\n    } else {\n        write_and_free(c, c->stats.buffer, c->stats.offset);\n        c->stats.buffer = NULL;\n    }\n}\n\n/* Just write an error message and disconnect the client */\nstatic void handle_binary_protocol_error(conn *c) {\n    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, 0);\n    if (settings.verbose) {\n        fprintf(stderr, \"Protocol error (opcode %02x), close connection %d\\n\",\n                c->binary_header.request.opcode, c->sfd);\n    }\n    c->close_after_write = true;\n}\n\nstatic void init_sasl_conn(conn *c) {\n    assert(c);\n    /* should something else be returned? */\n    if (!settings.sasl)\n        return;\n\n    c->authenticated = false;\n\n    if (!c->sasl_conn) {\n        int result=sasl_server_new(\"memcached\",\n                                   NULL,\n                                   my_sasl_hostname[0] ? my_sasl_hostname : NULL,\n                                   NULL, NULL,\n                                   NULL, 0, &c->sasl_conn);\n        if (result != SASL_OK) {\n            if (settings.verbose) {\n                fprintf(stderr, \"Failed to initialize SASL conn.\\n\");\n            }\n            c->sasl_conn = NULL;\n        }\n    }\n}\n\nstatic void bin_list_sasl_mechs(conn *c) {\n    // Guard against a disabled SASL.\n    if (!settings.sasl) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,\n                        c->binary_header.request.bodylen\n                        - c->binary_header.request.keylen);\n        return;\n    }\n\n    init_sasl_conn(c);\n    const char *result_string = NULL;\n    unsigned int string_length = 0;\n    int result=sasl_listmech(c->sasl_conn, NULL,\n                             \"\",   /* What to prepend the string with */\n                             \" \",  /* What to separate mechanisms with */\n                             \"\",   /* What to append to the string */\n                             &result_string, &string_length,\n                             NULL);\n    if (result != SASL_OK) {\n        /* Perhaps there's a better error for this... */\n        if (settings.verbose) {\n            fprintf(stderr, \"Failed to list SASL mechanisms.\\n\");\n        }\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);\n        return;\n    }\n    write_bin_response(c, (char*)result_string, 0, 0, string_length);\n}\n\nstatic void process_bin_sasl_auth(conn *c) {\n    // Guard for handling disabled SASL on the server.\n    if (!settings.sasl) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,\n                        c->binary_header.request.bodylen\n                        - c->binary_header.request.keylen);\n        return;\n    }\n\n    assert(c->binary_header.request.extlen == 0);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    if (nkey > MAX_SASL_MECH_LEN) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);\n        conn_set_state(c, conn_swallow);\n        return;\n    }\n\n    char *key = binary_get_key(c);\n    assert(key);\n\n    item *it = item_alloc(key, nkey, 0, 0, vlen+2);\n\n    /* Can't use a chunked item for SASL authentication. */\n    if (it == 0 || (it->it_flags & ITEM_CHUNKED)) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, NULL, vlen);\n        conn_set_state(c, conn_swallow);\n        if (it) {\n            do_item_remove(it);\n        }\n        return;\n    }\n\n    c->item = it;\n    c->ritem = ITEM_data(it);\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_reading_sasl_auth_data;\n}\n\nstatic void process_bin_complete_sasl_auth(conn *c) {\n    assert(settings.sasl);\n    const char *out = NULL;\n    unsigned int outlen = 0;\n\n    assert(c->item);\n    init_sasl_conn(c);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    if (nkey > ((item*) c->item)->nkey) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);\n        conn_set_state(c, conn_swallow);\n        return;\n    }\n\n    char mech[nkey+1];\n    memcpy(mech, ITEM_key((item*)c->item), nkey);\n    mech[nkey] = 0x00;\n\n    if (settings.verbose)\n        fprintf(stderr, \"mech:  ``%s'' with %d bytes of data\\n\", mech, vlen);\n\n    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);\n\n    if (vlen > ((item*) c->item)->nbytes) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);\n        conn_set_state(c, conn_swallow);\n        return;\n    }\n\n    int result=-1;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        result = sasl_server_start(c->sasl_conn, mech,\n                                   challenge, vlen,\n                                   &out, &outlen);\n        c->sasl_started = (result == SASL_OK || result == SASL_CONTINUE);\n        break;\n    case PROTOCOL_BINARY_CMD_SASL_STEP:\n        if (!c->sasl_started) {\n            if (settings.verbose) {\n                fprintf(stderr, \"%d: SASL_STEP called but sasl_server_start \"\n                        \"not called for this connection!\\n\", c->sfd);\n            }\n            break;\n        }\n        result = sasl_server_step(c->sasl_conn,\n                                  challenge, vlen,\n                                  &out, &outlen);\n        break;\n    default:\n        assert(false); /* CMD should be one of the above */\n        /* This code is pretty much impossible, but makes the compiler\n           happier */\n        if (settings.verbose) {\n            fprintf(stderr, \"Unhandled command %d with challenge %s\\n\",\n                    c->cmd, challenge);\n        }\n        break;\n    }\n\n    if (settings.verbose) {\n        fprintf(stderr, \"sasl result code:  %d\\n\", result);\n    }\n\n    switch(result) {\n    case SASL_OK:\n        c->authenticated = true;\n        write_bin_response(c, \"Authenticated\", 0, 0, strlen(\"Authenticated\"));\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.auth_cmds++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n        break;\n    case SASL_CONTINUE:\n        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);\n        if (outlen > 0) {\n            resp_add_iov(c->resp, out, outlen);\n        }\n        // Immediately flush our write.\n        conn_set_state(c, conn_mwrite);\n        break;\n    default:\n        if (settings.verbose)\n            fprintf(stderr, \"Unknown sasl response:  %d\\n\", result);\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.auth_cmds++;\n        c->thread->stats.auth_errors++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n    }\n}\n\nstatic bool authenticated(conn *c) {\n    assert(settings.sasl);\n    bool rv = false;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */\n        rv = true;\n        break;\n    default:\n        rv = c->authenticated;\n    }\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"authenticated() in cmd 0x%02x is %s\\n\",\n                c->cmd, rv ? \"true\" : \"false\");\n    }\n\n    return rv;\n}\n\nstatic void dispatch_bin_command(conn *c, char *extbuf) {\n    int protocol_error = 0;\n\n    uint8_t extlen = c->binary_header.request.extlen;\n    uint16_t keylen = c->binary_header.request.keylen;\n    uint32_t bodylen = c->binary_header.request.bodylen;\n\n    if (keylen > bodylen || keylen + extlen > bodylen) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL, 0);\n        c->close_after_write = true;\n        return;\n    }\n\n    if (settings.sasl && !authenticated(c)) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);\n        c->close_after_write = true;\n        return;\n    }\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n    c->noreply = true;\n\n    /* binprot supports 16bit keys, but internals are still 8bit */\n    if (keylen > KEY_MAX_LENGTH) {\n        handle_binary_protocol_error(c);\n        return;\n    }\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_SET;\n        break;\n    case PROTOCOL_BINARY_CMD_ADDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_ADD;\n        break;\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;\n        break;\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DELETE;\n        break;\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_QUITQ:\n        c->cmd = PROTOCOL_BINARY_CMD_QUIT;\n        break;\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;\n        break;\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_APPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_GETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GET;\n        break;\n    case PROTOCOL_BINARY_CMD_GETKQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GETK;\n        break;\n    case PROTOCOL_BINARY_CMD_GATQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GAT;\n        break;\n    case PROTOCOL_BINARY_CMD_GATKQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GATK;\n        break;\n    default:\n        c->noreply = false;\n    }\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_VERSION:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_FLUSH:\n            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {\n                process_bin_flush(c, extbuf);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_NOOP:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n                // NOOP forces pipeline flush.\n                conn_set_state(c, conn_mwrite);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {\n                process_bin_update(c, extbuf);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETK:\n            if (extlen == 0 && bodylen == keylen && keylen > 0) {\n                process_bin_get_or_touch(c, extbuf);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_DELETE:\n            if (keylen > 0 && extlen == 0 && bodylen == keylen) {\n                process_bin_delete(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_INCREMENT:\n        case PROTOCOL_BINARY_CMD_DECREMENT:\n            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {\n                complete_incr_bin(c, extbuf);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_APPEND:\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            if (keylen > 0 && extlen == 0) {\n                process_bin_append_prepend(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_STAT:\n            if (extlen == 0) {\n                process_bin_stat(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_QUIT:\n            if (keylen == 0 && extlen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n                conn_set_state(c, conn_mwrite);\n                c->close_after_write = true;\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                bin_list_sasl_mechs(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        case PROTOCOL_BINARY_CMD_SASL_STEP:\n            if (extlen == 0 && keylen != 0) {\n                process_bin_sasl_auth(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_TOUCH:\n        case PROTOCOL_BINARY_CMD_GAT:\n        case PROTOCOL_BINARY_CMD_GATQ:\n        case PROTOCOL_BINARY_CMD_GATK:\n        case PROTOCOL_BINARY_CMD_GATKQ:\n            if (extlen == 4 && keylen != 0) {\n                process_bin_get_or_touch(c, extbuf);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        default:\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,\n                            bodylen);\n    }\n\n    if (protocol_error)\n        handle_binary_protocol_error(c);\n}\n\nstatic void process_bin_update(conn *c, char *extbuf) {\n    char *key;\n    int nkey;\n    int vlen;\n    item *it;\n    protocol_binary_request_set* req = (void *)extbuf;\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n\n    /* fix byteorder in the request */\n    req->message.body.flags = ntohl(req->message.body.flags);\n    req->message.body.expiration = ntohl(req->message.body.expiration);\n\n    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);\n\n    if (settings.verbose > 1) {\n        int ii;\n        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {\n            fprintf(stderr, \"<%d ADD \", c->sfd);\n        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            fprintf(stderr, \"<%d SET \", c->sfd);\n        } else {\n            fprintf(stderr, \"<%d REPLACE \", c->sfd);\n        }\n        for (ii = 0; ii < nkey; ++ii) {\n            fprintf(stderr, \"%c\", key[ii]);\n        }\n\n        fprintf(stderr, \" Value len is %d\", vlen);\n        fprintf(stderr, \"\\n\");\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    it = item_alloc(key, nkey, req->message.body.flags,\n            realtime(req->message.body.expiration), vlen+2);\n\n    if (it == 0) {\n        enum store_item_type status;\n        if (! item_size_ok(nkey, req->message.body.flags, vlen + 2)) {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);\n            status = TOO_LARGE;\n        } else {\n            out_of_memory(c, \"SERVER_ERROR Out of memory allocating item\");\n            /* This error generating method eats the swallow value. Add here. */\n            c->sbytes = vlen;\n            status = NO_MEMORY;\n        }\n        /* FIXME: losing c->cmd since it's translated below. refactor? */\n        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,\n                NULL, status, 0, key, nkey, req->message.body.expiration,\n                ITEM_clsid(it), c->sfd);\n\n        /* Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET. Anywhere else too? */\n        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            it = item_get(key, nkey, c, DONT_UPDATE);\n            if (it) {\n                item_unlink(it);\n                STORAGE_delete(c->thread->storage, it);\n                item_remove(it);\n            }\n        }\n\n        /* swallow the data line */\n        conn_set_state(c, conn_swallow);\n        return;\n    }\n\n    ITEM_set_cas(it, c->binary_header.request.cas);\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_ADD:\n            c->cmd = NREAD_ADD;\n            break;\n        case PROTOCOL_BINARY_CMD_SET:\n            c->cmd = NREAD_SET;\n            break;\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            c->cmd = NREAD_REPLACE;\n            break;\n        default:\n            assert(0);\n    }\n\n    if (ITEM_get_cas(it) != 0) {\n        c->cmd = NREAD_CAS;\n    }\n\n    c->item = it;\n#ifdef NEED_ALIGN\n    if (it->it_flags & ITEM_CHUNKED) {\n        c->ritem = ITEM_schunk(it);\n    } else {\n        c->ritem = ITEM_data(it);\n    }\n#else\n    c->ritem = ITEM_data(it);\n#endif\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_read_set_value;\n}\n\nstatic void process_bin_append_prepend(conn *c) {\n    char *key;\n    int nkey;\n    int vlen;\n    item *it;\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n    vlen = c->binary_header.request.bodylen - nkey;\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"Value len is %d\\n\", vlen);\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    it = item_alloc(key, nkey, 0, 0, vlen+2);\n\n    if (it == 0) {\n        if (! item_size_ok(nkey, 0, vlen + 2)) {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);\n        } else {\n            out_of_memory(c, \"SERVER_ERROR Out of memory allocating item\");\n            /* OOM calls eat the swallow value. Add here. */\n            c->sbytes = vlen;\n        }\n        /* swallow the data line */\n        conn_set_state(c, conn_swallow);\n        return;\n    }\n\n    ITEM_set_cas(it, c->binary_header.request.cas);\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_APPEND:\n            c->cmd = NREAD_APPEND;\n            break;\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            c->cmd = NREAD_PREPEND;\n            break;\n        default:\n            assert(0);\n    }\n\n    c->item = it;\n#ifdef NEED_ALIGN\n    if (it->it_flags & ITEM_CHUNKED) {\n        c->ritem = ITEM_schunk(it);\n    } else {\n        c->ritem = ITEM_data(it);\n    }\n#else\n    c->ritem = ITEM_data(it);\n#endif\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_read_set_value;\n}\n\nstatic void process_bin_flush(conn *c, char *extbuf) {\n    time_t exptime = 0;\n    protocol_binary_request_flush* req = (void *)extbuf;\n    rel_time_t new_oldest = 0;\n\n    if (!settings.flush_enabled) {\n      // flush_all is not allowed but we log it on stats\n      write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);\n      return;\n    }\n\n    if (c->binary_header.request.extlen == sizeof(req->message.body)) {\n        exptime = ntohl(req->message.body.expiration);\n    }\n\n    if (exptime > 0) {\n        new_oldest = realtime(exptime);\n    } else {\n        new_oldest = current_time;\n    }\n    if (settings.use_cas) {\n        settings.oldest_live = new_oldest - 1;\n        if (settings.oldest_live <= current_time)\n            settings.oldest_cas = get_cas_id();\n    } else {\n        settings.oldest_live = new_oldest;\n    }\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.flush_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    write_bin_response(c, NULL, 0, 0, 0);\n}\n\nstatic void process_bin_delete(conn *c) {\n    item *it;\n    uint32_t hv;\n\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    assert(c != NULL);\n\n    if (settings.verbose > 1) {\n        int ii;\n        fprintf(stderr, \"Deleting \");\n        for (ii = 0; ii < nkey; ++ii) {\n            fprintf(stderr, \"%c\", key[ii]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_delete(key, nkey);\n    }\n\n    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);\n    if (it) {\n        uint64_t cas = c->binary_header.request.cas;\n        if (cas == 0 || cas == ITEM_get_cas(it)) {\n            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n            do_item_unlink(it, hv);\n            STORAGE_delete(c->thread->storage, it);\n            write_bin_response(c, NULL, 0, 0, 0);\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);\n        }\n        do_item_remove(it);      /* release our reference */\n    } else {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.delete_misses++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n    }\n    item_unlock(hv);\n}\n\nstatic void complete_nread_binary(conn *c) {\n    assert(c != NULL);\n    assert(c->cmd >= 0);\n\n    switch(c->substate) {\n    case bin_read_set_value:\n        complete_update_bin(c);\n        break;\n    case bin_reading_sasl_auth_data:\n        process_bin_complete_sasl_auth(c);\n        if (c->item) {\n            do_item_remove(c->item);\n            c->item = NULL;\n        }\n        break;\n    default:\n        fprintf(stderr, \"Not handling substate %d\\n\", c->substate);\n        assert(0);\n    }\n}\n\nstatic void reset_cmd_handler(conn *c) {\n    c->cmd = -1;\n    c->substate = bin_no_state;\n    if (c->item != NULL) {\n        // TODO: Any other way to get here?\n        // SASL auth was mistakenly using it. Nothing else should?\n        item_remove(c->item);\n        c->item = NULL;\n    }\n    if (c->rbytes > 0) {\n        conn_set_state(c, conn_parse_cmd);\n    } else if (c->resp_head) {\n        conn_set_state(c, conn_mwrite);\n    } else {\n        conn_set_state(c, conn_waiting);\n    }\n}\n\nstatic void complete_nread(conn *c) {\n    assert(c != NULL);\n    assert(c->protocol == ascii_prot\n           || c->protocol == binary_prot);\n\n    if (c->protocol == ascii_prot) {\n        complete_nread_ascii(c);\n    } else if (c->protocol == binary_prot) {\n        complete_nread_binary(c);\n    }\n}\n\n/* Destination must always be chunked */\n/* This should be part of item.c */\nstatic int _store_item_copy_chunks(item *d_it, item *s_it, const int len) {\n    item_chunk *dch = (item_chunk *) ITEM_schunk(d_it);\n    /* Advance dch until we find free space */\n    while (dch->size == dch->used) {\n        if (dch->next) {\n            dch = dch->next;\n        } else {\n            break;\n        }\n    }\n\n    if (s_it->it_flags & ITEM_CHUNKED) {\n        int remain = len;\n        item_chunk *sch = (item_chunk *) ITEM_schunk(s_it);\n        int copied = 0;\n        /* Fills dch's to capacity, not straight copy sch in case data is\n         * being added or removed (ie append/prepend)\n         */\n        while (sch && dch && remain) {\n            assert(dch->used <= dch->size);\n            int todo = (dch->size - dch->used < sch->used - copied)\n                ? dch->size - dch->used : sch->used - copied;\n            if (remain < todo)\n                todo = remain;\n            memcpy(dch->data + dch->used, sch->data + copied, todo);\n            dch->used += todo;\n            copied += todo;\n            remain -= todo;\n            assert(dch->used <= dch->size);\n            if (dch->size == dch->used) {\n                item_chunk *tch = do_item_alloc_chunk(dch, remain);\n                if (tch) {\n                    dch = tch;\n                } else {\n                    return -1;\n                }\n            }\n            assert(copied <= sch->used);\n            if (copied == sch->used) {\n                copied = 0;\n                sch = sch->next;\n            }\n        }\n        /* assert that the destination had enough space for the source */\n        assert(remain == 0);\n    } else {\n        int done = 0;\n        /* Fill dch's via a non-chunked item. */\n        while (len > done && dch) {\n            int todo = (dch->size - dch->used < len - done)\n                ? dch->size - dch->used : len - done;\n            //assert(dch->size - dch->used != 0);\n            memcpy(dch->data + dch->used, ITEM_data(s_it) + done, todo);\n            done += todo;\n            dch->used += todo;\n            assert(dch->used <= dch->size);\n            if (dch->size == dch->used) {\n                item_chunk *tch = do_item_alloc_chunk(dch, len - done);\n                if (tch) {\n                    dch = tch;\n                } else {\n                    return -1;\n                }\n            }\n        }\n        assert(len == done);\n    }\n    return 0;\n}\n\nstatic int _store_item_copy_data(int comm, item *old_it, item *new_it, item *add_it) {\n    if (comm == NREAD_APPEND) {\n        if (new_it->it_flags & ITEM_CHUNKED) {\n            if (_store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2) == -1 ||\n                _store_item_copy_chunks(new_it, add_it, add_it->nbytes) == -1) {\n                return -1;\n            }\n        } else {\n            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);\n            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);\n        }\n    } else {\n        /* NREAD_PREPEND */\n        if (new_it->it_flags & ITEM_CHUNKED) {\n            if (_store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2) == -1 ||\n                _store_item_copy_chunks(new_it, old_it, old_it->nbytes) == -1) {\n                return -1;\n            }\n        } else {\n            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);\n            memcpy(ITEM_data(new_it) + add_it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);\n        }\n    }\n    return 0;\n}\n\n/*\n * Stores an item in the cache according to the semantics of one of the set\n * commands. Protected by the item lock.\n *\n * Returns the state of storage.\n */\nenum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {\n    char *key = ITEM_key(it);\n    item *old_it = do_item_get(key, it->nkey, hv, c, DONT_UPDATE);\n    enum store_item_type stored = NOT_STORED;\n\n    enum cas_result { CAS_NONE, CAS_MATCH, CAS_BADVAL, CAS_STALE, CAS_MISS };\n\n    item *new_it = NULL;\n    uint32_t flags;\n\n    /* Do the CAS test up front so we can apply to all store modes */\n    enum cas_result cas_res = CAS_NONE;\n\n    bool do_store = false;\n    if (old_it != NULL) {\n        // Most of the CAS work requires something to compare to.\n        uint64_t it_cas = ITEM_get_cas(it);\n        uint64_t old_cas = ITEM_get_cas(old_it);\n        if (it_cas == 0) {\n            cas_res = CAS_NONE;\n        } else if (it_cas == old_cas) {\n            cas_res = CAS_MATCH;\n        } else if (c->set_stale && it_cas < old_cas) {\n            cas_res = CAS_STALE;\n        } else {\n            cas_res = CAS_BADVAL;\n        }\n\n        switch (comm) {\n            case NREAD_ADD:\n                /* add only adds a nonexistent item, but promote to head of LRU */\n                do_item_update(old_it);\n                break;\n            case NREAD_CAS:\n                if (cas_res == CAS_MATCH) {\n                    // cas validates\n                    // it and old_it may belong to different classes.\n                    // I'm updating the stats for the one that's getting pushed out\n                    pthread_mutex_lock(&c->thread->stats.mutex);\n                    c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;\n                    pthread_mutex_unlock(&c->thread->stats.mutex);\n                    do_store = true;\n                } else if (cas_res == CAS_STALE) {\n                    // if we're allowed to set a stale value, CAS must be lower than\n                    // the current item's CAS.\n                    // This replaces the value, but should preserve TTL, and stale\n                    // item marker bit + token sent if exists.\n                    it->exptime = old_it->exptime;\n                    it->it_flags |= ITEM_STALE;\n                    if (old_it->it_flags & ITEM_TOKEN_SENT) {\n                        it->it_flags |= ITEM_TOKEN_SENT;\n                    }\n\n                    pthread_mutex_lock(&c->thread->stats.mutex);\n                    c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;\n                    pthread_mutex_unlock(&c->thread->stats.mutex);\n                    do_store = true;\n                } else {\n                    // NONE or BADVAL are the same for CAS cmd\n                    pthread_mutex_lock(&c->thread->stats.mutex);\n                    c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_badval++;\n                    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n                    if (settings.verbose > 1) {\n                        fprintf(stderr, \"CAS:  failure: expected %llu, got %llu\\n\",\n                                (unsigned long long)ITEM_get_cas(old_it),\n                                (unsigned long long)ITEM_get_cas(it));\n                    }\n                    stored = EXISTS;\n                }\n                break;\n            case NREAD_APPEND:\n            case NREAD_PREPEND:\n                if (cas_res != CAS_NONE && cas_res != CAS_MATCH) {\n                    stored = EXISTS;\n                    break;\n                }\n#ifdef EXTSTORE\n                if ((old_it->it_flags & ITEM_HDR) != 0) {\n                    /* block append/prepend from working with extstore-d items.\n                     * leave response code to NOT_STORED default */\n                    break;\n                }\n#endif\n                /* we have it and old_it here - alloc memory to hold both */\n                FLAGS_CONV(old_it, flags);\n                new_it = do_item_alloc(key, it->nkey, flags, old_it->exptime, it->nbytes + old_it->nbytes - 2 /* CRLF */);\n\n                // OOM trying to copy.\n                if (new_it == NULL)\n                    break;\n                /* copy data from it and old_it to new_it */\n                if (_store_item_copy_data(comm, old_it, new_it, it) == -1) {\n                    // failed data copy\n                    break;\n                } else {\n                    // refcount of new_it is 1 here. will end up 2 after link.\n                    // it's original ref is managed outside of this function\n                    it = new_it;\n                    do_store = true;\n                }\n                break;\n            case NREAD_REPLACE:\n            case NREAD_SET:\n                do_store = true;\n                break;\n        }\n\n        if (do_store) {\n            STORAGE_delete(c->thread->storage, old_it);\n            item_replace(old_it, it, hv);\n            stored = STORED;\n        }\n\n        do_item_remove(old_it);         /* release our reference */\n        if (new_it != NULL) {\n            // append/prepend end up with an extra reference for new_it.\n            do_item_remove(new_it);\n        }\n    } else {\n        /* No pre-existing item to replace or compare to. */\n        if (ITEM_get_cas(it) != 0) {\n            /* Asked for a CAS match but nothing to compare it to. */\n            cas_res = CAS_MISS;\n        }\n\n        switch (comm) {\n            case NREAD_ADD:\n            case NREAD_SET:\n                do_store = true;\n                break;\n            case NREAD_CAS:\n                // LRU expired\n                stored = NOT_FOUND;\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.cas_misses++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                break;\n            case NREAD_REPLACE:\n            case NREAD_APPEND:\n            case NREAD_PREPEND:\n                /* Requires an existing item. */\n                break;\n        }\n\n        if (do_store) {\n            do_item_link(it, hv);\n            stored = STORED;\n        }\n    }\n\n    if (stored == STORED) {\n        c->cas = ITEM_get_cas(it);\n    }\n    LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE, NULL,\n            stored, comm, ITEM_key(it), it->nkey, it->exptime, ITEM_clsid(it), c->sfd);\n\n    return stored;\n}\n\ntypedef struct token_s {\n    char *value;\n    size_t length;\n} token_t;\n\n#define COMMAND_TOKEN 0\n#define SUBCOMMAND_TOKEN 1\n#define KEY_TOKEN 1\n\n#define MAX_TOKENS 24\n\n/*\n * Tokenize the command string by replacing whitespace with '\\0' and update\n * the token array tokens with pointer to start of each token and length.\n * Returns total number of tokens.  The last valid token is the terminal\n * token (value points to the first unprocessed character of the string and\n * length zero).\n *\n * Usage example:\n *\n *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {\n *      for(int ix = 0; tokens[ix].length != 0; ix++) {\n *          ...\n *      }\n *      ncommand = tokens[ix].value - command;\n *      command  = tokens[ix].value;\n *   }\n */\nstatic size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {\n    char *s, *e;\n    size_t ntokens = 0;\n    size_t len = strlen(command);\n    unsigned int i = 0;\n\n    assert(command != NULL && tokens != NULL && max_tokens > 1);\n\n    s = e = command;\n    for (i = 0; i < len; i++) {\n        if (*e == ' ') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n                *e = '\\0';\n                if (ntokens == max_tokens - 1) {\n                    e++;\n                    s = e; /* so we don't add an extra token */\n                    break;\n                }\n            }\n            s = e + 1;\n        }\n        e++;\n    }\n\n    if (s != e) {\n        tokens[ntokens].value = s;\n        tokens[ntokens].length = e - s;\n        ntokens++;\n    }\n\n    /*\n     * If we scanned the whole string, the terminal value pointer is null,\n     * otherwise it is the first unprocessed character.\n     */\n    tokens[ntokens].value =  *e == '\\0' ? NULL : e;\n    tokens[ntokens].length = 0;\n    ntokens++;\n\n    return ntokens;\n}\n\n/* set up a connection to write a buffer then free it, used for stats */\nstatic void write_and_free(conn *c, char *buf, int bytes) {\n    if (buf) {\n        mc_resp *resp = c->resp;\n        resp->write_and_free = buf;\n        resp_add_iov(resp, buf, bytes);\n        conn_set_state(c, conn_new_cmd);\n    } else {\n        out_of_memory(c, \"SERVER_ERROR out of memory writing stats\");\n    }\n}\n\nstatic inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)\n{\n    int noreply_index = ntokens - 2;\n\n    /*\n      NOTE: this function is not the first place where we are going to\n      send the reply.  We could send it instead from process_command()\n      if the request line has wrong number of tokens.  However parsing\n      malformed line for \"noreply\" option is not reliable anyway, so\n      it can't be helped.\n    */\n    if (tokens[noreply_index].value\n        && strcmp(tokens[noreply_index].value, \"noreply\") == 0) {\n        c->noreply = true;\n    }\n    return c->noreply;\n}\n\nvoid append_stat(const char *name, ADD_STAT add_stats, conn *c,\n                 const char *fmt, ...) {\n    char val_str[STAT_VAL_LEN];\n    int vlen;\n    va_list ap;\n\n    assert(name);\n    assert(add_stats);\n    assert(c);\n    assert(fmt);\n\n    va_start(ap, fmt);\n    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);\n    va_end(ap);\n\n    add_stats(name, strlen(name), val_str, vlen, c);\n}\n\ninline static void process_stats_detail(conn *c, const char *command) {\n    assert(c != NULL);\n\n    if (strcmp(command, \"on\") == 0) {\n        settings.detail_enabled = 1;\n        out_string(c, \"OK\");\n    }\n    else if (strcmp(command, \"off\") == 0) {\n        settings.detail_enabled = 0;\n        out_string(c, \"OK\");\n    }\n    else if (strcmp(command, \"dump\") == 0) {\n        int len;\n        char *stats = stats_prefix_dump(&len);\n        write_and_free(c, stats, len);\n    }\n    else {\n        out_string(c, \"CLIENT_ERROR usage: stats detail on|off|dump\");\n    }\n}\n\n/* return server specific stats only */\nstatic void server_stats(ADD_STAT add_stats, conn *c) {\n    pid_t pid = getpid();\n    rel_time_t now = current_time;\n\n    struct thread_stats thread_stats;\n    threadlocal_stats_aggregate(&thread_stats);\n    struct slab_stats slab_stats;\n    slab_stats_aggregate(&thread_stats, &slab_stats);\n#ifdef EXTSTORE\n    struct extstore_stats st;\n#endif\n#ifndef WIN32\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n#endif /* !WIN32 */\n\n    STATS_LOCK();\n\n    APPEND_STAT(\"pid\", \"%lu\", (long)pid);\n    APPEND_STAT(\"uptime\", \"%u\", now - ITEM_UPDATE_INTERVAL);\n    APPEND_STAT(\"time\", \"%ld\", now + (long)process_started);\n    APPEND_STAT(\"version\", \"%s\", VERSION);\n    APPEND_STAT(\"libevent\", \"%s\", event_get_version());\n    APPEND_STAT(\"pointer_size\", \"%d\", (int)(8 * sizeof(void *)));\n\n#ifndef WIN32\n    append_stat(\"rusage_user\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_utime.tv_sec,\n                (long)usage.ru_utime.tv_usec);\n    append_stat(\"rusage_system\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_stime.tv_sec,\n                (long)usage.ru_stime.tv_usec);\n#endif /* !WIN32 */\n\n    APPEND_STAT(\"max_connections\", \"%d\", settings.maxconns);\n    APPEND_STAT(\"curr_connections\", \"%llu\", (unsigned long long)stats_state.curr_conns - 1);\n    APPEND_STAT(\"total_connections\", \"%llu\", (unsigned long long)stats.total_conns);\n    if (settings.maxconns_fast) {\n        APPEND_STAT(\"rejected_connections\", \"%llu\", (unsigned long long)stats.rejected_conns);\n    }\n    APPEND_STAT(\"connection_structures\", \"%u\", stats_state.conn_structs);\n    APPEND_STAT(\"response_obj_bytes\", \"%llu\", (unsigned long long)thread_stats.response_obj_bytes);\n    APPEND_STAT(\"response_obj_total\", \"%llu\", (unsigned long long)thread_stats.response_obj_total);\n    APPEND_STAT(\"response_obj_free\", \"%llu\", (unsigned long long)thread_stats.response_obj_free);\n    APPEND_STAT(\"response_obj_oom\", \"%llu\", (unsigned long long)thread_stats.response_obj_oom);\n    APPEND_STAT(\"read_buf_bytes\", \"%llu\", (unsigned long long)thread_stats.read_buf_bytes);\n    APPEND_STAT(\"read_buf_bytes_free\", \"%llu\", (unsigned long long)thread_stats.read_buf_bytes_free);\n    APPEND_STAT(\"read_buf_oom\", \"%llu\", (unsigned long long)thread_stats.read_buf_oom);\n    APPEND_STAT(\"reserved_fds\", \"%u\", stats_state.reserved_fds);\n    APPEND_STAT(\"cmd_get\", \"%llu\", (unsigned long long)thread_stats.get_cmds);\n    APPEND_STAT(\"cmd_set\", \"%llu\", (unsigned long long)slab_stats.set_cmds);\n    APPEND_STAT(\"cmd_flush\", \"%llu\", (unsigned long long)thread_stats.flush_cmds);\n    APPEND_STAT(\"cmd_touch\", \"%llu\", (unsigned long long)thread_stats.touch_cmds);\n    APPEND_STAT(\"cmd_meta\", \"%llu\", (unsigned long long)thread_stats.meta_cmds);\n    APPEND_STAT(\"get_hits\", \"%llu\", (unsigned long long)slab_stats.get_hits);\n    APPEND_STAT(\"get_misses\", \"%llu\", (unsigned long long)thread_stats.get_misses);\n    APPEND_STAT(\"get_expired\", \"%llu\", (unsigned long long)thread_stats.get_expired);\n    APPEND_STAT(\"get_flushed\", \"%llu\", (unsigned long long)thread_stats.get_flushed);\n#ifdef EXTSTORE\n    if (c->thread->storage) {\n        APPEND_STAT(\"get_extstore\", \"%llu\", (unsigned long long)thread_stats.get_extstore);\n        APPEND_STAT(\"get_aborted_extstore\", \"%llu\", (unsigned long long)thread_stats.get_aborted_extstore);\n        APPEND_STAT(\"get_oom_extstore\", \"%llu\", (unsigned long long)thread_stats.get_oom_extstore);\n        APPEND_STAT(\"recache_from_extstore\", \"%llu\", (unsigned long long)thread_stats.recache_from_extstore);\n        APPEND_STAT(\"miss_from_extstore\", \"%llu\", (unsigned long long)thread_stats.miss_from_extstore);\n        APPEND_STAT(\"badcrc_from_extstore\", \"%llu\", (unsigned long long)thread_stats.badcrc_from_extstore);\n    }\n#endif\n    APPEND_STAT(\"delete_misses\", \"%llu\", (unsigned long long)thread_stats.delete_misses);\n    APPEND_STAT(\"delete_hits\", \"%llu\", (unsigned long long)slab_stats.delete_hits);\n    APPEND_STAT(\"incr_misses\", \"%llu\", (unsigned long long)thread_stats.incr_misses);\n    APPEND_STAT(\"incr_hits\", \"%llu\", (unsigned long long)slab_stats.incr_hits);\n    APPEND_STAT(\"decr_misses\", \"%llu\", (unsigned long long)thread_stats.decr_misses);\n    APPEND_STAT(\"decr_hits\", \"%llu\", (unsigned long long)slab_stats.decr_hits);\n    APPEND_STAT(\"cas_misses\", \"%llu\", (unsigned long long)thread_stats.cas_misses);\n    APPEND_STAT(\"cas_hits\", \"%llu\", (unsigned long long)slab_stats.cas_hits);\n    APPEND_STAT(\"cas_badval\", \"%llu\", (unsigned long long)slab_stats.cas_badval);\n    APPEND_STAT(\"touch_hits\", \"%llu\", (unsigned long long)slab_stats.touch_hits);\n    APPEND_STAT(\"touch_misses\", \"%llu\", (unsigned long long)thread_stats.touch_misses);\n    APPEND_STAT(\"auth_cmds\", \"%llu\", (unsigned long long)thread_stats.auth_cmds);\n    APPEND_STAT(\"auth_errors\", \"%llu\", (unsigned long long)thread_stats.auth_errors);\n    if (settings.idle_timeout) {\n        APPEND_STAT(\"idle_kicks\", \"%llu\", (unsigned long long)thread_stats.idle_kicks);\n    }\n    APPEND_STAT(\"bytes_read\", \"%llu\", (unsigned long long)thread_stats.bytes_read);\n    APPEND_STAT(\"bytes_written\", \"%llu\", (unsigned long long)thread_stats.bytes_written);\n    APPEND_STAT(\"limit_maxbytes\", \"%llu\", (unsigned long long)settings.maxbytes);\n    APPEND_STAT(\"accepting_conns\", \"%u\", stats_state.accepting_conns);\n    APPEND_STAT(\"listen_disabled_num\", \"%llu\", (unsigned long long)stats.listen_disabled_num);\n    APPEND_STAT(\"time_in_listen_disabled_us\", \"%llu\", stats.time_in_listen_disabled_us);\n    APPEND_STAT(\"threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"conn_yields\", \"%llu\", (unsigned long long)thread_stats.conn_yields);\n    APPEND_STAT(\"hash_power_level\", \"%u\", stats_state.hash_power_level);\n    APPEND_STAT(\"hash_bytes\", \"%llu\", (unsigned long long)stats_state.hash_bytes);\n    APPEND_STAT(\"hash_is_expanding\", \"%u\", stats_state.hash_is_expanding);\n    if (settings.slab_reassign) {\n        APPEND_STAT(\"slab_reassign_rescues\", \"%llu\", stats.slab_reassign_rescues);\n        APPEND_STAT(\"slab_reassign_chunk_rescues\", \"%llu\", stats.slab_reassign_chunk_rescues);\n        APPEND_STAT(\"slab_reassign_evictions_nomem\", \"%llu\", stats.slab_reassign_evictions_nomem);\n        APPEND_STAT(\"slab_reassign_inline_reclaim\", \"%llu\", stats.slab_reassign_inline_reclaim);\n        APPEND_STAT(\"slab_reassign_busy_items\", \"%llu\", stats.slab_reassign_busy_items);\n        APPEND_STAT(\"slab_reassign_busy_deletes\", \"%llu\", stats.slab_reassign_busy_deletes);\n        APPEND_STAT(\"slab_reassign_running\", \"%u\", stats_state.slab_reassign_running);\n        APPEND_STAT(\"slabs_moved\", \"%llu\", stats.slabs_moved);\n    }\n    if (settings.lru_crawler) {\n        APPEND_STAT(\"lru_crawler_running\", \"%u\", stats_state.lru_crawler_running);\n        APPEND_STAT(\"lru_crawler_starts\", \"%u\", stats.lru_crawler_starts);\n    }\n    if (settings.lru_maintainer_thread) {\n        APPEND_STAT(\"lru_maintainer_juggles\", \"%llu\", (unsigned long long)stats.lru_maintainer_juggles);\n    }\n    APPEND_STAT(\"malloc_fails\", \"%llu\",\n                (unsigned long long)stats.malloc_fails);\n    APPEND_STAT(\"log_worker_dropped\", \"%llu\", (unsigned long long)stats.log_worker_dropped);\n    APPEND_STAT(\"log_worker_written\", \"%llu\", (unsigned long long)stats.log_worker_written);\n    APPEND_STAT(\"log_watcher_skipped\", \"%llu\", (unsigned long long)stats.log_watcher_skipped);\n    APPEND_STAT(\"log_watcher_sent\", \"%llu\", (unsigned long long)stats.log_watcher_sent);\n    STATS_UNLOCK();\n#ifdef EXTSTORE\n    if (c->thread->storage) {\n        STATS_LOCK();\n        APPEND_STAT(\"extstore_compact_lost\", \"%llu\", (unsigned long long)stats.extstore_compact_lost);\n        APPEND_STAT(\"extstore_compact_rescues\", \"%llu\", (unsigned long long)stats.extstore_compact_rescues);\n        APPEND_STAT(\"extstore_compact_skipped\", \"%llu\", (unsigned long long)stats.extstore_compact_skipped);\n        STATS_UNLOCK();\n        extstore_get_stats(c->thread->storage, &st);\n        APPEND_STAT(\"extstore_page_allocs\", \"%llu\", (unsigned long long)st.page_allocs);\n        APPEND_STAT(\"extstore_page_evictions\", \"%llu\", (unsigned long long)st.page_evictions);\n        APPEND_STAT(\"extstore_page_reclaims\", \"%llu\", (unsigned long long)st.page_reclaims);\n        APPEND_STAT(\"extstore_pages_free\", \"%llu\", (unsigned long long)st.pages_free);\n        APPEND_STAT(\"extstore_pages_used\", \"%llu\", (unsigned long long)st.pages_used);\n        APPEND_STAT(\"extstore_objects_evicted\", \"%llu\", (unsigned long long)st.objects_evicted);\n        APPEND_STAT(\"extstore_objects_read\", \"%llu\", (unsigned long long)st.objects_read);\n        APPEND_STAT(\"extstore_objects_written\", \"%llu\", (unsigned long long)st.objects_written);\n        APPEND_STAT(\"extstore_objects_used\", \"%llu\", (unsigned long long)st.objects_used);\n        APPEND_STAT(\"extstore_bytes_evicted\", \"%llu\", (unsigned long long)st.bytes_evicted);\n        APPEND_STAT(\"extstore_bytes_written\", \"%llu\", (unsigned long long)st.bytes_written);\n        APPEND_STAT(\"extstore_bytes_read\", \"%llu\", (unsigned long long)st.bytes_read);\n        APPEND_STAT(\"extstore_bytes_used\", \"%llu\", (unsigned long long)st.bytes_used);\n        APPEND_STAT(\"extstore_bytes_fragmented\", \"%llu\", (unsigned long long)st.bytes_fragmented);\n        APPEND_STAT(\"extstore_limit_maxbytes\", \"%llu\", (unsigned long long)(st.page_count * st.page_size));\n        APPEND_STAT(\"extstore_io_queue\", \"%llu\", (unsigned long long)(st.io_queue));\n    }\n#endif\n#ifdef TLS\n    if (settings.ssl_enabled) {\n        APPEND_STAT(\"ssl_handshake_errors\", \"%llu\", (unsigned long long)stats.ssl_handshake_errors);\n        APPEND_STAT(\"time_since_server_cert_refresh\", \"%u\", now - settings.ssl_last_cert_refresh_time);\n    }\n#endif\n}\n\nstatic void process_stat_settings(ADD_STAT add_stats, void *c) {\n    assert(add_stats);\n    APPEND_STAT(\"maxbytes\", \"%llu\", (unsigned long long)settings.maxbytes);\n    APPEND_STAT(\"maxconns\", \"%d\", settings.maxconns);\n    APPEND_STAT(\"tcpport\", \"%d\", settings.port);\n    APPEND_STAT(\"udpport\", \"%d\", settings.udpport);\n    APPEND_STAT(\"inter\", \"%s\", settings.inter ? settings.inter : \"NULL\");\n    APPEND_STAT(\"verbosity\", \"%d\", settings.verbose);\n    APPEND_STAT(\"oldest\", \"%lu\", (unsigned long)settings.oldest_live);\n    APPEND_STAT(\"evictions\", \"%s\", settings.evict_to_free ? \"on\" : \"off\");\n    APPEND_STAT(\"domain_socket\", \"%s\",\n                settings.socketpath ? settings.socketpath : \"NULL\");\n    APPEND_STAT(\"umask\", \"%o\", settings.access);\n    APPEND_STAT(\"growth_factor\", \"%.2f\", settings.factor);\n    APPEND_STAT(\"chunk_size\", \"%d\", settings.chunk_size);\n    APPEND_STAT(\"num_threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"num_threads_per_udp\", \"%d\", settings.num_threads_per_udp);\n    APPEND_STAT(\"stat_key_prefix\", \"%c\", settings.prefix_delimiter);\n    APPEND_STAT(\"detail_enabled\", \"%s\",\n                settings.detail_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"reqs_per_event\", \"%d\", settings.reqs_per_event);\n    APPEND_STAT(\"cas_enabled\", \"%s\", settings.use_cas ? \"yes\" : \"no\");\n    APPEND_STAT(\"tcp_backlog\", \"%d\", settings.backlog);\n    APPEND_STAT(\"binding_protocol\", \"%s\",\n                prot_text(settings.binding_protocol));\n    APPEND_STAT(\"auth_enabled_sasl\", \"%s\", settings.sasl ? \"yes\" : \"no\");\n    APPEND_STAT(\"auth_enabled_ascii\", \"%s\", settings.auth_file ? settings.auth_file : \"no\");\n    APPEND_STAT(\"item_size_max\", \"%d\", settings.item_size_max);\n    APPEND_STAT(\"maxconns_fast\", \"%s\", settings.maxconns_fast ? \"yes\" : \"no\");\n    APPEND_STAT(\"hashpower_init\", \"%d\", settings.hashpower_init);\n    APPEND_STAT(\"slab_reassign\", \"%s\", settings.slab_reassign ? \"yes\" : \"no\");\n    APPEND_STAT(\"slab_automove\", \"%d\", settings.slab_automove);\n    APPEND_STAT(\"slab_automove_ratio\", \"%.2f\", settings.slab_automove_ratio);\n    APPEND_STAT(\"slab_automove_window\", \"%u\", settings.slab_automove_window);\n    APPEND_STAT(\"slab_chunk_max\", \"%d\", settings.slab_chunk_size_max);\n    APPEND_STAT(\"lru_crawler\", \"%s\", settings.lru_crawler ? \"yes\" : \"no\");\n    APPEND_STAT(\"lru_crawler_sleep\", \"%d\", settings.lru_crawler_sleep);\n    APPEND_STAT(\"lru_crawler_tocrawl\", \"%lu\", (unsigned long)settings.lru_crawler_tocrawl);\n    APPEND_STAT(\"tail_repair_time\", \"%d\", settings.tail_repair_time);\n    APPEND_STAT(\"flush_enabled\", \"%s\", settings.flush_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"dump_enabled\", \"%s\", settings.dump_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"hash_algorithm\", \"%s\", settings.hash_algorithm);\n    APPEND_STAT(\"lru_maintainer_thread\", \"%s\", settings.lru_maintainer_thread ? \"yes\" : \"no\");\n    APPEND_STAT(\"lru_segmented\", \"%s\", settings.lru_segmented ? \"yes\" : \"no\");\n    APPEND_STAT(\"hot_lru_pct\", \"%d\", settings.hot_lru_pct);\n    APPEND_STAT(\"warm_lru_pct\", \"%d\", settings.warm_lru_pct);\n    APPEND_STAT(\"hot_max_factor\", \"%.2f\", settings.hot_max_factor);\n    APPEND_STAT(\"warm_max_factor\", \"%.2f\", settings.warm_max_factor);\n    APPEND_STAT(\"temp_lru\", \"%s\", settings.temp_lru ? \"yes\" : \"no\");\n    APPEND_STAT(\"temporary_ttl\", \"%u\", settings.temporary_ttl);\n    APPEND_STAT(\"idle_timeout\", \"%d\", settings.idle_timeout);\n    APPEND_STAT(\"watcher_logbuf_size\", \"%u\", settings.logger_watcher_buf_size);\n    APPEND_STAT(\"worker_logbuf_size\", \"%u\", settings.logger_buf_size);\n    APPEND_STAT(\"resp_obj_mem_limit\", \"%u\", settings.resp_obj_mem_limit);\n    APPEND_STAT(\"read_buf_mem_limit\", \"%u\", settings.read_buf_mem_limit);\n    APPEND_STAT(\"track_sizes\", \"%s\", item_stats_sizes_status() ? \"yes\" : \"no\");\n    APPEND_STAT(\"inline_ascii_response\", \"%s\", \"no\"); // setting is dead, cannot be yes.\n#ifdef HAVE_DROP_PRIVILEGES\n    APPEND_STAT(\"drop_privileges\", \"%s\", settings.drop_privileges ? \"yes\" : \"no\");\n#endif\n#ifdef EXTSTORE\n    APPEND_STAT(\"ext_item_size\", \"%u\", settings.ext_item_size);\n    APPEND_STAT(\"ext_item_age\", \"%u\", settings.ext_item_age);\n    APPEND_STAT(\"ext_low_ttl\", \"%u\", settings.ext_low_ttl);\n    APPEND_STAT(\"ext_recache_rate\", \"%u\", settings.ext_recache_rate);\n    APPEND_STAT(\"ext_wbuf_size\", \"%u\", settings.ext_wbuf_size);\n    APPEND_STAT(\"ext_compact_under\", \"%u\", settings.ext_compact_under);\n    APPEND_STAT(\"ext_drop_under\", \"%u\", settings.ext_drop_under);\n    APPEND_STAT(\"ext_max_frag\", \"%.2f\", settings.ext_max_frag);\n    APPEND_STAT(\"slab_automove_freeratio\", \"%.3f\", settings.slab_automove_freeratio);\n    APPEND_STAT(\"ext_drop_unread\", \"%s\", settings.ext_drop_unread ? \"yes\" : \"no\");\n#endif\n#ifdef TLS\n    APPEND_STAT(\"ssl_enabled\", \"%s\", settings.ssl_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"ssl_chain_cert\", \"%s\", settings.ssl_chain_cert);\n    APPEND_STAT(\"ssl_key\", \"%s\", settings.ssl_key);\n    APPEND_STAT(\"ssl_verify_mode\", \"%d\", settings.ssl_verify_mode);\n    APPEND_STAT(\"ssl_keyformat\", \"%d\", settings.ssl_keyformat);\n    APPEND_STAT(\"ssl_ciphers\", \"%s\", settings.ssl_ciphers ? settings.ssl_ciphers : \"NULL\");\n    APPEND_STAT(\"ssl_ca_cert\", \"%s\", settings.ssl_ca_cert ? settings.ssl_ca_cert : \"NULL\");\n    APPEND_STAT(\"ssl_wbuf_size\", \"%u\", settings.ssl_wbuf_size);\n#endif\n}\n\nstatic int nz_strcmp(int nzlength, const char *nz, const char *z) {\n    int zlength=strlen(z);\n    return (zlength == nzlength) && (strncmp(nz, z, zlength) == 0) ? 0 : -1;\n}\n\nstatic bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c) {\n    bool ret = true;\n\n    if (add_stats != NULL) {\n        if (!stat_type) {\n            /* prepare general statistics for the engine */\n            STATS_LOCK();\n            APPEND_STAT(\"bytes\", \"%llu\", (unsigned long long)stats_state.curr_bytes);\n            APPEND_STAT(\"curr_items\", \"%llu\", (unsigned long long)stats_state.curr_items);\n            APPEND_STAT(\"total_items\", \"%llu\", (unsigned long long)stats.total_items);\n            STATS_UNLOCK();\n            APPEND_STAT(\"slab_global_page_pool\", \"%u\", global_page_pool_size(NULL));\n            item_stats_totals(add_stats, c);\n        } else if (nz_strcmp(nkey, stat_type, \"items\") == 0) {\n            item_stats(add_stats, c);\n        } else if (nz_strcmp(nkey, stat_type, \"slabs\") == 0) {\n            slabs_stats(add_stats, c);\n        } else if (nz_strcmp(nkey, stat_type, \"sizes\") == 0) {\n            item_stats_sizes(add_stats, c);\n        } else if (nz_strcmp(nkey, stat_type, \"sizes_enable\") == 0) {\n            item_stats_sizes_enable(add_stats, c);\n        } else if (nz_strcmp(nkey, stat_type, \"sizes_disable\") == 0) {\n            item_stats_sizes_disable(add_stats, c);\n        } else {\n            ret = false;\n        }\n    } else {\n        ret = false;\n    }\n\n    return ret;\n}\n\nstatic inline void get_conn_text(const conn *c, const int af,\n                char* addr, struct sockaddr *sock_addr) {\n    char addr_text[MAXPATHLEN];\n    addr_text[0] = '\\0';\n    const char *protoname = \"?\";\n    unsigned short port = 0;\n    size_t pathlen = 0;\n\n    switch (af) {\n        case AF_INET:\n            (void) inet_ntop(af,\n                    &((struct sockaddr_in *)sock_addr)->sin_addr,\n                    addr_text,\n                    sizeof(addr_text) - 1);\n            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);\n            protoname = IS_UDP(c->transport) ? \"udp\" : \"tcp\";\n            break;\n\n        case AF_INET6:\n            addr_text[0] = '[';\n            addr_text[1] = '\\0';\n            if (inet_ntop(af,\n                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,\n                    addr_text + 1,\n                    sizeof(addr_text) - 2)) {\n                strcat(addr_text, \"]\");\n            }\n            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);\n            protoname = IS_UDP(c->transport) ? \"udp6\" : \"tcp6\";\n            break;\n\n        case AF_UNIX:\n            // this strncpy call originally could piss off an address\n            // sanitizer; we supplied the size of the dest buf as a limiter,\n            // but optimized versions of strncpy could read past the end of\n            // *src while looking for a null terminator. Since buf and\n            // sun_path here are both on the stack they could even overlap,\n            // which is \"undefined\". In all OSS versions of strncpy I could\n            // find this has no effect; it'll still only copy until the first null\n            // terminator is found. Thus it's possible to get the OS to\n            // examine past the end of sun_path but it's unclear to me if this\n            // can cause any actual problem.\n            //\n            // We need a safe_strncpy util function but I'll punt on figuring\n            // that out for now.\n            pathlen = sizeof(((struct sockaddr_un *)sock_addr)->sun_path);\n            if (MAXPATHLEN <= pathlen) {\n                pathlen = MAXPATHLEN - 1;\n            }\n            strncpy(addr_text,\n                    ((struct sockaddr_un *)sock_addr)->sun_path,\n                    pathlen);\n            addr_text[pathlen] = '\\0';\n            protoname = \"unix\";\n            break;\n    }\n\n    if (strlen(addr_text) < 2) {\n        /* Most likely this is a connected UNIX-domain client which\n         * has no peer socket address, but there's no portable way\n         * to tell for sure.\n         */\n        sprintf(addr_text, \"<AF %d>\", af);\n    }\n\n    if (port) {\n        sprintf(addr, \"%s:%s:%u\", protoname, addr_text, port);\n    } else {\n        sprintf(addr, \"%s:%s\", protoname, addr_text);\n    }\n}\n\nstatic void conn_to_str(const conn *c, char *addr, char *svr_addr) {\n    if (!c) {\n        strcpy(addr, \"<null>\");\n    } else if (c->state == conn_closed) {\n        strcpy(addr, \"<closed>\");\n    } else {\n        struct sockaddr_in6 local_addr;\n        struct sockaddr *sock_addr = (void *)&c->request_addr;\n\n        /* For listen ports and idle UDP ports, show listen address */\n        if (c->state == conn_listening ||\n                (IS_UDP(c->transport) &&\n                 c->state == conn_read)) {\n            socklen_t local_addr_len = sizeof(local_addr);\n\n            if (getsockname(c->sfd,\n                        (struct sockaddr *)&local_addr,\n                        &local_addr_len) == 0) {\n                sock_addr = (struct sockaddr *)&local_addr;\n            }\n        }\n        get_conn_text(c, sock_addr->sa_family, addr, sock_addr);\n\n        if (c->state != conn_listening && !(IS_UDP(c->transport) &&\n                 c->state == conn_read)) {\n            struct sockaddr_storage svr_sock_addr;\n            socklen_t svr_addr_len = sizeof(svr_sock_addr);\n            getsockname(c->sfd, (struct sockaddr *)&svr_sock_addr, &svr_addr_len);\n            get_conn_text(c, svr_sock_addr.ss_family, svr_addr, (struct sockaddr *)&svr_sock_addr);\n        }\n    }\n}\n\nstatic void process_stats_conns(ADD_STAT add_stats, void *c) {\n    int i;\n    char key_str[STAT_KEY_LEN];\n    char val_str[STAT_VAL_LEN];\n    size_t extras_len = sizeof(\"unix:\") + sizeof(\"65535\");\n    char addr[MAXPATHLEN + extras_len];\n    char svr_addr[MAXPATHLEN + extras_len];\n    int klen = 0, vlen = 0;\n\n    assert(add_stats);\n\n    for (i = 0; i < max_fds; i++) {\n        if (conns[i]) {\n            /* This is safe to do unlocked because conns are never freed; the\n             * worst that'll happen will be a minor inconsistency in the\n             * output -- not worth the complexity of the locking that'd be\n             * required to prevent it.\n             */\n            if (IS_UDP(conns[i]->transport)) {\n                APPEND_NUM_STAT(i, \"UDP\", \"%s\", \"UDP\");\n            }\n            if (conns[i]->state != conn_closed) {\n                conn_to_str(conns[i], addr, svr_addr);\n\n                APPEND_NUM_STAT(i, \"addr\", \"%s\", addr);\n                if (conns[i]->state != conn_listening &&\n                    !(IS_UDP(conns[i]->transport) && conns[i]->state == conn_read)) {\n                    APPEND_NUM_STAT(i, \"listen_addr\", \"%s\", svr_addr);\n                }\n                APPEND_NUM_STAT(i, \"state\", \"%s\",\n                        state_text(conns[i]->state));\n                APPEND_NUM_STAT(i, \"secs_since_last_cmd\", \"%d\",\n                        current_time - conns[i]->last_cmd_time);\n            }\n        }\n    }\n}\n#ifdef EXTSTORE\nstatic void process_extstore_stats(ADD_STAT add_stats, conn *c) {\n    int i;\n    char key_str[STAT_KEY_LEN];\n    char val_str[STAT_VAL_LEN];\n    int klen = 0, vlen = 0;\n    struct extstore_stats st;\n\n    assert(add_stats);\n\n    void *storage = c->thread->storage;\n    extstore_get_stats(storage, &st);\n    st.page_data = calloc(st.page_count, sizeof(struct extstore_page_data));\n    extstore_get_page_data(storage, &st);\n\n    for (i = 0; i < st.page_count; i++) {\n        APPEND_NUM_STAT(i, \"version\", \"%llu\",\n                (unsigned long long) st.page_data[i].version);\n        APPEND_NUM_STAT(i, \"bytes\", \"%llu\",\n                (unsigned long long) st.page_data[i].bytes_used);\n        APPEND_NUM_STAT(i, \"bucket\", \"%u\",\n                st.page_data[i].bucket);\n        APPEND_NUM_STAT(i, \"free_bucket\", \"%u\",\n                st.page_data[i].free_bucket);\n    }\n}\n#endif\nstatic void process_stat(conn *c, token_t *tokens, const size_t ntokens) {\n    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;\n    assert(c != NULL);\n\n    if (ntokens < 2) {\n        out_string(c, \"CLIENT_ERROR bad command line\");\n        return;\n    }\n\n    if (ntokens == 2) {\n        server_stats(&append_stats, c);\n        (void)get_stats(NULL, 0, &append_stats, c);\n    } else if (strcmp(subcommand, \"reset\") == 0) {\n        stats_reset();\n        out_string(c, \"RESET\");\n        return;\n    } else if (strcmp(subcommand, \"detail\") == 0) {\n        /* NOTE: how to tackle detail with binary? */\n        if (ntokens < 4)\n            process_stats_detail(c, \"\");  /* outputs the error message */\n        else\n            process_stats_detail(c, tokens[2].value);\n        /* Output already generated */\n        return;\n    } else if (strcmp(subcommand, \"settings\") == 0) {\n        process_stat_settings(&append_stats, c);\n    } else if (strcmp(subcommand, \"cachedump\") == 0) {\n        char *buf;\n        unsigned int bytes, id, limit = 0;\n\n        if (!settings.dump_enabled) {\n            out_string(c, \"CLIENT_ERROR stats cachedump not allowed\");\n            return;\n        }\n\n        if (ntokens < 5) {\n            out_string(c, \"CLIENT_ERROR bad command line\");\n            return;\n        }\n\n        if (!safe_strtoul(tokens[2].value, &id) ||\n            !safe_strtoul(tokens[3].value, &limit)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n\n        if (id >= MAX_NUMBER_OF_SLAB_CLASSES) {\n            out_string(c, \"CLIENT_ERROR Illegal slab id\");\n            return;\n        }\n\n        buf = item_cachedump(id, limit, &bytes);\n        write_and_free(c, buf, bytes);\n        return;\n    } else if (strcmp(subcommand, \"conns\") == 0) {\n        process_stats_conns(&append_stats, c);\n#ifdef EXTSTORE\n    } else if (strcmp(subcommand, \"extstore\") == 0) {\n        process_extstore_stats(&append_stats, c);\n#endif\n    } else {\n        /* getting here means that the subcommand is either engine specific or\n           is invalid. query the engine and see. */\n        if (get_stats(subcommand, strlen(subcommand), &append_stats, c)) {\n            if (c->stats.buffer == NULL) {\n                out_of_memory(c, \"SERVER_ERROR out of memory writing stats\");\n            } else {\n                write_and_free(c, c->stats.buffer, c->stats.offset);\n                c->stats.buffer = NULL;\n            }\n        } else {\n            out_string(c, \"ERROR\");\n        }\n        return;\n    }\n\n    /* append terminator and start the transfer */\n    append_stats(NULL, 0, NULL, 0, c);\n\n    if (c->stats.buffer == NULL) {\n        out_of_memory(c, \"SERVER_ERROR out of memory writing stats\");\n    } else {\n        write_and_free(c, c->stats.buffer, c->stats.offset);\n        c->stats.buffer = NULL;\n    }\n}\n\n/* client flags == 0 means use no storage for client flags */\nstatic inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas, int nbytes) {\n    char *p = suffix;\n    *p = ' ';\n    p++;\n    if (FLAGS_SIZE(it) == 0) {\n        *p = '0';\n        p++;\n    } else {\n        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);\n    }\n    *p = ' ';\n    p = itoa_u32(nbytes-2, p+1);\n\n    if (return_cas) {\n        *p = ' ';\n        p = itoa_u64(ITEM_get_cas(it), p+1);\n    }\n\n    *p = '\\r';\n    *(p+1) = '\\n';\n    *(p+2) = '\\0';\n    return (p - suffix) + 2;\n}\n\n#define IT_REFCOUNT_LIMIT 60000\nstatic inline item* limited_get(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch, bool do_update, bool *overflow) {\n    item *it;\n    if (should_touch) {\n        it = item_touch(key, nkey, exptime, c);\n    } else {\n        it = item_get(key, nkey, c, do_update);\n    }\n    if (it && it->refcount > IT_REFCOUNT_LIMIT) {\n        item_remove(it);\n        it = NULL;\n        *overflow = true;\n    } else {\n        *overflow = false;\n    }\n    return it;\n}\n\n// Semantics are different than limited_get; since the item is returned\n// locked, caller can directly change what it needs.\n// though it might eventually be a better interface to sink it all into\n// items.c.\nstatic inline item* limited_get_locked(char *key, size_t nkey, conn *c, bool do_update, uint32_t *hv, bool *overflow) {\n    item *it;\n    it = item_get_locked(key, nkey, c, do_update, hv);\n    if (it && it->refcount > IT_REFCOUNT_LIMIT) {\n        do_item_remove(it);\n        it = NULL;\n        item_unlock(*hv);\n        *overflow = true;\n    } else {\n        *overflow = false;\n    }\n    return it;\n}\n\n#ifdef EXTSTORE\n// FIXME: This runs in the IO thread. to get better IO performance this should\n// simply mark the io wrapper with the return value and decrement wrapleft, if\n// zero redispatching. Still a bit of work being done in the side thread but\n// minimized at least.\nstatic void _get_extstore_cb(void *e, obj_io *io, int ret) {\n    // FIXME: assumes success\n    io_wrap *wrap = (io_wrap *)io->data;\n    mc_resp *resp = wrap->resp;\n    conn *c = wrap->c;\n    assert(wrap->active == true);\n    item *read_it = (item *)io->buf;\n    bool miss = false;\n\n    // TODO: How to do counters for hit/misses?\n    if (ret < 1) {\n        miss = true;\n    } else {\n        uint32_t crc2;\n        uint32_t crc = (uint32_t) read_it->exptime;\n        int x;\n        // item is chunked, crc the iov's\n        if (io->iov != NULL) {\n            // first iov is the header, which we don't use beyond crc\n            crc2 = crc32c(0, (char *)io->iov[0].iov_base+STORE_OFFSET, io->iov[0].iov_len-STORE_OFFSET);\n            // make sure it's not sent. hack :(\n            io->iov[0].iov_len = 0;\n            for (x = 1; x < io->iovcnt; x++) {\n                crc2 = crc32c(crc2, (char *)io->iov[x].iov_base, io->iov[x].iov_len);\n            }\n        } else {\n            crc2 = crc32c(0, (char *)read_it+STORE_OFFSET, io->len-STORE_OFFSET);\n        }\n\n        if (crc != crc2) {\n            miss = true;\n            wrap->badcrc = true;\n        }\n    }\n\n    if (miss) {\n        if (wrap->noreply) {\n            // In all GET cases, noreply means we send nothing back.\n            resp->skip = true;\n        } else {\n            // TODO: This should be movable to the worker thread.\n            // Convert the binprot response into a miss response.\n            // The header requires knowing a bunch of stateful crap, so rather\n            // than simply writing out a \"new\" miss response we mangle what's\n            // already there.\n            if (c->protocol == binary_prot) {\n                protocol_binary_response_header *header =\n                    (protocol_binary_response_header *)resp->wbuf;\n\n                // cut the extra nbytes off of the body_len\n                uint32_t body_len = ntohl(header->response.bodylen);\n                uint8_t hdr_len = header->response.extlen;\n                body_len -= resp->iov[wrap->iovec_data].iov_len + hdr_len;\n                resp->tosend -= resp->iov[wrap->iovec_data].iov_len + hdr_len;\n                header->response.extlen = 0;\n                header->response.status = (uint16_t)htons(PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n                header->response.bodylen = htonl(body_len);\n\n                // truncate the data response.\n                resp->iov[wrap->iovec_data].iov_len = 0;\n                // wipe the extlen iov... wish it was just a flat buffer.\n                resp->iov[wrap->iovec_data-1].iov_len = 0;\n                resp->chunked_data_iov = 0;\n            } else {\n                int i;\n                // Meta commands have EN status lines for miss, rather than\n                // END as a trailer as per normal ascii.\n                if (resp->iov[0].iov_len >= 3\n                        && memcmp(resp->iov[0].iov_base, \"VA \", 3) == 0) {\n                    // TODO: These miss translators should use specific callback\n                    // functions attached to the io wrap. This is weird :(\n                    resp->iovcnt = 1;\n                    resp->iov[0].iov_len = 4;\n                    resp->iov[0].iov_base = \"EN\\r\\n\";\n                    resp->tosend = 4;\n                } else {\n                    // Wipe the iovecs up through our data injection.\n                    // Allows trailers to be returned (END)\n                    for (i = 0; i <= wrap->iovec_data; i++) {\n                        resp->tosend -= resp->iov[i].iov_len;\n                        resp->iov[i].iov_len = 0;\n                        resp->iov[i].iov_base = NULL;\n                    }\n                }\n                resp->chunked_total = 0;\n                resp->chunked_data_iov = 0;\n            }\n        }\n        wrap->miss = true;\n    } else {\n        assert(read_it->slabs_clsid != 0);\n        // TODO: should always use it instead of ITEM_data to kill more\n        // chunked special casing.\n        if ((read_it->it_flags & ITEM_CHUNKED) == 0) {\n            resp->iov[wrap->iovec_data].iov_base = ITEM_data(read_it);\n        }\n        wrap->miss = false;\n    }\n\n    c->io_wrapleft--;\n    wrap->active = false;\n    //assert(c->io_wrapleft >= 0);\n\n    // All IO's have returned, lets re-attach this connection to our original\n    // thread.\n    if (c->io_wrapleft == 0) {\n        assert(c->io_queued == true);\n        c->io_queued = false;\n        redispatch_conn(c);\n    }\n}\n\nstatic inline int _get_extstore(conn *c, item *it, mc_resp *resp) {\n#ifdef NEED_ALIGN\n    item_hdr hdr;\n    memcpy(&hdr, ITEM_data(it), sizeof(hdr));\n#else\n    item_hdr *hdr = (item_hdr *)ITEM_data(it);\n#endif\n    size_t ntotal = ITEM_ntotal(it);\n    unsigned int clsid = slabs_clsid(ntotal);\n    item *new_it;\n    bool chunked = false;\n    if (ntotal > settings.slab_chunk_size_max) {\n        // Pull a chunked item header.\n        uint32_t flags;\n        FLAGS_CONV(it, flags);\n        new_it = item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, it->nbytes);\n        assert(new_it == NULL || (new_it->it_flags & ITEM_CHUNKED));\n        chunked = true;\n    } else {\n        new_it = do_item_alloc_pull(ntotal, clsid);\n    }\n    if (new_it == NULL)\n        return -1;\n    assert(!c->io_queued); // FIXME: debugging.\n    // so we can free the chunk on a miss\n    new_it->slabs_clsid = clsid;\n\n    io_wrap *io = do_cache_alloc(c->thread->io_cache);\n    io->active = true;\n    io->miss = false;\n    io->badcrc = false;\n    io->noreply = c->noreply;\n    // io_wrap owns the reference for this object now.\n    io->hdr_it = it;\n    io->resp = resp;\n    io->io.iov = NULL;\n\n    // FIXME: error handling.\n    if (chunked) {\n        unsigned int ciovcnt = 0;\n        size_t remain = new_it->nbytes;\n        item_chunk *chunk = (item_chunk *) ITEM_schunk(new_it);\n        // TODO: This might make sense as a _global_ cache vs a per-thread.\n        // but we still can't load objects requiring > IOV_MAX iovs.\n        // In the meantime, these objects are rare/slow enough that\n        // malloc/freeing a statically sized object won't cause us much pain.\n        io->io.iov = malloc(sizeof(struct iovec) * IOV_MAX);\n        if (io->io.iov == NULL) {\n            item_remove(new_it);\n            do_cache_free(c->thread->io_cache, io);\n            return -1;\n        }\n\n        // fill the header so we can get the full data + crc back.\n        io->io.iov[0].iov_base = new_it;\n        io->io.iov[0].iov_len = ITEM_ntotal(new_it) - new_it->nbytes;\n        ciovcnt++;\n\n        while (remain > 0) {\n            chunk = do_item_alloc_chunk(chunk, remain);\n            // FIXME: _pure evil_, silently erroring if item is too large.\n            if (chunk == NULL || ciovcnt > IOV_MAX-1) {\n                item_remove(new_it);\n                free(io->io.iov);\n                // TODO: wrapper function for freeing up an io wrap?\n                io->io.iov = NULL;\n                do_cache_free(c->thread->io_cache, io);\n                return -1;\n            }\n            io->io.iov[ciovcnt].iov_base = chunk->data;\n            io->io.iov[ciovcnt].iov_len = (remain < chunk->size) ? remain : chunk->size;\n            chunk->used = (remain < chunk->size) ? remain : chunk->size;\n            remain -= chunk->size;\n            ciovcnt++;\n        }\n\n        io->io.iovcnt = ciovcnt;\n    }\n\n    // Chunked or non chunked we reserve a response iov here.\n    io->iovec_data = resp->iovcnt;\n    int iovtotal = (c->protocol == binary_prot) ? it->nbytes - 2 : it->nbytes;\n    if (chunked) {\n        resp_add_chunked_iov(resp, new_it, iovtotal);\n    } else {\n        resp_add_iov(resp, \"\", iovtotal);\n    }\n\n    io->io.buf = (void *)new_it;\n    io->c = c;\n\n    // We need to stack the sub-struct IO's together as well.\n    if (c->io_wraplist) {\n        io->io.next = &c->io_wraplist->io;\n    } else {\n        io->io.next = NULL;\n    }\n\n    // IO queue for this connection.\n    io->next = c->io_wraplist;\n    c->io_wraplist = io;\n    assert(c->io_wrapleft >= 0);\n    c->io_wrapleft++;\n    // reference ourselves for the callback.\n    io->io.data = (void *)io;\n\n    // Now, fill in io->io based on what was in our header.\n#ifdef NEED_ALIGN\n    io->io.page_version = hdr.page_version;\n    io->io.page_id = hdr.page_id;\n    io->io.offset = hdr.offset;\n#else\n    io->io.page_version = hdr->page_version;\n    io->io.page_id = hdr->page_id;\n    io->io.offset = hdr->offset;\n#endif\n    io->io.len = ntotal;\n    io->io.mode = OBJ_IO_READ;\n    io->io.cb = _get_extstore_cb;\n\n    //fprintf(stderr, \"EXTSTORE: IO stacked %u\\n\", io->iovec_data);\n    // FIXME: This stat needs to move to reflect # of flash hits vs misses\n    // for now it's a good gauge on how often we request out to flash at\n    // least.\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.get_extstore++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    return 0;\n}\n#endif\n\n/* ntokens is overwritten here... shrug.. */\nstatic inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {\n    char *key;\n    size_t nkey;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    int32_t exptime_int = 0;\n    rel_time_t exptime = 0;\n    bool fail_length = false;\n    assert(c != NULL);\n    mc_resp *resp = c->resp;\n\n    if (should_touch) {\n        // For get and touch commands, use first token as exptime\n        if (!safe_strtol(tokens[1].value, &exptime_int)) {\n            out_string(c, \"CLIENT_ERROR invalid exptime argument\");\n            return;\n        }\n        key_token++;\n        exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));\n    }\n\n    do {\n        while(key_token->length != 0) {\n            bool overflow; // not used here.\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if (nkey > KEY_MAX_LENGTH) {\n                fail_length = true;\n                goto stop;\n            }\n\n            it = limited_get(key, nkey, c, exptime, should_touch, DO_UPDATE, &overflow);\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n            if (it) {\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  int nbytes = it->nbytes;;\n                  nbytes = it->nbytes;\n                  char *p = resp->wbuf;\n                  memcpy(p, \"VALUE \", 6);\n                  p += 6;\n                  memcpy(p, ITEM_key(it), it->nkey);\n                  p += it->nkey;\n                  p += make_ascii_get_suffix(p, it, return_cas, nbytes);\n                  resp_add_iov(resp, resp->wbuf, p - resp->wbuf);\n\n#ifdef EXTSTORE\n                  if (it->it_flags & ITEM_HDR) {\n                      if (_get_extstore(c, it, resp) != 0) {\n                          pthread_mutex_lock(&c->thread->stats.mutex);\n                          c->thread->stats.get_oom_extstore++;\n                          pthread_mutex_unlock(&c->thread->stats.mutex);\n\n                          item_remove(it);\n                          goto stop;\n                      }\n                  } else if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                      resp_add_iov(resp, ITEM_data(it), it->nbytes);\n                  } else {\n                      resp_add_chunked_iov(resp, it, it->nbytes);\n                  }\n#else\n                  if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                      resp_add_iov(resp, ITEM_data(it), it->nbytes);\n                  } else {\n                      resp_add_chunked_iov(resp, it, it->nbytes);\n                  }\n#endif\n                }\n\n                if (settings.verbose > 1) {\n                    int ii;\n                    fprintf(stderr, \">%d sending key \", c->sfd);\n                    for (ii = 0; ii < it->nkey; ++ii) {\n                        fprintf(stderr, \"%c\", key[ii]);\n                    }\n                    fprintf(stderr, \"\\n\");\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                if (should_touch) {\n                    c->thread->stats.touch_cmds++;\n                    c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;\n                } else {\n                    c->thread->stats.lru_hits[it->slabs_clsid]++;\n                    c->thread->stats.get_cmds++;\n                }\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n#ifdef EXTSTORE\n                /* If ITEM_HDR, an io_wrap owns the reference. */\n                if ((it->it_flags & ITEM_HDR) == 0) {\n                    resp->item = it;\n                }\n#else\n                resp->item = it;\n#endif\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                if (should_touch) {\n                    c->thread->stats.touch_cmds++;\n                    c->thread->stats.touch_misses++;\n                } else {\n                    c->thread->stats.get_misses++;\n                    c->thread->stats.get_cmds++;\n                }\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n            }\n\n            key_token++;\n            if (key_token->length != 0) {\n                if (!resp_start(c)) {\n                    goto stop;\n                }\n                resp = c->resp;\n            }\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if (key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n            if (!resp_start(c)) {\n                goto stop;\n            }\n            resp = c->resp;\n        }\n    } while(key_token->value != NULL);\nstop:\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d END\\n\", c->sfd);\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL) {\n        // Kill any stacked responses we had.\n        conn_release_items(c);\n        // Start a new response object for the error message.\n        if (!resp_start(c)) {\n            // severe out of memory error.\n            conn_set_state(c, conn_closing);\n            return;\n        }\n        if (fail_length) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n        } else {\n            out_of_memory(c, \"SERVER_ERROR out of memory writing get response\");\n        }\n    } else {\n        // Tag the end token onto the most recent response object.\n        resp_add_iov(resp, \"END\\r\\n\", 5);\n        conn_set_state(c, conn_mwrite);\n    }\n}\n\n// slow snprintf for debugging purposes.\nstatic void process_meta_command(conn *c, token_t *tokens, const size_t ntokens) {\n    assert(c != NULL);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    char *key = tokens[KEY_TOKEN].value;\n    size_t nkey = tokens[KEY_TOKEN].length;\n\n    bool overflow; // not used here.\n    item *it = limited_get(key, nkey, c, 0, false, DONT_UPDATE, &overflow);\n    if (it) {\n        mc_resp *resp = c->resp;\n        size_t total = 0;\n        size_t ret;\n        // similar to out_string().\n        memcpy(resp->wbuf, \"ME \", 3);\n        total += 3;\n        memcpy(resp->wbuf + total, ITEM_key(it), it->nkey);\n        total += it->nkey;\n        resp->wbuf[total] = ' ';\n        total++;\n\n        ret = snprintf(resp->wbuf + total, WRITE_BUFFER_SIZE - (it->nkey + 12),\n                \"exp=%d la=%llu cas=%llu fetch=%s cls=%u size=%lu\\r\\n\",\n                (it->exptime == 0) ? -1 : (current_time - it->exptime),\n                (unsigned long long)(current_time - it->time),\n                (unsigned long long)ITEM_get_cas(it),\n                (it->it_flags & ITEM_FETCHED) ? \"yes\" : \"no\",\n                ITEM_clsid(it),\n                (unsigned long) ITEM_ntotal(it));\n\n        item_remove(it);\n        resp->wbytes = total + ret;\n        resp_add_iov(resp, resp->wbuf, resp->wbytes);\n        conn_set_state(c, conn_new_cmd);\n    } else {\n        out_string(c, \"EN\");\n    }\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.meta_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n}\n\n#define MFLAG_MAX_OPT_LENGTH 20\n#define MFLAG_MAX_OPAQUE_LENGTH 32\n\nstruct _meta_flags {\n    unsigned int has_error :1; // flipped if we found an error during parsing.\n    unsigned int no_update :1;\n    unsigned int locked :1;\n    unsigned int vivify :1;\n    unsigned int la :1;\n    unsigned int hit :1;\n    unsigned int value :1;\n    unsigned int set_stale :1;\n    unsigned int no_reply :1;\n    unsigned int has_cas :1;\n    unsigned int new_ttl :1;\n    char mode; // single character mode switch, common to ms/ma\n    rel_time_t exptime;\n    rel_time_t autoviv_exptime;\n    rel_time_t recache_time;\n    int32_t value_len;\n    uint32_t client_flags;\n    uint64_t req_cas_id;\n    uint64_t delta; // ma\n    uint64_t initial; // ma\n};\n\nstatic int _meta_flag_preparse(token_t *tokens, const size_t ntokens,\n        struct _meta_flags *of, char **errstr) {\n    unsigned int i;\n    int32_t tmp_int;\n    uint8_t seen[127] = {0};\n    // Start just past the key token. Look at first character of each token.\n    for (i = KEY_TOKEN+1; i < ntokens-1; i++) {\n        uint8_t o = (uint8_t)tokens[i].value[0];\n        // zero out repeat flags so we don't over-parse for return data.\n        if (o >= 127 || seen[o] != 0) {\n            *errstr = \"CLIENT_ERROR duplicate flag\";\n            return -1;\n        }\n        seen[o] = 1;\n        switch (o) {\n            /* Negative exptimes can underflow and end up immortal. realtime() will\n               immediately expire values that are greater than REALTIME_MAXDELTA, but less\n               than process_started, so lets aim for that. */\n            case 'N':\n                of->locked = 1;\n                of->vivify = 1;\n                if (!safe_strtol(tokens[i].value+1, &tmp_int)) {\n                    *errstr = \"CLIENT_ERROR bad token in command line format\";\n                    of->has_error = 1;\n                } else {\n                    of->autoviv_exptime = realtime(EXPTIME_TO_POSITIVE_TIME(tmp_int));\n                }\n                break;\n            case 'T':\n                of->locked = 1;\n                if (!safe_strtol(tokens[i].value+1, &tmp_int)) {\n                    *errstr = \"CLIENT_ERROR bad token in command line format\";\n                    of->has_error = 1;\n                } else {\n                    of->exptime = realtime(EXPTIME_TO_POSITIVE_TIME(tmp_int));\n                    of->new_ttl = true;\n                }\n                break;\n            case 'R':\n                of->locked = 1;\n                if (!safe_strtol(tokens[i].value+1, &tmp_int)) {\n                    *errstr = \"CLIENT_ERROR bad token in command line format\";\n                    of->has_error = 1;\n                } else {\n                    of->recache_time = realtime(EXPTIME_TO_POSITIVE_TIME(tmp_int));\n                }\n                break;\n            case 'l':\n                of->la = 1;\n                of->locked = 1; // need locked to delay LRU bump\n                break;\n            case 'O':\n                break;\n            case 'k': // known but no special handling\n            case 's':\n            case 't':\n            case 'c':\n            case 'f':\n                break;\n            case 'v':\n                of->value = 1;\n                break;\n            case 'h':\n                of->locked = 1; // need locked to delay LRU bump\n                break;\n            case 'u':\n                of->no_update = 1;\n                break;\n            case 'q':\n                of->no_reply = 1;\n                break;\n            // mset-related.\n            case 'F':\n                if (!safe_strtoul(tokens[i].value+1, &of->client_flags)) {\n                    of->has_error = true;\n                }\n                break;\n            case 'S':\n                if (!safe_strtol(tokens[i].value+1, &tmp_int)) {\n                    of->has_error = true;\n                } else {\n                    // Size is adjusted for underflow or overflow once the\n                    // \\r\\n terminator is added.\n                    if (tmp_int < 0 || tmp_int > (INT_MAX - 2)) {\n                        *errstr = \"CLIENT_ERROR invalid length\";\n                        of->has_error = true;\n                    } else {\n                        of->value_len = tmp_int + 2; // \\r\\n\n                    }\n                }\n                break;\n            case 'C': // mset, mdelete, marithmetic\n                if (!safe_strtoull(tokens[i].value+1, &of->req_cas_id)) {\n                    *errstr = \"CLIENT_ERROR bad token in command line format\";\n                    of->has_error = true;\n                } else {\n                    of->has_cas = true;\n                }\n                break;\n            case 'M': // mset and marithmetic mode switch\n                if (tokens[i].length != 2) {\n                    *errstr = \"CLIENT_ERROR incorrect length for M token\";\n                    of->has_error = 1;\n                } else {\n                    of->mode = tokens[i].value[1];\n                }\n                break;\n            case 'J': // marithmetic initial value\n                if (!safe_strtoull(tokens[i].value+1, &of->initial)) {\n                    *errstr = \"CLIENT_ERROR invalid numeric initial value\";\n                    of->has_error = 1;\n                }\n                break;\n            case 'D': // marithmetic delta value\n                if (!safe_strtoull(tokens[i].value+1, &of->delta)) {\n                    *errstr = \"CLIENT_ERROR invalid numeric delta value\";\n                    of->has_error = 1;\n                }\n                break;\n            case 'I':\n                of->set_stale = 1;\n                break;\n            default: // unknown flag, bail.\n                *errstr = \"CLIENT_ERROR invalid flag\";\n                return -1;\n        }\n    }\n\n    return of->has_error ? -1 : 0;\n}\n\n#define META_SPACE(p) { \\\n    *p = ' '; \\\n    p++; \\\n}\n\n#define META_CHAR(p, c) { \\\n    *p = ' '; \\\n    *(p+1) = c; \\\n    p += 2; \\\n}\n\nstatic void process_mget_command(conn *c, token_t *tokens, const size_t ntokens) {\n    char *key;\n    size_t nkey;\n    item *it;\n    unsigned int i = 0;\n    struct _meta_flags of = {0}; // option bitflags.\n    uint32_t hv; // cached hash value for unlocking an item.\n    bool failed = false;\n    bool item_created = false;\n    bool won_token = false;\n    bool ttl_set = false;\n    char *errstr;\n    mc_resp *resp = c->resp;\n    char *p = resp->wbuf;\n\n    assert(c != NULL);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_errstring(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    // NOTE: final token has length == 0.\n    // KEY_TOKEN == 1. 0 is command.\n\n    if (ntokens == 3) {\n        // TODO: any way to fix this?\n        out_errstring(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    } else if (ntokens > MFLAG_MAX_OPT_LENGTH) {\n        // TODO: ensure the command tokenizer gives us at least this many\n        out_errstring(c, \"CLIENT_ERROR options flags are too long\");\n        return;\n    }\n\n    // scrubs duplicated options and sets flags for how to load the item.\n    if (_meta_flag_preparse(tokens, ntokens, &of, &errstr) != 0) {\n        out_errstring(c, errstr);\n        return;\n    }\n    c->noreply = of.no_reply;\n\n    // TODO: need to indicate if the item was overflowed or not?\n    // I think we do, since an overflow shouldn't trigger an alloc/replace.\n    bool overflow = false;\n    if (!of.locked) {\n        it = limited_get(key, nkey, c, 0, false, !of.no_update, &overflow);\n    } else {\n        // If we had to lock the item, we're doing our own bump later.\n        it = limited_get_locked(key, nkey, c, DONT_UPDATE, &hv, &overflow);\n    }\n\n    // Since we're a new protocol, we can actually inform users that refcount\n    // overflow is happening by straight up throwing an error.\n    // We definitely don't want to re-autovivify by accident.\n    if (overflow) {\n        assert(it == NULL);\n        out_errstring(c, \"SERVER_ERROR refcount overflow during fetch\");\n        return;\n    }\n\n    if (it == NULL && of.vivify) {\n        // Fill in the exptime during parsing later.\n        it = item_alloc(key, nkey, 0, realtime(0), 2);\n        // We don't actually need any of do_store_item's logic:\n        // - already fetched and missed an existing item.\n        // - lock is still held.\n        // - not append/prepend/replace\n        // - not testing CAS\n        if (it != NULL) {\n            // I look forward to the day I get rid of this :)\n            memcpy(ITEM_data(it), \"\\r\\n\", 2);\n            // NOTE: This initializes the CAS value.\n            do_item_link(it, hv);\n            item_created = true;\n        }\n    }\n\n    // don't have to check result of add_iov() since the iov size defaults are\n    // enough.\n    if (it) {\n        if (of.value) {\n            memcpy(p, \"VA \", 3);\n            p = itoa_u32(it->nbytes-2, p+3);\n        } else {\n            memcpy(p, \"OK\", 2);\n            p += 2;\n        }\n\n        for (i = KEY_TOKEN+1; i < ntokens-1; i++) {\n            switch (tokens[i].value[0]) {\n                case 'T':\n                    ttl_set = true;\n                    it->exptime = of.exptime;\n                    break;\n                case 'N':\n                    if (item_created) {\n                        it->exptime = of.autoviv_exptime;\n                        won_token = true;\n                    }\n                    break;\n                case 'R':\n                    // If we haven't autovivified and supplied token is less\n                    // than current TTL, mark a win.\n                    if ((it->it_flags & ITEM_TOKEN_SENT) == 0\n                            && !item_created\n                            && it->exptime != 0\n                            && it->exptime < of.recache_time) {\n                        won_token = true;\n                    }\n                    break;\n                case 's':\n                    META_CHAR(p, 's');\n                    p = itoa_u32(it->nbytes-2, p);\n                    break;\n                case 't':\n                    // TTL remaining as of this request.\n                    // needs to be relative because server clocks may not be in sync.\n                    META_CHAR(p, 't');\n                    if (it->exptime == 0) {\n                        *p = '-';\n                        *(p+1) = '1';\n                        p += 2;\n                    } else {\n                        p = itoa_u32(it->exptime - current_time, p);\n                    }\n                    break;\n                case 'c':\n                    META_CHAR(p, 'c');\n                    p = itoa_u64(ITEM_get_cas(it), p);\n                    break;\n                case 'f':\n                    META_CHAR(p, 'f');\n                    if (FLAGS_SIZE(it) == 0) {\n                        *p = '0';\n                        p++;\n                    } else {\n                        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);\n                    }\n                    break;\n                case 'l':\n                    META_CHAR(p, 'l');\n                    p = itoa_u32(current_time - it->time, p);\n                    break;\n                case 'h':\n                    META_CHAR(p, 'h');\n                    if (it->it_flags & ITEM_FETCHED) {\n                        *p = '1';\n                    } else {\n                        *p = '0';\n                    }\n                    p++;\n                    break;\n                case 'O':\n                    if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {\n                        errstr = \"CLIENT_ERROR opaque token too long\";\n                        goto error;\n                    }\n                    META_SPACE(p);\n                    memcpy(p, tokens[i].value, tokens[i].length);\n                    p += tokens[i].length;\n                    break;\n                case 'k':\n                    META_CHAR(p, 'k');\n                    memcpy(p, ITEM_key(it), it->nkey);\n                    p += it->nkey;\n                    break;\n            }\n        }\n\n        // Has this item already sent a token?\n        // Important to do this here so we don't send W with Z.\n        // Isn't critical, but easier for client authors to understand.\n        if (it->it_flags & ITEM_TOKEN_SENT) {\n            META_CHAR(p, 'Z');\n        }\n        if (it->it_flags & ITEM_STALE) {\n            META_CHAR(p, 'X');\n            // FIXME: think hard about this. is this a default, or a flag?\n            if ((it->it_flags & ITEM_TOKEN_SENT) == 0) {\n                // If we're stale but no token already sent, now send one.\n                won_token = true;\n            }\n        }\n\n        if (won_token) {\n            // Mark a win into the flag buffer.\n            META_CHAR(p, 'W');\n            it->it_flags |= ITEM_TOKEN_SENT;\n        }\n\n        *p = '\\r';\n        *(p+1) = '\\n';\n        *(p+2) = '\\0';\n        p += 2;\n        // finally, chain in the buffer.\n        resp_add_iov(resp, resp->wbuf, p - resp->wbuf);\n\n        if (of.value) {\n#ifdef EXTSTORE\n            if (it->it_flags & ITEM_HDR) {\n                if (_get_extstore(c, it, resp) != 0) {\n                    pthread_mutex_lock(&c->thread->stats.mutex);\n                    c->thread->stats.get_oom_extstore++;\n                    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n                    failed = true;\n                }\n            } else if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                resp_add_iov(resp, ITEM_data(it), it->nbytes);\n            } else {\n                resp_add_chunked_iov(resp, it, it->nbytes);\n            }\n#else\n            if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                resp_add_iov(resp, ITEM_data(it), it->nbytes);\n            } else {\n                resp_add_chunked_iov(resp, it, it->nbytes);\n            }\n#endif\n        }\n\n        // need to hold the ref at least because of the key above.\n#ifdef EXTSTORE\n        if (!failed) {\n            if ((it->it_flags & ITEM_HDR) != 0 && of.value) {\n                // Only have extstore clean if header and returning value.\n                resp->item = NULL;\n            } else {\n                resp->item = it;\n            }\n        } else {\n            // Failed to set up extstore fetch.\n            if (of.locked) {\n                do_item_remove(it);\n            } else {\n                item_remove(it);\n            }\n        }\n#else\n        resp->item = it;\n#endif\n    } else {\n        failed = true;\n    }\n\n    if (of.locked) {\n        // Delayed bump so we could get fetched/last access time pre-update.\n        if (!of.no_update && it != NULL) {\n            do_item_bump(c, it, hv);\n        }\n        item_unlock(hv);\n    }\n\n    // we count this command as a normal one if we've gotten this far.\n    // TODO: for autovivify case, miss never happens. Is this okay?\n    if (!failed) {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        if (ttl_set) {\n            c->thread->stats.touch_cmds++;\n            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;\n        } else {\n            c->thread->stats.lru_hits[it->slabs_clsid]++;\n            c->thread->stats.get_cmds++;\n        }\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        conn_set_state(c, conn_new_cmd);\n    } else {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        if (ttl_set) {\n            c->thread->stats.touch_cmds++;\n            c->thread->stats.touch_misses++;\n        } else {\n            c->thread->stats.get_misses++;\n            c->thread->stats.get_cmds++;\n        }\n        MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        // This gets elided in noreply mode.\n        out_string(c, \"EN\");\n    }\n    return;\nerror:\n    if (it) {\n        do_item_remove(it);\n        if (of.locked) {\n            item_unlock(hv);\n        }\n    }\n    out_errstring(c, errstr);\n}\n\nstatic void process_mset_command(conn *c, token_t *tokens, const size_t ntokens) {\n    char *key;\n    size_t nkey;\n    item *it;\n    int i;\n    short comm = NREAD_SET;\n    struct _meta_flags of = {0}; // option bitflags.\n    char *errstr = \"CLIENT_ERROR bad command line format\";\n    uint32_t hv;\n    mc_resp *resp = c->resp;\n    char *p = resp->wbuf;\n\n    assert(c != NULL);\n\n    // TODO: most of this is identical to mget.\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_errstring(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (ntokens == 3) {\n        out_errstring(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    if (ntokens > MFLAG_MAX_OPT_LENGTH) {\n        out_errstring(c, \"CLIENT_ERROR options flags too long\");\n        return;\n    }\n\n    // leave space for the status code.\n    p = resp->wbuf + 3;\n\n    // We need to at least try to get the size to properly slurp bad bytes\n    // after an error.\n    if (_meta_flag_preparse(tokens, ntokens, &of, &errstr) != 0) {\n        goto error;\n    }\n\n    // Set noreply after tokens are understood.\n    c->noreply = of.no_reply;\n\n    bool has_error = false;\n    for (i = KEY_TOKEN+1; i < ntokens-1; i++) {\n        switch (tokens[i].value[0]) {\n            // TODO: macro perhaps?\n            case 'O':\n                if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {\n                    errstr = \"CLIENT_ERROR opaque token too long\";\n                    has_error = true;\n                    break;\n                }\n                META_SPACE(p);\n                memcpy(p, tokens[i].value, tokens[i].length);\n                p += tokens[i].length;\n                break;\n            case 'k':\n                META_CHAR(p, 'k');\n                memcpy(p, key, nkey);\n                p += nkey;\n                break;\n        }\n    }\n\n    // \"mode switch\" to alternative commands\n    switch (of.mode) {\n        case 0:\n            break; // no mode supplied.\n        case 'E': // Add...\n            comm = NREAD_ADD;\n            break;\n        case 'A': // Append.\n            comm = NREAD_APPEND;\n            break;\n        case 'P': // Prepend.\n            comm = NREAD_PREPEND;\n            break;\n        case 'R': // Replace.\n            comm = NREAD_REPLACE;\n            break;\n        case 'S': // Set. Default.\n            comm = NREAD_SET;\n            break;\n        default:\n            errstr = \"CLIENT_ERROR invalid mode for ms M token\";\n            goto error;\n    }\n\n    // The item storage function doesn't exactly map to mset.\n    // If a CAS value is supplied, upgrade default SET mode to CAS mode.\n    // Also allows REPLACE to work, as REPLACE + CAS works the same as CAS.\n    // add-with-cas works the same as add; but could only LRU bump if match..\n    // APPEND/PREPEND allow a simplified CAS check.\n    if (of.has_cas && (comm == NREAD_SET || comm == NREAD_REPLACE)) {\n        comm = NREAD_CAS;\n    }\n\n    // We attempt to process as much as we can in hopes of getting a valid and\n    // adjusted vlen, or else the data swallowed after error will be for 0b.\n    if (has_error)\n        goto error;\n\n    it = item_alloc(key, nkey, of.client_flags, of.exptime, of.value_len);\n\n    if (it == 0) {\n        enum store_item_type status;\n        // TODO: These could be normalized codes (TL and OM). Need to\n        // reorganize the output stuff a bit though.\n        if (! item_size_ok(nkey, of.client_flags, of.value_len)) {\n            errstr = \"SERVER_ERROR object too large for cache\";\n            status = TOO_LARGE;\n        } else {\n            errstr = \"SERVER_ERROR out of memory storing object\";\n            status = NO_MEMORY;\n        }\n        // FIXME: LOGGER_LOG specific to mset, include options.\n        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,\n                NULL, status, comm, key, nkey, 0, 0);\n\n        /* Avoid stale data persisting in cache because we failed alloc. */\n        // NOTE: only if SET mode?\n        it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);\n        if (it) {\n            do_item_unlink(it, hv);\n            STORAGE_delete(c->thread->storage, it);\n            do_item_remove(it);\n        }\n        item_unlock(hv);\n\n        goto error;\n    }\n    ITEM_set_cas(it, of.req_cas_id);\n\n    c->item = it;\n#ifdef NEED_ALIGN\n    if (it->it_flags & ITEM_CHUNKED) {\n        c->ritem = ITEM_schunk(it);\n    } else {\n        c->ritem = ITEM_data(it);\n    }\n#else\n    c->ritem = ITEM_data(it);\n#endif\n    c->rlbytes = it->nbytes;\n    c->cmd = comm;\n    if (of.set_stale && comm == NREAD_CAS) {\n        c->set_stale = true;\n    }\n    resp->wbytes = p - resp->wbuf;\n    memcpy(resp->wbuf + resp->wbytes, \"\\r\\n\", 2);\n    resp->wbytes += 2;\n    // We've written the status line into wbuf, use wbytes to finalize later.\n    resp_add_iov(resp, resp->wbuf, resp->wbytes);\n    c->mset_res = true;\n    conn_set_state(c, conn_nread);\n    return;\nerror:\n    /* swallow the data line */\n    c->sbytes = of.value_len;\n\n    // Note: no errors possible after the item was successfully allocated.\n    // So we're just looking at dumping error codes and returning.\n    out_errstring(c, errstr);\n    // TODO: pass state in? else switching twice meh.\n    conn_set_state(c, conn_swallow);\n}\n\nstatic void process_mdelete_command(conn *c, token_t *tokens, const size_t ntokens) {\n    char *key;\n    size_t nkey;\n    uint64_t req_cas_id = 0;\n    item *it = NULL;\n    int i;\n    uint32_t hv;\n    struct _meta_flags of = {0}; // option bitflags.\n    char *errstr = \"CLIENT_ERROR bad command line format\";\n    mc_resp *resp = c->resp;\n    // reserve 3 bytes for status code\n    char *p = resp->wbuf + 3;\n\n    assert(c != NULL);\n\n    // TODO: most of this is identical to mget.\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (ntokens > MFLAG_MAX_OPT_LENGTH) {\n        out_string(c, \"CLIENT_ERROR options flags too long\");\n        return;\n    }\n\n    // scrubs duplicated options and sets flags for how to load the item.\n    if (_meta_flag_preparse(tokens, ntokens, &of, &errstr) != 0) {\n        out_errstring(c, \"CLIENT_ERROR invalid or duplicate flag\");\n        return;\n    }\n    c->noreply = of.no_reply;\n\n    assert(c != NULL);\n    for (i = KEY_TOKEN+1; i < ntokens-1; i++) {\n        switch (tokens[i].value[0]) {\n            // TODO: macro perhaps?\n            case 'O':\n                if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {\n                    errstr = \"CLIENT_ERROR opaque token too long\";\n                    goto error;\n                }\n                META_SPACE(p);\n                memcpy(p, tokens[i].value, tokens[i].length);\n                p += tokens[i].length;\n                break;\n            case 'k':\n                META_CHAR(p, 'k');\n                memcpy(p, key, nkey);\n                p += nkey;\n                break;\n        }\n    }\n\n    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);\n    if (it) {\n        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);\n\n        // allow only deleting/marking if a CAS value matches.\n        if (of.has_cas && ITEM_get_cas(it) != req_cas_id) {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.delete_misses++;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n\n            memcpy(resp->wbuf, \"EX \", 3);\n            goto cleanup;\n        }\n\n        // If we're to set this item as stale, we don't actually want to\n        // delete it. We mark the stale bit, bump CAS, and update exptime if\n        // we were supplied a new TTL.\n        if (of.set_stale) {\n            if (of.new_ttl) {\n                it->exptime = of.exptime;\n            }\n            it->it_flags |= ITEM_STALE;\n            // Also need to remove TOKEN_SENT, so next client can win.\n            it->it_flags &= ~ITEM_TOKEN_SENT;\n\n            ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);\n\n            // Clients can noreply nominal responses.\n            if (c->noreply)\n                resp->skip = true;\n            memcpy(resp->wbuf, \"OK \", 3);\n        } else {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n\n            do_item_unlink(it, hv);\n            STORAGE_delete(c->thread->storage, it);\n            if (c->noreply)\n                resp->skip = true;\n            memcpy(resp->wbuf, \"OK \", 3);\n        }\n        goto cleanup;\n    } else {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.delete_misses++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        memcpy(resp->wbuf, \"NF \", 3);\n        goto cleanup;\n    }\ncleanup:\n    if (it) {\n        do_item_remove(it);\n    }\n    // Item is always returned locked, even if missing.\n    item_unlock(hv);\n    resp->wbytes = p - resp->wbuf;\n    memcpy(resp->wbuf + resp->wbytes, \"\\r\\n\", 2);\n    resp->wbytes += 2;\n    resp_add_iov(resp, resp->wbuf, resp->wbytes);\n    conn_set_state(c, conn_new_cmd);\n    return;\nerror:\n    out_errstring(c, errstr);\n}\n\nstatic void process_marithmetic_command(conn *c, token_t *tokens, const size_t ntokens) {\n    char *key;\n    size_t nkey;\n    int i;\n    struct _meta_flags of = {0}; // option bitflags.\n    char *errstr = \"CLIENT_ERROR bad command line format\";\n    mc_resp *resp = c->resp;\n    // no reservation (like del/set) since we post-process the status line.\n    char *p = resp->wbuf;\n\n    // If no argument supplied, incr or decr by one.\n    of.delta = 1;\n    of.initial = 0; // redundant, for clarity.\n    bool incr = true; // default mode is to increment.\n    bool locked = false;\n    uint32_t hv = 0;\n    item *it = NULL; // item returned by do_add_delta.\n\n    assert(c != NULL);\n\n    // TODO: most of this is identical to mget.\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (ntokens > MFLAG_MAX_OPT_LENGTH) {\n        out_string(c, \"CLIENT_ERROR options flags too long\");\n        return;\n    }\n\n    // scrubs duplicated options and sets flags for how to load the item.\n    if (_meta_flag_preparse(tokens, ntokens, &of, &errstr) != 0) {\n        out_errstring(c, \"CLIENT_ERROR invalid or duplicate flag\");\n        return;\n    }\n    c->noreply = of.no_reply;\n\n    assert(c != NULL);\n    // \"mode switch\" to alternative commands\n    switch (of.mode) {\n        case 0: // no switch supplied.\n            break;\n        case 'I': // Incr (default)\n        case '+':\n            incr = true;\n            break;\n        case 'D': // Decr.\n        case '-':\n            incr = false;\n            break;\n        default:\n            errstr = \"CLIENT_ERROR invalid mode for ma M token\";\n            goto error;\n            break;\n    }\n\n    // take hash value and manually lock item... hold lock during store phase\n    // on miss and avoid recalculating the hash multiple times.\n    hv = hash(key, nkey);\n    item_lock(hv);\n    locked = true;\n    char tmpbuf[INCR_MAX_STORAGE_LEN];\n\n    // return a referenced item if it exists, so we can modify it here, rather\n    // than adding even more parameters to do_add_delta.\n    bool item_created = false;\n    switch(do_add_delta(c, key, nkey, incr, of.delta, tmpbuf, &of.req_cas_id, hv, &it)) {\n    case OK:\n        if (c->noreply)\n            resp->skip = true;\n        memcpy(resp->wbuf, \"OK \", 3);\n        break;\n    case NON_NUMERIC:\n        errstr = \"CLIENT_ERROR cannot increment or decrement non-numeric value\";\n        goto error;\n        break;\n    case EOM:\n        errstr = \"SERVER_ERROR out of memory\";\n        goto error;\n        break;\n    case DELTA_ITEM_NOT_FOUND:\n        if (of.vivify) {\n            itoa_u64(of.initial, tmpbuf);\n            int vlen = strlen(tmpbuf);\n\n            it = item_alloc(key, nkey, 0, 0, vlen+2);\n            if (it != NULL) {\n                memcpy(ITEM_data(it), tmpbuf, vlen);\n                memcpy(ITEM_data(it) + vlen, \"\\r\\n\", 2);\n                if (do_store_item(it, NREAD_ADD, c, hv)) {\n                    item_created = true;\n                } else {\n                    // Not sure how we can get here if we're holding the lock.\n                    memcpy(resp->wbuf, \"NS \", 3);\n                }\n            } else {\n                errstr = \"SERVER_ERROR Out of memory allocating new item\";\n                goto error;\n            }\n        } else {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            if (incr) {\n                c->thread->stats.incr_misses++;\n            } else {\n                c->thread->stats.decr_misses++;\n            }\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n            // won't have a valid it here.\n            memcpy(p, \"NF \", 3);\n            p += 3;\n        }\n        break;\n    case DELTA_ITEM_CAS_MISMATCH:\n        // also returns without a valid it.\n        memcpy(p, \"EX \", 3);\n        p += 3;\n        break;\n    }\n\n    // final loop\n    // allows building the response with information after vivifying from a\n    // miss, or returning a new CAS value after add_delta().\n    if (it) {\n        size_t vlen = strlen(tmpbuf);\n        if (of.value) {\n            memcpy(p, \"VA \", 3);\n            p = itoa_u32(vlen, p+3);\n        } else {\n            memcpy(p, \"OK\", 2);\n            p += 2;\n        }\n\n        for (i = KEY_TOKEN+1; i < ntokens-1; i++) {\n            switch (tokens[i].value[0]) {\n                case 'c':\n                    META_CHAR(p, 'c');\n                    p = itoa_u64(ITEM_get_cas(it), p);\n                    break;\n                case 't':\n                    META_CHAR(p, 't');\n                    if (it->exptime == 0) {\n                        *p = '-';\n                        *(p+1) = '1';\n                        p += 2;\n                    } else {\n                        p = itoa_u32(it->exptime - current_time, p);\n                    }\n                    break;\n                case 'T':\n                    it->exptime = of.exptime;\n                    break;\n                case 'N':\n                    if (item_created) {\n                        it->exptime = of.autoviv_exptime;\n                    }\n                    break;\n                // TODO: macro perhaps?\n                case 'O':\n                    if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {\n                        errstr = \"CLIENT_ERROR opaque token too long\";\n                        goto error;\n                    }\n                    META_SPACE(p);\n                    memcpy(p, tokens[i].value, tokens[i].length);\n                    p += tokens[i].length;\n                    break;\n                case 'k':\n                    META_CHAR(p, 'k');\n                    memcpy(p, key, nkey);\n                    p += nkey;\n                    break;\n            }\n        }\n\n        if (of.value) {\n            *p = '\\r';\n            *(p+1) = '\\n';\n            p += 2;\n            memcpy(p, tmpbuf, vlen);\n            p += vlen;\n        }\n\n        do_item_remove(it);\n    } else {\n        // No item to handle. still need to return opaque/key tokens\n        for (i = KEY_TOKEN+1; i < ntokens-1; i++) {\n            switch (tokens[i].value[0]) {\n                // TODO: macro perhaps?\n                case 'O':\n                    if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {\n                        errstr = \"CLIENT_ERROR opaque token too long\";\n                        goto error;\n                    }\n                    META_SPACE(p);\n                    memcpy(p, tokens[i].value, tokens[i].length);\n                    p += tokens[i].length;\n                    break;\n                case 'k':\n                    META_CHAR(p, 'k');\n                    memcpy(p, key, nkey);\n                    p += nkey;\n                    break;\n            }\n        }\n    }\n\n    item_unlock(hv);\n\n    resp->wbytes = p - resp->wbuf;\n    memcpy(resp->wbuf + resp->wbytes, \"\\r\\n\", 2);\n    resp->wbytes += 2;\n    resp_add_iov(resp, resp->wbuf, resp->wbytes);\n    conn_set_state(c, conn_new_cmd);\n    return;\nerror:\n    if (it != NULL)\n        do_item_remove(it);\n    if (locked)\n        item_unlock(hv);\n    out_errstring(c, errstr);\n}\n\n\nstatic void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {\n    char *key;\n    size_t nkey;\n    unsigned int flags;\n    int32_t exptime_int = 0;\n    rel_time_t exptime = 0;\n    int vlen;\n    uint64_t req_cas_id=0;\n    item *it;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)\n           && safe_strtol(tokens[3].value, &exptime_int)\n           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));\n\n    // does cas value exist?\n    if (handle_cas) {\n        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n    }\n\n    if (vlen < 0 || vlen > (INT_MAX - 2)) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n    vlen += 2;\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    it = item_alloc(key, nkey, flags, exptime, vlen);\n\n    if (it == 0) {\n        enum store_item_type status;\n        if (! item_size_ok(nkey, flags, vlen)) {\n            out_string(c, \"SERVER_ERROR object too large for cache\");\n            status = TOO_LARGE;\n        } else {\n            out_of_memory(c, \"SERVER_ERROR out of memory storing object\");\n            status = NO_MEMORY;\n        }\n        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,\n                NULL, status, comm, key, nkey, 0, 0, c->sfd);\n        /* swallow the data line */\n        conn_set_state(c, conn_swallow);\n        c->sbytes = vlen;\n\n        /* Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET. Anywhere else too? */\n        if (comm == NREAD_SET) {\n            it = item_get(key, nkey, c, DONT_UPDATE);\n            if (it) {\n                item_unlink(it);\n                STORAGE_delete(c->thread->storage, it);\n                item_remove(it);\n            }\n        }\n\n        return;\n    }\n    ITEM_set_cas(it, req_cas_id);\n\n    c->item = it;\n#ifdef NEED_ALIGN\n    if (it->it_flags & ITEM_CHUNKED) {\n        c->ritem = ITEM_schunk(it);\n    } else {\n        c->ritem = ITEM_data(it);\n    }\n#else\n    c->ritem = ITEM_data(it);\n#endif\n    c->rlbytes = it->nbytes;\n    c->cmd = comm;\n    conn_set_state(c, conn_nread);\n}\n\nstatic void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {\n    char *key;\n    size_t nkey;\n    int32_t exptime_int = 0;\n    rel_time_t exptime = 0;\n    item *it;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (!safe_strtol(tokens[2].value, &exptime_int)) {\n        out_string(c, \"CLIENT_ERROR invalid exptime argument\");\n        return;\n    }\n\n    exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));\n    it = item_touch(key, nkey, exptime, c);\n    if (it) {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.touch_cmds++;\n        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        out_string(c, \"TOUCHED\");\n        item_remove(it);\n    } else {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.touch_cmds++;\n        c->thread->stats.touch_misses++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        out_string(c, \"NOT_FOUND\");\n    }\n}\n\nstatic void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {\n    char temp[INCR_MAX_STORAGE_LEN];\n    uint64_t delta;\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (!safe_strtoull(tokens[2].value, &delta)) {\n        out_string(c, \"CLIENT_ERROR invalid numeric delta argument\");\n        return;\n    }\n\n    switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {\n    case OK:\n        out_string(c, temp);\n        break;\n    case NON_NUMERIC:\n        out_string(c, \"CLIENT_ERROR cannot increment or decrement non-numeric value\");\n        break;\n    case EOM:\n        out_of_memory(c, \"SERVER_ERROR out of memory\");\n        break;\n    case DELTA_ITEM_NOT_FOUND:\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        if (incr) {\n            c->thread->stats.incr_misses++;\n        } else {\n            c->thread->stats.decr_misses++;\n        }\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        out_string(c, \"NOT_FOUND\");\n        break;\n    case DELTA_ITEM_CAS_MISMATCH:\n        break; /* Should never get here */\n    }\n}\n\n/*\n * adds a delta value to a numeric item.\n *\n * c     connection requesting the operation\n * it    item to adjust\n * incr  true to increment value, false to decrement\n * delta amount to adjust value by\n * buf   buffer for response string\n *\n * returns a response string to send back to the client.\n */\nenum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,\n                                    const bool incr, const int64_t delta,\n                                    char *buf, uint64_t *cas,\n                                    const uint32_t hv,\n                                    item **it_ret) {\n    char *ptr;\n    uint64_t value;\n    int res;\n    item *it;\n\n    it = do_item_get(key, nkey, hv, c, DONT_UPDATE);\n    if (!it) {\n        return DELTA_ITEM_NOT_FOUND;\n    }\n\n    /* Can't delta zero byte values. 2-byte are the \"\\r\\n\" */\n    /* Also can't delta for chunked items. Too large to be a number */\n#ifdef EXTSTORE\n    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {\n#else\n    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) != 0) {\n#endif\n        do_item_remove(it);\n        return NON_NUMERIC;\n    }\n\n    if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {\n        do_item_remove(it);\n        return DELTA_ITEM_CAS_MISMATCH;\n    }\n\n    ptr = ITEM_data(it);\n\n    if (!safe_strtoull(ptr, &value)) {\n        do_item_remove(it);\n        return NON_NUMERIC;\n    }\n\n    if (incr) {\n        value += delta;\n        MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);\n    } else {\n        if(delta > value) {\n            value = 0;\n        } else {\n            value -= delta;\n        }\n        MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);\n    }\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    if (incr) {\n        c->thread->stats.slab_stats[ITEM_clsid(it)].incr_hits++;\n    } else {\n        c->thread->stats.slab_stats[ITEM_clsid(it)].decr_hits++;\n    }\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    itoa_u64(value, buf);\n    res = strlen(buf);\n    /* refcount == 2 means we are the only ones holding the item, and it is\n     * linked. We hold the item's lock in this function, so refcount cannot\n     * increase. */\n    if (res + 2 <= it->nbytes && it->refcount == 2) { /* replace in-place */\n        /* When changing the value without replacing the item, we\n           need to update the CAS on the existing item. */\n        /* We also need to fiddle it in the sizes tracker in case the tracking\n         * was enabled at runtime, since it relies on the CAS value to know\n         * whether to remove an item or not. */\n        item_stats_sizes_remove(it);\n        ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);\n        item_stats_sizes_add(it);\n        memcpy(ITEM_data(it), buf, res);\n        memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);\n        do_item_update(it);\n    } else if (it->refcount > 1) {\n        item *new_it;\n        uint32_t flags;\n        FLAGS_CONV(it, flags);\n        new_it = do_item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, res + 2);\n        if (new_it == 0) {\n            do_item_remove(it);\n            return EOM;\n        }\n        memcpy(ITEM_data(new_it), buf, res);\n        memcpy(ITEM_data(new_it) + res, \"\\r\\n\", 2);\n        item_replace(it, new_it, hv);\n        // Overwrite the older item's CAS with our new CAS since we're\n        // returning the CAS of the old item below.\n        ITEM_set_cas(it, (settings.use_cas) ? ITEM_get_cas(new_it) : 0);\n        do_item_remove(new_it);       /* release our reference */\n    } else {\n        /* Should never get here. This means we somehow fetched an unlinked\n         * item. TODO: Add a counter? */\n        if (settings.verbose) {\n            fprintf(stderr, \"Tried to do incr/decr on invalid item\\n\");\n        }\n        if (it->refcount == 1)\n            do_item_remove(it);\n        return DELTA_ITEM_NOT_FOUND;\n    }\n\n    if (cas) {\n        *cas = ITEM_get_cas(it);    /* swap the incoming CAS value */\n    }\n    if (it_ret != NULL) {\n        *it_ret = it;\n    } else {\n        do_item_remove(it);         /* release our reference */\n    }\n    return OK;\n}\n\nstatic void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {\n    char *key;\n    size_t nkey;\n    item *it;\n    uint32_t hv;\n\n    assert(c != NULL);\n\n    if (ntokens > 3) {\n        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, \"0\") == 0;\n        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);\n        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))\n            || (ntokens == 5 && hold_is_zero && sets_noreply);\n        if (!valid) {\n            out_string(c, \"CLIENT_ERROR bad command line format.  \"\n                       \"Usage: delete <key> [noreply]\");\n            return;\n        }\n    }\n\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if(nkey > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_delete(key, nkey);\n    }\n\n    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);\n    if (it) {\n        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        do_item_unlink(it, hv);\n        STORAGE_delete(c->thread->storage, it);\n        do_item_remove(it);      /* release our reference */\n        out_string(c, \"DELETED\");\n    } else {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.delete_misses++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        out_string(c, \"NOT_FOUND\");\n    }\n    item_unlock(hv);\n}\n\nstatic void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {\n    unsigned int level;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    level = strtoul(tokens[1].value, NULL, 10);\n    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;\n    out_string(c, \"OK\");\n    return;\n}\n\n#ifdef MEMCACHED_DEBUG\nstatic void process_misbehave_command(conn *c) {\n    int allowed = 0;\n\n    // try opening new TCP socket\n    int i = socket(AF_INET, SOCK_STREAM, 0);\n    if (i != -1) {\n        allowed++;\n        close(i);\n    }\n\n    // try executing new commands\n    i = system(\"sleep 0\");\n    if (i != -1) {\n        allowed++;\n    }\n\n    if (allowed) {\n        out_string(c, \"ERROR\");\n    } else {\n        out_string(c, \"OK\");\n    }\n}\n#endif\n\nstatic void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {\n    unsigned int level;\n    double ratio;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (strcmp(tokens[2].value, \"ratio\") == 0) {\n        if (ntokens < 5 || !safe_strtod(tokens[3].value, &ratio)) {\n            out_string(c, \"ERROR\");\n            return;\n        }\n        settings.slab_automove_ratio = ratio;\n    } else {\n        level = strtoul(tokens[2].value, NULL, 10);\n        if (level == 0) {\n            settings.slab_automove = 0;\n        } else if (level == 1 || level == 2) {\n            settings.slab_automove = level;\n        } else {\n            out_string(c, \"ERROR\");\n            return;\n        }\n    }\n    out_string(c, \"OK\");\n    return;\n}\n\n/* TODO: decide on syntax for sampling? */\nstatic void process_watch_command(conn *c, token_t *tokens, const size_t ntokens) {\n    uint16_t f = 0;\n    int x;\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n    if (!settings.watch_enabled) {\n        out_string(c, \"CLIENT_ERROR watch commands not allowed\");\n        return;\n    }\n\n    if (ntokens > 2) {\n        for (x = COMMAND_TOKEN + 1; x < ntokens - 1; x++) {\n            if ((strcmp(tokens[x].value, \"rawcmds\") == 0)) {\n                f |= LOG_RAWCMDS;\n            } else if ((strcmp(tokens[x].value, \"evictions\") == 0)) {\n                f |= LOG_EVICTIONS;\n            } else if ((strcmp(tokens[x].value, \"fetchers\") == 0)) {\n                f |= LOG_FETCHERS;\n            } else if ((strcmp(tokens[x].value, \"mutations\") == 0)) {\n                f |= LOG_MUTATIONS;\n            } else if ((strcmp(tokens[x].value, \"sysevents\") == 0)) {\n                f |= LOG_SYSEVENTS;\n            } else {\n                out_string(c, \"ERROR\");\n                return;\n            }\n        }\n    } else {\n        f |= LOG_FETCHERS;\n    }\n\n    switch(logger_add_watcher(c, c->sfd, f)) {\n        case LOGGER_ADD_WATCHER_TOO_MANY:\n            out_string(c, \"WATCHER_TOO_MANY log watcher limit reached\");\n            break;\n        case LOGGER_ADD_WATCHER_FAILED:\n            out_string(c, \"WATCHER_FAILED failed to add log watcher\");\n            break;\n        case LOGGER_ADD_WATCHER_OK:\n            conn_set_state(c, conn_watch);\n            event_del(&c->event);\n            break;\n    }\n}\n\nstatic void process_memlimit_command(conn *c, token_t *tokens, const size_t ntokens) {\n    uint32_t memlimit;\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (!safe_strtoul(tokens[1].value, &memlimit)) {\n        out_string(c, \"ERROR\");\n    } else {\n        if (memlimit < 8) {\n            out_string(c, \"MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m\");\n        } else {\n            if (memlimit > 1000000000) {\n                out_string(c, \"MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes\");\n            } else if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {\n                if (settings.verbose > 0) {\n                    fprintf(stderr, \"maxbytes adjusted to %llum\\n\", (unsigned long long)memlimit);\n                }\n\n                out_string(c, \"OK\");\n            } else {\n                out_string(c, \"MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust\");\n            }\n        }\n    }\n}\n\nstatic void process_lru_command(conn *c, token_t *tokens, const size_t ntokens) {\n    uint32_t pct_hot;\n    uint32_t pct_warm;\n    double hot_factor;\n    int32_t ttl;\n    double factor;\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (strcmp(tokens[1].value, \"tune\") == 0 && ntokens >= 7) {\n        if (!safe_strtoul(tokens[2].value, &pct_hot) ||\n            !safe_strtoul(tokens[3].value, &pct_warm) ||\n            !safe_strtod(tokens[4].value, &hot_factor) ||\n            !safe_strtod(tokens[5].value, &factor)) {\n            out_string(c, \"ERROR\");\n        } else {\n            if (pct_hot + pct_warm > 80) {\n                out_string(c, \"ERROR hot and warm pcts must not exceed 80\");\n            } else if (factor <= 0 || hot_factor <= 0) {\n                out_string(c, \"ERROR hot/warm age factors must be greater than 0\");\n            } else {\n                settings.hot_lru_pct = pct_hot;\n                settings.warm_lru_pct = pct_warm;\n                settings.hot_max_factor = hot_factor;\n                settings.warm_max_factor = factor;\n                out_string(c, \"OK\");\n            }\n        }\n    } else if (strcmp(tokens[1].value, \"mode\") == 0 && ntokens >= 4 &&\n               settings.lru_maintainer_thread) {\n        if (strcmp(tokens[2].value, \"flat\") == 0) {\n            settings.lru_segmented = false;\n            out_string(c, \"OK\");\n        } else if (strcmp(tokens[2].value, \"segmented\") == 0) {\n            settings.lru_segmented = true;\n            out_string(c, \"OK\");\n        } else {\n            out_string(c, \"ERROR\");\n        }\n    } else if (strcmp(tokens[1].value, \"temp_ttl\") == 0 && ntokens >= 4 &&\n               settings.lru_maintainer_thread) {\n        if (!safe_strtol(tokens[2].value, &ttl)) {\n            out_string(c, \"ERROR\");\n        } else {\n            if (ttl < 0) {\n                settings.temp_lru = false;\n            } else {\n                settings.temp_lru = true;\n                settings.temporary_ttl = ttl;\n            }\n            out_string(c, \"OK\");\n        }\n    } else {\n        out_string(c, \"ERROR\");\n    }\n}\n#ifdef EXTSTORE\nstatic void process_extstore_command(conn *c, token_t *tokens, const size_t ntokens) {\n    set_noreply_maybe(c, tokens, ntokens);\n    bool ok = true;\n    if (ntokens < 4) {\n        ok = false;\n    } else if (strcmp(tokens[1].value, \"free_memchunks\") == 0 && ntokens > 4) {\n        /* per-slab-class free chunk setting. */\n        unsigned int clsid = 0;\n        unsigned int limit = 0;\n        if (!safe_strtoul(tokens[2].value, &clsid) ||\n                !safe_strtoul(tokens[3].value, &limit)) {\n            ok = false;\n        } else {\n            if (clsid < MAX_NUMBER_OF_SLAB_CLASSES) {\n                settings.ext_free_memchunks[clsid] = limit;\n            } else {\n                ok = false;\n            }\n        }\n    } else if (strcmp(tokens[1].value, \"item_size\") == 0) {\n        if (!safe_strtoul(tokens[2].value, &settings.ext_item_size))\n            ok = false;\n    } else if (strcmp(tokens[1].value, \"item_age\") == 0) {\n        if (!safe_strtoul(tokens[2].value, &settings.ext_item_age))\n            ok = false;\n    } else if (strcmp(tokens[1].value, \"low_ttl\") == 0) {\n        if (!safe_strtoul(tokens[2].value, &settings.ext_low_ttl))\n            ok = false;\n    } else if (strcmp(tokens[1].value, \"recache_rate\") == 0) {\n        if (!safe_strtoul(tokens[2].value, &settings.ext_recache_rate))\n            ok = false;\n    } else if (strcmp(tokens[1].value, \"compact_under\") == 0) {\n        if (!safe_strtoul(tokens[2].value, &settings.ext_compact_under))\n            ok = false;\n    } else if (strcmp(tokens[1].value, \"drop_under\") == 0) {\n        if (!safe_strtoul(tokens[2].value, &settings.ext_drop_under))\n            ok = false;\n    } else if (strcmp(tokens[1].value, \"max_frag\") == 0) {\n        if (!safe_strtod(tokens[2].value, &settings.ext_max_frag))\n            ok = false;\n    } else if (strcmp(tokens[1].value, \"drop_unread\") == 0) {\n        unsigned int v;\n        if (!safe_strtoul(tokens[2].value, &v)) {\n            ok = false;\n        } else {\n            settings.ext_drop_unread = v == 0 ? false : true;\n        }\n    } else {\n        ok = false;\n    }\n    if (!ok) {\n        out_string(c, \"ERROR\");\n    } else {\n        out_string(c, \"OK\");\n    }\n}\n#endif\n// TODO: pipelined commands are incompatible with shifting connections to a\n// side thread. Given this only happens in two instances (watch and\n// lru_crawler metadump) it should be fine for things to bail. It _should_ be\n// unusual for these commands.\n// This is hard to fix since tokenize_command() mutilates the read buffer, so\n// we can't drop out and back in again.\n// Leaving this note here to spend more time on a fix when necessary, or if an\n// opportunity becomes obvious.\nstatic void process_command(conn *c, char *command) {\n\n    token_t tokens[MAX_TOKENS];\n    size_t ntokens;\n    int comm;\n\n    assert(c != NULL);\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"<%d %s\\n\", c->sfd, command);\n\n    /*\n     * for commands set/add/replace, we build an item and read the data\n     * directly into it, then continue in nread_complete().\n     */\n\n    // Prep the response object for this query.\n    if (!resp_start(c)) {\n        conn_set_state(c, conn_closing);\n        return;\n    }\n\n    ntokens = tokenize_command(command, tokens, MAX_TOKENS);\n    if (ntokens >= 3 &&\n        ((strcmp(tokens[COMMAND_TOKEN].value, \"get\") == 0) ||\n         (strcmp(tokens[COMMAND_TOKEN].value, \"bget\") == 0))) {\n\n        process_get_command(c, tokens, ntokens, false, false);\n\n    } else if ((ntokens == 6 || ntokens == 7) &&\n               ((strcmp(tokens[COMMAND_TOKEN].value, \"add\") == 0 && (comm = NREAD_ADD)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"set\") == 0 && (comm = NREAD_SET)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"replace\") == 0 && (comm = NREAD_REPLACE)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"prepend\") == 0 && (comm = NREAD_PREPEND)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"append\") == 0 && (comm = NREAD_APPEND)) )) {\n\n        process_update_command(c, tokens, ntokens, comm, false);\n\n    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, \"cas\") == 0 && (comm = NREAD_CAS))) {\n\n        process_update_command(c, tokens, ntokens, comm, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"incr\") == 0)) {\n\n        process_arithmetic_command(c, tokens, ntokens, 1);\n\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"gets\") == 0)) {\n\n        process_get_command(c, tokens, ntokens, true, false);\n\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"mg\") == 0)) {\n        process_mget_command(c, tokens, ntokens);\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"ms\") == 0)) {\n        process_mset_command(c, tokens, ntokens);\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"md\") == 0)) {\n        process_mdelete_command(c, tokens, ntokens);\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"mn\") == 0)) {\n        out_string(c, \"MN\");\n        // mn command forces immediate writeback flush.\n        conn_set_state(c, conn_mwrite);\n        return;\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"ma\") == 0)) {\n        process_marithmetic_command(c, tokens, ntokens);\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"me\") == 0)) {\n        process_meta_command(c, tokens, ntokens);\n        return;\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"decr\") == 0)) {\n\n        process_arithmetic_command(c, tokens, ntokens, 0);\n\n    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, \"delete\") == 0)) {\n\n        process_delete_command(c, tokens, ntokens);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"touch\") == 0)) {\n\n        process_touch_command(c, tokens, ntokens);\n\n    } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"gat\") == 0)) {\n\n        process_get_command(c, tokens, ntokens, false, true);\n\n    } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"gats\") == 0)) {\n\n        process_get_command(c, tokens, ntokens, true, true);\n\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"stats\") == 0)) {\n\n        process_stat(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"flush_all\") == 0)) {\n        time_t exptime = 0;\n        rel_time_t new_oldest = 0;\n\n        set_noreply_maybe(c, tokens, ntokens);\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.flush_cmds++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        if (!settings.flush_enabled) {\n            // flush_all is not allowed but we log it on stats\n            out_string(c, \"CLIENT_ERROR flush_all not allowed\");\n            return;\n        }\n\n        if (ntokens != (c->noreply ? 3 : 2)) {\n            exptime = strtol(tokens[1].value, NULL, 10);\n            if(errno == ERANGE) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return;\n            }\n        }\n\n        /*\n          If exptime is zero realtime() would return zero too, and\n          realtime(exptime) - 1 would overflow to the max unsigned\n          value.  So we process exptime == 0 the same way we do when\n          no delay is given at all.\n        */\n        if (exptime > 0) {\n            new_oldest = realtime(exptime);\n        } else { /* exptime == 0 */\n            new_oldest = current_time;\n        }\n\n        if (settings.use_cas) {\n            settings.oldest_live = new_oldest - 1;\n            if (settings.oldest_live <= current_time)\n                settings.oldest_cas = get_cas_id();\n        } else {\n            settings.oldest_live = new_oldest;\n        }\n        out_string(c, \"OK\");\n        return;\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"version\") == 0)) {\n\n        out_string(c, \"VERSION \" VERSION);\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"quit\") == 0)) {\n\n        conn_set_state(c, conn_mwrite);\n        c->close_after_write = true;\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"shutdown\") == 0)) {\n\n        if (settings.shutdown_command) {\n            conn_set_state(c, conn_closing);\n            raise(SIGINT);\n        } else {\n            out_string(c, \"ERROR: shutdown not enabled\");\n        }\n\n    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, \"slabs\") == 0) {\n        if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, \"reassign\") == 0) {\n            int src, dst, rv;\n\n            if (settings.slab_reassign == false) {\n                out_string(c, \"CLIENT_ERROR slab reassignment disabled\");\n                return;\n            }\n\n            src = strtol(tokens[2].value, NULL, 10);\n            dst = strtol(tokens[3].value, NULL, 10);\n\n            if (errno == ERANGE) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return;\n            }\n\n            rv = slabs_reassign(src, dst);\n            switch (rv) {\n            case REASSIGN_OK:\n                out_string(c, \"OK\");\n                break;\n            case REASSIGN_RUNNING:\n                out_string(c, \"BUSY currently processing reassign request\");\n                break;\n            case REASSIGN_BADCLASS:\n                out_string(c, \"BADCLASS invalid src or dst class id\");\n                break;\n            case REASSIGN_NOSPARE:\n                out_string(c, \"NOSPARE source class has no spare pages\");\n                break;\n            case REASSIGN_SRC_DST_SAME:\n                out_string(c, \"SAME src and dst class are identical\");\n                break;\n            }\n            return;\n        } else if (ntokens >= 4 &&\n            (strcmp(tokens[COMMAND_TOKEN + 1].value, \"automove\") == 0)) {\n            process_slabs_automove_command(c, tokens, ntokens);\n        } else {\n            out_string(c, \"ERROR\");\n        }\n    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, \"lru_crawler\") == 0) {\n        if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, \"crawl\") == 0) {\n            int rv;\n            if (settings.lru_crawler == false) {\n                out_string(c, \"CLIENT_ERROR lru crawler disabled\");\n                return;\n            }\n\n            rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0,\n                    settings.lru_crawler_tocrawl);\n            switch(rv) {\n            case CRAWLER_OK:\n                out_string(c, \"OK\");\n                break;\n            case CRAWLER_RUNNING:\n                out_string(c, \"BUSY currently processing crawler request\");\n                break;\n            case CRAWLER_BADCLASS:\n                out_string(c, \"BADCLASS invalid class id\");\n                break;\n            case CRAWLER_NOTSTARTED:\n                out_string(c, \"NOTSTARTED no items to crawl\");\n                break;\n            case CRAWLER_ERROR:\n                out_string(c, \"ERROR an unknown error happened\");\n                break;\n            }\n            return;\n        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, \"metadump\") == 0) {\n            if (settings.lru_crawler == false) {\n                out_string(c, \"CLIENT_ERROR lru crawler disabled\");\n                return;\n            }\n            if (!settings.dump_enabled) {\n                out_string(c, \"ERROR metadump not allowed\");\n                return;\n            }\n            if (resp_has_stack(c)) {\n                out_string(c, \"ERROR cannot pipeline other commands before metadump\");\n                return;\n            }\n\n            int rv = lru_crawler_crawl(tokens[2].value, CRAWLER_METADUMP,\n                    c, c->sfd, LRU_CRAWLER_CAP_REMAINING);\n            switch(rv) {\n                case CRAWLER_OK:\n                    // TODO: documentation says this string is returned, but\n                    // it never was before. We never switch to conn_write so\n                    // this o_s call never worked. Need to talk to users and\n                    // decide if removing the OK from docs is fine.\n                    //out_string(c, \"OK\");\n                    // TODO: Don't reuse conn_watch here.\n                    conn_set_state(c, conn_watch);\n                    event_del(&c->event);\n                    break;\n                case CRAWLER_RUNNING:\n                    out_string(c, \"BUSY currently processing crawler request\");\n                    break;\n                case CRAWLER_BADCLASS:\n                    out_string(c, \"BADCLASS invalid class id\");\n                    break;\n                case CRAWLER_NOTSTARTED:\n                    out_string(c, \"NOTSTARTED no items to crawl\");\n                    break;\n                case CRAWLER_ERROR:\n                    out_string(c, \"ERROR an unknown error happened\");\n                    break;\n            }\n            return;\n        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, \"tocrawl\") == 0) {\n            uint32_t tocrawl;\n             if (!safe_strtoul(tokens[2].value, &tocrawl)) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return;\n            }\n            settings.lru_crawler_tocrawl = tocrawl;\n            out_string(c, \"OK\");\n            return;\n        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, \"sleep\") == 0) {\n            uint32_t tosleep;\n            if (!safe_strtoul(tokens[2].value, &tosleep)) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return;\n            }\n            if (tosleep > 1000000) {\n                out_string(c, \"CLIENT_ERROR sleep must be one second or less\");\n                return;\n            }\n            settings.lru_crawler_sleep = tosleep;\n            out_string(c, \"OK\");\n            return;\n        } else if (ntokens == 3) {\n            if ((strcmp(tokens[COMMAND_TOKEN + 1].value, \"enable\") == 0)) {\n                if (start_item_crawler_thread() == 0) {\n                    out_string(c, \"OK\");\n                } else {\n                    out_string(c, \"ERROR failed to start lru crawler thread\");\n                }\n            } else if ((strcmp(tokens[COMMAND_TOKEN + 1].value, \"disable\") == 0)) {\n                if (stop_item_crawler_thread(CRAWLER_NOWAIT) == 0) {\n                    out_string(c, \"OK\");\n                } else {\n                    out_string(c, \"ERROR failed to stop lru crawler thread\");\n                }\n            } else {\n                out_string(c, \"ERROR\");\n            }\n            return;\n        } else {\n            out_string(c, \"ERROR\");\n        }\n    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, \"watch\") == 0) {\n        if (resp_has_stack(c)) {\n            out_string(c, \"ERROR cannot pipeline other commands before watch\");\n            return;\n        }\n        process_watch_command(c, tokens, ntokens);\n    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, \"cache_memlimit\") == 0)) {\n        process_memlimit_command(c, tokens, ntokens);\n    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, \"verbosity\") == 0)) {\n        process_verbosity_command(c, tokens, ntokens);\n    } else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, \"lru\") == 0) {\n        process_lru_command(c, tokens, ntokens);\n#ifdef MEMCACHED_DEBUG\n    // commands which exist only for testing the memcached's security protection\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"misbehave\") == 0)) {\n        process_misbehave_command(c);\n#endif\n#ifdef EXTSTORE\n    } else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, \"extstore\") == 0) {\n        process_extstore_command(c, tokens, ntokens);\n#endif\n#ifdef TLS\n    } else if (ntokens == 2 && strcmp(tokens[COMMAND_TOKEN].value, \"refresh_certs\") == 0) {\n        set_noreply_maybe(c, tokens, ntokens);\n        char *errmsg = NULL;\n        if (refresh_certs(&errmsg)) {\n            out_string(c, \"OK\");\n        } else {\n            write_and_free(c, errmsg, strlen(errmsg));\n        }\n        return;\n#endif\n    } else {\n        if (ntokens >= 2 && strncmp(tokens[ntokens - 2].value, \"HTTP/\", 5) == 0) {\n            conn_set_state(c, conn_closing);\n        } else {\n            out_string(c, \"ERROR\");\n        }\n    }\n    return;\n}\n\nstatic int try_read_command_negotiate(conn *c) {\n    assert(c->protocol == negotiating_prot);\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n        c->protocol = binary_prot;\n        c->try_read_command = try_read_command_binary;\n    } else {\n        // authentication doesn't work with negotiated protocol.\n        c->protocol = ascii_prot;\n        c->try_read_command = try_read_command_ascii;\n    }\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,\n                prot_text(c->protocol));\n    }\n\n    return c->try_read_command(c);\n}\n\nstatic int try_read_command_udp(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n        c->protocol = binary_prot;\n        return try_read_command_binary(c);\n    } else {\n        c->protocol = ascii_prot;\n        return try_read_command_ascii(c);\n    }\n}\n\nstatic int try_read_command_binary(conn *c) {\n    /* Do we have the complete packet header? */\n    if (c->rbytes < sizeof(c->binary_header)) {\n        /* need more data! */\n        return 0;\n    } else {\n        memcpy(&c->binary_header, c->rcurr, sizeof(c->binary_header));\n        protocol_binary_request_header* req;\n        req = &c->binary_header;\n\n        if (settings.verbose > 1) {\n            /* Dump the packet before we convert it to host order */\n            int ii;\n            fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);\n            for (ii = 0; ii < sizeof(req->bytes); ++ii) {\n                if (ii % 4 == 0) {\n                    fprintf(stderr, \"\\n<%d   \", c->sfd);\n                }\n                fprintf(stderr, \" 0x%02x\", req->bytes[ii]);\n            }\n            fprintf(stderr, \"\\n\");\n        }\n\n        c->binary_header = *req;\n        c->binary_header.request.keylen = ntohs(req->request.keylen);\n        c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n        c->binary_header.request.cas = ntohll(req->request.cas);\n\n        if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {\n            if (settings.verbose) {\n                fprintf(stderr, \"Invalid magic:  %x\\n\",\n                        c->binary_header.request.magic);\n            }\n            conn_set_state(c, conn_closing);\n            return -1;\n        }\n\n        uint8_t extlen = c->binary_header.request.extlen;\n        uint16_t keylen = c->binary_header.request.keylen;\n        if (c->rbytes < keylen + extlen + sizeof(c->binary_header)) {\n            // Still need more bytes. Let try_read_network() realign the\n            // read-buffer and fetch more data as necessary.\n            return 0;\n        }\n\n        if (!resp_start(c)) {\n            conn_set_state(c, conn_closing);\n            return -1;\n        }\n\n        c->cmd = c->binary_header.request.opcode;\n        c->keylen = c->binary_header.request.keylen;\n        c->opaque = c->binary_header.request.opaque;\n        /* clear the returned cas value */\n        c->cas = 0;\n\n        c->last_cmd_time = current_time;\n        // sigh. binprot has no \"largest possible extlen\" define, and I don't\n        // want to refactor a ton of code either. Header is only ever used out\n        // of c->binary_header, but the extlen stuff is used for the latter\n        // bytes. Just wastes 24 bytes on the stack this way.\n        char extbuf[sizeof(c->binary_header) + BIN_MAX_EXTLEN+1];\n        memcpy(extbuf + sizeof(c->binary_header), c->rcurr + sizeof(c->binary_header),\n                extlen > BIN_MAX_EXTLEN ? BIN_MAX_EXTLEN : extlen);\n        c->rbytes -= sizeof(c->binary_header) + extlen + keylen;\n        c->rcurr += sizeof(c->binary_header) + extlen + keylen;\n\n        dispatch_bin_command(c, extbuf);\n    }\n\n    return 1;\n}\n\nstatic int try_read_command_asciiauth(conn *c) {\n    token_t tokens[MAX_TOKENS];\n    size_t ntokens;\n    char *cont = NULL;\n\n    if (!c->resp) {\n        if (!resp_start(c)) {\n            conn_set_state(c, conn_closing);\n            return 1;\n        }\n    }\n\n    // TODO: move to another function.\n    if (!c->sasl_started) {\n        char *el;\n        uint32_t size = 0;\n\n        // impossible for the auth command to be this short.\n        if (c->rbytes < 2)\n            return 0;\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n\n        // If no newline after 1k, getting junk data, close out.\n        if (!el) {\n            if (c->rbytes > 1024) {\n                conn_set_state(c, conn_closing);\n                return 1;\n            }\n            return 0;\n        }\n\n        // Looking for: \"set foo 0 0 N\\r\\nuser pass\\r\\n\"\n        // key, flags, and ttl are ignored. N is used to see if we have the rest.\n\n        // so tokenize doesn't walk past into the value.\n        // it's fine to leave the \\r in, as strtoul will stop at it.\n        *el = '\\0';\n\n        ntokens = tokenize_command(c->rcurr, tokens, MAX_TOKENS);\n        // ensure the buffer is consumed.\n        c->rbytes -= (el - c->rcurr) + 1;\n        c->rcurr += (el - c->rcurr) + 1;\n\n        // final token is a NULL ender, so we have one more than expected.\n        if (ntokens < 6\n                || strcmp(tokens[0].value, \"set\") != 0\n                || !safe_strtoul(tokens[4].value, &size)) {\n            out_string(c, \"CLIENT_ERROR unauthenticated\");\n            return 1;\n        }\n\n        // we don't actually care about the key at all; it can be anything.\n        // we do care about the size of the remaining read.\n        c->rlbytes = size + 2;\n\n        c->sasl_started = true; // reuse from binprot sasl, but not sasl :)\n    }\n\n    if (c->rbytes < c->rlbytes) {\n        // need more bytes.\n        return 0;\n    }\n\n    cont = c->rcurr;\n    // advance buffer. no matter what we're stopping.\n    c->rbytes -= c->rlbytes;\n    c->rcurr += c->rlbytes;\n    c->sasl_started = false;\n\n    // must end with \\r\\n\n    // NB: I thought ASCII sets also worked with just \\n, but according to\n    // complete_nread_ascii only \\r\\n is valid.\n    if (strncmp(cont + c->rlbytes - 2, \"\\r\\n\", 2) != 0) {\n        out_string(c, \"CLIENT_ERROR bad command line termination\");\n        return 1;\n    }\n\n    // payload should be \"user pass\", so we can use the tokenizer.\n    cont[c->rlbytes - 2] = '\\0';\n    ntokens = tokenize_command(cont, tokens, MAX_TOKENS);\n\n    if (ntokens < 3) {\n        out_string(c, \"CLIENT_ERROR bad authentication token format\");\n        return 1;\n    }\n\n    if (authfile_check(tokens[0].value, tokens[1].value) == 1) {\n        out_string(c, \"STORED\");\n        c->authenticated = true;\n        c->try_read_command = try_read_command_ascii;\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.auth_cmds++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n    } else {\n        out_string(c, \"CLIENT_ERROR authentication failure\");\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.auth_cmds++;\n        c->thread->stats.auth_errors++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n    }\n\n    return 1;\n}\n\nstatic int try_read_command_ascii(conn *c) {\n    char *el, *cont;\n\n    if (c->rbytes == 0)\n        return 0;\n\n    el = memchr(c->rcurr, '\\n', c->rbytes);\n    if (!el) {\n        if (c->rbytes > 1024) {\n            /*\n             * We didn't have a '\\n' in the first k. This _has_ to be a\n             * large multiget, if not we should just nuke the connection.\n             */\n            char *ptr = c->rcurr;\n            while (*ptr == ' ') { /* ignore leading whitespaces */\n                ++ptr;\n            }\n\n            if (ptr - c->rcurr > 100 ||\n                (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n\n                conn_set_state(c, conn_closing);\n                return 1;\n            }\n\n            // ASCII multigets are unbound, so our fixed size rbuf may not\n            // work for this particular workload... For backcompat we'll use a\n            // malloc/realloc/free routine just for this.\n            if (!c->rbuf_malloced) {\n                if (!rbuf_switch_to_malloc(c)) {\n                    conn_set_state(c, conn_closing);\n                    return 1;\n                }\n            }\n        }\n\n        return 0;\n    }\n    cont = el + 1;\n    if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n        el--;\n    }\n    *el = '\\0';\n\n    assert(cont <= (c->rcurr + c->rbytes));\n\n    c->last_cmd_time = current_time;\n    process_command(c, c->rcurr);\n\n    c->rbytes -= (cont - c->rcurr);\n    c->rcurr = cont;\n\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n\n    return 1;\n}\n\n/*\n * read a UDP request.\n */\nstatic enum try_read_result try_read_udp(conn *c) {\n    int res;\n\n    assert(c != NULL);\n\n    c->request_addr_size = sizeof(c->request_addr);\n    res = recvfrom(c->sfd, c->rbuf, c->rsize,\n                   0, (struct sockaddr *)&c->request_addr,\n                   &c->request_addr_size);\n    if (res > 8) {\n        unsigned char *buf = (unsigned char *)c->rbuf;\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.bytes_read += res;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        /* Beginning of UDP packet is the request ID; save it. */\n        c->request_id = buf[0] * 256 + buf[1];\n\n        /* If this is a multi-packet request, drop it. */\n        if (buf[4] != 0 || buf[5] != 1) {\n            out_string(c, \"SERVER_ERROR multi-packet request not supported\");\n            return READ_NO_DATA_RECEIVED;\n        }\n\n        /* Don't care about any of the rest of the header. */\n        res -= 8;\n        memmove(c->rbuf, c->rbuf + 8, res);\n\n        c->rbytes = res;\n        c->rcurr = c->rbuf;\n        return READ_DATA_RECEIVED;\n    }\n    return READ_NO_DATA_RECEIVED;\n}\n\n/*\n * read from network as much as we can, handle buffer overflow and connection\n * close.\n * before reading, move the remaining incomplete fragment of a command\n * (if any) to the beginning of the buffer.\n *\n * To protect us from someone flooding a connection with bogus data causing\n * the connection to eat up all available memory, break out and start looking\n * at the data I've got after a number of reallocs...\n *\n * @return enum try_read_result\n */\nstatic enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n    int num_allocs = 0;\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) /* otherwise there's nothing to copy */\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        // TODO: move to rbuf_* func?\n        if (c->rbytes >= c->rsize && c->rbuf_malloced) {\n            if (num_allocs == 4) {\n                return gotdata;\n            }\n            ++num_allocs;\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                STATS_LOCK();\n                stats.malloc_fails++;\n                STATS_UNLOCK();\n                if (settings.verbose > 0) {\n                    fprintf(stderr, \"Couldn't realloc input buffer\\n\");\n                }\n                c->rbytes = 0; /* ignore what we read */\n                out_of_memory(c, \"SERVER_ERROR out of memory reading request\");\n                c->close_after_write = true;\n                return READ_MEMORY_ERROR;\n            }\n            c->rcurr = c->rbuf = new_rbuf;\n            c->rsize *= 2;\n        }\n\n        int avail = c->rsize - c->rbytes;\n        res = c->read(c, c->rbuf + c->rbytes, avail);\n        if (res > 0) {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.bytes_read += res;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n            gotdata = READ_DATA_RECEIVED;\n            c->rbytes += res;\n            if (res == avail && c->rbuf_malloced) {\n                // Resize rbuf and try a few times if huge ascii multiget.\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (res == 0) {\n            return READ_ERROR;\n        }\n        if (res == -1) {\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                break;\n            }\n            return READ_ERROR;\n        }\n    }\n    return gotdata;\n}\n\nstatic bool update_event(conn *c, const int new_flags) {\n    assert(c != NULL);\n\n    struct event_base *base = c->event.ev_base;\n    if (c->ev_flags == new_flags)\n        return true;\n    if (event_del(&c->event) == -1) return false;\n    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = new_flags;\n    if (event_add(&c->event, 0) == -1) return false;\n    return true;\n}\n\n/*\n * Sets whether we are listening for new connections or not.\n */\nvoid do_accept_new_conns(const bool do_accept) {\n    conn *next;\n\n    for (next = listen_conn; next; next = next->next) {\n        if (do_accept) {\n            update_event(next, EV_READ | EV_PERSIST);\n            if (listen(next->sfd, settings.backlog) != 0) {\n                perror(\"listen\");\n            }\n        }\n        else {\n            update_event(next, 0);\n            if (listen(next->sfd, 0) != 0) {\n                perror(\"listen\");\n            }\n        }\n    }\n\n    if (do_accept) {\n        struct timeval maxconns_exited;\n        uint64_t elapsed_us;\n        gettimeofday(&maxconns_exited,NULL);\n        STATS_LOCK();\n        elapsed_us =\n            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000\n            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);\n        stats.time_in_listen_disabled_us += elapsed_us;\n        stats_state.accepting_conns = true;\n        STATS_UNLOCK();\n    } else {\n        STATS_LOCK();\n        stats_state.accepting_conns = false;\n        gettimeofday(&stats.maxconns_entered,NULL);\n        stats.listen_disabled_num++;\n        STATS_UNLOCK();\n        allow_new_conns = false;\n        maxconns_handler(-42, 0, 0);\n    }\n}\n\n#define TRANSMIT_ONE_RESP true\n#define TRANSMIT_ALL_RESP false\nstatic int _transmit_pre(conn *c, struct iovec *iovs, int iovused, bool one_resp) {\n    mc_resp *resp = c->resp_head;\n    while (resp && iovused + resp->iovcnt < IOV_MAX-1) {\n        if (resp->skip) {\n            // Don't actually unchain the resp obj here since it's singly-linked.\n            // Just let the post function handle it linearly.\n            resp = resp->next;\n            continue;\n        }\n        if (resp->chunked_data_iov) {\n            // Handle chunked items specially.\n            // They spend much more time in send so we can be a bit wasteful\n            // in rebuilding iovecs for them.\n            item_chunk *ch = (item_chunk *)ITEM_schunk((item *)resp->iov[resp->chunked_data_iov].iov_base);\n            int x;\n            for (x = 0; x < resp->iovcnt; x++) {\n                // This iov is tracking how far we've copied so far.\n                if (x == resp->chunked_data_iov) {\n                    int done = resp->chunked_total - resp->iov[x].iov_len;\n                    // Start from the len to allow binprot to cut the \\r\\n\n                    int todo = resp->iov[x].iov_len;\n                    while (ch && todo > 0 && iovused < IOV_MAX-1) {\n                        int skip = 0;\n                        if (!ch->used) {\n                            ch = ch->next;\n                            continue;\n                        }\n                        // Skip parts we've already sent.\n                        if (done >= ch->used) {\n                            done -= ch->used;\n                            ch = ch->next;\n                            continue;\n                        } else if (done) {\n                            skip = done;\n                            done = 0;\n                        }\n                        iovs[iovused].iov_base = ch->data + skip;\n                        // Stupid binary protocol makes this go negative.\n                        iovs[iovused].iov_len = ch->used - skip > todo ? todo : ch->used - skip;\n                        iovused++;\n                        todo -= ch->used - skip;\n                        ch = ch->next;\n                    }\n                } else {\n                    iovs[iovused].iov_base = resp->iov[x].iov_base;\n                    iovs[iovused].iov_len = resp->iov[x].iov_len;\n                    iovused++;\n                }\n                if (iovused >= IOV_MAX-1)\n                    break;\n            }\n        } else {\n            memcpy(&iovs[iovused], resp->iov, sizeof(struct iovec)*resp->iovcnt);\n            iovused += resp->iovcnt;\n        }\n\n        // done looking at first response, walk down the chain.\n        resp = resp->next;\n        // used for UDP mode: UDP cannot send multiple responses per packet.\n        if (one_resp)\n            break;\n    }\n    return iovused;\n}\n\n/*\n * Decrements and completes responses based on how much data was transmitted.\n * Takes the connection and current result bytes.\n */\nstatic void _transmit_post(conn *c, ssize_t res) {\n    // We've written some of the data. Remove the completed\n    // responses from the list of pending writes.\n    mc_resp *resp = c->resp_head;\n    while (resp) {\n        int x;\n        if (resp->skip) {\n            resp = resp_finish(c, resp);\n            continue;\n        }\n\n        // fastpath check. all small responses should cut here.\n        if (res >= resp->tosend) {\n            res -= resp->tosend;\n            resp = resp_finish(c, resp);\n            continue;\n        }\n\n        // it's fine to re-check iov's that were zeroed out before.\n        for (x = 0; x < resp->iovcnt; x++) {\n            struct iovec *iov = &resp->iov[x];\n            if (res >= iov->iov_len) {\n                resp->tosend -= iov->iov_len;\n                res -= iov->iov_len;\n                iov->iov_len = 0;\n            } else {\n                // Dumb special case for chunked items. Currently tracking\n                // where to inject the chunked item via iov_base.\n                // Extra not-great since chunked items can't be the first\n                // index, so we have to check for non-zero c_d_iov first.\n                if (!resp->chunked_data_iov || x != resp->chunked_data_iov) {\n                    iov->iov_base = (char *)iov->iov_base + res;\n                }\n                iov->iov_len -= res;\n                resp->tosend -= res;\n                res = 0;\n                break;\n            }\n        }\n\n        // are we done with this response object?\n        if (resp->tosend == 0) {\n            resp = resp_finish(c, resp);\n        } else {\n            // Jammed up here. This is the new head.\n            break;\n        }\n    }\n}\n\n/*\n * Transmit the next chunk of data from our list of msgbuf structures.\n *\n * Returns:\n *   TRANSMIT_COMPLETE   All done writing.\n *   TRANSMIT_INCOMPLETE More data remaining to write.\n *   TRANSMIT_SOFT_ERROR Can't write any more right now.\n *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)\n */\nstatic enum transmit_result transmit(conn *c) {\n    assert(c != NULL);\n    struct iovec iovs[IOV_MAX];\n    struct msghdr msg;\n    int iovused = 0;\n\n    // init the msg.\n    memset(&msg, 0, sizeof(struct msghdr));\n    msg.msg_iov = iovs;\n\n    iovused = _transmit_pre(c, iovs, iovused, TRANSMIT_ALL_RESP);\n\n    // Alright, send.\n    ssize_t res;\n    msg.msg_iovlen = iovused;\n    res = c->sendmsg(c, &msg, 0);\n    if (res >= 0) {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.bytes_written += res;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        // Decrement any partial IOV's and complete any finished resp's.\n        _transmit_post(c, res);\n\n        if (c->resp_head) {\n            return TRANSMIT_INCOMPLETE;\n        } else {\n            return TRANSMIT_COMPLETE;\n        }\n    }\n\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n        if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n            if (settings.verbose > 0)\n                fprintf(stderr, \"Couldn't update event\\n\");\n            conn_set_state(c, conn_closing);\n            return TRANSMIT_HARD_ERROR;\n        }\n        return TRANSMIT_SOFT_ERROR;\n    }\n    /* if res == -1 and error is not EAGAIN or EWOULDBLOCK,\n       we have a real error, on which we close the connection */\n    if (settings.verbose > 0)\n        perror(\"Failed to write, and not due to blocking\");\n\n    conn_set_state(c, conn_closing);\n    return TRANSMIT_HARD_ERROR;\n}\n\nstatic void build_udp_header(unsigned char *hdr, mc_resp *resp) {\n    // We need to communicate the total number of packets\n    // If this isn't set, it's the first time this response is building a udp\n    // header, so \"tosend\" must be static.\n    if (!resp->udp_total) {\n        uint32_t total;\n        total = resp->tosend / UDP_MAX_PAYLOAD_SIZE;\n        if (resp->tosend % UDP_MAX_PAYLOAD_SIZE)\n            total++;\n        // The spec doesn't really say what we should do here. It's _probably_\n        // better to bail out?\n        if (total > USHRT_MAX) {\n            total = USHRT_MAX;\n        }\n        resp->udp_total = total;\n    }\n\n    // TODO: why wasn't this hto*'s and casts?\n    // this ends up sending UDP hdr data specifically in host byte order.\n    *hdr++ = resp->request_id / 256;\n    *hdr++ = resp->request_id % 256;\n    *hdr++ = resp->udp_sequence / 256;\n    *hdr++ = resp->udp_sequence % 256;\n    *hdr++ = resp->udp_total / 256;\n    *hdr++ = resp->udp_total % 256;\n    *hdr++ = 0;\n    *hdr++ = 0;\n    resp->udp_sequence++;\n}\n\n/*\n * UDP specific transmit function. Uses its own function rather than check\n * IS_UDP() five times. If we ever implement sendmmsg or similar support they\n * will diverge even more.\n * Does not use TLS.\n *\n * Returns:\n *   TRANSMIT_COMPLETE   All done writing.\n *   TRANSMIT_INCOMPLETE More data remaining to write.\n *   TRANSMIT_SOFT_ERROR Can't write any more right now.\n *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)\n */\nstatic enum transmit_result transmit_udp(conn *c) {\n    assert(c != NULL);\n    struct iovec iovs[IOV_MAX];\n    struct msghdr msg;\n    mc_resp *resp;\n    int iovused = 0;\n    unsigned char udp_hdr[UDP_HEADER_SIZE];\n\n    // We only send one UDP packet per call (ugh), so we can only operate on a\n    // single response at a time.\n    resp = c->resp_head;\n\n    if (!resp) {\n        return TRANSMIT_COMPLETE;\n    }\n\n    if (resp->skip) {\n        resp = resp_finish(c, resp);\n        return TRANSMIT_INCOMPLETE;\n    }\n\n    // clear the message and initialize it.\n    memset(&msg, 0, sizeof(struct msghdr));\n    msg.msg_iov = iovs;\n\n    // the UDP source to return to.\n    msg.msg_name = &resp->request_addr;\n    msg.msg_namelen = resp->request_addr_size;\n\n    // First IOV is the custom UDP header.\n    iovs[0].iov_base = udp_hdr;\n    iovs[0].iov_len = UDP_HEADER_SIZE;\n    build_udp_header(udp_hdr, resp);\n    iovused++;\n\n    // Fill the IOV's the standard way.\n    // TODO: might get a small speedup if we let it break early with a length\n    // limit.\n    iovused = _transmit_pre(c, iovs, iovused, TRANSMIT_ONE_RESP);\n\n    // Clip the IOV's to the max UDP packet size.\n    // If we add support for send_mmsg, this can be where we split msg's.\n    {\n        int x = 0;\n        int len = 0;\n        for (x = 0; x < iovused; x++) {\n            if (len + iovs[x].iov_len >= UDP_MAX_PAYLOAD_SIZE) {\n                iovs[x].iov_len = UDP_MAX_PAYLOAD_SIZE - len;\n                x++;\n                break;\n            } else {\n                len += iovs[x].iov_len;\n            }\n        }\n        iovused = x;\n    }\n\n    ssize_t res;\n    msg.msg_iovlen = iovused;\n    // NOTE: uses system sendmsg since we have no support for indirect UDP.\n    res = sendmsg(c->sfd, &msg, 0);\n    if (res >= 0) {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.bytes_written += res;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        // Ignore the header size from forwarding the IOV's\n        res -= UDP_HEADER_SIZE;\n\n        // Decrement any partial IOV's and complete any finished resp's.\n        _transmit_post(c, res);\n\n        if (c->resp_head) {\n            return TRANSMIT_INCOMPLETE;\n        } else {\n            return TRANSMIT_COMPLETE;\n        }\n    }\n\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n        if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n            if (settings.verbose > 0)\n                fprintf(stderr, \"Couldn't update event\\n\");\n            conn_set_state(c, conn_closing);\n            return TRANSMIT_HARD_ERROR;\n        }\n        return TRANSMIT_SOFT_ERROR;\n    }\n    /* if res == -1 and error is not EAGAIN or EWOULDBLOCK,\n       we have a real error, on which we close the connection */\n    if (settings.verbose > 0)\n        perror(\"Failed to write, and not due to blocking\");\n\n    conn_set_state(c, conn_read);\n    return TRANSMIT_HARD_ERROR;\n}\n\n\n/* Does a looped read to fill data chunks */\n/* TODO: restrict number of times this can loop.\n * Also, benchmark using readv's.\n */\nstatic int read_into_chunked_item(conn *c) {\n    int total = 0;\n    int res;\n    assert(c->rcurr != c->ritem);\n\n    while (c->rlbytes > 0) {\n        item_chunk *ch = (item_chunk *)c->ritem;\n        if (ch->size == ch->used) {\n            // FIXME: ch->next is currently always 0. remove this?\n            if (ch->next) {\n                c->ritem = (char *) ch->next;\n            } else {\n                /* Allocate next chunk. Binary protocol needs 2b for \\r\\n */\n                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +\n                       ((c->protocol == binary_prot) ? 2 : 0));\n                if (!c->ritem) {\n                    // We failed an allocation. Let caller handle cleanup.\n                    total = -2;\n                    break;\n                }\n                // ritem has new chunk, restart the loop.\n                continue;\n                //assert(c->rlbytes == 0);\n            }\n        }\n\n        int unused = ch->size - ch->used;\n        /* first check if we have leftovers in the conn_read buffer */\n        if (c->rbytes > 0) {\n            total = 0;\n            int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;\n            tocopy = tocopy > unused ? unused : tocopy;\n            if (c->ritem != c->rcurr) {\n                memmove(ch->data + ch->used, c->rcurr, tocopy);\n            }\n            total += tocopy;\n            c->rlbytes -= tocopy;\n            c->rcurr += tocopy;\n            c->rbytes -= tocopy;\n            ch->used += tocopy;\n            if (c->rlbytes == 0) {\n                break;\n            }\n        } else {\n            /*  now try reading from the socket */\n            res = c->read(c, ch->data + ch->used,\n                    (unused > c->rlbytes ? c->rlbytes : unused));\n            if (res > 0) {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.bytes_read += res;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                ch->used += res;\n                total += res;\n                c->rlbytes -= res;\n            } else {\n                /* Reset total to the latest result so caller can handle it */\n                total = res;\n                break;\n            }\n        }\n    }\n\n    /* At some point I will be able to ditch the \\r\\n from item storage and\n       remove all of these kludges.\n       The above binprot check ensures inline space for \\r\\n, but if we do\n       exactly enough allocs there will be no additional chunk for \\r\\n.\n     */\n    if (c->rlbytes == 0 && c->protocol == binary_prot && total >= 0) {\n        item_chunk *ch = (item_chunk *)c->ritem;\n        if (ch->size - ch->used < 2) {\n            c->ritem = (char *) do_item_alloc_chunk(ch, 2);\n            if (!c->ritem) {\n                total = -2;\n            }\n        }\n    }\n    return total;\n}\n\nstatic void drive_machine(conn *c) {\n    bool stop = false;\n    int sfd;\n    socklen_t addrlen;\n    struct sockaddr_storage addr;\n    int nreqs = settings.reqs_per_event;\n    int res;\n    const char *str;\n#ifdef HAVE_ACCEPT4\n    static int  use_accept4 = 1;\n#else\n    static int  use_accept4 = 0;\n#endif\n\n    assert(c != NULL);\n\n    while (!stop) {\n\n        switch(c->state) {\n        case conn_listening:\n            addrlen = sizeof(addr);\n#ifdef HAVE_ACCEPT4\n            if (use_accept4) {\n                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);\n            } else {\n                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);\n            }\n#else\n            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);\n#endif\n            if (sfd == -1) {\n                if (use_accept4 && errno == ENOSYS) {\n                    use_accept4 = 0;\n                    continue;\n                }\n                perror(use_accept4 ? \"accept4()\" : \"accept()\");\n                if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                    /* these are transient, so don't log anything */\n                    stop = true;\n                } else if (errno == EMFILE) {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Too many open connections\\n\");\n                    accept_new_conns(false);\n                    stop = true;\n                } else {\n                    perror(\"accept()\");\n                    stop = true;\n                }\n                break;\n            }\n            if (!use_accept4) {\n                if (fcntl(sfd, F_SETFL, fcntl(sfd, F_GETFL) | O_NONBLOCK) < 0) {\n                    perror(\"setting O_NONBLOCK\");\n                    close(sfd);\n                    break;\n                }\n            }\n\n            bool reject;\n            if (settings.maxconns_fast) {\n                STATS_LOCK();\n                reject = stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1;\n                if (reject) {\n                    stats.rejected_conns++;\n                }\n                STATS_UNLOCK();\n            } else {\n                reject = false;\n            }\n\n            if (reject) {\n                str = \"ERROR Too many open connections\\r\\n\";\n                res = write(sfd, str, strlen(str));\n                close(sfd);\n            } else {\n                void *ssl_v = NULL;\n#ifdef TLS\n                SSL *ssl = NULL;\n                if (c->ssl_enabled) {\n                    assert(IS_TCP(c->transport) && settings.ssl_enabled);\n\n                    if (settings.ssl_ctx == NULL) {\n                        if (settings.verbose) {\n                            fprintf(stderr, \"SSL context is not initialized\\n\");\n                        }\n                        close(sfd);\n                        break;\n                    }\n                    SSL_LOCK();\n                    ssl = SSL_new(settings.ssl_ctx);\n                    SSL_UNLOCK();\n                    if (ssl == NULL) {\n                        if (settings.verbose) {\n                            fprintf(stderr, \"Failed to created the SSL object\\n\");\n                        }\n                        close(sfd);\n                        break;\n                    }\n                    SSL_set_fd(ssl, sfd);\n                    int ret = SSL_accept(ssl);\n                    if (ret <= 0) {\n                        int err = SSL_get_error(ssl, ret);\n                        if (err == SSL_ERROR_SYSCALL || err == SSL_ERROR_SSL) {\n                            if (settings.verbose) {\n                                fprintf(stderr, \"SSL connection failed with error code : %d : %s\\n\", err, strerror(errno));\n                            }\n                            SSL_free(ssl);\n                            close(sfd);\n                            STATS_LOCK();\n                            stats.ssl_handshake_errors++;\n                            STATS_UNLOCK();\n                            break;\n                        }\n                    }\n                }\n                ssl_v = (void*) ssl;\n#endif\n\n                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,\n                                     READ_BUFFER_CACHED, c->transport, ssl_v);\n            }\n\n            stop = true;\n            break;\n\n        case conn_waiting:\n            rbuf_release(c);\n            if (!update_event(c, EV_READ | EV_PERSIST)) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't update event\\n\");\n                conn_set_state(c, conn_closing);\n                break;\n            }\n\n            conn_set_state(c, conn_read);\n            stop = true;\n            break;\n\n        case conn_read:\n            if (!IS_UDP(c->transport)) {\n                // Assign a read buffer if necessary.\n                if (!rbuf_alloc(c)) {\n                    // TODO: Some way to allow for temporary failures.\n                    conn_set_state(c, conn_closing);\n                    break;\n                }\n                res = try_read_network(c);\n            } else {\n                // UDP connections always have a static buffer.\n                res = try_read_udp(c);\n            }\n\n            switch (res) {\n            case READ_NO_DATA_RECEIVED:\n                conn_set_state(c, conn_waiting);\n                break;\n            case READ_DATA_RECEIVED:\n                conn_set_state(c, conn_parse_cmd);\n                break;\n            case READ_ERROR:\n                conn_set_state(c, conn_closing);\n                break;\n            case READ_MEMORY_ERROR: /* Failed to allocate more memory */\n                /* State already set by try_read_network */\n                break;\n            }\n            break;\n\n        case conn_parse_cmd:\n            c->noreply = false;\n            if (c->try_read_command(c) == 0) {\n                /* wee need more data! */\n                if (c->resp_head) {\n                    // Buffered responses waiting, flush in the meantime.\n                    conn_set_state(c, conn_mwrite);\n                } else {\n                    conn_set_state(c, conn_waiting);\n                }\n            }\n\n            break;\n\n        case conn_new_cmd:\n            /* Only process nreqs at a time to avoid starving other\n               connections */\n\n            --nreqs;\n            if (nreqs >= 0) {\n                reset_cmd_handler(c);\n            } else if (c->resp_head) {\n                // flush response pipe on yield.\n                conn_set_state(c, conn_mwrite);\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.conn_yields++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                if (c->rbytes > 0) {\n                    /* We have already read in data into the input buffer,\n                       so libevent will most likely not signal read events\n                       on the socket (unless more data is available. As a\n                       hack we should just put in a request to write data,\n                       because that should be possible ;-)\n                    */\n                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                        if (settings.verbose > 0)\n                            fprintf(stderr, \"Couldn't update event\\n\");\n                        conn_set_state(c, conn_closing);\n                        break;\n                    }\n                }\n                stop = true;\n            }\n            break;\n\n        case conn_nread:\n            if (c->rlbytes == 0) {\n                complete_nread(c);\n                break;\n            }\n\n            /* Check if rbytes < 0, to prevent crash */\n            if (c->rlbytes < 0) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"Invalid rlbytes to read: len %d\\n\", c->rlbytes);\n                }\n                conn_set_state(c, conn_closing);\n                break;\n            }\n\n            if ((((item *)c->item)->it_flags & ITEM_CHUNKED) == 0) {\n                /* first check if we have leftovers in the conn_read buffer */\n                if (c->rbytes > 0) {\n                    int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;\n                    memmove(c->ritem, c->rcurr, tocopy);\n                    c->ritem += tocopy;\n                    c->rlbytes -= tocopy;\n                    c->rcurr += tocopy;\n                    c->rbytes -= tocopy;\n                    if (c->rlbytes == 0) {\n                        break;\n                    }\n                }\n\n                /*  now try reading from the socket */\n                res = c->read(c, c->ritem, c->rlbytes);\n                if (res > 0) {\n                    pthread_mutex_lock(&c->thread->stats.mutex);\n                    c->thread->stats.bytes_read += res;\n                    pthread_mutex_unlock(&c->thread->stats.mutex);\n                    if (c->rcurr == c->ritem) {\n                        c->rcurr += res;\n                    }\n                    c->ritem += res;\n                    c->rlbytes -= res;\n                    break;\n                }\n            } else {\n                res = read_into_chunked_item(c);\n                if (res > 0)\n                    break;\n            }\n\n            if (res == 0) { /* end of stream */\n                conn_set_state(c, conn_closing);\n                break;\n            }\n\n            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n                if (!update_event(c, EV_READ | EV_PERSIST)) {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Couldn't update event\\n\");\n                    conn_set_state(c, conn_closing);\n                    break;\n                }\n                stop = true;\n                break;\n            }\n\n            /* Memory allocation failure */\n            if (res == -2) {\n                out_of_memory(c, \"SERVER_ERROR Out of memory during read\");\n                c->sbytes = c->rlbytes;\n                conn_set_state(c, conn_swallow);\n                // Ensure this flag gets cleared. It gets killed on conn_new()\n                // so any conn_closing is fine, calling complete_nread is\n                // fine. This swallow semms to be the only other case.\n                c->set_stale = false;\n                c->mset_res = false;\n                break;\n            }\n            /* otherwise we have a real error, on which we close the connection */\n            if (settings.verbose > 0) {\n                fprintf(stderr, \"Failed to read, and not due to blocking:\\n\"\n                        \"errno: %d %s \\n\"\n                        \"rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\\n\",\n                        errno, strerror(errno),\n                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,\n                        (int)c->rlbytes, (int)c->rsize);\n            }\n            conn_set_state(c, conn_closing);\n            break;\n\n        case conn_swallow:\n            /* we are reading sbytes and throwing them away */\n            if (c->sbytes <= 0) {\n                conn_set_state(c, conn_new_cmd);\n                break;\n            }\n\n            /* first check if we have leftovers in the conn_read buffer */\n            if (c->rbytes > 0) {\n                int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;\n                c->sbytes -= tocopy;\n                c->rcurr += tocopy;\n                c->rbytes -= tocopy;\n                break;\n            }\n\n            /*  now try reading from the socket */\n            res = c->read(c, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);\n            if (res > 0) {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.bytes_read += res;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                c->sbytes -= res;\n                break;\n            }\n            if (res == 0) { /* end of stream */\n                conn_set_state(c, conn_closing);\n                break;\n            }\n            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n                if (!update_event(c, EV_READ | EV_PERSIST)) {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Couldn't update event\\n\");\n                    conn_set_state(c, conn_closing);\n                    break;\n                }\n                stop = true;\n                break;\n            }\n            /* otherwise we have a real error, on which we close the connection */\n            if (settings.verbose > 0)\n                fprintf(stderr, \"Failed to read, and not due to blocking\\n\");\n            conn_set_state(c, conn_closing);\n            break;\n\n        case conn_write:\n        case conn_mwrite:\n#ifdef EXTSTORE\n            /* have side IO's that must process before transmit() can run.\n             * remove the connection from the worker thread and dispatch the\n             * IO queue\n             */\n            if (c->io_wrapleft) {\n                assert(c->io_queued == false);\n                assert(c->io_wraplist != NULL);\n                // TODO: create proper state for this condition\n                conn_set_state(c, conn_watch);\n                event_del(&c->event);\n                c->io_queued = true;\n                extstore_submit(c->thread->storage, &c->io_wraplist->io);\n                stop = true;\n                break;\n            }\n#endif\n            switch (!IS_UDP(c->transport) ? transmit(c) : transmit_udp(c)) {\n            case TRANSMIT_COMPLETE:\n                if (c->state == conn_mwrite) {\n                    // Free up IO wraps and any half-uploaded items.\n                    conn_release_items(c);\n                    conn_set_state(c, conn_new_cmd);\n                    if (c->close_after_write) {\n                        conn_set_state(c, conn_closing);\n                    }\n                } else {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Unexpected state %d\\n\", c->state);\n                    conn_set_state(c, conn_closing);\n                }\n                break;\n\n            case TRANSMIT_INCOMPLETE:\n            case TRANSMIT_HARD_ERROR:\n                break;                   /* Continue in state machine. */\n\n            case TRANSMIT_SOFT_ERROR:\n                stop = true;\n                break;\n            }\n            break;\n\n        case conn_closing:\n            if (IS_UDP(c->transport))\n                conn_cleanup(c);\n            else\n                conn_close(c);\n            stop = true;\n            break;\n\n        case conn_closed:\n            /* This only happens if dormando is an idiot. */\n            abort();\n            break;\n\n        case conn_watch:\n            /* We handed off our connection to the logger thread. */\n            stop = true;\n            break;\n        case conn_max_state:\n            assert(false);\n            break;\n        }\n    }\n\n    return;\n}\n\nvoid event_handler(const int fd, const short which, void *arg) {\n    conn *c;\n\n    c = (conn *)arg;\n    assert(c != NULL);\n\n    c->which = which;\n\n    /* sanity */\n    if (fd != c->sfd) {\n        if (settings.verbose > 0)\n            fprintf(stderr, \"Catastrophic: event fd doesn't match conn fd!\\n\");\n        conn_close(c);\n        return;\n    }\n\n    drive_machine(c);\n\n    /* wait for next event */\n    return;\n}\n\nstatic int new_socket(struct addrinfo *ai) {\n    int sfd;\n    int flags;\n\n    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {\n        return -1;\n    }\n\n    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||\n        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {\n        perror(\"setting O_NONBLOCK\");\n        close(sfd);\n        return -1;\n    }\n    return sfd;\n}\n\n\n/*\n * Sets a socket's send buffer size to the maximum allowed by the system.\n */\nstatic void maximize_sndbuf(const int sfd) {\n    socklen_t intsize = sizeof(int);\n    int last_good = 0;\n    int min, max, avg;\n    int old_size;\n\n    /* Start with the default size. */\n    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {\n        if (settings.verbose > 0)\n            perror(\"getsockopt(SO_SNDBUF)\");\n        return;\n    }\n\n    /* Binary-search for the real maximum. */\n    min = old_size;\n    max = MAX_SENDBUF_SIZE;\n\n    while (min <= max) {\n        avg = ((unsigned int)(min + max)) / 2;\n        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {\n            last_good = avg;\n            min = avg + 1;\n        } else {\n            max = avg - 1;\n        }\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"<%d send buffer was %d, now %d\\n\", sfd, old_size, last_good);\n}\n\n/**\n * Create a socket and bind it to a specific port number\n * @param interface the interface to bind to\n * @param port the port number to bind to\n * @param transport the transport protocol (TCP / UDP)\n * @param portnumber_file A filepointer to write the port numbers to\n *        when they are successfully added to the list of ports we\n *        listen on.\n */\nstatic int server_socket(const char *interface,\n                         int port,\n                         enum network_transport transport,\n                         FILE *portnumber_file, bool ssl_enabled) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct addrinfo *ai;\n    struct addrinfo *next;\n    struct addrinfo hints = { .ai_flags = AI_PASSIVE,\n                              .ai_family = AF_UNSPEC };\n    char port_buf[NI_MAXSERV];\n    int error;\n    int success = 0;\n    int flags =1;\n\n    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;\n\n    if (port == -1) {\n        port = 0;\n    }\n    snprintf(port_buf, sizeof(port_buf), \"%d\", port);\n    error= getaddrinfo(interface, port_buf, &hints, &ai);\n    if (error != 0) {\n        if (error != EAI_SYSTEM)\n          fprintf(stderr, \"getaddrinfo(): %s\\n\", gai_strerror(error));\n        else\n          perror(\"getaddrinfo()\");\n        return 1;\n    }\n\n    for (next= ai; next; next= next->ai_next) {\n        conn *listen_conn_add;\n        if ((sfd = new_socket(next)) == -1) {\n            /* getaddrinfo can return \"junk\" addresses,\n             * we make sure at least one works before erroring.\n             */\n            if (errno == EMFILE) {\n                /* ...unless we're out of fds */\n                perror(\"server_socket\");\n                exit(EX_OSERR);\n            }\n            continue;\n        }\n\n#ifdef IPV6_V6ONLY\n        if (next->ai_family == AF_INET6) {\n            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));\n            if (error != 0) {\n                perror(\"setsockopt\");\n                close(sfd);\n                continue;\n            }\n        }\n#endif\n\n        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n        if (IS_UDP(transport)) {\n            maximize_sndbuf(sfd);\n        } else {\n            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n            if (error != 0)\n                perror(\"setsockopt\");\n\n            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n            if (error != 0)\n                perror(\"setsockopt\");\n\n            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));\n            if (error != 0)\n                perror(\"setsockopt\");\n        }\n\n        if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {\n            if (errno != EADDRINUSE) {\n                perror(\"bind()\");\n                close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            close(sfd);\n            continue;\n        } else {\n            success++;\n            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {\n                perror(\"listen()\");\n                close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            if (portnumber_file != NULL &&\n                (next->ai_addr->sa_family == AF_INET ||\n                 next->ai_addr->sa_family == AF_INET6)) {\n                union {\n                    struct sockaddr_in in;\n                    struct sockaddr_in6 in6;\n                } my_sockaddr;\n                socklen_t len = sizeof(my_sockaddr);\n                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {\n                    if (next->ai_addr->sa_family == AF_INET) {\n                        fprintf(portnumber_file, \"%s INET: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in.sin_port));\n                    } else {\n                        fprintf(portnumber_file, \"%s INET6: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in6.sin6_port));\n                    }\n                }\n            }\n        }\n\n        if (IS_UDP(transport)) {\n            int c;\n\n            for (c = 0; c < settings.num_threads_per_udp; c++) {\n                /* Allocate one UDP file descriptor per worker thread;\n                 * this allows \"stats conns\" to separately list multiple\n                 * parallel UDP requests in progress.\n                 *\n                 * The dispatch code round-robins new connection requests\n                 * among threads, so this is guaranteed to assign one\n                 * FD to each thread.\n                 */\n                int per_thread_fd;\n                if (c == 0) {\n                    per_thread_fd = sfd;\n                } else {\n                    per_thread_fd = dup(sfd);\n                    if (per_thread_fd < 0) {\n                        perror(\"Failed to duplicate file descriptor\");\n                        exit(EXIT_FAILURE);\n                    }\n                }\n                dispatch_conn_new(per_thread_fd, conn_read,\n                                  EV_READ | EV_PERSIST,\n                                  UDP_READ_BUFFER_SIZE, transport, NULL);\n            }\n        } else {\n            if (!(listen_conn_add = conn_new(sfd, conn_listening,\n                                             EV_READ | EV_PERSIST, 1,\n                                             transport, main_base, NULL))) {\n                fprintf(stderr, \"failed to create listening connection\\n\");\n                exit(EXIT_FAILURE);\n            }\n#ifdef TLS\n            listen_conn_add->ssl_enabled = ssl_enabled;\n#else\n            assert(ssl_enabled == false);\n#endif\n            listen_conn_add->next = listen_conn;\n            listen_conn = listen_conn_add;\n        }\n    }\n\n    freeaddrinfo(ai);\n\n    /* Return zero iff we detected no errors in starting up connections */\n    return success == 0;\n}\n\nstatic int server_sockets(int port, enum network_transport transport,\n                          FILE *portnumber_file) {\n    bool ssl_enabled = false;\n\n#ifdef TLS\n    const char *notls = \"notls\";\n    ssl_enabled = settings.ssl_enabled;\n#endif\n\n    if (settings.inter == NULL) {\n        return server_socket(settings.inter, port, transport, portnumber_file, ssl_enabled);\n    } else {\n        // tokenize them and bind to each one of them..\n        char *b;\n        int ret = 0;\n        char *list = strdup(settings.inter);\n\n        if (list == NULL) {\n            fprintf(stderr, \"Failed to allocate memory for parsing server interface string\\n\");\n            return 1;\n        }\n        for (char *p = strtok_r(list, \";,\", &b);\n            p != NULL;\n            p = strtok_r(NULL, \";,\", &b)) {\n            int the_port = port;\n#ifdef TLS\n            ssl_enabled = settings.ssl_enabled;\n            // \"notls\" option is valid only when memcached is run with SSL enabled.\n            if (strncmp(p, notls, strlen(notls)) == 0) {\n                if (!settings.ssl_enabled) {\n                    fprintf(stderr, \"'notls' option is valid only when SSL is enabled\\n\");\n                    free(list);\n                    return 1;\n                }\n                ssl_enabled = false;\n                p += strlen(notls) + 1;\n            }\n#endif\n\n            char *h = NULL;\n            if (*p == '[') {\n                // expecting it to be an IPv6 address enclosed in []\n                // i.e. RFC3986 style recommended by RFC5952\n                char *e = strchr(p, ']');\n                if (e == NULL) {\n                    fprintf(stderr, \"Invalid IPV6 address: \\\"%s\\\"\", p);\n                    free(list);\n                    return 1;\n                }\n                h = ++p; // skip the opening '['\n                *e = '\\0';\n                p = ++e; // skip the closing ']'\n            }\n\n            char *s = strchr(p, ':');\n            if (s != NULL) {\n                // If no more semicolons - attempt to treat as port number.\n                // Otherwise the only valid option is an unenclosed IPv6 without port, until\n                // of course there was an RFC3986 IPv6 address previously specified -\n                // in such a case there is no good option, will just send it to fail as port number.\n                if (strchr(s + 1, ':') == NULL || h != NULL) {\n                    *s = '\\0';\n                    ++s;\n                    if (!safe_strtol(s, &the_port)) {\n                        fprintf(stderr, \"Invalid port number: \\\"%s\\\"\", s);\n                        free(list);\n                        return 1;\n                    }\n                }\n            }\n\n            if (h != NULL)\n                p = h;\n\n            if (strcmp(p, \"*\") == 0) {\n                p = NULL;\n            }\n            ret |= server_socket(p, the_port, transport, portnumber_file, ssl_enabled);\n        }\n        free(list);\n        return ret;\n    }\n}\n\nstatic int new_socket_unix(void) {\n    int sfd;\n    int flags;\n\n    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {\n        perror(\"socket()\");\n        return -1;\n    }\n\n    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||\n        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {\n        perror(\"setting O_NONBLOCK\");\n        close(sfd);\n        return -1;\n    }\n    return sfd;\n}\n\nstatic int server_socket_unix(const char *path, int access_mask) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct sockaddr_un addr;\n    struct stat tstat;\n    int flags =1;\n    int old_umask;\n\n    if (!path) {\n        return 1;\n    }\n\n    if ((sfd = new_socket_unix()) == -1) {\n        return 1;\n    }\n\n    /*\n     * Clean up a previous socket file if we left it around\n     */\n    if (lstat(path, &tstat) == 0) {\n        if (S_ISSOCK(tstat.st_mode))\n            unlink(path);\n    }\n\n    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n\n    /*\n     * the memset call clears nonstandard fields in some implementations\n     * that otherwise mess things up.\n     */\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n    assert(strcmp(addr.sun_path, path) == 0);\n    old_umask = umask( ~(access_mask&0777));\n    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n        perror(\"bind()\");\n        close(sfd);\n        umask(old_umask);\n        return 1;\n    }\n    umask(old_umask);\n    if (listen(sfd, settings.backlog) == -1) {\n        perror(\"listen()\");\n        close(sfd);\n        return 1;\n    }\n    if (!(listen_conn = conn_new(sfd, conn_listening,\n                                 EV_READ | EV_PERSIST, 1,\n                                 local_transport, main_base, NULL))) {\n        fprintf(stderr, \"failed to create listening connection\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    return 0;\n}\n\n/*\n * We keep the current time of day in a global variable that's updated by a\n * timer event. This saves us a bunch of time() system calls (we really only\n * need to get the time once a second, whereas there can be tens of thousands\n * of requests a second) and allows us to use server-start-relative timestamps\n * rather than absolute UNIX timestamps, a space savings on systems where\n * sizeof(time_t) > sizeof(unsigned int).\n */\nvolatile rel_time_t current_time;\nstatic struct event clockevent;\n#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)\nstatic bool monotonic = false;\nstatic int64_t monotonic_start;\n#endif\n\n/* libevent uses a monotonic clock when available for event scheduling. Aside\n * from jitter, simply ticking our internal timer here is accurate enough.\n * Note that users who are setting explicit dates for expiration times *must*\n * ensure their clocks are correct before starting memcached. */\nstatic void clock_handler(const int fd, const short which, void *arg) {\n    struct timeval t = {.tv_sec = 1, .tv_usec = 0};\n    static bool initialized = false;\n\n    if (initialized) {\n        /* only delete the event if it's actually there. */\n        evtimer_del(&clockevent);\n    } else {\n        initialized = true;\n    }\n\n    // While we're here, check for hash table expansion.\n    // This function should be quick to avoid delaying the timer.\n    assoc_start_expand(stats_state.curr_items);\n    // also, if HUP'ed we need to do some maintenance.\n    // for now that's just the authfile reload.\n    if (settings.sig_hup) {\n        settings.sig_hup = false;\n\n        authfile_load(settings.auth_file);\n    }\n\n    evtimer_set(&clockevent, clock_handler, 0);\n    event_base_set(main_base, &clockevent);\n    evtimer_add(&clockevent, &t);\n\n#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)\n    if (monotonic) {\n        struct timespec ts;\n        if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)\n            return;\n        current_time = (rel_time_t) (ts.tv_sec - monotonic_start);\n        return;\n    }\n#endif\n    {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        current_time = (rel_time_t) (tv.tv_sec - process_started);\n    }\n}\n\nstatic const char* flag_enabled_disabled(bool flag) {\n    return (flag ? \"enabled\" : \"disabled\");\n}\n\nstatic void verify_default(const char* param, bool condition) {\n    if (!condition) {\n        printf(\"Default value of [%s] has changed.\"\n            \" Modify the help text and default value check.\\n\", param);\n        exit(EXIT_FAILURE);\n    }\n}\n\nstatic void usage(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\");\n    printf(\"-p, --port=<num>          TCP port to listen on (default: %d)\\n\"\n           \"-U, --udp-port=<num>      UDP port to listen on (default: %d, off)\\n\"\n           \"-s, --unix-socket=<file>  UNIX socket to listen on (disables network support)\\n\"\n           \"-A, --enable-shutdown     enable ascii \\\"shutdown\\\" command\\n\"\n           \"-a, --unix-mask=<mask>    access mask for UNIX socket, in octal (default: %o)\\n\"\n           \"-l, --listen=<addr>       interface to listen on (default: INADDR_ANY)\\n\"\n#ifdef TLS\n           \"                          if TLS/SSL is enabled, 'notls' prefix can be used to\\n\"\n           \"                          disable for specific listeners (-l notls:<ip>:<port>) \\n\"\n#endif\n           \"-d, --daemon              run as a daemon\\n\"\n           \"-r, --enable-coredumps    maximize core file limit\\n\"\n           \"-u, --user=<user>         assume identity of <username> (only when run as root)\\n\"\n           \"-m, --memory-limit=<num>  item memory in megabytes (default: %lu)\\n\"\n           \"-M, --disable-evictions   return error on memory exhausted instead of evicting\\n\"\n           \"-c, --conn-limit=<num>    max simultaneous connections (default: %d)\\n\"\n           \"-k, --lock-memory         lock down all paged memory\\n\"\n           \"-v, --verbose             verbose (print errors/warnings while in event loop)\\n\"\n           \"-vv                       very verbose (also print client commands/responses)\\n\"\n           \"-vvv                      extremely verbose (internal state transitions)\\n\"\n           \"-h, --help                print this help and exit\\n\"\n           \"-i, --license             print memcached and libevent license\\n\"\n           \"-V, --version             print version and exit\\n\"\n           \"-P, --pidfile=<file>      save PID in <file>, only used with -d option\\n\"\n           \"-f, --slab-growth-factor=<num> chunk size growth factor (default: %2.2f)\\n\"\n           \"-n, --slab-min-size=<bytes> min space used for key+value+flags (default: %d)\\n\",\n           settings.port, settings.udpport, settings.access, (unsigned long) settings.maxbytes / (1 << 20),\n           settings.maxconns, settings.factor, settings.chunk_size);\n    verify_default(\"udp-port\",settings.udpport == 0);\n    printf(\"-L, --enable-largepages  try to use large memory pages (if available)\\n\");\n    printf(\"-D <char>     Use <char> as the delimiter between key prefixes and IDs.\\n\"\n           \"              This is used for per-prefix stats reporting. The default is\\n\"\n           \"              \\\"%c\\\" (colon). If this option is specified, stats collection\\n\"\n           \"              is turned on automatically; if not, then it may be turned on\\n\"\n           \"              by sending the \\\"stats detail on\\\" command to the server.\\n\",\n           settings.prefix_delimiter);\n    printf(\"-t, --threads=<num>       number of threads to use (default: %d)\\n\", settings.num_threads);\n    printf(\"-R, --max-reqs-per-event  maximum number of requests per event, limits the\\n\"\n           \"                          requests processed per connection to prevent \\n\"\n           \"                          starvation (default: %d)\\n\", settings.reqs_per_event);\n    printf(\"-C, --disable-cas         disable use of CAS\\n\");\n    printf(\"-b, --listen-backlog=<num> set the backlog queue limit (default: %d)\\n\", settings.backlog);\n    printf(\"-B, --protocol=<name>     protocol - one of ascii, binary, or auto (default: %s)\\n\",\n           prot_text(settings.binding_protocol));\n    printf(\"-I, --max-item-size=<num> adjusts max item size\\n\"\n           \"                          (default: %dm, min: %dk, max: %dm)\\n\",\n           settings.item_size_max/ (1 << 20), ITEM_SIZE_MAX_LOWER_LIMIT / (1 << 10),  ITEM_SIZE_MAX_UPPER_LIMIT / (1 << 20));\n#ifdef ENABLE_SASL\n    printf(\"-S, --enable-sasl         turn on Sasl authentication\\n\");\n#endif\n    printf(\"-F, --disable-flush-all   disable flush_all command\\n\");\n    printf(\"-X, --disable-dumping     disable stats cachedump and lru_crawler metadump\\n\");\n    printf(\"-W  --disable-watch       disable watch commands (live logging)\\n\");\n    printf(\"-Y, --auth-file=<file>    (EXPERIMENTAL) enable ASCII protocol authentication. format:\\n\"\n           \"                          user:pass\\\\nuser2:pass2\\\\n\\n\");\n    printf(\"-e, --memory-file=<file>  (EXPERIMENTAL) mmap a file for item memory.\\n\"\n           \"                          use only in ram disks or persistent memory mounts!\\n\"\n           \"                          enables restartable cache (stop with SIGUSR1)\\n\");\n#ifdef TLS\n    printf(\"-Z, --enable-ssl          enable TLS/SSL\\n\");\n#endif\n    printf(\"-o, --extended            comma separated list of extended options\\n\"\n           \"                          most options have a 'no_' prefix to disable\\n\"\n           \"   - maxconns_fast:       immediately close new connections after limit (default: %s)\\n\"\n           \"   - hashpower:           an integer multiplier for how large the hash\\n\"\n           \"                          table should be. normally grows at runtime. (default starts at: %d)\\n\"\n           \"                          set based on \\\"STAT hash_power_level\\\"\\n\"\n           \"   - tail_repair_time:    time in seconds for how long to wait before\\n\"\n           \"                          forcefully killing LRU tail item.\\n\"\n           \"                          disabled by default; very dangerous option.\\n\"\n           \"   - hash_algorithm:      the hash table algorithm\\n\"\n           \"                          default is murmur3 hash. options: jenkins, murmur3\\n\"\n           \"   - no_lru_crawler:      disable LRU Crawler background thread.\\n\"\n           \"   - lru_crawler_sleep:   microseconds to sleep between items\\n\"\n           \"                          default is %d.\\n\"\n           \"   - lru_crawler_tocrawl: max items to crawl per slab per run\\n\"\n           \"                          default is %u (unlimited)\\n\",\n           flag_enabled_disabled(settings.maxconns_fast), settings.hashpower_init,\n           settings.lru_crawler_sleep, settings.lru_crawler_tocrawl);\n    printf(\"   - resp_obj_mem_limit:  limit in megabytes for connection response objects.\\n\"\n           \"                          do not adjust unless you have high (100k+) conn. limits.\\n\"\n           \"                          0 means unlimited (default: %u)\\n\"\n           \"   - read_buf_mem_limit:  limit in megabytes for connection read buffers.\\n\"\n           \"                          do not adjust unless you have high (100k+) conn. limits.\\n\"\n           \"                          0 means unlimited (default: %u)\\n\",\n           settings.resp_obj_mem_limit,\n           settings.read_buf_mem_limit);\n    verify_default(\"resp_obj_mem_limit\", settings.resp_obj_mem_limit == 0);\n    verify_default(\"read_buf_mem_limit\", settings.read_buf_mem_limit == 0);\n    printf(\"   - no_lru_maintainer:   disable new LRU system + background thread.\\n\"\n           \"   - hot_lru_pct:         pct of slab memory to reserve for hot lru.\\n\"\n           \"                          (requires lru_maintainer, default pct: %d)\\n\"\n           \"   - warm_lru_pct:        pct of slab memory to reserve for warm lru.\\n\"\n           \"                          (requires lru_maintainer, default pct: %d)\\n\"\n           \"   - hot_max_factor:      items idle > cold lru age * drop from hot lru. (default: %.2f)\\n\"\n           \"   - warm_max_factor:     items idle > cold lru age * this drop from warm. (default: %.2f)\\n\"\n           \"   - temporary_ttl:       TTL's below get separate LRU, can't be evicted.\\n\"\n           \"                          (requires lru_maintainer, default: %d)\\n\"\n           \"   - idle_timeout:        timeout for idle connections. (default: %d, no timeout)\\n\",\n           settings.hot_lru_pct, settings.warm_lru_pct, settings.hot_max_factor, settings.warm_max_factor,\n           settings.temporary_ttl, settings.idle_timeout);\n    printf(\"   - slab_chunk_max:      (EXPERIMENTAL) maximum slab size in kilobytes. use extreme care. (default: %d)\\n\"\n           \"   - watcher_logbuf_size: size in kilobytes of per-watcher write buffer. (default: %u)\\n\"\n           \"   - worker_logbuf_size:  size in kilobytes of per-worker-thread buffer\\n\"\n           \"                          read by background thread, then written to watchers. (default: %u)\\n\"\n           \"   - track_sizes:         enable dynamic reports for 'stats sizes' command.\\n\"\n           \"   - no_hashexpand:       disables hash table expansion (dangerous)\\n\"\n           \"   - modern:              enables options which will be default in future.\\n\"\n           \"                          currently: nothing\\n\"\n           \"   - no_modern:           uses defaults of previous major version (1.4.x)\\n\",\n           settings.slab_chunk_size_max / (1 << 10), settings.logger_watcher_buf_size / (1 << 10),\n           settings.logger_buf_size / (1 << 10));\n    verify_default(\"tail_repair_time\", settings.tail_repair_time == TAIL_REPAIR_TIME_DEFAULT);\n    verify_default(\"lru_crawler_tocrawl\", settings.lru_crawler_tocrawl == 0);\n    verify_default(\"idle_timeout\", settings.idle_timeout == 0);\n#ifdef HAVE_DROP_PRIVILEGES\n    printf(\"   - drop_privileges:     enable dropping extra syscall privileges\\n\"\n           \"   - no_drop_privileges:  disable drop_privileges in case it causes issues with\\n\"\n           \"                          some customisation.\\n\"\n           \"                          (default is no_drop_privileges)\\n\");\n    verify_default(\"drop_privileges\", !settings.drop_privileges);\n#ifdef MEMCACHED_DEBUG\n    printf(\"   - relaxed_privileges:  running tests requires extra privileges. (default: %s)\\n\",\n           flag_enabled_disabled(settings.relaxed_privileges));\n#endif\n#endif\n#ifdef EXTSTORE\n    printf(\"\\n   - External storage (ext_*) related options (see: https://memcached.org/extstore)\\n\");\n    printf(\"   - ext_path:            file to write to for external storage.\\n\"\n           \"                          ie: ext_path=/mnt/d1/extstore:1G\\n\"\n           \"   - ext_page_size:       size in megabytes of storage pages. (default: %u)\\n\"\n           \"   - ext_wbuf_size:       size in megabytes of page write buffers. (default: %u)\\n\"\n           \"   - ext_threads:         number of IO threads to run. (default: %u)\\n\"\n           \"   - ext_item_size:       store items larger than this (bytes, default %u)\\n\"\n           \"   - ext_item_age:        store items idle at least this long (seconds, default: no age limit)\\n\"\n           \"   - ext_low_ttl:         consider TTLs lower than this specially (default: %u)\\n\"\n           \"   - ext_drop_unread:     don't re-write unread values during compaction (default: %s)\\n\"\n           \"   - ext_recache_rate:    recache an item every N accesses (default: %u)\\n\"\n           \"   - ext_compact_under:   compact when fewer than this many free pages\\n\"\n           \"                          (default: 1/4th of the assigned storage)\\n\"\n           \"   - ext_drop_under:      drop COLD items when fewer than this many free pages\\n\"\n           \"                          (default: 1/4th of the assigned storage)\\n\"\n           \"   - ext_max_frag:        max page fragmentation to tolerate (default: %.2f)\\n\"\n           \"   - slab_automove_freeratio: ratio of memory to hold free as buffer.\\n\"\n           \"                          (see doc/storage.txt for more info, default: %.3f)\\n\",\n           settings.ext_page_size / (1 << 20), settings.ext_wbuf_size / (1 << 20), settings.ext_io_threadcount,\n           settings.ext_item_size, settings.ext_low_ttl,\n           flag_enabled_disabled(settings.ext_drop_unread), settings.ext_recache_rate,\n           settings.ext_max_frag, settings.slab_automove_freeratio);\n    verify_default(\"ext_item_age\", settings.ext_item_age == UINT_MAX);\n#endif\n#ifdef TLS\n    printf(\"   - ssl_chain_cert:      certificate chain file in PEM format\\n\"\n           \"   - ssl_key:             private key, if not part of the -ssl_chain_cert\\n\"\n           \"   - ssl_keyformat:       private key format (PEM, DER or ENGINE) (default: PEM)\\n\");\n    printf(\"   - ssl_verify_mode:     peer certificate verification mode, default is 0(None).\\n\"\n           \"                          valid values are 0(None), 1(Request), 2(Require)\\n\"\n           \"                          or 3(Once)\\n\");\n    printf(\"   - ssl_ciphers:         specify cipher list to be used\\n\"\n           \"   - ssl_ca_cert:         PEM format file of acceptable client CA's\\n\"\n           \"   - ssl_wbuf_size:       size in kilobytes of per-connection SSL output buffer\\n\"\n           \"                          (default: %u)\\n\", settings.ssl_wbuf_size / (1 << 10));\n    verify_default(\"ssl_keyformat\", settings.ssl_keyformat == SSL_FILETYPE_PEM);\n    verify_default(\"ssl_verify_mode\", settings.ssl_verify_mode == SSL_VERIFY_NONE);\n#endif\n    return;\n}\n\nstatic void usage_license(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\\n\");\n    printf(\n    \"Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions are\\n\"\n    \"met:\\n\"\n    \"\\n\"\n    \"    * Redistributions of source code must retain the above copyright\\n\"\n    \"notice, this list of conditions and the following disclaimer.\\n\"\n    \"\\n\"\n    \"    * Redistributions in binary form must reproduce the above\\n\"\n    \"copyright notice, this list of conditions and the following disclaimer\\n\"\n    \"in the documentation and/or other materials provided with the\\n\"\n    \"distribution.\\n\"\n    \"\\n\"\n    \"    * Neither the name of the Danga Interactive nor the names of its\\n\"\n    \"contributors may be used to endorse or promote products derived from\\n\"\n    \"this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n\"\n    \"\\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n\"\n    \"A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n\"\n    \"OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n\"\n    \"SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\"\n    \"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    \"\\n\"\n    \"\\n\"\n    \"This product includes software developed by Niels Provos.\\n\"\n    \"\\n\"\n    \"[ libevent ]\\n\"\n    \"\\n\"\n    \"Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions\\n\"\n    \"are met:\\n\"\n    \"1. Redistributions of source code must retain the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer.\\n\"\n    \"2. Redistributions in binary form must reproduce the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer in the\\n\"\n    \"   documentation and/or other materials provided with the distribution.\\n\"\n    \"3. All advertising materials mentioning features or use of this software\\n\"\n    \"   must display the following acknowledgement:\\n\"\n    \"      This product includes software developed by Niels Provos.\\n\"\n    \"4. The name of the author may not be used to endorse or promote products\\n\"\n    \"   derived from this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\\n\"\n    \"IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\\n\"\n    \"OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\\n\"\n    \"IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\\n\"\n    \"INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\\n\"\n    \"NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\\n\"\n    \"THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    );\n\n    return;\n}\n\nstatic void save_pid(const char *pid_file) {\n    FILE *fp;\n    if (access(pid_file, F_OK) == 0) {\n        if ((fp = fopen(pid_file, \"r\")) != NULL) {\n            char buffer[1024];\n            if (fgets(buffer, sizeof(buffer), fp) != NULL) {\n                unsigned int pid;\n                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {\n                    fprintf(stderr, \"WARNING: The pid file contained the following (running) pid: %u\\n\", pid);\n                }\n            }\n            fclose(fp);\n        }\n    }\n\n    /* Create the pid file first with a temporary name, then\n     * atomically move the file to the real name to avoid a race with\n     * another process opening the file to read the pid, but finding\n     * it empty.\n     */\n    char tmp_pid_file[1024];\n    snprintf(tmp_pid_file, sizeof(tmp_pid_file), \"%s.tmp\", pid_file);\n\n    if ((fp = fopen(tmp_pid_file, \"w\")) == NULL) {\n        vperror(\"Could not open the pid file %s for writing\", tmp_pid_file);\n        return;\n    }\n\n    fprintf(fp,\"%ld\\n\", (long)getpid());\n    if (fclose(fp) == -1) {\n        vperror(\"Could not close the pid file %s\", tmp_pid_file);\n    }\n\n    if (rename(tmp_pid_file, pid_file) != 0) {\n        vperror(\"Could not rename the pid file from %s to %s\",\n                tmp_pid_file, pid_file);\n    }\n}\n\nstatic void remove_pidfile(const char *pid_file) {\n  if (pid_file == NULL)\n      return;\n\n  if (unlink(pid_file) != 0) {\n      vperror(\"Could not remove the pid file %s\", pid_file);\n  }\n\n}\n\nstatic void sig_handler(const int sig) {\n    printf(\"Signal handled: %s.\\n\", strsignal(sig));\n    exit(EXIT_SUCCESS);\n}\n\nstatic void sighup_handler(const int sig) {\n    settings.sig_hup = true;\n}\n\nstatic void sig_usrhandler(const int sig) {\n    printf(\"Graceful shutdown signal handled: %s.\\n\", strsignal(sig));\n    stop_main_loop = true;\n}\n\n#ifndef HAVE_SIGIGNORE\nstatic int sigignore(int sig) {\n    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {\n        return -1;\n    }\n    return 0;\n}\n#endif\n\n\n/*\n * On systems that supports multiple page sizes we may reduce the\n * number of TLB-misses by using the biggest available page size\n */\nstatic int enable_large_pages(void) {\n#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)\n    int ret = -1;\n    size_t sizes[32];\n    int avail = getpagesizes(sizes, 32);\n    if (avail != -1) {\n        size_t max = sizes[0];\n        struct memcntl_mha arg = {0};\n        int ii;\n\n        for (ii = 1; ii < avail; ++ii) {\n            if (max < sizes[ii]) {\n                max = sizes[ii];\n            }\n        }\n\n        arg.mha_flags   = 0;\n        arg.mha_pagesize = max;\n        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;\n\n        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {\n            fprintf(stderr, \"Failed to set large pages: %s\\n\",\n                    strerror(errno));\n            fprintf(stderr, \"Will use default page size\\n\");\n        } else {\n            ret = 0;\n        }\n    } else {\n        fprintf(stderr, \"Failed to get supported pagesizes: %s\\n\",\n                strerror(errno));\n        fprintf(stderr, \"Will use default page size\\n\");\n    }\n\n    return ret;\n#elif defined(__linux__) && defined(MADV_HUGEPAGE)\n    /* check if transparent hugepages is compiled into the kernel */\n    struct stat st;\n    int ret = stat(\"/sys/kernel/mm/transparent_hugepage/enabled\", &st);\n    if (ret || !(st.st_mode & S_IFREG)) {\n        fprintf(stderr, \"Transparent huge pages support not detected.\\n\");\n        fprintf(stderr, \"Will use default page size.\\n\");\n        return -1;\n    }\n    return 0;\n#elif defined(__FreeBSD__)\n    int spages;\n    size_t spagesl = sizeof(spages);\n\n    if (sysctlbyname(\"vm.pmap.pg_ps_enabled\", &spages,\n    &spagesl, NULL, 0) != 0) {\n        fprintf(stderr, \"Could not evaluate the presence of superpages features.\");\n        return -1;\n    }\n    if (spages != 1) {\n        fprintf(stderr, \"Superpages support not detected.\\n\");\n        fprintf(stderr, \"Will use default page size.\\n\");\n        return -1;\n    }\n    return 0;\n#else\n    return -1;\n#endif\n}\n\n/**\n * Do basic sanity check of the runtime environment\n * @return true if no errors found, false if we can't use this env\n */\nstatic bool sanitycheck(void) {\n    /* One of our biggest problems is old and bogus libevents */\n    const char *ever = event_get_version();\n    if (ever != NULL) {\n        if (strncmp(ever, \"1.\", 2) == 0) {\n            /* Require at least 1.3 (that's still a couple of years old) */\n            if (('0' <= ever[2] && ever[2] < '3') && !isdigit(ever[3])) {\n                fprintf(stderr, \"You are using libevent %s.\\nPlease upgrade to\"\n                        \" a more recent version (1.3 or newer)\\n\",\n                        event_get_version());\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nstatic bool _parse_slab_sizes(char *s, uint32_t *slab_sizes) {\n    char *b = NULL;\n    uint32_t size = 0;\n    int i = 0;\n    uint32_t last_size = 0;\n\n    if (strlen(s) < 1)\n        return false;\n\n    for (char *p = strtok_r(s, \"-\", &b);\n         p != NULL;\n         p = strtok_r(NULL, \"-\", &b)) {\n        if (!safe_strtoul(p, &size) || size < settings.chunk_size\n             || size > settings.slab_chunk_size_max) {\n            fprintf(stderr, \"slab size %u is out of valid range\\n\", size);\n            return false;\n        }\n        if (last_size >= size) {\n            fprintf(stderr, \"slab size %u cannot be lower than or equal to a previous class size\\n\", size);\n            return false;\n        }\n        if (size <= last_size + CHUNK_ALIGN_BYTES) {\n            fprintf(stderr, \"slab size %u must be at least %d bytes larger than previous class\\n\",\n                    size, CHUNK_ALIGN_BYTES);\n            return false;\n        }\n        slab_sizes[i++] = size;\n        last_size = size;\n        if (i >= MAX_NUMBER_OF_SLAB_CLASSES-1) {\n            fprintf(stderr, \"too many slab classes specified\\n\");\n            return false;\n        }\n    }\n\n    slab_sizes[i] = 0;\n    return true;\n}\n\nstruct _mc_meta_data {\n    void *mmap_base;\n    uint64_t old_base;\n    char *slab_config; // string containing either factor or custom slab list.\n    int64_t time_delta;\n    uint64_t process_started;\n    uint32_t current_time;\n};\n\n// We need to remember a combination of configuration settings and global\n// state for restart viability and resumption of internal services.\n// Compared to the number of tunables and state values, relatively little\n// does need to be remembered.\n// Time is the hardest; we have to assume the sys clock is correct and re-sync for\n// the lost time after restart.\nstatic int _mc_meta_save_cb(const char *tag, void *ctx, void *data) {\n    struct _mc_meta_data *meta = (struct _mc_meta_data *)data;\n\n    // Settings to remember.\n    // TODO: should get a version of version which is numeric, else\n    // comparisons for compat reasons are difficult.\n    // it may be possible to punt on this for now; since we can test for the\n    // absense of another key... such as the new numeric version.\n    //restart_set_kv(ctx, \"version\", \"%s\", VERSION);\n    // We hold the original factor or subopts _string_\n    // it can be directly compared without roundtripping through floats or\n    // serializing/deserializing the long options list.\n    restart_set_kv(ctx, \"slab_config\", \"%s\", meta->slab_config);\n    restart_set_kv(ctx, \"maxbytes\", \"%llu\", (unsigned long long) settings.maxbytes);\n    restart_set_kv(ctx, \"chunk_size\", \"%d\", settings.chunk_size);\n    restart_set_kv(ctx, \"item_size_max\", \"%d\", settings.item_size_max);\n    restart_set_kv(ctx, \"slab_chunk_size_max\", \"%d\", settings.slab_chunk_size_max);\n    restart_set_kv(ctx, \"slab_page_size\", \"%d\", settings.slab_page_size);\n    restart_set_kv(ctx, \"use_cas\", \"%s\", settings.use_cas ? \"true\" : \"false\");\n    restart_set_kv(ctx, \"slab_reassign\", \"%s\", settings.slab_reassign ? \"true\" : \"false\");\n\n    // Online state to remember.\n\n    // current time is tough. we need to rely on the clock being correct to\n    // pull the delta between stop and start times. we also need to know the\n    // delta between start time and now to restore monotonic clocks.\n    // for non-monotonic clocks (some OS?), process_started is the only\n    // important one.\n    restart_set_kv(ctx, \"current_time\", \"%u\", current_time);\n    // types are great until... this. some systems time_t could be big, but\n    // I'm assuming never negative.\n    restart_set_kv(ctx, \"process_started\", \"%llu\", (unsigned long long) process_started);\n    {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        restart_set_kv(ctx, \"stop_time\", \"%lu\", tv.tv_sec);\n    }\n\n    // Might as well just fetch the next CAS value to use than tightly\n    // coupling the internal variable into the restart system.\n    restart_set_kv(ctx, \"current_cas\", \"%llu\", (unsigned long long) get_cas_id());\n    restart_set_kv(ctx, \"oldest_cas\", \"%llu\", (unsigned long long) settings.oldest_cas);\n    restart_set_kv(ctx, \"logger_gid\", \"%llu\", logger_get_gid());\n    restart_set_kv(ctx, \"hashpower\", \"%u\", stats_state.hash_power_level);\n    // NOTE: oldest_live is a rel_time_t, which aliases for unsigned int.\n    // should future proof this with a 64bit upcast, or fetch value from a\n    // converter function/macro?\n    restart_set_kv(ctx, \"oldest_live\", \"%u\", settings.oldest_live);\n    // TODO: use uintptr_t etc? is it portable enough?\n    restart_set_kv(ctx, \"mmap_oldbase\", \"%p\", meta->mmap_base);\n\n    return 0;\n}\n\n// We must see at least this number of checked lines. Else empty/missing lines\n// could cause a false-positive.\n// TODO: Once crc32'ing of the metadata file is done this could be ensured better by\n// the restart module itself (crc32 + count of lines must match on the\n// backend)\n#define RESTART_REQUIRED_META 17\n\n// With this callback we make a decision on if the current configuration\n// matches up enough to allow reusing the cache.\n// We also re-load important runtime information.\nstatic int _mc_meta_load_cb(const char *tag, void *ctx, void *data) {\n    struct _mc_meta_data *meta = (struct _mc_meta_data *)data;\n    char *key;\n    char *val;\n    int reuse_mmap = 0;\n    meta->process_started = 0;\n    meta->time_delta = 0;\n    meta->current_time = 0;\n    int lines_seen = 0;\n\n    // TODO: not sure this is any better than just doing an if/else tree with\n    // strcmp's...\n    enum {\n        R_MMAP_OLDBASE = 0,\n        R_MAXBYTES,\n        R_CHUNK_SIZE,\n        R_ITEM_SIZE_MAX,\n        R_SLAB_CHUNK_SIZE_MAX,\n        R_SLAB_PAGE_SIZE,\n        R_SLAB_CONFIG,\n        R_USE_CAS,\n        R_SLAB_REASSIGN,\n        R_CURRENT_CAS,\n        R_OLDEST_CAS,\n        R_OLDEST_LIVE,\n        R_LOGGER_GID,\n        R_CURRENT_TIME,\n        R_STOP_TIME,\n        R_PROCESS_STARTED,\n        R_HASHPOWER,\n    };\n\n    const char *opts[] = {\n        [R_MMAP_OLDBASE] = \"mmap_oldbase\",\n        [R_MAXBYTES] = \"maxbytes\",\n        [R_CHUNK_SIZE] = \"chunk_size\",\n        [R_ITEM_SIZE_MAX] = \"item_size_max\",\n        [R_SLAB_CHUNK_SIZE_MAX] = \"slab_chunk_size_max\",\n        [R_SLAB_PAGE_SIZE] = \"slab_page_size\",\n        [R_SLAB_CONFIG] = \"slab_config\",\n        [R_USE_CAS] = \"use_cas\",\n        [R_SLAB_REASSIGN] = \"slab_reassign\",\n        [R_CURRENT_CAS] = \"current_cas\",\n        [R_OLDEST_CAS] = \"oldest_cas\",\n        [R_OLDEST_LIVE] = \"oldest_live\",\n        [R_LOGGER_GID] = \"logger_gid\",\n        [R_CURRENT_TIME] = \"current_time\",\n        [R_STOP_TIME] = \"stop_time\",\n        [R_PROCESS_STARTED] = \"process_started\",\n        [R_HASHPOWER] = \"hashpower\",\n        NULL\n    };\n\n    while (restart_get_kv(ctx, &key, &val) == RESTART_OK) {\n        int type = 0;\n        int32_t val_int = 0;\n        uint32_t val_uint = 0;\n        int64_t bigval_int = 0;\n        uint64_t bigval_uint = 0;\n\n        while (opts[type] != NULL && strcmp(key, opts[type]) != 0) {\n            type++;\n        }\n        if (opts[type] == NULL) {\n            fprintf(stderr, \"[restart] unknown/unhandled key: %s\\n\", key);\n            continue;\n        }\n        lines_seen++;\n\n        // helper for any boolean checkers.\n        bool val_bool = false;\n        bool is_bool = true;\n        if (strcmp(val, \"false\") == 0) {\n            val_bool = false;\n        } else if (strcmp(val, \"true\") == 0) {\n            val_bool = true;\n        } else {\n            is_bool = false;\n        }\n\n        switch (type) {\n        case R_MMAP_OLDBASE:\n            if (!safe_strtoull_hex(val, &meta->old_base)) {\n                fprintf(stderr, \"[restart] failed to parse %s: %s\\n\", key, val);\n                reuse_mmap = -1;\n            }\n            break;\n        case R_MAXBYTES:\n            if (!safe_strtoll(val, &bigval_int) || settings.maxbytes != bigval_int) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_CHUNK_SIZE:\n            if (!safe_strtol(val, &val_int) || settings.chunk_size != val_int) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_ITEM_SIZE_MAX:\n            if (!safe_strtol(val, &val_int) || settings.item_size_max != val_int) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_SLAB_CHUNK_SIZE_MAX:\n            if (!safe_strtol(val, &val_int) || settings.slab_chunk_size_max != val_int) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_SLAB_PAGE_SIZE:\n            if (!safe_strtol(val, &val_int) || settings.slab_page_size != val_int) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_SLAB_CONFIG:\n            if (strcmp(val, meta->slab_config) != 0) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_USE_CAS:\n            if (!is_bool || settings.use_cas != val_bool) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_SLAB_REASSIGN:\n            if (!is_bool || settings.slab_reassign != val_bool) {\n                reuse_mmap = -1;\n            }\n            break;\n        case R_CURRENT_CAS:\n            // FIXME: do we need to fail if these values _aren't_ found?\n            if (!safe_strtoull(val, &bigval_uint)) {\n                reuse_mmap = -1;\n            } else {\n                set_cas_id(bigval_uint);\n            }\n            break;\n        case R_OLDEST_CAS:\n            if (!safe_strtoull(val, &bigval_uint)) {\n                reuse_mmap = -1;\n            } else {\n                settings.oldest_cas = bigval_uint;\n            }\n            break;\n        case R_OLDEST_LIVE:\n            if (!safe_strtoul(val, &val_uint)) {\n                reuse_mmap = -1;\n            } else {\n                settings.oldest_live = val_uint;\n            }\n            break;\n        case R_LOGGER_GID:\n            if (!safe_strtoull(val, &bigval_uint)) {\n                reuse_mmap = -1;\n            } else {\n                logger_set_gid(bigval_uint);\n            }\n            break;\n        case R_PROCESS_STARTED:\n            if (!safe_strtoull(val, &bigval_uint)) {\n                reuse_mmap = -1;\n            } else {\n                meta->process_started = bigval_uint;\n            }\n            break;\n        case R_CURRENT_TIME:\n            if (!safe_strtoul(val, &val_uint)) {\n                reuse_mmap = -1;\n            } else {\n                meta->current_time = val_uint;\n            }\n            break;\n        case R_STOP_TIME:\n            if (!safe_strtoll(val, &bigval_int)) {\n                reuse_mmap = -1;\n            } else {\n                struct timeval t;\n                gettimeofday(&t, NULL);\n                meta->time_delta = t.tv_sec - bigval_int;\n                // clock has done something crazy.\n                // there are _lots_ of ways the clock can go wrong here, but\n                // this is a safe sanity check since there's nothing else we\n                // can realistically do.\n                if (meta->time_delta <= 0) {\n                    reuse_mmap = -1;\n                }\n            }\n            break;\n        case R_HASHPOWER:\n            if (!safe_strtoul(val, &val_uint)) {\n                reuse_mmap = -1;\n            } else {\n                settings.hashpower_init = val_uint;\n            }\n            break;\n        default:\n            fprintf(stderr, \"[restart] unhandled key: %s\\n\", key);\n        }\n\n        if (reuse_mmap != 0) {\n            fprintf(stderr, \"[restart] restart incompatible due to setting for [%s] [old value: %s]\\n\", key, val);\n            break;\n        }\n    }\n\n    if (lines_seen < RESTART_REQUIRED_META) {\n        fprintf(stderr, \"[restart] missing some metadata lines\\n\");\n        reuse_mmap = -1;\n    }\n\n    return reuse_mmap;\n}\n\nint main (int argc, char **argv) {\n    int c;\n    bool lock_memory = false;\n    bool do_daemonize = false;\n    bool preallocate = false;\n    int maxcore = 0;\n    char *username = NULL;\n    char *pid_file = NULL;\n    char *memory_file = NULL;\n    struct passwd *pw;\n    struct rlimit rlim;\n    char *buf;\n    char unit = '\\0';\n    int size_max = 0;\n    int retval = EXIT_SUCCESS;\n    bool protocol_specified = false;\n    bool tcp_specified = false;\n    bool udp_specified = false;\n    bool start_lru_maintainer = true;\n    bool start_lru_crawler = true;\n    bool start_assoc_maint = true;\n    enum hashfunc_type hash_type = MURMUR3_HASH;\n    uint32_t tocrawl;\n    uint32_t slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];\n    bool use_slab_sizes = false;\n    char *slab_sizes_unparsed = NULL;\n    bool slab_chunk_size_changed = false;\n    // struct for restart code. Initialized up here so we can curry\n    // important settings to save or validate.\n    struct _mc_meta_data *meta = malloc(sizeof(struct _mc_meta_data));\n    meta->slab_config = NULL;\n#ifdef EXTSTORE\n    void *storage = NULL;\n    struct extstore_conf_file *storage_file = NULL;\n    struct extstore_conf ext_cf;\n#endif\n    char *subopts, *subopts_orig;\n    char *subopts_value;\n    enum {\n        MAXCONNS_FAST = 0,\n        HASHPOWER_INIT,\n        NO_HASHEXPAND,\n        SLAB_REASSIGN,\n        SLAB_AUTOMOVE,\n        SLAB_AUTOMOVE_RATIO,\n        SLAB_AUTOMOVE_WINDOW,\n        TAIL_REPAIR_TIME,\n        HASH_ALGORITHM,\n        LRU_CRAWLER,\n        LRU_CRAWLER_SLEEP,\n        LRU_CRAWLER_TOCRAWL,\n        LRU_MAINTAINER,\n        HOT_LRU_PCT,\n        WARM_LRU_PCT,\n        HOT_MAX_FACTOR,\n        WARM_MAX_FACTOR,\n        TEMPORARY_TTL,\n        IDLE_TIMEOUT,\n        WATCHER_LOGBUF_SIZE,\n        WORKER_LOGBUF_SIZE,\n        SLAB_SIZES,\n        SLAB_CHUNK_MAX,\n        TRACK_SIZES,\n        NO_INLINE_ASCII_RESP,\n        MODERN,\n        NO_MODERN,\n        NO_CHUNKED_ITEMS,\n        NO_SLAB_REASSIGN,\n        NO_SLAB_AUTOMOVE,\n        NO_MAXCONNS_FAST,\n        INLINE_ASCII_RESP,\n        NO_LRU_CRAWLER,\n        NO_LRU_MAINTAINER,\n        NO_DROP_PRIVILEGES,\n        DROP_PRIVILEGES,\n        RESP_OBJ_MEM_LIMIT,\n        READ_BUF_MEM_LIMIT,\n#ifdef TLS\n        SSL_CERT,\n        SSL_KEY,\n        SSL_VERIFY_MODE,\n        SSL_KEYFORM,\n        SSL_CIPHERS,\n        SSL_CA_CERT,\n        SSL_WBUF_SIZE,\n#endif\n#ifdef MEMCACHED_DEBUG\n        RELAXED_PRIVILEGES,\n#endif\n#ifdef EXTSTORE\n        EXT_PAGE_SIZE,\n        EXT_WBUF_SIZE,\n        EXT_THREADS,\n        EXT_IO_DEPTH,\n        EXT_PATH,\n        EXT_ITEM_SIZE,\n        EXT_ITEM_AGE,\n        EXT_LOW_TTL,\n        EXT_RECACHE_RATE,\n        EXT_COMPACT_UNDER,\n        EXT_DROP_UNDER,\n        EXT_MAX_FRAG,\n        EXT_DROP_UNREAD,\n        SLAB_AUTOMOVE_FREERATIO,\n#endif\n    };\n    char *const subopts_tokens[] = {\n        [MAXCONNS_FAST] = \"maxconns_fast\",\n        [HASHPOWER_INIT] = \"hashpower\",\n        [NO_HASHEXPAND] = \"no_hashexpand\",\n        [SLAB_REASSIGN] = \"slab_reassign\",\n        [SLAB_AUTOMOVE] = \"slab_automove\",\n        [SLAB_AUTOMOVE_RATIO] = \"slab_automove_ratio\",\n        [SLAB_AUTOMOVE_WINDOW] = \"slab_automove_window\",\n        [TAIL_REPAIR_TIME] = \"tail_repair_time\",\n        [HASH_ALGORITHM] = \"hash_algorithm\",\n        [LRU_CRAWLER] = \"lru_crawler\",\n        [LRU_CRAWLER_SLEEP] = \"lru_crawler_sleep\",\n        [LRU_CRAWLER_TOCRAWL] = \"lru_crawler_tocrawl\",\n        [LRU_MAINTAINER] = \"lru_maintainer\",\n        [HOT_LRU_PCT] = \"hot_lru_pct\",\n        [WARM_LRU_PCT] = \"warm_lru_pct\",\n        [HOT_MAX_FACTOR] = \"hot_max_factor\",\n        [WARM_MAX_FACTOR] = \"warm_max_factor\",\n        [TEMPORARY_TTL] = \"temporary_ttl\",\n        [IDLE_TIMEOUT] = \"idle_timeout\",\n        [WATCHER_LOGBUF_SIZE] = \"watcher_logbuf_size\",\n        [WORKER_LOGBUF_SIZE] = \"worker_logbuf_size\",\n        [SLAB_SIZES] = \"slab_sizes\",\n        [SLAB_CHUNK_MAX] = \"slab_chunk_max\",\n        [TRACK_SIZES] = \"track_sizes\",\n        [NO_INLINE_ASCII_RESP] = \"no_inline_ascii_resp\",\n        [MODERN] = \"modern\",\n        [NO_MODERN] = \"no_modern\",\n        [NO_CHUNKED_ITEMS] = \"no_chunked_items\",\n        [NO_SLAB_REASSIGN] = \"no_slab_reassign\",\n        [NO_SLAB_AUTOMOVE] = \"no_slab_automove\",\n        [NO_MAXCONNS_FAST] = \"no_maxconns_fast\",\n        [INLINE_ASCII_RESP] = \"inline_ascii_resp\",\n        [NO_LRU_CRAWLER] = \"no_lru_crawler\",\n        [NO_LRU_MAINTAINER] = \"no_lru_maintainer\",\n        [NO_DROP_PRIVILEGES] = \"no_drop_privileges\",\n        [DROP_PRIVILEGES] = \"drop_privileges\",\n        [RESP_OBJ_MEM_LIMIT] = \"resp_obj_mem_limit\",\n        [READ_BUF_MEM_LIMIT] = \"read_buf_mem_limit\",\n#ifdef TLS\n        [SSL_CERT] = \"ssl_chain_cert\",\n        [SSL_KEY] = \"ssl_key\",\n        [SSL_VERIFY_MODE] = \"ssl_verify_mode\",\n        [SSL_KEYFORM] = \"ssl_keyformat\",\n        [SSL_CIPHERS] = \"ssl_ciphers\",\n        [SSL_CA_CERT] = \"ssl_ca_cert\",\n        [SSL_WBUF_SIZE] = \"ssl_wbuf_size\",\n#endif\n#ifdef MEMCACHED_DEBUG\n        [RELAXED_PRIVILEGES] = \"relaxed_privileges\",\n#endif\n#ifdef EXTSTORE\n        [EXT_PAGE_SIZE] = \"ext_page_size\",\n        [EXT_WBUF_SIZE] = \"ext_wbuf_size\",\n        [EXT_THREADS] = \"ext_threads\",\n        [EXT_IO_DEPTH] = \"ext_io_depth\",\n        [EXT_PATH] = \"ext_path\",\n        [EXT_ITEM_SIZE] = \"ext_item_size\",\n        [EXT_ITEM_AGE] = \"ext_item_age\",\n        [EXT_LOW_TTL] = \"ext_low_ttl\",\n        [EXT_RECACHE_RATE] = \"ext_recache_rate\",\n        [EXT_COMPACT_UNDER] = \"ext_compact_under\",\n        [EXT_DROP_UNDER] = \"ext_drop_under\",\n        [EXT_MAX_FRAG] = \"ext_max_frag\",\n        [EXT_DROP_UNREAD] = \"ext_drop_unread\",\n        [SLAB_AUTOMOVE_FREERATIO] = \"slab_automove_freeratio\",\n#endif\n        NULL\n    };\n\n    if (!sanitycheck()) {\n        free(meta);\n        return EX_OSERR;\n    }\n\n    /* handle SIGINT, SIGTERM */\n    signal(SIGINT, sig_handler);\n    signal(SIGTERM, sig_handler);\n    signal(SIGHUP, sighup_handler);\n    signal(SIGUSR1, sig_usrhandler);\n\n    /* init settings */\n    settings_init();\n    verify_default(\"hash_algorithm\", hash_type == MURMUR3_HASH);\n#ifdef EXTSTORE\n    settings.ext_item_size = 512;\n    settings.ext_item_age = UINT_MAX;\n    settings.ext_low_ttl = 0;\n    settings.ext_recache_rate = 2000;\n    settings.ext_max_frag = 0.8;\n    settings.ext_drop_unread = false;\n    settings.ext_wbuf_size = 1024 * 1024 * 4;\n    settings.ext_compact_under = 0;\n    settings.ext_drop_under = 0;\n    settings.slab_automove_freeratio = 0.01;\n    settings.ext_page_size = 1024 * 1024 * 64;\n    settings.ext_io_threadcount = 1;\n    ext_cf.page_size = settings.ext_page_size;\n    ext_cf.wbuf_size = settings.ext_wbuf_size;\n    ext_cf.io_threadcount = settings.ext_io_threadcount;\n    ext_cf.io_depth = 1;\n    ext_cf.page_buckets = 4;\n    ext_cf.wbuf_count = ext_cf.page_buckets;\n#endif\n\n    /* Run regardless of initializing it later */\n    init_lru_maintainer();\n\n    /* set stderr non-buffering (for running under, say, daemontools) */\n    setbuf(stderr, NULL);\n\n    char *shortopts =\n          \"a:\"  /* access mask for unix socket */\n          \"A\"  /* enable admin shutdown command */\n          \"Z\"   /* enable SSL */\n          \"p:\"  /* TCP port number to listen on */\n          \"s:\"  /* unix socket path to listen on */\n          \"U:\"  /* UDP port number to listen on */\n          \"m:\"  /* max memory to use for items in megabytes */\n          \"M\"   /* return error on memory exhausted */\n          \"c:\"  /* max simultaneous connections */\n          \"k\"   /* lock down all paged memory */\n          \"hiV\" /* help, licence info, version */\n          \"r\"   /* maximize core file limit */\n          \"v\"   /* verbose */\n          \"d\"   /* daemon mode */\n          \"l:\"  /* interface to listen on */\n          \"u:\"  /* user identity to run as */\n          \"P:\"  /* save PID in file */\n          \"f:\"  /* factor? */\n          \"n:\"  /* minimum space allocated for key+value+flags */\n          \"t:\"  /* threads */\n          \"D:\"  /* prefix delimiter? */\n          \"L\"   /* Large memory pages */\n          \"R:\"  /* max requests per event */\n          \"C\"   /* Disable use of CAS */\n          \"b:\"  /* backlog queue limit */\n          \"B:\"  /* Binding protocol */\n          \"I:\"  /* Max item size */\n          \"S\"   /* Sasl ON */\n          \"F\"   /* Disable flush_all */\n          \"X\"   /* Disable dump commands */\n          \"W\"   /* Disable watch commands */\n          \"Y:\"   /* Enable token auth */\n          \"e:\"  /* mmap path for external item memory */\n          \"o:\"  /* Extended generic options */\n          ;\n\n    /* process arguments */\n#ifdef HAVE_GETOPT_LONG\n    const struct option longopts[] = {\n        {\"unix-mask\", required_argument, 0, 'a'},\n        {\"enable-shutdown\", no_argument, 0, 'A'},\n        {\"enable-ssl\", no_argument, 0, 'Z'},\n        {\"port\", required_argument, 0, 'p'},\n        {\"unix-socket\", required_argument, 0, 's'},\n        {\"udp-port\", required_argument, 0, 'U'},\n        {\"memory-limit\", required_argument, 0, 'm'},\n        {\"disable-evictions\", no_argument, 0, 'M'},\n        {\"conn-limit\", required_argument, 0, 'c'},\n        {\"lock-memory\", no_argument, 0, 'k'},\n        {\"help\", no_argument, 0, 'h'},\n        {\"license\", no_argument, 0, 'i'},\n        {\"version\", no_argument, 0, 'V'},\n        {\"enable-coredumps\", no_argument, 0, 'r'},\n        {\"verbose\", optional_argument, 0, 'v'},\n        {\"daemon\", no_argument, 0, 'd'},\n        {\"listen\", required_argument, 0, 'l'},\n        {\"user\", required_argument, 0, 'u'},\n        {\"pidfile\", required_argument, 0, 'P'},\n        {\"slab-growth-factor\", required_argument, 0, 'f'},\n        {\"slab-min-size\", required_argument, 0, 'n'},\n        {\"threads\", required_argument, 0, 't'},\n        {\"enable-largepages\", no_argument, 0, 'L'},\n        {\"max-reqs-per-event\", required_argument, 0, 'R'},\n        {\"disable-cas\", no_argument, 0, 'C'},\n        {\"listen-backlog\", required_argument, 0, 'b'},\n        {\"protocol\", required_argument, 0, 'B'},\n        {\"max-item-size\", required_argument, 0, 'I'},\n        {\"enable-sasl\", no_argument, 0, 'S'},\n        {\"disable-flush-all\", no_argument, 0, 'F'},\n        {\"disable-dumping\", no_argument, 0, 'X'},\n        {\"disable-watch\", no_argument, 0, 'W'},\n        {\"auth-file\", required_argument, 0, 'Y'},\n        {\"memory-file\", required_argument, 0, 'e'},\n        {\"extended\", required_argument, 0, 'o'},\n        {0, 0, 0, 0}\n    };\n    int optindex;\n    while (-1 != (c = getopt_long(argc, argv, shortopts,\n                    longopts, &optindex))) {\n#else\n    while (-1 != (c = getopt(argc, argv, shortopts))) {\n#endif\n        switch (c) {\n        case 'A':\n            /* enables \"shutdown\" command */\n            settings.shutdown_command = true;\n            break;\n        case 'Z':\n            /* enable secure communication*/\n#ifdef TLS\n            settings.ssl_enabled = true;\n#else\n            fprintf(stderr, \"This server is not built with TLS support.\\n\");\n            exit(EX_USAGE);\n#endif\n            break;\n        case 'a':\n            /* access for unix domain socket, as octal mask (like chmod)*/\n            settings.access= strtol(optarg,NULL,8);\n            break;\n        case 'U':\n            settings.udpport = atoi(optarg);\n            udp_specified = true;\n            break;\n        case 'p':\n            settings.port = atoi(optarg);\n            tcp_specified = true;\n            break;\n        case 's':\n            settings.socketpath = optarg;\n            break;\n        case 'm':\n            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n            break;\n        case 'M':\n            settings.evict_to_free = 0;\n            break;\n        case 'c':\n            settings.maxconns = atoi(optarg);\n            if (settings.maxconns <= 0) {\n                fprintf(stderr, \"Maximum connections must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'h':\n            usage();\n            exit(EXIT_SUCCESS);\n        case 'i':\n            usage_license();\n            exit(EXIT_SUCCESS);\n        case 'V':\n            printf(PACKAGE \" \" VERSION \"\\n\");\n            exit(EXIT_SUCCESS);\n        case 'k':\n            lock_memory = true;\n            break;\n        case 'v':\n            settings.verbose++;\n            break;\n        case 'l':\n            if (settings.inter != NULL) {\n                if (strstr(settings.inter, optarg) != NULL) {\n                    break;\n                }\n                size_t len = strlen(settings.inter) + strlen(optarg) + 2;\n                char *p = malloc(len);\n                if (p == NULL) {\n                    fprintf(stderr, \"Failed to allocate memory\\n\");\n                    return 1;\n                }\n                snprintf(p, len, \"%s,%s\", settings.inter, optarg);\n                free(settings.inter);\n                settings.inter = p;\n            } else {\n                settings.inter= strdup(optarg);\n            }\n            break;\n        case 'd':\n            do_daemonize = true;\n            break;\n        case 'r':\n            maxcore = 1;\n            break;\n        case 'R':\n            settings.reqs_per_event = atoi(optarg);\n            if (settings.reqs_per_event == 0) {\n                fprintf(stderr, \"Number of requests per event must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'u':\n            username = optarg;\n            break;\n        case 'P':\n            pid_file = optarg;\n            break;\n        case 'e':\n            memory_file = optarg;\n            break;\n        case 'f':\n            settings.factor = atof(optarg);\n            if (settings.factor <= 1.0) {\n                fprintf(stderr, \"Factor must be greater than 1\\n\");\n                return 1;\n            }\n            meta->slab_config = strdup(optarg);\n            break;\n        case 'n':\n            settings.chunk_size = atoi(optarg);\n            if (settings.chunk_size == 0) {\n                fprintf(stderr, \"Chunk size must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 't':\n            settings.num_threads = atoi(optarg);\n            if (settings.num_threads <= 0) {\n                fprintf(stderr, \"Number of threads must be greater than 0\\n\");\n                return 1;\n            }\n            /* There're other problems when you get above 64 threads.\n             * In the future we should portably detect # of cores for the\n             * default.\n             */\n            if (settings.num_threads > 64) {\n                fprintf(stderr, \"WARNING: Setting a high number of worker\"\n                                \"threads is not recommended.\\n\"\n                                \" Set this value to the number of cores in\"\n                                \" your machine or less.\\n\");\n            }\n            break;\n        case 'D':\n            if (! optarg || ! optarg[0]) {\n                fprintf(stderr, \"No delimiter specified\\n\");\n                return 1;\n            }\n            settings.prefix_delimiter = optarg[0];\n            settings.detail_enabled = 1;\n            break;\n        case 'L' :\n            if (enable_large_pages() == 0) {\n                preallocate = true;\n            } else {\n                fprintf(stderr, \"Cannot enable large pages on this system\\n\"\n                    \"(There is no support as of this version)\\n\");\n                return 1;\n            }\n            break;\n        case 'C' :\n            settings.use_cas = false;\n            break;\n        case 'b' :\n            settings.backlog = atoi(optarg);\n            break;\n        case 'B':\n            protocol_specified = true;\n            if (strcmp(optarg, \"auto\") == 0) {\n                settings.binding_protocol = negotiating_prot;\n            } else if (strcmp(optarg, \"binary\") == 0) {\n                settings.binding_protocol = binary_prot;\n            } else if (strcmp(optarg, \"ascii\") == 0) {\n                settings.binding_protocol = ascii_prot;\n            } else {\n                fprintf(stderr, \"Invalid value for binding protocol: %s\\n\"\n                        \" -- should be one of auto, binary, or ascii\\n\", optarg);\n                exit(EX_USAGE);\n            }\n            break;\n        case 'I':\n            buf = strdup(optarg);\n            unit = buf[strlen(buf)-1];\n            if (unit == 'k' || unit == 'm' ||\n                unit == 'K' || unit == 'M') {\n                buf[strlen(buf)-1] = '\\0';\n                size_max = atoi(buf);\n                if (unit == 'k' || unit == 'K')\n                    size_max *= 1024;\n                if (unit == 'm' || unit == 'M')\n                    size_max *= 1024 * 1024;\n                settings.item_size_max = size_max;\n            } else {\n                settings.item_size_max = atoi(buf);\n            }\n            free(buf);\n            break;\n        case 'S': /* set Sasl authentication to true. Default is false */\n#ifndef ENABLE_SASL\n            fprintf(stderr, \"This server is not built with SASL support.\\n\");\n            exit(EX_USAGE);\n#endif\n            settings.sasl = true;\n            break;\n       case 'F' :\n            settings.flush_enabled = false;\n            break;\n       case 'X' :\n            settings.dump_enabled = false;\n            break;\n       case 'W' :\n            settings.watch_enabled = false;\n            break;\n       case 'Y' :\n            // dupe the file path now just in case the options get mangled.\n            settings.auth_file = strdup(optarg);\n            break;\n        case 'o': /* It's sub-opts time! */\n            subopts_orig = subopts = strdup(optarg); /* getsubopt() changes the original args */\n\n            while (*subopts != '\\0') {\n\n            switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {\n            case MAXCONNS_FAST:\n                settings.maxconns_fast = true;\n                break;\n            case HASHPOWER_INIT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing numeric argument for hashpower\\n\");\n                    return 1;\n                }\n                settings.hashpower_init = atoi(subopts_value);\n                if (settings.hashpower_init < 12) {\n                    fprintf(stderr, \"Initial hashtable multiplier of %d is too low\\n\",\n                        settings.hashpower_init);\n                    return 1;\n                } else if (settings.hashpower_init > 32) {\n                    fprintf(stderr, \"Initial hashtable multiplier of %d is too high\\n\"\n                        \"Choose a value based on \\\"STAT hash_power_level\\\" from a running instance\\n\",\n                        settings.hashpower_init);\n                    return 1;\n                }\n                break;\n            case NO_HASHEXPAND:\n                start_assoc_maint = false;\n                break;\n            case SLAB_REASSIGN:\n                settings.slab_reassign = true;\n                break;\n            case SLAB_AUTOMOVE:\n                if (subopts_value == NULL) {\n                    settings.slab_automove = 1;\n                    break;\n                }\n                settings.slab_automove = atoi(subopts_value);\n                if (settings.slab_automove < 0 || settings.slab_automove > 2) {\n                    fprintf(stderr, \"slab_automove must be between 0 and 2\\n\");\n                    return 1;\n                }\n                break;\n            case SLAB_AUTOMOVE_RATIO:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing slab_automove_ratio argument\\n\");\n                    return 1;\n                }\n                settings.slab_automove_ratio = atof(subopts_value);\n                if (settings.slab_automove_ratio <= 0 || settings.slab_automove_ratio > 1) {\n                    fprintf(stderr, \"slab_automove_ratio must be > 0 and < 1\\n\");\n                    return 1;\n                }\n                break;\n            case SLAB_AUTOMOVE_WINDOW:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing slab_automove_window argument\\n\");\n                    return 1;\n                }\n                settings.slab_automove_window = atoi(subopts_value);\n                if (settings.slab_automove_window < 3) {\n                    fprintf(stderr, \"slab_automove_window must be > 2\\n\");\n                    return 1;\n                }\n                break;\n            case TAIL_REPAIR_TIME:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing numeric argument for tail_repair_time\\n\");\n                    return 1;\n                }\n                settings.tail_repair_time = atoi(subopts_value);\n                if (settings.tail_repair_time < 10) {\n                    fprintf(stderr, \"Cannot set tail_repair_time to less than 10 seconds\\n\");\n                    return 1;\n                }\n                break;\n            case HASH_ALGORITHM:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing hash_algorithm argument\\n\");\n                    return 1;\n                };\n                if (strcmp(subopts_value, \"jenkins\") == 0) {\n                    hash_type = JENKINS_HASH;\n                } else if (strcmp(subopts_value, \"murmur3\") == 0) {\n                    hash_type = MURMUR3_HASH;\n                } else {\n                    fprintf(stderr, \"Unknown hash_algorithm option (jenkins, murmur3)\\n\");\n                    return 1;\n                }\n                break;\n            case LRU_CRAWLER:\n                start_lru_crawler = true;\n                break;\n            case LRU_CRAWLER_SLEEP:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing lru_crawler_sleep value\\n\");\n                    return 1;\n                }\n                settings.lru_crawler_sleep = atoi(subopts_value);\n                if (settings.lru_crawler_sleep > 1000000 || settings.lru_crawler_sleep < 0) {\n                    fprintf(stderr, \"LRU crawler sleep must be between 0 and 1 second\\n\");\n                    return 1;\n                }\n                break;\n            case LRU_CRAWLER_TOCRAWL:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing lru_crawler_tocrawl value\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &tocrawl)) {\n                    fprintf(stderr, \"lru_crawler_tocrawl takes a numeric 32bit value\\n\");\n                    return 1;\n                }\n                settings.lru_crawler_tocrawl = tocrawl;\n                break;\n            case LRU_MAINTAINER:\n                start_lru_maintainer = true;\n                settings.lru_segmented = true;\n                break;\n            case HOT_LRU_PCT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing hot_lru_pct argument\\n\");\n                    return 1;\n                }\n                settings.hot_lru_pct = atoi(subopts_value);\n                if (settings.hot_lru_pct < 1 || settings.hot_lru_pct >= 80) {\n                    fprintf(stderr, \"hot_lru_pct must be > 1 and < 80\\n\");\n                    return 1;\n                }\n                break;\n            case WARM_LRU_PCT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing warm_lru_pct argument\\n\");\n                    return 1;\n                }\n                settings.warm_lru_pct = atoi(subopts_value);\n                if (settings.warm_lru_pct < 1 || settings.warm_lru_pct >= 80) {\n                    fprintf(stderr, \"warm_lru_pct must be > 1 and < 80\\n\");\n                    return 1;\n                }\n                break;\n            case HOT_MAX_FACTOR:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing hot_max_factor argument\\n\");\n                    return 1;\n                }\n                settings.hot_max_factor = atof(subopts_value);\n                if (settings.hot_max_factor <= 0) {\n                    fprintf(stderr, \"hot_max_factor must be > 0\\n\");\n                    return 1;\n                }\n                break;\n            case WARM_MAX_FACTOR:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing warm_max_factor argument\\n\");\n                    return 1;\n                }\n                settings.warm_max_factor = atof(subopts_value);\n                if (settings.warm_max_factor <= 0) {\n                    fprintf(stderr, \"warm_max_factor must be > 0\\n\");\n                    return 1;\n                }\n                break;\n            case TEMPORARY_TTL:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing temporary_ttl argument\\n\");\n                    return 1;\n                }\n                settings.temp_lru = true;\n                settings.temporary_ttl = atoi(subopts_value);\n                break;\n            case IDLE_TIMEOUT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing numeric argument for idle_timeout\\n\");\n                    return 1;\n                }\n                settings.idle_timeout = atoi(subopts_value);\n                break;\n            case WATCHER_LOGBUF_SIZE:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing watcher_logbuf_size argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.logger_watcher_buf_size)) {\n                    fprintf(stderr, \"could not parse argument to watcher_logbuf_size\\n\");\n                    return 1;\n                }\n                settings.logger_watcher_buf_size *= 1024; /* kilobytes */\n                break;\n            case WORKER_LOGBUF_SIZE:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing worker_logbuf_size argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.logger_buf_size)) {\n                    fprintf(stderr, \"could not parse argument to worker_logbuf_size\\n\");\n                    return 1;\n                }\n                settings.logger_buf_size *= 1024; /* kilobytes */\n            case SLAB_SIZES:\n                slab_sizes_unparsed = strdup(subopts_value);\n                break;\n            case SLAB_CHUNK_MAX:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing slab_chunk_max argument\\n\");\n                }\n                if (!safe_strtol(subopts_value, &settings.slab_chunk_size_max)) {\n                    fprintf(stderr, \"could not parse argument to slab_chunk_max\\n\");\n                }\n                slab_chunk_size_changed = true;\n                break;\n            case TRACK_SIZES:\n                item_stats_sizes_init();\n                break;\n            case NO_INLINE_ASCII_RESP:\n                break;\n            case INLINE_ASCII_RESP:\n                break;\n            case NO_CHUNKED_ITEMS:\n                settings.slab_chunk_size_max = settings.slab_page_size;\n                break;\n            case NO_SLAB_REASSIGN:\n                settings.slab_reassign = false;\n                break;\n            case NO_SLAB_AUTOMOVE:\n                settings.slab_automove = 0;\n                break;\n            case NO_MAXCONNS_FAST:\n                settings.maxconns_fast = false;\n                break;\n            case NO_LRU_CRAWLER:\n                settings.lru_crawler = false;\n                start_lru_crawler = false;\n                break;\n            case NO_LRU_MAINTAINER:\n                start_lru_maintainer = false;\n                settings.lru_segmented = false;\n                break;\n#ifdef TLS\n            case SSL_CERT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ssl_chain_cert argument\\n\");\n                    return 1;\n                }\n                settings.ssl_chain_cert = strdup(subopts_value);\n                break;\n            case SSL_KEY:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ssl_key argument\\n\");\n                    return 1;\n                }\n                settings.ssl_key = strdup(subopts_value);\n                break;\n            case SSL_VERIFY_MODE:\n            {\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ssl_verify_mode argument\\n\");\n                    return 1;\n                }\n                int verify  = 0;\n                if (!safe_strtol(subopts_value, &verify)) {\n                    fprintf(stderr, \"could not parse argument to ssl_verify_mode\\n\");\n                    return 1;\n                }\n                switch(verify) {\n                    case 0:\n                        settings.ssl_verify_mode = SSL_VERIFY_NONE;\n                        break;\n                    case 1:\n                        settings.ssl_verify_mode = SSL_VERIFY_PEER;\n                        break;\n                    case 2:\n                        settings.ssl_verify_mode = SSL_VERIFY_PEER |\n                                                    SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n                        break;\n                    case 3:\n                        settings.ssl_verify_mode = SSL_VERIFY_PEER |\n                                                    SSL_VERIFY_FAIL_IF_NO_PEER_CERT |\n                                                    SSL_VERIFY_CLIENT_ONCE;\n                        break;\n                    default:\n                        fprintf(stderr, \"Invalid ssl_verify_mode. Use help to see valid options.\\n\");\n                        return 1;\n                }\n                break;\n            }\n            case SSL_KEYFORM:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ssl_keyformat argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtol(subopts_value, &settings.ssl_keyformat)) {\n                    fprintf(stderr, \"could not parse argument to ssl_keyformat\\n\");\n                    return 1;\n                }\n                break;\n            case SSL_CIPHERS:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ssl_ciphers argument\\n\");\n                    return 1;\n                }\n                settings.ssl_ciphers = strdup(subopts_value);\n                break;\n            case SSL_CA_CERT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ssl_ca_cert argument\\n\");\n                    return 1;\n                }\n                settings.ssl_ca_cert = strdup(subopts_value);\n                break;\n            case SSL_WBUF_SIZE:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ssl_wbuf_size argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.ssl_wbuf_size)) {\n                    fprintf(stderr, \"could not parse argument to ssl_wbuf_size\\n\");\n                    return 1;\n                }\n                settings.ssl_wbuf_size *= 1024; /* kilobytes */\n                break;\n#endif\n#ifdef EXTSTORE\n            case EXT_PAGE_SIZE:\n                if (storage_file) {\n                    fprintf(stderr, \"Must specify ext_page_size before any ext_path arguments\\n\");\n                    return 1;\n                }\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_page_size argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &ext_cf.page_size)) {\n                    fprintf(stderr, \"could not parse argument to ext_page_size\\n\");\n                    return 1;\n                }\n                ext_cf.page_size *= 1024 * 1024; /* megabytes */\n                break;\n            case EXT_WBUF_SIZE:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_wbuf_size argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &ext_cf.wbuf_size)) {\n                    fprintf(stderr, \"could not parse argument to ext_wbuf_size\\n\");\n                    return 1;\n                }\n                ext_cf.wbuf_size *= 1024 * 1024; /* megabytes */\n                settings.ext_wbuf_size = ext_cf.wbuf_size;\n                break;\n            case EXT_THREADS:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_threads argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &ext_cf.io_threadcount)) {\n                    fprintf(stderr, \"could not parse argument to ext_threads\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_IO_DEPTH:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_io_depth argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &ext_cf.io_depth)) {\n                    fprintf(stderr, \"could not parse argument to ext_io_depth\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_ITEM_SIZE:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_item_size argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.ext_item_size)) {\n                    fprintf(stderr, \"could not parse argument to ext_item_size\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_ITEM_AGE:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_item_age argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.ext_item_age)) {\n                    fprintf(stderr, \"could not parse argument to ext_item_age\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_LOW_TTL:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_low_ttl argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.ext_low_ttl)) {\n                    fprintf(stderr, \"could not parse argument to ext_low_ttl\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_RECACHE_RATE:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_recache_rate argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.ext_recache_rate)) {\n                    fprintf(stderr, \"could not parse argument to ext_recache_rate\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_COMPACT_UNDER:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_compact_under argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.ext_compact_under)) {\n                    fprintf(stderr, \"could not parse argument to ext_compact_under\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_DROP_UNDER:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_drop_under argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.ext_drop_under)) {\n                    fprintf(stderr, \"could not parse argument to ext_drop_under\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_MAX_FRAG:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing ext_max_frag argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtod(subopts_value, &settings.ext_max_frag)) {\n                    fprintf(stderr, \"could not parse argument to ext_max_frag\\n\");\n                    return 1;\n                }\n                break;\n            case SLAB_AUTOMOVE_FREERATIO:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing slab_automove_freeratio argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtod(subopts_value, &settings.slab_automove_freeratio)) {\n                    fprintf(stderr, \"could not parse argument to slab_automove_freeratio\\n\");\n                    return 1;\n                }\n                break;\n            case EXT_DROP_UNREAD:\n                settings.ext_drop_unread = true;\n                break;\n            case EXT_PATH:\n                if (subopts_value) {\n                    struct extstore_conf_file *tmp = storage_conf_parse(subopts_value, ext_cf.page_size);\n                    if (tmp == NULL) {\n                        fprintf(stderr, \"failed to parse ext_path argument\\n\");\n                        return 1;\n                    }\n                    if (storage_file != NULL) {\n                        tmp->next = storage_file;\n                    }\n                    storage_file = tmp;\n                } else {\n                    fprintf(stderr, \"missing argument to ext_path, ie: ext_path=/d/file:5G\\n\");\n                    return 1;\n                }\n                break;\n#endif\n            case MODERN:\n                /* currently no new defaults */\n                break;\n            case NO_MODERN:\n                if (!slab_chunk_size_changed) {\n                    settings.slab_chunk_size_max = settings.slab_page_size;\n                }\n                settings.slab_reassign = false;\n                settings.slab_automove = 0;\n                settings.maxconns_fast = false;\n                settings.lru_segmented = false;\n                hash_type = JENKINS_HASH;\n                start_lru_crawler = false;\n                start_lru_maintainer = false;\n                break;\n            case NO_DROP_PRIVILEGES:\n                settings.drop_privileges = false;\n                break;\n            case DROP_PRIVILEGES:\n                settings.drop_privileges = true;\n                break;\n            case RESP_OBJ_MEM_LIMIT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing resp_obj_mem_limit argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.resp_obj_mem_limit)) {\n                    fprintf(stderr, \"could not parse argument to resp_obj_mem_limit\\n\");\n                    return 1;\n                }\n                settings.resp_obj_mem_limit *= 1024 * 1024; /* megabytes */\n                break;\n            case READ_BUF_MEM_LIMIT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing read_buf_mem_limit argument\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &settings.read_buf_mem_limit)) {\n                    fprintf(stderr, \"could not parse argument to read_buf_mem_limit\\n\");\n                    return 1;\n                }\n                settings.read_buf_mem_limit *= 1024 * 1024; /* megabytes */\n                break;\n#ifdef MEMCACHED_DEBUG\n            case RELAXED_PRIVILEGES:\n                settings.relaxed_privileges = true;\n                break;\n#endif\n            default:\n                printf(\"Illegal suboption \\\"%s\\\"\\n\", subopts_value);\n                return 1;\n            }\n\n            }\n            free(subopts_orig);\n            break;\n        default:\n            fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    if (settings.item_size_max < ITEM_SIZE_MAX_LOWER_LIMIT) {\n        fprintf(stderr, \"Item max size cannot be less than 1024 bytes.\\n\");\n        exit(EX_USAGE);\n    }\n    if (settings.item_size_max > (settings.maxbytes / 2)) {\n        fprintf(stderr, \"Cannot set item size limit higher than 1/2 of memory max.\\n\");\n        exit(EX_USAGE);\n    }\n    if (settings.item_size_max > (ITEM_SIZE_MAX_UPPER_LIMIT)) {\n        fprintf(stderr, \"Cannot set item size limit higher than a gigabyte.\\n\");\n        exit(EX_USAGE);\n    }\n    if (settings.item_size_max > 1024 * 1024) {\n        if (!slab_chunk_size_changed) {\n            // Ideal new default is 16k, but needs stitching.\n            settings.slab_chunk_size_max = settings.slab_page_size / 2;\n        }\n    }\n\n    if (settings.slab_chunk_size_max > settings.item_size_max) {\n        fprintf(stderr, \"slab_chunk_max (bytes: %d) cannot be larger than -I (item_size_max %d)\\n\",\n                settings.slab_chunk_size_max, settings.item_size_max);\n        exit(EX_USAGE);\n    }\n\n    if (settings.item_size_max % settings.slab_chunk_size_max != 0) {\n        fprintf(stderr, \"-I (item_size_max: %d) must be evenly divisible by slab_chunk_max (bytes: %d)\\n\",\n                settings.item_size_max, settings.slab_chunk_size_max);\n        exit(EX_USAGE);\n    }\n\n    if (settings.slab_page_size % settings.slab_chunk_size_max != 0) {\n        fprintf(stderr, \"slab_chunk_max (bytes: %d) must divide evenly into %d (slab_page_size)\\n\",\n                settings.slab_chunk_size_max, settings.slab_page_size);\n        exit(EX_USAGE);\n    }\n#ifdef EXTSTORE\n    if (storage_file) {\n        if (settings.item_size_max > ext_cf.wbuf_size) {\n            fprintf(stderr, \"-I (item_size_max: %d) cannot be larger than ext_wbuf_size: %d\\n\",\n                settings.item_size_max, ext_cf.wbuf_size);\n            exit(EX_USAGE);\n        }\n\n        if (settings.udpport) {\n            fprintf(stderr, \"Cannot use UDP with extstore enabled (-U 0 to disable)\\n\");\n            exit(EX_USAGE);\n        }\n    }\n#endif\n    // Reserve this for the new default. If factor size hasn't changed, use\n    // new default.\n    /*if (settings.slab_chunk_size_max == 16384 && settings.factor == 1.25) {\n        settings.factor = 1.08;\n    }*/\n\n    if (slab_sizes_unparsed != NULL) {\n        // want the unedited string for restart code.\n        char *temp = strdup(slab_sizes_unparsed);\n        if (_parse_slab_sizes(slab_sizes_unparsed, slab_sizes)) {\n            use_slab_sizes = true;\n            if (meta->slab_config) {\n                free(meta->slab_config);\n            }\n            meta->slab_config = temp;\n        } else {\n            exit(EX_USAGE);\n        }\n    } else if (!meta->slab_config) {\n        // using the default factor.\n        meta->slab_config = \"1.25\";\n    }\n\n    if (settings.hot_lru_pct + settings.warm_lru_pct > 80) {\n        fprintf(stderr, \"hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\\n\");\n        exit(EX_USAGE);\n    }\n\n    if (settings.temp_lru && !start_lru_maintainer) {\n        fprintf(stderr, \"temporary_ttl requires lru_maintainer to be enabled\\n\");\n        exit(EX_USAGE);\n    }\n\n    if (hash_init(hash_type) != 0) {\n        fprintf(stderr, \"Failed to initialize hash_algorithm!\\n\");\n        exit(EX_USAGE);\n    }\n\n    /*\n     * Use one workerthread to serve each UDP port if the user specified\n     * multiple ports\n     */\n    if (settings.inter != NULL && strchr(settings.inter, ',')) {\n        settings.num_threads_per_udp = 1;\n    } else {\n        settings.num_threads_per_udp = settings.num_threads;\n    }\n\n    if (settings.sasl) {\n        if (!protocol_specified) {\n            settings.binding_protocol = binary_prot;\n        } else {\n            if (settings.binding_protocol != binary_prot) {\n                fprintf(stderr, \"ERROR: You cannot allow the ASCII protocol while using SASL.\\n\");\n                exit(EX_USAGE);\n            }\n        }\n\n        if (settings.udpport) {\n            fprintf(stderr, \"ERROR: Cannot enable UDP while using binary SASL authentication.\\n\");\n            exit(EX_USAGE);\n        }\n    }\n\n    if (settings.auth_file) {\n        if (!protocol_specified) {\n            settings.binding_protocol = ascii_prot;\n        } else {\n            if (settings.binding_protocol != ascii_prot) {\n                fprintf(stderr, \"ERROR: You cannot allow the BINARY protocol while using ascii authentication tokens.\\n\");\n                exit(EX_USAGE);\n            }\n        }\n    }\n\n    if (udp_specified && settings.udpport != 0 && !tcp_specified) {\n        settings.port = settings.udpport;\n    }\n\n\n#ifdef TLS\n    /*\n     * Setup SSL if enabled\n     */\n    if (settings.ssl_enabled) {\n        if (!settings.port) {\n            fprintf(stderr, \"ERROR: You cannot enable SSL without a TCP port.\\n\");\n            exit(EX_USAGE);\n        }\n        // openssl init methods.\n        SSL_load_error_strings();\n        SSLeay_add_ssl_algorithms();\n        // Initiate the SSL context.\n        ssl_init();\n    }\n#endif\n\n    if (maxcore != 0) {\n        struct rlimit rlim_new;\n        /*\n         * First try raising to infinity; if that fails, try bringing\n         * the soft limit to the hard.\n         */\n        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {\n            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;\n            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {\n                /* failed. try raising just to the old max */\n                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;\n                (void)setrlimit(RLIMIT_CORE, &rlim_new);\n            }\n        }\n        /*\n         * getrlimit again to see what we ended up with. Only fail if\n         * the soft limit ends up 0, because then no core files will be\n         * created at all.\n         */\n\n        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {\n            fprintf(stderr, \"failed to ensure corefile creation\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /*\n     * If needed, increase rlimits to allow as many connections\n     * as needed.\n     */\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n        fprintf(stderr, \"failed to getrlimit number of files\\n\");\n        exit(EX_OSERR);\n    } else {\n        rlim.rlim_cur = settings.maxconns;\n        rlim.rlim_max = settings.maxconns;\n        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n            fprintf(stderr, \"failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /* lose root privileges if we have them */\n    if (getuid() == 0 || geteuid() == 0) {\n        if (username == 0 || *username == '\\0') {\n            fprintf(stderr, \"can't run as root without the -u switch\\n\");\n            exit(EX_USAGE);\n        }\n        if ((pw = getpwnam(username)) == 0) {\n            fprintf(stderr, \"can't find the user %s to switch to\\n\", username);\n            exit(EX_NOUSER);\n        }\n        if (setgroups(0, NULL) < 0) {\n            /* setgroups may fail with EPERM, indicating we are already in a\n             * minimally-privileged state. In that case we continue. For all\n             * other failure codes we exit.\n             *\n             * Note that errno is stored here because fprintf may change it.\n             */\n            bool should_exit = errno != EPERM;\n            fprintf(stderr, \"failed to drop supplementary groups: %s\\n\",\n                    strerror(errno));\n            if (should_exit) {\n                exit(EX_OSERR);\n            }\n        }\n        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {\n            fprintf(stderr, \"failed to assume identity of user %s\\n\", username);\n            exit(EX_OSERR);\n        }\n    }\n\n    /* Initialize Sasl if -S was specified */\n    if (settings.sasl) {\n        init_sasl();\n    }\n\n    /* daemonize if requested */\n    /* if we want to ensure our ability to dump core, don't chdir to / */\n    if (do_daemonize) {\n        if (sigignore(SIGHUP) == -1) {\n            perror(\"Failed to ignore SIGHUP\");\n        }\n        if (daemonize(maxcore, settings.verbose) == -1) {\n            fprintf(stderr, \"failed to daemon() in order to daemonize\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* lock paged memory if needed */\n    if (lock_memory) {\n#ifdef HAVE_MLOCKALL\n        int res = mlockall(MCL_CURRENT | MCL_FUTURE);\n        if (res != 0) {\n            fprintf(stderr, \"warning: -k invalid, mlockall() failed: %s\\n\",\n                    strerror(errno));\n        }\n#else\n        fprintf(stderr, \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");\n#endif\n    }\n\n    /* initialize main thread libevent instance */\n#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101\n    /* If libevent version is larger/equal to 2.0.2-alpha, use newer version */\n    struct event_config *ev_config;\n    ev_config = event_config_new();\n    event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);\n    main_base = event_base_new_with_config(ev_config);\n    event_config_free(ev_config);\n#else\n    /* Otherwise, use older API */\n    main_base = event_init();\n#endif\n\n    /* Load initial auth file if required */\n    if (settings.auth_file) {\n        if (settings.udpport) {\n            fprintf(stderr, \"Cannot use UDP with ascii authentication enabled (-U 0 to disable)\\n\");\n            exit(EX_USAGE);\n        }\n\n        switch (authfile_load(settings.auth_file)) {\n            case AUTHFILE_MISSING: // fall through.\n            case AUTHFILE_OPENFAIL:\n                vperror(\"Could not open authfile [%s] for reading\", settings.auth_file);\n                exit(EXIT_FAILURE);\n                break;\n            case AUTHFILE_OOM:\n                fprintf(stderr, \"Out of memory reading password file: %s\", settings.auth_file);\n                exit(EXIT_FAILURE);\n                break;\n            case AUTHFILE_MALFORMED:\n                fprintf(stderr, \"Authfile [%s] has a malformed entry. Should be 'user:password'\", settings.auth_file);\n                exit(EXIT_FAILURE);\n                break;\n            case AUTHFILE_OK:\n                break;\n        }\n    }\n\n    /* initialize other stuff */\n    stats_init();\n    logger_init();\n    conn_init();\n    bool reuse_mem = false;\n    void *mem_base = NULL;\n    bool prefill = false;\n    if (memory_file != NULL) {\n        preallocate = true;\n        // Easier to manage memory if we prefill the global pool when reusing.\n        prefill = true;\n        restart_register(\"main\", _mc_meta_load_cb, _mc_meta_save_cb, meta);\n        reuse_mem = restart_mmap_open(settings.maxbytes,\n                        memory_file,\n                        &mem_base);\n        // The \"save\" callback gets called when we're closing out the mmap,\n        // but we don't know what the mmap_base is until after we call open.\n        // So we pass the struct above but have to fill it in here so the\n        // data's available during the save routine.\n        meta->mmap_base = mem_base;\n        // Also, the callbacks for load() run before _open returns, so we\n        // should have the old base in 'meta' as of here.\n    }\n    // Initialize the hash table _after_ checking restart metadata.\n    // We override the hash table start argument with what was live\n    // previously, to avoid filling a huge set of items into a tiny hash\n    // table.\n    assoc_init(settings.hashpower_init);\n#ifdef EXTSTORE\n    if (storage_file && reuse_mem) {\n        fprintf(stderr, \"[restart] memory restart with extstore not presently supported.\\n\");\n        reuse_mem = false;\n    }\n#endif\n    slabs_init(settings.maxbytes, settings.factor, preallocate,\n            use_slab_sizes ? slab_sizes : NULL, mem_base, reuse_mem);\n#ifdef EXTSTORE\n    if (storage_file) {\n        enum extstore_res eres;\n        if (settings.ext_compact_under == 0) {\n            // If changing the default fraction (4), change the help text as well.\n            settings.ext_compact_under = storage_file->page_count / 4;\n            /* Only rescues non-COLD items if below this threshold */\n            settings.ext_drop_under = storage_file->page_count / 4;\n        }\n        crc32c_init();\n        /* Init free chunks to zero. */\n        for (int x = 0; x < MAX_NUMBER_OF_SLAB_CLASSES; x++) {\n            settings.ext_free_memchunks[x] = 0;\n        }\n        storage = extstore_init(storage_file, &ext_cf, &eres);\n        if (storage == NULL) {\n            fprintf(stderr, \"Failed to initialize external storage: %s\\n\",\n                    extstore_err(eres));\n            if (eres == EXTSTORE_INIT_OPEN_FAIL) {\n                perror(\"extstore open\");\n            }\n            exit(EXIT_FAILURE);\n        }\n        ext_storage = storage;\n        /* page mover algorithm for extstore needs memory prefilled */\n        prefill = true;\n    }\n#endif\n\n    if (settings.drop_privileges) {\n        setup_privilege_violations_handler();\n    }\n\n    if (prefill)\n        slabs_prefill_global();\n    /* In restartable mode and we've decided to issue a fixup on memory */\n    if (memory_file != NULL && reuse_mem) {\n        mc_ptr_t old_base = meta->old_base;\n        assert(old_base == meta->old_base);\n\n        // should've pulled in process_started from meta file.\n        process_started = meta->process_started;\n        // TODO: must be a more canonical way of serializing/deserializing\n        // pointers? passing through uint64_t should work, and we're not\n        // annotating the pointer with anything, but it's still slightly\n        // insane.\n        restart_fixup((void *)old_base);\n    }\n    /*\n     * ignore SIGPIPE signals; we can use errno == EPIPE if we\n     * need that information\n     */\n    if (sigignore(SIGPIPE) == -1) {\n        perror(\"failed to ignore SIGPIPE; sigaction\");\n        exit(EX_OSERR);\n    }\n    /* start up worker threads if MT mode */\n#ifdef EXTSTORE\n    slabs_set_storage(storage);\n    memcached_thread_init(settings.num_threads, storage);\n    init_lru_crawler(storage);\n#else\n    memcached_thread_init(settings.num_threads, NULL);\n    init_lru_crawler(NULL);\n#endif\n\n    if (start_assoc_maint && start_assoc_maintenance_thread() == -1) {\n        exit(EXIT_FAILURE);\n    }\n    if (start_lru_crawler && start_item_crawler_thread() != 0) {\n        fprintf(stderr, \"Failed to enable LRU crawler thread\\n\");\n        exit(EXIT_FAILURE);\n    }\n#ifdef EXTSTORE\n    if (storage && start_storage_compact_thread(storage) != 0) {\n        fprintf(stderr, \"Failed to start storage compaction thread\\n\");\n        exit(EXIT_FAILURE);\n    }\n    if (storage && start_storage_write_thread(storage) != 0) {\n        fprintf(stderr, \"Failed to start storage writer thread\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (start_lru_maintainer && start_lru_maintainer_thread(storage) != 0) {\n#else\n    if (start_lru_maintainer && start_lru_maintainer_thread(NULL) != 0) {\n#endif\n        fprintf(stderr, \"Failed to enable LRU maintainer thread\\n\");\n        free(meta);\n        return 1;\n    }\n\n    if (settings.slab_reassign &&\n        start_slab_maintenance_thread() == -1) {\n        exit(EXIT_FAILURE);\n    }\n\n    if (settings.idle_timeout && start_conn_timeout_thread() == -1) {\n        exit(EXIT_FAILURE);\n    }\n\n    /* initialise clock event */\n#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)\n    {\n        struct timespec ts;\n        if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0) {\n            monotonic = true;\n            monotonic_start = ts.tv_sec;\n            // Monotonic clock needs special handling for restarts.\n            // We get a start time at an arbitrary place, so we need to\n            // restore the original time delta, which is always \"now\" - _start\n            if (reuse_mem) {\n                // the running timespan at stop time + the time we think we\n                // were stopped.\n                monotonic_start -= meta->current_time + meta->time_delta;\n            } else {\n                monotonic_start -= ITEM_UPDATE_INTERVAL + 2;\n            }\n        }\n    }\n#endif\n    clock_handler(0, 0, 0);\n\n    /* create unix mode sockets after dropping privileges */\n    if (settings.socketpath != NULL) {\n        errno = 0;\n        if (server_socket_unix(settings.socketpath,settings.access)) {\n            vperror(\"failed to listen on UNIX socket: %s\", settings.socketpath);\n            exit(EX_OSERR);\n        }\n    }\n\n    /* create the listening socket, bind it, and init */\n    if (settings.socketpath == NULL) {\n        const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");\n        char *temp_portnumber_filename = NULL;\n        size_t len;\n        FILE *portnumber_file = NULL;\n\n        if (portnumber_filename != NULL) {\n            len = strlen(portnumber_filename)+4+1;\n            temp_portnumber_filename = malloc(len);\n            snprintf(temp_portnumber_filename,\n                     len,\n                     \"%s.lck\", portnumber_filename);\n\n            portnumber_file = fopen(temp_portnumber_filename, \"a\");\n            if (portnumber_file == NULL) {\n                fprintf(stderr, \"Failed to open \\\"%s\\\": %s\\n\",\n                        temp_portnumber_filename, strerror(errno));\n            }\n        }\n\n        errno = 0;\n        if (settings.port && server_sockets(settings.port, tcp_transport,\n                                           portnumber_file)) {\n            vperror(\"failed to listen on TCP port %d\", settings.port);\n            exit(EX_OSERR);\n        }\n\n        /*\n         * initialization order: first create the listening sockets\n         * (may need root on low ports), then drop root if needed,\n         * then daemonize if needed, then init libevent (in some cases\n         * descriptors created by libevent wouldn't survive forking).\n         */\n\n        /* create the UDP listening socket and bind it */\n        errno = 0;\n        if (settings.udpport && server_sockets(settings.udpport, udp_transport,\n                                              portnumber_file)) {\n            vperror(\"failed to listen on UDP port %d\", settings.udpport);\n            exit(EX_OSERR);\n        }\n\n        if (portnumber_file) {\n            fclose(portnumber_file);\n            rename(temp_portnumber_filename, portnumber_filename);\n        }\n        if (temp_portnumber_filename)\n            free(temp_portnumber_filename);\n    }\n\n    /* Give the sockets a moment to open. I know this is dumb, but the error\n     * is only an advisory.\n     */\n    usleep(1000);\n    if (stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {\n        fprintf(stderr, \"Maxconns setting is too low, use -c to increase.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid_file != NULL) {\n        save_pid(pid_file);\n    }\n\n    /* Drop privileges no longer needed */\n    if (settings.drop_privileges) {\n        drop_privileges();\n    }\n\n    /* Initialize the uriencode lookup table. */\n    uriencode_init();\n\n    /* enter the event loop */\n    while (!stop_main_loop) {\n        if (event_base_loop(main_base, EVLOOP_ONCE) != 0) {\n            retval = EXIT_FAILURE;\n            break;\n        }\n    }\n\n    fprintf(stderr, \"Gracefully stopping\\n\");\n    stop_threads();\n    int i;\n    // FIXME: make a function callable from threads.c\n    for (i = 0; i < max_fds; i++) {\n        if (conns[i] && conns[i]->state != conn_closed) {\n            conn_close(conns[i]);\n        }\n    }\n    if (memory_file != NULL) {\n        restart_mmap_close();\n    }\n\n    /* remove the PID file if we're a daemon */\n    if (do_daemonize)\n        remove_pidfile(pid_file);\n    /* Clean up strdup() call for bind() address */\n    if (settings.inter)\n      free(settings.inter);\n\n    /* cleanup base */\n    event_base_free(main_base);\n\n    free(meta);\n\n    return retval;\n}\n"], "filenames": ["memcached.c"], "buggy_code_start_loc": [6178], "buggy_code_end_loc": [6180], "fixing_code_start_loc": [6178], "fixing_code_end_loc": [6181], "type": "CWE-120", "message": "Memcached 1.6.x before 1.6.2 allows remote attackers to cause a denial of service (daemon crash) via a crafted binary protocol header to try_read_command_binary in memcached.c.", "other": {"cve": {"id": "CVE-2020-10931", "sourceIdentifier": "cve@mitre.org", "published": "2020-03-24T15:15:12.107", "lastModified": "2020-03-27T19:48:07.003", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Memcached 1.6.x before 1.6.2 allows remote attackers to cause a denial of service (daemon crash) via a crafted binary protocol header to try_read_command_binary in memcached.c."}, {"lang": "es", "value": "Memcached versiones 1.6.x anteriores a la versi\u00f3n 1.6.2, permite a atacantes remotos causar una denegaci\u00f3n de servicio (bloqueo del demonio) por medio de un encabezado de protocolo binario dise\u00f1ado para la funci\u00f3n try_read_command_binary en el archivo memcached.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:memcached:memcached:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.6.0", "versionEndExcluding": "1.6.2", "matchCriteriaId": "4B224531-B654-4A70-A6B9-476B6A03D1DF"}]}]}], "references": [{"url": "https://github.com/memcached/memcached/commit/02c6a2b62ddcb6fa4569a591d3461a156a636305", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/memcached/memcached/issues/629", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/memcached/memcached/wiki/ReleaseNotes162", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/memcached/memcached/commit/02c6a2b62ddcb6fa4569a591d3461a156a636305"}}