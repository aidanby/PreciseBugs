{"buggy_code": ["#include \"extensions/common/wasm/wasm.h\"\n\n#include <stdio.h>\n\n#include <limits>\n#include <memory>\n#include <string>\n\n#include \"envoy/common/exception.h\"\n#include \"envoy/config/wasm/v2/wasm.pb.validate.h\"\n#include \"envoy/grpc/status.h\"\n#include \"envoy/http/codes.h\"\n#include \"envoy/local_info/local_info.h\"\n#include \"envoy/server/wasm.h\"\n#include \"envoy/thread_local/thread_local.h\"\n\n#include \"common/buffer/buffer_impl.h\"\n#include \"common/common/assert.h\"\n#include \"common/common/base64.h\"\n#include \"common/common/empty_string.h\"\n#include \"common/common/enum_to_int.h\"\n#include \"common/common/logger.h\"\n#include \"common/config/datasource.h\"\n#include \"common/http/header_map_impl.h\"\n#include \"common/http/message_impl.h\"\n#include \"common/http/utility.h\"\n#include \"common/tracing/http_tracer_impl.h\"\n\n#include \"extensions/common/wasm/wasm_state.h\"\n#include \"extensions/common/wasm/well_known_names.h\"\n#include \"extensions/filters/common/expr/context.h\"\n\n#include \"absl/base/casts.h\"\n#include \"absl/container/flat_hash_map.h\"\n#include \"absl/container/node_hash_map.h\"\n#include \"absl/synchronization/mutex.h\"\n#include \"eval/eval/field_access.h\"\n#include \"eval/eval/field_backed_list_impl.h\"\n#include \"eval/eval/field_backed_map_impl.h\"\n#include \"eval/public/cel_value.h\"\n#include \"openssl/bytestring.h\"\n#include \"openssl/hmac.h\"\n#include \"openssl/sha.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Common {\nnamespace Wasm {\n\n// Any currently executing Wasm call context.\n#define WASM_CONTEXT(_c)                                                                           \\\n  (ContextOrEffectiveContext(static_cast<Context*>((void)_c, current_context_)))\n// The id of the context which should be used for calls out of the VM in place of current_context_\n// above.\n\nnamespace {\n\n// TODO: move to utils during upstreaming.\nstd::string base64Sha256(absl::string_view data) {\n  std::vector<uint8_t> digest(SHA256_DIGEST_LENGTH);\n  EVP_MD_CTX* ctx(EVP_MD_CTX_new());\n  auto rc = EVP_DigestInit(ctx, EVP_sha256());\n  RELEASE_ASSERT(rc == 1, \"Failed to init digest context\");\n  rc = EVP_DigestUpdate(ctx, data.data(), data.size());\n  RELEASE_ASSERT(rc == 1, \"Failed to update digest\");\n  rc = EVP_DigestFinal(ctx, digest.data(), nullptr);\n  RELEASE_ASSERT(rc == 1, \"Failed to finalize digest\");\n  EVP_MD_CTX_free(ctx);\n  return Base64::encode(reinterpret_cast<const char*>(&digest[0]), digest.size());\n}\n\ninline Word wasmResultToWord(WasmResult r) { return Word(static_cast<uint64_t>(r)); }\n\ninline uint32_t convertWordToUint32(Word w) { return static_cast<uint32_t>(w.u64_); }\n\n// Convert a function of the form Word(Word...) to one of the form uint32_t(uint32_t...).\ntemplate <typename F, F* fn> struct ConvertFunctionWordToUint32 {\n  static void convertFunctionWordToUint32() {}\n};\ntemplate <typename R, typename... Args, auto (*F)(Args...)->R>\nstruct ConvertFunctionWordToUint32<R(Args...), F> {\n  static auto convertFunctionWordToUint32(typename ConvertWordTypeToUint32<Args>::type... args) {\n    return convertWordToUint32(F(std::forward<Args>(args)...));\n  }\n};\ntemplate <typename... Args, auto (*F)(Args...)->void>\nstruct ConvertFunctionWordToUint32<void(Args...), F> {\n  static void convertFunctionWordToUint32(typename ConvertWordTypeToUint32<Args>::type... args) {\n    F(std::forward<Args>(args)...);\n  }\n};\n\nclass SharedData {\npublic:\n  WasmResult get(absl::string_view vm_id, const absl::string_view key,\n                 std::pair<std::string, uint32_t>* result) {\n    absl::ReaderMutexLock l(&mutex);\n    auto map = data.find(vm_id);\n    if (map == data.end()) {\n      return WasmResult::NotFound;\n    }\n    auto it = map->second.find(key);\n    if (it != map->second.end()) {\n      *result = it->second;\n      return WasmResult::Ok;\n    }\n    return WasmResult::NotFound;\n  }\n\n  WasmResult set(absl::string_view vm_id, absl::string_view key, absl::string_view value,\n                 uint32_t cas) {\n    absl::WriterMutexLock l(&mutex);\n    absl::flat_hash_map<std::string, std::pair<std::string, uint32_t>>* map;\n    auto map_it = data.find(vm_id);\n    if (map_it == data.end()) {\n      map = &data[vm_id];\n    } else {\n      map = &map_it->second;\n    }\n    auto it = map->find(key);\n    if (it != map->end()) {\n      if (cas && cas != it->second.second) {\n        return WasmResult::CasMismatch;\n      }\n      it->second = std::make_pair(std::string(value), nextCas());\n    } else {\n      map->emplace(key, std::make_pair(std::string(value), nextCas()));\n    }\n    return WasmResult::Ok;\n  }\n\n  uint32_t registerQueue(absl::string_view vm_id, absl::string_view queue_name, uint32_t context_id,\n                         Event::Dispatcher& dispatcher) {\n    absl::WriterMutexLock l(&mutex);\n    auto key = std::make_pair(std::string(vm_id), std::string(queue_name));\n    auto it = queue_tokens.insert(std::make_pair(key, static_cast<uint32_t>(0)));\n    if (it.second) {\n      it.first->second = nextQueueToken();\n      queue_token_set.insert(it.first->second);\n    }\n    uint32_t token = it.first->second;\n    auto& q = queues[token];\n    q.vm_id = std::string(vm_id);\n    q.context_id = context_id;\n    q.dispatcher = &dispatcher;\n    // Preserve any existing data.\n    return token;\n  }\n\n  uint32_t resolveQueue(absl::string_view vm_id, absl::string_view queue_name) {\n    absl::WriterMutexLock l(&mutex);\n    auto key = std::make_pair(std::string(vm_id), std::string(queue_name));\n    auto it = queue_tokens.find(key);\n    if (it != queue_tokens.end()) {\n      return it->second;\n    }\n    return 0; // N.B. zero indicates that the queue was not found.\n  }\n\n  WasmResult dequeue(uint32_t token, std::string* data) {\n    absl::ReaderMutexLock l(&mutex);\n    auto it = queues.find(token);\n    if (it == queues.end()) {\n      return WasmResult::NotFound;\n    }\n    if (it->second.queue.empty()) {\n      return WasmResult::Empty;\n    }\n    *data = it->second.queue.front();\n    it->second.queue.pop_front();\n    return WasmResult::Ok;\n  }\n\n  WasmResult enqueue(uint32_t token, absl::string_view value) {\n    absl::WriterMutexLock l(&mutex);\n    auto it = queues.find(token);\n    if (it == queues.end()) {\n      return WasmResult::NotFound;\n    }\n    it->second.queue.push_back(std::string(value));\n    auto vm_id = it->second.vm_id;\n    auto context_id = it->second.context_id;\n    it->second.dispatcher->post([vm_id, context_id, token] {\n      auto wasm = getThreadLocalWasmPtr(vm_id);\n      if (wasm) {\n        wasm->queueReady(context_id, token);\n      }\n    });\n    return WasmResult::Ok;\n  }\n\n  uint32_t nextCas() {\n    auto result = cas;\n    cas++;\n    if (!cas) { // 0 is not a valid CAS value.\n      cas++;\n    }\n    return result;\n  }\n\nprivate:\n  uint32_t nextQueueToken() {\n    while (true) {\n      uint32_t token = next_queue_token++;\n      if (token == 0) {\n        continue; // 0 is an illegal token.\n      }\n      if (queue_token_set.find(token) == queue_token_set.end()) {\n        return token;\n      }\n    }\n  }\n\n  struct Queue {\n    std::string vm_id;\n    uint32_t context_id;\n    Event::Dispatcher* dispatcher;\n    std::deque<std::string> queue;\n  };\n\n  absl::Mutex mutex;\n  uint32_t cas = 1;\n  uint32_t next_queue_token = 1;\n  absl::node_hash_map<std::string,\n                      absl::flat_hash_map<std::string, std::pair<std::string, uint32_t>>>\n      data;\n  absl::node_hash_map<uint32_t, Queue> queues;\n  struct pair_hash {\n    template <class T1, class T2> std::size_t operator()(const std::pair<T1, T2>& pair) const {\n      return std::hash<T1>()(pair.first) ^ std::hash<T2>()(pair.second);\n    }\n  };\n  absl::flat_hash_map<std::pair<std::string, std::string>, uint32_t, pair_hash> queue_tokens;\n  absl::flat_hash_set<uint32_t> queue_token_set;\n};\n\nSharedData global_shared_data;\n\n// Map from Wasm ID to the local Wasm instance.\nthread_local absl::flat_hash_map<std::string, std::weak_ptr<Wasm>> local_wasms;\n\nconst std::string INLINE_STRING = \"<inline>\";\n\ntemplate <typename Pairs> size_t pairsSize(const Pairs& result) {\n  size_t size = 4; // number of headers\n  for (auto& p : result) {\n    size += 8;                   // size of key, size of value\n    size += p.first.size() + 1;  // null terminated key\n    size += p.second.size() + 1; // null terminated value\n  }\n  return size;\n}\n\ntemplate <typename Pairs> void marshalPairs(const Pairs& result, char* buffer) {\n  char* b = buffer;\n  *reinterpret_cast<uint32_t*>(b) = result.size();\n  b += sizeof(uint32_t);\n  for (auto& p : result) {\n    *reinterpret_cast<uint32_t*>(b) = p.first.size();\n    b += sizeof(uint32_t);\n    *reinterpret_cast<uint32_t*>(b) = p.second.size();\n    b += sizeof(uint32_t);\n  }\n  for (auto& p : result) {\n    memcpy(b, p.first.data(), p.first.size());\n    b += p.first.size();\n    *b++ = 0;\n    memcpy(b, p.second.data(), p.second.size());\n    b += p.second.size();\n    *b++ = 0;\n  }\n}\n\nPairs toPairs(absl::string_view buffer) {\n  Pairs result;\n  const char* b = buffer.data();\n  if (buffer.size() < sizeof(uint32_t)) {\n    return {};\n  }\n  auto size = *reinterpret_cast<const uint32_t*>(b);\n  b += sizeof(uint32_t);\n  if (sizeof(uint32_t) + size * 2 * sizeof(uint32_t) > buffer.size()) {\n    return {};\n  }\n  result.resize(size);\n  for (uint32_t i = 0; i < size; i++) {\n    result[i].first = absl::string_view(nullptr, *reinterpret_cast<const uint32_t*>(b));\n    b += sizeof(uint32_t);\n    result[i].second = absl::string_view(nullptr, *reinterpret_cast<const uint32_t*>(b));\n    b += sizeof(uint32_t);\n  }\n  for (auto& p : result) {\n    p.first = absl::string_view(b, p.first.size());\n    b += p.first.size() + 1;\n    p.second = absl::string_view(b, p.second.size());\n    b += p.second.size() + 1;\n  }\n  return result;\n}\n\ntemplate <typename Pairs>\nbool getPairs(Context* context, const Pairs& result, uint64_t ptr_ptr, uint64_t size_ptr) {\n  if (result.empty()) {\n    return context->wasm()->copyToPointerSize(\"\", ptr_ptr, size_ptr);\n  }\n  uint64_t size = pairsSize(result);\n  uint64_t ptr;\n  char* buffer = static_cast<char*>(context->wasm()->allocMemory(size, &ptr));\n  marshalPairs(result, buffer);\n  if (!context->wasmVm()->setWord(ptr_ptr, Word(ptr))) {\n    return false;\n  }\n  if (!context->wasmVm()->setWord(size_ptr, Word(size))) {\n    return false;\n  }\n  return true;\n}\n\nvoid exportPairs(Context* context, const Pairs& pairs, uint64_t* ptr_ptr, uint64_t* size_ptr) {\n  if (pairs.empty()) {\n    *ptr_ptr = 0;\n    *size_ptr = 0;\n    return;\n  }\n  uint64_t size = pairsSize(pairs);\n  char* buffer = static_cast<char*>(context->wasm()->allocMemory(size, ptr_ptr));\n  marshalPairs(pairs, buffer);\n  *size_ptr = size;\n}\n\nHttp::HeaderMapPtr buildHeaderMapFromPairs(const Pairs& pairs) {\n  auto map = std::make_unique<Http::HeaderMapImpl>();\n  for (auto& p : pairs) {\n    // Note: because of the lack of a string_view interface for addCopy and\n    // the lack of an interface to add an entry with an empty value and return\n    // the entry, there is no efficient way to prevent either a double copy\n    // of the valueor a double lookup of the entry.\n    map->addCopy(Http::LowerCaseString(std::string(p.first)), std::string(p.second));\n  }\n  return map;\n}\n\nconst uint8_t* decodeVarint(const uint8_t* pos, const uint8_t* end, uint32_t* out) {\n  uint32_t ret = 0;\n  int shift = 0;\n  while (pos < end && (*pos & 0x80)) {\n    ret |= (*pos & 0x7f) << shift;\n    shift += 7;\n    pos++;\n  }\n  if (pos < end) {\n    ret |= *pos << shift;\n    pos++;\n  }\n  *out = ret;\n  return pos;\n}\n\nContext* ContextOrEffectiveContext(Context* context) {\n  if (effective_context_id_ == 0) {\n    return context;\n  }\n  auto effective_context = context->wasm()->getContext(effective_context_id_);\n  if (effective_context) {\n    return effective_context;\n  }\n  // The effective_context_id_ no longer exists, revert to the true context.\n  return context;\n}\n\n} // namespace\n\n// Test support.\n\nuint32_t resolveQueueForTest(absl::string_view vm_id, absl::string_view queue_name) {\n  return global_shared_data.resolveQueue(vm_id, queue_name);\n}\n\n//\n// HTTP Handlers\n//\n\nWord setPropertyHandler(void* raw_context, Word key_ptr, Word key_size, Word value_ptr,\n                        Word value_size) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto key = context->wasmVm()->getMemory(key_ptr.u64_, key_size.u64_);\n  auto value = context->wasmVm()->getMemory(value_ptr.u64_, value_size.u64_);\n  if (!key || !value) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(context->setProperty(key.value(), value.value()));\n}\n\n// Generic selector\nWord getPropertyHandler(void* raw_context, Word path_ptr, Word path_size, Word value_ptr_ptr,\n                        Word value_size_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto path = context->wasmVm()->getMemory(path_ptr.u64_, path_size.u64_);\n  if (!path.has_value()) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  std::string value;\n  auto result = context->getProperty(path.value(), &value);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  if (!context->wasm()->copyToPointerSize(value, value_ptr_ptr.u64_, value_size_ptr.u64_)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\n// Continue/Reply/Route\nWord continueRequestHandler(void* raw_context) {\n  auto context = WASM_CONTEXT(raw_context);\n  context->continueRequest();\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord continueResponseHandler(void* raw_context) {\n  auto context = WASM_CONTEXT(raw_context);\n  context->continueResponse();\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord sendLocalResponseHandler(void* raw_context, Word response_code, Word response_code_details_ptr,\n                              Word response_code_details_size, Word body_ptr, Word body_size,\n                              Word additional_response_header_pairs_ptr,\n                              Word additional_response_header_pairs_size, Word grpc_code) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto details =\n      context->wasmVm()->getMemory(response_code_details_ptr.u64_, response_code_details_size.u64_);\n  auto body = context->wasmVm()->getMemory(body_ptr.u64_, body_size.u64_);\n  auto additional_response_header_pairs = context->wasmVm()->getMemory(\n      additional_response_header_pairs_ptr.u64_, additional_response_header_pairs_size.u64_);\n  if (!details || !body || !additional_response_header_pairs) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  auto additional_headers = toPairs(additional_response_header_pairs.value());\n  auto modify_headers = [additional_headers](Http::HeaderMap& headers) {\n    for (auto& p : additional_headers) {\n      const Http::LowerCaseString lower_key(std::move(std::string(p.first)));\n      headers.addCopy(lower_key, std::string(p.second));\n    }\n  };\n  auto grpc_status = static_cast<Grpc::Status::GrpcStatus>(grpc_code.u64_);\n  auto grpc_status_opt = (grpc_status != Grpc::Status::GrpcStatus::InvalidCode)\n                             ? absl::optional<Grpc::Status::GrpcStatus>(grpc_status)\n                             : absl::optional<Grpc::Status::GrpcStatus>();\n  context->sendLocalResponse(static_cast<Envoy::Http::Code>(response_code.u64_), body.value(),\n                             modify_headers, grpc_status_opt, details.value());\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord setEffectiveContextHandler(void* raw_context, Word context_id) {\n  auto context = WASM_CONTEXT(raw_context);\n  uint32_t cid = static_cast<uint32_t>(context_id.u64_);\n  auto c = context->wasm()->getContext(cid);\n  if (!c) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  effective_context_id_ = cid;\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord clearRouteCacheHandler(void* raw_context) {\n  auto context = WASM_CONTEXT(raw_context);\n  context->clearRouteCache();\n  return wasmResultToWord(WasmResult::Ok);\n}\n\n// SharedData\nWord getSharedDataHandler(void* raw_context, Word key_ptr, Word key_size, Word value_ptr_ptr,\n                          Word value_size_ptr, Word cas_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto key = context->wasmVm()->getMemory(key_ptr.u64_, key_size.u64_);\n  if (!key) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  std::pair<std::string, uint32_t> data;\n  WasmResult result = context->getSharedData(key.value(), &data);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  if (!context->wasm()->copyToPointerSize(data.first, value_ptr_ptr.u64_, value_size_ptr.u64_)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  if (!context->wasmVm()->setMemory(cas_ptr.u64_, sizeof(uint32_t), &data.second)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord setSharedDataHandler(void* raw_context, Word key_ptr, Word key_size, Word value_ptr,\n                          Word value_size, Word cas) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto key = context->wasmVm()->getMemory(key_ptr.u64_, key_size.u64_);\n  auto value = context->wasmVm()->getMemory(value_ptr.u64_, value_size.u64_);\n  if (!key || !value) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(context->setSharedData(key.value(), value.value(), cas.u64_));\n}\n\nWord registerSharedQueueHandler(void* raw_context, Word queue_name_ptr, Word queue_name_size,\n                                Word token_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto queue_name = context->wasmVm()->getMemory(queue_name_ptr.u64_, queue_name_size.u64_);\n  if (!queue_name) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  uint32_t token = context->registerSharedQueue(queue_name.value());\n  if (!context->wasm()->setDatatype(token_ptr.u64_, token)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord dequeueSharedQueueHandler(void* raw_context, Word token, Word data_ptr_ptr,\n                               Word data_size_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  std::string data;\n  WasmResult result = context->dequeueSharedQueue(token.u32(), &data);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  if (!context->wasm()->copyToPointerSize(data, data_ptr_ptr.u64_, data_size_ptr.u64_)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord resolveSharedQueueHandler(void* raw_context, Word vm_id_ptr, Word vm_id_size,\n                               Word queue_name_ptr, Word queue_name_size, Word token_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto vm_id = context->wasmVm()->getMemory(vm_id_ptr.u64_, vm_id_size.u64_);\n  auto queue_name = context->wasmVm()->getMemory(queue_name_ptr.u64_, queue_name_size.u64_);\n  if (!vm_id || !queue_name) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  uint32_t token = 0;\n  auto result = context->resolveSharedQueue(vm_id.value(), queue_name.value(), &token);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  if (!context->wasm()->setDatatype(token_ptr.u64_, token)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord enqueueSharedQueueHandler(void* raw_context, Word token, Word data_ptr, Word data_size) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto data = context->wasmVm()->getMemory(data_ptr.u64_, data_size.u64_);\n  if (!data) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(context->enqueueSharedQueue(token.u32(), data.value()));\n}\n\n// Network\nWord getDownstreamDataBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                         Word size_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  absl::string_view data;\n  auto result = context->getDownstreamDataBufferBytes(start.u64_, length.u64_, &data);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  context->wasm()->copyToPointerSize(data, ptr_ptr.u64_, size_ptr.u64_);\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord getUpstreamDataBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                       Word size_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  absl::string_view data;\n  auto result = context->getUpstreamDataBufferBytes(start.u64_, length.u64_, &data);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  context->wasm()->copyToPointerSize(data, ptr_ptr.u64_, size_ptr.u64_);\n  return wasmResultToWord(WasmResult::Ok);\n}\n\n// Header/Trailer/Metadata Maps\nWord addHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size,\n                              Word value_ptr, Word value_size) {\n  if (type.u64_ > static_cast<uint64_t>(HeaderMapType::MAX)) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  auto key = context->wasmVm()->getMemory(key_ptr.u64_, key_size.u64_);\n  auto value = context->wasmVm()->getMemory(value_ptr.u64_, value_size.u64_);\n  if (!key || !value) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  context->addHeaderMapValue(static_cast<HeaderMapType>(type.u64_), key.value(), value.value());\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord getHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size,\n                              Word value_ptr_ptr, Word value_size_ptr) {\n  if (type.u64_ > static_cast<uint64_t>(HeaderMapType::MAX)) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  auto key = context->wasmVm()->getMemory(key_ptr.u64_, key_size.u64_);\n  if (!key) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  auto result = context->getHeaderMapValue(static_cast<HeaderMapType>(type.u64_), key.value());\n  context->wasm()->copyToPointerSize(result, value_ptr_ptr.u64_, value_size_ptr.u64_);\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord replaceHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size,\n                                  Word value_ptr, Word value_size) {\n  if (type.u64_ > static_cast<uint64_t>(HeaderMapType::MAX)) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  auto key = context->wasmVm()->getMemory(key_ptr.u64_, key_size.u64_);\n  auto value = context->wasmVm()->getMemory(value_ptr.u64_, value_size.u64_);\n  if (!key || !value) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  context->replaceHeaderMapValue(static_cast<HeaderMapType>(type.u64_), key.value(), value.value());\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord removeHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size) {\n  if (type.u64_ > static_cast<uint64_t>(HeaderMapType::MAX)) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  auto key = context->wasmVm()->getMemory(key_ptr.u64_, key_size.u64_);\n  if (!key) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  context->removeHeaderMapValue(static_cast<HeaderMapType>(type.u64_), key.value());\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord getHeaderMapPairsHandler(void* raw_context, Word type, Word ptr_ptr, Word size_ptr) {\n  if (type.u64_ > static_cast<uint64_t>(HeaderMapType::MAX)) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  auto result = context->getHeaderMapPairs(static_cast<HeaderMapType>(type.u64_));\n  if (!getPairs(context, result, ptr_ptr.u64_, size_ptr.u64_)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord setHeaderMapPairsHandler(void* raw_context, Word type, Word ptr, Word size) {\n  if (type.u64_ > static_cast<uint64_t>(HeaderMapType::MAX)) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  auto data = context->wasmVm()->getMemory(ptr.u64_, size.u64_);\n  if (!data) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  context->setHeaderMapPairs(static_cast<HeaderMapType>(type.u64_), toPairs(data.value()));\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord getHeaderMapSizeHandler(void* raw_context, Word type, Word result_ptr) {\n  if (type.u64_ > static_cast<uint64_t>(HeaderMapType::MAX)) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  size_t result = context->getHeaderMapSize(static_cast<HeaderMapType>(type.u64_));\n  if (!context->wasmVm()->setWord(result_ptr.u64_, Word(result))) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\n// Body Buffer\nWord getRequestBodyBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                      Word size_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto result = context->getRequestBodyBufferBytes(start.u64_, length.u64_);\n  context->wasm()->copyToPointerSize(result, ptr_ptr.u64_, size_ptr.u64_);\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord getResponseBodyBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                       Word size_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto result = context->getResponseBodyBufferBytes(start.u64_, length.u64_);\n  context->wasm()->copyToPointerSize(result, ptr_ptr.u64_, size_ptr.u64_);\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord httpCallHandler(void* raw_context, Word uri_ptr, Word uri_size, Word header_pairs_ptr,\n                     Word header_pairs_size, Word body_ptr, Word body_size, Word trailer_pairs_ptr,\n                     Word trailer_pairs_size, Word timeout_milliseconds) {\n  auto context = WASM_CONTEXT(raw_context)->root_context();\n  auto uri = context->wasmVm()->getMemory(uri_ptr.u64_, uri_size.u64_);\n  auto body = context->wasmVm()->getMemory(body_ptr.u64_, body_size.u64_);\n  auto header_pairs = context->wasmVm()->getMemory(header_pairs_ptr.u64_, header_pairs_size.u64_);\n  auto trailer_pairs =\n      context->wasmVm()->getMemory(trailer_pairs_ptr.u64_, trailer_pairs_size.u64_);\n  if (!uri || !body || !header_pairs || !trailer_pairs) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  auto headers = toPairs(header_pairs.value());\n  auto trailers = toPairs(trailer_pairs.value());\n  return context->httpCall(uri.value(), headers, body.value(), trailers, timeout_milliseconds.u64_);\n}\n\nWord defineMetricHandler(void* raw_context, Word metric_type, Word name_ptr, Word name_size,\n                         Word metric_id_ptr) {\n  if (metric_type.u64_ > static_cast<uint64_t>(Context::MetricType::Max)) {\n    return 0;\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  auto name = context->wasmVm()->getMemory(name_ptr.u64_, name_size.u64_);\n  if (!name) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  uint32_t metric_id = 0;\n  auto result = context->defineMetric(static_cast<Context::MetricType>(metric_type.u64_),\n                                      name.value(), &metric_id);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  if (!context->wasm()->setDatatype(metric_id_ptr.u64_, metric_id)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord incrementMetricHandler(void* raw_context, Word metric_id, int64_t offset) {\n  auto context = WASM_CONTEXT(raw_context);\n  return wasmResultToWord(context->incrementMetric(metric_id.u64_, offset));\n}\n\nWord recordMetricHandler(void* raw_context, Word metric_id, uint64_t value) {\n  auto context = WASM_CONTEXT(raw_context);\n  return wasmResultToWord(context->recordMetric(metric_id.u64_, value));\n}\n\nWord getMetricHandler(void* raw_context, Word metric_id, Word result_uint64_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  uint64_t value = 0;\n  auto result = context->getMetric(metric_id.u64_, &value);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  if (!context->wasm()->setDatatype(result_uint64_ptr.u64_, value)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord grpcCallHandler(void* raw_context, Word service_ptr, Word service_size, Word service_name_ptr,\n                     Word service_name_size, Word method_name_ptr, Word method_name_size,\n                     Word request_ptr, Word request_size, Word timeout_milliseconds) {\n  auto context = WASM_CONTEXT(raw_context)->root_context();\n  auto service = context->wasmVm()->getMemory(service_ptr.u64_, service_size.u64_);\n  auto service_name = context->wasmVm()->getMemory(service_name_ptr.u64_, service_name_size.u64_);\n  auto method_name = context->wasmVm()->getMemory(method_name_ptr.u64_, method_name_size.u64_);\n  auto request = context->wasmVm()->getMemory(request_ptr.u64_, request_size.u64_);\n  if (!service || !service_name || !method_name || !request) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  envoy::api::v2::core::GrpcService service_proto;\n  if (!service_proto.ParseFromArray(service.value().data(), service.value().size())) {\n    return false;\n  }\n  return context->grpcCall(service_proto, service_name.value(), method_name.value(),\n                           request.value(), std::chrono::milliseconds(timeout_milliseconds.u64_));\n}\n\nWord grpcStreamHandler(void* raw_context, Word service_ptr, Word service_size,\n                       Word service_name_ptr, Word service_name_size, Word method_name_ptr,\n                       Word method_name_size) {\n  auto context = WASM_CONTEXT(raw_context)->root_context();\n  auto service = context->wasmVm()->getMemory(service_ptr.u64_, service_size.u64_);\n  auto service_name = context->wasmVm()->getMemory(service_name_ptr.u64_, service_name_size.u64_);\n  auto method_name = context->wasmVm()->getMemory(method_name_ptr.u64_, method_name_size.u64_);\n  if (!service || !service_name || !method_name) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  envoy::api::v2::core::GrpcService service_proto;\n  if (!service_proto.ParseFromArray(service.value().data(), service.value().size())) {\n    return false;\n  }\n  return context->grpcStream(service_proto, service_name.value(), method_name.value());\n}\n\nWord grpcCancelHandler(void* raw_context, Word token) {\n  auto context = WASM_CONTEXT(raw_context)->root_context();\n  return wasmResultToWord(context->grpcCancel(token.u64_));\n}\n\nWord grpcCloseHandler(void* raw_context, Word token) {\n  auto context = WASM_CONTEXT(raw_context)->root_context();\n  return wasmResultToWord(context->grpcClose(token.u64_));\n}\n\nWord grpcSendHandler(void* raw_context, Word token, Word message_ptr, Word message_size,\n                     Word end_stream) {\n  auto context = WASM_CONTEXT(raw_context)->root_context();\n  auto message = context->wasmVm()->getMemory(message_ptr.u64_, message_size.u64_);\n  if (!message) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(context->grpcSend(token.u64_, message.value(), end_stream.u64_));\n}\n\n// Implementation of writev-like() syscall that redirects stdout/stderr to Envoy logs.\nWord writevImpl(void* raw_context, Word fd, Word iovs, Word iovs_len, Word* nwritten_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n\n  // Read syscall args.\n  spdlog::level::level_enum log_level;\n  switch (fd.u64_) {\n  case 1 /* stdout */:\n    log_level = spdlog::level::info;\n    break;\n  case 2 /* stderr */:\n    log_level = spdlog::level::err;\n    break;\n  default:\n    return 8; // __WASI_EBADF\n  }\n\n  std::string s;\n  for (size_t i = 0; i < iovs_len.u64_; i++) {\n    auto memslice =\n        context->wasmVm()->getMemory(iovs.u64_ + i * 2 * sizeof(uint32_t), 2 * sizeof(uint32_t));\n    if (!memslice) {\n      return 21; // __WASI_EFAULT\n    }\n    const uint32_t* iovec = reinterpret_cast<const uint32_t*>(memslice.value().data());\n    if (iovec[1] /* buf_len */) {\n      memslice = context->wasmVm()->getMemory(iovec[0] /* buf */, iovec[1] /* buf_len */);\n      if (!memslice) {\n        return 21; // __WASI_EFAULT\n      }\n      s.append(memslice.value().data(), memslice.value().size());\n    }\n  }\n\n  size_t written = s.size();\n  if (written) {\n    // Remove trailing newline from the logs, if any.\n    if (s[written - 1] == '\\n') {\n      s.erase(written - 1);\n    }\n    context->scriptLog(log_level, s);\n  }\n  *nwritten_ptr = Word(written);\n  return 0; // __WASI_ESUCCESS\n}\n\n// __wasi_errno_t __wasi_fd_write(_wasi_fd_t fd, const _wasi_ciovec_t *iov, size_t iovs_len, size_t*\n// nwritten);\nWord wasi_unstable_fd_writeHandler(void* raw_context, Word fd, Word iovs, Word iovs_len,\n                                   Word nwritten_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n\n  Word nwritten(0);\n  auto result = writevImpl(raw_context, fd, iovs, iovs_len, &nwritten);\n  if (result.u64_ != 0) { // __WASI_ESUCCESS\n    return result;\n  }\n  if (!context->wasmVm()->setWord(nwritten_ptr.u64_, Word(nwritten))) {\n    return 21; // __WASI_EFAULT\n  }\n  return 0; // __WASI_ESUCCESS\n}\n\n// __wasi_errno_t __wasi_fd_seek(__wasi_fd_t fd, __wasi_filedelta_t offset, __wasi_whence_t\n// whence,__wasi_filesize_t *newoffset);\nWord wasi_unstable_fd_seekHandler(void*, Word, int64_t, Word, Word) {\n  throw WasmException(\"wasi_unstable fd_seek\");\n}\n\n// __wasi_errno_t __wasi_fd_close(__wasi_fd_t fd);\nWord wasi_unstable_fd_closeHandler(void*, Word) { throw WasmException(\"wasi_unstable fd_close\"); }\n\n// __wasi_errno_t __wasi_environ_get(char **environ, char *environ_buf);\nWord wasi_unstable_environ_getHandler(void*, Word, Word) {\n  return 0; // __WASI_ESUCCESS\n}\n\n// __wasi_errno_t __wasi_environ_sizes_get(size_t *environ_count, size_t *environ_buf_size);\nWord wasi_unstable_environ_sizes_getHandler(void* raw_context, Word count_ptr, Word buf_size_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  if (!context->wasmVm()->setWord(count_ptr.u64_, Word(0))) {\n    return 21; // __WASI_EFAULT\n  }\n  if (!context->wasmVm()->setWord(buf_size_ptr.u64_, Word(0))) {\n    return 21; // __WASI_EFAULT\n  }\n  return 0; // __WASI_ESUCCESS\n}\n\n// void __wasi_proc_exit(__wasi_exitcode_t rval);\nvoid wasi_unstable_proc_exitHandler(void*, Word) { throw WasmException(\"wasi_unstable proc_exit\"); }\n\nWord pthread_equalHandler(void*, Word left, Word right) { return left.u64_ == right.u64_; }\n\nWord setTickPeriodMillisecondsHandler(void* raw_context, Word tick_period_milliseconds) {\n  return wasmResultToWord(\n      WASM_CONTEXT(raw_context)\n          ->setTickPeriod(std::chrono::milliseconds(tick_period_milliseconds.u64_)));\n}\n\nWord getCurrentTimeNanosecondsHandler(void* raw_context, Word result_uint64_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  uint64_t result = context->getCurrentTimeNanoseconds();\n  if (!context->wasm()->setDatatype(result_uint64_ptr.u64_, result)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord logHandler(void* raw_context, Word level, Word address, Word size) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto message = context->wasmVm()->getMemory(address.u64_, size.u64_);\n  if (!message) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  context->scriptLog(static_cast<spdlog::level::level_enum>(level.u64_), message.value());\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWasmResult Context::setTickPeriod(std::chrono::milliseconds tick_period) {\n  wasm_->setTickPeriod(root_context_id_ ? root_context_id_ : id_, tick_period);\n  return WasmResult::Ok;\n}\n\nuint64_t Context::getCurrentTimeNanoseconds() {\n  return std::chrono::duration_cast<std::chrono::nanoseconds>(\n             wasm_->time_source_.systemTime().time_since_epoch())\n      .count();\n}\n\n// TODO(https://github.com/google/cel-cpp/issues/38)\nbool exportValue(const Filters::Common::Expr::CelValue& value, ProtobufWkt::Value* out) {\n  using Filters::Common::Expr::CelValue;\n  switch (value.type()) {\n  case CelValue::Type::kBool:\n    out->set_bool_value(value.BoolOrDie());\n    return true;\n  case CelValue::Type::kInt64:\n    out->set_number_value(static_cast<double>(value.Int64OrDie()));\n    return true;\n  case CelValue::Type::kUint64:\n    out->set_number_value(static_cast<double>(value.Uint64OrDie()));\n    return true;\n  case CelValue::Type::kDouble:\n    out->set_number_value(value.DoubleOrDie());\n    return true;\n  case CelValue::Type::kString:\n    *out->mutable_string_value() = std::string(value.StringOrDie().value());\n    return true;\n  case CelValue::Type::kBytes:\n    *out->mutable_string_value() = std::string(value.BytesOrDie().value());\n    return true;\n  case CelValue::Type::kMessage: {\n    if (value.IsNull()) {\n      out->set_null_value(ProtobufWkt::NullValue::NULL_VALUE);\n    } else {\n      auto msg = value.MessageOrDie();\n      out->mutable_struct_value()->MergeFrom(*msg);\n    }\n    return true;\n  }\n  case CelValue::Type::kDuration:\n    *out->mutable_string_value() = absl::FormatDuration(value.DurationOrDie());\n    return true;\n  case CelValue::Type::kTimestamp:\n    *out->mutable_string_value() = absl::FormatTime(value.TimestampOrDie());\n    return true;\n  case CelValue::Type::kList: {\n    auto list = value.ListOrDie();\n    auto values = out->mutable_list_value();\n    for (int i = 0; i < list->size(); i++) {\n      if (!exportValue((*list)[i], values->add_values())) {\n        return false;\n      }\n    }\n    return true;\n  }\n  case CelValue::Type::kMap: {\n    auto map = value.MapOrDie();\n    auto list = map->ListKeys();\n    auto struct_obj = out->mutable_struct_value();\n    for (int i = 0; i < list->size(); i++) {\n      ProtobufWkt::Value field_key;\n      if (!exportValue((*list)[i], &field_key)) {\n        return false;\n      }\n      ProtobufWkt::Value field_value;\n      if (!exportValue((*map)[(*list)[i]].value(), &field_value)) {\n        return false;\n      }\n      (*struct_obj->mutable_fields())[field_key.string_value()] = field_value;\n    }\n    return true;\n  }\n  default:\n    // do nothing for special values\n    return false;\n  }\n  return false;\n}\n\nWasmResult serializeValue(Filters::Common::Expr::CelValue value, std::string* result) {\n  using Filters::Common::Expr::CelValue;\n  switch (value.type()) {\n  case CelValue::Type::kMessage:\n    if (value.MessageOrDie() != nullptr && value.MessageOrDie()->SerializeToString(result)) {\n      return WasmResult::Ok;\n    }\n    return WasmResult::SerializationFailure;\n  case CelValue::Type::kString:\n    result->assign(value.StringOrDie().value().data(), value.StringOrDie().value().size());\n    return WasmResult::Ok;\n  case CelValue::Type::kBytes:\n    result->assign(value.BytesOrDie().value().data(), value.BytesOrDie().value().size());\n    return WasmResult::Ok;\n  case CelValue::Type::kInt64: {\n    auto out = value.Int64OrDie();\n    result->assign(reinterpret_cast<const char*>(&out), sizeof(int64_t));\n    return WasmResult::Ok;\n  }\n  case CelValue::Type::kUint64: {\n    auto out = value.Uint64OrDie();\n    result->assign(reinterpret_cast<const char*>(&out), sizeof(uint64_t));\n    return WasmResult::Ok;\n  }\n  case CelValue::Type::kDouble: {\n    auto out = value.DoubleOrDie();\n    result->assign(reinterpret_cast<const char*>(&out), sizeof(double));\n    return WasmResult::Ok;\n  }\n  case CelValue::Type::kBool: {\n    auto out = value.BoolOrDie();\n    result->assign(reinterpret_cast<const char*>(&out), sizeof(bool));\n    return WasmResult::Ok;\n  }\n  case CelValue::Type::kDuration: {\n    auto out = value.DurationOrDie();\n    result->assign(reinterpret_cast<const char*>(&out), sizeof(absl::Duration));\n    return WasmResult::Ok;\n  }\n  case CelValue::Type::kTimestamp: {\n    auto out = value.TimestampOrDie();\n    result->assign(reinterpret_cast<const char*>(&out), sizeof(absl::Time));\n    return WasmResult::Ok;\n  }\n  case CelValue::Type::kMap: {\n    ProtobufWkt::Value out;\n    if (!exportValue(value, &out)) {\n      return WasmResult::SerializationFailure;\n    }\n    if (!out.struct_value().SerializeToString(result)) {\n      return WasmResult::SerializationFailure;\n    }\n    return WasmResult::Ok;\n  }\n  case CelValue::Type::kList: {\n    ProtobufWkt::Value out;\n    if (!exportValue(value, &out)) {\n      return WasmResult::SerializationFailure;\n    }\n    if (!out.list_value().SerializeToString(result)) {\n      return WasmResult::SerializationFailure;\n    }\n    return WasmResult::Ok;\n  }\n  default:\n    return WasmResult::SerializationFailure;\n  }\n  return WasmResult::SerializationFailure;\n}\n\n// An expression wrapper for the WASM state\nclass WasmStateWrapper : public google::api::expr::runtime::CelMap {\npublic:\n  WasmStateWrapper(const StreamInfo::FilterState& filter_state) : filter_state_(filter_state) {}\n  absl::optional<google::api::expr::runtime::CelValue>\n  operator[](google::api::expr::runtime::CelValue key) const override {\n    if (!key.IsString()) {\n      return {};\n    }\n    auto value = key.StringOrDie().value();\n    try {\n      const WasmState& result = filter_state_.getDataReadOnly<WasmState>(value);\n      return google::api::expr::runtime::CelValue::CreateBytes(&result.value());\n    } catch (const EnvoyException& e) {\n      return {};\n    }\n  }\n  int size() const override { NOT_IMPLEMENTED_GCOVR_EXCL_LINE; }\n  bool empty() const override { NOT_IMPLEMENTED_GCOVR_EXCL_LINE; }\n  const google::api::expr::runtime::CelList* ListKeys() const override {\n    NOT_IMPLEMENTED_GCOVR_EXCL_LINE;\n  }\n\nprivate:\n  const StreamInfo::FilterState& filter_state_;\n};\n\nWasmResult Context::getProperty(absl::string_view path, std::string* result) {\n  using google::api::expr::runtime::CelValue;\n  using google::api::expr::runtime::FieldBackedListImpl;\n  using google::api::expr::runtime::FieldBackedMapImpl;\n\n  bool first = true;\n  CelValue value;\n  Protobuf::Arena arena;\n  const StreamInfo::StreamInfo* info = getConstRequestStreamInfo();\n  const auto request_headers = request_headers_ ? request_headers_ : access_log_request_headers_;\n  const auto response_headers =\n      response_headers_ ? response_headers_ : access_log_response_headers_;\n  const auto response_trailers =\n      response_trailers_ ? response_trailers_ : access_log_response_trailers_;\n\n  size_t start = 0;\n  while (true) {\n    if (start >= path.size()) {\n      break;\n    }\n\n    size_t end = path.find('\\0', start);\n    if (end == absl::string_view::npos) {\n      // this should not happen unless the input string is not null-terminated in the view\n      return WasmResult::ParseFailure;\n    }\n    auto part = path.substr(start, end - start);\n    start = end + 1;\n\n    // top-level ident\n    if (first) {\n      first = false;\n      if (part == \"metadata\") {\n        value = CelValue::CreateMessage(&info->dynamicMetadata(), &arena);\n      } else if (part == \"filter_state\") {\n        value = CelValue::CreateMap(\n            Protobuf::Arena::Create<WasmStateWrapper>(&arena, info->filterState()));\n      } else if (part == \"request\") {\n        value = CelValue::CreateMap(Protobuf::Arena::Create<Filters::Common::Expr::RequestWrapper>(\n            &arena, request_headers, *info));\n      } else if (part == \"response\") {\n        value = CelValue::CreateMap(Protobuf::Arena::Create<Filters::Common::Expr::ResponseWrapper>(\n            &arena, response_headers, response_trailers, *info));\n      } else if (part == \"connection\") {\n        value = CelValue::CreateMap(\n            Protobuf::Arena::Create<Filters::Common::Expr::ConnectionWrapper>(&arena, *info));\n      } else if (part == \"upstream\") {\n        value = CelValue::CreateMap(\n            Protobuf::Arena::Create<Filters::Common::Expr::UpstreamWrapper>(&arena, *info));\n      } else if (part == \"node\") {\n        value = CelValue::CreateMessage(&plugin_->local_info_.node(), &arena);\n      } else if (part == \"source\") {\n        value = CelValue::CreateMap(\n            Protobuf::Arena::Create<Filters::Common::Expr::PeerWrapper>(&arena, *info, false));\n      } else if (part == \"destination\") {\n        value = CelValue::CreateMap(\n            Protobuf::Arena::Create<Filters::Common::Expr::PeerWrapper>(&arena, *info, true));\n      } else if (part == \"request_protocol\") {\n        // TODO(kyessenov) move this upstream to CEL context\n        if (info->protocol().has_value()) {\n          value =\n              CelValue::CreateString(&Http::Utility::getProtocolString(info->protocol().value()));\n        } else {\n          return WasmResult::NotFound;\n        }\n        // Reflective accessors\n      } else if (part == \"listener_direction\") {\n        value = CelValue::CreateInt64(plugin_->direction_);\n      } else if (part == \"listener_metadata\") {\n        value = CelValue::CreateMessage(plugin_->listener_metadata_, &arena);\n      } else if (part == \"cluster_name\" && info->upstreamHost() != nullptr) {\n        value = CelValue::CreateString(&info->upstreamHost()->cluster().name());\n      } else if (part == \"cluster_metadata\" && info->upstreamHost() != nullptr) {\n        value = CelValue::CreateMessage(&info->upstreamHost()->cluster().metadata(), &arena);\n      } else if (part == \"route_name\") {\n        value = CelValue::CreateString(&info->getRouteName());\n      } else if (part == \"route_metadata\" && info->routeEntry() != nullptr) {\n        value = CelValue::CreateMessage(&info->routeEntry()->metadata(), &arena);\n      } else {\n        return WasmResult::NotFound;\n      }\n      continue;\n    }\n\n    if (value.IsMap()) {\n      auto& map = *value.MapOrDie();\n      auto field = map[CelValue::CreateString(part)];\n      if (field.has_value()) {\n        value = field.value();\n      } else {\n        return {};\n      }\n    } else if (value.IsMessage()) {\n      auto msg = value.MessageOrDie();\n      if (msg == nullptr) {\n        return {};\n      }\n      const Protobuf::Descriptor* desc = msg->GetDescriptor();\n      const Protobuf::FieldDescriptor* field_desc = desc->FindFieldByName(std::string(part));\n      if (field_desc == nullptr) {\n        return {};\n      } else if (field_desc->is_map()) {\n        value = CelValue::CreateMap(\n            Protobuf::Arena::Create<FieldBackedMapImpl>(&arena, msg, field_desc, &arena));\n      } else if (field_desc->is_repeated()) {\n        value = CelValue::CreateList(\n            Protobuf::Arena::Create<FieldBackedListImpl>(&arena, msg, field_desc, &arena));\n      } else {\n        auto status =\n            google::api::expr::runtime::CreateValueFromSingleField(msg, field_desc, &arena, &value);\n        if (!status.ok()) {\n          return {};\n        }\n      }\n    } else {\n      return {};\n    }\n  }\n\n  return serializeValue(value, result);\n}\n\n// Shared Data\nWasmResult Context::getSharedData(absl::string_view key, std::pair<std::string, uint32_t>* data) {\n  return global_shared_data.get(wasm_->vm_id(), key, data);\n}\n\nWasmResult Context::setSharedData(absl::string_view key, absl::string_view value, uint32_t cas) {\n  return global_shared_data.set(wasm_->vm_id(), key, value, cas);\n}\n\n// Shared Queue\n\nuint32_t Context::registerSharedQueue(absl::string_view queue_name) {\n  // Get the id of the root context if this is a stream context because onQueueReady is on the root.\n  return global_shared_data.registerQueue(\n      wasm_->vm_id(), queue_name, isRootContext() ? id_ : root_context_id_, wasm_->dispatcher_);\n}\n\nWasmResult Context::resolveSharedQueue(absl::string_view vm_id, absl::string_view queue_name,\n                                       uint32_t* token_ptr) {\n  uint32_t token = global_shared_data.resolveQueue(vm_id, queue_name);\n  if (!token) {\n    return WasmResult::NotFound;\n  }\n  *token_ptr = token;\n  return WasmResult::Ok;\n}\n\nWasmResult Context::dequeueSharedQueue(uint32_t token, std::string* data) {\n  return global_shared_data.dequeue(token, data);\n}\n\nWasmResult Context::enqueueSharedQueue(uint32_t token, absl::string_view value) {\n  return global_shared_data.enqueue(token, value);\n}\n\n// Network bytes.\n\nWasmResult Context::getDownstreamDataBufferBytes(uint32_t start, uint32_t length,\n                                                 absl::string_view* data) {\n  if (!network_downstream_data_buffer_)\n    return WasmResult::NotFound;\n  if (network_downstream_data_buffer_->length() < static_cast<uint64_t>(start + length))\n    return WasmResult::InvalidMemoryAccess;\n  *data = absl::string_view(\n      static_cast<char*>(network_downstream_data_buffer_->linearize(start + length)) + start,\n      length);\n  return WasmResult::Ok;\n}\n\nWasmResult Context::getUpstreamDataBufferBytes(uint32_t start, uint32_t length,\n                                               absl::string_view* data) {\n  if (!network_upstream_data_buffer_)\n    return WasmResult::NotFound;\n  if (network_upstream_data_buffer_->length() < static_cast<uint64_t>(start + length))\n    return WasmResult::InvalidMemoryAccess;\n  *data = absl::string_view(\n      static_cast<char*>(network_upstream_data_buffer_->linearize(start + length)) + start, length);\n  return WasmResult::Ok;\n}\n\n// Header/Trailer/Metadata Maps.\nHttp::HeaderMap* Context::getMap(HeaderMapType type) {\n  switch (type) {\n  case HeaderMapType::RequestHeaders:\n    return request_headers_;\n  case HeaderMapType::RequestTrailers:\n    return request_trailers_;\n  case HeaderMapType::ResponseHeaders:\n    return response_headers_;\n  case HeaderMapType::ResponseTrailers:\n    return response_trailers_;\n  case HeaderMapType::GrpcCreateInitialMetadata:\n    return grpc_create_initial_metadata_;\n  default:\n    return nullptr;\n  }\n}\n\nconst Http::HeaderMap* Context::getConstMap(HeaderMapType type) {\n  switch (type) {\n  case HeaderMapType::RequestHeaders:\n    if (access_log_request_headers_) {\n      return access_log_request_headers_;\n    }\n    return request_headers_;\n  case HeaderMapType::RequestTrailers:\n    if (access_log_request_trailers_) {\n      return access_log_request_trailers_;\n    }\n    return request_trailers_;\n  case HeaderMapType::ResponseHeaders:\n    if (access_log_response_headers_) {\n      return access_log_response_headers_;\n    }\n    return response_headers_;\n  case HeaderMapType::ResponseTrailers:\n    if (access_log_response_trailers_) {\n      return access_log_response_trailers_;\n    }\n    return response_trailers_;\n  case HeaderMapType::GrpcCreateInitialMetadata:\n    return grpc_create_initial_metadata_;\n  case HeaderMapType::GrpcReceiveInitialMetadata:\n    return grpc_receive_initial_metadata_.get();\n  case HeaderMapType::GrpcReceiveTrailingMetadata:\n    return grpc_receive_trailing_metadata_.get();\n  }\n  return nullptr;\n}\n\nvoid Context::addHeaderMapValue(HeaderMapType type, absl::string_view key,\n                                absl::string_view value) {\n  auto map = getMap(type);\n  if (!map) {\n    return;\n  }\n  const Http::LowerCaseString lower_key(std::move(std::string(key)));\n  map->addCopy(lower_key, std::string(value));\n}\n\nabsl::string_view Context::getHeaderMapValue(HeaderMapType type, absl::string_view key) {\n  auto map = getConstMap(type);\n  if (!map) {\n    return \"\";\n  }\n  const Http::LowerCaseString lower_key(std::move(std::string(key)));\n  auto entry = map->get(lower_key);\n  if (!entry) {\n    return \"\";\n  }\n  return entry->value().getStringView();\n}\n\nPairs headerMapToPairs(const Http::HeaderMap* map) {\n  if (!map) {\n    return {};\n  }\n  Pairs pairs;\n  pairs.reserve(map->size());\n  map->iterate(\n      [](const Http::HeaderEntry& header, void* pairs) -> Http::HeaderMap::Iterate {\n        (static_cast<Pairs*>(pairs))\n            ->push_back(\n                std::make_pair(header.key().getStringView(), header.value().getStringView()));\n        return Http::HeaderMap::Iterate::Continue;\n      },\n      &pairs);\n  return pairs;\n}\n\nPairs Context::getHeaderMapPairs(HeaderMapType type) { return headerMapToPairs(getConstMap(type)); }\n\nvoid Context::setHeaderMapPairs(HeaderMapType type, const Pairs& pairs) {\n  auto map = getMap(type);\n  if (!map) {\n    return;\n  }\n  std::vector<std::string> keys;\n  map->iterate(\n      [](const Http::HeaderEntry& header, void* keys) -> Http::HeaderMap::Iterate {\n        (static_cast<std::vector<std::string>*>(keys))\n            ->push_back(std::string(header.key().getStringView()));\n        return Http::HeaderMap::Iterate::Continue;\n      },\n      &keys);\n  for (auto& k : keys) {\n    const Http::LowerCaseString lower_key(std::move(k));\n    map->remove(lower_key);\n  }\n  for (auto& p : pairs) {\n    const Http::LowerCaseString lower_key(std::move(std::string(p.first)));\n    map->addCopy(lower_key, std::move(std::string(p.second)));\n  }\n}\n\nvoid Context::removeHeaderMapValue(HeaderMapType type, absl::string_view key) {\n  auto map = getMap(type);\n  if (!map) {\n    return;\n  }\n  const Http::LowerCaseString lower_key(std::move(std::string(key)));\n  map->remove(lower_key);\n}\n\nvoid Context::replaceHeaderMapValue(HeaderMapType type, absl::string_view key,\n                                    absl::string_view value) {\n  auto map = getMap(type);\n  if (!map) {\n    return;\n  }\n  const Http::LowerCaseString lower_key(std::move(std::string(key)));\n  auto entry = map->get(lower_key);\n  if (entry != nullptr) {\n    entry->value(value.data(), value.size());\n  } else {\n    map->addCopy(lower_key, std::string(value));\n  }\n}\n\nuint32_t Context::getHeaderMapSize(HeaderMapType type) {\n  auto map = getMap(type);\n  if (!map) {\n    return 0;\n  }\n  return map->refreshByteSize();\n}\n\n// Body Buffer\n\nabsl::string_view Context::getRequestBodyBufferBytes(uint32_t start, uint32_t length) {\n  if (!requestBodyBuffer_) {\n    return \"\";\n  }\n  if (requestBodyBuffer_->length() < static_cast<uint64_t>((start + length))) {\n    return \"\";\n  }\n  return absl::string_view(\n      static_cast<char*>(requestBodyBuffer_->linearize(start + length)) + start, length);\n}\n\nabsl::string_view Context::getResponseBodyBufferBytes(uint32_t start, uint32_t length) {\n  if (!responseBodyBuffer_) {\n    return \"\";\n  }\n  if (responseBodyBuffer_->length() < static_cast<uint64_t>((start + length))) {\n    return \"\";\n  }\n  return absl::string_view(\n      static_cast<char*>(responseBodyBuffer_->linearize(start + length)) + start, length);\n}\n\n// Async call via HTTP\nuint32_t Context::httpCall(absl::string_view cluster, const Pairs& request_headers,\n                           absl::string_view request_body, const Pairs& request_trailers,\n                           int timeout_milliseconds) {\n  if (timeout_milliseconds < 0) {\n    return 0;\n  }\n  auto cluster_string = std::string(cluster);\n  if (clusterManager().get(cluster_string) == nullptr) {\n    return 0;\n  }\n\n  Http::MessagePtr message(new Http::RequestMessageImpl(buildHeaderMapFromPairs(request_headers)));\n\n  // Check that we were provided certain headers.\n  if (message->headers().Path() == nullptr || message->headers().Method() == nullptr ||\n      message->headers().Host() == nullptr) {\n    return 0;\n  }\n\n  if (!request_body.empty()) {\n    message->body().reset(new Buffer::OwnedImpl(request_body.data(), request_body.size()));\n    message->headers().insertContentLength().value(request_body.size());\n  }\n\n  if (request_trailers.size() > 0) {\n    message->trailers(buildHeaderMapFromPairs(request_trailers));\n  }\n\n  absl::optional<std::chrono::milliseconds> timeout;\n  if (timeout_milliseconds > 0) {\n    timeout = std::chrono::milliseconds(timeout_milliseconds);\n  }\n\n  auto token = next_http_call_token_++;\n  // Handle rollover.\n  for (;;) {\n    if (token == 0) {\n      token = next_http_call_token_++;\n    }\n    if (!http_request_.count(token)) {\n      break;\n    }\n    token = next_http_call_token_++;\n  }\n  auto& handler = http_request_[token];\n\n  // set default hash policy to be based on :authority to enable consistent hash\n  Http::AsyncClient::RequestOptions options;\n  options.setTimeout(timeout);\n  Protobuf::RepeatedPtrField<envoy::api::v2::route::RouteAction::HashPolicy> hash_policy;\n  hash_policy.Add()->mutable_header()->set_header_name(Http::Headers::get().Host.get());\n  options.setHashPolicy(hash_policy);\n  auto http_request = clusterManager()\n                          .httpAsyncClientForCluster(cluster_string)\n                          .send(std::move(message), handler, options);\n  if (!http_request) {\n    http_request_.erase(token);\n    return 0;\n  }\n  handler.context = this;\n  handler.token = token;\n  handler.request = http_request;\n  return token;\n}\n\nuint32_t Context::grpcCall(const envoy::api::v2::core::GrpcService& grpc_service,\n                           absl::string_view service_name, absl::string_view method_name,\n                           absl::string_view request,\n                           const absl::optional<std::chrono::milliseconds>& timeout) {\n  auto token = next_grpc_token_++;\n  if (IsGrpcStreamToken(token)) {\n    token = next_grpc_token_++;\n  }\n  // Handle rollover.\n  for (;;) {\n    if (token == 0) {\n      token = next_grpc_token_ += 2;\n    }\n    if (!grpc_call_request_.count(token)) {\n      break;\n    }\n    token = next_grpc_token_ += 2;\n  }\n  auto& handler = grpc_call_request_[token];\n  handler.context = this;\n  handler.token = token;\n  auto grpc_client =\n      clusterManager()\n          .grpcAsyncClientManager()\n          .factoryForGrpcService(grpc_service, *wasm()->scope_, true /* skip_cluster_check */)\n          ->create();\n\n  // set default hash policy to be based on :authority to enable consistent hash\n  Http::AsyncClient::RequestOptions options;\n  options.setTimeout(timeout);\n  Protobuf::RepeatedPtrField<envoy::api::v2::route::RouteAction::HashPolicy> hash_policy;\n  hash_policy.Add()->mutable_header()->set_header_name(Http::Headers::get().Host.get());\n  options.setHashPolicy(hash_policy);\n\n  // NB: this call causes the onCreateInitialMetadata callback to occur inline *before* this call\n  // returns. Consequently the grpc_request is not available. Attempting to close or reset from that\n  // callback will fail.\n  auto grpc_request =\n      grpc_client->sendRaw(service_name, method_name, std::make_unique<Buffer::OwnedImpl>(request),\n                           handler, Tracing::NullSpan::instance(), options);\n  if (!grpc_request) {\n    grpc_call_request_.erase(token);\n    return 0;\n  }\n  handler.client = std::move(grpc_client);\n  handler.request = grpc_request;\n  return token;\n}\n\nuint32_t Context::grpcStream(const envoy::api::v2::core::GrpcService& grpc_service,\n                             absl::string_view service_name, absl::string_view method_name) {\n  auto token = next_grpc_token_++;\n  if (IsGrpcCallToken(token)) {\n    token = next_grpc_token_++;\n  }\n  // Handle rollover.\n  for (;;) {\n    if (token == 0) {\n      token = next_grpc_token_ += 2;\n    }\n    if (!grpc_stream_.count(token)) {\n      break;\n    }\n    token = next_grpc_token_ += 2;\n  }\n  auto& handler = grpc_stream_[token];\n  handler.context = this;\n  handler.token = token;\n  auto grpc_client =\n      clusterManager()\n          .grpcAsyncClientManager()\n          .factoryForGrpcService(grpc_service, *wasm()->scope_, true /* skip_cluster_check */)\n          ->create();\n\n  // set default hash policy to be based on :authority to enable consistent hash\n  Http::AsyncClient::StreamOptions options;\n  Protobuf::RepeatedPtrField<envoy::api::v2::route::RouteAction::HashPolicy> hash_policy;\n  hash_policy.Add()->mutable_header()->set_header_name(Http::Headers::get().Host.get());\n  options.setHashPolicy(hash_policy);\n\n  // NB: this call causes the onCreateInitialMetadata callback to occur inline *before* this call\n  // returns. Consequently the grpc_stream is not available. Attempting to close or reset from that\n  // callback will fail.\n  auto grpc_stream = grpc_client->startRaw(service_name, method_name, handler, options);\n  if (!grpc_stream) {\n    grpc_stream_.erase(token);\n    return 0;\n  }\n  handler.client = std::move(grpc_client);\n  handler.stream = grpc_stream;\n  return token;\n}\n\nvoid Context::httpRespond(const Pairs& response_headers, absl::string_view body,\n                          const Pairs& response_trailers) {\n  (void)response_headers;\n  (void)body;\n  (void)response_trailers;\n}\n\n// StreamInfo\nconst StreamInfo::StreamInfo* Context::getConstRequestStreamInfo() const {\n  if (encoder_callbacks_) {\n    return &encoder_callbacks_->streamInfo();\n  } else if (decoder_callbacks_) {\n    return &decoder_callbacks_->streamInfo();\n  } else if (access_log_stream_info_) {\n    return access_log_stream_info_;\n  }\n  return nullptr;\n}\n\nStreamInfo::StreamInfo* Context::getRequestStreamInfo() const {\n  if (encoder_callbacks_) {\n    return &encoder_callbacks_->streamInfo();\n  } else if (decoder_callbacks_) {\n    return &decoder_callbacks_->streamInfo();\n  }\n  return nullptr;\n}\n\nWasmResult Context::setProperty(absl::string_view key, absl::string_view serialized_value) {\n  auto* stream_info = getRequestStreamInfo();\n  if (!stream_info) {\n    return WasmResult::NotFound;\n  }\n  stream_info->filterState().setData(key, std::make_unique<WasmState>(serialized_value),\n                                     StreamInfo::FilterState::StateType::Mutable);\n  return WasmResult::Ok;\n}\n\nvoid Context::scriptLog(spdlog::level::level_enum level, absl::string_view message) {\n  switch (level) {\n  case spdlog::level::trace:\n    ENVOY_LOG(trace, \"wasm log{}: {}\", log_prefix(), message);\n    return;\n  case spdlog::level::debug:\n    ENVOY_LOG(debug, \"wasm log{}: {}\", log_prefix(), message);\n    return;\n  case spdlog::level::info:\n    ENVOY_LOG(info, \"wasm log{}: {}\", log_prefix(), message);\n    return;\n  case spdlog::level::warn:\n    ENVOY_LOG(warn, \"wasm log{}: {}\", log_prefix(), message);\n    return;\n  case spdlog::level::err:\n    ENVOY_LOG(error, \"wasm log{}: {}\", log_prefix(), message);\n    return;\n  case spdlog::level::critical:\n    ENVOY_LOG(critical, \"wasm log{}: {}\", log_prefix(), message);\n    return;\n  case spdlog::level::off:\n    NOT_IMPLEMENTED_GCOVR_EXCL_LINE;\n  }\n}\n\n// Connection\nbool Context::isSsl() { return decoder_callbacks_->connection()->ssl() != nullptr; }\n\n//\n// Calls into the WASM code.\n//\nvoid Context::onStart(absl::string_view root_id, absl::string_view vm_configuration) {\n  if (wasm_->onStart_) {\n    auto root_id_addr = wasm_->copyString(root_id);\n    auto config_addr = wasm_->copyString(vm_configuration);\n    wasm_->onStart_(this, id_, root_id_addr, root_id.size(), config_addr, vm_configuration.size());\n  }\n}\n\nbool Context::validateConfiguration(absl::string_view configuration) {\n  if (!wasm_->validateConfiguration_) {\n    return true;\n  }\n  auto address = wasm_->copyString(configuration);\n  return wasm_->validateConfiguration_(this, id_, address, configuration.size()).u64_ != 0;\n}\n\nbool Context::onConfigure(absl::string_view configuration) {\n  if (!wasm_->onConfigure_) {\n    return true;\n  }\n  auto address = wasm_->copyString(configuration);\n  return wasm_->onConfigure_(this, id_, address, configuration.size()).u64_ != 0;\n}\n\nvoid Context::onCreate(uint32_t root_context_id) {\n  if (wasm_->onCreate_) {\n    wasm_->onCreate_(this, id_, root_context_id);\n  }\n}\n\nNetwork::FilterStatus Context::onNetworkNewConnection() {\n  onCreate(root_context_id_);\n  if (!wasm_->onNewConnection_) {\n    return Network::FilterStatus::Continue;\n  }\n  if (wasm_->onNewConnection_(this, id_).u64_ == 0) {\n    return Network::FilterStatus::Continue;\n  }\n  return Network::FilterStatus::StopIteration;\n}\n\nNetwork::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onDownstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                         static_cast<uint32_t>(end_of_stream));\n  // TODO(PiotrSikora): pull Proxy-WASM's FilterStatus values.\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}\n\nNetwork::FilterStatus Context::onUpstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onUpstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onUpstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                       static_cast<uint32_t>(end_of_stream));\n  // TODO(PiotrSikora): pull Proxy-WASM's FilterStatus values.\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}\n\nvoid Context::onDownstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onDownstreamConnectionClose_) {\n    wasm_->onDownstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}\n\nvoid Context::onUpstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onUpstreamConnectionClose_) {\n    wasm_->onUpstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}\n\nHttp::FilterHeadersStatus Context::onRequestHeaders() {\n  onCreate(root_context_id_);\n  in_vm_context_created_ = true;\n  // Store the stream id so that we can use it in log().\n  auto& stream_info = decoder_callbacks_->streamInfo();\n  auto& metadata = (*stream_info.dynamicMetadata()\n                         .mutable_filter_metadata())[HttpFilters::HttpFilterNames::get().Wasm];\n  (*metadata.mutable_fields())[std::string(\"_stream_id_\" + std::string(root_id()))]\n      .set_number_value(id_);\n  if (!wasm_->onRequestHeaders_) {\n    return Http::FilterHeadersStatus::Continue;\n  }\n  if (wasm_->onRequestHeaders_(this, id_).u64_ == 0) {\n    return Http::FilterHeadersStatus::Continue;\n  }\n  return Http::FilterHeadersStatus::StopIteration;\n}\n\nHttp::FilterDataStatus Context::onRequestBody(int body_buffer_length, bool end_of_stream) {\n  if (!wasm_->onRequestBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              ->onRequestBody_(this, id_, static_cast<uint32_t>(body_buffer_length),\n                               static_cast<uint32_t>(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}\n\nHttp::FilterTrailersStatus Context::onRequestTrailers() {\n  if (!wasm_->onRequestTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onRequestTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}\n\nHttp::FilterMetadataStatus Context::onRequestMetadata() {\n  if (!wasm_->onRequestMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onRequestMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; // This is currently the only return code.\n}\n\nHttp::FilterHeadersStatus Context::onResponseHeaders() {\n  if (!in_vm_context_created_) {\n    // If the request is invalid then onRequestHeaders() will not be called and neither will\n    // onCreate() then sendLocalReply be called which will call this function. In this case we\n    // need to call onCreate() so that the Context inside the VM is created before the\n    // onResponseHeaders() call.\n    onCreate(root_context_id_);\n    in_vm_context_created_ = true;\n  }\n  if (!wasm_->onResponseHeaders_) {\n    return Http::FilterHeadersStatus::Continue;\n  }\n  if (wasm_->onResponseHeaders_(this, id_).u64_ == 0) {\n    return Http::FilterHeadersStatus::Continue;\n  }\n  return Http::FilterHeadersStatus::StopIteration;\n}\n\nHttp::FilterDataStatus Context::onResponseBody(int body_buffer_length, bool end_of_stream) {\n  if (!wasm_->onResponseBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              ->onResponseBody_(this, id_, static_cast<uint32_t>(body_buffer_length),\n                                static_cast<uint32_t>(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}\n\nHttp::FilterTrailersStatus Context::onResponseTrailers() {\n  if (!wasm_->onResponseTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}\n\nHttp::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; // This is currently the only return code.\n}\n\nvoid Context::onHttpCallResponse(uint32_t token, const Pairs& response_headers,\n                                 absl::string_view response_body, const Pairs& response_trailers) {\n  if (!wasm_->onHttpCallResponse_) {\n    return;\n  }\n  uint64_t headers_ptr, headers_size, trailers_ptr, trailers_size;\n  exportPairs(this, response_headers, &headers_ptr, &headers_size);\n  exportPairs(this, response_trailers, &trailers_ptr, &trailers_size);\n  auto body_ptr = wasm_->copyString(response_body);\n  auto body_size = response_body.size();\n  wasm_->onHttpCallResponse_(this, id_, token, headers_ptr, headers_size, body_ptr, body_size,\n                             trailers_ptr, trailers_size);\n}\n\nvoid Context::onQueueReady(uint32_t token) {\n  if (wasm_->onQueueReady_) {\n    wasm_->onQueueReady_(this, id_, token);\n  }\n}\n\nvoid Context::onGrpcCreateInitialMetadata(uint32_t token, Http::HeaderMap& metadata) {\n  if (!wasm_->onGrpcCreateInitialMetadata_) {\n    return;\n  }\n  grpc_create_initial_metadata_ = &metadata;\n  wasm_->onGrpcCreateInitialMetadata_(this, id_, token);\n  grpc_create_initial_metadata_ = nullptr;\n}\n\nvoid Context::onGrpcReceiveInitialMetadata(uint32_t token, Http::HeaderMapPtr&& metadata) {\n  if (!wasm_->onGrpcReceiveInitialMetadata_) {\n    return;\n  }\n  grpc_receive_initial_metadata_ = std::move(metadata);\n  wasm_->onGrpcReceiveInitialMetadata_(this, id_, token);\n  grpc_receive_initial_metadata_ = nullptr;\n}\n\nvoid Context::onGrpcReceiveTrailingMetadata(uint32_t token, Http::HeaderMapPtr&& metadata) {\n  if (!wasm_->onGrpcReceiveTrailingMetadata_) {\n    return;\n  }\n  grpc_receive_trailing_metadata_ = std::move(metadata);\n  wasm_->onGrpcReceiveTrailingMetadata_(this, id_, token);\n  grpc_receive_trailing_metadata_ = nullptr;\n}\n\nWasmResult Context::defineMetric(MetricType type, absl::string_view name, uint32_t* metric_id_ptr) {\n  auto stat_name = wasm_->stat_name_set_->getDynamic(name);\n  if (type == MetricType::Counter) {\n    auto id = wasm_->nextCounterMetricId();\n    auto c = &wasm_->scope_->counterFromStatName(stat_name);\n    wasm_->counters_.emplace(id, c);\n    *metric_id_ptr = id;\n    return WasmResult::Ok;\n  } else if (type == MetricType::Gauge) {\n    auto id = wasm_->nextGaugeMetricId();\n    auto g = &wasm_->scope_->gaugeFromStatName(stat_name, Stats::Gauge::ImportMode::Accumulate);\n    wasm_->gauges_.emplace(id, g);\n    *metric_id_ptr = id;\n    return WasmResult::Ok;\n  } else if (type == MetricType::Histogram) {\n    auto id = wasm_->nextHistogramMetricId();\n    auto h = &wasm_->scope_->histogramFromStatName(stat_name, Stats::Histogram::Unit::Unspecified);\n    wasm_->histograms_.emplace(id, h);\n    *metric_id_ptr = id;\n    return WasmResult::Ok;\n  }\n  return WasmResult::BadArgument;\n}\n\nWasmResult Context::incrementMetric(uint32_t metric_id, int64_t offset) {\n  auto type = static_cast<MetricType>(metric_id & Wasm::kMetricTypeMask);\n  if (type == MetricType::Counter) {\n    auto it = wasm_->counters_.find(metric_id);\n    if (it != wasm_->counters_.end()) {\n      if (offset > 0) {\n        it->second->add(offset);\n        return WasmResult::Ok;\n      } else {\n        return WasmResult::BadArgument;\n      }\n      return WasmResult::NotFound;\n    }\n  } else if (type == MetricType::Gauge) {\n    auto it = wasm_->gauges_.find(metric_id);\n    if (it != wasm_->gauges_.end()) {\n      if (offset > 0) {\n        it->second->add(offset);\n        return WasmResult::Ok;\n      } else {\n        it->second->sub(-offset);\n        return WasmResult::Ok;\n      }\n    }\n    return WasmResult::NotFound;\n  }\n  return WasmResult::BadArgument;\n}\n\nWasmResult Context::recordMetric(uint32_t metric_id, uint64_t value) {\n  auto type = static_cast<MetricType>(metric_id & Wasm::kMetricTypeMask);\n  if (type == MetricType::Counter) {\n    auto it = wasm_->counters_.find(metric_id);\n    if (it != wasm_->counters_.end()) {\n      it->second->add(value);\n      return WasmResult::Ok;\n    }\n  } else if (type == MetricType::Gauge) {\n    auto it = wasm_->gauges_.find(metric_id);\n    if (it != wasm_->gauges_.end()) {\n      it->second->set(value);\n      return WasmResult::Ok;\n    }\n  } else if (type == MetricType::Histogram) {\n    auto it = wasm_->histograms_.find(metric_id);\n    if (it != wasm_->histograms_.end()) {\n      it->second->recordValue(value);\n      return WasmResult::Ok;\n    }\n  }\n  return WasmResult::NotFound;\n}\n\nWasmResult Context::getMetric(uint32_t metric_id, uint64_t* result_uint64_ptr) {\n  auto type = static_cast<MetricType>(metric_id & Wasm::kMetricTypeMask);\n  if (type == MetricType::Counter) {\n    auto it = wasm_->counters_.find(metric_id);\n    if (it != wasm_->counters_.end()) {\n      *result_uint64_ptr = it->second->value();\n      return WasmResult::Ok;\n    }\n    return WasmResult::NotFound;\n  } else if (type == MetricType::Gauge) {\n    auto it = wasm_->gauges_.find(metric_id);\n    if (it != wasm_->gauges_.end()) {\n      *result_uint64_ptr = it->second->value();\n      return WasmResult::Ok;\n    }\n    return WasmResult::NotFound;\n  }\n  return WasmResult::BadArgument;\n}\n\nWasm::Wasm(absl::string_view vm, absl::string_view vm_id, absl::string_view vm_configuration,\n           PluginSharedPtr plugin, Stats::ScopeSharedPtr scope,\n           Upstream::ClusterManager& cluster_manager, Event::Dispatcher& dispatcher)\n    : vm_id_(std::string(vm_id)), wasm_vm_(Common::Wasm::createWasmVm(vm)), plugin_(plugin),\n      scope_(scope), cluster_manager_(cluster_manager), dispatcher_(dispatcher),\n      time_source_(dispatcher.timeSource()), vm_configuration_(vm_configuration),\n      stat_name_set_(scope_->symbolTable().makeSet(\"Wasm\").release()) {}\n\nstd::string Plugin::makeLogPrefix() const {\n  std::string prefix;\n  if (!name_.empty()) {\n    prefix = prefix + \" \" + name_;\n  }\n  if (!root_id_.empty()) {\n    prefix = prefix + \" \" + std::string(root_id_);\n  }\n  if (vm_id_.empty()) {\n    prefix = prefix + \" \" + std::string(vm_id_);\n  }\n  return prefix;\n}\n\nContext::~Context() {\n  // Cancel any outstanding requests.\n  for (auto& p : http_request_) {\n    p.second.request->cancel();\n  }\n  for (auto& p : grpc_call_request_) {\n    p.second.request->cancel();\n  }\n  for (auto& p : grpc_stream_) {\n    p.second.stream->resetStream();\n  }\n  // Do not remove vm or root contexts which have the same lifetime as wasm_.\n  if (root_context_id_) {\n    wasm_->contexts_.erase(id_);\n  }\n}\n\nvoid Wasm::registerCallbacks() {\n#define _REGISTER(_fn)                                                                             \\\n  wasm_vm_->registerCallback(                                                                      \\\n      \"env\", #_fn, &_fn##Handler,                                                                  \\\n      &ConvertFunctionWordToUint32<decltype(_fn##Handler),                                         \\\n                                   _fn##Handler>::convertFunctionWordToUint32)\n  if (is_emscripten_) {\n    _REGISTER(pthread_equal);\n  }\n#undef _REGISTER\n\n#define _REGISTER_WASI(_fn)                                                                        \\\n  wasm_vm_->registerCallback(                                                                      \\\n      \"wasi_unstable\", #_fn, &wasi_unstable_##_fn##Handler,                                        \\\n      &ConvertFunctionWordToUint32<decltype(wasi_unstable_##_fn##Handler),                         \\\n                                   wasi_unstable_##_fn##Handler>::convertFunctionWordToUint32)\n  if (is_emscripten_) {\n    _REGISTER_WASI(fd_write);\n    _REGISTER_WASI(fd_seek);\n    _REGISTER_WASI(fd_close);\n    _REGISTER_WASI(environ_get);\n    _REGISTER_WASI(environ_sizes_get);\n    _REGISTER_WASI(proc_exit);\n  }\n#undef _REGISTER_WASI\n\n  // Calls with the \"proxy_\" prefix.\n#define _REGISTER_PROXY(_fn)                                                                       \\\n  wasm_vm_->registerCallback(                                                                      \\\n      \"env\", \"proxy_\" #_fn, &_fn##Handler,                                                         \\\n      &ConvertFunctionWordToUint32<decltype(_fn##Handler),                                         \\\n                                   _fn##Handler>::convertFunctionWordToUint32);\n  _REGISTER_PROXY(log);\n\n  _REGISTER_PROXY(setProperty);\n  _REGISTER_PROXY(getProperty);\n\n  _REGISTER_PROXY(continueRequest);\n  _REGISTER_PROXY(continueResponse);\n  _REGISTER_PROXY(sendLocalResponse);\n  _REGISTER_PROXY(clearRouteCache);\n\n  _REGISTER_PROXY(getSharedData);\n  _REGISTER_PROXY(setSharedData);\n\n  _REGISTER_PROXY(registerSharedQueue);\n  _REGISTER_PROXY(resolveSharedQueue);\n  _REGISTER_PROXY(dequeueSharedQueue);\n  _REGISTER_PROXY(enqueueSharedQueue);\n\n  _REGISTER_PROXY(getDownstreamDataBufferBytes);\n  _REGISTER_PROXY(getUpstreamDataBufferBytes);\n\n  _REGISTER_PROXY(getHeaderMapValue);\n  _REGISTER_PROXY(addHeaderMapValue);\n  _REGISTER_PROXY(replaceHeaderMapValue);\n  _REGISTER_PROXY(removeHeaderMapValue);\n  _REGISTER_PROXY(getHeaderMapPairs);\n  _REGISTER_PROXY(setHeaderMapPairs);\n  _REGISTER_PROXY(getHeaderMapSize);\n\n  _REGISTER_PROXY(getRequestBodyBufferBytes);\n  _REGISTER_PROXY(getResponseBodyBufferBytes);\n\n  _REGISTER_PROXY(httpCall);\n\n  _REGISTER_PROXY(grpcCall);\n  _REGISTER_PROXY(grpcStream);\n  _REGISTER_PROXY(grpcClose);\n  _REGISTER_PROXY(grpcCancel);\n  _REGISTER_PROXY(grpcSend);\n\n  _REGISTER_PROXY(setTickPeriodMilliseconds);\n  _REGISTER_PROXY(getCurrentTimeNanoseconds);\n\n  _REGISTER_PROXY(defineMetric);\n  _REGISTER_PROXY(incrementMetric);\n  _REGISTER_PROXY(recordMetric);\n  _REGISTER_PROXY(getMetric);\n\n  _REGISTER_PROXY(setEffectiveContext);\n#undef _REGISTER_PROXY\n}\n\nvoid Wasm::getFunctions() {\n#define _GET(_fn) wasm_vm_->getFunction(#_fn, &_fn##_);\n  _GET(_start);\n  _GET(__wasm_call_ctors);\n\n  _GET(malloc);\n  _GET(free);\n#undef _GET\n\n#define _GET_PROXY(_fn) wasm_vm_->getFunction(\"proxy_\" #_fn, &_fn##_);\n  _GET_PROXY(validateConfiguration);\n  _GET_PROXY(onStart);\n  _GET_PROXY(onConfigure);\n  _GET_PROXY(onTick);\n\n  _GET_PROXY(onCreate);\n\n  _GET_PROXY(onNewConnection);\n  _GET_PROXY(onDownstreamData);\n  _GET_PROXY(onUpstreamData);\n  _GET_PROXY(onDownstreamConnectionClose);\n  _GET_PROXY(onUpstreamConnectionClose);\n\n  _GET_PROXY(onRequestHeaders);\n  _GET_PROXY(onRequestBody);\n  _GET_PROXY(onRequestTrailers);\n  _GET_PROXY(onRequestMetadata);\n  _GET_PROXY(onResponseHeaders);\n  _GET_PROXY(onResponseBody);\n  _GET_PROXY(onResponseTrailers);\n  _GET_PROXY(onResponseMetadata);\n  _GET_PROXY(onHttpCallResponse);\n  _GET_PROXY(onGrpcReceive);\n  _GET_PROXY(onGrpcClose);\n  _GET_PROXY(onGrpcCreateInitialMetadata);\n  _GET_PROXY(onGrpcReceiveInitialMetadata);\n  _GET_PROXY(onGrpcReceiveTrailingMetadata);\n  _GET_PROXY(onQueueReady);\n  _GET_PROXY(onDone);\n  _GET_PROXY(onLog);\n  _GET_PROXY(onDelete);\n#undef _GET_PROXY\n\n  if (!malloc_ || !free_) {\n    throw WasmException(\"WASM missing malloc/free\");\n  }\n}\n\nWasm::Wasm(const Wasm& wasm, Event::Dispatcher& dispatcher)\n    : std::enable_shared_from_this<Wasm>(wasm), vm_id_(wasm.vm_id_), plugin_(wasm.plugin_),\n      scope_(wasm.scope_), cluster_manager_(wasm.cluster_manager_), dispatcher_(dispatcher),\n      time_source_(dispatcher.timeSource()), stat_name_set_(wasm.stat_name_set_) {\n  if (wasm.wasmVm()->cloneable()) {\n    wasm_vm_ = wasm.wasmVm()->clone();\n    vm_context_ = std::make_shared<Context>(this);\n    getFunctions();\n  } else {\n    wasm_vm_ = Common::Wasm::createWasmVm(wasm.wasmVm()->runtime());\n    if (!initialize(wasm.code(), wasm.allow_precompiled())) {\n      throw WasmException(\"Failed to initialize WASM code\");\n    }\n  }\n}\n\nbool Wasm::initialize(const std::string& code, bool allow_precompiled) {\n  if (!wasm_vm_) {\n    return false;\n  }\n\n  // If the configured_vm_id is empty, then hash the code to create a unique vm_id.\n  if (vm_id_.empty()) {\n    vm_id_ = base64Sha256(code);\n  }\n\n  auto ok = wasm_vm_->load(code, allow_precompiled);\n  if (!ok) {\n    return false;\n  }\n  auto metadata = wasm_vm_->getCustomSection(\"emscripten_metadata\");\n  if (!metadata.empty()) {\n    // See https://github.com/emscripten-core/emscripten/blob/incoming/tools/shared.py#L3059\n    is_emscripten_ = true;\n    auto start = reinterpret_cast<const uint8_t*>(metadata.data());\n    auto end = reinterpret_cast<const uint8_t*>(metadata.data() + metadata.size());\n    start = decodeVarint(start, end, &emscripten_metadata_major_version_);\n    start = decodeVarint(start, end, &emscripten_metadata_minor_version_);\n    start = decodeVarint(start, end, &emscripten_abi_major_version_);\n    start = decodeVarint(start, end, &emscripten_abi_minor_version_);\n    uint32_t temp;\n    if (emscripten_metadata_major_version_ > 0 || emscripten_metadata_minor_version_ > 1) {\n      // metadata 0.2 - added: wasm_backend.\n      start = decodeVarint(start, end, &temp);\n    }\n    start = decodeVarint(start, end, &temp);\n    start = decodeVarint(start, end, &temp);\n    if (emscripten_metadata_major_version_ > 0 || emscripten_metadata_minor_version_ > 0) {\n      // metadata 0.1 - added: global_base, dynamic_base, dynamictop_ptr and tempdouble_ptr.\n      start = decodeVarint(start, end, &temp);\n      start = decodeVarint(start, end, &temp);\n      start = decodeVarint(start, end, &temp);\n      decodeVarint(start, end, &temp);\n      if (emscripten_metadata_major_version_ > 0 || emscripten_metadata_minor_version_ > 2) {\n        // metadata 0.3 - added: standalone_wasm.\n        start = decodeVarint(start, end, &emscripten_standalone_wasm_);\n      }\n    }\n  }\n  registerCallbacks();\n  wasm_vm_->link(vm_id_);\n  vm_context_ = std::make_shared<Context>(this);\n  getFunctions();\n  startVm(vm_context_.get());\n  code_ = code;\n  allow_precompiled_ = allow_precompiled;\n  return true;\n}\n\nvoid Wasm::startVm(Context* root_context) {\n  /* Call \"_start\" function, and fallback to \"__wasm_call_ctors\" if the former is not available. */\n  if (_start_) {\n    _start_(root_context);\n  } else if (__wasm_call_ctors_) {\n    __wasm_call_ctors_(root_context);\n  }\n}\n\nbool Wasm::configure(Context* root_context, absl::string_view configuration) {\n  if (!onConfigure_) {\n    return true;\n  }\n  auto address = copyString(configuration);\n  return onConfigure_(root_context, root_context->id(), address, configuration.size()).u64_ != 0;\n}\n\nContext* Wasm::start() {\n  auto root_id = plugin_->root_id_;\n  auto it = root_contexts_.find(root_id);\n  if (it != root_contexts_.end()) {\n    it->second->onStart(root_id, vm_configuration());\n    return it->second.get();\n  }\n  auto context = std::make_unique<Context>(this, root_id, plugin_);\n  auto context_ptr = context.get();\n  root_contexts_[root_id] = std::move(context);\n  context_ptr->onStart(root_id, vm_configuration());\n  return context_ptr;\n};\n\nvoid Wasm::startForTesting(std::unique_ptr<Context> context) {\n  auto context_ptr = context.get();\n  if (!context->wasm_) {\n    // Initialization was delayed till the Wasm object was created.\n    context->wasm_ = this;\n    context->plugin_ = plugin_;\n    context->id_ = allocContextId();\n    contexts_[context->id_] = context.get();\n  }\n  root_contexts_[\"\"] = std::move(context);\n  context_ptr->onStart(\"\", \"\");\n}\n\nvoid Wasm::setTickPeriod(uint32_t context_id, std::chrono::milliseconds new_tick_period) {\n  auto& tick_period = tick_period_[context_id];\n  auto& timer = timer_[context_id];\n  bool was_running = timer && tick_period.count() > 0;\n  tick_period = new_tick_period;\n  if (tick_period.count() > 0 && !was_running) {\n    timer = dispatcher_.createTimer([weak = std::weak_ptr<Wasm>(shared_from_this()), context_id]() {\n      auto shared = weak.lock();\n      if (shared) {\n        shared->tickHandler(context_id);\n      }\n    });\n    timer->enableTimer(tick_period);\n  }\n}\n\nvoid Wasm::tickHandler(uint32_t root_context_id) {\n  auto& tick_period = tick_period_[root_context_id];\n  auto& timer = timer_[root_context_id];\n  if (onTick_) {\n    onTick_(getContext(root_context_id), root_context_id);\n    if (timer && tick_period.count() > 0) {\n      timer->enableTimer(tick_period);\n    }\n  }\n}\n\nuint32_t Wasm::allocContextId() {\n  while (true) {\n    auto id = next_context_id_++;\n    // Prevent reuse.\n    if (contexts_.find(id) == contexts_.end()) {\n      return id;\n    }\n  }\n}\n\nvoid Wasm::queueReady(uint32_t root_context_id, uint32_t token) {\n  auto it = contexts_.find(root_context_id);\n  if (it == contexts_.end() || !it->second->isRootContext()) {\n    return;\n  }\n  it->second->onQueueReady(token);\n}\n\nNetwork::FilterStatus Context::onNewConnection() { return onNetworkNewConnection(); };\n\nNetwork::FilterStatus Context::onData(Buffer::Instance& data, bool end_stream) {\n  network_downstream_data_buffer_ = &data;\n  auto result = onDownstreamData(data.length(), end_stream);\n  network_downstream_data_buffer_ = nullptr;\n  return result;\n}\n\nNetwork::FilterStatus Context::onWrite(Buffer::Instance& data, bool end_stream) {\n  network_upstream_data_buffer_ = &data;\n  auto result = onUpstreamData(data.length(), end_stream);\n  network_upstream_data_buffer_ = nullptr;\n  if (end_stream) {\n    // This is called when seeing end_stream=true and not on an upstream connection event,\n    // because registering for latter requires replicating the whole TCP proxy extension.\n    onUpstreamConnectionClose(PeerType::Unknown);\n  }\n  return result;\n}\n\nvoid Context::onEvent(Network::ConnectionEvent event) {\n  switch (event) {\n  case Network::ConnectionEvent::LocalClose:\n    onDownstreamConnectionClose(PeerType::Local);\n    break;\n  case Network::ConnectionEvent::RemoteClose:\n    onDownstreamConnectionClose(PeerType::Remote);\n    break;\n  default:\n    break;\n  }\n}\n\nvoid Context::initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) {\n  network_read_filter_callbacks_ = &callbacks;\n  network_read_filter_callbacks_->connection().addConnectionCallbacks(*this);\n}\n\nvoid Context::initializeWriteFilterCallbacks(Network::WriteFilterCallbacks& callbacks) {\n  network_write_filter_callbacks_ = &callbacks;\n}\n\nvoid Wasm::log(absl::string_view root_id, const Http::HeaderMap* request_headers,\n               const Http::HeaderMap* response_headers, const Http::HeaderMap* response_trailers,\n               const StreamInfo::StreamInfo& stream_info) {\n  // Check dynamic metadata for the id_ of the stream for this root_id.\n  Context* context = nullptr;\n  auto metadata_it = stream_info.dynamicMetadata().filter_metadata().find(\n      HttpFilters::HttpFilterNames::get().Wasm);\n  if (metadata_it != stream_info.dynamicMetadata().filter_metadata().end()) {\n    auto find_id =\n        metadata_it->second.fields().find(std::string(\"_stream_id_\" + std::string(root_id)));\n    if (find_id != metadata_it->second.fields().end()) {\n      context = getContext(static_cast<uint32_t>(find_id->second.number_value()));\n    }\n  }\n  if (!context) {\n    context = getRootContext(root_id);\n  }\n  context->log(request_headers, response_headers, response_trailers, stream_info);\n}\n\nvoid Context::log(const Http::HeaderMap* request_headers, const Http::HeaderMap* response_headers,\n                  const Http::HeaderMap* response_trailers,\n                  const StreamInfo::StreamInfo& stream_info) {\n  access_log_request_headers_ = request_headers;\n  // ? request_trailers  ?\n  access_log_response_headers_ = response_headers;\n  access_log_response_trailers_ = response_trailers;\n  access_log_stream_info_ = &stream_info;\n\n  onLog();\n\n  access_log_request_headers_ = nullptr;\n  // ? request_trailers  ?\n  access_log_response_headers_ = nullptr;\n  access_log_response_trailers_ = nullptr;\n  access_log_stream_info_ = nullptr;\n\n  onDelete();\n}\n\nvoid Context::onDestroy() {\n  if (destroyed_) {\n    return;\n  }\n  destroyed_ = true;\n  onDone();\n}\n\nvoid Context::onDone() {\n  if (wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}\n\nvoid Context::onLog() {\n  if (wasm_->onLog_) {\n    wasm_->onLog_(this, id_);\n  }\n}\n\nvoid Context::onDelete() {\n  if (wasm_->onDelete_) {\n    wasm_->onDelete_(this, id_);\n  }\n}\n\nHttp::FilterHeadersStatus Context::decodeHeaders(Http::HeaderMap& headers, bool end_stream) {\n  request_headers_ = &headers;\n  request_end_of_stream_ = end_stream;\n  auto result = onRequestHeaders();\n  request_headers_ = nullptr;\n  return result;\n}\n\nHttp::FilterDataStatus Context::decodeData(Buffer::Instance& data, bool end_stream) {\n  requestBodyBuffer_ = &data;\n  auto result = onRequestBody(data.length(), end_stream);\n  requestBodyBuffer_ = nullptr;\n  return result;\n}\n\nHttp::FilterTrailersStatus Context::decodeTrailers(Http::HeaderMap& trailers) {\n  request_trailers_ = &trailers;\n  auto result = onRequestTrailers();\n  request_trailers_ = nullptr;\n  return result;\n}\n\nHttp::FilterMetadataStatus Context::decodeMetadata(Http::MetadataMap& response_metadata) {\n  response_metadata_ = &response_metadata;\n  auto result = onRequestMetadata();\n  response_metadata_ = nullptr;\n  return result;\n}\n\nvoid Context::setDecoderFilterCallbacks(Envoy::Http::StreamDecoderFilterCallbacks& callbacks) {\n  decoder_callbacks_ = &callbacks;\n}\n\nHttp::FilterHeadersStatus Context::encode100ContinueHeaders(Http::HeaderMap&) {\n  return Http::FilterHeadersStatus::Continue;\n}\n\nHttp::FilterHeadersStatus Context::encodeHeaders(Http::HeaderMap& headers, bool end_stream) {\n  response_headers_ = &headers;\n  response_end_of_stream_ = end_stream;\n  auto result = onResponseHeaders();\n  response_headers_ = nullptr;\n  return result;\n}\n\nHttp::FilterDataStatus Context::encodeData(Buffer::Instance& data, bool end_stream) {\n  responseBodyBuffer_ = &data;\n  auto result = onResponseBody(data.length(), end_stream);\n  responseBodyBuffer_ = nullptr;\n  return result;\n}\n\nHttp::FilterTrailersStatus Context::encodeTrailers(Http::HeaderMap& trailers) {\n  response_trailers_ = &trailers;\n  auto result = onResponseTrailers();\n  response_trailers_ = nullptr;\n  return result;\n}\n\nHttp::FilterMetadataStatus Context::encodeMetadata(Http::MetadataMap& response_metadata) {\n  response_metadata_ = &response_metadata;\n  auto result = onResponseMetadata();\n  response_metadata_ = nullptr;\n  return result;\n}\n\n//  Http::FilterMetadataStatus::Continue;\n\nvoid Context::setEncoderFilterCallbacks(Envoy::Http::StreamEncoderFilterCallbacks& callbacks) {\n  encoder_callbacks_ = &callbacks;\n}\n\nvoid Context::onHttpCallSuccess(uint32_t token, Envoy::Http::MessagePtr& response) {\n  auto body =\n      absl::string_view(static_cast<char*>(response->body()->linearize(response->body()->length())),\n                        response->body()->length());\n  onHttpCallResponse(token, headerMapToPairs(&response->headers()), body,\n                     headerMapToPairs(response->trailers()));\n  http_request_.erase(token);\n}\n\nvoid Context::onHttpCallFailure(uint32_t token, Http::AsyncClient::FailureReason /* reason */) {\n  onHttpCallResponse(token, {}, \"\", {});\n  http_request_.erase(token);\n}\n\nvoid AsyncClientHandler::onSuccess(Envoy::Http::MessagePtr&& response) {\n  context->onHttpCallSuccess(token, response);\n}\n\nvoid AsyncClientHandler::onFailure(Http::AsyncClient::FailureReason reason) {\n  context->onHttpCallFailure(token, reason);\n}\n\nvoid GrpcCallClientHandler::onCreateInitialMetadata(Http::HeaderMap& metadata) {\n  context->onGrpcCreateInitialMetadata(token, metadata);\n}\n\nvoid GrpcStreamClientHandler::onCreateInitialMetadata(Http::HeaderMap& metadata) {\n  context->onGrpcCreateInitialMetadata(token, metadata);\n}\n\nvoid GrpcStreamClientHandler::onReceiveInitialMetadata(Http::HeaderMapPtr&& metadata) {\n  context->onGrpcReceiveInitialMetadata(token, std::move(metadata));\n}\n\nvoid GrpcStreamClientHandler::onReceiveTrailingMetadata(Http::HeaderMapPtr&& metadata) {\n  context->onGrpcReceiveTrailingMetadata(token, std::move(metadata));\n}\n\nvoid Context::onGrpcReceive(uint32_t token, Buffer::InstancePtr response) {\n  if (wasm_->onGrpcReceive_) {\n    auto response_size = response->length();\n    auto response_ptr = wasm_->copyBuffer(*response);\n    wasm_->onGrpcReceive_(this, id_, token, response_ptr, response_size);\n  }\n  if (IsGrpcCallToken(token)) {\n    grpc_call_request_.erase(token);\n  }\n}\n\nvoid Context::onGrpcClose(uint32_t token, const Grpc::Status::GrpcStatus& status,\n                          const absl::string_view message) {\n  if (wasm_->onGrpcClose_) {\n    auto message_ptr = wasm_->copyString(message);\n    wasm_->onGrpcClose_(this, id_, token, static_cast<uint64_t>(status), message_ptr,\n                        message.size());\n  }\n  if (IsGrpcCallToken(token)) {\n    grpc_call_request_.erase(token);\n  } else {\n    grpc_stream_.erase(token);\n  }\n}\n\nWasmResult Context::grpcSend(uint32_t token, absl::string_view message, bool end_stream) {\n  if (IsGrpcCallToken(token)) {\n    return WasmResult::BadArgument;\n  }\n  auto it = grpc_stream_.find(token);\n  if (it == grpc_stream_.end()) {\n    return WasmResult::NotFound;\n  }\n  if (it != grpc_stream_.end() && it->second.stream) {\n    it->second.stream->sendMessageRaw(\n        Buffer::InstancePtr(new Buffer::OwnedImpl(message.data(), message.size())), end_stream);\n  }\n  return WasmResult::Ok;\n}\n\nWasmResult Context::grpcClose(uint32_t token) {\n  if (IsGrpcCallToken(token)) {\n    auto it = grpc_call_request_.find(token);\n    if (it == grpc_call_request_.end()) {\n      return WasmResult::NotFound;\n    }\n    if (it != grpc_call_request_.end() && it->second.request) {\n      it->second.request->cancel();\n    }\n    grpc_call_request_.erase(token);\n  } else {\n    auto it = grpc_stream_.find(token);\n    if (it == grpc_stream_.end()) {\n      return WasmResult::NotFound;\n    }\n    if (it != grpc_stream_.end() && it->second.stream) {\n      it->second.stream->closeStream();\n    }\n    grpc_stream_.erase(token);\n  }\n  return WasmResult::Ok;\n}\n\nWasmResult Context::grpcCancel(uint32_t token) {\n  if (IsGrpcCallToken(token)) {\n    auto it = grpc_call_request_.find(token);\n    if (it == grpc_call_request_.end()) {\n      return WasmResult::NotFound;\n    }\n    if (it != grpc_call_request_.end() && it->second.request) {\n      it->second.request->cancel();\n    }\n    grpc_call_request_.erase(token);\n  } else {\n    auto it = grpc_stream_.find(token);\n    if (it == grpc_stream_.end()) {\n      return WasmResult::NotFound;\n    }\n    if (it != grpc_stream_.end() && it->second.stream) {\n      it->second.stream->resetStream();\n    }\n    grpc_stream_.erase(token);\n  }\n  return WasmResult::Ok;\n}\n\nvoid GrpcCallClientHandler::onSuccessRaw(Buffer::InstancePtr&& response, Tracing::Span&) {\n  context->onGrpcReceive(token, std::move(response));\n}\n\nvoid GrpcCallClientHandler::onFailure(Grpc::Status::GrpcStatus status, const std::string& message,\n                                      Tracing::Span&) {\n  context->onGrpcClose(token, status, message);\n}\n\nbool GrpcStreamClientHandler::onReceiveMessageRaw(Buffer::InstancePtr&& response) {\n  context->onGrpcReceive(token, std::move(response));\n  return true;\n}\n\nvoid GrpcStreamClientHandler::onRemoteClose(Grpc::Status::GrpcStatus status,\n                                            const std::string& message) {\n  context->onGrpcClose(token, status, message);\n}\n\nstatic std::shared_ptr<Wasm> createWasmInternal(const envoy::config::wasm::v2::VmConfig& vm_config,\n                                                PluginSharedPtr plugin, Stats::ScopeSharedPtr scope,\n                                                Upstream::ClusterManager& cluster_manager,\n                                                Event::Dispatcher& dispatcher, Api::Api& api,\n                                                std::unique_ptr<Context> root_context_for_testing) {\n  auto wasm =\n      std::make_shared<Wasm>(vm_config.runtime(), vm_config.vm_id(), vm_config.configuration(),\n                             plugin, scope, cluster_manager, dispatcher);\n  const auto& code = Config::DataSource::read(vm_config.code(), true, api);\n  const auto& path = Config::DataSource::getPath(vm_config.code())\n                         .value_or(code.empty() ? EMPTY_STRING : INLINE_STRING);\n  if (code.empty()) {\n    throw WasmException(fmt::format(\"Failed to load WASM code from {}\", path));\n  }\n  if (!wasm->initialize(code, vm_config.allow_precompiled())) {\n    throw WasmException(fmt::format(\"Failed to initialize WASM code from {}\", path));\n  }\n  if (!root_context_for_testing) {\n    wasm->start();\n  } else {\n    wasm->startForTesting(std::move(root_context_for_testing));\n  }\n  return wasm;\n}\n\nstd::shared_ptr<Wasm> createWasm(const envoy::config::wasm::v2::VmConfig& vm_config,\n                                 PluginSharedPtr plugin, Stats::ScopeSharedPtr scope,\n                                 Upstream::ClusterManager& cluster_manager,\n                                 Event::Dispatcher& dispatcher, Api::Api& api) {\n  return createWasmInternal(vm_config, plugin, scope, cluster_manager, dispatcher, api,\n                            nullptr /* root_context_for_testing */);\n} // namespace Wasm\n\nstd::shared_ptr<Wasm> createWasmForTesting(const envoy::config::wasm::v2::VmConfig& vm_config,\n                                           PluginSharedPtr plugin, Stats::ScopeSharedPtr scope,\n                                           Upstream::ClusterManager& cluster_manager,\n                                           Event::Dispatcher& dispatcher, Api::Api& api,\n                                           std::unique_ptr<Context> root_context_for_testing) {\n  return createWasmInternal(vm_config, plugin, scope, cluster_manager, dispatcher, api,\n                            std::move(root_context_for_testing));\n}\n\nstd::shared_ptr<Wasm> createThreadLocalWasm(Wasm& base_wasm, absl::string_view configuration,\n                                            Event::Dispatcher& dispatcher) {\n  auto wasm = std::make_shared<Wasm>(base_wasm, dispatcher);\n  Context* root_context = wasm->start();\n  if (!wasm->configure(root_context, configuration)) {\n    throw WasmException(\"Failed to configure WASM code\");\n  }\n  if (!wasm->vm_id().empty()) {\n    local_wasms[wasm->vm_id()] = wasm;\n  }\n  return wasm;\n}\n\nstd::shared_ptr<Wasm> getThreadLocalWasmPtr(absl::string_view vm_id) {\n  auto it = local_wasms.find(vm_id);\n  if (it == local_wasms.end()) {\n    return nullptr;\n  }\n  auto wasm = it->second.lock();\n  if (!wasm) {\n    local_wasms.erase(vm_id);\n  }\n  return wasm;\n}\n\nstd::shared_ptr<Wasm> getOrCreateThreadLocalWasm(Wasm& base_wasm, absl::string_view configuration,\n                                                 Event::Dispatcher& dispatcher) {\n  auto wasm = getThreadLocalWasmPtr(base_wasm.vm_id());\n  if (wasm) {\n    auto root_context = wasm->start();\n    if (!wasm->configure(root_context, configuration)) {\n      throw WasmException(\"Failed to configure WASM code\");\n    }\n    return wasm;\n  }\n  return createThreadLocalWasm(base_wasm, configuration, dispatcher);\n}\n\n} // namespace Wasm\n} // namespace Common\n} // namespace Extensions\n} // namespace Envoy\n", "#pragma once\n\n#include <map>\n#include <memory>\n\n#include \"envoy/access_log/access_log.h\"\n#include \"envoy/buffer/buffer.h\"\n#include \"envoy/common/exception.h\"\n#include \"envoy/config/wasm/v2/wasm.pb.validate.h\"\n#include \"envoy/http/filter.h\"\n#include \"envoy/server/wasm.h\"\n#include \"envoy/stats/scope.h\"\n#include \"envoy/stats/stats.h\"\n#include \"envoy/thread_local/thread_local.h\"\n#include \"envoy/upstream/cluster_manager.h\"\n\n#include \"common/common/assert.h\"\n#include \"common/common/logger.h\"\n#include \"common/common/stack_array.h\"\n#include \"common/stats/symbol_table_impl.h\"\n\n#include \"extensions/common/wasm/wasm_vm.h\"\n#include \"extensions/common/wasm/well_known_names.h\"\n#include \"extensions/filters/http/well_known_names.h\"\n\nnamespace Envoy {\n\n// TODO: move to source/common/stats/symbol_table_impl.h when upstreaming.\nnamespace Stats {\nusing StatNameSetSharedPtr = std::shared_ptr<Stats::StatNameSet>;\n} // namespace Stats\n\nnamespace Extensions {\nnamespace Common {\nnamespace Wasm {\n\n#include \"api/wasm/cpp/proxy_wasm_result.h\"\n#include \"api/wasm/cpp/proxy_wasm_metadata.h\"\n\nclass Context;\nclass Wasm;\nclass WasmVm;\n\nusing Pairs = std::vector<std::pair<absl::string_view, absl::string_view>>;\nusing PairsWithStringValues = std::vector<std::pair<absl::string_view, std::string>>;\n\nenum class StreamType : int32_t { Request = 0, Response = 1, MAX = 1 };\n\n// Handlers for functions exported from envoy to wasm.\nWord logHandler(void* raw_context, Word level, Word address, Word size);\nWord getPropertyHandler(void* raw_context, Word path_ptr, Word path_size, Word value_ptr_ptr,\n                        Word value_size_ptr);\nWord setPropertyHandler(void* raw_context, Word key_ptr, Word key_size, Word value_ptr,\n                        Word value_size);\nWord continueRequestHandler(void* raw_context);\nWord continueResponseHandler(void* raw_context);\nWord sendLocalResponseHandler(void* raw_context, Word response_code, Word response_code_details_ptr,\n                              Word response_code_details_size, Word body_ptr, Word body_size,\n                              Word additional_response_header_pairs_ptr,\n                              Word additional_response_header_pairs_size, Word grpc_status);\nWord clearRouteCacheHandler(void* raw_context);\nWord getSharedDataHandler(void* raw_context, Word key_ptr, Word key_size, Word value_ptr_ptr,\n                          Word value_size_ptr, Word cas_ptr);\nWord setSharedDataHandler(void* raw_context, Word key_ptr, Word key_size, Word value_ptr,\n                          Word value_size, Word cas);\nWord registerSharedQueueHandler(void* raw_context, Word queue_name_ptr, Word queue_name_size,\n                                Word token_ptr);\nWord resolveSharedQueueHandler(void* raw_context, Word vm_id_ptr, Word vm_id_size,\n                               Word queue_name_ptr, Word queue_name_size, Word token_ptr);\nWord dequeueSharedQueueHandler(void* raw_context, Word token, Word data_ptr_ptr,\n                               Word data_size_ptr);\nWord enqueueSharedQueueHandler(void* raw_context, Word token, Word data_ptr, Word data_size);\nWord getDownstreamDataBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                         Word size_ptr);\nWord getUpstreamDataBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                       Word size_ptr);\nWord addHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size,\n                              Word value_ptr, Word value_size);\nWord getHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size,\n                              Word value_ptr_ptr, Word value_size_ptr);\nWord replaceHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size,\n                                  Word value_ptr, Word value_size);\nWord removeHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size);\nWord getHeaderMapPairsHandler(void* raw_context, Word type, Word ptr_ptr, Word size_ptr);\nWord setHeaderMapPairsHandler(void* raw_context, Word type, Word ptr, Word size);\nWord getHeaderMapSizeHandler(void* raw_context, Word type, Word result_ptr);\nWord getRequestBodyBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                      Word size_ptr);\nWord getResponseBodyBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                       Word size_ptr);\nWord httpCallHandler(void* raw_context, Word uri_ptr, Word uri_size, Word header_pairs_ptr,\n                     Word header_pairs_size, Word body_ptr, Word body_size, Word trailer_pairs_ptr,\n                     Word trailer_pairs_size, Word timeout_milliseconds);\nWord defineMetricHandler(void* raw_context, Word metric_type, Word name_ptr, Word name_size,\n                         Word result_ptr);\nWord incrementMetricHandler(void* raw_context, Word metric_id, int64_t offset);\nWord recordMetricHandler(void* raw_context, Word metric_id, uint64_t value);\nWord getMetricHandler(void* raw_context, Word metric_id, Word result_uint64_ptr);\nWord grpcCallHandler(void* raw_context, Word service_ptr, Word service_size, Word service_name_ptr,\n                     Word service_name_size, Word method_name_ptr, Word method_name_size,\n                     Word request_ptr, Word request_size, Word timeout_milliseconds);\nWord grpcStreamHandler(void* raw_context, Word service_ptr, Word service_size,\n                       Word service_name_ptr, Word service_name_size, Word method_name_ptr,\n                       Word method_name_size);\nWord grpcCancelHandler(void* raw_context, Word token);\nWord grpcCloseHandler(void* raw_context, Word token);\nWord grpcSendHandler(void* raw_context, Word token, Word message_ptr, Word message_size,\n                     Word end_stream);\n\nWord setTickPeriodMillisecondsHandler(void* raw_context, Word tick_period_milliseconds);\nWord getCurrentTimeNanosecondsHandler(void* raw_context, Word result_uint64_ptr);\n\nWord setEffectiveContextHandler(void* raw_context, Word context_id);\n\ninline MetadataType StreamType2MetadataType(StreamType type) {\n  return static_cast<MetadataType>(type);\n}\n\nstruct AsyncClientHandler : public Http::AsyncClient::Callbacks {\n  // Http::AsyncClient::Callbacks\n  void onSuccess(Envoy::Http::MessagePtr&& response) override;\n  void onFailure(Http::AsyncClient::FailureReason reason) override;\n\n  Context* context;\n  uint32_t token;\n  Http::AsyncClient::Request* request;\n};\n\nstruct GrpcCallClientHandler : public Grpc::RawAsyncRequestCallbacks {\n  // Grpc::AsyncRequestCallbacks\n  void onCreateInitialMetadata(Http::HeaderMap& metadata) override;\n  void onSuccessRaw(Buffer::InstancePtr&& response, Tracing::Span& span) override;\n  void onFailure(Grpc::Status::GrpcStatus status, const std::string& message,\n                 Tracing::Span& span) override;\n\n  Context* context;\n  uint32_t token;\n  Grpc::RawAsyncClientPtr client;\n  Grpc::AsyncRequest* request;\n};\n\nstruct GrpcStreamClientHandler : public Grpc::RawAsyncStreamCallbacks {\n  // Grpc::AsyncStreamCallbacks\n  void onCreateInitialMetadata(Http::HeaderMap& metadata) override;\n  void onReceiveInitialMetadata(Http::HeaderMapPtr&& metadata) override;\n  bool onReceiveMessageRaw(Buffer::InstancePtr&& response) override;\n  void onReceiveTrailingMetadata(Http::HeaderMapPtr&& metadata) override;\n  void onRemoteClose(Grpc::Status::GrpcStatus status, const std::string& message) override;\n\n  Context* context;\n  uint32_t token;\n  Grpc::RawAsyncClientPtr client;\n  Grpc::RawAsyncStream* stream;\n};\n\n// Plugin contains the information for a filter/service.\nstruct Plugin {\n  Plugin(absl::string_view name, absl::string_view root_id, absl::string_view vm_id,\n         envoy::api::v2::core::TrafficDirection direction, const LocalInfo::LocalInfo& local_info,\n         const envoy::api::v2::core::Metadata* listener_metadata)\n      : name_(std::string(name)), root_id_(std::string(root_id)), vm_id_(std::string(vm_id)),\n        direction_(direction), local_info_(local_info), listener_metadata_(listener_metadata),\n        log_prefix_(makeLogPrefix()) {}\n\n  std::string makeLogPrefix() const;\n\n  const std::string name_;\n  const std::string root_id_;\n  const std::string vm_id_;\n  envoy::api::v2::core::TrafficDirection direction_;\n  const LocalInfo::LocalInfo& local_info_;\n  const envoy::api::v2::core::Metadata* listener_metadata_;\n\n  std::string log_prefix_;\n};\nusing PluginSharedPtr = std::shared_ptr<Plugin>;\n\n// A context which will be the target of callbacks for a particular session\n// e.g. a handler of a stream.\nclass Context : public Logger::Loggable<Logger::Id::wasm>,\n                public AccessLog::Instance,\n                public Http::StreamFilter,\n                public Network::ConnectionCallbacks,\n                public Network::Filter,\n                public std::enable_shared_from_this<Context> {\npublic:\n  Context();                                                              // Testing.\n  Context(Wasm* wasm);                                                    // Vm Context.\n  Context(Wasm* wasm, absl::string_view root_id, PluginSharedPtr plugin); // Root Context.\n  Context(Wasm* wasm, uint32_t root_context_id, PluginSharedPtr plugin);  // Stream context.\n  ~Context();\n\n  Wasm* wasm() const { return wasm_; }\n  uint32_t id() const { return id_; }\n  bool isVmContext() { return id_ == 0; }\n  bool isRootContext() { return root_context_id_ == 0; }\n  Context* root_context() { return root_context_; }\n\n  absl::string_view root_id() const { return plugin_->root_id_; }\n  absl::string_view log_prefix() const { return plugin_->log_prefix_; }\n\n  WasmVm* wasmVm() const;\n  Upstream::ClusterManager& clusterManager() const;\n\n  // Retrieves the stream info associated with the request (a.k.a active stream).\n  // It selects a value based on the following order: encoder callback, decoder\n  // callback, log callback. As long as any one of the callbacks is invoked, the value should be\n  // available.\n  const StreamInfo::StreamInfo* getConstRequestStreamInfo() const;\n  StreamInfo::StreamInfo* getRequestStreamInfo() const;\n\n  //\n  // VM level downcalls into the WASM code on Context(id == 0).\n  //\n  virtual bool validateConfiguration(absl::string_view configuration);\n  virtual void onStart(absl::string_view root_id, absl::string_view vm_configuration);\n  virtual bool onConfigure(absl::string_view configuration);\n\n  //\n  // Stream downcalls on Context(id > 0).\n  //\n  // General stream downcall on a new stream.\n  virtual void onCreate(uint32_t root_context_id);\n  // Network\n  virtual Network::FilterStatus onNetworkNewConnection();\n  virtual Network::FilterStatus onDownstreamData(int data_length, bool end_of_stream);\n  virtual Network::FilterStatus onUpstreamData(int data_length, bool end_of_stream);\n  enum class PeerType : uint32_t {\n    Unknown = 0,\n    Local = 1,\n    Remote = 2,\n  };\n  virtual void onDownstreamConnectionClose(PeerType);\n  virtual void onUpstreamConnectionClose(PeerType);\n  // HTTP Filter Stream Request Downcalls.\n  virtual Http::FilterHeadersStatus onRequestHeaders();\n  virtual Http::FilterDataStatus onRequestBody(int body_buffer_length, bool end_of_stream);\n  virtual Http::FilterTrailersStatus onRequestTrailers();\n  virtual Http::FilterMetadataStatus onRequestMetadata();\n  // HTTP Filter Stream Response Downcalls.\n  virtual Http::FilterHeadersStatus onResponseHeaders();\n  virtual Http::FilterDataStatus onResponseBody(int body_buffer_length, bool end_of_stream);\n  virtual Http::FilterTrailersStatus onResponseTrailers();\n  virtual Http::FilterMetadataStatus onResponseMetadata();\n  // Async Response Downcalls on any Context.\n  virtual void onHttpCallResponse(uint32_t token, const Pairs& response_headers,\n                                  absl::string_view response_body, const Pairs& response_trailers);\n  virtual void onQueueReady(uint32_t token);\n  // General stream downcall when the stream has ended.\n  virtual void onDone();\n  // General stream downcall for logging. Occurs after onDone().\n  virtual void onLog();\n  // General stream downcall when no further stream calls will occur.\n  virtual void onDelete();\n\n  //\n  // General Callbacks.\n  //\n  virtual void scriptLog(spdlog::level::level_enum level, absl::string_view message);\n  virtual WasmResult setTickPeriod(std::chrono::milliseconds tick_period);\n  virtual uint64_t getCurrentTimeNanoseconds();\n\n  //\n  // AccessLog::Instance\n  //\n  void log(const Http::HeaderMap* request_headers, const Http::HeaderMap* response_headers,\n           const Http::HeaderMap* response_trailers,\n           const StreamInfo::StreamInfo& stream_info) override;\n\n  //\n  // Network::ConnectionCallbacks\n  //\n  void onEvent(Network::ConnectionEvent event) override;\n  void onAboveWriteBufferHighWatermark() override {}\n  void onBelowWriteBufferLowWatermark() override {}\n\n  //\n  // Network::ReadFilter\n  //\n  Network::FilterStatus onNewConnection() override;\n  Network::FilterStatus onData(Buffer::Instance& data, bool end_stream) override;\n  void initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) override;\n\n  //\n  // Network::WriteFilter\n  //\n  Network::FilterStatus onWrite(Buffer::Instance& data, bool end_stream) override;\n  void initializeWriteFilterCallbacks(Network::WriteFilterCallbacks& callbacks) override;\n\n  //\n  // Http::StreamFilterBase\n  //\n  // Note: This calls onDone() in WASM.\n  void onDestroy() override;\n\n  //\n  // Http::StreamDecoderFilter\n  //\n  Http::FilterHeadersStatus decodeHeaders(Http::HeaderMap& headers, bool end_stream) override;\n  Http::FilterDataStatus decodeData(Buffer::Instance& data, bool end_stream) override;\n  Http::FilterTrailersStatus decodeTrailers(Http::HeaderMap& trailers) override;\n  Http::FilterMetadataStatus decodeMetadata(Http::MetadataMap& metadata_map) override;\n  void setDecoderFilterCallbacks(Envoy::Http::StreamDecoderFilterCallbacks& callbacks) override;\n\n  //\n  // Http::StreamEncoderFilter\n  //\n  Http::FilterHeadersStatus encode100ContinueHeaders(Http::HeaderMap&) override;\n  Http::FilterHeadersStatus encodeHeaders(Http::HeaderMap& headers, bool end_stream) override;\n  Http::FilterDataStatus encodeData(Buffer::Instance& data, bool end_stream) override;\n  Http::FilterTrailersStatus encodeTrailers(Http::HeaderMap& trailers) override;\n  Http::FilterMetadataStatus encodeMetadata(Http::MetadataMap& metadata_map) override;\n  void setEncoderFilterCallbacks(Envoy::Http::StreamEncoderFilterCallbacks& callbacks) override;\n\n  //\n  // HTTP Filter Callbacks\n  //\n\n  // State accessors\n  virtual WasmResult getProperty(absl::string_view path, std::string* result);\n  virtual WasmResult setProperty(absl::string_view key, absl::string_view serialized_value);\n\n  // Continue\n  virtual void continueRequest() {\n    if (decoder_callbacks_)\n      decoder_callbacks_->continueDecoding();\n  }\n  virtual void continueResponse() {\n    if (encoder_callbacks_)\n      encoder_callbacks_->continueEncoding();\n  }\n  virtual void sendLocalResponse(Http::Code response_code, absl::string_view body_text,\n                                 std::function<void(Http::HeaderMap& headers)> modify_headers,\n                                 const absl::optional<Grpc::Status::GrpcStatus> grpc_status,\n                                 absl::string_view details) {\n    if (decoder_callbacks_)\n      decoder_callbacks_->sendLocalReply(response_code, body_text, modify_headers, grpc_status,\n                                         details);\n  }\n  virtual void clearRouteCache() {\n    if (decoder_callbacks_)\n      decoder_callbacks_->clearRouteCache();\n  }\n\n  // Shared Data\n  virtual WasmResult getSharedData(absl::string_view key,\n                                   std::pair<std::string, uint32_t /* cas */>* data);\n  virtual WasmResult setSharedData(absl::string_view key, absl::string_view value, uint32_t cas);\n\n  // Shared Queue\n  virtual uint32_t registerSharedQueue(absl::string_view queue_name);\n  virtual WasmResult resolveSharedQueue(absl::string_view vm_id, absl::string_view queue_name,\n                                        uint32_t* token);\n  virtual WasmResult dequeueSharedQueue(uint32_t token, std::string* data);\n  virtual WasmResult enqueueSharedQueue(uint32_t token, absl::string_view value);\n\n  // Network\n  virtual WasmResult getDownstreamDataBufferBytes(uint32_t start, uint32_t length,\n                                                  absl::string_view* data);\n  virtual WasmResult getUpstreamDataBufferBytes(uint32_t start, uint32_t length,\n                                                absl::string_view* data);\n\n  // Header/Trailer/Metadata Maps\n  virtual void addHeaderMapValue(HeaderMapType type, absl::string_view key,\n                                 absl::string_view value);\n  virtual absl::string_view getHeaderMapValue(HeaderMapType type, absl::string_view key);\n  virtual Pairs getHeaderMapPairs(HeaderMapType type);\n  virtual void setHeaderMapPairs(HeaderMapType type, const Pairs& pairs);\n\n  virtual void removeHeaderMapValue(HeaderMapType type, absl::string_view key);\n  virtual void replaceHeaderMapValue(HeaderMapType type, absl::string_view key,\n                                     absl::string_view value);\n\n  virtual uint32_t getHeaderMapSize(HeaderMapType type);\n\n  // Body Buffer\n  virtual absl::string_view getRequestBodyBufferBytes(uint32_t start, uint32_t length);\n  virtual absl::string_view getResponseBodyBufferBytes(uint32_t start, uint32_t length);\n\n  // HTTP\n  // Returns a token which will be used with the corresponding onHttpCallResponse.\n  virtual uint32_t httpCall(absl::string_view cluster, const Pairs& request_headers,\n                            absl::string_view request_body, const Pairs& request_trailers,\n                            int timeout_millisconds);\n  virtual void httpRespond(const Pairs& response_headers, absl::string_view body,\n                           const Pairs& response_trailers);\n\n  // Stats/Metrics\n  enum class MetricType : uint32_t {\n    Counter = 0,\n    Gauge = 1,\n    Histogram = 2,\n    Max = 2,\n  };\n  virtual WasmResult defineMetric(MetricType type, absl::string_view name, uint32_t* metric_id_ptr);\n  virtual WasmResult incrementMetric(uint32_t metric_id, int64_t offset);\n  virtual WasmResult recordMetric(uint32_t metric_id, uint64_t value);\n  virtual WasmResult getMetric(uint32_t metric_id, uint64_t* value_ptr);\n\n  // gRPC\n  // Returns a token which will be used with the corresponding onGrpc and grpc calls.\n  virtual uint32_t grpcCall(const envoy::api::v2::core::GrpcService& grpc_service,\n                            absl::string_view service_name, absl::string_view method_name,\n                            absl::string_view request,\n                            const absl::optional<std::chrono::milliseconds>& timeout);\n  virtual uint32_t grpcStream(const envoy::api::v2::core::GrpcService& grpc_service,\n                              absl::string_view service_name, absl::string_view method_name);\n  virtual WasmResult grpcClose(uint32_t token);  // cancel on call, close on stream.\n  virtual WasmResult grpcCancel(uint32_t token); // cancel on call, reset on stream.\n  virtual WasmResult grpcSend(uint32_t token, absl::string_view message,\n                              bool end_stream); // stream only\n\n  // Connection\n  virtual bool isSsl();\n\nprotected:\n  friend class Wasm;\n  friend struct AsyncClientHandler;\n  friend struct GrpcCallClientHandler;\n  friend struct GrpcStreamClientHandler;\n\n  void onHttpCallSuccess(uint32_t token, Envoy::Http::MessagePtr& response);\n  void onHttpCallFailure(uint32_t token, Http::AsyncClient::FailureReason reason);\n\n  virtual void onGrpcCreateInitialMetadata(uint32_t token,\n                                           Http::HeaderMap& metadata); // For both Call and Stream.\n  virtual void onGrpcReceive(uint32_t token,\n                             Buffer::InstancePtr response); // Call (implies OK close) and Stream.\n  virtual void onGrpcClose(uint32_t token, const Grpc::Status::GrpcStatus& status,\n                           const absl::string_view message); // Call (not OK) and Stream.\n\n  virtual void onGrpcReceiveInitialMetadata(uint32_t token,\n                                            Http::HeaderMapPtr&& metadata); // Stream only.\n  virtual void onGrpcReceiveTrailingMetadata(uint32_t token,\n                                             Http::HeaderMapPtr&& metadata); // Stream only.\n\n  bool IsGrpcStreamToken(uint32_t token) { return (token & 1) == 0; }\n  bool IsGrpcCallToken(uint32_t token) { return (token & 1) == 1; }\n\n  Http::HeaderMap* getMap(HeaderMapType type);\n  const Http::HeaderMap* getConstMap(HeaderMapType type);\n\n  Wasm* wasm_{nullptr};\n  uint32_t id_{0};\n  uint32_t root_context_id_{0};    // 0 for roots and the general context.\n  Context* root_context_{nullptr}; // set in all contexts.\n  PluginSharedPtr plugin_;\n  bool in_vm_context_created_ = false;\n  bool destroyed_ = false;\n\n  uint32_t next_http_call_token_ = 1;\n  uint32_t next_grpc_token_ = 1; // Odd tokens are for Calls even for Streams.\n\n  // MB: must be a node-type map as we take persistent references to the entries.\n  std::map<uint32_t, AsyncClientHandler> http_request_;\n  std::map<uint32_t, GrpcCallClientHandler> grpc_call_request_;\n  std::map<uint32_t, GrpcStreamClientHandler> grpc_stream_;\n  Envoy::Http::StreamDecoderFilterCallbacks* decoder_callbacks_{};\n  Envoy::Http::StreamEncoderFilterCallbacks* encoder_callbacks_{};\n\n  // Network filter state.\n  Network::ReadFilterCallbacks* network_read_filter_callbacks_{};\n  Network::WriteFilterCallbacks* network_write_filter_callbacks_{};\n  Buffer::Instance* network_downstream_data_buffer_{};\n  Buffer::Instance* network_upstream_data_buffer_{};\n\n  // HTTP Filter state.\n  Http::HeaderMap* request_headers_{};\n  Http::HeaderMap* response_headers_{};\n  Buffer::Instance* requestBodyBuffer_{};\n  Buffer::Instance* responseBodyBuffer_{};\n  bool request_end_of_stream_{};\n  bool response_end_of_stream_{};\n  Http::HeaderMap* request_trailers_{};\n  Http::HeaderMap* response_trailers_{};\n  Http::MetadataMap* request_metadata_{};\n  Http::MetadataMap* response_metadata_{};\n\n  Http::HeaderMap* grpc_create_initial_metadata_{};\n  Http::HeaderMapPtr grpc_receive_initial_metadata_{};\n  Http::HeaderMapPtr grpc_receive_trailing_metadata_{};\n\n  const StreamInfo::StreamInfo* access_log_stream_info_{};\n  const Http::HeaderMap* access_log_request_headers_{};\n  const Http::HeaderMap* access_log_response_headers_{};\n  const Http::HeaderMap* access_log_request_trailers_{}; // unused\n  const Http::HeaderMap* access_log_response_trailers_{};\n\n  ProtobufWkt::Struct temporary_metadata_;\n};\n\n// Wasm execution instance. Manages the Envoy side of the Wasm interface.\nclass Wasm : public Envoy::Server::Wasm,\n             public ThreadLocal::ThreadLocalObject,\n             public Logger::Loggable<Logger::Id::wasm>,\n             public std::enable_shared_from_this<Wasm> {\npublic:\n  Wasm(absl::string_view runtime, absl::string_view vm_id, absl::string_view vm_configuration,\n       PluginSharedPtr plugin, Stats::ScopeSharedPtr scope,\n       Upstream::ClusterManager& cluster_manager, Event::Dispatcher& dispatcher);\n  Wasm(const Wasm& other, Event::Dispatcher& dispatcher);\n  ~Wasm() {}\n\n  bool initialize(const std::string& code, bool allow_precompiled = false);\n  void startVm(Context* root_context);\n  bool configure(Context* root_context, absl::string_view configuration);\n  Context* start(); // returns the root Context.\n\n  absl::string_view vm_id() const { return vm_id_; }\n  const PluginSharedPtr& plugin() const { return plugin_; }\n  void setPlugin(const PluginSharedPtr plugin) { plugin_ = plugin; }\n  WasmVm* wasmVm() const { return wasm_vm_.get(); }\n  Context* vmContext() const { return vm_context_.get(); }\n  Stats::StatNameSetSharedPtr stat_name_set() const { return stat_name_set_; }\n  Context* getRootContext(absl::string_view root_id) { return root_contexts_[root_id].get(); }\n  Context* getContext(uint32_t id) {\n    auto it = contexts_.find(id);\n    if (it != contexts_.end())\n      return it->second;\n    return nullptr;\n  }\n  Upstream::ClusterManager& clusterManager() const { return cluster_manager_; }\n  void setTickPeriod(uint32_t root_context_id, std::chrono::milliseconds tick_period);\n  void tickHandler(uint32_t root_context_id);\n  void queueReady(uint32_t root_context_id, uint32_t token);\n\n  uint32_t allocContextId();\n\n  const std::string& code() const { return code_; }\n  const std::string& vm_configuration() const { return vm_configuration_; }\n  bool allow_precompiled() const { return allow_precompiled_; }\n  void setInitialConfiguration(const std::string& vm_configuration) {\n    vm_configuration_ = vm_configuration;\n  }\n\n  //\n  // AccessLog::Instance\n  //\n  void log(absl::string_view root_id, const Http::HeaderMap* request_headers,\n           const Http::HeaderMap* response_headers, const Http::HeaderMap* response_trailers,\n           const StreamInfo::StreamInfo& stream_info);\n\n  // Support functions.\n  void* allocMemory(uint64_t size, uint64_t* address);\n  // Allocate a null-terminated string in the VM and return the pointer to use as a call arguments.\n  uint64_t copyString(absl::string_view s);\n  uint64_t copyBuffer(const Buffer::Instance& buffer);\n  // Copy the data in 's' into the VM along with the pointer-size pair. Returns true on success.\n  bool copyToPointerSize(absl::string_view s, uint64_t ptr_ptr, uint64_t size_ptr);\n  bool copyToPointerSize(const Buffer::Instance& buffer, uint64_t start, uint64_t length,\n                         uint64_t ptr_ptr, uint64_t size_ptr);\n  template <typename T> bool setDatatype(uint64_t ptr, const T& t);\n\n  // For testing.\n  void setContext(Context* context) { contexts_[context->id()] = context; }\n  void startForTesting(std::unique_ptr<Context> root_context);\n\n  bool getEmscriptenVersion(uint32_t* emscripten_metadata_major_version,\n                            uint32_t* emscripten_metadata_minor_version,\n                            uint32_t* emscripten_abi_major_version,\n                            uint32_t* emscripten_abi_minor_version) {\n    if (!is_emscripten_) {\n      return false;\n    }\n    *emscripten_metadata_major_version = emscripten_metadata_major_version_;\n    *emscripten_metadata_minor_version = emscripten_metadata_minor_version_;\n    *emscripten_abi_major_version = emscripten_abi_major_version_;\n    *emscripten_abi_minor_version = emscripten_abi_minor_version_;\n    return true;\n  }\n\nprivate:\n  friend class Context;\n  // These are the same as the values of the Context::MetricType enum, here separately for\n  // convenience.\n  static const uint32_t kMetricTypeCounter = 0x0;\n  static const uint32_t kMetricTypeGauge = 0x1;\n  static const uint32_t kMetricTypeHistogram = 0x2;\n  static const uint32_t kMetricTypeMask = 0x3;\n  static const uint32_t kMetricIdIncrement = 0x4;\n  static void StaticAsserts() {\n    static_assert(static_cast<uint32_t>(Context::MetricType::Counter) == kMetricTypeCounter, \"\");\n    static_assert(static_cast<uint32_t>(Context::MetricType::Gauge) == kMetricTypeGauge, \"\");\n    static_assert(static_cast<uint32_t>(Context::MetricType::Histogram) == kMetricTypeHistogram,\n                  \"\");\n  }\n\n  bool isCounterMetricId(uint32_t metric_id) {\n    return (metric_id & kMetricTypeMask) == kMetricTypeCounter;\n  }\n  bool isGaugeMetricId(uint32_t metric_id) {\n    return (metric_id & kMetricTypeMask) == kMetricTypeGauge;\n  }\n  bool isHistogramMetricId(uint32_t metric_id) {\n    return (metric_id & kMetricTypeMask) == kMetricTypeHistogram;\n  }\n  uint32_t nextCounterMetricId() { return next_counter_metric_id_ += kMetricIdIncrement; }\n  uint32_t nextGaugeMetricId() { return next_gauge_metric_id_ += kMetricIdIncrement; }\n  uint32_t nextHistogramMetricId() { return next_histogram_metric_id_ += kMetricIdIncrement; }\n\n  void registerCallbacks();    // Register functions called out from WASM.\n  void establishEnvironment(); // Language specific environments.\n  void getFunctions();         // Get functions call into WASM.\n\n  std::string vm_id_; // The effective vm_id (may be a hash).\n  std::unique_ptr<WasmVm> wasm_vm_;\n\n  PluginSharedPtr plugin_;\n  Stats::ScopeSharedPtr scope_;\n\n  Upstream::ClusterManager& cluster_manager_;\n  Event::Dispatcher& dispatcher_;\n\n  uint32_t next_context_id_ = 1;        // 0 is reserved for the VM context.\n  std::shared_ptr<Context> vm_context_; // Context unrelated to any specific root or stream\n                                        // (e.g. for global constructors).\n  absl::flat_hash_map<std::string, std::unique_ptr<Context>> root_contexts_;\n  absl::flat_hash_map<uint32_t, Context*> contexts_;                    // Contains all contexts.\n  std::unordered_map<uint32_t, std::chrono::milliseconds> tick_period_; // per root_id.\n  std::unordered_map<uint32_t, Event::TimerPtr> timer_;                 // per root_id.\n\n  TimeSource& time_source_;\n\n  WasmCallVoid<0> _start_; /* Emscripten v1.39.0+ */\n  WasmCallVoid<0> __wasm_call_ctors_;\n\n  WasmCallWord<1> malloc_;\n  WasmCallVoid<1> free_;\n\n  // Calls into the VM.\n  WasmCallWord<3> validateConfiguration_;\n  WasmCallVoid<5> onStart_;\n  WasmCallWord<3> onConfigure_;\n  WasmCallVoid<1> onTick_;\n\n  WasmCallVoid<2> onCreate_;\n\n  WasmCallWord<1> onNewConnection_;\n  WasmCallWord<3> onDownstreamData_;\n  WasmCallWord<3> onUpstreamData_;\n  WasmCallVoid<2> onDownstreamConnectionClose_;\n  WasmCallVoid<2> onUpstreamConnectionClose_;\n\n  WasmCallWord<1> onRequestHeaders_;\n  WasmCallWord<3> onRequestBody_;\n  WasmCallWord<1> onRequestTrailers_;\n  WasmCallWord<1> onRequestMetadata_;\n\n  WasmCallWord<1> onResponseHeaders_;\n  WasmCallWord<3> onResponseBody_;\n  WasmCallWord<1> onResponseTrailers_;\n  WasmCallWord<1> onResponseMetadata_;\n\n  WasmCallVoid<8> onHttpCallResponse_;\n\n  WasmCallVoid<4> onGrpcReceive_;\n  WasmCallVoid<5> onGrpcClose_;\n  WasmCallVoid<2> onGrpcCreateInitialMetadata_;\n  WasmCallVoid<2> onGrpcReceiveInitialMetadata_;\n  WasmCallVoid<2> onGrpcReceiveTrailingMetadata_;\n\n  WasmCallVoid<2> onQueueReady_;\n\n  WasmCallVoid<1> onDone_;\n  WasmCallVoid<1> onLog_;\n  WasmCallVoid<1> onDelete_;\n\n  // Used by the base_wasm to enable non-clonable thread local Wasm(s) to be constructed.\n  std::string code_;\n  std::string vm_configuration_;\n  bool allow_precompiled_ = false;\n\n  bool is_emscripten_ = false;\n  uint32_t emscripten_metadata_major_version_ = 0;\n  uint32_t emscripten_metadata_minor_version_ = 0;\n  uint32_t emscripten_abi_major_version_ = 0;\n  uint32_t emscripten_abi_minor_version_ = 0;\n  uint32_t emscripten_standalone_wasm_ = 0;\n\n  // Stats/Metrics\n  Stats::StatNameSetSharedPtr stat_name_set_;\n  uint32_t next_counter_metric_id_ = kMetricTypeCounter;\n  uint32_t next_gauge_metric_id_ = kMetricTypeGauge;\n  uint32_t next_histogram_metric_id_ = kMetricTypeHistogram;\n  absl::flat_hash_map<uint32_t, Stats::Counter*> counters_;\n  absl::flat_hash_map<uint32_t, Stats::Gauge*> gauges_;\n  absl::flat_hash_map<uint32_t, Stats::Histogram*> histograms_;\n};\n\n// These accessors require Wasm.\ninline WasmVm* Context::wasmVm() const { return wasm_->wasmVm(); }\ninline Upstream::ClusterManager& Context::clusterManager() const { return wasm_->clusterManager(); }\n\n// Create a high level Wasm VM with Envoy API support. Note: 'id' may be empty if this VM will not\n// be shared by APIs (e.g. HTTP Filter + AccessLog).\nstd::shared_ptr<Wasm> createWasm(const envoy::config::wasm::v2::VmConfig& vm_config,\n                                 PluginSharedPtr plugin_config, Stats::ScopeSharedPtr scope,\n                                 Upstream::ClusterManager& cluster_manager,\n                                 Event::Dispatcher& dispatcher, Api::Api& api);\n\n// Create a ThreadLocal VM from an existing VM (e.g. from createWasm() above).\nstd::shared_ptr<Wasm> createThreadLocalWasm(Wasm& base_wasm, absl::string_view configuration,\n                                            Event::Dispatcher& dispatcher);\n\nstd::shared_ptr<Wasm> createWasmForTesting(const envoy::config::wasm::v2::VmConfig& vm_config,\n                                           PluginSharedPtr plugin, Stats::ScopeSharedPtr scope,\n                                           Upstream::ClusterManager& cluster_manager,\n                                           Event::Dispatcher& dispatcher, Api::Api& api,\n                                           std::unique_ptr<Context> root_context_for_testing);\n\n// Get an existing ThreadLocal VM matching 'vm_id' or nullptr if there isn't one.\nstd::shared_ptr<Wasm> getThreadLocalWasmPtr(absl::string_view vm_id);\n// Get an existing ThreadLocal VM matching 'vm_id' or create one using 'base_wavm' by cloning or by\n// using it it as a template.\nstd::shared_ptr<Wasm> getOrCreateThreadLocalWasm(Wasm& base_wasm, absl::string_view configuration,\n                                                 Event::Dispatcher& dispatcher);\n\nuint32_t resolveQueueForTest(absl::string_view vm_id, absl::string_view queue_name);\n\ninline Context::Context() : root_context_(this) {}\n\ninline Context::Context(Wasm* wasm) : wasm_(wasm), root_context_(this), plugin_(wasm->plugin()) {\n  wasm_->contexts_[id_] = this;\n}\n\ninline Context::Context(Wasm* wasm, absl::string_view root_id, PluginSharedPtr plugin)\n    : wasm_(wasm), id_(wasm->allocContextId()), root_context_(this), plugin_(plugin) {\n  RELEASE_ASSERT(root_id == plugin->root_id_, \"\");\n  wasm_->contexts_[id_] = this;\n}\n\ninline Context::Context(Wasm* wasm, uint32_t root_context_id, PluginSharedPtr plugin)\n    : wasm_(wasm), id_(wasm->allocContextId()), root_context_id_(root_context_id), plugin_(plugin) {\n  wasm_->contexts_[id_] = this;\n  root_context_ = wasm_->contexts_[root_context_id_];\n}\n\ninline void* Wasm::allocMemory(uint64_t size, uint64_t* address) {\n  Word a = malloc_(vmContext(), size);\n  if (!a.u64_) {\n    throw WasmException(\"malloc_ returns nullptr (OOM)\");\n  }\n  auto memory = wasm_vm_->getMemory(a.u64_, size);\n  if (!memory) {\n    throw WasmException(\"malloc_ returned illegal address\");\n  }\n  *address = a.u64_;\n  return const_cast<void*>(reinterpret_cast<const void*>(memory.value().data()));\n}\n\ninline uint64_t Wasm::copyString(absl::string_view s) {\n  if (s.empty()) {\n    return 0; // nullptr\n  }\n  uint64_t pointer;\n  uint8_t* m = static_cast<uint8_t*>(allocMemory((s.size() + 1), &pointer));\n  memcpy(m, s.data(), s.size());\n  m[s.size()] = 0;\n  return pointer;\n}\n\ninline uint64_t Wasm::copyBuffer(const Buffer::Instance& buffer) {\n  uint64_t pointer;\n  auto length = buffer.length();\n  if (length <= 0) {\n    return 0;\n  }\n  Buffer::RawSlice oneRawSlice;\n  // NB: we need to pass in >= 1 in order to get the real \"n\" (see Buffer::Instance for details).\n  int nSlices = buffer.getRawSlices(&oneRawSlice, 1);\n  if (nSlices <= 0) {\n    return 0;\n  }\n  uint8_t* m = static_cast<uint8_t*>(allocMemory(length, &pointer));\n  if (nSlices == 1) {\n    memcpy(m, oneRawSlice.mem_, oneRawSlice.len_);\n    return pointer;\n  }\n  STACK_ARRAY(manyRawSlices, Buffer::RawSlice, nSlices);\n  buffer.getRawSlices(manyRawSlices.begin(), nSlices);\n  auto p = m;\n  for (int i = 0; i < nSlices; i++) {\n    memcpy(p, manyRawSlices[i].mem_, manyRawSlices[i].len_);\n    p += manyRawSlices[i].len_;\n  }\n  return pointer;\n}\n\ninline bool Wasm::copyToPointerSize(absl::string_view s, uint64_t ptr_ptr, uint64_t size_ptr) {\n  uint64_t pointer = 0;\n  uint64_t size = s.size();\n  void* p = nullptr;\n  if (size > 0) {\n    p = allocMemory(size, &pointer);\n    if (!p) {\n      return false;\n    }\n    memcpy(p, s.data(), size);\n  }\n  if (!wasm_vm_->setWord(ptr_ptr, Word(pointer))) {\n    return false;\n  }\n  if (!wasm_vm_->setWord(size_ptr, Word(size))) {\n    return false;\n  }\n  return true;\n}\n\ninline bool Wasm::copyToPointerSize(const Buffer::Instance& buffer, uint64_t start, uint64_t length,\n                                    uint64_t ptr_ptr, uint64_t size_ptr) {\n  uint64_t size = buffer.length();\n  if (size < start + length) {\n    return false;\n  }\n  auto nslices = buffer.getRawSlices(nullptr, 0);\n  auto slices = std::make_unique<Buffer::RawSlice[]>(nslices + 10 /* pad for evbuffer overrun */);\n  auto actual_slices = buffer.getRawSlices(&slices[0], nslices);\n  uint64_t pointer = 0;\n  char* p = static_cast<char*>(allocMemory(length, &pointer));\n  auto s = start;\n  auto l = length;\n  if (!p) {\n    return false;\n  }\n  for (uint64_t i = 0; i < actual_slices; i++) {\n    if (slices[i].len_ <= s) {\n      s -= slices[i].len_;\n      continue;\n    }\n    auto ll = l;\n    if (ll > s + slices[i].len_)\n      ll = s + slices[i].len_;\n    memcpy(p, static_cast<char*>(slices[i].mem_) + s, ll);\n    l -= ll;\n    if (l <= 0) {\n      break;\n    }\n    s = 0;\n    p += ll;\n  }\n  if (!wasm_vm_->setWord(ptr_ptr, Word(pointer))) {\n    return false;\n  }\n  if (!wasm_vm_->setWord(size_ptr, Word(length))) {\n    return false;\n  }\n  return true;\n}\n\ntemplate <typename T> inline bool Wasm::setDatatype(uint64_t ptr, const T& t) {\n  return wasm_vm_->setMemory(ptr, sizeof(T), &t);\n}\n\n} // namespace Wasm\n} // namespace Common\n} // namespace Extensions\n} // namespace Envoy\n", "#include <stdio.h>\n\n#include \"common/event/dispatcher_impl.h\"\n#include \"common/stats/isolated_store_impl.h\"\n\n#include \"extensions/common/wasm/wasm.h\"\n\n#include \"test/mocks/server/mocks.h\"\n#include \"test/mocks/upstream/mocks.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"absl/types/optional.h\"\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing testing::Eq;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Wasm {\n\nclass TestContext : public Extensions::Common::Wasm::Context {\npublic:\n  TestContext(Extensions::Common::Wasm::Wasm* wasm) : Extensions::Common::Wasm::Context(wasm) {}\n  ~TestContext() override {}\n  void scriptLog(spdlog::level::level_enum level, absl::string_view message) override {\n    std::cerr << std::string(message) << \"\\n\";\n    scriptLog_(level, message);\n  }\n  MOCK_METHOD2(scriptLog_, void(spdlog::level::level_enum level, absl::string_view message));\n  MOCK_METHOD1(setTickPeriodMilliseconds, void(uint32_t tick_period_milliseconds));\n};\n\nclass WasmTest : public testing::TestWithParam<std::string> {};\n\nINSTANTIATE_TEST_SUITE_P(Runtimes, WasmTest,\n                         testing::Values(\n#if defined(ENVOY_WASM_V8) && defined(ENVOY_WASM_WAVM)\n                             \"v8\", \"wavm\"\n#elif defined(ENVOY_WASM_V8)\n                             \"v8\"\n#elif defined(ENVOY_WASM_WAVM)\n                             \"wavm\"\n#endif\n                             ));\n\nclass WasmTestMatrix : public testing::TestWithParam<std::tuple<std::string, std::string>> {};\n\nINSTANTIATE_TEST_SUITE_P(RuntimesAndLanguages, WasmTestMatrix,\n                         testing::Combine(testing::Values(\n#if defined(ENVOY_WASM_V8) && defined(ENVOY_WASM_WAVM)\n                                              \"v8\", \"wavm\"\n#elif defined(ENVOY_WASM_V8)\n                                              \"v8\"\n#elif defined(ENVOY_WASM_WAVM)\n                                              \"wavm\"\n#endif\n                                              ),\n                                          testing::Values(\"cpp\", \"rust\")));\n\nTEST_P(WasmTestMatrix, Logging) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", std::get<0>(GetParam())), vm_id, vm_configuration, plugin,\n      scope, cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      absl::StrCat(\"{{ test_rundir }}/test/extensions/wasm/test_data/logging_\",\n                   std::get<1>(GetParam()), \".wasm\")));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::warn, Eq(\"warn configure-test\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::trace, Eq(\"test trace logging\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::debug, Eq(\"test debug logging\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"test error logging\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::info, Eq(\"test tick logging\")));\n\n  EXPECT_TRUE(wasm->initialize(code, false));\n  wasm->setContext(context.get());\n  auto root_context = context.get();\n  wasm->startForTesting(std::move(context));\n  wasm->configure(root_context, \"configure-test\");\n  wasm->tickHandler(root_context->id());\n}\n\nTEST_P(WasmTest, BadSignature) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/bad_signature_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  EXPECT_THROW_WITH_MESSAGE(wasm->initialize(code, false),\n                            Extensions::Common::Wasm::WasmVmException,\n                            \"Bad function signature for: proxy_onConfigure\");\n}\n\nTEST_P(WasmTest, Segv) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/segv_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"before badptr\")));\n  EXPECT_TRUE(wasm->initialize(code, false));\n\n  if (GetParam() == \"v8\") {\n    EXPECT_THROW_WITH_MESSAGE(wasm->startForTesting(std::move(context)),\n                              Extensions::Common::Wasm::WasmException,\n                              \"Function: proxy_onStart failed: Uncaught RuntimeError: unreachable\");\n  } else if (GetParam() == \"wavm\") {\n    EXPECT_THROW_WITH_REGEX(wasm->startForTesting(std::move(context)),\n                            Extensions::Common::Wasm::WasmException,\n                            \"Function: proxy_onStart failed: wavm.reachedUnreachable.*\");\n  } else {\n    ASSERT_FALSE(true); // Neither of the above was matched.\n  }\n}\n\nTEST_P(WasmTest, DivByZero) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/segv_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"before div by zero\")));\n  EXPECT_TRUE(wasm->initialize(code, false));\n  wasm->setContext(context.get());\n\n  if (GetParam() == \"v8\") {\n    EXPECT_THROW_WITH_MESSAGE(\n        context->onLog(), Extensions::Common::Wasm::WasmException,\n        \"Function: proxy_onLog failed: Uncaught RuntimeError: divide by zero\");\n  } else if (GetParam() == \"wavm\") {\n    EXPECT_THROW_WITH_REGEX(context->onLog(), Extensions::Common::Wasm::WasmException,\n                            \"Function: proxy_onLog failed: wavm.integerDivideByZeroOrOverflow.*\");\n  } else {\n    ASSERT_FALSE(true); // Neither of the above was matched.\n  }\n}\n\nTEST_P(WasmTest, EmscriptenVersion) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/segv_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n  EXPECT_TRUE(wasm->initialize(code, false));\n  uint32_t major = 9, minor = 9, abi_major = 9, abi_minor = 9;\n  EXPECT_TRUE(wasm->getEmscriptenVersion(&major, &minor, &abi_major, &abi_minor));\n  EXPECT_EQ(major, 0);\n  EXPECT_LE(minor, 3);\n  // Up to (at least) emsdk 1.39.0.\n  EXPECT_EQ(abi_major, 0);\n  EXPECT_LE(abi_minor, 19);\n}\n\nTEST_P(WasmTest, IntrinsicGlobals) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/emscripten_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::info, Eq(\"NaN nan\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::warn, Eq(\"inf inf\"))).Times(3);\n  EXPECT_TRUE(wasm->initialize(code, false));\n  wasm->startForTesting(std::move(context));\n}\n\n// The asm2wasm.wasm file uses operations which would require the asm2wasm Emscripten module *if*\n// em++ is invoked with the trap mode \"clamp\". See\n// https://emscripten.org/docs/compiling/WebAssembly.html This test demonstrates that the asm2wasm\n// module is not required with the trap mode is set to \"allow\". Note: future WASM standards will\n// change this behavior by providing non-trapping instructions, but in the mean time we support the\n// default Emscripten behavior.\nTEST_P(WasmTest, Asm2Wasm) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/asm2wasm_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::info, Eq(\"out 0 0 0\")));\n  EXPECT_TRUE(wasm->initialize(code, false));\n  wasm->startForTesting(std::move(context));\n}\n\nTEST_P(WasmTest, Stats) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/stats_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::trace, Eq(\"get counter = 1\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::debug, Eq(\"get counter = 2\")));\n  // recordMetric on a Counter is the same as increment.\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::info, Eq(\"get counter = 5\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::warn, Eq(\"get gauge = 2\")));\n  // Get is not supported on histograms.\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"get histogram = Unsupported\")));\n\n  EXPECT_TRUE(wasm->initialize(code, false));\n  wasm->startForTesting(std::move(context));\n}\n\nTEST_P(WasmTest, StatsHigherLevel) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/stats_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::trace, Eq(\"get counter = 1\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::debug, Eq(\"get counter = 2\")));\n  // recordMetric on a Counter is the same as increment.\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::info, Eq(\"get counter = 5\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::warn, Eq(\"get gauge = 2\")));\n  // Get is not supported on histograms.\n  EXPECT_CALL(*context,\n              scriptLog_(spdlog::level::err,\n                         Eq(std::string(\"resolved histogram name = \"\n                                        \"histogram_int_tag.7.histogram_string_tag.test_tag.\"\n                                        \"histogram_bool_tag.true.test_histogram\"))));\n\n  EXPECT_TRUE(wasm->initialize(code, false));\n  wasm->setContext(context.get());\n  wasm->tickHandler(context->id());\n}\n\nTEST_P(WasmTest, StatsHighLevel) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/stats_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::trace, Eq(\"get counter = 1\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::debug, Eq(\"get counter = 2\")));\n  // recordMetric on a Counter is the same as increment.\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::info, Eq(\"get counter = 5\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::warn, Eq(\"get gauge = 2\")));\n  // Get is not supported on histograms.\n  // EXPECT_CALL(*context, scriptLog(spdlog::level::err, Eq(std::string(\"resolved histogram name\n  // = int_tag.7_string_tag.test_tag.bool_tag.true.test_histogram\"))));\n  EXPECT_CALL(*context,\n              scriptLog_(spdlog::level::err,\n                         Eq(\"h_id = int_tag.7.string_tag.test_tag.bool_tag.true.test_histogram\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"stack_c = 1\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"stack_g = 2\")));\n  // Get is not supported on histograms.\n  // EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"stack_h = 3\")));\n  EXPECT_TRUE(wasm->initialize(code, false));\n  wasm->setContext(context.get());\n  context->onLog();\n}\n\n} // namespace Wasm\n} // namespace Extensions\n} // namespace Envoy\n"], "fixing_code": ["#include \"extensions/common/wasm/wasm.h\"\n\n#include <stdio.h>\n\n#include <limits>\n#include <memory>\n#include <string>\n\n#include \"envoy/common/exception.h\"\n#include \"envoy/config/wasm/v2/wasm.pb.validate.h\"\n#include \"envoy/grpc/status.h\"\n#include \"envoy/http/codes.h\"\n#include \"envoy/local_info/local_info.h\"\n#include \"envoy/server/wasm.h\"\n#include \"envoy/thread_local/thread_local.h\"\n\n#include \"common/buffer/buffer_impl.h\"\n#include \"common/common/assert.h\"\n#include \"common/common/base64.h\"\n#include \"common/common/empty_string.h\"\n#include \"common/common/enum_to_int.h\"\n#include \"common/common/logger.h\"\n#include \"common/config/datasource.h\"\n#include \"common/http/header_map_impl.h\"\n#include \"common/http/message_impl.h\"\n#include \"common/http/utility.h\"\n#include \"common/tracing/http_tracer_impl.h\"\n\n#include \"extensions/common/wasm/wasm_state.h\"\n#include \"extensions/common/wasm/well_known_names.h\"\n#include \"extensions/filters/common/expr/context.h\"\n\n#include \"absl/base/casts.h\"\n#include \"absl/container/flat_hash_map.h\"\n#include \"absl/container/node_hash_map.h\"\n#include \"absl/synchronization/mutex.h\"\n#include \"eval/eval/field_access.h\"\n#include \"eval/eval/field_backed_list_impl.h\"\n#include \"eval/eval/field_backed_map_impl.h\"\n#include \"eval/public/cel_value.h\"\n#include \"openssl/bytestring.h\"\n#include \"openssl/hmac.h\"\n#include \"openssl/sha.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Common {\nnamespace Wasm {\n\n// Any currently executing Wasm call context.\n#define WASM_CONTEXT(_c)                                                                           \\\n  (ContextOrEffectiveContext(static_cast<Context*>((void)_c, current_context_)))\n// The id of the context which should be used for calls out of the VM in place of current_context_\n// above.\n\nnamespace {\n\n// TODO: move to utils during upstreaming.\nstd::string base64Sha256(absl::string_view data) {\n  std::vector<uint8_t> digest(SHA256_DIGEST_LENGTH);\n  EVP_MD_CTX* ctx(EVP_MD_CTX_new());\n  auto rc = EVP_DigestInit(ctx, EVP_sha256());\n  RELEASE_ASSERT(rc == 1, \"Failed to init digest context\");\n  rc = EVP_DigestUpdate(ctx, data.data(), data.size());\n  RELEASE_ASSERT(rc == 1, \"Failed to update digest\");\n  rc = EVP_DigestFinal(ctx, digest.data(), nullptr);\n  RELEASE_ASSERT(rc == 1, \"Failed to finalize digest\");\n  EVP_MD_CTX_free(ctx);\n  return Base64::encode(reinterpret_cast<const char*>(&digest[0]), digest.size());\n}\n\ninline Word wasmResultToWord(WasmResult r) { return Word(static_cast<uint64_t>(r)); }\n\ninline uint32_t convertWordToUint32(Word w) { return static_cast<uint32_t>(w.u64_); }\n\n// Convert a function of the form Word(Word...) to one of the form uint32_t(uint32_t...).\ntemplate <typename F, F* fn> struct ConvertFunctionWordToUint32 {\n  static void convertFunctionWordToUint32() {}\n};\ntemplate <typename R, typename... Args, auto (*F)(Args...)->R>\nstruct ConvertFunctionWordToUint32<R(Args...), F> {\n  static auto convertFunctionWordToUint32(typename ConvertWordTypeToUint32<Args>::type... args) {\n    return convertWordToUint32(F(std::forward<Args>(args)...));\n  }\n};\ntemplate <typename... Args, auto (*F)(Args...)->void>\nstruct ConvertFunctionWordToUint32<void(Args...), F> {\n  static void convertFunctionWordToUint32(typename ConvertWordTypeToUint32<Args>::type... args) {\n    F(std::forward<Args>(args)...);\n  }\n};\n\nclass SharedData {\npublic:\n  WasmResult get(absl::string_view vm_id, const absl::string_view key,\n                 std::pair<std::string, uint32_t>* result) {\n    absl::ReaderMutexLock l(&mutex);\n    auto map = data.find(vm_id);\n    if (map == data.end()) {\n      return WasmResult::NotFound;\n    }\n    auto it = map->second.find(key);\n    if (it != map->second.end()) {\n      *result = it->second;\n      return WasmResult::Ok;\n    }\n    return WasmResult::NotFound;\n  }\n\n  WasmResult set(absl::string_view vm_id, absl::string_view key, absl::string_view value,\n                 uint32_t cas) {\n    absl::WriterMutexLock l(&mutex);\n    absl::flat_hash_map<std::string, std::pair<std::string, uint32_t>>* map;\n    auto map_it = data.find(vm_id);\n    if (map_it == data.end()) {\n      map = &data[vm_id];\n    } else {\n      map = &map_it->second;\n    }\n    auto it = map->find(key);\n    if (it != map->end()) {\n      if (cas && cas != it->second.second) {\n        return WasmResult::CasMismatch;\n      }\n      it->second = std::make_pair(std::string(value), nextCas());\n    } else {\n      map->emplace(key, std::make_pair(std::string(value), nextCas()));\n    }\n    return WasmResult::Ok;\n  }\n\n  uint32_t registerQueue(absl::string_view vm_id, absl::string_view queue_name, uint32_t context_id,\n                         Event::Dispatcher& dispatcher) {\n    absl::WriterMutexLock l(&mutex);\n    auto key = std::make_pair(std::string(vm_id), std::string(queue_name));\n    auto it = queue_tokens.insert(std::make_pair(key, static_cast<uint32_t>(0)));\n    if (it.second) {\n      it.first->second = nextQueueToken();\n      queue_token_set.insert(it.first->second);\n    }\n    uint32_t token = it.first->second;\n    auto& q = queues[token];\n    q.vm_id = std::string(vm_id);\n    q.context_id = context_id;\n    q.dispatcher = &dispatcher;\n    // Preserve any existing data.\n    return token;\n  }\n\n  uint32_t resolveQueue(absl::string_view vm_id, absl::string_view queue_name) {\n    absl::WriterMutexLock l(&mutex);\n    auto key = std::make_pair(std::string(vm_id), std::string(queue_name));\n    auto it = queue_tokens.find(key);\n    if (it != queue_tokens.end()) {\n      return it->second;\n    }\n    return 0; // N.B. zero indicates that the queue was not found.\n  }\n\n  WasmResult dequeue(uint32_t token, std::string* data) {\n    absl::ReaderMutexLock l(&mutex);\n    auto it = queues.find(token);\n    if (it == queues.end()) {\n      return WasmResult::NotFound;\n    }\n    if (it->second.queue.empty()) {\n      return WasmResult::Empty;\n    }\n    *data = it->second.queue.front();\n    it->second.queue.pop_front();\n    return WasmResult::Ok;\n  }\n\n  WasmResult enqueue(uint32_t token, absl::string_view value) {\n    absl::WriterMutexLock l(&mutex);\n    auto it = queues.find(token);\n    if (it == queues.end()) {\n      return WasmResult::NotFound;\n    }\n    it->second.queue.push_back(std::string(value));\n    auto vm_id = it->second.vm_id;\n    auto context_id = it->second.context_id;\n    it->second.dispatcher->post([vm_id, context_id, token] {\n      auto wasm = getThreadLocalWasmPtr(vm_id);\n      if (wasm) {\n        wasm->queueReady(context_id, token);\n      }\n    });\n    return WasmResult::Ok;\n  }\n\n  uint32_t nextCas() {\n    auto result = cas;\n    cas++;\n    if (!cas) { // 0 is not a valid CAS value.\n      cas++;\n    }\n    return result;\n  }\n\nprivate:\n  uint32_t nextQueueToken() {\n    while (true) {\n      uint32_t token = next_queue_token++;\n      if (token == 0) {\n        continue; // 0 is an illegal token.\n      }\n      if (queue_token_set.find(token) == queue_token_set.end()) {\n        return token;\n      }\n    }\n  }\n\n  struct Queue {\n    std::string vm_id;\n    uint32_t context_id;\n    Event::Dispatcher* dispatcher;\n    std::deque<std::string> queue;\n  };\n\n  absl::Mutex mutex;\n  uint32_t cas = 1;\n  uint32_t next_queue_token = 1;\n  absl::node_hash_map<std::string,\n                      absl::flat_hash_map<std::string, std::pair<std::string, uint32_t>>>\n      data;\n  absl::node_hash_map<uint32_t, Queue> queues;\n  struct pair_hash {\n    template <class T1, class T2> std::size_t operator()(const std::pair<T1, T2>& pair) const {\n      return std::hash<T1>()(pair.first) ^ std::hash<T2>()(pair.second);\n    }\n  };\n  absl::flat_hash_map<std::pair<std::string, std::string>, uint32_t, pair_hash> queue_tokens;\n  absl::flat_hash_set<uint32_t> queue_token_set;\n};\n\nSharedData global_shared_data;\n\n// Map from Wasm ID to the local Wasm instance.\nthread_local absl::flat_hash_map<std::string, std::weak_ptr<Wasm>> local_wasms;\n\nconst std::string INLINE_STRING = \"<inline>\";\n\ntemplate <typename Pairs> size_t pairsSize(const Pairs& result) {\n  size_t size = 4; // number of headers\n  for (auto& p : result) {\n    size += 8;                   // size of key, size of value\n    size += p.first.size() + 1;  // null terminated key\n    size += p.second.size() + 1; // null terminated value\n  }\n  return size;\n}\n\ntemplate <typename Pairs> void marshalPairs(const Pairs& result, char* buffer) {\n  char* b = buffer;\n  *reinterpret_cast<uint32_t*>(b) = result.size();\n  b += sizeof(uint32_t);\n  for (auto& p : result) {\n    *reinterpret_cast<uint32_t*>(b) = p.first.size();\n    b += sizeof(uint32_t);\n    *reinterpret_cast<uint32_t*>(b) = p.second.size();\n    b += sizeof(uint32_t);\n  }\n  for (auto& p : result) {\n    memcpy(b, p.first.data(), p.first.size());\n    b += p.first.size();\n    *b++ = 0;\n    memcpy(b, p.second.data(), p.second.size());\n    b += p.second.size();\n    *b++ = 0;\n  }\n}\n\nPairs toPairs(absl::string_view buffer) {\n  Pairs result;\n  const char* b = buffer.data();\n  if (buffer.size() < sizeof(uint32_t)) {\n    return {};\n  }\n  auto size = *reinterpret_cast<const uint32_t*>(b);\n  b += sizeof(uint32_t);\n  if (sizeof(uint32_t) + size * 2 * sizeof(uint32_t) > buffer.size()) {\n    return {};\n  }\n  result.resize(size);\n  for (uint32_t i = 0; i < size; i++) {\n    result[i].first = absl::string_view(nullptr, *reinterpret_cast<const uint32_t*>(b));\n    b += sizeof(uint32_t);\n    result[i].second = absl::string_view(nullptr, *reinterpret_cast<const uint32_t*>(b));\n    b += sizeof(uint32_t);\n  }\n  for (auto& p : result) {\n    p.first = absl::string_view(b, p.first.size());\n    b += p.first.size() + 1;\n    p.second = absl::string_view(b, p.second.size());\n    b += p.second.size() + 1;\n  }\n  return result;\n}\n\ntemplate <typename Pairs>\nbool getPairs(Context* context, const Pairs& result, uint64_t ptr_ptr, uint64_t size_ptr) {\n  if (result.empty()) {\n    return context->wasm()->copyToPointerSize(\"\", ptr_ptr, size_ptr);\n  }\n  uint64_t size = pairsSize(result);\n  uint64_t ptr;\n  char* buffer = static_cast<char*>(context->wasm()->allocMemory(size, &ptr));\n  marshalPairs(result, buffer);\n  if (!context->wasmVm()->setWord(ptr_ptr, Word(ptr))) {\n    return false;\n  }\n  if (!context->wasmVm()->setWord(size_ptr, Word(size))) {\n    return false;\n  }\n  return true;\n}\n\nvoid exportPairs(Context* context, const Pairs& pairs, uint64_t* ptr_ptr, uint64_t* size_ptr) {\n  if (pairs.empty()) {\n    *ptr_ptr = 0;\n    *size_ptr = 0;\n    return;\n  }\n  uint64_t size = pairsSize(pairs);\n  char* buffer = static_cast<char*>(context->wasm()->allocMemory(size, ptr_ptr));\n  marshalPairs(pairs, buffer);\n  *size_ptr = size;\n}\n\nHttp::HeaderMapPtr buildHeaderMapFromPairs(const Pairs& pairs) {\n  auto map = std::make_unique<Http::HeaderMapImpl>();\n  for (auto& p : pairs) {\n    // Note: because of the lack of a string_view interface for addCopy and\n    // the lack of an interface to add an entry with an empty value and return\n    // the entry, there is no efficient way to prevent either a double copy\n    // of the valueor a double lookup of the entry.\n    map->addCopy(Http::LowerCaseString(std::string(p.first)), std::string(p.second));\n  }\n  return map;\n}\n\nconst uint8_t* decodeVarint(const uint8_t* pos, const uint8_t* end, uint32_t* out) {\n  uint32_t ret = 0;\n  int shift = 0;\n  while (pos < end && (*pos & 0x80)) {\n    ret |= (*pos & 0x7f) << shift;\n    shift += 7;\n    pos++;\n  }\n  if (pos < end) {\n    ret |= *pos << shift;\n    pos++;\n  }\n  *out = ret;\n  return pos;\n}\n\nContext* ContextOrEffectiveContext(Context* context) {\n  if (effective_context_id_ == 0) {\n    return context;\n  }\n  auto effective_context = context->wasm()->getContext(effective_context_id_);\n  if (effective_context) {\n    return effective_context;\n  }\n  // The effective_context_id_ no longer exists, revert to the true context.\n  return context;\n}\n\n} // namespace\n\n// Test support.\n\nuint32_t resolveQueueForTest(absl::string_view vm_id, absl::string_view queue_name) {\n  return global_shared_data.resolveQueue(vm_id, queue_name);\n}\n\n//\n// HTTP Handlers\n//\n\nWord setPropertyHandler(void* raw_context, Word key_ptr, Word key_size, Word value_ptr,\n                        Word value_size) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto key = context->wasmVm()->getMemory(key_ptr.u64_, key_size.u64_);\n  auto value = context->wasmVm()->getMemory(value_ptr.u64_, value_size.u64_);\n  if (!key || !value) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(context->setProperty(key.value(), value.value()));\n}\n\n// Generic selector\nWord getPropertyHandler(void* raw_context, Word path_ptr, Word path_size, Word value_ptr_ptr,\n                        Word value_size_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto path = context->wasmVm()->getMemory(path_ptr.u64_, path_size.u64_);\n  if (!path.has_value()) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  std::string value;\n  auto result = context->getProperty(path.value(), &value);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  if (!context->wasm()->copyToPointerSize(value, value_ptr_ptr.u64_, value_size_ptr.u64_)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\n// Continue/Reply/Route\nWord continueRequestHandler(void* raw_context) {\n  auto context = WASM_CONTEXT(raw_context);\n  context->continueRequest();\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord continueResponseHandler(void* raw_context) {\n  auto context = WASM_CONTEXT(raw_context);\n  context->continueResponse();\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord sendLocalResponseHandler(void* raw_context, Word response_code, Word response_code_details_ptr,\n                              Word response_code_details_size, Word body_ptr, Word body_size,\n                              Word additional_response_header_pairs_ptr,\n                              Word additional_response_header_pairs_size, Word grpc_code) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto details =\n      context->wasmVm()->getMemory(response_code_details_ptr.u64_, response_code_details_size.u64_);\n  auto body = context->wasmVm()->getMemory(body_ptr.u64_, body_size.u64_);\n  auto additional_response_header_pairs = context->wasmVm()->getMemory(\n      additional_response_header_pairs_ptr.u64_, additional_response_header_pairs_size.u64_);\n  if (!details || !body || !additional_response_header_pairs) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  auto additional_headers = toPairs(additional_response_header_pairs.value());\n  auto modify_headers = [additional_headers](Http::HeaderMap& headers) {\n    for (auto& p : additional_headers) {\n      const Http::LowerCaseString lower_key(std::move(std::string(p.first)));\n      headers.addCopy(lower_key, std::string(p.second));\n    }\n  };\n  auto grpc_status = static_cast<Grpc::Status::GrpcStatus>(grpc_code.u64_);\n  auto grpc_status_opt = (grpc_status != Grpc::Status::GrpcStatus::InvalidCode)\n                             ? absl::optional<Grpc::Status::GrpcStatus>(grpc_status)\n                             : absl::optional<Grpc::Status::GrpcStatus>();\n  context->sendLocalResponse(static_cast<Envoy::Http::Code>(response_code.u64_), body.value(),\n                             modify_headers, grpc_status_opt, details.value());\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord setEffectiveContextHandler(void* raw_context, Word context_id) {\n  auto context = WASM_CONTEXT(raw_context);\n  uint32_t cid = static_cast<uint32_t>(context_id.u64_);\n  auto c = context->wasm()->getContext(cid);\n  if (!c) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  effective_context_id_ = cid;\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord clearRouteCacheHandler(void* raw_context) {\n  auto context = WASM_CONTEXT(raw_context);\n  context->clearRouteCache();\n  return wasmResultToWord(WasmResult::Ok);\n}\n\n// SharedData\nWord getSharedDataHandler(void* raw_context, Word key_ptr, Word key_size, Word value_ptr_ptr,\n                          Word value_size_ptr, Word cas_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto key = context->wasmVm()->getMemory(key_ptr.u64_, key_size.u64_);\n  if (!key) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  std::pair<std::string, uint32_t> data;\n  WasmResult result = context->getSharedData(key.value(), &data);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  if (!context->wasm()->copyToPointerSize(data.first, value_ptr_ptr.u64_, value_size_ptr.u64_)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  if (!context->wasmVm()->setMemory(cas_ptr.u64_, sizeof(uint32_t), &data.second)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord setSharedDataHandler(void* raw_context, Word key_ptr, Word key_size, Word value_ptr,\n                          Word value_size, Word cas) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto key = context->wasmVm()->getMemory(key_ptr.u64_, key_size.u64_);\n  auto value = context->wasmVm()->getMemory(value_ptr.u64_, value_size.u64_);\n  if (!key || !value) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(context->setSharedData(key.value(), value.value(), cas.u64_));\n}\n\nWord registerSharedQueueHandler(void* raw_context, Word queue_name_ptr, Word queue_name_size,\n                                Word token_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto queue_name = context->wasmVm()->getMemory(queue_name_ptr.u64_, queue_name_size.u64_);\n  if (!queue_name) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  uint32_t token = context->registerSharedQueue(queue_name.value());\n  if (!context->wasm()->setDatatype(token_ptr.u64_, token)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord dequeueSharedQueueHandler(void* raw_context, Word token, Word data_ptr_ptr,\n                               Word data_size_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  std::string data;\n  WasmResult result = context->dequeueSharedQueue(token.u32(), &data);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  if (!context->wasm()->copyToPointerSize(data, data_ptr_ptr.u64_, data_size_ptr.u64_)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord resolveSharedQueueHandler(void* raw_context, Word vm_id_ptr, Word vm_id_size,\n                               Word queue_name_ptr, Word queue_name_size, Word token_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto vm_id = context->wasmVm()->getMemory(vm_id_ptr.u64_, vm_id_size.u64_);\n  auto queue_name = context->wasmVm()->getMemory(queue_name_ptr.u64_, queue_name_size.u64_);\n  if (!vm_id || !queue_name) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  uint32_t token = 0;\n  auto result = context->resolveSharedQueue(vm_id.value(), queue_name.value(), &token);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  if (!context->wasm()->setDatatype(token_ptr.u64_, token)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord enqueueSharedQueueHandler(void* raw_context, Word token, Word data_ptr, Word data_size) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto data = context->wasmVm()->getMemory(data_ptr.u64_, data_size.u64_);\n  if (!data) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(context->enqueueSharedQueue(token.u32(), data.value()));\n}\n\n// Network\nWord getDownstreamDataBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                         Word size_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  absl::string_view data;\n  auto result = context->getDownstreamDataBufferBytes(start.u64_, length.u64_, &data);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  context->wasm()->copyToPointerSize(data, ptr_ptr.u64_, size_ptr.u64_);\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord getUpstreamDataBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                       Word size_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  absl::string_view data;\n  auto result = context->getUpstreamDataBufferBytes(start.u64_, length.u64_, &data);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  context->wasm()->copyToPointerSize(data, ptr_ptr.u64_, size_ptr.u64_);\n  return wasmResultToWord(WasmResult::Ok);\n}\n\n// Header/Trailer/Metadata Maps\nWord addHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size,\n                              Word value_ptr, Word value_size) {\n  if (type.u64_ > static_cast<uint64_t>(HeaderMapType::MAX)) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  auto key = context->wasmVm()->getMemory(key_ptr.u64_, key_size.u64_);\n  auto value = context->wasmVm()->getMemory(value_ptr.u64_, value_size.u64_);\n  if (!key || !value) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  context->addHeaderMapValue(static_cast<HeaderMapType>(type.u64_), key.value(), value.value());\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord getHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size,\n                              Word value_ptr_ptr, Word value_size_ptr) {\n  if (type.u64_ > static_cast<uint64_t>(HeaderMapType::MAX)) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  auto key = context->wasmVm()->getMemory(key_ptr.u64_, key_size.u64_);\n  if (!key) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  auto result = context->getHeaderMapValue(static_cast<HeaderMapType>(type.u64_), key.value());\n  context->wasm()->copyToPointerSize(result, value_ptr_ptr.u64_, value_size_ptr.u64_);\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord replaceHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size,\n                                  Word value_ptr, Word value_size) {\n  if (type.u64_ > static_cast<uint64_t>(HeaderMapType::MAX)) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  auto key = context->wasmVm()->getMemory(key_ptr.u64_, key_size.u64_);\n  auto value = context->wasmVm()->getMemory(value_ptr.u64_, value_size.u64_);\n  if (!key || !value) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  context->replaceHeaderMapValue(static_cast<HeaderMapType>(type.u64_), key.value(), value.value());\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord removeHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size) {\n  if (type.u64_ > static_cast<uint64_t>(HeaderMapType::MAX)) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  auto key = context->wasmVm()->getMemory(key_ptr.u64_, key_size.u64_);\n  if (!key) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  context->removeHeaderMapValue(static_cast<HeaderMapType>(type.u64_), key.value());\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord getHeaderMapPairsHandler(void* raw_context, Word type, Word ptr_ptr, Word size_ptr) {\n  if (type.u64_ > static_cast<uint64_t>(HeaderMapType::MAX)) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  auto result = context->getHeaderMapPairs(static_cast<HeaderMapType>(type.u64_));\n  if (!getPairs(context, result, ptr_ptr.u64_, size_ptr.u64_)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord setHeaderMapPairsHandler(void* raw_context, Word type, Word ptr, Word size) {\n  if (type.u64_ > static_cast<uint64_t>(HeaderMapType::MAX)) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  auto data = context->wasmVm()->getMemory(ptr.u64_, size.u64_);\n  if (!data) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  context->setHeaderMapPairs(static_cast<HeaderMapType>(type.u64_), toPairs(data.value()));\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord getHeaderMapSizeHandler(void* raw_context, Word type, Word result_ptr) {\n  if (type.u64_ > static_cast<uint64_t>(HeaderMapType::MAX)) {\n    return wasmResultToWord(WasmResult::BadArgument);\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  size_t result = context->getHeaderMapSize(static_cast<HeaderMapType>(type.u64_));\n  if (!context->wasmVm()->setWord(result_ptr.u64_, Word(result))) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\n// Body Buffer\nWord getRequestBodyBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                      Word size_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto result = context->getRequestBodyBufferBytes(start.u64_, length.u64_);\n  context->wasm()->copyToPointerSize(result, ptr_ptr.u64_, size_ptr.u64_);\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord getResponseBodyBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                       Word size_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto result = context->getResponseBodyBufferBytes(start.u64_, length.u64_);\n  context->wasm()->copyToPointerSize(result, ptr_ptr.u64_, size_ptr.u64_);\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord httpCallHandler(void* raw_context, Word uri_ptr, Word uri_size, Word header_pairs_ptr,\n                     Word header_pairs_size, Word body_ptr, Word body_size, Word trailer_pairs_ptr,\n                     Word trailer_pairs_size, Word timeout_milliseconds) {\n  auto context = WASM_CONTEXT(raw_context)->root_context();\n  auto uri = context->wasmVm()->getMemory(uri_ptr.u64_, uri_size.u64_);\n  auto body = context->wasmVm()->getMemory(body_ptr.u64_, body_size.u64_);\n  auto header_pairs = context->wasmVm()->getMemory(header_pairs_ptr.u64_, header_pairs_size.u64_);\n  auto trailer_pairs =\n      context->wasmVm()->getMemory(trailer_pairs_ptr.u64_, trailer_pairs_size.u64_);\n  if (!uri || !body || !header_pairs || !trailer_pairs) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  auto headers = toPairs(header_pairs.value());\n  auto trailers = toPairs(trailer_pairs.value());\n  return context->httpCall(uri.value(), headers, body.value(), trailers, timeout_milliseconds.u64_);\n}\n\nWord defineMetricHandler(void* raw_context, Word metric_type, Word name_ptr, Word name_size,\n                         Word metric_id_ptr) {\n  if (metric_type.u64_ > static_cast<uint64_t>(Context::MetricType::Max)) {\n    return 0;\n  }\n  auto context = WASM_CONTEXT(raw_context);\n  auto name = context->wasmVm()->getMemory(name_ptr.u64_, name_size.u64_);\n  if (!name) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  uint32_t metric_id = 0;\n  auto result = context->defineMetric(static_cast<Context::MetricType>(metric_type.u64_),\n                                      name.value(), &metric_id);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  if (!context->wasm()->setDatatype(metric_id_ptr.u64_, metric_id)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord incrementMetricHandler(void* raw_context, Word metric_id, int64_t offset) {\n  auto context = WASM_CONTEXT(raw_context);\n  return wasmResultToWord(context->incrementMetric(metric_id.u64_, offset));\n}\n\nWord recordMetricHandler(void* raw_context, Word metric_id, uint64_t value) {\n  auto context = WASM_CONTEXT(raw_context);\n  return wasmResultToWord(context->recordMetric(metric_id.u64_, value));\n}\n\nWord getMetricHandler(void* raw_context, Word metric_id, Word result_uint64_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  uint64_t value = 0;\n  auto result = context->getMetric(metric_id.u64_, &value);\n  if (result != WasmResult::Ok) {\n    return wasmResultToWord(result);\n  }\n  if (!context->wasm()->setDatatype(result_uint64_ptr.u64_, value)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord grpcCallHandler(void* raw_context, Word service_ptr, Word service_size, Word service_name_ptr,\n                     Word service_name_size, Word method_name_ptr, Word method_name_size,\n                     Word request_ptr, Word request_size, Word timeout_milliseconds) {\n  auto context = WASM_CONTEXT(raw_context)->root_context();\n  auto service = context->wasmVm()->getMemory(service_ptr.u64_, service_size.u64_);\n  auto service_name = context->wasmVm()->getMemory(service_name_ptr.u64_, service_name_size.u64_);\n  auto method_name = context->wasmVm()->getMemory(method_name_ptr.u64_, method_name_size.u64_);\n  auto request = context->wasmVm()->getMemory(request_ptr.u64_, request_size.u64_);\n  if (!service || !service_name || !method_name || !request) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  envoy::api::v2::core::GrpcService service_proto;\n  if (!service_proto.ParseFromArray(service.value().data(), service.value().size())) {\n    return false;\n  }\n  return context->grpcCall(service_proto, service_name.value(), method_name.value(),\n                           request.value(), std::chrono::milliseconds(timeout_milliseconds.u64_));\n}\n\nWord grpcStreamHandler(void* raw_context, Word service_ptr, Word service_size,\n                       Word service_name_ptr, Word service_name_size, Word method_name_ptr,\n                       Word method_name_size) {\n  auto context = WASM_CONTEXT(raw_context)->root_context();\n  auto service = context->wasmVm()->getMemory(service_ptr.u64_, service_size.u64_);\n  auto service_name = context->wasmVm()->getMemory(service_name_ptr.u64_, service_name_size.u64_);\n  auto method_name = context->wasmVm()->getMemory(method_name_ptr.u64_, method_name_size.u64_);\n  if (!service || !service_name || !method_name) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  envoy::api::v2::core::GrpcService service_proto;\n  if (!service_proto.ParseFromArray(service.value().data(), service.value().size())) {\n    return false;\n  }\n  return context->grpcStream(service_proto, service_name.value(), method_name.value());\n}\n\nWord grpcCancelHandler(void* raw_context, Word token) {\n  auto context = WASM_CONTEXT(raw_context)->root_context();\n  return wasmResultToWord(context->grpcCancel(token.u64_));\n}\n\nWord grpcCloseHandler(void* raw_context, Word token) {\n  auto context = WASM_CONTEXT(raw_context)->root_context();\n  return wasmResultToWord(context->grpcClose(token.u64_));\n}\n\nWord grpcSendHandler(void* raw_context, Word token, Word message_ptr, Word message_size,\n                     Word end_stream) {\n  auto context = WASM_CONTEXT(raw_context)->root_context();\n  auto message = context->wasmVm()->getMemory(message_ptr.u64_, message_size.u64_);\n  if (!message) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(context->grpcSend(token.u64_, message.value(), end_stream.u64_));\n}\n\n// Implementation of writev-like() syscall that redirects stdout/stderr to Envoy logs.\nWord writevImpl(void* raw_context, Word fd, Word iovs, Word iovs_len, Word* nwritten_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n\n  // Read syscall args.\n  spdlog::level::level_enum log_level;\n  switch (fd.u64_) {\n  case 1 /* stdout */:\n    log_level = spdlog::level::info;\n    break;\n  case 2 /* stderr */:\n    log_level = spdlog::level::err;\n    break;\n  default:\n    return 8; // __WASI_EBADF\n  }\n\n  std::string s;\n  for (size_t i = 0; i < iovs_len.u64_; i++) {\n    auto memslice =\n        context->wasmVm()->getMemory(iovs.u64_ + i * 2 * sizeof(uint32_t), 2 * sizeof(uint32_t));\n    if (!memslice) {\n      return 21; // __WASI_EFAULT\n    }\n    const uint32_t* iovec = reinterpret_cast<const uint32_t*>(memslice.value().data());\n    if (iovec[1] /* buf_len */) {\n      memslice = context->wasmVm()->getMemory(iovec[0] /* buf */, iovec[1] /* buf_len */);\n      if (!memslice) {\n        return 21; // __WASI_EFAULT\n      }\n      s.append(memslice.value().data(), memslice.value().size());\n    }\n  }\n\n  size_t written = s.size();\n  if (written) {\n    // Remove trailing newline from the logs, if any.\n    if (s[written - 1] == '\\n') {\n      s.erase(written - 1);\n    }\n    context->scriptLog(log_level, s);\n  }\n  *nwritten_ptr = Word(written);\n  return 0; // __WASI_ESUCCESS\n}\n\n// __wasi_errno_t __wasi_fd_write(_wasi_fd_t fd, const _wasi_ciovec_t *iov, size_t iovs_len, size_t*\n// nwritten);\nWord wasi_unstable_fd_writeHandler(void* raw_context, Word fd, Word iovs, Word iovs_len,\n                                   Word nwritten_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n\n  Word nwritten(0);\n  auto result = writevImpl(raw_context, fd, iovs, iovs_len, &nwritten);\n  if (result.u64_ != 0) { // __WASI_ESUCCESS\n    return result;\n  }\n  if (!context->wasmVm()->setWord(nwritten_ptr.u64_, Word(nwritten))) {\n    return 21; // __WASI_EFAULT\n  }\n  return 0; // __WASI_ESUCCESS\n}\n\n// __wasi_errno_t __wasi_fd_seek(__wasi_fd_t fd, __wasi_filedelta_t offset, __wasi_whence_t\n// whence,__wasi_filesize_t *newoffset);\nWord wasi_unstable_fd_seekHandler(void*, Word, int64_t, Word, Word) {\n  throw WasmException(\"wasi_unstable fd_seek\");\n}\n\n// __wasi_errno_t __wasi_fd_close(__wasi_fd_t fd);\nWord wasi_unstable_fd_closeHandler(void*, Word) { throw WasmException(\"wasi_unstable fd_close\"); }\n\n// __wasi_errno_t __wasi_environ_get(char **environ, char *environ_buf);\nWord wasi_unstable_environ_getHandler(void*, Word, Word) {\n  return 0; // __WASI_ESUCCESS\n}\n\n// __wasi_errno_t __wasi_environ_sizes_get(size_t *environ_count, size_t *environ_buf_size);\nWord wasi_unstable_environ_sizes_getHandler(void* raw_context, Word count_ptr, Word buf_size_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  if (!context->wasmVm()->setWord(count_ptr.u64_, Word(0))) {\n    return 21; // __WASI_EFAULT\n  }\n  if (!context->wasmVm()->setWord(buf_size_ptr.u64_, Word(0))) {\n    return 21; // __WASI_EFAULT\n  }\n  return 0; // __WASI_ESUCCESS\n}\n\n// void __wasi_proc_exit(__wasi_exitcode_t rval);\nvoid wasi_unstable_proc_exitHandler(void*, Word) { throw WasmException(\"wasi_unstable proc_exit\"); }\n\nWord pthread_equalHandler(void*, Word left, Word right) { return left.u64_ == right.u64_; }\n\nWord setTickPeriodMillisecondsHandler(void* raw_context, Word tick_period_milliseconds) {\n  return wasmResultToWord(\n      WASM_CONTEXT(raw_context)\n          ->setTickPeriod(std::chrono::milliseconds(tick_period_milliseconds.u64_)));\n}\n\nWord getCurrentTimeNanosecondsHandler(void* raw_context, Word result_uint64_ptr) {\n  auto context = WASM_CONTEXT(raw_context);\n  uint64_t result = context->getCurrentTimeNanoseconds();\n  if (!context->wasm()->setDatatype(result_uint64_ptr.u64_, result)) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWord logHandler(void* raw_context, Word level, Word address, Word size) {\n  auto context = WASM_CONTEXT(raw_context);\n  auto message = context->wasmVm()->getMemory(address.u64_, size.u64_);\n  if (!message) {\n    return wasmResultToWord(WasmResult::InvalidMemoryAccess);\n  }\n  context->scriptLog(static_cast<spdlog::level::level_enum>(level.u64_), message.value());\n  return wasmResultToWord(WasmResult::Ok);\n}\n\nWasmResult Context::setTickPeriod(std::chrono::milliseconds tick_period) {\n  wasm_->setTickPeriod(root_context_id_ ? root_context_id_ : id_, tick_period);\n  return WasmResult::Ok;\n}\n\nuint64_t Context::getCurrentTimeNanoseconds() {\n  return std::chrono::duration_cast<std::chrono::nanoseconds>(\n             wasm_->time_source_.systemTime().time_since_epoch())\n      .count();\n}\n\n// TODO(https://github.com/google/cel-cpp/issues/38)\nbool exportValue(const Filters::Common::Expr::CelValue& value, ProtobufWkt::Value* out) {\n  using Filters::Common::Expr::CelValue;\n  switch (value.type()) {\n  case CelValue::Type::kBool:\n    out->set_bool_value(value.BoolOrDie());\n    return true;\n  case CelValue::Type::kInt64:\n    out->set_number_value(static_cast<double>(value.Int64OrDie()));\n    return true;\n  case CelValue::Type::kUint64:\n    out->set_number_value(static_cast<double>(value.Uint64OrDie()));\n    return true;\n  case CelValue::Type::kDouble:\n    out->set_number_value(value.DoubleOrDie());\n    return true;\n  case CelValue::Type::kString:\n    *out->mutable_string_value() = std::string(value.StringOrDie().value());\n    return true;\n  case CelValue::Type::kBytes:\n    *out->mutable_string_value() = std::string(value.BytesOrDie().value());\n    return true;\n  case CelValue::Type::kMessage: {\n    if (value.IsNull()) {\n      out->set_null_value(ProtobufWkt::NullValue::NULL_VALUE);\n    } else {\n      auto msg = value.MessageOrDie();\n      out->mutable_struct_value()->MergeFrom(*msg);\n    }\n    return true;\n  }\n  case CelValue::Type::kDuration:\n    *out->mutable_string_value() = absl::FormatDuration(value.DurationOrDie());\n    return true;\n  case CelValue::Type::kTimestamp:\n    *out->mutable_string_value() = absl::FormatTime(value.TimestampOrDie());\n    return true;\n  case CelValue::Type::kList: {\n    auto list = value.ListOrDie();\n    auto values = out->mutable_list_value();\n    for (int i = 0; i < list->size(); i++) {\n      if (!exportValue((*list)[i], values->add_values())) {\n        return false;\n      }\n    }\n    return true;\n  }\n  case CelValue::Type::kMap: {\n    auto map = value.MapOrDie();\n    auto list = map->ListKeys();\n    auto struct_obj = out->mutable_struct_value();\n    for (int i = 0; i < list->size(); i++) {\n      ProtobufWkt::Value field_key;\n      if (!exportValue((*list)[i], &field_key)) {\n        return false;\n      }\n      ProtobufWkt::Value field_value;\n      if (!exportValue((*map)[(*list)[i]].value(), &field_value)) {\n        return false;\n      }\n      (*struct_obj->mutable_fields())[field_key.string_value()] = field_value;\n    }\n    return true;\n  }\n  default:\n    // do nothing for special values\n    return false;\n  }\n  return false;\n}\n\nWasmResult serializeValue(Filters::Common::Expr::CelValue value, std::string* result) {\n  using Filters::Common::Expr::CelValue;\n  switch (value.type()) {\n  case CelValue::Type::kMessage:\n    if (value.MessageOrDie() != nullptr && value.MessageOrDie()->SerializeToString(result)) {\n      return WasmResult::Ok;\n    }\n    return WasmResult::SerializationFailure;\n  case CelValue::Type::kString:\n    result->assign(value.StringOrDie().value().data(), value.StringOrDie().value().size());\n    return WasmResult::Ok;\n  case CelValue::Type::kBytes:\n    result->assign(value.BytesOrDie().value().data(), value.BytesOrDie().value().size());\n    return WasmResult::Ok;\n  case CelValue::Type::kInt64: {\n    auto out = value.Int64OrDie();\n    result->assign(reinterpret_cast<const char*>(&out), sizeof(int64_t));\n    return WasmResult::Ok;\n  }\n  case CelValue::Type::kUint64: {\n    auto out = value.Uint64OrDie();\n    result->assign(reinterpret_cast<const char*>(&out), sizeof(uint64_t));\n    return WasmResult::Ok;\n  }\n  case CelValue::Type::kDouble: {\n    auto out = value.DoubleOrDie();\n    result->assign(reinterpret_cast<const char*>(&out), sizeof(double));\n    return WasmResult::Ok;\n  }\n  case CelValue::Type::kBool: {\n    auto out = value.BoolOrDie();\n    result->assign(reinterpret_cast<const char*>(&out), sizeof(bool));\n    return WasmResult::Ok;\n  }\n  case CelValue::Type::kDuration: {\n    auto out = value.DurationOrDie();\n    result->assign(reinterpret_cast<const char*>(&out), sizeof(absl::Duration));\n    return WasmResult::Ok;\n  }\n  case CelValue::Type::kTimestamp: {\n    auto out = value.TimestampOrDie();\n    result->assign(reinterpret_cast<const char*>(&out), sizeof(absl::Time));\n    return WasmResult::Ok;\n  }\n  case CelValue::Type::kMap: {\n    ProtobufWkt::Value out;\n    if (!exportValue(value, &out)) {\n      return WasmResult::SerializationFailure;\n    }\n    if (!out.struct_value().SerializeToString(result)) {\n      return WasmResult::SerializationFailure;\n    }\n    return WasmResult::Ok;\n  }\n  case CelValue::Type::kList: {\n    ProtobufWkt::Value out;\n    if (!exportValue(value, &out)) {\n      return WasmResult::SerializationFailure;\n    }\n    if (!out.list_value().SerializeToString(result)) {\n      return WasmResult::SerializationFailure;\n    }\n    return WasmResult::Ok;\n  }\n  default:\n    return WasmResult::SerializationFailure;\n  }\n  return WasmResult::SerializationFailure;\n}\n\n// An expression wrapper for the WASM state\nclass WasmStateWrapper : public google::api::expr::runtime::CelMap {\npublic:\n  WasmStateWrapper(const StreamInfo::FilterState& filter_state) : filter_state_(filter_state) {}\n  absl::optional<google::api::expr::runtime::CelValue>\n  operator[](google::api::expr::runtime::CelValue key) const override {\n    if (!key.IsString()) {\n      return {};\n    }\n    auto value = key.StringOrDie().value();\n    try {\n      const WasmState& result = filter_state_.getDataReadOnly<WasmState>(value);\n      return google::api::expr::runtime::CelValue::CreateBytes(&result.value());\n    } catch (const EnvoyException& e) {\n      return {};\n    }\n  }\n  int size() const override { NOT_IMPLEMENTED_GCOVR_EXCL_LINE; }\n  bool empty() const override { NOT_IMPLEMENTED_GCOVR_EXCL_LINE; }\n  const google::api::expr::runtime::CelList* ListKeys() const override {\n    NOT_IMPLEMENTED_GCOVR_EXCL_LINE;\n  }\n\nprivate:\n  const StreamInfo::FilterState& filter_state_;\n};\n\nWasmResult Context::getProperty(absl::string_view path, std::string* result) {\n  using google::api::expr::runtime::CelValue;\n  using google::api::expr::runtime::FieldBackedListImpl;\n  using google::api::expr::runtime::FieldBackedMapImpl;\n\n  bool first = true;\n  CelValue value;\n  Protobuf::Arena arena;\n  const StreamInfo::StreamInfo* info = getConstRequestStreamInfo();\n  const auto request_headers = request_headers_ ? request_headers_ : access_log_request_headers_;\n  const auto response_headers =\n      response_headers_ ? response_headers_ : access_log_response_headers_;\n  const auto response_trailers =\n      response_trailers_ ? response_trailers_ : access_log_response_trailers_;\n\n  size_t start = 0;\n  while (true) {\n    if (start >= path.size()) {\n      break;\n    }\n\n    size_t end = path.find('\\0', start);\n    if (end == absl::string_view::npos) {\n      // this should not happen unless the input string is not null-terminated in the view\n      return WasmResult::ParseFailure;\n    }\n    auto part = path.substr(start, end - start);\n    start = end + 1;\n\n    // top-level ident\n    if (first) {\n      first = false;\n      if (part == \"metadata\") {\n        value = CelValue::CreateMessage(&info->dynamicMetadata(), &arena);\n      } else if (part == \"filter_state\") {\n        value = CelValue::CreateMap(\n            Protobuf::Arena::Create<WasmStateWrapper>(&arena, info->filterState()));\n      } else if (part == \"request\") {\n        value = CelValue::CreateMap(Protobuf::Arena::Create<Filters::Common::Expr::RequestWrapper>(\n            &arena, request_headers, *info));\n      } else if (part == \"response\") {\n        value = CelValue::CreateMap(Protobuf::Arena::Create<Filters::Common::Expr::ResponseWrapper>(\n            &arena, response_headers, response_trailers, *info));\n      } else if (part == \"connection\") {\n        value = CelValue::CreateMap(\n            Protobuf::Arena::Create<Filters::Common::Expr::ConnectionWrapper>(&arena, *info));\n      } else if (part == \"upstream\") {\n        value = CelValue::CreateMap(\n            Protobuf::Arena::Create<Filters::Common::Expr::UpstreamWrapper>(&arena, *info));\n      } else if (part == \"node\") {\n        value = CelValue::CreateMessage(&plugin_->local_info_.node(), &arena);\n      } else if (part == \"source\") {\n        value = CelValue::CreateMap(\n            Protobuf::Arena::Create<Filters::Common::Expr::PeerWrapper>(&arena, *info, false));\n      } else if (part == \"destination\") {\n        value = CelValue::CreateMap(\n            Protobuf::Arena::Create<Filters::Common::Expr::PeerWrapper>(&arena, *info, true));\n      } else if (part == \"request_protocol\") {\n        // TODO(kyessenov) move this upstream to CEL context\n        if (info->protocol().has_value()) {\n          value =\n              CelValue::CreateString(&Http::Utility::getProtocolString(info->protocol().value()));\n        } else {\n          return WasmResult::NotFound;\n        }\n        // Reflective accessors\n      } else if (part == \"listener_direction\") {\n        value = CelValue::CreateInt64(plugin_->direction_);\n      } else if (part == \"listener_metadata\") {\n        value = CelValue::CreateMessage(plugin_->listener_metadata_, &arena);\n      } else if (part == \"cluster_name\" && info->upstreamHost() != nullptr) {\n        value = CelValue::CreateString(&info->upstreamHost()->cluster().name());\n      } else if (part == \"cluster_metadata\" && info->upstreamHost() != nullptr) {\n        value = CelValue::CreateMessage(&info->upstreamHost()->cluster().metadata(), &arena);\n      } else if (part == \"route_name\") {\n        value = CelValue::CreateString(&info->getRouteName());\n      } else if (part == \"route_metadata\" && info->routeEntry() != nullptr) {\n        value = CelValue::CreateMessage(&info->routeEntry()->metadata(), &arena);\n      } else {\n        return WasmResult::NotFound;\n      }\n      continue;\n    }\n\n    if (value.IsMap()) {\n      auto& map = *value.MapOrDie();\n      auto field = map[CelValue::CreateString(part)];\n      if (field.has_value()) {\n        value = field.value();\n      } else {\n        return {};\n      }\n    } else if (value.IsMessage()) {\n      auto msg = value.MessageOrDie();\n      if (msg == nullptr) {\n        return {};\n      }\n      const Protobuf::Descriptor* desc = msg->GetDescriptor();\n      const Protobuf::FieldDescriptor* field_desc = desc->FindFieldByName(std::string(part));\n      if (field_desc == nullptr) {\n        return {};\n      } else if (field_desc->is_map()) {\n        value = CelValue::CreateMap(\n            Protobuf::Arena::Create<FieldBackedMapImpl>(&arena, msg, field_desc, &arena));\n      } else if (field_desc->is_repeated()) {\n        value = CelValue::CreateList(\n            Protobuf::Arena::Create<FieldBackedListImpl>(&arena, msg, field_desc, &arena));\n      } else {\n        auto status =\n            google::api::expr::runtime::CreateValueFromSingleField(msg, field_desc, &arena, &value);\n        if (!status.ok()) {\n          return {};\n        }\n      }\n    } else {\n      return {};\n    }\n  }\n\n  return serializeValue(value, result);\n}\n\n// Shared Data\nWasmResult Context::getSharedData(absl::string_view key, std::pair<std::string, uint32_t>* data) {\n  return global_shared_data.get(wasm_->vm_id(), key, data);\n}\n\nWasmResult Context::setSharedData(absl::string_view key, absl::string_view value, uint32_t cas) {\n  return global_shared_data.set(wasm_->vm_id(), key, value, cas);\n}\n\n// Shared Queue\n\nuint32_t Context::registerSharedQueue(absl::string_view queue_name) {\n  // Get the id of the root context if this is a stream context because onQueueReady is on the root.\n  return global_shared_data.registerQueue(\n      wasm_->vm_id(), queue_name, isRootContext() ? id_ : root_context_id_, wasm_->dispatcher_);\n}\n\nWasmResult Context::resolveSharedQueue(absl::string_view vm_id, absl::string_view queue_name,\n                                       uint32_t* token_ptr) {\n  uint32_t token = global_shared_data.resolveQueue(vm_id, queue_name);\n  if (!token) {\n    return WasmResult::NotFound;\n  }\n  *token_ptr = token;\n  return WasmResult::Ok;\n}\n\nWasmResult Context::dequeueSharedQueue(uint32_t token, std::string* data) {\n  return global_shared_data.dequeue(token, data);\n}\n\nWasmResult Context::enqueueSharedQueue(uint32_t token, absl::string_view value) {\n  return global_shared_data.enqueue(token, value);\n}\n\n// Network bytes.\n\nWasmResult Context::getDownstreamDataBufferBytes(uint32_t start, uint32_t length,\n                                                 absl::string_view* data) {\n  if (!network_downstream_data_buffer_)\n    return WasmResult::NotFound;\n  if (network_downstream_data_buffer_->length() < static_cast<uint64_t>(start + length))\n    return WasmResult::InvalidMemoryAccess;\n  *data = absl::string_view(\n      static_cast<char*>(network_downstream_data_buffer_->linearize(start + length)) + start,\n      length);\n  return WasmResult::Ok;\n}\n\nWasmResult Context::getUpstreamDataBufferBytes(uint32_t start, uint32_t length,\n                                               absl::string_view* data) {\n  if (!network_upstream_data_buffer_)\n    return WasmResult::NotFound;\n  if (network_upstream_data_buffer_->length() < static_cast<uint64_t>(start + length))\n    return WasmResult::InvalidMemoryAccess;\n  *data = absl::string_view(\n      static_cast<char*>(network_upstream_data_buffer_->linearize(start + length)) + start, length);\n  return WasmResult::Ok;\n}\n\n// Header/Trailer/Metadata Maps.\nHttp::HeaderMap* Context::getMap(HeaderMapType type) {\n  switch (type) {\n  case HeaderMapType::RequestHeaders:\n    return request_headers_;\n  case HeaderMapType::RequestTrailers:\n    return request_trailers_;\n  case HeaderMapType::ResponseHeaders:\n    return response_headers_;\n  case HeaderMapType::ResponseTrailers:\n    return response_trailers_;\n  case HeaderMapType::GrpcCreateInitialMetadata:\n    return grpc_create_initial_metadata_;\n  default:\n    return nullptr;\n  }\n}\n\nconst Http::HeaderMap* Context::getConstMap(HeaderMapType type) {\n  switch (type) {\n  case HeaderMapType::RequestHeaders:\n    if (access_log_request_headers_) {\n      return access_log_request_headers_;\n    }\n    return request_headers_;\n  case HeaderMapType::RequestTrailers:\n    if (access_log_request_trailers_) {\n      return access_log_request_trailers_;\n    }\n    return request_trailers_;\n  case HeaderMapType::ResponseHeaders:\n    if (access_log_response_headers_) {\n      return access_log_response_headers_;\n    }\n    return response_headers_;\n  case HeaderMapType::ResponseTrailers:\n    if (access_log_response_trailers_) {\n      return access_log_response_trailers_;\n    }\n    return response_trailers_;\n  case HeaderMapType::GrpcCreateInitialMetadata:\n    return grpc_create_initial_metadata_;\n  case HeaderMapType::GrpcReceiveInitialMetadata:\n    return grpc_receive_initial_metadata_.get();\n  case HeaderMapType::GrpcReceiveTrailingMetadata:\n    return grpc_receive_trailing_metadata_.get();\n  }\n  return nullptr;\n}\n\nvoid Context::addHeaderMapValue(HeaderMapType type, absl::string_view key,\n                                absl::string_view value) {\n  auto map = getMap(type);\n  if (!map) {\n    return;\n  }\n  const Http::LowerCaseString lower_key(std::move(std::string(key)));\n  map->addCopy(lower_key, std::string(value));\n}\n\nabsl::string_view Context::getHeaderMapValue(HeaderMapType type, absl::string_view key) {\n  auto map = getConstMap(type);\n  if (!map) {\n    return \"\";\n  }\n  const Http::LowerCaseString lower_key(std::move(std::string(key)));\n  auto entry = map->get(lower_key);\n  if (!entry) {\n    return \"\";\n  }\n  return entry->value().getStringView();\n}\n\nPairs headerMapToPairs(const Http::HeaderMap* map) {\n  if (!map) {\n    return {};\n  }\n  Pairs pairs;\n  pairs.reserve(map->size());\n  map->iterate(\n      [](const Http::HeaderEntry& header, void* pairs) -> Http::HeaderMap::Iterate {\n        (static_cast<Pairs*>(pairs))\n            ->push_back(\n                std::make_pair(header.key().getStringView(), header.value().getStringView()));\n        return Http::HeaderMap::Iterate::Continue;\n      },\n      &pairs);\n  return pairs;\n}\n\nPairs Context::getHeaderMapPairs(HeaderMapType type) { return headerMapToPairs(getConstMap(type)); }\n\nvoid Context::setHeaderMapPairs(HeaderMapType type, const Pairs& pairs) {\n  auto map = getMap(type);\n  if (!map) {\n    return;\n  }\n  std::vector<std::string> keys;\n  map->iterate(\n      [](const Http::HeaderEntry& header, void* keys) -> Http::HeaderMap::Iterate {\n        (static_cast<std::vector<std::string>*>(keys))\n            ->push_back(std::string(header.key().getStringView()));\n        return Http::HeaderMap::Iterate::Continue;\n      },\n      &keys);\n  for (auto& k : keys) {\n    const Http::LowerCaseString lower_key(std::move(k));\n    map->remove(lower_key);\n  }\n  for (auto& p : pairs) {\n    const Http::LowerCaseString lower_key(std::move(std::string(p.first)));\n    map->addCopy(lower_key, std::move(std::string(p.second)));\n  }\n}\n\nvoid Context::removeHeaderMapValue(HeaderMapType type, absl::string_view key) {\n  auto map = getMap(type);\n  if (!map) {\n    return;\n  }\n  const Http::LowerCaseString lower_key(std::move(std::string(key)));\n  map->remove(lower_key);\n}\n\nvoid Context::replaceHeaderMapValue(HeaderMapType type, absl::string_view key,\n                                    absl::string_view value) {\n  auto map = getMap(type);\n  if (!map) {\n    return;\n  }\n  const Http::LowerCaseString lower_key(std::move(std::string(key)));\n  auto entry = map->get(lower_key);\n  if (entry != nullptr) {\n    entry->value(value.data(), value.size());\n  } else {\n    map->addCopy(lower_key, std::string(value));\n  }\n}\n\nuint32_t Context::getHeaderMapSize(HeaderMapType type) {\n  auto map = getMap(type);\n  if (!map) {\n    return 0;\n  }\n  return map->refreshByteSize();\n}\n\n// Body Buffer\n\nabsl::string_view Context::getRequestBodyBufferBytes(uint32_t start, uint32_t length) {\n  if (!requestBodyBuffer_) {\n    return \"\";\n  }\n  if (requestBodyBuffer_->length() < static_cast<uint64_t>((start + length))) {\n    return \"\";\n  }\n  return absl::string_view(\n      static_cast<char*>(requestBodyBuffer_->linearize(start + length)) + start, length);\n}\n\nabsl::string_view Context::getResponseBodyBufferBytes(uint32_t start, uint32_t length) {\n  if (!responseBodyBuffer_) {\n    return \"\";\n  }\n  if (responseBodyBuffer_->length() < static_cast<uint64_t>((start + length))) {\n    return \"\";\n  }\n  return absl::string_view(\n      static_cast<char*>(responseBodyBuffer_->linearize(start + length)) + start, length);\n}\n\n// Async call via HTTP\nuint32_t Context::httpCall(absl::string_view cluster, const Pairs& request_headers,\n                           absl::string_view request_body, const Pairs& request_trailers,\n                           int timeout_milliseconds) {\n  if (timeout_milliseconds < 0) {\n    return 0;\n  }\n  auto cluster_string = std::string(cluster);\n  if (clusterManager().get(cluster_string) == nullptr) {\n    return 0;\n  }\n\n  Http::MessagePtr message(new Http::RequestMessageImpl(buildHeaderMapFromPairs(request_headers)));\n\n  // Check that we were provided certain headers.\n  if (message->headers().Path() == nullptr || message->headers().Method() == nullptr ||\n      message->headers().Host() == nullptr) {\n    return 0;\n  }\n\n  if (!request_body.empty()) {\n    message->body().reset(new Buffer::OwnedImpl(request_body.data(), request_body.size()));\n    message->headers().insertContentLength().value(request_body.size());\n  }\n\n  if (request_trailers.size() > 0) {\n    message->trailers(buildHeaderMapFromPairs(request_trailers));\n  }\n\n  absl::optional<std::chrono::milliseconds> timeout;\n  if (timeout_milliseconds > 0) {\n    timeout = std::chrono::milliseconds(timeout_milliseconds);\n  }\n\n  auto token = next_http_call_token_++;\n  // Handle rollover.\n  for (;;) {\n    if (token == 0) {\n      token = next_http_call_token_++;\n    }\n    if (!http_request_.count(token)) {\n      break;\n    }\n    token = next_http_call_token_++;\n  }\n  auto& handler = http_request_[token];\n\n  // set default hash policy to be based on :authority to enable consistent hash\n  Http::AsyncClient::RequestOptions options;\n  options.setTimeout(timeout);\n  Protobuf::RepeatedPtrField<envoy::api::v2::route::RouteAction::HashPolicy> hash_policy;\n  hash_policy.Add()->mutable_header()->set_header_name(Http::Headers::get().Host.get());\n  options.setHashPolicy(hash_policy);\n  auto http_request = clusterManager()\n                          .httpAsyncClientForCluster(cluster_string)\n                          .send(std::move(message), handler, options);\n  if (!http_request) {\n    http_request_.erase(token);\n    return 0;\n  }\n  handler.context = this;\n  handler.token = token;\n  handler.request = http_request;\n  return token;\n}\n\nuint32_t Context::grpcCall(const envoy::api::v2::core::GrpcService& grpc_service,\n                           absl::string_view service_name, absl::string_view method_name,\n                           absl::string_view request,\n                           const absl::optional<std::chrono::milliseconds>& timeout) {\n  auto token = next_grpc_token_++;\n  if (IsGrpcStreamToken(token)) {\n    token = next_grpc_token_++;\n  }\n  // Handle rollover.\n  for (;;) {\n    if (token == 0) {\n      token = next_grpc_token_ += 2;\n    }\n    if (!grpc_call_request_.count(token)) {\n      break;\n    }\n    token = next_grpc_token_ += 2;\n  }\n  auto& handler = grpc_call_request_[token];\n  handler.context = this;\n  handler.token = token;\n  auto grpc_client =\n      clusterManager()\n          .grpcAsyncClientManager()\n          .factoryForGrpcService(grpc_service, *wasm()->scope_, true /* skip_cluster_check */)\n          ->create();\n\n  // set default hash policy to be based on :authority to enable consistent hash\n  Http::AsyncClient::RequestOptions options;\n  options.setTimeout(timeout);\n  Protobuf::RepeatedPtrField<envoy::api::v2::route::RouteAction::HashPolicy> hash_policy;\n  hash_policy.Add()->mutable_header()->set_header_name(Http::Headers::get().Host.get());\n  options.setHashPolicy(hash_policy);\n\n  // NB: this call causes the onCreateInitialMetadata callback to occur inline *before* this call\n  // returns. Consequently the grpc_request is not available. Attempting to close or reset from that\n  // callback will fail.\n  auto grpc_request =\n      grpc_client->sendRaw(service_name, method_name, std::make_unique<Buffer::OwnedImpl>(request),\n                           handler, Tracing::NullSpan::instance(), options);\n  if (!grpc_request) {\n    grpc_call_request_.erase(token);\n    return 0;\n  }\n  handler.client = std::move(grpc_client);\n  handler.request = grpc_request;\n  return token;\n}\n\nuint32_t Context::grpcStream(const envoy::api::v2::core::GrpcService& grpc_service,\n                             absl::string_view service_name, absl::string_view method_name) {\n  auto token = next_grpc_token_++;\n  if (IsGrpcCallToken(token)) {\n    token = next_grpc_token_++;\n  }\n  // Handle rollover.\n  for (;;) {\n    if (token == 0) {\n      token = next_grpc_token_ += 2;\n    }\n    if (!grpc_stream_.count(token)) {\n      break;\n    }\n    token = next_grpc_token_ += 2;\n  }\n  auto& handler = grpc_stream_[token];\n  handler.context = this;\n  handler.token = token;\n  auto grpc_client =\n      clusterManager()\n          .grpcAsyncClientManager()\n          .factoryForGrpcService(grpc_service, *wasm()->scope_, true /* skip_cluster_check */)\n          ->create();\n\n  // set default hash policy to be based on :authority to enable consistent hash\n  Http::AsyncClient::StreamOptions options;\n  Protobuf::RepeatedPtrField<envoy::api::v2::route::RouteAction::HashPolicy> hash_policy;\n  hash_policy.Add()->mutable_header()->set_header_name(Http::Headers::get().Host.get());\n  options.setHashPolicy(hash_policy);\n\n  // NB: this call causes the onCreateInitialMetadata callback to occur inline *before* this call\n  // returns. Consequently the grpc_stream is not available. Attempting to close or reset from that\n  // callback will fail.\n  auto grpc_stream = grpc_client->startRaw(service_name, method_name, handler, options);\n  if (!grpc_stream) {\n    grpc_stream_.erase(token);\n    return 0;\n  }\n  handler.client = std::move(grpc_client);\n  handler.stream = grpc_stream;\n  return token;\n}\n\nvoid Context::httpRespond(const Pairs& response_headers, absl::string_view body,\n                          const Pairs& response_trailers) {\n  (void)response_headers;\n  (void)body;\n  (void)response_trailers;\n}\n\n// StreamInfo\nconst StreamInfo::StreamInfo* Context::getConstRequestStreamInfo() const {\n  if (encoder_callbacks_) {\n    return &encoder_callbacks_->streamInfo();\n  } else if (decoder_callbacks_) {\n    return &decoder_callbacks_->streamInfo();\n  } else if (access_log_stream_info_) {\n    return access_log_stream_info_;\n  }\n  return nullptr;\n}\n\nStreamInfo::StreamInfo* Context::getRequestStreamInfo() const {\n  if (encoder_callbacks_) {\n    return &encoder_callbacks_->streamInfo();\n  } else if (decoder_callbacks_) {\n    return &decoder_callbacks_->streamInfo();\n  }\n  return nullptr;\n}\n\nWasmResult Context::setProperty(absl::string_view key, absl::string_view serialized_value) {\n  auto* stream_info = getRequestStreamInfo();\n  if (!stream_info) {\n    return WasmResult::NotFound;\n  }\n  stream_info->filterState().setData(key, std::make_unique<WasmState>(serialized_value),\n                                     StreamInfo::FilterState::StateType::Mutable);\n  return WasmResult::Ok;\n}\n\nvoid Context::scriptLog(spdlog::level::level_enum level, absl::string_view message) {\n  switch (level) {\n  case spdlog::level::trace:\n    ENVOY_LOG(trace, \"wasm log{}: {}\", log_prefix(), message);\n    return;\n  case spdlog::level::debug:\n    ENVOY_LOG(debug, \"wasm log{}: {}\", log_prefix(), message);\n    return;\n  case spdlog::level::info:\n    ENVOY_LOG(info, \"wasm log{}: {}\", log_prefix(), message);\n    return;\n  case spdlog::level::warn:\n    ENVOY_LOG(warn, \"wasm log{}: {}\", log_prefix(), message);\n    return;\n  case spdlog::level::err:\n    ENVOY_LOG(error, \"wasm log{}: {}\", log_prefix(), message);\n    return;\n  case spdlog::level::critical:\n    ENVOY_LOG(critical, \"wasm log{}: {}\", log_prefix(), message);\n    return;\n  case spdlog::level::off:\n    NOT_IMPLEMENTED_GCOVR_EXCL_LINE;\n  }\n}\n\n// Connection\nbool Context::isSsl() { return decoder_callbacks_->connection()->ssl() != nullptr; }\n\n//\n// Calls into the WASM code.\n//\nvoid Context::onStart(absl::string_view root_id, absl::string_view vm_configuration) {\n  if (wasm_->onStart_) {\n    auto root_id_addr = wasm_->copyString(root_id);\n    auto config_addr = wasm_->copyString(vm_configuration);\n    wasm_->onStart_(this, id_, root_id_addr, root_id.size(), config_addr, vm_configuration.size());\n  }\n  in_vm_context_created_ = true;\n}\n\nbool Context::validateConfiguration(absl::string_view configuration) {\n  if (!wasm_->validateConfiguration_) {\n    return true;\n  }\n  auto address = wasm_->copyString(configuration);\n  return wasm_->validateConfiguration_(this, id_, address, configuration.size()).u64_ != 0;\n}\n\nbool Context::onConfigure(absl::string_view configuration) {\n  if (!wasm_->onConfigure_) {\n    return true;\n  }\n  auto address = wasm_->copyString(configuration);\n  return wasm_->onConfigure_(this, id_, address, configuration.size()).u64_ != 0;\n}\n\nvoid Context::onCreate(uint32_t root_context_id) {\n  if (wasm_->onCreate_) {\n    wasm_->onCreate_(this, id_, root_context_id);\n  }\n}\n\nNetwork::FilterStatus Context::onNetworkNewConnection() {\n  onCreate(root_context_id_);\n  in_vm_context_created_ = true;\n  if (!wasm_->onNewConnection_) {\n    return Network::FilterStatus::Continue;\n  }\n  if (wasm_->onNewConnection_(this, id_).u64_ == 0) {\n    return Network::FilterStatus::Continue;\n  }\n  return Network::FilterStatus::StopIteration;\n}\n\nNetwork::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {\n  if (!in_vm_context_created_ || !wasm_->onDownstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                         static_cast<uint32_t>(end_of_stream));\n  // TODO(PiotrSikora): pull Proxy-WASM's FilterStatus values.\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}\n\nNetwork::FilterStatus Context::onUpstreamData(int data_length, bool end_of_stream) {\n  if (!in_vm_context_created_ || !wasm_->onUpstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onUpstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                       static_cast<uint32_t>(end_of_stream));\n  // TODO(PiotrSikora): pull Proxy-WASM's FilterStatus values.\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}\n\nvoid Context::onDownstreamConnectionClose(PeerType peer_type) {\n  if (in_vm_context_created_ && wasm_->onDownstreamConnectionClose_) {\n    wasm_->onDownstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}\n\nvoid Context::onUpstreamConnectionClose(PeerType peer_type) {\n  if (in_vm_context_created_ && wasm_->onUpstreamConnectionClose_) {\n    wasm_->onUpstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}\n\nHttp::FilterHeadersStatus Context::onRequestHeaders() {\n  onCreate(root_context_id_);\n  in_vm_context_created_ = true;\n  // Store the stream id so that we can use it in log().\n  auto& stream_info = decoder_callbacks_->streamInfo();\n  auto& metadata = (*stream_info.dynamicMetadata()\n                         .mutable_filter_metadata())[HttpFilters::HttpFilterNames::get().Wasm];\n  (*metadata.mutable_fields())[std::string(\"_stream_id_\" + std::string(root_id()))]\n      .set_number_value(id_);\n  if (!wasm_->onRequestHeaders_) {\n    return Http::FilterHeadersStatus::Continue;\n  }\n  if (wasm_->onRequestHeaders_(this, id_).u64_ == 0) {\n    return Http::FilterHeadersStatus::Continue;\n  }\n  return Http::FilterHeadersStatus::StopIteration;\n}\n\nHttp::FilterDataStatus Context::onRequestBody(int body_buffer_length, bool end_of_stream) {\n  if (!in_vm_context_created_ || !wasm_->onRequestBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              ->onRequestBody_(this, id_, static_cast<uint32_t>(body_buffer_length),\n                               static_cast<uint32_t>(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}\n\nHttp::FilterTrailersStatus Context::onRequestTrailers() {\n  if (!in_vm_context_created_ || !wasm_->onRequestTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onRequestTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}\n\nHttp::FilterMetadataStatus Context::onRequestMetadata() {\n  if (!in_vm_context_created_ || !wasm_->onRequestMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onRequestMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; // This is currently the only return code.\n}\n\nHttp::FilterHeadersStatus Context::onResponseHeaders() {\n  if (!in_vm_context_created_) {\n    // If the request is invalid then onRequestHeaders() will not be called and neither will\n    // onCreate() then sendLocalReply be called which will call this function. In this case we\n    // need to call onCreate() so that the Context inside the VM is created before the\n    // onResponseHeaders() call.\n    onCreate(root_context_id_);\n    in_vm_context_created_ = true;\n  }\n  if (!wasm_->onResponseHeaders_) {\n    return Http::FilterHeadersStatus::Continue;\n  }\n  if (wasm_->onResponseHeaders_(this, id_).u64_ == 0) {\n    return Http::FilterHeadersStatus::Continue;\n  }\n  return Http::FilterHeadersStatus::StopIteration;\n}\n\nHttp::FilterDataStatus Context::onResponseBody(int body_buffer_length, bool end_of_stream) {\n  if (!in_vm_context_created_ || !wasm_->onResponseBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              ->onResponseBody_(this, id_, static_cast<uint32_t>(body_buffer_length),\n                                static_cast<uint32_t>(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}\n\nHttp::FilterTrailersStatus Context::onResponseTrailers() {\n  if (!in_vm_context_created_ || !wasm_->onResponseTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}\n\nHttp::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!in_vm_context_created_ || !wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; // This is currently the only return code.\n}\n\nvoid Context::onHttpCallResponse(uint32_t token, const Pairs& response_headers,\n                                 absl::string_view response_body, const Pairs& response_trailers) {\n  if (!wasm_->onHttpCallResponse_) {\n    return;\n  }\n  uint64_t headers_ptr, headers_size, trailers_ptr, trailers_size;\n  exportPairs(this, response_headers, &headers_ptr, &headers_size);\n  exportPairs(this, response_trailers, &trailers_ptr, &trailers_size);\n  auto body_ptr = wasm_->copyString(response_body);\n  auto body_size = response_body.size();\n  wasm_->onHttpCallResponse_(this, id_, token, headers_ptr, headers_size, body_ptr, body_size,\n                             trailers_ptr, trailers_size);\n}\n\nvoid Context::onQueueReady(uint32_t token) {\n  if (wasm_->onQueueReady_) {\n    wasm_->onQueueReady_(this, id_, token);\n  }\n}\n\nvoid Context::onGrpcCreateInitialMetadata(uint32_t token, Http::HeaderMap& metadata) {\n  if (!wasm_->onGrpcCreateInitialMetadata_) {\n    return;\n  }\n  grpc_create_initial_metadata_ = &metadata;\n  wasm_->onGrpcCreateInitialMetadata_(this, id_, token);\n  grpc_create_initial_metadata_ = nullptr;\n}\n\nvoid Context::onGrpcReceiveInitialMetadata(uint32_t token, Http::HeaderMapPtr&& metadata) {\n  if (!wasm_->onGrpcReceiveInitialMetadata_) {\n    return;\n  }\n  grpc_receive_initial_metadata_ = std::move(metadata);\n  wasm_->onGrpcReceiveInitialMetadata_(this, id_, token);\n  grpc_receive_initial_metadata_ = nullptr;\n}\n\nvoid Context::onGrpcReceiveTrailingMetadata(uint32_t token, Http::HeaderMapPtr&& metadata) {\n  if (!wasm_->onGrpcReceiveTrailingMetadata_) {\n    return;\n  }\n  grpc_receive_trailing_metadata_ = std::move(metadata);\n  wasm_->onGrpcReceiveTrailingMetadata_(this, id_, token);\n  grpc_receive_trailing_metadata_ = nullptr;\n}\n\nWasmResult Context::defineMetric(MetricType type, absl::string_view name, uint32_t* metric_id_ptr) {\n  auto stat_name = wasm_->stat_name_set_->getDynamic(name);\n  if (type == MetricType::Counter) {\n    auto id = wasm_->nextCounterMetricId();\n    auto c = &wasm_->scope_->counterFromStatName(stat_name);\n    wasm_->counters_.emplace(id, c);\n    *metric_id_ptr = id;\n    return WasmResult::Ok;\n  } else if (type == MetricType::Gauge) {\n    auto id = wasm_->nextGaugeMetricId();\n    auto g = &wasm_->scope_->gaugeFromStatName(stat_name, Stats::Gauge::ImportMode::Accumulate);\n    wasm_->gauges_.emplace(id, g);\n    *metric_id_ptr = id;\n    return WasmResult::Ok;\n  } else if (type == MetricType::Histogram) {\n    auto id = wasm_->nextHistogramMetricId();\n    auto h = &wasm_->scope_->histogramFromStatName(stat_name, Stats::Histogram::Unit::Unspecified);\n    wasm_->histograms_.emplace(id, h);\n    *metric_id_ptr = id;\n    return WasmResult::Ok;\n  }\n  return WasmResult::BadArgument;\n}\n\nWasmResult Context::incrementMetric(uint32_t metric_id, int64_t offset) {\n  auto type = static_cast<MetricType>(metric_id & Wasm::kMetricTypeMask);\n  if (type == MetricType::Counter) {\n    auto it = wasm_->counters_.find(metric_id);\n    if (it != wasm_->counters_.end()) {\n      if (offset > 0) {\n        it->second->add(offset);\n        return WasmResult::Ok;\n      } else {\n        return WasmResult::BadArgument;\n      }\n      return WasmResult::NotFound;\n    }\n  } else if (type == MetricType::Gauge) {\n    auto it = wasm_->gauges_.find(metric_id);\n    if (it != wasm_->gauges_.end()) {\n      if (offset > 0) {\n        it->second->add(offset);\n        return WasmResult::Ok;\n      } else {\n        it->second->sub(-offset);\n        return WasmResult::Ok;\n      }\n    }\n    return WasmResult::NotFound;\n  }\n  return WasmResult::BadArgument;\n}\n\nWasmResult Context::recordMetric(uint32_t metric_id, uint64_t value) {\n  auto type = static_cast<MetricType>(metric_id & Wasm::kMetricTypeMask);\n  if (type == MetricType::Counter) {\n    auto it = wasm_->counters_.find(metric_id);\n    if (it != wasm_->counters_.end()) {\n      it->second->add(value);\n      return WasmResult::Ok;\n    }\n  } else if (type == MetricType::Gauge) {\n    auto it = wasm_->gauges_.find(metric_id);\n    if (it != wasm_->gauges_.end()) {\n      it->second->set(value);\n      return WasmResult::Ok;\n    }\n  } else if (type == MetricType::Histogram) {\n    auto it = wasm_->histograms_.find(metric_id);\n    if (it != wasm_->histograms_.end()) {\n      it->second->recordValue(value);\n      return WasmResult::Ok;\n    }\n  }\n  return WasmResult::NotFound;\n}\n\nWasmResult Context::getMetric(uint32_t metric_id, uint64_t* result_uint64_ptr) {\n  auto type = static_cast<MetricType>(metric_id & Wasm::kMetricTypeMask);\n  if (type == MetricType::Counter) {\n    auto it = wasm_->counters_.find(metric_id);\n    if (it != wasm_->counters_.end()) {\n      *result_uint64_ptr = it->second->value();\n      return WasmResult::Ok;\n    }\n    return WasmResult::NotFound;\n  } else if (type == MetricType::Gauge) {\n    auto it = wasm_->gauges_.find(metric_id);\n    if (it != wasm_->gauges_.end()) {\n      *result_uint64_ptr = it->second->value();\n      return WasmResult::Ok;\n    }\n    return WasmResult::NotFound;\n  }\n  return WasmResult::BadArgument;\n}\n\nWasm::Wasm(absl::string_view vm, absl::string_view vm_id, absl::string_view vm_configuration,\n           PluginSharedPtr plugin, Stats::ScopeSharedPtr scope,\n           Upstream::ClusterManager& cluster_manager, Event::Dispatcher& dispatcher)\n    : vm_id_(std::string(vm_id)), wasm_vm_(Common::Wasm::createWasmVm(vm)), plugin_(plugin),\n      scope_(scope), cluster_manager_(cluster_manager), dispatcher_(dispatcher),\n      time_source_(dispatcher.timeSource()), vm_configuration_(vm_configuration),\n      stat_name_set_(scope_->symbolTable().makeSet(\"Wasm\").release()) {}\n\nstd::string Plugin::makeLogPrefix() const {\n  std::string prefix;\n  if (!name_.empty()) {\n    prefix = prefix + \" \" + name_;\n  }\n  if (!root_id_.empty()) {\n    prefix = prefix + \" \" + std::string(root_id_);\n  }\n  if (vm_id_.empty()) {\n    prefix = prefix + \" \" + std::string(vm_id_);\n  }\n  return prefix;\n}\n\nContext::~Context() {\n  // Cancel any outstanding requests.\n  for (auto& p : http_request_) {\n    p.second.request->cancel();\n  }\n  for (auto& p : grpc_call_request_) {\n    p.second.request->cancel();\n  }\n  for (auto& p : grpc_stream_) {\n    p.second.stream->resetStream();\n  }\n  // Do not remove vm or root contexts which have the same lifetime as wasm_.\n  if (root_context_id_) {\n    wasm_->contexts_.erase(id_);\n  }\n}\n\nvoid Wasm::registerCallbacks() {\n#define _REGISTER(_fn)                                                                             \\\n  wasm_vm_->registerCallback(                                                                      \\\n      \"env\", #_fn, &_fn##Handler,                                                                  \\\n      &ConvertFunctionWordToUint32<decltype(_fn##Handler),                                         \\\n                                   _fn##Handler>::convertFunctionWordToUint32)\n  if (is_emscripten_) {\n    _REGISTER(pthread_equal);\n  }\n#undef _REGISTER\n\n#define _REGISTER_WASI(_fn)                                                                        \\\n  wasm_vm_->registerCallback(                                                                      \\\n      \"wasi_unstable\", #_fn, &wasi_unstable_##_fn##Handler,                                        \\\n      &ConvertFunctionWordToUint32<decltype(wasi_unstable_##_fn##Handler),                         \\\n                                   wasi_unstable_##_fn##Handler>::convertFunctionWordToUint32)\n  if (is_emscripten_) {\n    _REGISTER_WASI(fd_write);\n    _REGISTER_WASI(fd_seek);\n    _REGISTER_WASI(fd_close);\n    _REGISTER_WASI(environ_get);\n    _REGISTER_WASI(environ_sizes_get);\n    _REGISTER_WASI(proc_exit);\n  }\n#undef _REGISTER_WASI\n\n  // Calls with the \"proxy_\" prefix.\n#define _REGISTER_PROXY(_fn)                                                                       \\\n  wasm_vm_->registerCallback(                                                                      \\\n      \"env\", \"proxy_\" #_fn, &_fn##Handler,                                                         \\\n      &ConvertFunctionWordToUint32<decltype(_fn##Handler),                                         \\\n                                   _fn##Handler>::convertFunctionWordToUint32);\n  _REGISTER_PROXY(log);\n\n  _REGISTER_PROXY(setProperty);\n  _REGISTER_PROXY(getProperty);\n\n  _REGISTER_PROXY(continueRequest);\n  _REGISTER_PROXY(continueResponse);\n  _REGISTER_PROXY(sendLocalResponse);\n  _REGISTER_PROXY(clearRouteCache);\n\n  _REGISTER_PROXY(getSharedData);\n  _REGISTER_PROXY(setSharedData);\n\n  _REGISTER_PROXY(registerSharedQueue);\n  _REGISTER_PROXY(resolveSharedQueue);\n  _REGISTER_PROXY(dequeueSharedQueue);\n  _REGISTER_PROXY(enqueueSharedQueue);\n\n  _REGISTER_PROXY(getDownstreamDataBufferBytes);\n  _REGISTER_PROXY(getUpstreamDataBufferBytes);\n\n  _REGISTER_PROXY(getHeaderMapValue);\n  _REGISTER_PROXY(addHeaderMapValue);\n  _REGISTER_PROXY(replaceHeaderMapValue);\n  _REGISTER_PROXY(removeHeaderMapValue);\n  _REGISTER_PROXY(getHeaderMapPairs);\n  _REGISTER_PROXY(setHeaderMapPairs);\n  _REGISTER_PROXY(getHeaderMapSize);\n\n  _REGISTER_PROXY(getRequestBodyBufferBytes);\n  _REGISTER_PROXY(getResponseBodyBufferBytes);\n\n  _REGISTER_PROXY(httpCall);\n\n  _REGISTER_PROXY(grpcCall);\n  _REGISTER_PROXY(grpcStream);\n  _REGISTER_PROXY(grpcClose);\n  _REGISTER_PROXY(grpcCancel);\n  _REGISTER_PROXY(grpcSend);\n\n  _REGISTER_PROXY(setTickPeriodMilliseconds);\n  _REGISTER_PROXY(getCurrentTimeNanoseconds);\n\n  _REGISTER_PROXY(defineMetric);\n  _REGISTER_PROXY(incrementMetric);\n  _REGISTER_PROXY(recordMetric);\n  _REGISTER_PROXY(getMetric);\n\n  _REGISTER_PROXY(setEffectiveContext);\n#undef _REGISTER_PROXY\n}\n\nvoid Wasm::getFunctions() {\n#define _GET(_fn) wasm_vm_->getFunction(#_fn, &_fn##_);\n  _GET(_start);\n  _GET(__wasm_call_ctors);\n\n  _GET(malloc);\n  _GET(free);\n#undef _GET\n\n#define _GET_PROXY(_fn) wasm_vm_->getFunction(\"proxy_\" #_fn, &_fn##_);\n  _GET_PROXY(validateConfiguration);\n  _GET_PROXY(onStart);\n  _GET_PROXY(onConfigure);\n  _GET_PROXY(onTick);\n\n  _GET_PROXY(onCreate);\n\n  _GET_PROXY(onNewConnection);\n  _GET_PROXY(onDownstreamData);\n  _GET_PROXY(onUpstreamData);\n  _GET_PROXY(onDownstreamConnectionClose);\n  _GET_PROXY(onUpstreamConnectionClose);\n\n  _GET_PROXY(onRequestHeaders);\n  _GET_PROXY(onRequestBody);\n  _GET_PROXY(onRequestTrailers);\n  _GET_PROXY(onRequestMetadata);\n  _GET_PROXY(onResponseHeaders);\n  _GET_PROXY(onResponseBody);\n  _GET_PROXY(onResponseTrailers);\n  _GET_PROXY(onResponseMetadata);\n  _GET_PROXY(onHttpCallResponse);\n  _GET_PROXY(onGrpcReceive);\n  _GET_PROXY(onGrpcClose);\n  _GET_PROXY(onGrpcCreateInitialMetadata);\n  _GET_PROXY(onGrpcReceiveInitialMetadata);\n  _GET_PROXY(onGrpcReceiveTrailingMetadata);\n  _GET_PROXY(onQueueReady);\n  _GET_PROXY(onDone);\n  _GET_PROXY(onLog);\n  _GET_PROXY(onDelete);\n#undef _GET_PROXY\n\n  if (!malloc_ || !free_) {\n    throw WasmException(\"WASM missing malloc/free\");\n  }\n}\n\nWasm::Wasm(const Wasm& wasm, Event::Dispatcher& dispatcher)\n    : std::enable_shared_from_this<Wasm>(wasm), vm_id_(wasm.vm_id_), plugin_(wasm.plugin_),\n      scope_(wasm.scope_), cluster_manager_(wasm.cluster_manager_), dispatcher_(dispatcher),\n      time_source_(dispatcher.timeSource()), stat_name_set_(wasm.stat_name_set_) {\n  if (wasm.wasmVm()->cloneable()) {\n    wasm_vm_ = wasm.wasmVm()->clone();\n    vm_context_ = std::make_shared<Context>(this);\n    getFunctions();\n  } else {\n    wasm_vm_ = Common::Wasm::createWasmVm(wasm.wasmVm()->runtime());\n    if (!initialize(wasm.code(), wasm.allow_precompiled())) {\n      throw WasmException(\"Failed to initialize WASM code\");\n    }\n  }\n}\n\nbool Wasm::initialize(const std::string& code, bool allow_precompiled) {\n  if (!wasm_vm_) {\n    return false;\n  }\n\n  // If the configured_vm_id is empty, then hash the code to create a unique vm_id.\n  if (vm_id_.empty()) {\n    vm_id_ = base64Sha256(code);\n  }\n\n  auto ok = wasm_vm_->load(code, allow_precompiled);\n  if (!ok) {\n    return false;\n  }\n  auto metadata = wasm_vm_->getCustomSection(\"emscripten_metadata\");\n  if (!metadata.empty()) {\n    // See https://github.com/emscripten-core/emscripten/blob/incoming/tools/shared.py#L3059\n    is_emscripten_ = true;\n    auto start = reinterpret_cast<const uint8_t*>(metadata.data());\n    auto end = reinterpret_cast<const uint8_t*>(metadata.data() + metadata.size());\n    start = decodeVarint(start, end, &emscripten_metadata_major_version_);\n    start = decodeVarint(start, end, &emscripten_metadata_minor_version_);\n    start = decodeVarint(start, end, &emscripten_abi_major_version_);\n    start = decodeVarint(start, end, &emscripten_abi_minor_version_);\n    uint32_t temp;\n    if (emscripten_metadata_major_version_ > 0 || emscripten_metadata_minor_version_ > 1) {\n      // metadata 0.2 - added: wasm_backend.\n      start = decodeVarint(start, end, &temp);\n    }\n    start = decodeVarint(start, end, &temp);\n    start = decodeVarint(start, end, &temp);\n    if (emscripten_metadata_major_version_ > 0 || emscripten_metadata_minor_version_ > 0) {\n      // metadata 0.1 - added: global_base, dynamic_base, dynamictop_ptr and tempdouble_ptr.\n      start = decodeVarint(start, end, &temp);\n      start = decodeVarint(start, end, &temp);\n      start = decodeVarint(start, end, &temp);\n      decodeVarint(start, end, &temp);\n      if (emscripten_metadata_major_version_ > 0 || emscripten_metadata_minor_version_ > 2) {\n        // metadata 0.3 - added: standalone_wasm.\n        start = decodeVarint(start, end, &emscripten_standalone_wasm_);\n      }\n    }\n  }\n  registerCallbacks();\n  wasm_vm_->link(vm_id_);\n  vm_context_ = std::make_shared<Context>(this);\n  getFunctions();\n  startVm(vm_context_.get());\n  code_ = code;\n  allow_precompiled_ = allow_precompiled;\n  return true;\n}\n\nvoid Wasm::startVm(Context* root_context) {\n  /* Call \"_start\" function, and fallback to \"__wasm_call_ctors\" if the former is not available. */\n  if (_start_) {\n    _start_(root_context);\n  } else if (__wasm_call_ctors_) {\n    __wasm_call_ctors_(root_context);\n  }\n}\n\nbool Wasm::configure(Context* root_context, absl::string_view configuration) {\n  if (!onConfigure_) {\n    return true;\n  }\n  auto address = copyString(configuration);\n  return onConfigure_(root_context, root_context->id(), address, configuration.size()).u64_ != 0;\n}\n\nContext* Wasm::start() {\n  auto root_id = plugin_->root_id_;\n  auto it = root_contexts_.find(root_id);\n  if (it != root_contexts_.end()) {\n    it->second->onStart(root_id, vm_configuration());\n    return it->second.get();\n  }\n  auto context = std::make_unique<Context>(this, root_id, plugin_);\n  auto context_ptr = context.get();\n  root_contexts_[root_id] = std::move(context);\n  context_ptr->onStart(root_id, vm_configuration());\n  return context_ptr;\n};\n\nvoid Wasm::startForTesting(std::unique_ptr<Context> context) {\n  auto context_ptr = context.get();\n  if (!context->wasm_) {\n    // Initialization was delayed till the Wasm object was created.\n    context->wasm_ = this;\n    context->plugin_ = plugin_;\n    context->id_ = allocContextId();\n    contexts_[context->id_] = context.get();\n  }\n  root_contexts_[\"\"] = std::move(context);\n  context_ptr->onStart(\"\", \"\");\n}\n\nvoid Wasm::setTickPeriod(uint32_t context_id, std::chrono::milliseconds new_tick_period) {\n  auto& tick_period = tick_period_[context_id];\n  auto& timer = timer_[context_id];\n  bool was_running = timer && tick_period.count() > 0;\n  tick_period = new_tick_period;\n  if (tick_period.count() > 0 && !was_running) {\n    timer = dispatcher_.createTimer([weak = std::weak_ptr<Wasm>(shared_from_this()), context_id]() {\n      auto shared = weak.lock();\n      if (shared) {\n        shared->tickHandler(context_id);\n      }\n    });\n    timer->enableTimer(tick_period);\n  }\n}\n\nvoid Wasm::tickHandler(uint32_t root_context_id) {\n  auto& tick_period = tick_period_[root_context_id];\n  auto& timer = timer_[root_context_id];\n  if (onTick_) {\n    onTick_(getContext(root_context_id), root_context_id);\n    if (timer && tick_period.count() > 0) {\n      timer->enableTimer(tick_period);\n    }\n  }\n}\n\nuint32_t Wasm::allocContextId() {\n  while (true) {\n    auto id = next_context_id_++;\n    // Prevent reuse.\n    if (contexts_.find(id) == contexts_.end()) {\n      return id;\n    }\n  }\n}\n\nvoid Wasm::queueReady(uint32_t root_context_id, uint32_t token) {\n  auto it = contexts_.find(root_context_id);\n  if (it == contexts_.end() || !it->second->isRootContext()) {\n    return;\n  }\n  it->second->onQueueReady(token);\n}\n\nNetwork::FilterStatus Context::onNewConnection() { return onNetworkNewConnection(); };\n\nNetwork::FilterStatus Context::onData(Buffer::Instance& data, bool end_stream) {\n  network_downstream_data_buffer_ = &data;\n  auto result = onDownstreamData(data.length(), end_stream);\n  network_downstream_data_buffer_ = nullptr;\n  return result;\n}\n\nNetwork::FilterStatus Context::onWrite(Buffer::Instance& data, bool end_stream) {\n  network_upstream_data_buffer_ = &data;\n  auto result = onUpstreamData(data.length(), end_stream);\n  network_upstream_data_buffer_ = nullptr;\n  if (end_stream) {\n    // This is called when seeing end_stream=true and not on an upstream connection event,\n    // because registering for latter requires replicating the whole TCP proxy extension.\n    onUpstreamConnectionClose(PeerType::Unknown);\n  }\n  return result;\n}\n\nvoid Context::onEvent(Network::ConnectionEvent event) {\n  switch (event) {\n  case Network::ConnectionEvent::LocalClose:\n    onDownstreamConnectionClose(PeerType::Local);\n    break;\n  case Network::ConnectionEvent::RemoteClose:\n    onDownstreamConnectionClose(PeerType::Remote);\n    break;\n  default:\n    break;\n  }\n}\n\nvoid Context::initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) {\n  network_read_filter_callbacks_ = &callbacks;\n  network_read_filter_callbacks_->connection().addConnectionCallbacks(*this);\n}\n\nvoid Context::initializeWriteFilterCallbacks(Network::WriteFilterCallbacks& callbacks) {\n  network_write_filter_callbacks_ = &callbacks;\n}\n\nvoid Wasm::log(absl::string_view root_id, const Http::HeaderMap* request_headers,\n               const Http::HeaderMap* response_headers, const Http::HeaderMap* response_trailers,\n               const StreamInfo::StreamInfo& stream_info) {\n  // Check dynamic metadata for the id_ of the stream for this root_id.\n  Context* context = nullptr;\n  auto metadata_it = stream_info.dynamicMetadata().filter_metadata().find(\n      HttpFilters::HttpFilterNames::get().Wasm);\n  if (metadata_it != stream_info.dynamicMetadata().filter_metadata().end()) {\n    auto find_id =\n        metadata_it->second.fields().find(std::string(\"_stream_id_\" + std::string(root_id)));\n    if (find_id != metadata_it->second.fields().end()) {\n      context = getContext(static_cast<uint32_t>(find_id->second.number_value()));\n    }\n  }\n  if (!context) {\n    context = getRootContext(root_id);\n  }\n  context->log(request_headers, response_headers, response_trailers, stream_info);\n}\n\nvoid Context::log(const Http::HeaderMap* request_headers, const Http::HeaderMap* response_headers,\n                  const Http::HeaderMap* response_trailers,\n                  const StreamInfo::StreamInfo& stream_info) {\n  access_log_request_headers_ = request_headers;\n  // ? request_trailers  ?\n  access_log_response_headers_ = response_headers;\n  access_log_response_trailers_ = response_trailers;\n  access_log_stream_info_ = &stream_info;\n\n  onLog();\n\n  access_log_request_headers_ = nullptr;\n  // ? request_trailers  ?\n  access_log_response_headers_ = nullptr;\n  access_log_response_trailers_ = nullptr;\n  access_log_stream_info_ = nullptr;\n\n  onDelete();\n}\n\nvoid Context::onDestroy() {\n  if (destroyed_) {\n    return;\n  }\n  destroyed_ = true;\n  onDone();\n}\n\nvoid Context::onDone() {\n  if (in_vm_context_created_ && wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}\n\nvoid Context::onLog() {\n  if (in_vm_context_created_ && wasm_->onLog_) {\n    wasm_->onLog_(this, id_);\n  }\n}\n\nvoid Context::onDelete() {\n  if (in_vm_context_created_ && wasm_->onDelete_) {\n    wasm_->onDelete_(this, id_);\n  }\n}\n\nHttp::FilterHeadersStatus Context::decodeHeaders(Http::HeaderMap& headers, bool end_stream) {\n  request_headers_ = &headers;\n  request_end_of_stream_ = end_stream;\n  auto result = onRequestHeaders();\n  request_headers_ = nullptr;\n  return result;\n}\n\nHttp::FilterDataStatus Context::decodeData(Buffer::Instance& data, bool end_stream) {\n  requestBodyBuffer_ = &data;\n  auto result = onRequestBody(data.length(), end_stream);\n  requestBodyBuffer_ = nullptr;\n  return result;\n}\n\nHttp::FilterTrailersStatus Context::decodeTrailers(Http::HeaderMap& trailers) {\n  request_trailers_ = &trailers;\n  auto result = onRequestTrailers();\n  request_trailers_ = nullptr;\n  return result;\n}\n\nHttp::FilterMetadataStatus Context::decodeMetadata(Http::MetadataMap& response_metadata) {\n  response_metadata_ = &response_metadata;\n  auto result = onRequestMetadata();\n  response_metadata_ = nullptr;\n  return result;\n}\n\nvoid Context::setDecoderFilterCallbacks(Envoy::Http::StreamDecoderFilterCallbacks& callbacks) {\n  decoder_callbacks_ = &callbacks;\n}\n\nHttp::FilterHeadersStatus Context::encode100ContinueHeaders(Http::HeaderMap&) {\n  return Http::FilterHeadersStatus::Continue;\n}\n\nHttp::FilterHeadersStatus Context::encodeHeaders(Http::HeaderMap& headers, bool end_stream) {\n  response_headers_ = &headers;\n  response_end_of_stream_ = end_stream;\n  auto result = onResponseHeaders();\n  response_headers_ = nullptr;\n  return result;\n}\n\nHttp::FilterDataStatus Context::encodeData(Buffer::Instance& data, bool end_stream) {\n  responseBodyBuffer_ = &data;\n  auto result = onResponseBody(data.length(), end_stream);\n  responseBodyBuffer_ = nullptr;\n  return result;\n}\n\nHttp::FilterTrailersStatus Context::encodeTrailers(Http::HeaderMap& trailers) {\n  response_trailers_ = &trailers;\n  auto result = onResponseTrailers();\n  response_trailers_ = nullptr;\n  return result;\n}\n\nHttp::FilterMetadataStatus Context::encodeMetadata(Http::MetadataMap& response_metadata) {\n  response_metadata_ = &response_metadata;\n  auto result = onResponseMetadata();\n  response_metadata_ = nullptr;\n  return result;\n}\n\n//  Http::FilterMetadataStatus::Continue;\n\nvoid Context::setEncoderFilterCallbacks(Envoy::Http::StreamEncoderFilterCallbacks& callbacks) {\n  encoder_callbacks_ = &callbacks;\n}\n\nvoid Context::onHttpCallSuccess(uint32_t token, Envoy::Http::MessagePtr& response) {\n  auto body =\n      absl::string_view(static_cast<char*>(response->body()->linearize(response->body()->length())),\n                        response->body()->length());\n  onHttpCallResponse(token, headerMapToPairs(&response->headers()), body,\n                     headerMapToPairs(response->trailers()));\n  http_request_.erase(token);\n}\n\nvoid Context::onHttpCallFailure(uint32_t token, Http::AsyncClient::FailureReason /* reason */) {\n  onHttpCallResponse(token, {}, \"\", {});\n  http_request_.erase(token);\n}\n\nvoid AsyncClientHandler::onSuccess(Envoy::Http::MessagePtr&& response) {\n  context->onHttpCallSuccess(token, response);\n}\n\nvoid AsyncClientHandler::onFailure(Http::AsyncClient::FailureReason reason) {\n  context->onHttpCallFailure(token, reason);\n}\n\nvoid GrpcCallClientHandler::onCreateInitialMetadata(Http::HeaderMap& metadata) {\n  context->onGrpcCreateInitialMetadata(token, metadata);\n}\n\nvoid GrpcStreamClientHandler::onCreateInitialMetadata(Http::HeaderMap& metadata) {\n  context->onGrpcCreateInitialMetadata(token, metadata);\n}\n\nvoid GrpcStreamClientHandler::onReceiveInitialMetadata(Http::HeaderMapPtr&& metadata) {\n  context->onGrpcReceiveInitialMetadata(token, std::move(metadata));\n}\n\nvoid GrpcStreamClientHandler::onReceiveTrailingMetadata(Http::HeaderMapPtr&& metadata) {\n  context->onGrpcReceiveTrailingMetadata(token, std::move(metadata));\n}\n\nvoid Context::onGrpcReceive(uint32_t token, Buffer::InstancePtr response) {\n  if (wasm_->onGrpcReceive_) {\n    auto response_size = response->length();\n    auto response_ptr = wasm_->copyBuffer(*response);\n    wasm_->onGrpcReceive_(this, id_, token, response_ptr, response_size);\n  }\n  if (IsGrpcCallToken(token)) {\n    grpc_call_request_.erase(token);\n  }\n}\n\nvoid Context::onGrpcClose(uint32_t token, const Grpc::Status::GrpcStatus& status,\n                          const absl::string_view message) {\n  if (wasm_->onGrpcClose_) {\n    auto message_ptr = wasm_->copyString(message);\n    wasm_->onGrpcClose_(this, id_, token, static_cast<uint64_t>(status), message_ptr,\n                        message.size());\n  }\n  if (IsGrpcCallToken(token)) {\n    grpc_call_request_.erase(token);\n  } else {\n    grpc_stream_.erase(token);\n  }\n}\n\nWasmResult Context::grpcSend(uint32_t token, absl::string_view message, bool end_stream) {\n  if (IsGrpcCallToken(token)) {\n    return WasmResult::BadArgument;\n  }\n  auto it = grpc_stream_.find(token);\n  if (it == grpc_stream_.end()) {\n    return WasmResult::NotFound;\n  }\n  if (it != grpc_stream_.end() && it->second.stream) {\n    it->second.stream->sendMessageRaw(\n        Buffer::InstancePtr(new Buffer::OwnedImpl(message.data(), message.size())), end_stream);\n  }\n  return WasmResult::Ok;\n}\n\nWasmResult Context::grpcClose(uint32_t token) {\n  if (IsGrpcCallToken(token)) {\n    auto it = grpc_call_request_.find(token);\n    if (it == grpc_call_request_.end()) {\n      return WasmResult::NotFound;\n    }\n    if (it != grpc_call_request_.end() && it->second.request) {\n      it->second.request->cancel();\n    }\n    grpc_call_request_.erase(token);\n  } else {\n    auto it = grpc_stream_.find(token);\n    if (it == grpc_stream_.end()) {\n      return WasmResult::NotFound;\n    }\n    if (it != grpc_stream_.end() && it->second.stream) {\n      it->second.stream->closeStream();\n    }\n    grpc_stream_.erase(token);\n  }\n  return WasmResult::Ok;\n}\n\nWasmResult Context::grpcCancel(uint32_t token) {\n  if (IsGrpcCallToken(token)) {\n    auto it = grpc_call_request_.find(token);\n    if (it == grpc_call_request_.end()) {\n      return WasmResult::NotFound;\n    }\n    if (it != grpc_call_request_.end() && it->second.request) {\n      it->second.request->cancel();\n    }\n    grpc_call_request_.erase(token);\n  } else {\n    auto it = grpc_stream_.find(token);\n    if (it == grpc_stream_.end()) {\n      return WasmResult::NotFound;\n    }\n    if (it != grpc_stream_.end() && it->second.stream) {\n      it->second.stream->resetStream();\n    }\n    grpc_stream_.erase(token);\n  }\n  return WasmResult::Ok;\n}\n\nvoid GrpcCallClientHandler::onSuccessRaw(Buffer::InstancePtr&& response, Tracing::Span&) {\n  context->onGrpcReceive(token, std::move(response));\n}\n\nvoid GrpcCallClientHandler::onFailure(Grpc::Status::GrpcStatus status, const std::string& message,\n                                      Tracing::Span&) {\n  context->onGrpcClose(token, status, message);\n}\n\nbool GrpcStreamClientHandler::onReceiveMessageRaw(Buffer::InstancePtr&& response) {\n  context->onGrpcReceive(token, std::move(response));\n  return true;\n}\n\nvoid GrpcStreamClientHandler::onRemoteClose(Grpc::Status::GrpcStatus status,\n                                            const std::string& message) {\n  context->onGrpcClose(token, status, message);\n}\n\nstatic std::shared_ptr<Wasm> createWasmInternal(const envoy::config::wasm::v2::VmConfig& vm_config,\n                                                PluginSharedPtr plugin, Stats::ScopeSharedPtr scope,\n                                                Upstream::ClusterManager& cluster_manager,\n                                                Event::Dispatcher& dispatcher, Api::Api& api,\n                                                std::unique_ptr<Context> root_context_for_testing) {\n  auto wasm =\n      std::make_shared<Wasm>(vm_config.runtime(), vm_config.vm_id(), vm_config.configuration(),\n                             plugin, scope, cluster_manager, dispatcher);\n  const auto& code = Config::DataSource::read(vm_config.code(), true, api);\n  const auto& path = Config::DataSource::getPath(vm_config.code())\n                         .value_or(code.empty() ? EMPTY_STRING : INLINE_STRING);\n  if (code.empty()) {\n    throw WasmException(fmt::format(\"Failed to load WASM code from {}\", path));\n  }\n  if (!wasm->initialize(code, vm_config.allow_precompiled())) {\n    throw WasmException(fmt::format(\"Failed to initialize WASM code from {}\", path));\n  }\n  if (!root_context_for_testing) {\n    wasm->start();\n  } else {\n    wasm->startForTesting(std::move(root_context_for_testing));\n  }\n  return wasm;\n}\n\nstd::shared_ptr<Wasm> createWasm(const envoy::config::wasm::v2::VmConfig& vm_config,\n                                 PluginSharedPtr plugin, Stats::ScopeSharedPtr scope,\n                                 Upstream::ClusterManager& cluster_manager,\n                                 Event::Dispatcher& dispatcher, Api::Api& api) {\n  return createWasmInternal(vm_config, plugin, scope, cluster_manager, dispatcher, api,\n                            nullptr /* root_context_for_testing */);\n} // namespace Wasm\n\nstd::shared_ptr<Wasm> createWasmForTesting(const envoy::config::wasm::v2::VmConfig& vm_config,\n                                           PluginSharedPtr plugin, Stats::ScopeSharedPtr scope,\n                                           Upstream::ClusterManager& cluster_manager,\n                                           Event::Dispatcher& dispatcher, Api::Api& api,\n                                           std::unique_ptr<Context> root_context_for_testing) {\n  return createWasmInternal(vm_config, plugin, scope, cluster_manager, dispatcher, api,\n                            std::move(root_context_for_testing));\n}\n\nstd::shared_ptr<Wasm> createThreadLocalWasm(Wasm& base_wasm, absl::string_view configuration,\n                                            Event::Dispatcher& dispatcher) {\n  auto wasm = std::make_shared<Wasm>(base_wasm, dispatcher);\n  Context* root_context = wasm->start();\n  if (!wasm->configure(root_context, configuration)) {\n    throw WasmException(\"Failed to configure WASM code\");\n  }\n  if (!wasm->vm_id().empty()) {\n    local_wasms[wasm->vm_id()] = wasm;\n  }\n  return wasm;\n}\n\nstd::shared_ptr<Wasm> getThreadLocalWasmPtr(absl::string_view vm_id) {\n  auto it = local_wasms.find(vm_id);\n  if (it == local_wasms.end()) {\n    return nullptr;\n  }\n  auto wasm = it->second.lock();\n  if (!wasm) {\n    local_wasms.erase(vm_id);\n  }\n  return wasm;\n}\n\nstd::shared_ptr<Wasm> getOrCreateThreadLocalWasm(Wasm& base_wasm, absl::string_view configuration,\n                                                 Event::Dispatcher& dispatcher) {\n  auto wasm = getThreadLocalWasmPtr(base_wasm.vm_id());\n  if (wasm) {\n    auto root_context = wasm->start();\n    if (!wasm->configure(root_context, configuration)) {\n      throw WasmException(\"Failed to configure WASM code\");\n    }\n    return wasm;\n  }\n  return createThreadLocalWasm(base_wasm, configuration, dispatcher);\n}\n\n} // namespace Wasm\n} // namespace Common\n} // namespace Extensions\n} // namespace Envoy\n", "#pragma once\n\n#include <map>\n#include <memory>\n\n#include \"envoy/access_log/access_log.h\"\n#include \"envoy/buffer/buffer.h\"\n#include \"envoy/common/exception.h\"\n#include \"envoy/config/wasm/v2/wasm.pb.validate.h\"\n#include \"envoy/http/filter.h\"\n#include \"envoy/server/wasm.h\"\n#include \"envoy/stats/scope.h\"\n#include \"envoy/stats/stats.h\"\n#include \"envoy/thread_local/thread_local.h\"\n#include \"envoy/upstream/cluster_manager.h\"\n\n#include \"common/common/assert.h\"\n#include \"common/common/logger.h\"\n#include \"common/common/stack_array.h\"\n#include \"common/stats/symbol_table_impl.h\"\n\n#include \"extensions/common/wasm/wasm_vm.h\"\n#include \"extensions/common/wasm/well_known_names.h\"\n#include \"extensions/filters/http/well_known_names.h\"\n\nnamespace Envoy {\n\n// TODO: move to source/common/stats/symbol_table_impl.h when upstreaming.\nnamespace Stats {\nusing StatNameSetSharedPtr = std::shared_ptr<Stats::StatNameSet>;\n} // namespace Stats\n\nnamespace Extensions {\nnamespace Common {\nnamespace Wasm {\n\n#include \"api/wasm/cpp/proxy_wasm_result.h\"\n#include \"api/wasm/cpp/proxy_wasm_metadata.h\"\n\nclass Context;\nclass Wasm;\nclass WasmVm;\n\nusing Pairs = std::vector<std::pair<absl::string_view, absl::string_view>>;\nusing PairsWithStringValues = std::vector<std::pair<absl::string_view, std::string>>;\n\nenum class StreamType : int32_t { Request = 0, Response = 1, MAX = 1 };\n\n// Handlers for functions exported from envoy to wasm.\nWord logHandler(void* raw_context, Word level, Word address, Word size);\nWord getPropertyHandler(void* raw_context, Word path_ptr, Word path_size, Word value_ptr_ptr,\n                        Word value_size_ptr);\nWord setPropertyHandler(void* raw_context, Word key_ptr, Word key_size, Word value_ptr,\n                        Word value_size);\nWord continueRequestHandler(void* raw_context);\nWord continueResponseHandler(void* raw_context);\nWord sendLocalResponseHandler(void* raw_context, Word response_code, Word response_code_details_ptr,\n                              Word response_code_details_size, Word body_ptr, Word body_size,\n                              Word additional_response_header_pairs_ptr,\n                              Word additional_response_header_pairs_size, Word grpc_status);\nWord clearRouteCacheHandler(void* raw_context);\nWord getSharedDataHandler(void* raw_context, Word key_ptr, Word key_size, Word value_ptr_ptr,\n                          Word value_size_ptr, Word cas_ptr);\nWord setSharedDataHandler(void* raw_context, Word key_ptr, Word key_size, Word value_ptr,\n                          Word value_size, Word cas);\nWord registerSharedQueueHandler(void* raw_context, Word queue_name_ptr, Word queue_name_size,\n                                Word token_ptr);\nWord resolveSharedQueueHandler(void* raw_context, Word vm_id_ptr, Word vm_id_size,\n                               Word queue_name_ptr, Word queue_name_size, Word token_ptr);\nWord dequeueSharedQueueHandler(void* raw_context, Word token, Word data_ptr_ptr,\n                               Word data_size_ptr);\nWord enqueueSharedQueueHandler(void* raw_context, Word token, Word data_ptr, Word data_size);\nWord getDownstreamDataBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                         Word size_ptr);\nWord getUpstreamDataBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                       Word size_ptr);\nWord addHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size,\n                              Word value_ptr, Word value_size);\nWord getHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size,\n                              Word value_ptr_ptr, Word value_size_ptr);\nWord replaceHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size,\n                                  Word value_ptr, Word value_size);\nWord removeHeaderMapValueHandler(void* raw_context, Word type, Word key_ptr, Word key_size);\nWord getHeaderMapPairsHandler(void* raw_context, Word type, Word ptr_ptr, Word size_ptr);\nWord setHeaderMapPairsHandler(void* raw_context, Word type, Word ptr, Word size);\nWord getHeaderMapSizeHandler(void* raw_context, Word type, Word result_ptr);\nWord getRequestBodyBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                      Word size_ptr);\nWord getResponseBodyBufferBytesHandler(void* raw_context, Word start, Word length, Word ptr_ptr,\n                                       Word size_ptr);\nWord httpCallHandler(void* raw_context, Word uri_ptr, Word uri_size, Word header_pairs_ptr,\n                     Word header_pairs_size, Word body_ptr, Word body_size, Word trailer_pairs_ptr,\n                     Word trailer_pairs_size, Word timeout_milliseconds);\nWord defineMetricHandler(void* raw_context, Word metric_type, Word name_ptr, Word name_size,\n                         Word result_ptr);\nWord incrementMetricHandler(void* raw_context, Word metric_id, int64_t offset);\nWord recordMetricHandler(void* raw_context, Word metric_id, uint64_t value);\nWord getMetricHandler(void* raw_context, Word metric_id, Word result_uint64_ptr);\nWord grpcCallHandler(void* raw_context, Word service_ptr, Word service_size, Word service_name_ptr,\n                     Word service_name_size, Word method_name_ptr, Word method_name_size,\n                     Word request_ptr, Word request_size, Word timeout_milliseconds);\nWord grpcStreamHandler(void* raw_context, Word service_ptr, Word service_size,\n                       Word service_name_ptr, Word service_name_size, Word method_name_ptr,\n                       Word method_name_size);\nWord grpcCancelHandler(void* raw_context, Word token);\nWord grpcCloseHandler(void* raw_context, Word token);\nWord grpcSendHandler(void* raw_context, Word token, Word message_ptr, Word message_size,\n                     Word end_stream);\n\nWord setTickPeriodMillisecondsHandler(void* raw_context, Word tick_period_milliseconds);\nWord getCurrentTimeNanosecondsHandler(void* raw_context, Word result_uint64_ptr);\n\nWord setEffectiveContextHandler(void* raw_context, Word context_id);\n\ninline MetadataType StreamType2MetadataType(StreamType type) {\n  return static_cast<MetadataType>(type);\n}\n\nstruct AsyncClientHandler : public Http::AsyncClient::Callbacks {\n  // Http::AsyncClient::Callbacks\n  void onSuccess(Envoy::Http::MessagePtr&& response) override;\n  void onFailure(Http::AsyncClient::FailureReason reason) override;\n\n  Context* context;\n  uint32_t token;\n  Http::AsyncClient::Request* request;\n};\n\nstruct GrpcCallClientHandler : public Grpc::RawAsyncRequestCallbacks {\n  // Grpc::AsyncRequestCallbacks\n  void onCreateInitialMetadata(Http::HeaderMap& metadata) override;\n  void onSuccessRaw(Buffer::InstancePtr&& response, Tracing::Span& span) override;\n  void onFailure(Grpc::Status::GrpcStatus status, const std::string& message,\n                 Tracing::Span& span) override;\n\n  Context* context;\n  uint32_t token;\n  Grpc::RawAsyncClientPtr client;\n  Grpc::AsyncRequest* request;\n};\n\nstruct GrpcStreamClientHandler : public Grpc::RawAsyncStreamCallbacks {\n  // Grpc::AsyncStreamCallbacks\n  void onCreateInitialMetadata(Http::HeaderMap& metadata) override;\n  void onReceiveInitialMetadata(Http::HeaderMapPtr&& metadata) override;\n  bool onReceiveMessageRaw(Buffer::InstancePtr&& response) override;\n  void onReceiveTrailingMetadata(Http::HeaderMapPtr&& metadata) override;\n  void onRemoteClose(Grpc::Status::GrpcStatus status, const std::string& message) override;\n\n  Context* context;\n  uint32_t token;\n  Grpc::RawAsyncClientPtr client;\n  Grpc::RawAsyncStream* stream;\n};\n\n// Plugin contains the information for a filter/service.\nstruct Plugin {\n  Plugin(absl::string_view name, absl::string_view root_id, absl::string_view vm_id,\n         envoy::api::v2::core::TrafficDirection direction, const LocalInfo::LocalInfo& local_info,\n         const envoy::api::v2::core::Metadata* listener_metadata)\n      : name_(std::string(name)), root_id_(std::string(root_id)), vm_id_(std::string(vm_id)),\n        direction_(direction), local_info_(local_info), listener_metadata_(listener_metadata),\n        log_prefix_(makeLogPrefix()) {}\n\n  std::string makeLogPrefix() const;\n\n  const std::string name_;\n  const std::string root_id_;\n  const std::string vm_id_;\n  envoy::api::v2::core::TrafficDirection direction_;\n  const LocalInfo::LocalInfo& local_info_;\n  const envoy::api::v2::core::Metadata* listener_metadata_;\n\n  std::string log_prefix_;\n};\nusing PluginSharedPtr = std::shared_ptr<Plugin>;\n\n// A context which will be the target of callbacks for a particular session\n// e.g. a handler of a stream.\nclass Context : public Logger::Loggable<Logger::Id::wasm>,\n                public AccessLog::Instance,\n                public Http::StreamFilter,\n                public Network::ConnectionCallbacks,\n                public Network::Filter,\n                public std::enable_shared_from_this<Context> {\npublic:\n  Context();                                                              // Testing.\n  Context(Wasm* wasm);                                                    // Vm Context.\n  Context(Wasm* wasm, absl::string_view root_id, PluginSharedPtr plugin); // Root Context.\n  Context(Wasm* wasm, uint32_t root_context_id, PluginSharedPtr plugin);  // Stream context.\n  ~Context();\n\n  Wasm* wasm() const { return wasm_; }\n  uint32_t id() const { return id_; }\n  bool isVmContext() { return id_ == 0; }\n  bool isRootContext() { return root_context_id_ == 0; }\n  Context* root_context() { return root_context_; }\n\n  absl::string_view root_id() const { return plugin_->root_id_; }\n  absl::string_view log_prefix() const { return plugin_->log_prefix_; }\n\n  WasmVm* wasmVm() const;\n  Upstream::ClusterManager& clusterManager() const;\n\n  // Retrieves the stream info associated with the request (a.k.a active stream).\n  // It selects a value based on the following order: encoder callback, decoder\n  // callback, log callback. As long as any one of the callbacks is invoked, the value should be\n  // available.\n  const StreamInfo::StreamInfo* getConstRequestStreamInfo() const;\n  StreamInfo::StreamInfo* getRequestStreamInfo() const;\n\n  //\n  // VM level downcalls into the WASM code on Context(id == 0).\n  //\n  virtual bool validateConfiguration(absl::string_view configuration);\n  virtual void onStart(absl::string_view root_id, absl::string_view vm_configuration);\n  virtual bool onConfigure(absl::string_view configuration);\n\n  //\n  // Stream downcalls on Context(id > 0).\n  //\n  // General stream downcall on a new stream.\n  virtual void onCreate(uint32_t root_context_id);\n  // Network\n  virtual Network::FilterStatus onNetworkNewConnection();\n  virtual Network::FilterStatus onDownstreamData(int data_length, bool end_of_stream);\n  virtual Network::FilterStatus onUpstreamData(int data_length, bool end_of_stream);\n  enum class PeerType : uint32_t {\n    Unknown = 0,\n    Local = 1,\n    Remote = 2,\n  };\n  virtual void onDownstreamConnectionClose(PeerType);\n  virtual void onUpstreamConnectionClose(PeerType);\n  // HTTP Filter Stream Request Downcalls.\n  virtual Http::FilterHeadersStatus onRequestHeaders();\n  virtual Http::FilterDataStatus onRequestBody(int body_buffer_length, bool end_of_stream);\n  virtual Http::FilterTrailersStatus onRequestTrailers();\n  virtual Http::FilterMetadataStatus onRequestMetadata();\n  // HTTP Filter Stream Response Downcalls.\n  virtual Http::FilterHeadersStatus onResponseHeaders();\n  virtual Http::FilterDataStatus onResponseBody(int body_buffer_length, bool end_of_stream);\n  virtual Http::FilterTrailersStatus onResponseTrailers();\n  virtual Http::FilterMetadataStatus onResponseMetadata();\n  // Async Response Downcalls on any Context.\n  virtual void onHttpCallResponse(uint32_t token, const Pairs& response_headers,\n                                  absl::string_view response_body, const Pairs& response_trailers);\n  virtual void onQueueReady(uint32_t token);\n  // General stream downcall when the stream has ended.\n  virtual void onDone();\n  // General stream downcall for logging. Occurs after onDone().\n  virtual void onLog();\n  // General stream downcall when no further stream calls will occur.\n  virtual void onDelete();\n\n  //\n  // General Callbacks.\n  //\n  virtual void scriptLog(spdlog::level::level_enum level, absl::string_view message);\n  virtual WasmResult setTickPeriod(std::chrono::milliseconds tick_period);\n  virtual uint64_t getCurrentTimeNanoseconds();\n\n  //\n  // AccessLog::Instance\n  //\n  void log(const Http::HeaderMap* request_headers, const Http::HeaderMap* response_headers,\n           const Http::HeaderMap* response_trailers,\n           const StreamInfo::StreamInfo& stream_info) override;\n\n  //\n  // Network::ConnectionCallbacks\n  //\n  void onEvent(Network::ConnectionEvent event) override;\n  void onAboveWriteBufferHighWatermark() override {}\n  void onBelowWriteBufferLowWatermark() override {}\n\n  //\n  // Network::ReadFilter\n  //\n  Network::FilterStatus onNewConnection() override;\n  Network::FilterStatus onData(Buffer::Instance& data, bool end_stream) override;\n  void initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) override;\n\n  //\n  // Network::WriteFilter\n  //\n  Network::FilterStatus onWrite(Buffer::Instance& data, bool end_stream) override;\n  void initializeWriteFilterCallbacks(Network::WriteFilterCallbacks& callbacks) override;\n\n  //\n  // Http::StreamFilterBase\n  //\n  // Note: This calls onDone() in WASM.\n  void onDestroy() override;\n\n  //\n  // Http::StreamDecoderFilter\n  //\n  Http::FilterHeadersStatus decodeHeaders(Http::HeaderMap& headers, bool end_stream) override;\n  Http::FilterDataStatus decodeData(Buffer::Instance& data, bool end_stream) override;\n  Http::FilterTrailersStatus decodeTrailers(Http::HeaderMap& trailers) override;\n  Http::FilterMetadataStatus decodeMetadata(Http::MetadataMap& metadata_map) override;\n  void setDecoderFilterCallbacks(Envoy::Http::StreamDecoderFilterCallbacks& callbacks) override;\n\n  //\n  // Http::StreamEncoderFilter\n  //\n  Http::FilterHeadersStatus encode100ContinueHeaders(Http::HeaderMap&) override;\n  Http::FilterHeadersStatus encodeHeaders(Http::HeaderMap& headers, bool end_stream) override;\n  Http::FilterDataStatus encodeData(Buffer::Instance& data, bool end_stream) override;\n  Http::FilterTrailersStatus encodeTrailers(Http::HeaderMap& trailers) override;\n  Http::FilterMetadataStatus encodeMetadata(Http::MetadataMap& metadata_map) override;\n  void setEncoderFilterCallbacks(Envoy::Http::StreamEncoderFilterCallbacks& callbacks) override;\n\n  //\n  // HTTP Filter Callbacks\n  //\n\n  // State accessors\n  virtual WasmResult getProperty(absl::string_view path, std::string* result);\n  virtual WasmResult setProperty(absl::string_view key, absl::string_view serialized_value);\n\n  // Continue\n  virtual void continueRequest() {\n    if (decoder_callbacks_)\n      decoder_callbacks_->continueDecoding();\n  }\n  virtual void continueResponse() {\n    if (encoder_callbacks_)\n      encoder_callbacks_->continueEncoding();\n  }\n  virtual void sendLocalResponse(Http::Code response_code, absl::string_view body_text,\n                                 std::function<void(Http::HeaderMap& headers)> modify_headers,\n                                 const absl::optional<Grpc::Status::GrpcStatus> grpc_status,\n                                 absl::string_view details) {\n    if (decoder_callbacks_)\n      decoder_callbacks_->sendLocalReply(response_code, body_text, modify_headers, grpc_status,\n                                         details);\n  }\n  virtual void clearRouteCache() {\n    if (decoder_callbacks_)\n      decoder_callbacks_->clearRouteCache();\n  }\n\n  // Shared Data\n  virtual WasmResult getSharedData(absl::string_view key,\n                                   std::pair<std::string, uint32_t /* cas */>* data);\n  virtual WasmResult setSharedData(absl::string_view key, absl::string_view value, uint32_t cas);\n\n  // Shared Queue\n  virtual uint32_t registerSharedQueue(absl::string_view queue_name);\n  virtual WasmResult resolveSharedQueue(absl::string_view vm_id, absl::string_view queue_name,\n                                        uint32_t* token);\n  virtual WasmResult dequeueSharedQueue(uint32_t token, std::string* data);\n  virtual WasmResult enqueueSharedQueue(uint32_t token, absl::string_view value);\n\n  // Network\n  virtual WasmResult getDownstreamDataBufferBytes(uint32_t start, uint32_t length,\n                                                  absl::string_view* data);\n  virtual WasmResult getUpstreamDataBufferBytes(uint32_t start, uint32_t length,\n                                                absl::string_view* data);\n\n  // Header/Trailer/Metadata Maps\n  virtual void addHeaderMapValue(HeaderMapType type, absl::string_view key,\n                                 absl::string_view value);\n  virtual absl::string_view getHeaderMapValue(HeaderMapType type, absl::string_view key);\n  virtual Pairs getHeaderMapPairs(HeaderMapType type);\n  virtual void setHeaderMapPairs(HeaderMapType type, const Pairs& pairs);\n\n  virtual void removeHeaderMapValue(HeaderMapType type, absl::string_view key);\n  virtual void replaceHeaderMapValue(HeaderMapType type, absl::string_view key,\n                                     absl::string_view value);\n\n  virtual uint32_t getHeaderMapSize(HeaderMapType type);\n\n  // Body Buffer\n  virtual absl::string_view getRequestBodyBufferBytes(uint32_t start, uint32_t length);\n  virtual absl::string_view getResponseBodyBufferBytes(uint32_t start, uint32_t length);\n\n  // HTTP\n  // Returns a token which will be used with the corresponding onHttpCallResponse.\n  virtual uint32_t httpCall(absl::string_view cluster, const Pairs& request_headers,\n                            absl::string_view request_body, const Pairs& request_trailers,\n                            int timeout_millisconds);\n  virtual void httpRespond(const Pairs& response_headers, absl::string_view body,\n                           const Pairs& response_trailers);\n\n  // Stats/Metrics\n  enum class MetricType : uint32_t {\n    Counter = 0,\n    Gauge = 1,\n    Histogram = 2,\n    Max = 2,\n  };\n  virtual WasmResult defineMetric(MetricType type, absl::string_view name, uint32_t* metric_id_ptr);\n  virtual WasmResult incrementMetric(uint32_t metric_id, int64_t offset);\n  virtual WasmResult recordMetric(uint32_t metric_id, uint64_t value);\n  virtual WasmResult getMetric(uint32_t metric_id, uint64_t* value_ptr);\n\n  // gRPC\n  // Returns a token which will be used with the corresponding onGrpc and grpc calls.\n  virtual uint32_t grpcCall(const envoy::api::v2::core::GrpcService& grpc_service,\n                            absl::string_view service_name, absl::string_view method_name,\n                            absl::string_view request,\n                            const absl::optional<std::chrono::milliseconds>& timeout);\n  virtual uint32_t grpcStream(const envoy::api::v2::core::GrpcService& grpc_service,\n                              absl::string_view service_name, absl::string_view method_name);\n  virtual WasmResult grpcClose(uint32_t token);  // cancel on call, close on stream.\n  virtual WasmResult grpcCancel(uint32_t token); // cancel on call, reset on stream.\n  virtual WasmResult grpcSend(uint32_t token, absl::string_view message,\n                              bool end_stream); // stream only\n\n  // Connection\n  virtual bool isSsl();\n\n  void setInVmContextCreatedForTesting() { in_vm_context_created_ = true; }\n\nprotected:\n  friend class Wasm;\n  friend struct AsyncClientHandler;\n  friend struct GrpcCallClientHandler;\n  friend struct GrpcStreamClientHandler;\n\n  void onHttpCallSuccess(uint32_t token, Envoy::Http::MessagePtr& response);\n  void onHttpCallFailure(uint32_t token, Http::AsyncClient::FailureReason reason);\n\n  virtual void onGrpcCreateInitialMetadata(uint32_t token,\n                                           Http::HeaderMap& metadata); // For both Call and Stream.\n  virtual void onGrpcReceive(uint32_t token,\n                             Buffer::InstancePtr response); // Call (implies OK close) and Stream.\n  virtual void onGrpcClose(uint32_t token, const Grpc::Status::GrpcStatus& status,\n                           const absl::string_view message); // Call (not OK) and Stream.\n\n  virtual void onGrpcReceiveInitialMetadata(uint32_t token,\n                                            Http::HeaderMapPtr&& metadata); // Stream only.\n  virtual void onGrpcReceiveTrailingMetadata(uint32_t token,\n                                             Http::HeaderMapPtr&& metadata); // Stream only.\n\n  bool IsGrpcStreamToken(uint32_t token) { return (token & 1) == 0; }\n  bool IsGrpcCallToken(uint32_t token) { return (token & 1) == 1; }\n\n  Http::HeaderMap* getMap(HeaderMapType type);\n  const Http::HeaderMap* getConstMap(HeaderMapType type);\n\n  Wasm* wasm_{nullptr};\n  uint32_t id_{0};\n  uint32_t root_context_id_{0};    // 0 for roots and the general context.\n  Context* root_context_{nullptr}; // set in all contexts.\n  PluginSharedPtr plugin_;\n  bool in_vm_context_created_ = false;\n  bool destroyed_ = false;\n\n  uint32_t next_http_call_token_ = 1;\n  uint32_t next_grpc_token_ = 1; // Odd tokens are for Calls even for Streams.\n\n  // MB: must be a node-type map as we take persistent references to the entries.\n  std::map<uint32_t, AsyncClientHandler> http_request_;\n  std::map<uint32_t, GrpcCallClientHandler> grpc_call_request_;\n  std::map<uint32_t, GrpcStreamClientHandler> grpc_stream_;\n  Envoy::Http::StreamDecoderFilterCallbacks* decoder_callbacks_{};\n  Envoy::Http::StreamEncoderFilterCallbacks* encoder_callbacks_{};\n\n  // Network filter state.\n  Network::ReadFilterCallbacks* network_read_filter_callbacks_{};\n  Network::WriteFilterCallbacks* network_write_filter_callbacks_{};\n  Buffer::Instance* network_downstream_data_buffer_{};\n  Buffer::Instance* network_upstream_data_buffer_{};\n\n  // HTTP Filter state.\n  Http::HeaderMap* request_headers_{};\n  Http::HeaderMap* response_headers_{};\n  Buffer::Instance* requestBodyBuffer_{};\n  Buffer::Instance* responseBodyBuffer_{};\n  bool request_end_of_stream_{};\n  bool response_end_of_stream_{};\n  Http::HeaderMap* request_trailers_{};\n  Http::HeaderMap* response_trailers_{};\n  Http::MetadataMap* request_metadata_{};\n  Http::MetadataMap* response_metadata_{};\n\n  Http::HeaderMap* grpc_create_initial_metadata_{};\n  Http::HeaderMapPtr grpc_receive_initial_metadata_{};\n  Http::HeaderMapPtr grpc_receive_trailing_metadata_{};\n\n  const StreamInfo::StreamInfo* access_log_stream_info_{};\n  const Http::HeaderMap* access_log_request_headers_{};\n  const Http::HeaderMap* access_log_response_headers_{};\n  const Http::HeaderMap* access_log_request_trailers_{}; // unused\n  const Http::HeaderMap* access_log_response_trailers_{};\n\n  ProtobufWkt::Struct temporary_metadata_;\n};\n\n// Wasm execution instance. Manages the Envoy side of the Wasm interface.\nclass Wasm : public Envoy::Server::Wasm,\n             public ThreadLocal::ThreadLocalObject,\n             public Logger::Loggable<Logger::Id::wasm>,\n             public std::enable_shared_from_this<Wasm> {\npublic:\n  Wasm(absl::string_view runtime, absl::string_view vm_id, absl::string_view vm_configuration,\n       PluginSharedPtr plugin, Stats::ScopeSharedPtr scope,\n       Upstream::ClusterManager& cluster_manager, Event::Dispatcher& dispatcher);\n  Wasm(const Wasm& other, Event::Dispatcher& dispatcher);\n  ~Wasm() {}\n\n  bool initialize(const std::string& code, bool allow_precompiled = false);\n  void startVm(Context* root_context);\n  bool configure(Context* root_context, absl::string_view configuration);\n  Context* start(); // returns the root Context.\n\n  absl::string_view vm_id() const { return vm_id_; }\n  const PluginSharedPtr& plugin() const { return plugin_; }\n  void setPlugin(const PluginSharedPtr plugin) { plugin_ = plugin; }\n  WasmVm* wasmVm() const { return wasm_vm_.get(); }\n  Context* vmContext() const { return vm_context_.get(); }\n  Stats::StatNameSetSharedPtr stat_name_set() const { return stat_name_set_; }\n  Context* getRootContext(absl::string_view root_id) { return root_contexts_[root_id].get(); }\n  Context* getContext(uint32_t id) {\n    auto it = contexts_.find(id);\n    if (it != contexts_.end())\n      return it->second;\n    return nullptr;\n  }\n  Upstream::ClusterManager& clusterManager() const { return cluster_manager_; }\n  void setTickPeriod(uint32_t root_context_id, std::chrono::milliseconds tick_period);\n  void tickHandler(uint32_t root_context_id);\n  void queueReady(uint32_t root_context_id, uint32_t token);\n\n  uint32_t allocContextId();\n\n  const std::string& code() const { return code_; }\n  const std::string& vm_configuration() const { return vm_configuration_; }\n  bool allow_precompiled() const { return allow_precompiled_; }\n  void setInitialConfiguration(const std::string& vm_configuration) {\n    vm_configuration_ = vm_configuration;\n  }\n\n  //\n  // AccessLog::Instance\n  //\n  void log(absl::string_view root_id, const Http::HeaderMap* request_headers,\n           const Http::HeaderMap* response_headers, const Http::HeaderMap* response_trailers,\n           const StreamInfo::StreamInfo& stream_info);\n\n  // Support functions.\n  void* allocMemory(uint64_t size, uint64_t* address);\n  // Allocate a null-terminated string in the VM and return the pointer to use as a call arguments.\n  uint64_t copyString(absl::string_view s);\n  uint64_t copyBuffer(const Buffer::Instance& buffer);\n  // Copy the data in 's' into the VM along with the pointer-size pair. Returns true on success.\n  bool copyToPointerSize(absl::string_view s, uint64_t ptr_ptr, uint64_t size_ptr);\n  bool copyToPointerSize(const Buffer::Instance& buffer, uint64_t start, uint64_t length,\n                         uint64_t ptr_ptr, uint64_t size_ptr);\n  template <typename T> bool setDatatype(uint64_t ptr, const T& t);\n\n  // For testing.\n  void setContext(Context* context) { contexts_[context->id()] = context; }\n  void startForTesting(std::unique_ptr<Context> root_context);\n\n  bool getEmscriptenVersion(uint32_t* emscripten_metadata_major_version,\n                            uint32_t* emscripten_metadata_minor_version,\n                            uint32_t* emscripten_abi_major_version,\n                            uint32_t* emscripten_abi_minor_version) {\n    if (!is_emscripten_) {\n      return false;\n    }\n    *emscripten_metadata_major_version = emscripten_metadata_major_version_;\n    *emscripten_metadata_minor_version = emscripten_metadata_minor_version_;\n    *emscripten_abi_major_version = emscripten_abi_major_version_;\n    *emscripten_abi_minor_version = emscripten_abi_minor_version_;\n    return true;\n  }\n\nprivate:\n  friend class Context;\n  // These are the same as the values of the Context::MetricType enum, here separately for\n  // convenience.\n  static const uint32_t kMetricTypeCounter = 0x0;\n  static const uint32_t kMetricTypeGauge = 0x1;\n  static const uint32_t kMetricTypeHistogram = 0x2;\n  static const uint32_t kMetricTypeMask = 0x3;\n  static const uint32_t kMetricIdIncrement = 0x4;\n  static void StaticAsserts() {\n    static_assert(static_cast<uint32_t>(Context::MetricType::Counter) == kMetricTypeCounter, \"\");\n    static_assert(static_cast<uint32_t>(Context::MetricType::Gauge) == kMetricTypeGauge, \"\");\n    static_assert(static_cast<uint32_t>(Context::MetricType::Histogram) == kMetricTypeHistogram,\n                  \"\");\n  }\n\n  bool isCounterMetricId(uint32_t metric_id) {\n    return (metric_id & kMetricTypeMask) == kMetricTypeCounter;\n  }\n  bool isGaugeMetricId(uint32_t metric_id) {\n    return (metric_id & kMetricTypeMask) == kMetricTypeGauge;\n  }\n  bool isHistogramMetricId(uint32_t metric_id) {\n    return (metric_id & kMetricTypeMask) == kMetricTypeHistogram;\n  }\n  uint32_t nextCounterMetricId() { return next_counter_metric_id_ += kMetricIdIncrement; }\n  uint32_t nextGaugeMetricId() { return next_gauge_metric_id_ += kMetricIdIncrement; }\n  uint32_t nextHistogramMetricId() { return next_histogram_metric_id_ += kMetricIdIncrement; }\n\n  void registerCallbacks();    // Register functions called out from WASM.\n  void establishEnvironment(); // Language specific environments.\n  void getFunctions();         // Get functions call into WASM.\n\n  std::string vm_id_; // The effective vm_id (may be a hash).\n  std::unique_ptr<WasmVm> wasm_vm_;\n\n  PluginSharedPtr plugin_;\n  Stats::ScopeSharedPtr scope_;\n\n  Upstream::ClusterManager& cluster_manager_;\n  Event::Dispatcher& dispatcher_;\n\n  uint32_t next_context_id_ = 1;        // 0 is reserved for the VM context.\n  std::shared_ptr<Context> vm_context_; // Context unrelated to any specific root or stream\n                                        // (e.g. for global constructors).\n  absl::flat_hash_map<std::string, std::unique_ptr<Context>> root_contexts_;\n  absl::flat_hash_map<uint32_t, Context*> contexts_;                    // Contains all contexts.\n  std::unordered_map<uint32_t, std::chrono::milliseconds> tick_period_; // per root_id.\n  std::unordered_map<uint32_t, Event::TimerPtr> timer_;                 // per root_id.\n\n  TimeSource& time_source_;\n\n  WasmCallVoid<0> _start_; /* Emscripten v1.39.0+ */\n  WasmCallVoid<0> __wasm_call_ctors_;\n\n  WasmCallWord<1> malloc_;\n  WasmCallVoid<1> free_;\n\n  // Calls into the VM.\n  WasmCallWord<3> validateConfiguration_;\n  WasmCallVoid<5> onStart_;\n  WasmCallWord<3> onConfigure_;\n  WasmCallVoid<1> onTick_;\n\n  WasmCallVoid<2> onCreate_;\n\n  WasmCallWord<1> onNewConnection_;\n  WasmCallWord<3> onDownstreamData_;\n  WasmCallWord<3> onUpstreamData_;\n  WasmCallVoid<2> onDownstreamConnectionClose_;\n  WasmCallVoid<2> onUpstreamConnectionClose_;\n\n  WasmCallWord<1> onRequestHeaders_;\n  WasmCallWord<3> onRequestBody_;\n  WasmCallWord<1> onRequestTrailers_;\n  WasmCallWord<1> onRequestMetadata_;\n\n  WasmCallWord<1> onResponseHeaders_;\n  WasmCallWord<3> onResponseBody_;\n  WasmCallWord<1> onResponseTrailers_;\n  WasmCallWord<1> onResponseMetadata_;\n\n  WasmCallVoid<8> onHttpCallResponse_;\n\n  WasmCallVoid<4> onGrpcReceive_;\n  WasmCallVoid<5> onGrpcClose_;\n  WasmCallVoid<2> onGrpcCreateInitialMetadata_;\n  WasmCallVoid<2> onGrpcReceiveInitialMetadata_;\n  WasmCallVoid<2> onGrpcReceiveTrailingMetadata_;\n\n  WasmCallVoid<2> onQueueReady_;\n\n  WasmCallVoid<1> onDone_;\n  WasmCallVoid<1> onLog_;\n  WasmCallVoid<1> onDelete_;\n\n  // Used by the base_wasm to enable non-clonable thread local Wasm(s) to be constructed.\n  std::string code_;\n  std::string vm_configuration_;\n  bool allow_precompiled_ = false;\n\n  bool is_emscripten_ = false;\n  uint32_t emscripten_metadata_major_version_ = 0;\n  uint32_t emscripten_metadata_minor_version_ = 0;\n  uint32_t emscripten_abi_major_version_ = 0;\n  uint32_t emscripten_abi_minor_version_ = 0;\n  uint32_t emscripten_standalone_wasm_ = 0;\n\n  // Stats/Metrics\n  Stats::StatNameSetSharedPtr stat_name_set_;\n  uint32_t next_counter_metric_id_ = kMetricTypeCounter;\n  uint32_t next_gauge_metric_id_ = kMetricTypeGauge;\n  uint32_t next_histogram_metric_id_ = kMetricTypeHistogram;\n  absl::flat_hash_map<uint32_t, Stats::Counter*> counters_;\n  absl::flat_hash_map<uint32_t, Stats::Gauge*> gauges_;\n  absl::flat_hash_map<uint32_t, Stats::Histogram*> histograms_;\n};\n\n// These accessors require Wasm.\ninline WasmVm* Context::wasmVm() const { return wasm_->wasmVm(); }\ninline Upstream::ClusterManager& Context::clusterManager() const { return wasm_->clusterManager(); }\n\n// Create a high level Wasm VM with Envoy API support. Note: 'id' may be empty if this VM will not\n// be shared by APIs (e.g. HTTP Filter + AccessLog).\nstd::shared_ptr<Wasm> createWasm(const envoy::config::wasm::v2::VmConfig& vm_config,\n                                 PluginSharedPtr plugin_config, Stats::ScopeSharedPtr scope,\n                                 Upstream::ClusterManager& cluster_manager,\n                                 Event::Dispatcher& dispatcher, Api::Api& api);\n\n// Create a ThreadLocal VM from an existing VM (e.g. from createWasm() above).\nstd::shared_ptr<Wasm> createThreadLocalWasm(Wasm& base_wasm, absl::string_view configuration,\n                                            Event::Dispatcher& dispatcher);\n\nstd::shared_ptr<Wasm> createWasmForTesting(const envoy::config::wasm::v2::VmConfig& vm_config,\n                                           PluginSharedPtr plugin, Stats::ScopeSharedPtr scope,\n                                           Upstream::ClusterManager& cluster_manager,\n                                           Event::Dispatcher& dispatcher, Api::Api& api,\n                                           std::unique_ptr<Context> root_context_for_testing);\n\n// Get an existing ThreadLocal VM matching 'vm_id' or nullptr if there isn't one.\nstd::shared_ptr<Wasm> getThreadLocalWasmPtr(absl::string_view vm_id);\n// Get an existing ThreadLocal VM matching 'vm_id' or create one using 'base_wavm' by cloning or by\n// using it it as a template.\nstd::shared_ptr<Wasm> getOrCreateThreadLocalWasm(Wasm& base_wasm, absl::string_view configuration,\n                                                 Event::Dispatcher& dispatcher);\n\nuint32_t resolveQueueForTest(absl::string_view vm_id, absl::string_view queue_name);\n\ninline Context::Context() : root_context_(this) {}\n\ninline Context::Context(Wasm* wasm) : wasm_(wasm), root_context_(this), plugin_(wasm->plugin()) {\n  wasm_->contexts_[id_] = this;\n}\n\ninline Context::Context(Wasm* wasm, absl::string_view root_id, PluginSharedPtr plugin)\n    : wasm_(wasm), id_(wasm->allocContextId()), root_context_(this), plugin_(plugin) {\n  RELEASE_ASSERT(root_id == plugin->root_id_, \"\");\n  wasm_->contexts_[id_] = this;\n}\n\ninline Context::Context(Wasm* wasm, uint32_t root_context_id, PluginSharedPtr plugin)\n    : wasm_(wasm), id_(wasm->allocContextId()), root_context_id_(root_context_id), plugin_(plugin) {\n  wasm_->contexts_[id_] = this;\n  root_context_ = wasm_->contexts_[root_context_id_];\n}\n\ninline void* Wasm::allocMemory(uint64_t size, uint64_t* address) {\n  Word a = malloc_(vmContext(), size);\n  if (!a.u64_) {\n    throw WasmException(\"malloc_ returns nullptr (OOM)\");\n  }\n  auto memory = wasm_vm_->getMemory(a.u64_, size);\n  if (!memory) {\n    throw WasmException(\"malloc_ returned illegal address\");\n  }\n  *address = a.u64_;\n  return const_cast<void*>(reinterpret_cast<const void*>(memory.value().data()));\n}\n\ninline uint64_t Wasm::copyString(absl::string_view s) {\n  if (s.empty()) {\n    return 0; // nullptr\n  }\n  uint64_t pointer;\n  uint8_t* m = static_cast<uint8_t*>(allocMemory((s.size() + 1), &pointer));\n  memcpy(m, s.data(), s.size());\n  m[s.size()] = 0;\n  return pointer;\n}\n\ninline uint64_t Wasm::copyBuffer(const Buffer::Instance& buffer) {\n  uint64_t pointer;\n  auto length = buffer.length();\n  if (length <= 0) {\n    return 0;\n  }\n  Buffer::RawSlice oneRawSlice;\n  // NB: we need to pass in >= 1 in order to get the real \"n\" (see Buffer::Instance for details).\n  int nSlices = buffer.getRawSlices(&oneRawSlice, 1);\n  if (nSlices <= 0) {\n    return 0;\n  }\n  uint8_t* m = static_cast<uint8_t*>(allocMemory(length, &pointer));\n  if (nSlices == 1) {\n    memcpy(m, oneRawSlice.mem_, oneRawSlice.len_);\n    return pointer;\n  }\n  STACK_ARRAY(manyRawSlices, Buffer::RawSlice, nSlices);\n  buffer.getRawSlices(manyRawSlices.begin(), nSlices);\n  auto p = m;\n  for (int i = 0; i < nSlices; i++) {\n    memcpy(p, manyRawSlices[i].mem_, manyRawSlices[i].len_);\n    p += manyRawSlices[i].len_;\n  }\n  return pointer;\n}\n\ninline bool Wasm::copyToPointerSize(absl::string_view s, uint64_t ptr_ptr, uint64_t size_ptr) {\n  uint64_t pointer = 0;\n  uint64_t size = s.size();\n  void* p = nullptr;\n  if (size > 0) {\n    p = allocMemory(size, &pointer);\n    if (!p) {\n      return false;\n    }\n    memcpy(p, s.data(), size);\n  }\n  if (!wasm_vm_->setWord(ptr_ptr, Word(pointer))) {\n    return false;\n  }\n  if (!wasm_vm_->setWord(size_ptr, Word(size))) {\n    return false;\n  }\n  return true;\n}\n\ninline bool Wasm::copyToPointerSize(const Buffer::Instance& buffer, uint64_t start, uint64_t length,\n                                    uint64_t ptr_ptr, uint64_t size_ptr) {\n  uint64_t size = buffer.length();\n  if (size < start + length) {\n    return false;\n  }\n  auto nslices = buffer.getRawSlices(nullptr, 0);\n  auto slices = std::make_unique<Buffer::RawSlice[]>(nslices + 10 /* pad for evbuffer overrun */);\n  auto actual_slices = buffer.getRawSlices(&slices[0], nslices);\n  uint64_t pointer = 0;\n  char* p = static_cast<char*>(allocMemory(length, &pointer));\n  auto s = start;\n  auto l = length;\n  if (!p) {\n    return false;\n  }\n  for (uint64_t i = 0; i < actual_slices; i++) {\n    if (slices[i].len_ <= s) {\n      s -= slices[i].len_;\n      continue;\n    }\n    auto ll = l;\n    if (ll > s + slices[i].len_)\n      ll = s + slices[i].len_;\n    memcpy(p, static_cast<char*>(slices[i].mem_) + s, ll);\n    l -= ll;\n    if (l <= 0) {\n      break;\n    }\n    s = 0;\n    p += ll;\n  }\n  if (!wasm_vm_->setWord(ptr_ptr, Word(pointer))) {\n    return false;\n  }\n  if (!wasm_vm_->setWord(size_ptr, Word(length))) {\n    return false;\n  }\n  return true;\n}\n\ntemplate <typename T> inline bool Wasm::setDatatype(uint64_t ptr, const T& t) {\n  return wasm_vm_->setMemory(ptr, sizeof(T), &t);\n}\n\n} // namespace Wasm\n} // namespace Common\n} // namespace Extensions\n} // namespace Envoy\n", "#include <stdio.h>\n\n#include \"common/event/dispatcher_impl.h\"\n#include \"common/stats/isolated_store_impl.h\"\n\n#include \"extensions/common/wasm/wasm.h\"\n\n#include \"test/mocks/server/mocks.h\"\n#include \"test/mocks/upstream/mocks.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"absl/types/optional.h\"\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing testing::Eq;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Wasm {\n\nclass TestContext : public Extensions::Common::Wasm::Context {\npublic:\n  TestContext(Extensions::Common::Wasm::Wasm* wasm) : Extensions::Common::Wasm::Context(wasm) {}\n  ~TestContext() override {}\n  void scriptLog(spdlog::level::level_enum level, absl::string_view message) override {\n    std::cerr << std::string(message) << \"\\n\";\n    scriptLog_(level, message);\n  }\n  MOCK_METHOD2(scriptLog_, void(spdlog::level::level_enum level, absl::string_view message));\n  MOCK_METHOD1(setTickPeriodMilliseconds, void(uint32_t tick_period_milliseconds));\n};\n\nclass WasmTest : public testing::TestWithParam<std::string> {};\n\nINSTANTIATE_TEST_SUITE_P(Runtimes, WasmTest,\n                         testing::Values(\n#if defined(ENVOY_WASM_V8) && defined(ENVOY_WASM_WAVM)\n                             \"v8\", \"wavm\"\n#elif defined(ENVOY_WASM_V8)\n                             \"v8\"\n#elif defined(ENVOY_WASM_WAVM)\n                             \"wavm\"\n#endif\n                             ));\n\nclass WasmTestMatrix : public testing::TestWithParam<std::tuple<std::string, std::string>> {};\n\nINSTANTIATE_TEST_SUITE_P(RuntimesAndLanguages, WasmTestMatrix,\n                         testing::Combine(testing::Values(\n#if defined(ENVOY_WASM_V8) && defined(ENVOY_WASM_WAVM)\n                                              \"v8\", \"wavm\"\n#elif defined(ENVOY_WASM_V8)\n                                              \"v8\"\n#elif defined(ENVOY_WASM_WAVM)\n                                              \"wavm\"\n#endif\n                                              ),\n                                          testing::Values(\"cpp\", \"rust\")));\n\nTEST_P(WasmTestMatrix, Logging) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", std::get<0>(GetParam())), vm_id, vm_configuration, plugin,\n      scope, cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      absl::StrCat(\"{{ test_rundir }}/test/extensions/wasm/test_data/logging_\",\n                   std::get<1>(GetParam()), \".wasm\")));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::warn, Eq(\"warn configure-test\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::trace, Eq(\"test trace logging\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::debug, Eq(\"test debug logging\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"test error logging\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::info, Eq(\"test tick logging\")));\n\n  EXPECT_TRUE(wasm->initialize(code, false));\n  wasm->setContext(context.get());\n  auto root_context = context.get();\n  wasm->startForTesting(std::move(context));\n  wasm->configure(root_context, \"configure-test\");\n  wasm->tickHandler(root_context->id());\n}\n\nTEST_P(WasmTest, BadSignature) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/bad_signature_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  EXPECT_THROW_WITH_MESSAGE(wasm->initialize(code, false),\n                            Extensions::Common::Wasm::WasmVmException,\n                            \"Bad function signature for: proxy_onConfigure\");\n}\n\nTEST_P(WasmTest, Segv) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/segv_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"before badptr\")));\n  EXPECT_TRUE(wasm->initialize(code, false));\n\n  if (GetParam() == \"v8\") {\n    EXPECT_THROW_WITH_MESSAGE(wasm->startForTesting(std::move(context)),\n                              Extensions::Common::Wasm::WasmException,\n                              \"Function: proxy_onStart failed: Uncaught RuntimeError: unreachable\");\n  } else if (GetParam() == \"wavm\") {\n    EXPECT_THROW_WITH_REGEX(wasm->startForTesting(std::move(context)),\n                            Extensions::Common::Wasm::WasmException,\n                            \"Function: proxy_onStart failed: wavm.reachedUnreachable.*\");\n  } else {\n    ASSERT_FALSE(true); // Neither of the above was matched.\n  }\n}\n\nTEST_P(WasmTest, DivByZero) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/segv_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"before div by zero\")));\n  EXPECT_TRUE(wasm->initialize(code, false));\n  context->setInVmContextCreatedForTesting();\n\n  if (GetParam() == \"v8\") {\n    EXPECT_THROW_WITH_MESSAGE(\n        context->onLog(), Extensions::Common::Wasm::WasmException,\n        \"Function: proxy_onLog failed: Uncaught RuntimeError: divide by zero\");\n  } else if (GetParam() == \"wavm\") {\n    EXPECT_THROW_WITH_REGEX(context->onLog(), Extensions::Common::Wasm::WasmException,\n                            \"Function: proxy_onLog failed: wavm.integerDivideByZeroOrOverflow.*\");\n  } else {\n    ASSERT_FALSE(true); // Neither of the above was matched.\n  }\n}\n\nTEST_P(WasmTest, EmscriptenVersion) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/segv_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n  EXPECT_TRUE(wasm->initialize(code, false));\n  uint32_t major = 9, minor = 9, abi_major = 9, abi_minor = 9;\n  EXPECT_TRUE(wasm->getEmscriptenVersion(&major, &minor, &abi_major, &abi_minor));\n  EXPECT_EQ(major, 0);\n  EXPECT_LE(minor, 3);\n  // Up to (at least) emsdk 1.39.0.\n  EXPECT_EQ(abi_major, 0);\n  EXPECT_LE(abi_minor, 19);\n}\n\nTEST_P(WasmTest, IntrinsicGlobals) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/emscripten_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::info, Eq(\"NaN nan\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::warn, Eq(\"inf inf\"))).Times(3);\n  EXPECT_TRUE(wasm->initialize(code, false));\n  wasm->startForTesting(std::move(context));\n}\n\n// The asm2wasm.wasm file uses operations which would require the asm2wasm Emscripten module *if*\n// em++ is invoked with the trap mode \"clamp\". See\n// https://emscripten.org/docs/compiling/WebAssembly.html This test demonstrates that the asm2wasm\n// module is not required with the trap mode is set to \"allow\". Note: future WASM standards will\n// change this behavior by providing non-trapping instructions, but in the mean time we support the\n// default Emscripten behavior.\nTEST_P(WasmTest, Asm2Wasm) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/asm2wasm_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::info, Eq(\"out 0 0 0\")));\n  EXPECT_TRUE(wasm->initialize(code, false));\n  wasm->startForTesting(std::move(context));\n}\n\nTEST_P(WasmTest, Stats) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/stats_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::trace, Eq(\"get counter = 1\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::debug, Eq(\"get counter = 2\")));\n  // recordMetric on a Counter is the same as increment.\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::info, Eq(\"get counter = 5\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::warn, Eq(\"get gauge = 2\")));\n  // Get is not supported on histograms.\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"get histogram = Unsupported\")));\n\n  EXPECT_TRUE(wasm->initialize(code, false));\n  wasm->startForTesting(std::move(context));\n}\n\nTEST_P(WasmTest, StatsHigherLevel) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/stats_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::trace, Eq(\"get counter = 1\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::debug, Eq(\"get counter = 2\")));\n  // recordMetric on a Counter is the same as increment.\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::info, Eq(\"get counter = 5\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::warn, Eq(\"get gauge = 2\")));\n  // Get is not supported on histograms.\n  EXPECT_CALL(*context,\n              scriptLog_(spdlog::level::err,\n                         Eq(std::string(\"resolved histogram name = \"\n                                        \"histogram_int_tag.7.histogram_string_tag.test_tag.\"\n                                        \"histogram_bool_tag.true.test_histogram\"))));\n\n  EXPECT_TRUE(wasm->initialize(code, false));\n  wasm->setContext(context.get());\n  wasm->tickHandler(context->id());\n}\n\nTEST_P(WasmTest, StatsHighLevel) {\n  Stats::IsolatedStoreImpl stats_store;\n  Api::ApiPtr api = Api::createApiForTest(stats_store);\n  Upstream::MockClusterManager cluster_manager;\n  Event::DispatcherPtr dispatcher(api->allocateDispatcher());\n  auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  auto name = \"\";\n  auto root_id = \"\";\n  auto vm_id = \"\";\n  auto vm_configuration = \"\";\n  auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(\n      name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,\n      nullptr);\n  auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(\n      absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,\n      cluster_manager, *dispatcher);\n  EXPECT_NE(wasm, nullptr);\n  const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/wasm/test_data/stats_cpp.wasm\"));\n  EXPECT_FALSE(code.empty());\n  auto context = std::make_unique<TestContext>(wasm.get());\n  context->setInVmContextCreatedForTesting();\n\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::trace, Eq(\"get counter = 1\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::debug, Eq(\"get counter = 2\")));\n  // recordMetric on a Counter is the same as increment.\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::info, Eq(\"get counter = 5\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::warn, Eq(\"get gauge = 2\")));\n  // Get is not supported on histograms.\n  // EXPECT_CALL(*context, scriptLog(spdlog::level::err, Eq(std::string(\"resolved histogram name\n  // = int_tag.7_string_tag.test_tag.bool_tag.true.test_histogram\"))));\n  EXPECT_CALL(*context,\n              scriptLog_(spdlog::level::err,\n                         Eq(\"h_id = int_tag.7.string_tag.test_tag.bool_tag.true.test_histogram\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"stack_c = 1\")));\n  EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"stack_g = 2\")));\n  // Get is not supported on histograms.\n  // EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"stack_h = 3\")));\n  EXPECT_TRUE(wasm->initialize(code, false));\n  wasm->setContext(context.get());\n  context->onLog();\n}\n\n} // namespace Wasm\n} // namespace Extensions\n} // namespace Envoy\n"], "filenames": ["source/extensions/common/wasm/wasm.cc", "source/extensions/common/wasm/wasm.h", "test/extensions/wasm/wasm_test.cc"], "buggy_code_start_loc": [1701, 415, 187], "buggy_code_end_loc": [2461, 415, 390], "fixing_code_start_loc": [1702, 416, 187], "fixing_code_end_loc": [2463, 418, 392], "type": "CWE-476", "message": "Istio 1.4.x before 1.4.9 and Istio 1.5.x before 1.5.4 contain the following vulnerability when telemetry v2 is enabled: by sending a specially crafted packet, an attacker could trigger a Null Pointer Exception resulting in a Denial of Service. This could be sent to the ingress gateway or a sidecar, triggering a null pointer exception which results in a denial of service. This also affects servicemesh-proxy where a null pointer exception flaw was found in servicemesh-proxy. When running Telemetry v2 (not on by default in version 1.4.x), an attacker could send a specially crafted packet to the ingress gateway or proxy sidecar, triggering a denial of service.", "other": {"cve": {"id": "CVE-2020-10739", "sourceIdentifier": "secalert@redhat.com", "published": "2020-06-02T13:15:10.983", "lastModified": "2020-06-02T19:26:56.937", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Istio 1.4.x before 1.4.9 and Istio 1.5.x before 1.5.4 contain the following vulnerability when telemetry v2 is enabled: by sending a specially crafted packet, an attacker could trigger a Null Pointer Exception resulting in a Denial of Service. This could be sent to the ingress gateway or a sidecar, triggering a null pointer exception which results in a denial of service. This also affects servicemesh-proxy where a null pointer exception flaw was found in servicemesh-proxy. When running Telemetry v2 (not on by default in version 1.4.x), an attacker could send a specially crafted packet to the ingress gateway or proxy sidecar, triggering a denial of service."}, {"lang": "es", "value": "Istio versiones 1.4.x anteriores a 1.4.9 e Istio versiones 1.5.x anteriores a 1.5.4, contienen la siguiente vulnerabilidad cuando se habilita la telemetry v2: al enviar un paquete especialmente dise\u00f1ado, un atacante podr\u00eda desencadenar una Excepci\u00f3n de Puntero Null resultando en una Denegaci\u00f3n de Servicio. Esto podr\u00eda ser enviado hacia la puerta de enlace de ingreso o un archivo sidecar, desencadenando una excepci\u00f3n de puntero null que resulta en una denegaci\u00f3n de servicio. Esto tambi\u00e9n afecta a servicemesh-proxy donde fue encontrado un fallo de excepci\u00f3n de puntero null en servicemesh-proxy. Cuando se ejecuta Telemetry v2 (no activado por defecto en la versi\u00f3n 1.4.x), un atacante podr\u00eda enviar un paquete especialmente dise\u00f1ado hacia la puerta de enlace de ingreso o al proxy sidecar, desencadenando una denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:istio:istio:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.4.0", "versionEndExcluding": "1.4.9", "matchCriteriaId": "11766B73-EF96-44BC-A741-03DE8E93C7BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:istio:istio:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.5.0", "versionEndExcluding": "1.5.4", "matchCriteriaId": "5D7A6B12-4FF8-42D5-86AA-70535571BD1E"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2020-10739", "source": "secalert@redhat.com", "tags": ["Broken Link", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/istio/envoy/commit/8788a3cf255b647fd14e6b5e2585abaaedb28153#diff-fcf2cf5dd389b5285f882ba4a8708633", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://istio.io/news/security/istio-security-2020-005/", "source": "secalert@redhat.com", "tags": ["Mitigation", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/istio/envoy/commit/8788a3cf255b647fd14e6b5e2585abaaedb28153#diff-fcf2cf5dd389b5285f882ba4a8708633"}}