{"buggy_code": ["'use strict';\n\nconst os = require('os');\nconst nconf = require('nconf');\nconst winston = require('winston');\nconst util = require('util');\nconst validator = require('validator');\nconst cookieParser = require('cookie-parser')(nconf.get('secret'));\n\nconst db = require('../database');\nconst user = require('../user');\nconst logger = require('../logger');\nconst plugins = require('../plugins');\nconst ratelimit = require('../middleware/ratelimit');\n\nconst Namespaces = Object.create(null);\n\nconst Sockets = module.exports;\n\nSockets.init = async function (server) {\n\trequireModules();\n\n\tconst SocketIO = require('socket.io').Server;\n\tconst io = new SocketIO({\n\t\tpath: `${nconf.get('relative_path')}/socket.io`,\n\t});\n\n\tif (nconf.get('isCluster')) {\n\t\tif (nconf.get('redis')) {\n\t\t\tconst adapter = await require('../database/redis').socketAdapter();\n\t\t\tio.adapter(adapter);\n\t\t} else {\n\t\t\twinston.warn('clustering detected, you should setup redis!');\n\t\t}\n\t}\n\n\tio.use(authorize);\n\n\tio.on('connection', onConnection);\n\n\tconst opts = {\n\t\ttransports: nconf.get('socket.io:transports') || ['polling', 'websocket'],\n\t\tcookie: false,\n\t};\n\t/*\n\t * Restrict socket.io listener to cookie domain. If none is set, infer based on url.\n\t * Production only so you don't get accidentally locked out.\n\t * Can be overridden via config (socket.io:origins)\n\t */\n\tif (process.env.NODE_ENV !== 'development' || nconf.get('socket.io:cors')) {\n\t\tconst origins = nconf.get('socket.io:origins');\n\t\topts.cors = nconf.get('socket.io:cors') || {\n\t\t\torigin: origins,\n\t\t\tmethods: ['GET', 'POST'],\n\t\t\tallowedHeaders: ['content-type'],\n\t\t};\n\t\twinston.info(`[socket.io] Restricting access to origin: ${origins}`);\n\t}\n\n\tio.listen(server, opts);\n\tSockets.server = io;\n};\n\nfunction onConnection(socket) {\n\tsocket.ip = (socket.request.headers['x-forwarded-for'] || socket.request.connection.remoteAddress || '').split(',')[0];\n\tsocket.request.ip = socket.ip;\n\tlogger.io_one(socket, socket.uid);\n\n\tonConnect(socket);\n\tsocket.onAny((event, ...args) => {\n\t\tconst payload = { data: [event].concat(args) };\n\t\tconst als = require('../als');\n\t\tals.run({ uid: socket.uid }, onMessage, socket, payload);\n\t});\n\n\tsocket.on('disconnect', () => {\n\t\tonDisconnect(socket);\n\t});\n}\n\nfunction onDisconnect(socket) {\n\trequire('./uploads').clear(socket.id);\n\tplugins.hooks.fire('action:sockets.disconnect', { socket: socket });\n}\n\nasync function onConnect(socket) {\n\ttry {\n\t\tawait validateSession(socket, '[[error:invalid-session]]');\n\t} catch (e) {\n\t\tif (e.message === '[[error:invalid-session]]') {\n\t\t\tsocket.emit('event:invalid_session');\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (socket.uid) {\n\t\tsocket.join(`uid_${socket.uid}`);\n\t\tsocket.join('online_users');\n\t} else {\n\t\tsocket.join('online_guests');\n\t}\n\n\tsocket.join(`sess_${socket.request.signedCookies[nconf.get('sessionKey')]}`);\n\tsocket.emit('checkSession', socket.uid);\n\tsocket.emit('setHostname', os.hostname());\n\tplugins.hooks.fire('action:sockets.connect', { socket: socket });\n}\n\nasync function onMessage(socket, payload) {\n\tif (!payload.data.length) {\n\t\treturn winston.warn('[socket.io] Empty payload');\n\t}\n\n\tconst eventName = payload.data[0];\n\tconst params = typeof payload.data[1] === 'function' ? {} : payload.data[1];\n\tconst callback = typeof payload.data[payload.data.length - 1] === 'function' ? payload.data[payload.data.length - 1] : function () {};\n\n\tif (!eventName) {\n\t\treturn winston.warn('[socket.io] Empty method name');\n\t}\n\n\tconst parts = eventName.toString().split('.');\n\tconst namespace = parts[0];\n\tconst methodToCall = parts.reduce((prev, cur) => {\n\t\tif (prev !== null && prev[cur] && (!prev.hasOwnProperty || prev.hasOwnProperty(cur))) {\n\t\t\treturn prev[cur];\n\t\t}\n\t\treturn null;\n\t}, Namespaces);\n\n\tif (!methodToCall || typeof methodToCall !== 'function') {\n\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\twinston.warn(`[socket.io] Unrecognized message: ${eventName}`);\n\t\t}\n\t\tconst escapedName = validator.escape(String(eventName));\n\t\treturn callback({ message: `[[error:invalid-event, ${escapedName}]]` });\n\t}\n\n\tsocket.previousEvents = socket.previousEvents || [];\n\tsocket.previousEvents.push(eventName);\n\tif (socket.previousEvents.length > 20) {\n\t\tsocket.previousEvents.shift();\n\t}\n\n\tif (!eventName.startsWith('admin.') && ratelimit.isFlooding(socket)) {\n\t\twinston.warn(`[socket.io] Too many emits! Disconnecting uid : ${socket.uid}. Events : ${socket.previousEvents}`);\n\t\treturn socket.disconnect();\n\t}\n\n\ttry {\n\t\tawait checkMaintenance(socket);\n\t\tawait validateSession(socket, '[[error:revalidate-failure]]');\n\n\t\tif (Namespaces[namespace].before) {\n\t\t\tawait Namespaces[namespace].before(socket, eventName, params);\n\t\t}\n\n\t\tif (methodToCall.constructor && methodToCall.constructor.name === 'AsyncFunction') {\n\t\t\tconst result = await methodToCall(socket, params);\n\t\t\tcallback(null, result);\n\t\t} else {\n\t\t\tmethodToCall(socket, params, (err, result) => {\n\t\t\t\tcallback(err ? { message: err.message } : null, result);\n\t\t\t});\n\t\t}\n\t} catch (err) {\n\t\twinston.error(`${eventName}\\n${err.stack ? err.stack : err.message}`);\n\t\tcallback({ message: err.message });\n\t}\n}\n\nfunction requireModules() {\n\tconst modules = [\n\t\t'admin', 'categories', 'groups', 'meta', 'modules',\n\t\t'notifications', 'plugins', 'posts', 'topics', 'user',\n\t\t'blacklist', 'uploads',\n\t];\n\n\tmodules.forEach((module) => {\n\t\tNamespaces[module] = require(`./${module}`);\n\t});\n}\n\nasync function checkMaintenance(socket) {\n\tconst meta = require('../meta');\n\tif (!meta.config.maintenanceMode) {\n\t\treturn;\n\t}\n\tconst isAdmin = await user.isAdministrator(socket.uid);\n\tif (isAdmin) {\n\t\treturn;\n\t}\n\tconst validator = require('validator');\n\tthrow new Error(`[[pages:maintenance.text, ${validator.escape(String(meta.config.title || 'NodeBB'))}]]`);\n}\n\nconst getSessionAsync = util.promisify(\n\t(sid, callback) => db.sessionStore.get(sid, (err, sessionObj) => callback(err, sessionObj || null))\n);\n\nasync function validateSession(socket, errorMsg) {\n\tconst req = socket.request;\n\tconst { sessionId } = await plugins.hooks.fire('filter:sockets.sessionId', {\n\t\tsessionId: req.signedCookies ? req.signedCookies[nconf.get('sessionKey')] : null,\n\t\trequest: req,\n\t});\n\n\tif (!sessionId) {\n\t\treturn;\n\t}\n\n\tconst sessionData = await getSessionAsync(sessionId);\n\n\tif (!sessionData) {\n\t\tthrow new Error(errorMsg);\n\t}\n\n\tawait plugins.hooks.fire('static:sockets.validateSession', {\n\t\treq: req,\n\t\tsocket: socket,\n\t\tsession: sessionData,\n\t});\n}\n\nconst cookieParserAsync = util.promisify((req, callback) => cookieParser(req, {}, err => callback(err)));\n\nasync function authorize(socket, callback) {\n\tconst { request } = socket;\n\n\tif (!request) {\n\t\treturn callback(new Error('[[error:not-authorized]]'));\n\t}\n\n\tawait cookieParserAsync(request);\n\n\tconst { sessionId } = await plugins.hooks.fire('filter:sockets.sessionId', {\n\t\tsessionId: request.signedCookies ? request.signedCookies[nconf.get('sessionKey')] : null,\n\t\trequest: request,\n\t});\n\n\tconst sessionData = await getSessionAsync(sessionId);\n\n\tif (sessionData && sessionData.passport && sessionData.passport.user) {\n\t\trequest.session = sessionData;\n\t\tsocket.uid = parseInt(sessionData.passport.user, 10);\n\t} else {\n\t\tsocket.uid = 0;\n\t}\n\trequest.uid = socket.uid;\n\tcallback();\n}\n\nSockets.in = function (room) {\n\treturn Sockets.server && Sockets.server.in(room);\n};\n\nSockets.getUserSocketCount = function (uid) {\n\treturn Sockets.getCountInRoom(`uid_${uid}`);\n};\n\nSockets.getCountInRoom = function (room) {\n\tif (!Sockets.server) {\n\t\treturn 0;\n\t}\n\tconst roomMap = Sockets.server.sockets.adapter.rooms.get(room);\n\treturn roomMap ? roomMap.size : 0;\n};\n\nSockets.warnDeprecated = (socket, replacement) => {\n\tif (socket.previousEvents && socket.emit) {\n\t\tsocket.emit('event:deprecated_call', {\n\t\t\teventName: socket.previousEvents[socket.previousEvents.length - 1],\n\t\t\treplacement: replacement,\n\t\t});\n\t}\n\twinston.warn(`[deprecated]\\n ${new Error('-').stack.split('\\n').slice(2, 5).join('\\n')}\\n     use ${replacement}`);\n};\n", "'use strict';\n\n// see https://gist.github.com/jfromaniello/4087861#gistcomment-1447029\n\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\nconst util = require('util');\n\nconst sleep = util.promisify(setTimeout);\nconst assert = require('assert');\nconst async = require('async');\nconst nconf = require('nconf');\nconst request = require('request');\n\nconst cookies = request.jar();\n\nconst db = require('./mocks/databasemock');\nconst user = require('../src/user');\nconst groups = require('../src/groups');\nconst categories = require('../src/categories');\nconst helpers = require('./helpers');\nconst meta = require('../src/meta');\nconst events = require('../src/events');\n\nconst socketAdmin = require('../src/socket.io/admin');\n\ndescribe('socket.io', () => {\n\tlet io;\n\tlet cid;\n\tlet tid;\n\tlet adminUid;\n\tlet regularUid;\n\n\tbefore(async () => {\n\t\tconst data = await Promise.all([\n\t\t\tuser.create({ username: 'admin', password: 'adminpwd' }),\n\t\t\tuser.create({ username: 'regular', password: 'regularpwd' }),\n\t\t\tcategories.create({\n\t\t\t\tname: 'Test Category',\n\t\t\t\tdescription: 'Test category created by testing script',\n\t\t\t}),\n\t\t]);\n\t\tadminUid = data[0];\n\t\tawait groups.join('administrators', data[0]);\n\n\t\tregularUid = data[1];\n\t\tawait user.setUserField(regularUid, 'email', 'regular@test.com');\n\t\tawait user.email.confirmByUid(regularUid);\n\n\t\tcid = data[2].cid;\n\t});\n\n\n\tit('should connect and auth properly', (done) => {\n\t\trequest.get({\n\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\tjar: cookies,\n\t\t\tjson: true,\n\t\t}, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\n\t\t\trequest.post(`${nconf.get('url')}/login`, {\n\t\t\t\tjar: cookies,\n\t\t\t\tform: {\n\t\t\t\t\tusername: 'admin',\n\t\t\t\t\tpassword: 'adminpwd',\n\t\t\t\t},\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': body.csrf_token,\n\t\t\t\t},\n\t\t\t\tjson: true,\n\t\t\t}, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\thelpers.connectSocketIO(res, (err, _io) => {\n\t\t\t\t\tio = _io;\n\t\t\t\t\tassert.ifError(err);\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should return error for unknown event', (done) => {\n\t\tio.emit('unknown.event', (err) => {\n\t\t\tassert(err);\n\t\t\tassert.equal(err.message, '[[error:invalid-event, unknown.event]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error for unknown event', (done) => {\n\t\tio.emit('user.gdpr.__proto__.constructor.toString', (err) => {\n\t\t\tassert(err);\n\t\t\tassert.equal(err.message, '[[error:invalid-event, user.gdpr.__proto__.constructor.toString]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error for unknown event', (done) => {\n\t\tio.emit('constructor.toString', (err) => {\n\t\t\tassert(err);\n\t\t\tassert.equal(err.message, '[[error:invalid-event, constructor.toString]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get installed themes', (done) => {\n\t\tconst themes = ['nodebb-theme-lavender', 'nodebb-theme-persona', 'nodebb-theme-vanilla'];\n\t\tio.emit('admin.themes.getInstalled', (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tconst installed = data.map(theme => theme.id);\n\t\t\tthemes.forEach((theme) => {\n\t\t\t\tassert.notEqual(installed.indexOf(theme), -1);\n\t\t\t});\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should ban a user', async () => {\n\t\tconst apiUser = require('../src/api/users');\n\t\tawait apiUser.ban({ uid: adminUid }, { uid: regularUid, reason: 'spammer' });\n\t\tconst data = await user.getLatestBanInfo(regularUid);\n\t\tassert(data.uid);\n\t\tassert(data.timestamp);\n\t\tassert(data.hasOwnProperty('banned_until'));\n\t\tassert(data.hasOwnProperty('banned_until_readable'));\n\t\tassert.equal(data.reason, 'spammer');\n\t});\n\n\tit('should return ban reason', (done) => {\n\t\tuser.bans.getReason(regularUid, (err, reason) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(reason, 'spammer');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should unban a user', async () => {\n\t\tconst apiUser = require('../src/api/users');\n\t\tawait apiUser.unban({ uid: adminUid }, { uid: regularUid });\n\t\tconst isBanned = await user.bans.isBanned(regularUid);\n\t\tassert(!isBanned);\n\t});\n\n\tit('should make user admin', (done) => {\n\t\tsocketAdmin.user.makeAdmins({ uid: adminUid }, [regularUid], (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tgroups.isMember(regularUid, 'administrators', (err, isMember) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(isMember);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should make user non-admin', (done) => {\n\t\tsocketAdmin.user.removeAdmins({ uid: adminUid }, [regularUid], (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tgroups.isMember(regularUid, 'administrators', (err, isMember) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(!isMember);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('user create/delete', () => {\n\t\tlet uid;\n\t\tconst apiUsers = require('../src/api/users');\n\t\tit('should create a user', async () => {\n\t\t\tconst userData = await apiUsers.create({ uid: adminUid }, { username: 'foo1' });\n\t\t\tuid = userData.uid;\n\t\t\tconst isMember = await groups.isMember(userData.uid, 'registered-users');\n\t\t\tassert(isMember);\n\t\t});\n\n\t\tit('should delete users', async () => {\n\t\t\tawait apiUsers.delete({ uid: adminUid }, { uid });\n\t\t\tawait sleep(500);\n\t\t\tconst isMember = await groups.isMember(uid, 'registered-users');\n\t\t\tassert(!isMember);\n\t\t});\n\n\t\tit('should error if user does not exist', async () => {\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tawait apiUsers.deleteMany({ uid: adminUid }, { uids: [uid] });\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.strictEqual(err.message, '[[error:no-user]]');\n\t\t});\n\n\t\tit('should delete users and their content', async () => {\n\t\t\tconst userData = await apiUsers.create({ uid: adminUid }, { username: 'foo2' });\n\t\t\tawait apiUsers.deleteMany({ uid: adminUid }, { uids: [userData.uid] });\n\t\t\tawait sleep(500);\n\t\t\tconst isMember = await groups.isMember(userData.uid, 'registered-users');\n\t\t\tassert(!isMember);\n\t\t});\n\n\t\tit('should error with invalid data', async () => {\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tawait apiUsers.create({ uid: adminUid }, null);\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t});\n\t});\n\n\tit('should load user groups', async () => {\n\t\tconst { users } = await socketAdmin.user.loadGroups({ uid: adminUid }, [adminUid]);\n\t\tassert.strictEqual(users[0].username, 'admin');\n\t\tassert(Array.isArray(users[0].groups));\n\t});\n\n\tit('should reset lockouts', (done) => {\n\t\tsocketAdmin.user.resetLockouts({ uid: adminUid }, [regularUid], (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('validation emails', () => {\n\t\tconst plugins = require('../src/plugins');\n\n\t\tasync function dummyEmailerHook(data) {\n\t\t\t// pretend to handle sending emails\n\t\t}\n\t\tbefore(() => {\n\t\t\t// Attach an emailer hook so related requests do not error\n\t\t\tplugins.hooks.register('emailer-test', {\n\t\t\t\thook: 'filter:email.send',\n\t\t\t\tmethod: dummyEmailerHook,\n\t\t\t});\n\t\t});\n\t\tafter(() => {\n\t\t\tplugins.hooks.unregister('emailer-test', 'filter:email.send');\n\t\t});\n\n\t\tit('should validate emails', (done) => {\n\t\t\tsocketAdmin.user.validateEmail({ uid: adminUid }, [regularUid], (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tuser.getUserField(regularUid, 'email:confirmed', (err, emailConfirmed) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(parseInt(emailConfirmed, 10), 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid uids', (done) => {\n\t\t\tsocketAdmin.user.sendValidationEmail({ uid: adminUid }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should send validation email', (done) => {\n\t\t\tsocketAdmin.user.sendValidationEmail({ uid: adminUid }, [regularUid], (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should push unread notifications on reconnect', (done) => {\n\t\tconst socketMeta = require('../src/socket.io/meta');\n\t\tsocketMeta.reconnected({ uid: 1 }, {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\n\tit('should error if the room is missing', (done) => {\n\t\tio.emit('meta.rooms.enter', null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return if uid is 0', (done) => {\n\t\tconst socketMeta = require('../src/socket.io/meta');\n\t\tsocketMeta.rooms.enter({ uid: 0 }, null, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should join a room', (done) => {\n\t\tio.emit('meta.rooms.enter', { enter: 'recent_topics' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should leave current room', (done) => {\n\t\tio.emit('meta.rooms.leaveCurrent', {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get server time', (done) => {\n\t\tio.emit('admin.getServerTime', null, (err, time) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(time);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should error to get daily analytics with invalid data', (done) => {\n\t\tio.emit('admin.analytics.get', null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get daily analytics', (done) => {\n\t\tio.emit('admin.analytics.get', { graph: 'traffic', units: 'days' }, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tassert(data.summary);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get hourly analytics', (done) => {\n\t\tio.emit('admin.analytics.get', { graph: 'traffic', units: 'hours' }, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tassert(data.summary);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should allow a custom date range for traffic graph analytics', (done) => {\n\t\tio.emit('admin.analytics.get', { graph: 'traffic', units: 'days', amount: '7' }, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tassert(data.pageviews);\n\t\t\tassert(data.uniqueVisitors);\n\t\t\tassert.strictEqual(7, data.pageviews.length);\n\t\t\tassert.strictEqual(7, data.uniqueVisitors.length);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error', (done) => {\n\t\tsocketAdmin.before({ uid: 10 }, 'someMethod', {}, (err) => {\n\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get room stats', (done) => {\n\t\tio.emit('meta.rooms.enter', { enter: 'topic_1' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err, data) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(data.hasOwnProperty('onlineGuestCount'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('onlineRegisteredCount'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('socketCount'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('topics'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('users'));\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t}, 1000);\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should get room stats', (done) => {\n\t\tio.emit('meta.rooms.enter', { enter: 'category_1' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err, data) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(data.users.category, 1, JSON.stringify(data, null, 4));\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t}, 1000);\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should get admin search dictionary', (done) => {\n\t\tsocketAdmin.getSearchDict({ uid: adminUid }, {}, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(Array.isArray(data));\n\t\t\tassert(data[0].namespace);\n\t\t\tassert(data[0].translations);\n\t\t\tassert(data[0].title);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should fire event', (done) => {\n\t\tio.on('testEvent', (data) => {\n\t\t\tassert.equal(data.foo, 1);\n\t\t\tdone();\n\t\t});\n\t\tsocketAdmin.fireEvent({ uid: adminUid }, { name: 'testEvent', payload: { foo: 1 } }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t});\n\t});\n\n\tit('should error with invalid data', (done) => {\n\t\tsocketAdmin.themes.set({ uid: adminUid }, null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should set theme to bootswatch', (done) => {\n\t\tsocketAdmin.themes.set({ uid: adminUid }, {\n\t\t\ttype: 'bootswatch',\n\t\t\tsrc: '//maxcdn.bootstrapcdn.com/bootswatch/latest/darkly/bootstrap.min.css',\n\t\t\tid: 'darkly',\n\t\t}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tmeta.configs.getFields(['theme:src', 'bootswatchSkin'], (err, fields) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(fields['theme:src'], '//maxcdn.bootstrapcdn.com/bootswatch/latest/darkly/bootstrap.min.css');\n\t\t\t\tassert.equal(fields.bootswatchSkin, 'darkly');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should set theme to local persona', (done) => {\n\t\tsocketAdmin.themes.set({ uid: adminUid }, { type: 'local', id: 'nodebb-theme-persona' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tmeta.configs.get('theme:id', (err, id) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(id, 'nodebb-theme-persona');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should toggle plugin active', (done) => {\n\t\tsocketAdmin.plugins.toggleActive({ uid: adminUid }, 'nodebb-plugin-location-to-map', (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.deepEqual(data, { id: 'nodebb-plugin-location-to-map', active: true });\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should toggle plugin install', function (done) {\n\t\tthis.timeout(0);\n\t\tconst oldValue = process.env.NODE_ENV;\n\t\tprocess.env.NODE_ENV = 'development';\n\t\tsocketAdmin.plugins.toggleInstall({\n\t\t\tuid: adminUid,\n\t\t}, {\n\t\t\tid: 'nodebb-plugin-location-to-map',\n\t\t\tversion: 'latest',\n\t\t}, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(data.name, 'nodebb-plugin-location-to-map');\n\t\t\tprocess.env.NODE_ENV = oldValue;\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get list of active plugins', (done) => {\n\t\tsocketAdmin.plugins.getActive({ uid: adminUid }, {}, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(Array.isArray(data));\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should order active plugins', (done) => {\n\t\tconst data = [\n\t\t\t{ name: 'nodebb-theme-persona', order: 0 },\n\t\t\t{ name: 'nodebb-plugin-dbsearch', order: 1 },\n\t\t\t{ name: 'nodebb-plugin-markdown', order: 2 },\n\t\t\t{ ignoreme: 'wrong data' },\n\t\t];\n\t\tsocketAdmin.plugins.orderActivePlugins({ uid: adminUid }, data, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.sortedSetRank('plugins:active', 'nodebb-plugin-dbsearch', (err, rank) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(rank, 1);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should upgrade plugin', function (done) {\n\t\tthis.timeout(0);\n\t\tconst oldValue = process.env.NODE_ENV;\n\t\tprocess.env.NODE_ENV = 'development';\n\t\tsocketAdmin.plugins.upgrade({\n\t\t\tuid: adminUid,\n\t\t}, {\n\t\t\tid: 'nodebb-plugin-location-to-map',\n\t\t\tversion: 'latest',\n\t\t}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tprocess.env.NODE_ENV = oldValue;\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should error with invalid data', (done) => {\n\t\tsocketAdmin.widgets.set({ uid: adminUid }, null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should error with invalid data', (done) => {\n\t\tconst data = [\n\t\t\t{\n\t\t\t\ttemplate: 'global',\n\t\t\t\tlocation: 'sidebar',\n\t\t\t\twidgets: [{ widget: 'html', data: { html: 'test', title: 'test', container: '' } }],\n\t\t\t},\n\t\t];\n\t\tsocketAdmin.widgets.set({ uid: adminUid }, data, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.getObjectField('widgets:global', 'sidebar', (err, widgetData) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tassert.equal(JSON.parse(widgetData)[0].data.html, 'test');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear sitemap cache', async () => {\n\t\tawait socketAdmin.settings.clearSitemapCache({ uid: adminUid }, {});\n\t});\n\n\tit('should send test email', async () => {\n\t\tconst tpls = ['digest', 'banned', 'verify', 'welcome', 'notification', 'invitation'];\n\t\ttry {\n\t\t\tfor (const tpl of tpls) {\n\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\tawait socketAdmin.email.test({ uid: adminUid }, { template: tpl });\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tif (err.message !== '[[error:sendmail-not-found]]') {\n\t\t\t\tassert.ifError(err);\n\t\t\t}\n\t\t}\n\t});\n\n\tit('should not error when resending digests', async () => {\n\t\tawait socketAdmin.digest.resend({ uid: adminUid }, { action: 'resend-day', uid: adminUid });\n\t\tawait socketAdmin.digest.resend({ uid: adminUid }, { action: 'resend-day' });\n\t});\n\n\tit('should error with invalid interval', async () => {\n\t\tconst oldValue = meta.config.dailyDigestFreq;\n\t\tmeta.config.dailyDigestFreq = 'off';\n\t\ttry {\n\t\t\tawait socketAdmin.digest.resend({ uid: adminUid }, { action: 'resend-' });\n\t\t} catch (err) {\n\t\t\tassert.strictEqual(err.message, '[[error:digest-not-enabled]]');\n\t\t}\n\t\tmeta.config.dailyDigestFreq = oldValue;\n\t});\n\n\tit('should get logs', (done) => {\n\t\tconst fs = require('fs');\n\t\tconst path = require('path');\n\t\tmeta.logs.path = path.join(nconf.get('base_dir'), 'test/files', 'output.log');\n\t\tfs.appendFile(meta.logs.path, 'some logs', (err) => {\n\t\t\tassert.ifError(err);\n\n\t\t\tsocketAdmin.logs.get({ uid: adminUid }, {}, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(data);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear logs', (done) => {\n\t\tsocketAdmin.logs.clear({ uid: adminUid }, {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tsocketAdmin.logs.get({ uid: adminUid }, {}, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.length, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear errors', (done) => {\n\t\tsocketAdmin.errors.clear({ uid: adminUid }, {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.exists('error:404', (err, exists) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(!exists);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should delete a single event', (done) => {\n\t\tdb.getSortedSetRevRange('events:time', 0, 0, (err, eids) => {\n\t\t\tassert.ifError(err);\n\t\t\tevents.deleteEvents(eids, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdb.isSortedSetMembers('events:time', eids, (err, isMembers) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert(!isMembers.includes(true));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should delete all events', (done) => {\n\t\tevents.deleteAll((err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.sortedSetCard('events:time', (err, count) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(count, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('logger', () => {\n\t\tconst logger = require('../src/logger');\n\t\tconst index = require('../src/socket.io');\n\t\tconst fs = require('fs');\n\t\tconst path = require('path');\n\n\t\tit('should enable logging', (done) => {\n\t\t\tmeta.config.loggerStatus = 1;\n\t\t\tmeta.config.loggerIOStatus = 1;\n\t\t\tconst loggerPath = path.join(__dirname, '..', 'logs', 'logger.log');\n\t\t\tlogger.monitorConfig({ io: index.server }, { key: 'loggerPath', value: loggerPath });\n\t\t\tsetTimeout(() => {\n\t\t\t\tio.emit('meta.rooms.enter', { enter: 'recent_topics' }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tfs.readFile(loggerPath, 'utf-8', (err, content) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(content);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}, 500);\n\t\t});\n\n\t\tafter((done) => {\n\t\t\tmeta.config.loggerStatus = 0;\n\t\t\tmeta.config.loggerIOStatus = 0;\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('password reset', () => {\n\t\tconst socketUser = require('../src/socket.io/user');\n\n\t\tit('should error if uids is not array', (done) => {\n\t\t\tsocketAdmin.user.sendPasswordResetEmail({ uid: adminUid }, null, (err) => {\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if uid doesnt have email', (done) => {\n\t\t\tsocketAdmin.user.sendPasswordResetEmail({ uid: adminUid }, [adminUid], (err) => {\n\t\t\t\tassert.strictEqual(err.message, '[[error:user-doesnt-have-email, admin]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should send password reset email', async () => {\n\t\t\tawait user.setUserField(adminUid, 'email', 'admin_test@nodebb.org');\n\t\t\tawait user.email.confirmByUid(adminUid);\n\t\t\tawait socketAdmin.user.sendPasswordResetEmail({ uid: adminUid }, [adminUid]);\n\t\t});\n\n\t\tit('should error if uids is not array', (done) => {\n\t\t\tsocketAdmin.user.forcePasswordReset({ uid: adminUid }, null, (err) => {\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should for password reset', async () => {\n\t\t\tconst then = Date.now();\n\t\t\tconst uid = await user.create({ username: 'forceme', password: '123345' });\n\t\t\tawait socketAdmin.user.forcePasswordReset({ uid: adminUid }, [uid]);\n\t\t\tconst pwExpiry = await user.getUserField(uid, 'passwordExpiry');\n\t\t\tconst sleep = util.promisify(setTimeout);\n\t\t\tawait sleep(500);\n\t\t\tassert(pwExpiry > then && pwExpiry < Date.now());\n\t\t});\n\n\t\tit('should not error on valid email', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'regular@test.com', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tasync.parallel({\n\t\t\t\t\tcount: async.apply(db.sortedSetCount.bind(db), 'reset:issueDate', 0, Date.now()),\n\t\t\t\t\tevent: async.apply(events.getEvents, '', 0, 0),\n\t\t\t\t}, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(data.count, 2);\n\n\t\t\t\t\t// Event validity\n\t\t\t\t\tassert.strictEqual(data.event.length, 1);\n\t\t\t\t\tconst event = data.event[0];\n\t\t\t\t\tassert.strictEqual(event.type, 'password-reset');\n\t\t\t\t\tassert.strictEqual(event.text, '[[success:success]]');\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not generate code if rate limited', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'regular@test.com', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tasync.parallel({\n\t\t\t\t\tcount: async.apply(db.sortedSetCount.bind(db), 'reset:issueDate', 0, Date.now()),\n\t\t\t\t\tevent: async.apply(events.getEvents, '', 0, 0),\n\t\t\t\t}, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(data.count, 2);\n\n\t\t\t\t\t// Event validity\n\t\t\t\t\tassert.strictEqual(data.event.length, 1);\n\t\t\t\t\tconst event = data.event[0];\n\t\t\t\t\tassert.strictEqual(event.type, 'password-reset');\n\t\t\t\t\tassert.strictEqual(event.text, '[[error:reset-rate-limited]]');\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not error on invalid email (but not generate reset code)', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'irregular@test.com', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tdb.sortedSetCount('reset:issueDate', 0, Date.now(), (err, count) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(count, 2);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error on no email', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, '', (err) => {\n\t\t\t\tassert(err instanceof Error);\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear caches', async () => {\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'post' });\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'object' });\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'group' });\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'local' });\n\t});\n\n\tit('should toggle caches', async () => {\n\t\tconst caches = {\n\t\t\tpost: require('../src/posts/cache'),\n\t\t\tobject: require('../src/database').objectCache,\n\t\t\tgroup: require('../src/groups').cache,\n\t\t\tlocal: require('../src/cache'),\n\t\t};\n\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'post', enabled: !caches.post.enabled });\n\t\tif (caches.object) {\n\t\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'object', enabled: !caches.object.enabled });\n\t\t}\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'group', enabled: !caches.group.enabled });\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'local', enabled: !caches.local.enabled });\n\n\t\t// call again to return back to original state\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'post', enabled: !caches.post.enabled });\n\t\tif (caches.object) {\n\t\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'object', enabled: !caches.object.enabled });\n\t\t}\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'group', enabled: !caches.group.enabled });\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'local', enabled: !caches.local.enabled });\n\t});\n});\n"], "fixing_code": ["'use strict';\n\nconst os = require('os');\nconst nconf = require('nconf');\nconst winston = require('winston');\nconst util = require('util');\nconst validator = require('validator');\nconst cookieParser = require('cookie-parser')(nconf.get('secret'));\n\nconst db = require('../database');\nconst user = require('../user');\nconst logger = require('../logger');\nconst plugins = require('../plugins');\nconst ratelimit = require('../middleware/ratelimit');\n\nconst Namespaces = Object.create(null);\n\nconst Sockets = module.exports;\n\nSockets.init = async function (server) {\n\trequireModules();\n\n\tconst SocketIO = require('socket.io').Server;\n\tconst io = new SocketIO({\n\t\tpath: `${nconf.get('relative_path')}/socket.io`,\n\t});\n\n\tif (nconf.get('isCluster')) {\n\t\tif (nconf.get('redis')) {\n\t\t\tconst adapter = await require('../database/redis').socketAdapter();\n\t\t\tio.adapter(adapter);\n\t\t} else {\n\t\t\twinston.warn('clustering detected, you should setup redis!');\n\t\t}\n\t}\n\n\tio.use(authorize);\n\n\tio.on('connection', onConnection);\n\n\tconst opts = {\n\t\ttransports: nconf.get('socket.io:transports') || ['polling', 'websocket'],\n\t\tcookie: false,\n\t};\n\t/*\n\t * Restrict socket.io listener to cookie domain. If none is set, infer based on url.\n\t * Production only so you don't get accidentally locked out.\n\t * Can be overridden via config (socket.io:origins)\n\t */\n\tif (process.env.NODE_ENV !== 'development' || nconf.get('socket.io:cors')) {\n\t\tconst origins = nconf.get('socket.io:origins');\n\t\topts.cors = nconf.get('socket.io:cors') || {\n\t\t\torigin: origins,\n\t\t\tmethods: ['GET', 'POST'],\n\t\t\tallowedHeaders: ['content-type'],\n\t\t};\n\t\twinston.info(`[socket.io] Restricting access to origin: ${origins}`);\n\t}\n\n\tio.listen(server, opts);\n\tSockets.server = io;\n};\n\nfunction onConnection(socket) {\n\tsocket.ip = (socket.request.headers['x-forwarded-for'] || socket.request.connection.remoteAddress || '').split(',')[0];\n\tsocket.request.ip = socket.ip;\n\tlogger.io_one(socket, socket.uid);\n\n\tonConnect(socket);\n\tsocket.onAny((event, ...args) => {\n\t\tconst payload = { data: [event].concat(args) };\n\t\tconst als = require('../als');\n\t\tals.run({ uid: socket.uid }, onMessage, socket, payload);\n\t});\n\n\tsocket.on('disconnect', () => {\n\t\tonDisconnect(socket);\n\t});\n}\n\nfunction onDisconnect(socket) {\n\trequire('./uploads').clear(socket.id);\n\tplugins.hooks.fire('action:sockets.disconnect', { socket: socket });\n}\n\nasync function onConnect(socket) {\n\ttry {\n\t\tawait validateSession(socket, '[[error:invalid-session]]');\n\t} catch (e) {\n\t\tif (e.message === '[[error:invalid-session]]') {\n\t\t\tsocket.emit('event:invalid_session');\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (socket.uid) {\n\t\tsocket.join(`uid_${socket.uid}`);\n\t\tsocket.join('online_users');\n\t} else {\n\t\tsocket.join('online_guests');\n\t}\n\n\tsocket.join(`sess_${socket.request.signedCookies[nconf.get('sessionKey')]}`);\n\tsocket.emit('checkSession', socket.uid);\n\tsocket.emit('setHostname', os.hostname());\n\tplugins.hooks.fire('action:sockets.connect', { socket: socket });\n}\n\nasync function onMessage(socket, payload) {\n\tif (!payload.data.length) {\n\t\treturn winston.warn('[socket.io] Empty payload');\n\t}\n\n\tconst eventName = payload.data[0];\n\tconst params = typeof payload.data[1] === 'function' ? {} : payload.data[1];\n\tconst callback = typeof payload.data[payload.data.length - 1] === 'function' ? payload.data[payload.data.length - 1] : function () {};\n\n\tif (!eventName) {\n\t\treturn winston.warn('[socket.io] Empty method name');\n\t}\n\n\tif (typeof eventName !== 'string') {\n\t\tconst escapedName = validator.escape(String(eventName));\n\t\treturn callback({ message: `[[error:invalid-event, ${escapedName}]]` });\n\t}\n\n\tconst parts = eventName.split('.');\n\tconst namespace = parts[0];\n\tconst methodToCall = parts.reduce((prev, cur) => {\n\t\tif (prev !== null && prev[cur] && (!prev.hasOwnProperty || prev.hasOwnProperty(cur))) {\n\t\t\treturn prev[cur];\n\t\t}\n\t\treturn null;\n\t}, Namespaces);\n\n\tif (!methodToCall || typeof methodToCall !== 'function') {\n\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\twinston.warn(`[socket.io] Unrecognized message: ${eventName}`);\n\t\t}\n\t\tconst escapedName = validator.escape(String(eventName));\n\t\treturn callback({ message: `[[error:invalid-event, ${escapedName}]]` });\n\t}\n\n\tsocket.previousEvents = socket.previousEvents || [];\n\tsocket.previousEvents.push(eventName);\n\tif (socket.previousEvents.length > 20) {\n\t\tsocket.previousEvents.shift();\n\t}\n\n\tif (!eventName.startsWith('admin.') && ratelimit.isFlooding(socket)) {\n\t\twinston.warn(`[socket.io] Too many emits! Disconnecting uid : ${socket.uid}. Events : ${socket.previousEvents}`);\n\t\treturn socket.disconnect();\n\t}\n\n\ttry {\n\t\tawait checkMaintenance(socket);\n\t\tawait validateSession(socket, '[[error:revalidate-failure]]');\n\n\t\tif (Namespaces[namespace].before) {\n\t\t\tawait Namespaces[namespace].before(socket, eventName, params);\n\t\t}\n\n\t\tif (methodToCall.constructor && methodToCall.constructor.name === 'AsyncFunction') {\n\t\t\tconst result = await methodToCall(socket, params);\n\t\t\tcallback(null, result);\n\t\t} else {\n\t\t\tmethodToCall(socket, params, (err, result) => {\n\t\t\t\tcallback(err ? { message: err.message } : null, result);\n\t\t\t});\n\t\t}\n\t} catch (err) {\n\t\twinston.error(`${eventName}\\n${err.stack ? err.stack : err.message}`);\n\t\tcallback({ message: err.message });\n\t}\n}\n\nfunction requireModules() {\n\tconst modules = [\n\t\t'admin', 'categories', 'groups', 'meta', 'modules',\n\t\t'notifications', 'plugins', 'posts', 'topics', 'user',\n\t\t'blacklist', 'uploads',\n\t];\n\n\tmodules.forEach((module) => {\n\t\tNamespaces[module] = require(`./${module}`);\n\t});\n}\n\nasync function checkMaintenance(socket) {\n\tconst meta = require('../meta');\n\tif (!meta.config.maintenanceMode) {\n\t\treturn;\n\t}\n\tconst isAdmin = await user.isAdministrator(socket.uid);\n\tif (isAdmin) {\n\t\treturn;\n\t}\n\tconst validator = require('validator');\n\tthrow new Error(`[[pages:maintenance.text, ${validator.escape(String(meta.config.title || 'NodeBB'))}]]`);\n}\n\nconst getSessionAsync = util.promisify(\n\t(sid, callback) => db.sessionStore.get(sid, (err, sessionObj) => callback(err, sessionObj || null))\n);\n\nasync function validateSession(socket, errorMsg) {\n\tconst req = socket.request;\n\tconst { sessionId } = await plugins.hooks.fire('filter:sockets.sessionId', {\n\t\tsessionId: req.signedCookies ? req.signedCookies[nconf.get('sessionKey')] : null,\n\t\trequest: req,\n\t});\n\n\tif (!sessionId) {\n\t\treturn;\n\t}\n\n\tconst sessionData = await getSessionAsync(sessionId);\n\n\tif (!sessionData) {\n\t\tthrow new Error(errorMsg);\n\t}\n\n\tawait plugins.hooks.fire('static:sockets.validateSession', {\n\t\treq: req,\n\t\tsocket: socket,\n\t\tsession: sessionData,\n\t});\n}\n\nconst cookieParserAsync = util.promisify((req, callback) => cookieParser(req, {}, err => callback(err)));\n\nasync function authorize(socket, callback) {\n\tconst { request } = socket;\n\n\tif (!request) {\n\t\treturn callback(new Error('[[error:not-authorized]]'));\n\t}\n\n\tawait cookieParserAsync(request);\n\n\tconst { sessionId } = await plugins.hooks.fire('filter:sockets.sessionId', {\n\t\tsessionId: request.signedCookies ? request.signedCookies[nconf.get('sessionKey')] : null,\n\t\trequest: request,\n\t});\n\n\tconst sessionData = await getSessionAsync(sessionId);\n\n\tif (sessionData && sessionData.passport && sessionData.passport.user) {\n\t\trequest.session = sessionData;\n\t\tsocket.uid = parseInt(sessionData.passport.user, 10);\n\t} else {\n\t\tsocket.uid = 0;\n\t}\n\trequest.uid = socket.uid;\n\tcallback();\n}\n\nSockets.in = function (room) {\n\treturn Sockets.server && Sockets.server.in(room);\n};\n\nSockets.getUserSocketCount = function (uid) {\n\treturn Sockets.getCountInRoom(`uid_${uid}`);\n};\n\nSockets.getCountInRoom = function (room) {\n\tif (!Sockets.server) {\n\t\treturn 0;\n\t}\n\tconst roomMap = Sockets.server.sockets.adapter.rooms.get(room);\n\treturn roomMap ? roomMap.size : 0;\n};\n\nSockets.warnDeprecated = (socket, replacement) => {\n\tif (socket.previousEvents && socket.emit) {\n\t\tsocket.emit('event:deprecated_call', {\n\t\t\teventName: socket.previousEvents[socket.previousEvents.length - 1],\n\t\t\treplacement: replacement,\n\t\t});\n\t}\n\twinston.warn(`[deprecated]\\n ${new Error('-').stack.split('\\n').slice(2, 5).join('\\n')}\\n     use ${replacement}`);\n};\n", "'use strict';\n\n// see https://gist.github.com/jfromaniello/4087861#gistcomment-1447029\n\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\nconst util = require('util');\n\nconst sleep = util.promisify(setTimeout);\nconst assert = require('assert');\nconst async = require('async');\nconst nconf = require('nconf');\nconst request = require('request');\n\nconst cookies = request.jar();\n\nconst db = require('./mocks/databasemock');\nconst user = require('../src/user');\nconst groups = require('../src/groups');\nconst categories = require('../src/categories');\nconst helpers = require('./helpers');\nconst meta = require('../src/meta');\nconst events = require('../src/events');\n\nconst socketAdmin = require('../src/socket.io/admin');\n\ndescribe('socket.io', () => {\n\tlet io;\n\tlet cid;\n\tlet tid;\n\tlet adminUid;\n\tlet regularUid;\n\n\tbefore(async () => {\n\t\tconst data = await Promise.all([\n\t\t\tuser.create({ username: 'admin', password: 'adminpwd' }),\n\t\t\tuser.create({ username: 'regular', password: 'regularpwd' }),\n\t\t\tcategories.create({\n\t\t\t\tname: 'Test Category',\n\t\t\t\tdescription: 'Test category created by testing script',\n\t\t\t}),\n\t\t]);\n\t\tadminUid = data[0];\n\t\tawait groups.join('administrators', data[0]);\n\n\t\tregularUid = data[1];\n\t\tawait user.setUserField(regularUid, 'email', 'regular@test.com');\n\t\tawait user.email.confirmByUid(regularUid);\n\n\t\tcid = data[2].cid;\n\t});\n\n\n\tit('should connect and auth properly', (done) => {\n\t\trequest.get({\n\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\tjar: cookies,\n\t\t\tjson: true,\n\t\t}, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\n\t\t\trequest.post(`${nconf.get('url')}/login`, {\n\t\t\t\tjar: cookies,\n\t\t\t\tform: {\n\t\t\t\t\tusername: 'admin',\n\t\t\t\t\tpassword: 'adminpwd',\n\t\t\t\t},\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': body.csrf_token,\n\t\t\t\t},\n\t\t\t\tjson: true,\n\t\t\t}, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\thelpers.connectSocketIO(res, (err, _io) => {\n\t\t\t\t\tio = _io;\n\t\t\t\t\tassert.ifError(err);\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should return error for unknown event', (done) => {\n\t\tio.emit('unknown.event', (err) => {\n\t\t\tassert(err);\n\t\t\tassert.equal(err.message, '[[error:invalid-event, unknown.event]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error for unknown event', (done) => {\n\t\tio.emit('user.gdpr.__proto__.constructor.toString', (err) => {\n\t\t\tassert(err);\n\t\t\tassert.equal(err.message, '[[error:invalid-event, user.gdpr.__proto__.constructor.toString]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error for unknown event', (done) => {\n\t\tio.emit('constructor.toString', (err) => {\n\t\t\tassert(err);\n\t\t\tassert.equal(err.message, '[[error:invalid-event, constructor.toString]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error for invalid eventName type', (done) => {\n\t\tconst eventName = ['topics.loadMoreTags'];\n\t\tio.emit(eventName, function (err) {\n\t\t\tconst eventAsString = String(eventName);\n\t\t\tassert.strictEqual(err.message, `[[error:invalid-event, ${eventAsString}]]`);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get installed themes', (done) => {\n\t\tconst themes = ['nodebb-theme-lavender', 'nodebb-theme-persona', 'nodebb-theme-vanilla'];\n\t\tio.emit('admin.themes.getInstalled', (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tconst installed = data.map(theme => theme.id);\n\t\t\tthemes.forEach((theme) => {\n\t\t\t\tassert.notEqual(installed.indexOf(theme), -1);\n\t\t\t});\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should ban a user', async () => {\n\t\tconst apiUser = require('../src/api/users');\n\t\tawait apiUser.ban({ uid: adminUid }, { uid: regularUid, reason: 'spammer' });\n\t\tconst data = await user.getLatestBanInfo(regularUid);\n\t\tassert(data.uid);\n\t\tassert(data.timestamp);\n\t\tassert(data.hasOwnProperty('banned_until'));\n\t\tassert(data.hasOwnProperty('banned_until_readable'));\n\t\tassert.equal(data.reason, 'spammer');\n\t});\n\n\tit('should return ban reason', (done) => {\n\t\tuser.bans.getReason(regularUid, (err, reason) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(reason, 'spammer');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should unban a user', async () => {\n\t\tconst apiUser = require('../src/api/users');\n\t\tawait apiUser.unban({ uid: adminUid }, { uid: regularUid });\n\t\tconst isBanned = await user.bans.isBanned(regularUid);\n\t\tassert(!isBanned);\n\t});\n\n\tit('should make user admin', (done) => {\n\t\tsocketAdmin.user.makeAdmins({ uid: adminUid }, [regularUid], (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tgroups.isMember(regularUid, 'administrators', (err, isMember) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(isMember);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should make user non-admin', (done) => {\n\t\tsocketAdmin.user.removeAdmins({ uid: adminUid }, [regularUid], (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tgroups.isMember(regularUid, 'administrators', (err, isMember) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(!isMember);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('user create/delete', () => {\n\t\tlet uid;\n\t\tconst apiUsers = require('../src/api/users');\n\t\tit('should create a user', async () => {\n\t\t\tconst userData = await apiUsers.create({ uid: adminUid }, { username: 'foo1' });\n\t\t\tuid = userData.uid;\n\t\t\tconst isMember = await groups.isMember(userData.uid, 'registered-users');\n\t\t\tassert(isMember);\n\t\t});\n\n\t\tit('should delete users', async () => {\n\t\t\tawait apiUsers.delete({ uid: adminUid }, { uid });\n\t\t\tawait sleep(500);\n\t\t\tconst isMember = await groups.isMember(uid, 'registered-users');\n\t\t\tassert(!isMember);\n\t\t});\n\n\t\tit('should error if user does not exist', async () => {\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tawait apiUsers.deleteMany({ uid: adminUid }, { uids: [uid] });\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.strictEqual(err.message, '[[error:no-user]]');\n\t\t});\n\n\t\tit('should delete users and their content', async () => {\n\t\t\tconst userData = await apiUsers.create({ uid: adminUid }, { username: 'foo2' });\n\t\t\tawait apiUsers.deleteMany({ uid: adminUid }, { uids: [userData.uid] });\n\t\t\tawait sleep(500);\n\t\t\tconst isMember = await groups.isMember(userData.uid, 'registered-users');\n\t\t\tassert(!isMember);\n\t\t});\n\n\t\tit('should error with invalid data', async () => {\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tawait apiUsers.create({ uid: adminUid }, null);\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t});\n\t});\n\n\tit('should load user groups', async () => {\n\t\tconst { users } = await socketAdmin.user.loadGroups({ uid: adminUid }, [adminUid]);\n\t\tassert.strictEqual(users[0].username, 'admin');\n\t\tassert(Array.isArray(users[0].groups));\n\t});\n\n\tit('should reset lockouts', (done) => {\n\t\tsocketAdmin.user.resetLockouts({ uid: adminUid }, [regularUid], (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('validation emails', () => {\n\t\tconst plugins = require('../src/plugins');\n\n\t\tasync function dummyEmailerHook(data) {\n\t\t\t// pretend to handle sending emails\n\t\t}\n\t\tbefore(() => {\n\t\t\t// Attach an emailer hook so related requests do not error\n\t\t\tplugins.hooks.register('emailer-test', {\n\t\t\t\thook: 'filter:email.send',\n\t\t\t\tmethod: dummyEmailerHook,\n\t\t\t});\n\t\t});\n\t\tafter(() => {\n\t\t\tplugins.hooks.unregister('emailer-test', 'filter:email.send');\n\t\t});\n\n\t\tit('should validate emails', (done) => {\n\t\t\tsocketAdmin.user.validateEmail({ uid: adminUid }, [regularUid], (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tuser.getUserField(regularUid, 'email:confirmed', (err, emailConfirmed) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(parseInt(emailConfirmed, 10), 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid uids', (done) => {\n\t\t\tsocketAdmin.user.sendValidationEmail({ uid: adminUid }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should send validation email', (done) => {\n\t\t\tsocketAdmin.user.sendValidationEmail({ uid: adminUid }, [regularUid], (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should push unread notifications on reconnect', (done) => {\n\t\tconst socketMeta = require('../src/socket.io/meta');\n\t\tsocketMeta.reconnected({ uid: 1 }, {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\n\tit('should error if the room is missing', (done) => {\n\t\tio.emit('meta.rooms.enter', null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return if uid is 0', (done) => {\n\t\tconst socketMeta = require('../src/socket.io/meta');\n\t\tsocketMeta.rooms.enter({ uid: 0 }, null, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should join a room', (done) => {\n\t\tio.emit('meta.rooms.enter', { enter: 'recent_topics' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should leave current room', (done) => {\n\t\tio.emit('meta.rooms.leaveCurrent', {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get server time', (done) => {\n\t\tio.emit('admin.getServerTime', null, (err, time) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(time);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should error to get daily analytics with invalid data', (done) => {\n\t\tio.emit('admin.analytics.get', null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get daily analytics', (done) => {\n\t\tio.emit('admin.analytics.get', { graph: 'traffic', units: 'days' }, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tassert(data.summary);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get hourly analytics', (done) => {\n\t\tio.emit('admin.analytics.get', { graph: 'traffic', units: 'hours' }, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tassert(data.summary);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should allow a custom date range for traffic graph analytics', (done) => {\n\t\tio.emit('admin.analytics.get', { graph: 'traffic', units: 'days', amount: '7' }, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tassert(data.pageviews);\n\t\t\tassert(data.uniqueVisitors);\n\t\t\tassert.strictEqual(7, data.pageviews.length);\n\t\t\tassert.strictEqual(7, data.uniqueVisitors.length);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error', (done) => {\n\t\tsocketAdmin.before({ uid: 10 }, 'someMethod', {}, (err) => {\n\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get room stats', (done) => {\n\t\tio.emit('meta.rooms.enter', { enter: 'topic_1' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err, data) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(data.hasOwnProperty('onlineGuestCount'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('onlineRegisteredCount'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('socketCount'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('topics'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('users'));\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t}, 1000);\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should get room stats', (done) => {\n\t\tio.emit('meta.rooms.enter', { enter: 'category_1' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err, data) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(data.users.category, 1, JSON.stringify(data, null, 4));\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t}, 1000);\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should get admin search dictionary', (done) => {\n\t\tsocketAdmin.getSearchDict({ uid: adminUid }, {}, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(Array.isArray(data));\n\t\t\tassert(data[0].namespace);\n\t\t\tassert(data[0].translations);\n\t\t\tassert(data[0].title);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should fire event', (done) => {\n\t\tio.on('testEvent', (data) => {\n\t\t\tassert.equal(data.foo, 1);\n\t\t\tdone();\n\t\t});\n\t\tsocketAdmin.fireEvent({ uid: adminUid }, { name: 'testEvent', payload: { foo: 1 } }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t});\n\t});\n\n\tit('should error with invalid data', (done) => {\n\t\tsocketAdmin.themes.set({ uid: adminUid }, null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should set theme to bootswatch', (done) => {\n\t\tsocketAdmin.themes.set({ uid: adminUid }, {\n\t\t\ttype: 'bootswatch',\n\t\t\tsrc: '//maxcdn.bootstrapcdn.com/bootswatch/latest/darkly/bootstrap.min.css',\n\t\t\tid: 'darkly',\n\t\t}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tmeta.configs.getFields(['theme:src', 'bootswatchSkin'], (err, fields) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(fields['theme:src'], '//maxcdn.bootstrapcdn.com/bootswatch/latest/darkly/bootstrap.min.css');\n\t\t\t\tassert.equal(fields.bootswatchSkin, 'darkly');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should set theme to local persona', (done) => {\n\t\tsocketAdmin.themes.set({ uid: adminUid }, { type: 'local', id: 'nodebb-theme-persona' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tmeta.configs.get('theme:id', (err, id) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(id, 'nodebb-theme-persona');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should toggle plugin active', (done) => {\n\t\tsocketAdmin.plugins.toggleActive({ uid: adminUid }, 'nodebb-plugin-location-to-map', (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.deepEqual(data, { id: 'nodebb-plugin-location-to-map', active: true });\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should toggle plugin install', function (done) {\n\t\tthis.timeout(0);\n\t\tconst oldValue = process.env.NODE_ENV;\n\t\tprocess.env.NODE_ENV = 'development';\n\t\tsocketAdmin.plugins.toggleInstall({\n\t\t\tuid: adminUid,\n\t\t}, {\n\t\t\tid: 'nodebb-plugin-location-to-map',\n\t\t\tversion: 'latest',\n\t\t}, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(data.name, 'nodebb-plugin-location-to-map');\n\t\t\tprocess.env.NODE_ENV = oldValue;\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get list of active plugins', (done) => {\n\t\tsocketAdmin.plugins.getActive({ uid: adminUid }, {}, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(Array.isArray(data));\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should order active plugins', (done) => {\n\t\tconst data = [\n\t\t\t{ name: 'nodebb-theme-persona', order: 0 },\n\t\t\t{ name: 'nodebb-plugin-dbsearch', order: 1 },\n\t\t\t{ name: 'nodebb-plugin-markdown', order: 2 },\n\t\t\t{ ignoreme: 'wrong data' },\n\t\t];\n\t\tsocketAdmin.plugins.orderActivePlugins({ uid: adminUid }, data, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.sortedSetRank('plugins:active', 'nodebb-plugin-dbsearch', (err, rank) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(rank, 1);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should upgrade plugin', function (done) {\n\t\tthis.timeout(0);\n\t\tconst oldValue = process.env.NODE_ENV;\n\t\tprocess.env.NODE_ENV = 'development';\n\t\tsocketAdmin.plugins.upgrade({\n\t\t\tuid: adminUid,\n\t\t}, {\n\t\t\tid: 'nodebb-plugin-location-to-map',\n\t\t\tversion: 'latest',\n\t\t}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tprocess.env.NODE_ENV = oldValue;\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should error with invalid data', (done) => {\n\t\tsocketAdmin.widgets.set({ uid: adminUid }, null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should error with invalid data', (done) => {\n\t\tconst data = [\n\t\t\t{\n\t\t\t\ttemplate: 'global',\n\t\t\t\tlocation: 'sidebar',\n\t\t\t\twidgets: [{ widget: 'html', data: { html: 'test', title: 'test', container: '' } }],\n\t\t\t},\n\t\t];\n\t\tsocketAdmin.widgets.set({ uid: adminUid }, data, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.getObjectField('widgets:global', 'sidebar', (err, widgetData) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tassert.equal(JSON.parse(widgetData)[0].data.html, 'test');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear sitemap cache', async () => {\n\t\tawait socketAdmin.settings.clearSitemapCache({ uid: adminUid }, {});\n\t});\n\n\tit('should send test email', async () => {\n\t\tconst tpls = ['digest', 'banned', 'verify', 'welcome', 'notification', 'invitation'];\n\t\ttry {\n\t\t\tfor (const tpl of tpls) {\n\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\tawait socketAdmin.email.test({ uid: adminUid }, { template: tpl });\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tif (err.message !== '[[error:sendmail-not-found]]') {\n\t\t\t\tassert.ifError(err);\n\t\t\t}\n\t\t}\n\t});\n\n\tit('should not error when resending digests', async () => {\n\t\tawait socketAdmin.digest.resend({ uid: adminUid }, { action: 'resend-day', uid: adminUid });\n\t\tawait socketAdmin.digest.resend({ uid: adminUid }, { action: 'resend-day' });\n\t});\n\n\tit('should error with invalid interval', async () => {\n\t\tconst oldValue = meta.config.dailyDigestFreq;\n\t\tmeta.config.dailyDigestFreq = 'off';\n\t\ttry {\n\t\t\tawait socketAdmin.digest.resend({ uid: adminUid }, { action: 'resend-' });\n\t\t} catch (err) {\n\t\t\tassert.strictEqual(err.message, '[[error:digest-not-enabled]]');\n\t\t}\n\t\tmeta.config.dailyDigestFreq = oldValue;\n\t});\n\n\tit('should get logs', (done) => {\n\t\tconst fs = require('fs');\n\t\tconst path = require('path');\n\t\tmeta.logs.path = path.join(nconf.get('base_dir'), 'test/files', 'output.log');\n\t\tfs.appendFile(meta.logs.path, 'some logs', (err) => {\n\t\t\tassert.ifError(err);\n\n\t\t\tsocketAdmin.logs.get({ uid: adminUid }, {}, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(data);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear logs', (done) => {\n\t\tsocketAdmin.logs.clear({ uid: adminUid }, {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tsocketAdmin.logs.get({ uid: adminUid }, {}, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.length, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear errors', (done) => {\n\t\tsocketAdmin.errors.clear({ uid: adminUid }, {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.exists('error:404', (err, exists) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(!exists);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should delete a single event', (done) => {\n\t\tdb.getSortedSetRevRange('events:time', 0, 0, (err, eids) => {\n\t\t\tassert.ifError(err);\n\t\t\tevents.deleteEvents(eids, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdb.isSortedSetMembers('events:time', eids, (err, isMembers) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert(!isMembers.includes(true));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should delete all events', (done) => {\n\t\tevents.deleteAll((err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.sortedSetCard('events:time', (err, count) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(count, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('logger', () => {\n\t\tconst logger = require('../src/logger');\n\t\tconst index = require('../src/socket.io');\n\t\tconst fs = require('fs');\n\t\tconst path = require('path');\n\n\t\tit('should enable logging', (done) => {\n\t\t\tmeta.config.loggerStatus = 1;\n\t\t\tmeta.config.loggerIOStatus = 1;\n\t\t\tconst loggerPath = path.join(__dirname, '..', 'logs', 'logger.log');\n\t\t\tlogger.monitorConfig({ io: index.server }, { key: 'loggerPath', value: loggerPath });\n\t\t\tsetTimeout(() => {\n\t\t\t\tio.emit('meta.rooms.enter', { enter: 'recent_topics' }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tfs.readFile(loggerPath, 'utf-8', (err, content) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(content);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}, 500);\n\t\t});\n\n\t\tafter((done) => {\n\t\t\tmeta.config.loggerStatus = 0;\n\t\t\tmeta.config.loggerIOStatus = 0;\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('password reset', () => {\n\t\tconst socketUser = require('../src/socket.io/user');\n\n\t\tit('should error if uids is not array', (done) => {\n\t\t\tsocketAdmin.user.sendPasswordResetEmail({ uid: adminUid }, null, (err) => {\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if uid doesnt have email', (done) => {\n\t\t\tsocketAdmin.user.sendPasswordResetEmail({ uid: adminUid }, [adminUid], (err) => {\n\t\t\t\tassert.strictEqual(err.message, '[[error:user-doesnt-have-email, admin]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should send password reset email', async () => {\n\t\t\tawait user.setUserField(adminUid, 'email', 'admin_test@nodebb.org');\n\t\t\tawait user.email.confirmByUid(adminUid);\n\t\t\tawait socketAdmin.user.sendPasswordResetEmail({ uid: adminUid }, [adminUid]);\n\t\t});\n\n\t\tit('should error if uids is not array', (done) => {\n\t\t\tsocketAdmin.user.forcePasswordReset({ uid: adminUid }, null, (err) => {\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should for password reset', async () => {\n\t\t\tconst then = Date.now();\n\t\t\tconst uid = await user.create({ username: 'forceme', password: '123345' });\n\t\t\tawait socketAdmin.user.forcePasswordReset({ uid: adminUid }, [uid]);\n\t\t\tconst pwExpiry = await user.getUserField(uid, 'passwordExpiry');\n\t\t\tconst sleep = util.promisify(setTimeout);\n\t\t\tawait sleep(500);\n\t\t\tassert(pwExpiry > then && pwExpiry < Date.now());\n\t\t});\n\n\t\tit('should not error on valid email', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'regular@test.com', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tasync.parallel({\n\t\t\t\t\tcount: async.apply(db.sortedSetCount.bind(db), 'reset:issueDate', 0, Date.now()),\n\t\t\t\t\tevent: async.apply(events.getEvents, '', 0, 0),\n\t\t\t\t}, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(data.count, 2);\n\n\t\t\t\t\t// Event validity\n\t\t\t\t\tassert.strictEqual(data.event.length, 1);\n\t\t\t\t\tconst event = data.event[0];\n\t\t\t\t\tassert.strictEqual(event.type, 'password-reset');\n\t\t\t\t\tassert.strictEqual(event.text, '[[success:success]]');\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not generate code if rate limited', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'regular@test.com', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tasync.parallel({\n\t\t\t\t\tcount: async.apply(db.sortedSetCount.bind(db), 'reset:issueDate', 0, Date.now()),\n\t\t\t\t\tevent: async.apply(events.getEvents, '', 0, 0),\n\t\t\t\t}, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(data.count, 2);\n\n\t\t\t\t\t// Event validity\n\t\t\t\t\tassert.strictEqual(data.event.length, 1);\n\t\t\t\t\tconst event = data.event[0];\n\t\t\t\t\tassert.strictEqual(event.type, 'password-reset');\n\t\t\t\t\tassert.strictEqual(event.text, '[[error:reset-rate-limited]]');\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not error on invalid email (but not generate reset code)', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'irregular@test.com', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tdb.sortedSetCount('reset:issueDate', 0, Date.now(), (err, count) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(count, 2);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error on no email', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, '', (err) => {\n\t\t\t\tassert(err instanceof Error);\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear caches', async () => {\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'post' });\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'object' });\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'group' });\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'local' });\n\t});\n\n\tit('should toggle caches', async () => {\n\t\tconst caches = {\n\t\t\tpost: require('../src/posts/cache'),\n\t\t\tobject: require('../src/database').objectCache,\n\t\t\tgroup: require('../src/groups').cache,\n\t\t\tlocal: require('../src/cache'),\n\t\t};\n\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'post', enabled: !caches.post.enabled });\n\t\tif (caches.object) {\n\t\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'object', enabled: !caches.object.enabled });\n\t\t}\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'group', enabled: !caches.group.enabled });\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'local', enabled: !caches.local.enabled });\n\n\t\t// call again to return back to original state\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'post', enabled: !caches.post.enabled });\n\t\tif (caches.object) {\n\t\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'object', enabled: !caches.object.enabled });\n\t\t}\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'group', enabled: !caches.group.enabled });\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'local', enabled: !caches.local.enabled });\n\t});\n});\n"], "filenames": ["src/socket.io/index.js", "test/socket.io.js"], "buggy_code_start_loc": [123, 105], "buggy_code_end_loc": [124, 105], "fixing_code_start_loc": [123, 106], "fixing_code_end_loc": [129, 115], "type": "CWE-754", "message": "Denial-of-service in NodeBB <= v2.8.10 allows unauthenticated attackers to trigger a crash, when invoking `eventName.startsWith()` or `eventName.toString()`, while processing Socket.IO messages via crafted Socket.IO messages containing array or object type for the event name respectively.", "other": {"cve": {"id": "CVE-2023-30591", "sourceIdentifier": "info@starlabs.sg", "published": "2023-09-29T06:15:09.870", "lastModified": "2023-10-02T18:19:47.023", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Denial-of-service in NodeBB <= v2.8.10 allows unauthenticated attackers to trigger a crash, when invoking `eventName.startsWith()` or `eventName.toString()`, while processing Socket.IO messages via crafted Socket.IO messages containing array or object type for the event name respectively."}, {"lang": "es", "value": "La denegaci\u00f3n de servicio en NodeBB en versiones &lt;=2.8.10 permite a atacantes no autenticados provocar un fallo al invocar `eventName.startsWith()` o `eventName.toString()`, mientras procesan mensajes Socket.IO a trav\u00e9s de mensajes Socket.IO manipulados que contienen una matriz o un tipo de objeto para el nombre del evento, respectivamente."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "info@starlabs.sg", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-754"}]}, {"source": "info@starlabs.sg", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-241"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodebb:nodebb:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.8.10", "matchCriteriaId": "99BDD6A9-80DA-4181-84F6-C78E05E0AA97"}]}]}], "references": [{"url": "https://github.com/NodeBB/NodeBB/commit/37b48b82a4bc7680c6e4c42647209010cb239c2c", "source": "info@starlabs.sg", "tags": ["Patch"]}, {"url": "https://github.com/NodeBB/NodeBB/commit/4d2d76897a02e7068ab74c81d17a2febfae8bfb9", "source": "info@starlabs.sg", "tags": ["Patch"]}, {"url": "https://github.com/NodeBB/NodeBB/commit/830f142b7aea2e597294a84d52c05aab3a3539ca", "source": "info@starlabs.sg", "tags": ["Patch"]}, {"url": "https://starlabs.sg/advisories/23/23-30591/", "source": "info@starlabs.sg", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/NodeBB/NodeBB/commit/37b48b82a4bc7680c6e4c42647209010cb239c2c"}}