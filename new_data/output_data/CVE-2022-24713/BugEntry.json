{"buggy_code": ["use std::collections::HashMap;\nuse std::fmt;\nuse std::iter;\nuse std::result;\nuse std::sync::Arc;\n\nuse regex_syntax::hir::{self, Hir};\nuse regex_syntax::is_word_byte;\nuse regex_syntax::utf8::{Utf8Range, Utf8Sequence, Utf8Sequences};\n\nuse crate::prog::{\n    EmptyLook, Inst, InstBytes, InstChar, InstEmptyLook, InstPtr, InstRanges,\n    InstSave, InstSplit, Program,\n};\n\nuse crate::Error;\n\ntype Result = result::Result<Patch, Error>;\ntype ResultOrEmpty = result::Result<Option<Patch>, Error>;\n\n#[derive(Debug)]\nstruct Patch {\n    hole: Hole,\n    entry: InstPtr,\n}\n\n/// A compiler translates a regular expression AST to a sequence of\n/// instructions. The sequence of instructions represents an NFA.\n// `Compiler` is only public via the `internal` module, so avoid deriving\n// `Debug`.\n#[allow(missing_debug_implementations)]\npub struct Compiler {\n    insts: Vec<MaybeInst>,\n    compiled: Program,\n    capture_name_idx: HashMap<String, usize>,\n    num_exprs: usize,\n    size_limit: usize,\n    suffix_cache: SuffixCache,\n    utf8_seqs: Option<Utf8Sequences>,\n    byte_classes: ByteClassSet,\n    extra_inst_bytes: usize,\n}\n\nimpl Compiler {\n    /// Create a new regular expression compiler.\n    ///\n    /// Various options can be set before calling `compile` on an expression.\n    pub fn new() -> Self {\n        Compiler {\n            insts: vec![],\n            compiled: Program::new(),\n            capture_name_idx: HashMap::new(),\n            num_exprs: 0,\n            size_limit: 10 * (1 << 20),\n            suffix_cache: SuffixCache::new(1000),\n            utf8_seqs: Some(Utf8Sequences::new('\\x00', '\\x00')),\n            byte_classes: ByteClassSet::new(),\n            extra_inst_bytes: 0,\n        }\n    }\n\n    /// The size of the resulting program is limited by size_limit. If\n    /// the program approximately exceeds the given size (in bytes), then\n    /// compilation will stop and return an error.\n    pub fn size_limit(mut self, size_limit: usize) -> Self {\n        self.size_limit = size_limit;\n        self\n    }\n\n    /// If bytes is true, then the program is compiled as a byte based\n    /// automaton, which incorporates UTF-8 decoding into the machine. If it's\n    /// false, then the automaton is Unicode scalar value based, e.g., an\n    /// engine utilizing such an automaton is responsible for UTF-8 decoding.\n    ///\n    /// The specific invariant is that when returning a byte based machine,\n    /// the neither the `Char` nor `Ranges` instructions are produced.\n    /// Conversely, when producing a Unicode scalar value machine, the `Bytes`\n    /// instruction is never produced.\n    ///\n    /// Note that `dfa(true)` implies `bytes(true)`.\n    pub fn bytes(mut self, yes: bool) -> Self {\n        self.compiled.is_bytes = yes;\n        self\n    }\n\n    /// When disabled, the program compiled may match arbitrary bytes.\n    ///\n    /// When enabled (the default), all compiled programs exclusively match\n    /// valid UTF-8 bytes.\n    pub fn only_utf8(mut self, yes: bool) -> Self {\n        self.compiled.only_utf8 = yes;\n        self\n    }\n\n    /// When set, the machine returned is suitable for use in the DFA matching\n    /// engine.\n    ///\n    /// In particular, this ensures that if the regex is not anchored in the\n    /// beginning, then a preceding `.*?` is included in the program. (The NFA\n    /// based engines handle the preceding `.*?` explicitly, which is difficult\n    /// or impossible in the DFA engine.)\n    pub fn dfa(mut self, yes: bool) -> Self {\n        self.compiled.is_dfa = yes;\n        self\n    }\n\n    /// When set, the machine returned is suitable for matching text in\n    /// reverse. In particular, all concatenations are flipped.\n    pub fn reverse(mut self, yes: bool) -> Self {\n        self.compiled.is_reverse = yes;\n        self\n    }\n\n    /// Compile a regular expression given its AST.\n    ///\n    /// The compiler is guaranteed to succeed unless the program exceeds the\n    /// specified size limit. If the size limit is exceeded, then compilation\n    /// stops and returns an error.\n    pub fn compile(mut self, exprs: &[Hir]) -> result::Result<Program, Error> {\n        debug_assert!(!exprs.is_empty());\n        self.num_exprs = exprs.len();\n        if exprs.len() == 1 {\n            self.compile_one(&exprs[0])\n        } else {\n            self.compile_many(exprs)\n        }\n    }\n\n    fn compile_one(mut self, expr: &Hir) -> result::Result<Program, Error> {\n        // If we're compiling a forward DFA and we aren't anchored, then\n        // add a `.*?` before the first capture group.\n        // Other matching engines handle this by baking the logic into the\n        // matching engine itself.\n        let mut dotstar_patch = Patch { hole: Hole::None, entry: 0 };\n        self.compiled.is_anchored_start = expr.is_anchored_start();\n        self.compiled.is_anchored_end = expr.is_anchored_end();\n        if self.compiled.needs_dotstar() {\n            dotstar_patch = self.c_dotstar()?;\n            self.compiled.start = dotstar_patch.entry;\n        }\n        self.compiled.captures = vec![None];\n        let patch = self.c_capture(0, expr)?.unwrap_or(self.next_inst());\n        if self.compiled.needs_dotstar() {\n            self.fill(dotstar_patch.hole, patch.entry);\n        } else {\n            self.compiled.start = patch.entry;\n        }\n        self.fill_to_next(patch.hole);\n        self.compiled.matches = vec![self.insts.len()];\n        self.push_compiled(Inst::Match(0));\n        self.compile_finish()\n    }\n\n    fn compile_many(\n        mut self,\n        exprs: &[Hir],\n    ) -> result::Result<Program, Error> {\n        debug_assert!(exprs.len() > 1);\n\n        self.compiled.is_anchored_start =\n            exprs.iter().all(|e| e.is_anchored_start());\n        self.compiled.is_anchored_end =\n            exprs.iter().all(|e| e.is_anchored_end());\n        let mut dotstar_patch = Patch { hole: Hole::None, entry: 0 };\n        if self.compiled.needs_dotstar() {\n            dotstar_patch = self.c_dotstar()?;\n            self.compiled.start = dotstar_patch.entry;\n        } else {\n            self.compiled.start = 0; // first instruction is always split\n        }\n        self.fill_to_next(dotstar_patch.hole);\n\n        let mut prev_hole = Hole::None;\n        for (i, expr) in exprs[0..exprs.len() - 1].iter().enumerate() {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let Patch { hole, entry } =\n                self.c_capture(0, expr)?.unwrap_or(self.next_inst());\n            self.fill_to_next(hole);\n            self.compiled.matches.push(self.insts.len());\n            self.push_compiled(Inst::Match(i));\n            prev_hole = self.fill_split(split, Some(entry), None);\n        }\n        let i = exprs.len() - 1;\n        let Patch { hole, entry } =\n            self.c_capture(0, &exprs[i])?.unwrap_or(self.next_inst());\n        self.fill(prev_hole, entry);\n        self.fill_to_next(hole);\n        self.compiled.matches.push(self.insts.len());\n        self.push_compiled(Inst::Match(i));\n        self.compile_finish()\n    }\n\n    fn compile_finish(mut self) -> result::Result<Program, Error> {\n        self.compiled.insts =\n            self.insts.into_iter().map(|inst| inst.unwrap()).collect();\n        self.compiled.byte_classes = self.byte_classes.byte_classes();\n        self.compiled.capture_name_idx = Arc::new(self.capture_name_idx);\n        Ok(self.compiled)\n    }\n\n    /// Compile expr into self.insts, returning a patch on success,\n    /// or an error if we run out of memory.\n    ///\n    /// All of the c_* methods of the compiler share the contract outlined\n    /// here.\n    ///\n    /// The main thing that a c_* method does is mutate `self.insts`\n    /// to add a list of mostly compiled instructions required to execute\n    /// the given expression. `self.insts` contains MaybeInsts rather than\n    /// Insts because there is some backpatching required.\n    ///\n    /// The `Patch` value returned by each c_* method provides metadata\n    /// about the compiled instructions emitted to `self.insts`. The\n    /// `entry` member of the patch refers to the first instruction\n    /// (the entry point), while the `hole` member contains zero or\n    /// more offsets to partial instructions that need to be backpatched.\n    /// The c_* routine can't know where its list of instructions are going to\n    /// jump to after execution, so it is up to the caller to patch\n    /// these jumps to point to the right place. So compiling some\n    /// expression, e, we would end up with a situation that looked like:\n    ///\n    /// ```text\n    /// self.insts = [ ..., i1, i2, ..., iexit1, ..., iexitn, ...]\n    ///                     ^              ^             ^\n    ///                     |                \\         /\n    ///                   entry                \\     /\n    ///                                         hole\n    /// ```\n    ///\n    /// To compile two expressions, e1 and e2, concatenated together we\n    /// would do:\n    ///\n    /// ```ignore\n    /// let patch1 = self.c(e1);\n    /// let patch2 = self.c(e2);\n    /// ```\n    ///\n    /// while leaves us with a situation that looks like\n    ///\n    /// ```text\n    /// self.insts = [ ..., i1, ..., iexit1, ..., i2, ..., iexit2 ]\n    ///                     ^        ^            ^        ^\n    ///                     |        |            |        |\n    ///                entry1        hole1   entry2        hole2\n    /// ```\n    ///\n    /// Then to merge the two patches together into one we would backpatch\n    /// hole1 with entry2 and return a new patch that enters at entry1\n    /// and has hole2 for a hole. In fact, if you look at the c_concat\n    /// method you will see that it does exactly this, though it handles\n    /// a list of expressions rather than just the two that we use for\n    /// an example.\n    ///\n    /// Ok(None) is returned when an expression is compiled to no\n    /// instruction, and so no patch.entry value makes sense.\n    fn c(&mut self, expr: &Hir) -> ResultOrEmpty {\n        use crate::prog;\n        use regex_syntax::hir::HirKind::*;\n\n        self.check_size()?;\n        match *expr.kind() {\n            Empty => Ok(None),\n            Literal(hir::Literal::Unicode(c)) => self.c_char(c),\n            Literal(hir::Literal::Byte(b)) => {\n                assert!(self.compiled.uses_bytes());\n                self.c_byte(b)\n            }\n            Class(hir::Class::Unicode(ref cls)) => self.c_class(cls.ranges()),\n            Class(hir::Class::Bytes(ref cls)) => {\n                if self.compiled.uses_bytes() {\n                    self.c_class_bytes(cls.ranges())\n                } else {\n                    assert!(cls.is_all_ascii());\n                    let mut char_ranges = vec![];\n                    for r in cls.iter() {\n                        let (s, e) = (r.start() as char, r.end() as char);\n                        char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n                    }\n                    self.c_class(&char_ranges)\n                }\n            }\n            Anchor(hir::Anchor::StartLine) if self.compiled.is_reverse => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::EndLine)\n            }\n            Anchor(hir::Anchor::StartLine) => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::StartLine)\n            }\n            Anchor(hir::Anchor::EndLine) if self.compiled.is_reverse => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::StartLine)\n            }\n            Anchor(hir::Anchor::EndLine) => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::EndLine)\n            }\n            Anchor(hir::Anchor::StartText) if self.compiled.is_reverse => {\n                self.c_empty_look(prog::EmptyLook::EndText)\n            }\n            Anchor(hir::Anchor::StartText) => {\n                self.c_empty_look(prog::EmptyLook::StartText)\n            }\n            Anchor(hir::Anchor::EndText) if self.compiled.is_reverse => {\n                self.c_empty_look(prog::EmptyLook::StartText)\n            }\n            Anchor(hir::Anchor::EndText) => {\n                self.c_empty_look(prog::EmptyLook::EndText)\n            }\n            WordBoundary(hir::WordBoundary::Unicode) => {\n                if !cfg!(feature = \"unicode-perl\") {\n                    return Err(Error::Syntax(\n                        \"Unicode word boundaries are unavailable when \\\n                         the unicode-perl feature is disabled\"\n                            .to_string(),\n                    ));\n                }\n                self.compiled.has_unicode_word_boundary = true;\n                self.byte_classes.set_word_boundary();\n                // We also make sure that all ASCII bytes are in a different\n                // class from non-ASCII bytes. Otherwise, it's possible for\n                // ASCII bytes to get lumped into the same class as non-ASCII\n                // bytes. This in turn may cause the lazy DFA to falsely start\n                // when it sees an ASCII byte that maps to a byte class with\n                // non-ASCII bytes. This ensures that never happens.\n                self.byte_classes.set_range(0, 0x7F);\n                self.c_empty_look(prog::EmptyLook::WordBoundary)\n            }\n            WordBoundary(hir::WordBoundary::UnicodeNegate) => {\n                if !cfg!(feature = \"unicode-perl\") {\n                    return Err(Error::Syntax(\n                        \"Unicode word boundaries are unavailable when \\\n                         the unicode-perl feature is disabled\"\n                            .to_string(),\n                    ));\n                }\n                self.compiled.has_unicode_word_boundary = true;\n                self.byte_classes.set_word_boundary();\n                // See comments above for why we set the ASCII range here.\n                self.byte_classes.set_range(0, 0x7F);\n                self.c_empty_look(prog::EmptyLook::NotWordBoundary)\n            }\n            WordBoundary(hir::WordBoundary::Ascii) => {\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)\n            }\n            WordBoundary(hir::WordBoundary::AsciiNegate) => {\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)\n            }\n            Group(ref g) => match g.kind {\n                hir::GroupKind::NonCapturing => self.c(&g.hir),\n                hir::GroupKind::CaptureIndex(index) => {\n                    if index as usize >= self.compiled.captures.len() {\n                        self.compiled.captures.push(None);\n                    }\n                    self.c_capture(2 * index as usize, &g.hir)\n                }\n                hir::GroupKind::CaptureName { index, ref name } => {\n                    if index as usize >= self.compiled.captures.len() {\n                        let n = name.to_string();\n                        self.compiled.captures.push(Some(n.clone()));\n                        self.capture_name_idx.insert(n, index as usize);\n                    }\n                    self.c_capture(2 * index as usize, &g.hir)\n                }\n            },\n            Concat(ref es) => {\n                if self.compiled.is_reverse {\n                    self.c_concat(es.iter().rev())\n                } else {\n                    self.c_concat(es)\n                }\n            }\n            Alternation(ref es) => self.c_alternate(&**es),\n            Repetition(ref rep) => self.c_repeat(rep),\n        }\n    }\n\n    fn c_capture(&mut self, first_slot: usize, expr: &Hir) -> ResultOrEmpty {\n        if self.num_exprs > 1 || self.compiled.is_dfa {\n            // Don't ever compile Save instructions for regex sets because\n            // they are never used. They are also never used in DFA programs\n            // because DFAs can't handle captures.\n            self.c(expr)\n        } else {\n            let entry = self.insts.len();\n            let hole = self.push_hole(InstHole::Save { slot: first_slot });\n            let patch = self.c(expr)?.unwrap_or(self.next_inst());\n            self.fill(hole, patch.entry);\n            self.fill_to_next(patch.hole);\n            let hole = self.push_hole(InstHole::Save { slot: first_slot + 1 });\n            Ok(Some(Patch { hole: hole, entry: entry }))\n        }\n    }\n\n    fn c_dotstar(&mut self) -> Result {\n        Ok(if !self.compiled.only_utf8() {\n            self.c(&Hir::repetition(hir::Repetition {\n                kind: hir::RepetitionKind::ZeroOrMore,\n                greedy: false,\n                hir: Box::new(Hir::any(true)),\n            }))?\n            .unwrap()\n        } else {\n            self.c(&Hir::repetition(hir::Repetition {\n                kind: hir::RepetitionKind::ZeroOrMore,\n                greedy: false,\n                hir: Box::new(Hir::any(false)),\n            }))?\n            .unwrap()\n        })\n    }\n\n    fn c_char(&mut self, c: char) -> ResultOrEmpty {\n        if self.compiled.uses_bytes() {\n            if c.is_ascii() {\n                let b = c as u8;\n                let hole =\n                    self.push_hole(InstHole::Bytes { start: b, end: b });\n                self.byte_classes.set_range(b, b);\n                Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))\n            } else {\n                self.c_class(&[hir::ClassUnicodeRange::new(c, c)])\n            }\n        } else {\n            let hole = self.push_hole(InstHole::Char { c: c });\n            Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))\n        }\n    }\n\n    fn c_class(&mut self, ranges: &[hir::ClassUnicodeRange]) -> ResultOrEmpty {\n        use std::mem::size_of;\n\n        assert!(!ranges.is_empty());\n        if self.compiled.uses_bytes() {\n            Ok(Some(CompileClass { c: self, ranges: ranges }.compile()?))\n        } else {\n            let ranges: Vec<(char, char)> =\n                ranges.iter().map(|r| (r.start(), r.end())).collect();\n            let hole = if ranges.len() == 1 && ranges[0].0 == ranges[0].1 {\n                self.push_hole(InstHole::Char { c: ranges[0].0 })\n            } else {\n                self.extra_inst_bytes +=\n                    ranges.len() * (size_of::<char>() * 2);\n                self.push_hole(InstHole::Ranges { ranges: ranges })\n            };\n            Ok(Some(Patch { hole: hole, entry: self.insts.len() - 1 }))\n        }\n    }\n\n    fn c_byte(&mut self, b: u8) -> ResultOrEmpty {\n        self.c_class_bytes(&[hir::ClassBytesRange::new(b, b)])\n    }\n\n    fn c_class_bytes(\n        &mut self,\n        ranges: &[hir::ClassBytesRange],\n    ) -> ResultOrEmpty {\n        debug_assert!(!ranges.is_empty());\n\n        let first_split_entry = self.insts.len();\n        let mut holes = vec![];\n        let mut prev_hole = Hole::None;\n        for r in &ranges[0..ranges.len() - 1] {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let next = self.insts.len();\n            self.byte_classes.set_range(r.start(), r.end());\n            holes.push(self.push_hole(InstHole::Bytes {\n                start: r.start(),\n                end: r.end(),\n            }));\n            prev_hole = self.fill_split(split, Some(next), None);\n        }\n        let next = self.insts.len();\n        let r = &ranges[ranges.len() - 1];\n        self.byte_classes.set_range(r.start(), r.end());\n        holes.push(\n            self.push_hole(InstHole::Bytes { start: r.start(), end: r.end() }),\n        );\n        self.fill(prev_hole, next);\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))\n    }\n\n    fn c_empty_look(&mut self, look: EmptyLook) -> ResultOrEmpty {\n        let hole = self.push_hole(InstHole::EmptyLook { look: look });\n        Ok(Some(Patch { hole: hole, entry: self.insts.len() - 1 }))\n    }\n\n    fn c_concat<'a, I>(&mut self, exprs: I) -> ResultOrEmpty\n    where\n        I: IntoIterator<Item = &'a Hir>,\n    {\n        let mut exprs = exprs.into_iter();\n        let Patch { mut hole, entry } = loop {\n            match exprs.next() {\n                None => return Ok(None),\n                Some(e) => {\n                    if let Some(p) = self.c(e)? {\n                        break p;\n                    }\n                }\n            }\n        };\n        for e in exprs {\n            if let Some(p) = self.c(e)? {\n                self.fill(hole, p.entry);\n                hole = p.hole;\n            }\n        }\n        Ok(Some(Patch { hole: hole, entry: entry }))\n    }\n\n    fn c_alternate(&mut self, exprs: &[Hir]) -> ResultOrEmpty {\n        debug_assert!(\n            exprs.len() >= 2,\n            \"alternates must have at least 2 exprs\"\n        );\n\n        // Initial entry point is always the first split.\n        let first_split_entry = self.insts.len();\n\n        // Save up all of the holes from each alternate. They will all get\n        // patched to point to the same location.\n        let mut holes = vec![];\n\n        // true indicates that the hole is a split where we want to fill\n        // the second branch.\n        let mut prev_hole = (Hole::None, false);\n        for e in &exprs[0..exprs.len() - 1] {\n            if prev_hole.1 {\n                let next = self.insts.len();\n                self.fill_split(prev_hole.0, None, Some(next));\n            } else {\n                self.fill_to_next(prev_hole.0);\n            }\n            let split = self.push_split_hole();\n            if let Some(Patch { hole, entry }) = self.c(e)? {\n                holes.push(hole);\n                prev_hole = (self.fill_split(split, Some(entry), None), false);\n            } else {\n                let (split1, split2) = split.dup_one();\n                holes.push(split1);\n                prev_hole = (split2, true);\n            }\n        }\n        if let Some(Patch { hole, entry }) = self.c(&exprs[exprs.len() - 1])? {\n            holes.push(hole);\n            if prev_hole.1 {\n                self.fill_split(prev_hole.0, None, Some(entry));\n            } else {\n                self.fill(prev_hole.0, entry);\n            }\n        } else {\n            // We ignore prev_hole.1. When it's true, it means we have two\n            // empty branches both pushing prev_hole.0 into holes, so both\n            // branches will go to the same place anyway.\n            holes.push(prev_hole.0);\n        }\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))\n    }\n\n    fn c_repeat(&mut self, rep: &hir::Repetition) -> ResultOrEmpty {\n        use regex_syntax::hir::RepetitionKind::*;\n        match rep.kind {\n            ZeroOrOne => self.c_repeat_zero_or_one(&rep.hir, rep.greedy),\n            ZeroOrMore => self.c_repeat_zero_or_more(&rep.hir, rep.greedy),\n            OneOrMore => self.c_repeat_one_or_more(&rep.hir, rep.greedy),\n            Range(hir::RepetitionRange::Exactly(min_max)) => {\n                self.c_repeat_range(&rep.hir, rep.greedy, min_max, min_max)\n            }\n            Range(hir::RepetitionRange::AtLeast(min)) => {\n                self.c_repeat_range_min_or_more(&rep.hir, rep.greedy, min)\n            }\n            Range(hir::RepetitionRange::Bounded(min, max)) => {\n                self.c_repeat_range(&rep.hir, rep.greedy, min, max)\n            }\n        }\n    }\n\n    fn c_repeat_zero_or_one(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty {\n        let split_entry = self.insts.len();\n        let split = self.push_split_hole();\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return self.pop_split_hole(),\n        };\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        let holes = vec![hole_rep, split_hole];\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: split_entry }))\n    }\n\n    fn c_repeat_zero_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty {\n        let split_entry = self.insts.len();\n        let split = self.push_split_hole();\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return self.pop_split_hole(),\n        };\n\n        self.fill(hole_rep, split_entry);\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        Ok(Some(Patch { hole: split_hole, entry: split_entry }))\n    }\n\n    fn c_repeat_one_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty {\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return Ok(None),\n        };\n        self.fill_to_next(hole_rep);\n        let split = self.push_split_hole();\n\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        Ok(Some(Patch { hole: split_hole, entry: entry_rep }))\n    }\n\n    fn c_repeat_range_min_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n        min: u32,\n    ) -> ResultOrEmpty {\n        let min = u32_to_usize(min);\n        // Using next_inst() is ok, because we can't return it (concat would\n        // have to return Some(_) while c_repeat_range_min_or_more returns\n        // None).\n        let patch_concat = self\n            .c_concat(iter::repeat(expr).take(min))?\n            .unwrap_or(self.next_inst());\n        if let Some(patch_rep) = self.c_repeat_zero_or_more(expr, greedy)? {\n            self.fill(patch_concat.hole, patch_rep.entry);\n            Ok(Some(Patch { hole: patch_rep.hole, entry: patch_concat.entry }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn c_repeat_range(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n        min: u32,\n        max: u32,\n    ) -> ResultOrEmpty {\n        let (min, max) = (u32_to_usize(min), u32_to_usize(max));\n        debug_assert!(min <= max);\n        let patch_concat = self.c_concat(iter::repeat(expr).take(min))?;\n        if min == max {\n            return Ok(patch_concat);\n        }\n        // Same reasoning as in c_repeat_range_min_or_more (we know that min <\n        // max at this point).\n        let patch_concat = patch_concat.unwrap_or(self.next_inst());\n        let initial_entry = patch_concat.entry;\n        // It is much simpler to compile, e.g., `a{2,5}` as:\n        //\n        //     aaa?a?a?\n        //\n        // But you end up with a sequence of instructions like this:\n        //\n        //     0: 'a'\n        //     1: 'a',\n        //     2: split(3, 4)\n        //     3: 'a'\n        //     4: split(5, 6)\n        //     5: 'a'\n        //     6: split(7, 8)\n        //     7: 'a'\n        //     8: MATCH\n        //\n        // This is *incredibly* inefficient because the splits end\n        // up forming a chain, which has to be resolved everything a\n        // transition is followed.\n        let mut holes = vec![];\n        let mut prev_hole = patch_concat.hole;\n        for _ in min..max {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let Patch { hole, entry } = match self.c(expr)? {\n                Some(p) => p,\n                None => return self.pop_split_hole(),\n            };\n            prev_hole = hole;\n            if greedy {\n                holes.push(self.fill_split(split, Some(entry), None));\n            } else {\n                holes.push(self.fill_split(split, None, Some(entry)));\n            }\n        }\n        holes.push(prev_hole);\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: initial_entry }))\n    }\n\n    /// Can be used as a default value for the c_* functions when the call to\n    /// c_function is followed by inserting at least one instruction that is\n    /// always executed after the ones written by the c* function.\n    fn next_inst(&self) -> Patch {\n        Patch { hole: Hole::None, entry: self.insts.len() }\n    }\n\n    fn fill(&mut self, hole: Hole, goto: InstPtr) {\n        match hole {\n            Hole::None => {}\n            Hole::One(pc) => {\n                self.insts[pc].fill(goto);\n            }\n            Hole::Many(holes) => {\n                for hole in holes {\n                    self.fill(hole, goto);\n                }\n            }\n        }\n    }\n\n    fn fill_to_next(&mut self, hole: Hole) {\n        let next = self.insts.len();\n        self.fill(hole, next);\n    }\n\n    fn fill_split(\n        &mut self,\n        hole: Hole,\n        goto1: Option<InstPtr>,\n        goto2: Option<InstPtr>,\n    ) -> Hole {\n        match hole {\n            Hole::None => Hole::None,\n            Hole::One(pc) => match (goto1, goto2) {\n                (Some(goto1), Some(goto2)) => {\n                    self.insts[pc].fill_split(goto1, goto2);\n                    Hole::None\n                }\n                (Some(goto1), None) => {\n                    self.insts[pc].half_fill_split_goto1(goto1);\n                    Hole::One(pc)\n                }\n                (None, Some(goto2)) => {\n                    self.insts[pc].half_fill_split_goto2(goto2);\n                    Hole::One(pc)\n                }\n                (None, None) => unreachable!(\n                    \"at least one of the split \\\n                     holes must be filled\"\n                ),\n            },\n            Hole::Many(holes) => {\n                let mut new_holes = vec![];\n                for hole in holes {\n                    new_holes.push(self.fill_split(hole, goto1, goto2));\n                }\n                if new_holes.is_empty() {\n                    Hole::None\n                } else if new_holes.len() == 1 {\n                    new_holes.pop().unwrap()\n                } else {\n                    Hole::Many(new_holes)\n                }\n            }\n        }\n    }\n\n    fn push_compiled(&mut self, inst: Inst) {\n        self.insts.push(MaybeInst::Compiled(inst));\n    }\n\n    fn push_hole(&mut self, inst: InstHole) -> Hole {\n        let hole = self.insts.len();\n        self.insts.push(MaybeInst::Uncompiled(inst));\n        Hole::One(hole)\n    }\n\n    fn push_split_hole(&mut self) -> Hole {\n        let hole = self.insts.len();\n        self.insts.push(MaybeInst::Split);\n        Hole::One(hole)\n    }\n\n    fn pop_split_hole(&mut self) -> ResultOrEmpty {\n        self.insts.pop();\n        Ok(None)\n    }\n\n    fn check_size(&self) -> result::Result<(), Error> {\n        use std::mem::size_of;\n\n        let size =\n            self.extra_inst_bytes + (self.insts.len() * size_of::<Inst>());\n        if size > self.size_limit {\n            Err(Error::CompiledTooBig(self.size_limit))\n        } else {\n            Ok(())\n        }\n    }\n}\n\n#[derive(Debug)]\nenum Hole {\n    None,\n    One(InstPtr),\n    Many(Vec<Hole>),\n}\n\nimpl Hole {\n    fn dup_one(self) -> (Self, Self) {\n        match self {\n            Hole::One(pc) => (Hole::One(pc), Hole::One(pc)),\n            Hole::None | Hole::Many(_) => {\n                unreachable!(\"must be called on single hole\")\n            }\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nenum MaybeInst {\n    Compiled(Inst),\n    Uncompiled(InstHole),\n    Split,\n    Split1(InstPtr),\n    Split2(InstPtr),\n}\n\nimpl MaybeInst {\n    fn fill(&mut self, goto: InstPtr) {\n        let maybeinst = match *self {\n            MaybeInst::Split => MaybeInst::Split1(goto),\n            MaybeInst::Uncompiled(ref inst) => {\n                MaybeInst::Compiled(inst.fill(goto))\n            }\n            MaybeInst::Split1(goto1) => {\n                MaybeInst::Compiled(Inst::Split(InstSplit {\n                    goto1: goto1,\n                    goto2: goto,\n                }))\n            }\n            MaybeInst::Split2(goto2) => {\n                MaybeInst::Compiled(Inst::Split(InstSplit {\n                    goto1: goto,\n                    goto2: goto2,\n                }))\n            }\n            _ => unreachable!(\n                \"not all instructions were compiled! \\\n                 found uncompiled instruction: {:?}\",\n                self\n            ),\n        };\n        *self = maybeinst;\n    }\n\n    fn fill_split(&mut self, goto1: InstPtr, goto2: InstPtr) {\n        let filled = match *self {\n            MaybeInst::Split => {\n                Inst::Split(InstSplit { goto1: goto1, goto2: goto2 })\n            }\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Compiled(filled);\n    }\n\n    fn half_fill_split_goto1(&mut self, goto1: InstPtr) {\n        let half_filled = match *self {\n            MaybeInst::Split => goto1,\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Split1(half_filled);\n    }\n\n    fn half_fill_split_goto2(&mut self, goto2: InstPtr) {\n        let half_filled = match *self {\n            MaybeInst::Split => goto2,\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Split2(half_filled);\n    }\n\n    fn unwrap(self) -> Inst {\n        match self {\n            MaybeInst::Compiled(inst) => inst,\n            _ => unreachable!(\n                \"must be called on a compiled instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nenum InstHole {\n    Save { slot: usize },\n    EmptyLook { look: EmptyLook },\n    Char { c: char },\n    Ranges { ranges: Vec<(char, char)> },\n    Bytes { start: u8, end: u8 },\n}\n\nimpl InstHole {\n    fn fill(&self, goto: InstPtr) -> Inst {\n        match *self {\n            InstHole::Save { slot } => {\n                Inst::Save(InstSave { goto: goto, slot: slot })\n            }\n            InstHole::EmptyLook { look } => {\n                Inst::EmptyLook(InstEmptyLook { goto: goto, look: look })\n            }\n            InstHole::Char { c } => Inst::Char(InstChar { goto: goto, c: c }),\n            InstHole::Ranges { ref ranges } => Inst::Ranges(InstRanges {\n                goto: goto,\n                ranges: ranges.clone().into_boxed_slice(),\n            }),\n            InstHole::Bytes { start, end } => {\n                Inst::Bytes(InstBytes { goto: goto, start: start, end: end })\n            }\n        }\n    }\n}\n\nstruct CompileClass<'a, 'b> {\n    c: &'a mut Compiler,\n    ranges: &'b [hir::ClassUnicodeRange],\n}\n\nimpl<'a, 'b> CompileClass<'a, 'b> {\n    fn compile(mut self) -> Result {\n        let mut holes = vec![];\n        let mut initial_entry = None;\n        let mut last_split = Hole::None;\n        let mut utf8_seqs = self.c.utf8_seqs.take().unwrap();\n        self.c.suffix_cache.clear();\n\n        for (i, range) in self.ranges.iter().enumerate() {\n            let is_last_range = i + 1 == self.ranges.len();\n            utf8_seqs.reset(range.start(), range.end());\n            let mut it = (&mut utf8_seqs).peekable();\n            loop {\n                let utf8_seq = match it.next() {\n                    None => break,\n                    Some(utf8_seq) => utf8_seq,\n                };\n                if is_last_range && it.peek().is_none() {\n                    let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;\n                    holes.push(hole);\n                    self.c.fill(last_split, entry);\n                    last_split = Hole::None;\n                    if initial_entry.is_none() {\n                        initial_entry = Some(entry);\n                    }\n                } else {\n                    if initial_entry.is_none() {\n                        initial_entry = Some(self.c.insts.len());\n                    }\n                    self.c.fill_to_next(last_split);\n                    last_split = self.c.push_split_hole();\n                    let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;\n                    holes.push(hole);\n                    last_split =\n                        self.c.fill_split(last_split, Some(entry), None);\n                }\n            }\n        }\n        self.c.utf8_seqs = Some(utf8_seqs);\n        Ok(Patch { hole: Hole::Many(holes), entry: initial_entry.unwrap() })\n    }\n\n    fn c_utf8_seq(&mut self, seq: &Utf8Sequence) -> Result {\n        if self.c.compiled.is_reverse {\n            self.c_utf8_seq_(seq)\n        } else {\n            self.c_utf8_seq_(seq.into_iter().rev())\n        }\n    }\n\n    fn c_utf8_seq_<'r, I>(&mut self, seq: I) -> Result\n    where\n        I: IntoIterator<Item = &'r Utf8Range>,\n    {\n        // The initial instruction for each UTF-8 sequence should be the same.\n        let mut from_inst = ::std::usize::MAX;\n        let mut last_hole = Hole::None;\n        for byte_range in seq {\n            let key = SuffixCacheKey {\n                from_inst: from_inst,\n                start: byte_range.start,\n                end: byte_range.end,\n            };\n            {\n                let pc = self.c.insts.len();\n                if let Some(cached_pc) = self.c.suffix_cache.get(key, pc) {\n                    from_inst = cached_pc;\n                    continue;\n                }\n            }\n            self.c.byte_classes.set_range(byte_range.start, byte_range.end);\n            if from_inst == ::std::usize::MAX {\n                last_hole = self.c.push_hole(InstHole::Bytes {\n                    start: byte_range.start,\n                    end: byte_range.end,\n                });\n            } else {\n                self.c.push_compiled(Inst::Bytes(InstBytes {\n                    goto: from_inst,\n                    start: byte_range.start,\n                    end: byte_range.end,\n                }));\n            }\n            from_inst = self.c.insts.len().checked_sub(1).unwrap();\n            debug_assert!(from_inst < ::std::usize::MAX);\n        }\n        debug_assert!(from_inst < ::std::usize::MAX);\n        Ok(Patch { hole: last_hole, entry: from_inst })\n    }\n}\n\n/// `SuffixCache` is a simple bounded hash map for caching suffix entries in\n/// UTF-8 automata. For example, consider the Unicode range \\u{0}-\\u{FFFF}.\n/// The set of byte ranges looks like this:\n///\n/// [0-7F]\n/// [C2-DF][80-BF]\n/// [E0][A0-BF][80-BF]\n/// [E1-EC][80-BF][80-BF]\n/// [ED][80-9F][80-BF]\n/// [EE-EF][80-BF][80-BF]\n///\n/// Each line above translates to one alternate in the compiled regex program.\n/// However, all but one of the alternates end in the same suffix, which is\n/// a waste of an instruction. The suffix cache facilitates reusing them across\n/// alternates.\n///\n/// Note that a HashMap could be trivially used for this, but we don't need its\n/// overhead. Some small bounded space (LRU style) is more than enough.\n///\n/// This uses similar idea to [`SparseSet`](../sparse/struct.SparseSet.html),\n/// except it uses hashes as original indices and then compares full keys for\n/// validation against `dense` array.\n#[derive(Debug)]\nstruct SuffixCache {\n    sparse: Box<[usize]>,\n    dense: Vec<SuffixCacheEntry>,\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]\nstruct SuffixCacheEntry {\n    key: SuffixCacheKey,\n    pc: InstPtr,\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]\nstruct SuffixCacheKey {\n    from_inst: InstPtr,\n    start: u8,\n    end: u8,\n}\n\nimpl SuffixCache {\n    fn new(size: usize) -> Self {\n        SuffixCache {\n            sparse: vec![0usize; size].into(),\n            dense: Vec::with_capacity(size),\n        }\n    }\n\n    fn get(&mut self, key: SuffixCacheKey, pc: InstPtr) -> Option<InstPtr> {\n        let hash = self.hash(&key);\n        let pos = &mut self.sparse[hash];\n        if let Some(entry) = self.dense.get(*pos) {\n            if entry.key == key {\n                return Some(entry.pc);\n            }\n        }\n        *pos = self.dense.len();\n        self.dense.push(SuffixCacheEntry { key: key, pc: pc });\n        None\n    }\n\n    fn clear(&mut self) {\n        self.dense.clear();\n    }\n\n    fn hash(&self, suffix: &SuffixCacheKey) -> usize {\n        // Basic FNV-1a hash as described:\n        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n        const FNV_PRIME: u64 = 1099511628211;\n        let mut h = 14695981039346656037;\n        h = (h ^ (suffix.from_inst as u64)).wrapping_mul(FNV_PRIME);\n        h = (h ^ (suffix.start as u64)).wrapping_mul(FNV_PRIME);\n        h = (h ^ (suffix.end as u64)).wrapping_mul(FNV_PRIME);\n        (h as usize) % self.sparse.len()\n    }\n}\n\nstruct ByteClassSet([bool; 256]);\n\nimpl ByteClassSet {\n    fn new() -> Self {\n        ByteClassSet([false; 256])\n    }\n\n    fn set_range(&mut self, start: u8, end: u8) {\n        debug_assert!(start <= end);\n        if start > 0 {\n            self.0[start as usize - 1] = true;\n        }\n        self.0[end as usize] = true;\n    }\n\n    fn set_word_boundary(&mut self) {\n        // We need to mark all ranges of bytes whose pairs result in\n        // evaluating \\b differently.\n        let iswb = is_word_byte;\n        let mut b1: u16 = 0;\n        let mut b2: u16;\n        while b1 <= 255 {\n            b2 = b1 + 1;\n            while b2 <= 255 && iswb(b1 as u8) == iswb(b2 as u8) {\n                b2 += 1;\n            }\n            self.set_range(b1 as u8, (b2 - 1) as u8);\n            b1 = b2;\n        }\n    }\n\n    fn byte_classes(&self) -> Vec<u8> {\n        // N.B. If you're debugging the DFA, it's useful to simply return\n        // `(0..256).collect()`, which effectively removes the byte classes\n        // and makes the transitions easier to read.\n        // (0usize..256).map(|x| x as u8).collect()\n        let mut byte_classes = vec![0; 256];\n        let mut class = 0u8;\n        let mut i = 0;\n        loop {\n            byte_classes[i] = class as u8;\n            if i >= 255 {\n                break;\n            }\n            if self.0[i] {\n                class = class.checked_add(1).unwrap();\n            }\n            i += 1;\n        }\n        byte_classes\n    }\n}\n\nimpl fmt::Debug for ByteClassSet {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"ByteClassSet\").field(&&self.0[..]).finish()\n    }\n}\n\nfn u32_to_usize(n: u32) -> usize {\n    // In case usize is less than 32 bits, we need to guard against overflow.\n    // On most platforms this compiles to nothing.\n    // TODO Use `std::convert::TryFrom` once it's stable.\n    if (n as u64) > (::std::usize::MAX as u64) {\n        panic!(\"BUG: {} is too big to be pointer sized\", n)\n    }\n    n as usize\n}\n\n#[cfg(test)]\nmod tests {\n    use super::ByteClassSet;\n\n    #[test]\n    fn byte_classes() {\n        let mut set = ByteClassSet::new();\n        set.set_range(b'a', b'z');\n        let classes = set.byte_classes();\n        assert_eq!(classes[0], 0);\n        assert_eq!(classes[1], 0);\n        assert_eq!(classes[2], 0);\n        assert_eq!(classes[b'a' as usize - 1], 0);\n        assert_eq!(classes[b'a' as usize], 1);\n        assert_eq!(classes[b'm' as usize], 1);\n        assert_eq!(classes[b'z' as usize], 1);\n        assert_eq!(classes[b'z' as usize + 1], 2);\n        assert_eq!(classes[254], 2);\n        assert_eq!(classes[255], 2);\n\n        let mut set = ByteClassSet::new();\n        set.set_range(0, 2);\n        set.set_range(4, 6);\n        let classes = set.byte_classes();\n        assert_eq!(classes[0], 0);\n        assert_eq!(classes[1], 0);\n        assert_eq!(classes[2], 0);\n        assert_eq!(classes[3], 1);\n        assert_eq!(classes[4], 2);\n        assert_eq!(classes[5], 2);\n        assert_eq!(classes[6], 2);\n        assert_eq!(classes[7], 3);\n        assert_eq!(classes[255], 3);\n    }\n\n    #[test]\n    fn full_byte_classes() {\n        let mut set = ByteClassSet::new();\n        for i in 0..256u16 {\n            set.set_range(i as u8, i as u8);\n        }\n        assert_eq!(set.byte_classes().len(), 256);\n    }\n}\n", "#![cfg_attr(feature = \"pattern\", feature(pattern))]\n\nuse regex;\n\n// Due to macro scoping rules, this definition only applies for the modules\n// defined below. Effectively, it allows us to use the same tests for both\n// native and dynamic regexes.\n//\n// This is also used to test the various matching engines. This one exercises\n// the normal code path which automatically chooses the engine based on the\n// regex and the input. Other dynamic tests explicitly set the engine to use.\nmacro_rules! regex_new {\n    ($re:expr) => {{\n        use regex::Regex;\n        Regex::new($re)\n    }};\n}\n\nmacro_rules! regex {\n    ($re:expr) => {\n        regex_new!($re).unwrap()\n    };\n}\n\nmacro_rules! regex_set_new {\n    ($re:expr) => {{\n        use regex::RegexSet;\n        RegexSet::new($re)\n    }};\n}\n\nmacro_rules! regex_set {\n    ($res:expr) => {\n        regex_set_new!($res).unwrap()\n    };\n}\n\n// Must come before other module definitions.\ninclude!(\"macros_str.rs\");\ninclude!(\"macros.rs\");\n\nmod api;\nmod api_str;\nmod crazy;\nmod flags;\nmod fowler;\nmod misc;\nmod multiline;\nmod noparse;\nmod regression;\nmod regression_fuzz;\nmod replace;\nmod searcher;\nmod set;\nmod shortest_match;\nmod suffix_reverse;\n#[cfg(feature = \"unicode\")]\nmod unicode;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary_unicode;\n\n#[test]\nfn disallow_non_utf8() {\n    assert!(regex::Regex::new(r\"(?-u)\\xFF\").is_err());\n    assert!(regex::Regex::new(r\"(?-u).\").is_err());\n    assert!(regex::Regex::new(r\"(?-u)[\\xFF]\").is_err());\n    assert!(regex::Regex::new(r\"(?-u)\u2603\").is_err());\n}\n\n#[test]\nfn disallow_octal() {\n    assert!(regex::Regex::new(r\"\\0\").is_err());\n}\n\n#[test]\nfn allow_octal() {\n    assert!(regex::RegexBuilder::new(r\"\\0\").octal(true).build().is_ok());\n}\n\n#[test]\nfn oibits() {\n    use regex::bytes;\n    use regex::{Regex, RegexBuilder, RegexSet, RegexSetBuilder};\n    use std::panic::{RefUnwindSafe, UnwindSafe};\n\n    fn assert_send<T: Send>() {}\n    fn assert_sync<T: Sync>() {}\n    fn assert_unwind_safe<T: UnwindSafe>() {}\n    fn assert_ref_unwind_safe<T: RefUnwindSafe>() {}\n\n    assert_send::<Regex>();\n    assert_sync::<Regex>();\n    assert_unwind_safe::<Regex>();\n    assert_ref_unwind_safe::<Regex>();\n    assert_send::<RegexBuilder>();\n    assert_sync::<RegexBuilder>();\n    assert_unwind_safe::<RegexBuilder>();\n    assert_ref_unwind_safe::<RegexBuilder>();\n\n    assert_send::<bytes::Regex>();\n    assert_sync::<bytes::Regex>();\n    assert_unwind_safe::<bytes::Regex>();\n    assert_ref_unwind_safe::<bytes::Regex>();\n    assert_send::<bytes::RegexBuilder>();\n    assert_sync::<bytes::RegexBuilder>();\n    assert_unwind_safe::<bytes::RegexBuilder>();\n    assert_ref_unwind_safe::<bytes::RegexBuilder>();\n\n    assert_send::<RegexSet>();\n    assert_sync::<RegexSet>();\n    assert_unwind_safe::<RegexSet>();\n    assert_ref_unwind_safe::<RegexSet>();\n    assert_send::<RegexSetBuilder>();\n    assert_sync::<RegexSetBuilder>();\n    assert_unwind_safe::<RegexSetBuilder>();\n    assert_ref_unwind_safe::<RegexSetBuilder>();\n\n    assert_send::<bytes::RegexSet>();\n    assert_sync::<bytes::RegexSet>();\n    assert_unwind_safe::<bytes::RegexSet>();\n    assert_ref_unwind_safe::<bytes::RegexSet>();\n    assert_send::<bytes::RegexSetBuilder>();\n    assert_sync::<bytes::RegexSetBuilder>();\n    assert_unwind_safe::<bytes::RegexSetBuilder>();\n    assert_ref_unwind_safe::<bytes::RegexSetBuilder>();\n}\n\n// See: https://github.com/rust-lang/regex/issues/568\n#[test]\nfn oibits_regression() {\n    use regex::Regex;\n    use std::panic;\n\n    let _ = panic::catch_unwind(|| Regex::new(\"a\").unwrap());\n}\n\n// See: https://github.com/rust-lang/regex/issues/750\n#[test]\n#[cfg(target_pointer_width = \"64\")]\nfn regex_is_reasonably_small() {\n    use std::mem::size_of;\n\n    use regex::bytes;\n    use regex::{Regex, RegexSet};\n\n    assert_eq!(16, size_of::<Regex>());\n    assert_eq!(16, size_of::<RegexSet>());\n    assert_eq!(16, size_of::<bytes::Regex>());\n    assert_eq!(16, size_of::<bytes::RegexSet>());\n}\n"], "fixing_code": ["use std::collections::HashMap;\nuse std::fmt;\nuse std::iter;\nuse std::result;\nuse std::sync::Arc;\n\nuse regex_syntax::hir::{self, Hir};\nuse regex_syntax::is_word_byte;\nuse regex_syntax::utf8::{Utf8Range, Utf8Sequence, Utf8Sequences};\n\nuse crate::prog::{\n    EmptyLook, Inst, InstBytes, InstChar, InstEmptyLook, InstPtr, InstRanges,\n    InstSave, InstSplit, Program,\n};\n\nuse crate::Error;\n\ntype Result = result::Result<Patch, Error>;\ntype ResultOrEmpty = result::Result<Option<Patch>, Error>;\n\n#[derive(Debug)]\nstruct Patch {\n    hole: Hole,\n    entry: InstPtr,\n}\n\n/// A compiler translates a regular expression AST to a sequence of\n/// instructions. The sequence of instructions represents an NFA.\n// `Compiler` is only public via the `internal` module, so avoid deriving\n// `Debug`.\n#[allow(missing_debug_implementations)]\npub struct Compiler {\n    insts: Vec<MaybeInst>,\n    compiled: Program,\n    capture_name_idx: HashMap<String, usize>,\n    num_exprs: usize,\n    size_limit: usize,\n    suffix_cache: SuffixCache,\n    utf8_seqs: Option<Utf8Sequences>,\n    byte_classes: ByteClassSet,\n    // This keeps track of extra bytes allocated while compiling the regex\n    // program. Currently, this corresponds to two things. First is the heap\n    // memory allocated by Unicode character classes ('InstRanges'). Second is\n    // a \"fake\" amount of memory used by empty sub-expressions, so that enough\n    // empty sub-expressions will ultimately trigger the compiler to bail\n    // because of a size limit restriction. (That empty sub-expressions don't\n    // add to heap memory usage is more-or-less an implementation detail.) In\n    // the second case, if we don't bail, then an excessively large repetition\n    // on an empty sub-expression can result in the compiler using a very large\n    // amount of CPU time.\n    extra_inst_bytes: usize,\n}\n\nimpl Compiler {\n    /// Create a new regular expression compiler.\n    ///\n    /// Various options can be set before calling `compile` on an expression.\n    pub fn new() -> Self {\n        Compiler {\n            insts: vec![],\n            compiled: Program::new(),\n            capture_name_idx: HashMap::new(),\n            num_exprs: 0,\n            size_limit: 10 * (1 << 20),\n            suffix_cache: SuffixCache::new(1000),\n            utf8_seqs: Some(Utf8Sequences::new('\\x00', '\\x00')),\n            byte_classes: ByteClassSet::new(),\n            extra_inst_bytes: 0,\n        }\n    }\n\n    /// The size of the resulting program is limited by size_limit. If\n    /// the program approximately exceeds the given size (in bytes), then\n    /// compilation will stop and return an error.\n    pub fn size_limit(mut self, size_limit: usize) -> Self {\n        self.size_limit = size_limit;\n        self\n    }\n\n    /// If bytes is true, then the program is compiled as a byte based\n    /// automaton, which incorporates UTF-8 decoding into the machine. If it's\n    /// false, then the automaton is Unicode scalar value based, e.g., an\n    /// engine utilizing such an automaton is responsible for UTF-8 decoding.\n    ///\n    /// The specific invariant is that when returning a byte based machine,\n    /// the neither the `Char` nor `Ranges` instructions are produced.\n    /// Conversely, when producing a Unicode scalar value machine, the `Bytes`\n    /// instruction is never produced.\n    ///\n    /// Note that `dfa(true)` implies `bytes(true)`.\n    pub fn bytes(mut self, yes: bool) -> Self {\n        self.compiled.is_bytes = yes;\n        self\n    }\n\n    /// When disabled, the program compiled may match arbitrary bytes.\n    ///\n    /// When enabled (the default), all compiled programs exclusively match\n    /// valid UTF-8 bytes.\n    pub fn only_utf8(mut self, yes: bool) -> Self {\n        self.compiled.only_utf8 = yes;\n        self\n    }\n\n    /// When set, the machine returned is suitable for use in the DFA matching\n    /// engine.\n    ///\n    /// In particular, this ensures that if the regex is not anchored in the\n    /// beginning, then a preceding `.*?` is included in the program. (The NFA\n    /// based engines handle the preceding `.*?` explicitly, which is difficult\n    /// or impossible in the DFA engine.)\n    pub fn dfa(mut self, yes: bool) -> Self {\n        self.compiled.is_dfa = yes;\n        self\n    }\n\n    /// When set, the machine returned is suitable for matching text in\n    /// reverse. In particular, all concatenations are flipped.\n    pub fn reverse(mut self, yes: bool) -> Self {\n        self.compiled.is_reverse = yes;\n        self\n    }\n\n    /// Compile a regular expression given its AST.\n    ///\n    /// The compiler is guaranteed to succeed unless the program exceeds the\n    /// specified size limit. If the size limit is exceeded, then compilation\n    /// stops and returns an error.\n    pub fn compile(mut self, exprs: &[Hir]) -> result::Result<Program, Error> {\n        debug_assert!(!exprs.is_empty());\n        self.num_exprs = exprs.len();\n        if exprs.len() == 1 {\n            self.compile_one(&exprs[0])\n        } else {\n            self.compile_many(exprs)\n        }\n    }\n\n    fn compile_one(mut self, expr: &Hir) -> result::Result<Program, Error> {\n        // If we're compiling a forward DFA and we aren't anchored, then\n        // add a `.*?` before the first capture group.\n        // Other matching engines handle this by baking the logic into the\n        // matching engine itself.\n        let mut dotstar_patch = Patch { hole: Hole::None, entry: 0 };\n        self.compiled.is_anchored_start = expr.is_anchored_start();\n        self.compiled.is_anchored_end = expr.is_anchored_end();\n        if self.compiled.needs_dotstar() {\n            dotstar_patch = self.c_dotstar()?;\n            self.compiled.start = dotstar_patch.entry;\n        }\n        self.compiled.captures = vec![None];\n        let patch = self.c_capture(0, expr)?.unwrap_or(self.next_inst());\n        if self.compiled.needs_dotstar() {\n            self.fill(dotstar_patch.hole, patch.entry);\n        } else {\n            self.compiled.start = patch.entry;\n        }\n        self.fill_to_next(patch.hole);\n        self.compiled.matches = vec![self.insts.len()];\n        self.push_compiled(Inst::Match(0));\n        self.compile_finish()\n    }\n\n    fn compile_many(\n        mut self,\n        exprs: &[Hir],\n    ) -> result::Result<Program, Error> {\n        debug_assert!(exprs.len() > 1);\n\n        self.compiled.is_anchored_start =\n            exprs.iter().all(|e| e.is_anchored_start());\n        self.compiled.is_anchored_end =\n            exprs.iter().all(|e| e.is_anchored_end());\n        let mut dotstar_patch = Patch { hole: Hole::None, entry: 0 };\n        if self.compiled.needs_dotstar() {\n            dotstar_patch = self.c_dotstar()?;\n            self.compiled.start = dotstar_patch.entry;\n        } else {\n            self.compiled.start = 0; // first instruction is always split\n        }\n        self.fill_to_next(dotstar_patch.hole);\n\n        let mut prev_hole = Hole::None;\n        for (i, expr) in exprs[0..exprs.len() - 1].iter().enumerate() {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let Patch { hole, entry } =\n                self.c_capture(0, expr)?.unwrap_or(self.next_inst());\n            self.fill_to_next(hole);\n            self.compiled.matches.push(self.insts.len());\n            self.push_compiled(Inst::Match(i));\n            prev_hole = self.fill_split(split, Some(entry), None);\n        }\n        let i = exprs.len() - 1;\n        let Patch { hole, entry } =\n            self.c_capture(0, &exprs[i])?.unwrap_or(self.next_inst());\n        self.fill(prev_hole, entry);\n        self.fill_to_next(hole);\n        self.compiled.matches.push(self.insts.len());\n        self.push_compiled(Inst::Match(i));\n        self.compile_finish()\n    }\n\n    fn compile_finish(mut self) -> result::Result<Program, Error> {\n        self.compiled.insts =\n            self.insts.into_iter().map(|inst| inst.unwrap()).collect();\n        self.compiled.byte_classes = self.byte_classes.byte_classes();\n        self.compiled.capture_name_idx = Arc::new(self.capture_name_idx);\n        Ok(self.compiled)\n    }\n\n    /// Compile expr into self.insts, returning a patch on success,\n    /// or an error if we run out of memory.\n    ///\n    /// All of the c_* methods of the compiler share the contract outlined\n    /// here.\n    ///\n    /// The main thing that a c_* method does is mutate `self.insts`\n    /// to add a list of mostly compiled instructions required to execute\n    /// the given expression. `self.insts` contains MaybeInsts rather than\n    /// Insts because there is some backpatching required.\n    ///\n    /// The `Patch` value returned by each c_* method provides metadata\n    /// about the compiled instructions emitted to `self.insts`. The\n    /// `entry` member of the patch refers to the first instruction\n    /// (the entry point), while the `hole` member contains zero or\n    /// more offsets to partial instructions that need to be backpatched.\n    /// The c_* routine can't know where its list of instructions are going to\n    /// jump to after execution, so it is up to the caller to patch\n    /// these jumps to point to the right place. So compiling some\n    /// expression, e, we would end up with a situation that looked like:\n    ///\n    /// ```text\n    /// self.insts = [ ..., i1, i2, ..., iexit1, ..., iexitn, ...]\n    ///                     ^              ^             ^\n    ///                     |                \\         /\n    ///                   entry                \\     /\n    ///                                         hole\n    /// ```\n    ///\n    /// To compile two expressions, e1 and e2, concatenated together we\n    /// would do:\n    ///\n    /// ```ignore\n    /// let patch1 = self.c(e1);\n    /// let patch2 = self.c(e2);\n    /// ```\n    ///\n    /// while leaves us with a situation that looks like\n    ///\n    /// ```text\n    /// self.insts = [ ..., i1, ..., iexit1, ..., i2, ..., iexit2 ]\n    ///                     ^        ^            ^        ^\n    ///                     |        |            |        |\n    ///                entry1        hole1   entry2        hole2\n    /// ```\n    ///\n    /// Then to merge the two patches together into one we would backpatch\n    /// hole1 with entry2 and return a new patch that enters at entry1\n    /// and has hole2 for a hole. In fact, if you look at the c_concat\n    /// method you will see that it does exactly this, though it handles\n    /// a list of expressions rather than just the two that we use for\n    /// an example.\n    ///\n    /// Ok(None) is returned when an expression is compiled to no\n    /// instruction, and so no patch.entry value makes sense.\n    fn c(&mut self, expr: &Hir) -> ResultOrEmpty {\n        use crate::prog;\n        use regex_syntax::hir::HirKind::*;\n\n        self.check_size()?;\n        match *expr.kind() {\n            Empty => self.c_empty(),\n            Literal(hir::Literal::Unicode(c)) => self.c_char(c),\n            Literal(hir::Literal::Byte(b)) => {\n                assert!(self.compiled.uses_bytes());\n                self.c_byte(b)\n            }\n            Class(hir::Class::Unicode(ref cls)) => self.c_class(cls.ranges()),\n            Class(hir::Class::Bytes(ref cls)) => {\n                if self.compiled.uses_bytes() {\n                    self.c_class_bytes(cls.ranges())\n                } else {\n                    assert!(cls.is_all_ascii());\n                    let mut char_ranges = vec![];\n                    for r in cls.iter() {\n                        let (s, e) = (r.start() as char, r.end() as char);\n                        char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n                    }\n                    self.c_class(&char_ranges)\n                }\n            }\n            Anchor(hir::Anchor::StartLine) if self.compiled.is_reverse => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::EndLine)\n            }\n            Anchor(hir::Anchor::StartLine) => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::StartLine)\n            }\n            Anchor(hir::Anchor::EndLine) if self.compiled.is_reverse => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::StartLine)\n            }\n            Anchor(hir::Anchor::EndLine) => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::EndLine)\n            }\n            Anchor(hir::Anchor::StartText) if self.compiled.is_reverse => {\n                self.c_empty_look(prog::EmptyLook::EndText)\n            }\n            Anchor(hir::Anchor::StartText) => {\n                self.c_empty_look(prog::EmptyLook::StartText)\n            }\n            Anchor(hir::Anchor::EndText) if self.compiled.is_reverse => {\n                self.c_empty_look(prog::EmptyLook::StartText)\n            }\n            Anchor(hir::Anchor::EndText) => {\n                self.c_empty_look(prog::EmptyLook::EndText)\n            }\n            WordBoundary(hir::WordBoundary::Unicode) => {\n                if !cfg!(feature = \"unicode-perl\") {\n                    return Err(Error::Syntax(\n                        \"Unicode word boundaries are unavailable when \\\n                         the unicode-perl feature is disabled\"\n                            .to_string(),\n                    ));\n                }\n                self.compiled.has_unicode_word_boundary = true;\n                self.byte_classes.set_word_boundary();\n                // We also make sure that all ASCII bytes are in a different\n                // class from non-ASCII bytes. Otherwise, it's possible for\n                // ASCII bytes to get lumped into the same class as non-ASCII\n                // bytes. This in turn may cause the lazy DFA to falsely start\n                // when it sees an ASCII byte that maps to a byte class with\n                // non-ASCII bytes. This ensures that never happens.\n                self.byte_classes.set_range(0, 0x7F);\n                self.c_empty_look(prog::EmptyLook::WordBoundary)\n            }\n            WordBoundary(hir::WordBoundary::UnicodeNegate) => {\n                if !cfg!(feature = \"unicode-perl\") {\n                    return Err(Error::Syntax(\n                        \"Unicode word boundaries are unavailable when \\\n                         the unicode-perl feature is disabled\"\n                            .to_string(),\n                    ));\n                }\n                self.compiled.has_unicode_word_boundary = true;\n                self.byte_classes.set_word_boundary();\n                // See comments above for why we set the ASCII range here.\n                self.byte_classes.set_range(0, 0x7F);\n                self.c_empty_look(prog::EmptyLook::NotWordBoundary)\n            }\n            WordBoundary(hir::WordBoundary::Ascii) => {\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)\n            }\n            WordBoundary(hir::WordBoundary::AsciiNegate) => {\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)\n            }\n            Group(ref g) => match g.kind {\n                hir::GroupKind::NonCapturing => self.c(&g.hir),\n                hir::GroupKind::CaptureIndex(index) => {\n                    if index as usize >= self.compiled.captures.len() {\n                        self.compiled.captures.push(None);\n                    }\n                    self.c_capture(2 * index as usize, &g.hir)\n                }\n                hir::GroupKind::CaptureName { index, ref name } => {\n                    if index as usize >= self.compiled.captures.len() {\n                        let n = name.to_string();\n                        self.compiled.captures.push(Some(n.clone()));\n                        self.capture_name_idx.insert(n, index as usize);\n                    }\n                    self.c_capture(2 * index as usize, &g.hir)\n                }\n            },\n            Concat(ref es) => {\n                if self.compiled.is_reverse {\n                    self.c_concat(es.iter().rev())\n                } else {\n                    self.c_concat(es)\n                }\n            }\n            Alternation(ref es) => self.c_alternate(&**es),\n            Repetition(ref rep) => self.c_repeat(rep),\n        }\n    }\n\n    fn c_empty(&mut self) -> ResultOrEmpty {\n        // See: https://github.com/rust-lang/regex/security/advisories/GHSA-m5pq-gvj9-9vr8\n        // See: CVE-2022-24713\n        //\n        // Since 'empty' sub-expressions don't increase the size of\n        // the actual compiled object, we \"fake\" an increase in its\n        // size so that our 'check_size_limit' routine will eventually\n        // stop compilation if there are too many empty sub-expressions\n        // (e.g., via a large repetition).\n        self.extra_inst_bytes += std::mem::size_of::<Inst>();\n        Ok(None)\n    }\n\n    fn c_capture(&mut self, first_slot: usize, expr: &Hir) -> ResultOrEmpty {\n        if self.num_exprs > 1 || self.compiled.is_dfa {\n            // Don't ever compile Save instructions for regex sets because\n            // they are never used. They are also never used in DFA programs\n            // because DFAs can't handle captures.\n            self.c(expr)\n        } else {\n            let entry = self.insts.len();\n            let hole = self.push_hole(InstHole::Save { slot: first_slot });\n            let patch = self.c(expr)?.unwrap_or(self.next_inst());\n            self.fill(hole, patch.entry);\n            self.fill_to_next(patch.hole);\n            let hole = self.push_hole(InstHole::Save { slot: first_slot + 1 });\n            Ok(Some(Patch { hole: hole, entry: entry }))\n        }\n    }\n\n    fn c_dotstar(&mut self) -> Result {\n        Ok(if !self.compiled.only_utf8() {\n            self.c(&Hir::repetition(hir::Repetition {\n                kind: hir::RepetitionKind::ZeroOrMore,\n                greedy: false,\n                hir: Box::new(Hir::any(true)),\n            }))?\n            .unwrap()\n        } else {\n            self.c(&Hir::repetition(hir::Repetition {\n                kind: hir::RepetitionKind::ZeroOrMore,\n                greedy: false,\n                hir: Box::new(Hir::any(false)),\n            }))?\n            .unwrap()\n        })\n    }\n\n    fn c_char(&mut self, c: char) -> ResultOrEmpty {\n        if self.compiled.uses_bytes() {\n            if c.is_ascii() {\n                let b = c as u8;\n                let hole =\n                    self.push_hole(InstHole::Bytes { start: b, end: b });\n                self.byte_classes.set_range(b, b);\n                Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))\n            } else {\n                self.c_class(&[hir::ClassUnicodeRange::new(c, c)])\n            }\n        } else {\n            let hole = self.push_hole(InstHole::Char { c: c });\n            Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))\n        }\n    }\n\n    fn c_class(&mut self, ranges: &[hir::ClassUnicodeRange]) -> ResultOrEmpty {\n        use std::mem::size_of;\n\n        assert!(!ranges.is_empty());\n        if self.compiled.uses_bytes() {\n            Ok(Some(CompileClass { c: self, ranges: ranges }.compile()?))\n        } else {\n            let ranges: Vec<(char, char)> =\n                ranges.iter().map(|r| (r.start(), r.end())).collect();\n            let hole = if ranges.len() == 1 && ranges[0].0 == ranges[0].1 {\n                self.push_hole(InstHole::Char { c: ranges[0].0 })\n            } else {\n                self.extra_inst_bytes +=\n                    ranges.len() * (size_of::<char>() * 2);\n                self.push_hole(InstHole::Ranges { ranges: ranges })\n            };\n            Ok(Some(Patch { hole: hole, entry: self.insts.len() - 1 }))\n        }\n    }\n\n    fn c_byte(&mut self, b: u8) -> ResultOrEmpty {\n        self.c_class_bytes(&[hir::ClassBytesRange::new(b, b)])\n    }\n\n    fn c_class_bytes(\n        &mut self,\n        ranges: &[hir::ClassBytesRange],\n    ) -> ResultOrEmpty {\n        debug_assert!(!ranges.is_empty());\n\n        let first_split_entry = self.insts.len();\n        let mut holes = vec![];\n        let mut prev_hole = Hole::None;\n        for r in &ranges[0..ranges.len() - 1] {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let next = self.insts.len();\n            self.byte_classes.set_range(r.start(), r.end());\n            holes.push(self.push_hole(InstHole::Bytes {\n                start: r.start(),\n                end: r.end(),\n            }));\n            prev_hole = self.fill_split(split, Some(next), None);\n        }\n        let next = self.insts.len();\n        let r = &ranges[ranges.len() - 1];\n        self.byte_classes.set_range(r.start(), r.end());\n        holes.push(\n            self.push_hole(InstHole::Bytes { start: r.start(), end: r.end() }),\n        );\n        self.fill(prev_hole, next);\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))\n    }\n\n    fn c_empty_look(&mut self, look: EmptyLook) -> ResultOrEmpty {\n        let hole = self.push_hole(InstHole::EmptyLook { look: look });\n        Ok(Some(Patch { hole: hole, entry: self.insts.len() - 1 }))\n    }\n\n    fn c_concat<'a, I>(&mut self, exprs: I) -> ResultOrEmpty\n    where\n        I: IntoIterator<Item = &'a Hir>,\n    {\n        let mut exprs = exprs.into_iter();\n        let Patch { mut hole, entry } = loop {\n            match exprs.next() {\n                None => return self.c_empty(),\n                Some(e) => {\n                    if let Some(p) = self.c(e)? {\n                        break p;\n                    }\n                }\n            }\n        };\n        for e in exprs {\n            if let Some(p) = self.c(e)? {\n                self.fill(hole, p.entry);\n                hole = p.hole;\n            }\n        }\n        Ok(Some(Patch { hole: hole, entry: entry }))\n    }\n\n    fn c_alternate(&mut self, exprs: &[Hir]) -> ResultOrEmpty {\n        debug_assert!(\n            exprs.len() >= 2,\n            \"alternates must have at least 2 exprs\"\n        );\n\n        // Initial entry point is always the first split.\n        let first_split_entry = self.insts.len();\n\n        // Save up all of the holes from each alternate. They will all get\n        // patched to point to the same location.\n        let mut holes = vec![];\n\n        // true indicates that the hole is a split where we want to fill\n        // the second branch.\n        let mut prev_hole = (Hole::None, false);\n        for e in &exprs[0..exprs.len() - 1] {\n            if prev_hole.1 {\n                let next = self.insts.len();\n                self.fill_split(prev_hole.0, None, Some(next));\n            } else {\n                self.fill_to_next(prev_hole.0);\n            }\n            let split = self.push_split_hole();\n            if let Some(Patch { hole, entry }) = self.c(e)? {\n                holes.push(hole);\n                prev_hole = (self.fill_split(split, Some(entry), None), false);\n            } else {\n                let (split1, split2) = split.dup_one();\n                holes.push(split1);\n                prev_hole = (split2, true);\n            }\n        }\n        if let Some(Patch { hole, entry }) = self.c(&exprs[exprs.len() - 1])? {\n            holes.push(hole);\n            if prev_hole.1 {\n                self.fill_split(prev_hole.0, None, Some(entry));\n            } else {\n                self.fill(prev_hole.0, entry);\n            }\n        } else {\n            // We ignore prev_hole.1. When it's true, it means we have two\n            // empty branches both pushing prev_hole.0 into holes, so both\n            // branches will go to the same place anyway.\n            holes.push(prev_hole.0);\n        }\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))\n    }\n\n    fn c_repeat(&mut self, rep: &hir::Repetition) -> ResultOrEmpty {\n        use regex_syntax::hir::RepetitionKind::*;\n        match rep.kind {\n            ZeroOrOne => self.c_repeat_zero_or_one(&rep.hir, rep.greedy),\n            ZeroOrMore => self.c_repeat_zero_or_more(&rep.hir, rep.greedy),\n            OneOrMore => self.c_repeat_one_or_more(&rep.hir, rep.greedy),\n            Range(hir::RepetitionRange::Exactly(min_max)) => {\n                self.c_repeat_range(&rep.hir, rep.greedy, min_max, min_max)\n            }\n            Range(hir::RepetitionRange::AtLeast(min)) => {\n                self.c_repeat_range_min_or_more(&rep.hir, rep.greedy, min)\n            }\n            Range(hir::RepetitionRange::Bounded(min, max)) => {\n                self.c_repeat_range(&rep.hir, rep.greedy, min, max)\n            }\n        }\n    }\n\n    fn c_repeat_zero_or_one(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty {\n        let split_entry = self.insts.len();\n        let split = self.push_split_hole();\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return self.pop_split_hole(),\n        };\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        let holes = vec![hole_rep, split_hole];\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: split_entry }))\n    }\n\n    fn c_repeat_zero_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty {\n        let split_entry = self.insts.len();\n        let split = self.push_split_hole();\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return self.pop_split_hole(),\n        };\n\n        self.fill(hole_rep, split_entry);\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        Ok(Some(Patch { hole: split_hole, entry: split_entry }))\n    }\n\n    fn c_repeat_one_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty {\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return Ok(None),\n        };\n        self.fill_to_next(hole_rep);\n        let split = self.push_split_hole();\n\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        Ok(Some(Patch { hole: split_hole, entry: entry_rep }))\n    }\n\n    fn c_repeat_range_min_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n        min: u32,\n    ) -> ResultOrEmpty {\n        let min = u32_to_usize(min);\n        // Using next_inst() is ok, because we can't return it (concat would\n        // have to return Some(_) while c_repeat_range_min_or_more returns\n        // None).\n        let patch_concat = self\n            .c_concat(iter::repeat(expr).take(min))?\n            .unwrap_or(self.next_inst());\n        if let Some(patch_rep) = self.c_repeat_zero_or_more(expr, greedy)? {\n            self.fill(patch_concat.hole, patch_rep.entry);\n            Ok(Some(Patch { hole: patch_rep.hole, entry: patch_concat.entry }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn c_repeat_range(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n        min: u32,\n        max: u32,\n    ) -> ResultOrEmpty {\n        let (min, max) = (u32_to_usize(min), u32_to_usize(max));\n        debug_assert!(min <= max);\n        let patch_concat = self.c_concat(iter::repeat(expr).take(min))?;\n        if min == max {\n            return Ok(patch_concat);\n        }\n        // Same reasoning as in c_repeat_range_min_or_more (we know that min <\n        // max at this point).\n        let patch_concat = patch_concat.unwrap_or(self.next_inst());\n        let initial_entry = patch_concat.entry;\n        // It is much simpler to compile, e.g., `a{2,5}` as:\n        //\n        //     aaa?a?a?\n        //\n        // But you end up with a sequence of instructions like this:\n        //\n        //     0: 'a'\n        //     1: 'a',\n        //     2: split(3, 4)\n        //     3: 'a'\n        //     4: split(5, 6)\n        //     5: 'a'\n        //     6: split(7, 8)\n        //     7: 'a'\n        //     8: MATCH\n        //\n        // This is *incredibly* inefficient because the splits end\n        // up forming a chain, which has to be resolved everything a\n        // transition is followed.\n        let mut holes = vec![];\n        let mut prev_hole = patch_concat.hole;\n        for _ in min..max {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let Patch { hole, entry } = match self.c(expr)? {\n                Some(p) => p,\n                None => return self.pop_split_hole(),\n            };\n            prev_hole = hole;\n            if greedy {\n                holes.push(self.fill_split(split, Some(entry), None));\n            } else {\n                holes.push(self.fill_split(split, None, Some(entry)));\n            }\n        }\n        holes.push(prev_hole);\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: initial_entry }))\n    }\n\n    /// Can be used as a default value for the c_* functions when the call to\n    /// c_function is followed by inserting at least one instruction that is\n    /// always executed after the ones written by the c* function.\n    fn next_inst(&self) -> Patch {\n        Patch { hole: Hole::None, entry: self.insts.len() }\n    }\n\n    fn fill(&mut self, hole: Hole, goto: InstPtr) {\n        match hole {\n            Hole::None => {}\n            Hole::One(pc) => {\n                self.insts[pc].fill(goto);\n            }\n            Hole::Many(holes) => {\n                for hole in holes {\n                    self.fill(hole, goto);\n                }\n            }\n        }\n    }\n\n    fn fill_to_next(&mut self, hole: Hole) {\n        let next = self.insts.len();\n        self.fill(hole, next);\n    }\n\n    fn fill_split(\n        &mut self,\n        hole: Hole,\n        goto1: Option<InstPtr>,\n        goto2: Option<InstPtr>,\n    ) -> Hole {\n        match hole {\n            Hole::None => Hole::None,\n            Hole::One(pc) => match (goto1, goto2) {\n                (Some(goto1), Some(goto2)) => {\n                    self.insts[pc].fill_split(goto1, goto2);\n                    Hole::None\n                }\n                (Some(goto1), None) => {\n                    self.insts[pc].half_fill_split_goto1(goto1);\n                    Hole::One(pc)\n                }\n                (None, Some(goto2)) => {\n                    self.insts[pc].half_fill_split_goto2(goto2);\n                    Hole::One(pc)\n                }\n                (None, None) => unreachable!(\n                    \"at least one of the split \\\n                     holes must be filled\"\n                ),\n            },\n            Hole::Many(holes) => {\n                let mut new_holes = vec![];\n                for hole in holes {\n                    new_holes.push(self.fill_split(hole, goto1, goto2));\n                }\n                if new_holes.is_empty() {\n                    Hole::None\n                } else if new_holes.len() == 1 {\n                    new_holes.pop().unwrap()\n                } else {\n                    Hole::Many(new_holes)\n                }\n            }\n        }\n    }\n\n    fn push_compiled(&mut self, inst: Inst) {\n        self.insts.push(MaybeInst::Compiled(inst));\n    }\n\n    fn push_hole(&mut self, inst: InstHole) -> Hole {\n        let hole = self.insts.len();\n        self.insts.push(MaybeInst::Uncompiled(inst));\n        Hole::One(hole)\n    }\n\n    fn push_split_hole(&mut self) -> Hole {\n        let hole = self.insts.len();\n        self.insts.push(MaybeInst::Split);\n        Hole::One(hole)\n    }\n\n    fn pop_split_hole(&mut self) -> ResultOrEmpty {\n        self.insts.pop();\n        Ok(None)\n    }\n\n    fn check_size(&self) -> result::Result<(), Error> {\n        use std::mem::size_of;\n\n        let size =\n            self.extra_inst_bytes + (self.insts.len() * size_of::<Inst>());\n        if size > self.size_limit {\n            Err(Error::CompiledTooBig(self.size_limit))\n        } else {\n            Ok(())\n        }\n    }\n}\n\n#[derive(Debug)]\nenum Hole {\n    None,\n    One(InstPtr),\n    Many(Vec<Hole>),\n}\n\nimpl Hole {\n    fn dup_one(self) -> (Self, Self) {\n        match self {\n            Hole::One(pc) => (Hole::One(pc), Hole::One(pc)),\n            Hole::None | Hole::Many(_) => {\n                unreachable!(\"must be called on single hole\")\n            }\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nenum MaybeInst {\n    Compiled(Inst),\n    Uncompiled(InstHole),\n    Split,\n    Split1(InstPtr),\n    Split2(InstPtr),\n}\n\nimpl MaybeInst {\n    fn fill(&mut self, goto: InstPtr) {\n        let maybeinst = match *self {\n            MaybeInst::Split => MaybeInst::Split1(goto),\n            MaybeInst::Uncompiled(ref inst) => {\n                MaybeInst::Compiled(inst.fill(goto))\n            }\n            MaybeInst::Split1(goto1) => {\n                MaybeInst::Compiled(Inst::Split(InstSplit {\n                    goto1: goto1,\n                    goto2: goto,\n                }))\n            }\n            MaybeInst::Split2(goto2) => {\n                MaybeInst::Compiled(Inst::Split(InstSplit {\n                    goto1: goto,\n                    goto2: goto2,\n                }))\n            }\n            _ => unreachable!(\n                \"not all instructions were compiled! \\\n                 found uncompiled instruction: {:?}\",\n                self\n            ),\n        };\n        *self = maybeinst;\n    }\n\n    fn fill_split(&mut self, goto1: InstPtr, goto2: InstPtr) {\n        let filled = match *self {\n            MaybeInst::Split => {\n                Inst::Split(InstSplit { goto1: goto1, goto2: goto2 })\n            }\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Compiled(filled);\n    }\n\n    fn half_fill_split_goto1(&mut self, goto1: InstPtr) {\n        let half_filled = match *self {\n            MaybeInst::Split => goto1,\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Split1(half_filled);\n    }\n\n    fn half_fill_split_goto2(&mut self, goto2: InstPtr) {\n        let half_filled = match *self {\n            MaybeInst::Split => goto2,\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Split2(half_filled);\n    }\n\n    fn unwrap(self) -> Inst {\n        match self {\n            MaybeInst::Compiled(inst) => inst,\n            _ => unreachable!(\n                \"must be called on a compiled instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nenum InstHole {\n    Save { slot: usize },\n    EmptyLook { look: EmptyLook },\n    Char { c: char },\n    Ranges { ranges: Vec<(char, char)> },\n    Bytes { start: u8, end: u8 },\n}\n\nimpl InstHole {\n    fn fill(&self, goto: InstPtr) -> Inst {\n        match *self {\n            InstHole::Save { slot } => {\n                Inst::Save(InstSave { goto: goto, slot: slot })\n            }\n            InstHole::EmptyLook { look } => {\n                Inst::EmptyLook(InstEmptyLook { goto: goto, look: look })\n            }\n            InstHole::Char { c } => Inst::Char(InstChar { goto: goto, c: c }),\n            InstHole::Ranges { ref ranges } => Inst::Ranges(InstRanges {\n                goto: goto,\n                ranges: ranges.clone().into_boxed_slice(),\n            }),\n            InstHole::Bytes { start, end } => {\n                Inst::Bytes(InstBytes { goto: goto, start: start, end: end })\n            }\n        }\n    }\n}\n\nstruct CompileClass<'a, 'b> {\n    c: &'a mut Compiler,\n    ranges: &'b [hir::ClassUnicodeRange],\n}\n\nimpl<'a, 'b> CompileClass<'a, 'b> {\n    fn compile(mut self) -> Result {\n        let mut holes = vec![];\n        let mut initial_entry = None;\n        let mut last_split = Hole::None;\n        let mut utf8_seqs = self.c.utf8_seqs.take().unwrap();\n        self.c.suffix_cache.clear();\n\n        for (i, range) in self.ranges.iter().enumerate() {\n            let is_last_range = i + 1 == self.ranges.len();\n            utf8_seqs.reset(range.start(), range.end());\n            let mut it = (&mut utf8_seqs).peekable();\n            loop {\n                let utf8_seq = match it.next() {\n                    None => break,\n                    Some(utf8_seq) => utf8_seq,\n                };\n                if is_last_range && it.peek().is_none() {\n                    let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;\n                    holes.push(hole);\n                    self.c.fill(last_split, entry);\n                    last_split = Hole::None;\n                    if initial_entry.is_none() {\n                        initial_entry = Some(entry);\n                    }\n                } else {\n                    if initial_entry.is_none() {\n                        initial_entry = Some(self.c.insts.len());\n                    }\n                    self.c.fill_to_next(last_split);\n                    last_split = self.c.push_split_hole();\n                    let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;\n                    holes.push(hole);\n                    last_split =\n                        self.c.fill_split(last_split, Some(entry), None);\n                }\n            }\n        }\n        self.c.utf8_seqs = Some(utf8_seqs);\n        Ok(Patch { hole: Hole::Many(holes), entry: initial_entry.unwrap() })\n    }\n\n    fn c_utf8_seq(&mut self, seq: &Utf8Sequence) -> Result {\n        if self.c.compiled.is_reverse {\n            self.c_utf8_seq_(seq)\n        } else {\n            self.c_utf8_seq_(seq.into_iter().rev())\n        }\n    }\n\n    fn c_utf8_seq_<'r, I>(&mut self, seq: I) -> Result\n    where\n        I: IntoIterator<Item = &'r Utf8Range>,\n    {\n        // The initial instruction for each UTF-8 sequence should be the same.\n        let mut from_inst = ::std::usize::MAX;\n        let mut last_hole = Hole::None;\n        for byte_range in seq {\n            let key = SuffixCacheKey {\n                from_inst: from_inst,\n                start: byte_range.start,\n                end: byte_range.end,\n            };\n            {\n                let pc = self.c.insts.len();\n                if let Some(cached_pc) = self.c.suffix_cache.get(key, pc) {\n                    from_inst = cached_pc;\n                    continue;\n                }\n            }\n            self.c.byte_classes.set_range(byte_range.start, byte_range.end);\n            if from_inst == ::std::usize::MAX {\n                last_hole = self.c.push_hole(InstHole::Bytes {\n                    start: byte_range.start,\n                    end: byte_range.end,\n                });\n            } else {\n                self.c.push_compiled(Inst::Bytes(InstBytes {\n                    goto: from_inst,\n                    start: byte_range.start,\n                    end: byte_range.end,\n                }));\n            }\n            from_inst = self.c.insts.len().checked_sub(1).unwrap();\n            debug_assert!(from_inst < ::std::usize::MAX);\n        }\n        debug_assert!(from_inst < ::std::usize::MAX);\n        Ok(Patch { hole: last_hole, entry: from_inst })\n    }\n}\n\n/// `SuffixCache` is a simple bounded hash map for caching suffix entries in\n/// UTF-8 automata. For example, consider the Unicode range \\u{0}-\\u{FFFF}.\n/// The set of byte ranges looks like this:\n///\n/// [0-7F]\n/// [C2-DF][80-BF]\n/// [E0][A0-BF][80-BF]\n/// [E1-EC][80-BF][80-BF]\n/// [ED][80-9F][80-BF]\n/// [EE-EF][80-BF][80-BF]\n///\n/// Each line above translates to one alternate in the compiled regex program.\n/// However, all but one of the alternates end in the same suffix, which is\n/// a waste of an instruction. The suffix cache facilitates reusing them across\n/// alternates.\n///\n/// Note that a HashMap could be trivially used for this, but we don't need its\n/// overhead. Some small bounded space (LRU style) is more than enough.\n///\n/// This uses similar idea to [`SparseSet`](../sparse/struct.SparseSet.html),\n/// except it uses hashes as original indices and then compares full keys for\n/// validation against `dense` array.\n#[derive(Debug)]\nstruct SuffixCache {\n    sparse: Box<[usize]>,\n    dense: Vec<SuffixCacheEntry>,\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]\nstruct SuffixCacheEntry {\n    key: SuffixCacheKey,\n    pc: InstPtr,\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]\nstruct SuffixCacheKey {\n    from_inst: InstPtr,\n    start: u8,\n    end: u8,\n}\n\nimpl SuffixCache {\n    fn new(size: usize) -> Self {\n        SuffixCache {\n            sparse: vec![0usize; size].into(),\n            dense: Vec::with_capacity(size),\n        }\n    }\n\n    fn get(&mut self, key: SuffixCacheKey, pc: InstPtr) -> Option<InstPtr> {\n        let hash = self.hash(&key);\n        let pos = &mut self.sparse[hash];\n        if let Some(entry) = self.dense.get(*pos) {\n            if entry.key == key {\n                return Some(entry.pc);\n            }\n        }\n        *pos = self.dense.len();\n        self.dense.push(SuffixCacheEntry { key: key, pc: pc });\n        None\n    }\n\n    fn clear(&mut self) {\n        self.dense.clear();\n    }\n\n    fn hash(&self, suffix: &SuffixCacheKey) -> usize {\n        // Basic FNV-1a hash as described:\n        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n        const FNV_PRIME: u64 = 1099511628211;\n        let mut h = 14695981039346656037;\n        h = (h ^ (suffix.from_inst as u64)).wrapping_mul(FNV_PRIME);\n        h = (h ^ (suffix.start as u64)).wrapping_mul(FNV_PRIME);\n        h = (h ^ (suffix.end as u64)).wrapping_mul(FNV_PRIME);\n        (h as usize) % self.sparse.len()\n    }\n}\n\nstruct ByteClassSet([bool; 256]);\n\nimpl ByteClassSet {\n    fn new() -> Self {\n        ByteClassSet([false; 256])\n    }\n\n    fn set_range(&mut self, start: u8, end: u8) {\n        debug_assert!(start <= end);\n        if start > 0 {\n            self.0[start as usize - 1] = true;\n        }\n        self.0[end as usize] = true;\n    }\n\n    fn set_word_boundary(&mut self) {\n        // We need to mark all ranges of bytes whose pairs result in\n        // evaluating \\b differently.\n        let iswb = is_word_byte;\n        let mut b1: u16 = 0;\n        let mut b2: u16;\n        while b1 <= 255 {\n            b2 = b1 + 1;\n            while b2 <= 255 && iswb(b1 as u8) == iswb(b2 as u8) {\n                b2 += 1;\n            }\n            self.set_range(b1 as u8, (b2 - 1) as u8);\n            b1 = b2;\n        }\n    }\n\n    fn byte_classes(&self) -> Vec<u8> {\n        // N.B. If you're debugging the DFA, it's useful to simply return\n        // `(0..256).collect()`, which effectively removes the byte classes\n        // and makes the transitions easier to read.\n        // (0usize..256).map(|x| x as u8).collect()\n        let mut byte_classes = vec![0; 256];\n        let mut class = 0u8;\n        let mut i = 0;\n        loop {\n            byte_classes[i] = class as u8;\n            if i >= 255 {\n                break;\n            }\n            if self.0[i] {\n                class = class.checked_add(1).unwrap();\n            }\n            i += 1;\n        }\n        byte_classes\n    }\n}\n\nimpl fmt::Debug for ByteClassSet {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"ByteClassSet\").field(&&self.0[..]).finish()\n    }\n}\n\nfn u32_to_usize(n: u32) -> usize {\n    // In case usize is less than 32 bits, we need to guard against overflow.\n    // On most platforms this compiles to nothing.\n    // TODO Use `std::convert::TryFrom` once it's stable.\n    if (n as u64) > (::std::usize::MAX as u64) {\n        panic!(\"BUG: {} is too big to be pointer sized\", n)\n    }\n    n as usize\n}\n\n#[cfg(test)]\nmod tests {\n    use super::ByteClassSet;\n\n    #[test]\n    fn byte_classes() {\n        let mut set = ByteClassSet::new();\n        set.set_range(b'a', b'z');\n        let classes = set.byte_classes();\n        assert_eq!(classes[0], 0);\n        assert_eq!(classes[1], 0);\n        assert_eq!(classes[2], 0);\n        assert_eq!(classes[b'a' as usize - 1], 0);\n        assert_eq!(classes[b'a' as usize], 1);\n        assert_eq!(classes[b'm' as usize], 1);\n        assert_eq!(classes[b'z' as usize], 1);\n        assert_eq!(classes[b'z' as usize + 1], 2);\n        assert_eq!(classes[254], 2);\n        assert_eq!(classes[255], 2);\n\n        let mut set = ByteClassSet::new();\n        set.set_range(0, 2);\n        set.set_range(4, 6);\n        let classes = set.byte_classes();\n        assert_eq!(classes[0], 0);\n        assert_eq!(classes[1], 0);\n        assert_eq!(classes[2], 0);\n        assert_eq!(classes[3], 1);\n        assert_eq!(classes[4], 2);\n        assert_eq!(classes[5], 2);\n        assert_eq!(classes[6], 2);\n        assert_eq!(classes[7], 3);\n        assert_eq!(classes[255], 3);\n    }\n\n    #[test]\n    fn full_byte_classes() {\n        let mut set = ByteClassSet::new();\n        for i in 0..256u16 {\n            set.set_range(i as u8, i as u8);\n        }\n        assert_eq!(set.byte_classes().len(), 256);\n    }\n}\n", "#![cfg_attr(feature = \"pattern\", feature(pattern))]\n\nuse regex;\n\n// Due to macro scoping rules, this definition only applies for the modules\n// defined below. Effectively, it allows us to use the same tests for both\n// native and dynamic regexes.\n//\n// This is also used to test the various matching engines. This one exercises\n// the normal code path which automatically chooses the engine based on the\n// regex and the input. Other dynamic tests explicitly set the engine to use.\nmacro_rules! regex_new {\n    ($re:expr) => {{\n        use regex::Regex;\n        Regex::new($re)\n    }};\n}\n\nmacro_rules! regex {\n    ($re:expr) => {\n        regex_new!($re).unwrap()\n    };\n}\n\nmacro_rules! regex_set_new {\n    ($re:expr) => {{\n        use regex::RegexSet;\n        RegexSet::new($re)\n    }};\n}\n\nmacro_rules! regex_set {\n    ($res:expr) => {\n        regex_set_new!($res).unwrap()\n    };\n}\n\n// Must come before other module definitions.\ninclude!(\"macros_str.rs\");\ninclude!(\"macros.rs\");\n\nmod api;\nmod api_str;\nmod crazy;\nmod flags;\nmod fowler;\nmod misc;\nmod multiline;\nmod noparse;\nmod regression;\nmod regression_fuzz;\nmod replace;\nmod searcher;\nmod set;\nmod shortest_match;\nmod suffix_reverse;\n#[cfg(feature = \"unicode\")]\nmod unicode;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary;\n#[cfg(feature = \"unicode-perl\")]\nmod word_boundary_unicode;\n\n#[test]\nfn disallow_non_utf8() {\n    assert!(regex::Regex::new(r\"(?-u)\\xFF\").is_err());\n    assert!(regex::Regex::new(r\"(?-u).\").is_err());\n    assert!(regex::Regex::new(r\"(?-u)[\\xFF]\").is_err());\n    assert!(regex::Regex::new(r\"(?-u)\u2603\").is_err());\n}\n\n#[test]\nfn disallow_octal() {\n    assert!(regex::Regex::new(r\"\\0\").is_err());\n}\n\n#[test]\nfn allow_octal() {\n    assert!(regex::RegexBuilder::new(r\"\\0\").octal(true).build().is_ok());\n}\n\n#[test]\nfn oibits() {\n    use regex::bytes;\n    use regex::{Regex, RegexBuilder, RegexSet, RegexSetBuilder};\n    use std::panic::{RefUnwindSafe, UnwindSafe};\n\n    fn assert_send<T: Send>() {}\n    fn assert_sync<T: Sync>() {}\n    fn assert_unwind_safe<T: UnwindSafe>() {}\n    fn assert_ref_unwind_safe<T: RefUnwindSafe>() {}\n\n    assert_send::<Regex>();\n    assert_sync::<Regex>();\n    assert_unwind_safe::<Regex>();\n    assert_ref_unwind_safe::<Regex>();\n    assert_send::<RegexBuilder>();\n    assert_sync::<RegexBuilder>();\n    assert_unwind_safe::<RegexBuilder>();\n    assert_ref_unwind_safe::<RegexBuilder>();\n\n    assert_send::<bytes::Regex>();\n    assert_sync::<bytes::Regex>();\n    assert_unwind_safe::<bytes::Regex>();\n    assert_ref_unwind_safe::<bytes::Regex>();\n    assert_send::<bytes::RegexBuilder>();\n    assert_sync::<bytes::RegexBuilder>();\n    assert_unwind_safe::<bytes::RegexBuilder>();\n    assert_ref_unwind_safe::<bytes::RegexBuilder>();\n\n    assert_send::<RegexSet>();\n    assert_sync::<RegexSet>();\n    assert_unwind_safe::<RegexSet>();\n    assert_ref_unwind_safe::<RegexSet>();\n    assert_send::<RegexSetBuilder>();\n    assert_sync::<RegexSetBuilder>();\n    assert_unwind_safe::<RegexSetBuilder>();\n    assert_ref_unwind_safe::<RegexSetBuilder>();\n\n    assert_send::<bytes::RegexSet>();\n    assert_sync::<bytes::RegexSet>();\n    assert_unwind_safe::<bytes::RegexSet>();\n    assert_ref_unwind_safe::<bytes::RegexSet>();\n    assert_send::<bytes::RegexSetBuilder>();\n    assert_sync::<bytes::RegexSetBuilder>();\n    assert_unwind_safe::<bytes::RegexSetBuilder>();\n    assert_ref_unwind_safe::<bytes::RegexSetBuilder>();\n}\n\n// See: https://github.com/rust-lang/regex/issues/568\n#[test]\nfn oibits_regression() {\n    use regex::Regex;\n    use std::panic;\n\n    let _ = panic::catch_unwind(|| Regex::new(\"a\").unwrap());\n}\n\n// See: https://github.com/rust-lang/regex/issues/750\n#[test]\n#[cfg(target_pointer_width = \"64\")]\nfn regex_is_reasonably_small() {\n    use std::mem::size_of;\n\n    use regex::bytes;\n    use regex::{Regex, RegexSet};\n\n    assert_eq!(16, size_of::<Regex>());\n    assert_eq!(16, size_of::<RegexSet>());\n    assert_eq!(16, size_of::<bytes::Regex>());\n    assert_eq!(16, size_of::<bytes::RegexSet>());\n}\n\n// See: https://github.com/rust-lang/regex/security/advisories/GHSA-m5pq-gvj9-9vr8\n// See: CVE-2022-24713\n//\n// We test that our regex compiler will correctly return a \"too big\" error when\n// we try to use a very large repetition on an *empty* sub-expression.\n//\n// At the time this test was written, the regex compiler does not represent\n// empty sub-expressions with any bytecode instructions. In effect, it's an\n// \"optimization\" to leave them out, since they would otherwise correspond\n// to an unconditional JUMP in the regex bytecode (i.e., an unconditional\n// epsilon transition in the NFA graph). Therefore, an empty sub-expression\n// represents an interesting case for the compiler's size limits. Since it\n// doesn't actually contribute any additional memory to the compiled regex\n// instructions, the size limit machinery never detects it. Instead, it just\n// dumbly tries to compile the empty sub-expression N times, where N is the\n// repetition size.\n//\n// When N is very large, this will cause the compiler to essentially spin and\n// do nothing for a decently large amount of time. It causes the regex to take\n// quite a bit of time to compile, despite the concrete syntax of the regex\n// being quite small.\n//\n// The degree to which this is actually a problem is somewhat of a judgment\n// call. Some regexes simply take a long time to compile. But in general, you\n// should be able to reasonably control this by setting lower or higher size\n// limits on the compiled object size. But this mitigation doesn't work at all\n// for this case.\n//\n// This particular test is somewhat narrow. It merely checks that regex\n// compilation will, at some point, return a \"too big\" error. Before the\n// fix landed, this test would eventually fail because the regex would be\n// successfully compiled (after enough time elapsed). So while this test\n// doesn't check that we exit in a reasonable amount of time, it does at least\n// check that we are properly returning an error at some point.\n#[test]\nfn big_empty_regex_fails() {\n    use regex::Regex;\n\n    let result = Regex::new(\"(?:){4294967295}\");\n    assert!(result.is_err());\n}\n\n// Below is a \"billion laughs\" variant of the previous test case.\n#[test]\nfn big_empty_reps_chain_regex_fails() {\n    use regex::Regex;\n\n    let result = Regex::new(\"(?:){64}{64}{64}{64}{64}{64}\");\n    assert!(result.is_err());\n}\n\n// Below is another situation where a zero-length sub-expression can be\n// introduced.\n#[test]\nfn big_zero_reps_regex_fails() {\n    use regex::Regex;\n\n    let result = Regex::new(r\"x{0}{4294967295}\");\n    assert!(result.is_err());\n}\n\n// Testing another case for completeness.\n#[test]\nfn empty_alt_regex_fails() {\n    use regex::Regex;\n\n    let result = Regex::new(r\"(?:|){4294967295}\");\n    assert!(result.is_err());\n}\n"], "filenames": ["src/compile.rs", "tests/test_default.rs"], "buggy_code_start_loc": [40, 152], "buggy_code_end_loc": [500, 152], "fixing_code_start_loc": [41, 153], "fixing_code_end_loc": [523, 223], "type": "CWE-400", "message": "regex is an implementation of regular expressions for the Rust language. The regex crate features built-in mitigations to prevent denial of service attacks caused by untrusted regexes, or untrusted input matched by trusted regexes. Those (tunable) mitigations already provide sane defaults to prevent attacks. This guarantee is documented and it's considered part of the crate's API. Unfortunately a bug was discovered in the mitigations designed to prevent untrusted regexes to take an arbitrary amount of time during parsing, and it's possible to craft regexes that bypass such mitigations. This makes it possible to perform denial of service attacks by sending specially crafted regexes to services accepting user-controlled, untrusted regexes. All versions of the regex crate before or equal to 1.5.4 are affected by this issue. The fix is include starting from regex 1.5.5. All users accepting user-controlled regexes are recommended to upgrade immediately to the latest version of the regex crate. Unfortunately there is no fixed set of problematic regexes, as there are practically infinite regexes that could be crafted to exploit this vulnerability. Because of this, it us not recommend to deny known problematic regexes.", "other": {"cve": {"id": "CVE-2022-24713", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-08T19:15:08.000", "lastModified": "2023-01-20T18:05:38.477", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "regex is an implementation of regular expressions for the Rust language. The regex crate features built-in mitigations to prevent denial of service attacks caused by untrusted regexes, or untrusted input matched by trusted regexes. Those (tunable) mitigations already provide sane defaults to prevent attacks. This guarantee is documented and it's considered part of the crate's API. Unfortunately a bug was discovered in the mitigations designed to prevent untrusted regexes to take an arbitrary amount of time during parsing, and it's possible to craft regexes that bypass such mitigations. This makes it possible to perform denial of service attacks by sending specially crafted regexes to services accepting user-controlled, untrusted regexes. All versions of the regex crate before or equal to 1.5.4 are affected by this issue. The fix is include starting from regex 1.5.5. All users accepting user-controlled regexes are recommended to upgrade immediately to the latest version of the regex crate. Unfortunately there is no fixed set of problematic regexes, as there are practically infinite regexes that could be crafted to exploit this vulnerability. Because of this, it us not recommend to deny known problematic regexes."}, {"lang": "es", "value": "regex es una implementaci\u00f3n de expresiones regulares para el lenguaje Rust. La caja de regex presenta mitigaciones incorporadas para prevenir ataques de denegaci\u00f3n de servicio causados por regexes no confiables, o por entradas no confiables coincidentes con regexes confiables. Estas mitigaciones (sintonizables) ya proporcionan valores predeterminados sanos para prevenir ataques. Esta garant\u00eda est\u00e1 documentada y se considera parte de la API de la caja. Desafortunadamente, se descubri\u00f3 un error en las mitigaciones dise\u00f1adas para evitar que las expresiones regulares no confiables tomen una cantidad arbitraria de tiempo durante el an\u00e1lisis, y es posible crear expresiones regulares que eludan dichas mitigaciones. Esto hace posible realizar ataques de denegaci\u00f3n de servicio enviando regexes especialmente dise\u00f1ados a servicios que aceptan regexes no confiables controlados por el usuario. Todas las versiones de regex crate anteriores o iguales a la 1.5.4 est\u00e1n afectadas por este problema. La correcci\u00f3n se incluye a partir de regex 1.5.5. Se recomienda a todos los usuarios que acepten regexes controlados por el usuario que actualicen inmediatamente a la \u00faltima versi\u00f3n del regex crate. Lamentablemente, no existe un conjunto fijo de regexes problem\u00e1ticos, ya que hay pr\u00e1cticamente infinitas regexes que podr\u00edan ser creadas para explotar esta vulnerabilidad. Por ello, no recomendamos negar las regex problem\u00e1ticas conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rust-lang:regex:*:*:*:*:*:rust:*:*", "versionEndExcluding": "1.5.5", "matchCriteriaId": "C19062C7-2E3B-40F0-B813-413768896F67"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/rust-lang/regex/commit/ae70b41d4f46641dbc45c7a4f87954aea356283e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rust-lang/regex/security/advisories/GHSA-m5pq-gvj9-9vr8", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://groups.google.com/g/rustlang-security-announcements/c/NcNNL1Jq7Yw", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/04/msg00003.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/04/msg00009.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JANLZ3JXWJR7FSHE57K66UIZUIJZI67T/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3YB7CURSG64CIPCDPNMGPE4UU24AB6H/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PDOWTHNVGBOP2HN27PUFIGRYNSNDTYRJ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-08", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-14", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5113", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5118", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rust-lang/regex/commit/ae70b41d4f46641dbc45c7a4f87954aea356283e"}}