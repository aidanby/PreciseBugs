{"buggy_code": ["/*\n * Marvell Wireless LAN device driver: management IE handling- setting and\n * deleting IE.\n *\n * Copyright (C) 2012-2014, Marvell International Ltd.\n *\n * This software file (the \"File\") is distributed by Marvell International\n * Ltd. under the terms of the GNU General Public License Version 2, June 1991\n * (the \"License\").  You may use, redistribute and/or modify this File in\n * accordance with the terms and conditions of the License, a copy of which\n * is available by writing to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the\n * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n *\n * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE\n * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about\n * this warranty disclaimer.\n */\n\n#include \"main.h\"\n\n/* This function checks if current IE index is used by any on other interface.\n * Return: -1: yes, current IE index is used by someone else.\n *          0: no, current IE index is NOT used by other interface.\n */\nstatic int\nmwifiex_ie_index_used_by_other_intf(struct mwifiex_private *priv, u16 idx)\n{\n\tint i;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_ie *ie;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (adapter->priv[i] != priv) {\n\t\t\tie = &adapter->priv[i]->mgmt_ie[idx];\n\t\t\tif (ie->mgmt_subtype_mask && ie->ie_length)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* Get unused IE index. This index will be used for setting new IE */\nstatic int\nmwifiex_ie_get_autoidx(struct mwifiex_private *priv, u16 subtype_mask,\n\t\t       struct mwifiex_ie *ie, u16 *index)\n{\n\tu16 mask, len, i;\n\n\tfor (i = 0; i < priv->adapter->max_mgmt_ie_index; i++) {\n\t\tmask = le16_to_cpu(priv->mgmt_ie[i].mgmt_subtype_mask);\n\t\tlen = le16_to_cpu(ie->ie_length);\n\n\t\tif (mask == MWIFIEX_AUTO_IDX_MASK)\n\t\t\tcontinue;\n\n\t\tif (mask == subtype_mask) {\n\t\t\tif (len > IEEE_MAX_IE_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\t*index = i;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!priv->mgmt_ie[i].ie_length) {\n\t\t\tif (mwifiex_ie_index_used_by_other_intf(priv, i))\n\t\t\t\tcontinue;\n\n\t\t\t*index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/* This function prepares IE data buffer for command to be sent to FW */\nstatic int\nmwifiex_update_autoindex_ies(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_ie_list *ie_list)\n{\n\tu16 travel_len, index, mask;\n\ts16 input_len, tlv_len;\n\tstruct mwifiex_ie *ie;\n\tu8 *tmp;\n\n\tinput_len = le16_to_cpu(ie_list->len);\n\ttravel_len = sizeof(struct mwifiex_ie_types_header);\n\n\tie_list->len = 0;\n\n\twhile (input_len >= sizeof(struct mwifiex_ie_types_header)) {\n\t\tie = (struct mwifiex_ie *)(((u8 *)ie_list) + travel_len);\n\t\ttlv_len = le16_to_cpu(ie->ie_length);\n\t\ttravel_len += tlv_len + MWIFIEX_IE_HDR_SIZE;\n\n\t\tif (input_len < tlv_len + MWIFIEX_IE_HDR_SIZE)\n\t\t\treturn -1;\n\t\tindex = le16_to_cpu(ie->ie_index);\n\t\tmask = le16_to_cpu(ie->mgmt_subtype_mask);\n\n\t\tif (index == MWIFIEX_AUTO_IDX_MASK) {\n\t\t\t/* automatic addition */\n\t\t\tif (mwifiex_ie_get_autoidx(priv, mask, ie, &index))\n\t\t\t\treturn -1;\n\t\t\tif (index == MWIFIEX_AUTO_IDX_MASK)\n\t\t\t\treturn -1;\n\n\t\t\ttmp = (u8 *)&priv->mgmt_ie[index].ie_buffer;\n\t\t\tmemcpy(tmp, &ie->ie_buffer, le16_to_cpu(ie->ie_length));\n\t\t\tpriv->mgmt_ie[index].ie_length = ie->ie_length;\n\t\t\tpriv->mgmt_ie[index].ie_index = cpu_to_le16(index);\n\t\t\tpriv->mgmt_ie[index].mgmt_subtype_mask =\n\t\t\t\t\t\t\tcpu_to_le16(mask);\n\n\t\t\tie->ie_index = cpu_to_le16(index);\n\t\t} else {\n\t\t\tif (mask != MWIFIEX_DELETE_MASK)\n\t\t\t\treturn -1;\n\t\t\t/*\n\t\t\t * Check if this index is being used on any\n\t\t\t * other interface.\n\t\t\t */\n\t\t\tif (mwifiex_ie_index_used_by_other_intf(priv, index))\n\t\t\t\treturn -1;\n\n\t\t\tie->ie_length = 0;\n\t\t\tmemcpy(&priv->mgmt_ie[index], ie,\n\t\t\t       sizeof(struct mwifiex_ie));\n\t\t}\n\n\t\tle16_unaligned_add_cpu(&ie_list->len,\n\t\t\t\t       le16_to_cpu(\n\t\t\t\t\t    priv->mgmt_ie[index].ie_length) +\n\t\t\t\t       MWIFIEX_IE_HDR_SIZE);\n\t\tinput_len -= tlv_len + MWIFIEX_IE_HDR_SIZE;\n\t}\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP)\n\t\treturn mwifiex_send_cmd(priv, HostCmd_CMD_UAP_SYS_CONFIG,\n\t\t\t\t\tHostCmd_ACT_GEN_SET,\n\t\t\t\t\tUAP_CUSTOM_IE_I, ie_list, true);\n\n\treturn 0;\n}\n\n/* Copy individual custom IEs for beacon, probe response and assoc response\n * and prepare single structure for IE setting.\n * This function also updates allocated IE indices from driver.\n */\nstatic int\nmwifiex_update_uap_custom_ie(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_ie *beacon_ie, u16 *beacon_idx,\n\t\t\t     struct mwifiex_ie *pr_ie, u16 *probe_idx,\n\t\t\t     struct mwifiex_ie *ar_ie, u16 *assoc_idx)\n{\n\tstruct mwifiex_ie_list *ap_custom_ie;\n\tu8 *pos;\n\tu16 len;\n\tint ret;\n\n\tap_custom_ie = kzalloc(sizeof(*ap_custom_ie), GFP_KERNEL);\n\tif (!ap_custom_ie)\n\t\treturn -ENOMEM;\n\n\tap_custom_ie->type = cpu_to_le16(TLV_TYPE_MGMT_IE);\n\tpos = (u8 *)ap_custom_ie->ie_list;\n\n\tif (beacon_ie) {\n\t\tlen = sizeof(struct mwifiex_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(beacon_ie->ie_length);\n\t\tmemcpy(pos, beacon_ie, len);\n\t\tpos += len;\n\t\tle16_unaligned_add_cpu(&ap_custom_ie->len, len);\n\t}\n\tif (pr_ie) {\n\t\tlen = sizeof(struct mwifiex_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(pr_ie->ie_length);\n\t\tmemcpy(pos, pr_ie, len);\n\t\tpos += len;\n\t\tle16_unaligned_add_cpu(&ap_custom_ie->len, len);\n\t}\n\tif (ar_ie) {\n\t\tlen = sizeof(struct mwifiex_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(ar_ie->ie_length);\n\t\tmemcpy(pos, ar_ie, len);\n\t\tpos += len;\n\t\tle16_unaligned_add_cpu(&ap_custom_ie->len, len);\n\t}\n\n\tret = mwifiex_update_autoindex_ies(priv, ap_custom_ie);\n\n\tpos = (u8 *)(&ap_custom_ie->ie_list[0].ie_index);\n\tif (beacon_ie && *beacon_idx == MWIFIEX_AUTO_IDX_MASK) {\n\t\t/* save beacon ie index after auto-indexing */\n\t\t*beacon_idx = le16_to_cpu(ap_custom_ie->ie_list[0].ie_index);\n\t\tlen = sizeof(*beacon_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(beacon_ie->ie_length);\n\t\tpos += len;\n\t}\n\tif (pr_ie && le16_to_cpu(pr_ie->ie_index) == MWIFIEX_AUTO_IDX_MASK) {\n\t\t/* save probe resp ie index after auto-indexing */\n\t\t*probe_idx = *((u16 *)pos);\n\t\tlen = sizeof(*pr_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(pr_ie->ie_length);\n\t\tpos += len;\n\t}\n\tif (ar_ie && le16_to_cpu(ar_ie->ie_index) == MWIFIEX_AUTO_IDX_MASK)\n\t\t/* save assoc resp ie index after auto-indexing */\n\t\t*assoc_idx = *((u16 *)pos);\n\n\tkfree(ap_custom_ie);\n\treturn ret;\n}\n\n/* This function checks if the vendor specified IE is present in passed buffer\n * and copies it to mwifiex_ie structure.\n * Function takes pointer to struct mwifiex_ie pointer as argument.\n * If the vendor specified IE is present then memory is allocated for\n * mwifiex_ie pointer and filled in with IE. Caller should take care of freeing\n * this memory.\n */\nstatic int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\n\t*ie_ptr = ie;\n\treturn 0;\n}\n\n/* This function parses beacon IEs, probe response IEs, association response IEs\n * from cfg80211_ap_settings->beacon and sets these IE to FW.\n */\nstatic int mwifiex_set_mgmt_beacon_data_ies(struct mwifiex_private *priv,\n\t\t\t\t\t    struct cfg80211_beacon_data *data)\n{\n\tstruct mwifiex_ie *beacon_ie = NULL, *pr_ie = NULL, *ar_ie = NULL;\n\tu16 beacon_idx = MWIFIEX_AUTO_IDX_MASK, pr_idx = MWIFIEX_AUTO_IDX_MASK;\n\tu16 ar_idx = MWIFIEX_AUTO_IDX_MASK;\n\tint ret = 0;\n\n\tif (data->beacon_ies && data->beacon_ies_len) {\n\t\tmwifiex_update_vs_ie(data->beacon_ies, data->beacon_ies_len,\n\t\t\t\t     &beacon_ie, MGMT_MASK_BEACON,\n\t\t\t\t     WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->beacon_ies, data->beacon_ies_len,\n\t\t\t\t     &beacon_ie, MGMT_MASK_BEACON,\n\t\t\t\t     WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (data->proberesp_ies && data->proberesp_ies_len) {\n\t\tmwifiex_update_vs_ie(data->proberesp_ies,\n\t\t\t\t     data->proberesp_ies_len, &pr_ie,\n\t\t\t\t     MGMT_MASK_PROBE_RESP, WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->proberesp_ies,\n\t\t\t\t     data->proberesp_ies_len, &pr_ie,\n\t\t\t\t     MGMT_MASK_PROBE_RESP,\n\t\t\t\t     WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (data->assocresp_ies && data->assocresp_ies_len) {\n\t\tmwifiex_update_vs_ie(data->assocresp_ies,\n\t\t\t\t     data->assocresp_ies_len, &ar_ie,\n\t\t\t\t     MGMT_MASK_ASSOC_RESP |\n\t\t\t\t     MGMT_MASK_REASSOC_RESP,\n\t\t\t\t     WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->assocresp_ies,\n\t\t\t\t     data->assocresp_ies_len, &ar_ie,\n\t\t\t\t     MGMT_MASK_ASSOC_RESP |\n\t\t\t\t     MGMT_MASK_REASSOC_RESP, WLAN_OUI_WFA,\n\t\t\t\t     WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (beacon_ie || pr_ie || ar_ie) {\n\t\tret = mwifiex_update_uap_custom_ie(priv, beacon_ie,\n\t\t\t\t\t\t   &beacon_idx, pr_ie,\n\t\t\t\t\t\t   &pr_idx, ar_ie, &ar_idx);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tpriv->beacon_idx = beacon_idx;\n\tpriv->proberesp_idx = pr_idx;\n\tpriv->assocresp_idx = ar_idx;\n\ndone:\n\tkfree(beacon_ie);\n\tkfree(pr_ie);\n\tkfree(ar_ie);\n\n\treturn ret;\n}\n\n/* This function parses  head and tail IEs, from cfg80211_beacon_data and sets\n * these IE to FW.\n */\nstatic int mwifiex_uap_parse_tail_ies(struct mwifiex_private *priv,\n\t\t\t\t      struct cfg80211_beacon_data *info)\n{\n\tstruct mwifiex_ie *gen_ie;\n\tstruct ieee_types_header *hdr;\n\tstruct ieee80211_vendor_ie *vendorhdr;\n\tu16 gen_idx = MWIFIEX_AUTO_IDX_MASK, ie_len = 0;\n\tint left_len, parsed_len = 0;\n\tunsigned int token_len;\n\tint err = 0;\n\n\tif (!info->tail || !info->tail_len)\n\t\treturn 0;\n\n\tgen_ie = kzalloc(sizeof(*gen_ie), GFP_KERNEL);\n\tif (!gen_ie)\n\t\treturn -ENOMEM;\n\n\tleft_len = info->tail_len;\n\n\t/* Many IEs are generated in FW by parsing bss configuration.\n\t * Let's not add them here; else we may end up duplicating these IEs\n\t */\n\twhile (left_len > sizeof(struct ieee_types_header)) {\n\t\thdr = (void *)(info->tail + parsed_len);\n\t\ttoken_len = hdr->len + sizeof(struct ieee_types_header);\n\t\tif (token_len > left_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (hdr->element_id) {\n\t\tcase WLAN_EID_SSID:\n\t\tcase WLAN_EID_SUPP_RATES:\n\t\tcase WLAN_EID_COUNTRY:\n\t\tcase WLAN_EID_PWR_CONSTRAINT:\n\t\tcase WLAN_EID_ERP_INFO:\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\tcase WLAN_EID_HT_OPERATION:\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\tcase WLAN_EID_VHT_OPERATION:\n\t\t\tbreak;\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t/* Skip only Microsoft WMM IE */\n\t\t\tif (cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t\t    (const u8 *)hdr,\n\t\t\t\t\t\t    token_len))\n\t\t\t\tbreak;\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\tif (ie_len + token_len > IEEE_MAX_IE_SIZE) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(gen_ie->ie_buffer + ie_len, hdr, token_len);\n\t\t\tie_len += token_len;\n\t\t\tbreak;\n\t\t}\n\t\tleft_len -= token_len;\n\t\tparsed_len += token_len;\n\t}\n\n\t/* parse only WPA vendor IE from tail, WMM IE is configured by\n\t * bss_config command\n\t */\n\tvendorhdr = (void *)cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t\t    info->tail, info->tail_len);\n\tif (vendorhdr) {\n\t\ttoken_len = vendorhdr->len + sizeof(struct ieee_types_header);\n\t\tif (ie_len + token_len > IEEE_MAX_IE_SIZE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(gen_ie->ie_buffer + ie_len, vendorhdr, token_len);\n\t\tie_len += token_len;\n\t}\n\n\tif (!ie_len)\n\t\tgoto out;\n\n\tgen_ie->ie_index = cpu_to_le16(gen_idx);\n\tgen_ie->mgmt_subtype_mask = cpu_to_le16(MGMT_MASK_BEACON |\n\t\t\t\t\t\tMGMT_MASK_PROBE_RESP |\n\t\t\t\t\t\tMGMT_MASK_ASSOC_RESP);\n\tgen_ie->ie_length = cpu_to_le16(ie_len);\n\n\tif (mwifiex_update_uap_custom_ie(priv, gen_ie, &gen_idx, NULL, NULL,\n\t\t\t\t\t NULL, NULL)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->gen_idx = gen_idx;\n\n out:\n\tkfree(gen_ie);\n\treturn err;\n}\n\n/* This function parses different IEs-head & tail IEs, beacon IEs,\n * probe response IEs, association response IEs from cfg80211_ap_settings\n * function and sets these IE to FW.\n */\nint mwifiex_set_mgmt_ies(struct mwifiex_private *priv,\n\t\t\t struct cfg80211_beacon_data *info)\n{\n\tint ret;\n\n\tret = mwifiex_uap_parse_tail_ies(priv, info);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn mwifiex_set_mgmt_beacon_data_ies(priv, info);\n}\n\n/* This function removes management IE set */\nint mwifiex_del_mgmt_ies(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_ie *beacon_ie = NULL, *pr_ie = NULL;\n\tstruct mwifiex_ie *ar_ie = NULL, *gen_ie = NULL;\n\tint ret = 0;\n\n\tif (priv->gen_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tgen_ie = kmalloc(sizeof(*gen_ie), GFP_KERNEL);\n\t\tif (!gen_ie)\n\t\t\treturn -ENOMEM;\n\n\t\tgen_ie->ie_index = cpu_to_le16(priv->gen_idx);\n\t\tgen_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tgen_ie->ie_length = 0;\n\t\tif (mwifiex_update_uap_custom_ie(priv, gen_ie, &priv->gen_idx,\n\t\t\t\t\t\t NULL, &priv->proberesp_idx,\n\t\t\t\t\t\t NULL, &priv->assocresp_idx)) {\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tpriv->gen_idx = MWIFIEX_AUTO_IDX_MASK;\n\t}\n\n\tif (priv->beacon_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tbeacon_ie = kmalloc(sizeof(struct mwifiex_ie), GFP_KERNEL);\n\t\tif (!beacon_ie) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tbeacon_ie->ie_index = cpu_to_le16(priv->beacon_idx);\n\t\tbeacon_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tbeacon_ie->ie_length = 0;\n\t}\n\tif (priv->proberesp_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tpr_ie = kmalloc(sizeof(struct mwifiex_ie), GFP_KERNEL);\n\t\tif (!pr_ie) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tpr_ie->ie_index = cpu_to_le16(priv->proberesp_idx);\n\t\tpr_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tpr_ie->ie_length = 0;\n\t}\n\tif (priv->assocresp_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tar_ie = kmalloc(sizeof(struct mwifiex_ie), GFP_KERNEL);\n\t\tif (!ar_ie) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tar_ie->ie_index = cpu_to_le16(priv->assocresp_idx);\n\t\tar_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tar_ie->ie_length = 0;\n\t}\n\n\tif (beacon_ie || pr_ie || ar_ie)\n\t\tret = mwifiex_update_uap_custom_ie(priv,\n\t\t\t\t\t\t   beacon_ie, &priv->beacon_idx,\n\t\t\t\t\t\t   pr_ie, &priv->proberesp_idx,\n\t\t\t\t\t\t   ar_ie, &priv->assocresp_idx);\n\ndone:\n\tkfree(gen_ie);\n\tkfree(beacon_ie);\n\tkfree(pr_ie);\n\tkfree(ar_ie);\n\n\treturn ret;\n}\n", "/*\n * Marvell Wireless LAN device driver: AP specific command handling\n *\n * Copyright (C) 2012-2014, Marvell International Ltd.\n *\n * This software file (the \"File\") is distributed by Marvell International\n * Ltd. under the terms of the GNU General Public License Version 2, June 1991\n * (the \"License\").  You may use, redistribute and/or modify this File in\n * accordance with the terms and conditions of the License, a copy of which\n * is available by writing to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the\n * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n *\n * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE\n * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about\n * this warranty disclaimer.\n */\n\n#include \"main.h\"\n#include \"11ac.h\"\n#include \"11n.h\"\n\n/* This function parses security related parameters from cfg80211_ap_settings\n * and sets into FW understandable bss_config structure.\n */\nint mwifiex_set_secure_params(struct mwifiex_private *priv,\n\t\t\t      struct mwifiex_uap_bss_param *bss_config,\n\t\t\t      struct cfg80211_ap_settings *params) {\n\tint i;\n\tstruct mwifiex_wep_key wep_key;\n\n\tif (!params->privacy) {\n\t\tbss_config->protocol = PROTOCOL_NO_SECURITY;\n\t\tbss_config->key_mgmt = KEY_MGMT_NONE;\n\t\tbss_config->wpa_cfg.length = 0;\n\t\tpriv->sec_info.wep_enabled = 0;\n\t\tpriv->sec_info.wpa_enabled = 0;\n\t\tpriv->sec_info.wpa2_enabled = 0;\n\n\t\treturn 0;\n\t}\n\n\tswitch (params->auth_type) {\n\tcase NL80211_AUTHTYPE_OPEN_SYSTEM:\n\t\tbss_config->auth_mode = WLAN_AUTH_OPEN;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_SHARED_KEY:\n\t\tbss_config->auth_mode = WLAN_AUTH_SHARED_KEY;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_NETWORK_EAP:\n\t\tbss_config->auth_mode = WLAN_AUTH_LEAP;\n\t\tbreak;\n\tdefault:\n\t\tbss_config->auth_mode = MWIFIEX_AUTH_MODE_AUTO;\n\t\tbreak;\n\t}\n\n\tbss_config->key_mgmt_operation |= KEY_MGMT_ON_HOST;\n\n\tfor (i = 0; i < params->crypto.n_akm_suites; i++) {\n\t\tswitch (params->crypto.akm_suites[i]) {\n\t\tcase WLAN_AKM_SUITE_8021X:\n\t\t\tif (params->crypto.wpa_versions &\n\t\t\t    NL80211_WPA_VERSION_1) {\n\t\t\t\tbss_config->protocol = PROTOCOL_WPA;\n\t\t\t\tbss_config->key_mgmt = KEY_MGMT_EAP;\n\t\t\t}\n\t\t\tif (params->crypto.wpa_versions &\n\t\t\t    NL80211_WPA_VERSION_2) {\n\t\t\t\tbss_config->protocol |= PROTOCOL_WPA2;\n\t\t\t\tbss_config->key_mgmt = KEY_MGMT_EAP;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_PSK:\n\t\t\tif (params->crypto.wpa_versions &\n\t\t\t    NL80211_WPA_VERSION_1) {\n\t\t\t\tbss_config->protocol = PROTOCOL_WPA;\n\t\t\t\tbss_config->key_mgmt = KEY_MGMT_PSK;\n\t\t\t}\n\t\t\tif (params->crypto.wpa_versions &\n\t\t\t    NL80211_WPA_VERSION_2) {\n\t\t\t\tbss_config->protocol |= PROTOCOL_WPA2;\n\t\t\t\tbss_config->key_mgmt = KEY_MGMT_PSK;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 0; i < params->crypto.n_ciphers_pairwise; i++) {\n\t\tswitch (params->crypto.ciphers_pairwise[i]) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tif (params->crypto.wpa_versions & NL80211_WPA_VERSION_1)\n\t\t\t\tbss_config->wpa_cfg.pairwise_cipher_wpa |=\n\t\t\t\t\t\t\t\tCIPHER_TKIP;\n\t\t\tif (params->crypto.wpa_versions & NL80211_WPA_VERSION_2)\n\t\t\t\tbss_config->wpa_cfg.pairwise_cipher_wpa2 |=\n\t\t\t\t\t\t\t\tCIPHER_TKIP;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tif (params->crypto.wpa_versions & NL80211_WPA_VERSION_1)\n\t\t\t\tbss_config->wpa_cfg.pairwise_cipher_wpa |=\n\t\t\t\t\t\t\t\tCIPHER_AES_CCMP;\n\t\t\tif (params->crypto.wpa_versions & NL80211_WPA_VERSION_2)\n\t\t\t\tbss_config->wpa_cfg.pairwise_cipher_wpa2 |=\n\t\t\t\t\t\t\t\tCIPHER_AES_CCMP;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (params->crypto.cipher_group) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tif (priv->sec_info.wep_enabled) {\n\t\t\tbss_config->protocol = PROTOCOL_STATIC_WEP;\n\t\t\tbss_config->key_mgmt = KEY_MGMT_NONE;\n\t\t\tbss_config->wpa_cfg.length = 0;\n\n\t\t\tfor (i = 0; i < NUM_WEP_KEYS; i++) {\n\t\t\t\twep_key = priv->wep_key[i];\n\t\t\t\tbss_config->wep_cfg[i].key_index = i;\n\n\t\t\t\tif (priv->wep_key_curr_index == i)\n\t\t\t\t\tbss_config->wep_cfg[i].is_default = 1;\n\t\t\t\telse\n\t\t\t\t\tbss_config->wep_cfg[i].is_default = 0;\n\n\t\t\t\tbss_config->wep_cfg[i].length =\n\t\t\t\t\t\t\t     wep_key.key_length;\n\t\t\t\tmemcpy(&bss_config->wep_cfg[i].key,\n\t\t\t\t       &wep_key.key_material,\n\t\t\t\t       wep_key.key_length);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tbss_config->wpa_cfg.group_cipher = CIPHER_TKIP;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tbss_config->wpa_cfg.group_cipher = CIPHER_AES_CCMP;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/* This function updates 11n related parameters from IE and sets them into\n * bss_config structure.\n */\nvoid\nmwifiex_set_ht_params(struct mwifiex_private *priv,\n\t\t      struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tconst u8 *ht_ie;\n\n\tif (!ISSUPP_11NENABLED(priv->adapter->fw_cap_info))\n\t\treturn;\n\n\tht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, params->beacon.tail,\n\t\t\t\t params->beacon.tail_len);\n\tif (ht_ie) {\n\t\tmemcpy(&bss_cfg->ht_cap, ht_ie + 2,\n\t\t       sizeof(struct ieee80211_ht_cap));\n\t\tpriv->ap_11n_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->ht_cap, 0, sizeof(struct ieee80211_ht_cap));\n\t\tbss_cfg->ht_cap.cap_info = cpu_to_le16(MWIFIEX_DEF_HT_CAP);\n\t\tbss_cfg->ht_cap.ampdu_params_info = MWIFIEX_DEF_AMPDU;\n\t}\n\n\treturn;\n}\n\n/* This function updates 11ac related parameters from IE\n * and sets them into bss_config structure.\n */\nvoid mwifiex_set_vht_params(struct mwifiex_private *priv,\n\t\t\t    struct mwifiex_uap_bss_param *bss_cfg,\n\t\t\t    struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vht_ie;\n\n\tvht_ie = cfg80211_find_ie(WLAN_EID_VHT_CAPABILITY, params->beacon.tail,\n\t\t\t\t  params->beacon.tail_len);\n\tif (vht_ie) {\n\t\tmemcpy(&bss_cfg->vht_cap, vht_ie + 2,\n\t\t       sizeof(struct ieee80211_vht_cap));\n\t\tpriv->ap_11ac_enabled = 1;\n\t} else {\n\t\tpriv->ap_11ac_enabled = 0;\n\t}\n\n\treturn;\n}\n\n/* This function updates 11ac related parameters from IE\n * and sets them into bss_config structure.\n */\nvoid mwifiex_set_tpc_params(struct mwifiex_private *priv,\n\t\t\t    struct mwifiex_uap_bss_param *bss_cfg,\n\t\t\t    struct cfg80211_ap_settings *params)\n{\n\tconst u8 *tpc_ie;\n\n\ttpc_ie = cfg80211_find_ie(WLAN_EID_TPC_REQUEST, params->beacon.tail,\n\t\t\t\t  params->beacon.tail_len);\n\tif (tpc_ie)\n\t\tbss_cfg->power_constraint = *(tpc_ie + 2);\n\telse\n\t\tbss_cfg->power_constraint = 0;\n}\n\n/* Enable VHT only when cfg80211_ap_settings has VHT IE.\n * Otherwise disable VHT.\n */\nvoid mwifiex_set_vht_width(struct mwifiex_private *priv,\n\t\t\t   enum nl80211_chan_width width,\n\t\t\t   bool ap_11ac_enable)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_11ac_vht_cfg vht_cfg;\n\n\tvht_cfg.band_config = VHT_CFG_5GHZ;\n\tvht_cfg.cap_info = adapter->hw_dot_11ac_dev_cap;\n\n\tif (!ap_11ac_enable) {\n\t\tvht_cfg.mcs_tx_set = DISABLE_VHT_MCS_SET;\n\t\tvht_cfg.mcs_rx_set = DISABLE_VHT_MCS_SET;\n\t} else {\n\t\tvht_cfg.mcs_tx_set = DEFAULT_VHT_MCS_SET;\n\t\tvht_cfg.mcs_rx_set = DEFAULT_VHT_MCS_SET;\n\t}\n\n\tvht_cfg.misc_config  = VHT_CAP_UAP_ONLY;\n\n\tif (ap_11ac_enable && width >= NL80211_CHAN_WIDTH_80)\n\t\tvht_cfg.misc_config |= VHT_BW_80_160_80P80;\n\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11AC_CFG,\n\t\t\t HostCmd_ACT_GEN_SET, 0, &vht_cfg, true);\n\n\treturn;\n}\n\n/* This function finds supported rates IE from beacon parameter and sets\n * these rates into bss_config structure.\n */\nvoid\nmwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie)\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\n\treturn;\n}\n\n/* This function initializes some of mwifiex_uap_bss_param variables.\n * This helps FW in ignoring invalid values. These values may or may not\n * be get updated to valid ones at later stage.\n */\nvoid mwifiex_set_sys_config_invalid_data(struct mwifiex_uap_bss_param *config)\n{\n\tconfig->bcast_ssid_ctl = 0x7F;\n\tconfig->radio_ctl = 0x7F;\n\tconfig->dtim_period = 0x7F;\n\tconfig->beacon_period = 0x7FFF;\n\tconfig->auth_mode = 0x7F;\n\tconfig->rts_threshold = 0x7FFF;\n\tconfig->frag_threshold = 0x7FFF;\n\tconfig->retry_limit = 0x7F;\n\tconfig->qos_info = 0xFF;\n}\n\n/* This function parses BSS related parameters from structure\n * and prepares TLVs specific to WPA/WPA2 security.\n * These TLVs are appended to command buffer.\n */\nstatic void\nmwifiex_uap_bss_wpa(u8 **tlv_buf, void *cmd_buf, u16 *param_size)\n{\n\tstruct host_cmd_tlv_pwk_cipher *pwk_cipher;\n\tstruct host_cmd_tlv_gwk_cipher *gwk_cipher;\n\tstruct host_cmd_tlv_passphrase *passphrase;\n\tstruct host_cmd_tlv_akmp *tlv_akmp;\n\tstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\n\tu16 cmd_size = *param_size;\n\tu8 *tlv = *tlv_buf;\n\n\ttlv_akmp = (struct host_cmd_tlv_akmp *)tlv;\n\ttlv_akmp->header.type = cpu_to_le16(TLV_TYPE_UAP_AKMP);\n\ttlv_akmp->header.len = cpu_to_le16(sizeof(struct host_cmd_tlv_akmp) -\n\t\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\ttlv_akmp->key_mgmt_operation = cpu_to_le16(bss_cfg->key_mgmt_operation);\n\ttlv_akmp->key_mgmt = cpu_to_le16(bss_cfg->key_mgmt);\n\tcmd_size += sizeof(struct host_cmd_tlv_akmp);\n\ttlv += sizeof(struct host_cmd_tlv_akmp);\n\n\tif (bss_cfg->wpa_cfg.pairwise_cipher_wpa & VALID_CIPHER_BITMAP) {\n\t\tpwk_cipher = (struct host_cmd_tlv_pwk_cipher *)tlv;\n\t\tpwk_cipher->header.type = cpu_to_le16(TLV_TYPE_PWK_CIPHER);\n\t\tpwk_cipher->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_pwk_cipher) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tpwk_cipher->proto = cpu_to_le16(PROTOCOL_WPA);\n\t\tpwk_cipher->cipher = bss_cfg->wpa_cfg.pairwise_cipher_wpa;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t\ttlv += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t}\n\n\tif (bss_cfg->wpa_cfg.pairwise_cipher_wpa2 & VALID_CIPHER_BITMAP) {\n\t\tpwk_cipher = (struct host_cmd_tlv_pwk_cipher *)tlv;\n\t\tpwk_cipher->header.type = cpu_to_le16(TLV_TYPE_PWK_CIPHER);\n\t\tpwk_cipher->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_pwk_cipher) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tpwk_cipher->proto = cpu_to_le16(PROTOCOL_WPA2);\n\t\tpwk_cipher->cipher = bss_cfg->wpa_cfg.pairwise_cipher_wpa2;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t\ttlv += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t}\n\n\tif (bss_cfg->wpa_cfg.group_cipher & VALID_CIPHER_BITMAP) {\n\t\tgwk_cipher = (struct host_cmd_tlv_gwk_cipher *)tlv;\n\t\tgwk_cipher->header.type = cpu_to_le16(TLV_TYPE_GWK_CIPHER);\n\t\tgwk_cipher->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_gwk_cipher) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tgwk_cipher->cipher = bss_cfg->wpa_cfg.group_cipher;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_gwk_cipher);\n\t\ttlv += sizeof(struct host_cmd_tlv_gwk_cipher);\n\t}\n\n\tif (bss_cfg->wpa_cfg.length) {\n\t\tpassphrase = (struct host_cmd_tlv_passphrase *)tlv;\n\t\tpassphrase->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_WPA_PASSPHRASE);\n\t\tpassphrase->header.len = cpu_to_le16(bss_cfg->wpa_cfg.length);\n\t\tmemcpy(passphrase->passphrase, bss_cfg->wpa_cfg.passphrase,\n\t\t       bss_cfg->wpa_cfg.length);\n\t\tcmd_size += sizeof(struct mwifiex_ie_types_header) +\n\t\t\t    bss_cfg->wpa_cfg.length;\n\t\ttlv += sizeof(struct mwifiex_ie_types_header) +\n\t\t\t\tbss_cfg->wpa_cfg.length;\n\t}\n\n\t*param_size = cmd_size;\n\t*tlv_buf = tlv;\n\n\treturn;\n}\n\n/* This function parses WMM related parameters from cfg80211_ap_settings\n * structure and updates bss_config structure.\n */\nvoid\nmwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = vendor_ie;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n\t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}\n/* This function parses BSS related parameters from structure\n * and prepares TLVs specific to WEP encryption.\n * These TLVs are appended to command buffer.\n */\nstatic void\nmwifiex_uap_bss_wep(u8 **tlv_buf, void *cmd_buf, u16 *param_size)\n{\n\tstruct host_cmd_tlv_wep_key *wep_key;\n\tu16 cmd_size = *param_size;\n\tint i;\n\tu8 *tlv = *tlv_buf;\n\tstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\n\n\tfor (i = 0; i < NUM_WEP_KEYS; i++) {\n\t\tif (bss_cfg->wep_cfg[i].length &&\n\t\t    (bss_cfg->wep_cfg[i].length == WLAN_KEY_LEN_WEP40 ||\n\t\t     bss_cfg->wep_cfg[i].length == WLAN_KEY_LEN_WEP104)) {\n\t\t\twep_key = (struct host_cmd_tlv_wep_key *)tlv;\n\t\t\twep_key->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_WEP_KEY);\n\t\t\twep_key->header.len =\n\t\t\t\tcpu_to_le16(bss_cfg->wep_cfg[i].length + 2);\n\t\t\twep_key->key_index = bss_cfg->wep_cfg[i].key_index;\n\t\t\twep_key->is_default = bss_cfg->wep_cfg[i].is_default;\n\t\t\tmemcpy(wep_key->key, bss_cfg->wep_cfg[i].key,\n\t\t\t       bss_cfg->wep_cfg[i].length);\n\t\t\tcmd_size += sizeof(struct mwifiex_ie_types_header) + 2 +\n\t\t\t\t    bss_cfg->wep_cfg[i].length;\n\t\t\ttlv += sizeof(struct mwifiex_ie_types_header) + 2 +\n\t\t\t\t    bss_cfg->wep_cfg[i].length;\n\t\t}\n\t}\n\n\t*param_size = cmd_size;\n\t*tlv_buf = tlv;\n\n\treturn;\n}\n\n/* This function enable 11D if userspace set the country IE.\n */\nvoid mwifiex_config_uap_11d(struct mwifiex_private *priv,\n\t\t\t    struct cfg80211_beacon_data *beacon_data)\n{\n\tenum state_11d_t state_11d;\n\tconst u8 *country_ie;\n\n\tcountry_ie = cfg80211_find_ie(WLAN_EID_COUNTRY, beacon_data->tail,\n\t\t\t\t      beacon_data->tail_len);\n\tif (country_ie) {\n\t\t/* Send cmd to FW to enable 11D function */\n\t\tstate_11d = ENABLE_11D;\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\t     HostCmd_ACT_GEN_SET, DOT11D_I,\n\t\t\t\t     &state_11d, true)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"11D: failed to enable 11D\\n\");\n\t\t}\n\t}\n}\n\n/* This function parses BSS related parameters from structure\n * and prepares TLVs. These TLVs are appended to command buffer.\n*/\nstatic int\nmwifiex_uap_bss_param_prepare(u8 *tlv, void *cmd_buf, u16 *param_size)\n{\n\tstruct host_cmd_tlv_dtim_period *dtim_period;\n\tstruct host_cmd_tlv_beacon_period *beacon_period;\n\tstruct host_cmd_tlv_ssid *ssid;\n\tstruct host_cmd_tlv_bcast_ssid *bcast_ssid;\n\tstruct host_cmd_tlv_channel_band *chan_band;\n\tstruct host_cmd_tlv_frag_threshold *frag_threshold;\n\tstruct host_cmd_tlv_rts_threshold *rts_threshold;\n\tstruct host_cmd_tlv_retry_limit *retry_limit;\n\tstruct host_cmd_tlv_encrypt_protocol *encrypt_protocol;\n\tstruct host_cmd_tlv_auth_type *auth_type;\n\tstruct host_cmd_tlv_rates *tlv_rates;\n\tstruct host_cmd_tlv_ageout_timer *ao_timer, *ps_ao_timer;\n\tstruct host_cmd_tlv_power_constraint *pwr_ct;\n\tstruct mwifiex_ie_types_htcap *htcap;\n\tstruct mwifiex_ie_types_wmmcap *wmm_cap;\n\tstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\n\tint i;\n\tu16 cmd_size = *param_size;\n\n\tif (bss_cfg->ssid.ssid_len) {\n\t\tssid = (struct host_cmd_tlv_ssid *)tlv;\n\t\tssid->header.type = cpu_to_le16(TLV_TYPE_UAP_SSID);\n\t\tssid->header.len = cpu_to_le16((u16)bss_cfg->ssid.ssid_len);\n\t\tmemcpy(ssid->ssid, bss_cfg->ssid.ssid, bss_cfg->ssid.ssid_len);\n\t\tcmd_size += sizeof(struct mwifiex_ie_types_header) +\n\t\t\t    bss_cfg->ssid.ssid_len;\n\t\ttlv += sizeof(struct mwifiex_ie_types_header) +\n\t\t\t\tbss_cfg->ssid.ssid_len;\n\n\t\tbcast_ssid = (struct host_cmd_tlv_bcast_ssid *)tlv;\n\t\tbcast_ssid->header.type = cpu_to_le16(TLV_TYPE_UAP_BCAST_SSID);\n\t\tbcast_ssid->header.len =\n\t\t\t\tcpu_to_le16(sizeof(bcast_ssid->bcast_ctl));\n\t\tbcast_ssid->bcast_ctl = bss_cfg->bcast_ssid_ctl;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_bcast_ssid);\n\t\ttlv += sizeof(struct host_cmd_tlv_bcast_ssid);\n\t}\n\tif (bss_cfg->rates[0]) {\n\t\ttlv_rates = (struct host_cmd_tlv_rates *)tlv;\n\t\ttlv_rates->header.type = cpu_to_le16(TLV_TYPE_UAP_RATES);\n\n\t\tfor (i = 0; i < MWIFIEX_SUPPORTED_RATES && bss_cfg->rates[i];\n\t\t     i++)\n\t\t\ttlv_rates->rates[i] = bss_cfg->rates[i];\n\n\t\ttlv_rates->header.len = cpu_to_le16(i);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_rates) + i;\n\t\ttlv += sizeof(struct host_cmd_tlv_rates) + i;\n\t}\n\tif (bss_cfg->channel &&\n\t    (((bss_cfg->band_cfg & BIT(0)) == BAND_CONFIG_BG &&\n\t      bss_cfg->channel <= MAX_CHANNEL_BAND_BG) ||\n\t    ((bss_cfg->band_cfg & BIT(0)) == BAND_CONFIG_A &&\n\t     bss_cfg->channel <= MAX_CHANNEL_BAND_A))) {\n\t\tchan_band = (struct host_cmd_tlv_channel_band *)tlv;\n\t\tchan_band->header.type = cpu_to_le16(TLV_TYPE_CHANNELBANDLIST);\n\t\tchan_band->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_channel_band) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tchan_band->band_config = bss_cfg->band_cfg;\n\t\tchan_band->channel = bss_cfg->channel;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_channel_band);\n\t\ttlv += sizeof(struct host_cmd_tlv_channel_band);\n\t}\n\tif (bss_cfg->beacon_period >= MIN_BEACON_PERIOD &&\n\t    bss_cfg->beacon_period <= MAX_BEACON_PERIOD) {\n\t\tbeacon_period = (struct host_cmd_tlv_beacon_period *)tlv;\n\t\tbeacon_period->header.type =\n\t\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_BEACON_PERIOD);\n\t\tbeacon_period->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_beacon_period) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tbeacon_period->period = cpu_to_le16(bss_cfg->beacon_period);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_beacon_period);\n\t\ttlv += sizeof(struct host_cmd_tlv_beacon_period);\n\t}\n\tif (bss_cfg->dtim_period >= MIN_DTIM_PERIOD &&\n\t    bss_cfg->dtim_period <= MAX_DTIM_PERIOD) {\n\t\tdtim_period = (struct host_cmd_tlv_dtim_period *)tlv;\n\t\tdtim_period->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_UAP_DTIM_PERIOD);\n\t\tdtim_period->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_dtim_period) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tdtim_period->period = bss_cfg->dtim_period;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_dtim_period);\n\t\ttlv += sizeof(struct host_cmd_tlv_dtim_period);\n\t}\n\tif (bss_cfg->rts_threshold <= MWIFIEX_RTS_MAX_VALUE) {\n\t\trts_threshold = (struct host_cmd_tlv_rts_threshold *)tlv;\n\t\trts_threshold->header.type =\n\t\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_RTS_THRESHOLD);\n\t\trts_threshold->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_rts_threshold) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\trts_threshold->rts_thr = cpu_to_le16(bss_cfg->rts_threshold);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_frag_threshold);\n\t\ttlv += sizeof(struct host_cmd_tlv_frag_threshold);\n\t}\n\tif ((bss_cfg->frag_threshold >= MWIFIEX_FRAG_MIN_VALUE) &&\n\t    (bss_cfg->frag_threshold <= MWIFIEX_FRAG_MAX_VALUE)) {\n\t\tfrag_threshold = (struct host_cmd_tlv_frag_threshold *)tlv;\n\t\tfrag_threshold->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_FRAG_THRESHOLD);\n\t\tfrag_threshold->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_frag_threshold) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tfrag_threshold->frag_thr = cpu_to_le16(bss_cfg->frag_threshold);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_frag_threshold);\n\t\ttlv += sizeof(struct host_cmd_tlv_frag_threshold);\n\t}\n\tif (bss_cfg->retry_limit <= MWIFIEX_RETRY_LIMIT) {\n\t\tretry_limit = (struct host_cmd_tlv_retry_limit *)tlv;\n\t\tretry_limit->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_UAP_RETRY_LIMIT);\n\t\tretry_limit->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_retry_limit) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tretry_limit->limit = (u8)bss_cfg->retry_limit;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_retry_limit);\n\t\ttlv += sizeof(struct host_cmd_tlv_retry_limit);\n\t}\n\tif ((bss_cfg->protocol & PROTOCOL_WPA) ||\n\t    (bss_cfg->protocol & PROTOCOL_WPA2) ||\n\t    (bss_cfg->protocol & PROTOCOL_EAP))\n\t\tmwifiex_uap_bss_wpa(&tlv, cmd_buf, &cmd_size);\n\telse\n\t\tmwifiex_uap_bss_wep(&tlv, cmd_buf, &cmd_size);\n\n\tif ((bss_cfg->auth_mode <= WLAN_AUTH_SHARED_KEY) ||\n\t    (bss_cfg->auth_mode == MWIFIEX_AUTH_MODE_AUTO)) {\n\t\tauth_type = (struct host_cmd_tlv_auth_type *)tlv;\n\t\tauth_type->header.type = cpu_to_le16(TLV_TYPE_AUTH_TYPE);\n\t\tauth_type->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_auth_type) -\n\t\t\tsizeof(struct mwifiex_ie_types_header));\n\t\tauth_type->auth_type = (u8)bss_cfg->auth_mode;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_auth_type);\n\t\ttlv += sizeof(struct host_cmd_tlv_auth_type);\n\t}\n\tif (bss_cfg->protocol) {\n\t\tencrypt_protocol = (struct host_cmd_tlv_encrypt_protocol *)tlv;\n\t\tencrypt_protocol->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_UAP_ENCRY_PROTOCOL);\n\t\tencrypt_protocol->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_encrypt_protocol)\n\t\t\t- sizeof(struct mwifiex_ie_types_header));\n\t\tencrypt_protocol->proto = cpu_to_le16(bss_cfg->protocol);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_encrypt_protocol);\n\t\ttlv += sizeof(struct host_cmd_tlv_encrypt_protocol);\n\t}\n\n\tif (bss_cfg->ht_cap.cap_info) {\n\t\thtcap = (struct mwifiex_ie_types_htcap *)tlv;\n\t\thtcap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\thtcap->header.len =\n\t\t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\thtcap->ht_cap.cap_info = bss_cfg->ht_cap.cap_info;\n\t\thtcap->ht_cap.ampdu_params_info =\n\t\t\t\t\t     bss_cfg->ht_cap.ampdu_params_info;\n\t\tmemcpy(&htcap->ht_cap.mcs, &bss_cfg->ht_cap.mcs,\n\t\t       sizeof(struct ieee80211_mcs_info));\n\t\thtcap->ht_cap.extended_ht_cap_info =\n\t\t\t\t\tbss_cfg->ht_cap.extended_ht_cap_info;\n\t\thtcap->ht_cap.tx_BF_cap_info = bss_cfg->ht_cap.tx_BF_cap_info;\n\t\thtcap->ht_cap.antenna_selection_info =\n\t\t\t\t\tbss_cfg->ht_cap.antenna_selection_info;\n\t\tcmd_size += sizeof(struct mwifiex_ie_types_htcap);\n\t\ttlv += sizeof(struct mwifiex_ie_types_htcap);\n\t}\n\n\tif (bss_cfg->wmm_info.qos_info != 0xFF) {\n\t\twmm_cap = (struct mwifiex_ie_types_wmmcap *)tlv;\n\t\twmm_cap->header.type = cpu_to_le16(WLAN_EID_VENDOR_SPECIFIC);\n\t\twmm_cap->header.len = cpu_to_le16(sizeof(wmm_cap->wmm_info));\n\t\tmemcpy(&wmm_cap->wmm_info, &bss_cfg->wmm_info,\n\t\t       sizeof(wmm_cap->wmm_info));\n\t\tcmd_size += sizeof(struct mwifiex_ie_types_wmmcap);\n\t\ttlv += sizeof(struct mwifiex_ie_types_wmmcap);\n\t}\n\n\tif (bss_cfg->sta_ao_timer) {\n\t\tao_timer = (struct host_cmd_tlv_ageout_timer *)tlv;\n\t\tao_timer->header.type = cpu_to_le16(TLV_TYPE_UAP_AO_TIMER);\n\t\tao_timer->header.len = cpu_to_le16(sizeof(*ao_timer) -\n\t\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\t\tao_timer->sta_ao_timer = cpu_to_le32(bss_cfg->sta_ao_timer);\n\t\tcmd_size += sizeof(*ao_timer);\n\t\ttlv += sizeof(*ao_timer);\n\t}\n\n\tif (bss_cfg->power_constraint) {\n\t\tpwr_ct = (void *)tlv;\n\t\tpwr_ct->header.type = cpu_to_le16(TLV_TYPE_PWR_CONSTRAINT);\n\t\tpwr_ct->header.len = cpu_to_le16(sizeof(u8));\n\t\tpwr_ct->constraint = bss_cfg->power_constraint;\n\t\tcmd_size += sizeof(*pwr_ct);\n\t\ttlv += sizeof(*pwr_ct);\n\t}\n\n\tif (bss_cfg->ps_sta_ao_timer) {\n\t\tps_ao_timer = (struct host_cmd_tlv_ageout_timer *)tlv;\n\t\tps_ao_timer->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_PS_AO_TIMER);\n\t\tps_ao_timer->header.len = cpu_to_le16(sizeof(*ps_ao_timer) -\n\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\t\tps_ao_timer->sta_ao_timer =\n\t\t\t\t\tcpu_to_le32(bss_cfg->ps_sta_ao_timer);\n\t\tcmd_size += sizeof(*ps_ao_timer);\n\t\ttlv += sizeof(*ps_ao_timer);\n\t}\n\n\t*param_size = cmd_size;\n\n\treturn 0;\n}\n\n/* This function parses custom IEs from IE list and prepares command buffer */\nstatic int mwifiex_uap_custom_ie_prepare(u8 *tlv, void *cmd_buf, u16 *ie_size)\n{\n\tstruct mwifiex_ie_list *ap_ie = cmd_buf;\n\tstruct mwifiex_ie_types_header *tlv_ie = (void *)tlv;\n\n\tif (!ap_ie || !ap_ie->len)\n\t\treturn -1;\n\n\t*ie_size += le16_to_cpu(ap_ie->len) +\n\t\t\tsizeof(struct mwifiex_ie_types_header);\n\n\ttlv_ie->type = cpu_to_le16(TLV_TYPE_MGMT_IE);\n\ttlv_ie->len = ap_ie->len;\n\ttlv += sizeof(struct mwifiex_ie_types_header);\n\n\tmemcpy(tlv, ap_ie->ie_list, le16_to_cpu(ap_ie->len));\n\n\treturn 0;\n}\n\n/* Parse AP config structure and prepare TLV based command structure\n * to be sent to FW for uAP configuration\n */\nstatic int\nmwifiex_cmd_uap_sys_config(struct host_cmd_ds_command *cmd, u16 cmd_action,\n\t\t\t   u32 type, void *cmd_buf)\n{\n\tu8 *tlv;\n\tu16 cmd_size, param_size, ie_size;\n\tstruct host_cmd_ds_sys_config *sys_cfg;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_UAP_SYS_CONFIG);\n\tcmd_size = (u16)(sizeof(struct host_cmd_ds_sys_config) + S_DS_GEN);\n\tsys_cfg = (struct host_cmd_ds_sys_config *)&cmd->params.uap_sys_config;\n\tsys_cfg->action = cpu_to_le16(cmd_action);\n\ttlv = sys_cfg->tlv;\n\n\tswitch (type) {\n\tcase UAP_BSS_PARAMS_I:\n\t\tparam_size = cmd_size;\n\t\tif (mwifiex_uap_bss_param_prepare(tlv, cmd_buf, &param_size))\n\t\t\treturn -1;\n\t\tcmd->size = cpu_to_le16(param_size);\n\t\tbreak;\n\tcase UAP_CUSTOM_IE_I:\n\t\tie_size = cmd_size;\n\t\tif (mwifiex_uap_custom_ie_prepare(tlv, cmd_buf, &ie_size))\n\t\t\treturn -1;\n\t\tcmd->size = cpu_to_le16(ie_size);\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* This function prepares AP specific deauth command with mac supplied in\n * function parameter.\n */\nstatic int mwifiex_cmd_uap_sta_deauth(struct mwifiex_private *priv,\n\t\t\t\t      struct host_cmd_ds_command *cmd, u8 *mac)\n{\n\tstruct host_cmd_ds_sta_deauth *sta_deauth = &cmd->params.sta_deauth;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_UAP_STA_DEAUTH);\n\tmemcpy(sta_deauth->mac, mac, ETH_ALEN);\n\tsta_deauth->reason = cpu_to_le16(WLAN_REASON_DEAUTH_LEAVING);\n\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_sta_deauth) +\n\t\t\t\tS_DS_GEN);\n\treturn 0;\n}\n\n/* This function prepares the AP specific commands before sending them\n * to the firmware.\n * This is a generic function which calls specific command preparation\n * routines based upon the command number.\n */\nint mwifiex_uap_prepare_cmd(struct mwifiex_private *priv, u16 cmd_no,\n\t\t\t    u16 cmd_action, u32 type,\n\t\t\t    void *data_buf, void *cmd_buf)\n{\n\tstruct host_cmd_ds_command *cmd = cmd_buf;\n\n\tswitch (cmd_no) {\n\tcase HostCmd_CMD_UAP_SYS_CONFIG:\n\t\tif (mwifiex_cmd_uap_sys_config(cmd, cmd_action, type, data_buf))\n\t\t\treturn -1;\n\t\tbreak;\n\tcase HostCmd_CMD_UAP_BSS_START:\n\tcase HostCmd_CMD_UAP_BSS_STOP:\n\tcase HOST_CMD_APCMD_SYS_RESET:\n\tcase HOST_CMD_APCMD_STA_LIST:\n\t\tcmd->command = cpu_to_le16(cmd_no);\n\t\tcmd->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_UAP_STA_DEAUTH:\n\t\tif (mwifiex_cmd_uap_sta_deauth(priv, cmd, data_buf))\n\t\t\treturn -1;\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\n\t\tif (mwifiex_cmd_issue_chan_report_request(priv, cmd_buf,\n\t\t\t\t\t\t\t  data_buf))\n\t\t\treturn -1;\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"PREP_CMD: unknown cmd %#x\\n\", cmd_no);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid mwifiex_uap_set_channel(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_uap_bss_param *bss_cfg,\n\t\t\t     struct cfg80211_chan_def chandef)\n{\n\tu8 config_bands = 0, old_bands = priv->adapter->config_bands;\n\n\tpriv->bss_chandef = chandef;\n\n\tbss_cfg->channel = ieee80211_frequency_to_channel(\n\t\t\t\t\t\t     chandef.chan->center_freq);\n\n\t/* Set appropriate bands */\n\tif (chandef.chan->band == NL80211_BAND_2GHZ) {\n\t\tbss_cfg->band_cfg = BAND_CONFIG_BG;\n\t\tconfig_bands = BAND_B | BAND_G;\n\n\t\tif (chandef.width > NL80211_CHAN_WIDTH_20_NOHT)\n\t\t\tconfig_bands |= BAND_GN;\n\t} else {\n\t\tbss_cfg->band_cfg = BAND_CONFIG_A;\n\t\tconfig_bands = BAND_A;\n\n\t\tif (chandef.width > NL80211_CHAN_WIDTH_20_NOHT)\n\t\t\tconfig_bands |= BAND_AN;\n\n\t\tif (chandef.width > NL80211_CHAN_WIDTH_40)\n\t\t\tconfig_bands |= BAND_AAC;\n\t}\n\n\tswitch (chandef.width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (chandef.center_freq1 < chandef.chan->center_freq)\n\t\t\tbss_cfg->band_cfg |= MWIFIEX_SEC_CHAN_BELOW;\n\t\telse\n\t\t\tbss_cfg->band_cfg |= MWIFIEX_SEC_CHAN_ABOVE;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tbss_cfg->band_cfg |=\n\t\t    mwifiex_get_sec_chan_offset(bss_cfg->channel) << 4;\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter,\n\t\t\t    WARN, \"Unknown channel width: %d\\n\",\n\t\t\t    chandef.width);\n\t\tbreak;\n\t}\n\n\tpriv->adapter->config_bands = config_bands;\n\n\tif (old_bands != config_bands) {\n\t\tmwifiex_send_domain_info_cmd_fw(priv->adapter->wiphy);\n\t\tmwifiex_dnld_txpwr_table(priv);\n\t}\n}\n\nint mwifiex_config_start_uap(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_uap_bss_param *bss_cfg)\n{\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_SYS_CONFIG,\n\t\t\t     HostCmd_ACT_GEN_SET,\n\t\t\t     UAP_BSS_PARAMS_I, bss_cfg, true)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to set AP configuration\\n\");\n\t\treturn -1;\n\t}\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_START,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, NULL, true)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to start the BSS\\n\");\n\t\treturn -1;\n\t}\n\n\tif (priv->sec_info.wep_enabled)\n\t\tpriv->curr_pkt_filter |= HostCmd_ACT_MAC_WEP_ENABLE;\n\telse\n\t\tpriv->curr_pkt_filter &= ~HostCmd_ACT_MAC_WEP_ENABLE;\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t     &priv->curr_pkt_filter, true))\n\t\treturn -1;\n\n\treturn 0;\n}\n"], "fixing_code": ["/*\n * Marvell Wireless LAN device driver: management IE handling- setting and\n * deleting IE.\n *\n * Copyright (C) 2012-2014, Marvell International Ltd.\n *\n * This software file (the \"File\") is distributed by Marvell International\n * Ltd. under the terms of the GNU General Public License Version 2, June 1991\n * (the \"License\").  You may use, redistribute and/or modify this File in\n * accordance with the terms and conditions of the License, a copy of which\n * is available by writing to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the\n * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n *\n * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE\n * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about\n * this warranty disclaimer.\n */\n\n#include \"main.h\"\n\n/* This function checks if current IE index is used by any on other interface.\n * Return: -1: yes, current IE index is used by someone else.\n *          0: no, current IE index is NOT used by other interface.\n */\nstatic int\nmwifiex_ie_index_used_by_other_intf(struct mwifiex_private *priv, u16 idx)\n{\n\tint i;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_ie *ie;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (adapter->priv[i] != priv) {\n\t\t\tie = &adapter->priv[i]->mgmt_ie[idx];\n\t\t\tif (ie->mgmt_subtype_mask && ie->ie_length)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* Get unused IE index. This index will be used for setting new IE */\nstatic int\nmwifiex_ie_get_autoidx(struct mwifiex_private *priv, u16 subtype_mask,\n\t\t       struct mwifiex_ie *ie, u16 *index)\n{\n\tu16 mask, len, i;\n\n\tfor (i = 0; i < priv->adapter->max_mgmt_ie_index; i++) {\n\t\tmask = le16_to_cpu(priv->mgmt_ie[i].mgmt_subtype_mask);\n\t\tlen = le16_to_cpu(ie->ie_length);\n\n\t\tif (mask == MWIFIEX_AUTO_IDX_MASK)\n\t\t\tcontinue;\n\n\t\tif (mask == subtype_mask) {\n\t\t\tif (len > IEEE_MAX_IE_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\t*index = i;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!priv->mgmt_ie[i].ie_length) {\n\t\t\tif (mwifiex_ie_index_used_by_other_intf(priv, i))\n\t\t\t\tcontinue;\n\n\t\t\t*index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/* This function prepares IE data buffer for command to be sent to FW */\nstatic int\nmwifiex_update_autoindex_ies(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_ie_list *ie_list)\n{\n\tu16 travel_len, index, mask;\n\ts16 input_len, tlv_len;\n\tstruct mwifiex_ie *ie;\n\tu8 *tmp;\n\n\tinput_len = le16_to_cpu(ie_list->len);\n\ttravel_len = sizeof(struct mwifiex_ie_types_header);\n\n\tie_list->len = 0;\n\n\twhile (input_len >= sizeof(struct mwifiex_ie_types_header)) {\n\t\tie = (struct mwifiex_ie *)(((u8 *)ie_list) + travel_len);\n\t\ttlv_len = le16_to_cpu(ie->ie_length);\n\t\ttravel_len += tlv_len + MWIFIEX_IE_HDR_SIZE;\n\n\t\tif (input_len < tlv_len + MWIFIEX_IE_HDR_SIZE)\n\t\t\treturn -1;\n\t\tindex = le16_to_cpu(ie->ie_index);\n\t\tmask = le16_to_cpu(ie->mgmt_subtype_mask);\n\n\t\tif (index == MWIFIEX_AUTO_IDX_MASK) {\n\t\t\t/* automatic addition */\n\t\t\tif (mwifiex_ie_get_autoidx(priv, mask, ie, &index))\n\t\t\t\treturn -1;\n\t\t\tif (index == MWIFIEX_AUTO_IDX_MASK)\n\t\t\t\treturn -1;\n\n\t\t\ttmp = (u8 *)&priv->mgmt_ie[index].ie_buffer;\n\t\t\tmemcpy(tmp, &ie->ie_buffer, le16_to_cpu(ie->ie_length));\n\t\t\tpriv->mgmt_ie[index].ie_length = ie->ie_length;\n\t\t\tpriv->mgmt_ie[index].ie_index = cpu_to_le16(index);\n\t\t\tpriv->mgmt_ie[index].mgmt_subtype_mask =\n\t\t\t\t\t\t\tcpu_to_le16(mask);\n\n\t\t\tie->ie_index = cpu_to_le16(index);\n\t\t} else {\n\t\t\tif (mask != MWIFIEX_DELETE_MASK)\n\t\t\t\treturn -1;\n\t\t\t/*\n\t\t\t * Check if this index is being used on any\n\t\t\t * other interface.\n\t\t\t */\n\t\t\tif (mwifiex_ie_index_used_by_other_intf(priv, index))\n\t\t\t\treturn -1;\n\n\t\t\tie->ie_length = 0;\n\t\t\tmemcpy(&priv->mgmt_ie[index], ie,\n\t\t\t       sizeof(struct mwifiex_ie));\n\t\t}\n\n\t\tle16_unaligned_add_cpu(&ie_list->len,\n\t\t\t\t       le16_to_cpu(\n\t\t\t\t\t    priv->mgmt_ie[index].ie_length) +\n\t\t\t\t       MWIFIEX_IE_HDR_SIZE);\n\t\tinput_len -= tlv_len + MWIFIEX_IE_HDR_SIZE;\n\t}\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP)\n\t\treturn mwifiex_send_cmd(priv, HostCmd_CMD_UAP_SYS_CONFIG,\n\t\t\t\t\tHostCmd_ACT_GEN_SET,\n\t\t\t\t\tUAP_CUSTOM_IE_I, ie_list, true);\n\n\treturn 0;\n}\n\n/* Copy individual custom IEs for beacon, probe response and assoc response\n * and prepare single structure for IE setting.\n * This function also updates allocated IE indices from driver.\n */\nstatic int\nmwifiex_update_uap_custom_ie(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_ie *beacon_ie, u16 *beacon_idx,\n\t\t\t     struct mwifiex_ie *pr_ie, u16 *probe_idx,\n\t\t\t     struct mwifiex_ie *ar_ie, u16 *assoc_idx)\n{\n\tstruct mwifiex_ie_list *ap_custom_ie;\n\tu8 *pos;\n\tu16 len;\n\tint ret;\n\n\tap_custom_ie = kzalloc(sizeof(*ap_custom_ie), GFP_KERNEL);\n\tif (!ap_custom_ie)\n\t\treturn -ENOMEM;\n\n\tap_custom_ie->type = cpu_to_le16(TLV_TYPE_MGMT_IE);\n\tpos = (u8 *)ap_custom_ie->ie_list;\n\n\tif (beacon_ie) {\n\t\tlen = sizeof(struct mwifiex_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(beacon_ie->ie_length);\n\t\tmemcpy(pos, beacon_ie, len);\n\t\tpos += len;\n\t\tle16_unaligned_add_cpu(&ap_custom_ie->len, len);\n\t}\n\tif (pr_ie) {\n\t\tlen = sizeof(struct mwifiex_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(pr_ie->ie_length);\n\t\tmemcpy(pos, pr_ie, len);\n\t\tpos += len;\n\t\tle16_unaligned_add_cpu(&ap_custom_ie->len, len);\n\t}\n\tif (ar_ie) {\n\t\tlen = sizeof(struct mwifiex_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(ar_ie->ie_length);\n\t\tmemcpy(pos, ar_ie, len);\n\t\tpos += len;\n\t\tle16_unaligned_add_cpu(&ap_custom_ie->len, len);\n\t}\n\n\tret = mwifiex_update_autoindex_ies(priv, ap_custom_ie);\n\n\tpos = (u8 *)(&ap_custom_ie->ie_list[0].ie_index);\n\tif (beacon_ie && *beacon_idx == MWIFIEX_AUTO_IDX_MASK) {\n\t\t/* save beacon ie index after auto-indexing */\n\t\t*beacon_idx = le16_to_cpu(ap_custom_ie->ie_list[0].ie_index);\n\t\tlen = sizeof(*beacon_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(beacon_ie->ie_length);\n\t\tpos += len;\n\t}\n\tif (pr_ie && le16_to_cpu(pr_ie->ie_index) == MWIFIEX_AUTO_IDX_MASK) {\n\t\t/* save probe resp ie index after auto-indexing */\n\t\t*probe_idx = *((u16 *)pos);\n\t\tlen = sizeof(*pr_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(pr_ie->ie_length);\n\t\tpos += len;\n\t}\n\tif (ar_ie && le16_to_cpu(ar_ie->ie_index) == MWIFIEX_AUTO_IDX_MASK)\n\t\t/* save assoc resp ie index after auto-indexing */\n\t\t*assoc_idx = *((u16 *)pos);\n\n\tkfree(ap_custom_ie);\n\treturn ret;\n}\n\n/* This function checks if the vendor specified IE is present in passed buffer\n * and copies it to mwifiex_ie structure.\n * Function takes pointer to struct mwifiex_ie pointer as argument.\n * If the vendor specified IE is present then memory is allocated for\n * mwifiex_ie pointer and filled in with IE. Caller should take care of freeing\n * this memory.\n */\nstatic int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n\t\t\tIEEE_MAX_IE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\n\t*ie_ptr = ie;\n\treturn 0;\n}\n\n/* This function parses beacon IEs, probe response IEs, association response IEs\n * from cfg80211_ap_settings->beacon and sets these IE to FW.\n */\nstatic int mwifiex_set_mgmt_beacon_data_ies(struct mwifiex_private *priv,\n\t\t\t\t\t    struct cfg80211_beacon_data *data)\n{\n\tstruct mwifiex_ie *beacon_ie = NULL, *pr_ie = NULL, *ar_ie = NULL;\n\tu16 beacon_idx = MWIFIEX_AUTO_IDX_MASK, pr_idx = MWIFIEX_AUTO_IDX_MASK;\n\tu16 ar_idx = MWIFIEX_AUTO_IDX_MASK;\n\tint ret = 0;\n\n\tif (data->beacon_ies && data->beacon_ies_len) {\n\t\tmwifiex_update_vs_ie(data->beacon_ies, data->beacon_ies_len,\n\t\t\t\t     &beacon_ie, MGMT_MASK_BEACON,\n\t\t\t\t     WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->beacon_ies, data->beacon_ies_len,\n\t\t\t\t     &beacon_ie, MGMT_MASK_BEACON,\n\t\t\t\t     WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (data->proberesp_ies && data->proberesp_ies_len) {\n\t\tmwifiex_update_vs_ie(data->proberesp_ies,\n\t\t\t\t     data->proberesp_ies_len, &pr_ie,\n\t\t\t\t     MGMT_MASK_PROBE_RESP, WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->proberesp_ies,\n\t\t\t\t     data->proberesp_ies_len, &pr_ie,\n\t\t\t\t     MGMT_MASK_PROBE_RESP,\n\t\t\t\t     WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (data->assocresp_ies && data->assocresp_ies_len) {\n\t\tmwifiex_update_vs_ie(data->assocresp_ies,\n\t\t\t\t     data->assocresp_ies_len, &ar_ie,\n\t\t\t\t     MGMT_MASK_ASSOC_RESP |\n\t\t\t\t     MGMT_MASK_REASSOC_RESP,\n\t\t\t\t     WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->assocresp_ies,\n\t\t\t\t     data->assocresp_ies_len, &ar_ie,\n\t\t\t\t     MGMT_MASK_ASSOC_RESP |\n\t\t\t\t     MGMT_MASK_REASSOC_RESP, WLAN_OUI_WFA,\n\t\t\t\t     WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (beacon_ie || pr_ie || ar_ie) {\n\t\tret = mwifiex_update_uap_custom_ie(priv, beacon_ie,\n\t\t\t\t\t\t   &beacon_idx, pr_ie,\n\t\t\t\t\t\t   &pr_idx, ar_ie, &ar_idx);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tpriv->beacon_idx = beacon_idx;\n\tpriv->proberesp_idx = pr_idx;\n\tpriv->assocresp_idx = ar_idx;\n\ndone:\n\tkfree(beacon_ie);\n\tkfree(pr_ie);\n\tkfree(ar_ie);\n\n\treturn ret;\n}\n\n/* This function parses  head and tail IEs, from cfg80211_beacon_data and sets\n * these IE to FW.\n */\nstatic int mwifiex_uap_parse_tail_ies(struct mwifiex_private *priv,\n\t\t\t\t      struct cfg80211_beacon_data *info)\n{\n\tstruct mwifiex_ie *gen_ie;\n\tstruct ieee_types_header *hdr;\n\tstruct ieee80211_vendor_ie *vendorhdr;\n\tu16 gen_idx = MWIFIEX_AUTO_IDX_MASK, ie_len = 0;\n\tint left_len, parsed_len = 0;\n\tunsigned int token_len;\n\tint err = 0;\n\n\tif (!info->tail || !info->tail_len)\n\t\treturn 0;\n\n\tgen_ie = kzalloc(sizeof(*gen_ie), GFP_KERNEL);\n\tif (!gen_ie)\n\t\treturn -ENOMEM;\n\n\tleft_len = info->tail_len;\n\n\t/* Many IEs are generated in FW by parsing bss configuration.\n\t * Let's not add them here; else we may end up duplicating these IEs\n\t */\n\twhile (left_len > sizeof(struct ieee_types_header)) {\n\t\thdr = (void *)(info->tail + parsed_len);\n\t\ttoken_len = hdr->len + sizeof(struct ieee_types_header);\n\t\tif (token_len > left_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (hdr->element_id) {\n\t\tcase WLAN_EID_SSID:\n\t\tcase WLAN_EID_SUPP_RATES:\n\t\tcase WLAN_EID_COUNTRY:\n\t\tcase WLAN_EID_PWR_CONSTRAINT:\n\t\tcase WLAN_EID_ERP_INFO:\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\tcase WLAN_EID_HT_OPERATION:\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\tcase WLAN_EID_VHT_OPERATION:\n\t\t\tbreak;\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t/* Skip only Microsoft WMM IE */\n\t\t\tif (cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t\t    (const u8 *)hdr,\n\t\t\t\t\t\t    token_len))\n\t\t\t\tbreak;\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\tif (ie_len + token_len > IEEE_MAX_IE_SIZE) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(gen_ie->ie_buffer + ie_len, hdr, token_len);\n\t\t\tie_len += token_len;\n\t\t\tbreak;\n\t\t}\n\t\tleft_len -= token_len;\n\t\tparsed_len += token_len;\n\t}\n\n\t/* parse only WPA vendor IE from tail, WMM IE is configured by\n\t * bss_config command\n\t */\n\tvendorhdr = (void *)cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t\t    info->tail, info->tail_len);\n\tif (vendorhdr) {\n\t\ttoken_len = vendorhdr->len + sizeof(struct ieee_types_header);\n\t\tif (ie_len + token_len > IEEE_MAX_IE_SIZE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(gen_ie->ie_buffer + ie_len, vendorhdr, token_len);\n\t\tie_len += token_len;\n\t}\n\n\tif (!ie_len)\n\t\tgoto out;\n\n\tgen_ie->ie_index = cpu_to_le16(gen_idx);\n\tgen_ie->mgmt_subtype_mask = cpu_to_le16(MGMT_MASK_BEACON |\n\t\t\t\t\t\tMGMT_MASK_PROBE_RESP |\n\t\t\t\t\t\tMGMT_MASK_ASSOC_RESP);\n\tgen_ie->ie_length = cpu_to_le16(ie_len);\n\n\tif (mwifiex_update_uap_custom_ie(priv, gen_ie, &gen_idx, NULL, NULL,\n\t\t\t\t\t NULL, NULL)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->gen_idx = gen_idx;\n\n out:\n\tkfree(gen_ie);\n\treturn err;\n}\n\n/* This function parses different IEs-head & tail IEs, beacon IEs,\n * probe response IEs, association response IEs from cfg80211_ap_settings\n * function and sets these IE to FW.\n */\nint mwifiex_set_mgmt_ies(struct mwifiex_private *priv,\n\t\t\t struct cfg80211_beacon_data *info)\n{\n\tint ret;\n\n\tret = mwifiex_uap_parse_tail_ies(priv, info);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn mwifiex_set_mgmt_beacon_data_ies(priv, info);\n}\n\n/* This function removes management IE set */\nint mwifiex_del_mgmt_ies(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_ie *beacon_ie = NULL, *pr_ie = NULL;\n\tstruct mwifiex_ie *ar_ie = NULL, *gen_ie = NULL;\n\tint ret = 0;\n\n\tif (priv->gen_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tgen_ie = kmalloc(sizeof(*gen_ie), GFP_KERNEL);\n\t\tif (!gen_ie)\n\t\t\treturn -ENOMEM;\n\n\t\tgen_ie->ie_index = cpu_to_le16(priv->gen_idx);\n\t\tgen_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tgen_ie->ie_length = 0;\n\t\tif (mwifiex_update_uap_custom_ie(priv, gen_ie, &priv->gen_idx,\n\t\t\t\t\t\t NULL, &priv->proberesp_idx,\n\t\t\t\t\t\t NULL, &priv->assocresp_idx)) {\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tpriv->gen_idx = MWIFIEX_AUTO_IDX_MASK;\n\t}\n\n\tif (priv->beacon_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tbeacon_ie = kmalloc(sizeof(struct mwifiex_ie), GFP_KERNEL);\n\t\tif (!beacon_ie) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tbeacon_ie->ie_index = cpu_to_le16(priv->beacon_idx);\n\t\tbeacon_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tbeacon_ie->ie_length = 0;\n\t}\n\tif (priv->proberesp_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tpr_ie = kmalloc(sizeof(struct mwifiex_ie), GFP_KERNEL);\n\t\tif (!pr_ie) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tpr_ie->ie_index = cpu_to_le16(priv->proberesp_idx);\n\t\tpr_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tpr_ie->ie_length = 0;\n\t}\n\tif (priv->assocresp_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tar_ie = kmalloc(sizeof(struct mwifiex_ie), GFP_KERNEL);\n\t\tif (!ar_ie) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tar_ie->ie_index = cpu_to_le16(priv->assocresp_idx);\n\t\tar_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tar_ie->ie_length = 0;\n\t}\n\n\tif (beacon_ie || pr_ie || ar_ie)\n\t\tret = mwifiex_update_uap_custom_ie(priv,\n\t\t\t\t\t\t   beacon_ie, &priv->beacon_idx,\n\t\t\t\t\t\t   pr_ie, &priv->proberesp_idx,\n\t\t\t\t\t\t   ar_ie, &priv->assocresp_idx);\n\ndone:\n\tkfree(gen_ie);\n\tkfree(beacon_ie);\n\tkfree(pr_ie);\n\tkfree(ar_ie);\n\n\treturn ret;\n}\n", "/*\n * Marvell Wireless LAN device driver: AP specific command handling\n *\n * Copyright (C) 2012-2014, Marvell International Ltd.\n *\n * This software file (the \"File\") is distributed by Marvell International\n * Ltd. under the terms of the GNU General Public License Version 2, June 1991\n * (the \"License\").  You may use, redistribute and/or modify this File in\n * accordance with the terms and conditions of the License, a copy of which\n * is available by writing to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the\n * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n *\n * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE\n * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about\n * this warranty disclaimer.\n */\n\n#include \"main.h\"\n#include \"11ac.h\"\n#include \"11n.h\"\n\n/* This function parses security related parameters from cfg80211_ap_settings\n * and sets into FW understandable bss_config structure.\n */\nint mwifiex_set_secure_params(struct mwifiex_private *priv,\n\t\t\t      struct mwifiex_uap_bss_param *bss_config,\n\t\t\t      struct cfg80211_ap_settings *params) {\n\tint i;\n\tstruct mwifiex_wep_key wep_key;\n\n\tif (!params->privacy) {\n\t\tbss_config->protocol = PROTOCOL_NO_SECURITY;\n\t\tbss_config->key_mgmt = KEY_MGMT_NONE;\n\t\tbss_config->wpa_cfg.length = 0;\n\t\tpriv->sec_info.wep_enabled = 0;\n\t\tpriv->sec_info.wpa_enabled = 0;\n\t\tpriv->sec_info.wpa2_enabled = 0;\n\n\t\treturn 0;\n\t}\n\n\tswitch (params->auth_type) {\n\tcase NL80211_AUTHTYPE_OPEN_SYSTEM:\n\t\tbss_config->auth_mode = WLAN_AUTH_OPEN;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_SHARED_KEY:\n\t\tbss_config->auth_mode = WLAN_AUTH_SHARED_KEY;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_NETWORK_EAP:\n\t\tbss_config->auth_mode = WLAN_AUTH_LEAP;\n\t\tbreak;\n\tdefault:\n\t\tbss_config->auth_mode = MWIFIEX_AUTH_MODE_AUTO;\n\t\tbreak;\n\t}\n\n\tbss_config->key_mgmt_operation |= KEY_MGMT_ON_HOST;\n\n\tfor (i = 0; i < params->crypto.n_akm_suites; i++) {\n\t\tswitch (params->crypto.akm_suites[i]) {\n\t\tcase WLAN_AKM_SUITE_8021X:\n\t\t\tif (params->crypto.wpa_versions &\n\t\t\t    NL80211_WPA_VERSION_1) {\n\t\t\t\tbss_config->protocol = PROTOCOL_WPA;\n\t\t\t\tbss_config->key_mgmt = KEY_MGMT_EAP;\n\t\t\t}\n\t\t\tif (params->crypto.wpa_versions &\n\t\t\t    NL80211_WPA_VERSION_2) {\n\t\t\t\tbss_config->protocol |= PROTOCOL_WPA2;\n\t\t\t\tbss_config->key_mgmt = KEY_MGMT_EAP;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_PSK:\n\t\t\tif (params->crypto.wpa_versions &\n\t\t\t    NL80211_WPA_VERSION_1) {\n\t\t\t\tbss_config->protocol = PROTOCOL_WPA;\n\t\t\t\tbss_config->key_mgmt = KEY_MGMT_PSK;\n\t\t\t}\n\t\t\tif (params->crypto.wpa_versions &\n\t\t\t    NL80211_WPA_VERSION_2) {\n\t\t\t\tbss_config->protocol |= PROTOCOL_WPA2;\n\t\t\t\tbss_config->key_mgmt = KEY_MGMT_PSK;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 0; i < params->crypto.n_ciphers_pairwise; i++) {\n\t\tswitch (params->crypto.ciphers_pairwise[i]) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tif (params->crypto.wpa_versions & NL80211_WPA_VERSION_1)\n\t\t\t\tbss_config->wpa_cfg.pairwise_cipher_wpa |=\n\t\t\t\t\t\t\t\tCIPHER_TKIP;\n\t\t\tif (params->crypto.wpa_versions & NL80211_WPA_VERSION_2)\n\t\t\t\tbss_config->wpa_cfg.pairwise_cipher_wpa2 |=\n\t\t\t\t\t\t\t\tCIPHER_TKIP;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tif (params->crypto.wpa_versions & NL80211_WPA_VERSION_1)\n\t\t\t\tbss_config->wpa_cfg.pairwise_cipher_wpa |=\n\t\t\t\t\t\t\t\tCIPHER_AES_CCMP;\n\t\t\tif (params->crypto.wpa_versions & NL80211_WPA_VERSION_2)\n\t\t\t\tbss_config->wpa_cfg.pairwise_cipher_wpa2 |=\n\t\t\t\t\t\t\t\tCIPHER_AES_CCMP;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (params->crypto.cipher_group) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tif (priv->sec_info.wep_enabled) {\n\t\t\tbss_config->protocol = PROTOCOL_STATIC_WEP;\n\t\t\tbss_config->key_mgmt = KEY_MGMT_NONE;\n\t\t\tbss_config->wpa_cfg.length = 0;\n\n\t\t\tfor (i = 0; i < NUM_WEP_KEYS; i++) {\n\t\t\t\twep_key = priv->wep_key[i];\n\t\t\t\tbss_config->wep_cfg[i].key_index = i;\n\n\t\t\t\tif (priv->wep_key_curr_index == i)\n\t\t\t\t\tbss_config->wep_cfg[i].is_default = 1;\n\t\t\t\telse\n\t\t\t\t\tbss_config->wep_cfg[i].is_default = 0;\n\n\t\t\t\tbss_config->wep_cfg[i].length =\n\t\t\t\t\t\t\t     wep_key.key_length;\n\t\t\t\tmemcpy(&bss_config->wep_cfg[i].key,\n\t\t\t\t       &wep_key.key_material,\n\t\t\t\t       wep_key.key_length);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tbss_config->wpa_cfg.group_cipher = CIPHER_TKIP;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tbss_config->wpa_cfg.group_cipher = CIPHER_AES_CCMP;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/* This function updates 11n related parameters from IE and sets them into\n * bss_config structure.\n */\nvoid\nmwifiex_set_ht_params(struct mwifiex_private *priv,\n\t\t      struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tconst u8 *ht_ie;\n\n\tif (!ISSUPP_11NENABLED(priv->adapter->fw_cap_info))\n\t\treturn;\n\n\tht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, params->beacon.tail,\n\t\t\t\t params->beacon.tail_len);\n\tif (ht_ie) {\n\t\tmemcpy(&bss_cfg->ht_cap, ht_ie + 2,\n\t\t       sizeof(struct ieee80211_ht_cap));\n\t\tpriv->ap_11n_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->ht_cap, 0, sizeof(struct ieee80211_ht_cap));\n\t\tbss_cfg->ht_cap.cap_info = cpu_to_le16(MWIFIEX_DEF_HT_CAP);\n\t\tbss_cfg->ht_cap.ampdu_params_info = MWIFIEX_DEF_AMPDU;\n\t}\n\n\treturn;\n}\n\n/* This function updates 11ac related parameters from IE\n * and sets them into bss_config structure.\n */\nvoid mwifiex_set_vht_params(struct mwifiex_private *priv,\n\t\t\t    struct mwifiex_uap_bss_param *bss_cfg,\n\t\t\t    struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vht_ie;\n\n\tvht_ie = cfg80211_find_ie(WLAN_EID_VHT_CAPABILITY, params->beacon.tail,\n\t\t\t\t  params->beacon.tail_len);\n\tif (vht_ie) {\n\t\tmemcpy(&bss_cfg->vht_cap, vht_ie + 2,\n\t\t       sizeof(struct ieee80211_vht_cap));\n\t\tpriv->ap_11ac_enabled = 1;\n\t} else {\n\t\tpriv->ap_11ac_enabled = 0;\n\t}\n\n\treturn;\n}\n\n/* This function updates 11ac related parameters from IE\n * and sets them into bss_config structure.\n */\nvoid mwifiex_set_tpc_params(struct mwifiex_private *priv,\n\t\t\t    struct mwifiex_uap_bss_param *bss_cfg,\n\t\t\t    struct cfg80211_ap_settings *params)\n{\n\tconst u8 *tpc_ie;\n\n\ttpc_ie = cfg80211_find_ie(WLAN_EID_TPC_REQUEST, params->beacon.tail,\n\t\t\t\t  params->beacon.tail_len);\n\tif (tpc_ie)\n\t\tbss_cfg->power_constraint = *(tpc_ie + 2);\n\telse\n\t\tbss_cfg->power_constraint = 0;\n}\n\n/* Enable VHT only when cfg80211_ap_settings has VHT IE.\n * Otherwise disable VHT.\n */\nvoid mwifiex_set_vht_width(struct mwifiex_private *priv,\n\t\t\t   enum nl80211_chan_width width,\n\t\t\t   bool ap_11ac_enable)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_11ac_vht_cfg vht_cfg;\n\n\tvht_cfg.band_config = VHT_CFG_5GHZ;\n\tvht_cfg.cap_info = adapter->hw_dot_11ac_dev_cap;\n\n\tif (!ap_11ac_enable) {\n\t\tvht_cfg.mcs_tx_set = DISABLE_VHT_MCS_SET;\n\t\tvht_cfg.mcs_rx_set = DISABLE_VHT_MCS_SET;\n\t} else {\n\t\tvht_cfg.mcs_tx_set = DEFAULT_VHT_MCS_SET;\n\t\tvht_cfg.mcs_rx_set = DEFAULT_VHT_MCS_SET;\n\t}\n\n\tvht_cfg.misc_config  = VHT_CAP_UAP_ONLY;\n\n\tif (ap_11ac_enable && width >= NL80211_CHAN_WIDTH_80)\n\t\tvht_cfg.misc_config |= VHT_BW_80_160_80P80;\n\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11AC_CFG,\n\t\t\t HostCmd_ACT_GEN_SET, 0, &vht_cfg, true);\n\n\treturn;\n}\n\n/* This function finds supported rates IE from beacon parameter and sets\n * these rates into bss_config structure.\n */\nvoid\nmwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES)\n\t\t\treturn;\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie) {\n\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES - rate_len)\n\t\t\treturn;\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\t}\n\n\treturn;\n}\n\n/* This function initializes some of mwifiex_uap_bss_param variables.\n * This helps FW in ignoring invalid values. These values may or may not\n * be get updated to valid ones at later stage.\n */\nvoid mwifiex_set_sys_config_invalid_data(struct mwifiex_uap_bss_param *config)\n{\n\tconfig->bcast_ssid_ctl = 0x7F;\n\tconfig->radio_ctl = 0x7F;\n\tconfig->dtim_period = 0x7F;\n\tconfig->beacon_period = 0x7FFF;\n\tconfig->auth_mode = 0x7F;\n\tconfig->rts_threshold = 0x7FFF;\n\tconfig->frag_threshold = 0x7FFF;\n\tconfig->retry_limit = 0x7F;\n\tconfig->qos_info = 0xFF;\n}\n\n/* This function parses BSS related parameters from structure\n * and prepares TLVs specific to WPA/WPA2 security.\n * These TLVs are appended to command buffer.\n */\nstatic void\nmwifiex_uap_bss_wpa(u8 **tlv_buf, void *cmd_buf, u16 *param_size)\n{\n\tstruct host_cmd_tlv_pwk_cipher *pwk_cipher;\n\tstruct host_cmd_tlv_gwk_cipher *gwk_cipher;\n\tstruct host_cmd_tlv_passphrase *passphrase;\n\tstruct host_cmd_tlv_akmp *tlv_akmp;\n\tstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\n\tu16 cmd_size = *param_size;\n\tu8 *tlv = *tlv_buf;\n\n\ttlv_akmp = (struct host_cmd_tlv_akmp *)tlv;\n\ttlv_akmp->header.type = cpu_to_le16(TLV_TYPE_UAP_AKMP);\n\ttlv_akmp->header.len = cpu_to_le16(sizeof(struct host_cmd_tlv_akmp) -\n\t\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\ttlv_akmp->key_mgmt_operation = cpu_to_le16(bss_cfg->key_mgmt_operation);\n\ttlv_akmp->key_mgmt = cpu_to_le16(bss_cfg->key_mgmt);\n\tcmd_size += sizeof(struct host_cmd_tlv_akmp);\n\ttlv += sizeof(struct host_cmd_tlv_akmp);\n\n\tif (bss_cfg->wpa_cfg.pairwise_cipher_wpa & VALID_CIPHER_BITMAP) {\n\t\tpwk_cipher = (struct host_cmd_tlv_pwk_cipher *)tlv;\n\t\tpwk_cipher->header.type = cpu_to_le16(TLV_TYPE_PWK_CIPHER);\n\t\tpwk_cipher->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_pwk_cipher) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tpwk_cipher->proto = cpu_to_le16(PROTOCOL_WPA);\n\t\tpwk_cipher->cipher = bss_cfg->wpa_cfg.pairwise_cipher_wpa;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t\ttlv += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t}\n\n\tif (bss_cfg->wpa_cfg.pairwise_cipher_wpa2 & VALID_CIPHER_BITMAP) {\n\t\tpwk_cipher = (struct host_cmd_tlv_pwk_cipher *)tlv;\n\t\tpwk_cipher->header.type = cpu_to_le16(TLV_TYPE_PWK_CIPHER);\n\t\tpwk_cipher->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_pwk_cipher) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tpwk_cipher->proto = cpu_to_le16(PROTOCOL_WPA2);\n\t\tpwk_cipher->cipher = bss_cfg->wpa_cfg.pairwise_cipher_wpa2;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t\ttlv += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t}\n\n\tif (bss_cfg->wpa_cfg.group_cipher & VALID_CIPHER_BITMAP) {\n\t\tgwk_cipher = (struct host_cmd_tlv_gwk_cipher *)tlv;\n\t\tgwk_cipher->header.type = cpu_to_le16(TLV_TYPE_GWK_CIPHER);\n\t\tgwk_cipher->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_gwk_cipher) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tgwk_cipher->cipher = bss_cfg->wpa_cfg.group_cipher;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_gwk_cipher);\n\t\ttlv += sizeof(struct host_cmd_tlv_gwk_cipher);\n\t}\n\n\tif (bss_cfg->wpa_cfg.length) {\n\t\tpassphrase = (struct host_cmd_tlv_passphrase *)tlv;\n\t\tpassphrase->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_WPA_PASSPHRASE);\n\t\tpassphrase->header.len = cpu_to_le16(bss_cfg->wpa_cfg.length);\n\t\tmemcpy(passphrase->passphrase, bss_cfg->wpa_cfg.passphrase,\n\t\t       bss_cfg->wpa_cfg.length);\n\t\tcmd_size += sizeof(struct mwifiex_ie_types_header) +\n\t\t\t    bss_cfg->wpa_cfg.length;\n\t\ttlv += sizeof(struct mwifiex_ie_types_header) +\n\t\t\t\tbss_cfg->wpa_cfg.length;\n\t}\n\n\t*param_size = cmd_size;\n\t*tlv_buf = tlv;\n\n\treturn;\n}\n\n/* This function parses WMM related parameters from cfg80211_ap_settings\n * structure and updates bss_config structure.\n */\nvoid\nmwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = vendor_ie;\n\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n\t\t\treturn;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n\t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}\n/* This function parses BSS related parameters from structure\n * and prepares TLVs specific to WEP encryption.\n * These TLVs are appended to command buffer.\n */\nstatic void\nmwifiex_uap_bss_wep(u8 **tlv_buf, void *cmd_buf, u16 *param_size)\n{\n\tstruct host_cmd_tlv_wep_key *wep_key;\n\tu16 cmd_size = *param_size;\n\tint i;\n\tu8 *tlv = *tlv_buf;\n\tstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\n\n\tfor (i = 0; i < NUM_WEP_KEYS; i++) {\n\t\tif (bss_cfg->wep_cfg[i].length &&\n\t\t    (bss_cfg->wep_cfg[i].length == WLAN_KEY_LEN_WEP40 ||\n\t\t     bss_cfg->wep_cfg[i].length == WLAN_KEY_LEN_WEP104)) {\n\t\t\twep_key = (struct host_cmd_tlv_wep_key *)tlv;\n\t\t\twep_key->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_WEP_KEY);\n\t\t\twep_key->header.len =\n\t\t\t\tcpu_to_le16(bss_cfg->wep_cfg[i].length + 2);\n\t\t\twep_key->key_index = bss_cfg->wep_cfg[i].key_index;\n\t\t\twep_key->is_default = bss_cfg->wep_cfg[i].is_default;\n\t\t\tmemcpy(wep_key->key, bss_cfg->wep_cfg[i].key,\n\t\t\t       bss_cfg->wep_cfg[i].length);\n\t\t\tcmd_size += sizeof(struct mwifiex_ie_types_header) + 2 +\n\t\t\t\t    bss_cfg->wep_cfg[i].length;\n\t\t\ttlv += sizeof(struct mwifiex_ie_types_header) + 2 +\n\t\t\t\t    bss_cfg->wep_cfg[i].length;\n\t\t}\n\t}\n\n\t*param_size = cmd_size;\n\t*tlv_buf = tlv;\n\n\treturn;\n}\n\n/* This function enable 11D if userspace set the country IE.\n */\nvoid mwifiex_config_uap_11d(struct mwifiex_private *priv,\n\t\t\t    struct cfg80211_beacon_data *beacon_data)\n{\n\tenum state_11d_t state_11d;\n\tconst u8 *country_ie;\n\n\tcountry_ie = cfg80211_find_ie(WLAN_EID_COUNTRY, beacon_data->tail,\n\t\t\t\t      beacon_data->tail_len);\n\tif (country_ie) {\n\t\t/* Send cmd to FW to enable 11D function */\n\t\tstate_11d = ENABLE_11D;\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\t     HostCmd_ACT_GEN_SET, DOT11D_I,\n\t\t\t\t     &state_11d, true)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"11D: failed to enable 11D\\n\");\n\t\t}\n\t}\n}\n\n/* This function parses BSS related parameters from structure\n * and prepares TLVs. These TLVs are appended to command buffer.\n*/\nstatic int\nmwifiex_uap_bss_param_prepare(u8 *tlv, void *cmd_buf, u16 *param_size)\n{\n\tstruct host_cmd_tlv_dtim_period *dtim_period;\n\tstruct host_cmd_tlv_beacon_period *beacon_period;\n\tstruct host_cmd_tlv_ssid *ssid;\n\tstruct host_cmd_tlv_bcast_ssid *bcast_ssid;\n\tstruct host_cmd_tlv_channel_band *chan_band;\n\tstruct host_cmd_tlv_frag_threshold *frag_threshold;\n\tstruct host_cmd_tlv_rts_threshold *rts_threshold;\n\tstruct host_cmd_tlv_retry_limit *retry_limit;\n\tstruct host_cmd_tlv_encrypt_protocol *encrypt_protocol;\n\tstruct host_cmd_tlv_auth_type *auth_type;\n\tstruct host_cmd_tlv_rates *tlv_rates;\n\tstruct host_cmd_tlv_ageout_timer *ao_timer, *ps_ao_timer;\n\tstruct host_cmd_tlv_power_constraint *pwr_ct;\n\tstruct mwifiex_ie_types_htcap *htcap;\n\tstruct mwifiex_ie_types_wmmcap *wmm_cap;\n\tstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\n\tint i;\n\tu16 cmd_size = *param_size;\n\n\tif (bss_cfg->ssid.ssid_len) {\n\t\tssid = (struct host_cmd_tlv_ssid *)tlv;\n\t\tssid->header.type = cpu_to_le16(TLV_TYPE_UAP_SSID);\n\t\tssid->header.len = cpu_to_le16((u16)bss_cfg->ssid.ssid_len);\n\t\tmemcpy(ssid->ssid, bss_cfg->ssid.ssid, bss_cfg->ssid.ssid_len);\n\t\tcmd_size += sizeof(struct mwifiex_ie_types_header) +\n\t\t\t    bss_cfg->ssid.ssid_len;\n\t\ttlv += sizeof(struct mwifiex_ie_types_header) +\n\t\t\t\tbss_cfg->ssid.ssid_len;\n\n\t\tbcast_ssid = (struct host_cmd_tlv_bcast_ssid *)tlv;\n\t\tbcast_ssid->header.type = cpu_to_le16(TLV_TYPE_UAP_BCAST_SSID);\n\t\tbcast_ssid->header.len =\n\t\t\t\tcpu_to_le16(sizeof(bcast_ssid->bcast_ctl));\n\t\tbcast_ssid->bcast_ctl = bss_cfg->bcast_ssid_ctl;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_bcast_ssid);\n\t\ttlv += sizeof(struct host_cmd_tlv_bcast_ssid);\n\t}\n\tif (bss_cfg->rates[0]) {\n\t\ttlv_rates = (struct host_cmd_tlv_rates *)tlv;\n\t\ttlv_rates->header.type = cpu_to_le16(TLV_TYPE_UAP_RATES);\n\n\t\tfor (i = 0; i < MWIFIEX_SUPPORTED_RATES && bss_cfg->rates[i];\n\t\t     i++)\n\t\t\ttlv_rates->rates[i] = bss_cfg->rates[i];\n\n\t\ttlv_rates->header.len = cpu_to_le16(i);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_rates) + i;\n\t\ttlv += sizeof(struct host_cmd_tlv_rates) + i;\n\t}\n\tif (bss_cfg->channel &&\n\t    (((bss_cfg->band_cfg & BIT(0)) == BAND_CONFIG_BG &&\n\t      bss_cfg->channel <= MAX_CHANNEL_BAND_BG) ||\n\t    ((bss_cfg->band_cfg & BIT(0)) == BAND_CONFIG_A &&\n\t     bss_cfg->channel <= MAX_CHANNEL_BAND_A))) {\n\t\tchan_band = (struct host_cmd_tlv_channel_band *)tlv;\n\t\tchan_band->header.type = cpu_to_le16(TLV_TYPE_CHANNELBANDLIST);\n\t\tchan_band->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_channel_band) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tchan_band->band_config = bss_cfg->band_cfg;\n\t\tchan_band->channel = bss_cfg->channel;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_channel_band);\n\t\ttlv += sizeof(struct host_cmd_tlv_channel_band);\n\t}\n\tif (bss_cfg->beacon_period >= MIN_BEACON_PERIOD &&\n\t    bss_cfg->beacon_period <= MAX_BEACON_PERIOD) {\n\t\tbeacon_period = (struct host_cmd_tlv_beacon_period *)tlv;\n\t\tbeacon_period->header.type =\n\t\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_BEACON_PERIOD);\n\t\tbeacon_period->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_beacon_period) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tbeacon_period->period = cpu_to_le16(bss_cfg->beacon_period);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_beacon_period);\n\t\ttlv += sizeof(struct host_cmd_tlv_beacon_period);\n\t}\n\tif (bss_cfg->dtim_period >= MIN_DTIM_PERIOD &&\n\t    bss_cfg->dtim_period <= MAX_DTIM_PERIOD) {\n\t\tdtim_period = (struct host_cmd_tlv_dtim_period *)tlv;\n\t\tdtim_period->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_UAP_DTIM_PERIOD);\n\t\tdtim_period->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_dtim_period) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tdtim_period->period = bss_cfg->dtim_period;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_dtim_period);\n\t\ttlv += sizeof(struct host_cmd_tlv_dtim_period);\n\t}\n\tif (bss_cfg->rts_threshold <= MWIFIEX_RTS_MAX_VALUE) {\n\t\trts_threshold = (struct host_cmd_tlv_rts_threshold *)tlv;\n\t\trts_threshold->header.type =\n\t\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_RTS_THRESHOLD);\n\t\trts_threshold->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_rts_threshold) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\trts_threshold->rts_thr = cpu_to_le16(bss_cfg->rts_threshold);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_frag_threshold);\n\t\ttlv += sizeof(struct host_cmd_tlv_frag_threshold);\n\t}\n\tif ((bss_cfg->frag_threshold >= MWIFIEX_FRAG_MIN_VALUE) &&\n\t    (bss_cfg->frag_threshold <= MWIFIEX_FRAG_MAX_VALUE)) {\n\t\tfrag_threshold = (struct host_cmd_tlv_frag_threshold *)tlv;\n\t\tfrag_threshold->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_FRAG_THRESHOLD);\n\t\tfrag_threshold->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_frag_threshold) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tfrag_threshold->frag_thr = cpu_to_le16(bss_cfg->frag_threshold);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_frag_threshold);\n\t\ttlv += sizeof(struct host_cmd_tlv_frag_threshold);\n\t}\n\tif (bss_cfg->retry_limit <= MWIFIEX_RETRY_LIMIT) {\n\t\tretry_limit = (struct host_cmd_tlv_retry_limit *)tlv;\n\t\tretry_limit->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_UAP_RETRY_LIMIT);\n\t\tretry_limit->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_retry_limit) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tretry_limit->limit = (u8)bss_cfg->retry_limit;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_retry_limit);\n\t\ttlv += sizeof(struct host_cmd_tlv_retry_limit);\n\t}\n\tif ((bss_cfg->protocol & PROTOCOL_WPA) ||\n\t    (bss_cfg->protocol & PROTOCOL_WPA2) ||\n\t    (bss_cfg->protocol & PROTOCOL_EAP))\n\t\tmwifiex_uap_bss_wpa(&tlv, cmd_buf, &cmd_size);\n\telse\n\t\tmwifiex_uap_bss_wep(&tlv, cmd_buf, &cmd_size);\n\n\tif ((bss_cfg->auth_mode <= WLAN_AUTH_SHARED_KEY) ||\n\t    (bss_cfg->auth_mode == MWIFIEX_AUTH_MODE_AUTO)) {\n\t\tauth_type = (struct host_cmd_tlv_auth_type *)tlv;\n\t\tauth_type->header.type = cpu_to_le16(TLV_TYPE_AUTH_TYPE);\n\t\tauth_type->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_auth_type) -\n\t\t\tsizeof(struct mwifiex_ie_types_header));\n\t\tauth_type->auth_type = (u8)bss_cfg->auth_mode;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_auth_type);\n\t\ttlv += sizeof(struct host_cmd_tlv_auth_type);\n\t}\n\tif (bss_cfg->protocol) {\n\t\tencrypt_protocol = (struct host_cmd_tlv_encrypt_protocol *)tlv;\n\t\tencrypt_protocol->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_UAP_ENCRY_PROTOCOL);\n\t\tencrypt_protocol->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_encrypt_protocol)\n\t\t\t- sizeof(struct mwifiex_ie_types_header));\n\t\tencrypt_protocol->proto = cpu_to_le16(bss_cfg->protocol);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_encrypt_protocol);\n\t\ttlv += sizeof(struct host_cmd_tlv_encrypt_protocol);\n\t}\n\n\tif (bss_cfg->ht_cap.cap_info) {\n\t\thtcap = (struct mwifiex_ie_types_htcap *)tlv;\n\t\thtcap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\thtcap->header.len =\n\t\t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\thtcap->ht_cap.cap_info = bss_cfg->ht_cap.cap_info;\n\t\thtcap->ht_cap.ampdu_params_info =\n\t\t\t\t\t     bss_cfg->ht_cap.ampdu_params_info;\n\t\tmemcpy(&htcap->ht_cap.mcs, &bss_cfg->ht_cap.mcs,\n\t\t       sizeof(struct ieee80211_mcs_info));\n\t\thtcap->ht_cap.extended_ht_cap_info =\n\t\t\t\t\tbss_cfg->ht_cap.extended_ht_cap_info;\n\t\thtcap->ht_cap.tx_BF_cap_info = bss_cfg->ht_cap.tx_BF_cap_info;\n\t\thtcap->ht_cap.antenna_selection_info =\n\t\t\t\t\tbss_cfg->ht_cap.antenna_selection_info;\n\t\tcmd_size += sizeof(struct mwifiex_ie_types_htcap);\n\t\ttlv += sizeof(struct mwifiex_ie_types_htcap);\n\t}\n\n\tif (bss_cfg->wmm_info.qos_info != 0xFF) {\n\t\twmm_cap = (struct mwifiex_ie_types_wmmcap *)tlv;\n\t\twmm_cap->header.type = cpu_to_le16(WLAN_EID_VENDOR_SPECIFIC);\n\t\twmm_cap->header.len = cpu_to_le16(sizeof(wmm_cap->wmm_info));\n\t\tmemcpy(&wmm_cap->wmm_info, &bss_cfg->wmm_info,\n\t\t       sizeof(wmm_cap->wmm_info));\n\t\tcmd_size += sizeof(struct mwifiex_ie_types_wmmcap);\n\t\ttlv += sizeof(struct mwifiex_ie_types_wmmcap);\n\t}\n\n\tif (bss_cfg->sta_ao_timer) {\n\t\tao_timer = (struct host_cmd_tlv_ageout_timer *)tlv;\n\t\tao_timer->header.type = cpu_to_le16(TLV_TYPE_UAP_AO_TIMER);\n\t\tao_timer->header.len = cpu_to_le16(sizeof(*ao_timer) -\n\t\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\t\tao_timer->sta_ao_timer = cpu_to_le32(bss_cfg->sta_ao_timer);\n\t\tcmd_size += sizeof(*ao_timer);\n\t\ttlv += sizeof(*ao_timer);\n\t}\n\n\tif (bss_cfg->power_constraint) {\n\t\tpwr_ct = (void *)tlv;\n\t\tpwr_ct->header.type = cpu_to_le16(TLV_TYPE_PWR_CONSTRAINT);\n\t\tpwr_ct->header.len = cpu_to_le16(sizeof(u8));\n\t\tpwr_ct->constraint = bss_cfg->power_constraint;\n\t\tcmd_size += sizeof(*pwr_ct);\n\t\ttlv += sizeof(*pwr_ct);\n\t}\n\n\tif (bss_cfg->ps_sta_ao_timer) {\n\t\tps_ao_timer = (struct host_cmd_tlv_ageout_timer *)tlv;\n\t\tps_ao_timer->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_PS_AO_TIMER);\n\t\tps_ao_timer->header.len = cpu_to_le16(sizeof(*ps_ao_timer) -\n\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\t\tps_ao_timer->sta_ao_timer =\n\t\t\t\t\tcpu_to_le32(bss_cfg->ps_sta_ao_timer);\n\t\tcmd_size += sizeof(*ps_ao_timer);\n\t\ttlv += sizeof(*ps_ao_timer);\n\t}\n\n\t*param_size = cmd_size;\n\n\treturn 0;\n}\n\n/* This function parses custom IEs from IE list and prepares command buffer */\nstatic int mwifiex_uap_custom_ie_prepare(u8 *tlv, void *cmd_buf, u16 *ie_size)\n{\n\tstruct mwifiex_ie_list *ap_ie = cmd_buf;\n\tstruct mwifiex_ie_types_header *tlv_ie = (void *)tlv;\n\n\tif (!ap_ie || !ap_ie->len)\n\t\treturn -1;\n\n\t*ie_size += le16_to_cpu(ap_ie->len) +\n\t\t\tsizeof(struct mwifiex_ie_types_header);\n\n\ttlv_ie->type = cpu_to_le16(TLV_TYPE_MGMT_IE);\n\ttlv_ie->len = ap_ie->len;\n\ttlv += sizeof(struct mwifiex_ie_types_header);\n\n\tmemcpy(tlv, ap_ie->ie_list, le16_to_cpu(ap_ie->len));\n\n\treturn 0;\n}\n\n/* Parse AP config structure and prepare TLV based command structure\n * to be sent to FW for uAP configuration\n */\nstatic int\nmwifiex_cmd_uap_sys_config(struct host_cmd_ds_command *cmd, u16 cmd_action,\n\t\t\t   u32 type, void *cmd_buf)\n{\n\tu8 *tlv;\n\tu16 cmd_size, param_size, ie_size;\n\tstruct host_cmd_ds_sys_config *sys_cfg;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_UAP_SYS_CONFIG);\n\tcmd_size = (u16)(sizeof(struct host_cmd_ds_sys_config) + S_DS_GEN);\n\tsys_cfg = (struct host_cmd_ds_sys_config *)&cmd->params.uap_sys_config;\n\tsys_cfg->action = cpu_to_le16(cmd_action);\n\ttlv = sys_cfg->tlv;\n\n\tswitch (type) {\n\tcase UAP_BSS_PARAMS_I:\n\t\tparam_size = cmd_size;\n\t\tif (mwifiex_uap_bss_param_prepare(tlv, cmd_buf, &param_size))\n\t\t\treturn -1;\n\t\tcmd->size = cpu_to_le16(param_size);\n\t\tbreak;\n\tcase UAP_CUSTOM_IE_I:\n\t\tie_size = cmd_size;\n\t\tif (mwifiex_uap_custom_ie_prepare(tlv, cmd_buf, &ie_size))\n\t\t\treturn -1;\n\t\tcmd->size = cpu_to_le16(ie_size);\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* This function prepares AP specific deauth command with mac supplied in\n * function parameter.\n */\nstatic int mwifiex_cmd_uap_sta_deauth(struct mwifiex_private *priv,\n\t\t\t\t      struct host_cmd_ds_command *cmd, u8 *mac)\n{\n\tstruct host_cmd_ds_sta_deauth *sta_deauth = &cmd->params.sta_deauth;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_UAP_STA_DEAUTH);\n\tmemcpy(sta_deauth->mac, mac, ETH_ALEN);\n\tsta_deauth->reason = cpu_to_le16(WLAN_REASON_DEAUTH_LEAVING);\n\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_sta_deauth) +\n\t\t\t\tS_DS_GEN);\n\treturn 0;\n}\n\n/* This function prepares the AP specific commands before sending them\n * to the firmware.\n * This is a generic function which calls specific command preparation\n * routines based upon the command number.\n */\nint mwifiex_uap_prepare_cmd(struct mwifiex_private *priv, u16 cmd_no,\n\t\t\t    u16 cmd_action, u32 type,\n\t\t\t    void *data_buf, void *cmd_buf)\n{\n\tstruct host_cmd_ds_command *cmd = cmd_buf;\n\n\tswitch (cmd_no) {\n\tcase HostCmd_CMD_UAP_SYS_CONFIG:\n\t\tif (mwifiex_cmd_uap_sys_config(cmd, cmd_action, type, data_buf))\n\t\t\treturn -1;\n\t\tbreak;\n\tcase HostCmd_CMD_UAP_BSS_START:\n\tcase HostCmd_CMD_UAP_BSS_STOP:\n\tcase HOST_CMD_APCMD_SYS_RESET:\n\tcase HOST_CMD_APCMD_STA_LIST:\n\t\tcmd->command = cpu_to_le16(cmd_no);\n\t\tcmd->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_UAP_STA_DEAUTH:\n\t\tif (mwifiex_cmd_uap_sta_deauth(priv, cmd, data_buf))\n\t\t\treturn -1;\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\n\t\tif (mwifiex_cmd_issue_chan_report_request(priv, cmd_buf,\n\t\t\t\t\t\t\t  data_buf))\n\t\t\treturn -1;\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"PREP_CMD: unknown cmd %#x\\n\", cmd_no);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid mwifiex_uap_set_channel(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_uap_bss_param *bss_cfg,\n\t\t\t     struct cfg80211_chan_def chandef)\n{\n\tu8 config_bands = 0, old_bands = priv->adapter->config_bands;\n\n\tpriv->bss_chandef = chandef;\n\n\tbss_cfg->channel = ieee80211_frequency_to_channel(\n\t\t\t\t\t\t     chandef.chan->center_freq);\n\n\t/* Set appropriate bands */\n\tif (chandef.chan->band == NL80211_BAND_2GHZ) {\n\t\tbss_cfg->band_cfg = BAND_CONFIG_BG;\n\t\tconfig_bands = BAND_B | BAND_G;\n\n\t\tif (chandef.width > NL80211_CHAN_WIDTH_20_NOHT)\n\t\t\tconfig_bands |= BAND_GN;\n\t} else {\n\t\tbss_cfg->band_cfg = BAND_CONFIG_A;\n\t\tconfig_bands = BAND_A;\n\n\t\tif (chandef.width > NL80211_CHAN_WIDTH_20_NOHT)\n\t\t\tconfig_bands |= BAND_AN;\n\n\t\tif (chandef.width > NL80211_CHAN_WIDTH_40)\n\t\t\tconfig_bands |= BAND_AAC;\n\t}\n\n\tswitch (chandef.width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (chandef.center_freq1 < chandef.chan->center_freq)\n\t\t\tbss_cfg->band_cfg |= MWIFIEX_SEC_CHAN_BELOW;\n\t\telse\n\t\t\tbss_cfg->band_cfg |= MWIFIEX_SEC_CHAN_ABOVE;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tbss_cfg->band_cfg |=\n\t\t    mwifiex_get_sec_chan_offset(bss_cfg->channel) << 4;\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter,\n\t\t\t    WARN, \"Unknown channel width: %d\\n\",\n\t\t\t    chandef.width);\n\t\tbreak;\n\t}\n\n\tpriv->adapter->config_bands = config_bands;\n\n\tif (old_bands != config_bands) {\n\t\tmwifiex_send_domain_info_cmd_fw(priv->adapter->wiphy);\n\t\tmwifiex_dnld_txpwr_table(priv);\n\t}\n}\n\nint mwifiex_config_start_uap(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_uap_bss_param *bss_cfg)\n{\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_SYS_CONFIG,\n\t\t\t     HostCmd_ACT_GEN_SET,\n\t\t\t     UAP_BSS_PARAMS_I, bss_cfg, true)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to set AP configuration\\n\");\n\t\treturn -1;\n\t}\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_START,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, NULL, true)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to start the BSS\\n\");\n\t\treturn -1;\n\t}\n\n\tif (priv->sec_info.wep_enabled)\n\t\tpriv->curr_pkt_filter |= HostCmd_ACT_MAC_WEP_ENABLE;\n\telse\n\t\tpriv->curr_pkt_filter &= ~HostCmd_ACT_MAC_WEP_ENABLE;\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t     &priv->curr_pkt_filter, true))\n\t\treturn -1;\n\n\treturn 0;\n}\n"], "filenames": ["drivers/net/wireless/marvell/mwifiex/ie.c", "drivers/net/wireless/marvell/mwifiex/uap_cmd.c"], "buggy_code_start_loc": [243, 267], "buggy_code_end_loc": [243, 393], "fixing_code_start_loc": [244, 268], "fixing_code_end_loc": [247, 401], "type": "CWE-122", "message": "There is heap-based buffer overflow in Linux kernel, all versions up to, excluding 5.3, in the marvell wifi chip driver in Linux kernel, that allows local users to cause a denial of service(system crash) or possibly execute arbitrary code.", "other": {"cve": {"id": "CVE-2019-14814", "sourceIdentifier": "secalert@redhat.com", "published": "2019-09-20T19:15:11.690", "lastModified": "2023-02-12T23:34:00.817", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "There is heap-based buffer overflow in Linux kernel, all versions up to, excluding 5.3, in the marvell wifi chip driver in Linux kernel, that allows local users to cause a denial of service(system crash) or possibly execute arbitrary code."}, {"lang": "es", "value": "Se presenta un desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria en el kernel de Linux, todas las versiones hasta 5.3 (excluy\u00e9ndola), en el controlador de chip wifi marvell en el kernel de Linux, que permite a usuarios locales causar una denegaci\u00f3n de servicio (bloqueo del sistema) o posiblemente ejecutar c\u00f3digo arbitrario."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.3", "matchCriteriaId": "4F1C9EF6-9355-4C88-8F20-5098E3416EBE"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "1D8B549B-E57B-4DFE-8A13-CAB06B5356B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.1:*:*:*:*:*:*:*", "matchCriteriaId": "92BC9265-6959-4D37-BE5E-8C45E98992F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "831F0F47-3565-4763-B16F-C87B1FF2035E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "0E3F09B5-569F-4C58-9FCA-3C0953D107B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_real_time:8:*:*:*:*:*:*:*", "matchCriteriaId": "CBF9BCF3-187F-410A-96CA-9C47D3ED6924"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_real_time_for_nfv:8:*:*:*:*:*:*:*", "matchCriteriaId": "E5CB3640-F55B-4127-875A-2F52D873D179"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_real_time_for_nfv_tus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "77C61DDC-81F3-4E2D-9CAA-17A256C85443"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_real_time_for_nfv_tus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "B6B0DA79-DF12-4418-B075-F048C9E2979A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_real_time_tus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "B92409A9-0D6B-4B7E-8847-1B63837D201F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_real_time_tus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "C5C5860E-9FEB-4259-92FD-A85911E2F99E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "6897676D-53F9-45B3-B27F-7FF9A4C58D33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "E28F226A-CBC7-4A32-BE58-398FA5B42481"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "B09ACF2D-D83F-4A86-8185-9569605D8EE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "AC10D919-57FD-4725-B8D2-39ECB476902F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:messaging_realtime_grid:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F0ED77E-6D8E-48DF-9D2E-4E821399F893"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:data_availability_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "0EF46487-B64A-454E-AECC-D74B83170ACD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:service_processor:-:*:*:*:*:*:*:*", "matchCriteriaId": "146A767F-DC04-454B-9913-17D3A2B5AAA4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:steelstore_cloud_integrated_storage:-:*:*:*:*:*:*:*", "matchCriteriaId": "E94F7F59-1785-493F-91A7-5F5EA5E87E4D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:a700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FDD92BFA-9117-4E6E-A13F-ED064B4B7284"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:a700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "4B7DA42F-5D64-4967-A2D4-6210FE507841"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:a320_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6ADE5E80-06D3-4A1B-A655-FBB6CCA03939"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:a320:-:*:*:*:*:*:*:*", "matchCriteriaId": "E8FD5E05-3C58-465F-9D4F-ECC2CD78DCFF"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:c190_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "75A43965-CB2E-4C28-AFC3-1ADE7A6B845C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:c190:-:*:*:*:*:*:*:*", "matchCriteriaId": "0D421A96-E6E9-4B27-ADE0-D8E87A82EEDE"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:a220_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "4F2D2745-242C-4603-899E-70C9025BDDD2"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:a220:-:*:*:*:*:*:*:*", "matchCriteriaId": "EFB4541D-5EF7-4266-BFF3-2DDEC95E8012"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:fas2720_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "B7FD1DA9-7980-4643-B378-7095892DA176"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:fas2720:-:*:*:*:*:*:*:*", "matchCriteriaId": "347E9E3E-941C-4109-B59F-B9BB05486B34"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:fas2750_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD661062-0D5B-4671-9D92-FEF8D7395C1E"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:fas2750:-:*:*:*:*:*:*:*", "matchCriteriaId": "8155BF5F-DD1B-4AB4-81F8-9BCE6A8821AE"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:a800_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "B36CECA5-4545-49C2-92EB-B739407B207F"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:a800:-:*:*:*:*:*:*:*", "matchCriteriaId": "D8E7549A-DE35-4274-B3F6-22D51C7A6613"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h610s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FD7CFE0E-9D1E-4495-B302-89C3096FC0DF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h610s:-:*:*:*:*:*:*:*", "matchCriteriaId": "F63A3FA7-AAED-4A9D-9FDE-6195302DA0F6"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00064.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00066.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/154951/Kernel-Live-Patch-Security-Notice-LSN-0058-1.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://packetstormsecurity.com/files/155212/Slackware-Security-Advisory-Slackware-14.2-kernel-Updates.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.openwall.com/lists/oss-security/2019/08/28/1", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2020:0174", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2020:0328", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2020:0339", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/security/cve/cve-2019-14814", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2019-14814", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/09/msg00025.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00001.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/O3RUDQJXRJQVGHCGR4YZWTQ3ECBI7TXH/", "source": "secalert@redhat.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/T4JZ6AEUKFWBHQAROGMQARJ274PQP2QP/", "source": "secalert@redhat.com"}, {"url": "https://seclists.org/bugtraq/2019/Nov/11", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191031-0005/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4157-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4157-2/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4162-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4162-2/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4163-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4163-2/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2019/08/28/1", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a"}}