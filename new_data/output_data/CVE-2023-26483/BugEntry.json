{"buggy_code": ["// Copyright 2016 Russell Haering et al.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage saml2\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\n\tdsig \"github.com/russellhaering/goxmldsig\"\n)\n\nfunc (sp *SAMLServiceProvider) validateLogoutRequestAttributes(request *LogoutRequest) error {\n\tif request.Destination != \"\" && request.Destination != sp.ServiceProviderSLOURL {\n\t\treturn ErrInvalidValue{\n\t\t\tKey:      DestinationAttr,\n\t\t\tExpected: sp.ServiceProviderSLOURL,\n\t\t\tActual:   request.Destination,\n\t\t}\n\t}\n\n\tif request.Version != \"2.0\" {\n\t\treturn ErrInvalidValue{\n\t\t\tReason:   ReasonUnsupported,\n\t\t\tKey:      \"SAML version\",\n\t\t\tExpected: \"2.0\",\n\t\t\tActual:   request.Version,\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (sp *SAMLServiceProvider) ValidateEncodedLogoutRequestPOST(encodedRequest string) (*LogoutRequest, error) {\n\traw, err := base64.StdEncoding.DecodeString(encodedRequest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Parse the raw request - parseResponse is generic\n\tdoc, el, err := parseResponse(raw)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar requestSignatureValidated bool\n\tif !sp.SkipSignatureValidation {\n\t\tel, err = sp.validateElementSignature(el)\n\t\tif err == dsig.ErrMissingSignature {\n\t\t\t// Unfortunately we just blew away our Response\n\t\t\tel = doc.Root()\n\t\t} else if err != nil {\n\t\t\treturn nil, err\n\t\t} else if el == nil {\n\t\t\treturn nil, fmt.Errorf(\"missing transformed logout request\")\n\t\t} else {\n\t\t\trequestSignatureValidated = true\n\t\t}\n\t}\n\n\tdecodedRequest := &LogoutRequest{}\n\terr = xmlUnmarshalElement(el, decodedRequest)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to unmarshal logout request: %v\", err)\n\t}\n\tdecodedRequest.SignatureValidated = requestSignatureValidated\n\n\terr = sp.ValidateDecodedLogoutRequest(decodedRequest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn decodedRequest, nil\n}\n", "// Copyright 2016 Russell Haering et al.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage saml2\n\nimport (\n\t\"bytes\"\n\t\"compress/flate\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"encoding/xml\"\n\n\t\"github.com/beevik/etree\"\n\t\"github.com/russellhaering/gosaml2/types\"\n\tdsig \"github.com/russellhaering/goxmldsig\"\n\t\"github.com/russellhaering/goxmldsig/etreeutils\"\n\trtvalidator \"github.com/mattermost/xml-roundtrip-validator\"\n)\n\nfunc (sp *SAMLServiceProvider) validationContext() *dsig.ValidationContext {\n\tctx := dsig.NewDefaultValidationContext(sp.IDPCertificateStore)\n\tctx.Clock = sp.Clock\n\treturn ctx\n}\n\n// validateResponseAttributes validates a SAML Response's tag and attributes. It does\n// not inspect child elements of the Response at all.\nfunc (sp *SAMLServiceProvider) validateResponseAttributes(response *types.Response) error {\n\tif response.Destination != \"\" && response.Destination != sp.AssertionConsumerServiceURL {\n\t\treturn ErrInvalidValue{\n\t\t\tKey:      DestinationAttr,\n\t\t\tExpected: sp.AssertionConsumerServiceURL,\n\t\t\tActual:   response.Destination,\n\t\t}\n\t}\n\n\tif response.Version != \"2.0\" {\n\t\treturn ErrInvalidValue{\n\t\t\tReason:   ReasonUnsupported,\n\t\t\tKey:      \"SAML version\",\n\t\t\tExpected: \"2.0\",\n\t\t\tActual:   response.Version,\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// validateLogoutResponseAttributes validates a SAML Response's tag and attributes. It does\n// not inspect child elements of the Response at all.\nfunc (sp *SAMLServiceProvider) validateLogoutResponseAttributes(response *types.LogoutResponse) error {\n\tif response.Destination != \"\" && response.Destination != sp.ServiceProviderSLOURL {\n\t\treturn ErrInvalidValue{\n\t\t\tKey:      DestinationAttr,\n\t\t\tExpected: sp.ServiceProviderSLOURL,\n\t\t\tActual:   response.Destination,\n\t\t}\n\t}\n\n\tif response.Version != \"2.0\" {\n\t\treturn ErrInvalidValue{\n\t\t\tReason:   ReasonUnsupported,\n\t\t\tKey:      \"SAML version\",\n\t\t\tExpected: \"2.0\",\n\t\t\tActual:   response.Version,\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc xmlUnmarshalElement(el *etree.Element, obj interface{}) error {\n\tdoc := etree.NewDocument()\n\tdoc.SetRoot(el)\n\tdata, err := doc.WriteToBytes()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = xml.Unmarshal(data, obj)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (sp *SAMLServiceProvider) getDecryptCert() (*tls.Certificate, error) {\n\tif sp.SPKeyStore == nil {\n\t\treturn nil, fmt.Errorf(\"no decryption certs available\")\n\t}\n\n\t//This is the tls.Certificate we'll use to decrypt any encrypted assertions\n\tvar decryptCert tls.Certificate\n\n\tswitch crt := sp.SPKeyStore.(type) {\n\tcase dsig.TLSCertKeyStore:\n\t\t// Get the tls.Certificate directly if possible\n\t\tdecryptCert = tls.Certificate(crt)\n\n\tdefault:\n\n\t\t//Otherwise, construct one from the results of GetKeyPair\n\t\tpk, cert, err := sp.SPKeyStore.GetKeyPair()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error getting keypair: %v\", err)\n\t\t}\n\n\t\tdecryptCert = tls.Certificate{\n\t\t\tCertificate: [][]byte{cert},\n\t\t\tPrivateKey:  pk,\n\t\t}\n\t}\n\n\tif sp.ValidateEncryptionCert {\n\t\t// Check Validity period of certificate\n\t\tif len(decryptCert.Certificate) < 1 || len(decryptCert.Certificate[0]) < 1 {\n\t\t\treturn nil, fmt.Errorf(\"empty decryption cert\")\n\t\t} else if cert, err := x509.ParseCertificate(decryptCert.Certificate[0]); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid x509 decryption cert: %v\", err)\n\t\t} else {\n\t\t\tnow := sp.Clock.Now()\n\t\t\tif now.Before(cert.NotBefore) || now.After(cert.NotAfter) {\n\t\t\t\treturn nil, fmt.Errorf(\"decryption cert is not valid at this time\")\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &decryptCert, nil\n}\n\nfunc (sp *SAMLServiceProvider) decryptAssertions(el *etree.Element) error {\n\tvar decryptCert *tls.Certificate\n\n\tdecryptAssertion := func(ctx etreeutils.NSContext, encryptedElement *etree.Element) error {\n\t\tif encryptedElement.Parent() != el {\n\t\t\treturn fmt.Errorf(\"found encrypted assertion with unexpected parent element: %s\", encryptedElement.Parent().Tag)\n\t\t}\n\n\t\tdetached, err := etreeutils.NSDetatch(ctx, encryptedElement) // make a detached copy\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to detach encrypted assertion: %v\", err)\n\t\t}\n\n\t\tencryptedAssertion := &types.EncryptedAssertion{}\n\t\terr = xmlUnmarshalElement(detached, encryptedAssertion)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to unmarshal encrypted assertion: %v\", err)\n\t\t}\n\n\t\tif decryptCert == nil {\n\t\t\tdecryptCert, err = sp.getDecryptCert()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to get decryption certificate: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\traw, derr := encryptedAssertion.DecryptBytes(decryptCert)\n\t\tif derr != nil {\n\t\t\treturn fmt.Errorf(\"unable to decrypt encrypted assertion: %v\", derr)\n\t\t}\n\n\t\tdoc, _, err := parseResponse(raw)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to create element from decrypted assertion bytes: %v\", err)\n\t\t}\n\n\t\t// Replace the original encrypted assertion with the decrypted one.\n\t\tif el.RemoveChild(encryptedElement) == nil {\n\t\t\t// Out of an abundance of caution, make sure removed worked\n\t\t\tpanic(\"unable to remove encrypted assertion\")\n\t\t}\n\n\t\tel.AddChild(doc.Root())\n\t\treturn nil\n\t}\n\n\tif err := etreeutils.NSFindIterate(el, SAMLAssertionNamespace, EncryptedAssertionTag, decryptAssertion); err != nil {\n\t\treturn err\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc (sp *SAMLServiceProvider) validateElementSignature(el *etree.Element) (*etree.Element, error) {\n\treturn sp.validationContext().Validate(el)\n}\n\nfunc (sp *SAMLServiceProvider) validateAssertionSignatures(el *etree.Element) error {\n\tsignedAssertions := 0\n\tunsignedAssertions := 0\n\tvalidateAssertion := func(ctx etreeutils.NSContext, unverifiedAssertion *etree.Element) error {\n\t\tparent := unverifiedAssertion.Parent()\n\t\tif parent == nil {\n\t\t\treturn fmt.Errorf(\"parent is nil\")\n\t\t}\n\t\tif parent != el {\n\t\t\treturn fmt.Errorf(\"found assertion with unexpected parent element: %s\", unverifiedAssertion.Parent().Tag)\n\t\t}\n\n\t\tdetached, err := etreeutils.NSDetatch(ctx, unverifiedAssertion) // make a detached copy\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to detach unverified assertion: %v\", err)\n\t\t}\n\n\t\tassertion, err := sp.validationContext().Validate(detached)\n\t\tif err == dsig.ErrMissingSignature {\n\t\t\tunsignedAssertions++\n\t\t\treturn nil\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Replace the original unverified Assertion with the verified one. Note that\n\t\t// if the Response is not signed, only signed Assertions (and not the parent Response) can be trusted.\n\t\tif el.RemoveChild(unverifiedAssertion) == nil {\n\t\t\t// Out of an abundance of caution, check to make sure an Assertion was actually\n\t\t\t// removed. If it wasn't a programming error has occurred.\n\t\t\tpanic(\"unable to remove assertion\")\n\t\t}\n\n\t\tel.AddChild(assertion)\n\t\tsignedAssertions++\n\n\t\treturn nil\n\t}\n\n\tif err := etreeutils.NSFindIterate(el, SAMLAssertionNamespace, AssertionTag, validateAssertion); err != nil {\n\t\treturn err\n\t} else if signedAssertions > 0 && unsignedAssertions > 0 {\n\t\treturn fmt.Errorf(\"invalid to have both signed and unsigned assertions\")\n\t} else if signedAssertions < 1 {\n\t\treturn dsig.ErrMissingSignature\n\t} else {\n\t\treturn nil\n\t}\n}\n\n//ValidateEncodedResponse both decodes and validates, based on SP\n//configuration, an encoded, signed response. It will also appropriately\n//decrypt a response if the assertion was encrypted\nfunc (sp *SAMLServiceProvider) ValidateEncodedResponse(encodedResponse string) (*types.Response, error) {\n\traw, err := base64.StdEncoding.DecodeString(encodedResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Parse the raw response\n\tdoc, el, err := parseResponse(raw)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar responseSignatureValidated bool\n\tif !sp.SkipSignatureValidation {\n\t\tel, err = sp.validateElementSignature(el)\n\t\tif err == dsig.ErrMissingSignature {\n\t\t\t// Unfortunately we just blew away our Response\n\t\t\tel = doc.Root()\n\t\t} else if err != nil {\n\t\t\treturn nil, err\n\t\t} else if el == nil {\n\t\t\treturn nil, fmt.Errorf(\"missing transformed response\")\n\t\t} else {\n\t\t\tresponseSignatureValidated = true\n\t\t}\n\t}\n\n\terr = sp.decryptAssertions(el)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar assertionSignaturesValidated bool\n\tif !sp.SkipSignatureValidation {\n\t\terr = sp.validateAssertionSignatures(el)\n\t\tif err == dsig.ErrMissingSignature {\n\t\t\tif !responseSignatureValidated {\n\t\t\t\treturn nil, fmt.Errorf(\"response and/or assertions must be signed\")\n\t\t\t}\n\t\t} else if err != nil {\n\t\t\treturn nil, err\n\t\t} else {\n\t\t\tassertionSignaturesValidated = true\n\t\t}\n\t}\n\n\tdecodedResponse := &types.Response{}\n\terr = xmlUnmarshalElement(el, decodedResponse)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to unmarshal response: %v\", err)\n\t}\n\tdecodedResponse.SignatureValidated = responseSignatureValidated\n\tif assertionSignaturesValidated {\n\t\tfor idx := 0; idx < len(decodedResponse.Assertions); idx++ {\n\t\t\tdecodedResponse.Assertions[idx].SignatureValidated = true\n\t\t}\n\t}\n\n\terr = sp.Validate(decodedResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn decodedResponse, nil\n}\n\n// DecodeUnverifiedBaseResponse decodes several attributes from a SAML response for the purpose\n// of determining how to validate the response. This is useful for Service Providers which\n// expose a single Assertion Consumer Service URL but consume Responses from many IdPs.\nfunc DecodeUnverifiedBaseResponse(encodedResponse string) (*types.UnverifiedBaseResponse, error) {\n\traw, err := base64.StdEncoding.DecodeString(encodedResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response *types.UnverifiedBaseResponse\n\n\terr = maybeDeflate(raw, func(maybeXML []byte) error {\n\t\tresponse = &types.UnverifiedBaseResponse{}\n\t\treturn xml.Unmarshal(maybeXML, response)\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}\n\n// maybeDeflate invokes the passed decoder over the passed data. If an error is\n// returned, it then attempts to deflate the passed data before re-invoking\n// the decoder over the deflated data.\nfunc maybeDeflate(data []byte, decoder func([]byte) error) error {\n\terr := decoder(data)\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\tdeflated, err := ioutil.ReadAll(flate.NewReader(bytes.NewReader(data)))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn decoder(deflated)\n}\n\n// parseResponse is a helper function that was refactored out so that the XML parsing behavior can be isolated and unit tested\nfunc parseResponse(xml []byte) (*etree.Document, *etree.Element, error) {\n\tvar doc *etree.Document\n\tvar rawXML []byte\n\n\terr := maybeDeflate(xml, func(xml []byte) error {\n\t\tdoc = etree.NewDocument()\n\t\trawXML = xml\n\t\treturn doc.ReadFromBytes(xml)\n\t})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tel := doc.Root()\n\tif el == nil {\n\t\treturn nil, nil, fmt.Errorf(\"unable to parse response\")\n\t}\n\n\t// Examine the response for attempts to exploit weaknesses in Go's encoding/xml\n\terr = rtvalidator.Validate(bytes.NewReader(rawXML))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn doc, el, nil\n}\n\n// DecodeUnverifiedLogoutResponse decodes several attributes from a SAML Logout response, without doing any verifications.\nfunc DecodeUnverifiedLogoutResponse(encodedResponse string) (*types.LogoutResponse, error) {\n\traw, err := base64.StdEncoding.DecodeString(encodedResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response *types.LogoutResponse\n\n\terr = maybeDeflate(raw, func(maybeXML []byte) error {\n\t\tresponse = &types.LogoutResponse{}\n\t\treturn xml.Unmarshal(maybeXML, response)\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}\n\nfunc (sp *SAMLServiceProvider) ValidateEncodedLogoutResponsePOST(encodedResponse string) (*types.LogoutResponse, error) {\n\traw, err := base64.StdEncoding.DecodeString(encodedResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Parse the raw response\n\tdoc, el, err := parseResponse(raw)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar responseSignatureValidated bool\n\tif !sp.SkipSignatureValidation {\n\t\tel, err = sp.validateElementSignature(el)\n\t\tif err == dsig.ErrMissingSignature {\n\t\t\t// Unfortunately we just blew away our Response\n\t\t\tel = doc.Root()\n\t\t} else if err != nil {\n\t\t\treturn nil, err\n\t\t} else if el == nil {\n\t\t\treturn nil, fmt.Errorf(\"missing transformed logout response\")\n\t\t} else {\n\t\t\tresponseSignatureValidated = true\n\t\t}\n\t}\n\n\tdecodedResponse := &types.LogoutResponse{}\n\terr = xmlUnmarshalElement(el, decodedResponse)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to unmarshal logout response: %v\", err)\n\t}\n\tdecodedResponse.SignatureValidated = responseSignatureValidated\n\n\terr = sp.ValidateDecodedLogoutResponse(decodedResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn decodedResponse, nil\n}\n", "// Copyright 2016 Russell Haering et al.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage saml2\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/pem\"\n\t\"io/ioutil\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/jonboulle/clockwork\"\n\t\"github.com/russellhaering/goxmldsig\"\n\t\"github.com/stretchr/testify/require\"\n\trtvalidator \"github.com/mattermost/xml-roundtrip-validator\"\n)\n\nconst (\n\tidpCert = `\n-----BEGIN CERTIFICATE-----\nMIIDODCCAiCgAwIBAgIUQH54kyyeacU69J2iwz9bzeLmMaswDQYJKoZIhvcNAQEL\nBQAwHTEbMBkGA1UEAwwSY29sbGVnZS5jY2N0Y2EuZWR1MB4XDTE1MDYwNDIyMTAz\nMVoXDTM1MDYwNDIyMTAzMVowHTEbMBkGA1UEAwwSY29sbGVnZS5jY2N0Y2EuZWR1\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlJhN20ng2VN/cTrWtqUI\nNaUsrHCkYXbm2y1PTN4b6fJI5hbvcv+LWCuLkLi3+iPGlBpcHHfrdJcyhmBHRHQ9\nSos3RIH5Lsn1IgjWe3hxQQmVeEi5xVxnw2YZGHaeX4YnI1TEBJwhtJmyitk74LHy\nbPGEqOJdApUnLz54L7I+252G/cOfEqUHMbxxtmHSc/9chF8bBxQ8OzIbJsByHnqi\nawQHwtsttre7n328gVqmf1VHE27cfAYiSjuK5pCsx/1kuJMBN+kg/3Gg9oi6aR50\nWX1VUF3IBcnTDeiAXRz3PgsT8FlVZou6Ik9NT/Y5IHOZVGk64SRDaG8FuGxLexXr\nswIDAQABo3AwbjAdBgNVHQ4EFgQUjQwaAoY3u/iToIE3ADeNEW+Uu34wTQYDVR0R\nBEYwRIISY29sbGVnZS5jY2N0Y2EuZWR1hi5odHRwczovL2NvbGxlZ2UuY2NjdGNh\nLmVkdTo4NDQzL2lkcC9zaGliYm9sZXRoMA0GCSqGSIb3DQEBCwUAA4IBAQB26rdx\nphN1YKad3yDhLg6Y1ZwbmAjc+l4QB1KSL+cLqhDn5iMy4VdWh8HpSKRqCwofLtlw\n3qOwospj+mJaguXRMpjYODRQaKRkTrCGxJhuNrQxDXL/b6FOEIJnUYenbPevuNgR\nJc1VnREhWUUXT44KN5YUz9FEiG0BsBK8ecCPKBzTQ/hwaczhpqw6uqVMqxJaTGcn\nlCUHJAhVHiA8lWJ7vaNPsJ86xBFs/F76EwyFXIKQaruvcvChU7GNNSYdNJBa6HO9\n9QWdGbr5aNQ4diunnBQdrdjgbQIwyhKTfbFWa2l5vbqEKDc0dwuPa6c25l8ruqxq\nCQ1CF8ZDDJ0XV6Ab\n-----END CERTIFICATE-----\n`\n\n\toktaCert = `\n-----BEGIN CERTIFICATE-----\nMIIDPDCCAiQCCQDydJgOlszqbzANBgkqhkiG9w0BAQUFADBgMQswCQYDVQQGEwJVUzETMB\nEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZyYW5jaXNjbzEQMA4GA1UEChMH\nSmFua3lDbzESMBAGA1UEAxMJbG9jYWxob3N0MB4XDTE0MDMxMjE5NDYzM1oXDTI3MTExOT\nE5NDYzM1owYDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcT\nDVNhbiBGcmFuY2lzY28xEDAOBgNVBAoTB0phbmt5Q28xEjAQBgNVBAMTCWxvY2FsaG9zdD\nCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMGvJpRTTasRUSPqcbqCG+ZnTAur\nnu0vVpIG9lzExnh11o/BGmzu7lB+yLHcEdwrKBBmpepDBPCYxpVajvuEhZdKFx/Fdy6j5m\nH3rrW0Bh/zd36CoUNjbbhHyTjeM7FN2yF3u9lcyubuvOzr3B3gX66IwJlU46+wzcQVhSOl\nMk2tXR+fIKQExFrOuK9tbX3JIBUqItpI+HnAow509CnM134svw8PTFLkR6/CcMqnDfDK1m\n993PyoC1Y+N4X9XkhSmEQoAlAHPI5LHrvuujM13nvtoVYvKYoj7ScgumkpWNEvX652LfXO\nnKYlkB8ZybuxmFfIkzedQrbJsyOhfL03cMECAwEAATANBgkqhkiG9w0BAQUFAAOCAQEAeH\nwzqwnzGEkxjzSD47imXaTqtYyETZow7XwBc0ZaFS50qRFJUgKTAmKS1xQBP/qHpStsROT3\n5DUxJAE6NY1Kbq3ZbCuhGoSlY0L7VzVT5tpu4EY8+Dq/u2EjRmmhoL7UkskvIZ2n1DdERt\nd+YUMTeqYl9co43csZwDno/IKomeN5qaPc39IZjikJ+nUC6kPFKeu/3j9rgHNlRtocI6S1\nFdtFz9OZMQlpr0JbUt2T3xS/YoQJn6coDmJL5GTiiKM6cOe+Ur1VwzS1JEDbSS2TWWhzq8\nojLdrotYLGd9JOsoQhElmz+tMfCFQUFLExinPAyy7YHlSiVX13QH2XTu/iQQ==\n-----END CERTIFICATE-----\n`\n\n\toktaCert2 = `\n-----BEGIN CERTIFICATE-----\nMIIDpDCCAoygAwIBAgIGAWxzAwX1MA0GCSqGSIb3DQEBCwUAMIGSMQswCQYDVQQGEwJVUzETMBEG\nA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNU2FuIEZyYW5jaXNjbzENMAsGA1UECgwET2t0YTEU\nMBIGA1UECwwLU1NPUHJvdmlkZXIxEzARBgNVBAMMCmRldi05MDUyNTExHDAaBgkqhkiG9w0BCQEW\nDWluZm9Ab2t0YS5jb20wHhcNMTkwODA4MjA1MzMzWhcNMjkwODA4MjA1NDMzWjCBkjELMAkGA1UE\nBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDVNhbiBGcmFuY2lzY28xDTALBgNV\nBAoMBE9rdGExFDASBgNVBAsMC1NTT1Byb3ZpZGVyMRMwEQYDVQQDDApkZXYtOTA1MjUxMRwwGgYJ\nKoZIhvcNAQkBFg1pbmZvQG9rdGEuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\nm+ZZF6aEG6ehLLIV6RPA+i1z6ss3HBG2bZD3efwKCDDXYUkp59AE7JsjVHMtpJPHhzHuScuHDMlu\nHmkBQTW7j9XpnaRn8SfZXkwlCUHTo+HAC9lwbQxO4d4wnwgnm6FAjm1I/gbfFAobd8BR9pDxHuXE\nMQ0DtQu/W3WbDUrz/bhSxPJAoVy2koQn9G0y3unm7eRwYWHeuW6GdPWV2szTtDS0c3qtUXVF5Ugg\niQYlwQu6xkfy4l8iGJL7ETa2BmJzwCFecMIct87SqNhYQwCBH54MBaHcaSsCKyimNvMY9B7RmC+H\n4+awePPA1q3R/UQ3Pfom8mx6yDdKIWqlkG3MsQIDAQABMA0GCSqGSIb3DQEBCwUAA4IBAQAiURCZ\nP4oJWcf1o5nm4yG15UH01g/S6Y4OUWMi6BFJy9fCrJ0h/2BZKi68SQ0uMAbdK6anxCzq3Rr5MSzW\nOWPQ1Zljn3LGPsiTFdFca/GVRen5IYQ7Dr2Mvhtm+QVscEY9TDjtETbTAHEVEjwXmB21wtdIhizv\nsQS7wz0A8LV+Atpbev45RiV6COmB6T6vJuFQ7ZsDZMSHZriTYiETTJvHBGd7PtbCxYNc6LRB2JDb\nwlekRhVEjR0UhnM+nn2sqqbv7tDEPs63lZSDXCnR1PhscHrEuQ04rHI3OL0gCULVQFvJrj85IAZF\n1QQuGUK8ozfOyFpQWAJUW71INnF/SLWv\n-----END CERTIFICATE-----\n`\n\n\tbadInput = `<saml2:Assertion ID=\"id1684056077776386493060641\"IssueInstant=\"2019-08-12T12:00:52.718Z\"Version=\"2.0\"xmlns:saml2=\"urn:oasis:names:tc:SAML:2.0:assertion\"xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"><saml2:Issuer Format=\"urn:oasis:names:tc:SAML:2.0:nameid-format:entity\"xmlns=\"\">http://www.okta.com/exk133onomIuOW98z357</l><ds:Signature xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"><ds:SignedInfo><ds:CanonicalizationMethod Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\"/><ds:SignatureMethod Algorithm=\"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\"/><ds:Reference URI=\"#id1684056077776386493060641\"><ds:Transforms><ds:Transform Algorithm=\"http://www.w3.org/2000/09/xmldsig#enveloped-signature\"/><ds:Transform Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\"><ec:InclusiveNamespaces PrefixList=\"xs\"xmlns:ec=\"http://www.w3.org/2001/10/xml-exc-c14n#\"/></m></s><ds:DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\"/><ds:DigestValue>dC1cm0pLLjIWZC6G2Pmf0JogmqHztp9W1euXPd/TUHo=</e></e></o><ds:SignatureValue>YRSCFLIkIgjbbYLyfCIc8jsP2MUJPjn+nYWRdlVIDdXtYXXxklYqdBXQsxDwNcsOAIGS75PeVGryml3oBkUDg/MfK7z/fFPLXX7c7xgh7/DBAFlSXbwlJQxuXQ5eZcGesgG6nYRwU1hpW+yN7C2ODN9KHi5TUdiEhvy8vdlFSfxdy4Mn68nG/UZBqmHHIZdRG2/Hpcs29YyaVVZUCZ0w22b7zsPuOXHuStOSTQ6isxI2R268+ZNKERYaNMCAGX4zNlT3mHBV0NnZkbO3wmlOfKksL+Qx7L64xFc3PaervxWuPqh2FoWpTCqFdliLdvUfFDszKXJKhO0bj1U0aSrdzg==</e><s><s><s></X></X></o></e><saml2:Subject xmlns=\"\"><saml2:NameID Format=\"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\">steven.james.johnstone@gmail.com</l><saml2:SubjectConfirmation Method=\"urn:oasis:names:tc:SAML:2.0:cm:bearer\"><saml2:SubjectConfirmationData InResponseTo=\"_40a419f5-5c1c-43d0-5834-5caf268a5f01\"NotOnOrAfter=\"2019-08-12T12:05:52.718Z\"Recipient=\"https://127.0.0.1/login\"/></l></l><saml2:Conditions NotBefore=\"2019-08-12T11:55:52.718Z\"NotOnOrAfter=\"2019-08-12T12:05:52.718Z\"xmlns=\"\"><saml2:AudienceRestriction><saml2:Audience>37a8eec1ce19687d132fe29051dca629d164e2c4958ba141d5f4133a33f0688f.jazznetworks.com</l></l></l><saml2:AuthnStatement AuthnInstant=\"2019-08-12T12:00:52.718Z\"SessionIndex=\"_40a419f5-5c1c-43d0-5834-5caf268a5f01\"xmlns=\"\"><saml2:AuthnContext><saml2:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport</l></l></l><saml2:AttributeStatement xmlns=\"\"><saml2:Attribute Name=\"FirstName\"NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified\"><saml2:AttributeValue xmlns=\"\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:type=\"xs:string\">Steven</l></l><saml2:Attribute Name=\"LastName\"NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified\"><saml2:AttributeValue xmlns=\"\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:type=\"xs:string\">Johnstone</l></l><saml2:Attribute Name=\"Email\"NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified\"><saml2:AttributeValue xmlns=\"\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:type=\"xs:string\">steven.james.johnstone@gmail.com`\n)\n\nfunc testEncryptedAssertion(t *testing.T, validateEncryptionCert bool) {\n\tvar err error\n\tcert, err := tls.LoadX509KeyPair(\"./testdata/test.crt\", \"./testdata/test.key\")\n\trequire.NoError(t, err, \"could not load x509 key pair\")\n\n\tblock, _ := pem.Decode([]byte(idpCert))\n\n\tidpCert, err := x509.ParseCertificate(block.Bytes)\n\trequire.NoError(t, err, \"couldn't parse idp cert pem block\")\n\n\tsp := SAMLServiceProvider{\n\t\tAssertionConsumerServiceURL: \"https://saml2.test.astuart.co/sso/saml2\",\n\t\tSPKeyStore:                  dsig.TLSCertKeyStore(cert),\n\t\tValidateEncryptionCert:      validateEncryptionCert,\n\t\tIDPCertificateStore: &dsig.MemoryX509CertificateStore{\n\t\t\tRoots: []*x509.Certificate{idpCert},\n\t\t},\n\t\tClock: dsig.NewFakeClockAt(time.Date(2016, 04, 28, 22, 00, 00, 00, time.UTC)),\n\t}\n\n\tbs, err := ioutil.ReadFile(\"./testdata/saml.post\")\n\trequire.NoError(t, err, \"couldn't read post\")\n\n\t_, err = sp.RetrieveAssertionInfo(string(bs))\n\tif validateEncryptionCert {\n\t\trequire.Error(t, err)\n\t\trequire.Equal(t, \"error validating response: unable to get decryption certificate: decryption cert is not valid at this time\", err.Error())\n\t} else {\n\t\trequire.NoError(t, err, \"Assertion info should be retrieved with no error\")\n\t}\n}\n\nfunc TestEncryptedAssertion(t *testing.T) {\n\ttestEncryptedAssertion(t, false)\n}\n\nfunc TestEncryptedAssertionInvalidCert(t *testing.T) {\n\ttestEncryptedAssertion(t, true)\n}\n\nfunc TestCompressedResponse(t *testing.T) {\n\tbs, err := ioutil.ReadFile(\"./testdata/saml_compressed.post\")\n\trequire.NoError(t, err, \"couldn't read compressed post\")\n\n\tblock, _ := pem.Decode([]byte(oktaCert))\n\n\tidpCert, err := x509.ParseCertificate(block.Bytes)\n\trequire.NoError(t, err, \"couldn't parse okta cert pem block\")\n\n\tsp := SAMLServiceProvider{\n\t\tAssertionConsumerServiceURL: \"https://f1f51ddc.ngrok.io/api/sso/saml2/acs/58cafd0573d4f375b8e70e8e\",\n\t\tSPKeyStore:                  dsig.TLSCertKeyStore(cert),\n\t\tIDPCertificateStore: &dsig.MemoryX509CertificateStore{\n\t\t\tRoots: []*x509.Certificate{idpCert},\n\t\t},\n\t\tClock: dsig.NewFakeClock(clockwork.NewFakeClockAt(time.Date(2017, 3, 17, 20, 00, 0, 0, time.UTC))),\n\t}\n\n\t_, err = sp.RetrieveAssertionInfo(string(bs))\n\trequire.NoError(t, err, \"Assertion info should be retrieved with no error\")\n}\n\nfunc TestDecodeColonsInLocalNames(t *testing.T) {\n\t// Handling of double colons was improved in Go 1.7 such that this test no longer fails.\n\t// See: https://go-review.googlesource.com/c/go/+/277892\n\tif rtvalidator.Validate(bytes.NewReader([]byte(`<x::Root/>`))) == nil {\n\t\tt.Skip()\n\t}\n\n\t_, _, err := parseResponse([]byte(`<x::Root/>`))\n\trequire.Error(t, err)\n}\n\nfunc TestDecodeDoubleColonInjectionAttackResponse(t *testing.T) {\n\t// Handling of double colons was improved in Go 1.7 such that this test no longer fails.\n\t// See: https://go-review.googlesource.com/c/go/+/277892\n\tif rtvalidator.Validate(bytes.NewReader([]byte(`<x::Root/>`))) == nil {\n\t\tt.Skip()\n\t}\n\n\t_, _, err := parseResponse([]byte(doubleColonAssertionInjectionAttackResponse))\n\trequire.Error(t, err)\n}\n\nfunc TestMalFormedInput(t *testing.T) {\n\tblock, _ := pem.Decode([]byte(oktaCert2))\n\tidpCert, err := x509.ParseCertificate(block.Bytes)\n\trequire.NoError(t, err, \"couldn't parse okta cert pem block\")\n\n\tcertStore := dsig.MemoryX509CertificateStore{\n\t\tRoots: []*x509.Certificate{idpCert},\n\t}\n\n\tsp := &SAMLServiceProvider{\n\t\tClock: dsig.NewFakeClock(clockwork.NewFakeClockAt(time.Date(2019, 8, 12, 12, 00, 52, 718, time.UTC))),\n\t\tAssertionConsumerServiceURL: \"https://saml2.test.astuart.co/sso/saml2\",\n\t\tSignAuthnRequests:           true,\n\t\tIDPCertificateStore:         &certStore,\n\t\tValidateEncryptionCert:      true,\n\t}\n\tbase64Input := base64.StdEncoding.EncodeToString([]byte(badInput))\n\t_, err = sp.RetrieveAssertionInfo(base64Input)\n\trequire.Errorf(t, err, \"parent is nil\")\n}", "// Copyright 2016 Russell Haering et al.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage saml2\n\nimport (\n\t\"encoding/base64\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/russellhaering/gosaml2/types\"\n\tdsig \"github.com/russellhaering/goxmldsig\"\n\tdsigtypes \"github.com/russellhaering/goxmldsig/types\"\n)\n\ntype ErrSaml struct {\n\tMessage string\n\tSystem  error\n}\n\nfunc (serr ErrSaml) Error() string {\n\tif serr.Message != \"\" {\n\t\treturn serr.Message\n\t}\n\treturn \"SAML error\"\n}\n\ntype SAMLServiceProvider struct {\n\tIdentityProviderSSOURL     string\n\tIdentityProviderSSOBinding string\n\tIdentityProviderSLOURL     string\n\tIdentityProviderSLOBinding string\n\tIdentityProviderIssuer     string\n\n\tAssertionConsumerServiceURL string\n\tServiceProviderSLOURL       string\n\tServiceProviderIssuer       string\n\n\tSignAuthnRequests              bool\n\tSignAuthnRequestsAlgorithm     string\n\tSignAuthnRequestsCanonicalizer dsig.Canonicalizer\n\n\t// ForceAuthn attribute in authentication request forces the identity provider to\n\t// re-authenticate the presenter directly rather than rely on a previous security context.\n\t// NOTE: If both ForceAuthn and IsPassive are \"true\", the identity provider MUST NOT freshly\n\t// authenticate the presenter unless the constraints of IsPassive can be met.\n\tForceAuthn bool\n\t// IsPassive attribute in authentication request requires that the identity provider and the\n\t// user agent itself MUST NOT visibly take control of the user interface from the requester\n\t// and interact with the presenter in a noticeable fashion.\n\tIsPassive bool\n\t// RequestedAuthnContext allows service providers to require that the identity\n\t// provider use specific authentication mechanisms. Leaving this unset will\n\t// permit the identity provider to choose the auth method. To maximize compatibility\n\t// with identity providers it is recommended to leave this unset.\n\tRequestedAuthnContext   *RequestedAuthnContext\n\tAudienceURI             string\n\tIDPCertificateStore     dsig.X509CertificateStore\n\tSPKeyStore              dsig.X509KeyStore // Required encryption key, default signing key\n\tSPSigningKeyStore       dsig.X509KeyStore // Optional signing key\n\tNameIdFormat            string\n\tValidateEncryptionCert  bool\n\tSkipSignatureValidation bool\n\tAllowMissingAttributes  bool\n\tClock                   *dsig.Clock\n\tsigningContextMu        sync.RWMutex\n\tsigningContext          *dsig.SigningContext\n}\n\n// RequestedAuthnContext controls which authentication mechanisms are requested of\n// the identity provider. It is generally sufficient to omit this and let the\n// identity provider select an authentication mechansim.\ntype RequestedAuthnContext struct {\n\t// The RequestedAuthnContext comparison policy to use. See the section 3.3.2.2.1\n\t// of the SAML 2.0 specification for details. Constants named AuthnPolicyMatch*\n\t// contain standardized values.\n\tComparison string\n\n\t// Contexts will be passed as AuthnContextClassRefs. For example, to force password\n\t// authentication on some identity providers, Contexts should have a value of\n\t// []string{AuthnContextPasswordProtectedTransport}, and Comparison should have a\n\t// value of AuthnPolicyMatchExact.\n\tContexts []string\n}\n\nfunc (sp *SAMLServiceProvider) Metadata() (*types.EntityDescriptor, error) {\n\tkeyDescriptors := make([]types.KeyDescriptor, 0, 2)\n\tif sp.GetSigningKey() != nil {\n\t\tsigningCertBytes, err := sp.GetSigningCertBytes()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tkeyDescriptors = append(keyDescriptors, types.KeyDescriptor{\n\t\t\tUse: \"signing\",\n\t\t\tKeyInfo: dsigtypes.KeyInfo{\n\t\t\t\tX509Data: dsigtypes.X509Data{\n\t\t\t\t\tX509Certificates: []dsigtypes.X509Certificate{dsigtypes.X509Certificate{\n\t\t\t\t\t\tData: base64.StdEncoding.EncodeToString(signingCertBytes),\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t}\n\tif sp.GetEncryptionKey() != nil {\n\t\tencryptionCertBytes, err := sp.GetEncryptionCertBytes()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tkeyDescriptors = append(keyDescriptors, types.KeyDescriptor{\n\t\t\tUse: \"encryption\",\n\t\t\tKeyInfo: dsigtypes.KeyInfo{\n\t\t\t\tX509Data: dsigtypes.X509Data{\n\t\t\t\t\tX509Certificates: []dsigtypes.X509Certificate{dsigtypes.X509Certificate{\n\t\t\t\t\t\tData: base64.StdEncoding.EncodeToString(encryptionCertBytes),\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tEncryptionMethods: []types.EncryptionMethod{\n\t\t\t\t{Algorithm: types.MethodAES128GCM},\n\t\t\t\t{Algorithm: types.MethodAES192GCM},\n\t\t\t\t{Algorithm: types.MethodAES256GCM},\n\t\t\t\t{Algorithm: types.MethodAES128CBC},\n\t\t\t\t{Algorithm: types.MethodAES256CBC},\n\t\t\t},\n\t\t})\n\t}\n\treturn &types.EntityDescriptor{\n\t\tValidUntil: time.Now().UTC().Add(time.Hour * 24 * 7), // 7 days\n\t\tEntityID:   sp.ServiceProviderIssuer,\n\t\tSPSSODescriptor: &types.SPSSODescriptor{\n\t\t\tAuthnRequestsSigned:        sp.SignAuthnRequests,\n\t\t\tWantAssertionsSigned:       !sp.SkipSignatureValidation,\n\t\t\tProtocolSupportEnumeration: SAMLProtocolNamespace,\n\t\t\tKeyDescriptors:             keyDescriptors,\n\t\t\tAssertionConsumerServices: []types.IndexedEndpoint{{\n\t\t\t\tBinding:  BindingHttpPost,\n\t\t\t\tLocation: sp.AssertionConsumerServiceURL,\n\t\t\t\tIndex:    1,\n\t\t\t}},\n\t\t},\n\t}, nil\n}\n\nfunc (sp *SAMLServiceProvider) MetadataWithSLO(validityHours int64) (*types.EntityDescriptor, error) {\n\tsigningCertBytes, err := sp.GetSigningCertBytes()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tencryptionCertBytes, err := sp.GetEncryptionCertBytes()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif validityHours <= 0 {\n\t\t//By default let's keep it to 7 days.\n\t\tvalidityHours = int64(time.Hour * 24 * 7)\n\t}\n\n\treturn &types.EntityDescriptor{\n\t\tValidUntil: time.Now().UTC().Add(time.Duration(validityHours)), // default 7 days\n\t\tEntityID:   sp.ServiceProviderIssuer,\n\t\tSPSSODescriptor: &types.SPSSODescriptor{\n\t\t\tAuthnRequestsSigned:        sp.SignAuthnRequests,\n\t\t\tWantAssertionsSigned:       !sp.SkipSignatureValidation,\n\t\t\tProtocolSupportEnumeration: SAMLProtocolNamespace,\n\t\t\tKeyDescriptors: []types.KeyDescriptor{\n\t\t\t\t{\n\t\t\t\t\tUse: \"signing\",\n\t\t\t\t\tKeyInfo: dsigtypes.KeyInfo{\n\t\t\t\t\t\tX509Data: dsigtypes.X509Data{\n\t\t\t\t\t\t\tX509Certificates: []dsigtypes.X509Certificate{dsigtypes.X509Certificate{\n\t\t\t\t\t\t\t\tData: base64.StdEncoding.EncodeToString(signingCertBytes),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tUse: \"encryption\",\n\t\t\t\t\tKeyInfo: dsigtypes.KeyInfo{\n\t\t\t\t\t\tX509Data: dsigtypes.X509Data{\n\t\t\t\t\t\t\tX509Certificates: []dsigtypes.X509Certificate{dsigtypes.X509Certificate{\n\t\t\t\t\t\t\t\tData: base64.StdEncoding.EncodeToString(encryptionCertBytes),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tEncryptionMethods: []types.EncryptionMethod{\n\t\t\t\t\t\t{Algorithm: types.MethodAES128GCM, DigestMethod: nil},\n\t\t\t\t\t\t{Algorithm: types.MethodAES192GCM, DigestMethod: nil},\n\t\t\t\t\t\t{Algorithm: types.MethodAES256GCM, DigestMethod: nil},\n\t\t\t\t\t\t{Algorithm: types.MethodAES128CBC, DigestMethod: nil},\n\t\t\t\t\t\t{Algorithm: types.MethodAES256CBC, DigestMethod: nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tAssertionConsumerServices: []types.IndexedEndpoint{{\n\t\t\t\tBinding:  BindingHttpPost,\n\t\t\t\tLocation: sp.AssertionConsumerServiceURL,\n\t\t\t\tIndex:    1,\n\t\t\t}},\n\t\t\tSingleLogoutServices: []types.Endpoint{{\n\t\t\t\tBinding:  BindingHttpPost,\n\t\t\t\tLocation: sp.ServiceProviderSLOURL,\n\t\t\t}},\n\t\t},\n\t}, nil\n}\n\nfunc (sp *SAMLServiceProvider) GetEncryptionKey() dsig.X509KeyStore {\n\treturn sp.SPKeyStore\n}\n\nfunc (sp *SAMLServiceProvider) GetSigningKey() dsig.X509KeyStore {\n\tif sp.SPSigningKeyStore == nil {\n\t\treturn sp.GetEncryptionKey() // Default is signing key is same as encryption key\n\t}\n\treturn sp.SPSigningKeyStore\n}\n\nfunc (sp *SAMLServiceProvider) GetEncryptionCertBytes() ([]byte, error) {\n\tif _, encryptionCert, err := sp.GetEncryptionKey().GetKeyPair(); err != nil {\n\t\treturn nil, ErrSaml{Message: \"no SP encryption certificate\", System: err}\n\t} else if len(encryptionCert) < 1 {\n\t\treturn nil, ErrSaml{Message: \"empty SP encryption certificate\"}\n\t} else {\n\t\treturn encryptionCert, nil\n\t}\n}\n\nfunc (sp *SAMLServiceProvider) GetSigningCertBytes() ([]byte, error) {\n\tif _, signingCert, err := sp.GetSigningKey().GetKeyPair(); err != nil {\n\t\treturn nil, ErrSaml{Message: \"no SP signing certificate\", System: err}\n\t} else if len(signingCert) < 1 {\n\t\treturn nil, ErrSaml{Message: \"empty SP signing certificate\"}\n\t} else {\n\t\treturn signingCert, nil\n\t}\n}\n\nfunc (sp *SAMLServiceProvider) SigningContext() *dsig.SigningContext {\n\tsp.signingContextMu.RLock()\n\tsigningContext := sp.signingContext\n\tsp.signingContextMu.RUnlock()\n\n\tif signingContext != nil {\n\t\treturn signingContext\n\t}\n\n\tsp.signingContextMu.Lock()\n\tdefer sp.signingContextMu.Unlock()\n\n\tsp.signingContext = dsig.NewDefaultSigningContext(sp.GetSigningKey())\n\tsp.signingContext.SetSignatureMethod(sp.SignAuthnRequestsAlgorithm)\n\tif sp.SignAuthnRequestsCanonicalizer != nil {\n\t\tsp.signingContext.Canonicalizer = sp.SignAuthnRequestsCanonicalizer\n\t}\n\n\treturn sp.signingContext\n}\n\ntype ProxyRestriction struct {\n\tCount    int\n\tAudience []string\n}\n\ntype WarningInfo struct {\n\tOneTimeUse       bool\n\tProxyRestriction *ProxyRestriction\n\tNotInAudience    bool\n\tInvalidTime      bool\n}\n\ntype AssertionInfo struct {\n\tNameID                     string\n\tValues                     Values\n\tWarningInfo                *WarningInfo\n\tSessionIndex               string\n\tAuthnInstant               *time.Time\n\tSessionNotOnOrAfter        *time.Time\n\tAssertions                 []types.Assertion\n\tResponseSignatureValidated bool\n}\n", "// Copyright 2016 Russell Haering et al.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage saml2\n\nimport (\n\t\"bytes\"\n\t\"compress/flate\"\n\t\"crypto\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/pem\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"testing\"\n\n\t\"github.com/beevik/etree\"\n\t\"github.com/russellhaering/gosaml2/types\"\n\tdsig \"github.com/russellhaering/goxmldsig\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar cert tls.Certificate\nvar pk crypto.PrivateKey\n\nfunc init() {\n\tvar err error\n\tpfx := \"./testdata/test\"\n\tcert, err = tls.LoadX509KeyPair(fmt.Sprintf(\"%s.crt\", pfx), fmt.Sprintf(\"%s.key\", pfx))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tpk = cert.PrivateKey\n}\n\nfunc TestDecode(t *testing.T) {\n\tf, err := ioutil.ReadFile(\"./testdata/saml.post\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not open test file: %v\\n\", err)\n\t}\n\tdecoded := make([]byte, len(f))\n\n\tbase64.StdEncoding.Decode(decoded, f)\n\tresponse := &types.Response{}\n\n\terr = xml.Unmarshal(decoded, response)\n\tif err != nil {\n\t\tt.Fatalf(\"error decoding test saml: %v\", err)\n\t}\n\n\tea := response.EncryptedAssertions[0]\n\n\tk, err := ea.EncryptedKey.DecryptSymmetricKey(&cert)\n\tif err != nil {\n\t\tt.Fatalf(\"could not get symmetric key: %v\\n\", err)\n\t}\n\n\tif k == nil {\n\t\tt.Fatalf(\"no symmetric key\")\n\t}\n\n\tassertion, err := ea.Decrypt(&cert)\n\tif err != nil {\n\t\tt.Fatalf(\"error decrypting saml data: %v\\n\", err)\n\t}\n\n\tf2, err := ioutil.ReadFile(\"./testdata/saml.xml\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not read expected output\")\n\t}\n\n\texpected := &types.Assertion{}\n\terr = xml.Unmarshal(f2, expected)\n\n\trequire.EqualValues(t, expected, assertion, \"decrypted assertion did not match expectation\")\n}\n\nfunc signResponse(t *testing.T, resp string, sp *SAMLServiceProvider) string {\n\tdoc := etree.NewDocument()\n\terr := doc.ReadFromBytes([]byte(resp))\n\trequire.NoError(t, err)\n\n\tel := doc.Root()\n\n\t// Strip existing signatures\n\tsignatures := el.FindElements(\"//Signature\")\n\tfor _, sig := range signatures {\n\t\tparent := sig.Parent()\n\t\tparent.RemoveChild(sig)\n\t}\n\n\tel, err = sp.SigningContext().SignEnveloped(el)\n\trequire.NoError(t, err)\n\n\tdoc0 := etree.NewDocument()\n\tdoc0.SetRoot(el)\n\tdoc0.WriteSettings = etree.WriteSettings{\n\t\tCanonicalAttrVal: true,\n\t\tCanonicalEndTags: true,\n\t\tCanonicalText:    true,\n\t}\n\n\tstr, err := doc0.WriteToString()\n\trequire.NoError(t, err)\n\treturn str\n}\n\nfunc TestSAML(t *testing.T) {\n\tblock, _ := pem.Decode([]byte(idpCertificate))\n\trequire.NotEmpty(t, block)\n\tcert, err := x509.ParseCertificate(block.Bytes)\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, cert)\n\n\trandomKeyStore := dsig.RandomKeyStoreForTest()\n\t_, _cert, err := randomKeyStore.GetKeyPair()\n\n\tcert0, err := x509.ParseCertificate(_cert)\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, cert0)\n\n\tcertStore := dsig.MemoryX509CertificateStore{\n\t\tRoots: []*x509.Certificate{cert, cert0},\n\t}\n\n\tsp := &SAMLServiceProvider{\n\t\tIdentityProviderSSOURL:      \"https://dev-116807.oktapreview.com/app/scaleftdev116807_scaleft_1/exk5zt0r12Edi4rD20h7/sso/saml\",\n\t\tIdentityProviderIssuer:      \"http://www.okta.com/exk5zt0r12Edi4rD20h7\",\n\t\tAssertionConsumerServiceURL: \"http://localhost:8080/v1/_saml_callback\",\n\t\tSignAuthnRequests:           true,\n\t\tAudienceURI:                 \"123\",\n\t\tIDPCertificateStore:         &certStore,\n\t\tSPKeyStore:                  randomKeyStore,\n\t\tNameIdFormat:                NameIdFormatPersistent,\n\t}\n\n\tauthRequestURL, err := sp.BuildAuthURL(\"/some/link/here\")\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, authRequestURL)\n\n\tauthRequestString, err := sp.BuildAuthRequest()\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, authRequestString)\n\n\t// Note (Phoebe): The sample responses we acquired expired fairly quickly, meaning that our validation will fail\n\t// because we check the expiration time;\n\t// I've modified them to expire in ~100 years and removed their signatures, since those hash values are no longer\n\t// valid. We have to re-sign them here before validating them\n\traw := signResponse(t, rawResponse, sp)\n\n\tel, err := sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(raw)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, el)\n\n\tassertionInfo, err := sp.RetrieveAssertionInfo(base64.StdEncoding.EncodeToString([]byte(raw)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, assertionInfo)\n\trequire.NotNil(t, assertionInfo.WarningInfo) // always set when err == nil\n\trequire.False(t, assertionInfo.WarningInfo.OneTimeUse)\n\trequire.False(t, assertionInfo.WarningInfo.NotInAudience)\n\trequire.False(t, assertionInfo.WarningInfo.InvalidTime)\n\trequire.Nil(t, assertionInfo.WarningInfo.ProxyRestriction)\n\n\trequire.Equal(t, \"phoebe.simon@scaleft.com\", assertionInfo.NameID)\n\trequire.Equal(t, \"phoebe.simon@scaleft.com\", assertionInfo.Values.Get(\"Email\"))\n\trequire.Equal(t, \"Phoebe\", assertionInfo.Values.Get(\"FirstName\"))\n\trequire.Equal(t, \"Simon\", assertionInfo.Values.Get(\"LastName\"))\n\trequire.Equal(t, \"phoebesimon\", assertionInfo.Values.Get(\"Login\"))\n\n\tassertionInfoModifiedAudience := signResponse(t, assertionInfoModifiedAudienceResponse, sp)\n\n\tassertionInfo, err = sp.RetrieveAssertionInfo(base64.StdEncoding.EncodeToString([]byte(assertionInfoModifiedAudience)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, assertionInfo)\n\trequire.True(t, assertionInfo.WarningInfo.NotInAudience)\n\n\tassertionInfoOneTimeUse := signResponse(t, assertionInfoOneTimeUseResponse, sp)\n\n\tassertionInfo, err = sp.RetrieveAssertionInfo(base64.StdEncoding.EncodeToString([]byte(assertionInfoOneTimeUse)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, assertionInfo)\n\trequire.True(t, assertionInfo.WarningInfo.OneTimeUse)\n\n\tassertionInfoProxyRestriction := signResponse(t, assertionInfoProxyRestrictionResponse, sp)\n\n\tassertionInfo, err = sp.RetrieveAssertionInfo(base64.StdEncoding.EncodeToString([]byte(assertionInfoProxyRestriction)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, assertionInfo)\n\trequire.NotEmpty(t, assertionInfo.WarningInfo.ProxyRestriction)\n\trequire.Equal(t, 3, assertionInfo.WarningInfo.ProxyRestriction.Count)\n\trequire.Equal(t, []string{\"123\"}, assertionInfo.WarningInfo.ProxyRestriction.Audience)\n\n\tassertionInfoProxyRestrictionNoCount := signResponse(t, assertionInfoProxyRestrictionNoCountResponse, sp)\n\n\tassertionInfo, err = sp.RetrieveAssertionInfo(base64.StdEncoding.EncodeToString([]byte(assertionInfoProxyRestrictionNoCount)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, assertionInfo)\n\trequire.NotEmpty(t, assertionInfo.WarningInfo.ProxyRestriction)\n\trequire.Equal(t, 0, assertionInfo.WarningInfo.ProxyRestriction.Count)\n\trequire.Equal(t, []string{\"123\"}, assertionInfo.WarningInfo.ProxyRestriction.Audience)\n\n\tassertionInfoProxyRestrictionNoAudience := signResponse(t, assertionInfoProxyRestrictionNoAudienceResponse, sp)\n\n\tassertionInfo, err = sp.RetrieveAssertionInfo(base64.StdEncoding.EncodeToString([]byte(assertionInfoProxyRestrictionNoAudience)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, assertionInfo)\n\trequire.NotEmpty(t, assertionInfo.WarningInfo.ProxyRestriction)\n\trequire.Equal(t, 3, assertionInfo.WarningInfo.ProxyRestriction.Count)\n\trequire.Equal(t, []string{}, assertionInfo.WarningInfo.ProxyRestriction.Audience)\n\n\tassertionInfoResp := signResponse(t, assertionInfoResponse, sp)\n\n\tassertionInfo, err = sp.RetrieveAssertionInfo(base64.StdEncoding.EncodeToString([]byte(assertionInfoResp)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, assertionInfo)\n\trequire.NotEmpty(t, assertionInfo.Values)\n\trequire.Equal(t, \"phoebe.simon@scaleft.com\", assertionInfo.Values.Get(\"Email\"))\n\trequire.Equal(t, \"Phoebe\", assertionInfo.Values.Get(\"FirstName\"))\n\trequire.Equal(t, \"Simon\", assertionInfo.Values.Get(\"LastName\"))\n\trequire.Equal(t, \"phoebe.simon@scaleft.com\", assertionInfo.Values.Get(\"Login\"))\n\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(manInTheMiddledResponse)))\n\trequire.Error(t, err)\n\trequire.Equal(t, \"Signature could not be verified\", err.Error())\n\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(alteredReferenceURIResponse)))\n\trequire.Error(t, err)\n\t// require.IsType(t, ErrInvalidValue{}, err, err.Error())\n\trequire.Equal(t, \"Could not verify certificate against trusted certs\", err.Error())\n\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(alteredSignedInfoResponse)))\n\trequire.Error(t, err)\n\trequire.Equal(t, \"Could not verify certificate against trusted certs\", err.Error())\n\n\talteredRecipient := signResponse(t, alteredRecipientResponse, sp)\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(alteredRecipient)))\n\trequire.Error(t, err)\n\trequire.IsType(t, err, ErrInvalidValue{})\n\trequire.Contains(t, err.Error(), \"Recipient\")\n\n\talteredDestination := signResponse(t, alteredDestinationResponse, sp)\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(alteredDestination)))\n\trequire.Error(t, err)\n\trequire.IsType(t, err, ErrInvalidValue{})\n\trequire.Equal(t, err.(ErrInvalidValue).Key, \"Destination\")\n\n\talteredSubjectConfirmationMethod := signResponse(t, alteredSubjectConfirmationMethodResponse, sp)\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(alteredSubjectConfirmationMethod)))\n\trequire.Error(t, err)\n\trequire.IsType(t, err, ErrInvalidValue{})\n\trequire.Equal(t, err.(ErrInvalidValue).Reason, ReasonUnsupported)\n\trequire.Equal(t, err.(ErrInvalidValue).Key, SubjectConfirmationTag)\n\n\talteredVersion := signResponse(t, alteredVersionResponse, sp)\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(alteredVersion)))\n\trequire.Error(t, err)\n\trequire.IsType(t, err, ErrInvalidValue{})\n\trequire.Equal(t, err.(ErrInvalidValue).Reason, ReasonUnsupported)\n\trequire.Equal(t, err.(ErrInvalidValue).Key, \"SAML version\")\n\trequire.Contains(t, err.Error(), \"Unsupported SAML version\")\n\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(missingIDResponse)))\n\trequire.Error(t, err)\n\trequire.Equal(t, \"Signature could not be verified\", err.Error())\n}\n\nfunc TestInvalidResponseBadBase64(t *testing.T) {\n\tsp := &SAMLServiceProvider{}\n\n\tresponse, err := sp.ValidateEncodedResponse(\"invalid-base64\")\n\trequire.EqualError(t, err, \"illegal base64 data at input byte 7\")\n\trequire.Nil(t, response)\n}\n\nfunc TestInvalidResponseBadCompression(t *testing.T) {\n\tsp := &SAMLServiceProvider{}\n\n\t// Value from: https://github.com/golang/go/blob/23416315060bf7601e5779c3a6a2529d4d604584/src/compress/flate/flate_test.go#L219\n\trawResponse, err := hex.DecodeString(\"33180700\")\n\trequire.NoError(t, err)\n\n\tb64Response := base64.StdEncoding.EncodeToString(rawResponse)\n\n\tresponse, err := sp.ValidateEncodedResponse(b64Response)\n\trequire.EqualError(t, err, \"flate: corrupt input before offset 3\")\n\trequire.Nil(t, response)\n}\n\nfunc TestInvalidResponseBadXML(t *testing.T) {\n\tsp := &SAMLServiceProvider{}\n\n\tcompressed := &bytes.Buffer{}\n\n\tcompressor, err := flate.NewWriter(compressed, flate.BestCompression)\n\trequire.NoError(t, err)\n\n\tcompressor.Write([]byte(\">Definitely&Invalid XML\"))\n\tcompressor.Close()\n\n\tb64Response := base64.StdEncoding.EncodeToString(compressed.Bytes())\n\n\tresponse, err := sp.ValidateEncodedResponse(b64Response)\n\trequire.EqualError(t, err, \"XML syntax error on line 1: invalid character entity &Invalid (no semicolon)\")\n\trequire.Nil(t, response)\n}\n\nfunc TestInvalidResponseNoElement(t *testing.T) {\n\tsp := &SAMLServiceProvider{}\n\n\tb64Response := base64.StdEncoding.EncodeToString([]byte(\"no-element-here\"))\n\n\tresponse, err := sp.ValidateEncodedResponse(b64Response)\n\trequire.EqualError(t, err, \"unable to parse response\")\n\trequire.Nil(t, response)\n}\nfunc TestSAMLCommentInjection(t *testing.T) {\n\t/*\n\t\tExplanation:\n\n\t\tSee: https://duo.com/blog/duo-finds-saml-vulnerabilities-affecting-multiple-implementations\n\n\t\tThe TLDR is that XML canonicalization may result in a different value being signed from the one being retrieved.\n\t\tThe target of this is the NameID in the Subject of the SAMLResponse Assertion\n\n\t\tExample:\n\t\t\t The following Subject\n\t\t\t ```<Subject>\n\t\t\t\t<NameID>user@user.com<!---->.evil.com</NameID>\n\t\t\t</Subject>```\n\t\t\twould get canonicalized to\n\t\t\t```\n\t\t\t<Subject>\n\t\t\t\t<NameID>user@user.com.evil.com</NameID>\n\t\t\t</Subject>\n\t\t\t```\n\t\t\tMany XML parsers have a behavior where they pull the first text element, so in the example with the comment, a vulnerable XML parser would return `user@user.com`, ignoring the text after the comment.\n\t\t\tKnowing this, a user (user@user.com.evil.com) can attack a vulnerable SP by manipulating their signed SAMLResponse with a comment that turns their username into another one.\n\t*/\n\n\t// To show that we are not vulnerable, we want to prove that we get the canonicalized value using our parser\n\t_, el, err := parseResponse([]byte(commentInjectionAttackResponse))\n\trequire.NoError(t, err)\n\tdecodedResponse := &types.Response{}\n\terr = xmlUnmarshalElement(el, decodedResponse)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"phoebe.simon@scaleft.com.evil.com\", decodedResponse.Assertions[0].Subject.NameID.Value, \"The full, canonacalized NameID should be returned.\")\n}\n"], "fixing_code": ["// Copyright 2016 Russell Haering et al.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage saml2\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\n\tdsig \"github.com/russellhaering/goxmldsig\"\n)\n\nfunc (sp *SAMLServiceProvider) validateLogoutRequestAttributes(request *LogoutRequest) error {\n\tif request.Destination != \"\" && request.Destination != sp.ServiceProviderSLOURL {\n\t\treturn ErrInvalidValue{\n\t\t\tKey:      DestinationAttr,\n\t\t\tExpected: sp.ServiceProviderSLOURL,\n\t\t\tActual:   request.Destination,\n\t\t}\n\t}\n\n\tif request.Version != \"2.0\" {\n\t\treturn ErrInvalidValue{\n\t\t\tReason:   ReasonUnsupported,\n\t\t\tKey:      \"SAML version\",\n\t\t\tExpected: \"2.0\",\n\t\t\tActual:   request.Version,\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (sp *SAMLServiceProvider) ValidateEncodedLogoutRequestPOST(encodedRequest string) (*LogoutRequest, error) {\n\traw, err := base64.StdEncoding.DecodeString(encodedRequest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Parse the raw request - parseResponse is generic\n\tdoc, el, err := parseResponse(raw, sp.MaximumDecompressedBodySize)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar requestSignatureValidated bool\n\tif !sp.SkipSignatureValidation {\n\t\tel, err = sp.validateElementSignature(el)\n\t\tif err == dsig.ErrMissingSignature {\n\t\t\t// Unfortunately we just blew away our Response\n\t\t\tel = doc.Root()\n\t\t} else if err != nil {\n\t\t\treturn nil, err\n\t\t} else if el == nil {\n\t\t\treturn nil, fmt.Errorf(\"missing transformed logout request\")\n\t\t} else {\n\t\t\trequestSignatureValidated = true\n\t\t}\n\t}\n\n\tdecodedRequest := &LogoutRequest{}\n\terr = xmlUnmarshalElement(el, decodedRequest)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to unmarshal logout request: %v\", err)\n\t}\n\tdecodedRequest.SignatureValidated = requestSignatureValidated\n\n\terr = sp.ValidateDecodedLogoutRequest(decodedRequest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn decodedRequest, nil\n}\n", "// Copyright 2016 Russell Haering et al.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage saml2\n\nimport (\n\t\"bytes\"\n\t\"compress/flate\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"encoding/xml\"\n\n\t\"github.com/beevik/etree\"\n\trtvalidator \"github.com/mattermost/xml-roundtrip-validator\"\n\t\"github.com/russellhaering/gosaml2/types\"\n\tdsig \"github.com/russellhaering/goxmldsig\"\n\t\"github.com/russellhaering/goxmldsig/etreeutils\"\n)\n\nconst (\n\tdefaultMaxDecompressedResponseSize = 5 * 1024 * 1024\n)\n\nfunc (sp *SAMLServiceProvider) validationContext() *dsig.ValidationContext {\n\tctx := dsig.NewDefaultValidationContext(sp.IDPCertificateStore)\n\tctx.Clock = sp.Clock\n\treturn ctx\n}\n\n// validateResponseAttributes validates a SAML Response's tag and attributes. It does\n// not inspect child elements of the Response at all.\nfunc (sp *SAMLServiceProvider) validateResponseAttributes(response *types.Response) error {\n\tif response.Destination != \"\" && response.Destination != sp.AssertionConsumerServiceURL {\n\t\treturn ErrInvalidValue{\n\t\t\tKey:      DestinationAttr,\n\t\t\tExpected: sp.AssertionConsumerServiceURL,\n\t\t\tActual:   response.Destination,\n\t\t}\n\t}\n\n\tif response.Version != \"2.0\" {\n\t\treturn ErrInvalidValue{\n\t\t\tReason:   ReasonUnsupported,\n\t\t\tKey:      \"SAML version\",\n\t\t\tExpected: \"2.0\",\n\t\t\tActual:   response.Version,\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// validateLogoutResponseAttributes validates a SAML Response's tag and attributes. It does\n// not inspect child elements of the Response at all.\nfunc (sp *SAMLServiceProvider) validateLogoutResponseAttributes(response *types.LogoutResponse) error {\n\tif response.Destination != \"\" && response.Destination != sp.ServiceProviderSLOURL {\n\t\treturn ErrInvalidValue{\n\t\t\tKey:      DestinationAttr,\n\t\t\tExpected: sp.ServiceProviderSLOURL,\n\t\t\tActual:   response.Destination,\n\t\t}\n\t}\n\n\tif response.Version != \"2.0\" {\n\t\treturn ErrInvalidValue{\n\t\t\tReason:   ReasonUnsupported,\n\t\t\tKey:      \"SAML version\",\n\t\t\tExpected: \"2.0\",\n\t\t\tActual:   response.Version,\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc xmlUnmarshalElement(el *etree.Element, obj interface{}) error {\n\tdoc := etree.NewDocument()\n\tdoc.SetRoot(el)\n\tdata, err := doc.WriteToBytes()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = xml.Unmarshal(data, obj)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (sp *SAMLServiceProvider) getDecryptCert() (*tls.Certificate, error) {\n\tif sp.SPKeyStore == nil {\n\t\treturn nil, fmt.Errorf(\"no decryption certs available\")\n\t}\n\n\t//This is the tls.Certificate we'll use to decrypt any encrypted assertions\n\tvar decryptCert tls.Certificate\n\n\tswitch crt := sp.SPKeyStore.(type) {\n\tcase dsig.TLSCertKeyStore:\n\t\t// Get the tls.Certificate directly if possible\n\t\tdecryptCert = tls.Certificate(crt)\n\n\tdefault:\n\n\t\t//Otherwise, construct one from the results of GetKeyPair\n\t\tpk, cert, err := sp.SPKeyStore.GetKeyPair()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error getting keypair: %v\", err)\n\t\t}\n\n\t\tdecryptCert = tls.Certificate{\n\t\t\tCertificate: [][]byte{cert},\n\t\t\tPrivateKey:  pk,\n\t\t}\n\t}\n\n\tif sp.ValidateEncryptionCert {\n\t\t// Check Validity period of certificate\n\t\tif len(decryptCert.Certificate) < 1 || len(decryptCert.Certificate[0]) < 1 {\n\t\t\treturn nil, fmt.Errorf(\"empty decryption cert\")\n\t\t} else if cert, err := x509.ParseCertificate(decryptCert.Certificate[0]); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid x509 decryption cert: %v\", err)\n\t\t} else {\n\t\t\tnow := sp.Clock.Now()\n\t\t\tif now.Before(cert.NotBefore) || now.After(cert.NotAfter) {\n\t\t\t\treturn nil, fmt.Errorf(\"decryption cert is not valid at this time\")\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &decryptCert, nil\n}\n\nfunc (sp *SAMLServiceProvider) decryptAssertions(el *etree.Element) error {\n\tvar decryptCert *tls.Certificate\n\n\tdecryptAssertion := func(ctx etreeutils.NSContext, encryptedElement *etree.Element) error {\n\t\tif encryptedElement.Parent() != el {\n\t\t\treturn fmt.Errorf(\"found encrypted assertion with unexpected parent element: %s\", encryptedElement.Parent().Tag)\n\t\t}\n\n\t\tdetached, err := etreeutils.NSDetatch(ctx, encryptedElement) // make a detached copy\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to detach encrypted assertion: %v\", err)\n\t\t}\n\n\t\tencryptedAssertion := &types.EncryptedAssertion{}\n\t\terr = xmlUnmarshalElement(detached, encryptedAssertion)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to unmarshal encrypted assertion: %v\", err)\n\t\t}\n\n\t\tif decryptCert == nil {\n\t\t\tdecryptCert, err = sp.getDecryptCert()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to get decryption certificate: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\traw, derr := encryptedAssertion.DecryptBytes(decryptCert)\n\t\tif derr != nil {\n\t\t\treturn fmt.Errorf(\"unable to decrypt encrypted assertion: %v\", derr)\n\t\t}\n\n\t\tdoc, _, err := parseResponse(raw, sp.MaximumDecompressedBodySize)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to create element from decrypted assertion bytes: %v\", err)\n\t\t}\n\n\t\t// Replace the original encrypted assertion with the decrypted one.\n\t\tif el.RemoveChild(encryptedElement) == nil {\n\t\t\t// Out of an abundance of caution, make sure removed worked\n\t\t\tpanic(\"unable to remove encrypted assertion\")\n\t\t}\n\n\t\tel.AddChild(doc.Root())\n\t\treturn nil\n\t}\n\n\tif err := etreeutils.NSFindIterate(el, SAMLAssertionNamespace, EncryptedAssertionTag, decryptAssertion); err != nil {\n\t\treturn err\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc (sp *SAMLServiceProvider) validateElementSignature(el *etree.Element) (*etree.Element, error) {\n\treturn sp.validationContext().Validate(el)\n}\n\nfunc (sp *SAMLServiceProvider) validateAssertionSignatures(el *etree.Element) error {\n\tsignedAssertions := 0\n\tunsignedAssertions := 0\n\tvalidateAssertion := func(ctx etreeutils.NSContext, unverifiedAssertion *etree.Element) error {\n\t\tparent := unverifiedAssertion.Parent()\n\t\tif parent == nil {\n\t\t\treturn fmt.Errorf(\"parent is nil\")\n\t\t}\n\t\tif parent != el {\n\t\t\treturn fmt.Errorf(\"found assertion with unexpected parent element: %s\", unverifiedAssertion.Parent().Tag)\n\t\t}\n\n\t\tdetached, err := etreeutils.NSDetatch(ctx, unverifiedAssertion) // make a detached copy\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to detach unverified assertion: %v\", err)\n\t\t}\n\n\t\tassertion, err := sp.validationContext().Validate(detached)\n\t\tif err == dsig.ErrMissingSignature {\n\t\t\tunsignedAssertions++\n\t\t\treturn nil\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Replace the original unverified Assertion with the verified one. Note that\n\t\t// if the Response is not signed, only signed Assertions (and not the parent Response) can be trusted.\n\t\tif el.RemoveChild(unverifiedAssertion) == nil {\n\t\t\t// Out of an abundance of caution, check to make sure an Assertion was actually\n\t\t\t// removed. If it wasn't a programming error has occurred.\n\t\t\tpanic(\"unable to remove assertion\")\n\t\t}\n\n\t\tel.AddChild(assertion)\n\t\tsignedAssertions++\n\n\t\treturn nil\n\t}\n\n\tif err := etreeutils.NSFindIterate(el, SAMLAssertionNamespace, AssertionTag, validateAssertion); err != nil {\n\t\treturn err\n\t} else if signedAssertions > 0 && unsignedAssertions > 0 {\n\t\treturn fmt.Errorf(\"invalid to have both signed and unsigned assertions\")\n\t} else if signedAssertions < 1 {\n\t\treturn dsig.ErrMissingSignature\n\t} else {\n\t\treturn nil\n\t}\n}\n\n// ValidateEncodedResponse both decodes and validates, based on SP\n// configuration, an encoded, signed response. It will also appropriately\n// decrypt a response if the assertion was encrypted\nfunc (sp *SAMLServiceProvider) ValidateEncodedResponse(encodedResponse string) (*types.Response, error) {\n\traw, err := base64.StdEncoding.DecodeString(encodedResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Parse the raw response\n\tdoc, el, err := parseResponse(raw, sp.MaximumDecompressedBodySize)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar responseSignatureValidated bool\n\tif !sp.SkipSignatureValidation {\n\t\tel, err = sp.validateElementSignature(el)\n\t\tif err == dsig.ErrMissingSignature {\n\t\t\t// Unfortunately we just blew away our Response\n\t\t\tel = doc.Root()\n\t\t} else if err != nil {\n\t\t\treturn nil, err\n\t\t} else if el == nil {\n\t\t\treturn nil, fmt.Errorf(\"missing transformed response\")\n\t\t} else {\n\t\t\tresponseSignatureValidated = true\n\t\t}\n\t}\n\n\terr = sp.decryptAssertions(el)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar assertionSignaturesValidated bool\n\tif !sp.SkipSignatureValidation {\n\t\terr = sp.validateAssertionSignatures(el)\n\t\tif err == dsig.ErrMissingSignature {\n\t\t\tif !responseSignatureValidated {\n\t\t\t\treturn nil, fmt.Errorf(\"response and/or assertions must be signed\")\n\t\t\t}\n\t\t} else if err != nil {\n\t\t\treturn nil, err\n\t\t} else {\n\t\t\tassertionSignaturesValidated = true\n\t\t}\n\t}\n\n\tdecodedResponse := &types.Response{}\n\terr = xmlUnmarshalElement(el, decodedResponse)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to unmarshal response: %v\", err)\n\t}\n\tdecodedResponse.SignatureValidated = responseSignatureValidated\n\tif assertionSignaturesValidated {\n\t\tfor idx := 0; idx < len(decodedResponse.Assertions); idx++ {\n\t\t\tdecodedResponse.Assertions[idx].SignatureValidated = true\n\t\t}\n\t}\n\n\terr = sp.Validate(decodedResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn decodedResponse, nil\n}\n\n// DecodeUnverifiedBaseResponse decodes several attributes from a SAML response for the purpose\n// of determining how to validate the response. This is useful for Service Providers which\n// expose a single Assertion Consumer Service URL but consume Responses from many IdPs.\nfunc DecodeUnverifiedBaseResponse(encodedResponse string) (*types.UnverifiedBaseResponse, error) {\n\traw, err := base64.StdEncoding.DecodeString(encodedResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response *types.UnverifiedBaseResponse\n\n\terr = maybeDeflate(raw, defaultMaxDecompressedResponseSize, func(maybeXML []byte) error {\n\t\tresponse = &types.UnverifiedBaseResponse{}\n\t\treturn xml.Unmarshal(maybeXML, response)\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}\n\n// maybeDeflate invokes the passed decoder over the passed data. If an error is\n// returned, it then attempts to deflate the passed data before re-invoking\n// the decoder over the deflated data.\nfunc maybeDeflate(data []byte, maxSize int64, decoder func([]byte) error) error {\n\terr := decoder(data)\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\t// Default to 5MB max size\n\tif maxSize == 0 {\n\t\tmaxSize = defaultMaxDecompressedResponseSize\n\t}\n\n\tlr := io.LimitReader(flate.NewReader(bytes.NewReader(data)), maxSize+1)\n\n\tdeflated, err := io.ReadAll(lr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif int64(len(deflated)) > maxSize {\n\t\treturn fmt.Errorf(\"deflated response exceeds maximum size of %d bytes\", maxSize)\n\t}\n\n\treturn decoder(deflated)\n}\n\n// parseResponse is a helper function that was refactored out so that the XML parsing behavior can be isolated and unit tested\nfunc parseResponse(xml []byte, maxSize int64) (*etree.Document, *etree.Element, error) {\n\tvar doc *etree.Document\n\tvar rawXML []byte\n\n\terr := maybeDeflate(xml, maxSize, func(xml []byte) error {\n\t\tdoc = etree.NewDocument()\n\t\trawXML = xml\n\t\treturn doc.ReadFromBytes(xml)\n\t})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tel := doc.Root()\n\tif el == nil {\n\t\treturn nil, nil, fmt.Errorf(\"unable to parse response\")\n\t}\n\n\t// Examine the response for attempts to exploit weaknesses in Go's encoding/xml\n\terr = rtvalidator.Validate(bytes.NewReader(rawXML))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn doc, el, nil\n}\n\n// DecodeUnverifiedLogoutResponse decodes several attributes from a SAML Logout response, without doing any verifications.\nfunc DecodeUnverifiedLogoutResponse(encodedResponse string) (*types.LogoutResponse, error) {\n\traw, err := base64.StdEncoding.DecodeString(encodedResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response *types.LogoutResponse\n\n\terr = maybeDeflate(raw, defaultMaxDecompressedResponseSize, func(maybeXML []byte) error {\n\t\tresponse = &types.LogoutResponse{}\n\t\treturn xml.Unmarshal(maybeXML, response)\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}\n\nfunc (sp *SAMLServiceProvider) ValidateEncodedLogoutResponsePOST(encodedResponse string) (*types.LogoutResponse, error) {\n\traw, err := base64.StdEncoding.DecodeString(encodedResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Parse the raw response\n\tdoc, el, err := parseResponse(raw, sp.MaximumDecompressedBodySize)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar responseSignatureValidated bool\n\tif !sp.SkipSignatureValidation {\n\t\tel, err = sp.validateElementSignature(el)\n\t\tif err == dsig.ErrMissingSignature {\n\t\t\t// Unfortunately we just blew away our Response\n\t\t\tel = doc.Root()\n\t\t} else if err != nil {\n\t\t\treturn nil, err\n\t\t} else if el == nil {\n\t\t\treturn nil, fmt.Errorf(\"missing transformed logout response\")\n\t\t} else {\n\t\t\tresponseSignatureValidated = true\n\t\t}\n\t}\n\n\tdecodedResponse := &types.LogoutResponse{}\n\terr = xmlUnmarshalElement(el, decodedResponse)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to unmarshal logout response: %v\", err)\n\t}\n\tdecodedResponse.SignatureValidated = responseSignatureValidated\n\n\terr = sp.ValidateDecodedLogoutResponse(decodedResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn decodedResponse, nil\n}\n", "// Copyright 2016 Russell Haering et al.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage saml2\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/pem\"\n\t\"io/ioutil\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/jonboulle/clockwork\"\n\trtvalidator \"github.com/mattermost/xml-roundtrip-validator\"\n\tdsig \"github.com/russellhaering/goxmldsig\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nconst (\n\tidpCert = `\n-----BEGIN CERTIFICATE-----\nMIIDODCCAiCgAwIBAgIUQH54kyyeacU69J2iwz9bzeLmMaswDQYJKoZIhvcNAQEL\nBQAwHTEbMBkGA1UEAwwSY29sbGVnZS5jY2N0Y2EuZWR1MB4XDTE1MDYwNDIyMTAz\nMVoXDTM1MDYwNDIyMTAzMVowHTEbMBkGA1UEAwwSY29sbGVnZS5jY2N0Y2EuZWR1\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlJhN20ng2VN/cTrWtqUI\nNaUsrHCkYXbm2y1PTN4b6fJI5hbvcv+LWCuLkLi3+iPGlBpcHHfrdJcyhmBHRHQ9\nSos3RIH5Lsn1IgjWe3hxQQmVeEi5xVxnw2YZGHaeX4YnI1TEBJwhtJmyitk74LHy\nbPGEqOJdApUnLz54L7I+252G/cOfEqUHMbxxtmHSc/9chF8bBxQ8OzIbJsByHnqi\nawQHwtsttre7n328gVqmf1VHE27cfAYiSjuK5pCsx/1kuJMBN+kg/3Gg9oi6aR50\nWX1VUF3IBcnTDeiAXRz3PgsT8FlVZou6Ik9NT/Y5IHOZVGk64SRDaG8FuGxLexXr\nswIDAQABo3AwbjAdBgNVHQ4EFgQUjQwaAoY3u/iToIE3ADeNEW+Uu34wTQYDVR0R\nBEYwRIISY29sbGVnZS5jY2N0Y2EuZWR1hi5odHRwczovL2NvbGxlZ2UuY2NjdGNh\nLmVkdTo4NDQzL2lkcC9zaGliYm9sZXRoMA0GCSqGSIb3DQEBCwUAA4IBAQB26rdx\nphN1YKad3yDhLg6Y1ZwbmAjc+l4QB1KSL+cLqhDn5iMy4VdWh8HpSKRqCwofLtlw\n3qOwospj+mJaguXRMpjYODRQaKRkTrCGxJhuNrQxDXL/b6FOEIJnUYenbPevuNgR\nJc1VnREhWUUXT44KN5YUz9FEiG0BsBK8ecCPKBzTQ/hwaczhpqw6uqVMqxJaTGcn\nlCUHJAhVHiA8lWJ7vaNPsJ86xBFs/F76EwyFXIKQaruvcvChU7GNNSYdNJBa6HO9\n9QWdGbr5aNQ4diunnBQdrdjgbQIwyhKTfbFWa2l5vbqEKDc0dwuPa6c25l8ruqxq\nCQ1CF8ZDDJ0XV6Ab\n-----END CERTIFICATE-----\n`\n\n\toktaCert = `\n-----BEGIN CERTIFICATE-----\nMIIDPDCCAiQCCQDydJgOlszqbzANBgkqhkiG9w0BAQUFADBgMQswCQYDVQQGEwJVUzETMB\nEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZyYW5jaXNjbzEQMA4GA1UEChMH\nSmFua3lDbzESMBAGA1UEAxMJbG9jYWxob3N0MB4XDTE0MDMxMjE5NDYzM1oXDTI3MTExOT\nE5NDYzM1owYDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcT\nDVNhbiBGcmFuY2lzY28xEDAOBgNVBAoTB0phbmt5Q28xEjAQBgNVBAMTCWxvY2FsaG9zdD\nCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMGvJpRTTasRUSPqcbqCG+ZnTAur\nnu0vVpIG9lzExnh11o/BGmzu7lB+yLHcEdwrKBBmpepDBPCYxpVajvuEhZdKFx/Fdy6j5m\nH3rrW0Bh/zd36CoUNjbbhHyTjeM7FN2yF3u9lcyubuvOzr3B3gX66IwJlU46+wzcQVhSOl\nMk2tXR+fIKQExFrOuK9tbX3JIBUqItpI+HnAow509CnM134svw8PTFLkR6/CcMqnDfDK1m\n993PyoC1Y+N4X9XkhSmEQoAlAHPI5LHrvuujM13nvtoVYvKYoj7ScgumkpWNEvX652LfXO\nnKYlkB8ZybuxmFfIkzedQrbJsyOhfL03cMECAwEAATANBgkqhkiG9w0BAQUFAAOCAQEAeH\nwzqwnzGEkxjzSD47imXaTqtYyETZow7XwBc0ZaFS50qRFJUgKTAmKS1xQBP/qHpStsROT3\n5DUxJAE6NY1Kbq3ZbCuhGoSlY0L7VzVT5tpu4EY8+Dq/u2EjRmmhoL7UkskvIZ2n1DdERt\nd+YUMTeqYl9co43csZwDno/IKomeN5qaPc39IZjikJ+nUC6kPFKeu/3j9rgHNlRtocI6S1\nFdtFz9OZMQlpr0JbUt2T3xS/YoQJn6coDmJL5GTiiKM6cOe+Ur1VwzS1JEDbSS2TWWhzq8\nojLdrotYLGd9JOsoQhElmz+tMfCFQUFLExinPAyy7YHlSiVX13QH2XTu/iQQ==\n-----END CERTIFICATE-----\n`\n\n\toktaCert2 = `\n-----BEGIN CERTIFICATE-----\nMIIDpDCCAoygAwIBAgIGAWxzAwX1MA0GCSqGSIb3DQEBCwUAMIGSMQswCQYDVQQGEwJVUzETMBEG\nA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNU2FuIEZyYW5jaXNjbzENMAsGA1UECgwET2t0YTEU\nMBIGA1UECwwLU1NPUHJvdmlkZXIxEzARBgNVBAMMCmRldi05MDUyNTExHDAaBgkqhkiG9w0BCQEW\nDWluZm9Ab2t0YS5jb20wHhcNMTkwODA4MjA1MzMzWhcNMjkwODA4MjA1NDMzWjCBkjELMAkGA1UE\nBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDVNhbiBGcmFuY2lzY28xDTALBgNV\nBAoMBE9rdGExFDASBgNVBAsMC1NTT1Byb3ZpZGVyMRMwEQYDVQQDDApkZXYtOTA1MjUxMRwwGgYJ\nKoZIhvcNAQkBFg1pbmZvQG9rdGEuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\nm+ZZF6aEG6ehLLIV6RPA+i1z6ss3HBG2bZD3efwKCDDXYUkp59AE7JsjVHMtpJPHhzHuScuHDMlu\nHmkBQTW7j9XpnaRn8SfZXkwlCUHTo+HAC9lwbQxO4d4wnwgnm6FAjm1I/gbfFAobd8BR9pDxHuXE\nMQ0DtQu/W3WbDUrz/bhSxPJAoVy2koQn9G0y3unm7eRwYWHeuW6GdPWV2szTtDS0c3qtUXVF5Ugg\niQYlwQu6xkfy4l8iGJL7ETa2BmJzwCFecMIct87SqNhYQwCBH54MBaHcaSsCKyimNvMY9B7RmC+H\n4+awePPA1q3R/UQ3Pfom8mx6yDdKIWqlkG3MsQIDAQABMA0GCSqGSIb3DQEBCwUAA4IBAQAiURCZ\nP4oJWcf1o5nm4yG15UH01g/S6Y4OUWMi6BFJy9fCrJ0h/2BZKi68SQ0uMAbdK6anxCzq3Rr5MSzW\nOWPQ1Zljn3LGPsiTFdFca/GVRen5IYQ7Dr2Mvhtm+QVscEY9TDjtETbTAHEVEjwXmB21wtdIhizv\nsQS7wz0A8LV+Atpbev45RiV6COmB6T6vJuFQ7ZsDZMSHZriTYiETTJvHBGd7PtbCxYNc6LRB2JDb\nwlekRhVEjR0UhnM+nn2sqqbv7tDEPs63lZSDXCnR1PhscHrEuQ04rHI3OL0gCULVQFvJrj85IAZF\n1QQuGUK8ozfOyFpQWAJUW71INnF/SLWv\n-----END CERTIFICATE-----\n`\n\n\tbadInput = `<saml2:Assertion ID=\"id1684056077776386493060641\"IssueInstant=\"2019-08-12T12:00:52.718Z\"Version=\"2.0\"xmlns:saml2=\"urn:oasis:names:tc:SAML:2.0:assertion\"xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"><saml2:Issuer Format=\"urn:oasis:names:tc:SAML:2.0:nameid-format:entity\"xmlns=\"\">http://www.okta.com/exk133onomIuOW98z357</l><ds:Signature xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"><ds:SignedInfo><ds:CanonicalizationMethod Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\"/><ds:SignatureMethod Algorithm=\"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\"/><ds:Reference URI=\"#id1684056077776386493060641\"><ds:Transforms><ds:Transform Algorithm=\"http://www.w3.org/2000/09/xmldsig#enveloped-signature\"/><ds:Transform Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\"><ec:InclusiveNamespaces PrefixList=\"xs\"xmlns:ec=\"http://www.w3.org/2001/10/xml-exc-c14n#\"/></m></s><ds:DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\"/><ds:DigestValue>dC1cm0pLLjIWZC6G2Pmf0JogmqHztp9W1euXPd/TUHo=</e></e></o><ds:SignatureValue>YRSCFLIkIgjbbYLyfCIc8jsP2MUJPjn+nYWRdlVIDdXtYXXxklYqdBXQsxDwNcsOAIGS75PeVGryml3oBkUDg/MfK7z/fFPLXX7c7xgh7/DBAFlSXbwlJQxuXQ5eZcGesgG6nYRwU1hpW+yN7C2ODN9KHi5TUdiEhvy8vdlFSfxdy4Mn68nG/UZBqmHHIZdRG2/Hpcs29YyaVVZUCZ0w22b7zsPuOXHuStOSTQ6isxI2R268+ZNKERYaNMCAGX4zNlT3mHBV0NnZkbO3wmlOfKksL+Qx7L64xFc3PaervxWuPqh2FoWpTCqFdliLdvUfFDszKXJKhO0bj1U0aSrdzg==</e><s><s><s></X></X></o></e><saml2:Subject xmlns=\"\"><saml2:NameID Format=\"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\">steven.james.johnstone@gmail.com</l><saml2:SubjectConfirmation Method=\"urn:oasis:names:tc:SAML:2.0:cm:bearer\"><saml2:SubjectConfirmationData InResponseTo=\"_40a419f5-5c1c-43d0-5834-5caf268a5f01\"NotOnOrAfter=\"2019-08-12T12:05:52.718Z\"Recipient=\"https://127.0.0.1/login\"/></l></l><saml2:Conditions NotBefore=\"2019-08-12T11:55:52.718Z\"NotOnOrAfter=\"2019-08-12T12:05:52.718Z\"xmlns=\"\"><saml2:AudienceRestriction><saml2:Audience>37a8eec1ce19687d132fe29051dca629d164e2c4958ba141d5f4133a33f0688f.jazznetworks.com</l></l></l><saml2:AuthnStatement AuthnInstant=\"2019-08-12T12:00:52.718Z\"SessionIndex=\"_40a419f5-5c1c-43d0-5834-5caf268a5f01\"xmlns=\"\"><saml2:AuthnContext><saml2:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport</l></l></l><saml2:AttributeStatement xmlns=\"\"><saml2:Attribute Name=\"FirstName\"NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified\"><saml2:AttributeValue xmlns=\"\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:type=\"xs:string\">Steven</l></l><saml2:Attribute Name=\"LastName\"NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified\"><saml2:AttributeValue xmlns=\"\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:type=\"xs:string\">Johnstone</l></l><saml2:Attribute Name=\"Email\"NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified\"><saml2:AttributeValue xmlns=\"\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:type=\"xs:string\">steven.james.johnstone@gmail.com`\n)\n\nfunc testEncryptedAssertion(t *testing.T, validateEncryptionCert bool) {\n\tvar err error\n\tcert, err := tls.LoadX509KeyPair(\"./testdata/test.crt\", \"./testdata/test.key\")\n\trequire.NoError(t, err, \"could not load x509 key pair\")\n\n\tblock, _ := pem.Decode([]byte(idpCert))\n\n\tidpCert, err := x509.ParseCertificate(block.Bytes)\n\trequire.NoError(t, err, \"couldn't parse idp cert pem block\")\n\n\tsp := SAMLServiceProvider{\n\t\tAssertionConsumerServiceURL: \"https://saml2.test.astuart.co/sso/saml2\",\n\t\tSPKeyStore:                  dsig.TLSCertKeyStore(cert),\n\t\tValidateEncryptionCert:      validateEncryptionCert,\n\t\tIDPCertificateStore: &dsig.MemoryX509CertificateStore{\n\t\t\tRoots: []*x509.Certificate{idpCert},\n\t\t},\n\t\tClock: dsig.NewFakeClockAt(time.Date(2016, 04, 28, 22, 00, 00, 00, time.UTC)),\n\t}\n\n\tbs, err := ioutil.ReadFile(\"./testdata/saml.post\")\n\trequire.NoError(t, err, \"couldn't read post\")\n\n\t_, err = sp.RetrieveAssertionInfo(string(bs))\n\tif validateEncryptionCert {\n\t\trequire.Error(t, err)\n\t\trequire.Equal(t, \"error validating response: unable to get decryption certificate: decryption cert is not valid at this time\", err.Error())\n\t} else {\n\t\trequire.NoError(t, err, \"Assertion info should be retrieved with no error\")\n\t}\n}\n\nfunc TestEncryptedAssertion(t *testing.T) {\n\ttestEncryptedAssertion(t, false)\n}\n\nfunc TestEncryptedAssertionInvalidCert(t *testing.T) {\n\ttestEncryptedAssertion(t, true)\n}\n\nfunc TestCompressedResponse(t *testing.T) {\n\tbs, err := ioutil.ReadFile(\"./testdata/saml_compressed.post\")\n\trequire.NoError(t, err, \"couldn't read compressed post\")\n\n\tblock, _ := pem.Decode([]byte(oktaCert))\n\n\tidpCert, err := x509.ParseCertificate(block.Bytes)\n\trequire.NoError(t, err, \"couldn't parse okta cert pem block\")\n\n\tsp := SAMLServiceProvider{\n\t\tAssertionConsumerServiceURL: \"https://f1f51ddc.ngrok.io/api/sso/saml2/acs/58cafd0573d4f375b8e70e8e\",\n\t\tSPKeyStore:                  dsig.TLSCertKeyStore(cert),\n\t\tIDPCertificateStore: &dsig.MemoryX509CertificateStore{\n\t\t\tRoots: []*x509.Certificate{idpCert},\n\t\t},\n\t\tClock: dsig.NewFakeClock(clockwork.NewFakeClockAt(time.Date(2017, 3, 17, 20, 00, 0, 0, time.UTC))),\n\t}\n\n\t_, err = sp.RetrieveAssertionInfo(string(bs))\n\trequire.NoError(t, err, \"Assertion info should be retrieved with no error\")\n}\n\nfunc TestDecodeColonsInLocalNames(t *testing.T) {\n\t// Handling of double colons was improved in Go 1.7 such that this test no longer fails.\n\t// See: https://go-review.googlesource.com/c/go/+/277892\n\tif rtvalidator.Validate(bytes.NewReader([]byte(`<x::Root/>`))) == nil {\n\t\tt.Skip()\n\t}\n\n\t_, _, err := parseResponse([]byte(`<x::Root/>`), 0)\n\trequire.Error(t, err)\n}\n\nfunc TestDecodeDoubleColonInjectionAttackResponse(t *testing.T) {\n\t// Handling of double colons was improved in Go 1.7 such that this test no longer fails.\n\t// See: https://go-review.googlesource.com/c/go/+/277892\n\tif rtvalidator.Validate(bytes.NewReader([]byte(`<x::Root/>`))) == nil {\n\t\tt.Skip()\n\t}\n\n\t_, _, err := parseResponse([]byte(doubleColonAssertionInjectionAttackResponse), 0)\n\trequire.Error(t, err)\n}\n\nfunc TestMalFormedInput(t *testing.T) {\n\tblock, _ := pem.Decode([]byte(oktaCert2))\n\tidpCert, err := x509.ParseCertificate(block.Bytes)\n\trequire.NoError(t, err, \"couldn't parse okta cert pem block\")\n\n\tcertStore := dsig.MemoryX509CertificateStore{\n\t\tRoots: []*x509.Certificate{idpCert},\n\t}\n\n\tsp := &SAMLServiceProvider{\n\t\tClock:                       dsig.NewFakeClock(clockwork.NewFakeClockAt(time.Date(2019, 8, 12, 12, 00, 52, 718, time.UTC))),\n\t\tAssertionConsumerServiceURL: \"https://saml2.test.astuart.co/sso/saml2\",\n\t\tSignAuthnRequests:           true,\n\t\tIDPCertificateStore:         &certStore,\n\t\tValidateEncryptionCert:      true,\n\t}\n\tbase64Input := base64.StdEncoding.EncodeToString([]byte(badInput))\n\t_, err = sp.RetrieveAssertionInfo(base64Input)\n\trequire.Errorf(t, err, \"parent is nil\")\n}\n\nfunc TestCompressionBombInput(t *testing.T) {\n\tbs, err := ioutil.ReadFile(\"./testdata/saml_compressed.post\")\n\trequire.NoError(t, err, \"couldn't read compressed post\")\n\n\tblock, _ := pem.Decode([]byte(oktaCert))\n\n\tidpCert, err := x509.ParseCertificate(block.Bytes)\n\trequire.NoError(t, err, \"couldn't parse okta cert pem block\")\n\n\tsp := SAMLServiceProvider{\n\t\tAssertionConsumerServiceURL: \"https://f1f51ddc.ngrok.io/api/sso/saml2/acs/58cafd0573d4f375b8e70e8e\",\n\t\tSPKeyStore:                  dsig.TLSCertKeyStore(cert),\n\t\tIDPCertificateStore: &dsig.MemoryX509CertificateStore{\n\t\t\tRoots: []*x509.Certificate{idpCert},\n\t\t},\n\t\tClock:                       dsig.NewFakeClock(clockwork.NewFakeClockAt(time.Date(2017, 3, 17, 20, 00, 0, 0, time.UTC))),\n\t\tMaximumDecompressedBodySize: 2048,\n\t}\n\n\t_, err = sp.RetrieveAssertionInfo(string(bs))\n\trequire.NoError(t, err, \"Assertion info should be retrieved with no error\")\n}\n", "// Copyright 2016 Russell Haering et al.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage saml2\n\nimport (\n\t\"encoding/base64\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/russellhaering/gosaml2/types\"\n\tdsig \"github.com/russellhaering/goxmldsig\"\n\tdsigtypes \"github.com/russellhaering/goxmldsig/types\"\n)\n\ntype ErrSaml struct {\n\tMessage string\n\tSystem  error\n}\n\nfunc (serr ErrSaml) Error() string {\n\tif serr.Message != \"\" {\n\t\treturn serr.Message\n\t}\n\treturn \"SAML error\"\n}\n\ntype SAMLServiceProvider struct {\n\tIdentityProviderSSOURL     string\n\tIdentityProviderSSOBinding string\n\tIdentityProviderSLOURL     string\n\tIdentityProviderSLOBinding string\n\tIdentityProviderIssuer     string\n\n\tAssertionConsumerServiceURL string\n\tServiceProviderSLOURL       string\n\tServiceProviderIssuer       string\n\n\tSignAuthnRequests              bool\n\tSignAuthnRequestsAlgorithm     string\n\tSignAuthnRequestsCanonicalizer dsig.Canonicalizer\n\n\t// ForceAuthn attribute in authentication request forces the identity provider to\n\t// re-authenticate the presenter directly rather than rely on a previous security context.\n\t// NOTE: If both ForceAuthn and IsPassive are \"true\", the identity provider MUST NOT freshly\n\t// authenticate the presenter unless the constraints of IsPassive can be met.\n\tForceAuthn bool\n\t// IsPassive attribute in authentication request requires that the identity provider and the\n\t// user agent itself MUST NOT visibly take control of the user interface from the requester\n\t// and interact with the presenter in a noticeable fashion.\n\tIsPassive bool\n\t// RequestedAuthnContext allows service providers to require that the identity\n\t// provider use specific authentication mechanisms. Leaving this unset will\n\t// permit the identity provider to choose the auth method. To maximize compatibility\n\t// with identity providers it is recommended to leave this unset.\n\tRequestedAuthnContext   *RequestedAuthnContext\n\tAudienceURI             string\n\tIDPCertificateStore     dsig.X509CertificateStore\n\tSPKeyStore              dsig.X509KeyStore // Required encryption key, default signing key\n\tSPSigningKeyStore       dsig.X509KeyStore // Optional signing key\n\tNameIdFormat            string\n\tValidateEncryptionCert  bool\n\tSkipSignatureValidation bool\n\tAllowMissingAttributes  bool\n\tClock                   *dsig.Clock\n\n\t// MaximumDecompressedBodySize is the maximum size to which a compressed\n\t// SAML document will be decompressed. If a compresed document is exceeds\n\t// this size during decompression an error will be returned.\n\tMaximumDecompressedBodySize int64\n\n\tsigningContextMu sync.RWMutex\n\tsigningContext   *dsig.SigningContext\n}\n\n// RequestedAuthnContext controls which authentication mechanisms are requested of\n// the identity provider. It is generally sufficient to omit this and let the\n// identity provider select an authentication mechansim.\ntype RequestedAuthnContext struct {\n\t// The RequestedAuthnContext comparison policy to use. See the section 3.3.2.2.1\n\t// of the SAML 2.0 specification for details. Constants named AuthnPolicyMatch*\n\t// contain standardized values.\n\tComparison string\n\n\t// Contexts will be passed as AuthnContextClassRefs. For example, to force password\n\t// authentication on some identity providers, Contexts should have a value of\n\t// []string{AuthnContextPasswordProtectedTransport}, and Comparison should have a\n\t// value of AuthnPolicyMatchExact.\n\tContexts []string\n}\n\nfunc (sp *SAMLServiceProvider) Metadata() (*types.EntityDescriptor, error) {\n\tkeyDescriptors := make([]types.KeyDescriptor, 0, 2)\n\tif sp.GetSigningKey() != nil {\n\t\tsigningCertBytes, err := sp.GetSigningCertBytes()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tkeyDescriptors = append(keyDescriptors, types.KeyDescriptor{\n\t\t\tUse: \"signing\",\n\t\t\tKeyInfo: dsigtypes.KeyInfo{\n\t\t\t\tX509Data: dsigtypes.X509Data{\n\t\t\t\t\tX509Certificates: []dsigtypes.X509Certificate{dsigtypes.X509Certificate{\n\t\t\t\t\t\tData: base64.StdEncoding.EncodeToString(signingCertBytes),\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t}\n\tif sp.GetEncryptionKey() != nil {\n\t\tencryptionCertBytes, err := sp.GetEncryptionCertBytes()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tkeyDescriptors = append(keyDescriptors, types.KeyDescriptor{\n\t\t\tUse: \"encryption\",\n\t\t\tKeyInfo: dsigtypes.KeyInfo{\n\t\t\t\tX509Data: dsigtypes.X509Data{\n\t\t\t\t\tX509Certificates: []dsigtypes.X509Certificate{dsigtypes.X509Certificate{\n\t\t\t\t\t\tData: base64.StdEncoding.EncodeToString(encryptionCertBytes),\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tEncryptionMethods: []types.EncryptionMethod{\n\t\t\t\t{Algorithm: types.MethodAES128GCM},\n\t\t\t\t{Algorithm: types.MethodAES192GCM},\n\t\t\t\t{Algorithm: types.MethodAES256GCM},\n\t\t\t\t{Algorithm: types.MethodAES128CBC},\n\t\t\t\t{Algorithm: types.MethodAES256CBC},\n\t\t\t},\n\t\t})\n\t}\n\treturn &types.EntityDescriptor{\n\t\tValidUntil: time.Now().UTC().Add(time.Hour * 24 * 7), // 7 days\n\t\tEntityID:   sp.ServiceProviderIssuer,\n\t\tSPSSODescriptor: &types.SPSSODescriptor{\n\t\t\tAuthnRequestsSigned:        sp.SignAuthnRequests,\n\t\t\tWantAssertionsSigned:       !sp.SkipSignatureValidation,\n\t\t\tProtocolSupportEnumeration: SAMLProtocolNamespace,\n\t\t\tKeyDescriptors:             keyDescriptors,\n\t\t\tAssertionConsumerServices: []types.IndexedEndpoint{{\n\t\t\t\tBinding:  BindingHttpPost,\n\t\t\t\tLocation: sp.AssertionConsumerServiceURL,\n\t\t\t\tIndex:    1,\n\t\t\t}},\n\t\t},\n\t}, nil\n}\n\nfunc (sp *SAMLServiceProvider) MetadataWithSLO(validityHours int64) (*types.EntityDescriptor, error) {\n\tsigningCertBytes, err := sp.GetSigningCertBytes()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tencryptionCertBytes, err := sp.GetEncryptionCertBytes()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif validityHours <= 0 {\n\t\t//By default let's keep it to 7 days.\n\t\tvalidityHours = int64(time.Hour * 24 * 7)\n\t}\n\n\treturn &types.EntityDescriptor{\n\t\tValidUntil: time.Now().UTC().Add(time.Duration(validityHours)), // default 7 days\n\t\tEntityID:   sp.ServiceProviderIssuer,\n\t\tSPSSODescriptor: &types.SPSSODescriptor{\n\t\t\tAuthnRequestsSigned:        sp.SignAuthnRequests,\n\t\t\tWantAssertionsSigned:       !sp.SkipSignatureValidation,\n\t\t\tProtocolSupportEnumeration: SAMLProtocolNamespace,\n\t\t\tKeyDescriptors: []types.KeyDescriptor{\n\t\t\t\t{\n\t\t\t\t\tUse: \"signing\",\n\t\t\t\t\tKeyInfo: dsigtypes.KeyInfo{\n\t\t\t\t\t\tX509Data: dsigtypes.X509Data{\n\t\t\t\t\t\t\tX509Certificates: []dsigtypes.X509Certificate{dsigtypes.X509Certificate{\n\t\t\t\t\t\t\t\tData: base64.StdEncoding.EncodeToString(signingCertBytes),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tUse: \"encryption\",\n\t\t\t\t\tKeyInfo: dsigtypes.KeyInfo{\n\t\t\t\t\t\tX509Data: dsigtypes.X509Data{\n\t\t\t\t\t\t\tX509Certificates: []dsigtypes.X509Certificate{dsigtypes.X509Certificate{\n\t\t\t\t\t\t\t\tData: base64.StdEncoding.EncodeToString(encryptionCertBytes),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tEncryptionMethods: []types.EncryptionMethod{\n\t\t\t\t\t\t{Algorithm: types.MethodAES128GCM, DigestMethod: nil},\n\t\t\t\t\t\t{Algorithm: types.MethodAES192GCM, DigestMethod: nil},\n\t\t\t\t\t\t{Algorithm: types.MethodAES256GCM, DigestMethod: nil},\n\t\t\t\t\t\t{Algorithm: types.MethodAES128CBC, DigestMethod: nil},\n\t\t\t\t\t\t{Algorithm: types.MethodAES256CBC, DigestMethod: nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tAssertionConsumerServices: []types.IndexedEndpoint{{\n\t\t\t\tBinding:  BindingHttpPost,\n\t\t\t\tLocation: sp.AssertionConsumerServiceURL,\n\t\t\t\tIndex:    1,\n\t\t\t}},\n\t\t\tSingleLogoutServices: []types.Endpoint{{\n\t\t\t\tBinding:  BindingHttpPost,\n\t\t\t\tLocation: sp.ServiceProviderSLOURL,\n\t\t\t}},\n\t\t},\n\t}, nil\n}\n\nfunc (sp *SAMLServiceProvider) GetEncryptionKey() dsig.X509KeyStore {\n\treturn sp.SPKeyStore\n}\n\nfunc (sp *SAMLServiceProvider) GetSigningKey() dsig.X509KeyStore {\n\tif sp.SPSigningKeyStore == nil {\n\t\treturn sp.GetEncryptionKey() // Default is signing key is same as encryption key\n\t}\n\treturn sp.SPSigningKeyStore\n}\n\nfunc (sp *SAMLServiceProvider) GetEncryptionCertBytes() ([]byte, error) {\n\tif _, encryptionCert, err := sp.GetEncryptionKey().GetKeyPair(); err != nil {\n\t\treturn nil, ErrSaml{Message: \"no SP encryption certificate\", System: err}\n\t} else if len(encryptionCert) < 1 {\n\t\treturn nil, ErrSaml{Message: \"empty SP encryption certificate\"}\n\t} else {\n\t\treturn encryptionCert, nil\n\t}\n}\n\nfunc (sp *SAMLServiceProvider) GetSigningCertBytes() ([]byte, error) {\n\tif _, signingCert, err := sp.GetSigningKey().GetKeyPair(); err != nil {\n\t\treturn nil, ErrSaml{Message: \"no SP signing certificate\", System: err}\n\t} else if len(signingCert) < 1 {\n\t\treturn nil, ErrSaml{Message: \"empty SP signing certificate\"}\n\t} else {\n\t\treturn signingCert, nil\n\t}\n}\n\nfunc (sp *SAMLServiceProvider) SigningContext() *dsig.SigningContext {\n\tsp.signingContextMu.RLock()\n\tsigningContext := sp.signingContext\n\tsp.signingContextMu.RUnlock()\n\n\tif signingContext != nil {\n\t\treturn signingContext\n\t}\n\n\tsp.signingContextMu.Lock()\n\tdefer sp.signingContextMu.Unlock()\n\n\tsp.signingContext = dsig.NewDefaultSigningContext(sp.GetSigningKey())\n\tsp.signingContext.SetSignatureMethod(sp.SignAuthnRequestsAlgorithm)\n\tif sp.SignAuthnRequestsCanonicalizer != nil {\n\t\tsp.signingContext.Canonicalizer = sp.SignAuthnRequestsCanonicalizer\n\t}\n\n\treturn sp.signingContext\n}\n\ntype ProxyRestriction struct {\n\tCount    int\n\tAudience []string\n}\n\ntype WarningInfo struct {\n\tOneTimeUse       bool\n\tProxyRestriction *ProxyRestriction\n\tNotInAudience    bool\n\tInvalidTime      bool\n}\n\ntype AssertionInfo struct {\n\tNameID                     string\n\tValues                     Values\n\tWarningInfo                *WarningInfo\n\tSessionIndex               string\n\tAuthnInstant               *time.Time\n\tSessionNotOnOrAfter        *time.Time\n\tAssertions                 []types.Assertion\n\tResponseSignatureValidated bool\n}\n", "// Copyright 2016 Russell Haering et al.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage saml2\n\nimport (\n\t\"bytes\"\n\t\"compress/flate\"\n\t\"crypto\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/pem\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"testing\"\n\n\t\"github.com/beevik/etree\"\n\t\"github.com/russellhaering/gosaml2/types\"\n\tdsig \"github.com/russellhaering/goxmldsig\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar cert tls.Certificate\nvar pk crypto.PrivateKey\n\nfunc init() {\n\tvar err error\n\tpfx := \"./testdata/test\"\n\tcert, err = tls.LoadX509KeyPair(fmt.Sprintf(\"%s.crt\", pfx), fmt.Sprintf(\"%s.key\", pfx))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tpk = cert.PrivateKey\n}\n\nfunc TestDecode(t *testing.T) {\n\tf, err := ioutil.ReadFile(\"./testdata/saml.post\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not open test file: %v\\n\", err)\n\t}\n\tdecoded := make([]byte, len(f))\n\n\tbase64.StdEncoding.Decode(decoded, f)\n\tresponse := &types.Response{}\n\n\terr = xml.Unmarshal(decoded, response)\n\tif err != nil {\n\t\tt.Fatalf(\"error decoding test saml: %v\", err)\n\t}\n\n\tea := response.EncryptedAssertions[0]\n\n\tk, err := ea.EncryptedKey.DecryptSymmetricKey(&cert)\n\tif err != nil {\n\t\tt.Fatalf(\"could not get symmetric key: %v\\n\", err)\n\t}\n\n\tif k == nil {\n\t\tt.Fatalf(\"no symmetric key\")\n\t}\n\n\tassertion, err := ea.Decrypt(&cert)\n\tif err != nil {\n\t\tt.Fatalf(\"error decrypting saml data: %v\\n\", err)\n\t}\n\n\tf2, err := ioutil.ReadFile(\"./testdata/saml.xml\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not read expected output\")\n\t}\n\n\texpected := &types.Assertion{}\n\terr = xml.Unmarshal(f2, expected)\n\n\trequire.EqualValues(t, expected, assertion, \"decrypted assertion did not match expectation\")\n}\n\nfunc signResponse(t *testing.T, resp string, sp *SAMLServiceProvider) string {\n\tdoc := etree.NewDocument()\n\terr := doc.ReadFromBytes([]byte(resp))\n\trequire.NoError(t, err)\n\n\tel := doc.Root()\n\n\t// Strip existing signatures\n\tsignatures := el.FindElements(\"//Signature\")\n\tfor _, sig := range signatures {\n\t\tparent := sig.Parent()\n\t\tparent.RemoveChild(sig)\n\t}\n\n\tel, err = sp.SigningContext().SignEnveloped(el)\n\trequire.NoError(t, err)\n\n\tdoc0 := etree.NewDocument()\n\tdoc0.SetRoot(el)\n\tdoc0.WriteSettings = etree.WriteSettings{\n\t\tCanonicalAttrVal: true,\n\t\tCanonicalEndTags: true,\n\t\tCanonicalText:    true,\n\t}\n\n\tstr, err := doc0.WriteToString()\n\trequire.NoError(t, err)\n\treturn str\n}\n\nfunc TestSAML(t *testing.T) {\n\tblock, _ := pem.Decode([]byte(idpCertificate))\n\trequire.NotEmpty(t, block)\n\tcert, err := x509.ParseCertificate(block.Bytes)\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, cert)\n\n\trandomKeyStore := dsig.RandomKeyStoreForTest()\n\t_, _cert, err := randomKeyStore.GetKeyPair()\n\n\tcert0, err := x509.ParseCertificate(_cert)\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, cert0)\n\n\tcertStore := dsig.MemoryX509CertificateStore{\n\t\tRoots: []*x509.Certificate{cert, cert0},\n\t}\n\n\tsp := &SAMLServiceProvider{\n\t\tIdentityProviderSSOURL:      \"https://dev-116807.oktapreview.com/app/scaleftdev116807_scaleft_1/exk5zt0r12Edi4rD20h7/sso/saml\",\n\t\tIdentityProviderIssuer:      \"http://www.okta.com/exk5zt0r12Edi4rD20h7\",\n\t\tAssertionConsumerServiceURL: \"http://localhost:8080/v1/_saml_callback\",\n\t\tSignAuthnRequests:           true,\n\t\tAudienceURI:                 \"123\",\n\t\tIDPCertificateStore:         &certStore,\n\t\tSPKeyStore:                  randomKeyStore,\n\t\tNameIdFormat:                NameIdFormatPersistent,\n\t}\n\n\tauthRequestURL, err := sp.BuildAuthURL(\"/some/link/here\")\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, authRequestURL)\n\n\tauthRequestString, err := sp.BuildAuthRequest()\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, authRequestString)\n\n\t// Note (Phoebe): The sample responses we acquired expired fairly quickly, meaning that our validation will fail\n\t// because we check the expiration time;\n\t// I've modified them to expire in ~100 years and removed their signatures, since those hash values are no longer\n\t// valid. We have to re-sign them here before validating them\n\traw := signResponse(t, rawResponse, sp)\n\n\tel, err := sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(raw)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, el)\n\n\tassertionInfo, err := sp.RetrieveAssertionInfo(base64.StdEncoding.EncodeToString([]byte(raw)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, assertionInfo)\n\trequire.NotNil(t, assertionInfo.WarningInfo) // always set when err == nil\n\trequire.False(t, assertionInfo.WarningInfo.OneTimeUse)\n\trequire.False(t, assertionInfo.WarningInfo.NotInAudience)\n\trequire.False(t, assertionInfo.WarningInfo.InvalidTime)\n\trequire.Nil(t, assertionInfo.WarningInfo.ProxyRestriction)\n\n\trequire.Equal(t, \"phoebe.simon@scaleft.com\", assertionInfo.NameID)\n\trequire.Equal(t, \"phoebe.simon@scaleft.com\", assertionInfo.Values.Get(\"Email\"))\n\trequire.Equal(t, \"Phoebe\", assertionInfo.Values.Get(\"FirstName\"))\n\trequire.Equal(t, \"Simon\", assertionInfo.Values.Get(\"LastName\"))\n\trequire.Equal(t, \"phoebesimon\", assertionInfo.Values.Get(\"Login\"))\n\n\tassertionInfoModifiedAudience := signResponse(t, assertionInfoModifiedAudienceResponse, sp)\n\n\tassertionInfo, err = sp.RetrieveAssertionInfo(base64.StdEncoding.EncodeToString([]byte(assertionInfoModifiedAudience)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, assertionInfo)\n\trequire.True(t, assertionInfo.WarningInfo.NotInAudience)\n\n\tassertionInfoOneTimeUse := signResponse(t, assertionInfoOneTimeUseResponse, sp)\n\n\tassertionInfo, err = sp.RetrieveAssertionInfo(base64.StdEncoding.EncodeToString([]byte(assertionInfoOneTimeUse)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, assertionInfo)\n\trequire.True(t, assertionInfo.WarningInfo.OneTimeUse)\n\n\tassertionInfoProxyRestriction := signResponse(t, assertionInfoProxyRestrictionResponse, sp)\n\n\tassertionInfo, err = sp.RetrieveAssertionInfo(base64.StdEncoding.EncodeToString([]byte(assertionInfoProxyRestriction)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, assertionInfo)\n\trequire.NotEmpty(t, assertionInfo.WarningInfo.ProxyRestriction)\n\trequire.Equal(t, 3, assertionInfo.WarningInfo.ProxyRestriction.Count)\n\trequire.Equal(t, []string{\"123\"}, assertionInfo.WarningInfo.ProxyRestriction.Audience)\n\n\tassertionInfoProxyRestrictionNoCount := signResponse(t, assertionInfoProxyRestrictionNoCountResponse, sp)\n\n\tassertionInfo, err = sp.RetrieveAssertionInfo(base64.StdEncoding.EncodeToString([]byte(assertionInfoProxyRestrictionNoCount)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, assertionInfo)\n\trequire.NotEmpty(t, assertionInfo.WarningInfo.ProxyRestriction)\n\trequire.Equal(t, 0, assertionInfo.WarningInfo.ProxyRestriction.Count)\n\trequire.Equal(t, []string{\"123\"}, assertionInfo.WarningInfo.ProxyRestriction.Audience)\n\n\tassertionInfoProxyRestrictionNoAudience := signResponse(t, assertionInfoProxyRestrictionNoAudienceResponse, sp)\n\n\tassertionInfo, err = sp.RetrieveAssertionInfo(base64.StdEncoding.EncodeToString([]byte(assertionInfoProxyRestrictionNoAudience)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, assertionInfo)\n\trequire.NotEmpty(t, assertionInfo.WarningInfo.ProxyRestriction)\n\trequire.Equal(t, 3, assertionInfo.WarningInfo.ProxyRestriction.Count)\n\trequire.Equal(t, []string{}, assertionInfo.WarningInfo.ProxyRestriction.Audience)\n\n\tassertionInfoResp := signResponse(t, assertionInfoResponse, sp)\n\n\tassertionInfo, err = sp.RetrieveAssertionInfo(base64.StdEncoding.EncodeToString([]byte(assertionInfoResp)))\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, assertionInfo)\n\trequire.NotEmpty(t, assertionInfo.Values)\n\trequire.Equal(t, \"phoebe.simon@scaleft.com\", assertionInfo.Values.Get(\"Email\"))\n\trequire.Equal(t, \"Phoebe\", assertionInfo.Values.Get(\"FirstName\"))\n\trequire.Equal(t, \"Simon\", assertionInfo.Values.Get(\"LastName\"))\n\trequire.Equal(t, \"phoebe.simon@scaleft.com\", assertionInfo.Values.Get(\"Login\"))\n\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(manInTheMiddledResponse)))\n\trequire.Error(t, err)\n\trequire.Equal(t, \"Signature could not be verified\", err.Error())\n\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(alteredReferenceURIResponse)))\n\trequire.Error(t, err)\n\t// require.IsType(t, ErrInvalidValue{}, err, err.Error())\n\trequire.Equal(t, \"Could not verify certificate against trusted certs\", err.Error())\n\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(alteredSignedInfoResponse)))\n\trequire.Error(t, err)\n\trequire.Equal(t, \"Could not verify certificate against trusted certs\", err.Error())\n\n\talteredRecipient := signResponse(t, alteredRecipientResponse, sp)\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(alteredRecipient)))\n\trequire.Error(t, err)\n\trequire.IsType(t, err, ErrInvalidValue{})\n\trequire.Contains(t, err.Error(), \"Recipient\")\n\n\talteredDestination := signResponse(t, alteredDestinationResponse, sp)\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(alteredDestination)))\n\trequire.Error(t, err)\n\trequire.IsType(t, err, ErrInvalidValue{})\n\trequire.Equal(t, err.(ErrInvalidValue).Key, \"Destination\")\n\n\talteredSubjectConfirmationMethod := signResponse(t, alteredSubjectConfirmationMethodResponse, sp)\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(alteredSubjectConfirmationMethod)))\n\trequire.Error(t, err)\n\trequire.IsType(t, err, ErrInvalidValue{})\n\trequire.Equal(t, err.(ErrInvalidValue).Reason, ReasonUnsupported)\n\trequire.Equal(t, err.(ErrInvalidValue).Key, SubjectConfirmationTag)\n\n\talteredVersion := signResponse(t, alteredVersionResponse, sp)\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(alteredVersion)))\n\trequire.Error(t, err)\n\trequire.IsType(t, err, ErrInvalidValue{})\n\trequire.Equal(t, err.(ErrInvalidValue).Reason, ReasonUnsupported)\n\trequire.Equal(t, err.(ErrInvalidValue).Key, \"SAML version\")\n\trequire.Contains(t, err.Error(), \"Unsupported SAML version\")\n\n\t_, err = sp.ValidateEncodedResponse(base64.StdEncoding.EncodeToString([]byte(missingIDResponse)))\n\trequire.Error(t, err)\n\trequire.Equal(t, \"Signature could not be verified\", err.Error())\n}\n\nfunc TestInvalidResponseBadBase64(t *testing.T) {\n\tsp := &SAMLServiceProvider{}\n\n\tresponse, err := sp.ValidateEncodedResponse(\"invalid-base64\")\n\trequire.EqualError(t, err, \"illegal base64 data at input byte 7\")\n\trequire.Nil(t, response)\n}\n\nfunc TestInvalidResponseBadCompression(t *testing.T) {\n\tsp := &SAMLServiceProvider{}\n\n\t// Value from: https://github.com/golang/go/blob/23416315060bf7601e5779c3a6a2529d4d604584/src/compress/flate/flate_test.go#L219\n\trawResponse, err := hex.DecodeString(\"33180700\")\n\trequire.NoError(t, err)\n\n\tb64Response := base64.StdEncoding.EncodeToString(rawResponse)\n\n\tresponse, err := sp.ValidateEncodedResponse(b64Response)\n\trequire.EqualError(t, err, \"flate: corrupt input before offset 3\")\n\trequire.Nil(t, response)\n}\n\nfunc TestInvalidResponseBadXML(t *testing.T) {\n\tsp := &SAMLServiceProvider{}\n\n\tcompressed := &bytes.Buffer{}\n\n\tcompressor, err := flate.NewWriter(compressed, flate.BestCompression)\n\trequire.NoError(t, err)\n\n\tcompressor.Write([]byte(\">Definitely&Invalid XML\"))\n\tcompressor.Close()\n\n\tb64Response := base64.StdEncoding.EncodeToString(compressed.Bytes())\n\n\tresponse, err := sp.ValidateEncodedResponse(b64Response)\n\trequire.EqualError(t, err, \"XML syntax error on line 1: invalid character entity &Invalid (no semicolon)\")\n\trequire.Nil(t, response)\n}\n\nfunc TestInvalidResponseNoElement(t *testing.T) {\n\tsp := &SAMLServiceProvider{}\n\n\tb64Response := base64.StdEncoding.EncodeToString([]byte(\"no-element-here\"))\n\n\tresponse, err := sp.ValidateEncodedResponse(b64Response)\n\trequire.EqualError(t, err, \"unable to parse response\")\n\trequire.Nil(t, response)\n}\nfunc TestSAMLCommentInjection(t *testing.T) {\n\t/*\n\t\tExplanation:\n\n\t\tSee: https://duo.com/blog/duo-finds-saml-vulnerabilities-affecting-multiple-implementations\n\n\t\tThe TLDR is that XML canonicalization may result in a different value being signed from the one being retrieved.\n\t\tThe target of this is the NameID in the Subject of the SAMLResponse Assertion\n\n\t\tExample:\n\t\t\t The following Subject\n\t\t\t ```<Subject>\n\t\t\t\t<NameID>user@user.com<!---->.evil.com</NameID>\n\t\t\t</Subject>```\n\t\t\twould get canonicalized to\n\t\t\t```\n\t\t\t<Subject>\n\t\t\t\t<NameID>user@user.com.evil.com</NameID>\n\t\t\t</Subject>\n\t\t\t```\n\t\t\tMany XML parsers have a behavior where they pull the first text element, so in the example with the comment, a vulnerable XML parser would return `user@user.com`, ignoring the text after the comment.\n\t\t\tKnowing this, a user (user@user.com.evil.com) can attack a vulnerable SP by manipulating their signed SAMLResponse with a comment that turns their username into another one.\n\t*/\n\n\t// To show that we are not vulnerable, we want to prove that we get the canonicalized value using our parser\n\t_, el, err := parseResponse([]byte(commentInjectionAttackResponse), 0)\n\trequire.NoError(t, err)\n\tdecodedResponse := &types.Response{}\n\terr = xmlUnmarshalElement(el, decodedResponse)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"phoebe.simon@scaleft.com.evil.com\", decodedResponse.Assertions[0].Subject.NameID.Value, \"The full, canonacalized NameID should be returned.\")\n}\n"], "filenames": ["decode_logout_request.go", "decode_response.go", "decode_response_test.go", "saml.go", "saml_test.go"], "buggy_code_start_loc": [52, 24, 28, 77, 356], "buggy_code_end_loc": [53, 417, 207, 79, 357], "fixing_code_start_loc": [52, 24, 28, 77, 356], "fixing_code_end_loc": [53, 432, 230, 85, 357], "type": "NVD-CWE-Other", "message": "gosaml2 is a Pure Go implementation of SAML 2.0. SAML Service Providers using this library for SAML authentication support are likely susceptible to Denial of Service attacks. A bug in this library enables attackers to craft a `deflate`-compressed request which will consume significantly more memory during processing than the size of the original request. This may eventually lead to memory exhaustion and the process being killed. The maximum compression ratio achievable with `deflate` is 1032:1, so by limiting the size of bodies passed to gosaml2, limiting the rate and concurrency of calls, and ensuring that lots of memory is available to the process it _may_ be possible to help Go's garbage collector \"keep up\". Implementors are encouraged not to rely on this. This issue is fixed in version 0.9.0.", "other": {"cve": {"id": "CVE-2023-26483", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-03T23:15:12.327", "lastModified": "2023-03-13T17:02:20.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "gosaml2 is a Pure Go implementation of SAML 2.0. SAML Service Providers using this library for SAML authentication support are likely susceptible to Denial of Service attacks. A bug in this library enables attackers to craft a `deflate`-compressed request which will consume significantly more memory during processing than the size of the original request. This may eventually lead to memory exhaustion and the process being killed. The maximum compression ratio achievable with `deflate` is 1032:1, so by limiting the size of bodies passed to gosaml2, limiting the rate and concurrency of calls, and ensuring that lots of memory is available to the process it _may_ be possible to help Go's garbage collector \"keep up\". Implementors are encouraged not to rely on this. This issue is fixed in version 0.9.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-409"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gosaml2_project:gosaml2:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.0", "matchCriteriaId": "3952C468-2CAE-4F88-8183-38E1C1250141"}]}]}], "references": [{"url": "https://github.com/russellhaering/gosaml2/commit/f9d66040241093e8702649baff50cc70d2c683c0", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/russellhaering/gosaml2/releases/tag/v0.9.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/russellhaering/gosaml2/security/advisories/GHSA-6gc3-crp7-25w5", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2023-1602", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/russellhaering/gosaml2/commit/f9d66040241093e8702649baff50cc70d2c683c0"}}