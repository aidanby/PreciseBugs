{"buggy_code": ["/*\n * Performance events core code:\n *\n *  Copyright (C) 2008 Thomas Gleixner <tglx@linutronix.de>\n *  Copyright (C) 2008-2011 Red Hat, Inc., Ingo Molnar\n *  Copyright (C) 2008-2011 Red Hat, Inc., Peter Zijlstra\n *  Copyright  \u00a9  2009 Paul Mackerras, IBM Corp. <paulus@au1.ibm.com>\n *\n * For licensing details see kernel-base/COPYING\n */\n\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/idr.h>\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <linux/tick.h>\n#include <linux/sysfs.h>\n#include <linux/dcache.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/reboot.h>\n#include <linux/vmstat.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/hardirq.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/kernel_stat.h>\n#include <linux/cgroup.h>\n#include <linux/perf_event.h>\n#include <linux/trace_events.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/mm_types.h>\n#include <linux/module.h>\n#include <linux/mman.h>\n#include <linux/compat.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n\n#include \"internal.h\"\n\n#include <asm/irq_regs.h>\n\ntypedef int (*remote_function_f)(void *);\n\nstruct remote_function_call {\n\tstruct task_struct\t*p;\n\tremote_function_f\tfunc;\n\tvoid\t\t\t*info;\n\tint\t\t\tret;\n};\n\nstatic void remote_function(void *data)\n{\n\tstruct remote_function_call *tfc = data;\n\tstruct task_struct *p = tfc->p;\n\n\tif (p) {\n\t\t/* -EAGAIN */\n\t\tif (task_cpu(p) != smp_processor_id())\n\t\t\treturn;\n\n\t\t/*\n\t\t * Now that we're on right CPU with IRQs disabled, we can test\n\t\t * if we hit the right task without races.\n\t\t */\n\n\t\ttfc->ret = -ESRCH; /* No such (running) process */\n\t\tif (p != current)\n\t\t\treturn;\n\t}\n\n\ttfc->ret = tfc->func(tfc->info);\n}\n\n/**\n * task_function_call - call a function on the cpu on which a task runs\n * @p:\t\tthe task to evaluate\n * @func:\tthe function to be called\n * @info:\tthe function call argument\n *\n * Calls the function @func when the task is currently running. This might\n * be on the current CPU, which just calls the function directly\n *\n * returns: @func return value, or\n *\t    -ESRCH  - when the process isn't running\n *\t    -EAGAIN - when the process moved away\n */\nstatic int\ntask_function_call(struct task_struct *p, remote_function_f func, void *info)\n{\n\tstruct remote_function_call data = {\n\t\t.p\t= p,\n\t\t.func\t= func,\n\t\t.info\t= info,\n\t\t.ret\t= -EAGAIN,\n\t};\n\tint ret;\n\n\tdo {\n\t\tret = smp_call_function_single(task_cpu(p), remote_function, &data, 1);\n\t\tif (!ret)\n\t\t\tret = data.ret;\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}\n\n/**\n * cpu_function_call - call a function on the cpu\n * @func:\tthe function to be called\n * @info:\tthe function call argument\n *\n * Calls the function @func on the remote cpu.\n *\n * returns: @func return value or -ENXIO when the cpu is offline\n */\nstatic int cpu_function_call(int cpu, remote_function_f func, void *info)\n{\n\tstruct remote_function_call data = {\n\t\t.p\t= NULL,\n\t\t.func\t= func,\n\t\t.info\t= info,\n\t\t.ret\t= -ENXIO, /* No such CPU */\n\t};\n\n\tsmp_call_function_single(cpu, remote_function, &data, 1);\n\n\treturn data.ret;\n}\n\nstatic inline struct perf_cpu_context *\n__get_cpu_context(struct perf_event_context *ctx)\n{\n\treturn this_cpu_ptr(ctx->pmu->pmu_cpu_context);\n}\n\nstatic void perf_ctx_lock(struct perf_cpu_context *cpuctx,\n\t\t\t  struct perf_event_context *ctx)\n{\n\traw_spin_lock(&cpuctx->ctx.lock);\n\tif (ctx)\n\t\traw_spin_lock(&ctx->lock);\n}\n\nstatic void perf_ctx_unlock(struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx)\n{\n\tif (ctx)\n\t\traw_spin_unlock(&ctx->lock);\n\traw_spin_unlock(&cpuctx->ctx.lock);\n}\n\n#define TASK_TOMBSTONE ((void *)-1L)\n\nstatic bool is_kernel_event(struct perf_event *event)\n{\n\treturn READ_ONCE(event->owner) == TASK_TOMBSTONE;\n}\n\n/*\n * On task ctx scheduling...\n *\n * When !ctx->nr_events a task context will not be scheduled. This means\n * we can disable the scheduler hooks (for performance) without leaving\n * pending task ctx state.\n *\n * This however results in two special cases:\n *\n *  - removing the last event from a task ctx; this is relatively straight\n *    forward and is done in __perf_remove_from_context.\n *\n *  - adding the first event to a task ctx; this is tricky because we cannot\n *    rely on ctx->is_active and therefore cannot use event_function_call().\n *    See perf_install_in_context().\n *\n * If ctx->nr_events, then ctx->is_active and cpuctx->task_ctx are set.\n */\n\ntypedef void (*event_f)(struct perf_event *, struct perf_cpu_context *,\n\t\t\tstruct perf_event_context *, void *);\n\nstruct event_function_struct {\n\tstruct perf_event *event;\n\tevent_f func;\n\tvoid *data;\n};\n\nstatic int event_function(void *info)\n{\n\tstruct event_function_struct *efs = info;\n\tstruct perf_event *event = efs->event;\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\tstruct perf_event_context *task_ctx = cpuctx->task_ctx;\n\tint ret = 0;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\n\tperf_ctx_lock(cpuctx, task_ctx);\n\t/*\n\t * Since we do the IPI call without holding ctx->lock things can have\n\t * changed, double check we hit the task we set out to hit.\n\t */\n\tif (ctx->task) {\n\t\tif (ctx->task != current) {\n\t\t\tret = -ESRCH;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t/*\n\t\t * We only use event_function_call() on established contexts,\n\t\t * and event_function() is only ever called when active (or\n\t\t * rather, we'll have bailed in task_function_call() or the\n\t\t * above ctx->task != current test), therefore we must have\n\t\t * ctx->is_active here.\n\t\t */\n\t\tWARN_ON_ONCE(!ctx->is_active);\n\t\t/*\n\t\t * And since we have ctx->is_active, cpuctx->task_ctx must\n\t\t * match.\n\t\t */\n\t\tWARN_ON_ONCE(task_ctx != ctx);\n\t} else {\n\t\tWARN_ON_ONCE(&cpuctx->ctx != ctx);\n\t}\n\n\tefs->func(event, cpuctx, ctx, efs->data);\nunlock:\n\tperf_ctx_unlock(cpuctx, task_ctx);\n\n\treturn ret;\n}\n\nstatic void event_function_call(struct perf_event *event, event_f func, void *data)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct task_struct *task = READ_ONCE(ctx->task); /* verified in event_function */\n\tstruct event_function_struct efs = {\n\t\t.event = event,\n\t\t.func = func,\n\t\t.data = data,\n\t};\n\n\tif (!event->parent) {\n\t\t/*\n\t\t * If this is a !child event, we must hold ctx::mutex to\n\t\t * stabilize the the event->ctx relation. See\n\t\t * perf_event_ctx_lock().\n\t\t */\n\t\tlockdep_assert_held(&ctx->mutex);\n\t}\n\n\tif (!task) {\n\t\tcpu_function_call(event->cpu, event_function, &efs);\n\t\treturn;\n\t}\n\n\tif (task == TASK_TOMBSTONE)\n\t\treturn;\n\nagain:\n\tif (!task_function_call(task, event_function, &efs))\n\t\treturn;\n\n\traw_spin_lock_irq(&ctx->lock);\n\t/*\n\t * Reload the task pointer, it might have been changed by\n\t * a concurrent perf_event_context_sched_out().\n\t */\n\ttask = ctx->task;\n\tif (task == TASK_TOMBSTONE) {\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\treturn;\n\t}\n\tif (ctx->is_active) {\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\tgoto again;\n\t}\n\tfunc(event, NULL, ctx, data);\n\traw_spin_unlock_irq(&ctx->lock);\n}\n\n/*\n * Similar to event_function_call() + event_function(), but hard assumes IRQs\n * are already disabled and we're on the right CPU.\n */\nstatic void event_function_local(struct perf_event *event, event_f func, void *data)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\tstruct task_struct *task = READ_ONCE(ctx->task);\n\tstruct perf_event_context *task_ctx = NULL;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\n\tif (task) {\n\t\tif (task == TASK_TOMBSTONE)\n\t\t\treturn;\n\n\t\ttask_ctx = ctx;\n\t}\n\n\tperf_ctx_lock(cpuctx, task_ctx);\n\n\ttask = ctx->task;\n\tif (task == TASK_TOMBSTONE)\n\t\tgoto unlock;\n\n\tif (task) {\n\t\t/*\n\t\t * We must be either inactive or active and the right task,\n\t\t * otherwise we're screwed, since we cannot IPI to somewhere\n\t\t * else.\n\t\t */\n\t\tif (ctx->is_active) {\n\t\t\tif (WARN_ON_ONCE(task != current))\n\t\t\t\tgoto unlock;\n\n\t\t\tif (WARN_ON_ONCE(cpuctx->task_ctx != ctx))\n\t\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tWARN_ON_ONCE(&cpuctx->ctx != ctx);\n\t}\n\n\tfunc(event, cpuctx, ctx, data);\nunlock:\n\tperf_ctx_unlock(cpuctx, task_ctx);\n}\n\n#define PERF_FLAG_ALL (PERF_FLAG_FD_NO_GROUP |\\\n\t\t       PERF_FLAG_FD_OUTPUT  |\\\n\t\t       PERF_FLAG_PID_CGROUP |\\\n\t\t       PERF_FLAG_FD_CLOEXEC)\n\n/*\n * branch priv levels that need permission checks\n */\n#define PERF_SAMPLE_BRANCH_PERM_PLM \\\n\t(PERF_SAMPLE_BRANCH_KERNEL |\\\n\t PERF_SAMPLE_BRANCH_HV)\n\nenum event_type_t {\n\tEVENT_FLEXIBLE = 0x1,\n\tEVENT_PINNED = 0x2,\n\tEVENT_TIME = 0x4,\n\tEVENT_ALL = EVENT_FLEXIBLE | EVENT_PINNED,\n};\n\n/*\n * perf_sched_events : >0 events exist\n * perf_cgroup_events: >0 per-cpu cgroup events exist on this cpu\n */\n\nstatic void perf_sched_delayed(struct work_struct *work);\nDEFINE_STATIC_KEY_FALSE(perf_sched_events);\nstatic DECLARE_DELAYED_WORK(perf_sched_work, perf_sched_delayed);\nstatic DEFINE_MUTEX(perf_sched_mutex);\nstatic atomic_t perf_sched_count;\n\nstatic DEFINE_PER_CPU(atomic_t, perf_cgroup_events);\nstatic DEFINE_PER_CPU(int, perf_sched_cb_usages);\nstatic DEFINE_PER_CPU(struct pmu_event_list, pmu_sb_events);\n\nstatic atomic_t nr_mmap_events __read_mostly;\nstatic atomic_t nr_comm_events __read_mostly;\nstatic atomic_t nr_task_events __read_mostly;\nstatic atomic_t nr_freq_events __read_mostly;\nstatic atomic_t nr_switch_events __read_mostly;\n\nstatic LIST_HEAD(pmus);\nstatic DEFINE_MUTEX(pmus_lock);\nstatic struct srcu_struct pmus_srcu;\n\n/*\n * perf event paranoia level:\n *  -1 - not paranoid at all\n *   0 - disallow raw tracepoint access for unpriv\n *   1 - disallow cpu events for unpriv\n *   2 - disallow kernel profiling for unpriv\n */\nint sysctl_perf_event_paranoid __read_mostly = 2;\n\n/* Minimum for 512 kiB + 1 user control page */\nint sysctl_perf_event_mlock __read_mostly = 512 + (PAGE_SIZE / 1024); /* 'free' kiB per user */\n\n/*\n * max perf event sample rate\n */\n#define DEFAULT_MAX_SAMPLE_RATE\t\t100000\n#define DEFAULT_SAMPLE_PERIOD_NS\t(NSEC_PER_SEC / DEFAULT_MAX_SAMPLE_RATE)\n#define DEFAULT_CPU_TIME_MAX_PERCENT\t25\n\nint sysctl_perf_event_sample_rate __read_mostly\t= DEFAULT_MAX_SAMPLE_RATE;\n\nstatic int max_samples_per_tick __read_mostly\t= DIV_ROUND_UP(DEFAULT_MAX_SAMPLE_RATE, HZ);\nstatic int perf_sample_period_ns __read_mostly\t= DEFAULT_SAMPLE_PERIOD_NS;\n\nstatic int perf_sample_allowed_ns __read_mostly =\n\tDEFAULT_SAMPLE_PERIOD_NS * DEFAULT_CPU_TIME_MAX_PERCENT / 100;\n\nstatic void update_perf_cpu_limits(void)\n{\n\tu64 tmp = perf_sample_period_ns;\n\n\ttmp *= sysctl_perf_cpu_time_max_percent;\n\ttmp = div_u64(tmp, 100);\n\tif (!tmp)\n\t\ttmp = 1;\n\n\tWRITE_ONCE(perf_sample_allowed_ns, tmp);\n}\n\nstatic int perf_rotate_context(struct perf_cpu_context *cpuctx);\n\nint perf_proc_update_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *lenp,\n\t\tloff_t *ppos)\n{\n\tint ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write)\n\t\treturn ret;\n\n\t/*\n\t * If throttling is disabled don't allow the write:\n\t */\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0)\n\t\treturn -EINVAL;\n\n\tmax_samples_per_tick = DIV_ROUND_UP(sysctl_perf_event_sample_rate, HZ);\n\tperf_sample_period_ns = NSEC_PER_SEC / sysctl_perf_event_sample_rate;\n\tupdate_perf_cpu_limits();\n\n\treturn 0;\n}\n\nint sysctl_perf_cpu_time_max_percent __read_mostly = DEFAULT_CPU_TIME_MAX_PERCENT;\n\nint perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp,\n\t\t\t\tloff_t *ppos)\n{\n\tint ret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write)\n\t\treturn ret;\n\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\n\treturn 0;\n}\n\n/*\n * perf samples are done in some very critical code paths (NMIs).\n * If they take too much CPU time, the system can lock up and not\n * get any real work done.  This will drop the sample rate when\n * we detect that events are taking too long.\n */\n#define NR_ACCUMULATED_SAMPLES 128\nstatic DEFINE_PER_CPU(u64, running_sample_length);\n\nstatic u64 __report_avg;\nstatic u64 __report_allowed;\n\nstatic void perf_duration_warn(struct irq_work *w)\n{\n\tprintk_ratelimited(KERN_INFO\n\t\t\"perf: interrupt took too long (%lld > %lld), lowering \"\n\t\t\"kernel.perf_event_max_sample_rate to %d\\n\",\n\t\t__report_avg, __report_allowed,\n\t\tsysctl_perf_event_sample_rate);\n}\n\nstatic DEFINE_IRQ_WORK(perf_duration_work, perf_duration_warn);\n\nvoid perf_sample_event_took(u64 sample_len_ns)\n{\n\tu64 max_len = READ_ONCE(perf_sample_allowed_ns);\n\tu64 running_len;\n\tu64 avg_len;\n\tu32 max;\n\n\tif (max_len == 0)\n\t\treturn;\n\n\t/* Decay the counter by 1 average sample. */\n\trunning_len = __this_cpu_read(running_sample_length);\n\trunning_len -= running_len/NR_ACCUMULATED_SAMPLES;\n\trunning_len += sample_len_ns;\n\t__this_cpu_write(running_sample_length, running_len);\n\n\t/*\n\t * Note: this will be biased artifically low until we have\n\t * seen NR_ACCUMULATED_SAMPLES. Doing it this way keeps us\n\t * from having to maintain a count.\n\t */\n\tavg_len = running_len/NR_ACCUMULATED_SAMPLES;\n\tif (avg_len <= max_len)\n\t\treturn;\n\n\t__report_avg = avg_len;\n\t__report_allowed = max_len;\n\n\t/*\n\t * Compute a throttle threshold 25% below the current duration.\n\t */\n\tavg_len += avg_len / 4;\n\tmax = (TICK_NSEC / 100) * sysctl_perf_cpu_time_max_percent;\n\tif (avg_len < max)\n\t\tmax /= (u32)avg_len;\n\telse\n\t\tmax = 1;\n\n\tWRITE_ONCE(perf_sample_allowed_ns, avg_len);\n\tWRITE_ONCE(max_samples_per_tick, max);\n\n\tsysctl_perf_event_sample_rate = max * HZ;\n\tperf_sample_period_ns = NSEC_PER_SEC / sysctl_perf_event_sample_rate;\n\n\tif (!irq_work_queue(&perf_duration_work)) {\n\t\tearly_printk(\"perf: interrupt took too long (%lld > %lld), lowering \"\n\t\t\t     \"kernel.perf_event_max_sample_rate to %d\\n\",\n\t\t\t     __report_avg, __report_allowed,\n\t\t\t     sysctl_perf_event_sample_rate);\n\t}\n}\n\nstatic atomic64_t perf_event_id;\n\nstatic void cpu_ctx_sched_out(struct perf_cpu_context *cpuctx,\n\t\t\t      enum event_type_t event_type);\n\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\n\nvoid __weak perf_event_print_debug(void)\t{ }\n\nextern __weak const char *perf_pmu_name(void)\n{\n\treturn \"pmu\";\n}\n\nstatic inline u64 perf_clock(void)\n{\n\treturn local_clock();\n}\n\nstatic inline u64 perf_event_clock(struct perf_event *event)\n{\n\treturn event->clock();\n}\n\n#ifdef CONFIG_CGROUP_PERF\n\nstatic inline bool\nperf_cgroup_match(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\n\t/* @event doesn't care about cgroup */\n\tif (!event->cgrp)\n\t\treturn true;\n\n\t/* wants specific cgroup scope but @cpuctx isn't associated with any */\n\tif (!cpuctx->cgrp)\n\t\treturn false;\n\n\t/*\n\t * Cgroup scoping is recursive.  An event enabled for a cgroup is\n\t * also enabled for all its descendant cgroups.  If @cpuctx's\n\t * cgroup is a descendant of @event's (the test covers identity\n\t * case), it's a match.\n\t */\n\treturn cgroup_is_descendant(cpuctx->cgrp->css.cgroup,\n\t\t\t\t    event->cgrp->css.cgroup);\n}\n\nstatic inline void perf_detach_cgroup(struct perf_event *event)\n{\n\tcss_put(&event->cgrp->css);\n\tevent->cgrp = NULL;\n}\n\nstatic inline int is_cgroup_event(struct perf_event *event)\n{\n\treturn event->cgrp != NULL;\n}\n\nstatic inline u64 perf_cgroup_event_time(struct perf_event *event)\n{\n\tstruct perf_cgroup_info *t;\n\n\tt = per_cpu_ptr(event->cgrp->info, event->cpu);\n\treturn t->time;\n}\n\nstatic inline void __update_cgrp_time(struct perf_cgroup *cgrp)\n{\n\tstruct perf_cgroup_info *info;\n\tu64 now;\n\n\tnow = perf_clock();\n\n\tinfo = this_cpu_ptr(cgrp->info);\n\n\tinfo->time += now - info->timestamp;\n\tinfo->timestamp = now;\n}\n\nstatic inline void update_cgrp_time_from_cpuctx(struct perf_cpu_context *cpuctx)\n{\n\tstruct perf_cgroup *cgrp_out = cpuctx->cgrp;\n\tif (cgrp_out)\n\t\t__update_cgrp_time(cgrp_out);\n}\n\nstatic inline void update_cgrp_time_from_event(struct perf_event *event)\n{\n\tstruct perf_cgroup *cgrp;\n\n\t/*\n\t * ensure we access cgroup data only when needed and\n\t * when we know the cgroup is pinned (css_get)\n\t */\n\tif (!is_cgroup_event(event))\n\t\treturn;\n\n\tcgrp = perf_cgroup_from_task(current, event->ctx);\n\t/*\n\t * Do not update time when cgroup is not active\n\t */\n\tif (cgrp == event->cgrp)\n\t\t__update_cgrp_time(event->cgrp);\n}\n\nstatic inline void\nperf_cgroup_set_timestamp(struct task_struct *task,\n\t\t\t  struct perf_event_context *ctx)\n{\n\tstruct perf_cgroup *cgrp;\n\tstruct perf_cgroup_info *info;\n\n\t/*\n\t * ctx->lock held by caller\n\t * ensure we do not access cgroup data\n\t * unless we have the cgroup pinned (css_get)\n\t */\n\tif (!task || !ctx->nr_cgroups)\n\t\treturn;\n\n\tcgrp = perf_cgroup_from_task(task, ctx);\n\tinfo = this_cpu_ptr(cgrp->info);\n\tinfo->timestamp = ctx->timestamp;\n}\n\n#define PERF_CGROUP_SWOUT\t0x1 /* cgroup switch out every event */\n#define PERF_CGROUP_SWIN\t0x2 /* cgroup switch in events based on task */\n\n/*\n * reschedule events based on the cgroup constraint of task.\n *\n * mode SWOUT : schedule out everything\n * mode SWIN : schedule in based on cgroup for next\n */\nstatic void perf_cgroup_switch(struct task_struct *task, int mode)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct pmu *pmu;\n\tunsigned long flags;\n\n\t/*\n\t * disable interrupts to avoid geting nr_cgroup\n\t * changes via __perf_event_disable(). Also\n\t * avoids preemption.\n\t */\n\tlocal_irq_save(flags);\n\n\t/*\n\t * we reschedule only in the presence of cgroup\n\t * constrained events.\n\t */\n\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = this_cpu_ptr(pmu->pmu_cpu_context);\n\t\tif (cpuctx->unique_pmu != pmu)\n\t\t\tcontinue; /* ensure we process each cpuctx once */\n\n\t\t/*\n\t\t * perf_cgroup_events says at least one\n\t\t * context on this CPU has cgroup events.\n\t\t *\n\t\t * ctx->nr_cgroups reports the number of cgroup\n\t\t * events for a context.\n\t\t */\n\t\tif (cpuctx->ctx.nr_cgroups > 0) {\n\t\t\tperf_ctx_lock(cpuctx, cpuctx->task_ctx);\n\t\t\tperf_pmu_disable(cpuctx->ctx.pmu);\n\n\t\t\tif (mode & PERF_CGROUP_SWOUT) {\n\t\t\t\tcpu_ctx_sched_out(cpuctx, EVENT_ALL);\n\t\t\t\t/*\n\t\t\t\t * must not be done before ctxswout due\n\t\t\t\t * to event_filter_match() in event_sched_out()\n\t\t\t\t */\n\t\t\t\tcpuctx->cgrp = NULL;\n\t\t\t}\n\n\t\t\tif (mode & PERF_CGROUP_SWIN) {\n\t\t\t\tWARN_ON_ONCE(cpuctx->cgrp);\n\t\t\t\t/*\n\t\t\t\t * set cgrp before ctxsw in to allow\n\t\t\t\t * event_filter_match() to not have to pass\n\t\t\t\t * task around\n\t\t\t\t * we pass the cpuctx->ctx to perf_cgroup_from_task()\n\t\t\t\t * because cgorup events are only per-cpu\n\t\t\t\t */\n\t\t\t\tcpuctx->cgrp = perf_cgroup_from_task(task, &cpuctx->ctx);\n\t\t\t\tcpu_ctx_sched_in(cpuctx, EVENT_ALL, task);\n\t\t\t}\n\t\t\tperf_pmu_enable(cpuctx->ctx.pmu);\n\t\t\tperf_ctx_unlock(cpuctx, cpuctx->task_ctx);\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}\n\nstatic inline void perf_cgroup_sched_out(struct task_struct *task,\n\t\t\t\t\t struct task_struct *next)\n{\n\tstruct perf_cgroup *cgrp1;\n\tstruct perf_cgroup *cgrp2 = NULL;\n\n\trcu_read_lock();\n\t/*\n\t * we come here when we know perf_cgroup_events > 0\n\t * we do not need to pass the ctx here because we know\n\t * we are holding the rcu lock\n\t */\n\tcgrp1 = perf_cgroup_from_task(task, NULL);\n\tcgrp2 = perf_cgroup_from_task(next, NULL);\n\n\t/*\n\t * only schedule out current cgroup events if we know\n\t * that we are switching to a different cgroup. Otherwise,\n\t * do no touch the cgroup events.\n\t */\n\tif (cgrp1 != cgrp2)\n\t\tperf_cgroup_switch(task, PERF_CGROUP_SWOUT);\n\n\trcu_read_unlock();\n}\n\nstatic inline void perf_cgroup_sched_in(struct task_struct *prev,\n\t\t\t\t\tstruct task_struct *task)\n{\n\tstruct perf_cgroup *cgrp1;\n\tstruct perf_cgroup *cgrp2 = NULL;\n\n\trcu_read_lock();\n\t/*\n\t * we come here when we know perf_cgroup_events > 0\n\t * we do not need to pass the ctx here because we know\n\t * we are holding the rcu lock\n\t */\n\tcgrp1 = perf_cgroup_from_task(task, NULL);\n\tcgrp2 = perf_cgroup_from_task(prev, NULL);\n\n\t/*\n\t * only need to schedule in cgroup events if we are changing\n\t * cgroup during ctxsw. Cgroup events were not scheduled\n\t * out of ctxsw out if that was not the case.\n\t */\n\tif (cgrp1 != cgrp2)\n\t\tperf_cgroup_switch(task, PERF_CGROUP_SWIN);\n\n\trcu_read_unlock();\n}\n\nstatic inline int perf_cgroup_connect(int fd, struct perf_event *event,\n\t\t\t\t      struct perf_event_attr *attr,\n\t\t\t\t      struct perf_event *group_leader)\n{\n\tstruct perf_cgroup *cgrp;\n\tstruct cgroup_subsys_state *css;\n\tstruct fd f = fdget(fd);\n\tint ret = 0;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tcss = css_tryget_online_from_dir(f.file->f_path.dentry,\n\t\t\t\t\t &perf_event_cgrp_subsys);\n\tif (IS_ERR(css)) {\n\t\tret = PTR_ERR(css);\n\t\tgoto out;\n\t}\n\n\tcgrp = container_of(css, struct perf_cgroup, css);\n\tevent->cgrp = cgrp;\n\n\t/*\n\t * all events in a group must monitor\n\t * the same cgroup because a task belongs\n\t * to only one perf cgroup at a time\n\t */\n\tif (group_leader && group_leader->cgrp != cgrp) {\n\t\tperf_detach_cgroup(event);\n\t\tret = -EINVAL;\n\t}\nout:\n\tfdput(f);\n\treturn ret;\n}\n\nstatic inline void\nperf_cgroup_set_shadow_time(struct perf_event *event, u64 now)\n{\n\tstruct perf_cgroup_info *t;\n\tt = per_cpu_ptr(event->cgrp->info, event->cpu);\n\tevent->shadow_ctx_time = now - t->timestamp;\n}\n\nstatic inline void\nperf_cgroup_defer_enabled(struct perf_event *event)\n{\n\t/*\n\t * when the current task's perf cgroup does not match\n\t * the event's, we need to remember to call the\n\t * perf_mark_enable() function the first time a task with\n\t * a matching perf cgroup is scheduled in.\n\t */\n\tif (is_cgroup_event(event) && !perf_cgroup_match(event))\n\t\tevent->cgrp_defer_enabled = 1;\n}\n\nstatic inline void\nperf_cgroup_mark_enabled(struct perf_event *event,\n\t\t\t struct perf_event_context *ctx)\n{\n\tstruct perf_event *sub;\n\tu64 tstamp = perf_event_time(event);\n\n\tif (!event->cgrp_defer_enabled)\n\t\treturn;\n\n\tevent->cgrp_defer_enabled = 0;\n\n\tevent->tstamp_enabled = tstamp - event->total_time_enabled;\n\tlist_for_each_entry(sub, &event->sibling_list, group_entry) {\n\t\tif (sub->state >= PERF_EVENT_STATE_INACTIVE) {\n\t\t\tsub->tstamp_enabled = tstamp - sub->total_time_enabled;\n\t\t\tsub->cgrp_defer_enabled = 0;\n\t\t}\n\t}\n}\n\n/*\n * Update cpuctx->cgrp so that it is set when first cgroup event is added and\n * cleared when last cgroup event is removed.\n */\nstatic inline void\nlist_update_cgroup_event(struct perf_event *event,\n\t\t\t struct perf_event_context *ctx, bool add)\n{\n\tstruct perf_cpu_context *cpuctx;\n\n\tif (!is_cgroup_event(event))\n\t\treturn;\n\n\tif (add && ctx->nr_cgroups++)\n\t\treturn;\n\telse if (!add && --ctx->nr_cgroups)\n\t\treturn;\n\t/*\n\t * Because cgroup events are always per-cpu events,\n\t * this will always be called from the right CPU.\n\t */\n\tcpuctx = __get_cpu_context(ctx);\n\n\t/*\n\t * cpuctx->cgrp is NULL until a cgroup event is sched in or\n\t * ctx->nr_cgroup == 0 .\n\t */\n\tif (add && perf_cgroup_from_task(current, ctx) == event->cgrp)\n\t\tcpuctx->cgrp = event->cgrp;\n\telse if (!add)\n\t\tcpuctx->cgrp = NULL;\n}\n\n#else /* !CONFIG_CGROUP_PERF */\n\nstatic inline bool\nperf_cgroup_match(struct perf_event *event)\n{\n\treturn true;\n}\n\nstatic inline void perf_detach_cgroup(struct perf_event *event)\n{}\n\nstatic inline int is_cgroup_event(struct perf_event *event)\n{\n\treturn 0;\n}\n\nstatic inline u64 perf_cgroup_event_cgrp_time(struct perf_event *event)\n{\n\treturn 0;\n}\n\nstatic inline void update_cgrp_time_from_event(struct perf_event *event)\n{\n}\n\nstatic inline void update_cgrp_time_from_cpuctx(struct perf_cpu_context *cpuctx)\n{\n}\n\nstatic inline void perf_cgroup_sched_out(struct task_struct *task,\n\t\t\t\t\t struct task_struct *next)\n{\n}\n\nstatic inline void perf_cgroup_sched_in(struct task_struct *prev,\n\t\t\t\t\tstruct task_struct *task)\n{\n}\n\nstatic inline int perf_cgroup_connect(pid_t pid, struct perf_event *event,\n\t\t\t\t      struct perf_event_attr *attr,\n\t\t\t\t      struct perf_event *group_leader)\n{\n\treturn -EINVAL;\n}\n\nstatic inline void\nperf_cgroup_set_timestamp(struct task_struct *task,\n\t\t\t  struct perf_event_context *ctx)\n{\n}\n\nvoid\nperf_cgroup_switch(struct task_struct *task, struct task_struct *next)\n{\n}\n\nstatic inline void\nperf_cgroup_set_shadow_time(struct perf_event *event, u64 now)\n{\n}\n\nstatic inline u64 perf_cgroup_event_time(struct perf_event *event)\n{\n\treturn 0;\n}\n\nstatic inline void\nperf_cgroup_defer_enabled(struct perf_event *event)\n{\n}\n\nstatic inline void\nperf_cgroup_mark_enabled(struct perf_event *event,\n\t\t\t struct perf_event_context *ctx)\n{\n}\n\nstatic inline void\nlist_update_cgroup_event(struct perf_event *event,\n\t\t\t struct perf_event_context *ctx, bool add)\n{\n}\n\n#endif\n\n/*\n * set default to be dependent on timer tick just\n * like original code\n */\n#define PERF_CPU_HRTIMER (1000 / HZ)\n/*\n * function must be called with interrupts disbled\n */\nstatic enum hrtimer_restart perf_mux_hrtimer_handler(struct hrtimer *hr)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tint rotations = 0;\n\n\tWARN_ON(!irqs_disabled());\n\n\tcpuctx = container_of(hr, struct perf_cpu_context, hrtimer);\n\trotations = perf_rotate_context(cpuctx);\n\n\traw_spin_lock(&cpuctx->hrtimer_lock);\n\tif (rotations)\n\t\thrtimer_forward_now(hr, cpuctx->hrtimer_interval);\n\telse\n\t\tcpuctx->hrtimer_active = 0;\n\traw_spin_unlock(&cpuctx->hrtimer_lock);\n\n\treturn rotations ? HRTIMER_RESTART : HRTIMER_NORESTART;\n}\n\nstatic void __perf_mux_hrtimer_init(struct perf_cpu_context *cpuctx, int cpu)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tu64 interval;\n\n\t/* no multiplexing needed for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn;\n\n\t/*\n\t * check default is sane, if not set then force to\n\t * default interval (1/tick)\n\t */\n\tinterval = pmu->hrtimer_interval_ms;\n\tif (interval < 1)\n\t\tinterval = pmu->hrtimer_interval_ms = PERF_CPU_HRTIMER;\n\n\tcpuctx->hrtimer_interval = ns_to_ktime(NSEC_PER_MSEC * interval);\n\n\traw_spin_lock_init(&cpuctx->hrtimer_lock);\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);\n\ttimer->function = perf_mux_hrtimer_handler;\n}\n\nstatic int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tunsigned long flags;\n\n\t/* not for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&cpuctx->hrtimer_lock, flags);\n\tif (!cpuctx->hrtimer_active) {\n\t\tcpuctx->hrtimer_active = 1;\n\t\thrtimer_forward_now(timer, cpuctx->hrtimer_interval);\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n\t}\n\traw_spin_unlock_irqrestore(&cpuctx->hrtimer_lock, flags);\n\n\treturn 0;\n}\n\nvoid perf_pmu_disable(struct pmu *pmu)\n{\n\tint *count = this_cpu_ptr(pmu->pmu_disable_count);\n\tif (!(*count)++)\n\t\tpmu->pmu_disable(pmu);\n}\n\nvoid perf_pmu_enable(struct pmu *pmu)\n{\n\tint *count = this_cpu_ptr(pmu->pmu_disable_count);\n\tif (!--(*count))\n\t\tpmu->pmu_enable(pmu);\n}\n\nstatic DEFINE_PER_CPU(struct list_head, active_ctx_list);\n\n/*\n * perf_event_ctx_activate(), perf_event_ctx_deactivate(), and\n * perf_event_task_tick() are fully serialized because they're strictly cpu\n * affine and perf_event_ctx{activate,deactivate} are called with IRQs\n * disabled, while perf_event_task_tick is called from IRQ context.\n */\nstatic void perf_event_ctx_activate(struct perf_event_context *ctx)\n{\n\tstruct list_head *head = this_cpu_ptr(&active_ctx_list);\n\n\tWARN_ON(!irqs_disabled());\n\n\tWARN_ON(!list_empty(&ctx->active_ctx_list));\n\n\tlist_add(&ctx->active_ctx_list, head);\n}\n\nstatic void perf_event_ctx_deactivate(struct perf_event_context *ctx)\n{\n\tWARN_ON(!irqs_disabled());\n\n\tWARN_ON(list_empty(&ctx->active_ctx_list));\n\n\tlist_del_init(&ctx->active_ctx_list);\n}\n\nstatic void get_ctx(struct perf_event_context *ctx)\n{\n\tWARN_ON(!atomic_inc_not_zero(&ctx->refcount));\n}\n\nstatic void free_ctx(struct rcu_head *head)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = container_of(head, struct perf_event_context, rcu_head);\n\tkfree(ctx->task_ctx_data);\n\tkfree(ctx);\n}\n\nstatic void put_ctx(struct perf_event_context *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tif (ctx->parent_ctx)\n\t\t\tput_ctx(ctx->parent_ctx);\n\t\tif (ctx->task && ctx->task != TASK_TOMBSTONE)\n\t\t\tput_task_struct(ctx->task);\n\t\tcall_rcu(&ctx->rcu_head, free_ctx);\n\t}\n}\n\n/*\n * Because of perf_event::ctx migration in sys_perf_event_open::move_group and\n * perf_pmu_migrate_context() we need some magic.\n *\n * Those places that change perf_event::ctx will hold both\n * perf_event_ctx::mutex of the 'old' and 'new' ctx value.\n *\n * Lock ordering is by mutex address. There are two other sites where\n * perf_event_context::mutex nests and those are:\n *\n *  - perf_event_exit_task_context()\t[ child , 0 ]\n *      perf_event_exit_event()\n *        put_event()\t\t\t[ parent, 1 ]\n *\n *  - perf_event_init_context()\t\t[ parent, 0 ]\n *      inherit_task_group()\n *        inherit_group()\n *          inherit_event()\n *            perf_event_alloc()\n *              perf_init_event()\n *                perf_try_init_event()\t[ child , 1 ]\n *\n * While it appears there is an obvious deadlock here -- the parent and child\n * nesting levels are inverted between the two. This is in fact safe because\n * life-time rules separate them. That is an exiting task cannot fork, and a\n * spawning task cannot (yet) exit.\n *\n * But remember that that these are parent<->child context relations, and\n * migration does not affect children, therefore these two orderings should not\n * interact.\n *\n * The change in perf_event::ctx does not affect children (as claimed above)\n * because the sys_perf_event_open() case will install a new event and break\n * the ctx parent<->child relation, and perf_pmu_migrate_context() is only\n * concerned with cpuctx and that doesn't have children.\n *\n * The places that change perf_event::ctx will issue:\n *\n *   perf_remove_from_context();\n *   synchronize_rcu();\n *   perf_install_in_context();\n *\n * to affect the change. The remove_from_context() + synchronize_rcu() should\n * quiesce the event, after which we can install it in the new location. This\n * means that only external vectors (perf_fops, prctl) can perturb the event\n * while in transit. Therefore all such accessors should also acquire\n * perf_event_context::mutex to serialize against this.\n *\n * However; because event->ctx can change while we're waiting to acquire\n * ctx->mutex we must be careful and use the below perf_event_ctx_lock()\n * function.\n *\n * Lock order:\n *    cred_guard_mutex\n *\ttask_struct::perf_event_mutex\n *\t  perf_event_context::mutex\n *\t    perf_event::child_mutex;\n *\t      perf_event_context::lock\n *\t    perf_event::mmap_mutex\n *\t    mmap_sem\n */\nstatic struct perf_event_context *\nperf_event_ctx_lock_nested(struct perf_event *event, int nesting)\n{\n\tstruct perf_event_context *ctx;\n\nagain:\n\trcu_read_lock();\n\tctx = ACCESS_ONCE(event->ctx);\n\tif (!atomic_inc_not_zero(&ctx->refcount)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\n\tmutex_lock_nested(&ctx->mutex, nesting);\n\tif (event->ctx != ctx) {\n\t\tmutex_unlock(&ctx->mutex);\n\t\tput_ctx(ctx);\n\t\tgoto again;\n\t}\n\n\treturn ctx;\n}\n\nstatic inline struct perf_event_context *\nperf_event_ctx_lock(struct perf_event *event)\n{\n\treturn perf_event_ctx_lock_nested(event, 0);\n}\n\nstatic void perf_event_ctx_unlock(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx)\n{\n\tmutex_unlock(&ctx->mutex);\n\tput_ctx(ctx);\n}\n\n/*\n * This must be done under the ctx->lock, such as to serialize against\n * context_equiv(), therefore we cannot call put_ctx() since that might end up\n * calling scheduler related locks and ctx->lock nests inside those.\n */\nstatic __must_check struct perf_event_context *\nunclone_ctx(struct perf_event_context *ctx)\n{\n\tstruct perf_event_context *parent_ctx = ctx->parent_ctx;\n\n\tlockdep_assert_held(&ctx->lock);\n\n\tif (parent_ctx)\n\t\tctx->parent_ctx = NULL;\n\tctx->generation++;\n\n\treturn parent_ctx;\n}\n\nstatic u32 perf_event_pid(struct perf_event *event, struct task_struct *p)\n{\n\t/*\n\t * only top level events have the pid namespace they were created in\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\treturn task_tgid_nr_ns(p, event->ns);\n}\n\nstatic u32 perf_event_tid(struct perf_event *event, struct task_struct *p)\n{\n\t/*\n\t * only top level events have the pid namespace they were created in\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\treturn task_pid_nr_ns(p, event->ns);\n}\n\n/*\n * If we inherit events we want to return the parent event id\n * to userspace.\n */\nstatic u64 primary_event_id(struct perf_event *event)\n{\n\tu64 id = event->id;\n\n\tif (event->parent)\n\t\tid = event->parent->id;\n\n\treturn id;\n}\n\n/*\n * Get the perf_event_context for a task and lock it.\n *\n * This has to cope with with the fact that until it is locked,\n * the context could get moved to another task.\n */\nstatic struct perf_event_context *\nperf_lock_task_context(struct task_struct *task, int ctxn, unsigned long *flags)\n{\n\tstruct perf_event_context *ctx;\n\nretry:\n\t/*\n\t * One of the few rules of preemptible RCU is that one cannot do\n\t * rcu_read_unlock() while holding a scheduler (or nested) lock when\n\t * part of the read side critical section was irqs-enabled -- see\n\t * rcu_read_unlock_special().\n\t *\n\t * Since ctx->lock nests under rq->lock we must ensure the entire read\n\t * side critical section has interrupts disabled.\n\t */\n\tlocal_irq_save(*flags);\n\trcu_read_lock();\n\tctx = rcu_dereference(task->perf_event_ctxp[ctxn]);\n\tif (ctx) {\n\t\t/*\n\t\t * If this context is a clone of another, it might\n\t\t * get swapped for another underneath us by\n\t\t * perf_event_task_sched_out, though the\n\t\t * rcu_read_lock() protects us from any context\n\t\t * getting freed.  Lock the context and check if it\n\t\t * got swapped before we could get the lock, and retry\n\t\t * if so.  If we locked the right context, then it\n\t\t * can't get swapped on us any more.\n\t\t */\n\t\traw_spin_lock(&ctx->lock);\n\t\tif (ctx != rcu_dereference(task->perf_event_ctxp[ctxn])) {\n\t\t\traw_spin_unlock(&ctx->lock);\n\t\t\trcu_read_unlock();\n\t\t\tlocal_irq_restore(*flags);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (ctx->task == TASK_TOMBSTONE ||\n\t\t    !atomic_inc_not_zero(&ctx->refcount)) {\n\t\t\traw_spin_unlock(&ctx->lock);\n\t\t\tctx = NULL;\n\t\t} else {\n\t\t\tWARN_ON_ONCE(ctx->task != task);\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (!ctx)\n\t\tlocal_irq_restore(*flags);\n\treturn ctx;\n}\n\n/*\n * Get the context for a task and increment its pin_count so it\n * can't get swapped to another task.  This also increments its\n * reference count so that the context can't get freed.\n */\nstatic struct perf_event_context *\nperf_pin_task_context(struct task_struct *task, int ctxn)\n{\n\tstruct perf_event_context *ctx;\n\tunsigned long flags;\n\n\tctx = perf_lock_task_context(task, ctxn, &flags);\n\tif (ctx) {\n\t\t++ctx->pin_count;\n\t\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n\t}\n\treturn ctx;\n}\n\nstatic void perf_unpin_context(struct perf_event_context *ctx)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ctx->lock, flags);\n\t--ctx->pin_count;\n\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n}\n\n/*\n * Update the record of the current time in a context.\n */\nstatic void update_context_time(struct perf_event_context *ctx)\n{\n\tu64 now = perf_clock();\n\n\tctx->time += now - ctx->timestamp;\n\tctx->timestamp = now;\n}\n\nstatic u64 perf_event_time(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\n\tif (is_cgroup_event(event))\n\t\treturn perf_cgroup_event_time(event);\n\n\treturn ctx ? ctx->time : 0;\n}\n\n/*\n * Update the total_time_enabled and total_time_running fields for a event.\n */\nstatic void update_event_times(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tu64 run_end;\n\n\tlockdep_assert_held(&ctx->lock);\n\n\tif (event->state < PERF_EVENT_STATE_INACTIVE ||\n\t    event->group_leader->state < PERF_EVENT_STATE_INACTIVE)\n\t\treturn;\n\n\t/*\n\t * in cgroup mode, time_enabled represents\n\t * the time the event was enabled AND active\n\t * tasks were in the monitored cgroup. This is\n\t * independent of the activity of the context as\n\t * there may be a mix of cgroup and non-cgroup events.\n\t *\n\t * That is why we treat cgroup events differently\n\t * here.\n\t */\n\tif (is_cgroup_event(event))\n\t\trun_end = perf_cgroup_event_time(event);\n\telse if (ctx->is_active)\n\t\trun_end = ctx->time;\n\telse\n\t\trun_end = event->tstamp_stopped;\n\n\tevent->total_time_enabled = run_end - event->tstamp_enabled;\n\n\tif (event->state == PERF_EVENT_STATE_INACTIVE)\n\t\trun_end = event->tstamp_stopped;\n\telse\n\t\trun_end = perf_event_time(event);\n\n\tevent->total_time_running = run_end - event->tstamp_running;\n\n}\n\n/*\n * Update total_time_enabled and total_time_running for all events in a group.\n */\nstatic void update_group_times(struct perf_event *leader)\n{\n\tstruct perf_event *event;\n\n\tupdate_event_times(leader);\n\tlist_for_each_entry(event, &leader->sibling_list, group_entry)\n\t\tupdate_event_times(event);\n}\n\nstatic struct list_head *\nctx_group_list(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tif (event->attr.pinned)\n\t\treturn &ctx->pinned_groups;\n\telse\n\t\treturn &ctx->flexible_groups;\n}\n\n/*\n * Add a event from the lists for its context.\n * Must be called with ctx->mutex and ctx->lock held.\n */\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tstruct list_head *list;\n\n\t\tevent->group_caps = event->event_caps;\n\n\t\tlist = ctx_group_list(event, ctx);\n\t\tlist_add_tail(&event->group_entry, list);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}\n\n/*\n * Initialize event state based on the perf_event_attr::disabled.\n */\nstatic inline void perf_event__state_init(struct perf_event *event)\n{\n\tevent->state = event->attr.disabled ? PERF_EVENT_STATE_OFF :\n\t\t\t\t\t      PERF_EVENT_STATE_INACTIVE;\n}\n\nstatic void __perf_event_read_size(struct perf_event *event, int nr_siblings)\n{\n\tint entry = sizeof(u64); /* value */\n\tint size = 0;\n\tint nr = 1;\n\n\tif (event->attr.read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)\n\t\tsize += sizeof(u64);\n\n\tif (event->attr.read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)\n\t\tsize += sizeof(u64);\n\n\tif (event->attr.read_format & PERF_FORMAT_ID)\n\t\tentry += sizeof(u64);\n\n\tif (event->attr.read_format & PERF_FORMAT_GROUP) {\n\t\tnr += nr_siblings;\n\t\tsize += sizeof(u64);\n\t}\n\n\tsize += entry * nr;\n\tevent->read_size = size;\n}\n\nstatic void __perf_event_header_size(struct perf_event *event, u64 sample_type)\n{\n\tstruct perf_sample_data *data;\n\tu16 size = 0;\n\n\tif (sample_type & PERF_SAMPLE_IP)\n\t\tsize += sizeof(data->ip);\n\n\tif (sample_type & PERF_SAMPLE_ADDR)\n\t\tsize += sizeof(data->addr);\n\n\tif (sample_type & PERF_SAMPLE_PERIOD)\n\t\tsize += sizeof(data->period);\n\n\tif (sample_type & PERF_SAMPLE_WEIGHT)\n\t\tsize += sizeof(data->weight);\n\n\tif (sample_type & PERF_SAMPLE_READ)\n\t\tsize += event->read_size;\n\n\tif (sample_type & PERF_SAMPLE_DATA_SRC)\n\t\tsize += sizeof(data->data_src.val);\n\n\tif (sample_type & PERF_SAMPLE_TRANSACTION)\n\t\tsize += sizeof(data->txn);\n\n\tevent->header_size = size;\n}\n\n/*\n * Called at perf_event creation and when events are attached/detached from a\n * group.\n */\nstatic void perf_event__header_size(struct perf_event *event)\n{\n\t__perf_event_read_size(event,\n\t\t\t       event->group_leader->nr_siblings);\n\t__perf_event_header_size(event, event->attr.sample_type);\n}\n\nstatic void perf_event__id_header_size(struct perf_event *event)\n{\n\tstruct perf_sample_data *data;\n\tu64 sample_type = event->attr.sample_type;\n\tu16 size = 0;\n\n\tif (sample_type & PERF_SAMPLE_TID)\n\t\tsize += sizeof(data->tid_entry);\n\n\tif (sample_type & PERF_SAMPLE_TIME)\n\t\tsize += sizeof(data->time);\n\n\tif (sample_type & PERF_SAMPLE_IDENTIFIER)\n\t\tsize += sizeof(data->id);\n\n\tif (sample_type & PERF_SAMPLE_ID)\n\t\tsize += sizeof(data->id);\n\n\tif (sample_type & PERF_SAMPLE_STREAM_ID)\n\t\tsize += sizeof(data->stream_id);\n\n\tif (sample_type & PERF_SAMPLE_CPU)\n\t\tsize += sizeof(data->cpu_entry);\n\n\tevent->id_header_size = size;\n}\n\nstatic bool perf_event_validate_size(struct perf_event *event)\n{\n\t/*\n\t * The values computed here will be over-written when we actually\n\t * attach the event.\n\t */\n\t__perf_event_read_size(event, event->group_leader->nr_siblings + 1);\n\t__perf_event_header_size(event, event->attr.sample_type & ~PERF_SAMPLE_READ);\n\tperf_event__id_header_size(event);\n\n\t/*\n\t * Sum the lot; should not exceed the 64k limit we have on records.\n\t * Conservative limit to allow for callchains and other variable fields.\n\t */\n\tif (event->read_size + event->header_size +\n\t    event->id_header_size + sizeof(struct perf_event_header) >= 16*1024)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void perf_group_attach(struct perf_event *event)\n{\n\tstruct perf_event *group_leader = event->group_leader, *pos;\n\n\t/*\n\t * We can have double attach due to group movement in perf_event_open.\n\t */\n\tif (event->attach_state & PERF_ATTACH_GROUP)\n\t\treturn;\n\n\tevent->attach_state |= PERF_ATTACH_GROUP;\n\n\tif (group_leader == event)\n\t\treturn;\n\n\tWARN_ON_ONCE(group_leader->ctx != event->ctx);\n\n\tgroup_leader->group_caps &= event->event_caps;\n\n\tlist_add_tail(&event->group_entry, &group_leader->sibling_list);\n\tgroup_leader->nr_siblings++;\n\n\tperf_event__header_size(group_leader);\n\n\tlist_for_each_entry(pos, &group_leader->sibling_list, group_entry)\n\t\tperf_event__header_size(pos);\n}\n\n/*\n * Remove a event from the lists for its context.\n * Must be called with ctx->mutex and ctx->lock held.\n */\nstatic void\nlist_del_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tWARN_ON_ONCE(event->ctx != ctx);\n\tlockdep_assert_held(&ctx->lock);\n\n\t/*\n\t * We can have double detach due to exit/hot-unplug + close.\n\t */\n\tif (!(event->attach_state & PERF_ATTACH_CONTEXT))\n\t\treturn;\n\n\tevent->attach_state &= ~PERF_ATTACH_CONTEXT;\n\n\tlist_update_cgroup_event(event, ctx, false);\n\n\tctx->nr_events--;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat--;\n\n\tlist_del_rcu(&event->event_entry);\n\n\tif (event->group_leader == event)\n\t\tlist_del_init(&event->group_entry);\n\n\tupdate_group_times(event);\n\n\t/*\n\t * If event was in error state, then keep it\n\t * that way, otherwise bogus counts will be\n\t * returned on read(). The only way to get out\n\t * of error state is by explicit re-enabling\n\t * of the event\n\t */\n\tif (event->state > PERF_EVENT_STATE_OFF)\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\n\tctx->generation++;\n}\n\nstatic void perf_group_detach(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *tmp;\n\tstruct list_head *list = NULL;\n\n\t/*\n\t * We can have double detach due to exit/hot-unplug + close.\n\t */\n\tif (!(event->attach_state & PERF_ATTACH_GROUP))\n\t\treturn;\n\n\tevent->attach_state &= ~PERF_ATTACH_GROUP;\n\n\t/*\n\t * If this is a sibling, remove it from its group.\n\t */\n\tif (event->group_leader != event) {\n\t\tlist_del_init(&event->group_entry);\n\t\tevent->group_leader->nr_siblings--;\n\t\tgoto out;\n\t}\n\n\tif (!list_empty(&event->group_entry))\n\t\tlist = &event->group_entry;\n\n\t/*\n\t * If this was a group event with sibling events then\n\t * upgrade the siblings to singleton events by adding them\n\t * to whatever list we are on.\n\t */\n\tlist_for_each_entry_safe(sibling, tmp, &event->sibling_list, group_entry) {\n\t\tif (list)\n\t\t\tlist_move_tail(&sibling->group_entry, list);\n\t\tsibling->group_leader = sibling;\n\n\t\t/* Inherit group flags from the previous leader */\n\t\tsibling->group_caps = event->group_caps;\n\n\t\tWARN_ON_ONCE(sibling->ctx != event->ctx);\n\t}\n\nout:\n\tperf_event__header_size(event->group_leader);\n\n\tlist_for_each_entry(tmp, &event->group_leader->sibling_list, group_entry)\n\t\tperf_event__header_size(tmp);\n}\n\nstatic bool is_orphaned_event(struct perf_event *event)\n{\n\treturn event->state == PERF_EVENT_STATE_DEAD;\n}\n\nstatic inline int __pmu_filter_match(struct perf_event *event)\n{\n\tstruct pmu *pmu = event->pmu;\n\treturn pmu->filter_match ? pmu->filter_match(event) : 1;\n}\n\n/*\n * Check whether we should attempt to schedule an event group based on\n * PMU-specific filtering. An event group can consist of HW and SW events,\n * potentially with a SW leader, so we must check all the filters, to\n * determine whether a group is schedulable:\n */\nstatic inline int pmu_filter_match(struct perf_event *event)\n{\n\tstruct perf_event *child;\n\n\tif (!__pmu_filter_match(event))\n\t\treturn 0;\n\n\tlist_for_each_entry(child, &event->sibling_list, group_entry) {\n\t\tif (!__pmu_filter_match(child))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic inline int\nevent_filter_match(struct perf_event *event)\n{\n\treturn (event->cpu == -1 || event->cpu == smp_processor_id()) &&\n\t       perf_cgroup_match(event) && pmu_filter_match(event);\n}\n\nstatic void\nevent_sched_out(struct perf_event *event,\n\t\t  struct perf_cpu_context *cpuctx,\n\t\t  struct perf_event_context *ctx)\n{\n\tu64 tstamp = perf_event_time(event);\n\tu64 delta;\n\n\tWARN_ON_ONCE(event->ctx != ctx);\n\tlockdep_assert_held(&ctx->lock);\n\n\t/*\n\t * An event which could not be activated because of\n\t * filter mismatch still needs to have its timings\n\t * maintained, otherwise bogus information is return\n\t * via read() for time_enabled, time_running:\n\t */\n\tif (event->state == PERF_EVENT_STATE_INACTIVE &&\n\t    !event_filter_match(event)) {\n\t\tdelta = tstamp - event->tstamp_stopped;\n\t\tevent->tstamp_running += delta;\n\t\tevent->tstamp_stopped = tstamp;\n\t}\n\n\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\treturn;\n\n\tperf_pmu_disable(event->pmu);\n\n\tevent->tstamp_stopped = tstamp;\n\tevent->pmu->del(event, 0);\n\tevent->oncpu = -1;\n\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\tif (event->pending_disable) {\n\t\tevent->pending_disable = 0;\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\t}\n\n\tif (!is_software_event(event))\n\t\tcpuctx->active_oncpu--;\n\tif (!--ctx->nr_active)\n\t\tperf_event_ctx_deactivate(ctx);\n\tif (event->attr.freq && event->attr.sample_freq)\n\t\tctx->nr_freq--;\n\tif (event->attr.exclusive || !cpuctx->active_oncpu)\n\t\tcpuctx->exclusive = 0;\n\n\tperf_pmu_enable(event->pmu);\n}\n\nstatic void\ngroup_sched_out(struct perf_event *group_event,\n\t\tstruct perf_cpu_context *cpuctx,\n\t\tstruct perf_event_context *ctx)\n{\n\tstruct perf_event *event;\n\tint state = group_event->state;\n\n\tperf_pmu_disable(ctx->pmu);\n\n\tevent_sched_out(group_event, cpuctx, ctx);\n\n\t/*\n\t * Schedule out siblings (if any):\n\t */\n\tlist_for_each_entry(event, &group_event->sibling_list, group_entry)\n\t\tevent_sched_out(event, cpuctx, ctx);\n\n\tperf_pmu_enable(ctx->pmu);\n\n\tif (state == PERF_EVENT_STATE_ACTIVE && group_event->attr.exclusive)\n\t\tcpuctx->exclusive = 0;\n}\n\n#define DETACH_GROUP\t0x01UL\n\n/*\n * Cross CPU call to remove a performance event\n *\n * We disable the event on the hardware level first. After that we\n * remove it from the context list.\n */\nstatic void\n__perf_remove_from_context(struct perf_event *event,\n\t\t\t   struct perf_cpu_context *cpuctx,\n\t\t\t   struct perf_event_context *ctx,\n\t\t\t   void *info)\n{\n\tunsigned long flags = (unsigned long)info;\n\n\tevent_sched_out(event, cpuctx, ctx);\n\tif (flags & DETACH_GROUP)\n\t\tperf_group_detach(event);\n\tlist_del_event(event, ctx);\n\n\tif (!ctx->nr_events && ctx->is_active) {\n\t\tctx->is_active = 0;\n\t\tif (ctx->task) {\n\t\t\tWARN_ON_ONCE(cpuctx->task_ctx != ctx);\n\t\t\tcpuctx->task_ctx = NULL;\n\t\t}\n\t}\n}\n\n/*\n * Remove the event from a task's (or a CPU's) list of events.\n *\n * If event->ctx is a cloned context, callers must make sure that\n * every task struct that event->ctx->task could possibly point to\n * remains valid.  This is OK when called from perf_release since\n * that only calls us on the top-level context, which can't be a clone.\n * When called from perf_event_exit_task, it's OK because the\n * context has been detached from its task.\n */\nstatic void perf_remove_from_context(struct perf_event *event, unsigned long flags)\n{\n\tlockdep_assert_held(&event->ctx->mutex);\n\n\tevent_function_call(event, __perf_remove_from_context, (void *)flags);\n}\n\n/*\n * Cross CPU call to disable a performance event\n */\nstatic void __perf_event_disable(struct perf_event *event,\n\t\t\t\t struct perf_cpu_context *cpuctx,\n\t\t\t\t struct perf_event_context *ctx,\n\t\t\t\t void *info)\n{\n\tif (event->state < PERF_EVENT_STATE_INACTIVE)\n\t\treturn;\n\n\tupdate_context_time(ctx);\n\tupdate_cgrp_time_from_event(event);\n\tupdate_group_times(event);\n\tif (event == event->group_leader)\n\t\tgroup_sched_out(event, cpuctx, ctx);\n\telse\n\t\tevent_sched_out(event, cpuctx, ctx);\n\tevent->state = PERF_EVENT_STATE_OFF;\n}\n\n/*\n * Disable a event.\n *\n * If event->ctx is a cloned context, callers must make sure that\n * every task struct that event->ctx->task could possibly point to\n * remains valid.  This condition is satisifed when called through\n * perf_event_for_each_child or perf_event_for_each because they\n * hold the top-level event's child_mutex, so any descendant that\n * goes to exit will block in perf_event_exit_event().\n *\n * When called from perf_pending_event it's OK because event->ctx\n * is the current context on this CPU and preemption is disabled,\n * hence we can't get into perf_event_task_sched_out for this context.\n */\nstatic void _perf_event_disable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\n\traw_spin_lock_irq(&ctx->lock);\n\tif (event->state <= PERF_EVENT_STATE_OFF) {\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\treturn;\n\t}\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tevent_function_call(event, __perf_event_disable, NULL);\n}\n\nvoid perf_event_disable_local(struct perf_event *event)\n{\n\tevent_function_local(event, __perf_event_disable, NULL);\n}\n\n/*\n * Strictly speaking kernel users cannot create groups and therefore this\n * interface does not need the perf_event_ctx_lock() magic.\n */\nvoid perf_event_disable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = perf_event_ctx_lock(event);\n\t_perf_event_disable(event);\n\tperf_event_ctx_unlock(event, ctx);\n}\nEXPORT_SYMBOL_GPL(perf_event_disable);\n\nvoid perf_event_disable_inatomic(struct perf_event *event)\n{\n\tevent->pending_disable = 1;\n\tirq_work_queue(&event->pending);\n}\n\nstatic void perf_set_shadow_time(struct perf_event *event,\n\t\t\t\t struct perf_event_context *ctx,\n\t\t\t\t u64 tstamp)\n{\n\t/*\n\t * use the correct time source for the time snapshot\n\t *\n\t * We could get by without this by leveraging the\n\t * fact that to get to this function, the caller\n\t * has most likely already called update_context_time()\n\t * and update_cgrp_time_xx() and thus both timestamp\n\t * are identical (or very close). Given that tstamp is,\n\t * already adjusted for cgroup, we could say that:\n\t *    tstamp - ctx->timestamp\n\t * is equivalent to\n\t *    tstamp - cgrp->timestamp.\n\t *\n\t * Then, in perf_output_read(), the calculation would\n\t * work with no changes because:\n\t * - event is guaranteed scheduled in\n\t * - no scheduled out in between\n\t * - thus the timestamp would be the same\n\t *\n\t * But this is a bit hairy.\n\t *\n\t * So instead, we have an explicit cgroup call to remain\n\t * within the time time source all along. We believe it\n\t * is cleaner and simpler to understand.\n\t */\n\tif (is_cgroup_event(event))\n\t\tperf_cgroup_set_shadow_time(event, tstamp);\n\telse\n\t\tevent->shadow_ctx_time = tstamp - ctx->timestamp;\n}\n\n#define MAX_INTERRUPTS (~0ULL)\n\nstatic void perf_log_throttle(struct perf_event *event, int enable);\nstatic void perf_log_itrace_start(struct perf_event *event);\n\nstatic int\nevent_sched_in(struct perf_event *event,\n\t\t struct perf_cpu_context *cpuctx,\n\t\t struct perf_event_context *ctx)\n{\n\tu64 tstamp = perf_event_time(event);\n\tint ret = 0;\n\n\tlockdep_assert_held(&ctx->lock);\n\n\tif (event->state <= PERF_EVENT_STATE_OFF)\n\t\treturn 0;\n\n\tWRITE_ONCE(event->oncpu, smp_processor_id());\n\t/*\n\t * Order event::oncpu write to happen before the ACTIVE state\n\t * is visible.\n\t */\n\tsmp_wmb();\n\tWRITE_ONCE(event->state, PERF_EVENT_STATE_ACTIVE);\n\n\t/*\n\t * Unthrottle events, since we scheduled we might have missed several\n\t * ticks already, also for a heavily scheduling task there is little\n\t * guarantee it'll get a tick in a timely manner.\n\t */\n\tif (unlikely(event->hw.interrupts == MAX_INTERRUPTS)) {\n\t\tperf_log_throttle(event, 1);\n\t\tevent->hw.interrupts = 0;\n\t}\n\n\t/*\n\t * The new state must be visible before we turn it on in the hardware:\n\t */\n\tsmp_wmb();\n\n\tperf_pmu_disable(event->pmu);\n\n\tperf_set_shadow_time(event, ctx, tstamp);\n\n\tperf_log_itrace_start(event);\n\n\tif (event->pmu->add(event, PERF_EF_START)) {\n\t\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\t\tevent->oncpu = -1;\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tevent->tstamp_running += tstamp - event->tstamp_stopped;\n\n\tif (!is_software_event(event))\n\t\tcpuctx->active_oncpu++;\n\tif (!ctx->nr_active++)\n\t\tperf_event_ctx_activate(ctx);\n\tif (event->attr.freq && event->attr.sample_freq)\n\t\tctx->nr_freq++;\n\n\tif (event->attr.exclusive)\n\t\tcpuctx->exclusive = 1;\n\nout:\n\tperf_pmu_enable(event->pmu);\n\n\treturn ret;\n}\n\nstatic int\ngroup_sched_in(struct perf_event *group_event,\n\t       struct perf_cpu_context *cpuctx,\n\t       struct perf_event_context *ctx)\n{\n\tstruct perf_event *event, *partial_group = NULL;\n\tstruct pmu *pmu = ctx->pmu;\n\tu64 now = ctx->time;\n\tbool simulate = false;\n\n\tif (group_event->state == PERF_EVENT_STATE_OFF)\n\t\treturn 0;\n\n\tpmu->start_txn(pmu, PERF_PMU_TXN_ADD);\n\n\tif (event_sched_in(group_event, cpuctx, ctx)) {\n\t\tpmu->cancel_txn(pmu);\n\t\tperf_mux_hrtimer_restart(cpuctx);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Schedule in siblings as one group (if any):\n\t */\n\tlist_for_each_entry(event, &group_event->sibling_list, group_entry) {\n\t\tif (event_sched_in(event, cpuctx, ctx)) {\n\t\t\tpartial_group = event;\n\t\t\tgoto group_error;\n\t\t}\n\t}\n\n\tif (!pmu->commit_txn(pmu))\n\t\treturn 0;\n\ngroup_error:\n\t/*\n\t * Groups can be scheduled in as one unit only, so undo any\n\t * partial group before returning:\n\t * The events up to the failed event are scheduled out normally,\n\t * tstamp_stopped will be updated.\n\t *\n\t * The failed events and the remaining siblings need to have\n\t * their timings updated as if they had gone thru event_sched_in()\n\t * and event_sched_out(). This is required to get consistent timings\n\t * across the group. This also takes care of the case where the group\n\t * could never be scheduled by ensuring tstamp_stopped is set to mark\n\t * the time the event was actually stopped, such that time delta\n\t * calculation in update_event_times() is correct.\n\t */\n\tlist_for_each_entry(event, &group_event->sibling_list, group_entry) {\n\t\tif (event == partial_group)\n\t\t\tsimulate = true;\n\n\t\tif (simulate) {\n\t\t\tevent->tstamp_running += now - event->tstamp_stopped;\n\t\t\tevent->tstamp_stopped = now;\n\t\t} else {\n\t\t\tevent_sched_out(event, cpuctx, ctx);\n\t\t}\n\t}\n\tevent_sched_out(group_event, cpuctx, ctx);\n\n\tpmu->cancel_txn(pmu);\n\n\tperf_mux_hrtimer_restart(cpuctx);\n\n\treturn -EAGAIN;\n}\n\n/*\n * Work out whether we can put this event group on the CPU now.\n */\nstatic int group_can_go_on(struct perf_event *event,\n\t\t\t   struct perf_cpu_context *cpuctx,\n\t\t\t   int can_add_hw)\n{\n\t/*\n\t * Groups consisting entirely of software events can always go on.\n\t */\n\tif (event->group_caps & PERF_EV_CAP_SOFTWARE)\n\t\treturn 1;\n\t/*\n\t * If an exclusive group is already on, no other hardware\n\t * events can go on.\n\t */\n\tif (cpuctx->exclusive)\n\t\treturn 0;\n\t/*\n\t * If this group is exclusive and there are already\n\t * events on the CPU, it can't go on.\n\t */\n\tif (event->attr.exclusive && cpuctx->active_oncpu)\n\t\treturn 0;\n\t/*\n\t * Otherwise, try to add it if all previous groups were able\n\t * to go on.\n\t */\n\treturn can_add_hw;\n}\n\nstatic void add_event_to_ctx(struct perf_event *event,\n\t\t\t       struct perf_event_context *ctx)\n{\n\tu64 tstamp = perf_event_time(event);\n\n\tlist_add_event(event, ctx);\n\tperf_group_attach(event);\n\tevent->tstamp_enabled = tstamp;\n\tevent->tstamp_running = tstamp;\n\tevent->tstamp_stopped = tstamp;\n}\n\nstatic void ctx_sched_out(struct perf_event_context *ctx,\n\t\t\t  struct perf_cpu_context *cpuctx,\n\t\t\t  enum event_type_t event_type);\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);\n\nstatic void task_ctx_sched_out(struct perf_cpu_context *cpuctx,\n\t\t\t       struct perf_event_context *ctx)\n{\n\tif (!cpuctx->task_ctx)\n\t\treturn;\n\n\tif (WARN_ON_ONCE(ctx != cpuctx->task_ctx))\n\t\treturn;\n\n\tctx_sched_out(ctx, cpuctx, EVENT_ALL);\n}\n\nstatic void perf_event_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t\tstruct perf_event_context *ctx,\n\t\t\t\tstruct task_struct *task)\n{\n\tcpu_ctx_sched_in(cpuctx, EVENT_PINNED, task);\n\tif (ctx)\n\t\tctx_sched_in(ctx, cpuctx, EVENT_PINNED, task);\n\tcpu_ctx_sched_in(cpuctx, EVENT_FLEXIBLE, task);\n\tif (ctx)\n\t\tctx_sched_in(ctx, cpuctx, EVENT_FLEXIBLE, task);\n}\n\nstatic void ctx_resched(struct perf_cpu_context *cpuctx,\n\t\t\tstruct perf_event_context *task_ctx)\n{\n\tperf_pmu_disable(cpuctx->ctx.pmu);\n\tif (task_ctx)\n\t\ttask_ctx_sched_out(cpuctx, task_ctx);\n\tcpu_ctx_sched_out(cpuctx, EVENT_ALL);\n\tperf_event_sched_in(cpuctx, task_ctx, current);\n\tperf_pmu_enable(cpuctx->ctx.pmu);\n}\n\n/*\n * Cross CPU call to install and enable a performance event\n *\n * Very similar to remote_function() + event_function() but cannot assume that\n * things like ctx->is_active and cpuctx->task_ctx are set.\n */\nstatic int  __perf_install_in_context(void *info)\n{\n\tstruct perf_event *event = info;\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\tstruct perf_event_context *task_ctx = cpuctx->task_ctx;\n\tbool reprogram = true;\n\tint ret = 0;\n\n\traw_spin_lock(&cpuctx->ctx.lock);\n\tif (ctx->task) {\n\t\traw_spin_lock(&ctx->lock);\n\t\ttask_ctx = ctx;\n\n\t\treprogram = (ctx->task == current);\n\n\t\t/*\n\t\t * If the task is running, it must be running on this CPU,\n\t\t * otherwise we cannot reprogram things.\n\t\t *\n\t\t * If its not running, we don't care, ctx->lock will\n\t\t * serialize against it becoming runnable.\n\t\t */\n\t\tif (task_curr(ctx->task) && !reprogram) {\n\t\t\tret = -ESRCH;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tWARN_ON_ONCE(reprogram && cpuctx->task_ctx && cpuctx->task_ctx != ctx);\n\t} else if (task_ctx) {\n\t\traw_spin_lock(&task_ctx->lock);\n\t}\n\n\tif (reprogram) {\n\t\tctx_sched_out(ctx, cpuctx, EVENT_TIME);\n\t\tadd_event_to_ctx(event, ctx);\n\t\tctx_resched(cpuctx, task_ctx);\n\t} else {\n\t\tadd_event_to_ctx(event, ctx);\n\t}\n\nunlock:\n\tperf_ctx_unlock(cpuctx, task_ctx);\n\n\treturn ret;\n}\n\n/*\n * Attach a performance event to a context.\n *\n * Very similar to event_function_call, see comment there.\n */\nstatic void\nperf_install_in_context(struct perf_event_context *ctx,\n\t\t\tstruct perf_event *event,\n\t\t\tint cpu)\n{\n\tstruct task_struct *task = READ_ONCE(ctx->task);\n\n\tlockdep_assert_held(&ctx->mutex);\n\n\tif (event->cpu != -1)\n\t\tevent->cpu = cpu;\n\n\t/*\n\t * Ensures that if we can observe event->ctx, both the event and ctx\n\t * will be 'complete'. See perf_iterate_sb_cpu().\n\t */\n\tsmp_store_release(&event->ctx, ctx);\n\n\tif (!task) {\n\t\tcpu_function_call(cpu, __perf_install_in_context, event);\n\t\treturn;\n\t}\n\n\t/*\n\t * Should not happen, we validate the ctx is still alive before calling.\n\t */\n\tif (WARN_ON_ONCE(task == TASK_TOMBSTONE))\n\t\treturn;\n\n\t/*\n\t * Installing events is tricky because we cannot rely on ctx->is_active\n\t * to be set in case this is the nr_events 0 -> 1 transition.\n\t *\n\t * Instead we use task_curr(), which tells us if the task is running.\n\t * However, since we use task_curr() outside of rq::lock, we can race\n\t * against the actual state. This means the result can be wrong.\n\t *\n\t * If we get a false positive, we retry, this is harmless.\n\t *\n\t * If we get a false negative, things are complicated. If we are after\n\t * perf_event_context_sched_in() ctx::lock will serialize us, and the\n\t * value must be correct. If we're before, it doesn't matter since\n\t * perf_event_context_sched_in() will program the counter.\n\t *\n\t * However, this hinges on the remote context switch having observed\n\t * our task->perf_event_ctxp[] store, such that it will in fact take\n\t * ctx::lock in perf_event_context_sched_in().\n\t *\n\t * We do this by task_function_call(), if the IPI fails to hit the task\n\t * we know any future context switch of task must see the\n\t * perf_event_ctpx[] store.\n\t */\n\n\t/*\n\t * This smp_mb() orders the task->perf_event_ctxp[] store with the\n\t * task_cpu() load, such that if the IPI then does not find the task\n\t * running, a future context switch of that task must observe the\n\t * store.\n\t */\n\tsmp_mb();\nagain:\n\tif (!task_function_call(task, __perf_install_in_context, event))\n\t\treturn;\n\n\traw_spin_lock_irq(&ctx->lock);\n\ttask = ctx->task;\n\tif (WARN_ON_ONCE(task == TASK_TOMBSTONE)) {\n\t\t/*\n\t\t * Cannot happen because we already checked above (which also\n\t\t * cannot happen), and we hold ctx->mutex, which serializes us\n\t\t * against perf_event_exit_task_context().\n\t\t */\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\treturn;\n\t}\n\t/*\n\t * If the task is not running, ctx->lock will avoid it becoming so,\n\t * thus we can safely install the event.\n\t */\n\tif (task_curr(task)) {\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\tgoto again;\n\t}\n\tadd_event_to_ctx(event, ctx);\n\traw_spin_unlock_irq(&ctx->lock);\n}\n\n/*\n * Put a event into inactive state and update time fields.\n * Enabling the leader of a group effectively enables all\n * the group members that aren't explicitly disabled, so we\n * have to update their ->tstamp_enabled also.\n * Note: this works for group members as well as group leaders\n * since the non-leader members' sibling_lists will be empty.\n */\nstatic void __perf_event_mark_enabled(struct perf_event *event)\n{\n\tstruct perf_event *sub;\n\tu64 tstamp = perf_event_time(event);\n\n\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\tevent->tstamp_enabled = tstamp - event->total_time_enabled;\n\tlist_for_each_entry(sub, &event->sibling_list, group_entry) {\n\t\tif (sub->state >= PERF_EVENT_STATE_INACTIVE)\n\t\t\tsub->tstamp_enabled = tstamp - sub->total_time_enabled;\n\t}\n}\n\n/*\n * Cross CPU call to enable a performance event\n */\nstatic void __perf_event_enable(struct perf_event *event,\n\t\t\t\tstruct perf_cpu_context *cpuctx,\n\t\t\t\tstruct perf_event_context *ctx,\n\t\t\t\tvoid *info)\n{\n\tstruct perf_event *leader = event->group_leader;\n\tstruct perf_event_context *task_ctx;\n\n\tif (event->state >= PERF_EVENT_STATE_INACTIVE ||\n\t    event->state <= PERF_EVENT_STATE_ERROR)\n\t\treturn;\n\n\tif (ctx->is_active)\n\t\tctx_sched_out(ctx, cpuctx, EVENT_TIME);\n\n\t__perf_event_mark_enabled(event);\n\n\tif (!ctx->is_active)\n\t\treturn;\n\n\tif (!event_filter_match(event)) {\n\t\tif (is_cgroup_event(event))\n\t\t\tperf_cgroup_defer_enabled(event);\n\t\tctx_sched_in(ctx, cpuctx, EVENT_TIME, current);\n\t\treturn;\n\t}\n\n\t/*\n\t * If the event is in a group and isn't the group leader,\n\t * then don't put it on unless the group is on.\n\t */\n\tif (leader != event && leader->state != PERF_EVENT_STATE_ACTIVE) {\n\t\tctx_sched_in(ctx, cpuctx, EVENT_TIME, current);\n\t\treturn;\n\t}\n\n\ttask_ctx = cpuctx->task_ctx;\n\tif (ctx->task)\n\t\tWARN_ON_ONCE(task_ctx != ctx);\n\n\tctx_resched(cpuctx, task_ctx);\n}\n\n/*\n * Enable a event.\n *\n * If event->ctx is a cloned context, callers must make sure that\n * every task struct that event->ctx->task could possibly point to\n * remains valid.  This condition is satisfied when called through\n * perf_event_for_each_child or perf_event_for_each as described\n * for perf_event_disable.\n */\nstatic void _perf_event_enable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\n\traw_spin_lock_irq(&ctx->lock);\n\tif (event->state >= PERF_EVENT_STATE_INACTIVE ||\n\t    event->state <  PERF_EVENT_STATE_ERROR) {\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\treturn;\n\t}\n\n\t/*\n\t * If the event is in error state, clear that first.\n\t *\n\t * That way, if we see the event in error state below, we know that it\n\t * has gone back into error state, as distinct from the task having\n\t * been scheduled away before the cross-call arrived.\n\t */\n\tif (event->state == PERF_EVENT_STATE_ERROR)\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tevent_function_call(event, __perf_event_enable, NULL);\n}\n\n/*\n * See perf_event_disable();\n */\nvoid perf_event_enable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = perf_event_ctx_lock(event);\n\t_perf_event_enable(event);\n\tperf_event_ctx_unlock(event, ctx);\n}\nEXPORT_SYMBOL_GPL(perf_event_enable);\n\nstruct stop_event_data {\n\tstruct perf_event\t*event;\n\tunsigned int\t\trestart;\n};\n\nstatic int __perf_event_stop(void *info)\n{\n\tstruct stop_event_data *sd = info;\n\tstruct perf_event *event = sd->event;\n\n\t/* if it's already INACTIVE, do nothing */\n\tif (READ_ONCE(event->state) != PERF_EVENT_STATE_ACTIVE)\n\t\treturn 0;\n\n\t/* matches smp_wmb() in event_sched_in() */\n\tsmp_rmb();\n\n\t/*\n\t * There is a window with interrupts enabled before we get here,\n\t * so we need to check again lest we try to stop another CPU's event.\n\t */\n\tif (READ_ONCE(event->oncpu) != smp_processor_id())\n\t\treturn -EAGAIN;\n\n\tevent->pmu->stop(event, PERF_EF_UPDATE);\n\n\t/*\n\t * May race with the actual stop (through perf_pmu_output_stop()),\n\t * but it is only used for events with AUX ring buffer, and such\n\t * events will refuse to restart because of rb::aux_mmap_count==0,\n\t * see comments in perf_aux_output_begin().\n\t *\n\t * Since this is happening on a event-local CPU, no trace is lost\n\t * while restarting.\n\t */\n\tif (sd->restart)\n\t\tevent->pmu->start(event, 0);\n\n\treturn 0;\n}\n\nstatic int perf_event_stop(struct perf_event *event, int restart)\n{\n\tstruct stop_event_data sd = {\n\t\t.event\t\t= event,\n\t\t.restart\t= restart,\n\t};\n\tint ret = 0;\n\n\tdo {\n\t\tif (READ_ONCE(event->state) != PERF_EVENT_STATE_ACTIVE)\n\t\t\treturn 0;\n\n\t\t/* matches smp_wmb() in event_sched_in() */\n\t\tsmp_rmb();\n\n\t\t/*\n\t\t * We only want to restart ACTIVE events, so if the event goes\n\t\t * inactive here (event->oncpu==-1), there's nothing more to do;\n\t\t * fall through with ret==-ENXIO.\n\t\t */\n\t\tret = cpu_function_call(READ_ONCE(event->oncpu),\n\t\t\t\t\t__perf_event_stop, &sd);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}\n\n/*\n * In order to contain the amount of racy and tricky in the address filter\n * configuration management, it is a two part process:\n *\n * (p1) when userspace mappings change as a result of (1) or (2) or (3) below,\n *      we update the addresses of corresponding vmas in\n *\tevent::addr_filters_offs array and bump the event::addr_filters_gen;\n * (p2) when an event is scheduled in (pmu::add), it calls\n *      perf_event_addr_filters_sync() which calls pmu::addr_filters_sync()\n *      if the generation has changed since the previous call.\n *\n * If (p1) happens while the event is active, we restart it to force (p2).\n *\n * (1) perf_addr_filters_apply(): adjusting filters' offsets based on\n *     pre-existing mappings, called once when new filters arrive via SET_FILTER\n *     ioctl;\n * (2) perf_addr_filters_adjust(): adjusting filters' offsets based on newly\n *     registered mapping, called for every new mmap(), with mm::mmap_sem down\n *     for reading;\n * (3) perf_event_addr_filters_exec(): clearing filters' offsets in the process\n *     of exec.\n */\nvoid perf_event_addr_filters_sync(struct perf_event *event)\n{\n\tstruct perf_addr_filters_head *ifh = perf_event_addr_filters(event);\n\n\tif (!has_addr_filter(event))\n\t\treturn;\n\n\traw_spin_lock(&ifh->lock);\n\tif (event->addr_filters_gen != event->hw.addr_filters_gen) {\n\t\tevent->pmu->addr_filters_sync(event);\n\t\tevent->hw.addr_filters_gen = event->addr_filters_gen;\n\t}\n\traw_spin_unlock(&ifh->lock);\n}\nEXPORT_SYMBOL_GPL(perf_event_addr_filters_sync);\n\nstatic int _perf_event_refresh(struct perf_event *event, int refresh)\n{\n\t/*\n\t * not supported on inherited events\n\t */\n\tif (event->attr.inherit || !is_sampling_event(event))\n\t\treturn -EINVAL;\n\n\tatomic_add(refresh, &event->event_limit);\n\t_perf_event_enable(event);\n\n\treturn 0;\n}\n\n/*\n * See perf_event_disable()\n */\nint perf_event_refresh(struct perf_event *event, int refresh)\n{\n\tstruct perf_event_context *ctx;\n\tint ret;\n\n\tctx = perf_event_ctx_lock(event);\n\tret = _perf_event_refresh(event, refresh);\n\tperf_event_ctx_unlock(event, ctx);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(perf_event_refresh);\n\nstatic void ctx_sched_out(struct perf_event_context *ctx,\n\t\t\t  struct perf_cpu_context *cpuctx,\n\t\t\t  enum event_type_t event_type)\n{\n\tint is_active = ctx->is_active;\n\tstruct perf_event *event;\n\n\tlockdep_assert_held(&ctx->lock);\n\n\tif (likely(!ctx->nr_events)) {\n\t\t/*\n\t\t * See __perf_remove_from_context().\n\t\t */\n\t\tWARN_ON_ONCE(ctx->is_active);\n\t\tif (ctx->task)\n\t\t\tWARN_ON_ONCE(cpuctx->task_ctx);\n\t\treturn;\n\t}\n\n\tctx->is_active &= ~event_type;\n\tif (!(ctx->is_active & EVENT_ALL))\n\t\tctx->is_active = 0;\n\n\tif (ctx->task) {\n\t\tWARN_ON_ONCE(cpuctx->task_ctx != ctx);\n\t\tif (!ctx->is_active)\n\t\t\tcpuctx->task_ctx = NULL;\n\t}\n\n\t/*\n\t * Always update time if it was set; not only when it changes.\n\t * Otherwise we can 'forget' to update time for any but the last\n\t * context we sched out. For example:\n\t *\n\t *   ctx_sched_out(.event_type = EVENT_FLEXIBLE)\n\t *   ctx_sched_out(.event_type = EVENT_PINNED)\n\t *\n\t * would only update time for the pinned events.\n\t */\n\tif (is_active & EVENT_TIME) {\n\t\t/* update (and stop) ctx time */\n\t\tupdate_context_time(ctx);\n\t\tupdate_cgrp_time_from_cpuctx(cpuctx);\n\t}\n\n\tis_active ^= ctx->is_active; /* changed bits */\n\n\tif (!ctx->nr_active || !(is_active & EVENT_ALL))\n\t\treturn;\n\n\tperf_pmu_disable(ctx->pmu);\n\tif (is_active & EVENT_PINNED) {\n\t\tlist_for_each_entry(event, &ctx->pinned_groups, group_entry)\n\t\t\tgroup_sched_out(event, cpuctx, ctx);\n\t}\n\n\tif (is_active & EVENT_FLEXIBLE) {\n\t\tlist_for_each_entry(event, &ctx->flexible_groups, group_entry)\n\t\t\tgroup_sched_out(event, cpuctx, ctx);\n\t}\n\tperf_pmu_enable(ctx->pmu);\n}\n\n/*\n * Test whether two contexts are equivalent, i.e. whether they have both been\n * cloned from the same version of the same context.\n *\n * Equivalence is measured using a generation number in the context that is\n * incremented on each modification to it; see unclone_ctx(), list_add_event()\n * and list_del_event().\n */\nstatic int context_equiv(struct perf_event_context *ctx1,\n\t\t\t struct perf_event_context *ctx2)\n{\n\tlockdep_assert_held(&ctx1->lock);\n\tlockdep_assert_held(&ctx2->lock);\n\n\t/* Pinning disables the swap optimization */\n\tif (ctx1->pin_count || ctx2->pin_count)\n\t\treturn 0;\n\n\t/* If ctx1 is the parent of ctx2 */\n\tif (ctx1 == ctx2->parent_ctx && ctx1->generation == ctx2->parent_gen)\n\t\treturn 1;\n\n\t/* If ctx2 is the parent of ctx1 */\n\tif (ctx1->parent_ctx == ctx2 && ctx1->parent_gen == ctx2->generation)\n\t\treturn 1;\n\n\t/*\n\t * If ctx1 and ctx2 have the same parent; we flatten the parent\n\t * hierarchy, see perf_event_init_context().\n\t */\n\tif (ctx1->parent_ctx && ctx1->parent_ctx == ctx2->parent_ctx &&\n\t\t\tctx1->parent_gen == ctx2->parent_gen)\n\t\treturn 1;\n\n\t/* Unmatched */\n\treturn 0;\n}\n\nstatic void __perf_event_sync_stat(struct perf_event *event,\n\t\t\t\t     struct perf_event *next_event)\n{\n\tu64 value;\n\n\tif (!event->attr.inherit_stat)\n\t\treturn;\n\n\t/*\n\t * Update the event value, we cannot use perf_event_read()\n\t * because we're in the middle of a context switch and have IRQs\n\t * disabled, which upsets smp_call_function_single(), however\n\t * we know the event must be on the current CPU, therefore we\n\t * don't need to use it.\n\t */\n\tswitch (event->state) {\n\tcase PERF_EVENT_STATE_ACTIVE:\n\t\tevent->pmu->read(event);\n\t\t/* fall-through */\n\n\tcase PERF_EVENT_STATE_INACTIVE:\n\t\tupdate_event_times(event);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * In order to keep per-task stats reliable we need to flip the event\n\t * values when we flip the contexts.\n\t */\n\tvalue = local64_read(&next_event->count);\n\tvalue = local64_xchg(&event->count, value);\n\tlocal64_set(&next_event->count, value);\n\n\tswap(event->total_time_enabled, next_event->total_time_enabled);\n\tswap(event->total_time_running, next_event->total_time_running);\n\n\t/*\n\t * Since we swizzled the values, update the user visible data too.\n\t */\n\tperf_event_update_userpage(event);\n\tperf_event_update_userpage(next_event);\n}\n\nstatic void perf_event_sync_stat(struct perf_event_context *ctx,\n\t\t\t\t   struct perf_event_context *next_ctx)\n{\n\tstruct perf_event *event, *next_event;\n\n\tif (!ctx->nr_stat)\n\t\treturn;\n\n\tupdate_context_time(ctx);\n\n\tevent = list_first_entry(&ctx->event_list,\n\t\t\t\t   struct perf_event, event_entry);\n\n\tnext_event = list_first_entry(&next_ctx->event_list,\n\t\t\t\t\tstruct perf_event, event_entry);\n\n\twhile (&event->event_entry != &ctx->event_list &&\n\t       &next_event->event_entry != &next_ctx->event_list) {\n\n\t\t__perf_event_sync_stat(event, next_event);\n\n\t\tevent = list_next_entry(event, event_entry);\n\t\tnext_event = list_next_entry(next_event, event_entry);\n\t}\n}\n\nstatic void perf_event_context_sched_out(struct task_struct *task, int ctxn,\n\t\t\t\t\t struct task_struct *next)\n{\n\tstruct perf_event_context *ctx = task->perf_event_ctxp[ctxn];\n\tstruct perf_event_context *next_ctx;\n\tstruct perf_event_context *parent, *next_parent;\n\tstruct perf_cpu_context *cpuctx;\n\tint do_switch = 1;\n\n\tif (likely(!ctx))\n\t\treturn;\n\n\tcpuctx = __get_cpu_context(ctx);\n\tif (!cpuctx->task_ctx)\n\t\treturn;\n\n\trcu_read_lock();\n\tnext_ctx = next->perf_event_ctxp[ctxn];\n\tif (!next_ctx)\n\t\tgoto unlock;\n\n\tparent = rcu_dereference(ctx->parent_ctx);\n\tnext_parent = rcu_dereference(next_ctx->parent_ctx);\n\n\t/* If neither context have a parent context; they cannot be clones. */\n\tif (!parent && !next_parent)\n\t\tgoto unlock;\n\n\tif (next_parent == ctx || next_ctx == parent || next_parent == parent) {\n\t\t/*\n\t\t * Looks like the two contexts are clones, so we might be\n\t\t * able to optimize the context switch.  We lock both\n\t\t * contexts and check that they are clones under the\n\t\t * lock (including re-checking that neither has been\n\t\t * uncloned in the meantime).  It doesn't matter which\n\t\t * order we take the locks because no other cpu could\n\t\t * be trying to lock both of these tasks.\n\t\t */\n\t\traw_spin_lock(&ctx->lock);\n\t\traw_spin_lock_nested(&next_ctx->lock, SINGLE_DEPTH_NESTING);\n\t\tif (context_equiv(ctx, next_ctx)) {\n\t\t\tWRITE_ONCE(ctx->task, next);\n\t\t\tWRITE_ONCE(next_ctx->task, task);\n\n\t\t\tswap(ctx->task_ctx_data, next_ctx->task_ctx_data);\n\n\t\t\t/*\n\t\t\t * RCU_INIT_POINTER here is safe because we've not\n\t\t\t * modified the ctx and the above modification of\n\t\t\t * ctx->task and ctx->task_ctx_data are immaterial\n\t\t\t * since those values are always verified under\n\t\t\t * ctx->lock which we're now holding.\n\t\t\t */\n\t\t\tRCU_INIT_POINTER(task->perf_event_ctxp[ctxn], next_ctx);\n\t\t\tRCU_INIT_POINTER(next->perf_event_ctxp[ctxn], ctx);\n\n\t\t\tdo_switch = 0;\n\n\t\t\tperf_event_sync_stat(ctx, next_ctx);\n\t\t}\n\t\traw_spin_unlock(&next_ctx->lock);\n\t\traw_spin_unlock(&ctx->lock);\n\t}\nunlock:\n\trcu_read_unlock();\n\n\tif (do_switch) {\n\t\traw_spin_lock(&ctx->lock);\n\t\ttask_ctx_sched_out(cpuctx, ctx);\n\t\traw_spin_unlock(&ctx->lock);\n\t}\n}\n\nstatic DEFINE_PER_CPU(struct list_head, sched_cb_list);\n\nvoid perf_sched_cb_dec(struct pmu *pmu)\n{\n\tstruct perf_cpu_context *cpuctx = this_cpu_ptr(pmu->pmu_cpu_context);\n\n\tthis_cpu_dec(perf_sched_cb_usages);\n\n\tif (!--cpuctx->sched_cb_usage)\n\t\tlist_del(&cpuctx->sched_cb_entry);\n}\n\n\nvoid perf_sched_cb_inc(struct pmu *pmu)\n{\n\tstruct perf_cpu_context *cpuctx = this_cpu_ptr(pmu->pmu_cpu_context);\n\n\tif (!cpuctx->sched_cb_usage++)\n\t\tlist_add(&cpuctx->sched_cb_entry, this_cpu_ptr(&sched_cb_list));\n\n\tthis_cpu_inc(perf_sched_cb_usages);\n}\n\n/*\n * This function provides the context switch callback to the lower code\n * layer. It is invoked ONLY when the context switch callback is enabled.\n *\n * This callback is relevant even to per-cpu events; for example multi event\n * PEBS requires this to provide PID/TID information. This requires we flush\n * all queued PEBS records before we context switch to a new task.\n */\nstatic void perf_pmu_sched_task(struct task_struct *prev,\n\t\t\t\tstruct task_struct *next,\n\t\t\t\tbool sched_in)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct pmu *pmu;\n\n\tif (prev == next)\n\t\treturn;\n\n\tlist_for_each_entry(cpuctx, this_cpu_ptr(&sched_cb_list), sched_cb_entry) {\n\t\tpmu = cpuctx->unique_pmu; /* software PMUs will not have sched_task */\n\n\t\tif (WARN_ON_ONCE(!pmu->sched_task))\n\t\t\tcontinue;\n\n\t\tperf_ctx_lock(cpuctx, cpuctx->task_ctx);\n\t\tperf_pmu_disable(pmu);\n\n\t\tpmu->sched_task(cpuctx->task_ctx, sched_in);\n\n\t\tperf_pmu_enable(pmu);\n\t\tperf_ctx_unlock(cpuctx, cpuctx->task_ctx);\n\t}\n}\n\nstatic void perf_event_switch(struct task_struct *task,\n\t\t\t      struct task_struct *next_prev, bool sched_in);\n\n#define for_each_task_context_nr(ctxn)\t\t\t\t\t\\\n\tfor ((ctxn) = 0; (ctxn) < perf_nr_task_contexts; (ctxn)++)\n\n/*\n * Called from scheduler to remove the events of the current task,\n * with interrupts disabled.\n *\n * We stop each event and update the event value in event->count.\n *\n * This does not protect us against NMI, but disable()\n * sets the disabled bit in the control field of event _before_\n * accessing the event control register. If a NMI hits, then it will\n * not restart the event.\n */\nvoid __perf_event_task_sched_out(struct task_struct *task,\n\t\t\t\t struct task_struct *next)\n{\n\tint ctxn;\n\n\tif (__this_cpu_read(perf_sched_cb_usages))\n\t\tperf_pmu_sched_task(task, next, false);\n\n\tif (atomic_read(&nr_switch_events))\n\t\tperf_event_switch(task, next, false);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_context_sched_out(task, ctxn, next);\n\n\t/*\n\t * if cgroup events exist on this CPU, then we need\n\t * to check if we have to switch out PMU state.\n\t * cgroup event are system-wide mode only\n\t */\n\tif (atomic_read(this_cpu_ptr(&perf_cgroup_events)))\n\t\tperf_cgroup_sched_out(task, next);\n}\n\n/*\n * Called with IRQs disabled\n */\nstatic void cpu_ctx_sched_out(struct perf_cpu_context *cpuctx,\n\t\t\t      enum event_type_t event_type)\n{\n\tctx_sched_out(&cpuctx->ctx, cpuctx, event_type);\n}\n\nstatic void\nctx_pinned_sched_in(struct perf_event_context *ctx,\n\t\t    struct perf_cpu_context *cpuctx)\n{\n\tstruct perf_event *event;\n\n\tlist_for_each_entry(event, &ctx->pinned_groups, group_entry) {\n\t\tif (event->state <= PERF_EVENT_STATE_OFF)\n\t\t\tcontinue;\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\n\t\t/* may need to reset tstamp_enabled */\n\t\tif (is_cgroup_event(event))\n\t\t\tperf_cgroup_mark_enabled(event, ctx);\n\n\t\tif (group_can_go_on(event, cpuctx, 1))\n\t\t\tgroup_sched_in(event, cpuctx, ctx);\n\n\t\t/*\n\t\t * If this pinned group hasn't been scheduled,\n\t\t * put it in error state.\n\t\t */\n\t\tif (event->state == PERF_EVENT_STATE_INACTIVE) {\n\t\t\tupdate_group_times(event);\n\t\t\tevent->state = PERF_EVENT_STATE_ERROR;\n\t\t}\n\t}\n}\n\nstatic void\nctx_flexible_sched_in(struct perf_event_context *ctx,\n\t\t      struct perf_cpu_context *cpuctx)\n{\n\tstruct perf_event *event;\n\tint can_add_hw = 1;\n\n\tlist_for_each_entry(event, &ctx->flexible_groups, group_entry) {\n\t\t/* Ignore events in OFF or ERROR state */\n\t\tif (event->state <= PERF_EVENT_STATE_OFF)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Listen to the 'cpu' scheduling filter constraint\n\t\t * of events:\n\t\t */\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\n\t\t/* may need to reset tstamp_enabled */\n\t\tif (is_cgroup_event(event))\n\t\t\tperf_cgroup_mark_enabled(event, ctx);\n\n\t\tif (group_can_go_on(event, cpuctx, can_add_hw)) {\n\t\t\tif (group_sched_in(event, cpuctx, ctx))\n\t\t\t\tcan_add_hw = 0;\n\t\t}\n\t}\n}\n\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task)\n{\n\tint is_active = ctx->is_active;\n\tu64 now;\n\n\tlockdep_assert_held(&ctx->lock);\n\n\tif (likely(!ctx->nr_events))\n\t\treturn;\n\n\tctx->is_active |= (event_type | EVENT_TIME);\n\tif (ctx->task) {\n\t\tif (!is_active)\n\t\t\tcpuctx->task_ctx = ctx;\n\t\telse\n\t\t\tWARN_ON_ONCE(cpuctx->task_ctx != ctx);\n\t}\n\n\tis_active ^= ctx->is_active; /* changed bits */\n\n\tif (is_active & EVENT_TIME) {\n\t\t/* start ctx time */\n\t\tnow = perf_clock();\n\t\tctx->timestamp = now;\n\t\tperf_cgroup_set_timestamp(task, ctx);\n\t}\n\n\t/*\n\t * First go through the list and put on any pinned groups\n\t * in order to give them the best chance of going on.\n\t */\n\tif (is_active & EVENT_PINNED)\n\t\tctx_pinned_sched_in(ctx, cpuctx);\n\n\t/* Then walk through the lower prio flexible groups */\n\tif (is_active & EVENT_FLEXIBLE)\n\t\tctx_flexible_sched_in(ctx, cpuctx);\n}\n\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task)\n{\n\tstruct perf_event_context *ctx = &cpuctx->ctx;\n\n\tctx_sched_in(ctx, cpuctx, event_type, task);\n}\n\nstatic void perf_event_context_sched_in(struct perf_event_context *ctx,\n\t\t\t\t\tstruct task_struct *task)\n{\n\tstruct perf_cpu_context *cpuctx;\n\n\tcpuctx = __get_cpu_context(ctx);\n\tif (cpuctx->task_ctx == ctx)\n\t\treturn;\n\n\tperf_ctx_lock(cpuctx, ctx);\n\tperf_pmu_disable(ctx->pmu);\n\t/*\n\t * We want to keep the following priority order:\n\t * cpu pinned (that don't need to move), task pinned,\n\t * cpu flexible, task flexible.\n\t */\n\tcpu_ctx_sched_out(cpuctx, EVENT_FLEXIBLE);\n\tperf_event_sched_in(cpuctx, ctx, task);\n\tperf_pmu_enable(ctx->pmu);\n\tperf_ctx_unlock(cpuctx, ctx);\n}\n\n/*\n * Called from scheduler to add the events of the current task\n * with interrupts disabled.\n *\n * We restore the event value and then enable it.\n *\n * This does not protect us against NMI, but enable()\n * sets the enabled bit in the control field of event _before_\n * accessing the event control register. If a NMI hits, then it will\n * keep the event running.\n */\nvoid __perf_event_task_sched_in(struct task_struct *prev,\n\t\t\t\tstruct task_struct *task)\n{\n\tstruct perf_event_context *ctx;\n\tint ctxn;\n\n\t/*\n\t * If cgroup events exist on this CPU, then we need to check if we have\n\t * to switch in PMU state; cgroup event are system-wide mode only.\n\t *\n\t * Since cgroup events are CPU events, we must schedule these in before\n\t * we schedule in the task events.\n\t */\n\tif (atomic_read(this_cpu_ptr(&perf_cgroup_events)))\n\t\tperf_cgroup_sched_in(prev, task);\n\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = task->perf_event_ctxp[ctxn];\n\t\tif (likely(!ctx))\n\t\t\tcontinue;\n\n\t\tperf_event_context_sched_in(ctx, task);\n\t}\n\n\tif (atomic_read(&nr_switch_events))\n\t\tperf_event_switch(task, prev, true);\n\n\tif (__this_cpu_read(perf_sched_cb_usages))\n\t\tperf_pmu_sched_task(prev, task, true);\n}\n\nstatic u64 perf_calculate_period(struct perf_event *event, u64 nsec, u64 count)\n{\n\tu64 frequency = event->attr.sample_freq;\n\tu64 sec = NSEC_PER_SEC;\n\tu64 divisor, dividend;\n\n\tint count_fls, nsec_fls, frequency_fls, sec_fls;\n\n\tcount_fls = fls64(count);\n\tnsec_fls = fls64(nsec);\n\tfrequency_fls = fls64(frequency);\n\tsec_fls = 30;\n\n\t/*\n\t * We got @count in @nsec, with a target of sample_freq HZ\n\t * the target period becomes:\n\t *\n\t *             @count * 10^9\n\t * period = -------------------\n\t *          @nsec * sample_freq\n\t *\n\t */\n\n\t/*\n\t * Reduce accuracy by one bit such that @a and @b converge\n\t * to a similar magnitude.\n\t */\n#define REDUCE_FLS(a, b)\t\t\\\ndo {\t\t\t\t\t\\\n\tif (a##_fls > b##_fls) {\t\\\n\t\ta >>= 1;\t\t\\\n\t\ta##_fls--;\t\t\\\n\t} else {\t\t\t\\\n\t\tb >>= 1;\t\t\\\n\t\tb##_fls--;\t\t\\\n\t}\t\t\t\t\\\n} while (0)\n\n\t/*\n\t * Reduce accuracy until either term fits in a u64, then proceed with\n\t * the other, so that finally we can do a u64/u64 division.\n\t */\n\twhile (count_fls + sec_fls > 64 && nsec_fls + frequency_fls > 64) {\n\t\tREDUCE_FLS(nsec, frequency);\n\t\tREDUCE_FLS(sec, count);\n\t}\n\n\tif (count_fls + sec_fls > 64) {\n\t\tdivisor = nsec * frequency;\n\n\t\twhile (count_fls + sec_fls > 64) {\n\t\t\tREDUCE_FLS(count, sec);\n\t\t\tdivisor >>= 1;\n\t\t}\n\n\t\tdividend = count * sec;\n\t} else {\n\t\tdividend = count * sec;\n\n\t\twhile (nsec_fls + frequency_fls > 64) {\n\t\t\tREDUCE_FLS(nsec, frequency);\n\t\t\tdividend >>= 1;\n\t\t}\n\n\t\tdivisor = nsec * frequency;\n\t}\n\n\tif (!divisor)\n\t\treturn dividend;\n\n\treturn div64_u64(dividend, divisor);\n}\n\nstatic DEFINE_PER_CPU(int, perf_throttled_count);\nstatic DEFINE_PER_CPU(u64, perf_throttled_seq);\n\nstatic void perf_adjust_period(struct perf_event *event, u64 nsec, u64 count, bool disable)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\ts64 period, sample_period;\n\ts64 delta;\n\n\tperiod = perf_calculate_period(event, nsec, count);\n\n\tdelta = (s64)(period - hwc->sample_period);\n\tdelta = (delta + 7) / 8; /* low pass filter */\n\n\tsample_period = hwc->sample_period + delta;\n\n\tif (!sample_period)\n\t\tsample_period = 1;\n\n\thwc->sample_period = sample_period;\n\n\tif (local64_read(&hwc->period_left) > 8*sample_period) {\n\t\tif (disable)\n\t\t\tevent->pmu->stop(event, PERF_EF_UPDATE);\n\n\t\tlocal64_set(&hwc->period_left, 0);\n\n\t\tif (disable)\n\t\t\tevent->pmu->start(event, PERF_EF_RELOAD);\n\t}\n}\n\n/*\n * combine freq adjustment with unthrottling to avoid two passes over the\n * events. At the same time, make sure, having freq events does not change\n * the rate of unthrottling as that would introduce bias.\n */\nstatic void perf_adjust_freq_unthr_context(struct perf_event_context *ctx,\n\t\t\t\t\t   int needs_unthr)\n{\n\tstruct perf_event *event;\n\tstruct hw_perf_event *hwc;\n\tu64 now, period = TICK_NSEC;\n\ts64 delta;\n\n\t/*\n\t * only need to iterate over all events iff:\n\t * - context have events in frequency mode (needs freq adjust)\n\t * - there are events to unthrottle on this cpu\n\t */\n\tif (!(ctx->nr_freq || needs_unthr))\n\t\treturn;\n\n\traw_spin_lock(&ctx->lock);\n\tperf_pmu_disable(ctx->pmu);\n\n\tlist_for_each_entry_rcu(event, &ctx->event_list, event_entry) {\n\t\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\t\tcontinue;\n\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\n\t\tperf_pmu_disable(event->pmu);\n\n\t\thwc = &event->hw;\n\n\t\tif (hwc->interrupts == MAX_INTERRUPTS) {\n\t\t\thwc->interrupts = 0;\n\t\t\tperf_log_throttle(event, 1);\n\t\t\tevent->pmu->start(event, 0);\n\t\t}\n\n\t\tif (!event->attr.freq || !event->attr.sample_freq)\n\t\t\tgoto next;\n\n\t\t/*\n\t\t * stop the event and update event->count\n\t\t */\n\t\tevent->pmu->stop(event, PERF_EF_UPDATE);\n\n\t\tnow = local64_read(&event->count);\n\t\tdelta = now - hwc->freq_count_stamp;\n\t\thwc->freq_count_stamp = now;\n\n\t\t/*\n\t\t * restart the event\n\t\t * reload only if value has changed\n\t\t * we have stopped the event so tell that\n\t\t * to perf_adjust_period() to avoid stopping it\n\t\t * twice.\n\t\t */\n\t\tif (delta > 0)\n\t\t\tperf_adjust_period(event, period, delta, false);\n\n\t\tevent->pmu->start(event, delta > 0 ? PERF_EF_RELOAD : 0);\n\tnext:\n\t\tperf_pmu_enable(event->pmu);\n\t}\n\n\tperf_pmu_enable(ctx->pmu);\n\traw_spin_unlock(&ctx->lock);\n}\n\n/*\n * Round-robin a context's events:\n */\nstatic void rotate_ctx(struct perf_event_context *ctx)\n{\n\t/*\n\t * Rotate the first entry last of non-pinned groups. Rotation might be\n\t * disabled by the inheritance code.\n\t */\n\tif (!ctx->rotate_disable)\n\t\tlist_rotate_left(&ctx->flexible_groups);\n}\n\nstatic int perf_rotate_context(struct perf_cpu_context *cpuctx)\n{\n\tstruct perf_event_context *ctx = NULL;\n\tint rotate = 0;\n\n\tif (cpuctx->ctx.nr_events) {\n\t\tif (cpuctx->ctx.nr_events != cpuctx->ctx.nr_active)\n\t\t\trotate = 1;\n\t}\n\n\tctx = cpuctx->task_ctx;\n\tif (ctx && ctx->nr_events) {\n\t\tif (ctx->nr_events != ctx->nr_active)\n\t\t\trotate = 1;\n\t}\n\n\tif (!rotate)\n\t\tgoto done;\n\n\tperf_ctx_lock(cpuctx, cpuctx->task_ctx);\n\tperf_pmu_disable(cpuctx->ctx.pmu);\n\n\tcpu_ctx_sched_out(cpuctx, EVENT_FLEXIBLE);\n\tif (ctx)\n\t\tctx_sched_out(ctx, cpuctx, EVENT_FLEXIBLE);\n\n\trotate_ctx(&cpuctx->ctx);\n\tif (ctx)\n\t\trotate_ctx(ctx);\n\n\tperf_event_sched_in(cpuctx, ctx, current);\n\n\tperf_pmu_enable(cpuctx->ctx.pmu);\n\tperf_ctx_unlock(cpuctx, cpuctx->task_ctx);\ndone:\n\n\treturn rotate;\n}\n\nvoid perf_event_task_tick(void)\n{\n\tstruct list_head *head = this_cpu_ptr(&active_ctx_list);\n\tstruct perf_event_context *ctx, *tmp;\n\tint throttled;\n\n\tWARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(perf_throttled_seq);\n\tthrottled = __this_cpu_xchg(perf_throttled_count, 0);\n\ttick_dep_clear_cpu(smp_processor_id(), TICK_DEP_BIT_PERF_EVENTS);\n\n\tlist_for_each_entry_safe(ctx, tmp, head, active_ctx_list)\n\t\tperf_adjust_freq_unthr_context(ctx, throttled);\n}\n\nstatic int event_enable_on_exec(struct perf_event *event,\n\t\t\t\tstruct perf_event_context *ctx)\n{\n\tif (!event->attr.enable_on_exec)\n\t\treturn 0;\n\n\tevent->attr.enable_on_exec = 0;\n\tif (event->state >= PERF_EVENT_STATE_INACTIVE)\n\t\treturn 0;\n\n\t__perf_event_mark_enabled(event);\n\n\treturn 1;\n}\n\n/*\n * Enable all of a task's events that have been marked enable-on-exec.\n * This expects task == current.\n */\nstatic void perf_event_enable_on_exec(int ctxn)\n{\n\tstruct perf_event_context *ctx, *clone_ctx = NULL;\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event *event;\n\tunsigned long flags;\n\tint enabled = 0;\n\n\tlocal_irq_save(flags);\n\tctx = current->perf_event_ctxp[ctxn];\n\tif (!ctx || !ctx->nr_events)\n\t\tgoto out;\n\n\tcpuctx = __get_cpu_context(ctx);\n\tperf_ctx_lock(cpuctx, ctx);\n\tctx_sched_out(ctx, cpuctx, EVENT_TIME);\n\tlist_for_each_entry(event, &ctx->event_list, event_entry)\n\t\tenabled |= event_enable_on_exec(event, ctx);\n\n\t/*\n\t * Unclone and reschedule this context if we enabled any event.\n\t */\n\tif (enabled) {\n\t\tclone_ctx = unclone_ctx(ctx);\n\t\tctx_resched(cpuctx, ctx);\n\t}\n\tperf_ctx_unlock(cpuctx, ctx);\n\nout:\n\tlocal_irq_restore(flags);\n\n\tif (clone_ctx)\n\t\tput_ctx(clone_ctx);\n}\n\nstruct perf_read_data {\n\tstruct perf_event *event;\n\tbool group;\n\tint ret;\n};\n\nstatic int find_cpu_to_read(struct perf_event *event, int local_cpu)\n{\n\tint event_cpu = event->oncpu;\n\tu16 local_pkg, event_pkg;\n\n\tif (event->group_caps & PERF_EV_CAP_READ_ACTIVE_PKG) {\n\t\tevent_pkg =  topology_physical_package_id(event_cpu);\n\t\tlocal_pkg =  topology_physical_package_id(local_cpu);\n\n\t\tif (event_pkg == local_pkg)\n\t\t\treturn local_cpu;\n\t}\n\n\treturn event_cpu;\n}\n\n/*\n * Cross CPU call to read the hardware event\n */\nstatic void __perf_event_read(void *info)\n{\n\tstruct perf_read_data *data = info;\n\tstruct perf_event *sub, *event = data->event;\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\tstruct pmu *pmu = event->pmu;\n\n\t/*\n\t * If this is a task context, we need to check whether it is\n\t * the current task context of this cpu.  If not it has been\n\t * scheduled out before the smp call arrived.  In that case\n\t * event->count would have been updated to a recent sample\n\t * when the event was scheduled out.\n\t */\n\tif (ctx->task && cpuctx->task_ctx != ctx)\n\t\treturn;\n\n\traw_spin_lock(&ctx->lock);\n\tif (ctx->is_active) {\n\t\tupdate_context_time(ctx);\n\t\tupdate_cgrp_time_from_event(event);\n\t}\n\n\tupdate_event_times(event);\n\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\tgoto unlock;\n\n\tif (!data->group) {\n\t\tpmu->read(event);\n\t\tdata->ret = 0;\n\t\tgoto unlock;\n\t}\n\n\tpmu->start_txn(pmu, PERF_PMU_TXN_READ);\n\n\tpmu->read(event);\n\n\tlist_for_each_entry(sub, &event->sibling_list, group_entry) {\n\t\tupdate_event_times(sub);\n\t\tif (sub->state == PERF_EVENT_STATE_ACTIVE) {\n\t\t\t/*\n\t\t\t * Use sibling's PMU rather than @event's since\n\t\t\t * sibling could be on different (eg: software) PMU.\n\t\t\t */\n\t\t\tsub->pmu->read(sub);\n\t\t}\n\t}\n\n\tdata->ret = pmu->commit_txn(pmu);\n\nunlock:\n\traw_spin_unlock(&ctx->lock);\n}\n\nstatic inline u64 perf_event_count(struct perf_event *event)\n{\n\tif (event->pmu->count)\n\t\treturn event->pmu->count(event);\n\n\treturn __perf_event_count(event);\n}\n\n/*\n * NMI-safe method to read a local event, that is an event that\n * is:\n *   - either for the current task, or for this CPU\n *   - does not have inherit set, for inherited task events\n *     will not be local and we cannot read them atomically\n *   - must not have a pmu::count method\n */\nu64 perf_event_read_local(struct perf_event *event)\n{\n\tunsigned long flags;\n\tu64 val;\n\n\t/*\n\t * Disabling interrupts avoids all counter scheduling (context\n\t * switches, timer based rotation and IPIs).\n\t */\n\tlocal_irq_save(flags);\n\n\t/* If this is a per-task event, it must be for current */\n\tWARN_ON_ONCE((event->attach_state & PERF_ATTACH_TASK) &&\n\t\t     event->hw.target != current);\n\n\t/* If this is a per-CPU event, it must be for this CPU */\n\tWARN_ON_ONCE(!(event->attach_state & PERF_ATTACH_TASK) &&\n\t\t     event->cpu != smp_processor_id());\n\n\t/*\n\t * It must not be an event with inherit set, we cannot read\n\t * all child counters from atomic context.\n\t */\n\tWARN_ON_ONCE(event->attr.inherit);\n\n\t/*\n\t * It must not have a pmu::count method, those are not\n\t * NMI safe.\n\t */\n\tWARN_ON_ONCE(event->pmu->count);\n\n\t/*\n\t * If the event is currently on this CPU, its either a per-task event,\n\t * or local to this CPU. Furthermore it means its ACTIVE (otherwise\n\t * oncpu == -1).\n\t */\n\tif (event->oncpu == smp_processor_id())\n\t\tevent->pmu->read(event);\n\n\tval = local64_read(&event->count);\n\tlocal_irq_restore(flags);\n\n\treturn val;\n}\n\nstatic int perf_event_read(struct perf_event *event, bool group)\n{\n\tint ret = 0, cpu_to_read, local_cpu;\n\n\t/*\n\t * If event is enabled and currently active on a CPU, update the\n\t * value in the event structure:\n\t */\n\tif (event->state == PERF_EVENT_STATE_ACTIVE) {\n\t\tstruct perf_read_data data = {\n\t\t\t.event = event,\n\t\t\t.group = group,\n\t\t\t.ret = 0,\n\t\t};\n\n\t\tlocal_cpu = get_cpu();\n\t\tcpu_to_read = find_cpu_to_read(event, local_cpu);\n\t\tput_cpu();\n\n\t\t/*\n\t\t * Purposely ignore the smp_call_function_single() return\n\t\t * value.\n\t\t *\n\t\t * If event->oncpu isn't a valid CPU it means the event got\n\t\t * scheduled out and that will have updated the event count.\n\t\t *\n\t\t * Therefore, either way, we'll have an up-to-date event count\n\t\t * after this.\n\t\t */\n\t\t(void)smp_call_function_single(cpu_to_read, __perf_event_read, &data, 1);\n\t\tret = data.ret;\n\t} else if (event->state == PERF_EVENT_STATE_INACTIVE) {\n\t\tstruct perf_event_context *ctx = event->ctx;\n\t\tunsigned long flags;\n\n\t\traw_spin_lock_irqsave(&ctx->lock, flags);\n\t\t/*\n\t\t * may read while context is not active\n\t\t * (e.g., thread is blocked), in that case\n\t\t * we cannot update context time\n\t\t */\n\t\tif (ctx->is_active) {\n\t\t\tupdate_context_time(ctx);\n\t\t\tupdate_cgrp_time_from_event(event);\n\t\t}\n\t\tif (group)\n\t\t\tupdate_group_times(event);\n\t\telse\n\t\t\tupdate_event_times(event);\n\t\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n\t}\n\n\treturn ret;\n}\n\n/*\n * Initialize the perf_event context in a task_struct:\n */\nstatic void __perf_event_init_context(struct perf_event_context *ctx)\n{\n\traw_spin_lock_init(&ctx->lock);\n\tmutex_init(&ctx->mutex);\n\tINIT_LIST_HEAD(&ctx->active_ctx_list);\n\tINIT_LIST_HEAD(&ctx->pinned_groups);\n\tINIT_LIST_HEAD(&ctx->flexible_groups);\n\tINIT_LIST_HEAD(&ctx->event_list);\n\tatomic_set(&ctx->refcount, 1);\n}\n\nstatic struct perf_event_context *\nalloc_perf_context(struct pmu *pmu, struct task_struct *task)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = kzalloc(sizeof(struct perf_event_context), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\t__perf_event_init_context(ctx);\n\tif (task) {\n\t\tctx->task = task;\n\t\tget_task_struct(task);\n\t}\n\tctx->pmu = pmu;\n\n\treturn ctx;\n}\n\nstatic struct task_struct *\nfind_lively_task_by_vpid(pid_t vpid)\n{\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\tif (!vpid)\n\t\ttask = current;\n\telse\n\t\ttask = find_task_by_vpid(vpid);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\n\tif (!task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\treturn task;\n}\n\n/*\n * Returns a matching context with refcount and pincount.\n */\nstatic struct perf_event_context *\nfind_get_context(struct pmu *pmu, struct task_struct *task,\n\t\tstruct perf_event *event)\n{\n\tstruct perf_event_context *ctx, *clone_ctx = NULL;\n\tstruct perf_cpu_context *cpuctx;\n\tvoid *task_ctx_data = NULL;\n\tunsigned long flags;\n\tint ctxn, err;\n\tint cpu = event->cpu;\n\n\tif (!task) {\n\t\t/* Must be root to operate on a CPU event: */\n\t\tif (perf_paranoid_cpu() && !capable(CAP_SYS_ADMIN))\n\t\t\treturn ERR_PTR(-EACCES);\n\n\t\t/*\n\t\t * We could be clever and allow to attach a event to an\n\t\t * offline CPU and activate it when the CPU comes up, but\n\t\t * that's for later.\n\t\t */\n\t\tif (!cpu_online(cpu))\n\t\t\treturn ERR_PTR(-ENODEV);\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\tctx = &cpuctx->ctx;\n\t\tget_ctx(ctx);\n\t\t++ctx->pin_count;\n\n\t\treturn ctx;\n\t}\n\n\terr = -EINVAL;\n\tctxn = pmu->task_ctx_nr;\n\tif (ctxn < 0)\n\t\tgoto errout;\n\n\tif (event->attach_state & PERF_ATTACH_TASK_DATA) {\n\t\ttask_ctx_data = kzalloc(pmu->task_ctx_size, GFP_KERNEL);\n\t\tif (!task_ctx_data) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\nretry:\n\tctx = perf_lock_task_context(task, ctxn, &flags);\n\tif (ctx) {\n\t\tclone_ctx = unclone_ctx(ctx);\n\t\t++ctx->pin_count;\n\n\t\tif (task_ctx_data && !ctx->task_ctx_data) {\n\t\t\tctx->task_ctx_data = task_ctx_data;\n\t\t\ttask_ctx_data = NULL;\n\t\t}\n\t\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n\n\t\tif (clone_ctx)\n\t\t\tput_ctx(clone_ctx);\n\t} else {\n\t\tctx = alloc_perf_context(pmu, task);\n\t\terr = -ENOMEM;\n\t\tif (!ctx)\n\t\t\tgoto errout;\n\n\t\tif (task_ctx_data) {\n\t\t\tctx->task_ctx_data = task_ctx_data;\n\t\t\ttask_ctx_data = NULL;\n\t\t}\n\n\t\terr = 0;\n\t\tmutex_lock(&task->perf_event_mutex);\n\t\t/*\n\t\t * If it has already passed perf_event_exit_task().\n\t\t * we must see PF_EXITING, it takes this mutex too.\n\t\t */\n\t\tif (task->flags & PF_EXITING)\n\t\t\terr = -ESRCH;\n\t\telse if (task->perf_event_ctxp[ctxn])\n\t\t\terr = -EAGAIN;\n\t\telse {\n\t\t\tget_ctx(ctx);\n\t\t\t++ctx->pin_count;\n\t\t\trcu_assign_pointer(task->perf_event_ctxp[ctxn], ctx);\n\t\t}\n\t\tmutex_unlock(&task->perf_event_mutex);\n\n\t\tif (unlikely(err)) {\n\t\t\tput_ctx(ctx);\n\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto retry;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tkfree(task_ctx_data);\n\treturn ctx;\n\nerrout:\n\tkfree(task_ctx_data);\n\treturn ERR_PTR(err);\n}\n\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\n\nstatic void free_event_rcu(struct rcu_head *head)\n{\n\tstruct perf_event *event;\n\n\tevent = container_of(head, struct perf_event, rcu_head);\n\tif (event->ns)\n\t\tput_pid_ns(event->ns);\n\tperf_event_free_filter(event);\n\tkfree(event);\n}\n\nstatic void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct ring_buffer *rb);\n\nstatic void detach_sb_event(struct perf_event *event)\n{\n\tstruct pmu_event_list *pel = per_cpu_ptr(&pmu_sb_events, event->cpu);\n\n\traw_spin_lock(&pel->lock);\n\tlist_del_rcu(&event->sb_list);\n\traw_spin_unlock(&pel->lock);\n}\n\nstatic bool is_sb_event(struct perf_event *event)\n{\n\tstruct perf_event_attr *attr = &event->attr;\n\n\tif (event->parent)\n\t\treturn false;\n\n\tif (event->attach_state & PERF_ATTACH_TASK)\n\t\treturn false;\n\n\tif (attr->mmap || attr->mmap_data || attr->mmap2 ||\n\t    attr->comm || attr->comm_exec ||\n\t    attr->task ||\n\t    attr->context_switch)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void unaccount_pmu_sb_event(struct perf_event *event)\n{\n\tif (is_sb_event(event))\n\t\tdetach_sb_event(event);\n}\n\nstatic void unaccount_event_cpu(struct perf_event *event, int cpu)\n{\n\tif (event->parent)\n\t\treturn;\n\n\tif (is_cgroup_event(event))\n\t\tatomic_dec(&per_cpu(perf_cgroup_events, cpu));\n}\n\n#ifdef CONFIG_NO_HZ_FULL\nstatic DEFINE_SPINLOCK(nr_freq_lock);\n#endif\n\nstatic void unaccount_freq_event_nohz(void)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tspin_lock(&nr_freq_lock);\n\tif (atomic_dec_and_test(&nr_freq_events))\n\t\ttick_nohz_dep_clear(TICK_DEP_BIT_PERF_EVENTS);\n\tspin_unlock(&nr_freq_lock);\n#endif\n}\n\nstatic void unaccount_freq_event(void)\n{\n\tif (tick_nohz_full_enabled())\n\t\tunaccount_freq_event_nohz();\n\telse\n\t\tatomic_dec(&nr_freq_events);\n}\n\nstatic void unaccount_event(struct perf_event *event)\n{\n\tbool dec = false;\n\n\tif (event->parent)\n\t\treturn;\n\n\tif (event->attach_state & PERF_ATTACH_TASK)\n\t\tdec = true;\n\tif (event->attr.mmap || event->attr.mmap_data)\n\t\tatomic_dec(&nr_mmap_events);\n\tif (event->attr.comm)\n\t\tatomic_dec(&nr_comm_events);\n\tif (event->attr.task)\n\t\tatomic_dec(&nr_task_events);\n\tif (event->attr.freq)\n\t\tunaccount_freq_event();\n\tif (event->attr.context_switch) {\n\t\tdec = true;\n\t\tatomic_dec(&nr_switch_events);\n\t}\n\tif (is_cgroup_event(event))\n\t\tdec = true;\n\tif (has_branch_stack(event))\n\t\tdec = true;\n\n\tif (dec) {\n\t\tif (!atomic_add_unless(&perf_sched_count, -1, 1))\n\t\t\tschedule_delayed_work(&perf_sched_work, HZ);\n\t}\n\n\tunaccount_event_cpu(event, event->cpu);\n\n\tunaccount_pmu_sb_event(event);\n}\n\nstatic void perf_sched_delayed(struct work_struct *work)\n{\n\tmutex_lock(&perf_sched_mutex);\n\tif (atomic_dec_and_test(&perf_sched_count))\n\t\tstatic_branch_disable(&perf_sched_events);\n\tmutex_unlock(&perf_sched_mutex);\n}\n\n/*\n * The following implement mutual exclusion of events on \"exclusive\" pmus\n * (PERF_PMU_CAP_EXCLUSIVE). Such pmus can only have one event scheduled\n * at a time, so we disallow creating events that might conflict, namely:\n *\n *  1) cpu-wide events in the presence of per-task events,\n *  2) per-task events in the presence of cpu-wide events,\n *  3) two matching events on the same context.\n *\n * The former two cases are handled in the allocation path (perf_event_alloc(),\n * _free_event()), the latter -- before the first perf_install_in_context().\n */\nstatic int exclusive_event_init(struct perf_event *event)\n{\n\tstruct pmu *pmu = event->pmu;\n\n\tif (!(pmu->capabilities & PERF_PMU_CAP_EXCLUSIVE))\n\t\treturn 0;\n\n\t/*\n\t * Prevent co-existence of per-task and cpu-wide events on the\n\t * same exclusive pmu.\n\t *\n\t * Negative pmu::exclusive_cnt means there are cpu-wide\n\t * events on this \"exclusive\" pmu, positive means there are\n\t * per-task events.\n\t *\n\t * Since this is called in perf_event_alloc() path, event::ctx\n\t * doesn't exist yet; it is, however, safe to use PERF_ATTACH_TASK\n\t * to mean \"per-task event\", because unlike other attach states it\n\t * never gets cleared.\n\t */\n\tif (event->attach_state & PERF_ATTACH_TASK) {\n\t\tif (!atomic_inc_unless_negative(&pmu->exclusive_cnt))\n\t\t\treturn -EBUSY;\n\t} else {\n\t\tif (!atomic_dec_unless_positive(&pmu->exclusive_cnt))\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic void exclusive_event_destroy(struct perf_event *event)\n{\n\tstruct pmu *pmu = event->pmu;\n\n\tif (!(pmu->capabilities & PERF_PMU_CAP_EXCLUSIVE))\n\t\treturn;\n\n\t/* see comment in exclusive_event_init() */\n\tif (event->attach_state & PERF_ATTACH_TASK)\n\t\tatomic_dec(&pmu->exclusive_cnt);\n\telse\n\t\tatomic_inc(&pmu->exclusive_cnt);\n}\n\nstatic bool exclusive_event_match(struct perf_event *e1, struct perf_event *e2)\n{\n\tif ((e1->pmu == e2->pmu) &&\n\t    (e1->cpu == e2->cpu ||\n\t     e1->cpu == -1 ||\n\t     e2->cpu == -1))\n\t\treturn true;\n\treturn false;\n}\n\n/* Called under the same ctx::mutex as perf_install_in_context() */\nstatic bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx)\n{\n\tstruct perf_event *iter_event;\n\tstruct pmu *pmu = event->pmu;\n\n\tif (!(pmu->capabilities & PERF_PMU_CAP_EXCLUSIVE))\n\t\treturn true;\n\n\tlist_for_each_entry(iter_event, &ctx->event_list, event_entry) {\n\t\tif (exclusive_event_match(iter_event, event))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void perf_addr_filters_splice(struct perf_event *event,\n\t\t\t\t       struct list_head *head);\n\nstatic void _free_event(struct perf_event *event)\n{\n\tirq_work_sync(&event->pending);\n\n\tunaccount_event(event);\n\n\tif (event->rb) {\n\t\t/*\n\t\t * Can happen when we close an event with re-directed output.\n\t\t *\n\t\t * Since we have a 0 refcount, perf_mmap_close() will skip\n\t\t * over us; possibly making our ring_buffer_put() the last.\n\t\t */\n\t\tmutex_lock(&event->mmap_mutex);\n\t\tring_buffer_attach(event, NULL);\n\t\tmutex_unlock(&event->mmap_mutex);\n\t}\n\n\tif (is_cgroup_event(event))\n\t\tperf_detach_cgroup(event);\n\n\tif (!event->parent) {\n\t\tif (event->attr.sample_type & PERF_SAMPLE_CALLCHAIN)\n\t\t\tput_callchain_buffers();\n\t}\n\n\tperf_event_free_bpf_prog(event);\n\tperf_addr_filters_splice(event, NULL);\n\tkfree(event->addr_filters_offs);\n\n\tif (event->destroy)\n\t\tevent->destroy(event);\n\n\tif (event->ctx)\n\t\tput_ctx(event->ctx);\n\n\texclusive_event_destroy(event);\n\tmodule_put(event->pmu->module);\n\n\tcall_rcu(&event->rcu_head, free_event_rcu);\n}\n\n/*\n * Used to free events which have a known refcount of 1, such as in error paths\n * where the event isn't exposed yet and inherited events.\n */\nstatic void free_event(struct perf_event *event)\n{\n\tif (WARN(atomic_long_cmpxchg(&event->refcount, 1, 0) != 1,\n\t\t\t\t\"unexpected event refcount: %ld; ptr=%p\\n\",\n\t\t\t\tatomic_long_read(&event->refcount), event)) {\n\t\t/* leak to avoid use-after-free */\n\t\treturn;\n\t}\n\n\t_free_event(event);\n}\n\n/*\n * Remove user event from the owner task.\n */\nstatic void perf_remove_from_owner(struct perf_event *event)\n{\n\tstruct task_struct *owner;\n\n\trcu_read_lock();\n\t/*\n\t * Matches the smp_store_release() in perf_event_exit_task(). If we\n\t * observe !owner it means the list deletion is complete and we can\n\t * indeed free this event, otherwise we need to serialize on\n\t * owner->perf_event_mutex.\n\t */\n\towner = lockless_dereference(event->owner);\n\tif (owner) {\n\t\t/*\n\t\t * Since delayed_put_task_struct() also drops the last\n\t\t * task reference we can safely take a new reference\n\t\t * while holding the rcu_read_lock().\n\t\t */\n\t\tget_task_struct(owner);\n\t}\n\trcu_read_unlock();\n\n\tif (owner) {\n\t\t/*\n\t\t * If we're here through perf_event_exit_task() we're already\n\t\t * holding ctx->mutex which would be an inversion wrt. the\n\t\t * normal lock order.\n\t\t *\n\t\t * However we can safely take this lock because its the child\n\t\t * ctx->mutex.\n\t\t */\n\t\tmutex_lock_nested(&owner->perf_event_mutex, SINGLE_DEPTH_NESTING);\n\n\t\t/*\n\t\t * We have to re-check the event->owner field, if it is cleared\n\t\t * we raced with perf_event_exit_task(), acquiring the mutex\n\t\t * ensured they're done, and we can proceed with freeing the\n\t\t * event.\n\t\t */\n\t\tif (event->owner) {\n\t\t\tlist_del_init(&event->owner_entry);\n\t\t\tsmp_store_release(&event->owner, NULL);\n\t\t}\n\t\tmutex_unlock(&owner->perf_event_mutex);\n\t\tput_task_struct(owner);\n\t}\n}\n\nstatic void put_event(struct perf_event *event)\n{\n\tif (!atomic_long_dec_and_test(&event->refcount))\n\t\treturn;\n\n\t_free_event(event);\n}\n\n/*\n * Kill an event dead; while event:refcount will preserve the event\n * object, it will not preserve its functionality. Once the last 'user'\n * gives up the object, we'll destroy the thing.\n */\nint perf_event_release_kernel(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_event *child, *tmp;\n\n\t/*\n\t * If we got here through err_file: fput(event_file); we will not have\n\t * attached to a context yet.\n\t */\n\tif (!ctx) {\n\t\tWARN_ON_ONCE(event->attach_state &\n\t\t\t\t(PERF_ATTACH_CONTEXT|PERF_ATTACH_GROUP));\n\t\tgoto no_ctx;\n\t}\n\n\tif (!is_kernel_event(event))\n\t\tperf_remove_from_owner(event);\n\n\tctx = perf_event_ctx_lock(event);\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tperf_remove_from_context(event, DETACH_GROUP);\n\n\traw_spin_lock_irq(&ctx->lock);\n\t/*\n\t * Mark this even as STATE_DEAD, there is no external reference to it\n\t * anymore.\n\t *\n\t * Anybody acquiring event->child_mutex after the below loop _must_\n\t * also see this, most importantly inherit_event() which will avoid\n\t * placing more children on the list.\n\t *\n\t * Thus this guarantees that we will in fact observe and kill _ALL_\n\t * child events.\n\t */\n\tevent->state = PERF_EVENT_STATE_DEAD;\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tperf_event_ctx_unlock(event, ctx);\n\nagain:\n\tmutex_lock(&event->child_mutex);\n\tlist_for_each_entry(child, &event->child_list, child_list) {\n\n\t\t/*\n\t\t * Cannot change, child events are not migrated, see the\n\t\t * comment with perf_event_ctx_lock_nested().\n\t\t */\n\t\tctx = lockless_dereference(child->ctx);\n\t\t/*\n\t\t * Since child_mutex nests inside ctx::mutex, we must jump\n\t\t * through hoops. We start by grabbing a reference on the ctx.\n\t\t *\n\t\t * Since the event cannot get freed while we hold the\n\t\t * child_mutex, the context must also exist and have a !0\n\t\t * reference count.\n\t\t */\n\t\tget_ctx(ctx);\n\n\t\t/*\n\t\t * Now that we have a ctx ref, we can drop child_mutex, and\n\t\t * acquire ctx::mutex without fear of it going away. Then we\n\t\t * can re-acquire child_mutex.\n\t\t */\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_lock(&ctx->mutex);\n\t\tmutex_lock(&event->child_mutex);\n\n\t\t/*\n\t\t * Now that we hold ctx::mutex and child_mutex, revalidate our\n\t\t * state, if child is still the first entry, it didn't get freed\n\t\t * and we can continue doing so.\n\t\t */\n\t\ttmp = list_first_entry_or_null(&event->child_list,\n\t\t\t\t\t       struct perf_event, child_list);\n\t\tif (tmp == child) {\n\t\t\tperf_remove_from_context(child, DETACH_GROUP);\n\t\t\tlist_del(&child->child_list);\n\t\t\tfree_event(child);\n\t\t\t/*\n\t\t\t * This matches the refcount bump in inherit_event();\n\t\t\t * this can't be the last reference.\n\t\t\t */\n\t\t\tput_event(event);\n\t\t}\n\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_unlock(&ctx->mutex);\n\t\tput_ctx(ctx);\n\t\tgoto again;\n\t}\n\tmutex_unlock(&event->child_mutex);\n\nno_ctx:\n\tput_event(event); /* Must be the 'last' reference */\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(perf_event_release_kernel);\n\n/*\n * Called when the last reference to the file is gone.\n */\nstatic int perf_release(struct inode *inode, struct file *file)\n{\n\tperf_event_release_kernel(file->private_data);\n\treturn 0;\n}\n\nu64 perf_event_read_value(struct perf_event *event, u64 *enabled, u64 *running)\n{\n\tstruct perf_event *child;\n\tu64 total = 0;\n\n\t*enabled = 0;\n\t*running = 0;\n\n\tmutex_lock(&event->child_mutex);\n\n\t(void)perf_event_read(event, false);\n\ttotal += perf_event_count(event);\n\n\t*enabled += event->total_time_enabled +\n\t\t\tatomic64_read(&event->child_total_time_enabled);\n\t*running += event->total_time_running +\n\t\t\tatomic64_read(&event->child_total_time_running);\n\n\tlist_for_each_entry(child, &event->child_list, child_list) {\n\t\t(void)perf_event_read(child, false);\n\t\ttotal += perf_event_count(child);\n\t\t*enabled += child->total_time_enabled;\n\t\t*running += child->total_time_running;\n\t}\n\tmutex_unlock(&event->child_mutex);\n\n\treturn total;\n}\nEXPORT_SYMBOL_GPL(perf_event_read_value);\n\nstatic int __perf_read_group_add(struct perf_event *leader,\n\t\t\t\t\tu64 read_format, u64 *values)\n{\n\tstruct perf_event *sub;\n\tint n = 1; /* skip @nr */\n\tint ret;\n\n\tret = perf_event_read(leader, true);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Since we co-schedule groups, {enabled,running} times of siblings\n\t * will be identical to those of the leader, so we only publish one\n\t * set.\n\t */\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED) {\n\t\tvalues[n++] += leader->total_time_enabled +\n\t\t\tatomic64_read(&leader->child_total_time_enabled);\n\t}\n\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING) {\n\t\tvalues[n++] += leader->total_time_running +\n\t\t\tatomic64_read(&leader->child_total_time_running);\n\t}\n\n\t/*\n\t * Write {count,id} tuples for every sibling.\n\t */\n\tvalues[n++] += perf_event_count(leader);\n\tif (read_format & PERF_FORMAT_ID)\n\t\tvalues[n++] = primary_event_id(leader);\n\n\tlist_for_each_entry(sub, &leader->sibling_list, group_entry) {\n\t\tvalues[n++] += perf_event_count(sub);\n\t\tif (read_format & PERF_FORMAT_ID)\n\t\t\tvalues[n++] = primary_event_id(sub);\n\t}\n\n\treturn 0;\n}\n\nstatic int perf_read_group(struct perf_event *event,\n\t\t\t\t   u64 read_format, char __user *buf)\n{\n\tstruct perf_event *leader = event->group_leader, *child;\n\tstruct perf_event_context *ctx = leader->ctx;\n\tint ret;\n\tu64 *values;\n\n\tlockdep_assert_held(&ctx->mutex);\n\n\tvalues = kzalloc(event->read_size, GFP_KERNEL);\n\tif (!values)\n\t\treturn -ENOMEM;\n\n\tvalues[0] = 1 + leader->nr_siblings;\n\n\t/*\n\t * By locking the child_mutex of the leader we effectively\n\t * lock the child list of all siblings.. XXX explain how.\n\t */\n\tmutex_lock(&leader->child_mutex);\n\n\tret = __perf_read_group_add(leader, read_format, values);\n\tif (ret)\n\t\tgoto unlock;\n\n\tlist_for_each_entry(child, &leader->child_list, child_list) {\n\t\tret = __perf_read_group_add(child, read_format, values);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tmutex_unlock(&leader->child_mutex);\n\n\tret = event->read_size;\n\tif (copy_to_user(buf, values, event->read_size))\n\t\tret = -EFAULT;\n\tgoto out;\n\nunlock:\n\tmutex_unlock(&leader->child_mutex);\nout:\n\tkfree(values);\n\treturn ret;\n}\n\nstatic int perf_read_one(struct perf_event *event,\n\t\t\t\t u64 read_format, char __user *buf)\n{\n\tu64 enabled, running;\n\tu64 values[4];\n\tint n = 0;\n\n\tvalues[n++] = perf_event_read_value(event, &enabled, &running);\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)\n\t\tvalues[n++] = enabled;\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)\n\t\tvalues[n++] = running;\n\tif (read_format & PERF_FORMAT_ID)\n\t\tvalues[n++] = primary_event_id(event);\n\n\tif (copy_to_user(buf, values, n * sizeof(u64)))\n\t\treturn -EFAULT;\n\n\treturn n * sizeof(u64);\n}\n\nstatic bool is_event_hup(struct perf_event *event)\n{\n\tbool no_children;\n\n\tif (event->state > PERF_EVENT_STATE_EXIT)\n\t\treturn false;\n\n\tmutex_lock(&event->child_mutex);\n\tno_children = list_empty(&event->child_list);\n\tmutex_unlock(&event->child_mutex);\n\treturn no_children;\n}\n\n/*\n * Read the performance event - simple non blocking version for now\n */\nstatic ssize_t\n__perf_read(struct perf_event *event, char __user *buf, size_t count)\n{\n\tu64 read_format = event->attr.read_format;\n\tint ret;\n\n\t/*\n\t * Return end-of-file for a read on a event that is in\n\t * error state (i.e. because it was pinned but it couldn't be\n\t * scheduled on to the CPU at some point).\n\t */\n\tif (event->state == PERF_EVENT_STATE_ERROR)\n\t\treturn 0;\n\n\tif (count < event->read_size)\n\t\treturn -ENOSPC;\n\n\tWARN_ON_ONCE(event->ctx->parent_ctx);\n\tif (read_format & PERF_FORMAT_GROUP)\n\t\tret = perf_read_group(event, read_format, buf);\n\telse\n\t\tret = perf_read_one(event, read_format, buf);\n\n\treturn ret;\n}\n\nstatic ssize_t\nperf_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct perf_event *event = file->private_data;\n\tstruct perf_event_context *ctx;\n\tint ret;\n\n\tctx = perf_event_ctx_lock(event);\n\tret = __perf_read(event, buf, count);\n\tperf_event_ctx_unlock(event, ctx);\n\n\treturn ret;\n}\n\nstatic unsigned int perf_poll(struct file *file, poll_table *wait)\n{\n\tstruct perf_event *event = file->private_data;\n\tstruct ring_buffer *rb;\n\tunsigned int events = POLLHUP;\n\n\tpoll_wait(file, &event->waitq, wait);\n\n\tif (is_event_hup(event))\n\t\treturn events;\n\n\t/*\n\t * Pin the event->rb by taking event->mmap_mutex; otherwise\n\t * perf_event_set_output() can swizzle our rb and make us miss wakeups.\n\t */\n\tmutex_lock(&event->mmap_mutex);\n\trb = event->rb;\n\tif (rb)\n\t\tevents = atomic_xchg(&rb->poll, 0);\n\tmutex_unlock(&event->mmap_mutex);\n\treturn events;\n}\n\nstatic void _perf_event_reset(struct perf_event *event)\n{\n\t(void)perf_event_read(event, false);\n\tlocal64_set(&event->count, 0);\n\tperf_event_update_userpage(event);\n}\n\n/*\n * Holding the top-level event's child_mutex means that any\n * descendant process that has inherited this event will block\n * in perf_event_exit_event() if it goes to exit, thus satisfying the\n * task existence requirements of perf_event_enable/disable.\n */\nstatic void perf_event_for_each_child(struct perf_event *event,\n\t\t\t\t\tvoid (*func)(struct perf_event *))\n{\n\tstruct perf_event *child;\n\n\tWARN_ON_ONCE(event->ctx->parent_ctx);\n\n\tmutex_lock(&event->child_mutex);\n\tfunc(event);\n\tlist_for_each_entry(child, &event->child_list, child_list)\n\t\tfunc(child);\n\tmutex_unlock(&event->child_mutex);\n}\n\nstatic void perf_event_for_each(struct perf_event *event,\n\t\t\t\t  void (*func)(struct perf_event *))\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_event *sibling;\n\n\tlockdep_assert_held(&ctx->mutex);\n\n\tevent = event->group_leader;\n\n\tperf_event_for_each_child(event, func);\n\tlist_for_each_entry(sibling, &event->sibling_list, group_entry)\n\t\tperf_event_for_each_child(sibling, func);\n}\n\nstatic void __perf_event_period(struct perf_event *event,\n\t\t\t\tstruct perf_cpu_context *cpuctx,\n\t\t\t\tstruct perf_event_context *ctx,\n\t\t\t\tvoid *info)\n{\n\tu64 value = *((u64 *)info);\n\tbool active;\n\n\tif (event->attr.freq) {\n\t\tevent->attr.sample_freq = value;\n\t} else {\n\t\tevent->attr.sample_period = value;\n\t\tevent->hw.sample_period = value;\n\t}\n\n\tactive = (event->state == PERF_EVENT_STATE_ACTIVE);\n\tif (active) {\n\t\tperf_pmu_disable(ctx->pmu);\n\t\t/*\n\t\t * We could be throttled; unthrottle now to avoid the tick\n\t\t * trying to unthrottle while we already re-started the event.\n\t\t */\n\t\tif (event->hw.interrupts == MAX_INTERRUPTS) {\n\t\t\tevent->hw.interrupts = 0;\n\t\t\tperf_log_throttle(event, 1);\n\t\t}\n\t\tevent->pmu->stop(event, PERF_EF_UPDATE);\n\t}\n\n\tlocal64_set(&event->hw.period_left, 0);\n\n\tif (active) {\n\t\tevent->pmu->start(event, PERF_EF_RELOAD);\n\t\tperf_pmu_enable(ctx->pmu);\n\t}\n}\n\nstatic int perf_event_period(struct perf_event *event, u64 __user *arg)\n{\n\tu64 value;\n\n\tif (!is_sampling_event(event))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&value, arg, sizeof(value)))\n\t\treturn -EFAULT;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\n\tif (event->attr.freq && value > sysctl_perf_event_sample_rate)\n\t\treturn -EINVAL;\n\n\tevent_function_call(event, __perf_event_period, &value);\n\n\treturn 0;\n}\n\nstatic const struct file_operations perf_fops;\n\nstatic inline int perf_fget_light(int fd, struct fd *p)\n{\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tif (f.file->f_op != &perf_fops) {\n\t\tfdput(f);\n\t\treturn -EBADF;\n\t}\n\t*p = f;\n\treturn 0;\n}\n\nstatic int perf_event_set_output(struct perf_event *event,\n\t\t\t\t struct perf_event *output_event);\nstatic int perf_event_set_filter(struct perf_event *event, void __user *arg);\nstatic int perf_event_set_bpf_prog(struct perf_event *event, u32 prog_fd);\n\nstatic long _perf_ioctl(struct perf_event *event, unsigned int cmd, unsigned long arg)\n{\n\tvoid (*func)(struct perf_event *);\n\tu32 flags = arg;\n\n\tswitch (cmd) {\n\tcase PERF_EVENT_IOC_ENABLE:\n\t\tfunc = _perf_event_enable;\n\t\tbreak;\n\tcase PERF_EVENT_IOC_DISABLE:\n\t\tfunc = _perf_event_disable;\n\t\tbreak;\n\tcase PERF_EVENT_IOC_RESET:\n\t\tfunc = _perf_event_reset;\n\t\tbreak;\n\n\tcase PERF_EVENT_IOC_REFRESH:\n\t\treturn _perf_event_refresh(event, arg);\n\n\tcase PERF_EVENT_IOC_PERIOD:\n\t\treturn perf_event_period(event, (u64 __user *)arg);\n\n\tcase PERF_EVENT_IOC_ID:\n\t{\n\t\tu64 id = primary_event_id(event);\n\n\t\tif (copy_to_user((void __user *)arg, &id, sizeof(id)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_OUTPUT:\n\t{\n\t\tint ret;\n\t\tif (arg != -1) {\n\t\t\tstruct perf_event *output_event;\n\t\t\tstruct fd output;\n\t\t\tret = perf_fget_light(arg, &output);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\toutput_event = output.file->private_data;\n\t\t\tret = perf_event_set_output(event, output_event);\n\t\t\tfdput(output);\n\t\t} else {\n\t\t\tret = perf_event_set_output(event, NULL);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_FILTER:\n\t\treturn perf_event_set_filter(event, (void __user *)arg);\n\n\tcase PERF_EVENT_IOC_SET_BPF:\n\t\treturn perf_event_set_bpf_prog(event, arg);\n\n\tcase PERF_EVENT_IOC_PAUSE_OUTPUT: {\n\t\tstruct ring_buffer *rb;\n\n\t\trcu_read_lock();\n\t\trb = rcu_dereference(event->rb);\n\t\tif (!rb || !rb->nr_pages) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trb_toggle_paused(rb, !!arg);\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tif (flags & PERF_IOC_FLAG_GROUP)\n\t\tperf_event_for_each(event, func);\n\telse\n\t\tperf_event_for_each_child(event, func);\n\n\treturn 0;\n}\n\nstatic long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct perf_event *event = file->private_data;\n\tstruct perf_event_context *ctx;\n\tlong ret;\n\n\tctx = perf_event_ctx_lock(event);\n\tret = _perf_ioctl(event, cmd, arg);\n\tperf_event_ctx_unlock(event, ctx);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long perf_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tswitch (_IOC_NR(cmd)) {\n\tcase _IOC_NR(PERF_EVENT_IOC_SET_FILTER):\n\tcase _IOC_NR(PERF_EVENT_IOC_ID):\n\t\t/* Fix up pointer size (usually 4 -> 8 in 32-on-64-bit case */\n\t\tif (_IOC_SIZE(cmd) == sizeof(compat_uptr_t)) {\n\t\t\tcmd &= ~IOCSIZE_MASK;\n\t\t\tcmd |= sizeof(void *) << IOCSIZE_SHIFT;\n\t\t}\n\t\tbreak;\n\t}\n\treturn perf_ioctl(file, cmd, arg);\n}\n#else\n# define perf_compat_ioctl NULL\n#endif\n\nint perf_event_task_enable(void)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\n\tmutex_lock(&current->perf_event_mutex);\n\tlist_for_each_entry(event, &current->perf_event_list, owner_entry) {\n\t\tctx = perf_event_ctx_lock(event);\n\t\tperf_event_for_each_child(event, _perf_event_enable);\n\t\tperf_event_ctx_unlock(event, ctx);\n\t}\n\tmutex_unlock(&current->perf_event_mutex);\n\n\treturn 0;\n}\n\nint perf_event_task_disable(void)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\n\tmutex_lock(&current->perf_event_mutex);\n\tlist_for_each_entry(event, &current->perf_event_list, owner_entry) {\n\t\tctx = perf_event_ctx_lock(event);\n\t\tperf_event_for_each_child(event, _perf_event_disable);\n\t\tperf_event_ctx_unlock(event, ctx);\n\t}\n\tmutex_unlock(&current->perf_event_mutex);\n\n\treturn 0;\n}\n\nstatic int perf_event_index(struct perf_event *event)\n{\n\tif (event->hw.state & PERF_HES_STOPPED)\n\t\treturn 0;\n\n\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\treturn 0;\n\n\treturn event->pmu->event_idx(event);\n}\n\nstatic void calc_timer_values(struct perf_event *event,\n\t\t\t\tu64 *now,\n\t\t\t\tu64 *enabled,\n\t\t\t\tu64 *running)\n{\n\tu64 ctx_time;\n\n\t*now = perf_clock();\n\tctx_time = event->shadow_ctx_time + *now;\n\t*enabled = ctx_time - event->tstamp_enabled;\n\t*running = ctx_time - event->tstamp_running;\n}\n\nstatic void perf_event_init_userpage(struct perf_event *event)\n{\n\tstruct perf_event_mmap_page *userpg;\n\tstruct ring_buffer *rb;\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (!rb)\n\t\tgoto unlock;\n\n\tuserpg = rb->user_page;\n\n\t/* Allow new userspace to detect that bit 0 is deprecated */\n\tuserpg->cap_bit0_is_deprecated = 1;\n\tuserpg->size = offsetof(struct perf_event_mmap_page, __reserved);\n\tuserpg->data_offset = PAGE_SIZE;\n\tuserpg->data_size = perf_data_size(rb);\n\nunlock:\n\trcu_read_unlock();\n}\n\nvoid __weak arch_perf_update_userpage(\n\tstruct perf_event *event, struct perf_event_mmap_page *userpg, u64 now)\n{\n}\n\n/*\n * Callers need to ensure there can be no nesting of this function, otherwise\n * the seqlock logic goes bad. We can not serialize this because the arch\n * code calls this from NMI context.\n */\nvoid perf_event_update_userpage(struct perf_event *event)\n{\n\tstruct perf_event_mmap_page *userpg;\n\tstruct ring_buffer *rb;\n\tu64 enabled, running, now;\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (!rb)\n\t\tgoto unlock;\n\n\t/*\n\t * compute total_time_enabled, total_time_running\n\t * based on snapshot values taken when the event\n\t * was last scheduled in.\n\t *\n\t * we cannot simply called update_context_time()\n\t * because of locking issue as we can be called in\n\t * NMI context\n\t */\n\tcalc_timer_values(event, &now, &enabled, &running);\n\n\tuserpg = rb->user_page;\n\t/*\n\t * Disable preemption so as to not let the corresponding user-space\n\t * spin too long if we get preempted.\n\t */\n\tpreempt_disable();\n\t++userpg->lock;\n\tbarrier();\n\tuserpg->index = perf_event_index(event);\n\tuserpg->offset = perf_event_count(event);\n\tif (userpg->index)\n\t\tuserpg->offset -= local64_read(&event->hw.prev_count);\n\n\tuserpg->time_enabled = enabled +\n\t\t\tatomic64_read(&event->child_total_time_enabled);\n\n\tuserpg->time_running = running +\n\t\t\tatomic64_read(&event->child_total_time_running);\n\n\tarch_perf_update_userpage(event, userpg, now);\n\n\tbarrier();\n\t++userpg->lock;\n\tpreempt_enable();\nunlock:\n\trcu_read_unlock();\n}\n\nstatic int perf_mmap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct perf_event *event = vma->vm_file->private_data;\n\tstruct ring_buffer *rb;\n\tint ret = VM_FAULT_SIGBUS;\n\n\tif (vmf->flags & FAULT_FLAG_MKWRITE) {\n\t\tif (vmf->pgoff == 0)\n\t\t\tret = 0;\n\t\treturn ret;\n\t}\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (!rb)\n\t\tgoto unlock;\n\n\tif (vmf->pgoff && (vmf->flags & FAULT_FLAG_WRITE))\n\t\tgoto unlock;\n\n\tvmf->page = perf_mmap_to_page(rb, vmf->pgoff);\n\tif (!vmf->page)\n\t\tgoto unlock;\n\n\tget_page(vmf->page);\n\tvmf->page->mapping = vma->vm_file->f_mapping;\n\tvmf->page->index   = vmf->pgoff;\n\n\tret = 0;\nunlock:\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct ring_buffer *rb)\n{\n\tstruct ring_buffer *old_rb = NULL;\n\tunsigned long flags;\n\n\tif (event->rb) {\n\t\t/*\n\t\t * Should be impossible, we set this when removing\n\t\t * event->rb_entry and wait/clear when adding event->rb_entry.\n\t\t */\n\t\tWARN_ON_ONCE(event->rcu_pending);\n\n\t\told_rb = event->rb;\n\t\tspin_lock_irqsave(&old_rb->event_lock, flags);\n\t\tlist_del_rcu(&event->rb_entry);\n\t\tspin_unlock_irqrestore(&old_rb->event_lock, flags);\n\n\t\tevent->rcu_batches = get_state_synchronize_rcu();\n\t\tevent->rcu_pending = 1;\n\t}\n\n\tif (rb) {\n\t\tif (event->rcu_pending) {\n\t\t\tcond_synchronize_rcu(event->rcu_batches);\n\t\t\tevent->rcu_pending = 0;\n\t\t}\n\n\t\tspin_lock_irqsave(&rb->event_lock, flags);\n\t\tlist_add_rcu(&event->rb_entry, &rb->event_list);\n\t\tspin_unlock_irqrestore(&rb->event_lock, flags);\n\t}\n\n\t/*\n\t * Avoid racing with perf_mmap_close(AUX): stop the event\n\t * before swizzling the event::rb pointer; if it's getting\n\t * unmapped, its aux_mmap_count will be 0 and it won't\n\t * restart. See the comment in __perf_pmu_output_stop().\n\t *\n\t * Data will inevitably be lost when set_output is done in\n\t * mid-air, but then again, whoever does it like this is\n\t * not in for the data anyway.\n\t */\n\tif (has_aux(event))\n\t\tperf_event_stop(event, 0);\n\n\trcu_assign_pointer(event->rb, rb);\n\n\tif (old_rb) {\n\t\tring_buffer_put(old_rb);\n\t\t/*\n\t\t * Since we detached before setting the new rb, so that we\n\t\t * could attach the new rb, we could have missed a wakeup.\n\t\t * Provide it now.\n\t\t */\n\t\twake_up_all(&event->waitq);\n\t}\n}\n\nstatic void ring_buffer_wakeup(struct perf_event *event)\n{\n\tstruct ring_buffer *rb;\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (rb) {\n\t\tlist_for_each_entry_rcu(event, &rb->event_list, rb_entry)\n\t\t\twake_up_all(&event->waitq);\n\t}\n\trcu_read_unlock();\n}\n\nstruct ring_buffer *ring_buffer_get(struct perf_event *event)\n{\n\tstruct ring_buffer *rb;\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (rb) {\n\t\tif (!atomic_inc_not_zero(&rb->refcount))\n\t\t\trb = NULL;\n\t}\n\trcu_read_unlock();\n\n\treturn rb;\n}\n\nvoid ring_buffer_put(struct ring_buffer *rb)\n{\n\tif (!atomic_dec_and_test(&rb->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&rb->event_list));\n\n\tcall_rcu(&rb->rcu_head, rb_free_rcu);\n}\n\nstatic void perf_mmap_open(struct vm_area_struct *vma)\n{\n\tstruct perf_event *event = vma->vm_file->private_data;\n\n\tatomic_inc(&event->mmap_count);\n\tatomic_inc(&event->rb->mmap_count);\n\n\tif (vma->vm_pgoff)\n\t\tatomic_inc(&event->rb->aux_mmap_count);\n\n\tif (event->pmu->event_mapped)\n\t\tevent->pmu->event_mapped(event);\n}\n\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\n/*\n * A buffer can be mmap()ed multiple times; either directly through the same\n * event, or through other events by use of perf_event_set_output().\n *\n * In order to undo the VM accounting done by perf_mmap() we need to destroy\n * the buffer here, where we still have a VM context. This means we need\n * to detach all events redirecting to us.\n */\nstatic void perf_mmap_close(struct vm_area_struct *vma)\n{\n\tstruct perf_event *event = vma->vm_file->private_data;\n\n\tstruct ring_buffer *rb = ring_buffer_get(event);\n\tstruct user_struct *mmap_user = rb->mmap_user;\n\tint mmap_locked = rb->mmap_locked;\n\tunsigned long size = perf_data_size(rb);\n\n\tif (event->pmu->event_unmapped)\n\t\tevent->pmu->event_unmapped(event);\n\n\t/*\n\t * rb->aux_mmap_count will always drop before rb->mmap_count and\n\t * event->mmap_count, so it is ok to use event->mmap_mutex to\n\t * serialize with perf_mmap here.\n\t */\n\tif (rb_has_aux(rb) && vma->vm_pgoff == rb->aux_pgoff &&\n\t    atomic_dec_and_mutex_lock(&rb->aux_mmap_count, &event->mmap_mutex)) {\n\t\t/*\n\t\t * Stop all AUX events that are writing to this buffer,\n\t\t * so that we can free its AUX pages and corresponding PMU\n\t\t * data. Note that after rb::aux_mmap_count dropped to zero,\n\t\t * they won't start any more (see perf_aux_output_begin()).\n\t\t */\n\t\tperf_pmu_output_stop(event);\n\n\t\t/* now it's safe to free the pages */\n\t\tatomic_long_sub(rb->aux_nr_pages, &mmap_user->locked_vm);\n\t\tvma->vm_mm->pinned_vm -= rb->aux_mmap_locked;\n\n\t\t/* this has to be the last one */\n\t\trb_free_aux(rb);\n\t\tWARN_ON_ONCE(atomic_read(&rb->aux_refcount));\n\n\t\tmutex_unlock(&event->mmap_mutex);\n\t}\n\n\tatomic_dec(&rb->mmap_count);\n\n\tif (!atomic_dec_and_mutex_lock(&event->mmap_count, &event->mmap_mutex))\n\t\tgoto out_put;\n\n\tring_buffer_attach(event, NULL);\n\tmutex_unlock(&event->mmap_mutex);\n\n\t/* If there's still other mmap()s of this buffer, we're done. */\n\tif (atomic_read(&rb->mmap_count))\n\t\tgoto out_put;\n\n\t/*\n\t * No other mmap()s, detach from all other events that might redirect\n\t * into the now unreachable buffer. Somewhat complicated by the\n\t * fact that rb::event_lock otherwise nests inside mmap_mutex.\n\t */\nagain:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(event, &rb->event_list, rb_entry) {\n\t\tif (!atomic_long_inc_not_zero(&event->refcount)) {\n\t\t\t/*\n\t\t\t * This event is en-route to free_event() which will\n\t\t\t * detach it and remove it from the list.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tmutex_lock(&event->mmap_mutex);\n\t\t/*\n\t\t * Check we didn't race with perf_event_set_output() which can\n\t\t * swizzle the rb from under us while we were waiting to\n\t\t * acquire mmap_mutex.\n\t\t *\n\t\t * If we find a different rb; ignore this event, a next\n\t\t * iteration will no longer find it on the list. We have to\n\t\t * still restart the iteration to make sure we're not now\n\t\t * iterating the wrong list.\n\t\t */\n\t\tif (event->rb == rb)\n\t\t\tring_buffer_attach(event, NULL);\n\n\t\tmutex_unlock(&event->mmap_mutex);\n\t\tput_event(event);\n\n\t\t/*\n\t\t * Restart the iteration; either we're on the wrong list or\n\t\t * destroyed its integrity by doing a deletion.\n\t\t */\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * It could be there's still a few 0-ref events on the list; they'll\n\t * get cleaned up by free_event() -- they'll also still have their\n\t * ref on the rb and will free it whenever they are done with it.\n\t *\n\t * Aside from that, this buffer is 'fully' detached and unmapped,\n\t * undo the VM accounting.\n\t */\n\n\tatomic_long_sub((size >> PAGE_SHIFT) + 1, &mmap_user->locked_vm);\n\tvma->vm_mm->pinned_vm -= mmap_locked;\n\tfree_uid(mmap_user);\n\nout_put:\n\tring_buffer_put(rb); /* could be last */\n}\n\nstatic const struct vm_operations_struct perf_mmap_vmops = {\n\t.open\t\t= perf_mmap_open,\n\t.close\t\t= perf_mmap_close, /* non mergable */\n\t.fault\t\t= perf_mmap_fault,\n\t.page_mkwrite\t= perf_mmap_fault,\n};\n\nstatic int perf_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct perf_event *event = file->private_data;\n\tunsigned long user_locked, user_lock_limit;\n\tstruct user_struct *user = current_user();\n\tunsigned long locked, lock_limit;\n\tstruct ring_buffer *rb = NULL;\n\tunsigned long vma_size;\n\tunsigned long nr_pages;\n\tlong user_extra = 0, extra = 0;\n\tint ret = 0, flags = 0;\n\n\t/*\n\t * Don't allow mmap() of inherited per-task counters. This would\n\t * create a performance issue due to all children writing to the\n\t * same rb.\n\t */\n\tif (event->cpu == -1 && event->attr.inherit)\n\t\treturn -EINVAL;\n\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\tvma_size = vma->vm_end - vma->vm_start;\n\n\tif (vma->vm_pgoff == 0) {\n\t\tnr_pages = (vma_size / PAGE_SIZE) - 1;\n\t} else {\n\t\t/*\n\t\t * AUX area mapping: if rb->aux_nr_pages != 0, it's already\n\t\t * mapped, all subsequent mappings should have the same size\n\t\t * and offset. Must be above the normal perf buffer.\n\t\t */\n\t\tu64 aux_offset, aux_size;\n\n\t\tif (!event->rb)\n\t\t\treturn -EINVAL;\n\n\t\tnr_pages = vma_size / PAGE_SIZE;\n\n\t\tmutex_lock(&event->mmap_mutex);\n\t\tret = -EINVAL;\n\n\t\trb = event->rb;\n\t\tif (!rb)\n\t\t\tgoto aux_unlock;\n\n\t\taux_offset = ACCESS_ONCE(rb->user_page->aux_offset);\n\t\taux_size = ACCESS_ONCE(rb->user_page->aux_size);\n\n\t\tif (aux_offset < perf_data_size(rb) + PAGE_SIZE)\n\t\t\tgoto aux_unlock;\n\n\t\tif (aux_offset != vma->vm_pgoff << PAGE_SHIFT)\n\t\t\tgoto aux_unlock;\n\n\t\t/* already mapped with a different offset */\n\t\tif (rb_has_aux(rb) && rb->aux_pgoff != vma->vm_pgoff)\n\t\t\tgoto aux_unlock;\n\n\t\tif (aux_size != vma_size || aux_size != nr_pages * PAGE_SIZE)\n\t\t\tgoto aux_unlock;\n\n\t\t/* already mapped with a different size */\n\t\tif (rb_has_aux(rb) && rb->aux_nr_pages != nr_pages)\n\t\t\tgoto aux_unlock;\n\n\t\tif (!is_power_of_2(nr_pages))\n\t\t\tgoto aux_unlock;\n\n\t\tif (!atomic_inc_not_zero(&rb->mmap_count))\n\t\t\tgoto aux_unlock;\n\n\t\tif (rb_has_aux(rb)) {\n\t\t\tatomic_inc(&rb->aux_mmap_count);\n\t\t\tret = 0;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tatomic_set(&rb->aux_mmap_count, 1);\n\t\tuser_extra = nr_pages;\n\n\t\tgoto accounting;\n\t}\n\n\t/*\n\t * If we have rb pages ensure they're a power-of-two number, so we\n\t * can do bitmasks instead of modulo.\n\t */\n\tif (nr_pages != 0 && !is_power_of_2(nr_pages))\n\t\treturn -EINVAL;\n\n\tif (vma_size != PAGE_SIZE * (1 + nr_pages))\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(event->ctx->parent_ctx);\nagain:\n\tmutex_lock(&event->mmap_mutex);\n\tif (event->rb) {\n\t\tif (event->rb->nr_pages != nr_pages) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (!atomic_inc_not_zero(&event->rb->mmap_count)) {\n\t\t\t/*\n\t\t\t * Raced against perf_mmap_close() through\n\t\t\t * perf_event_set_output(). Try again, hope for better\n\t\t\t * luck.\n\t\t\t */\n\t\t\tmutex_unlock(&event->mmap_mutex);\n\t\t\tgoto again;\n\t\t}\n\n\t\tgoto unlock;\n\t}\n\n\tuser_extra = nr_pages + 1;\n\naccounting:\n\tuser_lock_limit = sysctl_perf_event_mlock >> (PAGE_SHIFT - 10);\n\n\t/*\n\t * Increase the limit linearly with more CPUs:\n\t */\n\tuser_lock_limit *= num_online_cpus();\n\n\tuser_locked = atomic_long_read(&user->locked_vm) + user_extra;\n\n\tif (user_locked > user_lock_limit)\n\t\textra = user_locked - user_lock_limit;\n\n\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\tlock_limit >>= PAGE_SHIFT;\n\tlocked = vma->vm_mm->pinned_vm + extra;\n\n\tif ((locked > lock_limit) && perf_paranoid_tracepoint_raw() &&\n\t\t!capable(CAP_IPC_LOCK)) {\n\t\tret = -EPERM;\n\t\tgoto unlock;\n\t}\n\n\tWARN_ON(!rb && event->rb);\n\n\tif (vma->vm_flags & VM_WRITE)\n\t\tflags |= RING_BUFFER_WRITABLE;\n\n\tif (!rb) {\n\t\trb = rb_alloc(nr_pages,\n\t\t\t      event->attr.watermark ? event->attr.wakeup_watermark : 0,\n\t\t\t      event->cpu, flags);\n\n\t\tif (!rb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tatomic_set(&rb->mmap_count, 1);\n\t\trb->mmap_user = get_current_user();\n\t\trb->mmap_locked = extra;\n\n\t\tring_buffer_attach(event, rb);\n\n\t\tperf_event_init_userpage(event);\n\t\tperf_event_update_userpage(event);\n\t} else {\n\t\tret = rb_alloc_aux(rb, event, vma->vm_pgoff, nr_pages,\n\t\t\t\t   event->attr.aux_watermark, flags);\n\t\tif (!ret)\n\t\t\trb->aux_mmap_locked = extra;\n\t}\n\nunlock:\n\tif (!ret) {\n\t\tatomic_long_add(user_extra, &user->locked_vm);\n\t\tvma->vm_mm->pinned_vm += extra;\n\n\t\tatomic_inc(&event->mmap_count);\n\t} else if (rb) {\n\t\tatomic_dec(&rb->mmap_count);\n\t}\naux_unlock:\n\tmutex_unlock(&event->mmap_mutex);\n\n\t/*\n\t * Since pinned accounting is per vm we cannot allow fork() to copy our\n\t * vma.\n\t */\n\tvma->vm_flags |= VM_DONTCOPY | VM_DONTEXPAND | VM_DONTDUMP;\n\tvma->vm_ops = &perf_mmap_vmops;\n\n\tif (event->pmu->event_mapped)\n\t\tevent->pmu->event_mapped(event);\n\n\treturn ret;\n}\n\nstatic int perf_fasync(int fd, struct file *filp, int on)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct perf_event *event = filp->private_data;\n\tint retval;\n\n\tinode_lock(inode);\n\tretval = fasync_helper(fd, filp, on, &event->fasync);\n\tinode_unlock(inode);\n\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn 0;\n}\n\nstatic const struct file_operations perf_fops = {\n\t.llseek\t\t\t= no_llseek,\n\t.release\t\t= perf_release,\n\t.read\t\t\t= perf_read,\n\t.poll\t\t\t= perf_poll,\n\t.unlocked_ioctl\t\t= perf_ioctl,\n\t.compat_ioctl\t\t= perf_compat_ioctl,\n\t.mmap\t\t\t= perf_mmap,\n\t.fasync\t\t\t= perf_fasync,\n};\n\n/*\n * Perf event wakeup\n *\n * If there's data, ensure we set the poll() state and publish everything\n * to user-space before waking everybody up.\n */\n\nstatic inline struct fasync_struct **perf_event_fasync(struct perf_event *event)\n{\n\t/* only the parent has fasync state */\n\tif (event->parent)\n\t\tevent = event->parent;\n\treturn &event->fasync;\n}\n\nvoid perf_event_wakeup(struct perf_event *event)\n{\n\tring_buffer_wakeup(event);\n\n\tif (event->pending_kill) {\n\t\tkill_fasync(perf_event_fasync(event), SIGIO, event->pending_kill);\n\t\tevent->pending_kill = 0;\n\t}\n}\n\nstatic void perf_pending_event(struct irq_work *entry)\n{\n\tstruct perf_event *event = container_of(entry,\n\t\t\tstruct perf_event, pending);\n\tint rctx;\n\n\trctx = perf_swevent_get_recursion_context();\n\t/*\n\t * If we 'fail' here, that's OK, it means recursion is already disabled\n\t * and we won't recurse 'further'.\n\t */\n\n\tif (event->pending_disable) {\n\t\tevent->pending_disable = 0;\n\t\tperf_event_disable_local(event);\n\t}\n\n\tif (event->pending_wakeup) {\n\t\tevent->pending_wakeup = 0;\n\t\tperf_event_wakeup(event);\n\t}\n\n\tif (rctx >= 0)\n\t\tperf_swevent_put_recursion_context(rctx);\n}\n\n/*\n * We assume there is only KVM supporting the callbacks.\n * Later on, we might change it to a list if there is\n * another virtualization implementation supporting the callbacks.\n */\nstruct perf_guest_info_callbacks *perf_guest_cbs;\n\nint perf_register_guest_info_callbacks(struct perf_guest_info_callbacks *cbs)\n{\n\tperf_guest_cbs = cbs;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(perf_register_guest_info_callbacks);\n\nint perf_unregister_guest_info_callbacks(struct perf_guest_info_callbacks *cbs)\n{\n\tperf_guest_cbs = NULL;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(perf_unregister_guest_info_callbacks);\n\nstatic void\nperf_output_sample_regs(struct perf_output_handle *handle,\n\t\t\tstruct pt_regs *regs, u64 mask)\n{\n\tint bit;\n\tDECLARE_BITMAP(_mask, 64);\n\n\tbitmap_from_u64(_mask, mask);\n\tfor_each_set_bit(bit, _mask, sizeof(mask) * BITS_PER_BYTE) {\n\t\tu64 val;\n\n\t\tval = perf_reg_value(regs, bit);\n\t\tperf_output_put(handle, val);\n\t}\n}\n\nstatic void perf_sample_regs_user(struct perf_regs *regs_user,\n\t\t\t\t  struct pt_regs *regs,\n\t\t\t\t  struct pt_regs *regs_user_copy)\n{\n\tif (user_mode(regs)) {\n\t\tregs_user->abi = perf_reg_abi(current);\n\t\tregs_user->regs = regs;\n\t} else if (current->mm) {\n\t\tperf_get_regs_user(regs_user, regs, regs_user_copy);\n\t} else {\n\t\tregs_user->abi = PERF_SAMPLE_REGS_ABI_NONE;\n\t\tregs_user->regs = NULL;\n\t}\n}\n\nstatic void perf_sample_regs_intr(struct perf_regs *regs_intr,\n\t\t\t\t  struct pt_regs *regs)\n{\n\tregs_intr->regs = regs;\n\tregs_intr->abi  = perf_reg_abi(current);\n}\n\n\n/*\n * Get remaining task size from user stack pointer.\n *\n * It'd be better to take stack vma map and limit this more\n * precisly, but there's no way to get it safely under interrupt,\n * so using TASK_SIZE as limit.\n */\nstatic u64 perf_ustack_task_size(struct pt_regs *regs)\n{\n\tunsigned long addr = perf_user_stack_pointer(regs);\n\n\tif (!addr || addr >= TASK_SIZE)\n\t\treturn 0;\n\n\treturn TASK_SIZE - addr;\n}\n\nstatic u16\nperf_sample_ustack_size(u16 stack_size, u16 header_size,\n\t\t\tstruct pt_regs *regs)\n{\n\tu64 task_size;\n\n\t/* No regs, no stack pointer, no dump. */\n\tif (!regs)\n\t\treturn 0;\n\n\t/*\n\t * Check if we fit in with the requested stack size into the:\n\t * - TASK_SIZE\n\t *   If we don't, we limit the size to the TASK_SIZE.\n\t *\n\t * - remaining sample size\n\t *   If we don't, we customize the stack size to\n\t *   fit in to the remaining sample size.\n\t */\n\n\ttask_size  = min((u64) USHRT_MAX, perf_ustack_task_size(regs));\n\tstack_size = min(stack_size, (u16) task_size);\n\n\t/* Current header size plus static size and dynamic size. */\n\theader_size += 2 * sizeof(u64);\n\n\t/* Do we fit in with the current stack dump size? */\n\tif ((u16) (header_size + stack_size) < header_size) {\n\t\t/*\n\t\t * If we overflow the maximum size for the sample,\n\t\t * we customize the stack dump size to fit in.\n\t\t */\n\t\tstack_size = USHRT_MAX - header_size - sizeof(u64);\n\t\tstack_size = round_up(stack_size, sizeof(u64));\n\t}\n\n\treturn stack_size;\n}\n\nstatic void\nperf_output_sample_ustack(struct perf_output_handle *handle, u64 dump_size,\n\t\t\t  struct pt_regs *regs)\n{\n\t/* Case of a kernel thread, nothing to dump */\n\tif (!regs) {\n\t\tu64 size = 0;\n\t\tperf_output_put(handle, size);\n\t} else {\n\t\tunsigned long sp;\n\t\tunsigned int rem;\n\t\tu64 dyn_size;\n\n\t\t/*\n\t\t * We dump:\n\t\t * static size\n\t\t *   - the size requested by user or the best one we can fit\n\t\t *     in to the sample max size\n\t\t * data\n\t\t *   - user stack dump data\n\t\t * dynamic size\n\t\t *   - the actual dumped size\n\t\t */\n\n\t\t/* Static size. */\n\t\tperf_output_put(handle, dump_size);\n\n\t\t/* Data. */\n\t\tsp = perf_user_stack_pointer(regs);\n\t\trem = __output_copy_user(handle, (void *) sp, dump_size);\n\t\tdyn_size = dump_size - rem;\n\n\t\tperf_output_skip(handle, rem);\n\n\t\t/* Dynamic size. */\n\t\tperf_output_put(handle, dyn_size);\n\t}\n}\n\nstatic void __perf_event_header__init_id(struct perf_event_header *header,\n\t\t\t\t\t struct perf_sample_data *data,\n\t\t\t\t\t struct perf_event *event)\n{\n\tu64 sample_type = event->attr.sample_type;\n\n\tdata->type = sample_type;\n\theader->size += event->id_header_size;\n\n\tif (sample_type & PERF_SAMPLE_TID) {\n\t\t/* namespace issues */\n\t\tdata->tid_entry.pid = perf_event_pid(event, current);\n\t\tdata->tid_entry.tid = perf_event_tid(event, current);\n\t}\n\n\tif (sample_type & PERF_SAMPLE_TIME)\n\t\tdata->time = perf_event_clock(event);\n\n\tif (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))\n\t\tdata->id = primary_event_id(event);\n\n\tif (sample_type & PERF_SAMPLE_STREAM_ID)\n\t\tdata->stream_id = event->id;\n\n\tif (sample_type & PERF_SAMPLE_CPU) {\n\t\tdata->cpu_entry.cpu\t = raw_smp_processor_id();\n\t\tdata->cpu_entry.reserved = 0;\n\t}\n}\n\nvoid perf_event_header__init_id(struct perf_event_header *header,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct perf_event *event)\n{\n\tif (event->attr.sample_id_all)\n\t\t__perf_event_header__init_id(header, data, event);\n}\n\nstatic void __perf_event__output_id_sample(struct perf_output_handle *handle,\n\t\t\t\t\t   struct perf_sample_data *data)\n{\n\tu64 sample_type = data->type;\n\n\tif (sample_type & PERF_SAMPLE_TID)\n\t\tperf_output_put(handle, data->tid_entry);\n\n\tif (sample_type & PERF_SAMPLE_TIME)\n\t\tperf_output_put(handle, data->time);\n\n\tif (sample_type & PERF_SAMPLE_ID)\n\t\tperf_output_put(handle, data->id);\n\n\tif (sample_type & PERF_SAMPLE_STREAM_ID)\n\t\tperf_output_put(handle, data->stream_id);\n\n\tif (sample_type & PERF_SAMPLE_CPU)\n\t\tperf_output_put(handle, data->cpu_entry);\n\n\tif (sample_type & PERF_SAMPLE_IDENTIFIER)\n\t\tperf_output_put(handle, data->id);\n}\n\nvoid perf_event__output_id_sample(struct perf_event *event,\n\t\t\t\t  struct perf_output_handle *handle,\n\t\t\t\t  struct perf_sample_data *sample)\n{\n\tif (event->attr.sample_id_all)\n\t\t__perf_event__output_id_sample(handle, sample);\n}\n\nstatic void perf_output_read_one(struct perf_output_handle *handle,\n\t\t\t\t struct perf_event *event,\n\t\t\t\t u64 enabled, u64 running)\n{\n\tu64 read_format = event->attr.read_format;\n\tu64 values[4];\n\tint n = 0;\n\n\tvalues[n++] = perf_event_count(event);\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED) {\n\t\tvalues[n++] = enabled +\n\t\t\tatomic64_read(&event->child_total_time_enabled);\n\t}\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING) {\n\t\tvalues[n++] = running +\n\t\t\tatomic64_read(&event->child_total_time_running);\n\t}\n\tif (read_format & PERF_FORMAT_ID)\n\t\tvalues[n++] = primary_event_id(event);\n\n\t__output_copy(handle, values, n * sizeof(u64));\n}\n\n/*\n * XXX PERF_FORMAT_GROUP vs inherited events seems difficult.\n */\nstatic void perf_output_read_group(struct perf_output_handle *handle,\n\t\t\t    struct perf_event *event,\n\t\t\t    u64 enabled, u64 running)\n{\n\tstruct perf_event *leader = event->group_leader, *sub;\n\tu64 read_format = event->attr.read_format;\n\tu64 values[5];\n\tint n = 0;\n\n\tvalues[n++] = 1 + leader->nr_siblings;\n\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)\n\t\tvalues[n++] = enabled;\n\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)\n\t\tvalues[n++] = running;\n\n\tif (leader != event)\n\t\tleader->pmu->read(leader);\n\n\tvalues[n++] = perf_event_count(leader);\n\tif (read_format & PERF_FORMAT_ID)\n\t\tvalues[n++] = primary_event_id(leader);\n\n\t__output_copy(handle, values, n * sizeof(u64));\n\n\tlist_for_each_entry(sub, &leader->sibling_list, group_entry) {\n\t\tn = 0;\n\n\t\tif ((sub != event) &&\n\t\t    (sub->state == PERF_EVENT_STATE_ACTIVE))\n\t\t\tsub->pmu->read(sub);\n\n\t\tvalues[n++] = perf_event_count(sub);\n\t\tif (read_format & PERF_FORMAT_ID)\n\t\t\tvalues[n++] = primary_event_id(sub);\n\n\t\t__output_copy(handle, values, n * sizeof(u64));\n\t}\n}\n\n#define PERF_FORMAT_TOTAL_TIMES (PERF_FORMAT_TOTAL_TIME_ENABLED|\\\n\t\t\t\t PERF_FORMAT_TOTAL_TIME_RUNNING)\n\nstatic void perf_output_read(struct perf_output_handle *handle,\n\t\t\t     struct perf_event *event)\n{\n\tu64 enabled = 0, running = 0, now;\n\tu64 read_format = event->attr.read_format;\n\n\t/*\n\t * compute total_time_enabled, total_time_running\n\t * based on snapshot values taken when the event\n\t * was last scheduled in.\n\t *\n\t * we cannot simply called update_context_time()\n\t * because of locking issue as we are called in\n\t * NMI context\n\t */\n\tif (read_format & PERF_FORMAT_TOTAL_TIMES)\n\t\tcalc_timer_values(event, &now, &enabled, &running);\n\n\tif (event->attr.read_format & PERF_FORMAT_GROUP)\n\t\tperf_output_read_group(handle, event, enabled, running);\n\telse\n\t\tperf_output_read_one(handle, event, enabled, running);\n}\n\nvoid perf_output_sample(struct perf_output_handle *handle,\n\t\t\tstruct perf_event_header *header,\n\t\t\tstruct perf_sample_data *data,\n\t\t\tstruct perf_event *event)\n{\n\tu64 sample_type = data->type;\n\n\tperf_output_put(handle, *header);\n\n\tif (sample_type & PERF_SAMPLE_IDENTIFIER)\n\t\tperf_output_put(handle, data->id);\n\n\tif (sample_type & PERF_SAMPLE_IP)\n\t\tperf_output_put(handle, data->ip);\n\n\tif (sample_type & PERF_SAMPLE_TID)\n\t\tperf_output_put(handle, data->tid_entry);\n\n\tif (sample_type & PERF_SAMPLE_TIME)\n\t\tperf_output_put(handle, data->time);\n\n\tif (sample_type & PERF_SAMPLE_ADDR)\n\t\tperf_output_put(handle, data->addr);\n\n\tif (sample_type & PERF_SAMPLE_ID)\n\t\tperf_output_put(handle, data->id);\n\n\tif (sample_type & PERF_SAMPLE_STREAM_ID)\n\t\tperf_output_put(handle, data->stream_id);\n\n\tif (sample_type & PERF_SAMPLE_CPU)\n\t\tperf_output_put(handle, data->cpu_entry);\n\n\tif (sample_type & PERF_SAMPLE_PERIOD)\n\t\tperf_output_put(handle, data->period);\n\n\tif (sample_type & PERF_SAMPLE_READ)\n\t\tperf_output_read(handle, event);\n\n\tif (sample_type & PERF_SAMPLE_CALLCHAIN) {\n\t\tif (data->callchain) {\n\t\t\tint size = 1;\n\n\t\t\tif (data->callchain)\n\t\t\t\tsize += data->callchain->nr;\n\n\t\t\tsize *= sizeof(u64);\n\n\t\t\t__output_copy(handle, data->callchain, size);\n\t\t} else {\n\t\t\tu64 nr = 0;\n\t\t\tperf_output_put(handle, nr);\n\t\t}\n\t}\n\n\tif (sample_type & PERF_SAMPLE_RAW) {\n\t\tstruct perf_raw_record *raw = data->raw;\n\n\t\tif (raw) {\n\t\t\tstruct perf_raw_frag *frag = &raw->frag;\n\n\t\t\tperf_output_put(handle, raw->size);\n\t\t\tdo {\n\t\t\t\tif (frag->copy) {\n\t\t\t\t\t__output_custom(handle, frag->copy,\n\t\t\t\t\t\t\tfrag->data, frag->size);\n\t\t\t\t} else {\n\t\t\t\t\t__output_copy(handle, frag->data,\n\t\t\t\t\t\t      frag->size);\n\t\t\t\t}\n\t\t\t\tif (perf_raw_frag_last(frag))\n\t\t\t\t\tbreak;\n\t\t\t\tfrag = frag->next;\n\t\t\t} while (1);\n\t\t\tif (frag->pad)\n\t\t\t\t__output_skip(handle, NULL, frag->pad);\n\t\t} else {\n\t\t\tstruct {\n\t\t\t\tu32\tsize;\n\t\t\t\tu32\tdata;\n\t\t\t} raw = {\n\t\t\t\t.size = sizeof(u32),\n\t\t\t\t.data = 0,\n\t\t\t};\n\t\t\tperf_output_put(handle, raw);\n\t\t}\n\t}\n\n\tif (sample_type & PERF_SAMPLE_BRANCH_STACK) {\n\t\tif (data->br_stack) {\n\t\t\tsize_t size;\n\n\t\t\tsize = data->br_stack->nr\n\t\t\t     * sizeof(struct perf_branch_entry);\n\n\t\t\tperf_output_put(handle, data->br_stack->nr);\n\t\t\tperf_output_copy(handle, data->br_stack->entries, size);\n\t\t} else {\n\t\t\t/*\n\t\t\t * we always store at least the value of nr\n\t\t\t */\n\t\t\tu64 nr = 0;\n\t\t\tperf_output_put(handle, nr);\n\t\t}\n\t}\n\n\tif (sample_type & PERF_SAMPLE_REGS_USER) {\n\t\tu64 abi = data->regs_user.abi;\n\n\t\t/*\n\t\t * If there are no regs to dump, notice it through\n\t\t * first u64 being zero (PERF_SAMPLE_REGS_ABI_NONE).\n\t\t */\n\t\tperf_output_put(handle, abi);\n\n\t\tif (abi) {\n\t\t\tu64 mask = event->attr.sample_regs_user;\n\t\t\tperf_output_sample_regs(handle,\n\t\t\t\t\t\tdata->regs_user.regs,\n\t\t\t\t\t\tmask);\n\t\t}\n\t}\n\n\tif (sample_type & PERF_SAMPLE_STACK_USER) {\n\t\tperf_output_sample_ustack(handle,\n\t\t\t\t\t  data->stack_user_size,\n\t\t\t\t\t  data->regs_user.regs);\n\t}\n\n\tif (sample_type & PERF_SAMPLE_WEIGHT)\n\t\tperf_output_put(handle, data->weight);\n\n\tif (sample_type & PERF_SAMPLE_DATA_SRC)\n\t\tperf_output_put(handle, data->data_src.val);\n\n\tif (sample_type & PERF_SAMPLE_TRANSACTION)\n\t\tperf_output_put(handle, data->txn);\n\n\tif (sample_type & PERF_SAMPLE_REGS_INTR) {\n\t\tu64 abi = data->regs_intr.abi;\n\t\t/*\n\t\t * If there are no regs to dump, notice it through\n\t\t * first u64 being zero (PERF_SAMPLE_REGS_ABI_NONE).\n\t\t */\n\t\tperf_output_put(handle, abi);\n\n\t\tif (abi) {\n\t\t\tu64 mask = event->attr.sample_regs_intr;\n\n\t\t\tperf_output_sample_regs(handle,\n\t\t\t\t\t\tdata->regs_intr.regs,\n\t\t\t\t\t\tmask);\n\t\t}\n\t}\n\n\tif (!event->attr.watermark) {\n\t\tint wakeup_events = event->attr.wakeup_events;\n\n\t\tif (wakeup_events) {\n\t\t\tstruct ring_buffer *rb = handle->rb;\n\t\t\tint events = local_inc_return(&rb->events);\n\n\t\t\tif (events >= wakeup_events) {\n\t\t\t\tlocal_sub(wakeup_events, &rb->events);\n\t\t\t\tlocal_inc(&rb->wakeup);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid perf_prepare_sample(struct perf_event_header *header,\n\t\t\t struct perf_sample_data *data,\n\t\t\t struct perf_event *event,\n\t\t\t struct pt_regs *regs)\n{\n\tu64 sample_type = event->attr.sample_type;\n\n\theader->type = PERF_RECORD_SAMPLE;\n\theader->size = sizeof(*header) + event->header_size;\n\n\theader->misc = 0;\n\theader->misc |= perf_misc_flags(regs);\n\n\t__perf_event_header__init_id(header, data, event);\n\n\tif (sample_type & PERF_SAMPLE_IP)\n\t\tdata->ip = perf_instruction_pointer(regs);\n\n\tif (sample_type & PERF_SAMPLE_CALLCHAIN) {\n\t\tint size = 1;\n\n\t\tdata->callchain = perf_callchain(event, regs);\n\n\t\tif (data->callchain)\n\t\t\tsize += data->callchain->nr;\n\n\t\theader->size += size * sizeof(u64);\n\t}\n\n\tif (sample_type & PERF_SAMPLE_RAW) {\n\t\tstruct perf_raw_record *raw = data->raw;\n\t\tint size;\n\n\t\tif (raw) {\n\t\t\tstruct perf_raw_frag *frag = &raw->frag;\n\t\t\tu32 sum = 0;\n\n\t\t\tdo {\n\t\t\t\tsum += frag->size;\n\t\t\t\tif (perf_raw_frag_last(frag))\n\t\t\t\t\tbreak;\n\t\t\t\tfrag = frag->next;\n\t\t\t} while (1);\n\n\t\t\tsize = round_up(sum + sizeof(u32), sizeof(u64));\n\t\t\traw->size = size - sizeof(u32);\n\t\t\tfrag->pad = raw->size - sum;\n\t\t} else {\n\t\t\tsize = sizeof(u64);\n\t\t}\n\n\t\theader->size += size;\n\t}\n\n\tif (sample_type & PERF_SAMPLE_BRANCH_STACK) {\n\t\tint size = sizeof(u64); /* nr */\n\t\tif (data->br_stack) {\n\t\t\tsize += data->br_stack->nr\n\t\t\t      * sizeof(struct perf_branch_entry);\n\t\t}\n\t\theader->size += size;\n\t}\n\n\tif (sample_type & (PERF_SAMPLE_REGS_USER | PERF_SAMPLE_STACK_USER))\n\t\tperf_sample_regs_user(&data->regs_user, regs,\n\t\t\t\t      &data->regs_user_copy);\n\n\tif (sample_type & PERF_SAMPLE_REGS_USER) {\n\t\t/* regs dump ABI info */\n\t\tint size = sizeof(u64);\n\n\t\tif (data->regs_user.regs) {\n\t\t\tu64 mask = event->attr.sample_regs_user;\n\t\t\tsize += hweight64(mask) * sizeof(u64);\n\t\t}\n\n\t\theader->size += size;\n\t}\n\n\tif (sample_type & PERF_SAMPLE_STACK_USER) {\n\t\t/*\n\t\t * Either we need PERF_SAMPLE_STACK_USER bit to be allways\n\t\t * processed as the last one or have additional check added\n\t\t * in case new sample type is added, because we could eat\n\t\t * up the rest of the sample size.\n\t\t */\n\t\tu16 stack_size = event->attr.sample_stack_user;\n\t\tu16 size = sizeof(u64);\n\n\t\tstack_size = perf_sample_ustack_size(stack_size, header->size,\n\t\t\t\t\t\t     data->regs_user.regs);\n\n\t\t/*\n\t\t * If there is something to dump, add space for the dump\n\t\t * itself and for the field that tells the dynamic size,\n\t\t * which is how many have been actually dumped.\n\t\t */\n\t\tif (stack_size)\n\t\t\tsize += sizeof(u64) + stack_size;\n\n\t\tdata->stack_user_size = stack_size;\n\t\theader->size += size;\n\t}\n\n\tif (sample_type & PERF_SAMPLE_REGS_INTR) {\n\t\t/* regs dump ABI info */\n\t\tint size = sizeof(u64);\n\n\t\tperf_sample_regs_intr(&data->regs_intr, regs);\n\n\t\tif (data->regs_intr.regs) {\n\t\t\tu64 mask = event->attr.sample_regs_intr;\n\n\t\t\tsize += hweight64(mask) * sizeof(u64);\n\t\t}\n\n\t\theader->size += size;\n\t}\n}\n\nstatic void __always_inline\n__perf_event_output(struct perf_event *event,\n\t\t    struct perf_sample_data *data,\n\t\t    struct pt_regs *regs,\n\t\t    int (*output_begin)(struct perf_output_handle *,\n\t\t\t\t\tstruct perf_event *,\n\t\t\t\t\tunsigned int))\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_event_header header;\n\n\t/* protect the callchain buffers */\n\trcu_read_lock();\n\n\tperf_prepare_sample(&header, data, event, regs);\n\n\tif (output_begin(&handle, event, header.size))\n\t\tgoto exit;\n\n\tperf_output_sample(&handle, &header, data, event);\n\n\tperf_output_end(&handle);\n\nexit:\n\trcu_read_unlock();\n}\n\nvoid\nperf_event_output_forward(struct perf_event *event,\n\t\t\t struct perf_sample_data *data,\n\t\t\t struct pt_regs *regs)\n{\n\t__perf_event_output(event, data, regs, perf_output_begin_forward);\n}\n\nvoid\nperf_event_output_backward(struct perf_event *event,\n\t\t\t   struct perf_sample_data *data,\n\t\t\t   struct pt_regs *regs)\n{\n\t__perf_event_output(event, data, regs, perf_output_begin_backward);\n}\n\nvoid\nperf_event_output(struct perf_event *event,\n\t\t  struct perf_sample_data *data,\n\t\t  struct pt_regs *regs)\n{\n\t__perf_event_output(event, data, regs, perf_output_begin);\n}\n\n/*\n * read event_id\n */\n\nstruct perf_read_event {\n\tstruct perf_event_header\theader;\n\n\tu32\t\t\t\tpid;\n\tu32\t\t\t\ttid;\n};\n\nstatic void\nperf_event_read_event(struct perf_event *event,\n\t\t\tstruct task_struct *task)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_read_event read_event = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_READ,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(read_event) + event->read_size,\n\t\t},\n\t\t.pid = perf_event_pid(event, task),\n\t\t.tid = perf_event_tid(event, task),\n\t};\n\tint ret;\n\n\tperf_event_header__init_id(&read_event.header, &sample, event);\n\tret = perf_output_begin(&handle, event, read_event.header.size);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, read_event);\n\tperf_output_read(&handle, event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}\n\ntypedef void (perf_iterate_f)(struct perf_event *event, void *data);\n\nstatic void\nperf_iterate_ctx(struct perf_event_context *ctx,\n\t\t   perf_iterate_f output,\n\t\t   void *data, bool all)\n{\n\tstruct perf_event *event;\n\n\tlist_for_each_entry_rcu(event, &ctx->event_list, event_entry) {\n\t\tif (!all) {\n\t\t\tif (event->state < PERF_EVENT_STATE_INACTIVE)\n\t\t\t\tcontinue;\n\t\t\tif (!event_filter_match(event))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\toutput(event, data);\n\t}\n}\n\nstatic void perf_iterate_sb_cpu(perf_iterate_f output, void *data)\n{\n\tstruct pmu_event_list *pel = this_cpu_ptr(&pmu_sb_events);\n\tstruct perf_event *event;\n\n\tlist_for_each_entry_rcu(event, &pel->list, sb_list) {\n\t\t/*\n\t\t * Skip events that are not fully formed yet; ensure that\n\t\t * if we observe event->ctx, both event and ctx will be\n\t\t * complete enough. See perf_install_in_context().\n\t\t */\n\t\tif (!smp_load_acquire(&event->ctx))\n\t\t\tcontinue;\n\n\t\tif (event->state < PERF_EVENT_STATE_INACTIVE)\n\t\t\tcontinue;\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\t\toutput(event, data);\n\t}\n}\n\n/*\n * Iterate all events that need to receive side-band events.\n *\n * For new callers; ensure that account_pmu_sb_event() includes\n * your event, otherwise it might not get delivered.\n */\nstatic void\nperf_iterate_sb(perf_iterate_f output, void *data,\n\t       struct perf_event_context *task_ctx)\n{\n\tstruct perf_event_context *ctx;\n\tint ctxn;\n\n\trcu_read_lock();\n\tpreempt_disable();\n\n\t/*\n\t * If we have task_ctx != NULL we only notify the task context itself.\n\t * The task_ctx is set only for EXIT events before releasing task\n\t * context.\n\t */\n\tif (task_ctx) {\n\t\tperf_iterate_ctx(task_ctx, output, data, false);\n\t\tgoto done;\n\t}\n\n\tperf_iterate_sb_cpu(output, data);\n\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = rcu_dereference(current->perf_event_ctxp[ctxn]);\n\t\tif (ctx)\n\t\t\tperf_iterate_ctx(ctx, output, data, false);\n\t}\ndone:\n\tpreempt_enable();\n\trcu_read_unlock();\n}\n\n/*\n * Clear all file-based filters at exec, they'll have to be\n * re-instated when/if these objects are mmapped again.\n */\nstatic void perf_event_addr_filters_exec(struct perf_event *event, void *data)\n{\n\tstruct perf_addr_filters_head *ifh = perf_event_addr_filters(event);\n\tstruct perf_addr_filter *filter;\n\tunsigned int restart = 0, count = 0;\n\tunsigned long flags;\n\n\tif (!has_addr_filter(event))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&ifh->lock, flags);\n\tlist_for_each_entry(filter, &ifh->list, entry) {\n\t\tif (filter->inode) {\n\t\t\tevent->addr_filters_offs[count] = 0;\n\t\t\trestart++;\n\t\t}\n\n\t\tcount++;\n\t}\n\n\tif (restart)\n\t\tevent->addr_filters_gen++;\n\traw_spin_unlock_irqrestore(&ifh->lock, flags);\n\n\tif (restart)\n\t\tperf_event_stop(event, 1);\n}\n\nvoid perf_event_exec(void)\n{\n\tstruct perf_event_context *ctx;\n\tint ctxn;\n\n\trcu_read_lock();\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = current->perf_event_ctxp[ctxn];\n\t\tif (!ctx)\n\t\t\tcontinue;\n\n\t\tperf_event_enable_on_exec(ctxn);\n\n\t\tperf_iterate_ctx(ctx, perf_event_addr_filters_exec, NULL,\n\t\t\t\t   true);\n\t}\n\trcu_read_unlock();\n}\n\nstruct remote_output {\n\tstruct ring_buffer\t*rb;\n\tint\t\t\terr;\n};\n\nstatic void __perf_event_output_stop(struct perf_event *event, void *data)\n{\n\tstruct perf_event *parent = event->parent;\n\tstruct remote_output *ro = data;\n\tstruct ring_buffer *rb = ro->rb;\n\tstruct stop_event_data sd = {\n\t\t.event\t= event,\n\t};\n\n\tif (!has_aux(event))\n\t\treturn;\n\n\tif (!parent)\n\t\tparent = event;\n\n\t/*\n\t * In case of inheritance, it will be the parent that links to the\n\t * ring-buffer, but it will be the child that's actually using it.\n\t *\n\t * We are using event::rb to determine if the event should be stopped,\n\t * however this may race with ring_buffer_attach() (through set_output),\n\t * which will make us skip the event that actually needs to be stopped.\n\t * So ring_buffer_attach() has to stop an aux event before re-assigning\n\t * its rb pointer.\n\t */\n\tif (rcu_dereference(parent->rb) == rb)\n\t\tro->err = __perf_event_stop(&sd);\n}\n\nstatic int __perf_pmu_output_stop(void *info)\n{\n\tstruct perf_event *event = info;\n\tstruct pmu *pmu = event->pmu;\n\tstruct perf_cpu_context *cpuctx = this_cpu_ptr(pmu->pmu_cpu_context);\n\tstruct remote_output ro = {\n\t\t.rb\t= event->rb,\n\t};\n\n\trcu_read_lock();\n\tperf_iterate_ctx(&cpuctx->ctx, __perf_event_output_stop, &ro, false);\n\tif (cpuctx->task_ctx)\n\t\tperf_iterate_ctx(cpuctx->task_ctx, __perf_event_output_stop,\n\t\t\t\t   &ro, false);\n\trcu_read_unlock();\n\n\treturn ro.err;\n}\n\nstatic void perf_pmu_output_stop(struct perf_event *event)\n{\n\tstruct perf_event *iter;\n\tint err, cpu;\n\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(iter, &event->rb->event_list, rb_entry) {\n\t\t/*\n\t\t * For per-CPU events, we need to make sure that neither they\n\t\t * nor their children are running; for cpu==-1 events it's\n\t\t * sufficient to stop the event itself if it's active, since\n\t\t * it can't have children.\n\t\t */\n\t\tcpu = iter->cpu;\n\t\tif (cpu == -1)\n\t\t\tcpu = READ_ONCE(iter->oncpu);\n\n\t\tif (cpu == -1)\n\t\t\tcontinue;\n\n\t\terr = cpu_function_call(cpu, __perf_pmu_output_stop, event);\n\t\tif (err == -EAGAIN) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto restart;\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\n/*\n * task tracking -- fork/exit\n *\n * enabled by: attr.comm | attr.mmap | attr.mmap2 | attr.mmap_data | attr.task\n */\n\nstruct perf_task_event {\n\tstruct task_struct\t\t*task;\n\tstruct perf_event_context\t*task_ctx;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\n\t\tu32\t\t\t\tpid;\n\t\tu32\t\t\t\tppid;\n\t\tu32\t\t\t\ttid;\n\t\tu32\t\t\t\tptid;\n\t\tu64\t\t\t\ttime;\n\t} event_id;\n};\n\nstatic int perf_event_task_match(struct perf_event *event)\n{\n\treturn event->attr.comm  || event->attr.mmap ||\n\t       event->attr.mmap2 || event->attr.mmap_data ||\n\t       event->attr.task;\n}\n\nstatic void perf_event_task_output(struct perf_event *event,\n\t\t\t\t   void *data)\n{\n\tstruct perf_task_event *task_event = data;\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data\tsample;\n\tstruct task_struct *task = task_event->task;\n\tint ret, size = task_event->event_id.header.size;\n\n\tif (!perf_event_task_match(event))\n\t\treturn;\n\n\tperf_event_header__init_id(&task_event->event_id.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\ttask_event->event_id.header.size);\n\tif (ret)\n\t\tgoto out;\n\n\ttask_event->event_id.pid = perf_event_pid(event, task);\n\ttask_event->event_id.ppid = perf_event_pid(event, current);\n\n\ttask_event->event_id.tid = perf_event_tid(event, task);\n\ttask_event->event_id.ptid = perf_event_tid(event, current);\n\n\ttask_event->event_id.time = perf_event_clock(event);\n\n\tperf_output_put(&handle, task_event->event_id);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\nout:\n\ttask_event->event_id.header.size = size;\n}\n\nstatic void perf_event_task(struct task_struct *task,\n\t\t\t      struct perf_event_context *task_ctx,\n\t\t\t      int new)\n{\n\tstruct perf_task_event task_event;\n\n\tif (!atomic_read(&nr_comm_events) &&\n\t    !atomic_read(&nr_mmap_events) &&\n\t    !atomic_read(&nr_task_events))\n\t\treturn;\n\n\ttask_event = (struct perf_task_event){\n\t\t.task\t  = task,\n\t\t.task_ctx = task_ctx,\n\t\t.event_id    = {\n\t\t\t.header = {\n\t\t\t\t.type = new ? PERF_RECORD_FORK : PERF_RECORD_EXIT,\n\t\t\t\t.misc = 0,\n\t\t\t\t.size = sizeof(task_event.event_id),\n\t\t\t},\n\t\t\t/* .pid  */\n\t\t\t/* .ppid */\n\t\t\t/* .tid  */\n\t\t\t/* .ptid */\n\t\t\t/* .time */\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_task_output,\n\t\t       &task_event,\n\t\t       task_ctx);\n}\n\nvoid perf_event_fork(struct task_struct *task)\n{\n\tperf_event_task(task, NULL, 1);\n}\n\n/*\n * comm tracking\n */\n\nstruct perf_comm_event {\n\tstruct task_struct\t*task;\n\tchar\t\t\t*comm;\n\tint\t\t\tcomm_size;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\n\t\tu32\t\t\t\tpid;\n\t\tu32\t\t\t\ttid;\n\t} event_id;\n};\n\nstatic int perf_event_comm_match(struct perf_event *event)\n{\n\treturn event->attr.comm;\n}\n\nstatic void perf_event_comm_output(struct perf_event *event,\n\t\t\t\t   void *data)\n{\n\tstruct perf_comm_event *comm_event = data;\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint size = comm_event->event_id.header.size;\n\tint ret;\n\n\tif (!perf_event_comm_match(event))\n\t\treturn;\n\n\tperf_event_header__init_id(&comm_event->event_id.header, &sample, event);\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tcomm_event->event_id.header.size);\n\n\tif (ret)\n\t\tgoto out;\n\n\tcomm_event->event_id.pid = perf_event_pid(event, comm_event->task);\n\tcomm_event->event_id.tid = perf_event_tid(event, comm_event->task);\n\n\tperf_output_put(&handle, comm_event->event_id);\n\t__output_copy(&handle, comm_event->comm,\n\t\t\t\t   comm_event->comm_size);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\nout:\n\tcomm_event->event_id.header.size = size;\n}\n\nstatic void perf_event_comm_event(struct perf_comm_event *comm_event)\n{\n\tchar comm[TASK_COMM_LEN];\n\tunsigned int size;\n\n\tmemset(comm, 0, sizeof(comm));\n\tstrlcpy(comm, comm_event->task->comm, sizeof(comm));\n\tsize = ALIGN(strlen(comm)+1, sizeof(u64));\n\n\tcomm_event->comm = comm;\n\tcomm_event->comm_size = size;\n\n\tcomm_event->event_id.header.size = sizeof(comm_event->event_id) + size;\n\n\tperf_iterate_sb(perf_event_comm_output,\n\t\t       comm_event,\n\t\t       NULL);\n}\n\nvoid perf_event_comm(struct task_struct *task, bool exec)\n{\n\tstruct perf_comm_event comm_event;\n\n\tif (!atomic_read(&nr_comm_events))\n\t\treturn;\n\n\tcomm_event = (struct perf_comm_event){\n\t\t.task\t= task,\n\t\t/* .comm      */\n\t\t/* .comm_size */\n\t\t.event_id  = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_COMM,\n\t\t\t\t.misc = exec ? PERF_RECORD_MISC_COMM_EXEC : 0,\n\t\t\t\t/* .size */\n\t\t\t},\n\t\t\t/* .pid */\n\t\t\t/* .tid */\n\t\t},\n\t};\n\n\tperf_event_comm_event(&comm_event);\n}\n\n/*\n * mmap tracking\n */\n\nstruct perf_mmap_event {\n\tstruct vm_area_struct\t*vma;\n\n\tconst char\t\t*file_name;\n\tint\t\t\tfile_size;\n\tint\t\t\tmaj, min;\n\tu64\t\t\tino;\n\tu64\t\t\tino_generation;\n\tu32\t\t\tprot, flags;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\n\t\tu32\t\t\t\tpid;\n\t\tu32\t\t\t\ttid;\n\t\tu64\t\t\t\tstart;\n\t\tu64\t\t\t\tlen;\n\t\tu64\t\t\t\tpgoff;\n\t} event_id;\n};\n\nstatic int perf_event_mmap_match(struct perf_event *event,\n\t\t\t\t void *data)\n{\n\tstruct perf_mmap_event *mmap_event = data;\n\tstruct vm_area_struct *vma = mmap_event->vma;\n\tint executable = vma->vm_flags & VM_EXEC;\n\n\treturn (!executable && event->attr.mmap_data) ||\n\t       (executable && (event->attr.mmap || event->attr.mmap2));\n}\n\nstatic void perf_event_mmap_output(struct perf_event *event,\n\t\t\t\t   void *data)\n{\n\tstruct perf_mmap_event *mmap_event = data;\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint size = mmap_event->event_id.header.size;\n\tint ret;\n\n\tif (!perf_event_mmap_match(event, data))\n\t\treturn;\n\n\tif (event->attr.mmap2) {\n\t\tmmap_event->event_id.header.type = PERF_RECORD_MMAP2;\n\t\tmmap_event->event_id.header.size += sizeof(mmap_event->maj);\n\t\tmmap_event->event_id.header.size += sizeof(mmap_event->min);\n\t\tmmap_event->event_id.header.size += sizeof(mmap_event->ino);\n\t\tmmap_event->event_id.header.size += sizeof(mmap_event->ino_generation);\n\t\tmmap_event->event_id.header.size += sizeof(mmap_event->prot);\n\t\tmmap_event->event_id.header.size += sizeof(mmap_event->flags);\n\t}\n\n\tperf_event_header__init_id(&mmap_event->event_id.header, &sample, event);\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tmmap_event->event_id.header.size);\n\tif (ret)\n\t\tgoto out;\n\n\tmmap_event->event_id.pid = perf_event_pid(event, current);\n\tmmap_event->event_id.tid = perf_event_tid(event, current);\n\n\tperf_output_put(&handle, mmap_event->event_id);\n\n\tif (event->attr.mmap2) {\n\t\tperf_output_put(&handle, mmap_event->maj);\n\t\tperf_output_put(&handle, mmap_event->min);\n\t\tperf_output_put(&handle, mmap_event->ino);\n\t\tperf_output_put(&handle, mmap_event->ino_generation);\n\t\tperf_output_put(&handle, mmap_event->prot);\n\t\tperf_output_put(&handle, mmap_event->flags);\n\t}\n\n\t__output_copy(&handle, mmap_event->file_name,\n\t\t\t\t   mmap_event->file_size);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\nout:\n\tmmap_event->event_id.header.size = size;\n}\n\nstatic void perf_event_mmap_event(struct perf_mmap_event *mmap_event)\n{\n\tstruct vm_area_struct *vma = mmap_event->vma;\n\tstruct file *file = vma->vm_file;\n\tint maj = 0, min = 0;\n\tu64 ino = 0, gen = 0;\n\tu32 prot = 0, flags = 0;\n\tunsigned int size;\n\tchar tmp[16];\n\tchar *buf = NULL;\n\tchar *name;\n\n\tif (file) {\n\t\tstruct inode *inode;\n\t\tdev_t dev;\n\n\t\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tname = \"//enomem\";\n\t\t\tgoto cpy_name;\n\t\t}\n\t\t/*\n\t\t * d_path() works from the end of the rb backwards, so we\n\t\t * need to add enough zero bytes after the string to handle\n\t\t * the 64bit alignment we do later.\n\t\t */\n\t\tname = file_path(file, buf, PATH_MAX - sizeof(u64));\n\t\tif (IS_ERR(name)) {\n\t\t\tname = \"//toolong\";\n\t\t\tgoto cpy_name;\n\t\t}\n\t\tinode = file_inode(vma->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t\tgen = inode->i_generation;\n\t\tmaj = MAJOR(dev);\n\t\tmin = MINOR(dev);\n\n\t\tif (vma->vm_flags & VM_READ)\n\t\t\tprot |= PROT_READ;\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tprot |= PROT_WRITE;\n\t\tif (vma->vm_flags & VM_EXEC)\n\t\t\tprot |= PROT_EXEC;\n\n\t\tif (vma->vm_flags & VM_MAYSHARE)\n\t\t\tflags = MAP_SHARED;\n\t\telse\n\t\t\tflags = MAP_PRIVATE;\n\n\t\tif (vma->vm_flags & VM_DENYWRITE)\n\t\t\tflags |= MAP_DENYWRITE;\n\t\tif (vma->vm_flags & VM_MAYEXEC)\n\t\t\tflags |= MAP_EXECUTABLE;\n\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\tflags |= MAP_LOCKED;\n\t\tif (vma->vm_flags & VM_HUGETLB)\n\t\t\tflags |= MAP_HUGETLB;\n\n\t\tgoto got_name;\n\t} else {\n\t\tif (vma->vm_ops && vma->vm_ops->name) {\n\t\t\tname = (char *) vma->vm_ops->name(vma);\n\t\t\tif (name)\n\t\t\t\tgoto cpy_name;\n\t\t}\n\n\t\tname = (char *)arch_vma_name(vma);\n\t\tif (name)\n\t\t\tgoto cpy_name;\n\n\t\tif (vma->vm_start <= vma->vm_mm->start_brk &&\n\t\t\t\tvma->vm_end >= vma->vm_mm->brk) {\n\t\t\tname = \"[heap]\";\n\t\t\tgoto cpy_name;\n\t\t}\n\t\tif (vma->vm_start <= vma->vm_mm->start_stack &&\n\t\t\t\tvma->vm_end >= vma->vm_mm->start_stack) {\n\t\t\tname = \"[stack]\";\n\t\t\tgoto cpy_name;\n\t\t}\n\n\t\tname = \"//anon\";\n\t\tgoto cpy_name;\n\t}\n\ncpy_name:\n\tstrlcpy(tmp, name, sizeof(tmp));\n\tname = tmp;\ngot_name:\n\t/*\n\t * Since our buffer works in 8 byte units we need to align our string\n\t * size to a multiple of 8. However, we must guarantee the tail end is\n\t * zero'd out to avoid leaking random bits to userspace.\n\t */\n\tsize = strlen(name)+1;\n\twhile (!IS_ALIGNED(size, sizeof(u64)))\n\t\tname[size++] = '\\0';\n\n\tmmap_event->file_name = name;\n\tmmap_event->file_size = size;\n\tmmap_event->maj = maj;\n\tmmap_event->min = min;\n\tmmap_event->ino = ino;\n\tmmap_event->ino_generation = gen;\n\tmmap_event->prot = prot;\n\tmmap_event->flags = flags;\n\n\tif (!(vma->vm_flags & VM_EXEC))\n\t\tmmap_event->event_id.header.misc |= PERF_RECORD_MISC_MMAP_DATA;\n\n\tmmap_event->event_id.header.size = sizeof(mmap_event->event_id) + size;\n\n\tperf_iterate_sb(perf_event_mmap_output,\n\t\t       mmap_event,\n\t\t       NULL);\n\n\tkfree(buf);\n}\n\n/*\n * Check whether inode and address range match filter criteria.\n */\nstatic bool perf_addr_filter_match(struct perf_addr_filter *filter,\n\t\t\t\t     struct file *file, unsigned long offset,\n\t\t\t\t     unsigned long size)\n{\n\tif (filter->inode != file_inode(file))\n\t\treturn false;\n\n\tif (filter->offset > offset + size)\n\t\treturn false;\n\n\tif (filter->offset + filter->size < offset)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void __perf_addr_filters_adjust(struct perf_event *event, void *data)\n{\n\tstruct perf_addr_filters_head *ifh = perf_event_addr_filters(event);\n\tstruct vm_area_struct *vma = data;\n\tunsigned long off = vma->vm_pgoff << PAGE_SHIFT, flags;\n\tstruct file *file = vma->vm_file;\n\tstruct perf_addr_filter *filter;\n\tunsigned int restart = 0, count = 0;\n\n\tif (!has_addr_filter(event))\n\t\treturn;\n\n\tif (!file)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&ifh->lock, flags);\n\tlist_for_each_entry(filter, &ifh->list, entry) {\n\t\tif (perf_addr_filter_match(filter, file, off,\n\t\t\t\t\t     vma->vm_end - vma->vm_start)) {\n\t\t\tevent->addr_filters_offs[count] = vma->vm_start;\n\t\t\trestart++;\n\t\t}\n\n\t\tcount++;\n\t}\n\n\tif (restart)\n\t\tevent->addr_filters_gen++;\n\traw_spin_unlock_irqrestore(&ifh->lock, flags);\n\n\tif (restart)\n\t\tperf_event_stop(event, 1);\n}\n\n/*\n * Adjust all task's events' filters to the new vma\n */\nstatic void perf_addr_filters_adjust(struct vm_area_struct *vma)\n{\n\tstruct perf_event_context *ctx;\n\tint ctxn;\n\n\t/*\n\t * Data tracing isn't supported yet and as such there is no need\n\t * to keep track of anything that isn't related to executable code:\n\t */\n\tif (!(vma->vm_flags & VM_EXEC))\n\t\treturn;\n\n\trcu_read_lock();\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = rcu_dereference(current->perf_event_ctxp[ctxn]);\n\t\tif (!ctx)\n\t\t\tcontinue;\n\n\t\tperf_iterate_ctx(ctx, __perf_addr_filters_adjust, vma, true);\n\t}\n\trcu_read_unlock();\n}\n\nvoid perf_event_mmap(struct vm_area_struct *vma)\n{\n\tstruct perf_mmap_event mmap_event;\n\n\tif (!atomic_read(&nr_mmap_events))\n\t\treturn;\n\n\tmmap_event = (struct perf_mmap_event){\n\t\t.vma\t= vma,\n\t\t/* .file_name */\n\t\t/* .file_size */\n\t\t.event_id  = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_MMAP,\n\t\t\t\t.misc = PERF_RECORD_MISC_USER,\n\t\t\t\t/* .size */\n\t\t\t},\n\t\t\t/* .pid */\n\t\t\t/* .tid */\n\t\t\t.start  = vma->vm_start,\n\t\t\t.len    = vma->vm_end - vma->vm_start,\n\t\t\t.pgoff  = (u64)vma->vm_pgoff << PAGE_SHIFT,\n\t\t},\n\t\t/* .maj (attr_mmap2 only) */\n\t\t/* .min (attr_mmap2 only) */\n\t\t/* .ino (attr_mmap2 only) */\n\t\t/* .ino_generation (attr_mmap2 only) */\n\t\t/* .prot (attr_mmap2 only) */\n\t\t/* .flags (attr_mmap2 only) */\n\t};\n\n\tperf_addr_filters_adjust(vma);\n\tperf_event_mmap_event(&mmap_event);\n}\n\nvoid perf_event_aux_event(struct perf_event *event, unsigned long head,\n\t\t\t  unsigned long size, u64 flags)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_aux_event {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\toffset;\n\t\tu64\t\t\t\tsize;\n\t\tu64\t\t\t\tflags;\n\t} rec = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_AUX,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(rec),\n\t\t},\n\t\t.offset\t\t= head,\n\t\t.size\t\t= size,\n\t\t.flags\t\t= flags,\n\t};\n\tint ret;\n\n\tperf_event_header__init_id(&rec.header, &sample, event);\n\tret = perf_output_begin(&handle, event, rec.header.size);\n\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, rec);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}\n\n/*\n * Lost/dropped samples logging\n */\nvoid perf_log_lost_samples(struct perf_event *event, u64 lost)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint ret;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\tlost;\n\t} lost_samples_event = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_LOST_SAMPLES,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(lost_samples_event),\n\t\t},\n\t\t.lost\t\t= lost,\n\t};\n\n\tperf_event_header__init_id(&lost_samples_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tlost_samples_event.header.size);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, lost_samples_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}\n\n/*\n * context_switch tracking\n */\n\nstruct perf_switch_event {\n\tstruct task_struct\t*task;\n\tstruct task_struct\t*next_prev;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\t\tu32\t\t\t\tnext_prev_pid;\n\t\tu32\t\t\t\tnext_prev_tid;\n\t} event_id;\n};\n\nstatic int perf_event_switch_match(struct perf_event *event)\n{\n\treturn event->attr.context_switch;\n}\n\nstatic void perf_event_switch_output(struct perf_event *event, void *data)\n{\n\tstruct perf_switch_event *se = data;\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint ret;\n\n\tif (!perf_event_switch_match(event))\n\t\treturn;\n\n\t/* Only CPU-wide events are allowed to see next/prev pid/tid */\n\tif (event->ctx->task) {\n\t\tse->event_id.header.type = PERF_RECORD_SWITCH;\n\t\tse->event_id.header.size = sizeof(se->event_id.header);\n\t} else {\n\t\tse->event_id.header.type = PERF_RECORD_SWITCH_CPU_WIDE;\n\t\tse->event_id.header.size = sizeof(se->event_id);\n\t\tse->event_id.next_prev_pid =\n\t\t\t\t\tperf_event_pid(event, se->next_prev);\n\t\tse->event_id.next_prev_tid =\n\t\t\t\t\tperf_event_tid(event, se->next_prev);\n\t}\n\n\tperf_event_header__init_id(&se->event_id.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event, se->event_id.header.size);\n\tif (ret)\n\t\treturn;\n\n\tif (event->ctx->task)\n\t\tperf_output_put(&handle, se->event_id.header);\n\telse\n\t\tperf_output_put(&handle, se->event_id);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}\n\nstatic void perf_event_switch(struct task_struct *task,\n\t\t\t      struct task_struct *next_prev, bool sched_in)\n{\n\tstruct perf_switch_event switch_event;\n\n\t/* N.B. caller checks nr_switch_events != 0 */\n\n\tswitch_event = (struct perf_switch_event){\n\t\t.task\t\t= task,\n\t\t.next_prev\t= next_prev,\n\t\t.event_id\t= {\n\t\t\t.header = {\n\t\t\t\t/* .type */\n\t\t\t\t.misc = sched_in ? 0 : PERF_RECORD_MISC_SWITCH_OUT,\n\t\t\t\t/* .size */\n\t\t\t},\n\t\t\t/* .next_prev_pid */\n\t\t\t/* .next_prev_tid */\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_switch_output,\n\t\t       &switch_event,\n\t\t       NULL);\n}\n\n/*\n * IRQ throttle logging\n */\n\nstatic void perf_log_throttle(struct perf_event *event, int enable)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint ret;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\ttime;\n\t\tu64\t\t\t\tid;\n\t\tu64\t\t\t\tstream_id;\n\t} throttle_event = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_THROTTLE,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(throttle_event),\n\t\t},\n\t\t.time\t\t= perf_event_clock(event),\n\t\t.id\t\t= primary_event_id(event),\n\t\t.stream_id\t= event->id,\n\t};\n\n\tif (enable)\n\t\tthrottle_event.header.type = PERF_RECORD_UNTHROTTLE;\n\n\tperf_event_header__init_id(&throttle_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tthrottle_event.header.size);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, throttle_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}\n\nstatic void perf_log_itrace_start(struct perf_event *event)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_aux_event {\n\t\tstruct perf_event_header        header;\n\t\tu32\t\t\t\tpid;\n\t\tu32\t\t\t\ttid;\n\t} rec;\n\tint ret;\n\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\tif (!(event->pmu->capabilities & PERF_PMU_CAP_ITRACE) ||\n\t    event->hw.itrace_started)\n\t\treturn;\n\n\trec.header.type\t= PERF_RECORD_ITRACE_START;\n\trec.header.misc\t= 0;\n\trec.header.size\t= sizeof(rec);\n\trec.pid\t= perf_event_pid(event, current);\n\trec.tid\t= perf_event_tid(event, current);\n\n\tperf_event_header__init_id(&rec.header, &sample, event);\n\tret = perf_output_begin(&handle, event, rec.header.size);\n\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, rec);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}\n\n/*\n * Generic event overflow handling, sampling.\n */\n\nstatic int __perf_event_overflow(struct perf_event *event,\n\t\t\t\t   int throttle, struct perf_sample_data *data,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tint events = atomic_read(&event->event_limit);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 seq;\n\tint ret = 0;\n\n\t/*\n\t * Non-sampling counters might still use the PMI to fold short\n\t * hardware counters, ignore those.\n\t */\n\tif (unlikely(!is_sampling_event(event)))\n\t\treturn 0;\n\n\tseq = __this_cpu_read(perf_throttled_seq);\n\tif (seq != hwc->interrupts_seq) {\n\t\thwc->interrupts_seq = seq;\n\t\thwc->interrupts = 1;\n\t} else {\n\t\thwc->interrupts++;\n\t\tif (unlikely(throttle\n\t\t\t     && hwc->interrupts >= max_samples_per_tick)) {\n\t\t\t__this_cpu_inc(perf_throttled_count);\n\t\t\ttick_dep_set_cpu(smp_processor_id(), TICK_DEP_BIT_PERF_EVENTS);\n\t\t\thwc->interrupts = MAX_INTERRUPTS;\n\t\t\tperf_log_throttle(event, 0);\n\t\t\tret = 1;\n\t\t}\n\t}\n\n\tif (event->attr.freq) {\n\t\tu64 now = perf_clock();\n\t\ts64 delta = now - hwc->freq_time_stamp;\n\n\t\thwc->freq_time_stamp = now;\n\n\t\tif (delta > 0 && delta < 2*TICK_NSEC)\n\t\t\tperf_adjust_period(event, delta, hwc->last_period, true);\n\t}\n\n\t/*\n\t * XXX event_limit might not quite work as expected on inherited\n\t * events\n\t */\n\n\tevent->pending_kill = POLL_IN;\n\tif (events && atomic_dec_and_test(&event->event_limit)) {\n\t\tret = 1;\n\t\tevent->pending_kill = POLL_HUP;\n\n\t\tperf_event_disable_inatomic(event);\n\t}\n\n\tREAD_ONCE(event->overflow_handler)(event, data, regs);\n\n\tif (*perf_event_fasync(event) && event->pending_kill) {\n\t\tevent->pending_wakeup = 1;\n\t\tirq_work_queue(&event->pending);\n\t}\n\n\treturn ret;\n}\n\nint perf_event_overflow(struct perf_event *event,\n\t\t\t  struct perf_sample_data *data,\n\t\t\t  struct pt_regs *regs)\n{\n\treturn __perf_event_overflow(event, 1, data, regs);\n}\n\n/*\n * Generic software event infrastructure\n */\n\nstruct swevent_htable {\n\tstruct swevent_hlist\t\t*swevent_hlist;\n\tstruct mutex\t\t\thlist_mutex;\n\tint\t\t\t\thlist_refcount;\n\n\t/* Recursion avoidance in each contexts */\n\tint\t\t\t\trecursion[PERF_NR_CONTEXTS];\n};\n\nstatic DEFINE_PER_CPU(struct swevent_htable, swevent_htable);\n\n/*\n * We directly increment event->count and keep a second value in\n * event->hw.period_left to count intervals. This period event\n * is kept in the range [-sample_period, 0] so that we can use the\n * sign as trigger.\n */\n\nu64 perf_swevent_set_period(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 period = hwc->last_period;\n\tu64 nr, offset;\n\ts64 old, val;\n\n\thwc->last_period = hwc->sample_period;\n\nagain:\n\told = val = local64_read(&hwc->period_left);\n\tif (val < 0)\n\t\treturn 0;\n\n\tnr = div64_u64(period + val, period);\n\toffset = nr * period;\n\tval -= offset;\n\tif (local64_cmpxchg(&hwc->period_left, old, val) != old)\n\t\tgoto again;\n\n\treturn nr;\n}\n\nstatic void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n\t\t\t\t    struct perf_sample_data *data,\n\t\t\t\t    struct pt_regs *regs)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint throttle = 0;\n\n\tif (!overflow)\n\t\toverflow = perf_swevent_set_period(event);\n\n\tif (hwc->interrupts == MAX_INTERRUPTS)\n\t\treturn;\n\n\tfor (; overflow; overflow--) {\n\t\tif (__perf_event_overflow(event, throttle,\n\t\t\t\t\t    data, regs)) {\n\t\t\t/*\n\t\t\t * We inhibit the overflow from happening when\n\t\t\t * hwc->interrupts == MAX_INTERRUPTS.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tthrottle = 1;\n\t}\n}\n\nstatic void perf_swevent_event(struct perf_event *event, u64 nr,\n\t\t\t       struct perf_sample_data *data,\n\t\t\t       struct pt_regs *regs)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tlocal64_add(nr, &event->count);\n\n\tif (!regs)\n\t\treturn;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\tif ((event->attr.sample_type & PERF_SAMPLE_PERIOD) && !event->attr.freq) {\n\t\tdata->period = nr;\n\t\treturn perf_swevent_overflow(event, 1, data, regs);\n\t} else\n\t\tdata->period = event->hw.last_period;\n\n\tif (nr == 1 && hwc->sample_period == 1 && !event->attr.freq)\n\t\treturn perf_swevent_overflow(event, 1, data, regs);\n\n\tif (local64_add_negative(nr, &hwc->period_left))\n\t\treturn;\n\n\tperf_swevent_overflow(event, 0, data, regs);\n}\n\nstatic int perf_exclude_event(struct perf_event *event,\n\t\t\t      struct pt_regs *regs)\n{\n\tif (event->hw.state & PERF_HES_STOPPED)\n\t\treturn 1;\n\n\tif (regs) {\n\t\tif (event->attr.exclude_user && user_mode(regs))\n\t\t\treturn 1;\n\n\t\tif (event->attr.exclude_kernel && !user_mode(regs))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int perf_swevent_match(struct perf_event *event,\n\t\t\t\tenum perf_type_id type,\n\t\t\t\tu32 event_id,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct pt_regs *regs)\n{\n\tif (event->attr.type != type)\n\t\treturn 0;\n\n\tif (event->attr.config != event_id)\n\t\treturn 0;\n\n\tif (perf_exclude_event(event, regs))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline u64 swevent_hash(u64 type, u32 event_id)\n{\n\tu64 val = event_id | (type << 32);\n\n\treturn hash_64(val, SWEVENT_HLIST_BITS);\n}\n\nstatic inline struct hlist_head *\n__find_swevent_head(struct swevent_hlist *hlist, u64 type, u32 event_id)\n{\n\tu64 hash = swevent_hash(type, event_id);\n\n\treturn &hlist->heads[hash];\n}\n\n/* For the read side: events when they trigger */\nstatic inline struct hlist_head *\nfind_swevent_head_rcu(struct swevent_htable *swhash, u64 type, u32 event_id)\n{\n\tstruct swevent_hlist *hlist;\n\n\thlist = rcu_dereference(swhash->swevent_hlist);\n\tif (!hlist)\n\t\treturn NULL;\n\n\treturn __find_swevent_head(hlist, type, event_id);\n}\n\n/* For the event head insertion and removal in the hlist */\nstatic inline struct hlist_head *\nfind_swevent_head(struct swevent_htable *swhash, struct perf_event *event)\n{\n\tstruct swevent_hlist *hlist;\n\tu32 event_id = event->attr.config;\n\tu64 type = event->attr.type;\n\n\t/*\n\t * Event scheduling is always serialized against hlist allocation\n\t * and release. Which makes the protected version suitable here.\n\t * The context lock guarantees that.\n\t */\n\thlist = rcu_dereference_protected(swhash->swevent_hlist,\n\t\t\t\t\t  lockdep_is_held(&event->ctx->lock));\n\tif (!hlist)\n\t\treturn NULL;\n\n\treturn __find_swevent_head(hlist, type, event_id);\n}\n\nstatic void do_perf_sw_event(enum perf_type_id type, u32 event_id,\n\t\t\t\t    u64 nr,\n\t\t\t\t    struct perf_sample_data *data,\n\t\t\t\t    struct pt_regs *regs)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct perf_event *event;\n\tstruct hlist_head *head;\n\n\trcu_read_lock();\n\thead = find_swevent_head_rcu(swhash, type, event_id);\n\tif (!head)\n\t\tgoto end;\n\n\thlist_for_each_entry_rcu(event, head, hlist_entry) {\n\t\tif (perf_swevent_match(event, type, event_id, data, regs))\n\t\t\tperf_swevent_event(event, nr, data, regs);\n\t}\nend:\n\trcu_read_unlock();\n}\n\nDEFINE_PER_CPU(struct pt_regs, __perf_regs[4]);\n\nint perf_swevent_get_recursion_context(void)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\treturn get_recursion_context(swhash->recursion);\n}\nEXPORT_SYMBOL_GPL(perf_swevent_get_recursion_context);\n\nvoid perf_swevent_put_recursion_context(int rctx)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\tput_recursion_context(swhash->recursion, rctx);\n}\n\nvoid ___perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tstruct perf_sample_data data;\n\n\tif (WARN_ON_ONCE(!regs))\n\t\treturn;\n\n\tperf_sample_data_init(&data, addr, 0);\n\tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, &data, regs);\n}\n\nvoid __perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tint rctx;\n\n\tpreempt_disable_notrace();\n\trctx = perf_swevent_get_recursion_context();\n\tif (unlikely(rctx < 0))\n\t\tgoto fail;\n\n\t___perf_sw_event(event_id, nr, regs, addr);\n\n\tperf_swevent_put_recursion_context(rctx);\nfail:\n\tpreempt_enable_notrace();\n}\n\nstatic void perf_swevent_read(struct perf_event *event)\n{\n}\n\nstatic int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\n\thwc->state = !(flags & PERF_EF_START);\n\n\thead = find_swevent_head(swhash, event);\n\tif (WARN_ON_ONCE(!head))\n\t\treturn -EINVAL;\n\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void perf_swevent_del(struct perf_event *event, int flags)\n{\n\thlist_del_rcu(&event->hlist_entry);\n}\n\nstatic void perf_swevent_start(struct perf_event *event, int flags)\n{\n\tevent->hw.state = 0;\n}\n\nstatic void perf_swevent_stop(struct perf_event *event, int flags)\n{\n\tevent->hw.state = PERF_HES_STOPPED;\n}\n\n/* Deref the hlist from the update side */\nstatic inline struct swevent_hlist *\nswevent_hlist_deref(struct swevent_htable *swhash)\n{\n\treturn rcu_dereference_protected(swhash->swevent_hlist,\n\t\t\t\t\t lockdep_is_held(&swhash->hlist_mutex));\n}\n\nstatic void swevent_hlist_release(struct swevent_htable *swhash)\n{\n\tstruct swevent_hlist *hlist = swevent_hlist_deref(swhash);\n\n\tif (!hlist)\n\t\treturn;\n\n\tRCU_INIT_POINTER(swhash->swevent_hlist, NULL);\n\tkfree_rcu(hlist, rcu_head);\n}\n\nstatic void swevent_hlist_put_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\n\tmutex_lock(&swhash->hlist_mutex);\n\n\tif (!--swhash->hlist_refcount)\n\t\tswevent_hlist_release(swhash);\n\n\tmutex_unlock(&swhash->hlist_mutex);\n}\n\nstatic void swevent_hlist_put(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tswevent_hlist_put_cpu(cpu);\n}\n\nstatic int swevent_hlist_get_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tint err = 0;\n\n\tmutex_lock(&swhash->hlist_mutex);\n\tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc(sizeof(*hlist), GFP_KERNEL);\n\t\tif (!hlist) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\n\treturn err;\n}\n\nstatic int swevent_hlist_get(void)\n{\n\tint err, cpu, failed_cpu;\n\n\tget_online_cpus();\n\tfor_each_possible_cpu(cpu) {\n\t\terr = swevent_hlist_get_cpu(cpu);\n\t\tif (err) {\n\t\t\tfailed_cpu = cpu;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tput_online_cpus();\n\n\treturn 0;\nfail:\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == failed_cpu)\n\t\t\tbreak;\n\t\tswevent_hlist_put_cpu(cpu);\n\t}\n\n\tput_online_cpus();\n\treturn err;\n}\n\nstruct static_key perf_swevent_enabled[PERF_COUNT_SW_MAX];\n\nstatic void sw_perf_event_destroy(struct perf_event *event)\n{\n\tu64 event_id = event->attr.config;\n\n\tWARN_ON(event->parent);\n\n\tstatic_key_slow_dec(&perf_swevent_enabled[event_id]);\n\tswevent_hlist_put();\n}\n\nstatic int perf_swevent_init(struct perf_event *event)\n{\n\tu64 event_id = event->attr.config;\n\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\n\tif (!event->parent) {\n\t\tint err;\n\n\t\terr = swevent_hlist_get();\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\n\treturn 0;\n}\n\nstatic struct pmu perf_swevent = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.capabilities\t= PERF_PMU_CAP_NO_NMI,\n\n\t.event_init\t= perf_swevent_init,\n\t.add\t\t= perf_swevent_add,\n\t.del\t\t= perf_swevent_del,\n\t.start\t\t= perf_swevent_start,\n\t.stop\t\t= perf_swevent_stop,\n\t.read\t\t= perf_swevent_read,\n};\n\n#ifdef CONFIG_EVENT_TRACING\n\nstatic int perf_tp_filter_match(struct perf_event *event,\n\t\t\t\tstruct perf_sample_data *data)\n{\n\tvoid *record = data->raw->frag.data;\n\n\t/* only top level events have filters set */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\tif (likely(!event->filter) || filter_match_preds(event->filter, record))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int perf_tp_event_match(struct perf_event *event,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct pt_regs *regs)\n{\n\tif (event->hw.state & PERF_HES_STOPPED)\n\t\treturn 0;\n\t/*\n\t * All tracepoints are from kernel-space.\n\t */\n\tif (event->attr.exclude_kernel)\n\t\treturn 0;\n\n\tif (!perf_tp_filter_match(event, data))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nvoid perf_trace_run_bpf_submit(void *raw_data, int size, int rctx,\n\t\t\t       struct trace_event_call *call, u64 count,\n\t\t\t       struct pt_regs *regs, struct hlist_head *head,\n\t\t\t       struct task_struct *task)\n{\n\tstruct bpf_prog *prog = call->prog;\n\n\tif (prog) {\n\t\t*(struct pt_regs **)raw_data = regs;\n\t\tif (!trace_call_bpf(prog, raw_data) || hlist_empty(head)) {\n\t\t\tperf_swevent_put_recursion_context(rctx);\n\t\t\treturn;\n\t\t}\n\t}\n\tperf_tp_event(call->event.type, count, raw_data, size, regs, head,\n\t\t      rctx, task);\n}\nEXPORT_SYMBOL_GPL(perf_trace_run_bpf_submit);\n\nvoid perf_tp_event(u16 event_type, u64 count, void *record, int entry_size,\n\t\t   struct pt_regs *regs, struct hlist_head *head, int rctx,\n\t\t   struct task_struct *task)\n{\n\tstruct perf_sample_data data;\n\tstruct perf_event *event;\n\n\tstruct perf_raw_record raw = {\n\t\t.frag = {\n\t\t\t.size = entry_size,\n\t\t\t.data = record,\n\t\t},\n\t};\n\n\tperf_sample_data_init(&data, 0, 0);\n\tdata.raw = &raw;\n\n\tperf_trace_buf_update(record, event_type);\n\n\thlist_for_each_entry_rcu(event, head, hlist_entry) {\n\t\tif (perf_tp_event_match(event, &data, regs))\n\t\t\tperf_swevent_event(event, count, &data, regs);\n\t}\n\n\t/*\n\t * If we got specified a target task, also iterate its context and\n\t * deliver this event there too.\n\t */\n\tif (task && task != current) {\n\t\tstruct perf_event_context *ctx;\n\t\tstruct trace_entry *entry = record;\n\n\t\trcu_read_lock();\n\t\tctx = rcu_dereference(task->perf_event_ctxp[perf_sw_context]);\n\t\tif (!ctx)\n\t\t\tgoto unlock;\n\n\t\tlist_for_each_entry_rcu(event, &ctx->event_list, event_entry) {\n\t\t\tif (event->attr.type != PERF_TYPE_TRACEPOINT)\n\t\t\t\tcontinue;\n\t\t\tif (event->attr.config != entry->type)\n\t\t\t\tcontinue;\n\t\t\tif (perf_tp_event_match(event, &data, regs))\n\t\t\t\tperf_swevent_event(event, count, &data, regs);\n\t\t}\nunlock:\n\t\trcu_read_unlock();\n\t}\n\n\tperf_swevent_put_recursion_context(rctx);\n}\nEXPORT_SYMBOL_GPL(perf_tp_event);\n\nstatic void tp_perf_event_destroy(struct perf_event *event)\n{\n\tperf_trace_destroy(event);\n}\n\nstatic int perf_tp_event_init(struct perf_event *event)\n{\n\tint err;\n\n\tif (event->attr.type != PERF_TYPE_TRACEPOINT)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for tracepoint events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\terr = perf_trace_init(event);\n\tif (err)\n\t\treturn err;\n\n\tevent->destroy = tp_perf_event_destroy;\n\n\treturn 0;\n}\n\nstatic struct pmu perf_tracepoint = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.event_init\t= perf_tp_event_init,\n\t.add\t\t= perf_trace_add,\n\t.del\t\t= perf_trace_del,\n\t.start\t\t= perf_swevent_start,\n\t.stop\t\t= perf_swevent_stop,\n\t.read\t\t= perf_swevent_read,\n};\n\nstatic inline void perf_tp_register(void)\n{\n\tperf_pmu_register(&perf_tracepoint, \"tracepoint\", PERF_TYPE_TRACEPOINT);\n}\n\nstatic void perf_event_free_filter(struct perf_event *event)\n{\n\tftrace_profile_free_filter(event);\n}\n\n#ifdef CONFIG_BPF_SYSCALL\nstatic void bpf_overflow_handler(struct perf_event *event,\n\t\t\t\t struct perf_sample_data *data,\n\t\t\t\t struct pt_regs *regs)\n{\n\tstruct bpf_perf_event_data_kern ctx = {\n\t\t.data = data,\n\t\t.regs = regs,\n\t};\n\tint ret = 0;\n\n\tpreempt_disable();\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1))\n\t\tgoto out;\n\trcu_read_lock();\n\tret = BPF_PROG_RUN(event->prog, &ctx);\n\trcu_read_unlock();\nout:\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\tif (!ret)\n\t\treturn;\n\n\tevent->orig_overflow_handler(event, data, regs);\n}\n\nstatic int perf_event_set_bpf_handler(struct perf_event *event, u32 prog_fd)\n{\n\tstruct bpf_prog *prog;\n\n\tif (event->overflow_handler_context)\n\t\t/* hw breakpoint or kernel counter */\n\t\treturn -EINVAL;\n\n\tif (event->prog)\n\t\treturn -EEXIST;\n\n\tprog = bpf_prog_get_type(prog_fd, BPF_PROG_TYPE_PERF_EVENT);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tevent->prog = prog;\n\tevent->orig_overflow_handler = READ_ONCE(event->overflow_handler);\n\tWRITE_ONCE(event->overflow_handler, bpf_overflow_handler);\n\treturn 0;\n}\n\nstatic void perf_event_free_bpf_handler(struct perf_event *event)\n{\n\tstruct bpf_prog *prog = event->prog;\n\n\tif (!prog)\n\t\treturn;\n\n\tWRITE_ONCE(event->overflow_handler, event->orig_overflow_handler);\n\tevent->prog = NULL;\n\tbpf_prog_put(prog);\n}\n#else\nstatic int perf_event_set_bpf_handler(struct perf_event *event, u32 prog_fd)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic void perf_event_free_bpf_handler(struct perf_event *event)\n{\n}\n#endif\n\nstatic int perf_event_set_bpf_prog(struct perf_event *event, u32 prog_fd)\n{\n\tbool is_kprobe, is_tracepoint;\n\tstruct bpf_prog *prog;\n\n\tif (event->attr.type == PERF_TYPE_HARDWARE ||\n\t    event->attr.type == PERF_TYPE_SOFTWARE)\n\t\treturn perf_event_set_bpf_handler(event, prog_fd);\n\n\tif (event->attr.type != PERF_TYPE_TRACEPOINT)\n\t\treturn -EINVAL;\n\n\tif (event->tp_event->prog)\n\t\treturn -EEXIST;\n\n\tis_kprobe = event->tp_event->flags & TRACE_EVENT_FL_UKPROBE;\n\tis_tracepoint = event->tp_event->flags & TRACE_EVENT_FL_TRACEPOINT;\n\tif (!is_kprobe && !is_tracepoint)\n\t\t/* bpf programs can only be attached to u/kprobe or tracepoint */\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tif ((is_kprobe && prog->type != BPF_PROG_TYPE_KPROBE) ||\n\t    (is_tracepoint && prog->type != BPF_PROG_TYPE_TRACEPOINT)) {\n\t\t/* valid fd, but invalid bpf program type */\n\t\tbpf_prog_put(prog);\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_tracepoint) {\n\t\tint off = trace_event_get_offsets(event->tp_event);\n\n\t\tif (prog->aux->max_ctx_offset > off) {\n\t\t\tbpf_prog_put(prog);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\tevent->tp_event->prog = prog;\n\n\treturn 0;\n}\n\nstatic void perf_event_free_bpf_prog(struct perf_event *event)\n{\n\tstruct bpf_prog *prog;\n\n\tperf_event_free_bpf_handler(event);\n\n\tif (!event->tp_event)\n\t\treturn;\n\n\tprog = event->tp_event->prog;\n\tif (prog) {\n\t\tevent->tp_event->prog = NULL;\n\t\tbpf_prog_put(prog);\n\t}\n}\n\n#else\n\nstatic inline void perf_tp_register(void)\n{\n}\n\nstatic void perf_event_free_filter(struct perf_event *event)\n{\n}\n\nstatic int perf_event_set_bpf_prog(struct perf_event *event, u32 prog_fd)\n{\n\treturn -ENOENT;\n}\n\nstatic void perf_event_free_bpf_prog(struct perf_event *event)\n{\n}\n#endif /* CONFIG_EVENT_TRACING */\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\nvoid perf_bp_event(struct perf_event *bp, void *data)\n{\n\tstruct perf_sample_data sample;\n\tstruct pt_regs *regs = data;\n\n\tperf_sample_data_init(&sample, bp->attr.bp_addr, 0);\n\n\tif (!bp->hw.state && !perf_exclude_event(bp, regs))\n\t\tperf_swevent_event(bp, 1, &sample, regs);\n}\n#endif\n\n/*\n * Allocate a new address filter\n */\nstatic struct perf_addr_filter *\nperf_addr_filter_new(struct perf_event *event, struct list_head *filters)\n{\n\tint node = cpu_to_node(event->cpu == -1 ? 0 : event->cpu);\n\tstruct perf_addr_filter *filter;\n\n\tfilter = kzalloc_node(sizeof(*filter), GFP_KERNEL, node);\n\tif (!filter)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&filter->entry);\n\tlist_add_tail(&filter->entry, filters);\n\n\treturn filter;\n}\n\nstatic void free_filters_list(struct list_head *filters)\n{\n\tstruct perf_addr_filter *filter, *iter;\n\n\tlist_for_each_entry_safe(filter, iter, filters, entry) {\n\t\tif (filter->inode)\n\t\t\tiput(filter->inode);\n\t\tlist_del(&filter->entry);\n\t\tkfree(filter);\n\t}\n}\n\n/*\n * Free existing address filters and optionally install new ones\n */\nstatic void perf_addr_filters_splice(struct perf_event *event,\n\t\t\t\t     struct list_head *head)\n{\n\tunsigned long flags;\n\tLIST_HEAD(list);\n\n\tif (!has_addr_filter(event))\n\t\treturn;\n\n\t/* don't bother with children, they don't have their own filters */\n\tif (event->parent)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&event->addr_filters.lock, flags);\n\n\tlist_splice_init(&event->addr_filters.list, &list);\n\tif (head)\n\t\tlist_splice(head, &event->addr_filters.list);\n\n\traw_spin_unlock_irqrestore(&event->addr_filters.lock, flags);\n\n\tfree_filters_list(&list);\n}\n\n/*\n * Scan through mm's vmas and see if one of them matches the\n * @filter; if so, adjust filter's address range.\n * Called with mm::mmap_sem down for reading.\n */\nstatic unsigned long perf_addr_filter_apply(struct perf_addr_filter *filter,\n\t\t\t\t\t    struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tstruct file *file = vma->vm_file;\n\t\tunsigned long off = vma->vm_pgoff << PAGE_SHIFT;\n\t\tunsigned long vma_size = vma->vm_end - vma->vm_start;\n\n\t\tif (!file)\n\t\t\tcontinue;\n\n\t\tif (!perf_addr_filter_match(filter, file, off, vma_size))\n\t\t\tcontinue;\n\n\t\treturn vma->vm_start;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Update event's address range filters based on the\n * task's existing mappings, if any.\n */\nstatic void perf_event_addr_filters_apply(struct perf_event *event)\n{\n\tstruct perf_addr_filters_head *ifh = perf_event_addr_filters(event);\n\tstruct task_struct *task = READ_ONCE(event->ctx->task);\n\tstruct perf_addr_filter *filter;\n\tstruct mm_struct *mm = NULL;\n\tunsigned int count = 0;\n\tunsigned long flags;\n\n\t/*\n\t * We may observe TASK_TOMBSTONE, which means that the event tear-down\n\t * will stop on the parent's child_mutex that our caller is also holding\n\t */\n\tif (task == TASK_TOMBSTONE)\n\t\treturn;\n\n\tmm = get_task_mm(event->ctx->task);\n\tif (!mm)\n\t\tgoto restart;\n\n\tdown_read(&mm->mmap_sem);\n\n\traw_spin_lock_irqsave(&ifh->lock, flags);\n\tlist_for_each_entry(filter, &ifh->list, entry) {\n\t\tevent->addr_filters_offs[count] = 0;\n\n\t\t/*\n\t\t * Adjust base offset if the filter is associated to a binary\n\t\t * that needs to be mapped:\n\t\t */\n\t\tif (filter->inode)\n\t\t\tevent->addr_filters_offs[count] =\n\t\t\t\tperf_addr_filter_apply(filter, mm);\n\n\t\tcount++;\n\t}\n\n\tevent->addr_filters_gen++;\n\traw_spin_unlock_irqrestore(&ifh->lock, flags);\n\n\tup_read(&mm->mmap_sem);\n\n\tmmput(mm);\n\nrestart:\n\tperf_event_stop(event, 1);\n}\n\n/*\n * Address range filtering: limiting the data to certain\n * instruction address ranges. Filters are ioctl()ed to us from\n * userspace as ascii strings.\n *\n * Filter string format:\n *\n * ACTION RANGE_SPEC\n * where ACTION is one of the\n *  * \"filter\": limit the trace to this region\n *  * \"start\": start tracing from this address\n *  * \"stop\": stop tracing at this address/region;\n * RANGE_SPEC is\n *  * for kernel addresses: <start address>[/<size>]\n *  * for object files:     <start address>[/<size>]@</path/to/object/file>\n *\n * if <size> is not specified, the range is treated as a single address.\n */\nenum {\n\tIF_ACT_NONE = -1,\n\tIF_ACT_FILTER,\n\tIF_ACT_START,\n\tIF_ACT_STOP,\n\tIF_SRC_FILE,\n\tIF_SRC_KERNEL,\n\tIF_SRC_FILEADDR,\n\tIF_SRC_KERNELADDR,\n};\n\nenum {\n\tIF_STATE_ACTION = 0,\n\tIF_STATE_SOURCE,\n\tIF_STATE_END,\n};\n\nstatic const match_table_t if_tokens = {\n\t{ IF_ACT_FILTER,\t\"filter\" },\n\t{ IF_ACT_START,\t\t\"start\" },\n\t{ IF_ACT_STOP,\t\t\"stop\" },\n\t{ IF_SRC_FILE,\t\t\"%u/%u@%s\" },\n\t{ IF_SRC_KERNEL,\t\"%u/%u\" },\n\t{ IF_SRC_FILEADDR,\t\"%u@%s\" },\n\t{ IF_SRC_KERNELADDR,\t\"%u\" },\n\t{ IF_ACT_NONE,\t\tNULL },\n};\n\n/*\n * Address filter string parser\n */\nstatic int\nperf_event_parse_addr_filter(struct perf_event *event, char *fstr,\n\t\t\t     struct list_head *filters)\n{\n\tstruct perf_addr_filter *filter = NULL;\n\tchar *start, *orig, *filename = NULL;\n\tstruct path path;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint state = IF_STATE_ACTION, token;\n\tunsigned int kernel = 0;\n\tint ret = -EINVAL;\n\n\torig = fstr = kstrdup(fstr, GFP_KERNEL);\n\tif (!fstr)\n\t\treturn -ENOMEM;\n\n\twhile ((start = strsep(&fstr, \" ,\\n\")) != NULL) {\n\t\tret = -EINVAL;\n\n\t\tif (!*start)\n\t\t\tcontinue;\n\n\t\t/* filter definition begins */\n\t\tif (state == IF_STATE_ACTION) {\n\t\t\tfilter = perf_addr_filter_new(event, filters);\n\t\t\tif (!filter)\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\ttoken = match_token(start, if_tokens, args);\n\t\tswitch (token) {\n\t\tcase IF_ACT_FILTER:\n\t\tcase IF_ACT_START:\n\t\t\tfilter->filter = 1;\n\n\t\tcase IF_ACT_STOP:\n\t\t\tif (state != IF_STATE_ACTION)\n\t\t\t\tgoto fail;\n\n\t\t\tstate = IF_STATE_SOURCE;\n\t\t\tbreak;\n\n\t\tcase IF_SRC_KERNELADDR:\n\t\tcase IF_SRC_KERNEL:\n\t\t\tkernel = 1;\n\n\t\tcase IF_SRC_FILEADDR:\n\t\tcase IF_SRC_FILE:\n\t\t\tif (state != IF_STATE_SOURCE)\n\t\t\t\tgoto fail;\n\n\t\t\tif (token == IF_SRC_FILE || token == IF_SRC_KERNEL)\n\t\t\t\tfilter->range = 1;\n\n\t\t\t*args[0].to = 0;\n\t\t\tret = kstrtoul(args[0].from, 0, &filter->offset);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\n\t\t\tif (filter->range) {\n\t\t\t\t*args[1].to = 0;\n\t\t\t\tret = kstrtoul(args[1].from, 0, &filter->size);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (token == IF_SRC_FILE || token == IF_SRC_FILEADDR) {\n\t\t\t\tint fpos = filter->range ? 2 : 1;\n\n\t\t\t\tfilename = match_strdup(&args[fpos]);\n\t\t\t\tif (!filename) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate = IF_STATE_END;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Filter definition is fully parsed, validate and install it.\n\t\t * Make sure that it doesn't contradict itself or the event's\n\t\t * attribute.\n\t\t */\n\t\tif (state == IF_STATE_END) {\n\t\t\tif (kernel && event->attr.exclude_kernel)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!kernel) {\n\t\t\t\tif (!filename)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\t/* look up the path and grab its inode */\n\t\t\t\tret = kern_path(filename, LOOKUP_FOLLOW, &path);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto fail_free_name;\n\n\t\t\t\tfilter->inode = igrab(d_inode(path.dentry));\n\t\t\t\tpath_put(&path);\n\t\t\t\tkfree(filename);\n\t\t\t\tfilename = NULL;\n\n\t\t\t\tret = -EINVAL;\n\t\t\t\tif (!filter->inode ||\n\t\t\t\t    !S_ISREG(filter->inode->i_mode))\n\t\t\t\t\t/* free_filters_list() will iput() */\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* ready to consume more filters */\n\t\t\tstate = IF_STATE_ACTION;\n\t\t\tfilter = NULL;\n\t\t}\n\t}\n\n\tif (state != IF_STATE_ACTION)\n\t\tgoto fail;\n\n\tkfree(orig);\n\n\treturn 0;\n\nfail_free_name:\n\tkfree(filename);\nfail:\n\tfree_filters_list(filters);\n\tkfree(orig);\n\n\treturn ret;\n}\n\nstatic int\nperf_event_set_addr_filter(struct perf_event *event, char *filter_str)\n{\n\tLIST_HEAD(filters);\n\tint ret;\n\n\t/*\n\t * Since this is called in perf_ioctl() path, we're already holding\n\t * ctx::mutex.\n\t */\n\tlockdep_assert_held(&event->ctx->mutex);\n\n\tif (WARN_ON_ONCE(event->parent))\n\t\treturn -EINVAL;\n\n\t/*\n\t * For now, we only support filtering in per-task events; doing so\n\t * for CPU-wide events requires additional context switching trickery,\n\t * since same object code will be mapped at different virtual\n\t * addresses in different processes.\n\t */\n\tif (!event->ctx->task)\n\t\treturn -EOPNOTSUPP;\n\n\tret = perf_event_parse_addr_filter(event, filter_str, &filters);\n\tif (ret)\n\t\treturn ret;\n\n\tret = event->pmu->addr_filters_validate(&filters);\n\tif (ret) {\n\t\tfree_filters_list(&filters);\n\t\treturn ret;\n\t}\n\n\t/* remove existing filters, if any */\n\tperf_addr_filters_splice(event, &filters);\n\n\t/* install new filters */\n\tperf_event_for_each_child(event, perf_event_addr_filters_apply);\n\n\treturn ret;\n}\n\nstatic int perf_event_set_filter(struct perf_event *event, void __user *arg)\n{\n\tchar *filter_str;\n\tint ret = -EINVAL;\n\n\tif ((event->attr.type != PERF_TYPE_TRACEPOINT ||\n\t    !IS_ENABLED(CONFIG_EVENT_TRACING)) &&\n\t    !has_addr_filter(event))\n\t\treturn -EINVAL;\n\n\tfilter_str = strndup_user(arg, PAGE_SIZE);\n\tif (IS_ERR(filter_str))\n\t\treturn PTR_ERR(filter_str);\n\n\tif (IS_ENABLED(CONFIG_EVENT_TRACING) &&\n\t    event->attr.type == PERF_TYPE_TRACEPOINT)\n\t\tret = ftrace_profile_set_filter(event, event->attr.config,\n\t\t\t\t\t\tfilter_str);\n\telse if (has_addr_filter(event))\n\t\tret = perf_event_set_addr_filter(event, filter_str);\n\n\tkfree(filter_str);\n\treturn ret;\n}\n\n/*\n * hrtimer based swevent callback\n */\n\nstatic enum hrtimer_restart perf_swevent_hrtimer(struct hrtimer *hrtimer)\n{\n\tenum hrtimer_restart ret = HRTIMER_RESTART;\n\tstruct perf_sample_data data;\n\tstruct pt_regs *regs;\n\tstruct perf_event *event;\n\tu64 period;\n\n\tevent = container_of(hrtimer, struct perf_event, hw.hrtimer);\n\n\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\treturn HRTIMER_NORESTART;\n\n\tevent->pmu->read(event);\n\n\tperf_sample_data_init(&data, 0, event->hw.last_period);\n\tregs = get_irq_regs();\n\n\tif (regs && !perf_exclude_event(event, regs)) {\n\t\tif (!(event->attr.exclude_idle && is_idle_task(current)))\n\t\t\tif (__perf_event_overflow(event, 1, &data, regs))\n\t\t\t\tret = HRTIMER_NORESTART;\n\t}\n\n\tperiod = max_t(u64, 10000, event->hw.sample_period);\n\thrtimer_forward_now(hrtimer, ns_to_ktime(period));\n\n\treturn ret;\n}\n\nstatic void perf_swevent_start_hrtimer(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\ts64 period;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\tperiod = local64_read(&hwc->period_left);\n\tif (period) {\n\t\tif (period < 0)\n\t\t\tperiod = 10000;\n\n\t\tlocal64_set(&hwc->period_left, 0);\n\t} else {\n\t\tperiod = max_t(u64, 10000, hwc->sample_period);\n\t}\n\thrtimer_start(&hwc->hrtimer, ns_to_ktime(period),\n\t\t      HRTIMER_MODE_REL_PINNED);\n}\n\nstatic void perf_swevent_cancel_hrtimer(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (is_sampling_event(event)) {\n\t\tktime_t remaining = hrtimer_get_remaining(&hwc->hrtimer);\n\t\tlocal64_set(&hwc->period_left, ktime_to_ns(remaining));\n\n\t\thrtimer_cancel(&hwc->hrtimer);\n\t}\n}\n\nstatic void perf_swevent_init_hrtimer(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\thrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thwc->hrtimer.function = perf_swevent_hrtimer;\n\n\t/*\n\t * Since hrtimers have a fixed rate, we can do a static freq->period\n\t * mapping and avoid the whole period adjust feedback stuff.\n\t */\n\tif (event->attr.freq) {\n\t\tlong freq = event->attr.sample_freq;\n\n\t\tevent->attr.sample_period = NSEC_PER_SEC / freq;\n\t\thwc->sample_period = event->attr.sample_period;\n\t\tlocal64_set(&hwc->period_left, hwc->sample_period);\n\t\thwc->last_period = hwc->sample_period;\n\t\tevent->attr.freq = 0;\n\t}\n}\n\n/*\n * Software event: cpu wall time clock\n */\n\nstatic void cpu_clock_event_update(struct perf_event *event)\n{\n\ts64 prev;\n\tu64 now;\n\n\tnow = local_clock();\n\tprev = local64_xchg(&event->hw.prev_count, now);\n\tlocal64_add(now - prev, &event->count);\n}\n\nstatic void cpu_clock_event_start(struct perf_event *event, int flags)\n{\n\tlocal64_set(&event->hw.prev_count, local_clock());\n\tperf_swevent_start_hrtimer(event);\n}\n\nstatic void cpu_clock_event_stop(struct perf_event *event, int flags)\n{\n\tperf_swevent_cancel_hrtimer(event);\n\tcpu_clock_event_update(event);\n}\n\nstatic int cpu_clock_event_add(struct perf_event *event, int flags)\n{\n\tif (flags & PERF_EF_START)\n\t\tcpu_clock_event_start(event, flags);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void cpu_clock_event_del(struct perf_event *event, int flags)\n{\n\tcpu_clock_event_stop(event, flags);\n}\n\nstatic void cpu_clock_event_read(struct perf_event *event)\n{\n\tcpu_clock_event_update(event);\n}\n\nstatic int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}\n\nstatic struct pmu perf_cpu_clock = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.capabilities\t= PERF_PMU_CAP_NO_NMI,\n\n\t.event_init\t= cpu_clock_event_init,\n\t.add\t\t= cpu_clock_event_add,\n\t.del\t\t= cpu_clock_event_del,\n\t.start\t\t= cpu_clock_event_start,\n\t.stop\t\t= cpu_clock_event_stop,\n\t.read\t\t= cpu_clock_event_read,\n};\n\n/*\n * Software event: task time clock\n */\n\nstatic void task_clock_event_update(struct perf_event *event, u64 now)\n{\n\tu64 prev;\n\ts64 delta;\n\n\tprev = local64_xchg(&event->hw.prev_count, now);\n\tdelta = now - prev;\n\tlocal64_add(delta, &event->count);\n}\n\nstatic void task_clock_event_start(struct perf_event *event, int flags)\n{\n\tlocal64_set(&event->hw.prev_count, event->ctx->time);\n\tperf_swevent_start_hrtimer(event);\n}\n\nstatic void task_clock_event_stop(struct perf_event *event, int flags)\n{\n\tperf_swevent_cancel_hrtimer(event);\n\ttask_clock_event_update(event, event->ctx->time);\n}\n\nstatic int task_clock_event_add(struct perf_event *event, int flags)\n{\n\tif (flags & PERF_EF_START)\n\t\ttask_clock_event_start(event, flags);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void task_clock_event_del(struct perf_event *event, int flags)\n{\n\ttask_clock_event_stop(event, PERF_EF_UPDATE);\n}\n\nstatic void task_clock_event_read(struct perf_event *event)\n{\n\tu64 now = perf_clock();\n\tu64 delta = now - event->ctx->timestamp;\n\tu64 time = event->ctx->time + delta;\n\n\ttask_clock_event_update(event, time);\n}\n\nstatic int task_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_TASK_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}\n\nstatic struct pmu perf_task_clock = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.capabilities\t= PERF_PMU_CAP_NO_NMI,\n\n\t.event_init\t= task_clock_event_init,\n\t.add\t\t= task_clock_event_add,\n\t.del\t\t= task_clock_event_del,\n\t.start\t\t= task_clock_event_start,\n\t.stop\t\t= task_clock_event_stop,\n\t.read\t\t= task_clock_event_read,\n};\n\nstatic void perf_pmu_nop_void(struct pmu *pmu)\n{\n}\n\nstatic void perf_pmu_nop_txn(struct pmu *pmu, unsigned int flags)\n{\n}\n\nstatic int perf_pmu_nop_int(struct pmu *pmu)\n{\n\treturn 0;\n}\n\nstatic DEFINE_PER_CPU(unsigned int, nop_txn_flags);\n\nstatic void perf_pmu_start_txn(struct pmu *pmu, unsigned int flags)\n{\n\t__this_cpu_write(nop_txn_flags, flags);\n\n\tif (flags & ~PERF_PMU_TXN_ADD)\n\t\treturn;\n\n\tperf_pmu_disable(pmu);\n}\n\nstatic int perf_pmu_commit_txn(struct pmu *pmu)\n{\n\tunsigned int flags = __this_cpu_read(nop_txn_flags);\n\n\t__this_cpu_write(nop_txn_flags, 0);\n\n\tif (flags & ~PERF_PMU_TXN_ADD)\n\t\treturn 0;\n\n\tperf_pmu_enable(pmu);\n\treturn 0;\n}\n\nstatic void perf_pmu_cancel_txn(struct pmu *pmu)\n{\n\tunsigned int flags =  __this_cpu_read(nop_txn_flags);\n\n\t__this_cpu_write(nop_txn_flags, 0);\n\n\tif (flags & ~PERF_PMU_TXN_ADD)\n\t\treturn;\n\n\tperf_pmu_enable(pmu);\n}\n\nstatic int perf_event_idx_default(struct perf_event *event)\n{\n\treturn 0;\n}\n\n/*\n * Ensures all contexts with the same task_ctx_nr have the same\n * pmu_cpu_context too.\n */\nstatic struct perf_cpu_context __percpu *find_pmu_context(int ctxn)\n{\n\tstruct pmu *pmu;\n\n\tif (ctxn < 0)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pmu, &pmus, entry) {\n\t\tif (pmu->task_ctx_nr == ctxn)\n\t\t\treturn pmu->pmu_cpu_context;\n\t}\n\n\treturn NULL;\n}\n\nstatic void update_pmu_context(struct pmu *pmu, struct pmu *old_pmu)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\n\t\tif (cpuctx->unique_pmu == old_pmu)\n\t\t\tcpuctx->unique_pmu = pmu;\n\t}\n}\n\nstatic void free_pmu_context(struct pmu *pmu)\n{\n\tstruct pmu *i;\n\n\tmutex_lock(&pmus_lock);\n\t/*\n\t * Like a real lame refcount.\n\t */\n\tlist_for_each_entry(i, &pmus, entry) {\n\t\tif (i->pmu_cpu_context == pmu->pmu_cpu_context) {\n\t\t\tupdate_pmu_context(i, pmu);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfree_percpu(pmu->pmu_cpu_context);\nout:\n\tmutex_unlock(&pmus_lock);\n}\n\n/*\n * Let userspace know that this PMU supports address range filtering:\n */\nstatic ssize_t nr_addr_filters_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *page)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\n\treturn snprintf(page, PAGE_SIZE - 1, \"%d\\n\", pmu->nr_addr_filters);\n}\nDEVICE_ATTR_RO(nr_addr_filters);\n\nstatic struct idr pmu_idr;\n\nstatic ssize_t\ntype_show(struct device *dev, struct device_attribute *attr, char *page)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\n\treturn snprintf(page, PAGE_SIZE-1, \"%d\\n\", pmu->type);\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic ssize_t\nperf_event_mux_interval_ms_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *page)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\n\treturn snprintf(page, PAGE_SIZE-1, \"%d\\n\", pmu->hrtimer_interval_ms);\n}\n\nstatic DEFINE_MUTEX(mux_interval_mutex);\n\nstatic ssize_t\nperf_event_mux_interval_ms_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\tint timer, cpu, ret;\n\n\tret = kstrtoint(buf, 0, &timer);\n\tif (ret)\n\t\treturn ret;\n\n\tif (timer < 1)\n\t\treturn -EINVAL;\n\n\t/* same value, noting to do */\n\tif (timer == pmu->hrtimer_interval_ms)\n\t\treturn count;\n\n\tmutex_lock(&mux_interval_mutex);\n\tpmu->hrtimer_interval_ms = timer;\n\n\t/* update all cpuctx for this PMU */\n\tget_online_cpus();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\tcpuctx->hrtimer_interval = ns_to_ktime(NSEC_PER_MSEC * timer);\n\n\t\tcpu_function_call(cpu,\n\t\t\t(remote_function_f)perf_mux_hrtimer_restart, cpuctx);\n\t}\n\tput_online_cpus();\n\tmutex_unlock(&mux_interval_mutex);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(perf_event_mux_interval_ms);\n\nstatic struct attribute *pmu_dev_attrs[] = {\n\t&dev_attr_type.attr,\n\t&dev_attr_perf_event_mux_interval_ms.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(pmu_dev);\n\nstatic int pmu_bus_running;\nstatic struct bus_type pmu_bus = {\n\t.name\t\t= \"event_source\",\n\t.dev_groups\t= pmu_dev_groups,\n};\n\nstatic void pmu_dev_release(struct device *dev)\n{\n\tkfree(dev);\n}\n\nstatic int pmu_dev_alloc(struct pmu *pmu)\n{\n\tint ret = -ENOMEM;\n\n\tpmu->dev = kzalloc(sizeof(struct device), GFP_KERNEL);\n\tif (!pmu->dev)\n\t\tgoto out;\n\n\tpmu->dev->groups = pmu->attr_groups;\n\tdevice_initialize(pmu->dev);\n\tret = dev_set_name(pmu->dev, \"%s\", pmu->name);\n\tif (ret)\n\t\tgoto free_dev;\n\n\tdev_set_drvdata(pmu->dev, pmu);\n\tpmu->dev->bus = &pmu_bus;\n\tpmu->dev->release = pmu_dev_release;\n\tret = device_add(pmu->dev);\n\tif (ret)\n\t\tgoto free_dev;\n\n\t/* For PMUs with address filters, throw in an extra attribute: */\n\tif (pmu->nr_addr_filters)\n\t\tret = device_create_file(pmu->dev, &dev_attr_nr_addr_filters);\n\n\tif (ret)\n\t\tgoto del_dev;\n\nout:\n\treturn ret;\n\ndel_dev:\n\tdevice_del(pmu->dev);\n\nfree_dev:\n\tput_device(pmu->dev);\n\tgoto out;\n}\n\nstatic struct lock_class_key cpuctx_mutex;\nstatic struct lock_class_key cpuctx_lock;\n\nint perf_pmu_register(struct pmu *pmu, const char *name, int type)\n{\n\tint cpu, ret;\n\n\tmutex_lock(&pmus_lock);\n\tret = -ENOMEM;\n\tpmu->pmu_disable_count = alloc_percpu(int);\n\tif (!pmu->pmu_disable_count)\n\t\tgoto unlock;\n\n\tpmu->type = -1;\n\tif (!name)\n\t\tgoto skip_type;\n\tpmu->name = name;\n\n\tif (type < 0) {\n\t\ttype = idr_alloc(&pmu_idr, pmu, PERF_TYPE_MAX, 0, GFP_KERNEL);\n\t\tif (type < 0) {\n\t\t\tret = type;\n\t\t\tgoto free_pdc;\n\t\t}\n\t}\n\tpmu->type = type;\n\n\tif (pmu_bus_running) {\n\t\tret = pmu_dev_alloc(pmu);\n\t\tif (ret)\n\t\t\tgoto free_idr;\n\t}\n\nskip_type:\n\tif (pmu->task_ctx_nr == perf_hw_context) {\n\t\tstatic int hw_context_taken = 0;\n\n\t\t/*\n\t\t * Other than systems with heterogeneous CPUs, it never makes\n\t\t * sense for two PMUs to share perf_hw_context. PMUs which are\n\t\t * uncore must use perf_invalid_context.\n\t\t */\n\t\tif (WARN_ON_ONCE(hw_context_taken &&\n\t\t    !(pmu->capabilities & PERF_PMU_CAP_HETEROGENEOUS_CPUS)))\n\t\t\tpmu->task_ctx_nr = perf_invalid_context;\n\n\t\thw_context_taken = 1;\n\t}\n\n\tpmu->pmu_cpu_context = find_pmu_context(pmu->task_ctx_nr);\n\tif (pmu->pmu_cpu_context)\n\t\tgoto got_cpu_context;\n\n\tret = -ENOMEM;\n\tpmu->pmu_cpu_context = alloc_percpu(struct perf_cpu_context);\n\tif (!pmu->pmu_cpu_context)\n\t\tgoto free_dev;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\t__perf_event_init_context(&cpuctx->ctx);\n\t\tlockdep_set_class(&cpuctx->ctx.mutex, &cpuctx_mutex);\n\t\tlockdep_set_class(&cpuctx->ctx.lock, &cpuctx_lock);\n\t\tcpuctx->ctx.pmu = pmu;\n\n\t\t__perf_mux_hrtimer_init(cpuctx, cpu);\n\n\t\tcpuctx->unique_pmu = pmu;\n\t}\n\ngot_cpu_context:\n\tif (!pmu->start_txn) {\n\t\tif (pmu->pmu_enable) {\n\t\t\t/*\n\t\t\t * If we have pmu_enable/pmu_disable calls, install\n\t\t\t * transaction stubs that use that to try and batch\n\t\t\t * hardware accesses.\n\t\t\t */\n\t\t\tpmu->start_txn  = perf_pmu_start_txn;\n\t\t\tpmu->commit_txn = perf_pmu_commit_txn;\n\t\t\tpmu->cancel_txn = perf_pmu_cancel_txn;\n\t\t} else {\n\t\t\tpmu->start_txn  = perf_pmu_nop_txn;\n\t\t\tpmu->commit_txn = perf_pmu_nop_int;\n\t\t\tpmu->cancel_txn = perf_pmu_nop_void;\n\t\t}\n\t}\n\n\tif (!pmu->pmu_enable) {\n\t\tpmu->pmu_enable  = perf_pmu_nop_void;\n\t\tpmu->pmu_disable = perf_pmu_nop_void;\n\t}\n\n\tif (!pmu->event_idx)\n\t\tpmu->event_idx = perf_event_idx_default;\n\n\tlist_add_rcu(&pmu->entry, &pmus);\n\tatomic_set(&pmu->exclusive_cnt, 0);\n\tret = 0;\nunlock:\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n\nfree_dev:\n\tdevice_del(pmu->dev);\n\tput_device(pmu->dev);\n\nfree_idr:\n\tif (pmu->type >= PERF_TYPE_MAX)\n\t\tidr_remove(&pmu_idr, pmu->type);\n\nfree_pdc:\n\tfree_percpu(pmu->pmu_disable_count);\n\tgoto unlock;\n}\nEXPORT_SYMBOL_GPL(perf_pmu_register);\n\nvoid perf_pmu_unregister(struct pmu *pmu)\n{\n\tint remove_device;\n\n\tmutex_lock(&pmus_lock);\n\tremove_device = pmu_bus_running;\n\tlist_del_rcu(&pmu->entry);\n\tmutex_unlock(&pmus_lock);\n\n\t/*\n\t * We dereference the pmu list under both SRCU and regular RCU, so\n\t * synchronize against both of those.\n\t */\n\tsynchronize_srcu(&pmus_srcu);\n\tsynchronize_rcu();\n\n\tfree_percpu(pmu->pmu_disable_count);\n\tif (pmu->type >= PERF_TYPE_MAX)\n\t\tidr_remove(&pmu_idr, pmu->type);\n\tif (remove_device) {\n\t\tif (pmu->nr_addr_filters)\n\t\t\tdevice_remove_file(pmu->dev, &dev_attr_nr_addr_filters);\n\t\tdevice_del(pmu->dev);\n\t\tput_device(pmu->dev);\n\t}\n\tfree_pmu_context(pmu);\n}\nEXPORT_SYMBOL_GPL(perf_pmu_unregister);\n\nstatic int perf_try_init_event(struct pmu *pmu, struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = NULL;\n\tint ret;\n\n\tif (!try_module_get(pmu->module))\n\t\treturn -ENODEV;\n\n\tif (event->group_leader != event) {\n\t\t/*\n\t\t * This ctx->mutex can nest when we're called through\n\t\t * inheritance. See the perf_event_ctx_lock_nested() comment.\n\t\t */\n\t\tctx = perf_event_ctx_lock_nested(event->group_leader,\n\t\t\t\t\t\t SINGLE_DEPTH_NESTING);\n\t\tBUG_ON(!ctx);\n\t}\n\n\tevent->pmu = pmu;\n\tret = pmu->event_init(event);\n\n\tif (ctx)\n\t\tperf_event_ctx_unlock(event->group_leader, ctx);\n\n\tif (ret)\n\t\tmodule_put(pmu->module);\n\n\treturn ret;\n}\n\nstatic struct pmu *perf_init_event(struct perf_event *event)\n{\n\tstruct pmu *pmu = NULL;\n\tint idx;\n\tint ret;\n\n\tidx = srcu_read_lock(&pmus_srcu);\n\n\trcu_read_lock();\n\tpmu = idr_find(&pmu_idr, event->attr.type);\n\trcu_read_unlock();\n\tif (pmu) {\n\t\tret = perf_try_init_event(pmu, event);\n\t\tif (ret)\n\t\t\tpmu = ERR_PTR(ret);\n\t\tgoto unlock;\n\t}\n\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tret = perf_try_init_event(pmu, event);\n\t\tif (!ret)\n\t\t\tgoto unlock;\n\n\t\tif (ret != -ENOENT) {\n\t\t\tpmu = ERR_PTR(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tpmu = ERR_PTR(-ENOENT);\nunlock:\n\tsrcu_read_unlock(&pmus_srcu, idx);\n\n\treturn pmu;\n}\n\nstatic void attach_sb_event(struct perf_event *event)\n{\n\tstruct pmu_event_list *pel = per_cpu_ptr(&pmu_sb_events, event->cpu);\n\n\traw_spin_lock(&pel->lock);\n\tlist_add_rcu(&event->sb_list, &pel->list);\n\traw_spin_unlock(&pel->lock);\n}\n\n/*\n * We keep a list of all !task (and therefore per-cpu) events\n * that need to receive side-band records.\n *\n * This avoids having to scan all the various PMU per-cpu contexts\n * looking for them.\n */\nstatic void account_pmu_sb_event(struct perf_event *event)\n{\n\tif (is_sb_event(event))\n\t\tattach_sb_event(event);\n}\n\nstatic void account_event_cpu(struct perf_event *event, int cpu)\n{\n\tif (event->parent)\n\t\treturn;\n\n\tif (is_cgroup_event(event))\n\t\tatomic_inc(&per_cpu(perf_cgroup_events, cpu));\n}\n\n/* Freq events need the tick to stay alive (see perf_event_task_tick). */\nstatic void account_freq_event_nohz(void)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\t/* Lock so we don't race with concurrent unaccount */\n\tspin_lock(&nr_freq_lock);\n\tif (atomic_inc_return(&nr_freq_events) == 1)\n\t\ttick_nohz_dep_set(TICK_DEP_BIT_PERF_EVENTS);\n\tspin_unlock(&nr_freq_lock);\n#endif\n}\n\nstatic void account_freq_event(void)\n{\n\tif (tick_nohz_full_enabled())\n\t\taccount_freq_event_nohz();\n\telse\n\t\tatomic_inc(&nr_freq_events);\n}\n\n\nstatic void account_event(struct perf_event *event)\n{\n\tbool inc = false;\n\n\tif (event->parent)\n\t\treturn;\n\n\tif (event->attach_state & PERF_ATTACH_TASK)\n\t\tinc = true;\n\tif (event->attr.mmap || event->attr.mmap_data)\n\t\tatomic_inc(&nr_mmap_events);\n\tif (event->attr.comm)\n\t\tatomic_inc(&nr_comm_events);\n\tif (event->attr.task)\n\t\tatomic_inc(&nr_task_events);\n\tif (event->attr.freq)\n\t\taccount_freq_event();\n\tif (event->attr.context_switch) {\n\t\tatomic_inc(&nr_switch_events);\n\t\tinc = true;\n\t}\n\tif (has_branch_stack(event))\n\t\tinc = true;\n\tif (is_cgroup_event(event))\n\t\tinc = true;\n\n\tif (inc) {\n\t\tif (atomic_inc_not_zero(&perf_sched_count))\n\t\t\tgoto enabled;\n\n\t\tmutex_lock(&perf_sched_mutex);\n\t\tif (!atomic_read(&perf_sched_count)) {\n\t\t\tstatic_branch_enable(&perf_sched_events);\n\t\t\t/*\n\t\t\t * Guarantee that all CPUs observe they key change and\n\t\t\t * call the perf scheduling hooks before proceeding to\n\t\t\t * install events that need them.\n\t\t\t */\n\t\t\tsynchronize_sched();\n\t\t}\n\t\t/*\n\t\t * Now that we have waited for the sync_sched(), allow further\n\t\t * increments to by-pass the mutex.\n\t\t */\n\t\tatomic_inc(&perf_sched_count);\n\t\tmutex_unlock(&perf_sched_mutex);\n\t}\nenabled:\n\n\taccount_event_cpu(event, event->cpu);\n\n\taccount_pmu_sb_event(event);\n}\n\n/*\n * Allocate and initialize a event structure\n */\nstatic struct perf_event *\nperf_event_alloc(struct perf_event_attr *attr, int cpu,\n\t\t struct task_struct *task,\n\t\t struct perf_event *group_leader,\n\t\t struct perf_event *parent_event,\n\t\t perf_overflow_handler_t overflow_handler,\n\t\t void *context, int cgroup_fd)\n{\n\tstruct pmu *pmu;\n\tstruct perf_event *event;\n\tstruct hw_perf_event *hwc;\n\tlong err = -EINVAL;\n\n\tif ((unsigned)cpu >= nr_cpu_ids) {\n\t\tif (!task || cpu != -1)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Single events are their own group leaders, with an\n\t * empty sibling list:\n\t */\n\tif (!group_leader)\n\t\tgroup_leader = event;\n\n\tmutex_init(&event->child_mutex);\n\tINIT_LIST_HEAD(&event->child_list);\n\n\tINIT_LIST_HEAD(&event->group_entry);\n\tINIT_LIST_HEAD(&event->event_entry);\n\tINIT_LIST_HEAD(&event->sibling_list);\n\tINIT_LIST_HEAD(&event->rb_entry);\n\tINIT_LIST_HEAD(&event->active_entry);\n\tINIT_LIST_HEAD(&event->addr_filters.list);\n\tINIT_HLIST_NODE(&event->hlist_entry);\n\n\n\tinit_waitqueue_head(&event->waitq);\n\tinit_irq_work(&event->pending, perf_pending_event);\n\n\tmutex_init(&event->mmap_mutex);\n\traw_spin_lock_init(&event->addr_filters.lock);\n\n\tatomic_long_set(&event->refcount, 1);\n\tevent->cpu\t\t= cpu;\n\tevent->attr\t\t= *attr;\n\tevent->group_leader\t= group_leader;\n\tevent->pmu\t\t= NULL;\n\tevent->oncpu\t\t= -1;\n\n\tevent->parent\t\t= parent_event;\n\n\tevent->ns\t\t= get_pid_ns(task_active_pid_ns(current));\n\tevent->id\t\t= atomic64_inc_return(&perf_event_id);\n\n\tevent->state\t\t= PERF_EVENT_STATE_INACTIVE;\n\n\tif (task) {\n\t\tevent->attach_state = PERF_ATTACH_TASK;\n\t\t/*\n\t\t * XXX pmu::event_init needs to know what task to account to\n\t\t * and we cannot use the ctx information because we need the\n\t\t * pmu before we get a ctx.\n\t\t */\n\t\tevent->hw.target = task;\n\t}\n\n\tevent->clock = &local_clock;\n\tif (parent_event)\n\t\tevent->clock = parent_event->clock;\n\n\tif (!overflow_handler && parent_event) {\n\t\toverflow_handler = parent_event->overflow_handler;\n\t\tcontext = parent_event->overflow_handler_context;\n#if defined(CONFIG_BPF_SYSCALL) && defined(CONFIG_EVENT_TRACING)\n\t\tif (overflow_handler == bpf_overflow_handler) {\n\t\t\tstruct bpf_prog *prog = bpf_prog_inc(parent_event->prog);\n\n\t\t\tif (IS_ERR(prog)) {\n\t\t\t\terr = PTR_ERR(prog);\n\t\t\t\tgoto err_ns;\n\t\t\t}\n\t\t\tevent->prog = prog;\n\t\t\tevent->orig_overflow_handler =\n\t\t\t\tparent_event->orig_overflow_handler;\n\t\t}\n#endif\n\t}\n\n\tif (overflow_handler) {\n\t\tevent->overflow_handler\t= overflow_handler;\n\t\tevent->overflow_handler_context = context;\n\t} else if (is_write_backward(event)){\n\t\tevent->overflow_handler = perf_event_output_backward;\n\t\tevent->overflow_handler_context = NULL;\n\t} else {\n\t\tevent->overflow_handler = perf_event_output_forward;\n\t\tevent->overflow_handler_context = NULL;\n\t}\n\n\tperf_event__state_init(event);\n\n\tpmu = NULL;\n\n\thwc = &event->hw;\n\thwc->sample_period = attr->sample_period;\n\tif (attr->freq && attr->sample_freq)\n\t\thwc->sample_period = 1;\n\thwc->last_period = hwc->sample_period;\n\n\tlocal64_set(&hwc->period_left, hwc->sample_period);\n\n\t/*\n\t * we currently do not support PERF_FORMAT_GROUP on inherited events\n\t */\n\tif (attr->inherit && (attr->read_format & PERF_FORMAT_GROUP))\n\t\tgoto err_ns;\n\n\tif (!has_branch_stack(event))\n\t\tevent->attr.branch_sample_type = 0;\n\n\tif (cgroup_fd != -1) {\n\t\terr = perf_cgroup_connect(cgroup_fd, event, attr, group_leader);\n\t\tif (err)\n\t\t\tgoto err_ns;\n\t}\n\n\tpmu = perf_init_event(event);\n\tif (!pmu)\n\t\tgoto err_ns;\n\telse if (IS_ERR(pmu)) {\n\t\terr = PTR_ERR(pmu);\n\t\tgoto err_ns;\n\t}\n\n\terr = exclusive_event_init(event);\n\tif (err)\n\t\tgoto err_pmu;\n\n\tif (has_addr_filter(event)) {\n\t\tevent->addr_filters_offs = kcalloc(pmu->nr_addr_filters,\n\t\t\t\t\t\t   sizeof(unsigned long),\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!event->addr_filters_offs)\n\t\t\tgoto err_per_task;\n\n\t\t/* force hw sync on the address filters */\n\t\tevent->addr_filters_gen = 1;\n\t}\n\n\tif (!event->parent) {\n\t\tif (event->attr.sample_type & PERF_SAMPLE_CALLCHAIN) {\n\t\t\terr = get_callchain_buffers(attr->sample_max_stack);\n\t\t\tif (err)\n\t\t\t\tgoto err_addr_filters;\n\t\t}\n\t}\n\n\t/* symmetric to unaccount_event() in _free_event() */\n\taccount_event(event);\n\n\treturn event;\n\nerr_addr_filters:\n\tkfree(event->addr_filters_offs);\n\nerr_per_task:\n\texclusive_event_destroy(event);\n\nerr_pmu:\n\tif (event->destroy)\n\t\tevent->destroy(event);\n\tmodule_put(pmu->module);\nerr_ns:\n\tif (is_cgroup_event(event))\n\t\tperf_detach_cgroup(event);\n\tif (event->ns)\n\t\tput_pid_ns(event->ns);\n\tkfree(event);\n\n\treturn ERR_PTR(err);\n}\n\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr)\n{\n\tu32 size;\n\tint ret;\n\n\tif (!access_ok(VERIFY_WRITE, uattr, PERF_ATTR_SIZE_VER0))\n\t\treturn -EFAULT;\n\n\t/*\n\t * zero the full structure, so that a short copy will be nice.\n\t */\n\tmemset(attr, 0, sizeof(*attr));\n\n\tret = get_user(size, &uattr->size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (size > PAGE_SIZE)\t/* silly large */\n\t\tgoto err_size;\n\n\tif (!size)\t\t/* abi compat */\n\t\tsize = PERF_ATTR_SIZE_VER0;\n\n\tif (size < PERF_ATTR_SIZE_VER0)\n\t\tgoto err_size;\n\n\t/*\n\t * If we're handed a bigger struct than we know of,\n\t * ensure all the unknown bits are 0 - i.e. new\n\t * user-space does not rely on any kernel feature\n\t * extensions we dont know about yet.\n\t */\n\tif (size > sizeof(*attr)) {\n\t\tunsigned char __user *addr;\n\t\tunsigned char __user *end;\n\t\tunsigned char val;\n\n\t\taddr = (void __user *)uattr + sizeof(*attr);\n\t\tend  = (void __user *)uattr + size;\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tret = get_user(val, addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (val)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tsize = sizeof(*attr);\n\t}\n\n\tret = copy_from_user(attr, uattr, size);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tif (attr->__reserved_1)\n\t\treturn -EINVAL;\n\n\tif (attr->sample_type & ~(PERF_SAMPLE_MAX-1))\n\t\treturn -EINVAL;\n\n\tif (attr->read_format & ~(PERF_FORMAT_MAX-1))\n\t\treturn -EINVAL;\n\n\tif (attr->sample_type & PERF_SAMPLE_BRANCH_STACK) {\n\t\tu64 mask = attr->branch_sample_type;\n\n\t\t/* only using defined bits */\n\t\tif (mask & ~(PERF_SAMPLE_BRANCH_MAX-1))\n\t\t\treturn -EINVAL;\n\n\t\t/* at least one branch bit must be set */\n\t\tif (!(mask & ~PERF_SAMPLE_BRANCH_PLM_ALL))\n\t\t\treturn -EINVAL;\n\n\t\t/* propagate priv level, when not set for branch */\n\t\tif (!(mask & PERF_SAMPLE_BRANCH_PLM_ALL)) {\n\n\t\t\t/* exclude_kernel checked on syscall entry */\n\t\t\tif (!attr->exclude_kernel)\n\t\t\t\tmask |= PERF_SAMPLE_BRANCH_KERNEL;\n\n\t\t\tif (!attr->exclude_user)\n\t\t\t\tmask |= PERF_SAMPLE_BRANCH_USER;\n\n\t\t\tif (!attr->exclude_hv)\n\t\t\t\tmask |= PERF_SAMPLE_BRANCH_HV;\n\t\t\t/*\n\t\t\t * adjust user setting (for HW filter setup)\n\t\t\t */\n\t\t\tattr->branch_sample_type = mask;\n\t\t}\n\t\t/* privileged levels capture (kernel, hv): check permissions */\n\t\tif ((mask & PERF_SAMPLE_BRANCH_PERM_PLM)\n\t\t    && perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\t}\n\n\tif (attr->sample_type & PERF_SAMPLE_REGS_USER) {\n\t\tret = perf_reg_validate(attr->sample_regs_user);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (attr->sample_type & PERF_SAMPLE_STACK_USER) {\n\t\tif (!arch_perf_have_user_stack_dump())\n\t\t\treturn -ENOSYS;\n\n\t\t/*\n\t\t * We have __u32 type for the size, but so far\n\t\t * we can only use __u16 as maximum due to the\n\t\t * __u16 sample size limit.\n\t\t */\n\t\tif (attr->sample_stack_user >= USHRT_MAX)\n\t\t\tret = -EINVAL;\n\t\telse if (!IS_ALIGNED(attr->sample_stack_user, sizeof(u64)))\n\t\t\tret = -EINVAL;\n\t}\n\n\tif (attr->sample_type & PERF_SAMPLE_REGS_INTR)\n\t\tret = perf_reg_validate(attr->sample_regs_intr);\nout:\n\treturn ret;\n\nerr_size:\n\tput_user(sizeof(*attr), &uattr->size);\n\tret = -E2BIG;\n\tgoto out;\n}\n\nstatic int\nperf_event_set_output(struct perf_event *event, struct perf_event *output_event)\n{\n\tstruct ring_buffer *rb = NULL;\n\tint ret = -EINVAL;\n\n\tif (!output_event)\n\t\tgoto set;\n\n\t/* don't allow circular references */\n\tif (event == output_event)\n\t\tgoto out;\n\n\t/*\n\t * Don't allow cross-cpu buffers\n\t */\n\tif (output_event->cpu != event->cpu)\n\t\tgoto out;\n\n\t/*\n\t * If its not a per-cpu rb, it must be the same task.\n\t */\n\tif (output_event->cpu == -1 && output_event->ctx != event->ctx)\n\t\tgoto out;\n\n\t/*\n\t * Mixing clocks in the same buffer is trouble you don't need.\n\t */\n\tif (output_event->clock != event->clock)\n\t\tgoto out;\n\n\t/*\n\t * Either writing ring buffer from beginning or from end.\n\t * Mixing is not allowed.\n\t */\n\tif (is_write_backward(output_event) != is_write_backward(event))\n\t\tgoto out;\n\n\t/*\n\t * If both events generate aux data, they must be on the same PMU\n\t */\n\tif (has_aux(event) && has_aux(output_event) &&\n\t    event->pmu != output_event->pmu)\n\t\tgoto out;\n\nset:\n\tmutex_lock(&event->mmap_mutex);\n\t/* Can't redirect output if we've got an active mmap() */\n\tif (atomic_read(&event->mmap_count))\n\t\tgoto unlock;\n\n\tif (output_event) {\n\t\t/* get the rb we want to redirect to */\n\t\trb = ring_buffer_get(output_event);\n\t\tif (!rb)\n\t\t\tgoto unlock;\n\t}\n\n\tring_buffer_attach(event, rb);\n\n\tret = 0;\nunlock:\n\tmutex_unlock(&event->mmap_mutex);\n\nout:\n\treturn ret;\n}\n\nstatic void mutex_lock_double(struct mutex *a, struct mutex *b)\n{\n\tif (b < a)\n\t\tswap(a, b);\n\n\tmutex_lock(a);\n\tmutex_lock_nested(b, SINGLE_DEPTH_NESTING);\n}\n\nstatic int perf_event_set_clock(struct perf_event *event, clockid_t clk_id)\n{\n\tbool nmi_safe = false;\n\n\tswitch (clk_id) {\n\tcase CLOCK_MONOTONIC:\n\t\tevent->clock = &ktime_get_mono_fast_ns;\n\t\tnmi_safe = true;\n\t\tbreak;\n\n\tcase CLOCK_MONOTONIC_RAW:\n\t\tevent->clock = &ktime_get_raw_fast_ns;\n\t\tnmi_safe = true;\n\t\tbreak;\n\n\tcase CLOCK_REALTIME:\n\t\tevent->clock = &ktime_get_real_ns;\n\t\tbreak;\n\n\tcase CLOCK_BOOTTIME:\n\t\tevent->clock = &ktime_get_boot_ns;\n\t\tbreak;\n\n\tcase CLOCK_TAI:\n\t\tevent->clock = &ktime_get_tai_ns;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!nmi_safe && !(event->pmu->capabilities & PERF_PMU_CAP_NO_NMI))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/**\n * sys_perf_event_open - open a performance event, associate it to a task/cpu\n *\n * @attr_uptr:\tevent_id type attributes for monitoring/sampling\n * @pid:\t\ttarget pid\n * @cpu:\t\ttarget cpu\n * @group_fd:\t\tgroup leader event fd\n */\nSYSCALL_DEFINE5(perf_event_open,\n\t\tstruct perf_event_attr __user *, attr_uptr,\n\t\tpid_t, pid, int, cpu, int, group_fd, unsigned long, flags)\n{\n\tstruct perf_event *group_leader = NULL, *output_event = NULL;\n\tstruct perf_event *event, *sibling;\n\tstruct perf_event_attr attr;\n\tstruct perf_event_context *ctx, *uninitialized_var(gctx);\n\tstruct file *event_file = NULL;\n\tstruct fd group = {NULL, 0};\n\tstruct task_struct *task = NULL;\n\tstruct pmu *pmu;\n\tint event_fd;\n\tint move_group = 0;\n\tint err;\n\tint f_flags = O_RDWR;\n\tint cgroup_fd = -1;\n\n\t/* for future expandability... */\n\tif (flags & ~PERF_FLAG_ALL)\n\t\treturn -EINVAL;\n\n\terr = perf_copy_attr(attr_uptr, &attr);\n\tif (err)\n\t\treturn err;\n\n\tif (!attr.exclude_kernel) {\n\t\tif (perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\t}\n\n\tif (attr.freq) {\n\t\tif (attr.sample_freq > sysctl_perf_event_sample_rate)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (attr.sample_period & (1ULL << 63))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!attr.sample_max_stack)\n\t\tattr.sample_max_stack = sysctl_perf_event_max_stack;\n\n\t/*\n\t * In cgroup mode, the pid argument is used to pass the fd\n\t * opened to the cgroup directory in cgroupfs. The cpu argument\n\t * designates the cpu on which to monitor threads from that\n\t * cgroup.\n\t */\n\tif ((flags & PERF_FLAG_PID_CGROUP) && (pid == -1 || cpu == -1))\n\t\treturn -EINVAL;\n\n\tif (flags & PERF_FLAG_FD_CLOEXEC)\n\t\tf_flags |= O_CLOEXEC;\n\n\tevent_fd = get_unused_fd_flags(f_flags);\n\tif (event_fd < 0)\n\t\treturn event_fd;\n\n\tif (group_fd != -1) {\n\t\terr = perf_fget_light(group_fd, &group);\n\t\tif (err)\n\t\t\tgoto err_fd;\n\t\tgroup_leader = group.file->private_data;\n\t\tif (flags & PERF_FLAG_FD_OUTPUT)\n\t\t\toutput_event = group_leader;\n\t\tif (flags & PERF_FLAG_FD_NO_GROUP)\n\t\t\tgroup_leader = NULL;\n\t}\n\n\tif (pid != -1 && !(flags & PERF_FLAG_PID_CGROUP)) {\n\t\ttask = find_lively_task_by_vpid(pid);\n\t\tif (IS_ERR(task)) {\n\t\t\terr = PTR_ERR(task);\n\t\t\tgoto err_group_fd;\n\t\t}\n\t}\n\n\tif (task && group_leader &&\n\t    group_leader->attr.inherit != attr.inherit) {\n\t\terr = -EINVAL;\n\t\tgoto err_task;\n\t}\n\n\tget_online_cpus();\n\n\tif (task) {\n\t\terr = mutex_lock_interruptible(&task->signal->cred_guard_mutex);\n\t\tif (err)\n\t\t\tgoto err_cpus;\n\n\t\t/*\n\t\t * Reuse ptrace permission checks for now.\n\t\t *\n\t\t * We must hold cred_guard_mutex across this and any potential\n\t\t * perf_install_in_context() call for this new event to\n\t\t * serialize against exec() altering our credentials (and the\n\t\t * perf_event_exit_task() that could imply).\n\t\t */\n\t\terr = -EACCES;\n\t\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))\n\t\t\tgoto err_cred;\n\t}\n\n\tif (flags & PERF_FLAG_PID_CGROUP)\n\t\tcgroup_fd = pid;\n\n\tevent = perf_event_alloc(&attr, cpu, task, group_leader, NULL,\n\t\t\t\t NULL, NULL, cgroup_fd);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tgoto err_cred;\n\t}\n\n\tif (is_sampling_event(event)) {\n\t\tif (event->pmu->capabilities & PERF_PMU_CAP_NO_INTERRUPT) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_alloc;\n\t\t}\n\t}\n\n\t/*\n\t * Special case software events and allow them to be part of\n\t * any hardware group.\n\t */\n\tpmu = event->pmu;\n\n\tif (attr.use_clockid) {\n\t\terr = perf_event_set_clock(event, attr.clockid);\n\t\tif (err)\n\t\t\tgoto err_alloc;\n\t}\n\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\tevent->event_caps |= PERF_EV_CAP_SOFTWARE;\n\n\tif (group_leader &&\n\t    (is_software_event(event) != is_software_event(group_leader))) {\n\t\tif (is_software_event(event)) {\n\t\t\t/*\n\t\t\t * If event and group_leader are not both a software\n\t\t\t * event, and event is, then group leader is not.\n\t\t\t *\n\t\t\t * Allow the addition of software events to !software\n\t\t\t * groups, this is safe because software events never\n\t\t\t * fail to schedule.\n\t\t\t */\n\t\t\tpmu = group_leader->pmu;\n\t\t} else if (is_software_event(group_leader) &&\n\t\t\t   (group_leader->group_caps & PERF_EV_CAP_SOFTWARE)) {\n\t\t\t/*\n\t\t\t * In case the group is a pure software group, and we\n\t\t\t * try to add a hardware event, move the whole group to\n\t\t\t * the hardware context.\n\t\t\t */\n\t\t\tmove_group = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Get the target context (task or percpu):\n\t */\n\tctx = find_get_context(pmu, task, event);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto err_alloc;\n\t}\n\n\tif ((pmu->capabilities & PERF_PMU_CAP_EXCLUSIVE) && group_leader) {\n\t\terr = -EBUSY;\n\t\tgoto err_context;\n\t}\n\n\t/*\n\t * Look up the group leader (we will attach this event to it):\n\t */\n\tif (group_leader) {\n\t\terr = -EINVAL;\n\n\t\t/*\n\t\t * Do not allow a recursive hierarchy (this new sibling\n\t\t * becoming part of another group-sibling):\n\t\t */\n\t\tif (group_leader->group_leader != group_leader)\n\t\t\tgoto err_context;\n\n\t\t/* All events in a group should have the same clock */\n\t\tif (group_leader->clock != event->clock)\n\t\t\tgoto err_context;\n\n\t\t/*\n\t\t * Do not allow to attach to a group in a different\n\t\t * task or CPU context:\n\t\t */\n\t\tif (move_group) {\n\t\t\t/*\n\t\t\t * Make sure we're both on the same task, or both\n\t\t\t * per-cpu events.\n\t\t\t */\n\t\t\tif (group_leader->ctx->task != ctx->task)\n\t\t\t\tgoto err_context;\n\n\t\t\t/*\n\t\t\t * Make sure we're both events for the same CPU;\n\t\t\t * grouping events for different CPUs is broken; since\n\t\t\t * you can never concurrently schedule them anyhow.\n\t\t\t */\n\t\t\tif (group_leader->cpu != event->cpu)\n\t\t\t\tgoto err_context;\n\t\t} else {\n\t\t\tif (group_leader->ctx != ctx)\n\t\t\t\tgoto err_context;\n\t\t}\n\n\t\t/*\n\t\t * Only a group leader can be exclusive or pinned\n\t\t */\n\t\tif (attr.exclusive || attr.pinned)\n\t\t\tgoto err_context;\n\t}\n\n\tif (output_event) {\n\t\terr = perf_event_set_output(event, output_event);\n\t\tif (err)\n\t\t\tgoto err_context;\n\t}\n\n\tevent_file = anon_inode_getfile(\"[perf_event]\", &perf_fops, event,\n\t\t\t\t\tf_flags);\n\tif (IS_ERR(event_file)) {\n\t\terr = PTR_ERR(event_file);\n\t\tevent_file = NULL;\n\t\tgoto err_context;\n\t}\n\n\tif (move_group) {\n\t\tgctx = group_leader->ctx;\n\t\tmutex_lock_double(&gctx->mutex, &ctx->mutex);\n\t\tif (gctx->task == TASK_TOMBSTONE) {\n\t\t\terr = -ESRCH;\n\t\t\tgoto err_locked;\n\t\t}\n\t} else {\n\t\tmutex_lock(&ctx->mutex);\n\t}\n\n\tif (ctx->task == TASK_TOMBSTONE) {\n\t\terr = -ESRCH;\n\t\tgoto err_locked;\n\t}\n\n\tif (!perf_event_validate_size(event)) {\n\t\terr = -E2BIG;\n\t\tgoto err_locked;\n\t}\n\n\t/*\n\t * Must be under the same ctx::mutex as perf_install_in_context(),\n\t * because we need to serialize with concurrent event creation.\n\t */\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\t/* exclusive and group stuff are assumed mutually exclusive */\n\t\tWARN_ON_ONCE(move_group);\n\n\t\terr = -EBUSY;\n\t\tgoto err_locked;\n\t}\n\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\n\t/*\n\t * This is the point on no return; we cannot fail hereafter. This is\n\t * where we start modifying current state.\n\t */\n\n\tif (move_group) {\n\t\t/*\n\t\t * See perf_event_ctx_lock() for comments on the details\n\t\t * of swizzling perf_event::ctx.\n\t\t */\n\t\tperf_remove_from_context(group_leader, 0);\n\n\t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n\t\t\t\t    group_entry) {\n\t\t\tperf_remove_from_context(sibling, 0);\n\t\t\tput_ctx(gctx);\n\t\t}\n\n\t\t/*\n\t\t * Wait for everybody to stop referencing the events through\n\t\t * the old lists, before installing it on new lists.\n\t\t */\n\t\tsynchronize_rcu();\n\n\t\t/*\n\t\t * Install the group siblings before the group leader.\n\t\t *\n\t\t * Because a group leader will try and install the entire group\n\t\t * (through the sibling list, which is still in-tact), we can\n\t\t * end up with siblings installed in the wrong context.\n\t\t *\n\t\t * By installing siblings first we NO-OP because they're not\n\t\t * reachable through the group lists.\n\t\t */\n\t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n\t\t\t\t    group_entry) {\n\t\t\tperf_event__state_init(sibling);\n\t\t\tperf_install_in_context(ctx, sibling, sibling->cpu);\n\t\t\tget_ctx(ctx);\n\t\t}\n\n\t\t/*\n\t\t * Removing from the context ends up with disabled\n\t\t * event. What we want here is event in the initial\n\t\t * startup state, ready to be add into new context.\n\t\t */\n\t\tperf_event__state_init(group_leader);\n\t\tperf_install_in_context(ctx, group_leader, group_leader->cpu);\n\t\tget_ctx(ctx);\n\n\t\t/*\n\t\t * Now that all events are installed in @ctx, nothing\n\t\t * references @gctx anymore, so drop the last reference we have\n\t\t * on it.\n\t\t */\n\t\tput_ctx(gctx);\n\t}\n\n\t/*\n\t * Precalculate sample_data sizes; do while holding ctx::mutex such\n\t * that we're serialized against further additions and before\n\t * perf_install_in_context() which is the point the event is active and\n\t * can use these values.\n\t */\n\tperf_event__header_size(event);\n\tperf_event__id_header_size(event);\n\n\tevent->owner = current;\n\n\tperf_install_in_context(ctx, event, event->cpu);\n\tperf_unpin_context(ctx);\n\n\tif (move_group)\n\t\tmutex_unlock(&gctx->mutex);\n\tmutex_unlock(&ctx->mutex);\n\n\tif (task) {\n\t\tmutex_unlock(&task->signal->cred_guard_mutex);\n\t\tput_task_struct(task);\n\t}\n\n\tput_online_cpus();\n\n\tmutex_lock(&current->perf_event_mutex);\n\tlist_add_tail(&event->owner_entry, &current->perf_event_list);\n\tmutex_unlock(&current->perf_event_mutex);\n\n\t/*\n\t * Drop the reference on the group_event after placing the\n\t * new event on the sibling_list. This ensures destruction\n\t * of the group leader will find the pointer to itself in\n\t * perf_group_detach().\n\t */\n\tfdput(group);\n\tfd_install(event_fd, event_file);\n\treturn event_fd;\n\nerr_locked:\n\tif (move_group)\n\t\tmutex_unlock(&gctx->mutex);\n\tmutex_unlock(&ctx->mutex);\n/* err_file: */\n\tfput(event_file);\nerr_context:\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_alloc:\n\t/*\n\t * If event_file is set, the fput() above will have called ->release()\n\t * and that will take care of freeing the event.\n\t */\n\tif (!event_file)\n\t\tfree_event(event);\nerr_cred:\n\tif (task)\n\t\tmutex_unlock(&task->signal->cred_guard_mutex);\nerr_cpus:\n\tput_online_cpus();\nerr_task:\n\tif (task)\n\t\tput_task_struct(task);\nerr_group_fd:\n\tfdput(group);\nerr_fd:\n\tput_unused_fd(event_fd);\n\treturn err;\n}\n\n/**\n * perf_event_create_kernel_counter\n *\n * @attr: attributes of the counter to create\n * @cpu: cpu in which the counter is bound\n * @task: task to profile (NULL for percpu)\n */\nstruct perf_event *\nperf_event_create_kernel_counter(struct perf_event_attr *attr, int cpu,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t perf_overflow_handler_t overflow_handler,\n\t\t\t\t void *context)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\tint err;\n\n\t/*\n\t * Get the target context (task or percpu):\n\t */\n\n\tevent = perf_event_alloc(attr, cpu, task, NULL, NULL,\n\t\t\t\t overflow_handler, context, -1);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tgoto err;\n\t}\n\n\t/* Mark owner so we could distinguish it from user events. */\n\tevent->owner = TASK_TOMBSTONE;\n\n\tctx = find_get_context(event->pmu, task, event);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto err_free;\n\t}\n\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n\tif (ctx->task == TASK_TOMBSTONE) {\n\t\terr = -ESRCH;\n\t\tgoto err_unlock;\n\t}\n\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\terr = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tperf_install_in_context(ctx, event, cpu);\n\tperf_unpin_context(ctx);\n\tmutex_unlock(&ctx->mutex);\n\n\treturn event;\n\nerr_unlock:\n\tmutex_unlock(&ctx->mutex);\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_free:\n\tfree_event(event);\nerr:\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(perf_event_create_kernel_counter);\n\nvoid perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)\n{\n\tstruct perf_event_context *src_ctx;\n\tstruct perf_event_context *dst_ctx;\n\tstruct perf_event *event, *tmp;\n\tLIST_HEAD(events);\n\n\tsrc_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;\n\tdst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;\n\n\t/*\n\t * See perf_event_ctx_lock() for comments on the details\n\t * of swizzling perf_event::ctx.\n\t */\n\tmutex_lock_double(&src_ctx->mutex, &dst_ctx->mutex);\n\tlist_for_each_entry_safe(event, tmp, &src_ctx->event_list,\n\t\t\t\t event_entry) {\n\t\tperf_remove_from_context(event, 0);\n\t\tunaccount_event_cpu(event, src_cpu);\n\t\tput_ctx(src_ctx);\n\t\tlist_add(&event->migrate_entry, &events);\n\t}\n\n\t/*\n\t * Wait for the events to quiesce before re-instating them.\n\t */\n\tsynchronize_rcu();\n\n\t/*\n\t * Re-instate events in 2 passes.\n\t *\n\t * Skip over group leaders and only install siblings on this first\n\t * pass, siblings will not get enabled without a leader, however a\n\t * leader will enable its siblings, even if those are still on the old\n\t * context.\n\t */\n\tlist_for_each_entry_safe(event, tmp, &events, migrate_entry) {\n\t\tif (event->group_leader == event)\n\t\t\tcontinue;\n\n\t\tlist_del(&event->migrate_entry);\n\t\tif (event->state >= PERF_EVENT_STATE_OFF)\n\t\t\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\t\taccount_event_cpu(event, dst_cpu);\n\t\tperf_install_in_context(dst_ctx, event, dst_cpu);\n\t\tget_ctx(dst_ctx);\n\t}\n\n\t/*\n\t * Once all the siblings are setup properly, install the group leaders\n\t * to make it go.\n\t */\n\tlist_for_each_entry_safe(event, tmp, &events, migrate_entry) {\n\t\tlist_del(&event->migrate_entry);\n\t\tif (event->state >= PERF_EVENT_STATE_OFF)\n\t\t\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\t\taccount_event_cpu(event, dst_cpu);\n\t\tperf_install_in_context(dst_ctx, event, dst_cpu);\n\t\tget_ctx(dst_ctx);\n\t}\n\tmutex_unlock(&dst_ctx->mutex);\n\tmutex_unlock(&src_ctx->mutex);\n}\nEXPORT_SYMBOL_GPL(perf_pmu_migrate_context);\n\nstatic void sync_child_event(struct perf_event *child_event,\n\t\t\t       struct task_struct *child)\n{\n\tstruct perf_event *parent_event = child_event->parent;\n\tu64 child_val;\n\n\tif (child_event->attr.inherit_stat)\n\t\tperf_event_read_event(child_event, child);\n\n\tchild_val = perf_event_count(child_event);\n\n\t/*\n\t * Add back the child's count to the parent's count:\n\t */\n\tatomic64_add(child_val, &parent_event->child_count);\n\tatomic64_add(child_event->total_time_enabled,\n\t\t     &parent_event->child_total_time_enabled);\n\tatomic64_add(child_event->total_time_running,\n\t\t     &parent_event->child_total_time_running);\n}\n\nstatic void\nperf_event_exit_event(struct perf_event *child_event,\n\t\t      struct perf_event_context *child_ctx,\n\t\t      struct task_struct *child)\n{\n\tstruct perf_event *parent_event = child_event->parent;\n\n\t/*\n\t * Do not destroy the 'original' grouping; because of the context\n\t * switch optimization the original events could've ended up in a\n\t * random child task.\n\t *\n\t * If we were to destroy the original group, all group related\n\t * operations would cease to function properly after this random\n\t * child dies.\n\t *\n\t * Do destroy all inherited groups, we don't care about those\n\t * and being thorough is better.\n\t */\n\traw_spin_lock_irq(&child_ctx->lock);\n\tWARN_ON_ONCE(child_ctx->is_active);\n\n\tif (parent_event)\n\t\tperf_group_detach(child_event);\n\tlist_del_event(child_event, child_ctx);\n\tchild_event->state = PERF_EVENT_STATE_EXIT; /* is_event_hup() */\n\traw_spin_unlock_irq(&child_ctx->lock);\n\n\t/*\n\t * Parent events are governed by their filedesc, retain them.\n\t */\n\tif (!parent_event) {\n\t\tperf_event_wakeup(child_event);\n\t\treturn;\n\t}\n\t/*\n\t * Child events can be cleaned up.\n\t */\n\n\tsync_child_event(child_event, child);\n\n\t/*\n\t * Remove this event from the parent's list\n\t */\n\tWARN_ON_ONCE(parent_event->ctx->parent_ctx);\n\tmutex_lock(&parent_event->child_mutex);\n\tlist_del_init(&child_event->child_list);\n\tmutex_unlock(&parent_event->child_mutex);\n\n\t/*\n\t * Kick perf_poll() for is_event_hup().\n\t */\n\tperf_event_wakeup(parent_event);\n\tfree_event(child_event);\n\tput_event(parent_event);\n}\n\nstatic void perf_event_exit_task_context(struct task_struct *child, int ctxn)\n{\n\tstruct perf_event_context *child_ctx, *clone_ctx = NULL;\n\tstruct perf_event *child_event, *next;\n\n\tWARN_ON_ONCE(child != current);\n\n\tchild_ctx = perf_pin_task_context(child, ctxn);\n\tif (!child_ctx)\n\t\treturn;\n\n\t/*\n\t * In order to reduce the amount of tricky in ctx tear-down, we hold\n\t * ctx::mutex over the entire thing. This serializes against almost\n\t * everything that wants to access the ctx.\n\t *\n\t * The exception is sys_perf_event_open() /\n\t * perf_event_create_kernel_count() which does find_get_context()\n\t * without ctx::mutex (it cannot because of the move_group double mutex\n\t * lock thing). See the comments in perf_install_in_context().\n\t */\n\tmutex_lock(&child_ctx->mutex);\n\n\t/*\n\t * In a single ctx::lock section, de-schedule the events and detach the\n\t * context from the task such that we cannot ever get it scheduled back\n\t * in.\n\t */\n\traw_spin_lock_irq(&child_ctx->lock);\n\ttask_ctx_sched_out(__get_cpu_context(child_ctx), child_ctx);\n\n\t/*\n\t * Now that the context is inactive, destroy the task <-> ctx relation\n\t * and mark the context dead.\n\t */\n\tRCU_INIT_POINTER(child->perf_event_ctxp[ctxn], NULL);\n\tput_ctx(child_ctx); /* cannot be last */\n\tWRITE_ONCE(child_ctx->task, TASK_TOMBSTONE);\n\tput_task_struct(current); /* cannot be last */\n\n\tclone_ctx = unclone_ctx(child_ctx);\n\traw_spin_unlock_irq(&child_ctx->lock);\n\n\tif (clone_ctx)\n\t\tput_ctx(clone_ctx);\n\n\t/*\n\t * Report the task dead after unscheduling the events so that we\n\t * won't get any samples after PERF_RECORD_EXIT. We can however still\n\t * get a few PERF_RECORD_READ events.\n\t */\n\tperf_event_task(child, child_ctx, 0);\n\n\tlist_for_each_entry_safe(child_event, next, &child_ctx->event_list, event_entry)\n\t\tperf_event_exit_event(child_event, child_ctx, child);\n\n\tmutex_unlock(&child_ctx->mutex);\n\n\tput_ctx(child_ctx);\n}\n\n/*\n * When a child task exits, feed back event values to parent events.\n *\n * Can be called with cred_guard_mutex held when called from\n * install_exec_creds().\n */\nvoid perf_event_exit_task(struct task_struct *child)\n{\n\tstruct perf_event *event, *tmp;\n\tint ctxn;\n\n\tmutex_lock(&child->perf_event_mutex);\n\tlist_for_each_entry_safe(event, tmp, &child->perf_event_list,\n\t\t\t\t owner_entry) {\n\t\tlist_del_init(&event->owner_entry);\n\n\t\t/*\n\t\t * Ensure the list deletion is visible before we clear\n\t\t * the owner, closes a race against perf_release() where\n\t\t * we need to serialize on the owner->perf_event_mutex.\n\t\t */\n\t\tsmp_store_release(&event->owner, NULL);\n\t}\n\tmutex_unlock(&child->perf_event_mutex);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_exit_task_context(child, ctxn);\n\n\t/*\n\t * The perf_event_exit_task_context calls perf_event_task\n\t * with child's task_ctx, which generates EXIT events for\n\t * child contexts and sets child->perf_event_ctxp[] to NULL.\n\t * At this point we need to send EXIT events to cpu contexts.\n\t */\n\tperf_event_task(child, NULL, 0);\n}\n\nstatic void perf_free_event(struct perf_event *event,\n\t\t\t    struct perf_event_context *ctx)\n{\n\tstruct perf_event *parent = event->parent;\n\n\tif (WARN_ON_ONCE(!parent))\n\t\treturn;\n\n\tmutex_lock(&parent->child_mutex);\n\tlist_del_init(&event->child_list);\n\tmutex_unlock(&parent->child_mutex);\n\n\tput_event(parent);\n\n\traw_spin_lock_irq(&ctx->lock);\n\tperf_group_detach(event);\n\tlist_del_event(event, ctx);\n\traw_spin_unlock_irq(&ctx->lock);\n\tfree_event(event);\n}\n\n/*\n * Free an unexposed, unused context as created by inheritance by\n * perf_event_init_task below, used by fork() in case of fail.\n *\n * Not all locks are strictly required, but take them anyway to be nice and\n * help out with the lockdep assertions.\n */\nvoid perf_event_free_task(struct task_struct *task)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event, *tmp;\n\tint ctxn;\n\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = task->perf_event_ctxp[ctxn];\n\t\tif (!ctx)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&ctx->mutex);\nagain:\n\t\tlist_for_each_entry_safe(event, tmp, &ctx->pinned_groups,\n\t\t\t\tgroup_entry)\n\t\t\tperf_free_event(event, ctx);\n\n\t\tlist_for_each_entry_safe(event, tmp, &ctx->flexible_groups,\n\t\t\t\tgroup_entry)\n\t\t\tperf_free_event(event, ctx);\n\n\t\tif (!list_empty(&ctx->pinned_groups) ||\n\t\t\t\t!list_empty(&ctx->flexible_groups))\n\t\t\tgoto again;\n\n\t\tmutex_unlock(&ctx->mutex);\n\n\t\tput_ctx(ctx);\n\t}\n}\n\nvoid perf_event_delayed_put(struct task_struct *task)\n{\n\tint ctxn;\n\n\tfor_each_task_context_nr(ctxn)\n\t\tWARN_ON_ONCE(task->perf_event_ctxp[ctxn]);\n}\n\nstruct file *perf_event_get(unsigned int fd)\n{\n\tstruct file *file;\n\n\tfile = fget_raw(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (file->f_op != &perf_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn file;\n}\n\nconst struct perf_event_attr *perf_event_attrs(struct perf_event *event)\n{\n\tif (!event)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn &event->attr;\n}\n\n/*\n * inherit a event from parent task to child task:\n */\nstatic struct perf_event *\ninherit_event(struct perf_event *parent_event,\n\t      struct task_struct *parent,\n\t      struct perf_event_context *parent_ctx,\n\t      struct task_struct *child,\n\t      struct perf_event *group_leader,\n\t      struct perf_event_context *child_ctx)\n{\n\tenum perf_event_active_state parent_state = parent_event->state;\n\tstruct perf_event *child_event;\n\tunsigned long flags;\n\n\t/*\n\t * Instead of creating recursive hierarchies of events,\n\t * we link inherited events back to the original parent,\n\t * which has a filp for sure, which we use as the reference\n\t * count:\n\t */\n\tif (parent_event->parent)\n\t\tparent_event = parent_event->parent;\n\n\tchild_event = perf_event_alloc(&parent_event->attr,\n\t\t\t\t\t   parent_event->cpu,\n\t\t\t\t\t   child,\n\t\t\t\t\t   group_leader, parent_event,\n\t\t\t\t\t   NULL, NULL, -1);\n\tif (IS_ERR(child_event))\n\t\treturn child_event;\n\n\t/*\n\t * is_orphaned_event() and list_add_tail(&parent_event->child_list)\n\t * must be under the same lock in order to serialize against\n\t * perf_event_release_kernel(), such that either we must observe\n\t * is_orphaned_event() or they will observe us on the child_list.\n\t */\n\tmutex_lock(&parent_event->child_mutex);\n\tif (is_orphaned_event(parent_event) ||\n\t    !atomic_long_inc_not_zero(&parent_event->refcount)) {\n\t\tmutex_unlock(&parent_event->child_mutex);\n\t\tfree_event(child_event);\n\t\treturn NULL;\n\t}\n\n\tget_ctx(child_ctx);\n\n\t/*\n\t * Make the child state follow the state of the parent event,\n\t * not its attr.disabled bit.  We hold the parent's mutex,\n\t * so we won't race with perf_event_{en, dis}able_family.\n\t */\n\tif (parent_state >= PERF_EVENT_STATE_INACTIVE)\n\t\tchild_event->state = PERF_EVENT_STATE_INACTIVE;\n\telse\n\t\tchild_event->state = PERF_EVENT_STATE_OFF;\n\n\tif (parent_event->attr.freq) {\n\t\tu64 sample_period = parent_event->hw.sample_period;\n\t\tstruct hw_perf_event *hwc = &child_event->hw;\n\n\t\thwc->sample_period = sample_period;\n\t\thwc->last_period   = sample_period;\n\n\t\tlocal64_set(&hwc->period_left, sample_period);\n\t}\n\n\tchild_event->ctx = child_ctx;\n\tchild_event->overflow_handler = parent_event->overflow_handler;\n\tchild_event->overflow_handler_context\n\t\t= parent_event->overflow_handler_context;\n\n\t/*\n\t * Precalculate sample_data sizes\n\t */\n\tperf_event__header_size(child_event);\n\tperf_event__id_header_size(child_event);\n\n\t/*\n\t * Link it up in the child's context:\n\t */\n\traw_spin_lock_irqsave(&child_ctx->lock, flags);\n\tadd_event_to_ctx(child_event, child_ctx);\n\traw_spin_unlock_irqrestore(&child_ctx->lock, flags);\n\n\t/*\n\t * Link this into the parent event's child list\n\t */\n\tlist_add_tail(&child_event->child_list, &parent_event->child_list);\n\tmutex_unlock(&parent_event->child_mutex);\n\n\treturn child_event;\n}\n\nstatic int inherit_group(struct perf_event *parent_event,\n\t      struct task_struct *parent,\n\t      struct perf_event_context *parent_ctx,\n\t      struct task_struct *child,\n\t      struct perf_event_context *child_ctx)\n{\n\tstruct perf_event *leader;\n\tstruct perf_event *sub;\n\tstruct perf_event *child_ctr;\n\n\tleader = inherit_event(parent_event, parent, parent_ctx,\n\t\t\t\t child, NULL, child_ctx);\n\tif (IS_ERR(leader))\n\t\treturn PTR_ERR(leader);\n\tlist_for_each_entry(sub, &parent_event->sibling_list, group_entry) {\n\t\tchild_ctr = inherit_event(sub, parent, parent_ctx,\n\t\t\t\t\t    child, leader, child_ctx);\n\t\tif (IS_ERR(child_ctr))\n\t\t\treturn PTR_ERR(child_ctr);\n\t}\n\treturn 0;\n}\n\nstatic int\ninherit_task_group(struct perf_event *event, struct task_struct *parent,\n\t\t   struct perf_event_context *parent_ctx,\n\t\t   struct task_struct *child, int ctxn,\n\t\t   int *inherited_all)\n{\n\tint ret;\n\tstruct perf_event_context *child_ctx;\n\n\tif (!event->attr.inherit) {\n\t\t*inherited_all = 0;\n\t\treturn 0;\n\t}\n\n\tchild_ctx = child->perf_event_ctxp[ctxn];\n\tif (!child_ctx) {\n\t\t/*\n\t\t * This is executed from the parent task context, so\n\t\t * inherit events that have been marked for cloning.\n\t\t * First allocate and initialize a context for the\n\t\t * child.\n\t\t */\n\n\t\tchild_ctx = alloc_perf_context(parent_ctx->pmu, child);\n\t\tif (!child_ctx)\n\t\t\treturn -ENOMEM;\n\n\t\tchild->perf_event_ctxp[ctxn] = child_ctx;\n\t}\n\n\tret = inherit_group(event, parent, parent_ctx,\n\t\t\t    child, child_ctx);\n\n\tif (ret)\n\t\t*inherited_all = 0;\n\n\treturn ret;\n}\n\n/*\n * Initialize the perf_event context in task_struct\n */\nstatic int perf_event_init_context(struct task_struct *child, int ctxn)\n{\n\tstruct perf_event_context *child_ctx, *parent_ctx;\n\tstruct perf_event_context *cloned_ctx;\n\tstruct perf_event *event;\n\tstruct task_struct *parent = current;\n\tint inherited_all = 1;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (likely(!parent->perf_event_ctxp[ctxn]))\n\t\treturn 0;\n\n\t/*\n\t * If the parent's context is a clone, pin it so it won't get\n\t * swapped under us.\n\t */\n\tparent_ctx = perf_pin_task_context(parent, ctxn);\n\tif (!parent_ctx)\n\t\treturn 0;\n\n\t/*\n\t * No need to check if parent_ctx != NULL here; since we saw\n\t * it non-NULL earlier, the only reason for it to become NULL\n\t * is if we exit, and since we're currently in the middle of\n\t * a fork we can't be exiting at the same time.\n\t */\n\n\t/*\n\t * Lock the parent list. No need to lock the child - not PID\n\t * hashed yet and not running, so nobody can access it.\n\t */\n\tmutex_lock(&parent_ctx->mutex);\n\n\t/*\n\t * We dont have to disable NMIs - we are only looking at\n\t * the list, not manipulating it:\n\t */\n\tlist_for_each_entry(event, &parent_ctx->pinned_groups, group_entry) {\n\t\tret = inherit_task_group(event, parent, parent_ctx,\n\t\t\t\t\t child, ctxn, &inherited_all);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * We can't hold ctx->lock when iterating the ->flexible_group list due\n\t * to allocations, but we need to prevent rotation because\n\t * rotate_ctx() will change the list from interrupt context.\n\t */\n\traw_spin_lock_irqsave(&parent_ctx->lock, flags);\n\tparent_ctx->rotate_disable = 1;\n\traw_spin_unlock_irqrestore(&parent_ctx->lock, flags);\n\n\tlist_for_each_entry(event, &parent_ctx->flexible_groups, group_entry) {\n\t\tret = inherit_task_group(event, parent, parent_ctx,\n\t\t\t\t\t child, ctxn, &inherited_all);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\traw_spin_lock_irqsave(&parent_ctx->lock, flags);\n\tparent_ctx->rotate_disable = 0;\n\n\tchild_ctx = child->perf_event_ctxp[ctxn];\n\n\tif (child_ctx && inherited_all) {\n\t\t/*\n\t\t * Mark the child context as a clone of the parent\n\t\t * context, or of whatever the parent is a clone of.\n\t\t *\n\t\t * Note that if the parent is a clone, the holding of\n\t\t * parent_ctx->lock avoids it from being uncloned.\n\t\t */\n\t\tcloned_ctx = parent_ctx->parent_ctx;\n\t\tif (cloned_ctx) {\n\t\t\tchild_ctx->parent_ctx = cloned_ctx;\n\t\t\tchild_ctx->parent_gen = parent_ctx->parent_gen;\n\t\t} else {\n\t\t\tchild_ctx->parent_ctx = parent_ctx;\n\t\t\tchild_ctx->parent_gen = parent_ctx->generation;\n\t\t}\n\t\tget_ctx(child_ctx->parent_ctx);\n\t}\n\n\traw_spin_unlock_irqrestore(&parent_ctx->lock, flags);\n\tmutex_unlock(&parent_ctx->mutex);\n\n\tperf_unpin_context(parent_ctx);\n\tput_ctx(parent_ctx);\n\n\treturn ret;\n}\n\n/*\n * Initialize the perf_event context in task_struct\n */\nint perf_event_init_task(struct task_struct *child)\n{\n\tint ctxn, ret;\n\n\tmemset(child->perf_event_ctxp, 0, sizeof(child->perf_event_ctxp));\n\tmutex_init(&child->perf_event_mutex);\n\tINIT_LIST_HEAD(&child->perf_event_list);\n\n\tfor_each_task_context_nr(ctxn) {\n\t\tret = perf_event_init_context(child, ctxn);\n\t\tif (ret) {\n\t\t\tperf_event_free_task(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __init perf_event_init_all_cpus(void)\n{\n\tstruct swevent_htable *swhash;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tswhash = &per_cpu(swevent_htable, cpu);\n\t\tmutex_init(&swhash->hlist_mutex);\n\t\tINIT_LIST_HEAD(&per_cpu(active_ctx_list, cpu));\n\n\t\tINIT_LIST_HEAD(&per_cpu(pmu_sb_events.list, cpu));\n\t\traw_spin_lock_init(&per_cpu(pmu_sb_events.lock, cpu));\n\n\t\tINIT_LIST_HEAD(&per_cpu(sched_cb_list, cpu));\n\t}\n}\n\nint perf_event_init_cpu(unsigned int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\n\tmutex_lock(&swhash->hlist_mutex);\n\tif (swhash->hlist_refcount > 0 && !swevent_hlist_deref(swhash)) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));\n\t\tWARN_ON(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n\treturn 0;\n}\n\n#if defined CONFIG_HOTPLUG_CPU || defined CONFIG_KEXEC_CORE\nstatic void __perf_event_exit_context(void *__info)\n{\n\tstruct perf_event_context *ctx = __info;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\tstruct perf_event *event;\n\n\traw_spin_lock(&ctx->lock);\n\tlist_for_each_entry(event, &ctx->event_list, event_entry)\n\t\t__perf_remove_from_context(event, cpuctx, ctx, (void *)DETACH_GROUP);\n\traw_spin_unlock(&ctx->lock);\n}\n\nstatic void perf_event_exit_cpu_context(int cpu)\n{\n\tstruct perf_event_context *ctx;\n\tstruct pmu *pmu;\n\tint idx;\n\n\tidx = srcu_read_lock(&pmus_srcu);\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tctx = &per_cpu_ptr(pmu->pmu_cpu_context, cpu)->ctx;\n\n\t\tmutex_lock(&ctx->mutex);\n\t\tsmp_call_function_single(cpu, __perf_event_exit_context, ctx, 1);\n\t\tmutex_unlock(&ctx->mutex);\n\t}\n\tsrcu_read_unlock(&pmus_srcu, idx);\n}\n#else\n\nstatic void perf_event_exit_cpu_context(int cpu) { }\n\n#endif\n\nint perf_event_exit_cpu(unsigned int cpu)\n{\n\tperf_event_exit_cpu_context(cpu);\n\treturn 0;\n}\n\nstatic int\nperf_reboot(struct notifier_block *notifier, unsigned long val, void *v)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu)\n\t\tperf_event_exit_cpu(cpu);\n\n\treturn NOTIFY_OK;\n}\n\n/*\n * Run the perf reboot notifier at the very last possible moment so that\n * the generic watchdog code runs as long as possible.\n */\nstatic struct notifier_block perf_reboot_notifier = {\n\t.notifier_call = perf_reboot,\n\t.priority = INT_MIN,\n};\n\nvoid __init perf_event_init(void)\n{\n\tint ret;\n\n\tidr_init(&pmu_idr);\n\n\tperf_event_init_all_cpus();\n\tinit_srcu_struct(&pmus_srcu);\n\tperf_pmu_register(&perf_swevent, \"software\", PERF_TYPE_SOFTWARE);\n\tperf_pmu_register(&perf_cpu_clock, NULL, -1);\n\tperf_pmu_register(&perf_task_clock, NULL, -1);\n\tperf_tp_register();\n\tperf_event_init_cpu(smp_processor_id());\n\tregister_reboot_notifier(&perf_reboot_notifier);\n\n\tret = init_hw_breakpoint();\n\tWARN(ret, \"hw_breakpoint initialization failed with: %d\", ret);\n\n\t/*\n\t * Build time assertion that we keep the data_head at the intended\n\t * location.  IOW, validation we got the __reserved[] size right.\n\t */\n\tBUILD_BUG_ON((offsetof(struct perf_event_mmap_page, data_head))\n\t\t     != 1024);\n}\n\nssize_t perf_event_sysfs_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *page)\n{\n\tstruct perf_pmu_events_attr *pmu_attr =\n\t\tcontainer_of(attr, struct perf_pmu_events_attr, attr);\n\n\tif (pmu_attr->event_str)\n\t\treturn sprintf(page, \"%s\\n\", pmu_attr->event_str);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(perf_event_sysfs_show);\n\nstatic int __init perf_event_sysfs_init(void)\n{\n\tstruct pmu *pmu;\n\tint ret;\n\n\tmutex_lock(&pmus_lock);\n\n\tret = bus_register(&pmu_bus);\n\tif (ret)\n\t\tgoto unlock;\n\n\tlist_for_each_entry(pmu, &pmus, entry) {\n\t\tif (!pmu->name || pmu->type < 0)\n\t\t\tcontinue;\n\n\t\tret = pmu_dev_alloc(pmu);\n\t\tWARN(ret, \"Failed to register pmu: %s, reason %d\\n\", pmu->name, ret);\n\t}\n\tpmu_bus_running = 1;\n\tret = 0;\n\nunlock:\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n}\ndevice_initcall(perf_event_sysfs_init);\n\n#ifdef CONFIG_CGROUP_PERF\nstatic struct cgroup_subsys_state *\nperf_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct perf_cgroup *jc;\n\n\tjc = kzalloc(sizeof(*jc), GFP_KERNEL);\n\tif (!jc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tjc->info = alloc_percpu(struct perf_cgroup_info);\n\tif (!jc->info) {\n\t\tkfree(jc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn &jc->css;\n}\n\nstatic void perf_cgroup_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct perf_cgroup *jc = container_of(css, struct perf_cgroup, css);\n\n\tfree_percpu(jc->info);\n\tkfree(jc);\n}\n\nstatic int __perf_cgroup_move(void *info)\n{\n\tstruct task_struct *task = info;\n\trcu_read_lock();\n\tperf_cgroup_switch(task, PERF_CGROUP_SWOUT | PERF_CGROUP_SWIN);\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic void perf_cgroup_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *css;\n\n\tcgroup_taskset_for_each(task, css, tset)\n\t\ttask_function_call(task, __perf_cgroup_move, task);\n}\n\nstruct cgroup_subsys perf_event_cgrp_subsys = {\n\t.css_alloc\t= perf_cgroup_css_alloc,\n\t.css_free\t= perf_cgroup_css_free,\n\t.attach\t\t= perf_cgroup_attach,\n};\n#endif /* CONFIG_CGROUP_PERF */\n"], "fixing_code": ["/*\n * Performance events core code:\n *\n *  Copyright (C) 2008 Thomas Gleixner <tglx@linutronix.de>\n *  Copyright (C) 2008-2011 Red Hat, Inc., Ingo Molnar\n *  Copyright (C) 2008-2011 Red Hat, Inc., Peter Zijlstra\n *  Copyright  \u00a9  2009 Paul Mackerras, IBM Corp. <paulus@au1.ibm.com>\n *\n * For licensing details see kernel-base/COPYING\n */\n\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/idr.h>\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <linux/tick.h>\n#include <linux/sysfs.h>\n#include <linux/dcache.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/reboot.h>\n#include <linux/vmstat.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/hardirq.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/kernel_stat.h>\n#include <linux/cgroup.h>\n#include <linux/perf_event.h>\n#include <linux/trace_events.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/mm_types.h>\n#include <linux/module.h>\n#include <linux/mman.h>\n#include <linux/compat.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n\n#include \"internal.h\"\n\n#include <asm/irq_regs.h>\n\ntypedef int (*remote_function_f)(void *);\n\nstruct remote_function_call {\n\tstruct task_struct\t*p;\n\tremote_function_f\tfunc;\n\tvoid\t\t\t*info;\n\tint\t\t\tret;\n};\n\nstatic void remote_function(void *data)\n{\n\tstruct remote_function_call *tfc = data;\n\tstruct task_struct *p = tfc->p;\n\n\tif (p) {\n\t\t/* -EAGAIN */\n\t\tif (task_cpu(p) != smp_processor_id())\n\t\t\treturn;\n\n\t\t/*\n\t\t * Now that we're on right CPU with IRQs disabled, we can test\n\t\t * if we hit the right task without races.\n\t\t */\n\n\t\ttfc->ret = -ESRCH; /* No such (running) process */\n\t\tif (p != current)\n\t\t\treturn;\n\t}\n\n\ttfc->ret = tfc->func(tfc->info);\n}\n\n/**\n * task_function_call - call a function on the cpu on which a task runs\n * @p:\t\tthe task to evaluate\n * @func:\tthe function to be called\n * @info:\tthe function call argument\n *\n * Calls the function @func when the task is currently running. This might\n * be on the current CPU, which just calls the function directly\n *\n * returns: @func return value, or\n *\t    -ESRCH  - when the process isn't running\n *\t    -EAGAIN - when the process moved away\n */\nstatic int\ntask_function_call(struct task_struct *p, remote_function_f func, void *info)\n{\n\tstruct remote_function_call data = {\n\t\t.p\t= p,\n\t\t.func\t= func,\n\t\t.info\t= info,\n\t\t.ret\t= -EAGAIN,\n\t};\n\tint ret;\n\n\tdo {\n\t\tret = smp_call_function_single(task_cpu(p), remote_function, &data, 1);\n\t\tif (!ret)\n\t\t\tret = data.ret;\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}\n\n/**\n * cpu_function_call - call a function on the cpu\n * @func:\tthe function to be called\n * @info:\tthe function call argument\n *\n * Calls the function @func on the remote cpu.\n *\n * returns: @func return value or -ENXIO when the cpu is offline\n */\nstatic int cpu_function_call(int cpu, remote_function_f func, void *info)\n{\n\tstruct remote_function_call data = {\n\t\t.p\t= NULL,\n\t\t.func\t= func,\n\t\t.info\t= info,\n\t\t.ret\t= -ENXIO, /* No such CPU */\n\t};\n\n\tsmp_call_function_single(cpu, remote_function, &data, 1);\n\n\treturn data.ret;\n}\n\nstatic inline struct perf_cpu_context *\n__get_cpu_context(struct perf_event_context *ctx)\n{\n\treturn this_cpu_ptr(ctx->pmu->pmu_cpu_context);\n}\n\nstatic void perf_ctx_lock(struct perf_cpu_context *cpuctx,\n\t\t\t  struct perf_event_context *ctx)\n{\n\traw_spin_lock(&cpuctx->ctx.lock);\n\tif (ctx)\n\t\traw_spin_lock(&ctx->lock);\n}\n\nstatic void perf_ctx_unlock(struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx)\n{\n\tif (ctx)\n\t\traw_spin_unlock(&ctx->lock);\n\traw_spin_unlock(&cpuctx->ctx.lock);\n}\n\n#define TASK_TOMBSTONE ((void *)-1L)\n\nstatic bool is_kernel_event(struct perf_event *event)\n{\n\treturn READ_ONCE(event->owner) == TASK_TOMBSTONE;\n}\n\n/*\n * On task ctx scheduling...\n *\n * When !ctx->nr_events a task context will not be scheduled. This means\n * we can disable the scheduler hooks (for performance) without leaving\n * pending task ctx state.\n *\n * This however results in two special cases:\n *\n *  - removing the last event from a task ctx; this is relatively straight\n *    forward and is done in __perf_remove_from_context.\n *\n *  - adding the first event to a task ctx; this is tricky because we cannot\n *    rely on ctx->is_active and therefore cannot use event_function_call().\n *    See perf_install_in_context().\n *\n * If ctx->nr_events, then ctx->is_active and cpuctx->task_ctx are set.\n */\n\ntypedef void (*event_f)(struct perf_event *, struct perf_cpu_context *,\n\t\t\tstruct perf_event_context *, void *);\n\nstruct event_function_struct {\n\tstruct perf_event *event;\n\tevent_f func;\n\tvoid *data;\n};\n\nstatic int event_function(void *info)\n{\n\tstruct event_function_struct *efs = info;\n\tstruct perf_event *event = efs->event;\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\tstruct perf_event_context *task_ctx = cpuctx->task_ctx;\n\tint ret = 0;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\n\tperf_ctx_lock(cpuctx, task_ctx);\n\t/*\n\t * Since we do the IPI call without holding ctx->lock things can have\n\t * changed, double check we hit the task we set out to hit.\n\t */\n\tif (ctx->task) {\n\t\tif (ctx->task != current) {\n\t\t\tret = -ESRCH;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t/*\n\t\t * We only use event_function_call() on established contexts,\n\t\t * and event_function() is only ever called when active (or\n\t\t * rather, we'll have bailed in task_function_call() or the\n\t\t * above ctx->task != current test), therefore we must have\n\t\t * ctx->is_active here.\n\t\t */\n\t\tWARN_ON_ONCE(!ctx->is_active);\n\t\t/*\n\t\t * And since we have ctx->is_active, cpuctx->task_ctx must\n\t\t * match.\n\t\t */\n\t\tWARN_ON_ONCE(task_ctx != ctx);\n\t} else {\n\t\tWARN_ON_ONCE(&cpuctx->ctx != ctx);\n\t}\n\n\tefs->func(event, cpuctx, ctx, efs->data);\nunlock:\n\tperf_ctx_unlock(cpuctx, task_ctx);\n\n\treturn ret;\n}\n\nstatic void event_function_call(struct perf_event *event, event_f func, void *data)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct task_struct *task = READ_ONCE(ctx->task); /* verified in event_function */\n\tstruct event_function_struct efs = {\n\t\t.event = event,\n\t\t.func = func,\n\t\t.data = data,\n\t};\n\n\tif (!event->parent) {\n\t\t/*\n\t\t * If this is a !child event, we must hold ctx::mutex to\n\t\t * stabilize the the event->ctx relation. See\n\t\t * perf_event_ctx_lock().\n\t\t */\n\t\tlockdep_assert_held(&ctx->mutex);\n\t}\n\n\tif (!task) {\n\t\tcpu_function_call(event->cpu, event_function, &efs);\n\t\treturn;\n\t}\n\n\tif (task == TASK_TOMBSTONE)\n\t\treturn;\n\nagain:\n\tif (!task_function_call(task, event_function, &efs))\n\t\treturn;\n\n\traw_spin_lock_irq(&ctx->lock);\n\t/*\n\t * Reload the task pointer, it might have been changed by\n\t * a concurrent perf_event_context_sched_out().\n\t */\n\ttask = ctx->task;\n\tif (task == TASK_TOMBSTONE) {\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\treturn;\n\t}\n\tif (ctx->is_active) {\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\tgoto again;\n\t}\n\tfunc(event, NULL, ctx, data);\n\traw_spin_unlock_irq(&ctx->lock);\n}\n\n/*\n * Similar to event_function_call() + event_function(), but hard assumes IRQs\n * are already disabled and we're on the right CPU.\n */\nstatic void event_function_local(struct perf_event *event, event_f func, void *data)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\tstruct task_struct *task = READ_ONCE(ctx->task);\n\tstruct perf_event_context *task_ctx = NULL;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\n\tif (task) {\n\t\tif (task == TASK_TOMBSTONE)\n\t\t\treturn;\n\n\t\ttask_ctx = ctx;\n\t}\n\n\tperf_ctx_lock(cpuctx, task_ctx);\n\n\ttask = ctx->task;\n\tif (task == TASK_TOMBSTONE)\n\t\tgoto unlock;\n\n\tif (task) {\n\t\t/*\n\t\t * We must be either inactive or active and the right task,\n\t\t * otherwise we're screwed, since we cannot IPI to somewhere\n\t\t * else.\n\t\t */\n\t\tif (ctx->is_active) {\n\t\t\tif (WARN_ON_ONCE(task != current))\n\t\t\t\tgoto unlock;\n\n\t\t\tif (WARN_ON_ONCE(cpuctx->task_ctx != ctx))\n\t\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tWARN_ON_ONCE(&cpuctx->ctx != ctx);\n\t}\n\n\tfunc(event, cpuctx, ctx, data);\nunlock:\n\tperf_ctx_unlock(cpuctx, task_ctx);\n}\n\n#define PERF_FLAG_ALL (PERF_FLAG_FD_NO_GROUP |\\\n\t\t       PERF_FLAG_FD_OUTPUT  |\\\n\t\t       PERF_FLAG_PID_CGROUP |\\\n\t\t       PERF_FLAG_FD_CLOEXEC)\n\n/*\n * branch priv levels that need permission checks\n */\n#define PERF_SAMPLE_BRANCH_PERM_PLM \\\n\t(PERF_SAMPLE_BRANCH_KERNEL |\\\n\t PERF_SAMPLE_BRANCH_HV)\n\nenum event_type_t {\n\tEVENT_FLEXIBLE = 0x1,\n\tEVENT_PINNED = 0x2,\n\tEVENT_TIME = 0x4,\n\tEVENT_ALL = EVENT_FLEXIBLE | EVENT_PINNED,\n};\n\n/*\n * perf_sched_events : >0 events exist\n * perf_cgroup_events: >0 per-cpu cgroup events exist on this cpu\n */\n\nstatic void perf_sched_delayed(struct work_struct *work);\nDEFINE_STATIC_KEY_FALSE(perf_sched_events);\nstatic DECLARE_DELAYED_WORK(perf_sched_work, perf_sched_delayed);\nstatic DEFINE_MUTEX(perf_sched_mutex);\nstatic atomic_t perf_sched_count;\n\nstatic DEFINE_PER_CPU(atomic_t, perf_cgroup_events);\nstatic DEFINE_PER_CPU(int, perf_sched_cb_usages);\nstatic DEFINE_PER_CPU(struct pmu_event_list, pmu_sb_events);\n\nstatic atomic_t nr_mmap_events __read_mostly;\nstatic atomic_t nr_comm_events __read_mostly;\nstatic atomic_t nr_task_events __read_mostly;\nstatic atomic_t nr_freq_events __read_mostly;\nstatic atomic_t nr_switch_events __read_mostly;\n\nstatic LIST_HEAD(pmus);\nstatic DEFINE_MUTEX(pmus_lock);\nstatic struct srcu_struct pmus_srcu;\n\n/*\n * perf event paranoia level:\n *  -1 - not paranoid at all\n *   0 - disallow raw tracepoint access for unpriv\n *   1 - disallow cpu events for unpriv\n *   2 - disallow kernel profiling for unpriv\n */\nint sysctl_perf_event_paranoid __read_mostly = 2;\n\n/* Minimum for 512 kiB + 1 user control page */\nint sysctl_perf_event_mlock __read_mostly = 512 + (PAGE_SIZE / 1024); /* 'free' kiB per user */\n\n/*\n * max perf event sample rate\n */\n#define DEFAULT_MAX_SAMPLE_RATE\t\t100000\n#define DEFAULT_SAMPLE_PERIOD_NS\t(NSEC_PER_SEC / DEFAULT_MAX_SAMPLE_RATE)\n#define DEFAULT_CPU_TIME_MAX_PERCENT\t25\n\nint sysctl_perf_event_sample_rate __read_mostly\t= DEFAULT_MAX_SAMPLE_RATE;\n\nstatic int max_samples_per_tick __read_mostly\t= DIV_ROUND_UP(DEFAULT_MAX_SAMPLE_RATE, HZ);\nstatic int perf_sample_period_ns __read_mostly\t= DEFAULT_SAMPLE_PERIOD_NS;\n\nstatic int perf_sample_allowed_ns __read_mostly =\n\tDEFAULT_SAMPLE_PERIOD_NS * DEFAULT_CPU_TIME_MAX_PERCENT / 100;\n\nstatic void update_perf_cpu_limits(void)\n{\n\tu64 tmp = perf_sample_period_ns;\n\n\ttmp *= sysctl_perf_cpu_time_max_percent;\n\ttmp = div_u64(tmp, 100);\n\tif (!tmp)\n\t\ttmp = 1;\n\n\tWRITE_ONCE(perf_sample_allowed_ns, tmp);\n}\n\nstatic int perf_rotate_context(struct perf_cpu_context *cpuctx);\n\nint perf_proc_update_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *lenp,\n\t\tloff_t *ppos)\n{\n\tint ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write)\n\t\treturn ret;\n\n\t/*\n\t * If throttling is disabled don't allow the write:\n\t */\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0)\n\t\treturn -EINVAL;\n\n\tmax_samples_per_tick = DIV_ROUND_UP(sysctl_perf_event_sample_rate, HZ);\n\tperf_sample_period_ns = NSEC_PER_SEC / sysctl_perf_event_sample_rate;\n\tupdate_perf_cpu_limits();\n\n\treturn 0;\n}\n\nint sysctl_perf_cpu_time_max_percent __read_mostly = DEFAULT_CPU_TIME_MAX_PERCENT;\n\nint perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp,\n\t\t\t\tloff_t *ppos)\n{\n\tint ret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write)\n\t\treturn ret;\n\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\n\treturn 0;\n}\n\n/*\n * perf samples are done in some very critical code paths (NMIs).\n * If they take too much CPU time, the system can lock up and not\n * get any real work done.  This will drop the sample rate when\n * we detect that events are taking too long.\n */\n#define NR_ACCUMULATED_SAMPLES 128\nstatic DEFINE_PER_CPU(u64, running_sample_length);\n\nstatic u64 __report_avg;\nstatic u64 __report_allowed;\n\nstatic void perf_duration_warn(struct irq_work *w)\n{\n\tprintk_ratelimited(KERN_INFO\n\t\t\"perf: interrupt took too long (%lld > %lld), lowering \"\n\t\t\"kernel.perf_event_max_sample_rate to %d\\n\",\n\t\t__report_avg, __report_allowed,\n\t\tsysctl_perf_event_sample_rate);\n}\n\nstatic DEFINE_IRQ_WORK(perf_duration_work, perf_duration_warn);\n\nvoid perf_sample_event_took(u64 sample_len_ns)\n{\n\tu64 max_len = READ_ONCE(perf_sample_allowed_ns);\n\tu64 running_len;\n\tu64 avg_len;\n\tu32 max;\n\n\tif (max_len == 0)\n\t\treturn;\n\n\t/* Decay the counter by 1 average sample. */\n\trunning_len = __this_cpu_read(running_sample_length);\n\trunning_len -= running_len/NR_ACCUMULATED_SAMPLES;\n\trunning_len += sample_len_ns;\n\t__this_cpu_write(running_sample_length, running_len);\n\n\t/*\n\t * Note: this will be biased artifically low until we have\n\t * seen NR_ACCUMULATED_SAMPLES. Doing it this way keeps us\n\t * from having to maintain a count.\n\t */\n\tavg_len = running_len/NR_ACCUMULATED_SAMPLES;\n\tif (avg_len <= max_len)\n\t\treturn;\n\n\t__report_avg = avg_len;\n\t__report_allowed = max_len;\n\n\t/*\n\t * Compute a throttle threshold 25% below the current duration.\n\t */\n\tavg_len += avg_len / 4;\n\tmax = (TICK_NSEC / 100) * sysctl_perf_cpu_time_max_percent;\n\tif (avg_len < max)\n\t\tmax /= (u32)avg_len;\n\telse\n\t\tmax = 1;\n\n\tWRITE_ONCE(perf_sample_allowed_ns, avg_len);\n\tWRITE_ONCE(max_samples_per_tick, max);\n\n\tsysctl_perf_event_sample_rate = max * HZ;\n\tperf_sample_period_ns = NSEC_PER_SEC / sysctl_perf_event_sample_rate;\n\n\tif (!irq_work_queue(&perf_duration_work)) {\n\t\tearly_printk(\"perf: interrupt took too long (%lld > %lld), lowering \"\n\t\t\t     \"kernel.perf_event_max_sample_rate to %d\\n\",\n\t\t\t     __report_avg, __report_allowed,\n\t\t\t     sysctl_perf_event_sample_rate);\n\t}\n}\n\nstatic atomic64_t perf_event_id;\n\nstatic void cpu_ctx_sched_out(struct perf_cpu_context *cpuctx,\n\t\t\t      enum event_type_t event_type);\n\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\n\nvoid __weak perf_event_print_debug(void)\t{ }\n\nextern __weak const char *perf_pmu_name(void)\n{\n\treturn \"pmu\";\n}\n\nstatic inline u64 perf_clock(void)\n{\n\treturn local_clock();\n}\n\nstatic inline u64 perf_event_clock(struct perf_event *event)\n{\n\treturn event->clock();\n}\n\n#ifdef CONFIG_CGROUP_PERF\n\nstatic inline bool\nperf_cgroup_match(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\n\t/* @event doesn't care about cgroup */\n\tif (!event->cgrp)\n\t\treturn true;\n\n\t/* wants specific cgroup scope but @cpuctx isn't associated with any */\n\tif (!cpuctx->cgrp)\n\t\treturn false;\n\n\t/*\n\t * Cgroup scoping is recursive.  An event enabled for a cgroup is\n\t * also enabled for all its descendant cgroups.  If @cpuctx's\n\t * cgroup is a descendant of @event's (the test covers identity\n\t * case), it's a match.\n\t */\n\treturn cgroup_is_descendant(cpuctx->cgrp->css.cgroup,\n\t\t\t\t    event->cgrp->css.cgroup);\n}\n\nstatic inline void perf_detach_cgroup(struct perf_event *event)\n{\n\tcss_put(&event->cgrp->css);\n\tevent->cgrp = NULL;\n}\n\nstatic inline int is_cgroup_event(struct perf_event *event)\n{\n\treturn event->cgrp != NULL;\n}\n\nstatic inline u64 perf_cgroup_event_time(struct perf_event *event)\n{\n\tstruct perf_cgroup_info *t;\n\n\tt = per_cpu_ptr(event->cgrp->info, event->cpu);\n\treturn t->time;\n}\n\nstatic inline void __update_cgrp_time(struct perf_cgroup *cgrp)\n{\n\tstruct perf_cgroup_info *info;\n\tu64 now;\n\n\tnow = perf_clock();\n\n\tinfo = this_cpu_ptr(cgrp->info);\n\n\tinfo->time += now - info->timestamp;\n\tinfo->timestamp = now;\n}\n\nstatic inline void update_cgrp_time_from_cpuctx(struct perf_cpu_context *cpuctx)\n{\n\tstruct perf_cgroup *cgrp_out = cpuctx->cgrp;\n\tif (cgrp_out)\n\t\t__update_cgrp_time(cgrp_out);\n}\n\nstatic inline void update_cgrp_time_from_event(struct perf_event *event)\n{\n\tstruct perf_cgroup *cgrp;\n\n\t/*\n\t * ensure we access cgroup data only when needed and\n\t * when we know the cgroup is pinned (css_get)\n\t */\n\tif (!is_cgroup_event(event))\n\t\treturn;\n\n\tcgrp = perf_cgroup_from_task(current, event->ctx);\n\t/*\n\t * Do not update time when cgroup is not active\n\t */\n\tif (cgrp == event->cgrp)\n\t\t__update_cgrp_time(event->cgrp);\n}\n\nstatic inline void\nperf_cgroup_set_timestamp(struct task_struct *task,\n\t\t\t  struct perf_event_context *ctx)\n{\n\tstruct perf_cgroup *cgrp;\n\tstruct perf_cgroup_info *info;\n\n\t/*\n\t * ctx->lock held by caller\n\t * ensure we do not access cgroup data\n\t * unless we have the cgroup pinned (css_get)\n\t */\n\tif (!task || !ctx->nr_cgroups)\n\t\treturn;\n\n\tcgrp = perf_cgroup_from_task(task, ctx);\n\tinfo = this_cpu_ptr(cgrp->info);\n\tinfo->timestamp = ctx->timestamp;\n}\n\n#define PERF_CGROUP_SWOUT\t0x1 /* cgroup switch out every event */\n#define PERF_CGROUP_SWIN\t0x2 /* cgroup switch in events based on task */\n\n/*\n * reschedule events based on the cgroup constraint of task.\n *\n * mode SWOUT : schedule out everything\n * mode SWIN : schedule in based on cgroup for next\n */\nstatic void perf_cgroup_switch(struct task_struct *task, int mode)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct pmu *pmu;\n\tunsigned long flags;\n\n\t/*\n\t * disable interrupts to avoid geting nr_cgroup\n\t * changes via __perf_event_disable(). Also\n\t * avoids preemption.\n\t */\n\tlocal_irq_save(flags);\n\n\t/*\n\t * we reschedule only in the presence of cgroup\n\t * constrained events.\n\t */\n\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = this_cpu_ptr(pmu->pmu_cpu_context);\n\t\tif (cpuctx->unique_pmu != pmu)\n\t\t\tcontinue; /* ensure we process each cpuctx once */\n\n\t\t/*\n\t\t * perf_cgroup_events says at least one\n\t\t * context on this CPU has cgroup events.\n\t\t *\n\t\t * ctx->nr_cgroups reports the number of cgroup\n\t\t * events for a context.\n\t\t */\n\t\tif (cpuctx->ctx.nr_cgroups > 0) {\n\t\t\tperf_ctx_lock(cpuctx, cpuctx->task_ctx);\n\t\t\tperf_pmu_disable(cpuctx->ctx.pmu);\n\n\t\t\tif (mode & PERF_CGROUP_SWOUT) {\n\t\t\t\tcpu_ctx_sched_out(cpuctx, EVENT_ALL);\n\t\t\t\t/*\n\t\t\t\t * must not be done before ctxswout due\n\t\t\t\t * to event_filter_match() in event_sched_out()\n\t\t\t\t */\n\t\t\t\tcpuctx->cgrp = NULL;\n\t\t\t}\n\n\t\t\tif (mode & PERF_CGROUP_SWIN) {\n\t\t\t\tWARN_ON_ONCE(cpuctx->cgrp);\n\t\t\t\t/*\n\t\t\t\t * set cgrp before ctxsw in to allow\n\t\t\t\t * event_filter_match() to not have to pass\n\t\t\t\t * task around\n\t\t\t\t * we pass the cpuctx->ctx to perf_cgroup_from_task()\n\t\t\t\t * because cgorup events are only per-cpu\n\t\t\t\t */\n\t\t\t\tcpuctx->cgrp = perf_cgroup_from_task(task, &cpuctx->ctx);\n\t\t\t\tcpu_ctx_sched_in(cpuctx, EVENT_ALL, task);\n\t\t\t}\n\t\t\tperf_pmu_enable(cpuctx->ctx.pmu);\n\t\t\tperf_ctx_unlock(cpuctx, cpuctx->task_ctx);\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}\n\nstatic inline void perf_cgroup_sched_out(struct task_struct *task,\n\t\t\t\t\t struct task_struct *next)\n{\n\tstruct perf_cgroup *cgrp1;\n\tstruct perf_cgroup *cgrp2 = NULL;\n\n\trcu_read_lock();\n\t/*\n\t * we come here when we know perf_cgroup_events > 0\n\t * we do not need to pass the ctx here because we know\n\t * we are holding the rcu lock\n\t */\n\tcgrp1 = perf_cgroup_from_task(task, NULL);\n\tcgrp2 = perf_cgroup_from_task(next, NULL);\n\n\t/*\n\t * only schedule out current cgroup events if we know\n\t * that we are switching to a different cgroup. Otherwise,\n\t * do no touch the cgroup events.\n\t */\n\tif (cgrp1 != cgrp2)\n\t\tperf_cgroup_switch(task, PERF_CGROUP_SWOUT);\n\n\trcu_read_unlock();\n}\n\nstatic inline void perf_cgroup_sched_in(struct task_struct *prev,\n\t\t\t\t\tstruct task_struct *task)\n{\n\tstruct perf_cgroup *cgrp1;\n\tstruct perf_cgroup *cgrp2 = NULL;\n\n\trcu_read_lock();\n\t/*\n\t * we come here when we know perf_cgroup_events > 0\n\t * we do not need to pass the ctx here because we know\n\t * we are holding the rcu lock\n\t */\n\tcgrp1 = perf_cgroup_from_task(task, NULL);\n\tcgrp2 = perf_cgroup_from_task(prev, NULL);\n\n\t/*\n\t * only need to schedule in cgroup events if we are changing\n\t * cgroup during ctxsw. Cgroup events were not scheduled\n\t * out of ctxsw out if that was not the case.\n\t */\n\tif (cgrp1 != cgrp2)\n\t\tperf_cgroup_switch(task, PERF_CGROUP_SWIN);\n\n\trcu_read_unlock();\n}\n\nstatic inline int perf_cgroup_connect(int fd, struct perf_event *event,\n\t\t\t\t      struct perf_event_attr *attr,\n\t\t\t\t      struct perf_event *group_leader)\n{\n\tstruct perf_cgroup *cgrp;\n\tstruct cgroup_subsys_state *css;\n\tstruct fd f = fdget(fd);\n\tint ret = 0;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tcss = css_tryget_online_from_dir(f.file->f_path.dentry,\n\t\t\t\t\t &perf_event_cgrp_subsys);\n\tif (IS_ERR(css)) {\n\t\tret = PTR_ERR(css);\n\t\tgoto out;\n\t}\n\n\tcgrp = container_of(css, struct perf_cgroup, css);\n\tevent->cgrp = cgrp;\n\n\t/*\n\t * all events in a group must monitor\n\t * the same cgroup because a task belongs\n\t * to only one perf cgroup at a time\n\t */\n\tif (group_leader && group_leader->cgrp != cgrp) {\n\t\tperf_detach_cgroup(event);\n\t\tret = -EINVAL;\n\t}\nout:\n\tfdput(f);\n\treturn ret;\n}\n\nstatic inline void\nperf_cgroup_set_shadow_time(struct perf_event *event, u64 now)\n{\n\tstruct perf_cgroup_info *t;\n\tt = per_cpu_ptr(event->cgrp->info, event->cpu);\n\tevent->shadow_ctx_time = now - t->timestamp;\n}\n\nstatic inline void\nperf_cgroup_defer_enabled(struct perf_event *event)\n{\n\t/*\n\t * when the current task's perf cgroup does not match\n\t * the event's, we need to remember to call the\n\t * perf_mark_enable() function the first time a task with\n\t * a matching perf cgroup is scheduled in.\n\t */\n\tif (is_cgroup_event(event) && !perf_cgroup_match(event))\n\t\tevent->cgrp_defer_enabled = 1;\n}\n\nstatic inline void\nperf_cgroup_mark_enabled(struct perf_event *event,\n\t\t\t struct perf_event_context *ctx)\n{\n\tstruct perf_event *sub;\n\tu64 tstamp = perf_event_time(event);\n\n\tif (!event->cgrp_defer_enabled)\n\t\treturn;\n\n\tevent->cgrp_defer_enabled = 0;\n\n\tevent->tstamp_enabled = tstamp - event->total_time_enabled;\n\tlist_for_each_entry(sub, &event->sibling_list, group_entry) {\n\t\tif (sub->state >= PERF_EVENT_STATE_INACTIVE) {\n\t\t\tsub->tstamp_enabled = tstamp - sub->total_time_enabled;\n\t\t\tsub->cgrp_defer_enabled = 0;\n\t\t}\n\t}\n}\n\n/*\n * Update cpuctx->cgrp so that it is set when first cgroup event is added and\n * cleared when last cgroup event is removed.\n */\nstatic inline void\nlist_update_cgroup_event(struct perf_event *event,\n\t\t\t struct perf_event_context *ctx, bool add)\n{\n\tstruct perf_cpu_context *cpuctx;\n\n\tif (!is_cgroup_event(event))\n\t\treturn;\n\n\tif (add && ctx->nr_cgroups++)\n\t\treturn;\n\telse if (!add && --ctx->nr_cgroups)\n\t\treturn;\n\t/*\n\t * Because cgroup events are always per-cpu events,\n\t * this will always be called from the right CPU.\n\t */\n\tcpuctx = __get_cpu_context(ctx);\n\n\t/*\n\t * cpuctx->cgrp is NULL until a cgroup event is sched in or\n\t * ctx->nr_cgroup == 0 .\n\t */\n\tif (add && perf_cgroup_from_task(current, ctx) == event->cgrp)\n\t\tcpuctx->cgrp = event->cgrp;\n\telse if (!add)\n\t\tcpuctx->cgrp = NULL;\n}\n\n#else /* !CONFIG_CGROUP_PERF */\n\nstatic inline bool\nperf_cgroup_match(struct perf_event *event)\n{\n\treturn true;\n}\n\nstatic inline void perf_detach_cgroup(struct perf_event *event)\n{}\n\nstatic inline int is_cgroup_event(struct perf_event *event)\n{\n\treturn 0;\n}\n\nstatic inline u64 perf_cgroup_event_cgrp_time(struct perf_event *event)\n{\n\treturn 0;\n}\n\nstatic inline void update_cgrp_time_from_event(struct perf_event *event)\n{\n}\n\nstatic inline void update_cgrp_time_from_cpuctx(struct perf_cpu_context *cpuctx)\n{\n}\n\nstatic inline void perf_cgroup_sched_out(struct task_struct *task,\n\t\t\t\t\t struct task_struct *next)\n{\n}\n\nstatic inline void perf_cgroup_sched_in(struct task_struct *prev,\n\t\t\t\t\tstruct task_struct *task)\n{\n}\n\nstatic inline int perf_cgroup_connect(pid_t pid, struct perf_event *event,\n\t\t\t\t      struct perf_event_attr *attr,\n\t\t\t\t      struct perf_event *group_leader)\n{\n\treturn -EINVAL;\n}\n\nstatic inline void\nperf_cgroup_set_timestamp(struct task_struct *task,\n\t\t\t  struct perf_event_context *ctx)\n{\n}\n\nvoid\nperf_cgroup_switch(struct task_struct *task, struct task_struct *next)\n{\n}\n\nstatic inline void\nperf_cgroup_set_shadow_time(struct perf_event *event, u64 now)\n{\n}\n\nstatic inline u64 perf_cgroup_event_time(struct perf_event *event)\n{\n\treturn 0;\n}\n\nstatic inline void\nperf_cgroup_defer_enabled(struct perf_event *event)\n{\n}\n\nstatic inline void\nperf_cgroup_mark_enabled(struct perf_event *event,\n\t\t\t struct perf_event_context *ctx)\n{\n}\n\nstatic inline void\nlist_update_cgroup_event(struct perf_event *event,\n\t\t\t struct perf_event_context *ctx, bool add)\n{\n}\n\n#endif\n\n/*\n * set default to be dependent on timer tick just\n * like original code\n */\n#define PERF_CPU_HRTIMER (1000 / HZ)\n/*\n * function must be called with interrupts disbled\n */\nstatic enum hrtimer_restart perf_mux_hrtimer_handler(struct hrtimer *hr)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tint rotations = 0;\n\n\tWARN_ON(!irqs_disabled());\n\n\tcpuctx = container_of(hr, struct perf_cpu_context, hrtimer);\n\trotations = perf_rotate_context(cpuctx);\n\n\traw_spin_lock(&cpuctx->hrtimer_lock);\n\tif (rotations)\n\t\thrtimer_forward_now(hr, cpuctx->hrtimer_interval);\n\telse\n\t\tcpuctx->hrtimer_active = 0;\n\traw_spin_unlock(&cpuctx->hrtimer_lock);\n\n\treturn rotations ? HRTIMER_RESTART : HRTIMER_NORESTART;\n}\n\nstatic void __perf_mux_hrtimer_init(struct perf_cpu_context *cpuctx, int cpu)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tu64 interval;\n\n\t/* no multiplexing needed for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn;\n\n\t/*\n\t * check default is sane, if not set then force to\n\t * default interval (1/tick)\n\t */\n\tinterval = pmu->hrtimer_interval_ms;\n\tif (interval < 1)\n\t\tinterval = pmu->hrtimer_interval_ms = PERF_CPU_HRTIMER;\n\n\tcpuctx->hrtimer_interval = ns_to_ktime(NSEC_PER_MSEC * interval);\n\n\traw_spin_lock_init(&cpuctx->hrtimer_lock);\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);\n\ttimer->function = perf_mux_hrtimer_handler;\n}\n\nstatic int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tunsigned long flags;\n\n\t/* not for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&cpuctx->hrtimer_lock, flags);\n\tif (!cpuctx->hrtimer_active) {\n\t\tcpuctx->hrtimer_active = 1;\n\t\thrtimer_forward_now(timer, cpuctx->hrtimer_interval);\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n\t}\n\traw_spin_unlock_irqrestore(&cpuctx->hrtimer_lock, flags);\n\n\treturn 0;\n}\n\nvoid perf_pmu_disable(struct pmu *pmu)\n{\n\tint *count = this_cpu_ptr(pmu->pmu_disable_count);\n\tif (!(*count)++)\n\t\tpmu->pmu_disable(pmu);\n}\n\nvoid perf_pmu_enable(struct pmu *pmu)\n{\n\tint *count = this_cpu_ptr(pmu->pmu_disable_count);\n\tif (!--(*count))\n\t\tpmu->pmu_enable(pmu);\n}\n\nstatic DEFINE_PER_CPU(struct list_head, active_ctx_list);\n\n/*\n * perf_event_ctx_activate(), perf_event_ctx_deactivate(), and\n * perf_event_task_tick() are fully serialized because they're strictly cpu\n * affine and perf_event_ctx{activate,deactivate} are called with IRQs\n * disabled, while perf_event_task_tick is called from IRQ context.\n */\nstatic void perf_event_ctx_activate(struct perf_event_context *ctx)\n{\n\tstruct list_head *head = this_cpu_ptr(&active_ctx_list);\n\n\tWARN_ON(!irqs_disabled());\n\n\tWARN_ON(!list_empty(&ctx->active_ctx_list));\n\n\tlist_add(&ctx->active_ctx_list, head);\n}\n\nstatic void perf_event_ctx_deactivate(struct perf_event_context *ctx)\n{\n\tWARN_ON(!irqs_disabled());\n\n\tWARN_ON(list_empty(&ctx->active_ctx_list));\n\n\tlist_del_init(&ctx->active_ctx_list);\n}\n\nstatic void get_ctx(struct perf_event_context *ctx)\n{\n\tWARN_ON(!atomic_inc_not_zero(&ctx->refcount));\n}\n\nstatic void free_ctx(struct rcu_head *head)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = container_of(head, struct perf_event_context, rcu_head);\n\tkfree(ctx->task_ctx_data);\n\tkfree(ctx);\n}\n\nstatic void put_ctx(struct perf_event_context *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tif (ctx->parent_ctx)\n\t\t\tput_ctx(ctx->parent_ctx);\n\t\tif (ctx->task && ctx->task != TASK_TOMBSTONE)\n\t\t\tput_task_struct(ctx->task);\n\t\tcall_rcu(&ctx->rcu_head, free_ctx);\n\t}\n}\n\n/*\n * Because of perf_event::ctx migration in sys_perf_event_open::move_group and\n * perf_pmu_migrate_context() we need some magic.\n *\n * Those places that change perf_event::ctx will hold both\n * perf_event_ctx::mutex of the 'old' and 'new' ctx value.\n *\n * Lock ordering is by mutex address. There are two other sites where\n * perf_event_context::mutex nests and those are:\n *\n *  - perf_event_exit_task_context()\t[ child , 0 ]\n *      perf_event_exit_event()\n *        put_event()\t\t\t[ parent, 1 ]\n *\n *  - perf_event_init_context()\t\t[ parent, 0 ]\n *      inherit_task_group()\n *        inherit_group()\n *          inherit_event()\n *            perf_event_alloc()\n *              perf_init_event()\n *                perf_try_init_event()\t[ child , 1 ]\n *\n * While it appears there is an obvious deadlock here -- the parent and child\n * nesting levels are inverted between the two. This is in fact safe because\n * life-time rules separate them. That is an exiting task cannot fork, and a\n * spawning task cannot (yet) exit.\n *\n * But remember that that these are parent<->child context relations, and\n * migration does not affect children, therefore these two orderings should not\n * interact.\n *\n * The change in perf_event::ctx does not affect children (as claimed above)\n * because the sys_perf_event_open() case will install a new event and break\n * the ctx parent<->child relation, and perf_pmu_migrate_context() is only\n * concerned with cpuctx and that doesn't have children.\n *\n * The places that change perf_event::ctx will issue:\n *\n *   perf_remove_from_context();\n *   synchronize_rcu();\n *   perf_install_in_context();\n *\n * to affect the change. The remove_from_context() + synchronize_rcu() should\n * quiesce the event, after which we can install it in the new location. This\n * means that only external vectors (perf_fops, prctl) can perturb the event\n * while in transit. Therefore all such accessors should also acquire\n * perf_event_context::mutex to serialize against this.\n *\n * However; because event->ctx can change while we're waiting to acquire\n * ctx->mutex we must be careful and use the below perf_event_ctx_lock()\n * function.\n *\n * Lock order:\n *    cred_guard_mutex\n *\ttask_struct::perf_event_mutex\n *\t  perf_event_context::mutex\n *\t    perf_event::child_mutex;\n *\t      perf_event_context::lock\n *\t    perf_event::mmap_mutex\n *\t    mmap_sem\n */\nstatic struct perf_event_context *\nperf_event_ctx_lock_nested(struct perf_event *event, int nesting)\n{\n\tstruct perf_event_context *ctx;\n\nagain:\n\trcu_read_lock();\n\tctx = ACCESS_ONCE(event->ctx);\n\tif (!atomic_inc_not_zero(&ctx->refcount)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\n\tmutex_lock_nested(&ctx->mutex, nesting);\n\tif (event->ctx != ctx) {\n\t\tmutex_unlock(&ctx->mutex);\n\t\tput_ctx(ctx);\n\t\tgoto again;\n\t}\n\n\treturn ctx;\n}\n\nstatic inline struct perf_event_context *\nperf_event_ctx_lock(struct perf_event *event)\n{\n\treturn perf_event_ctx_lock_nested(event, 0);\n}\n\nstatic void perf_event_ctx_unlock(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx)\n{\n\tmutex_unlock(&ctx->mutex);\n\tput_ctx(ctx);\n}\n\n/*\n * This must be done under the ctx->lock, such as to serialize against\n * context_equiv(), therefore we cannot call put_ctx() since that might end up\n * calling scheduler related locks and ctx->lock nests inside those.\n */\nstatic __must_check struct perf_event_context *\nunclone_ctx(struct perf_event_context *ctx)\n{\n\tstruct perf_event_context *parent_ctx = ctx->parent_ctx;\n\n\tlockdep_assert_held(&ctx->lock);\n\n\tif (parent_ctx)\n\t\tctx->parent_ctx = NULL;\n\tctx->generation++;\n\n\treturn parent_ctx;\n}\n\nstatic u32 perf_event_pid(struct perf_event *event, struct task_struct *p)\n{\n\t/*\n\t * only top level events have the pid namespace they were created in\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\treturn task_tgid_nr_ns(p, event->ns);\n}\n\nstatic u32 perf_event_tid(struct perf_event *event, struct task_struct *p)\n{\n\t/*\n\t * only top level events have the pid namespace they were created in\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\treturn task_pid_nr_ns(p, event->ns);\n}\n\n/*\n * If we inherit events we want to return the parent event id\n * to userspace.\n */\nstatic u64 primary_event_id(struct perf_event *event)\n{\n\tu64 id = event->id;\n\n\tif (event->parent)\n\t\tid = event->parent->id;\n\n\treturn id;\n}\n\n/*\n * Get the perf_event_context for a task and lock it.\n *\n * This has to cope with with the fact that until it is locked,\n * the context could get moved to another task.\n */\nstatic struct perf_event_context *\nperf_lock_task_context(struct task_struct *task, int ctxn, unsigned long *flags)\n{\n\tstruct perf_event_context *ctx;\n\nretry:\n\t/*\n\t * One of the few rules of preemptible RCU is that one cannot do\n\t * rcu_read_unlock() while holding a scheduler (or nested) lock when\n\t * part of the read side critical section was irqs-enabled -- see\n\t * rcu_read_unlock_special().\n\t *\n\t * Since ctx->lock nests under rq->lock we must ensure the entire read\n\t * side critical section has interrupts disabled.\n\t */\n\tlocal_irq_save(*flags);\n\trcu_read_lock();\n\tctx = rcu_dereference(task->perf_event_ctxp[ctxn]);\n\tif (ctx) {\n\t\t/*\n\t\t * If this context is a clone of another, it might\n\t\t * get swapped for another underneath us by\n\t\t * perf_event_task_sched_out, though the\n\t\t * rcu_read_lock() protects us from any context\n\t\t * getting freed.  Lock the context and check if it\n\t\t * got swapped before we could get the lock, and retry\n\t\t * if so.  If we locked the right context, then it\n\t\t * can't get swapped on us any more.\n\t\t */\n\t\traw_spin_lock(&ctx->lock);\n\t\tif (ctx != rcu_dereference(task->perf_event_ctxp[ctxn])) {\n\t\t\traw_spin_unlock(&ctx->lock);\n\t\t\trcu_read_unlock();\n\t\t\tlocal_irq_restore(*flags);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (ctx->task == TASK_TOMBSTONE ||\n\t\t    !atomic_inc_not_zero(&ctx->refcount)) {\n\t\t\traw_spin_unlock(&ctx->lock);\n\t\t\tctx = NULL;\n\t\t} else {\n\t\t\tWARN_ON_ONCE(ctx->task != task);\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (!ctx)\n\t\tlocal_irq_restore(*flags);\n\treturn ctx;\n}\n\n/*\n * Get the context for a task and increment its pin_count so it\n * can't get swapped to another task.  This also increments its\n * reference count so that the context can't get freed.\n */\nstatic struct perf_event_context *\nperf_pin_task_context(struct task_struct *task, int ctxn)\n{\n\tstruct perf_event_context *ctx;\n\tunsigned long flags;\n\n\tctx = perf_lock_task_context(task, ctxn, &flags);\n\tif (ctx) {\n\t\t++ctx->pin_count;\n\t\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n\t}\n\treturn ctx;\n}\n\nstatic void perf_unpin_context(struct perf_event_context *ctx)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ctx->lock, flags);\n\t--ctx->pin_count;\n\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n}\n\n/*\n * Update the record of the current time in a context.\n */\nstatic void update_context_time(struct perf_event_context *ctx)\n{\n\tu64 now = perf_clock();\n\n\tctx->time += now - ctx->timestamp;\n\tctx->timestamp = now;\n}\n\nstatic u64 perf_event_time(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\n\tif (is_cgroup_event(event))\n\t\treturn perf_cgroup_event_time(event);\n\n\treturn ctx ? ctx->time : 0;\n}\n\n/*\n * Update the total_time_enabled and total_time_running fields for a event.\n */\nstatic void update_event_times(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tu64 run_end;\n\n\tlockdep_assert_held(&ctx->lock);\n\n\tif (event->state < PERF_EVENT_STATE_INACTIVE ||\n\t    event->group_leader->state < PERF_EVENT_STATE_INACTIVE)\n\t\treturn;\n\n\t/*\n\t * in cgroup mode, time_enabled represents\n\t * the time the event was enabled AND active\n\t * tasks were in the monitored cgroup. This is\n\t * independent of the activity of the context as\n\t * there may be a mix of cgroup and non-cgroup events.\n\t *\n\t * That is why we treat cgroup events differently\n\t * here.\n\t */\n\tif (is_cgroup_event(event))\n\t\trun_end = perf_cgroup_event_time(event);\n\telse if (ctx->is_active)\n\t\trun_end = ctx->time;\n\telse\n\t\trun_end = event->tstamp_stopped;\n\n\tevent->total_time_enabled = run_end - event->tstamp_enabled;\n\n\tif (event->state == PERF_EVENT_STATE_INACTIVE)\n\t\trun_end = event->tstamp_stopped;\n\telse\n\t\trun_end = perf_event_time(event);\n\n\tevent->total_time_running = run_end - event->tstamp_running;\n\n}\n\n/*\n * Update total_time_enabled and total_time_running for all events in a group.\n */\nstatic void update_group_times(struct perf_event *leader)\n{\n\tstruct perf_event *event;\n\n\tupdate_event_times(leader);\n\tlist_for_each_entry(event, &leader->sibling_list, group_entry)\n\t\tupdate_event_times(event);\n}\n\nstatic struct list_head *\nctx_group_list(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tif (event->attr.pinned)\n\t\treturn &ctx->pinned_groups;\n\telse\n\t\treturn &ctx->flexible_groups;\n}\n\n/*\n * Add a event from the lists for its context.\n * Must be called with ctx->mutex and ctx->lock held.\n */\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tstruct list_head *list;\n\n\t\tevent->group_caps = event->event_caps;\n\n\t\tlist = ctx_group_list(event, ctx);\n\t\tlist_add_tail(&event->group_entry, list);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}\n\n/*\n * Initialize event state based on the perf_event_attr::disabled.\n */\nstatic inline void perf_event__state_init(struct perf_event *event)\n{\n\tevent->state = event->attr.disabled ? PERF_EVENT_STATE_OFF :\n\t\t\t\t\t      PERF_EVENT_STATE_INACTIVE;\n}\n\nstatic void __perf_event_read_size(struct perf_event *event, int nr_siblings)\n{\n\tint entry = sizeof(u64); /* value */\n\tint size = 0;\n\tint nr = 1;\n\n\tif (event->attr.read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)\n\t\tsize += sizeof(u64);\n\n\tif (event->attr.read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)\n\t\tsize += sizeof(u64);\n\n\tif (event->attr.read_format & PERF_FORMAT_ID)\n\t\tentry += sizeof(u64);\n\n\tif (event->attr.read_format & PERF_FORMAT_GROUP) {\n\t\tnr += nr_siblings;\n\t\tsize += sizeof(u64);\n\t}\n\n\tsize += entry * nr;\n\tevent->read_size = size;\n}\n\nstatic void __perf_event_header_size(struct perf_event *event, u64 sample_type)\n{\n\tstruct perf_sample_data *data;\n\tu16 size = 0;\n\n\tif (sample_type & PERF_SAMPLE_IP)\n\t\tsize += sizeof(data->ip);\n\n\tif (sample_type & PERF_SAMPLE_ADDR)\n\t\tsize += sizeof(data->addr);\n\n\tif (sample_type & PERF_SAMPLE_PERIOD)\n\t\tsize += sizeof(data->period);\n\n\tif (sample_type & PERF_SAMPLE_WEIGHT)\n\t\tsize += sizeof(data->weight);\n\n\tif (sample_type & PERF_SAMPLE_READ)\n\t\tsize += event->read_size;\n\n\tif (sample_type & PERF_SAMPLE_DATA_SRC)\n\t\tsize += sizeof(data->data_src.val);\n\n\tif (sample_type & PERF_SAMPLE_TRANSACTION)\n\t\tsize += sizeof(data->txn);\n\n\tevent->header_size = size;\n}\n\n/*\n * Called at perf_event creation and when events are attached/detached from a\n * group.\n */\nstatic void perf_event__header_size(struct perf_event *event)\n{\n\t__perf_event_read_size(event,\n\t\t\t       event->group_leader->nr_siblings);\n\t__perf_event_header_size(event, event->attr.sample_type);\n}\n\nstatic void perf_event__id_header_size(struct perf_event *event)\n{\n\tstruct perf_sample_data *data;\n\tu64 sample_type = event->attr.sample_type;\n\tu16 size = 0;\n\n\tif (sample_type & PERF_SAMPLE_TID)\n\t\tsize += sizeof(data->tid_entry);\n\n\tif (sample_type & PERF_SAMPLE_TIME)\n\t\tsize += sizeof(data->time);\n\n\tif (sample_type & PERF_SAMPLE_IDENTIFIER)\n\t\tsize += sizeof(data->id);\n\n\tif (sample_type & PERF_SAMPLE_ID)\n\t\tsize += sizeof(data->id);\n\n\tif (sample_type & PERF_SAMPLE_STREAM_ID)\n\t\tsize += sizeof(data->stream_id);\n\n\tif (sample_type & PERF_SAMPLE_CPU)\n\t\tsize += sizeof(data->cpu_entry);\n\n\tevent->id_header_size = size;\n}\n\nstatic bool perf_event_validate_size(struct perf_event *event)\n{\n\t/*\n\t * The values computed here will be over-written when we actually\n\t * attach the event.\n\t */\n\t__perf_event_read_size(event, event->group_leader->nr_siblings + 1);\n\t__perf_event_header_size(event, event->attr.sample_type & ~PERF_SAMPLE_READ);\n\tperf_event__id_header_size(event);\n\n\t/*\n\t * Sum the lot; should not exceed the 64k limit we have on records.\n\t * Conservative limit to allow for callchains and other variable fields.\n\t */\n\tif (event->read_size + event->header_size +\n\t    event->id_header_size + sizeof(struct perf_event_header) >= 16*1024)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void perf_group_attach(struct perf_event *event)\n{\n\tstruct perf_event *group_leader = event->group_leader, *pos;\n\n\t/*\n\t * We can have double attach due to group movement in perf_event_open.\n\t */\n\tif (event->attach_state & PERF_ATTACH_GROUP)\n\t\treturn;\n\n\tevent->attach_state |= PERF_ATTACH_GROUP;\n\n\tif (group_leader == event)\n\t\treturn;\n\n\tWARN_ON_ONCE(group_leader->ctx != event->ctx);\n\n\tgroup_leader->group_caps &= event->event_caps;\n\n\tlist_add_tail(&event->group_entry, &group_leader->sibling_list);\n\tgroup_leader->nr_siblings++;\n\n\tperf_event__header_size(group_leader);\n\n\tlist_for_each_entry(pos, &group_leader->sibling_list, group_entry)\n\t\tperf_event__header_size(pos);\n}\n\n/*\n * Remove a event from the lists for its context.\n * Must be called with ctx->mutex and ctx->lock held.\n */\nstatic void\nlist_del_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tWARN_ON_ONCE(event->ctx != ctx);\n\tlockdep_assert_held(&ctx->lock);\n\n\t/*\n\t * We can have double detach due to exit/hot-unplug + close.\n\t */\n\tif (!(event->attach_state & PERF_ATTACH_CONTEXT))\n\t\treturn;\n\n\tevent->attach_state &= ~PERF_ATTACH_CONTEXT;\n\n\tlist_update_cgroup_event(event, ctx, false);\n\n\tctx->nr_events--;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat--;\n\n\tlist_del_rcu(&event->event_entry);\n\n\tif (event->group_leader == event)\n\t\tlist_del_init(&event->group_entry);\n\n\tupdate_group_times(event);\n\n\t/*\n\t * If event was in error state, then keep it\n\t * that way, otherwise bogus counts will be\n\t * returned on read(). The only way to get out\n\t * of error state is by explicit re-enabling\n\t * of the event\n\t */\n\tif (event->state > PERF_EVENT_STATE_OFF)\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\n\tctx->generation++;\n}\n\nstatic void perf_group_detach(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *tmp;\n\tstruct list_head *list = NULL;\n\n\t/*\n\t * We can have double detach due to exit/hot-unplug + close.\n\t */\n\tif (!(event->attach_state & PERF_ATTACH_GROUP))\n\t\treturn;\n\n\tevent->attach_state &= ~PERF_ATTACH_GROUP;\n\n\t/*\n\t * If this is a sibling, remove it from its group.\n\t */\n\tif (event->group_leader != event) {\n\t\tlist_del_init(&event->group_entry);\n\t\tevent->group_leader->nr_siblings--;\n\t\tgoto out;\n\t}\n\n\tif (!list_empty(&event->group_entry))\n\t\tlist = &event->group_entry;\n\n\t/*\n\t * If this was a group event with sibling events then\n\t * upgrade the siblings to singleton events by adding them\n\t * to whatever list we are on.\n\t */\n\tlist_for_each_entry_safe(sibling, tmp, &event->sibling_list, group_entry) {\n\t\tif (list)\n\t\t\tlist_move_tail(&sibling->group_entry, list);\n\t\tsibling->group_leader = sibling;\n\n\t\t/* Inherit group flags from the previous leader */\n\t\tsibling->group_caps = event->group_caps;\n\n\t\tWARN_ON_ONCE(sibling->ctx != event->ctx);\n\t}\n\nout:\n\tperf_event__header_size(event->group_leader);\n\n\tlist_for_each_entry(tmp, &event->group_leader->sibling_list, group_entry)\n\t\tperf_event__header_size(tmp);\n}\n\nstatic bool is_orphaned_event(struct perf_event *event)\n{\n\treturn event->state == PERF_EVENT_STATE_DEAD;\n}\n\nstatic inline int __pmu_filter_match(struct perf_event *event)\n{\n\tstruct pmu *pmu = event->pmu;\n\treturn pmu->filter_match ? pmu->filter_match(event) : 1;\n}\n\n/*\n * Check whether we should attempt to schedule an event group based on\n * PMU-specific filtering. An event group can consist of HW and SW events,\n * potentially with a SW leader, so we must check all the filters, to\n * determine whether a group is schedulable:\n */\nstatic inline int pmu_filter_match(struct perf_event *event)\n{\n\tstruct perf_event *child;\n\n\tif (!__pmu_filter_match(event))\n\t\treturn 0;\n\n\tlist_for_each_entry(child, &event->sibling_list, group_entry) {\n\t\tif (!__pmu_filter_match(child))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic inline int\nevent_filter_match(struct perf_event *event)\n{\n\treturn (event->cpu == -1 || event->cpu == smp_processor_id()) &&\n\t       perf_cgroup_match(event) && pmu_filter_match(event);\n}\n\nstatic void\nevent_sched_out(struct perf_event *event,\n\t\t  struct perf_cpu_context *cpuctx,\n\t\t  struct perf_event_context *ctx)\n{\n\tu64 tstamp = perf_event_time(event);\n\tu64 delta;\n\n\tWARN_ON_ONCE(event->ctx != ctx);\n\tlockdep_assert_held(&ctx->lock);\n\n\t/*\n\t * An event which could not be activated because of\n\t * filter mismatch still needs to have its timings\n\t * maintained, otherwise bogus information is return\n\t * via read() for time_enabled, time_running:\n\t */\n\tif (event->state == PERF_EVENT_STATE_INACTIVE &&\n\t    !event_filter_match(event)) {\n\t\tdelta = tstamp - event->tstamp_stopped;\n\t\tevent->tstamp_running += delta;\n\t\tevent->tstamp_stopped = tstamp;\n\t}\n\n\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\treturn;\n\n\tperf_pmu_disable(event->pmu);\n\n\tevent->tstamp_stopped = tstamp;\n\tevent->pmu->del(event, 0);\n\tevent->oncpu = -1;\n\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\tif (event->pending_disable) {\n\t\tevent->pending_disable = 0;\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\t}\n\n\tif (!is_software_event(event))\n\t\tcpuctx->active_oncpu--;\n\tif (!--ctx->nr_active)\n\t\tperf_event_ctx_deactivate(ctx);\n\tif (event->attr.freq && event->attr.sample_freq)\n\t\tctx->nr_freq--;\n\tif (event->attr.exclusive || !cpuctx->active_oncpu)\n\t\tcpuctx->exclusive = 0;\n\n\tperf_pmu_enable(event->pmu);\n}\n\nstatic void\ngroup_sched_out(struct perf_event *group_event,\n\t\tstruct perf_cpu_context *cpuctx,\n\t\tstruct perf_event_context *ctx)\n{\n\tstruct perf_event *event;\n\tint state = group_event->state;\n\n\tperf_pmu_disable(ctx->pmu);\n\n\tevent_sched_out(group_event, cpuctx, ctx);\n\n\t/*\n\t * Schedule out siblings (if any):\n\t */\n\tlist_for_each_entry(event, &group_event->sibling_list, group_entry)\n\t\tevent_sched_out(event, cpuctx, ctx);\n\n\tperf_pmu_enable(ctx->pmu);\n\n\tif (state == PERF_EVENT_STATE_ACTIVE && group_event->attr.exclusive)\n\t\tcpuctx->exclusive = 0;\n}\n\n#define DETACH_GROUP\t0x01UL\n\n/*\n * Cross CPU call to remove a performance event\n *\n * We disable the event on the hardware level first. After that we\n * remove it from the context list.\n */\nstatic void\n__perf_remove_from_context(struct perf_event *event,\n\t\t\t   struct perf_cpu_context *cpuctx,\n\t\t\t   struct perf_event_context *ctx,\n\t\t\t   void *info)\n{\n\tunsigned long flags = (unsigned long)info;\n\n\tevent_sched_out(event, cpuctx, ctx);\n\tif (flags & DETACH_GROUP)\n\t\tperf_group_detach(event);\n\tlist_del_event(event, ctx);\n\n\tif (!ctx->nr_events && ctx->is_active) {\n\t\tctx->is_active = 0;\n\t\tif (ctx->task) {\n\t\t\tWARN_ON_ONCE(cpuctx->task_ctx != ctx);\n\t\t\tcpuctx->task_ctx = NULL;\n\t\t}\n\t}\n}\n\n/*\n * Remove the event from a task's (or a CPU's) list of events.\n *\n * If event->ctx is a cloned context, callers must make sure that\n * every task struct that event->ctx->task could possibly point to\n * remains valid.  This is OK when called from perf_release since\n * that only calls us on the top-level context, which can't be a clone.\n * When called from perf_event_exit_task, it's OK because the\n * context has been detached from its task.\n */\nstatic void perf_remove_from_context(struct perf_event *event, unsigned long flags)\n{\n\tlockdep_assert_held(&event->ctx->mutex);\n\n\tevent_function_call(event, __perf_remove_from_context, (void *)flags);\n}\n\n/*\n * Cross CPU call to disable a performance event\n */\nstatic void __perf_event_disable(struct perf_event *event,\n\t\t\t\t struct perf_cpu_context *cpuctx,\n\t\t\t\t struct perf_event_context *ctx,\n\t\t\t\t void *info)\n{\n\tif (event->state < PERF_EVENT_STATE_INACTIVE)\n\t\treturn;\n\n\tupdate_context_time(ctx);\n\tupdate_cgrp_time_from_event(event);\n\tupdate_group_times(event);\n\tif (event == event->group_leader)\n\t\tgroup_sched_out(event, cpuctx, ctx);\n\telse\n\t\tevent_sched_out(event, cpuctx, ctx);\n\tevent->state = PERF_EVENT_STATE_OFF;\n}\n\n/*\n * Disable a event.\n *\n * If event->ctx is a cloned context, callers must make sure that\n * every task struct that event->ctx->task could possibly point to\n * remains valid.  This condition is satisifed when called through\n * perf_event_for_each_child or perf_event_for_each because they\n * hold the top-level event's child_mutex, so any descendant that\n * goes to exit will block in perf_event_exit_event().\n *\n * When called from perf_pending_event it's OK because event->ctx\n * is the current context on this CPU and preemption is disabled,\n * hence we can't get into perf_event_task_sched_out for this context.\n */\nstatic void _perf_event_disable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\n\traw_spin_lock_irq(&ctx->lock);\n\tif (event->state <= PERF_EVENT_STATE_OFF) {\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\treturn;\n\t}\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tevent_function_call(event, __perf_event_disable, NULL);\n}\n\nvoid perf_event_disable_local(struct perf_event *event)\n{\n\tevent_function_local(event, __perf_event_disable, NULL);\n}\n\n/*\n * Strictly speaking kernel users cannot create groups and therefore this\n * interface does not need the perf_event_ctx_lock() magic.\n */\nvoid perf_event_disable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = perf_event_ctx_lock(event);\n\t_perf_event_disable(event);\n\tperf_event_ctx_unlock(event, ctx);\n}\nEXPORT_SYMBOL_GPL(perf_event_disable);\n\nvoid perf_event_disable_inatomic(struct perf_event *event)\n{\n\tevent->pending_disable = 1;\n\tirq_work_queue(&event->pending);\n}\n\nstatic void perf_set_shadow_time(struct perf_event *event,\n\t\t\t\t struct perf_event_context *ctx,\n\t\t\t\t u64 tstamp)\n{\n\t/*\n\t * use the correct time source for the time snapshot\n\t *\n\t * We could get by without this by leveraging the\n\t * fact that to get to this function, the caller\n\t * has most likely already called update_context_time()\n\t * and update_cgrp_time_xx() and thus both timestamp\n\t * are identical (or very close). Given that tstamp is,\n\t * already adjusted for cgroup, we could say that:\n\t *    tstamp - ctx->timestamp\n\t * is equivalent to\n\t *    tstamp - cgrp->timestamp.\n\t *\n\t * Then, in perf_output_read(), the calculation would\n\t * work with no changes because:\n\t * - event is guaranteed scheduled in\n\t * - no scheduled out in between\n\t * - thus the timestamp would be the same\n\t *\n\t * But this is a bit hairy.\n\t *\n\t * So instead, we have an explicit cgroup call to remain\n\t * within the time time source all along. We believe it\n\t * is cleaner and simpler to understand.\n\t */\n\tif (is_cgroup_event(event))\n\t\tperf_cgroup_set_shadow_time(event, tstamp);\n\telse\n\t\tevent->shadow_ctx_time = tstamp - ctx->timestamp;\n}\n\n#define MAX_INTERRUPTS (~0ULL)\n\nstatic void perf_log_throttle(struct perf_event *event, int enable);\nstatic void perf_log_itrace_start(struct perf_event *event);\n\nstatic int\nevent_sched_in(struct perf_event *event,\n\t\t struct perf_cpu_context *cpuctx,\n\t\t struct perf_event_context *ctx)\n{\n\tu64 tstamp = perf_event_time(event);\n\tint ret = 0;\n\n\tlockdep_assert_held(&ctx->lock);\n\n\tif (event->state <= PERF_EVENT_STATE_OFF)\n\t\treturn 0;\n\n\tWRITE_ONCE(event->oncpu, smp_processor_id());\n\t/*\n\t * Order event::oncpu write to happen before the ACTIVE state\n\t * is visible.\n\t */\n\tsmp_wmb();\n\tWRITE_ONCE(event->state, PERF_EVENT_STATE_ACTIVE);\n\n\t/*\n\t * Unthrottle events, since we scheduled we might have missed several\n\t * ticks already, also for a heavily scheduling task there is little\n\t * guarantee it'll get a tick in a timely manner.\n\t */\n\tif (unlikely(event->hw.interrupts == MAX_INTERRUPTS)) {\n\t\tperf_log_throttle(event, 1);\n\t\tevent->hw.interrupts = 0;\n\t}\n\n\t/*\n\t * The new state must be visible before we turn it on in the hardware:\n\t */\n\tsmp_wmb();\n\n\tperf_pmu_disable(event->pmu);\n\n\tperf_set_shadow_time(event, ctx, tstamp);\n\n\tperf_log_itrace_start(event);\n\n\tif (event->pmu->add(event, PERF_EF_START)) {\n\t\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\t\tevent->oncpu = -1;\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tevent->tstamp_running += tstamp - event->tstamp_stopped;\n\n\tif (!is_software_event(event))\n\t\tcpuctx->active_oncpu++;\n\tif (!ctx->nr_active++)\n\t\tperf_event_ctx_activate(ctx);\n\tif (event->attr.freq && event->attr.sample_freq)\n\t\tctx->nr_freq++;\n\n\tif (event->attr.exclusive)\n\t\tcpuctx->exclusive = 1;\n\nout:\n\tperf_pmu_enable(event->pmu);\n\n\treturn ret;\n}\n\nstatic int\ngroup_sched_in(struct perf_event *group_event,\n\t       struct perf_cpu_context *cpuctx,\n\t       struct perf_event_context *ctx)\n{\n\tstruct perf_event *event, *partial_group = NULL;\n\tstruct pmu *pmu = ctx->pmu;\n\tu64 now = ctx->time;\n\tbool simulate = false;\n\n\tif (group_event->state == PERF_EVENT_STATE_OFF)\n\t\treturn 0;\n\n\tpmu->start_txn(pmu, PERF_PMU_TXN_ADD);\n\n\tif (event_sched_in(group_event, cpuctx, ctx)) {\n\t\tpmu->cancel_txn(pmu);\n\t\tperf_mux_hrtimer_restart(cpuctx);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Schedule in siblings as one group (if any):\n\t */\n\tlist_for_each_entry(event, &group_event->sibling_list, group_entry) {\n\t\tif (event_sched_in(event, cpuctx, ctx)) {\n\t\t\tpartial_group = event;\n\t\t\tgoto group_error;\n\t\t}\n\t}\n\n\tif (!pmu->commit_txn(pmu))\n\t\treturn 0;\n\ngroup_error:\n\t/*\n\t * Groups can be scheduled in as one unit only, so undo any\n\t * partial group before returning:\n\t * The events up to the failed event are scheduled out normally,\n\t * tstamp_stopped will be updated.\n\t *\n\t * The failed events and the remaining siblings need to have\n\t * their timings updated as if they had gone thru event_sched_in()\n\t * and event_sched_out(). This is required to get consistent timings\n\t * across the group. This also takes care of the case where the group\n\t * could never be scheduled by ensuring tstamp_stopped is set to mark\n\t * the time the event was actually stopped, such that time delta\n\t * calculation in update_event_times() is correct.\n\t */\n\tlist_for_each_entry(event, &group_event->sibling_list, group_entry) {\n\t\tif (event == partial_group)\n\t\t\tsimulate = true;\n\n\t\tif (simulate) {\n\t\t\tevent->tstamp_running += now - event->tstamp_stopped;\n\t\t\tevent->tstamp_stopped = now;\n\t\t} else {\n\t\t\tevent_sched_out(event, cpuctx, ctx);\n\t\t}\n\t}\n\tevent_sched_out(group_event, cpuctx, ctx);\n\n\tpmu->cancel_txn(pmu);\n\n\tperf_mux_hrtimer_restart(cpuctx);\n\n\treturn -EAGAIN;\n}\n\n/*\n * Work out whether we can put this event group on the CPU now.\n */\nstatic int group_can_go_on(struct perf_event *event,\n\t\t\t   struct perf_cpu_context *cpuctx,\n\t\t\t   int can_add_hw)\n{\n\t/*\n\t * Groups consisting entirely of software events can always go on.\n\t */\n\tif (event->group_caps & PERF_EV_CAP_SOFTWARE)\n\t\treturn 1;\n\t/*\n\t * If an exclusive group is already on, no other hardware\n\t * events can go on.\n\t */\n\tif (cpuctx->exclusive)\n\t\treturn 0;\n\t/*\n\t * If this group is exclusive and there are already\n\t * events on the CPU, it can't go on.\n\t */\n\tif (event->attr.exclusive && cpuctx->active_oncpu)\n\t\treturn 0;\n\t/*\n\t * Otherwise, try to add it if all previous groups were able\n\t * to go on.\n\t */\n\treturn can_add_hw;\n}\n\nstatic void add_event_to_ctx(struct perf_event *event,\n\t\t\t       struct perf_event_context *ctx)\n{\n\tu64 tstamp = perf_event_time(event);\n\n\tlist_add_event(event, ctx);\n\tperf_group_attach(event);\n\tevent->tstamp_enabled = tstamp;\n\tevent->tstamp_running = tstamp;\n\tevent->tstamp_stopped = tstamp;\n}\n\nstatic void ctx_sched_out(struct perf_event_context *ctx,\n\t\t\t  struct perf_cpu_context *cpuctx,\n\t\t\t  enum event_type_t event_type);\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);\n\nstatic void task_ctx_sched_out(struct perf_cpu_context *cpuctx,\n\t\t\t       struct perf_event_context *ctx)\n{\n\tif (!cpuctx->task_ctx)\n\t\treturn;\n\n\tif (WARN_ON_ONCE(ctx != cpuctx->task_ctx))\n\t\treturn;\n\n\tctx_sched_out(ctx, cpuctx, EVENT_ALL);\n}\n\nstatic void perf_event_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t\tstruct perf_event_context *ctx,\n\t\t\t\tstruct task_struct *task)\n{\n\tcpu_ctx_sched_in(cpuctx, EVENT_PINNED, task);\n\tif (ctx)\n\t\tctx_sched_in(ctx, cpuctx, EVENT_PINNED, task);\n\tcpu_ctx_sched_in(cpuctx, EVENT_FLEXIBLE, task);\n\tif (ctx)\n\t\tctx_sched_in(ctx, cpuctx, EVENT_FLEXIBLE, task);\n}\n\nstatic void ctx_resched(struct perf_cpu_context *cpuctx,\n\t\t\tstruct perf_event_context *task_ctx)\n{\n\tperf_pmu_disable(cpuctx->ctx.pmu);\n\tif (task_ctx)\n\t\ttask_ctx_sched_out(cpuctx, task_ctx);\n\tcpu_ctx_sched_out(cpuctx, EVENT_ALL);\n\tperf_event_sched_in(cpuctx, task_ctx, current);\n\tperf_pmu_enable(cpuctx->ctx.pmu);\n}\n\n/*\n * Cross CPU call to install and enable a performance event\n *\n * Very similar to remote_function() + event_function() but cannot assume that\n * things like ctx->is_active and cpuctx->task_ctx are set.\n */\nstatic int  __perf_install_in_context(void *info)\n{\n\tstruct perf_event *event = info;\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\tstruct perf_event_context *task_ctx = cpuctx->task_ctx;\n\tbool reprogram = true;\n\tint ret = 0;\n\n\traw_spin_lock(&cpuctx->ctx.lock);\n\tif (ctx->task) {\n\t\traw_spin_lock(&ctx->lock);\n\t\ttask_ctx = ctx;\n\n\t\treprogram = (ctx->task == current);\n\n\t\t/*\n\t\t * If the task is running, it must be running on this CPU,\n\t\t * otherwise we cannot reprogram things.\n\t\t *\n\t\t * If its not running, we don't care, ctx->lock will\n\t\t * serialize against it becoming runnable.\n\t\t */\n\t\tif (task_curr(ctx->task) && !reprogram) {\n\t\t\tret = -ESRCH;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tWARN_ON_ONCE(reprogram && cpuctx->task_ctx && cpuctx->task_ctx != ctx);\n\t} else if (task_ctx) {\n\t\traw_spin_lock(&task_ctx->lock);\n\t}\n\n\tif (reprogram) {\n\t\tctx_sched_out(ctx, cpuctx, EVENT_TIME);\n\t\tadd_event_to_ctx(event, ctx);\n\t\tctx_resched(cpuctx, task_ctx);\n\t} else {\n\t\tadd_event_to_ctx(event, ctx);\n\t}\n\nunlock:\n\tperf_ctx_unlock(cpuctx, task_ctx);\n\n\treturn ret;\n}\n\n/*\n * Attach a performance event to a context.\n *\n * Very similar to event_function_call, see comment there.\n */\nstatic void\nperf_install_in_context(struct perf_event_context *ctx,\n\t\t\tstruct perf_event *event,\n\t\t\tint cpu)\n{\n\tstruct task_struct *task = READ_ONCE(ctx->task);\n\n\tlockdep_assert_held(&ctx->mutex);\n\n\tif (event->cpu != -1)\n\t\tevent->cpu = cpu;\n\n\t/*\n\t * Ensures that if we can observe event->ctx, both the event and ctx\n\t * will be 'complete'. See perf_iterate_sb_cpu().\n\t */\n\tsmp_store_release(&event->ctx, ctx);\n\n\tif (!task) {\n\t\tcpu_function_call(cpu, __perf_install_in_context, event);\n\t\treturn;\n\t}\n\n\t/*\n\t * Should not happen, we validate the ctx is still alive before calling.\n\t */\n\tif (WARN_ON_ONCE(task == TASK_TOMBSTONE))\n\t\treturn;\n\n\t/*\n\t * Installing events is tricky because we cannot rely on ctx->is_active\n\t * to be set in case this is the nr_events 0 -> 1 transition.\n\t *\n\t * Instead we use task_curr(), which tells us if the task is running.\n\t * However, since we use task_curr() outside of rq::lock, we can race\n\t * against the actual state. This means the result can be wrong.\n\t *\n\t * If we get a false positive, we retry, this is harmless.\n\t *\n\t * If we get a false negative, things are complicated. If we are after\n\t * perf_event_context_sched_in() ctx::lock will serialize us, and the\n\t * value must be correct. If we're before, it doesn't matter since\n\t * perf_event_context_sched_in() will program the counter.\n\t *\n\t * However, this hinges on the remote context switch having observed\n\t * our task->perf_event_ctxp[] store, such that it will in fact take\n\t * ctx::lock in perf_event_context_sched_in().\n\t *\n\t * We do this by task_function_call(), if the IPI fails to hit the task\n\t * we know any future context switch of task must see the\n\t * perf_event_ctpx[] store.\n\t */\n\n\t/*\n\t * This smp_mb() orders the task->perf_event_ctxp[] store with the\n\t * task_cpu() load, such that if the IPI then does not find the task\n\t * running, a future context switch of that task must observe the\n\t * store.\n\t */\n\tsmp_mb();\nagain:\n\tif (!task_function_call(task, __perf_install_in_context, event))\n\t\treturn;\n\n\traw_spin_lock_irq(&ctx->lock);\n\ttask = ctx->task;\n\tif (WARN_ON_ONCE(task == TASK_TOMBSTONE)) {\n\t\t/*\n\t\t * Cannot happen because we already checked above (which also\n\t\t * cannot happen), and we hold ctx->mutex, which serializes us\n\t\t * against perf_event_exit_task_context().\n\t\t */\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\treturn;\n\t}\n\t/*\n\t * If the task is not running, ctx->lock will avoid it becoming so,\n\t * thus we can safely install the event.\n\t */\n\tif (task_curr(task)) {\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\tgoto again;\n\t}\n\tadd_event_to_ctx(event, ctx);\n\traw_spin_unlock_irq(&ctx->lock);\n}\n\n/*\n * Put a event into inactive state and update time fields.\n * Enabling the leader of a group effectively enables all\n * the group members that aren't explicitly disabled, so we\n * have to update their ->tstamp_enabled also.\n * Note: this works for group members as well as group leaders\n * since the non-leader members' sibling_lists will be empty.\n */\nstatic void __perf_event_mark_enabled(struct perf_event *event)\n{\n\tstruct perf_event *sub;\n\tu64 tstamp = perf_event_time(event);\n\n\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\tevent->tstamp_enabled = tstamp - event->total_time_enabled;\n\tlist_for_each_entry(sub, &event->sibling_list, group_entry) {\n\t\tif (sub->state >= PERF_EVENT_STATE_INACTIVE)\n\t\t\tsub->tstamp_enabled = tstamp - sub->total_time_enabled;\n\t}\n}\n\n/*\n * Cross CPU call to enable a performance event\n */\nstatic void __perf_event_enable(struct perf_event *event,\n\t\t\t\tstruct perf_cpu_context *cpuctx,\n\t\t\t\tstruct perf_event_context *ctx,\n\t\t\t\tvoid *info)\n{\n\tstruct perf_event *leader = event->group_leader;\n\tstruct perf_event_context *task_ctx;\n\n\tif (event->state >= PERF_EVENT_STATE_INACTIVE ||\n\t    event->state <= PERF_EVENT_STATE_ERROR)\n\t\treturn;\n\n\tif (ctx->is_active)\n\t\tctx_sched_out(ctx, cpuctx, EVENT_TIME);\n\n\t__perf_event_mark_enabled(event);\n\n\tif (!ctx->is_active)\n\t\treturn;\n\n\tif (!event_filter_match(event)) {\n\t\tif (is_cgroup_event(event))\n\t\t\tperf_cgroup_defer_enabled(event);\n\t\tctx_sched_in(ctx, cpuctx, EVENT_TIME, current);\n\t\treturn;\n\t}\n\n\t/*\n\t * If the event is in a group and isn't the group leader,\n\t * then don't put it on unless the group is on.\n\t */\n\tif (leader != event && leader->state != PERF_EVENT_STATE_ACTIVE) {\n\t\tctx_sched_in(ctx, cpuctx, EVENT_TIME, current);\n\t\treturn;\n\t}\n\n\ttask_ctx = cpuctx->task_ctx;\n\tif (ctx->task)\n\t\tWARN_ON_ONCE(task_ctx != ctx);\n\n\tctx_resched(cpuctx, task_ctx);\n}\n\n/*\n * Enable a event.\n *\n * If event->ctx is a cloned context, callers must make sure that\n * every task struct that event->ctx->task could possibly point to\n * remains valid.  This condition is satisfied when called through\n * perf_event_for_each_child or perf_event_for_each as described\n * for perf_event_disable.\n */\nstatic void _perf_event_enable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\n\traw_spin_lock_irq(&ctx->lock);\n\tif (event->state >= PERF_EVENT_STATE_INACTIVE ||\n\t    event->state <  PERF_EVENT_STATE_ERROR) {\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\treturn;\n\t}\n\n\t/*\n\t * If the event is in error state, clear that first.\n\t *\n\t * That way, if we see the event in error state below, we know that it\n\t * has gone back into error state, as distinct from the task having\n\t * been scheduled away before the cross-call arrived.\n\t */\n\tif (event->state == PERF_EVENT_STATE_ERROR)\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tevent_function_call(event, __perf_event_enable, NULL);\n}\n\n/*\n * See perf_event_disable();\n */\nvoid perf_event_enable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = perf_event_ctx_lock(event);\n\t_perf_event_enable(event);\n\tperf_event_ctx_unlock(event, ctx);\n}\nEXPORT_SYMBOL_GPL(perf_event_enable);\n\nstruct stop_event_data {\n\tstruct perf_event\t*event;\n\tunsigned int\t\trestart;\n};\n\nstatic int __perf_event_stop(void *info)\n{\n\tstruct stop_event_data *sd = info;\n\tstruct perf_event *event = sd->event;\n\n\t/* if it's already INACTIVE, do nothing */\n\tif (READ_ONCE(event->state) != PERF_EVENT_STATE_ACTIVE)\n\t\treturn 0;\n\n\t/* matches smp_wmb() in event_sched_in() */\n\tsmp_rmb();\n\n\t/*\n\t * There is a window with interrupts enabled before we get here,\n\t * so we need to check again lest we try to stop another CPU's event.\n\t */\n\tif (READ_ONCE(event->oncpu) != smp_processor_id())\n\t\treturn -EAGAIN;\n\n\tevent->pmu->stop(event, PERF_EF_UPDATE);\n\n\t/*\n\t * May race with the actual stop (through perf_pmu_output_stop()),\n\t * but it is only used for events with AUX ring buffer, and such\n\t * events will refuse to restart because of rb::aux_mmap_count==0,\n\t * see comments in perf_aux_output_begin().\n\t *\n\t * Since this is happening on a event-local CPU, no trace is lost\n\t * while restarting.\n\t */\n\tif (sd->restart)\n\t\tevent->pmu->start(event, 0);\n\n\treturn 0;\n}\n\nstatic int perf_event_stop(struct perf_event *event, int restart)\n{\n\tstruct stop_event_data sd = {\n\t\t.event\t\t= event,\n\t\t.restart\t= restart,\n\t};\n\tint ret = 0;\n\n\tdo {\n\t\tif (READ_ONCE(event->state) != PERF_EVENT_STATE_ACTIVE)\n\t\t\treturn 0;\n\n\t\t/* matches smp_wmb() in event_sched_in() */\n\t\tsmp_rmb();\n\n\t\t/*\n\t\t * We only want to restart ACTIVE events, so if the event goes\n\t\t * inactive here (event->oncpu==-1), there's nothing more to do;\n\t\t * fall through with ret==-ENXIO.\n\t\t */\n\t\tret = cpu_function_call(READ_ONCE(event->oncpu),\n\t\t\t\t\t__perf_event_stop, &sd);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}\n\n/*\n * In order to contain the amount of racy and tricky in the address filter\n * configuration management, it is a two part process:\n *\n * (p1) when userspace mappings change as a result of (1) or (2) or (3) below,\n *      we update the addresses of corresponding vmas in\n *\tevent::addr_filters_offs array and bump the event::addr_filters_gen;\n * (p2) when an event is scheduled in (pmu::add), it calls\n *      perf_event_addr_filters_sync() which calls pmu::addr_filters_sync()\n *      if the generation has changed since the previous call.\n *\n * If (p1) happens while the event is active, we restart it to force (p2).\n *\n * (1) perf_addr_filters_apply(): adjusting filters' offsets based on\n *     pre-existing mappings, called once when new filters arrive via SET_FILTER\n *     ioctl;\n * (2) perf_addr_filters_adjust(): adjusting filters' offsets based on newly\n *     registered mapping, called for every new mmap(), with mm::mmap_sem down\n *     for reading;\n * (3) perf_event_addr_filters_exec(): clearing filters' offsets in the process\n *     of exec.\n */\nvoid perf_event_addr_filters_sync(struct perf_event *event)\n{\n\tstruct perf_addr_filters_head *ifh = perf_event_addr_filters(event);\n\n\tif (!has_addr_filter(event))\n\t\treturn;\n\n\traw_spin_lock(&ifh->lock);\n\tif (event->addr_filters_gen != event->hw.addr_filters_gen) {\n\t\tevent->pmu->addr_filters_sync(event);\n\t\tevent->hw.addr_filters_gen = event->addr_filters_gen;\n\t}\n\traw_spin_unlock(&ifh->lock);\n}\nEXPORT_SYMBOL_GPL(perf_event_addr_filters_sync);\n\nstatic int _perf_event_refresh(struct perf_event *event, int refresh)\n{\n\t/*\n\t * not supported on inherited events\n\t */\n\tif (event->attr.inherit || !is_sampling_event(event))\n\t\treturn -EINVAL;\n\n\tatomic_add(refresh, &event->event_limit);\n\t_perf_event_enable(event);\n\n\treturn 0;\n}\n\n/*\n * See perf_event_disable()\n */\nint perf_event_refresh(struct perf_event *event, int refresh)\n{\n\tstruct perf_event_context *ctx;\n\tint ret;\n\n\tctx = perf_event_ctx_lock(event);\n\tret = _perf_event_refresh(event, refresh);\n\tperf_event_ctx_unlock(event, ctx);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(perf_event_refresh);\n\nstatic void ctx_sched_out(struct perf_event_context *ctx,\n\t\t\t  struct perf_cpu_context *cpuctx,\n\t\t\t  enum event_type_t event_type)\n{\n\tint is_active = ctx->is_active;\n\tstruct perf_event *event;\n\n\tlockdep_assert_held(&ctx->lock);\n\n\tif (likely(!ctx->nr_events)) {\n\t\t/*\n\t\t * See __perf_remove_from_context().\n\t\t */\n\t\tWARN_ON_ONCE(ctx->is_active);\n\t\tif (ctx->task)\n\t\t\tWARN_ON_ONCE(cpuctx->task_ctx);\n\t\treturn;\n\t}\n\n\tctx->is_active &= ~event_type;\n\tif (!(ctx->is_active & EVENT_ALL))\n\t\tctx->is_active = 0;\n\n\tif (ctx->task) {\n\t\tWARN_ON_ONCE(cpuctx->task_ctx != ctx);\n\t\tif (!ctx->is_active)\n\t\t\tcpuctx->task_ctx = NULL;\n\t}\n\n\t/*\n\t * Always update time if it was set; not only when it changes.\n\t * Otherwise we can 'forget' to update time for any but the last\n\t * context we sched out. For example:\n\t *\n\t *   ctx_sched_out(.event_type = EVENT_FLEXIBLE)\n\t *   ctx_sched_out(.event_type = EVENT_PINNED)\n\t *\n\t * would only update time for the pinned events.\n\t */\n\tif (is_active & EVENT_TIME) {\n\t\t/* update (and stop) ctx time */\n\t\tupdate_context_time(ctx);\n\t\tupdate_cgrp_time_from_cpuctx(cpuctx);\n\t}\n\n\tis_active ^= ctx->is_active; /* changed bits */\n\n\tif (!ctx->nr_active || !(is_active & EVENT_ALL))\n\t\treturn;\n\n\tperf_pmu_disable(ctx->pmu);\n\tif (is_active & EVENT_PINNED) {\n\t\tlist_for_each_entry(event, &ctx->pinned_groups, group_entry)\n\t\t\tgroup_sched_out(event, cpuctx, ctx);\n\t}\n\n\tif (is_active & EVENT_FLEXIBLE) {\n\t\tlist_for_each_entry(event, &ctx->flexible_groups, group_entry)\n\t\t\tgroup_sched_out(event, cpuctx, ctx);\n\t}\n\tperf_pmu_enable(ctx->pmu);\n}\n\n/*\n * Test whether two contexts are equivalent, i.e. whether they have both been\n * cloned from the same version of the same context.\n *\n * Equivalence is measured using a generation number in the context that is\n * incremented on each modification to it; see unclone_ctx(), list_add_event()\n * and list_del_event().\n */\nstatic int context_equiv(struct perf_event_context *ctx1,\n\t\t\t struct perf_event_context *ctx2)\n{\n\tlockdep_assert_held(&ctx1->lock);\n\tlockdep_assert_held(&ctx2->lock);\n\n\t/* Pinning disables the swap optimization */\n\tif (ctx1->pin_count || ctx2->pin_count)\n\t\treturn 0;\n\n\t/* If ctx1 is the parent of ctx2 */\n\tif (ctx1 == ctx2->parent_ctx && ctx1->generation == ctx2->parent_gen)\n\t\treturn 1;\n\n\t/* If ctx2 is the parent of ctx1 */\n\tif (ctx1->parent_ctx == ctx2 && ctx1->parent_gen == ctx2->generation)\n\t\treturn 1;\n\n\t/*\n\t * If ctx1 and ctx2 have the same parent; we flatten the parent\n\t * hierarchy, see perf_event_init_context().\n\t */\n\tif (ctx1->parent_ctx && ctx1->parent_ctx == ctx2->parent_ctx &&\n\t\t\tctx1->parent_gen == ctx2->parent_gen)\n\t\treturn 1;\n\n\t/* Unmatched */\n\treturn 0;\n}\n\nstatic void __perf_event_sync_stat(struct perf_event *event,\n\t\t\t\t     struct perf_event *next_event)\n{\n\tu64 value;\n\n\tif (!event->attr.inherit_stat)\n\t\treturn;\n\n\t/*\n\t * Update the event value, we cannot use perf_event_read()\n\t * because we're in the middle of a context switch and have IRQs\n\t * disabled, which upsets smp_call_function_single(), however\n\t * we know the event must be on the current CPU, therefore we\n\t * don't need to use it.\n\t */\n\tswitch (event->state) {\n\tcase PERF_EVENT_STATE_ACTIVE:\n\t\tevent->pmu->read(event);\n\t\t/* fall-through */\n\n\tcase PERF_EVENT_STATE_INACTIVE:\n\t\tupdate_event_times(event);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * In order to keep per-task stats reliable we need to flip the event\n\t * values when we flip the contexts.\n\t */\n\tvalue = local64_read(&next_event->count);\n\tvalue = local64_xchg(&event->count, value);\n\tlocal64_set(&next_event->count, value);\n\n\tswap(event->total_time_enabled, next_event->total_time_enabled);\n\tswap(event->total_time_running, next_event->total_time_running);\n\n\t/*\n\t * Since we swizzled the values, update the user visible data too.\n\t */\n\tperf_event_update_userpage(event);\n\tperf_event_update_userpage(next_event);\n}\n\nstatic void perf_event_sync_stat(struct perf_event_context *ctx,\n\t\t\t\t   struct perf_event_context *next_ctx)\n{\n\tstruct perf_event *event, *next_event;\n\n\tif (!ctx->nr_stat)\n\t\treturn;\n\n\tupdate_context_time(ctx);\n\n\tevent = list_first_entry(&ctx->event_list,\n\t\t\t\t   struct perf_event, event_entry);\n\n\tnext_event = list_first_entry(&next_ctx->event_list,\n\t\t\t\t\tstruct perf_event, event_entry);\n\n\twhile (&event->event_entry != &ctx->event_list &&\n\t       &next_event->event_entry != &next_ctx->event_list) {\n\n\t\t__perf_event_sync_stat(event, next_event);\n\n\t\tevent = list_next_entry(event, event_entry);\n\t\tnext_event = list_next_entry(next_event, event_entry);\n\t}\n}\n\nstatic void perf_event_context_sched_out(struct task_struct *task, int ctxn,\n\t\t\t\t\t struct task_struct *next)\n{\n\tstruct perf_event_context *ctx = task->perf_event_ctxp[ctxn];\n\tstruct perf_event_context *next_ctx;\n\tstruct perf_event_context *parent, *next_parent;\n\tstruct perf_cpu_context *cpuctx;\n\tint do_switch = 1;\n\n\tif (likely(!ctx))\n\t\treturn;\n\n\tcpuctx = __get_cpu_context(ctx);\n\tif (!cpuctx->task_ctx)\n\t\treturn;\n\n\trcu_read_lock();\n\tnext_ctx = next->perf_event_ctxp[ctxn];\n\tif (!next_ctx)\n\t\tgoto unlock;\n\n\tparent = rcu_dereference(ctx->parent_ctx);\n\tnext_parent = rcu_dereference(next_ctx->parent_ctx);\n\n\t/* If neither context have a parent context; they cannot be clones. */\n\tif (!parent && !next_parent)\n\t\tgoto unlock;\n\n\tif (next_parent == ctx || next_ctx == parent || next_parent == parent) {\n\t\t/*\n\t\t * Looks like the two contexts are clones, so we might be\n\t\t * able to optimize the context switch.  We lock both\n\t\t * contexts and check that they are clones under the\n\t\t * lock (including re-checking that neither has been\n\t\t * uncloned in the meantime).  It doesn't matter which\n\t\t * order we take the locks because no other cpu could\n\t\t * be trying to lock both of these tasks.\n\t\t */\n\t\traw_spin_lock(&ctx->lock);\n\t\traw_spin_lock_nested(&next_ctx->lock, SINGLE_DEPTH_NESTING);\n\t\tif (context_equiv(ctx, next_ctx)) {\n\t\t\tWRITE_ONCE(ctx->task, next);\n\t\t\tWRITE_ONCE(next_ctx->task, task);\n\n\t\t\tswap(ctx->task_ctx_data, next_ctx->task_ctx_data);\n\n\t\t\t/*\n\t\t\t * RCU_INIT_POINTER here is safe because we've not\n\t\t\t * modified the ctx and the above modification of\n\t\t\t * ctx->task and ctx->task_ctx_data are immaterial\n\t\t\t * since those values are always verified under\n\t\t\t * ctx->lock which we're now holding.\n\t\t\t */\n\t\t\tRCU_INIT_POINTER(task->perf_event_ctxp[ctxn], next_ctx);\n\t\t\tRCU_INIT_POINTER(next->perf_event_ctxp[ctxn], ctx);\n\n\t\t\tdo_switch = 0;\n\n\t\t\tperf_event_sync_stat(ctx, next_ctx);\n\t\t}\n\t\traw_spin_unlock(&next_ctx->lock);\n\t\traw_spin_unlock(&ctx->lock);\n\t}\nunlock:\n\trcu_read_unlock();\n\n\tif (do_switch) {\n\t\traw_spin_lock(&ctx->lock);\n\t\ttask_ctx_sched_out(cpuctx, ctx);\n\t\traw_spin_unlock(&ctx->lock);\n\t}\n}\n\nstatic DEFINE_PER_CPU(struct list_head, sched_cb_list);\n\nvoid perf_sched_cb_dec(struct pmu *pmu)\n{\n\tstruct perf_cpu_context *cpuctx = this_cpu_ptr(pmu->pmu_cpu_context);\n\n\tthis_cpu_dec(perf_sched_cb_usages);\n\n\tif (!--cpuctx->sched_cb_usage)\n\t\tlist_del(&cpuctx->sched_cb_entry);\n}\n\n\nvoid perf_sched_cb_inc(struct pmu *pmu)\n{\n\tstruct perf_cpu_context *cpuctx = this_cpu_ptr(pmu->pmu_cpu_context);\n\n\tif (!cpuctx->sched_cb_usage++)\n\t\tlist_add(&cpuctx->sched_cb_entry, this_cpu_ptr(&sched_cb_list));\n\n\tthis_cpu_inc(perf_sched_cb_usages);\n}\n\n/*\n * This function provides the context switch callback to the lower code\n * layer. It is invoked ONLY when the context switch callback is enabled.\n *\n * This callback is relevant even to per-cpu events; for example multi event\n * PEBS requires this to provide PID/TID information. This requires we flush\n * all queued PEBS records before we context switch to a new task.\n */\nstatic void perf_pmu_sched_task(struct task_struct *prev,\n\t\t\t\tstruct task_struct *next,\n\t\t\t\tbool sched_in)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct pmu *pmu;\n\n\tif (prev == next)\n\t\treturn;\n\n\tlist_for_each_entry(cpuctx, this_cpu_ptr(&sched_cb_list), sched_cb_entry) {\n\t\tpmu = cpuctx->unique_pmu; /* software PMUs will not have sched_task */\n\n\t\tif (WARN_ON_ONCE(!pmu->sched_task))\n\t\t\tcontinue;\n\n\t\tperf_ctx_lock(cpuctx, cpuctx->task_ctx);\n\t\tperf_pmu_disable(pmu);\n\n\t\tpmu->sched_task(cpuctx->task_ctx, sched_in);\n\n\t\tperf_pmu_enable(pmu);\n\t\tperf_ctx_unlock(cpuctx, cpuctx->task_ctx);\n\t}\n}\n\nstatic void perf_event_switch(struct task_struct *task,\n\t\t\t      struct task_struct *next_prev, bool sched_in);\n\n#define for_each_task_context_nr(ctxn)\t\t\t\t\t\\\n\tfor ((ctxn) = 0; (ctxn) < perf_nr_task_contexts; (ctxn)++)\n\n/*\n * Called from scheduler to remove the events of the current task,\n * with interrupts disabled.\n *\n * We stop each event and update the event value in event->count.\n *\n * This does not protect us against NMI, but disable()\n * sets the disabled bit in the control field of event _before_\n * accessing the event control register. If a NMI hits, then it will\n * not restart the event.\n */\nvoid __perf_event_task_sched_out(struct task_struct *task,\n\t\t\t\t struct task_struct *next)\n{\n\tint ctxn;\n\n\tif (__this_cpu_read(perf_sched_cb_usages))\n\t\tperf_pmu_sched_task(task, next, false);\n\n\tif (atomic_read(&nr_switch_events))\n\t\tperf_event_switch(task, next, false);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_context_sched_out(task, ctxn, next);\n\n\t/*\n\t * if cgroup events exist on this CPU, then we need\n\t * to check if we have to switch out PMU state.\n\t * cgroup event are system-wide mode only\n\t */\n\tif (atomic_read(this_cpu_ptr(&perf_cgroup_events)))\n\t\tperf_cgroup_sched_out(task, next);\n}\n\n/*\n * Called with IRQs disabled\n */\nstatic void cpu_ctx_sched_out(struct perf_cpu_context *cpuctx,\n\t\t\t      enum event_type_t event_type)\n{\n\tctx_sched_out(&cpuctx->ctx, cpuctx, event_type);\n}\n\nstatic void\nctx_pinned_sched_in(struct perf_event_context *ctx,\n\t\t    struct perf_cpu_context *cpuctx)\n{\n\tstruct perf_event *event;\n\n\tlist_for_each_entry(event, &ctx->pinned_groups, group_entry) {\n\t\tif (event->state <= PERF_EVENT_STATE_OFF)\n\t\t\tcontinue;\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\n\t\t/* may need to reset tstamp_enabled */\n\t\tif (is_cgroup_event(event))\n\t\t\tperf_cgroup_mark_enabled(event, ctx);\n\n\t\tif (group_can_go_on(event, cpuctx, 1))\n\t\t\tgroup_sched_in(event, cpuctx, ctx);\n\n\t\t/*\n\t\t * If this pinned group hasn't been scheduled,\n\t\t * put it in error state.\n\t\t */\n\t\tif (event->state == PERF_EVENT_STATE_INACTIVE) {\n\t\t\tupdate_group_times(event);\n\t\t\tevent->state = PERF_EVENT_STATE_ERROR;\n\t\t}\n\t}\n}\n\nstatic void\nctx_flexible_sched_in(struct perf_event_context *ctx,\n\t\t      struct perf_cpu_context *cpuctx)\n{\n\tstruct perf_event *event;\n\tint can_add_hw = 1;\n\n\tlist_for_each_entry(event, &ctx->flexible_groups, group_entry) {\n\t\t/* Ignore events in OFF or ERROR state */\n\t\tif (event->state <= PERF_EVENT_STATE_OFF)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Listen to the 'cpu' scheduling filter constraint\n\t\t * of events:\n\t\t */\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\n\t\t/* may need to reset tstamp_enabled */\n\t\tif (is_cgroup_event(event))\n\t\t\tperf_cgroup_mark_enabled(event, ctx);\n\n\t\tif (group_can_go_on(event, cpuctx, can_add_hw)) {\n\t\t\tif (group_sched_in(event, cpuctx, ctx))\n\t\t\t\tcan_add_hw = 0;\n\t\t}\n\t}\n}\n\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task)\n{\n\tint is_active = ctx->is_active;\n\tu64 now;\n\n\tlockdep_assert_held(&ctx->lock);\n\n\tif (likely(!ctx->nr_events))\n\t\treturn;\n\n\tctx->is_active |= (event_type | EVENT_TIME);\n\tif (ctx->task) {\n\t\tif (!is_active)\n\t\t\tcpuctx->task_ctx = ctx;\n\t\telse\n\t\t\tWARN_ON_ONCE(cpuctx->task_ctx != ctx);\n\t}\n\n\tis_active ^= ctx->is_active; /* changed bits */\n\n\tif (is_active & EVENT_TIME) {\n\t\t/* start ctx time */\n\t\tnow = perf_clock();\n\t\tctx->timestamp = now;\n\t\tperf_cgroup_set_timestamp(task, ctx);\n\t}\n\n\t/*\n\t * First go through the list and put on any pinned groups\n\t * in order to give them the best chance of going on.\n\t */\n\tif (is_active & EVENT_PINNED)\n\t\tctx_pinned_sched_in(ctx, cpuctx);\n\n\t/* Then walk through the lower prio flexible groups */\n\tif (is_active & EVENT_FLEXIBLE)\n\t\tctx_flexible_sched_in(ctx, cpuctx);\n}\n\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task)\n{\n\tstruct perf_event_context *ctx = &cpuctx->ctx;\n\n\tctx_sched_in(ctx, cpuctx, event_type, task);\n}\n\nstatic void perf_event_context_sched_in(struct perf_event_context *ctx,\n\t\t\t\t\tstruct task_struct *task)\n{\n\tstruct perf_cpu_context *cpuctx;\n\n\tcpuctx = __get_cpu_context(ctx);\n\tif (cpuctx->task_ctx == ctx)\n\t\treturn;\n\n\tperf_ctx_lock(cpuctx, ctx);\n\tperf_pmu_disable(ctx->pmu);\n\t/*\n\t * We want to keep the following priority order:\n\t * cpu pinned (that don't need to move), task pinned,\n\t * cpu flexible, task flexible.\n\t */\n\tcpu_ctx_sched_out(cpuctx, EVENT_FLEXIBLE);\n\tperf_event_sched_in(cpuctx, ctx, task);\n\tperf_pmu_enable(ctx->pmu);\n\tperf_ctx_unlock(cpuctx, ctx);\n}\n\n/*\n * Called from scheduler to add the events of the current task\n * with interrupts disabled.\n *\n * We restore the event value and then enable it.\n *\n * This does not protect us against NMI, but enable()\n * sets the enabled bit in the control field of event _before_\n * accessing the event control register. If a NMI hits, then it will\n * keep the event running.\n */\nvoid __perf_event_task_sched_in(struct task_struct *prev,\n\t\t\t\tstruct task_struct *task)\n{\n\tstruct perf_event_context *ctx;\n\tint ctxn;\n\n\t/*\n\t * If cgroup events exist on this CPU, then we need to check if we have\n\t * to switch in PMU state; cgroup event are system-wide mode only.\n\t *\n\t * Since cgroup events are CPU events, we must schedule these in before\n\t * we schedule in the task events.\n\t */\n\tif (atomic_read(this_cpu_ptr(&perf_cgroup_events)))\n\t\tperf_cgroup_sched_in(prev, task);\n\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = task->perf_event_ctxp[ctxn];\n\t\tif (likely(!ctx))\n\t\t\tcontinue;\n\n\t\tperf_event_context_sched_in(ctx, task);\n\t}\n\n\tif (atomic_read(&nr_switch_events))\n\t\tperf_event_switch(task, prev, true);\n\n\tif (__this_cpu_read(perf_sched_cb_usages))\n\t\tperf_pmu_sched_task(prev, task, true);\n}\n\nstatic u64 perf_calculate_period(struct perf_event *event, u64 nsec, u64 count)\n{\n\tu64 frequency = event->attr.sample_freq;\n\tu64 sec = NSEC_PER_SEC;\n\tu64 divisor, dividend;\n\n\tint count_fls, nsec_fls, frequency_fls, sec_fls;\n\n\tcount_fls = fls64(count);\n\tnsec_fls = fls64(nsec);\n\tfrequency_fls = fls64(frequency);\n\tsec_fls = 30;\n\n\t/*\n\t * We got @count in @nsec, with a target of sample_freq HZ\n\t * the target period becomes:\n\t *\n\t *             @count * 10^9\n\t * period = -------------------\n\t *          @nsec * sample_freq\n\t *\n\t */\n\n\t/*\n\t * Reduce accuracy by one bit such that @a and @b converge\n\t * to a similar magnitude.\n\t */\n#define REDUCE_FLS(a, b)\t\t\\\ndo {\t\t\t\t\t\\\n\tif (a##_fls > b##_fls) {\t\\\n\t\ta >>= 1;\t\t\\\n\t\ta##_fls--;\t\t\\\n\t} else {\t\t\t\\\n\t\tb >>= 1;\t\t\\\n\t\tb##_fls--;\t\t\\\n\t}\t\t\t\t\\\n} while (0)\n\n\t/*\n\t * Reduce accuracy until either term fits in a u64, then proceed with\n\t * the other, so that finally we can do a u64/u64 division.\n\t */\n\twhile (count_fls + sec_fls > 64 && nsec_fls + frequency_fls > 64) {\n\t\tREDUCE_FLS(nsec, frequency);\n\t\tREDUCE_FLS(sec, count);\n\t}\n\n\tif (count_fls + sec_fls > 64) {\n\t\tdivisor = nsec * frequency;\n\n\t\twhile (count_fls + sec_fls > 64) {\n\t\t\tREDUCE_FLS(count, sec);\n\t\t\tdivisor >>= 1;\n\t\t}\n\n\t\tdividend = count * sec;\n\t} else {\n\t\tdividend = count * sec;\n\n\t\twhile (nsec_fls + frequency_fls > 64) {\n\t\t\tREDUCE_FLS(nsec, frequency);\n\t\t\tdividend >>= 1;\n\t\t}\n\n\t\tdivisor = nsec * frequency;\n\t}\n\n\tif (!divisor)\n\t\treturn dividend;\n\n\treturn div64_u64(dividend, divisor);\n}\n\nstatic DEFINE_PER_CPU(int, perf_throttled_count);\nstatic DEFINE_PER_CPU(u64, perf_throttled_seq);\n\nstatic void perf_adjust_period(struct perf_event *event, u64 nsec, u64 count, bool disable)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\ts64 period, sample_period;\n\ts64 delta;\n\n\tperiod = perf_calculate_period(event, nsec, count);\n\n\tdelta = (s64)(period - hwc->sample_period);\n\tdelta = (delta + 7) / 8; /* low pass filter */\n\n\tsample_period = hwc->sample_period + delta;\n\n\tif (!sample_period)\n\t\tsample_period = 1;\n\n\thwc->sample_period = sample_period;\n\n\tif (local64_read(&hwc->period_left) > 8*sample_period) {\n\t\tif (disable)\n\t\t\tevent->pmu->stop(event, PERF_EF_UPDATE);\n\n\t\tlocal64_set(&hwc->period_left, 0);\n\n\t\tif (disable)\n\t\t\tevent->pmu->start(event, PERF_EF_RELOAD);\n\t}\n}\n\n/*\n * combine freq adjustment with unthrottling to avoid two passes over the\n * events. At the same time, make sure, having freq events does not change\n * the rate of unthrottling as that would introduce bias.\n */\nstatic void perf_adjust_freq_unthr_context(struct perf_event_context *ctx,\n\t\t\t\t\t   int needs_unthr)\n{\n\tstruct perf_event *event;\n\tstruct hw_perf_event *hwc;\n\tu64 now, period = TICK_NSEC;\n\ts64 delta;\n\n\t/*\n\t * only need to iterate over all events iff:\n\t * - context have events in frequency mode (needs freq adjust)\n\t * - there are events to unthrottle on this cpu\n\t */\n\tif (!(ctx->nr_freq || needs_unthr))\n\t\treturn;\n\n\traw_spin_lock(&ctx->lock);\n\tperf_pmu_disable(ctx->pmu);\n\n\tlist_for_each_entry_rcu(event, &ctx->event_list, event_entry) {\n\t\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\t\tcontinue;\n\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\n\t\tperf_pmu_disable(event->pmu);\n\n\t\thwc = &event->hw;\n\n\t\tif (hwc->interrupts == MAX_INTERRUPTS) {\n\t\t\thwc->interrupts = 0;\n\t\t\tperf_log_throttle(event, 1);\n\t\t\tevent->pmu->start(event, 0);\n\t\t}\n\n\t\tif (!event->attr.freq || !event->attr.sample_freq)\n\t\t\tgoto next;\n\n\t\t/*\n\t\t * stop the event and update event->count\n\t\t */\n\t\tevent->pmu->stop(event, PERF_EF_UPDATE);\n\n\t\tnow = local64_read(&event->count);\n\t\tdelta = now - hwc->freq_count_stamp;\n\t\thwc->freq_count_stamp = now;\n\n\t\t/*\n\t\t * restart the event\n\t\t * reload only if value has changed\n\t\t * we have stopped the event so tell that\n\t\t * to perf_adjust_period() to avoid stopping it\n\t\t * twice.\n\t\t */\n\t\tif (delta > 0)\n\t\t\tperf_adjust_period(event, period, delta, false);\n\n\t\tevent->pmu->start(event, delta > 0 ? PERF_EF_RELOAD : 0);\n\tnext:\n\t\tperf_pmu_enable(event->pmu);\n\t}\n\n\tperf_pmu_enable(ctx->pmu);\n\traw_spin_unlock(&ctx->lock);\n}\n\n/*\n * Round-robin a context's events:\n */\nstatic void rotate_ctx(struct perf_event_context *ctx)\n{\n\t/*\n\t * Rotate the first entry last of non-pinned groups. Rotation might be\n\t * disabled by the inheritance code.\n\t */\n\tif (!ctx->rotate_disable)\n\t\tlist_rotate_left(&ctx->flexible_groups);\n}\n\nstatic int perf_rotate_context(struct perf_cpu_context *cpuctx)\n{\n\tstruct perf_event_context *ctx = NULL;\n\tint rotate = 0;\n\n\tif (cpuctx->ctx.nr_events) {\n\t\tif (cpuctx->ctx.nr_events != cpuctx->ctx.nr_active)\n\t\t\trotate = 1;\n\t}\n\n\tctx = cpuctx->task_ctx;\n\tif (ctx && ctx->nr_events) {\n\t\tif (ctx->nr_events != ctx->nr_active)\n\t\t\trotate = 1;\n\t}\n\n\tif (!rotate)\n\t\tgoto done;\n\n\tperf_ctx_lock(cpuctx, cpuctx->task_ctx);\n\tperf_pmu_disable(cpuctx->ctx.pmu);\n\n\tcpu_ctx_sched_out(cpuctx, EVENT_FLEXIBLE);\n\tif (ctx)\n\t\tctx_sched_out(ctx, cpuctx, EVENT_FLEXIBLE);\n\n\trotate_ctx(&cpuctx->ctx);\n\tif (ctx)\n\t\trotate_ctx(ctx);\n\n\tperf_event_sched_in(cpuctx, ctx, current);\n\n\tperf_pmu_enable(cpuctx->ctx.pmu);\n\tperf_ctx_unlock(cpuctx, cpuctx->task_ctx);\ndone:\n\n\treturn rotate;\n}\n\nvoid perf_event_task_tick(void)\n{\n\tstruct list_head *head = this_cpu_ptr(&active_ctx_list);\n\tstruct perf_event_context *ctx, *tmp;\n\tint throttled;\n\n\tWARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(perf_throttled_seq);\n\tthrottled = __this_cpu_xchg(perf_throttled_count, 0);\n\ttick_dep_clear_cpu(smp_processor_id(), TICK_DEP_BIT_PERF_EVENTS);\n\n\tlist_for_each_entry_safe(ctx, tmp, head, active_ctx_list)\n\t\tperf_adjust_freq_unthr_context(ctx, throttled);\n}\n\nstatic int event_enable_on_exec(struct perf_event *event,\n\t\t\t\tstruct perf_event_context *ctx)\n{\n\tif (!event->attr.enable_on_exec)\n\t\treturn 0;\n\n\tevent->attr.enable_on_exec = 0;\n\tif (event->state >= PERF_EVENT_STATE_INACTIVE)\n\t\treturn 0;\n\n\t__perf_event_mark_enabled(event);\n\n\treturn 1;\n}\n\n/*\n * Enable all of a task's events that have been marked enable-on-exec.\n * This expects task == current.\n */\nstatic void perf_event_enable_on_exec(int ctxn)\n{\n\tstruct perf_event_context *ctx, *clone_ctx = NULL;\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event *event;\n\tunsigned long flags;\n\tint enabled = 0;\n\n\tlocal_irq_save(flags);\n\tctx = current->perf_event_ctxp[ctxn];\n\tif (!ctx || !ctx->nr_events)\n\t\tgoto out;\n\n\tcpuctx = __get_cpu_context(ctx);\n\tperf_ctx_lock(cpuctx, ctx);\n\tctx_sched_out(ctx, cpuctx, EVENT_TIME);\n\tlist_for_each_entry(event, &ctx->event_list, event_entry)\n\t\tenabled |= event_enable_on_exec(event, ctx);\n\n\t/*\n\t * Unclone and reschedule this context if we enabled any event.\n\t */\n\tif (enabled) {\n\t\tclone_ctx = unclone_ctx(ctx);\n\t\tctx_resched(cpuctx, ctx);\n\t}\n\tperf_ctx_unlock(cpuctx, ctx);\n\nout:\n\tlocal_irq_restore(flags);\n\n\tif (clone_ctx)\n\t\tput_ctx(clone_ctx);\n}\n\nstruct perf_read_data {\n\tstruct perf_event *event;\n\tbool group;\n\tint ret;\n};\n\nstatic int find_cpu_to_read(struct perf_event *event, int local_cpu)\n{\n\tint event_cpu = event->oncpu;\n\tu16 local_pkg, event_pkg;\n\n\tif (event->group_caps & PERF_EV_CAP_READ_ACTIVE_PKG) {\n\t\tevent_pkg =  topology_physical_package_id(event_cpu);\n\t\tlocal_pkg =  topology_physical_package_id(local_cpu);\n\n\t\tif (event_pkg == local_pkg)\n\t\t\treturn local_cpu;\n\t}\n\n\treturn event_cpu;\n}\n\n/*\n * Cross CPU call to read the hardware event\n */\nstatic void __perf_event_read(void *info)\n{\n\tstruct perf_read_data *data = info;\n\tstruct perf_event *sub, *event = data->event;\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\tstruct pmu *pmu = event->pmu;\n\n\t/*\n\t * If this is a task context, we need to check whether it is\n\t * the current task context of this cpu.  If not it has been\n\t * scheduled out before the smp call arrived.  In that case\n\t * event->count would have been updated to a recent sample\n\t * when the event was scheduled out.\n\t */\n\tif (ctx->task && cpuctx->task_ctx != ctx)\n\t\treturn;\n\n\traw_spin_lock(&ctx->lock);\n\tif (ctx->is_active) {\n\t\tupdate_context_time(ctx);\n\t\tupdate_cgrp_time_from_event(event);\n\t}\n\n\tupdate_event_times(event);\n\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\tgoto unlock;\n\n\tif (!data->group) {\n\t\tpmu->read(event);\n\t\tdata->ret = 0;\n\t\tgoto unlock;\n\t}\n\n\tpmu->start_txn(pmu, PERF_PMU_TXN_READ);\n\n\tpmu->read(event);\n\n\tlist_for_each_entry(sub, &event->sibling_list, group_entry) {\n\t\tupdate_event_times(sub);\n\t\tif (sub->state == PERF_EVENT_STATE_ACTIVE) {\n\t\t\t/*\n\t\t\t * Use sibling's PMU rather than @event's since\n\t\t\t * sibling could be on different (eg: software) PMU.\n\t\t\t */\n\t\t\tsub->pmu->read(sub);\n\t\t}\n\t}\n\n\tdata->ret = pmu->commit_txn(pmu);\n\nunlock:\n\traw_spin_unlock(&ctx->lock);\n}\n\nstatic inline u64 perf_event_count(struct perf_event *event)\n{\n\tif (event->pmu->count)\n\t\treturn event->pmu->count(event);\n\n\treturn __perf_event_count(event);\n}\n\n/*\n * NMI-safe method to read a local event, that is an event that\n * is:\n *   - either for the current task, or for this CPU\n *   - does not have inherit set, for inherited task events\n *     will not be local and we cannot read them atomically\n *   - must not have a pmu::count method\n */\nu64 perf_event_read_local(struct perf_event *event)\n{\n\tunsigned long flags;\n\tu64 val;\n\n\t/*\n\t * Disabling interrupts avoids all counter scheduling (context\n\t * switches, timer based rotation and IPIs).\n\t */\n\tlocal_irq_save(flags);\n\n\t/* If this is a per-task event, it must be for current */\n\tWARN_ON_ONCE((event->attach_state & PERF_ATTACH_TASK) &&\n\t\t     event->hw.target != current);\n\n\t/* If this is a per-CPU event, it must be for this CPU */\n\tWARN_ON_ONCE(!(event->attach_state & PERF_ATTACH_TASK) &&\n\t\t     event->cpu != smp_processor_id());\n\n\t/*\n\t * It must not be an event with inherit set, we cannot read\n\t * all child counters from atomic context.\n\t */\n\tWARN_ON_ONCE(event->attr.inherit);\n\n\t/*\n\t * It must not have a pmu::count method, those are not\n\t * NMI safe.\n\t */\n\tWARN_ON_ONCE(event->pmu->count);\n\n\t/*\n\t * If the event is currently on this CPU, its either a per-task event,\n\t * or local to this CPU. Furthermore it means its ACTIVE (otherwise\n\t * oncpu == -1).\n\t */\n\tif (event->oncpu == smp_processor_id())\n\t\tevent->pmu->read(event);\n\n\tval = local64_read(&event->count);\n\tlocal_irq_restore(flags);\n\n\treturn val;\n}\n\nstatic int perf_event_read(struct perf_event *event, bool group)\n{\n\tint ret = 0, cpu_to_read, local_cpu;\n\n\t/*\n\t * If event is enabled and currently active on a CPU, update the\n\t * value in the event structure:\n\t */\n\tif (event->state == PERF_EVENT_STATE_ACTIVE) {\n\t\tstruct perf_read_data data = {\n\t\t\t.event = event,\n\t\t\t.group = group,\n\t\t\t.ret = 0,\n\t\t};\n\n\t\tlocal_cpu = get_cpu();\n\t\tcpu_to_read = find_cpu_to_read(event, local_cpu);\n\t\tput_cpu();\n\n\t\t/*\n\t\t * Purposely ignore the smp_call_function_single() return\n\t\t * value.\n\t\t *\n\t\t * If event->oncpu isn't a valid CPU it means the event got\n\t\t * scheduled out and that will have updated the event count.\n\t\t *\n\t\t * Therefore, either way, we'll have an up-to-date event count\n\t\t * after this.\n\t\t */\n\t\t(void)smp_call_function_single(cpu_to_read, __perf_event_read, &data, 1);\n\t\tret = data.ret;\n\t} else if (event->state == PERF_EVENT_STATE_INACTIVE) {\n\t\tstruct perf_event_context *ctx = event->ctx;\n\t\tunsigned long flags;\n\n\t\traw_spin_lock_irqsave(&ctx->lock, flags);\n\t\t/*\n\t\t * may read while context is not active\n\t\t * (e.g., thread is blocked), in that case\n\t\t * we cannot update context time\n\t\t */\n\t\tif (ctx->is_active) {\n\t\t\tupdate_context_time(ctx);\n\t\t\tupdate_cgrp_time_from_event(event);\n\t\t}\n\t\tif (group)\n\t\t\tupdate_group_times(event);\n\t\telse\n\t\t\tupdate_event_times(event);\n\t\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n\t}\n\n\treturn ret;\n}\n\n/*\n * Initialize the perf_event context in a task_struct:\n */\nstatic void __perf_event_init_context(struct perf_event_context *ctx)\n{\n\traw_spin_lock_init(&ctx->lock);\n\tmutex_init(&ctx->mutex);\n\tINIT_LIST_HEAD(&ctx->active_ctx_list);\n\tINIT_LIST_HEAD(&ctx->pinned_groups);\n\tINIT_LIST_HEAD(&ctx->flexible_groups);\n\tINIT_LIST_HEAD(&ctx->event_list);\n\tatomic_set(&ctx->refcount, 1);\n}\n\nstatic struct perf_event_context *\nalloc_perf_context(struct pmu *pmu, struct task_struct *task)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = kzalloc(sizeof(struct perf_event_context), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\t__perf_event_init_context(ctx);\n\tif (task) {\n\t\tctx->task = task;\n\t\tget_task_struct(task);\n\t}\n\tctx->pmu = pmu;\n\n\treturn ctx;\n}\n\nstatic struct task_struct *\nfind_lively_task_by_vpid(pid_t vpid)\n{\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\tif (!vpid)\n\t\ttask = current;\n\telse\n\t\ttask = find_task_by_vpid(vpid);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\n\tif (!task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\treturn task;\n}\n\n/*\n * Returns a matching context with refcount and pincount.\n */\nstatic struct perf_event_context *\nfind_get_context(struct pmu *pmu, struct task_struct *task,\n\t\tstruct perf_event *event)\n{\n\tstruct perf_event_context *ctx, *clone_ctx = NULL;\n\tstruct perf_cpu_context *cpuctx;\n\tvoid *task_ctx_data = NULL;\n\tunsigned long flags;\n\tint ctxn, err;\n\tint cpu = event->cpu;\n\n\tif (!task) {\n\t\t/* Must be root to operate on a CPU event: */\n\t\tif (perf_paranoid_cpu() && !capable(CAP_SYS_ADMIN))\n\t\t\treturn ERR_PTR(-EACCES);\n\n\t\t/*\n\t\t * We could be clever and allow to attach a event to an\n\t\t * offline CPU and activate it when the CPU comes up, but\n\t\t * that's for later.\n\t\t */\n\t\tif (!cpu_online(cpu))\n\t\t\treturn ERR_PTR(-ENODEV);\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\tctx = &cpuctx->ctx;\n\t\tget_ctx(ctx);\n\t\t++ctx->pin_count;\n\n\t\treturn ctx;\n\t}\n\n\terr = -EINVAL;\n\tctxn = pmu->task_ctx_nr;\n\tif (ctxn < 0)\n\t\tgoto errout;\n\n\tif (event->attach_state & PERF_ATTACH_TASK_DATA) {\n\t\ttask_ctx_data = kzalloc(pmu->task_ctx_size, GFP_KERNEL);\n\t\tif (!task_ctx_data) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\nretry:\n\tctx = perf_lock_task_context(task, ctxn, &flags);\n\tif (ctx) {\n\t\tclone_ctx = unclone_ctx(ctx);\n\t\t++ctx->pin_count;\n\n\t\tif (task_ctx_data && !ctx->task_ctx_data) {\n\t\t\tctx->task_ctx_data = task_ctx_data;\n\t\t\ttask_ctx_data = NULL;\n\t\t}\n\t\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n\n\t\tif (clone_ctx)\n\t\t\tput_ctx(clone_ctx);\n\t} else {\n\t\tctx = alloc_perf_context(pmu, task);\n\t\terr = -ENOMEM;\n\t\tif (!ctx)\n\t\t\tgoto errout;\n\n\t\tif (task_ctx_data) {\n\t\t\tctx->task_ctx_data = task_ctx_data;\n\t\t\ttask_ctx_data = NULL;\n\t\t}\n\n\t\terr = 0;\n\t\tmutex_lock(&task->perf_event_mutex);\n\t\t/*\n\t\t * If it has already passed perf_event_exit_task().\n\t\t * we must see PF_EXITING, it takes this mutex too.\n\t\t */\n\t\tif (task->flags & PF_EXITING)\n\t\t\terr = -ESRCH;\n\t\telse if (task->perf_event_ctxp[ctxn])\n\t\t\terr = -EAGAIN;\n\t\telse {\n\t\t\tget_ctx(ctx);\n\t\t\t++ctx->pin_count;\n\t\t\trcu_assign_pointer(task->perf_event_ctxp[ctxn], ctx);\n\t\t}\n\t\tmutex_unlock(&task->perf_event_mutex);\n\n\t\tif (unlikely(err)) {\n\t\t\tput_ctx(ctx);\n\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto retry;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tkfree(task_ctx_data);\n\treturn ctx;\n\nerrout:\n\tkfree(task_ctx_data);\n\treturn ERR_PTR(err);\n}\n\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\n\nstatic void free_event_rcu(struct rcu_head *head)\n{\n\tstruct perf_event *event;\n\n\tevent = container_of(head, struct perf_event, rcu_head);\n\tif (event->ns)\n\t\tput_pid_ns(event->ns);\n\tperf_event_free_filter(event);\n\tkfree(event);\n}\n\nstatic void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct ring_buffer *rb);\n\nstatic void detach_sb_event(struct perf_event *event)\n{\n\tstruct pmu_event_list *pel = per_cpu_ptr(&pmu_sb_events, event->cpu);\n\n\traw_spin_lock(&pel->lock);\n\tlist_del_rcu(&event->sb_list);\n\traw_spin_unlock(&pel->lock);\n}\n\nstatic bool is_sb_event(struct perf_event *event)\n{\n\tstruct perf_event_attr *attr = &event->attr;\n\n\tif (event->parent)\n\t\treturn false;\n\n\tif (event->attach_state & PERF_ATTACH_TASK)\n\t\treturn false;\n\n\tif (attr->mmap || attr->mmap_data || attr->mmap2 ||\n\t    attr->comm || attr->comm_exec ||\n\t    attr->task ||\n\t    attr->context_switch)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void unaccount_pmu_sb_event(struct perf_event *event)\n{\n\tif (is_sb_event(event))\n\t\tdetach_sb_event(event);\n}\n\nstatic void unaccount_event_cpu(struct perf_event *event, int cpu)\n{\n\tif (event->parent)\n\t\treturn;\n\n\tif (is_cgroup_event(event))\n\t\tatomic_dec(&per_cpu(perf_cgroup_events, cpu));\n}\n\n#ifdef CONFIG_NO_HZ_FULL\nstatic DEFINE_SPINLOCK(nr_freq_lock);\n#endif\n\nstatic void unaccount_freq_event_nohz(void)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tspin_lock(&nr_freq_lock);\n\tif (atomic_dec_and_test(&nr_freq_events))\n\t\ttick_nohz_dep_clear(TICK_DEP_BIT_PERF_EVENTS);\n\tspin_unlock(&nr_freq_lock);\n#endif\n}\n\nstatic void unaccount_freq_event(void)\n{\n\tif (tick_nohz_full_enabled())\n\t\tunaccount_freq_event_nohz();\n\telse\n\t\tatomic_dec(&nr_freq_events);\n}\n\nstatic void unaccount_event(struct perf_event *event)\n{\n\tbool dec = false;\n\n\tif (event->parent)\n\t\treturn;\n\n\tif (event->attach_state & PERF_ATTACH_TASK)\n\t\tdec = true;\n\tif (event->attr.mmap || event->attr.mmap_data)\n\t\tatomic_dec(&nr_mmap_events);\n\tif (event->attr.comm)\n\t\tatomic_dec(&nr_comm_events);\n\tif (event->attr.task)\n\t\tatomic_dec(&nr_task_events);\n\tif (event->attr.freq)\n\t\tunaccount_freq_event();\n\tif (event->attr.context_switch) {\n\t\tdec = true;\n\t\tatomic_dec(&nr_switch_events);\n\t}\n\tif (is_cgroup_event(event))\n\t\tdec = true;\n\tif (has_branch_stack(event))\n\t\tdec = true;\n\n\tif (dec) {\n\t\tif (!atomic_add_unless(&perf_sched_count, -1, 1))\n\t\t\tschedule_delayed_work(&perf_sched_work, HZ);\n\t}\n\n\tunaccount_event_cpu(event, event->cpu);\n\n\tunaccount_pmu_sb_event(event);\n}\n\nstatic void perf_sched_delayed(struct work_struct *work)\n{\n\tmutex_lock(&perf_sched_mutex);\n\tif (atomic_dec_and_test(&perf_sched_count))\n\t\tstatic_branch_disable(&perf_sched_events);\n\tmutex_unlock(&perf_sched_mutex);\n}\n\n/*\n * The following implement mutual exclusion of events on \"exclusive\" pmus\n * (PERF_PMU_CAP_EXCLUSIVE). Such pmus can only have one event scheduled\n * at a time, so we disallow creating events that might conflict, namely:\n *\n *  1) cpu-wide events in the presence of per-task events,\n *  2) per-task events in the presence of cpu-wide events,\n *  3) two matching events on the same context.\n *\n * The former two cases are handled in the allocation path (perf_event_alloc(),\n * _free_event()), the latter -- before the first perf_install_in_context().\n */\nstatic int exclusive_event_init(struct perf_event *event)\n{\n\tstruct pmu *pmu = event->pmu;\n\n\tif (!(pmu->capabilities & PERF_PMU_CAP_EXCLUSIVE))\n\t\treturn 0;\n\n\t/*\n\t * Prevent co-existence of per-task and cpu-wide events on the\n\t * same exclusive pmu.\n\t *\n\t * Negative pmu::exclusive_cnt means there are cpu-wide\n\t * events on this \"exclusive\" pmu, positive means there are\n\t * per-task events.\n\t *\n\t * Since this is called in perf_event_alloc() path, event::ctx\n\t * doesn't exist yet; it is, however, safe to use PERF_ATTACH_TASK\n\t * to mean \"per-task event\", because unlike other attach states it\n\t * never gets cleared.\n\t */\n\tif (event->attach_state & PERF_ATTACH_TASK) {\n\t\tif (!atomic_inc_unless_negative(&pmu->exclusive_cnt))\n\t\t\treturn -EBUSY;\n\t} else {\n\t\tif (!atomic_dec_unless_positive(&pmu->exclusive_cnt))\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic void exclusive_event_destroy(struct perf_event *event)\n{\n\tstruct pmu *pmu = event->pmu;\n\n\tif (!(pmu->capabilities & PERF_PMU_CAP_EXCLUSIVE))\n\t\treturn;\n\n\t/* see comment in exclusive_event_init() */\n\tif (event->attach_state & PERF_ATTACH_TASK)\n\t\tatomic_dec(&pmu->exclusive_cnt);\n\telse\n\t\tatomic_inc(&pmu->exclusive_cnt);\n}\n\nstatic bool exclusive_event_match(struct perf_event *e1, struct perf_event *e2)\n{\n\tif ((e1->pmu == e2->pmu) &&\n\t    (e1->cpu == e2->cpu ||\n\t     e1->cpu == -1 ||\n\t     e2->cpu == -1))\n\t\treturn true;\n\treturn false;\n}\n\n/* Called under the same ctx::mutex as perf_install_in_context() */\nstatic bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx)\n{\n\tstruct perf_event *iter_event;\n\tstruct pmu *pmu = event->pmu;\n\n\tif (!(pmu->capabilities & PERF_PMU_CAP_EXCLUSIVE))\n\t\treturn true;\n\n\tlist_for_each_entry(iter_event, &ctx->event_list, event_entry) {\n\t\tif (exclusive_event_match(iter_event, event))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void perf_addr_filters_splice(struct perf_event *event,\n\t\t\t\t       struct list_head *head);\n\nstatic void _free_event(struct perf_event *event)\n{\n\tirq_work_sync(&event->pending);\n\n\tunaccount_event(event);\n\n\tif (event->rb) {\n\t\t/*\n\t\t * Can happen when we close an event with re-directed output.\n\t\t *\n\t\t * Since we have a 0 refcount, perf_mmap_close() will skip\n\t\t * over us; possibly making our ring_buffer_put() the last.\n\t\t */\n\t\tmutex_lock(&event->mmap_mutex);\n\t\tring_buffer_attach(event, NULL);\n\t\tmutex_unlock(&event->mmap_mutex);\n\t}\n\n\tif (is_cgroup_event(event))\n\t\tperf_detach_cgroup(event);\n\n\tif (!event->parent) {\n\t\tif (event->attr.sample_type & PERF_SAMPLE_CALLCHAIN)\n\t\t\tput_callchain_buffers();\n\t}\n\n\tperf_event_free_bpf_prog(event);\n\tperf_addr_filters_splice(event, NULL);\n\tkfree(event->addr_filters_offs);\n\n\tif (event->destroy)\n\t\tevent->destroy(event);\n\n\tif (event->ctx)\n\t\tput_ctx(event->ctx);\n\n\texclusive_event_destroy(event);\n\tmodule_put(event->pmu->module);\n\n\tcall_rcu(&event->rcu_head, free_event_rcu);\n}\n\n/*\n * Used to free events which have a known refcount of 1, such as in error paths\n * where the event isn't exposed yet and inherited events.\n */\nstatic void free_event(struct perf_event *event)\n{\n\tif (WARN(atomic_long_cmpxchg(&event->refcount, 1, 0) != 1,\n\t\t\t\t\"unexpected event refcount: %ld; ptr=%p\\n\",\n\t\t\t\tatomic_long_read(&event->refcount), event)) {\n\t\t/* leak to avoid use-after-free */\n\t\treturn;\n\t}\n\n\t_free_event(event);\n}\n\n/*\n * Remove user event from the owner task.\n */\nstatic void perf_remove_from_owner(struct perf_event *event)\n{\n\tstruct task_struct *owner;\n\n\trcu_read_lock();\n\t/*\n\t * Matches the smp_store_release() in perf_event_exit_task(). If we\n\t * observe !owner it means the list deletion is complete and we can\n\t * indeed free this event, otherwise we need to serialize on\n\t * owner->perf_event_mutex.\n\t */\n\towner = lockless_dereference(event->owner);\n\tif (owner) {\n\t\t/*\n\t\t * Since delayed_put_task_struct() also drops the last\n\t\t * task reference we can safely take a new reference\n\t\t * while holding the rcu_read_lock().\n\t\t */\n\t\tget_task_struct(owner);\n\t}\n\trcu_read_unlock();\n\n\tif (owner) {\n\t\t/*\n\t\t * If we're here through perf_event_exit_task() we're already\n\t\t * holding ctx->mutex which would be an inversion wrt. the\n\t\t * normal lock order.\n\t\t *\n\t\t * However we can safely take this lock because its the child\n\t\t * ctx->mutex.\n\t\t */\n\t\tmutex_lock_nested(&owner->perf_event_mutex, SINGLE_DEPTH_NESTING);\n\n\t\t/*\n\t\t * We have to re-check the event->owner field, if it is cleared\n\t\t * we raced with perf_event_exit_task(), acquiring the mutex\n\t\t * ensured they're done, and we can proceed with freeing the\n\t\t * event.\n\t\t */\n\t\tif (event->owner) {\n\t\t\tlist_del_init(&event->owner_entry);\n\t\t\tsmp_store_release(&event->owner, NULL);\n\t\t}\n\t\tmutex_unlock(&owner->perf_event_mutex);\n\t\tput_task_struct(owner);\n\t}\n}\n\nstatic void put_event(struct perf_event *event)\n{\n\tif (!atomic_long_dec_and_test(&event->refcount))\n\t\treturn;\n\n\t_free_event(event);\n}\n\n/*\n * Kill an event dead; while event:refcount will preserve the event\n * object, it will not preserve its functionality. Once the last 'user'\n * gives up the object, we'll destroy the thing.\n */\nint perf_event_release_kernel(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_event *child, *tmp;\n\n\t/*\n\t * If we got here through err_file: fput(event_file); we will not have\n\t * attached to a context yet.\n\t */\n\tif (!ctx) {\n\t\tWARN_ON_ONCE(event->attach_state &\n\t\t\t\t(PERF_ATTACH_CONTEXT|PERF_ATTACH_GROUP));\n\t\tgoto no_ctx;\n\t}\n\n\tif (!is_kernel_event(event))\n\t\tperf_remove_from_owner(event);\n\n\tctx = perf_event_ctx_lock(event);\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tperf_remove_from_context(event, DETACH_GROUP);\n\n\traw_spin_lock_irq(&ctx->lock);\n\t/*\n\t * Mark this even as STATE_DEAD, there is no external reference to it\n\t * anymore.\n\t *\n\t * Anybody acquiring event->child_mutex after the below loop _must_\n\t * also see this, most importantly inherit_event() which will avoid\n\t * placing more children on the list.\n\t *\n\t * Thus this guarantees that we will in fact observe and kill _ALL_\n\t * child events.\n\t */\n\tevent->state = PERF_EVENT_STATE_DEAD;\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tperf_event_ctx_unlock(event, ctx);\n\nagain:\n\tmutex_lock(&event->child_mutex);\n\tlist_for_each_entry(child, &event->child_list, child_list) {\n\n\t\t/*\n\t\t * Cannot change, child events are not migrated, see the\n\t\t * comment with perf_event_ctx_lock_nested().\n\t\t */\n\t\tctx = lockless_dereference(child->ctx);\n\t\t/*\n\t\t * Since child_mutex nests inside ctx::mutex, we must jump\n\t\t * through hoops. We start by grabbing a reference on the ctx.\n\t\t *\n\t\t * Since the event cannot get freed while we hold the\n\t\t * child_mutex, the context must also exist and have a !0\n\t\t * reference count.\n\t\t */\n\t\tget_ctx(ctx);\n\n\t\t/*\n\t\t * Now that we have a ctx ref, we can drop child_mutex, and\n\t\t * acquire ctx::mutex without fear of it going away. Then we\n\t\t * can re-acquire child_mutex.\n\t\t */\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_lock(&ctx->mutex);\n\t\tmutex_lock(&event->child_mutex);\n\n\t\t/*\n\t\t * Now that we hold ctx::mutex and child_mutex, revalidate our\n\t\t * state, if child is still the first entry, it didn't get freed\n\t\t * and we can continue doing so.\n\t\t */\n\t\ttmp = list_first_entry_or_null(&event->child_list,\n\t\t\t\t\t       struct perf_event, child_list);\n\t\tif (tmp == child) {\n\t\t\tperf_remove_from_context(child, DETACH_GROUP);\n\t\t\tlist_del(&child->child_list);\n\t\t\tfree_event(child);\n\t\t\t/*\n\t\t\t * This matches the refcount bump in inherit_event();\n\t\t\t * this can't be the last reference.\n\t\t\t */\n\t\t\tput_event(event);\n\t\t}\n\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_unlock(&ctx->mutex);\n\t\tput_ctx(ctx);\n\t\tgoto again;\n\t}\n\tmutex_unlock(&event->child_mutex);\n\nno_ctx:\n\tput_event(event); /* Must be the 'last' reference */\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(perf_event_release_kernel);\n\n/*\n * Called when the last reference to the file is gone.\n */\nstatic int perf_release(struct inode *inode, struct file *file)\n{\n\tperf_event_release_kernel(file->private_data);\n\treturn 0;\n}\n\nu64 perf_event_read_value(struct perf_event *event, u64 *enabled, u64 *running)\n{\n\tstruct perf_event *child;\n\tu64 total = 0;\n\n\t*enabled = 0;\n\t*running = 0;\n\n\tmutex_lock(&event->child_mutex);\n\n\t(void)perf_event_read(event, false);\n\ttotal += perf_event_count(event);\n\n\t*enabled += event->total_time_enabled +\n\t\t\tatomic64_read(&event->child_total_time_enabled);\n\t*running += event->total_time_running +\n\t\t\tatomic64_read(&event->child_total_time_running);\n\n\tlist_for_each_entry(child, &event->child_list, child_list) {\n\t\t(void)perf_event_read(child, false);\n\t\ttotal += perf_event_count(child);\n\t\t*enabled += child->total_time_enabled;\n\t\t*running += child->total_time_running;\n\t}\n\tmutex_unlock(&event->child_mutex);\n\n\treturn total;\n}\nEXPORT_SYMBOL_GPL(perf_event_read_value);\n\nstatic int __perf_read_group_add(struct perf_event *leader,\n\t\t\t\t\tu64 read_format, u64 *values)\n{\n\tstruct perf_event *sub;\n\tint n = 1; /* skip @nr */\n\tint ret;\n\n\tret = perf_event_read(leader, true);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Since we co-schedule groups, {enabled,running} times of siblings\n\t * will be identical to those of the leader, so we only publish one\n\t * set.\n\t */\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED) {\n\t\tvalues[n++] += leader->total_time_enabled +\n\t\t\tatomic64_read(&leader->child_total_time_enabled);\n\t}\n\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING) {\n\t\tvalues[n++] += leader->total_time_running +\n\t\t\tatomic64_read(&leader->child_total_time_running);\n\t}\n\n\t/*\n\t * Write {count,id} tuples for every sibling.\n\t */\n\tvalues[n++] += perf_event_count(leader);\n\tif (read_format & PERF_FORMAT_ID)\n\t\tvalues[n++] = primary_event_id(leader);\n\n\tlist_for_each_entry(sub, &leader->sibling_list, group_entry) {\n\t\tvalues[n++] += perf_event_count(sub);\n\t\tif (read_format & PERF_FORMAT_ID)\n\t\t\tvalues[n++] = primary_event_id(sub);\n\t}\n\n\treturn 0;\n}\n\nstatic int perf_read_group(struct perf_event *event,\n\t\t\t\t   u64 read_format, char __user *buf)\n{\n\tstruct perf_event *leader = event->group_leader, *child;\n\tstruct perf_event_context *ctx = leader->ctx;\n\tint ret;\n\tu64 *values;\n\n\tlockdep_assert_held(&ctx->mutex);\n\n\tvalues = kzalloc(event->read_size, GFP_KERNEL);\n\tif (!values)\n\t\treturn -ENOMEM;\n\n\tvalues[0] = 1 + leader->nr_siblings;\n\n\t/*\n\t * By locking the child_mutex of the leader we effectively\n\t * lock the child list of all siblings.. XXX explain how.\n\t */\n\tmutex_lock(&leader->child_mutex);\n\n\tret = __perf_read_group_add(leader, read_format, values);\n\tif (ret)\n\t\tgoto unlock;\n\n\tlist_for_each_entry(child, &leader->child_list, child_list) {\n\t\tret = __perf_read_group_add(child, read_format, values);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tmutex_unlock(&leader->child_mutex);\n\n\tret = event->read_size;\n\tif (copy_to_user(buf, values, event->read_size))\n\t\tret = -EFAULT;\n\tgoto out;\n\nunlock:\n\tmutex_unlock(&leader->child_mutex);\nout:\n\tkfree(values);\n\treturn ret;\n}\n\nstatic int perf_read_one(struct perf_event *event,\n\t\t\t\t u64 read_format, char __user *buf)\n{\n\tu64 enabled, running;\n\tu64 values[4];\n\tint n = 0;\n\n\tvalues[n++] = perf_event_read_value(event, &enabled, &running);\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)\n\t\tvalues[n++] = enabled;\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)\n\t\tvalues[n++] = running;\n\tif (read_format & PERF_FORMAT_ID)\n\t\tvalues[n++] = primary_event_id(event);\n\n\tif (copy_to_user(buf, values, n * sizeof(u64)))\n\t\treturn -EFAULT;\n\n\treturn n * sizeof(u64);\n}\n\nstatic bool is_event_hup(struct perf_event *event)\n{\n\tbool no_children;\n\n\tif (event->state > PERF_EVENT_STATE_EXIT)\n\t\treturn false;\n\n\tmutex_lock(&event->child_mutex);\n\tno_children = list_empty(&event->child_list);\n\tmutex_unlock(&event->child_mutex);\n\treturn no_children;\n}\n\n/*\n * Read the performance event - simple non blocking version for now\n */\nstatic ssize_t\n__perf_read(struct perf_event *event, char __user *buf, size_t count)\n{\n\tu64 read_format = event->attr.read_format;\n\tint ret;\n\n\t/*\n\t * Return end-of-file for a read on a event that is in\n\t * error state (i.e. because it was pinned but it couldn't be\n\t * scheduled on to the CPU at some point).\n\t */\n\tif (event->state == PERF_EVENT_STATE_ERROR)\n\t\treturn 0;\n\n\tif (count < event->read_size)\n\t\treturn -ENOSPC;\n\n\tWARN_ON_ONCE(event->ctx->parent_ctx);\n\tif (read_format & PERF_FORMAT_GROUP)\n\t\tret = perf_read_group(event, read_format, buf);\n\telse\n\t\tret = perf_read_one(event, read_format, buf);\n\n\treturn ret;\n}\n\nstatic ssize_t\nperf_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct perf_event *event = file->private_data;\n\tstruct perf_event_context *ctx;\n\tint ret;\n\n\tctx = perf_event_ctx_lock(event);\n\tret = __perf_read(event, buf, count);\n\tperf_event_ctx_unlock(event, ctx);\n\n\treturn ret;\n}\n\nstatic unsigned int perf_poll(struct file *file, poll_table *wait)\n{\n\tstruct perf_event *event = file->private_data;\n\tstruct ring_buffer *rb;\n\tunsigned int events = POLLHUP;\n\n\tpoll_wait(file, &event->waitq, wait);\n\n\tif (is_event_hup(event))\n\t\treturn events;\n\n\t/*\n\t * Pin the event->rb by taking event->mmap_mutex; otherwise\n\t * perf_event_set_output() can swizzle our rb and make us miss wakeups.\n\t */\n\tmutex_lock(&event->mmap_mutex);\n\trb = event->rb;\n\tif (rb)\n\t\tevents = atomic_xchg(&rb->poll, 0);\n\tmutex_unlock(&event->mmap_mutex);\n\treturn events;\n}\n\nstatic void _perf_event_reset(struct perf_event *event)\n{\n\t(void)perf_event_read(event, false);\n\tlocal64_set(&event->count, 0);\n\tperf_event_update_userpage(event);\n}\n\n/*\n * Holding the top-level event's child_mutex means that any\n * descendant process that has inherited this event will block\n * in perf_event_exit_event() if it goes to exit, thus satisfying the\n * task existence requirements of perf_event_enable/disable.\n */\nstatic void perf_event_for_each_child(struct perf_event *event,\n\t\t\t\t\tvoid (*func)(struct perf_event *))\n{\n\tstruct perf_event *child;\n\n\tWARN_ON_ONCE(event->ctx->parent_ctx);\n\n\tmutex_lock(&event->child_mutex);\n\tfunc(event);\n\tlist_for_each_entry(child, &event->child_list, child_list)\n\t\tfunc(child);\n\tmutex_unlock(&event->child_mutex);\n}\n\nstatic void perf_event_for_each(struct perf_event *event,\n\t\t\t\t  void (*func)(struct perf_event *))\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_event *sibling;\n\n\tlockdep_assert_held(&ctx->mutex);\n\n\tevent = event->group_leader;\n\n\tperf_event_for_each_child(event, func);\n\tlist_for_each_entry(sibling, &event->sibling_list, group_entry)\n\t\tperf_event_for_each_child(sibling, func);\n}\n\nstatic void __perf_event_period(struct perf_event *event,\n\t\t\t\tstruct perf_cpu_context *cpuctx,\n\t\t\t\tstruct perf_event_context *ctx,\n\t\t\t\tvoid *info)\n{\n\tu64 value = *((u64 *)info);\n\tbool active;\n\n\tif (event->attr.freq) {\n\t\tevent->attr.sample_freq = value;\n\t} else {\n\t\tevent->attr.sample_period = value;\n\t\tevent->hw.sample_period = value;\n\t}\n\n\tactive = (event->state == PERF_EVENT_STATE_ACTIVE);\n\tif (active) {\n\t\tperf_pmu_disable(ctx->pmu);\n\t\t/*\n\t\t * We could be throttled; unthrottle now to avoid the tick\n\t\t * trying to unthrottle while we already re-started the event.\n\t\t */\n\t\tif (event->hw.interrupts == MAX_INTERRUPTS) {\n\t\t\tevent->hw.interrupts = 0;\n\t\t\tperf_log_throttle(event, 1);\n\t\t}\n\t\tevent->pmu->stop(event, PERF_EF_UPDATE);\n\t}\n\n\tlocal64_set(&event->hw.period_left, 0);\n\n\tif (active) {\n\t\tevent->pmu->start(event, PERF_EF_RELOAD);\n\t\tperf_pmu_enable(ctx->pmu);\n\t}\n}\n\nstatic int perf_event_period(struct perf_event *event, u64 __user *arg)\n{\n\tu64 value;\n\n\tif (!is_sampling_event(event))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&value, arg, sizeof(value)))\n\t\treturn -EFAULT;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\n\tif (event->attr.freq && value > sysctl_perf_event_sample_rate)\n\t\treturn -EINVAL;\n\n\tevent_function_call(event, __perf_event_period, &value);\n\n\treturn 0;\n}\n\nstatic const struct file_operations perf_fops;\n\nstatic inline int perf_fget_light(int fd, struct fd *p)\n{\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tif (f.file->f_op != &perf_fops) {\n\t\tfdput(f);\n\t\treturn -EBADF;\n\t}\n\t*p = f;\n\treturn 0;\n}\n\nstatic int perf_event_set_output(struct perf_event *event,\n\t\t\t\t struct perf_event *output_event);\nstatic int perf_event_set_filter(struct perf_event *event, void __user *arg);\nstatic int perf_event_set_bpf_prog(struct perf_event *event, u32 prog_fd);\n\nstatic long _perf_ioctl(struct perf_event *event, unsigned int cmd, unsigned long arg)\n{\n\tvoid (*func)(struct perf_event *);\n\tu32 flags = arg;\n\n\tswitch (cmd) {\n\tcase PERF_EVENT_IOC_ENABLE:\n\t\tfunc = _perf_event_enable;\n\t\tbreak;\n\tcase PERF_EVENT_IOC_DISABLE:\n\t\tfunc = _perf_event_disable;\n\t\tbreak;\n\tcase PERF_EVENT_IOC_RESET:\n\t\tfunc = _perf_event_reset;\n\t\tbreak;\n\n\tcase PERF_EVENT_IOC_REFRESH:\n\t\treturn _perf_event_refresh(event, arg);\n\n\tcase PERF_EVENT_IOC_PERIOD:\n\t\treturn perf_event_period(event, (u64 __user *)arg);\n\n\tcase PERF_EVENT_IOC_ID:\n\t{\n\t\tu64 id = primary_event_id(event);\n\n\t\tif (copy_to_user((void __user *)arg, &id, sizeof(id)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_OUTPUT:\n\t{\n\t\tint ret;\n\t\tif (arg != -1) {\n\t\t\tstruct perf_event *output_event;\n\t\t\tstruct fd output;\n\t\t\tret = perf_fget_light(arg, &output);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\toutput_event = output.file->private_data;\n\t\t\tret = perf_event_set_output(event, output_event);\n\t\t\tfdput(output);\n\t\t} else {\n\t\t\tret = perf_event_set_output(event, NULL);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_FILTER:\n\t\treturn perf_event_set_filter(event, (void __user *)arg);\n\n\tcase PERF_EVENT_IOC_SET_BPF:\n\t\treturn perf_event_set_bpf_prog(event, arg);\n\n\tcase PERF_EVENT_IOC_PAUSE_OUTPUT: {\n\t\tstruct ring_buffer *rb;\n\n\t\trcu_read_lock();\n\t\trb = rcu_dereference(event->rb);\n\t\tif (!rb || !rb->nr_pages) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trb_toggle_paused(rb, !!arg);\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tif (flags & PERF_IOC_FLAG_GROUP)\n\t\tperf_event_for_each(event, func);\n\telse\n\t\tperf_event_for_each_child(event, func);\n\n\treturn 0;\n}\n\nstatic long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct perf_event *event = file->private_data;\n\tstruct perf_event_context *ctx;\n\tlong ret;\n\n\tctx = perf_event_ctx_lock(event);\n\tret = _perf_ioctl(event, cmd, arg);\n\tperf_event_ctx_unlock(event, ctx);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long perf_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tswitch (_IOC_NR(cmd)) {\n\tcase _IOC_NR(PERF_EVENT_IOC_SET_FILTER):\n\tcase _IOC_NR(PERF_EVENT_IOC_ID):\n\t\t/* Fix up pointer size (usually 4 -> 8 in 32-on-64-bit case */\n\t\tif (_IOC_SIZE(cmd) == sizeof(compat_uptr_t)) {\n\t\t\tcmd &= ~IOCSIZE_MASK;\n\t\t\tcmd |= sizeof(void *) << IOCSIZE_SHIFT;\n\t\t}\n\t\tbreak;\n\t}\n\treturn perf_ioctl(file, cmd, arg);\n}\n#else\n# define perf_compat_ioctl NULL\n#endif\n\nint perf_event_task_enable(void)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\n\tmutex_lock(&current->perf_event_mutex);\n\tlist_for_each_entry(event, &current->perf_event_list, owner_entry) {\n\t\tctx = perf_event_ctx_lock(event);\n\t\tperf_event_for_each_child(event, _perf_event_enable);\n\t\tperf_event_ctx_unlock(event, ctx);\n\t}\n\tmutex_unlock(&current->perf_event_mutex);\n\n\treturn 0;\n}\n\nint perf_event_task_disable(void)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\n\tmutex_lock(&current->perf_event_mutex);\n\tlist_for_each_entry(event, &current->perf_event_list, owner_entry) {\n\t\tctx = perf_event_ctx_lock(event);\n\t\tperf_event_for_each_child(event, _perf_event_disable);\n\t\tperf_event_ctx_unlock(event, ctx);\n\t}\n\tmutex_unlock(&current->perf_event_mutex);\n\n\treturn 0;\n}\n\nstatic int perf_event_index(struct perf_event *event)\n{\n\tif (event->hw.state & PERF_HES_STOPPED)\n\t\treturn 0;\n\n\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\treturn 0;\n\n\treturn event->pmu->event_idx(event);\n}\n\nstatic void calc_timer_values(struct perf_event *event,\n\t\t\t\tu64 *now,\n\t\t\t\tu64 *enabled,\n\t\t\t\tu64 *running)\n{\n\tu64 ctx_time;\n\n\t*now = perf_clock();\n\tctx_time = event->shadow_ctx_time + *now;\n\t*enabled = ctx_time - event->tstamp_enabled;\n\t*running = ctx_time - event->tstamp_running;\n}\n\nstatic void perf_event_init_userpage(struct perf_event *event)\n{\n\tstruct perf_event_mmap_page *userpg;\n\tstruct ring_buffer *rb;\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (!rb)\n\t\tgoto unlock;\n\n\tuserpg = rb->user_page;\n\n\t/* Allow new userspace to detect that bit 0 is deprecated */\n\tuserpg->cap_bit0_is_deprecated = 1;\n\tuserpg->size = offsetof(struct perf_event_mmap_page, __reserved);\n\tuserpg->data_offset = PAGE_SIZE;\n\tuserpg->data_size = perf_data_size(rb);\n\nunlock:\n\trcu_read_unlock();\n}\n\nvoid __weak arch_perf_update_userpage(\n\tstruct perf_event *event, struct perf_event_mmap_page *userpg, u64 now)\n{\n}\n\n/*\n * Callers need to ensure there can be no nesting of this function, otherwise\n * the seqlock logic goes bad. We can not serialize this because the arch\n * code calls this from NMI context.\n */\nvoid perf_event_update_userpage(struct perf_event *event)\n{\n\tstruct perf_event_mmap_page *userpg;\n\tstruct ring_buffer *rb;\n\tu64 enabled, running, now;\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (!rb)\n\t\tgoto unlock;\n\n\t/*\n\t * compute total_time_enabled, total_time_running\n\t * based on snapshot values taken when the event\n\t * was last scheduled in.\n\t *\n\t * we cannot simply called update_context_time()\n\t * because of locking issue as we can be called in\n\t * NMI context\n\t */\n\tcalc_timer_values(event, &now, &enabled, &running);\n\n\tuserpg = rb->user_page;\n\t/*\n\t * Disable preemption so as to not let the corresponding user-space\n\t * spin too long if we get preempted.\n\t */\n\tpreempt_disable();\n\t++userpg->lock;\n\tbarrier();\n\tuserpg->index = perf_event_index(event);\n\tuserpg->offset = perf_event_count(event);\n\tif (userpg->index)\n\t\tuserpg->offset -= local64_read(&event->hw.prev_count);\n\n\tuserpg->time_enabled = enabled +\n\t\t\tatomic64_read(&event->child_total_time_enabled);\n\n\tuserpg->time_running = running +\n\t\t\tatomic64_read(&event->child_total_time_running);\n\n\tarch_perf_update_userpage(event, userpg, now);\n\n\tbarrier();\n\t++userpg->lock;\n\tpreempt_enable();\nunlock:\n\trcu_read_unlock();\n}\n\nstatic int perf_mmap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct perf_event *event = vma->vm_file->private_data;\n\tstruct ring_buffer *rb;\n\tint ret = VM_FAULT_SIGBUS;\n\n\tif (vmf->flags & FAULT_FLAG_MKWRITE) {\n\t\tif (vmf->pgoff == 0)\n\t\t\tret = 0;\n\t\treturn ret;\n\t}\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (!rb)\n\t\tgoto unlock;\n\n\tif (vmf->pgoff && (vmf->flags & FAULT_FLAG_WRITE))\n\t\tgoto unlock;\n\n\tvmf->page = perf_mmap_to_page(rb, vmf->pgoff);\n\tif (!vmf->page)\n\t\tgoto unlock;\n\n\tget_page(vmf->page);\n\tvmf->page->mapping = vma->vm_file->f_mapping;\n\tvmf->page->index   = vmf->pgoff;\n\n\tret = 0;\nunlock:\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct ring_buffer *rb)\n{\n\tstruct ring_buffer *old_rb = NULL;\n\tunsigned long flags;\n\n\tif (event->rb) {\n\t\t/*\n\t\t * Should be impossible, we set this when removing\n\t\t * event->rb_entry and wait/clear when adding event->rb_entry.\n\t\t */\n\t\tWARN_ON_ONCE(event->rcu_pending);\n\n\t\told_rb = event->rb;\n\t\tspin_lock_irqsave(&old_rb->event_lock, flags);\n\t\tlist_del_rcu(&event->rb_entry);\n\t\tspin_unlock_irqrestore(&old_rb->event_lock, flags);\n\n\t\tevent->rcu_batches = get_state_synchronize_rcu();\n\t\tevent->rcu_pending = 1;\n\t}\n\n\tif (rb) {\n\t\tif (event->rcu_pending) {\n\t\t\tcond_synchronize_rcu(event->rcu_batches);\n\t\t\tevent->rcu_pending = 0;\n\t\t}\n\n\t\tspin_lock_irqsave(&rb->event_lock, flags);\n\t\tlist_add_rcu(&event->rb_entry, &rb->event_list);\n\t\tspin_unlock_irqrestore(&rb->event_lock, flags);\n\t}\n\n\t/*\n\t * Avoid racing with perf_mmap_close(AUX): stop the event\n\t * before swizzling the event::rb pointer; if it's getting\n\t * unmapped, its aux_mmap_count will be 0 and it won't\n\t * restart. See the comment in __perf_pmu_output_stop().\n\t *\n\t * Data will inevitably be lost when set_output is done in\n\t * mid-air, but then again, whoever does it like this is\n\t * not in for the data anyway.\n\t */\n\tif (has_aux(event))\n\t\tperf_event_stop(event, 0);\n\n\trcu_assign_pointer(event->rb, rb);\n\n\tif (old_rb) {\n\t\tring_buffer_put(old_rb);\n\t\t/*\n\t\t * Since we detached before setting the new rb, so that we\n\t\t * could attach the new rb, we could have missed a wakeup.\n\t\t * Provide it now.\n\t\t */\n\t\twake_up_all(&event->waitq);\n\t}\n}\n\nstatic void ring_buffer_wakeup(struct perf_event *event)\n{\n\tstruct ring_buffer *rb;\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (rb) {\n\t\tlist_for_each_entry_rcu(event, &rb->event_list, rb_entry)\n\t\t\twake_up_all(&event->waitq);\n\t}\n\trcu_read_unlock();\n}\n\nstruct ring_buffer *ring_buffer_get(struct perf_event *event)\n{\n\tstruct ring_buffer *rb;\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (rb) {\n\t\tif (!atomic_inc_not_zero(&rb->refcount))\n\t\t\trb = NULL;\n\t}\n\trcu_read_unlock();\n\n\treturn rb;\n}\n\nvoid ring_buffer_put(struct ring_buffer *rb)\n{\n\tif (!atomic_dec_and_test(&rb->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&rb->event_list));\n\n\tcall_rcu(&rb->rcu_head, rb_free_rcu);\n}\n\nstatic void perf_mmap_open(struct vm_area_struct *vma)\n{\n\tstruct perf_event *event = vma->vm_file->private_data;\n\n\tatomic_inc(&event->mmap_count);\n\tatomic_inc(&event->rb->mmap_count);\n\n\tif (vma->vm_pgoff)\n\t\tatomic_inc(&event->rb->aux_mmap_count);\n\n\tif (event->pmu->event_mapped)\n\t\tevent->pmu->event_mapped(event);\n}\n\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\n/*\n * A buffer can be mmap()ed multiple times; either directly through the same\n * event, or through other events by use of perf_event_set_output().\n *\n * In order to undo the VM accounting done by perf_mmap() we need to destroy\n * the buffer here, where we still have a VM context. This means we need\n * to detach all events redirecting to us.\n */\nstatic void perf_mmap_close(struct vm_area_struct *vma)\n{\n\tstruct perf_event *event = vma->vm_file->private_data;\n\n\tstruct ring_buffer *rb = ring_buffer_get(event);\n\tstruct user_struct *mmap_user = rb->mmap_user;\n\tint mmap_locked = rb->mmap_locked;\n\tunsigned long size = perf_data_size(rb);\n\n\tif (event->pmu->event_unmapped)\n\t\tevent->pmu->event_unmapped(event);\n\n\t/*\n\t * rb->aux_mmap_count will always drop before rb->mmap_count and\n\t * event->mmap_count, so it is ok to use event->mmap_mutex to\n\t * serialize with perf_mmap here.\n\t */\n\tif (rb_has_aux(rb) && vma->vm_pgoff == rb->aux_pgoff &&\n\t    atomic_dec_and_mutex_lock(&rb->aux_mmap_count, &event->mmap_mutex)) {\n\t\t/*\n\t\t * Stop all AUX events that are writing to this buffer,\n\t\t * so that we can free its AUX pages and corresponding PMU\n\t\t * data. Note that after rb::aux_mmap_count dropped to zero,\n\t\t * they won't start any more (see perf_aux_output_begin()).\n\t\t */\n\t\tperf_pmu_output_stop(event);\n\n\t\t/* now it's safe to free the pages */\n\t\tatomic_long_sub(rb->aux_nr_pages, &mmap_user->locked_vm);\n\t\tvma->vm_mm->pinned_vm -= rb->aux_mmap_locked;\n\n\t\t/* this has to be the last one */\n\t\trb_free_aux(rb);\n\t\tWARN_ON_ONCE(atomic_read(&rb->aux_refcount));\n\n\t\tmutex_unlock(&event->mmap_mutex);\n\t}\n\n\tatomic_dec(&rb->mmap_count);\n\n\tif (!atomic_dec_and_mutex_lock(&event->mmap_count, &event->mmap_mutex))\n\t\tgoto out_put;\n\n\tring_buffer_attach(event, NULL);\n\tmutex_unlock(&event->mmap_mutex);\n\n\t/* If there's still other mmap()s of this buffer, we're done. */\n\tif (atomic_read(&rb->mmap_count))\n\t\tgoto out_put;\n\n\t/*\n\t * No other mmap()s, detach from all other events that might redirect\n\t * into the now unreachable buffer. Somewhat complicated by the\n\t * fact that rb::event_lock otherwise nests inside mmap_mutex.\n\t */\nagain:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(event, &rb->event_list, rb_entry) {\n\t\tif (!atomic_long_inc_not_zero(&event->refcount)) {\n\t\t\t/*\n\t\t\t * This event is en-route to free_event() which will\n\t\t\t * detach it and remove it from the list.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tmutex_lock(&event->mmap_mutex);\n\t\t/*\n\t\t * Check we didn't race with perf_event_set_output() which can\n\t\t * swizzle the rb from under us while we were waiting to\n\t\t * acquire mmap_mutex.\n\t\t *\n\t\t * If we find a different rb; ignore this event, a next\n\t\t * iteration will no longer find it on the list. We have to\n\t\t * still restart the iteration to make sure we're not now\n\t\t * iterating the wrong list.\n\t\t */\n\t\tif (event->rb == rb)\n\t\t\tring_buffer_attach(event, NULL);\n\n\t\tmutex_unlock(&event->mmap_mutex);\n\t\tput_event(event);\n\n\t\t/*\n\t\t * Restart the iteration; either we're on the wrong list or\n\t\t * destroyed its integrity by doing a deletion.\n\t\t */\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * It could be there's still a few 0-ref events on the list; they'll\n\t * get cleaned up by free_event() -- they'll also still have their\n\t * ref on the rb and will free it whenever they are done with it.\n\t *\n\t * Aside from that, this buffer is 'fully' detached and unmapped,\n\t * undo the VM accounting.\n\t */\n\n\tatomic_long_sub((size >> PAGE_SHIFT) + 1, &mmap_user->locked_vm);\n\tvma->vm_mm->pinned_vm -= mmap_locked;\n\tfree_uid(mmap_user);\n\nout_put:\n\tring_buffer_put(rb); /* could be last */\n}\n\nstatic const struct vm_operations_struct perf_mmap_vmops = {\n\t.open\t\t= perf_mmap_open,\n\t.close\t\t= perf_mmap_close, /* non mergable */\n\t.fault\t\t= perf_mmap_fault,\n\t.page_mkwrite\t= perf_mmap_fault,\n};\n\nstatic int perf_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct perf_event *event = file->private_data;\n\tunsigned long user_locked, user_lock_limit;\n\tstruct user_struct *user = current_user();\n\tunsigned long locked, lock_limit;\n\tstruct ring_buffer *rb = NULL;\n\tunsigned long vma_size;\n\tunsigned long nr_pages;\n\tlong user_extra = 0, extra = 0;\n\tint ret = 0, flags = 0;\n\n\t/*\n\t * Don't allow mmap() of inherited per-task counters. This would\n\t * create a performance issue due to all children writing to the\n\t * same rb.\n\t */\n\tif (event->cpu == -1 && event->attr.inherit)\n\t\treturn -EINVAL;\n\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\tvma_size = vma->vm_end - vma->vm_start;\n\n\tif (vma->vm_pgoff == 0) {\n\t\tnr_pages = (vma_size / PAGE_SIZE) - 1;\n\t} else {\n\t\t/*\n\t\t * AUX area mapping: if rb->aux_nr_pages != 0, it's already\n\t\t * mapped, all subsequent mappings should have the same size\n\t\t * and offset. Must be above the normal perf buffer.\n\t\t */\n\t\tu64 aux_offset, aux_size;\n\n\t\tif (!event->rb)\n\t\t\treturn -EINVAL;\n\n\t\tnr_pages = vma_size / PAGE_SIZE;\n\n\t\tmutex_lock(&event->mmap_mutex);\n\t\tret = -EINVAL;\n\n\t\trb = event->rb;\n\t\tif (!rb)\n\t\t\tgoto aux_unlock;\n\n\t\taux_offset = ACCESS_ONCE(rb->user_page->aux_offset);\n\t\taux_size = ACCESS_ONCE(rb->user_page->aux_size);\n\n\t\tif (aux_offset < perf_data_size(rb) + PAGE_SIZE)\n\t\t\tgoto aux_unlock;\n\n\t\tif (aux_offset != vma->vm_pgoff << PAGE_SHIFT)\n\t\t\tgoto aux_unlock;\n\n\t\t/* already mapped with a different offset */\n\t\tif (rb_has_aux(rb) && rb->aux_pgoff != vma->vm_pgoff)\n\t\t\tgoto aux_unlock;\n\n\t\tif (aux_size != vma_size || aux_size != nr_pages * PAGE_SIZE)\n\t\t\tgoto aux_unlock;\n\n\t\t/* already mapped with a different size */\n\t\tif (rb_has_aux(rb) && rb->aux_nr_pages != nr_pages)\n\t\t\tgoto aux_unlock;\n\n\t\tif (!is_power_of_2(nr_pages))\n\t\t\tgoto aux_unlock;\n\n\t\tif (!atomic_inc_not_zero(&rb->mmap_count))\n\t\t\tgoto aux_unlock;\n\n\t\tif (rb_has_aux(rb)) {\n\t\t\tatomic_inc(&rb->aux_mmap_count);\n\t\t\tret = 0;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tatomic_set(&rb->aux_mmap_count, 1);\n\t\tuser_extra = nr_pages;\n\n\t\tgoto accounting;\n\t}\n\n\t/*\n\t * If we have rb pages ensure they're a power-of-two number, so we\n\t * can do bitmasks instead of modulo.\n\t */\n\tif (nr_pages != 0 && !is_power_of_2(nr_pages))\n\t\treturn -EINVAL;\n\n\tif (vma_size != PAGE_SIZE * (1 + nr_pages))\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(event->ctx->parent_ctx);\nagain:\n\tmutex_lock(&event->mmap_mutex);\n\tif (event->rb) {\n\t\tif (event->rb->nr_pages != nr_pages) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (!atomic_inc_not_zero(&event->rb->mmap_count)) {\n\t\t\t/*\n\t\t\t * Raced against perf_mmap_close() through\n\t\t\t * perf_event_set_output(). Try again, hope for better\n\t\t\t * luck.\n\t\t\t */\n\t\t\tmutex_unlock(&event->mmap_mutex);\n\t\t\tgoto again;\n\t\t}\n\n\t\tgoto unlock;\n\t}\n\n\tuser_extra = nr_pages + 1;\n\naccounting:\n\tuser_lock_limit = sysctl_perf_event_mlock >> (PAGE_SHIFT - 10);\n\n\t/*\n\t * Increase the limit linearly with more CPUs:\n\t */\n\tuser_lock_limit *= num_online_cpus();\n\n\tuser_locked = atomic_long_read(&user->locked_vm) + user_extra;\n\n\tif (user_locked > user_lock_limit)\n\t\textra = user_locked - user_lock_limit;\n\n\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\tlock_limit >>= PAGE_SHIFT;\n\tlocked = vma->vm_mm->pinned_vm + extra;\n\n\tif ((locked > lock_limit) && perf_paranoid_tracepoint_raw() &&\n\t\t!capable(CAP_IPC_LOCK)) {\n\t\tret = -EPERM;\n\t\tgoto unlock;\n\t}\n\n\tWARN_ON(!rb && event->rb);\n\n\tif (vma->vm_flags & VM_WRITE)\n\t\tflags |= RING_BUFFER_WRITABLE;\n\n\tif (!rb) {\n\t\trb = rb_alloc(nr_pages,\n\t\t\t      event->attr.watermark ? event->attr.wakeup_watermark : 0,\n\t\t\t      event->cpu, flags);\n\n\t\tif (!rb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tatomic_set(&rb->mmap_count, 1);\n\t\trb->mmap_user = get_current_user();\n\t\trb->mmap_locked = extra;\n\n\t\tring_buffer_attach(event, rb);\n\n\t\tperf_event_init_userpage(event);\n\t\tperf_event_update_userpage(event);\n\t} else {\n\t\tret = rb_alloc_aux(rb, event, vma->vm_pgoff, nr_pages,\n\t\t\t\t   event->attr.aux_watermark, flags);\n\t\tif (!ret)\n\t\t\trb->aux_mmap_locked = extra;\n\t}\n\nunlock:\n\tif (!ret) {\n\t\tatomic_long_add(user_extra, &user->locked_vm);\n\t\tvma->vm_mm->pinned_vm += extra;\n\n\t\tatomic_inc(&event->mmap_count);\n\t} else if (rb) {\n\t\tatomic_dec(&rb->mmap_count);\n\t}\naux_unlock:\n\tmutex_unlock(&event->mmap_mutex);\n\n\t/*\n\t * Since pinned accounting is per vm we cannot allow fork() to copy our\n\t * vma.\n\t */\n\tvma->vm_flags |= VM_DONTCOPY | VM_DONTEXPAND | VM_DONTDUMP;\n\tvma->vm_ops = &perf_mmap_vmops;\n\n\tif (event->pmu->event_mapped)\n\t\tevent->pmu->event_mapped(event);\n\n\treturn ret;\n}\n\nstatic int perf_fasync(int fd, struct file *filp, int on)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct perf_event *event = filp->private_data;\n\tint retval;\n\n\tinode_lock(inode);\n\tretval = fasync_helper(fd, filp, on, &event->fasync);\n\tinode_unlock(inode);\n\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn 0;\n}\n\nstatic const struct file_operations perf_fops = {\n\t.llseek\t\t\t= no_llseek,\n\t.release\t\t= perf_release,\n\t.read\t\t\t= perf_read,\n\t.poll\t\t\t= perf_poll,\n\t.unlocked_ioctl\t\t= perf_ioctl,\n\t.compat_ioctl\t\t= perf_compat_ioctl,\n\t.mmap\t\t\t= perf_mmap,\n\t.fasync\t\t\t= perf_fasync,\n};\n\n/*\n * Perf event wakeup\n *\n * If there's data, ensure we set the poll() state and publish everything\n * to user-space before waking everybody up.\n */\n\nstatic inline struct fasync_struct **perf_event_fasync(struct perf_event *event)\n{\n\t/* only the parent has fasync state */\n\tif (event->parent)\n\t\tevent = event->parent;\n\treturn &event->fasync;\n}\n\nvoid perf_event_wakeup(struct perf_event *event)\n{\n\tring_buffer_wakeup(event);\n\n\tif (event->pending_kill) {\n\t\tkill_fasync(perf_event_fasync(event), SIGIO, event->pending_kill);\n\t\tevent->pending_kill = 0;\n\t}\n}\n\nstatic void perf_pending_event(struct irq_work *entry)\n{\n\tstruct perf_event *event = container_of(entry,\n\t\t\tstruct perf_event, pending);\n\tint rctx;\n\n\trctx = perf_swevent_get_recursion_context();\n\t/*\n\t * If we 'fail' here, that's OK, it means recursion is already disabled\n\t * and we won't recurse 'further'.\n\t */\n\n\tif (event->pending_disable) {\n\t\tevent->pending_disable = 0;\n\t\tperf_event_disable_local(event);\n\t}\n\n\tif (event->pending_wakeup) {\n\t\tevent->pending_wakeup = 0;\n\t\tperf_event_wakeup(event);\n\t}\n\n\tif (rctx >= 0)\n\t\tperf_swevent_put_recursion_context(rctx);\n}\n\n/*\n * We assume there is only KVM supporting the callbacks.\n * Later on, we might change it to a list if there is\n * another virtualization implementation supporting the callbacks.\n */\nstruct perf_guest_info_callbacks *perf_guest_cbs;\n\nint perf_register_guest_info_callbacks(struct perf_guest_info_callbacks *cbs)\n{\n\tperf_guest_cbs = cbs;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(perf_register_guest_info_callbacks);\n\nint perf_unregister_guest_info_callbacks(struct perf_guest_info_callbacks *cbs)\n{\n\tperf_guest_cbs = NULL;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(perf_unregister_guest_info_callbacks);\n\nstatic void\nperf_output_sample_regs(struct perf_output_handle *handle,\n\t\t\tstruct pt_regs *regs, u64 mask)\n{\n\tint bit;\n\tDECLARE_BITMAP(_mask, 64);\n\n\tbitmap_from_u64(_mask, mask);\n\tfor_each_set_bit(bit, _mask, sizeof(mask) * BITS_PER_BYTE) {\n\t\tu64 val;\n\n\t\tval = perf_reg_value(regs, bit);\n\t\tperf_output_put(handle, val);\n\t}\n}\n\nstatic void perf_sample_regs_user(struct perf_regs *regs_user,\n\t\t\t\t  struct pt_regs *regs,\n\t\t\t\t  struct pt_regs *regs_user_copy)\n{\n\tif (user_mode(regs)) {\n\t\tregs_user->abi = perf_reg_abi(current);\n\t\tregs_user->regs = regs;\n\t} else if (current->mm) {\n\t\tperf_get_regs_user(regs_user, regs, regs_user_copy);\n\t} else {\n\t\tregs_user->abi = PERF_SAMPLE_REGS_ABI_NONE;\n\t\tregs_user->regs = NULL;\n\t}\n}\n\nstatic void perf_sample_regs_intr(struct perf_regs *regs_intr,\n\t\t\t\t  struct pt_regs *regs)\n{\n\tregs_intr->regs = regs;\n\tregs_intr->abi  = perf_reg_abi(current);\n}\n\n\n/*\n * Get remaining task size from user stack pointer.\n *\n * It'd be better to take stack vma map and limit this more\n * precisly, but there's no way to get it safely under interrupt,\n * so using TASK_SIZE as limit.\n */\nstatic u64 perf_ustack_task_size(struct pt_regs *regs)\n{\n\tunsigned long addr = perf_user_stack_pointer(regs);\n\n\tif (!addr || addr >= TASK_SIZE)\n\t\treturn 0;\n\n\treturn TASK_SIZE - addr;\n}\n\nstatic u16\nperf_sample_ustack_size(u16 stack_size, u16 header_size,\n\t\t\tstruct pt_regs *regs)\n{\n\tu64 task_size;\n\n\t/* No regs, no stack pointer, no dump. */\n\tif (!regs)\n\t\treturn 0;\n\n\t/*\n\t * Check if we fit in with the requested stack size into the:\n\t * - TASK_SIZE\n\t *   If we don't, we limit the size to the TASK_SIZE.\n\t *\n\t * - remaining sample size\n\t *   If we don't, we customize the stack size to\n\t *   fit in to the remaining sample size.\n\t */\n\n\ttask_size  = min((u64) USHRT_MAX, perf_ustack_task_size(regs));\n\tstack_size = min(stack_size, (u16) task_size);\n\n\t/* Current header size plus static size and dynamic size. */\n\theader_size += 2 * sizeof(u64);\n\n\t/* Do we fit in with the current stack dump size? */\n\tif ((u16) (header_size + stack_size) < header_size) {\n\t\t/*\n\t\t * If we overflow the maximum size for the sample,\n\t\t * we customize the stack dump size to fit in.\n\t\t */\n\t\tstack_size = USHRT_MAX - header_size - sizeof(u64);\n\t\tstack_size = round_up(stack_size, sizeof(u64));\n\t}\n\n\treturn stack_size;\n}\n\nstatic void\nperf_output_sample_ustack(struct perf_output_handle *handle, u64 dump_size,\n\t\t\t  struct pt_regs *regs)\n{\n\t/* Case of a kernel thread, nothing to dump */\n\tif (!regs) {\n\t\tu64 size = 0;\n\t\tperf_output_put(handle, size);\n\t} else {\n\t\tunsigned long sp;\n\t\tunsigned int rem;\n\t\tu64 dyn_size;\n\n\t\t/*\n\t\t * We dump:\n\t\t * static size\n\t\t *   - the size requested by user or the best one we can fit\n\t\t *     in to the sample max size\n\t\t * data\n\t\t *   - user stack dump data\n\t\t * dynamic size\n\t\t *   - the actual dumped size\n\t\t */\n\n\t\t/* Static size. */\n\t\tperf_output_put(handle, dump_size);\n\n\t\t/* Data. */\n\t\tsp = perf_user_stack_pointer(regs);\n\t\trem = __output_copy_user(handle, (void *) sp, dump_size);\n\t\tdyn_size = dump_size - rem;\n\n\t\tperf_output_skip(handle, rem);\n\n\t\t/* Dynamic size. */\n\t\tperf_output_put(handle, dyn_size);\n\t}\n}\n\nstatic void __perf_event_header__init_id(struct perf_event_header *header,\n\t\t\t\t\t struct perf_sample_data *data,\n\t\t\t\t\t struct perf_event *event)\n{\n\tu64 sample_type = event->attr.sample_type;\n\n\tdata->type = sample_type;\n\theader->size += event->id_header_size;\n\n\tif (sample_type & PERF_SAMPLE_TID) {\n\t\t/* namespace issues */\n\t\tdata->tid_entry.pid = perf_event_pid(event, current);\n\t\tdata->tid_entry.tid = perf_event_tid(event, current);\n\t}\n\n\tif (sample_type & PERF_SAMPLE_TIME)\n\t\tdata->time = perf_event_clock(event);\n\n\tif (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))\n\t\tdata->id = primary_event_id(event);\n\n\tif (sample_type & PERF_SAMPLE_STREAM_ID)\n\t\tdata->stream_id = event->id;\n\n\tif (sample_type & PERF_SAMPLE_CPU) {\n\t\tdata->cpu_entry.cpu\t = raw_smp_processor_id();\n\t\tdata->cpu_entry.reserved = 0;\n\t}\n}\n\nvoid perf_event_header__init_id(struct perf_event_header *header,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct perf_event *event)\n{\n\tif (event->attr.sample_id_all)\n\t\t__perf_event_header__init_id(header, data, event);\n}\n\nstatic void __perf_event__output_id_sample(struct perf_output_handle *handle,\n\t\t\t\t\t   struct perf_sample_data *data)\n{\n\tu64 sample_type = data->type;\n\n\tif (sample_type & PERF_SAMPLE_TID)\n\t\tperf_output_put(handle, data->tid_entry);\n\n\tif (sample_type & PERF_SAMPLE_TIME)\n\t\tperf_output_put(handle, data->time);\n\n\tif (sample_type & PERF_SAMPLE_ID)\n\t\tperf_output_put(handle, data->id);\n\n\tif (sample_type & PERF_SAMPLE_STREAM_ID)\n\t\tperf_output_put(handle, data->stream_id);\n\n\tif (sample_type & PERF_SAMPLE_CPU)\n\t\tperf_output_put(handle, data->cpu_entry);\n\n\tif (sample_type & PERF_SAMPLE_IDENTIFIER)\n\t\tperf_output_put(handle, data->id);\n}\n\nvoid perf_event__output_id_sample(struct perf_event *event,\n\t\t\t\t  struct perf_output_handle *handle,\n\t\t\t\t  struct perf_sample_data *sample)\n{\n\tif (event->attr.sample_id_all)\n\t\t__perf_event__output_id_sample(handle, sample);\n}\n\nstatic void perf_output_read_one(struct perf_output_handle *handle,\n\t\t\t\t struct perf_event *event,\n\t\t\t\t u64 enabled, u64 running)\n{\n\tu64 read_format = event->attr.read_format;\n\tu64 values[4];\n\tint n = 0;\n\n\tvalues[n++] = perf_event_count(event);\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED) {\n\t\tvalues[n++] = enabled +\n\t\t\tatomic64_read(&event->child_total_time_enabled);\n\t}\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING) {\n\t\tvalues[n++] = running +\n\t\t\tatomic64_read(&event->child_total_time_running);\n\t}\n\tif (read_format & PERF_FORMAT_ID)\n\t\tvalues[n++] = primary_event_id(event);\n\n\t__output_copy(handle, values, n * sizeof(u64));\n}\n\n/*\n * XXX PERF_FORMAT_GROUP vs inherited events seems difficult.\n */\nstatic void perf_output_read_group(struct perf_output_handle *handle,\n\t\t\t    struct perf_event *event,\n\t\t\t    u64 enabled, u64 running)\n{\n\tstruct perf_event *leader = event->group_leader, *sub;\n\tu64 read_format = event->attr.read_format;\n\tu64 values[5];\n\tint n = 0;\n\n\tvalues[n++] = 1 + leader->nr_siblings;\n\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)\n\t\tvalues[n++] = enabled;\n\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)\n\t\tvalues[n++] = running;\n\n\tif (leader != event)\n\t\tleader->pmu->read(leader);\n\n\tvalues[n++] = perf_event_count(leader);\n\tif (read_format & PERF_FORMAT_ID)\n\t\tvalues[n++] = primary_event_id(leader);\n\n\t__output_copy(handle, values, n * sizeof(u64));\n\n\tlist_for_each_entry(sub, &leader->sibling_list, group_entry) {\n\t\tn = 0;\n\n\t\tif ((sub != event) &&\n\t\t    (sub->state == PERF_EVENT_STATE_ACTIVE))\n\t\t\tsub->pmu->read(sub);\n\n\t\tvalues[n++] = perf_event_count(sub);\n\t\tif (read_format & PERF_FORMAT_ID)\n\t\t\tvalues[n++] = primary_event_id(sub);\n\n\t\t__output_copy(handle, values, n * sizeof(u64));\n\t}\n}\n\n#define PERF_FORMAT_TOTAL_TIMES (PERF_FORMAT_TOTAL_TIME_ENABLED|\\\n\t\t\t\t PERF_FORMAT_TOTAL_TIME_RUNNING)\n\nstatic void perf_output_read(struct perf_output_handle *handle,\n\t\t\t     struct perf_event *event)\n{\n\tu64 enabled = 0, running = 0, now;\n\tu64 read_format = event->attr.read_format;\n\n\t/*\n\t * compute total_time_enabled, total_time_running\n\t * based on snapshot values taken when the event\n\t * was last scheduled in.\n\t *\n\t * we cannot simply called update_context_time()\n\t * because of locking issue as we are called in\n\t * NMI context\n\t */\n\tif (read_format & PERF_FORMAT_TOTAL_TIMES)\n\t\tcalc_timer_values(event, &now, &enabled, &running);\n\n\tif (event->attr.read_format & PERF_FORMAT_GROUP)\n\t\tperf_output_read_group(handle, event, enabled, running);\n\telse\n\t\tperf_output_read_one(handle, event, enabled, running);\n}\n\nvoid perf_output_sample(struct perf_output_handle *handle,\n\t\t\tstruct perf_event_header *header,\n\t\t\tstruct perf_sample_data *data,\n\t\t\tstruct perf_event *event)\n{\n\tu64 sample_type = data->type;\n\n\tperf_output_put(handle, *header);\n\n\tif (sample_type & PERF_SAMPLE_IDENTIFIER)\n\t\tperf_output_put(handle, data->id);\n\n\tif (sample_type & PERF_SAMPLE_IP)\n\t\tperf_output_put(handle, data->ip);\n\n\tif (sample_type & PERF_SAMPLE_TID)\n\t\tperf_output_put(handle, data->tid_entry);\n\n\tif (sample_type & PERF_SAMPLE_TIME)\n\t\tperf_output_put(handle, data->time);\n\n\tif (sample_type & PERF_SAMPLE_ADDR)\n\t\tperf_output_put(handle, data->addr);\n\n\tif (sample_type & PERF_SAMPLE_ID)\n\t\tperf_output_put(handle, data->id);\n\n\tif (sample_type & PERF_SAMPLE_STREAM_ID)\n\t\tperf_output_put(handle, data->stream_id);\n\n\tif (sample_type & PERF_SAMPLE_CPU)\n\t\tperf_output_put(handle, data->cpu_entry);\n\n\tif (sample_type & PERF_SAMPLE_PERIOD)\n\t\tperf_output_put(handle, data->period);\n\n\tif (sample_type & PERF_SAMPLE_READ)\n\t\tperf_output_read(handle, event);\n\n\tif (sample_type & PERF_SAMPLE_CALLCHAIN) {\n\t\tif (data->callchain) {\n\t\t\tint size = 1;\n\n\t\t\tif (data->callchain)\n\t\t\t\tsize += data->callchain->nr;\n\n\t\t\tsize *= sizeof(u64);\n\n\t\t\t__output_copy(handle, data->callchain, size);\n\t\t} else {\n\t\t\tu64 nr = 0;\n\t\t\tperf_output_put(handle, nr);\n\t\t}\n\t}\n\n\tif (sample_type & PERF_SAMPLE_RAW) {\n\t\tstruct perf_raw_record *raw = data->raw;\n\n\t\tif (raw) {\n\t\t\tstruct perf_raw_frag *frag = &raw->frag;\n\n\t\t\tperf_output_put(handle, raw->size);\n\t\t\tdo {\n\t\t\t\tif (frag->copy) {\n\t\t\t\t\t__output_custom(handle, frag->copy,\n\t\t\t\t\t\t\tfrag->data, frag->size);\n\t\t\t\t} else {\n\t\t\t\t\t__output_copy(handle, frag->data,\n\t\t\t\t\t\t      frag->size);\n\t\t\t\t}\n\t\t\t\tif (perf_raw_frag_last(frag))\n\t\t\t\t\tbreak;\n\t\t\t\tfrag = frag->next;\n\t\t\t} while (1);\n\t\t\tif (frag->pad)\n\t\t\t\t__output_skip(handle, NULL, frag->pad);\n\t\t} else {\n\t\t\tstruct {\n\t\t\t\tu32\tsize;\n\t\t\t\tu32\tdata;\n\t\t\t} raw = {\n\t\t\t\t.size = sizeof(u32),\n\t\t\t\t.data = 0,\n\t\t\t};\n\t\t\tperf_output_put(handle, raw);\n\t\t}\n\t}\n\n\tif (sample_type & PERF_SAMPLE_BRANCH_STACK) {\n\t\tif (data->br_stack) {\n\t\t\tsize_t size;\n\n\t\t\tsize = data->br_stack->nr\n\t\t\t     * sizeof(struct perf_branch_entry);\n\n\t\t\tperf_output_put(handle, data->br_stack->nr);\n\t\t\tperf_output_copy(handle, data->br_stack->entries, size);\n\t\t} else {\n\t\t\t/*\n\t\t\t * we always store at least the value of nr\n\t\t\t */\n\t\t\tu64 nr = 0;\n\t\t\tperf_output_put(handle, nr);\n\t\t}\n\t}\n\n\tif (sample_type & PERF_SAMPLE_REGS_USER) {\n\t\tu64 abi = data->regs_user.abi;\n\n\t\t/*\n\t\t * If there are no regs to dump, notice it through\n\t\t * first u64 being zero (PERF_SAMPLE_REGS_ABI_NONE).\n\t\t */\n\t\tperf_output_put(handle, abi);\n\n\t\tif (abi) {\n\t\t\tu64 mask = event->attr.sample_regs_user;\n\t\t\tperf_output_sample_regs(handle,\n\t\t\t\t\t\tdata->regs_user.regs,\n\t\t\t\t\t\tmask);\n\t\t}\n\t}\n\n\tif (sample_type & PERF_SAMPLE_STACK_USER) {\n\t\tperf_output_sample_ustack(handle,\n\t\t\t\t\t  data->stack_user_size,\n\t\t\t\t\t  data->regs_user.regs);\n\t}\n\n\tif (sample_type & PERF_SAMPLE_WEIGHT)\n\t\tperf_output_put(handle, data->weight);\n\n\tif (sample_type & PERF_SAMPLE_DATA_SRC)\n\t\tperf_output_put(handle, data->data_src.val);\n\n\tif (sample_type & PERF_SAMPLE_TRANSACTION)\n\t\tperf_output_put(handle, data->txn);\n\n\tif (sample_type & PERF_SAMPLE_REGS_INTR) {\n\t\tu64 abi = data->regs_intr.abi;\n\t\t/*\n\t\t * If there are no regs to dump, notice it through\n\t\t * first u64 being zero (PERF_SAMPLE_REGS_ABI_NONE).\n\t\t */\n\t\tperf_output_put(handle, abi);\n\n\t\tif (abi) {\n\t\t\tu64 mask = event->attr.sample_regs_intr;\n\n\t\t\tperf_output_sample_regs(handle,\n\t\t\t\t\t\tdata->regs_intr.regs,\n\t\t\t\t\t\tmask);\n\t\t}\n\t}\n\n\tif (!event->attr.watermark) {\n\t\tint wakeup_events = event->attr.wakeup_events;\n\n\t\tif (wakeup_events) {\n\t\t\tstruct ring_buffer *rb = handle->rb;\n\t\t\tint events = local_inc_return(&rb->events);\n\n\t\t\tif (events >= wakeup_events) {\n\t\t\t\tlocal_sub(wakeup_events, &rb->events);\n\t\t\t\tlocal_inc(&rb->wakeup);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid perf_prepare_sample(struct perf_event_header *header,\n\t\t\t struct perf_sample_data *data,\n\t\t\t struct perf_event *event,\n\t\t\t struct pt_regs *regs)\n{\n\tu64 sample_type = event->attr.sample_type;\n\n\theader->type = PERF_RECORD_SAMPLE;\n\theader->size = sizeof(*header) + event->header_size;\n\n\theader->misc = 0;\n\theader->misc |= perf_misc_flags(regs);\n\n\t__perf_event_header__init_id(header, data, event);\n\n\tif (sample_type & PERF_SAMPLE_IP)\n\t\tdata->ip = perf_instruction_pointer(regs);\n\n\tif (sample_type & PERF_SAMPLE_CALLCHAIN) {\n\t\tint size = 1;\n\n\t\tdata->callchain = perf_callchain(event, regs);\n\n\t\tif (data->callchain)\n\t\t\tsize += data->callchain->nr;\n\n\t\theader->size += size * sizeof(u64);\n\t}\n\n\tif (sample_type & PERF_SAMPLE_RAW) {\n\t\tstruct perf_raw_record *raw = data->raw;\n\t\tint size;\n\n\t\tif (raw) {\n\t\t\tstruct perf_raw_frag *frag = &raw->frag;\n\t\t\tu32 sum = 0;\n\n\t\t\tdo {\n\t\t\t\tsum += frag->size;\n\t\t\t\tif (perf_raw_frag_last(frag))\n\t\t\t\t\tbreak;\n\t\t\t\tfrag = frag->next;\n\t\t\t} while (1);\n\n\t\t\tsize = round_up(sum + sizeof(u32), sizeof(u64));\n\t\t\traw->size = size - sizeof(u32);\n\t\t\tfrag->pad = raw->size - sum;\n\t\t} else {\n\t\t\tsize = sizeof(u64);\n\t\t}\n\n\t\theader->size += size;\n\t}\n\n\tif (sample_type & PERF_SAMPLE_BRANCH_STACK) {\n\t\tint size = sizeof(u64); /* nr */\n\t\tif (data->br_stack) {\n\t\t\tsize += data->br_stack->nr\n\t\t\t      * sizeof(struct perf_branch_entry);\n\t\t}\n\t\theader->size += size;\n\t}\n\n\tif (sample_type & (PERF_SAMPLE_REGS_USER | PERF_SAMPLE_STACK_USER))\n\t\tperf_sample_regs_user(&data->regs_user, regs,\n\t\t\t\t      &data->regs_user_copy);\n\n\tif (sample_type & PERF_SAMPLE_REGS_USER) {\n\t\t/* regs dump ABI info */\n\t\tint size = sizeof(u64);\n\n\t\tif (data->regs_user.regs) {\n\t\t\tu64 mask = event->attr.sample_regs_user;\n\t\t\tsize += hweight64(mask) * sizeof(u64);\n\t\t}\n\n\t\theader->size += size;\n\t}\n\n\tif (sample_type & PERF_SAMPLE_STACK_USER) {\n\t\t/*\n\t\t * Either we need PERF_SAMPLE_STACK_USER bit to be allways\n\t\t * processed as the last one or have additional check added\n\t\t * in case new sample type is added, because we could eat\n\t\t * up the rest of the sample size.\n\t\t */\n\t\tu16 stack_size = event->attr.sample_stack_user;\n\t\tu16 size = sizeof(u64);\n\n\t\tstack_size = perf_sample_ustack_size(stack_size, header->size,\n\t\t\t\t\t\t     data->regs_user.regs);\n\n\t\t/*\n\t\t * If there is something to dump, add space for the dump\n\t\t * itself and for the field that tells the dynamic size,\n\t\t * which is how many have been actually dumped.\n\t\t */\n\t\tif (stack_size)\n\t\t\tsize += sizeof(u64) + stack_size;\n\n\t\tdata->stack_user_size = stack_size;\n\t\theader->size += size;\n\t}\n\n\tif (sample_type & PERF_SAMPLE_REGS_INTR) {\n\t\t/* regs dump ABI info */\n\t\tint size = sizeof(u64);\n\n\t\tperf_sample_regs_intr(&data->regs_intr, regs);\n\n\t\tif (data->regs_intr.regs) {\n\t\t\tu64 mask = event->attr.sample_regs_intr;\n\n\t\t\tsize += hweight64(mask) * sizeof(u64);\n\t\t}\n\n\t\theader->size += size;\n\t}\n}\n\nstatic void __always_inline\n__perf_event_output(struct perf_event *event,\n\t\t    struct perf_sample_data *data,\n\t\t    struct pt_regs *regs,\n\t\t    int (*output_begin)(struct perf_output_handle *,\n\t\t\t\t\tstruct perf_event *,\n\t\t\t\t\tunsigned int))\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_event_header header;\n\n\t/* protect the callchain buffers */\n\trcu_read_lock();\n\n\tperf_prepare_sample(&header, data, event, regs);\n\n\tif (output_begin(&handle, event, header.size))\n\t\tgoto exit;\n\n\tperf_output_sample(&handle, &header, data, event);\n\n\tperf_output_end(&handle);\n\nexit:\n\trcu_read_unlock();\n}\n\nvoid\nperf_event_output_forward(struct perf_event *event,\n\t\t\t struct perf_sample_data *data,\n\t\t\t struct pt_regs *regs)\n{\n\t__perf_event_output(event, data, regs, perf_output_begin_forward);\n}\n\nvoid\nperf_event_output_backward(struct perf_event *event,\n\t\t\t   struct perf_sample_data *data,\n\t\t\t   struct pt_regs *regs)\n{\n\t__perf_event_output(event, data, regs, perf_output_begin_backward);\n}\n\nvoid\nperf_event_output(struct perf_event *event,\n\t\t  struct perf_sample_data *data,\n\t\t  struct pt_regs *regs)\n{\n\t__perf_event_output(event, data, regs, perf_output_begin);\n}\n\n/*\n * read event_id\n */\n\nstruct perf_read_event {\n\tstruct perf_event_header\theader;\n\n\tu32\t\t\t\tpid;\n\tu32\t\t\t\ttid;\n};\n\nstatic void\nperf_event_read_event(struct perf_event *event,\n\t\t\tstruct task_struct *task)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_read_event read_event = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_READ,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(read_event) + event->read_size,\n\t\t},\n\t\t.pid = perf_event_pid(event, task),\n\t\t.tid = perf_event_tid(event, task),\n\t};\n\tint ret;\n\n\tperf_event_header__init_id(&read_event.header, &sample, event);\n\tret = perf_output_begin(&handle, event, read_event.header.size);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, read_event);\n\tperf_output_read(&handle, event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}\n\ntypedef void (perf_iterate_f)(struct perf_event *event, void *data);\n\nstatic void\nperf_iterate_ctx(struct perf_event_context *ctx,\n\t\t   perf_iterate_f output,\n\t\t   void *data, bool all)\n{\n\tstruct perf_event *event;\n\n\tlist_for_each_entry_rcu(event, &ctx->event_list, event_entry) {\n\t\tif (!all) {\n\t\t\tif (event->state < PERF_EVENT_STATE_INACTIVE)\n\t\t\t\tcontinue;\n\t\t\tif (!event_filter_match(event))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\toutput(event, data);\n\t}\n}\n\nstatic void perf_iterate_sb_cpu(perf_iterate_f output, void *data)\n{\n\tstruct pmu_event_list *pel = this_cpu_ptr(&pmu_sb_events);\n\tstruct perf_event *event;\n\n\tlist_for_each_entry_rcu(event, &pel->list, sb_list) {\n\t\t/*\n\t\t * Skip events that are not fully formed yet; ensure that\n\t\t * if we observe event->ctx, both event and ctx will be\n\t\t * complete enough. See perf_install_in_context().\n\t\t */\n\t\tif (!smp_load_acquire(&event->ctx))\n\t\t\tcontinue;\n\n\t\tif (event->state < PERF_EVENT_STATE_INACTIVE)\n\t\t\tcontinue;\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\t\toutput(event, data);\n\t}\n}\n\n/*\n * Iterate all events that need to receive side-band events.\n *\n * For new callers; ensure that account_pmu_sb_event() includes\n * your event, otherwise it might not get delivered.\n */\nstatic void\nperf_iterate_sb(perf_iterate_f output, void *data,\n\t       struct perf_event_context *task_ctx)\n{\n\tstruct perf_event_context *ctx;\n\tint ctxn;\n\n\trcu_read_lock();\n\tpreempt_disable();\n\n\t/*\n\t * If we have task_ctx != NULL we only notify the task context itself.\n\t * The task_ctx is set only for EXIT events before releasing task\n\t * context.\n\t */\n\tif (task_ctx) {\n\t\tperf_iterate_ctx(task_ctx, output, data, false);\n\t\tgoto done;\n\t}\n\n\tperf_iterate_sb_cpu(output, data);\n\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = rcu_dereference(current->perf_event_ctxp[ctxn]);\n\t\tif (ctx)\n\t\t\tperf_iterate_ctx(ctx, output, data, false);\n\t}\ndone:\n\tpreempt_enable();\n\trcu_read_unlock();\n}\n\n/*\n * Clear all file-based filters at exec, they'll have to be\n * re-instated when/if these objects are mmapped again.\n */\nstatic void perf_event_addr_filters_exec(struct perf_event *event, void *data)\n{\n\tstruct perf_addr_filters_head *ifh = perf_event_addr_filters(event);\n\tstruct perf_addr_filter *filter;\n\tunsigned int restart = 0, count = 0;\n\tunsigned long flags;\n\n\tif (!has_addr_filter(event))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&ifh->lock, flags);\n\tlist_for_each_entry(filter, &ifh->list, entry) {\n\t\tif (filter->inode) {\n\t\t\tevent->addr_filters_offs[count] = 0;\n\t\t\trestart++;\n\t\t}\n\n\t\tcount++;\n\t}\n\n\tif (restart)\n\t\tevent->addr_filters_gen++;\n\traw_spin_unlock_irqrestore(&ifh->lock, flags);\n\n\tif (restart)\n\t\tperf_event_stop(event, 1);\n}\n\nvoid perf_event_exec(void)\n{\n\tstruct perf_event_context *ctx;\n\tint ctxn;\n\n\trcu_read_lock();\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = current->perf_event_ctxp[ctxn];\n\t\tif (!ctx)\n\t\t\tcontinue;\n\n\t\tperf_event_enable_on_exec(ctxn);\n\n\t\tperf_iterate_ctx(ctx, perf_event_addr_filters_exec, NULL,\n\t\t\t\t   true);\n\t}\n\trcu_read_unlock();\n}\n\nstruct remote_output {\n\tstruct ring_buffer\t*rb;\n\tint\t\t\terr;\n};\n\nstatic void __perf_event_output_stop(struct perf_event *event, void *data)\n{\n\tstruct perf_event *parent = event->parent;\n\tstruct remote_output *ro = data;\n\tstruct ring_buffer *rb = ro->rb;\n\tstruct stop_event_data sd = {\n\t\t.event\t= event,\n\t};\n\n\tif (!has_aux(event))\n\t\treturn;\n\n\tif (!parent)\n\t\tparent = event;\n\n\t/*\n\t * In case of inheritance, it will be the parent that links to the\n\t * ring-buffer, but it will be the child that's actually using it.\n\t *\n\t * We are using event::rb to determine if the event should be stopped,\n\t * however this may race with ring_buffer_attach() (through set_output),\n\t * which will make us skip the event that actually needs to be stopped.\n\t * So ring_buffer_attach() has to stop an aux event before re-assigning\n\t * its rb pointer.\n\t */\n\tif (rcu_dereference(parent->rb) == rb)\n\t\tro->err = __perf_event_stop(&sd);\n}\n\nstatic int __perf_pmu_output_stop(void *info)\n{\n\tstruct perf_event *event = info;\n\tstruct pmu *pmu = event->pmu;\n\tstruct perf_cpu_context *cpuctx = this_cpu_ptr(pmu->pmu_cpu_context);\n\tstruct remote_output ro = {\n\t\t.rb\t= event->rb,\n\t};\n\n\trcu_read_lock();\n\tperf_iterate_ctx(&cpuctx->ctx, __perf_event_output_stop, &ro, false);\n\tif (cpuctx->task_ctx)\n\t\tperf_iterate_ctx(cpuctx->task_ctx, __perf_event_output_stop,\n\t\t\t\t   &ro, false);\n\trcu_read_unlock();\n\n\treturn ro.err;\n}\n\nstatic void perf_pmu_output_stop(struct perf_event *event)\n{\n\tstruct perf_event *iter;\n\tint err, cpu;\n\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(iter, &event->rb->event_list, rb_entry) {\n\t\t/*\n\t\t * For per-CPU events, we need to make sure that neither they\n\t\t * nor their children are running; for cpu==-1 events it's\n\t\t * sufficient to stop the event itself if it's active, since\n\t\t * it can't have children.\n\t\t */\n\t\tcpu = iter->cpu;\n\t\tif (cpu == -1)\n\t\t\tcpu = READ_ONCE(iter->oncpu);\n\n\t\tif (cpu == -1)\n\t\t\tcontinue;\n\n\t\terr = cpu_function_call(cpu, __perf_pmu_output_stop, event);\n\t\tif (err == -EAGAIN) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto restart;\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\n/*\n * task tracking -- fork/exit\n *\n * enabled by: attr.comm | attr.mmap | attr.mmap2 | attr.mmap_data | attr.task\n */\n\nstruct perf_task_event {\n\tstruct task_struct\t\t*task;\n\tstruct perf_event_context\t*task_ctx;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\n\t\tu32\t\t\t\tpid;\n\t\tu32\t\t\t\tppid;\n\t\tu32\t\t\t\ttid;\n\t\tu32\t\t\t\tptid;\n\t\tu64\t\t\t\ttime;\n\t} event_id;\n};\n\nstatic int perf_event_task_match(struct perf_event *event)\n{\n\treturn event->attr.comm  || event->attr.mmap ||\n\t       event->attr.mmap2 || event->attr.mmap_data ||\n\t       event->attr.task;\n}\n\nstatic void perf_event_task_output(struct perf_event *event,\n\t\t\t\t   void *data)\n{\n\tstruct perf_task_event *task_event = data;\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data\tsample;\n\tstruct task_struct *task = task_event->task;\n\tint ret, size = task_event->event_id.header.size;\n\n\tif (!perf_event_task_match(event))\n\t\treturn;\n\n\tperf_event_header__init_id(&task_event->event_id.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\ttask_event->event_id.header.size);\n\tif (ret)\n\t\tgoto out;\n\n\ttask_event->event_id.pid = perf_event_pid(event, task);\n\ttask_event->event_id.ppid = perf_event_pid(event, current);\n\n\ttask_event->event_id.tid = perf_event_tid(event, task);\n\ttask_event->event_id.ptid = perf_event_tid(event, current);\n\n\ttask_event->event_id.time = perf_event_clock(event);\n\n\tperf_output_put(&handle, task_event->event_id);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\nout:\n\ttask_event->event_id.header.size = size;\n}\n\nstatic void perf_event_task(struct task_struct *task,\n\t\t\t      struct perf_event_context *task_ctx,\n\t\t\t      int new)\n{\n\tstruct perf_task_event task_event;\n\n\tif (!atomic_read(&nr_comm_events) &&\n\t    !atomic_read(&nr_mmap_events) &&\n\t    !atomic_read(&nr_task_events))\n\t\treturn;\n\n\ttask_event = (struct perf_task_event){\n\t\t.task\t  = task,\n\t\t.task_ctx = task_ctx,\n\t\t.event_id    = {\n\t\t\t.header = {\n\t\t\t\t.type = new ? PERF_RECORD_FORK : PERF_RECORD_EXIT,\n\t\t\t\t.misc = 0,\n\t\t\t\t.size = sizeof(task_event.event_id),\n\t\t\t},\n\t\t\t/* .pid  */\n\t\t\t/* .ppid */\n\t\t\t/* .tid  */\n\t\t\t/* .ptid */\n\t\t\t/* .time */\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_task_output,\n\t\t       &task_event,\n\t\t       task_ctx);\n}\n\nvoid perf_event_fork(struct task_struct *task)\n{\n\tperf_event_task(task, NULL, 1);\n}\n\n/*\n * comm tracking\n */\n\nstruct perf_comm_event {\n\tstruct task_struct\t*task;\n\tchar\t\t\t*comm;\n\tint\t\t\tcomm_size;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\n\t\tu32\t\t\t\tpid;\n\t\tu32\t\t\t\ttid;\n\t} event_id;\n};\n\nstatic int perf_event_comm_match(struct perf_event *event)\n{\n\treturn event->attr.comm;\n}\n\nstatic void perf_event_comm_output(struct perf_event *event,\n\t\t\t\t   void *data)\n{\n\tstruct perf_comm_event *comm_event = data;\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint size = comm_event->event_id.header.size;\n\tint ret;\n\n\tif (!perf_event_comm_match(event))\n\t\treturn;\n\n\tperf_event_header__init_id(&comm_event->event_id.header, &sample, event);\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tcomm_event->event_id.header.size);\n\n\tif (ret)\n\t\tgoto out;\n\n\tcomm_event->event_id.pid = perf_event_pid(event, comm_event->task);\n\tcomm_event->event_id.tid = perf_event_tid(event, comm_event->task);\n\n\tperf_output_put(&handle, comm_event->event_id);\n\t__output_copy(&handle, comm_event->comm,\n\t\t\t\t   comm_event->comm_size);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\nout:\n\tcomm_event->event_id.header.size = size;\n}\n\nstatic void perf_event_comm_event(struct perf_comm_event *comm_event)\n{\n\tchar comm[TASK_COMM_LEN];\n\tunsigned int size;\n\n\tmemset(comm, 0, sizeof(comm));\n\tstrlcpy(comm, comm_event->task->comm, sizeof(comm));\n\tsize = ALIGN(strlen(comm)+1, sizeof(u64));\n\n\tcomm_event->comm = comm;\n\tcomm_event->comm_size = size;\n\n\tcomm_event->event_id.header.size = sizeof(comm_event->event_id) + size;\n\n\tperf_iterate_sb(perf_event_comm_output,\n\t\t       comm_event,\n\t\t       NULL);\n}\n\nvoid perf_event_comm(struct task_struct *task, bool exec)\n{\n\tstruct perf_comm_event comm_event;\n\n\tif (!atomic_read(&nr_comm_events))\n\t\treturn;\n\n\tcomm_event = (struct perf_comm_event){\n\t\t.task\t= task,\n\t\t/* .comm      */\n\t\t/* .comm_size */\n\t\t.event_id  = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_COMM,\n\t\t\t\t.misc = exec ? PERF_RECORD_MISC_COMM_EXEC : 0,\n\t\t\t\t/* .size */\n\t\t\t},\n\t\t\t/* .pid */\n\t\t\t/* .tid */\n\t\t},\n\t};\n\n\tperf_event_comm_event(&comm_event);\n}\n\n/*\n * mmap tracking\n */\n\nstruct perf_mmap_event {\n\tstruct vm_area_struct\t*vma;\n\n\tconst char\t\t*file_name;\n\tint\t\t\tfile_size;\n\tint\t\t\tmaj, min;\n\tu64\t\t\tino;\n\tu64\t\t\tino_generation;\n\tu32\t\t\tprot, flags;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\n\t\tu32\t\t\t\tpid;\n\t\tu32\t\t\t\ttid;\n\t\tu64\t\t\t\tstart;\n\t\tu64\t\t\t\tlen;\n\t\tu64\t\t\t\tpgoff;\n\t} event_id;\n};\n\nstatic int perf_event_mmap_match(struct perf_event *event,\n\t\t\t\t void *data)\n{\n\tstruct perf_mmap_event *mmap_event = data;\n\tstruct vm_area_struct *vma = mmap_event->vma;\n\tint executable = vma->vm_flags & VM_EXEC;\n\n\treturn (!executable && event->attr.mmap_data) ||\n\t       (executable && (event->attr.mmap || event->attr.mmap2));\n}\n\nstatic void perf_event_mmap_output(struct perf_event *event,\n\t\t\t\t   void *data)\n{\n\tstruct perf_mmap_event *mmap_event = data;\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint size = mmap_event->event_id.header.size;\n\tint ret;\n\n\tif (!perf_event_mmap_match(event, data))\n\t\treturn;\n\n\tif (event->attr.mmap2) {\n\t\tmmap_event->event_id.header.type = PERF_RECORD_MMAP2;\n\t\tmmap_event->event_id.header.size += sizeof(mmap_event->maj);\n\t\tmmap_event->event_id.header.size += sizeof(mmap_event->min);\n\t\tmmap_event->event_id.header.size += sizeof(mmap_event->ino);\n\t\tmmap_event->event_id.header.size += sizeof(mmap_event->ino_generation);\n\t\tmmap_event->event_id.header.size += sizeof(mmap_event->prot);\n\t\tmmap_event->event_id.header.size += sizeof(mmap_event->flags);\n\t}\n\n\tperf_event_header__init_id(&mmap_event->event_id.header, &sample, event);\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tmmap_event->event_id.header.size);\n\tif (ret)\n\t\tgoto out;\n\n\tmmap_event->event_id.pid = perf_event_pid(event, current);\n\tmmap_event->event_id.tid = perf_event_tid(event, current);\n\n\tperf_output_put(&handle, mmap_event->event_id);\n\n\tif (event->attr.mmap2) {\n\t\tperf_output_put(&handle, mmap_event->maj);\n\t\tperf_output_put(&handle, mmap_event->min);\n\t\tperf_output_put(&handle, mmap_event->ino);\n\t\tperf_output_put(&handle, mmap_event->ino_generation);\n\t\tperf_output_put(&handle, mmap_event->prot);\n\t\tperf_output_put(&handle, mmap_event->flags);\n\t}\n\n\t__output_copy(&handle, mmap_event->file_name,\n\t\t\t\t   mmap_event->file_size);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\nout:\n\tmmap_event->event_id.header.size = size;\n}\n\nstatic void perf_event_mmap_event(struct perf_mmap_event *mmap_event)\n{\n\tstruct vm_area_struct *vma = mmap_event->vma;\n\tstruct file *file = vma->vm_file;\n\tint maj = 0, min = 0;\n\tu64 ino = 0, gen = 0;\n\tu32 prot = 0, flags = 0;\n\tunsigned int size;\n\tchar tmp[16];\n\tchar *buf = NULL;\n\tchar *name;\n\n\tif (file) {\n\t\tstruct inode *inode;\n\t\tdev_t dev;\n\n\t\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tname = \"//enomem\";\n\t\t\tgoto cpy_name;\n\t\t}\n\t\t/*\n\t\t * d_path() works from the end of the rb backwards, so we\n\t\t * need to add enough zero bytes after the string to handle\n\t\t * the 64bit alignment we do later.\n\t\t */\n\t\tname = file_path(file, buf, PATH_MAX - sizeof(u64));\n\t\tif (IS_ERR(name)) {\n\t\t\tname = \"//toolong\";\n\t\t\tgoto cpy_name;\n\t\t}\n\t\tinode = file_inode(vma->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t\tgen = inode->i_generation;\n\t\tmaj = MAJOR(dev);\n\t\tmin = MINOR(dev);\n\n\t\tif (vma->vm_flags & VM_READ)\n\t\t\tprot |= PROT_READ;\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tprot |= PROT_WRITE;\n\t\tif (vma->vm_flags & VM_EXEC)\n\t\t\tprot |= PROT_EXEC;\n\n\t\tif (vma->vm_flags & VM_MAYSHARE)\n\t\t\tflags = MAP_SHARED;\n\t\telse\n\t\t\tflags = MAP_PRIVATE;\n\n\t\tif (vma->vm_flags & VM_DENYWRITE)\n\t\t\tflags |= MAP_DENYWRITE;\n\t\tif (vma->vm_flags & VM_MAYEXEC)\n\t\t\tflags |= MAP_EXECUTABLE;\n\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\tflags |= MAP_LOCKED;\n\t\tif (vma->vm_flags & VM_HUGETLB)\n\t\t\tflags |= MAP_HUGETLB;\n\n\t\tgoto got_name;\n\t} else {\n\t\tif (vma->vm_ops && vma->vm_ops->name) {\n\t\t\tname = (char *) vma->vm_ops->name(vma);\n\t\t\tif (name)\n\t\t\t\tgoto cpy_name;\n\t\t}\n\n\t\tname = (char *)arch_vma_name(vma);\n\t\tif (name)\n\t\t\tgoto cpy_name;\n\n\t\tif (vma->vm_start <= vma->vm_mm->start_brk &&\n\t\t\t\tvma->vm_end >= vma->vm_mm->brk) {\n\t\t\tname = \"[heap]\";\n\t\t\tgoto cpy_name;\n\t\t}\n\t\tif (vma->vm_start <= vma->vm_mm->start_stack &&\n\t\t\t\tvma->vm_end >= vma->vm_mm->start_stack) {\n\t\t\tname = \"[stack]\";\n\t\t\tgoto cpy_name;\n\t\t}\n\n\t\tname = \"//anon\";\n\t\tgoto cpy_name;\n\t}\n\ncpy_name:\n\tstrlcpy(tmp, name, sizeof(tmp));\n\tname = tmp;\ngot_name:\n\t/*\n\t * Since our buffer works in 8 byte units we need to align our string\n\t * size to a multiple of 8. However, we must guarantee the tail end is\n\t * zero'd out to avoid leaking random bits to userspace.\n\t */\n\tsize = strlen(name)+1;\n\twhile (!IS_ALIGNED(size, sizeof(u64)))\n\t\tname[size++] = '\\0';\n\n\tmmap_event->file_name = name;\n\tmmap_event->file_size = size;\n\tmmap_event->maj = maj;\n\tmmap_event->min = min;\n\tmmap_event->ino = ino;\n\tmmap_event->ino_generation = gen;\n\tmmap_event->prot = prot;\n\tmmap_event->flags = flags;\n\n\tif (!(vma->vm_flags & VM_EXEC))\n\t\tmmap_event->event_id.header.misc |= PERF_RECORD_MISC_MMAP_DATA;\n\n\tmmap_event->event_id.header.size = sizeof(mmap_event->event_id) + size;\n\n\tperf_iterate_sb(perf_event_mmap_output,\n\t\t       mmap_event,\n\t\t       NULL);\n\n\tkfree(buf);\n}\n\n/*\n * Check whether inode and address range match filter criteria.\n */\nstatic bool perf_addr_filter_match(struct perf_addr_filter *filter,\n\t\t\t\t     struct file *file, unsigned long offset,\n\t\t\t\t     unsigned long size)\n{\n\tif (filter->inode != file_inode(file))\n\t\treturn false;\n\n\tif (filter->offset > offset + size)\n\t\treturn false;\n\n\tif (filter->offset + filter->size < offset)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void __perf_addr_filters_adjust(struct perf_event *event, void *data)\n{\n\tstruct perf_addr_filters_head *ifh = perf_event_addr_filters(event);\n\tstruct vm_area_struct *vma = data;\n\tunsigned long off = vma->vm_pgoff << PAGE_SHIFT, flags;\n\tstruct file *file = vma->vm_file;\n\tstruct perf_addr_filter *filter;\n\tunsigned int restart = 0, count = 0;\n\n\tif (!has_addr_filter(event))\n\t\treturn;\n\n\tif (!file)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&ifh->lock, flags);\n\tlist_for_each_entry(filter, &ifh->list, entry) {\n\t\tif (perf_addr_filter_match(filter, file, off,\n\t\t\t\t\t     vma->vm_end - vma->vm_start)) {\n\t\t\tevent->addr_filters_offs[count] = vma->vm_start;\n\t\t\trestart++;\n\t\t}\n\n\t\tcount++;\n\t}\n\n\tif (restart)\n\t\tevent->addr_filters_gen++;\n\traw_spin_unlock_irqrestore(&ifh->lock, flags);\n\n\tif (restart)\n\t\tperf_event_stop(event, 1);\n}\n\n/*\n * Adjust all task's events' filters to the new vma\n */\nstatic void perf_addr_filters_adjust(struct vm_area_struct *vma)\n{\n\tstruct perf_event_context *ctx;\n\tint ctxn;\n\n\t/*\n\t * Data tracing isn't supported yet and as such there is no need\n\t * to keep track of anything that isn't related to executable code:\n\t */\n\tif (!(vma->vm_flags & VM_EXEC))\n\t\treturn;\n\n\trcu_read_lock();\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = rcu_dereference(current->perf_event_ctxp[ctxn]);\n\t\tif (!ctx)\n\t\t\tcontinue;\n\n\t\tperf_iterate_ctx(ctx, __perf_addr_filters_adjust, vma, true);\n\t}\n\trcu_read_unlock();\n}\n\nvoid perf_event_mmap(struct vm_area_struct *vma)\n{\n\tstruct perf_mmap_event mmap_event;\n\n\tif (!atomic_read(&nr_mmap_events))\n\t\treturn;\n\n\tmmap_event = (struct perf_mmap_event){\n\t\t.vma\t= vma,\n\t\t/* .file_name */\n\t\t/* .file_size */\n\t\t.event_id  = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_MMAP,\n\t\t\t\t.misc = PERF_RECORD_MISC_USER,\n\t\t\t\t/* .size */\n\t\t\t},\n\t\t\t/* .pid */\n\t\t\t/* .tid */\n\t\t\t.start  = vma->vm_start,\n\t\t\t.len    = vma->vm_end - vma->vm_start,\n\t\t\t.pgoff  = (u64)vma->vm_pgoff << PAGE_SHIFT,\n\t\t},\n\t\t/* .maj (attr_mmap2 only) */\n\t\t/* .min (attr_mmap2 only) */\n\t\t/* .ino (attr_mmap2 only) */\n\t\t/* .ino_generation (attr_mmap2 only) */\n\t\t/* .prot (attr_mmap2 only) */\n\t\t/* .flags (attr_mmap2 only) */\n\t};\n\n\tperf_addr_filters_adjust(vma);\n\tperf_event_mmap_event(&mmap_event);\n}\n\nvoid perf_event_aux_event(struct perf_event *event, unsigned long head,\n\t\t\t  unsigned long size, u64 flags)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_aux_event {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\toffset;\n\t\tu64\t\t\t\tsize;\n\t\tu64\t\t\t\tflags;\n\t} rec = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_AUX,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(rec),\n\t\t},\n\t\t.offset\t\t= head,\n\t\t.size\t\t= size,\n\t\t.flags\t\t= flags,\n\t};\n\tint ret;\n\n\tperf_event_header__init_id(&rec.header, &sample, event);\n\tret = perf_output_begin(&handle, event, rec.header.size);\n\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, rec);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}\n\n/*\n * Lost/dropped samples logging\n */\nvoid perf_log_lost_samples(struct perf_event *event, u64 lost)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint ret;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\tlost;\n\t} lost_samples_event = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_LOST_SAMPLES,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(lost_samples_event),\n\t\t},\n\t\t.lost\t\t= lost,\n\t};\n\n\tperf_event_header__init_id(&lost_samples_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tlost_samples_event.header.size);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, lost_samples_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}\n\n/*\n * context_switch tracking\n */\n\nstruct perf_switch_event {\n\tstruct task_struct\t*task;\n\tstruct task_struct\t*next_prev;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\t\tu32\t\t\t\tnext_prev_pid;\n\t\tu32\t\t\t\tnext_prev_tid;\n\t} event_id;\n};\n\nstatic int perf_event_switch_match(struct perf_event *event)\n{\n\treturn event->attr.context_switch;\n}\n\nstatic void perf_event_switch_output(struct perf_event *event, void *data)\n{\n\tstruct perf_switch_event *se = data;\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint ret;\n\n\tif (!perf_event_switch_match(event))\n\t\treturn;\n\n\t/* Only CPU-wide events are allowed to see next/prev pid/tid */\n\tif (event->ctx->task) {\n\t\tse->event_id.header.type = PERF_RECORD_SWITCH;\n\t\tse->event_id.header.size = sizeof(se->event_id.header);\n\t} else {\n\t\tse->event_id.header.type = PERF_RECORD_SWITCH_CPU_WIDE;\n\t\tse->event_id.header.size = sizeof(se->event_id);\n\t\tse->event_id.next_prev_pid =\n\t\t\t\t\tperf_event_pid(event, se->next_prev);\n\t\tse->event_id.next_prev_tid =\n\t\t\t\t\tperf_event_tid(event, se->next_prev);\n\t}\n\n\tperf_event_header__init_id(&se->event_id.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event, se->event_id.header.size);\n\tif (ret)\n\t\treturn;\n\n\tif (event->ctx->task)\n\t\tperf_output_put(&handle, se->event_id.header);\n\telse\n\t\tperf_output_put(&handle, se->event_id);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}\n\nstatic void perf_event_switch(struct task_struct *task,\n\t\t\t      struct task_struct *next_prev, bool sched_in)\n{\n\tstruct perf_switch_event switch_event;\n\n\t/* N.B. caller checks nr_switch_events != 0 */\n\n\tswitch_event = (struct perf_switch_event){\n\t\t.task\t\t= task,\n\t\t.next_prev\t= next_prev,\n\t\t.event_id\t= {\n\t\t\t.header = {\n\t\t\t\t/* .type */\n\t\t\t\t.misc = sched_in ? 0 : PERF_RECORD_MISC_SWITCH_OUT,\n\t\t\t\t/* .size */\n\t\t\t},\n\t\t\t/* .next_prev_pid */\n\t\t\t/* .next_prev_tid */\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_switch_output,\n\t\t       &switch_event,\n\t\t       NULL);\n}\n\n/*\n * IRQ throttle logging\n */\n\nstatic void perf_log_throttle(struct perf_event *event, int enable)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint ret;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\ttime;\n\t\tu64\t\t\t\tid;\n\t\tu64\t\t\t\tstream_id;\n\t} throttle_event = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_THROTTLE,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(throttle_event),\n\t\t},\n\t\t.time\t\t= perf_event_clock(event),\n\t\t.id\t\t= primary_event_id(event),\n\t\t.stream_id\t= event->id,\n\t};\n\n\tif (enable)\n\t\tthrottle_event.header.type = PERF_RECORD_UNTHROTTLE;\n\n\tperf_event_header__init_id(&throttle_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tthrottle_event.header.size);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, throttle_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}\n\nstatic void perf_log_itrace_start(struct perf_event *event)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_aux_event {\n\t\tstruct perf_event_header        header;\n\t\tu32\t\t\t\tpid;\n\t\tu32\t\t\t\ttid;\n\t} rec;\n\tint ret;\n\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\tif (!(event->pmu->capabilities & PERF_PMU_CAP_ITRACE) ||\n\t    event->hw.itrace_started)\n\t\treturn;\n\n\trec.header.type\t= PERF_RECORD_ITRACE_START;\n\trec.header.misc\t= 0;\n\trec.header.size\t= sizeof(rec);\n\trec.pid\t= perf_event_pid(event, current);\n\trec.tid\t= perf_event_tid(event, current);\n\n\tperf_event_header__init_id(&rec.header, &sample, event);\n\tret = perf_output_begin(&handle, event, rec.header.size);\n\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, rec);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}\n\n/*\n * Generic event overflow handling, sampling.\n */\n\nstatic int __perf_event_overflow(struct perf_event *event,\n\t\t\t\t   int throttle, struct perf_sample_data *data,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tint events = atomic_read(&event->event_limit);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 seq;\n\tint ret = 0;\n\n\t/*\n\t * Non-sampling counters might still use the PMI to fold short\n\t * hardware counters, ignore those.\n\t */\n\tif (unlikely(!is_sampling_event(event)))\n\t\treturn 0;\n\n\tseq = __this_cpu_read(perf_throttled_seq);\n\tif (seq != hwc->interrupts_seq) {\n\t\thwc->interrupts_seq = seq;\n\t\thwc->interrupts = 1;\n\t} else {\n\t\thwc->interrupts++;\n\t\tif (unlikely(throttle\n\t\t\t     && hwc->interrupts >= max_samples_per_tick)) {\n\t\t\t__this_cpu_inc(perf_throttled_count);\n\t\t\ttick_dep_set_cpu(smp_processor_id(), TICK_DEP_BIT_PERF_EVENTS);\n\t\t\thwc->interrupts = MAX_INTERRUPTS;\n\t\t\tperf_log_throttle(event, 0);\n\t\t\tret = 1;\n\t\t}\n\t}\n\n\tif (event->attr.freq) {\n\t\tu64 now = perf_clock();\n\t\ts64 delta = now - hwc->freq_time_stamp;\n\n\t\thwc->freq_time_stamp = now;\n\n\t\tif (delta > 0 && delta < 2*TICK_NSEC)\n\t\t\tperf_adjust_period(event, delta, hwc->last_period, true);\n\t}\n\n\t/*\n\t * XXX event_limit might not quite work as expected on inherited\n\t * events\n\t */\n\n\tevent->pending_kill = POLL_IN;\n\tif (events && atomic_dec_and_test(&event->event_limit)) {\n\t\tret = 1;\n\t\tevent->pending_kill = POLL_HUP;\n\n\t\tperf_event_disable_inatomic(event);\n\t}\n\n\tREAD_ONCE(event->overflow_handler)(event, data, regs);\n\n\tif (*perf_event_fasync(event) && event->pending_kill) {\n\t\tevent->pending_wakeup = 1;\n\t\tirq_work_queue(&event->pending);\n\t}\n\n\treturn ret;\n}\n\nint perf_event_overflow(struct perf_event *event,\n\t\t\t  struct perf_sample_data *data,\n\t\t\t  struct pt_regs *regs)\n{\n\treturn __perf_event_overflow(event, 1, data, regs);\n}\n\n/*\n * Generic software event infrastructure\n */\n\nstruct swevent_htable {\n\tstruct swevent_hlist\t\t*swevent_hlist;\n\tstruct mutex\t\t\thlist_mutex;\n\tint\t\t\t\thlist_refcount;\n\n\t/* Recursion avoidance in each contexts */\n\tint\t\t\t\trecursion[PERF_NR_CONTEXTS];\n};\n\nstatic DEFINE_PER_CPU(struct swevent_htable, swevent_htable);\n\n/*\n * We directly increment event->count and keep a second value in\n * event->hw.period_left to count intervals. This period event\n * is kept in the range [-sample_period, 0] so that we can use the\n * sign as trigger.\n */\n\nu64 perf_swevent_set_period(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 period = hwc->last_period;\n\tu64 nr, offset;\n\ts64 old, val;\n\n\thwc->last_period = hwc->sample_period;\n\nagain:\n\told = val = local64_read(&hwc->period_left);\n\tif (val < 0)\n\t\treturn 0;\n\n\tnr = div64_u64(period + val, period);\n\toffset = nr * period;\n\tval -= offset;\n\tif (local64_cmpxchg(&hwc->period_left, old, val) != old)\n\t\tgoto again;\n\n\treturn nr;\n}\n\nstatic void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n\t\t\t\t    struct perf_sample_data *data,\n\t\t\t\t    struct pt_regs *regs)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint throttle = 0;\n\n\tif (!overflow)\n\t\toverflow = perf_swevent_set_period(event);\n\n\tif (hwc->interrupts == MAX_INTERRUPTS)\n\t\treturn;\n\n\tfor (; overflow; overflow--) {\n\t\tif (__perf_event_overflow(event, throttle,\n\t\t\t\t\t    data, regs)) {\n\t\t\t/*\n\t\t\t * We inhibit the overflow from happening when\n\t\t\t * hwc->interrupts == MAX_INTERRUPTS.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tthrottle = 1;\n\t}\n}\n\nstatic void perf_swevent_event(struct perf_event *event, u64 nr,\n\t\t\t       struct perf_sample_data *data,\n\t\t\t       struct pt_regs *regs)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tlocal64_add(nr, &event->count);\n\n\tif (!regs)\n\t\treturn;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\tif ((event->attr.sample_type & PERF_SAMPLE_PERIOD) && !event->attr.freq) {\n\t\tdata->period = nr;\n\t\treturn perf_swevent_overflow(event, 1, data, regs);\n\t} else\n\t\tdata->period = event->hw.last_period;\n\n\tif (nr == 1 && hwc->sample_period == 1 && !event->attr.freq)\n\t\treturn perf_swevent_overflow(event, 1, data, regs);\n\n\tif (local64_add_negative(nr, &hwc->period_left))\n\t\treturn;\n\n\tperf_swevent_overflow(event, 0, data, regs);\n}\n\nstatic int perf_exclude_event(struct perf_event *event,\n\t\t\t      struct pt_regs *regs)\n{\n\tif (event->hw.state & PERF_HES_STOPPED)\n\t\treturn 1;\n\n\tif (regs) {\n\t\tif (event->attr.exclude_user && user_mode(regs))\n\t\t\treturn 1;\n\n\t\tif (event->attr.exclude_kernel && !user_mode(regs))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int perf_swevent_match(struct perf_event *event,\n\t\t\t\tenum perf_type_id type,\n\t\t\t\tu32 event_id,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct pt_regs *regs)\n{\n\tif (event->attr.type != type)\n\t\treturn 0;\n\n\tif (event->attr.config != event_id)\n\t\treturn 0;\n\n\tif (perf_exclude_event(event, regs))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline u64 swevent_hash(u64 type, u32 event_id)\n{\n\tu64 val = event_id | (type << 32);\n\n\treturn hash_64(val, SWEVENT_HLIST_BITS);\n}\n\nstatic inline struct hlist_head *\n__find_swevent_head(struct swevent_hlist *hlist, u64 type, u32 event_id)\n{\n\tu64 hash = swevent_hash(type, event_id);\n\n\treturn &hlist->heads[hash];\n}\n\n/* For the read side: events when they trigger */\nstatic inline struct hlist_head *\nfind_swevent_head_rcu(struct swevent_htable *swhash, u64 type, u32 event_id)\n{\n\tstruct swevent_hlist *hlist;\n\n\thlist = rcu_dereference(swhash->swevent_hlist);\n\tif (!hlist)\n\t\treturn NULL;\n\n\treturn __find_swevent_head(hlist, type, event_id);\n}\n\n/* For the event head insertion and removal in the hlist */\nstatic inline struct hlist_head *\nfind_swevent_head(struct swevent_htable *swhash, struct perf_event *event)\n{\n\tstruct swevent_hlist *hlist;\n\tu32 event_id = event->attr.config;\n\tu64 type = event->attr.type;\n\n\t/*\n\t * Event scheduling is always serialized against hlist allocation\n\t * and release. Which makes the protected version suitable here.\n\t * The context lock guarantees that.\n\t */\n\thlist = rcu_dereference_protected(swhash->swevent_hlist,\n\t\t\t\t\t  lockdep_is_held(&event->ctx->lock));\n\tif (!hlist)\n\t\treturn NULL;\n\n\treturn __find_swevent_head(hlist, type, event_id);\n}\n\nstatic void do_perf_sw_event(enum perf_type_id type, u32 event_id,\n\t\t\t\t    u64 nr,\n\t\t\t\t    struct perf_sample_data *data,\n\t\t\t\t    struct pt_regs *regs)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct perf_event *event;\n\tstruct hlist_head *head;\n\n\trcu_read_lock();\n\thead = find_swevent_head_rcu(swhash, type, event_id);\n\tif (!head)\n\t\tgoto end;\n\n\thlist_for_each_entry_rcu(event, head, hlist_entry) {\n\t\tif (perf_swevent_match(event, type, event_id, data, regs))\n\t\t\tperf_swevent_event(event, nr, data, regs);\n\t}\nend:\n\trcu_read_unlock();\n}\n\nDEFINE_PER_CPU(struct pt_regs, __perf_regs[4]);\n\nint perf_swevent_get_recursion_context(void)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\treturn get_recursion_context(swhash->recursion);\n}\nEXPORT_SYMBOL_GPL(perf_swevent_get_recursion_context);\n\nvoid perf_swevent_put_recursion_context(int rctx)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\tput_recursion_context(swhash->recursion, rctx);\n}\n\nvoid ___perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tstruct perf_sample_data data;\n\n\tif (WARN_ON_ONCE(!regs))\n\t\treturn;\n\n\tperf_sample_data_init(&data, addr, 0);\n\tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, &data, regs);\n}\n\nvoid __perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tint rctx;\n\n\tpreempt_disable_notrace();\n\trctx = perf_swevent_get_recursion_context();\n\tif (unlikely(rctx < 0))\n\t\tgoto fail;\n\n\t___perf_sw_event(event_id, nr, regs, addr);\n\n\tperf_swevent_put_recursion_context(rctx);\nfail:\n\tpreempt_enable_notrace();\n}\n\nstatic void perf_swevent_read(struct perf_event *event)\n{\n}\n\nstatic int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\n\thwc->state = !(flags & PERF_EF_START);\n\n\thead = find_swevent_head(swhash, event);\n\tif (WARN_ON_ONCE(!head))\n\t\treturn -EINVAL;\n\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void perf_swevent_del(struct perf_event *event, int flags)\n{\n\thlist_del_rcu(&event->hlist_entry);\n}\n\nstatic void perf_swevent_start(struct perf_event *event, int flags)\n{\n\tevent->hw.state = 0;\n}\n\nstatic void perf_swevent_stop(struct perf_event *event, int flags)\n{\n\tevent->hw.state = PERF_HES_STOPPED;\n}\n\n/* Deref the hlist from the update side */\nstatic inline struct swevent_hlist *\nswevent_hlist_deref(struct swevent_htable *swhash)\n{\n\treturn rcu_dereference_protected(swhash->swevent_hlist,\n\t\t\t\t\t lockdep_is_held(&swhash->hlist_mutex));\n}\n\nstatic void swevent_hlist_release(struct swevent_htable *swhash)\n{\n\tstruct swevent_hlist *hlist = swevent_hlist_deref(swhash);\n\n\tif (!hlist)\n\t\treturn;\n\n\tRCU_INIT_POINTER(swhash->swevent_hlist, NULL);\n\tkfree_rcu(hlist, rcu_head);\n}\n\nstatic void swevent_hlist_put_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\n\tmutex_lock(&swhash->hlist_mutex);\n\n\tif (!--swhash->hlist_refcount)\n\t\tswevent_hlist_release(swhash);\n\n\tmutex_unlock(&swhash->hlist_mutex);\n}\n\nstatic void swevent_hlist_put(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tswevent_hlist_put_cpu(cpu);\n}\n\nstatic int swevent_hlist_get_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tint err = 0;\n\n\tmutex_lock(&swhash->hlist_mutex);\n\tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc(sizeof(*hlist), GFP_KERNEL);\n\t\tif (!hlist) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\n\treturn err;\n}\n\nstatic int swevent_hlist_get(void)\n{\n\tint err, cpu, failed_cpu;\n\n\tget_online_cpus();\n\tfor_each_possible_cpu(cpu) {\n\t\terr = swevent_hlist_get_cpu(cpu);\n\t\tif (err) {\n\t\t\tfailed_cpu = cpu;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tput_online_cpus();\n\n\treturn 0;\nfail:\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == failed_cpu)\n\t\t\tbreak;\n\t\tswevent_hlist_put_cpu(cpu);\n\t}\n\n\tput_online_cpus();\n\treturn err;\n}\n\nstruct static_key perf_swevent_enabled[PERF_COUNT_SW_MAX];\n\nstatic void sw_perf_event_destroy(struct perf_event *event)\n{\n\tu64 event_id = event->attr.config;\n\n\tWARN_ON(event->parent);\n\n\tstatic_key_slow_dec(&perf_swevent_enabled[event_id]);\n\tswevent_hlist_put();\n}\n\nstatic int perf_swevent_init(struct perf_event *event)\n{\n\tu64 event_id = event->attr.config;\n\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\n\tif (!event->parent) {\n\t\tint err;\n\n\t\terr = swevent_hlist_get();\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\n\treturn 0;\n}\n\nstatic struct pmu perf_swevent = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.capabilities\t= PERF_PMU_CAP_NO_NMI,\n\n\t.event_init\t= perf_swevent_init,\n\t.add\t\t= perf_swevent_add,\n\t.del\t\t= perf_swevent_del,\n\t.start\t\t= perf_swevent_start,\n\t.stop\t\t= perf_swevent_stop,\n\t.read\t\t= perf_swevent_read,\n};\n\n#ifdef CONFIG_EVENT_TRACING\n\nstatic int perf_tp_filter_match(struct perf_event *event,\n\t\t\t\tstruct perf_sample_data *data)\n{\n\tvoid *record = data->raw->frag.data;\n\n\t/* only top level events have filters set */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\tif (likely(!event->filter) || filter_match_preds(event->filter, record))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int perf_tp_event_match(struct perf_event *event,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct pt_regs *regs)\n{\n\tif (event->hw.state & PERF_HES_STOPPED)\n\t\treturn 0;\n\t/*\n\t * All tracepoints are from kernel-space.\n\t */\n\tif (event->attr.exclude_kernel)\n\t\treturn 0;\n\n\tif (!perf_tp_filter_match(event, data))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nvoid perf_trace_run_bpf_submit(void *raw_data, int size, int rctx,\n\t\t\t       struct trace_event_call *call, u64 count,\n\t\t\t       struct pt_regs *regs, struct hlist_head *head,\n\t\t\t       struct task_struct *task)\n{\n\tstruct bpf_prog *prog = call->prog;\n\n\tif (prog) {\n\t\t*(struct pt_regs **)raw_data = regs;\n\t\tif (!trace_call_bpf(prog, raw_data) || hlist_empty(head)) {\n\t\t\tperf_swevent_put_recursion_context(rctx);\n\t\t\treturn;\n\t\t}\n\t}\n\tperf_tp_event(call->event.type, count, raw_data, size, regs, head,\n\t\t      rctx, task);\n}\nEXPORT_SYMBOL_GPL(perf_trace_run_bpf_submit);\n\nvoid perf_tp_event(u16 event_type, u64 count, void *record, int entry_size,\n\t\t   struct pt_regs *regs, struct hlist_head *head, int rctx,\n\t\t   struct task_struct *task)\n{\n\tstruct perf_sample_data data;\n\tstruct perf_event *event;\n\n\tstruct perf_raw_record raw = {\n\t\t.frag = {\n\t\t\t.size = entry_size,\n\t\t\t.data = record,\n\t\t},\n\t};\n\n\tperf_sample_data_init(&data, 0, 0);\n\tdata.raw = &raw;\n\n\tperf_trace_buf_update(record, event_type);\n\n\thlist_for_each_entry_rcu(event, head, hlist_entry) {\n\t\tif (perf_tp_event_match(event, &data, regs))\n\t\t\tperf_swevent_event(event, count, &data, regs);\n\t}\n\n\t/*\n\t * If we got specified a target task, also iterate its context and\n\t * deliver this event there too.\n\t */\n\tif (task && task != current) {\n\t\tstruct perf_event_context *ctx;\n\t\tstruct trace_entry *entry = record;\n\n\t\trcu_read_lock();\n\t\tctx = rcu_dereference(task->perf_event_ctxp[perf_sw_context]);\n\t\tif (!ctx)\n\t\t\tgoto unlock;\n\n\t\tlist_for_each_entry_rcu(event, &ctx->event_list, event_entry) {\n\t\t\tif (event->attr.type != PERF_TYPE_TRACEPOINT)\n\t\t\t\tcontinue;\n\t\t\tif (event->attr.config != entry->type)\n\t\t\t\tcontinue;\n\t\t\tif (perf_tp_event_match(event, &data, regs))\n\t\t\t\tperf_swevent_event(event, count, &data, regs);\n\t\t}\nunlock:\n\t\trcu_read_unlock();\n\t}\n\n\tperf_swevent_put_recursion_context(rctx);\n}\nEXPORT_SYMBOL_GPL(perf_tp_event);\n\nstatic void tp_perf_event_destroy(struct perf_event *event)\n{\n\tperf_trace_destroy(event);\n}\n\nstatic int perf_tp_event_init(struct perf_event *event)\n{\n\tint err;\n\n\tif (event->attr.type != PERF_TYPE_TRACEPOINT)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for tracepoint events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\terr = perf_trace_init(event);\n\tif (err)\n\t\treturn err;\n\n\tevent->destroy = tp_perf_event_destroy;\n\n\treturn 0;\n}\n\nstatic struct pmu perf_tracepoint = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.event_init\t= perf_tp_event_init,\n\t.add\t\t= perf_trace_add,\n\t.del\t\t= perf_trace_del,\n\t.start\t\t= perf_swevent_start,\n\t.stop\t\t= perf_swevent_stop,\n\t.read\t\t= perf_swevent_read,\n};\n\nstatic inline void perf_tp_register(void)\n{\n\tperf_pmu_register(&perf_tracepoint, \"tracepoint\", PERF_TYPE_TRACEPOINT);\n}\n\nstatic void perf_event_free_filter(struct perf_event *event)\n{\n\tftrace_profile_free_filter(event);\n}\n\n#ifdef CONFIG_BPF_SYSCALL\nstatic void bpf_overflow_handler(struct perf_event *event,\n\t\t\t\t struct perf_sample_data *data,\n\t\t\t\t struct pt_regs *regs)\n{\n\tstruct bpf_perf_event_data_kern ctx = {\n\t\t.data = data,\n\t\t.regs = regs,\n\t};\n\tint ret = 0;\n\n\tpreempt_disable();\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1))\n\t\tgoto out;\n\trcu_read_lock();\n\tret = BPF_PROG_RUN(event->prog, &ctx);\n\trcu_read_unlock();\nout:\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\tif (!ret)\n\t\treturn;\n\n\tevent->orig_overflow_handler(event, data, regs);\n}\n\nstatic int perf_event_set_bpf_handler(struct perf_event *event, u32 prog_fd)\n{\n\tstruct bpf_prog *prog;\n\n\tif (event->overflow_handler_context)\n\t\t/* hw breakpoint or kernel counter */\n\t\treturn -EINVAL;\n\n\tif (event->prog)\n\t\treturn -EEXIST;\n\n\tprog = bpf_prog_get_type(prog_fd, BPF_PROG_TYPE_PERF_EVENT);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tevent->prog = prog;\n\tevent->orig_overflow_handler = READ_ONCE(event->overflow_handler);\n\tWRITE_ONCE(event->overflow_handler, bpf_overflow_handler);\n\treturn 0;\n}\n\nstatic void perf_event_free_bpf_handler(struct perf_event *event)\n{\n\tstruct bpf_prog *prog = event->prog;\n\n\tif (!prog)\n\t\treturn;\n\n\tWRITE_ONCE(event->overflow_handler, event->orig_overflow_handler);\n\tevent->prog = NULL;\n\tbpf_prog_put(prog);\n}\n#else\nstatic int perf_event_set_bpf_handler(struct perf_event *event, u32 prog_fd)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic void perf_event_free_bpf_handler(struct perf_event *event)\n{\n}\n#endif\n\nstatic int perf_event_set_bpf_prog(struct perf_event *event, u32 prog_fd)\n{\n\tbool is_kprobe, is_tracepoint;\n\tstruct bpf_prog *prog;\n\n\tif (event->attr.type == PERF_TYPE_HARDWARE ||\n\t    event->attr.type == PERF_TYPE_SOFTWARE)\n\t\treturn perf_event_set_bpf_handler(event, prog_fd);\n\n\tif (event->attr.type != PERF_TYPE_TRACEPOINT)\n\t\treturn -EINVAL;\n\n\tif (event->tp_event->prog)\n\t\treturn -EEXIST;\n\n\tis_kprobe = event->tp_event->flags & TRACE_EVENT_FL_UKPROBE;\n\tis_tracepoint = event->tp_event->flags & TRACE_EVENT_FL_TRACEPOINT;\n\tif (!is_kprobe && !is_tracepoint)\n\t\t/* bpf programs can only be attached to u/kprobe or tracepoint */\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tif ((is_kprobe && prog->type != BPF_PROG_TYPE_KPROBE) ||\n\t    (is_tracepoint && prog->type != BPF_PROG_TYPE_TRACEPOINT)) {\n\t\t/* valid fd, but invalid bpf program type */\n\t\tbpf_prog_put(prog);\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_tracepoint) {\n\t\tint off = trace_event_get_offsets(event->tp_event);\n\n\t\tif (prog->aux->max_ctx_offset > off) {\n\t\t\tbpf_prog_put(prog);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\tevent->tp_event->prog = prog;\n\n\treturn 0;\n}\n\nstatic void perf_event_free_bpf_prog(struct perf_event *event)\n{\n\tstruct bpf_prog *prog;\n\n\tperf_event_free_bpf_handler(event);\n\n\tif (!event->tp_event)\n\t\treturn;\n\n\tprog = event->tp_event->prog;\n\tif (prog) {\n\t\tevent->tp_event->prog = NULL;\n\t\tbpf_prog_put(prog);\n\t}\n}\n\n#else\n\nstatic inline void perf_tp_register(void)\n{\n}\n\nstatic void perf_event_free_filter(struct perf_event *event)\n{\n}\n\nstatic int perf_event_set_bpf_prog(struct perf_event *event, u32 prog_fd)\n{\n\treturn -ENOENT;\n}\n\nstatic void perf_event_free_bpf_prog(struct perf_event *event)\n{\n}\n#endif /* CONFIG_EVENT_TRACING */\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\nvoid perf_bp_event(struct perf_event *bp, void *data)\n{\n\tstruct perf_sample_data sample;\n\tstruct pt_regs *regs = data;\n\n\tperf_sample_data_init(&sample, bp->attr.bp_addr, 0);\n\n\tif (!bp->hw.state && !perf_exclude_event(bp, regs))\n\t\tperf_swevent_event(bp, 1, &sample, regs);\n}\n#endif\n\n/*\n * Allocate a new address filter\n */\nstatic struct perf_addr_filter *\nperf_addr_filter_new(struct perf_event *event, struct list_head *filters)\n{\n\tint node = cpu_to_node(event->cpu == -1 ? 0 : event->cpu);\n\tstruct perf_addr_filter *filter;\n\n\tfilter = kzalloc_node(sizeof(*filter), GFP_KERNEL, node);\n\tif (!filter)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&filter->entry);\n\tlist_add_tail(&filter->entry, filters);\n\n\treturn filter;\n}\n\nstatic void free_filters_list(struct list_head *filters)\n{\n\tstruct perf_addr_filter *filter, *iter;\n\n\tlist_for_each_entry_safe(filter, iter, filters, entry) {\n\t\tif (filter->inode)\n\t\t\tiput(filter->inode);\n\t\tlist_del(&filter->entry);\n\t\tkfree(filter);\n\t}\n}\n\n/*\n * Free existing address filters and optionally install new ones\n */\nstatic void perf_addr_filters_splice(struct perf_event *event,\n\t\t\t\t     struct list_head *head)\n{\n\tunsigned long flags;\n\tLIST_HEAD(list);\n\n\tif (!has_addr_filter(event))\n\t\treturn;\n\n\t/* don't bother with children, they don't have their own filters */\n\tif (event->parent)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&event->addr_filters.lock, flags);\n\n\tlist_splice_init(&event->addr_filters.list, &list);\n\tif (head)\n\t\tlist_splice(head, &event->addr_filters.list);\n\n\traw_spin_unlock_irqrestore(&event->addr_filters.lock, flags);\n\n\tfree_filters_list(&list);\n}\n\n/*\n * Scan through mm's vmas and see if one of them matches the\n * @filter; if so, adjust filter's address range.\n * Called with mm::mmap_sem down for reading.\n */\nstatic unsigned long perf_addr_filter_apply(struct perf_addr_filter *filter,\n\t\t\t\t\t    struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tstruct file *file = vma->vm_file;\n\t\tunsigned long off = vma->vm_pgoff << PAGE_SHIFT;\n\t\tunsigned long vma_size = vma->vm_end - vma->vm_start;\n\n\t\tif (!file)\n\t\t\tcontinue;\n\n\t\tif (!perf_addr_filter_match(filter, file, off, vma_size))\n\t\t\tcontinue;\n\n\t\treturn vma->vm_start;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Update event's address range filters based on the\n * task's existing mappings, if any.\n */\nstatic void perf_event_addr_filters_apply(struct perf_event *event)\n{\n\tstruct perf_addr_filters_head *ifh = perf_event_addr_filters(event);\n\tstruct task_struct *task = READ_ONCE(event->ctx->task);\n\tstruct perf_addr_filter *filter;\n\tstruct mm_struct *mm = NULL;\n\tunsigned int count = 0;\n\tunsigned long flags;\n\n\t/*\n\t * We may observe TASK_TOMBSTONE, which means that the event tear-down\n\t * will stop on the parent's child_mutex that our caller is also holding\n\t */\n\tif (task == TASK_TOMBSTONE)\n\t\treturn;\n\n\tmm = get_task_mm(event->ctx->task);\n\tif (!mm)\n\t\tgoto restart;\n\n\tdown_read(&mm->mmap_sem);\n\n\traw_spin_lock_irqsave(&ifh->lock, flags);\n\tlist_for_each_entry(filter, &ifh->list, entry) {\n\t\tevent->addr_filters_offs[count] = 0;\n\n\t\t/*\n\t\t * Adjust base offset if the filter is associated to a binary\n\t\t * that needs to be mapped:\n\t\t */\n\t\tif (filter->inode)\n\t\t\tevent->addr_filters_offs[count] =\n\t\t\t\tperf_addr_filter_apply(filter, mm);\n\n\t\tcount++;\n\t}\n\n\tevent->addr_filters_gen++;\n\traw_spin_unlock_irqrestore(&ifh->lock, flags);\n\n\tup_read(&mm->mmap_sem);\n\n\tmmput(mm);\n\nrestart:\n\tperf_event_stop(event, 1);\n}\n\n/*\n * Address range filtering: limiting the data to certain\n * instruction address ranges. Filters are ioctl()ed to us from\n * userspace as ascii strings.\n *\n * Filter string format:\n *\n * ACTION RANGE_SPEC\n * where ACTION is one of the\n *  * \"filter\": limit the trace to this region\n *  * \"start\": start tracing from this address\n *  * \"stop\": stop tracing at this address/region;\n * RANGE_SPEC is\n *  * for kernel addresses: <start address>[/<size>]\n *  * for object files:     <start address>[/<size>]@</path/to/object/file>\n *\n * if <size> is not specified, the range is treated as a single address.\n */\nenum {\n\tIF_ACT_NONE = -1,\n\tIF_ACT_FILTER,\n\tIF_ACT_START,\n\tIF_ACT_STOP,\n\tIF_SRC_FILE,\n\tIF_SRC_KERNEL,\n\tIF_SRC_FILEADDR,\n\tIF_SRC_KERNELADDR,\n};\n\nenum {\n\tIF_STATE_ACTION = 0,\n\tIF_STATE_SOURCE,\n\tIF_STATE_END,\n};\n\nstatic const match_table_t if_tokens = {\n\t{ IF_ACT_FILTER,\t\"filter\" },\n\t{ IF_ACT_START,\t\t\"start\" },\n\t{ IF_ACT_STOP,\t\t\"stop\" },\n\t{ IF_SRC_FILE,\t\t\"%u/%u@%s\" },\n\t{ IF_SRC_KERNEL,\t\"%u/%u\" },\n\t{ IF_SRC_FILEADDR,\t\"%u@%s\" },\n\t{ IF_SRC_KERNELADDR,\t\"%u\" },\n\t{ IF_ACT_NONE,\t\tNULL },\n};\n\n/*\n * Address filter string parser\n */\nstatic int\nperf_event_parse_addr_filter(struct perf_event *event, char *fstr,\n\t\t\t     struct list_head *filters)\n{\n\tstruct perf_addr_filter *filter = NULL;\n\tchar *start, *orig, *filename = NULL;\n\tstruct path path;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint state = IF_STATE_ACTION, token;\n\tunsigned int kernel = 0;\n\tint ret = -EINVAL;\n\n\torig = fstr = kstrdup(fstr, GFP_KERNEL);\n\tif (!fstr)\n\t\treturn -ENOMEM;\n\n\twhile ((start = strsep(&fstr, \" ,\\n\")) != NULL) {\n\t\tret = -EINVAL;\n\n\t\tif (!*start)\n\t\t\tcontinue;\n\n\t\t/* filter definition begins */\n\t\tif (state == IF_STATE_ACTION) {\n\t\t\tfilter = perf_addr_filter_new(event, filters);\n\t\t\tif (!filter)\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\ttoken = match_token(start, if_tokens, args);\n\t\tswitch (token) {\n\t\tcase IF_ACT_FILTER:\n\t\tcase IF_ACT_START:\n\t\t\tfilter->filter = 1;\n\n\t\tcase IF_ACT_STOP:\n\t\t\tif (state != IF_STATE_ACTION)\n\t\t\t\tgoto fail;\n\n\t\t\tstate = IF_STATE_SOURCE;\n\t\t\tbreak;\n\n\t\tcase IF_SRC_KERNELADDR:\n\t\tcase IF_SRC_KERNEL:\n\t\t\tkernel = 1;\n\n\t\tcase IF_SRC_FILEADDR:\n\t\tcase IF_SRC_FILE:\n\t\t\tif (state != IF_STATE_SOURCE)\n\t\t\t\tgoto fail;\n\n\t\t\tif (token == IF_SRC_FILE || token == IF_SRC_KERNEL)\n\t\t\t\tfilter->range = 1;\n\n\t\t\t*args[0].to = 0;\n\t\t\tret = kstrtoul(args[0].from, 0, &filter->offset);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\n\t\t\tif (filter->range) {\n\t\t\t\t*args[1].to = 0;\n\t\t\t\tret = kstrtoul(args[1].from, 0, &filter->size);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (token == IF_SRC_FILE || token == IF_SRC_FILEADDR) {\n\t\t\t\tint fpos = filter->range ? 2 : 1;\n\n\t\t\t\tfilename = match_strdup(&args[fpos]);\n\t\t\t\tif (!filename) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate = IF_STATE_END;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Filter definition is fully parsed, validate and install it.\n\t\t * Make sure that it doesn't contradict itself or the event's\n\t\t * attribute.\n\t\t */\n\t\tif (state == IF_STATE_END) {\n\t\t\tif (kernel && event->attr.exclude_kernel)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!kernel) {\n\t\t\t\tif (!filename)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\t/* look up the path and grab its inode */\n\t\t\t\tret = kern_path(filename, LOOKUP_FOLLOW, &path);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto fail_free_name;\n\n\t\t\t\tfilter->inode = igrab(d_inode(path.dentry));\n\t\t\t\tpath_put(&path);\n\t\t\t\tkfree(filename);\n\t\t\t\tfilename = NULL;\n\n\t\t\t\tret = -EINVAL;\n\t\t\t\tif (!filter->inode ||\n\t\t\t\t    !S_ISREG(filter->inode->i_mode))\n\t\t\t\t\t/* free_filters_list() will iput() */\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* ready to consume more filters */\n\t\t\tstate = IF_STATE_ACTION;\n\t\t\tfilter = NULL;\n\t\t}\n\t}\n\n\tif (state != IF_STATE_ACTION)\n\t\tgoto fail;\n\n\tkfree(orig);\n\n\treturn 0;\n\nfail_free_name:\n\tkfree(filename);\nfail:\n\tfree_filters_list(filters);\n\tkfree(orig);\n\n\treturn ret;\n}\n\nstatic int\nperf_event_set_addr_filter(struct perf_event *event, char *filter_str)\n{\n\tLIST_HEAD(filters);\n\tint ret;\n\n\t/*\n\t * Since this is called in perf_ioctl() path, we're already holding\n\t * ctx::mutex.\n\t */\n\tlockdep_assert_held(&event->ctx->mutex);\n\n\tif (WARN_ON_ONCE(event->parent))\n\t\treturn -EINVAL;\n\n\t/*\n\t * For now, we only support filtering in per-task events; doing so\n\t * for CPU-wide events requires additional context switching trickery,\n\t * since same object code will be mapped at different virtual\n\t * addresses in different processes.\n\t */\n\tif (!event->ctx->task)\n\t\treturn -EOPNOTSUPP;\n\n\tret = perf_event_parse_addr_filter(event, filter_str, &filters);\n\tif (ret)\n\t\treturn ret;\n\n\tret = event->pmu->addr_filters_validate(&filters);\n\tif (ret) {\n\t\tfree_filters_list(&filters);\n\t\treturn ret;\n\t}\n\n\t/* remove existing filters, if any */\n\tperf_addr_filters_splice(event, &filters);\n\n\t/* install new filters */\n\tperf_event_for_each_child(event, perf_event_addr_filters_apply);\n\n\treturn ret;\n}\n\nstatic int perf_event_set_filter(struct perf_event *event, void __user *arg)\n{\n\tchar *filter_str;\n\tint ret = -EINVAL;\n\n\tif ((event->attr.type != PERF_TYPE_TRACEPOINT ||\n\t    !IS_ENABLED(CONFIG_EVENT_TRACING)) &&\n\t    !has_addr_filter(event))\n\t\treturn -EINVAL;\n\n\tfilter_str = strndup_user(arg, PAGE_SIZE);\n\tif (IS_ERR(filter_str))\n\t\treturn PTR_ERR(filter_str);\n\n\tif (IS_ENABLED(CONFIG_EVENT_TRACING) &&\n\t    event->attr.type == PERF_TYPE_TRACEPOINT)\n\t\tret = ftrace_profile_set_filter(event, event->attr.config,\n\t\t\t\t\t\tfilter_str);\n\telse if (has_addr_filter(event))\n\t\tret = perf_event_set_addr_filter(event, filter_str);\n\n\tkfree(filter_str);\n\treturn ret;\n}\n\n/*\n * hrtimer based swevent callback\n */\n\nstatic enum hrtimer_restart perf_swevent_hrtimer(struct hrtimer *hrtimer)\n{\n\tenum hrtimer_restart ret = HRTIMER_RESTART;\n\tstruct perf_sample_data data;\n\tstruct pt_regs *regs;\n\tstruct perf_event *event;\n\tu64 period;\n\n\tevent = container_of(hrtimer, struct perf_event, hw.hrtimer);\n\n\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\treturn HRTIMER_NORESTART;\n\n\tevent->pmu->read(event);\n\n\tperf_sample_data_init(&data, 0, event->hw.last_period);\n\tregs = get_irq_regs();\n\n\tif (regs && !perf_exclude_event(event, regs)) {\n\t\tif (!(event->attr.exclude_idle && is_idle_task(current)))\n\t\t\tif (__perf_event_overflow(event, 1, &data, regs))\n\t\t\t\tret = HRTIMER_NORESTART;\n\t}\n\n\tperiod = max_t(u64, 10000, event->hw.sample_period);\n\thrtimer_forward_now(hrtimer, ns_to_ktime(period));\n\n\treturn ret;\n}\n\nstatic void perf_swevent_start_hrtimer(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\ts64 period;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\tperiod = local64_read(&hwc->period_left);\n\tif (period) {\n\t\tif (period < 0)\n\t\t\tperiod = 10000;\n\n\t\tlocal64_set(&hwc->period_left, 0);\n\t} else {\n\t\tperiod = max_t(u64, 10000, hwc->sample_period);\n\t}\n\thrtimer_start(&hwc->hrtimer, ns_to_ktime(period),\n\t\t      HRTIMER_MODE_REL_PINNED);\n}\n\nstatic void perf_swevent_cancel_hrtimer(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (is_sampling_event(event)) {\n\t\tktime_t remaining = hrtimer_get_remaining(&hwc->hrtimer);\n\t\tlocal64_set(&hwc->period_left, ktime_to_ns(remaining));\n\n\t\thrtimer_cancel(&hwc->hrtimer);\n\t}\n}\n\nstatic void perf_swevent_init_hrtimer(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\thrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thwc->hrtimer.function = perf_swevent_hrtimer;\n\n\t/*\n\t * Since hrtimers have a fixed rate, we can do a static freq->period\n\t * mapping and avoid the whole period adjust feedback stuff.\n\t */\n\tif (event->attr.freq) {\n\t\tlong freq = event->attr.sample_freq;\n\n\t\tevent->attr.sample_period = NSEC_PER_SEC / freq;\n\t\thwc->sample_period = event->attr.sample_period;\n\t\tlocal64_set(&hwc->period_left, hwc->sample_period);\n\t\thwc->last_period = hwc->sample_period;\n\t\tevent->attr.freq = 0;\n\t}\n}\n\n/*\n * Software event: cpu wall time clock\n */\n\nstatic void cpu_clock_event_update(struct perf_event *event)\n{\n\ts64 prev;\n\tu64 now;\n\n\tnow = local_clock();\n\tprev = local64_xchg(&event->hw.prev_count, now);\n\tlocal64_add(now - prev, &event->count);\n}\n\nstatic void cpu_clock_event_start(struct perf_event *event, int flags)\n{\n\tlocal64_set(&event->hw.prev_count, local_clock());\n\tperf_swevent_start_hrtimer(event);\n}\n\nstatic void cpu_clock_event_stop(struct perf_event *event, int flags)\n{\n\tperf_swevent_cancel_hrtimer(event);\n\tcpu_clock_event_update(event);\n}\n\nstatic int cpu_clock_event_add(struct perf_event *event, int flags)\n{\n\tif (flags & PERF_EF_START)\n\t\tcpu_clock_event_start(event, flags);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void cpu_clock_event_del(struct perf_event *event, int flags)\n{\n\tcpu_clock_event_stop(event, flags);\n}\n\nstatic void cpu_clock_event_read(struct perf_event *event)\n{\n\tcpu_clock_event_update(event);\n}\n\nstatic int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}\n\nstatic struct pmu perf_cpu_clock = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.capabilities\t= PERF_PMU_CAP_NO_NMI,\n\n\t.event_init\t= cpu_clock_event_init,\n\t.add\t\t= cpu_clock_event_add,\n\t.del\t\t= cpu_clock_event_del,\n\t.start\t\t= cpu_clock_event_start,\n\t.stop\t\t= cpu_clock_event_stop,\n\t.read\t\t= cpu_clock_event_read,\n};\n\n/*\n * Software event: task time clock\n */\n\nstatic void task_clock_event_update(struct perf_event *event, u64 now)\n{\n\tu64 prev;\n\ts64 delta;\n\n\tprev = local64_xchg(&event->hw.prev_count, now);\n\tdelta = now - prev;\n\tlocal64_add(delta, &event->count);\n}\n\nstatic void task_clock_event_start(struct perf_event *event, int flags)\n{\n\tlocal64_set(&event->hw.prev_count, event->ctx->time);\n\tperf_swevent_start_hrtimer(event);\n}\n\nstatic void task_clock_event_stop(struct perf_event *event, int flags)\n{\n\tperf_swevent_cancel_hrtimer(event);\n\ttask_clock_event_update(event, event->ctx->time);\n}\n\nstatic int task_clock_event_add(struct perf_event *event, int flags)\n{\n\tif (flags & PERF_EF_START)\n\t\ttask_clock_event_start(event, flags);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void task_clock_event_del(struct perf_event *event, int flags)\n{\n\ttask_clock_event_stop(event, PERF_EF_UPDATE);\n}\n\nstatic void task_clock_event_read(struct perf_event *event)\n{\n\tu64 now = perf_clock();\n\tu64 delta = now - event->ctx->timestamp;\n\tu64 time = event->ctx->time + delta;\n\n\ttask_clock_event_update(event, time);\n}\n\nstatic int task_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_TASK_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}\n\nstatic struct pmu perf_task_clock = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.capabilities\t= PERF_PMU_CAP_NO_NMI,\n\n\t.event_init\t= task_clock_event_init,\n\t.add\t\t= task_clock_event_add,\n\t.del\t\t= task_clock_event_del,\n\t.start\t\t= task_clock_event_start,\n\t.stop\t\t= task_clock_event_stop,\n\t.read\t\t= task_clock_event_read,\n};\n\nstatic void perf_pmu_nop_void(struct pmu *pmu)\n{\n}\n\nstatic void perf_pmu_nop_txn(struct pmu *pmu, unsigned int flags)\n{\n}\n\nstatic int perf_pmu_nop_int(struct pmu *pmu)\n{\n\treturn 0;\n}\n\nstatic DEFINE_PER_CPU(unsigned int, nop_txn_flags);\n\nstatic void perf_pmu_start_txn(struct pmu *pmu, unsigned int flags)\n{\n\t__this_cpu_write(nop_txn_flags, flags);\n\n\tif (flags & ~PERF_PMU_TXN_ADD)\n\t\treturn;\n\n\tperf_pmu_disable(pmu);\n}\n\nstatic int perf_pmu_commit_txn(struct pmu *pmu)\n{\n\tunsigned int flags = __this_cpu_read(nop_txn_flags);\n\n\t__this_cpu_write(nop_txn_flags, 0);\n\n\tif (flags & ~PERF_PMU_TXN_ADD)\n\t\treturn 0;\n\n\tperf_pmu_enable(pmu);\n\treturn 0;\n}\n\nstatic void perf_pmu_cancel_txn(struct pmu *pmu)\n{\n\tunsigned int flags =  __this_cpu_read(nop_txn_flags);\n\n\t__this_cpu_write(nop_txn_flags, 0);\n\n\tif (flags & ~PERF_PMU_TXN_ADD)\n\t\treturn;\n\n\tperf_pmu_enable(pmu);\n}\n\nstatic int perf_event_idx_default(struct perf_event *event)\n{\n\treturn 0;\n}\n\n/*\n * Ensures all contexts with the same task_ctx_nr have the same\n * pmu_cpu_context too.\n */\nstatic struct perf_cpu_context __percpu *find_pmu_context(int ctxn)\n{\n\tstruct pmu *pmu;\n\n\tif (ctxn < 0)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pmu, &pmus, entry) {\n\t\tif (pmu->task_ctx_nr == ctxn)\n\t\t\treturn pmu->pmu_cpu_context;\n\t}\n\n\treturn NULL;\n}\n\nstatic void update_pmu_context(struct pmu *pmu, struct pmu *old_pmu)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\n\t\tif (cpuctx->unique_pmu == old_pmu)\n\t\t\tcpuctx->unique_pmu = pmu;\n\t}\n}\n\nstatic void free_pmu_context(struct pmu *pmu)\n{\n\tstruct pmu *i;\n\n\tmutex_lock(&pmus_lock);\n\t/*\n\t * Like a real lame refcount.\n\t */\n\tlist_for_each_entry(i, &pmus, entry) {\n\t\tif (i->pmu_cpu_context == pmu->pmu_cpu_context) {\n\t\t\tupdate_pmu_context(i, pmu);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfree_percpu(pmu->pmu_cpu_context);\nout:\n\tmutex_unlock(&pmus_lock);\n}\n\n/*\n * Let userspace know that this PMU supports address range filtering:\n */\nstatic ssize_t nr_addr_filters_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *page)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\n\treturn snprintf(page, PAGE_SIZE - 1, \"%d\\n\", pmu->nr_addr_filters);\n}\nDEVICE_ATTR_RO(nr_addr_filters);\n\nstatic struct idr pmu_idr;\n\nstatic ssize_t\ntype_show(struct device *dev, struct device_attribute *attr, char *page)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\n\treturn snprintf(page, PAGE_SIZE-1, \"%d\\n\", pmu->type);\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic ssize_t\nperf_event_mux_interval_ms_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *page)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\n\treturn snprintf(page, PAGE_SIZE-1, \"%d\\n\", pmu->hrtimer_interval_ms);\n}\n\nstatic DEFINE_MUTEX(mux_interval_mutex);\n\nstatic ssize_t\nperf_event_mux_interval_ms_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\tint timer, cpu, ret;\n\n\tret = kstrtoint(buf, 0, &timer);\n\tif (ret)\n\t\treturn ret;\n\n\tif (timer < 1)\n\t\treturn -EINVAL;\n\n\t/* same value, noting to do */\n\tif (timer == pmu->hrtimer_interval_ms)\n\t\treturn count;\n\n\tmutex_lock(&mux_interval_mutex);\n\tpmu->hrtimer_interval_ms = timer;\n\n\t/* update all cpuctx for this PMU */\n\tget_online_cpus();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\tcpuctx->hrtimer_interval = ns_to_ktime(NSEC_PER_MSEC * timer);\n\n\t\tcpu_function_call(cpu,\n\t\t\t(remote_function_f)perf_mux_hrtimer_restart, cpuctx);\n\t}\n\tput_online_cpus();\n\tmutex_unlock(&mux_interval_mutex);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(perf_event_mux_interval_ms);\n\nstatic struct attribute *pmu_dev_attrs[] = {\n\t&dev_attr_type.attr,\n\t&dev_attr_perf_event_mux_interval_ms.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(pmu_dev);\n\nstatic int pmu_bus_running;\nstatic struct bus_type pmu_bus = {\n\t.name\t\t= \"event_source\",\n\t.dev_groups\t= pmu_dev_groups,\n};\n\nstatic void pmu_dev_release(struct device *dev)\n{\n\tkfree(dev);\n}\n\nstatic int pmu_dev_alloc(struct pmu *pmu)\n{\n\tint ret = -ENOMEM;\n\n\tpmu->dev = kzalloc(sizeof(struct device), GFP_KERNEL);\n\tif (!pmu->dev)\n\t\tgoto out;\n\n\tpmu->dev->groups = pmu->attr_groups;\n\tdevice_initialize(pmu->dev);\n\tret = dev_set_name(pmu->dev, \"%s\", pmu->name);\n\tif (ret)\n\t\tgoto free_dev;\n\n\tdev_set_drvdata(pmu->dev, pmu);\n\tpmu->dev->bus = &pmu_bus;\n\tpmu->dev->release = pmu_dev_release;\n\tret = device_add(pmu->dev);\n\tif (ret)\n\t\tgoto free_dev;\n\n\t/* For PMUs with address filters, throw in an extra attribute: */\n\tif (pmu->nr_addr_filters)\n\t\tret = device_create_file(pmu->dev, &dev_attr_nr_addr_filters);\n\n\tif (ret)\n\t\tgoto del_dev;\n\nout:\n\treturn ret;\n\ndel_dev:\n\tdevice_del(pmu->dev);\n\nfree_dev:\n\tput_device(pmu->dev);\n\tgoto out;\n}\n\nstatic struct lock_class_key cpuctx_mutex;\nstatic struct lock_class_key cpuctx_lock;\n\nint perf_pmu_register(struct pmu *pmu, const char *name, int type)\n{\n\tint cpu, ret;\n\n\tmutex_lock(&pmus_lock);\n\tret = -ENOMEM;\n\tpmu->pmu_disable_count = alloc_percpu(int);\n\tif (!pmu->pmu_disable_count)\n\t\tgoto unlock;\n\n\tpmu->type = -1;\n\tif (!name)\n\t\tgoto skip_type;\n\tpmu->name = name;\n\n\tif (type < 0) {\n\t\ttype = idr_alloc(&pmu_idr, pmu, PERF_TYPE_MAX, 0, GFP_KERNEL);\n\t\tif (type < 0) {\n\t\t\tret = type;\n\t\t\tgoto free_pdc;\n\t\t}\n\t}\n\tpmu->type = type;\n\n\tif (pmu_bus_running) {\n\t\tret = pmu_dev_alloc(pmu);\n\t\tif (ret)\n\t\t\tgoto free_idr;\n\t}\n\nskip_type:\n\tif (pmu->task_ctx_nr == perf_hw_context) {\n\t\tstatic int hw_context_taken = 0;\n\n\t\t/*\n\t\t * Other than systems with heterogeneous CPUs, it never makes\n\t\t * sense for two PMUs to share perf_hw_context. PMUs which are\n\t\t * uncore must use perf_invalid_context.\n\t\t */\n\t\tif (WARN_ON_ONCE(hw_context_taken &&\n\t\t    !(pmu->capabilities & PERF_PMU_CAP_HETEROGENEOUS_CPUS)))\n\t\t\tpmu->task_ctx_nr = perf_invalid_context;\n\n\t\thw_context_taken = 1;\n\t}\n\n\tpmu->pmu_cpu_context = find_pmu_context(pmu->task_ctx_nr);\n\tif (pmu->pmu_cpu_context)\n\t\tgoto got_cpu_context;\n\n\tret = -ENOMEM;\n\tpmu->pmu_cpu_context = alloc_percpu(struct perf_cpu_context);\n\tif (!pmu->pmu_cpu_context)\n\t\tgoto free_dev;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\t__perf_event_init_context(&cpuctx->ctx);\n\t\tlockdep_set_class(&cpuctx->ctx.mutex, &cpuctx_mutex);\n\t\tlockdep_set_class(&cpuctx->ctx.lock, &cpuctx_lock);\n\t\tcpuctx->ctx.pmu = pmu;\n\n\t\t__perf_mux_hrtimer_init(cpuctx, cpu);\n\n\t\tcpuctx->unique_pmu = pmu;\n\t}\n\ngot_cpu_context:\n\tif (!pmu->start_txn) {\n\t\tif (pmu->pmu_enable) {\n\t\t\t/*\n\t\t\t * If we have pmu_enable/pmu_disable calls, install\n\t\t\t * transaction stubs that use that to try and batch\n\t\t\t * hardware accesses.\n\t\t\t */\n\t\t\tpmu->start_txn  = perf_pmu_start_txn;\n\t\t\tpmu->commit_txn = perf_pmu_commit_txn;\n\t\t\tpmu->cancel_txn = perf_pmu_cancel_txn;\n\t\t} else {\n\t\t\tpmu->start_txn  = perf_pmu_nop_txn;\n\t\t\tpmu->commit_txn = perf_pmu_nop_int;\n\t\t\tpmu->cancel_txn = perf_pmu_nop_void;\n\t\t}\n\t}\n\n\tif (!pmu->pmu_enable) {\n\t\tpmu->pmu_enable  = perf_pmu_nop_void;\n\t\tpmu->pmu_disable = perf_pmu_nop_void;\n\t}\n\n\tif (!pmu->event_idx)\n\t\tpmu->event_idx = perf_event_idx_default;\n\n\tlist_add_rcu(&pmu->entry, &pmus);\n\tatomic_set(&pmu->exclusive_cnt, 0);\n\tret = 0;\nunlock:\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n\nfree_dev:\n\tdevice_del(pmu->dev);\n\tput_device(pmu->dev);\n\nfree_idr:\n\tif (pmu->type >= PERF_TYPE_MAX)\n\t\tidr_remove(&pmu_idr, pmu->type);\n\nfree_pdc:\n\tfree_percpu(pmu->pmu_disable_count);\n\tgoto unlock;\n}\nEXPORT_SYMBOL_GPL(perf_pmu_register);\n\nvoid perf_pmu_unregister(struct pmu *pmu)\n{\n\tint remove_device;\n\n\tmutex_lock(&pmus_lock);\n\tremove_device = pmu_bus_running;\n\tlist_del_rcu(&pmu->entry);\n\tmutex_unlock(&pmus_lock);\n\n\t/*\n\t * We dereference the pmu list under both SRCU and regular RCU, so\n\t * synchronize against both of those.\n\t */\n\tsynchronize_srcu(&pmus_srcu);\n\tsynchronize_rcu();\n\n\tfree_percpu(pmu->pmu_disable_count);\n\tif (pmu->type >= PERF_TYPE_MAX)\n\t\tidr_remove(&pmu_idr, pmu->type);\n\tif (remove_device) {\n\t\tif (pmu->nr_addr_filters)\n\t\t\tdevice_remove_file(pmu->dev, &dev_attr_nr_addr_filters);\n\t\tdevice_del(pmu->dev);\n\t\tput_device(pmu->dev);\n\t}\n\tfree_pmu_context(pmu);\n}\nEXPORT_SYMBOL_GPL(perf_pmu_unregister);\n\nstatic int perf_try_init_event(struct pmu *pmu, struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = NULL;\n\tint ret;\n\n\tif (!try_module_get(pmu->module))\n\t\treturn -ENODEV;\n\n\tif (event->group_leader != event) {\n\t\t/*\n\t\t * This ctx->mutex can nest when we're called through\n\t\t * inheritance. See the perf_event_ctx_lock_nested() comment.\n\t\t */\n\t\tctx = perf_event_ctx_lock_nested(event->group_leader,\n\t\t\t\t\t\t SINGLE_DEPTH_NESTING);\n\t\tBUG_ON(!ctx);\n\t}\n\n\tevent->pmu = pmu;\n\tret = pmu->event_init(event);\n\n\tif (ctx)\n\t\tperf_event_ctx_unlock(event->group_leader, ctx);\n\n\tif (ret)\n\t\tmodule_put(pmu->module);\n\n\treturn ret;\n}\n\nstatic struct pmu *perf_init_event(struct perf_event *event)\n{\n\tstruct pmu *pmu = NULL;\n\tint idx;\n\tint ret;\n\n\tidx = srcu_read_lock(&pmus_srcu);\n\n\trcu_read_lock();\n\tpmu = idr_find(&pmu_idr, event->attr.type);\n\trcu_read_unlock();\n\tif (pmu) {\n\t\tret = perf_try_init_event(pmu, event);\n\t\tif (ret)\n\t\t\tpmu = ERR_PTR(ret);\n\t\tgoto unlock;\n\t}\n\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tret = perf_try_init_event(pmu, event);\n\t\tif (!ret)\n\t\t\tgoto unlock;\n\n\t\tif (ret != -ENOENT) {\n\t\t\tpmu = ERR_PTR(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tpmu = ERR_PTR(-ENOENT);\nunlock:\n\tsrcu_read_unlock(&pmus_srcu, idx);\n\n\treturn pmu;\n}\n\nstatic void attach_sb_event(struct perf_event *event)\n{\n\tstruct pmu_event_list *pel = per_cpu_ptr(&pmu_sb_events, event->cpu);\n\n\traw_spin_lock(&pel->lock);\n\tlist_add_rcu(&event->sb_list, &pel->list);\n\traw_spin_unlock(&pel->lock);\n}\n\n/*\n * We keep a list of all !task (and therefore per-cpu) events\n * that need to receive side-band records.\n *\n * This avoids having to scan all the various PMU per-cpu contexts\n * looking for them.\n */\nstatic void account_pmu_sb_event(struct perf_event *event)\n{\n\tif (is_sb_event(event))\n\t\tattach_sb_event(event);\n}\n\nstatic void account_event_cpu(struct perf_event *event, int cpu)\n{\n\tif (event->parent)\n\t\treturn;\n\n\tif (is_cgroup_event(event))\n\t\tatomic_inc(&per_cpu(perf_cgroup_events, cpu));\n}\n\n/* Freq events need the tick to stay alive (see perf_event_task_tick). */\nstatic void account_freq_event_nohz(void)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\t/* Lock so we don't race with concurrent unaccount */\n\tspin_lock(&nr_freq_lock);\n\tif (atomic_inc_return(&nr_freq_events) == 1)\n\t\ttick_nohz_dep_set(TICK_DEP_BIT_PERF_EVENTS);\n\tspin_unlock(&nr_freq_lock);\n#endif\n}\n\nstatic void account_freq_event(void)\n{\n\tif (tick_nohz_full_enabled())\n\t\taccount_freq_event_nohz();\n\telse\n\t\tatomic_inc(&nr_freq_events);\n}\n\n\nstatic void account_event(struct perf_event *event)\n{\n\tbool inc = false;\n\n\tif (event->parent)\n\t\treturn;\n\n\tif (event->attach_state & PERF_ATTACH_TASK)\n\t\tinc = true;\n\tif (event->attr.mmap || event->attr.mmap_data)\n\t\tatomic_inc(&nr_mmap_events);\n\tif (event->attr.comm)\n\t\tatomic_inc(&nr_comm_events);\n\tif (event->attr.task)\n\t\tatomic_inc(&nr_task_events);\n\tif (event->attr.freq)\n\t\taccount_freq_event();\n\tif (event->attr.context_switch) {\n\t\tatomic_inc(&nr_switch_events);\n\t\tinc = true;\n\t}\n\tif (has_branch_stack(event))\n\t\tinc = true;\n\tif (is_cgroup_event(event))\n\t\tinc = true;\n\n\tif (inc) {\n\t\tif (atomic_inc_not_zero(&perf_sched_count))\n\t\t\tgoto enabled;\n\n\t\tmutex_lock(&perf_sched_mutex);\n\t\tif (!atomic_read(&perf_sched_count)) {\n\t\t\tstatic_branch_enable(&perf_sched_events);\n\t\t\t/*\n\t\t\t * Guarantee that all CPUs observe they key change and\n\t\t\t * call the perf scheduling hooks before proceeding to\n\t\t\t * install events that need them.\n\t\t\t */\n\t\t\tsynchronize_sched();\n\t\t}\n\t\t/*\n\t\t * Now that we have waited for the sync_sched(), allow further\n\t\t * increments to by-pass the mutex.\n\t\t */\n\t\tatomic_inc(&perf_sched_count);\n\t\tmutex_unlock(&perf_sched_mutex);\n\t}\nenabled:\n\n\taccount_event_cpu(event, event->cpu);\n\n\taccount_pmu_sb_event(event);\n}\n\n/*\n * Allocate and initialize a event structure\n */\nstatic struct perf_event *\nperf_event_alloc(struct perf_event_attr *attr, int cpu,\n\t\t struct task_struct *task,\n\t\t struct perf_event *group_leader,\n\t\t struct perf_event *parent_event,\n\t\t perf_overflow_handler_t overflow_handler,\n\t\t void *context, int cgroup_fd)\n{\n\tstruct pmu *pmu;\n\tstruct perf_event *event;\n\tstruct hw_perf_event *hwc;\n\tlong err = -EINVAL;\n\n\tif ((unsigned)cpu >= nr_cpu_ids) {\n\t\tif (!task || cpu != -1)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Single events are their own group leaders, with an\n\t * empty sibling list:\n\t */\n\tif (!group_leader)\n\t\tgroup_leader = event;\n\n\tmutex_init(&event->child_mutex);\n\tINIT_LIST_HEAD(&event->child_list);\n\n\tINIT_LIST_HEAD(&event->group_entry);\n\tINIT_LIST_HEAD(&event->event_entry);\n\tINIT_LIST_HEAD(&event->sibling_list);\n\tINIT_LIST_HEAD(&event->rb_entry);\n\tINIT_LIST_HEAD(&event->active_entry);\n\tINIT_LIST_HEAD(&event->addr_filters.list);\n\tINIT_HLIST_NODE(&event->hlist_entry);\n\n\n\tinit_waitqueue_head(&event->waitq);\n\tinit_irq_work(&event->pending, perf_pending_event);\n\n\tmutex_init(&event->mmap_mutex);\n\traw_spin_lock_init(&event->addr_filters.lock);\n\n\tatomic_long_set(&event->refcount, 1);\n\tevent->cpu\t\t= cpu;\n\tevent->attr\t\t= *attr;\n\tevent->group_leader\t= group_leader;\n\tevent->pmu\t\t= NULL;\n\tevent->oncpu\t\t= -1;\n\n\tevent->parent\t\t= parent_event;\n\n\tevent->ns\t\t= get_pid_ns(task_active_pid_ns(current));\n\tevent->id\t\t= atomic64_inc_return(&perf_event_id);\n\n\tevent->state\t\t= PERF_EVENT_STATE_INACTIVE;\n\n\tif (task) {\n\t\tevent->attach_state = PERF_ATTACH_TASK;\n\t\t/*\n\t\t * XXX pmu::event_init needs to know what task to account to\n\t\t * and we cannot use the ctx information because we need the\n\t\t * pmu before we get a ctx.\n\t\t */\n\t\tevent->hw.target = task;\n\t}\n\n\tevent->clock = &local_clock;\n\tif (parent_event)\n\t\tevent->clock = parent_event->clock;\n\n\tif (!overflow_handler && parent_event) {\n\t\toverflow_handler = parent_event->overflow_handler;\n\t\tcontext = parent_event->overflow_handler_context;\n#if defined(CONFIG_BPF_SYSCALL) && defined(CONFIG_EVENT_TRACING)\n\t\tif (overflow_handler == bpf_overflow_handler) {\n\t\t\tstruct bpf_prog *prog = bpf_prog_inc(parent_event->prog);\n\n\t\t\tif (IS_ERR(prog)) {\n\t\t\t\terr = PTR_ERR(prog);\n\t\t\t\tgoto err_ns;\n\t\t\t}\n\t\t\tevent->prog = prog;\n\t\t\tevent->orig_overflow_handler =\n\t\t\t\tparent_event->orig_overflow_handler;\n\t\t}\n#endif\n\t}\n\n\tif (overflow_handler) {\n\t\tevent->overflow_handler\t= overflow_handler;\n\t\tevent->overflow_handler_context = context;\n\t} else if (is_write_backward(event)){\n\t\tevent->overflow_handler = perf_event_output_backward;\n\t\tevent->overflow_handler_context = NULL;\n\t} else {\n\t\tevent->overflow_handler = perf_event_output_forward;\n\t\tevent->overflow_handler_context = NULL;\n\t}\n\n\tperf_event__state_init(event);\n\n\tpmu = NULL;\n\n\thwc = &event->hw;\n\thwc->sample_period = attr->sample_period;\n\tif (attr->freq && attr->sample_freq)\n\t\thwc->sample_period = 1;\n\thwc->last_period = hwc->sample_period;\n\n\tlocal64_set(&hwc->period_left, hwc->sample_period);\n\n\t/*\n\t * we currently do not support PERF_FORMAT_GROUP on inherited events\n\t */\n\tif (attr->inherit && (attr->read_format & PERF_FORMAT_GROUP))\n\t\tgoto err_ns;\n\n\tif (!has_branch_stack(event))\n\t\tevent->attr.branch_sample_type = 0;\n\n\tif (cgroup_fd != -1) {\n\t\terr = perf_cgroup_connect(cgroup_fd, event, attr, group_leader);\n\t\tif (err)\n\t\t\tgoto err_ns;\n\t}\n\n\tpmu = perf_init_event(event);\n\tif (!pmu)\n\t\tgoto err_ns;\n\telse if (IS_ERR(pmu)) {\n\t\terr = PTR_ERR(pmu);\n\t\tgoto err_ns;\n\t}\n\n\terr = exclusive_event_init(event);\n\tif (err)\n\t\tgoto err_pmu;\n\n\tif (has_addr_filter(event)) {\n\t\tevent->addr_filters_offs = kcalloc(pmu->nr_addr_filters,\n\t\t\t\t\t\t   sizeof(unsigned long),\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!event->addr_filters_offs)\n\t\t\tgoto err_per_task;\n\n\t\t/* force hw sync on the address filters */\n\t\tevent->addr_filters_gen = 1;\n\t}\n\n\tif (!event->parent) {\n\t\tif (event->attr.sample_type & PERF_SAMPLE_CALLCHAIN) {\n\t\t\terr = get_callchain_buffers(attr->sample_max_stack);\n\t\t\tif (err)\n\t\t\t\tgoto err_addr_filters;\n\t\t}\n\t}\n\n\t/* symmetric to unaccount_event() in _free_event() */\n\taccount_event(event);\n\n\treturn event;\n\nerr_addr_filters:\n\tkfree(event->addr_filters_offs);\n\nerr_per_task:\n\texclusive_event_destroy(event);\n\nerr_pmu:\n\tif (event->destroy)\n\t\tevent->destroy(event);\n\tmodule_put(pmu->module);\nerr_ns:\n\tif (is_cgroup_event(event))\n\t\tperf_detach_cgroup(event);\n\tif (event->ns)\n\t\tput_pid_ns(event->ns);\n\tkfree(event);\n\n\treturn ERR_PTR(err);\n}\n\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr)\n{\n\tu32 size;\n\tint ret;\n\n\tif (!access_ok(VERIFY_WRITE, uattr, PERF_ATTR_SIZE_VER0))\n\t\treturn -EFAULT;\n\n\t/*\n\t * zero the full structure, so that a short copy will be nice.\n\t */\n\tmemset(attr, 0, sizeof(*attr));\n\n\tret = get_user(size, &uattr->size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (size > PAGE_SIZE)\t/* silly large */\n\t\tgoto err_size;\n\n\tif (!size)\t\t/* abi compat */\n\t\tsize = PERF_ATTR_SIZE_VER0;\n\n\tif (size < PERF_ATTR_SIZE_VER0)\n\t\tgoto err_size;\n\n\t/*\n\t * If we're handed a bigger struct than we know of,\n\t * ensure all the unknown bits are 0 - i.e. new\n\t * user-space does not rely on any kernel feature\n\t * extensions we dont know about yet.\n\t */\n\tif (size > sizeof(*attr)) {\n\t\tunsigned char __user *addr;\n\t\tunsigned char __user *end;\n\t\tunsigned char val;\n\n\t\taddr = (void __user *)uattr + sizeof(*attr);\n\t\tend  = (void __user *)uattr + size;\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tret = get_user(val, addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (val)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tsize = sizeof(*attr);\n\t}\n\n\tret = copy_from_user(attr, uattr, size);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tif (attr->__reserved_1)\n\t\treturn -EINVAL;\n\n\tif (attr->sample_type & ~(PERF_SAMPLE_MAX-1))\n\t\treturn -EINVAL;\n\n\tif (attr->read_format & ~(PERF_FORMAT_MAX-1))\n\t\treturn -EINVAL;\n\n\tif (attr->sample_type & PERF_SAMPLE_BRANCH_STACK) {\n\t\tu64 mask = attr->branch_sample_type;\n\n\t\t/* only using defined bits */\n\t\tif (mask & ~(PERF_SAMPLE_BRANCH_MAX-1))\n\t\t\treturn -EINVAL;\n\n\t\t/* at least one branch bit must be set */\n\t\tif (!(mask & ~PERF_SAMPLE_BRANCH_PLM_ALL))\n\t\t\treturn -EINVAL;\n\n\t\t/* propagate priv level, when not set for branch */\n\t\tif (!(mask & PERF_SAMPLE_BRANCH_PLM_ALL)) {\n\n\t\t\t/* exclude_kernel checked on syscall entry */\n\t\t\tif (!attr->exclude_kernel)\n\t\t\t\tmask |= PERF_SAMPLE_BRANCH_KERNEL;\n\n\t\t\tif (!attr->exclude_user)\n\t\t\t\tmask |= PERF_SAMPLE_BRANCH_USER;\n\n\t\t\tif (!attr->exclude_hv)\n\t\t\t\tmask |= PERF_SAMPLE_BRANCH_HV;\n\t\t\t/*\n\t\t\t * adjust user setting (for HW filter setup)\n\t\t\t */\n\t\t\tattr->branch_sample_type = mask;\n\t\t}\n\t\t/* privileged levels capture (kernel, hv): check permissions */\n\t\tif ((mask & PERF_SAMPLE_BRANCH_PERM_PLM)\n\t\t    && perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\t}\n\n\tif (attr->sample_type & PERF_SAMPLE_REGS_USER) {\n\t\tret = perf_reg_validate(attr->sample_regs_user);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (attr->sample_type & PERF_SAMPLE_STACK_USER) {\n\t\tif (!arch_perf_have_user_stack_dump())\n\t\t\treturn -ENOSYS;\n\n\t\t/*\n\t\t * We have __u32 type for the size, but so far\n\t\t * we can only use __u16 as maximum due to the\n\t\t * __u16 sample size limit.\n\t\t */\n\t\tif (attr->sample_stack_user >= USHRT_MAX)\n\t\t\tret = -EINVAL;\n\t\telse if (!IS_ALIGNED(attr->sample_stack_user, sizeof(u64)))\n\t\t\tret = -EINVAL;\n\t}\n\n\tif (attr->sample_type & PERF_SAMPLE_REGS_INTR)\n\t\tret = perf_reg_validate(attr->sample_regs_intr);\nout:\n\treturn ret;\n\nerr_size:\n\tput_user(sizeof(*attr), &uattr->size);\n\tret = -E2BIG;\n\tgoto out;\n}\n\nstatic int\nperf_event_set_output(struct perf_event *event, struct perf_event *output_event)\n{\n\tstruct ring_buffer *rb = NULL;\n\tint ret = -EINVAL;\n\n\tif (!output_event)\n\t\tgoto set;\n\n\t/* don't allow circular references */\n\tif (event == output_event)\n\t\tgoto out;\n\n\t/*\n\t * Don't allow cross-cpu buffers\n\t */\n\tif (output_event->cpu != event->cpu)\n\t\tgoto out;\n\n\t/*\n\t * If its not a per-cpu rb, it must be the same task.\n\t */\n\tif (output_event->cpu == -1 && output_event->ctx != event->ctx)\n\t\tgoto out;\n\n\t/*\n\t * Mixing clocks in the same buffer is trouble you don't need.\n\t */\n\tif (output_event->clock != event->clock)\n\t\tgoto out;\n\n\t/*\n\t * Either writing ring buffer from beginning or from end.\n\t * Mixing is not allowed.\n\t */\n\tif (is_write_backward(output_event) != is_write_backward(event))\n\t\tgoto out;\n\n\t/*\n\t * If both events generate aux data, they must be on the same PMU\n\t */\n\tif (has_aux(event) && has_aux(output_event) &&\n\t    event->pmu != output_event->pmu)\n\t\tgoto out;\n\nset:\n\tmutex_lock(&event->mmap_mutex);\n\t/* Can't redirect output if we've got an active mmap() */\n\tif (atomic_read(&event->mmap_count))\n\t\tgoto unlock;\n\n\tif (output_event) {\n\t\t/* get the rb we want to redirect to */\n\t\trb = ring_buffer_get(output_event);\n\t\tif (!rb)\n\t\t\tgoto unlock;\n\t}\n\n\tring_buffer_attach(event, rb);\n\n\tret = 0;\nunlock:\n\tmutex_unlock(&event->mmap_mutex);\n\nout:\n\treturn ret;\n}\n\nstatic void mutex_lock_double(struct mutex *a, struct mutex *b)\n{\n\tif (b < a)\n\t\tswap(a, b);\n\n\tmutex_lock(a);\n\tmutex_lock_nested(b, SINGLE_DEPTH_NESTING);\n}\n\nstatic int perf_event_set_clock(struct perf_event *event, clockid_t clk_id)\n{\n\tbool nmi_safe = false;\n\n\tswitch (clk_id) {\n\tcase CLOCK_MONOTONIC:\n\t\tevent->clock = &ktime_get_mono_fast_ns;\n\t\tnmi_safe = true;\n\t\tbreak;\n\n\tcase CLOCK_MONOTONIC_RAW:\n\t\tevent->clock = &ktime_get_raw_fast_ns;\n\t\tnmi_safe = true;\n\t\tbreak;\n\n\tcase CLOCK_REALTIME:\n\t\tevent->clock = &ktime_get_real_ns;\n\t\tbreak;\n\n\tcase CLOCK_BOOTTIME:\n\t\tevent->clock = &ktime_get_boot_ns;\n\t\tbreak;\n\n\tcase CLOCK_TAI:\n\t\tevent->clock = &ktime_get_tai_ns;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!nmi_safe && !(event->pmu->capabilities & PERF_PMU_CAP_NO_NMI))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/*\n * Variation on perf_event_ctx_lock_nested(), except we take two context\n * mutexes.\n */\nstatic struct perf_event_context *\n__perf_event_ctx_lock_double(struct perf_event *group_leader,\n\t\t\t     struct perf_event_context *ctx)\n{\n\tstruct perf_event_context *gctx;\n\nagain:\n\trcu_read_lock();\n\tgctx = READ_ONCE(group_leader->ctx);\n\tif (!atomic_inc_not_zero(&gctx->refcount)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\n\tmutex_lock_double(&gctx->mutex, &ctx->mutex);\n\n\tif (group_leader->ctx != gctx) {\n\t\tmutex_unlock(&ctx->mutex);\n\t\tmutex_unlock(&gctx->mutex);\n\t\tput_ctx(gctx);\n\t\tgoto again;\n\t}\n\n\treturn gctx;\n}\n\n/**\n * sys_perf_event_open - open a performance event, associate it to a task/cpu\n *\n * @attr_uptr:\tevent_id type attributes for monitoring/sampling\n * @pid:\t\ttarget pid\n * @cpu:\t\ttarget cpu\n * @group_fd:\t\tgroup leader event fd\n */\nSYSCALL_DEFINE5(perf_event_open,\n\t\tstruct perf_event_attr __user *, attr_uptr,\n\t\tpid_t, pid, int, cpu, int, group_fd, unsigned long, flags)\n{\n\tstruct perf_event *group_leader = NULL, *output_event = NULL;\n\tstruct perf_event *event, *sibling;\n\tstruct perf_event_attr attr;\n\tstruct perf_event_context *ctx, *uninitialized_var(gctx);\n\tstruct file *event_file = NULL;\n\tstruct fd group = {NULL, 0};\n\tstruct task_struct *task = NULL;\n\tstruct pmu *pmu;\n\tint event_fd;\n\tint move_group = 0;\n\tint err;\n\tint f_flags = O_RDWR;\n\tint cgroup_fd = -1;\n\n\t/* for future expandability... */\n\tif (flags & ~PERF_FLAG_ALL)\n\t\treturn -EINVAL;\n\n\terr = perf_copy_attr(attr_uptr, &attr);\n\tif (err)\n\t\treturn err;\n\n\tif (!attr.exclude_kernel) {\n\t\tif (perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\t}\n\n\tif (attr.freq) {\n\t\tif (attr.sample_freq > sysctl_perf_event_sample_rate)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (attr.sample_period & (1ULL << 63))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!attr.sample_max_stack)\n\t\tattr.sample_max_stack = sysctl_perf_event_max_stack;\n\n\t/*\n\t * In cgroup mode, the pid argument is used to pass the fd\n\t * opened to the cgroup directory in cgroupfs. The cpu argument\n\t * designates the cpu on which to monitor threads from that\n\t * cgroup.\n\t */\n\tif ((flags & PERF_FLAG_PID_CGROUP) && (pid == -1 || cpu == -1))\n\t\treturn -EINVAL;\n\n\tif (flags & PERF_FLAG_FD_CLOEXEC)\n\t\tf_flags |= O_CLOEXEC;\n\n\tevent_fd = get_unused_fd_flags(f_flags);\n\tif (event_fd < 0)\n\t\treturn event_fd;\n\n\tif (group_fd != -1) {\n\t\terr = perf_fget_light(group_fd, &group);\n\t\tif (err)\n\t\t\tgoto err_fd;\n\t\tgroup_leader = group.file->private_data;\n\t\tif (flags & PERF_FLAG_FD_OUTPUT)\n\t\t\toutput_event = group_leader;\n\t\tif (flags & PERF_FLAG_FD_NO_GROUP)\n\t\t\tgroup_leader = NULL;\n\t}\n\n\tif (pid != -1 && !(flags & PERF_FLAG_PID_CGROUP)) {\n\t\ttask = find_lively_task_by_vpid(pid);\n\t\tif (IS_ERR(task)) {\n\t\t\terr = PTR_ERR(task);\n\t\t\tgoto err_group_fd;\n\t\t}\n\t}\n\n\tif (task && group_leader &&\n\t    group_leader->attr.inherit != attr.inherit) {\n\t\terr = -EINVAL;\n\t\tgoto err_task;\n\t}\n\n\tget_online_cpus();\n\n\tif (task) {\n\t\terr = mutex_lock_interruptible(&task->signal->cred_guard_mutex);\n\t\tif (err)\n\t\t\tgoto err_cpus;\n\n\t\t/*\n\t\t * Reuse ptrace permission checks for now.\n\t\t *\n\t\t * We must hold cred_guard_mutex across this and any potential\n\t\t * perf_install_in_context() call for this new event to\n\t\t * serialize against exec() altering our credentials (and the\n\t\t * perf_event_exit_task() that could imply).\n\t\t */\n\t\terr = -EACCES;\n\t\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))\n\t\t\tgoto err_cred;\n\t}\n\n\tif (flags & PERF_FLAG_PID_CGROUP)\n\t\tcgroup_fd = pid;\n\n\tevent = perf_event_alloc(&attr, cpu, task, group_leader, NULL,\n\t\t\t\t NULL, NULL, cgroup_fd);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tgoto err_cred;\n\t}\n\n\tif (is_sampling_event(event)) {\n\t\tif (event->pmu->capabilities & PERF_PMU_CAP_NO_INTERRUPT) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_alloc;\n\t\t}\n\t}\n\n\t/*\n\t * Special case software events and allow them to be part of\n\t * any hardware group.\n\t */\n\tpmu = event->pmu;\n\n\tif (attr.use_clockid) {\n\t\terr = perf_event_set_clock(event, attr.clockid);\n\t\tif (err)\n\t\t\tgoto err_alloc;\n\t}\n\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\tevent->event_caps |= PERF_EV_CAP_SOFTWARE;\n\n\tif (group_leader &&\n\t    (is_software_event(event) != is_software_event(group_leader))) {\n\t\tif (is_software_event(event)) {\n\t\t\t/*\n\t\t\t * If event and group_leader are not both a software\n\t\t\t * event, and event is, then group leader is not.\n\t\t\t *\n\t\t\t * Allow the addition of software events to !software\n\t\t\t * groups, this is safe because software events never\n\t\t\t * fail to schedule.\n\t\t\t */\n\t\t\tpmu = group_leader->pmu;\n\t\t} else if (is_software_event(group_leader) &&\n\t\t\t   (group_leader->group_caps & PERF_EV_CAP_SOFTWARE)) {\n\t\t\t/*\n\t\t\t * In case the group is a pure software group, and we\n\t\t\t * try to add a hardware event, move the whole group to\n\t\t\t * the hardware context.\n\t\t\t */\n\t\t\tmove_group = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Get the target context (task or percpu):\n\t */\n\tctx = find_get_context(pmu, task, event);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto err_alloc;\n\t}\n\n\tif ((pmu->capabilities & PERF_PMU_CAP_EXCLUSIVE) && group_leader) {\n\t\terr = -EBUSY;\n\t\tgoto err_context;\n\t}\n\n\t/*\n\t * Look up the group leader (we will attach this event to it):\n\t */\n\tif (group_leader) {\n\t\terr = -EINVAL;\n\n\t\t/*\n\t\t * Do not allow a recursive hierarchy (this new sibling\n\t\t * becoming part of another group-sibling):\n\t\t */\n\t\tif (group_leader->group_leader != group_leader)\n\t\t\tgoto err_context;\n\n\t\t/* All events in a group should have the same clock */\n\t\tif (group_leader->clock != event->clock)\n\t\t\tgoto err_context;\n\n\t\t/*\n\t\t * Do not allow to attach to a group in a different\n\t\t * task or CPU context:\n\t\t */\n\t\tif (move_group) {\n\t\t\t/*\n\t\t\t * Make sure we're both on the same task, or both\n\t\t\t * per-cpu events.\n\t\t\t */\n\t\t\tif (group_leader->ctx->task != ctx->task)\n\t\t\t\tgoto err_context;\n\n\t\t\t/*\n\t\t\t * Make sure we're both events for the same CPU;\n\t\t\t * grouping events for different CPUs is broken; since\n\t\t\t * you can never concurrently schedule them anyhow.\n\t\t\t */\n\t\t\tif (group_leader->cpu != event->cpu)\n\t\t\t\tgoto err_context;\n\t\t} else {\n\t\t\tif (group_leader->ctx != ctx)\n\t\t\t\tgoto err_context;\n\t\t}\n\n\t\t/*\n\t\t * Only a group leader can be exclusive or pinned\n\t\t */\n\t\tif (attr.exclusive || attr.pinned)\n\t\t\tgoto err_context;\n\t}\n\n\tif (output_event) {\n\t\terr = perf_event_set_output(event, output_event);\n\t\tif (err)\n\t\t\tgoto err_context;\n\t}\n\n\tevent_file = anon_inode_getfile(\"[perf_event]\", &perf_fops, event,\n\t\t\t\t\tf_flags);\n\tif (IS_ERR(event_file)) {\n\t\terr = PTR_ERR(event_file);\n\t\tevent_file = NULL;\n\t\tgoto err_context;\n\t}\n\n\tif (move_group) {\n\t\tgctx = __perf_event_ctx_lock_double(group_leader, ctx);\n\n\t\tif (gctx->task == TASK_TOMBSTONE) {\n\t\t\terr = -ESRCH;\n\t\t\tgoto err_locked;\n\t\t}\n\n\t\t/*\n\t\t * Check if we raced against another sys_perf_event_open() call\n\t\t * moving the software group underneath us.\n\t\t */\n\t\tif (!(group_leader->group_caps & PERF_EV_CAP_SOFTWARE)) {\n\t\t\t/*\n\t\t\t * If someone moved the group out from under us, check\n\t\t\t * if this new event wound up on the same ctx, if so\n\t\t\t * its the regular !move_group case, otherwise fail.\n\t\t\t */\n\t\t\tif (gctx != ctx) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_locked;\n\t\t\t} else {\n\t\t\t\tperf_event_ctx_unlock(group_leader, gctx);\n\t\t\t\tmove_group = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmutex_lock(&ctx->mutex);\n\t}\n\n\tif (ctx->task == TASK_TOMBSTONE) {\n\t\terr = -ESRCH;\n\t\tgoto err_locked;\n\t}\n\n\tif (!perf_event_validate_size(event)) {\n\t\terr = -E2BIG;\n\t\tgoto err_locked;\n\t}\n\n\t/*\n\t * Must be under the same ctx::mutex as perf_install_in_context(),\n\t * because we need to serialize with concurrent event creation.\n\t */\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\t/* exclusive and group stuff are assumed mutually exclusive */\n\t\tWARN_ON_ONCE(move_group);\n\n\t\terr = -EBUSY;\n\t\tgoto err_locked;\n\t}\n\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\n\t/*\n\t * This is the point on no return; we cannot fail hereafter. This is\n\t * where we start modifying current state.\n\t */\n\n\tif (move_group) {\n\t\t/*\n\t\t * See perf_event_ctx_lock() for comments on the details\n\t\t * of swizzling perf_event::ctx.\n\t\t */\n\t\tperf_remove_from_context(group_leader, 0);\n\n\t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n\t\t\t\t    group_entry) {\n\t\t\tperf_remove_from_context(sibling, 0);\n\t\t\tput_ctx(gctx);\n\t\t}\n\n\t\t/*\n\t\t * Wait for everybody to stop referencing the events through\n\t\t * the old lists, before installing it on new lists.\n\t\t */\n\t\tsynchronize_rcu();\n\n\t\t/*\n\t\t * Install the group siblings before the group leader.\n\t\t *\n\t\t * Because a group leader will try and install the entire group\n\t\t * (through the sibling list, which is still in-tact), we can\n\t\t * end up with siblings installed in the wrong context.\n\t\t *\n\t\t * By installing siblings first we NO-OP because they're not\n\t\t * reachable through the group lists.\n\t\t */\n\t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n\t\t\t\t    group_entry) {\n\t\t\tperf_event__state_init(sibling);\n\t\t\tperf_install_in_context(ctx, sibling, sibling->cpu);\n\t\t\tget_ctx(ctx);\n\t\t}\n\n\t\t/*\n\t\t * Removing from the context ends up with disabled\n\t\t * event. What we want here is event in the initial\n\t\t * startup state, ready to be add into new context.\n\t\t */\n\t\tperf_event__state_init(group_leader);\n\t\tperf_install_in_context(ctx, group_leader, group_leader->cpu);\n\t\tget_ctx(ctx);\n\n\t\t/*\n\t\t * Now that all events are installed in @ctx, nothing\n\t\t * references @gctx anymore, so drop the last reference we have\n\t\t * on it.\n\t\t */\n\t\tput_ctx(gctx);\n\t}\n\n\t/*\n\t * Precalculate sample_data sizes; do while holding ctx::mutex such\n\t * that we're serialized against further additions and before\n\t * perf_install_in_context() which is the point the event is active and\n\t * can use these values.\n\t */\n\tperf_event__header_size(event);\n\tperf_event__id_header_size(event);\n\n\tevent->owner = current;\n\n\tperf_install_in_context(ctx, event, event->cpu);\n\tperf_unpin_context(ctx);\n\n\tif (move_group)\n\t\tperf_event_ctx_unlock(group_leader, gctx);\n\tmutex_unlock(&ctx->mutex);\n\n\tif (task) {\n\t\tmutex_unlock(&task->signal->cred_guard_mutex);\n\t\tput_task_struct(task);\n\t}\n\n\tput_online_cpus();\n\n\tmutex_lock(&current->perf_event_mutex);\n\tlist_add_tail(&event->owner_entry, &current->perf_event_list);\n\tmutex_unlock(&current->perf_event_mutex);\n\n\t/*\n\t * Drop the reference on the group_event after placing the\n\t * new event on the sibling_list. This ensures destruction\n\t * of the group leader will find the pointer to itself in\n\t * perf_group_detach().\n\t */\n\tfdput(group);\n\tfd_install(event_fd, event_file);\n\treturn event_fd;\n\nerr_locked:\n\tif (move_group)\n\t\tperf_event_ctx_unlock(group_leader, gctx);\n\tmutex_unlock(&ctx->mutex);\n/* err_file: */\n\tfput(event_file);\nerr_context:\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_alloc:\n\t/*\n\t * If event_file is set, the fput() above will have called ->release()\n\t * and that will take care of freeing the event.\n\t */\n\tif (!event_file)\n\t\tfree_event(event);\nerr_cred:\n\tif (task)\n\t\tmutex_unlock(&task->signal->cred_guard_mutex);\nerr_cpus:\n\tput_online_cpus();\nerr_task:\n\tif (task)\n\t\tput_task_struct(task);\nerr_group_fd:\n\tfdput(group);\nerr_fd:\n\tput_unused_fd(event_fd);\n\treturn err;\n}\n\n/**\n * perf_event_create_kernel_counter\n *\n * @attr: attributes of the counter to create\n * @cpu: cpu in which the counter is bound\n * @task: task to profile (NULL for percpu)\n */\nstruct perf_event *\nperf_event_create_kernel_counter(struct perf_event_attr *attr, int cpu,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t perf_overflow_handler_t overflow_handler,\n\t\t\t\t void *context)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\tint err;\n\n\t/*\n\t * Get the target context (task or percpu):\n\t */\n\n\tevent = perf_event_alloc(attr, cpu, task, NULL, NULL,\n\t\t\t\t overflow_handler, context, -1);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tgoto err;\n\t}\n\n\t/* Mark owner so we could distinguish it from user events. */\n\tevent->owner = TASK_TOMBSTONE;\n\n\tctx = find_get_context(event->pmu, task, event);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto err_free;\n\t}\n\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n\tif (ctx->task == TASK_TOMBSTONE) {\n\t\terr = -ESRCH;\n\t\tgoto err_unlock;\n\t}\n\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\terr = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tperf_install_in_context(ctx, event, cpu);\n\tperf_unpin_context(ctx);\n\tmutex_unlock(&ctx->mutex);\n\n\treturn event;\n\nerr_unlock:\n\tmutex_unlock(&ctx->mutex);\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_free:\n\tfree_event(event);\nerr:\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(perf_event_create_kernel_counter);\n\nvoid perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)\n{\n\tstruct perf_event_context *src_ctx;\n\tstruct perf_event_context *dst_ctx;\n\tstruct perf_event *event, *tmp;\n\tLIST_HEAD(events);\n\n\tsrc_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;\n\tdst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;\n\n\t/*\n\t * See perf_event_ctx_lock() for comments on the details\n\t * of swizzling perf_event::ctx.\n\t */\n\tmutex_lock_double(&src_ctx->mutex, &dst_ctx->mutex);\n\tlist_for_each_entry_safe(event, tmp, &src_ctx->event_list,\n\t\t\t\t event_entry) {\n\t\tperf_remove_from_context(event, 0);\n\t\tunaccount_event_cpu(event, src_cpu);\n\t\tput_ctx(src_ctx);\n\t\tlist_add(&event->migrate_entry, &events);\n\t}\n\n\t/*\n\t * Wait for the events to quiesce before re-instating them.\n\t */\n\tsynchronize_rcu();\n\n\t/*\n\t * Re-instate events in 2 passes.\n\t *\n\t * Skip over group leaders and only install siblings on this first\n\t * pass, siblings will not get enabled without a leader, however a\n\t * leader will enable its siblings, even if those are still on the old\n\t * context.\n\t */\n\tlist_for_each_entry_safe(event, tmp, &events, migrate_entry) {\n\t\tif (event->group_leader == event)\n\t\t\tcontinue;\n\n\t\tlist_del(&event->migrate_entry);\n\t\tif (event->state >= PERF_EVENT_STATE_OFF)\n\t\t\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\t\taccount_event_cpu(event, dst_cpu);\n\t\tperf_install_in_context(dst_ctx, event, dst_cpu);\n\t\tget_ctx(dst_ctx);\n\t}\n\n\t/*\n\t * Once all the siblings are setup properly, install the group leaders\n\t * to make it go.\n\t */\n\tlist_for_each_entry_safe(event, tmp, &events, migrate_entry) {\n\t\tlist_del(&event->migrate_entry);\n\t\tif (event->state >= PERF_EVENT_STATE_OFF)\n\t\t\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\t\taccount_event_cpu(event, dst_cpu);\n\t\tperf_install_in_context(dst_ctx, event, dst_cpu);\n\t\tget_ctx(dst_ctx);\n\t}\n\tmutex_unlock(&dst_ctx->mutex);\n\tmutex_unlock(&src_ctx->mutex);\n}\nEXPORT_SYMBOL_GPL(perf_pmu_migrate_context);\n\nstatic void sync_child_event(struct perf_event *child_event,\n\t\t\t       struct task_struct *child)\n{\n\tstruct perf_event *parent_event = child_event->parent;\n\tu64 child_val;\n\n\tif (child_event->attr.inherit_stat)\n\t\tperf_event_read_event(child_event, child);\n\n\tchild_val = perf_event_count(child_event);\n\n\t/*\n\t * Add back the child's count to the parent's count:\n\t */\n\tatomic64_add(child_val, &parent_event->child_count);\n\tatomic64_add(child_event->total_time_enabled,\n\t\t     &parent_event->child_total_time_enabled);\n\tatomic64_add(child_event->total_time_running,\n\t\t     &parent_event->child_total_time_running);\n}\n\nstatic void\nperf_event_exit_event(struct perf_event *child_event,\n\t\t      struct perf_event_context *child_ctx,\n\t\t      struct task_struct *child)\n{\n\tstruct perf_event *parent_event = child_event->parent;\n\n\t/*\n\t * Do not destroy the 'original' grouping; because of the context\n\t * switch optimization the original events could've ended up in a\n\t * random child task.\n\t *\n\t * If we were to destroy the original group, all group related\n\t * operations would cease to function properly after this random\n\t * child dies.\n\t *\n\t * Do destroy all inherited groups, we don't care about those\n\t * and being thorough is better.\n\t */\n\traw_spin_lock_irq(&child_ctx->lock);\n\tWARN_ON_ONCE(child_ctx->is_active);\n\n\tif (parent_event)\n\t\tperf_group_detach(child_event);\n\tlist_del_event(child_event, child_ctx);\n\tchild_event->state = PERF_EVENT_STATE_EXIT; /* is_event_hup() */\n\traw_spin_unlock_irq(&child_ctx->lock);\n\n\t/*\n\t * Parent events are governed by their filedesc, retain them.\n\t */\n\tif (!parent_event) {\n\t\tperf_event_wakeup(child_event);\n\t\treturn;\n\t}\n\t/*\n\t * Child events can be cleaned up.\n\t */\n\n\tsync_child_event(child_event, child);\n\n\t/*\n\t * Remove this event from the parent's list\n\t */\n\tWARN_ON_ONCE(parent_event->ctx->parent_ctx);\n\tmutex_lock(&parent_event->child_mutex);\n\tlist_del_init(&child_event->child_list);\n\tmutex_unlock(&parent_event->child_mutex);\n\n\t/*\n\t * Kick perf_poll() for is_event_hup().\n\t */\n\tperf_event_wakeup(parent_event);\n\tfree_event(child_event);\n\tput_event(parent_event);\n}\n\nstatic void perf_event_exit_task_context(struct task_struct *child, int ctxn)\n{\n\tstruct perf_event_context *child_ctx, *clone_ctx = NULL;\n\tstruct perf_event *child_event, *next;\n\n\tWARN_ON_ONCE(child != current);\n\n\tchild_ctx = perf_pin_task_context(child, ctxn);\n\tif (!child_ctx)\n\t\treturn;\n\n\t/*\n\t * In order to reduce the amount of tricky in ctx tear-down, we hold\n\t * ctx::mutex over the entire thing. This serializes against almost\n\t * everything that wants to access the ctx.\n\t *\n\t * The exception is sys_perf_event_open() /\n\t * perf_event_create_kernel_count() which does find_get_context()\n\t * without ctx::mutex (it cannot because of the move_group double mutex\n\t * lock thing). See the comments in perf_install_in_context().\n\t */\n\tmutex_lock(&child_ctx->mutex);\n\n\t/*\n\t * In a single ctx::lock section, de-schedule the events and detach the\n\t * context from the task such that we cannot ever get it scheduled back\n\t * in.\n\t */\n\traw_spin_lock_irq(&child_ctx->lock);\n\ttask_ctx_sched_out(__get_cpu_context(child_ctx), child_ctx);\n\n\t/*\n\t * Now that the context is inactive, destroy the task <-> ctx relation\n\t * and mark the context dead.\n\t */\n\tRCU_INIT_POINTER(child->perf_event_ctxp[ctxn], NULL);\n\tput_ctx(child_ctx); /* cannot be last */\n\tWRITE_ONCE(child_ctx->task, TASK_TOMBSTONE);\n\tput_task_struct(current); /* cannot be last */\n\n\tclone_ctx = unclone_ctx(child_ctx);\n\traw_spin_unlock_irq(&child_ctx->lock);\n\n\tif (clone_ctx)\n\t\tput_ctx(clone_ctx);\n\n\t/*\n\t * Report the task dead after unscheduling the events so that we\n\t * won't get any samples after PERF_RECORD_EXIT. We can however still\n\t * get a few PERF_RECORD_READ events.\n\t */\n\tperf_event_task(child, child_ctx, 0);\n\n\tlist_for_each_entry_safe(child_event, next, &child_ctx->event_list, event_entry)\n\t\tperf_event_exit_event(child_event, child_ctx, child);\n\n\tmutex_unlock(&child_ctx->mutex);\n\n\tput_ctx(child_ctx);\n}\n\n/*\n * When a child task exits, feed back event values to parent events.\n *\n * Can be called with cred_guard_mutex held when called from\n * install_exec_creds().\n */\nvoid perf_event_exit_task(struct task_struct *child)\n{\n\tstruct perf_event *event, *tmp;\n\tint ctxn;\n\n\tmutex_lock(&child->perf_event_mutex);\n\tlist_for_each_entry_safe(event, tmp, &child->perf_event_list,\n\t\t\t\t owner_entry) {\n\t\tlist_del_init(&event->owner_entry);\n\n\t\t/*\n\t\t * Ensure the list deletion is visible before we clear\n\t\t * the owner, closes a race against perf_release() where\n\t\t * we need to serialize on the owner->perf_event_mutex.\n\t\t */\n\t\tsmp_store_release(&event->owner, NULL);\n\t}\n\tmutex_unlock(&child->perf_event_mutex);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_exit_task_context(child, ctxn);\n\n\t/*\n\t * The perf_event_exit_task_context calls perf_event_task\n\t * with child's task_ctx, which generates EXIT events for\n\t * child contexts and sets child->perf_event_ctxp[] to NULL.\n\t * At this point we need to send EXIT events to cpu contexts.\n\t */\n\tperf_event_task(child, NULL, 0);\n}\n\nstatic void perf_free_event(struct perf_event *event,\n\t\t\t    struct perf_event_context *ctx)\n{\n\tstruct perf_event *parent = event->parent;\n\n\tif (WARN_ON_ONCE(!parent))\n\t\treturn;\n\n\tmutex_lock(&parent->child_mutex);\n\tlist_del_init(&event->child_list);\n\tmutex_unlock(&parent->child_mutex);\n\n\tput_event(parent);\n\n\traw_spin_lock_irq(&ctx->lock);\n\tperf_group_detach(event);\n\tlist_del_event(event, ctx);\n\traw_spin_unlock_irq(&ctx->lock);\n\tfree_event(event);\n}\n\n/*\n * Free an unexposed, unused context as created by inheritance by\n * perf_event_init_task below, used by fork() in case of fail.\n *\n * Not all locks are strictly required, but take them anyway to be nice and\n * help out with the lockdep assertions.\n */\nvoid perf_event_free_task(struct task_struct *task)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event, *tmp;\n\tint ctxn;\n\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = task->perf_event_ctxp[ctxn];\n\t\tif (!ctx)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&ctx->mutex);\nagain:\n\t\tlist_for_each_entry_safe(event, tmp, &ctx->pinned_groups,\n\t\t\t\tgroup_entry)\n\t\t\tperf_free_event(event, ctx);\n\n\t\tlist_for_each_entry_safe(event, tmp, &ctx->flexible_groups,\n\t\t\t\tgroup_entry)\n\t\t\tperf_free_event(event, ctx);\n\n\t\tif (!list_empty(&ctx->pinned_groups) ||\n\t\t\t\t!list_empty(&ctx->flexible_groups))\n\t\t\tgoto again;\n\n\t\tmutex_unlock(&ctx->mutex);\n\n\t\tput_ctx(ctx);\n\t}\n}\n\nvoid perf_event_delayed_put(struct task_struct *task)\n{\n\tint ctxn;\n\n\tfor_each_task_context_nr(ctxn)\n\t\tWARN_ON_ONCE(task->perf_event_ctxp[ctxn]);\n}\n\nstruct file *perf_event_get(unsigned int fd)\n{\n\tstruct file *file;\n\n\tfile = fget_raw(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (file->f_op != &perf_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn file;\n}\n\nconst struct perf_event_attr *perf_event_attrs(struct perf_event *event)\n{\n\tif (!event)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn &event->attr;\n}\n\n/*\n * inherit a event from parent task to child task:\n */\nstatic struct perf_event *\ninherit_event(struct perf_event *parent_event,\n\t      struct task_struct *parent,\n\t      struct perf_event_context *parent_ctx,\n\t      struct task_struct *child,\n\t      struct perf_event *group_leader,\n\t      struct perf_event_context *child_ctx)\n{\n\tenum perf_event_active_state parent_state = parent_event->state;\n\tstruct perf_event *child_event;\n\tunsigned long flags;\n\n\t/*\n\t * Instead of creating recursive hierarchies of events,\n\t * we link inherited events back to the original parent,\n\t * which has a filp for sure, which we use as the reference\n\t * count:\n\t */\n\tif (parent_event->parent)\n\t\tparent_event = parent_event->parent;\n\n\tchild_event = perf_event_alloc(&parent_event->attr,\n\t\t\t\t\t   parent_event->cpu,\n\t\t\t\t\t   child,\n\t\t\t\t\t   group_leader, parent_event,\n\t\t\t\t\t   NULL, NULL, -1);\n\tif (IS_ERR(child_event))\n\t\treturn child_event;\n\n\t/*\n\t * is_orphaned_event() and list_add_tail(&parent_event->child_list)\n\t * must be under the same lock in order to serialize against\n\t * perf_event_release_kernel(), such that either we must observe\n\t * is_orphaned_event() or they will observe us on the child_list.\n\t */\n\tmutex_lock(&parent_event->child_mutex);\n\tif (is_orphaned_event(parent_event) ||\n\t    !atomic_long_inc_not_zero(&parent_event->refcount)) {\n\t\tmutex_unlock(&parent_event->child_mutex);\n\t\tfree_event(child_event);\n\t\treturn NULL;\n\t}\n\n\tget_ctx(child_ctx);\n\n\t/*\n\t * Make the child state follow the state of the parent event,\n\t * not its attr.disabled bit.  We hold the parent's mutex,\n\t * so we won't race with perf_event_{en, dis}able_family.\n\t */\n\tif (parent_state >= PERF_EVENT_STATE_INACTIVE)\n\t\tchild_event->state = PERF_EVENT_STATE_INACTIVE;\n\telse\n\t\tchild_event->state = PERF_EVENT_STATE_OFF;\n\n\tif (parent_event->attr.freq) {\n\t\tu64 sample_period = parent_event->hw.sample_period;\n\t\tstruct hw_perf_event *hwc = &child_event->hw;\n\n\t\thwc->sample_period = sample_period;\n\t\thwc->last_period   = sample_period;\n\n\t\tlocal64_set(&hwc->period_left, sample_period);\n\t}\n\n\tchild_event->ctx = child_ctx;\n\tchild_event->overflow_handler = parent_event->overflow_handler;\n\tchild_event->overflow_handler_context\n\t\t= parent_event->overflow_handler_context;\n\n\t/*\n\t * Precalculate sample_data sizes\n\t */\n\tperf_event__header_size(child_event);\n\tperf_event__id_header_size(child_event);\n\n\t/*\n\t * Link it up in the child's context:\n\t */\n\traw_spin_lock_irqsave(&child_ctx->lock, flags);\n\tadd_event_to_ctx(child_event, child_ctx);\n\traw_spin_unlock_irqrestore(&child_ctx->lock, flags);\n\n\t/*\n\t * Link this into the parent event's child list\n\t */\n\tlist_add_tail(&child_event->child_list, &parent_event->child_list);\n\tmutex_unlock(&parent_event->child_mutex);\n\n\treturn child_event;\n}\n\nstatic int inherit_group(struct perf_event *parent_event,\n\t      struct task_struct *parent,\n\t      struct perf_event_context *parent_ctx,\n\t      struct task_struct *child,\n\t      struct perf_event_context *child_ctx)\n{\n\tstruct perf_event *leader;\n\tstruct perf_event *sub;\n\tstruct perf_event *child_ctr;\n\n\tleader = inherit_event(parent_event, parent, parent_ctx,\n\t\t\t\t child, NULL, child_ctx);\n\tif (IS_ERR(leader))\n\t\treturn PTR_ERR(leader);\n\tlist_for_each_entry(sub, &parent_event->sibling_list, group_entry) {\n\t\tchild_ctr = inherit_event(sub, parent, parent_ctx,\n\t\t\t\t\t    child, leader, child_ctx);\n\t\tif (IS_ERR(child_ctr))\n\t\t\treturn PTR_ERR(child_ctr);\n\t}\n\treturn 0;\n}\n\nstatic int\ninherit_task_group(struct perf_event *event, struct task_struct *parent,\n\t\t   struct perf_event_context *parent_ctx,\n\t\t   struct task_struct *child, int ctxn,\n\t\t   int *inherited_all)\n{\n\tint ret;\n\tstruct perf_event_context *child_ctx;\n\n\tif (!event->attr.inherit) {\n\t\t*inherited_all = 0;\n\t\treturn 0;\n\t}\n\n\tchild_ctx = child->perf_event_ctxp[ctxn];\n\tif (!child_ctx) {\n\t\t/*\n\t\t * This is executed from the parent task context, so\n\t\t * inherit events that have been marked for cloning.\n\t\t * First allocate and initialize a context for the\n\t\t * child.\n\t\t */\n\n\t\tchild_ctx = alloc_perf_context(parent_ctx->pmu, child);\n\t\tif (!child_ctx)\n\t\t\treturn -ENOMEM;\n\n\t\tchild->perf_event_ctxp[ctxn] = child_ctx;\n\t}\n\n\tret = inherit_group(event, parent, parent_ctx,\n\t\t\t    child, child_ctx);\n\n\tif (ret)\n\t\t*inherited_all = 0;\n\n\treturn ret;\n}\n\n/*\n * Initialize the perf_event context in task_struct\n */\nstatic int perf_event_init_context(struct task_struct *child, int ctxn)\n{\n\tstruct perf_event_context *child_ctx, *parent_ctx;\n\tstruct perf_event_context *cloned_ctx;\n\tstruct perf_event *event;\n\tstruct task_struct *parent = current;\n\tint inherited_all = 1;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (likely(!parent->perf_event_ctxp[ctxn]))\n\t\treturn 0;\n\n\t/*\n\t * If the parent's context is a clone, pin it so it won't get\n\t * swapped under us.\n\t */\n\tparent_ctx = perf_pin_task_context(parent, ctxn);\n\tif (!parent_ctx)\n\t\treturn 0;\n\n\t/*\n\t * No need to check if parent_ctx != NULL here; since we saw\n\t * it non-NULL earlier, the only reason for it to become NULL\n\t * is if we exit, and since we're currently in the middle of\n\t * a fork we can't be exiting at the same time.\n\t */\n\n\t/*\n\t * Lock the parent list. No need to lock the child - not PID\n\t * hashed yet and not running, so nobody can access it.\n\t */\n\tmutex_lock(&parent_ctx->mutex);\n\n\t/*\n\t * We dont have to disable NMIs - we are only looking at\n\t * the list, not manipulating it:\n\t */\n\tlist_for_each_entry(event, &parent_ctx->pinned_groups, group_entry) {\n\t\tret = inherit_task_group(event, parent, parent_ctx,\n\t\t\t\t\t child, ctxn, &inherited_all);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * We can't hold ctx->lock when iterating the ->flexible_group list due\n\t * to allocations, but we need to prevent rotation because\n\t * rotate_ctx() will change the list from interrupt context.\n\t */\n\traw_spin_lock_irqsave(&parent_ctx->lock, flags);\n\tparent_ctx->rotate_disable = 1;\n\traw_spin_unlock_irqrestore(&parent_ctx->lock, flags);\n\n\tlist_for_each_entry(event, &parent_ctx->flexible_groups, group_entry) {\n\t\tret = inherit_task_group(event, parent, parent_ctx,\n\t\t\t\t\t child, ctxn, &inherited_all);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\traw_spin_lock_irqsave(&parent_ctx->lock, flags);\n\tparent_ctx->rotate_disable = 0;\n\n\tchild_ctx = child->perf_event_ctxp[ctxn];\n\n\tif (child_ctx && inherited_all) {\n\t\t/*\n\t\t * Mark the child context as a clone of the parent\n\t\t * context, or of whatever the parent is a clone of.\n\t\t *\n\t\t * Note that if the parent is a clone, the holding of\n\t\t * parent_ctx->lock avoids it from being uncloned.\n\t\t */\n\t\tcloned_ctx = parent_ctx->parent_ctx;\n\t\tif (cloned_ctx) {\n\t\t\tchild_ctx->parent_ctx = cloned_ctx;\n\t\t\tchild_ctx->parent_gen = parent_ctx->parent_gen;\n\t\t} else {\n\t\t\tchild_ctx->parent_ctx = parent_ctx;\n\t\t\tchild_ctx->parent_gen = parent_ctx->generation;\n\t\t}\n\t\tget_ctx(child_ctx->parent_ctx);\n\t}\n\n\traw_spin_unlock_irqrestore(&parent_ctx->lock, flags);\n\tmutex_unlock(&parent_ctx->mutex);\n\n\tperf_unpin_context(parent_ctx);\n\tput_ctx(parent_ctx);\n\n\treturn ret;\n}\n\n/*\n * Initialize the perf_event context in task_struct\n */\nint perf_event_init_task(struct task_struct *child)\n{\n\tint ctxn, ret;\n\n\tmemset(child->perf_event_ctxp, 0, sizeof(child->perf_event_ctxp));\n\tmutex_init(&child->perf_event_mutex);\n\tINIT_LIST_HEAD(&child->perf_event_list);\n\n\tfor_each_task_context_nr(ctxn) {\n\t\tret = perf_event_init_context(child, ctxn);\n\t\tif (ret) {\n\t\t\tperf_event_free_task(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __init perf_event_init_all_cpus(void)\n{\n\tstruct swevent_htable *swhash;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tswhash = &per_cpu(swevent_htable, cpu);\n\t\tmutex_init(&swhash->hlist_mutex);\n\t\tINIT_LIST_HEAD(&per_cpu(active_ctx_list, cpu));\n\n\t\tINIT_LIST_HEAD(&per_cpu(pmu_sb_events.list, cpu));\n\t\traw_spin_lock_init(&per_cpu(pmu_sb_events.lock, cpu));\n\n\t\tINIT_LIST_HEAD(&per_cpu(sched_cb_list, cpu));\n\t}\n}\n\nint perf_event_init_cpu(unsigned int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\n\tmutex_lock(&swhash->hlist_mutex);\n\tif (swhash->hlist_refcount > 0 && !swevent_hlist_deref(swhash)) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));\n\t\tWARN_ON(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n\treturn 0;\n}\n\n#if defined CONFIG_HOTPLUG_CPU || defined CONFIG_KEXEC_CORE\nstatic void __perf_event_exit_context(void *__info)\n{\n\tstruct perf_event_context *ctx = __info;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\tstruct perf_event *event;\n\n\traw_spin_lock(&ctx->lock);\n\tlist_for_each_entry(event, &ctx->event_list, event_entry)\n\t\t__perf_remove_from_context(event, cpuctx, ctx, (void *)DETACH_GROUP);\n\traw_spin_unlock(&ctx->lock);\n}\n\nstatic void perf_event_exit_cpu_context(int cpu)\n{\n\tstruct perf_event_context *ctx;\n\tstruct pmu *pmu;\n\tint idx;\n\n\tidx = srcu_read_lock(&pmus_srcu);\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tctx = &per_cpu_ptr(pmu->pmu_cpu_context, cpu)->ctx;\n\n\t\tmutex_lock(&ctx->mutex);\n\t\tsmp_call_function_single(cpu, __perf_event_exit_context, ctx, 1);\n\t\tmutex_unlock(&ctx->mutex);\n\t}\n\tsrcu_read_unlock(&pmus_srcu, idx);\n}\n#else\n\nstatic void perf_event_exit_cpu_context(int cpu) { }\n\n#endif\n\nint perf_event_exit_cpu(unsigned int cpu)\n{\n\tperf_event_exit_cpu_context(cpu);\n\treturn 0;\n}\n\nstatic int\nperf_reboot(struct notifier_block *notifier, unsigned long val, void *v)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu)\n\t\tperf_event_exit_cpu(cpu);\n\n\treturn NOTIFY_OK;\n}\n\n/*\n * Run the perf reboot notifier at the very last possible moment so that\n * the generic watchdog code runs as long as possible.\n */\nstatic struct notifier_block perf_reboot_notifier = {\n\t.notifier_call = perf_reboot,\n\t.priority = INT_MIN,\n};\n\nvoid __init perf_event_init(void)\n{\n\tint ret;\n\n\tidr_init(&pmu_idr);\n\n\tperf_event_init_all_cpus();\n\tinit_srcu_struct(&pmus_srcu);\n\tperf_pmu_register(&perf_swevent, \"software\", PERF_TYPE_SOFTWARE);\n\tperf_pmu_register(&perf_cpu_clock, NULL, -1);\n\tperf_pmu_register(&perf_task_clock, NULL, -1);\n\tperf_tp_register();\n\tperf_event_init_cpu(smp_processor_id());\n\tregister_reboot_notifier(&perf_reboot_notifier);\n\n\tret = init_hw_breakpoint();\n\tWARN(ret, \"hw_breakpoint initialization failed with: %d\", ret);\n\n\t/*\n\t * Build time assertion that we keep the data_head at the intended\n\t * location.  IOW, validation we got the __reserved[] size right.\n\t */\n\tBUILD_BUG_ON((offsetof(struct perf_event_mmap_page, data_head))\n\t\t     != 1024);\n}\n\nssize_t perf_event_sysfs_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *page)\n{\n\tstruct perf_pmu_events_attr *pmu_attr =\n\t\tcontainer_of(attr, struct perf_pmu_events_attr, attr);\n\n\tif (pmu_attr->event_str)\n\t\treturn sprintf(page, \"%s\\n\", pmu_attr->event_str);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(perf_event_sysfs_show);\n\nstatic int __init perf_event_sysfs_init(void)\n{\n\tstruct pmu *pmu;\n\tint ret;\n\n\tmutex_lock(&pmus_lock);\n\n\tret = bus_register(&pmu_bus);\n\tif (ret)\n\t\tgoto unlock;\n\n\tlist_for_each_entry(pmu, &pmus, entry) {\n\t\tif (!pmu->name || pmu->type < 0)\n\t\t\tcontinue;\n\n\t\tret = pmu_dev_alloc(pmu);\n\t\tWARN(ret, \"Failed to register pmu: %s, reason %d\\n\", pmu->name, ret);\n\t}\n\tpmu_bus_running = 1;\n\tret = 0;\n\nunlock:\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n}\ndevice_initcall(perf_event_sysfs_init);\n\n#ifdef CONFIG_CGROUP_PERF\nstatic struct cgroup_subsys_state *\nperf_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct perf_cgroup *jc;\n\n\tjc = kzalloc(sizeof(*jc), GFP_KERNEL);\n\tif (!jc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tjc->info = alloc_percpu(struct perf_cgroup_info);\n\tif (!jc->info) {\n\t\tkfree(jc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn &jc->css;\n}\n\nstatic void perf_cgroup_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct perf_cgroup *jc = container_of(css, struct perf_cgroup, css);\n\n\tfree_percpu(jc->info);\n\tkfree(jc);\n}\n\nstatic int __perf_cgroup_move(void *info)\n{\n\tstruct task_struct *task = info;\n\trcu_read_lock();\n\tperf_cgroup_switch(task, PERF_CGROUP_SWOUT | PERF_CGROUP_SWIN);\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic void perf_cgroup_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *css;\n\n\tcgroup_taskset_for_each(task, css, tset)\n\t\ttask_function_call(task, __perf_cgroup_move, task);\n}\n\nstruct cgroup_subsys perf_event_cgrp_subsys = {\n\t.css_alloc\t= perf_cgroup_css_alloc,\n\t.css_free\t= perf_cgroup_css_free,\n\t.attach\t\t= perf_cgroup_attach,\n};\n#endif /* CONFIG_CGROUP_PERF */\n"], "filenames": ["kernel/events/core.c"], "buggy_code_start_loc": [9531], "buggy_code_end_loc": [9909], "fixing_code_start_loc": [9532], "fixing_code_end_loc": [9959], "type": "CWE-362", "message": "Race condition in kernel/events/core.c in the Linux kernel before 4.9.7 allows local users to gain privileges via a crafted application that makes concurrent perf_event_open system calls for moving a software group into a hardware context.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-6786.", "other": {"cve": {"id": "CVE-2017-6001", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-18T21:59:00.193", "lastModified": "2018-06-20T01:29:01.103", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in kernel/events/core.c in the Linux kernel before 4.9.7 allows local users to gain privileges via a crafted application that makes concurrent perf_event_open system calls for moving a software group into a hardware context.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-6786."}, {"lang": "es", "value": "Condici\u00f3n de carrera en kernel/events/core.c en el kernel de Linux en versiones anteriores a 4.9.7 permite a usuarios locales obtener privilegios a trav\u00e9s de una aplicaci\u00f3n manipulada que hace llamadas concurrentes al sistema perf_event_open para mover un grupo de software en un contexto hardware. NOTA: esta vulnerabilidad existe debido a una soluci\u00f3n incompleta para CVE-2016-6786."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.6}, "baseSeverity": "HIGH", "exploitabilityScore": 4.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.9.6", "matchCriteriaId": "55352769-0317-401E-901B-1AE7A7ADD86F"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=321027c1fe77f892f4ea07846aeae08cefbbb290", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3791", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.7", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/02/16/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96264", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1842", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2077", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2669", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:1854", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1422825", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/321027c1fe77f892f4ea07846aeae08cefbbb290", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/pixel/2017-11-01", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/321027c1fe77f892f4ea07846aeae08cefbbb290"}}