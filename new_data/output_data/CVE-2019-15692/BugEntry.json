{"buggy_code": ["/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright 2014 Pierre Ossman for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n// -=- PixelBuffer.cxx\n//\n// The PixelBuffer class encapsulates the PixelFormat and dimensions\n// of a block of pixel data.\n\n#include <rfb/Exception.h>\n#include <rfb/LogWriter.h>\n#include <rfb/PixelBuffer.h>\n\nusing namespace rfb;\nusing namespace rdr;\n\nstatic LogWriter vlog(\"PixelBuffer\");\n\n\n// -=- Generic pixel buffer class\n\nPixelBuffer::PixelBuffer(const PixelFormat& pf, int w, int h)\n  : format(pf), width_(0), height_(0)\n{\n  setSize(w, h);\n}\n\nPixelBuffer::PixelBuffer() : width_(0), height_(0)\n{\n}\n\nPixelBuffer::~PixelBuffer() {}\n\n\nvoid\nPixelBuffer::getImage(void* imageBuf, const Rect& r, int outStride) const\n{\n  int inStride;\n  const U8* data;\n  int bytesPerPixel, inBytesPerRow, outBytesPerRow, bytesPerMemCpy;\n  U8* imageBufPos;\n  const U8* end;\n\n  if (!r.enclosed_by(getRect()))\n    throw rfb::Exception(\"Source rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         r.width(), r.height(),\n                         r.tl.x, r.tl.y, width(), height());\n\n  data = getBuffer(r, &inStride);\n\n  bytesPerPixel = format.bpp/8;\n  inBytesPerRow = inStride * bytesPerPixel;\n\n  if (!outStride)\n    outStride = r.width();\n  outBytesPerRow = outStride * bytesPerPixel;\n  bytesPerMemCpy = r.width() * bytesPerPixel;\n\n  imageBufPos = (U8*)imageBuf;\n  end = data + (inBytesPerRow * r.height());\n\n  while (data < end) {\n    memcpy(imageBufPos, data, bytesPerMemCpy);\n    imageBufPos += outBytesPerRow;\n    data += inBytesPerRow;\n  }\n}\n\nvoid PixelBuffer::getImage(const PixelFormat& pf, void* imageBuf,\n                           const Rect& r, int stride) const\n{\n  const rdr::U8* srcBuffer;\n  int srcStride;\n\n  if (format.equal(pf)) {\n    getImage(imageBuf, r, stride);\n    return;\n  }\n\n  if (!r.enclosed_by(getRect()))\n    throw rfb::Exception(\"Source rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         r.width(), r.height(),\n                         r.tl.x, r.tl.y, width(), height());\n\n  if (stride == 0)\n    stride = r.width();\n\n  srcBuffer = getBuffer(r, &srcStride);\n\n  pf.bufferFromBuffer((U8*)imageBuf, format, srcBuffer, r.width(), r.height(),\n                      stride, srcStride);\n}\n\nvoid PixelBuffer::setSize(int width, int height)\n{\n  width_ = width;\n  height_ = height;\n}\n\n// -=- Modifiable generic pixel buffer class\n\nModifiablePixelBuffer::ModifiablePixelBuffer(const PixelFormat& pf,\n                                             int w, int h)\n  : PixelBuffer(pf, w, h)\n{\n}\n\nModifiablePixelBuffer::ModifiablePixelBuffer()\n{\n}\n\nModifiablePixelBuffer::~ModifiablePixelBuffer()\n{\n}\n\nvoid ModifiablePixelBuffer::fillRect(const Rect& r, const void* pix)\n{\n  int stride;\n  U8 *buf;\n  int w, h, b;\n\n  if (!r.enclosed_by(getRect()))\n    throw rfb::Exception(\"Destination rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         r.width(), r.height(), r.tl.x, r.tl.y, width(), height());\n\n  w = r.width();\n  h = r.height();\n  b = format.bpp/8;\n\n  if (h == 0)\n    return;\n\n  buf = getBufferRW(r, &stride);\n\n  if (b == 1) {\n    while (h--) {\n      memset(buf, *(const U8*)pix, w);\n      buf += stride * b;\n    }\n  } else {\n    U8 *start;\n    int w1;\n\n    start = buf;\n\n    w1 = w;\n    while (w1--) {\n      memcpy(buf, pix, b);\n      buf += b;\n    }\n    buf += (stride - w) * b;\n    h--;\n\n    while (h--) {\n      memcpy(buf, start, w * b);\n      buf += stride * b;\n    }\n  }\n\n  commitBufferRW(r);\n}\n\nvoid ModifiablePixelBuffer::imageRect(const Rect& r,\n                                      const void* pixels, int srcStride)\n{\n  U8* dest;\n  int destStride;\n  int bytesPerPixel, bytesPerDestRow, bytesPerSrcRow, bytesPerFill;\n  const U8* src;\n  U8* end;\n\n  if (!r.enclosed_by(getRect()))\n    throw rfb::Exception(\"Destination rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         r.width(), r.height(),\n                         r.tl.x, r.tl.y, width(), height());\n\n  bytesPerPixel = getPF().bpp/8;\n\n  dest = getBufferRW(r, &destStride);\n\n  bytesPerDestRow = bytesPerPixel * destStride;\n\n  if (!srcStride)\n    srcStride = r.width();\n  bytesPerSrcRow = bytesPerPixel * srcStride;\n  bytesPerFill = bytesPerPixel * r.width();\n\n  src = (const U8*)pixels;\n  end = dest + (bytesPerDestRow * r.height());\n\n  while (dest < end) {\n    memcpy(dest, src, bytesPerFill);\n    dest += bytesPerDestRow;\n    src += bytesPerSrcRow;\n  }\n\n  commitBufferRW(r);\n}\n\nvoid ModifiablePixelBuffer::copyRect(const Rect &rect,\n                                     const Point &move_by_delta)\n{\n  int srcStride, dstStride;\n  int bytesPerPixel;\n  const U8* srcData;\n  U8* dstData;\n\n  Rect drect, srect;\n\n  drect = rect;\n  if (!drect.enclosed_by(getRect()))\n    throw rfb::Exception(\"Destination rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         drect.width(), drect.height(),\n                         drect.tl.x, drect.tl.y, width(), height());\n\n  srect = drect.translate(move_by_delta.negate());\n  if (!srect.enclosed_by(getRect()))\n    throw rfb::Exception(\"Source rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         srect.width(), srect.height(),\n                         srect.tl.x, srect.tl.y, width(), height());\n\n  bytesPerPixel = format.bpp/8;\n\n  srcData = getBuffer(srect, &srcStride);\n  dstData = getBufferRW(drect, &dstStride);\n\n  if (move_by_delta.y == 0) {\n    // Possible overlap. Be careful and use memmove().\n    int h = drect.height();\n    while (h--) {\n      memmove(dstData, srcData, drect.width() * bytesPerPixel);\n      dstData += dstStride * bytesPerPixel;\n      srcData += srcStride * bytesPerPixel;\n    }\n  } else if (move_by_delta.y < 0) {\n    // The data shifted upwards. Copy from top to bottom.\n    int h = drect.height();\n    while (h--) {\n      memcpy(dstData, srcData, drect.width() * bytesPerPixel);\n      dstData += dstStride * bytesPerPixel;\n      srcData += srcStride * bytesPerPixel;\n    }\n  } else {\n    // The data shifted downwards. Copy from bottom to top.\n    int h = drect.height();\n    dstData += (h-1) * dstStride * bytesPerPixel;\n    srcData += (h-1) * srcStride * bytesPerPixel;\n    while (h--) {\n      memcpy(dstData, srcData, drect.width() * bytesPerPixel);\n      dstData -= dstStride * bytesPerPixel;\n      srcData -= srcStride * bytesPerPixel;\n    }\n  }\n\n  commitBufferRW(drect);\n}\n\nvoid ModifiablePixelBuffer::fillRect(const PixelFormat& pf, const Rect &dest,\n                                     const void* pix)\n{\n  rdr::U8 buf[4];\n  format.bufferFromBuffer(buf, pf, (const rdr::U8*)pix, 1);\n  fillRect(dest, buf);\n}\n\nvoid ModifiablePixelBuffer::imageRect(const PixelFormat& pf, const Rect &dest,\n                                      const void* pixels, int stride)\n{\n  rdr::U8* dstBuffer;\n  int dstStride;\n\n  if (!dest.enclosed_by(getRect()))\n    throw rfb::Exception(\"Destination rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         dest.width(), dest.height(),\n                         dest.tl.x, dest.tl.y, width(), height());\n\n  if (stride == 0)\n    stride = dest.width();\n\n  dstBuffer = getBufferRW(dest, &dstStride);\n  format.bufferFromBuffer(dstBuffer, pf, (const rdr::U8*)pixels,\n                          dest.width(), dest.height(),\n                          dstStride, stride);\n  commitBufferRW(dest);\n}\n\n// -=- Simple pixel buffer with a continuous block of memory\n\nFullFramePixelBuffer::FullFramePixelBuffer(const PixelFormat& pf, int w, int h,\n                                           rdr::U8* data_, int stride_)\n  : ModifiablePixelBuffer(pf, w, h), data(data_), stride(stride_)\n{\n}\n\nFullFramePixelBuffer::FullFramePixelBuffer() : data(0) {}\n\nFullFramePixelBuffer::~FullFramePixelBuffer() {}\n\nrdr::U8* FullFramePixelBuffer::getBufferRW(const Rect& r, int* stride_)\n{\n  if (!r.enclosed_by(getRect()))\n    throw rfb::Exception(\"Pixel buffer request %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         r.width(), r.height(),\n                         r.tl.x, r.tl.y, width(), height());\n\n  *stride_ = stride;\n  return &data[(r.tl.x + (r.tl.y * stride)) * (format.bpp/8)];\n}\n\nvoid FullFramePixelBuffer::commitBufferRW(const Rect& r)\n{\n}\n\nconst rdr::U8* FullFramePixelBuffer::getBuffer(const Rect& r, int* stride_) const\n{\n  if (!r.enclosed_by(getRect()))\n    throw rfb::Exception(\"Pixel buffer request %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         r.width(), r.height(),\n                         r.tl.x, r.tl.y, width(), height());\n\n  *stride_ = stride;\n  return &data[(r.tl.x + (r.tl.y * stride)) * (format.bpp/8)];\n}\n\nvoid FullFramePixelBuffer::setBuffer(int width, int height,\n                                     rdr::U8* data_, int stride_)\n{\n  ModifiablePixelBuffer::setSize(width, height);\n  stride = stride_;\n  data = data_;\n}\n\nvoid FullFramePixelBuffer::setSize(int w, int h)\n{\n  // setBuffer() should be used\n  throw rfb::Exception(\"Invalid call to FullFramePixelBuffer::setSize()\");\n}\n\n// -=- Managed pixel buffer class\n// Automatically allocates enough space for the specified format & area\n\nManagedPixelBuffer::ManagedPixelBuffer()\n  : data_(NULL), datasize(0)\n{\n}\n\nManagedPixelBuffer::ManagedPixelBuffer(const PixelFormat& pf, int w, int h)\n  : FullFramePixelBuffer(pf, 0, 0, NULL, 0), data_(NULL), datasize(0)\n{\n  setSize(w, h);\n}\n\nManagedPixelBuffer::~ManagedPixelBuffer()\n{\n  if (data_)\n    delete [] data_;\n}\n\nvoid ManagedPixelBuffer::setPF(const PixelFormat &pf)\n{\n  format = pf;\n  setSize(width(), height());\n}\n\nvoid ManagedPixelBuffer::setSize(int w, int h)\n{\n  unsigned long new_datasize = w * h * (format.bpp/8);\n\n  new_datasize = w * h * (format.bpp/8);\n  if (datasize < new_datasize) {\n    if (data_) {\n      delete [] data_;\n      data_ = NULL;\n      datasize = 0;\n    }\n    if (new_datasize) {\n      data_ = new U8[new_datasize];\n      datasize = new_datasize;\n    }\n  }\n\n  setBuffer(w, h, data_, w);\n}\n"], "fixing_code": ["/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright 2014 Pierre Ossman for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n// -=- PixelBuffer.cxx\n//\n// The PixelBuffer class encapsulates the PixelFormat and dimensions\n// of a block of pixel data.\n\n#include <rfb/Exception.h>\n#include <rfb/LogWriter.h>\n#include <rfb/PixelBuffer.h>\n\nusing namespace rfb;\nusing namespace rdr;\n\nstatic LogWriter vlog(\"PixelBuffer\");\n\n// We do a lot of byte offset calculations that assume the result fits\n// inside a signed 32 bit integer. Limit the maximum size of pixel\n// buffers so that these calculations never overflow.\n\nconst int maxPixelBufferWidth = 16384;\nconst int maxPixelBufferHeight = 16384;\nconst int maxPixelBufferStride = 16384;\n\n\n// -=- Generic pixel buffer class\n\nPixelBuffer::PixelBuffer(const PixelFormat& pf, int w, int h)\n  : format(pf), width_(0), height_(0)\n{\n  setSize(w, h);\n}\n\nPixelBuffer::PixelBuffer() : width_(0), height_(0)\n{\n}\n\nPixelBuffer::~PixelBuffer() {}\n\n\nvoid\nPixelBuffer::getImage(void* imageBuf, const Rect& r, int outStride) const\n{\n  int inStride;\n  const U8* data;\n  int bytesPerPixel, inBytesPerRow, outBytesPerRow, bytesPerMemCpy;\n  U8* imageBufPos;\n  const U8* end;\n\n  if (!r.enclosed_by(getRect()))\n    throw rfb::Exception(\"Source rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         r.width(), r.height(),\n                         r.tl.x, r.tl.y, width(), height());\n\n  data = getBuffer(r, &inStride);\n\n  bytesPerPixel = format.bpp/8;\n  inBytesPerRow = inStride * bytesPerPixel;\n\n  if (!outStride)\n    outStride = r.width();\n  outBytesPerRow = outStride * bytesPerPixel;\n  bytesPerMemCpy = r.width() * bytesPerPixel;\n\n  imageBufPos = (U8*)imageBuf;\n  end = data + (inBytesPerRow * r.height());\n\n  while (data < end) {\n    memcpy(imageBufPos, data, bytesPerMemCpy);\n    imageBufPos += outBytesPerRow;\n    data += inBytesPerRow;\n  }\n}\n\nvoid PixelBuffer::getImage(const PixelFormat& pf, void* imageBuf,\n                           const Rect& r, int stride) const\n{\n  const rdr::U8* srcBuffer;\n  int srcStride;\n\n  if (format.equal(pf)) {\n    getImage(imageBuf, r, stride);\n    return;\n  }\n\n  if (!r.enclosed_by(getRect()))\n    throw rfb::Exception(\"Source rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         r.width(), r.height(),\n                         r.tl.x, r.tl.y, width(), height());\n\n  if (stride == 0)\n    stride = r.width();\n\n  srcBuffer = getBuffer(r, &srcStride);\n\n  pf.bufferFromBuffer((U8*)imageBuf, format, srcBuffer, r.width(), r.height(),\n                      stride, srcStride);\n}\n\nvoid PixelBuffer::setSize(int width, int height)\n{\n  if ((width < 0) || (width > maxPixelBufferWidth))\n    throw rfb::Exception(\"Invalid PixelBuffer width of %d pixels requested\", width);\n  if ((height < 0) || (height > maxPixelBufferHeight))\n    throw rfb::Exception(\"Invalid PixelBuffer height of %d pixels requested\", height);\n\n  width_ = width;\n  height_ = height;\n}\n\n// -=- Modifiable generic pixel buffer class\n\nModifiablePixelBuffer::ModifiablePixelBuffer(const PixelFormat& pf,\n                                             int w, int h)\n  : PixelBuffer(pf, w, h)\n{\n}\n\nModifiablePixelBuffer::ModifiablePixelBuffer()\n{\n}\n\nModifiablePixelBuffer::~ModifiablePixelBuffer()\n{\n}\n\nvoid ModifiablePixelBuffer::fillRect(const Rect& r, const void* pix)\n{\n  int stride;\n  U8 *buf;\n  int w, h, b;\n\n  if (!r.enclosed_by(getRect()))\n    throw rfb::Exception(\"Destination rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         r.width(), r.height(), r.tl.x, r.tl.y, width(), height());\n\n  w = r.width();\n  h = r.height();\n  b = format.bpp/8;\n\n  if (h == 0)\n    return;\n\n  buf = getBufferRW(r, &stride);\n\n  if (b == 1) {\n    while (h--) {\n      memset(buf, *(const U8*)pix, w);\n      buf += stride * b;\n    }\n  } else {\n    U8 *start;\n    int w1;\n\n    start = buf;\n\n    w1 = w;\n    while (w1--) {\n      memcpy(buf, pix, b);\n      buf += b;\n    }\n    buf += (stride - w) * b;\n    h--;\n\n    while (h--) {\n      memcpy(buf, start, w * b);\n      buf += stride * b;\n    }\n  }\n\n  commitBufferRW(r);\n}\n\nvoid ModifiablePixelBuffer::imageRect(const Rect& r,\n                                      const void* pixels, int srcStride)\n{\n  U8* dest;\n  int destStride;\n  int bytesPerPixel, bytesPerDestRow, bytesPerSrcRow, bytesPerFill;\n  const U8* src;\n  U8* end;\n\n  if (!r.enclosed_by(getRect()))\n    throw rfb::Exception(\"Destination rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         r.width(), r.height(),\n                         r.tl.x, r.tl.y, width(), height());\n\n  bytesPerPixel = getPF().bpp/8;\n\n  dest = getBufferRW(r, &destStride);\n\n  bytesPerDestRow = bytesPerPixel * destStride;\n\n  if (!srcStride)\n    srcStride = r.width();\n  bytesPerSrcRow = bytesPerPixel * srcStride;\n  bytesPerFill = bytesPerPixel * r.width();\n\n  src = (const U8*)pixels;\n  end = dest + (bytesPerDestRow * r.height());\n\n  while (dest < end) {\n    memcpy(dest, src, bytesPerFill);\n    dest += bytesPerDestRow;\n    src += bytesPerSrcRow;\n  }\n\n  commitBufferRW(r);\n}\n\nvoid ModifiablePixelBuffer::copyRect(const Rect &rect,\n                                     const Point &move_by_delta)\n{\n  int srcStride, dstStride;\n  int bytesPerPixel;\n  const U8* srcData;\n  U8* dstData;\n\n  Rect drect, srect;\n\n  drect = rect;\n  if (!drect.enclosed_by(getRect()))\n    throw rfb::Exception(\"Destination rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         drect.width(), drect.height(),\n                         drect.tl.x, drect.tl.y, width(), height());\n\n  srect = drect.translate(move_by_delta.negate());\n  if (!srect.enclosed_by(getRect()))\n    throw rfb::Exception(\"Source rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         srect.width(), srect.height(),\n                         srect.tl.x, srect.tl.y, width(), height());\n\n  bytesPerPixel = format.bpp/8;\n\n  srcData = getBuffer(srect, &srcStride);\n  dstData = getBufferRW(drect, &dstStride);\n\n  if (move_by_delta.y == 0) {\n    // Possible overlap. Be careful and use memmove().\n    int h = drect.height();\n    while (h--) {\n      memmove(dstData, srcData, drect.width() * bytesPerPixel);\n      dstData += dstStride * bytesPerPixel;\n      srcData += srcStride * bytesPerPixel;\n    }\n  } else if (move_by_delta.y < 0) {\n    // The data shifted upwards. Copy from top to bottom.\n    int h = drect.height();\n    while (h--) {\n      memcpy(dstData, srcData, drect.width() * bytesPerPixel);\n      dstData += dstStride * bytesPerPixel;\n      srcData += srcStride * bytesPerPixel;\n    }\n  } else {\n    // The data shifted downwards. Copy from bottom to top.\n    int h = drect.height();\n    dstData += (h-1) * dstStride * bytesPerPixel;\n    srcData += (h-1) * srcStride * bytesPerPixel;\n    while (h--) {\n      memcpy(dstData, srcData, drect.width() * bytesPerPixel);\n      dstData -= dstStride * bytesPerPixel;\n      srcData -= srcStride * bytesPerPixel;\n    }\n  }\n\n  commitBufferRW(drect);\n}\n\nvoid ModifiablePixelBuffer::fillRect(const PixelFormat& pf, const Rect &dest,\n                                     const void* pix)\n{\n  rdr::U8 buf[4];\n  format.bufferFromBuffer(buf, pf, (const rdr::U8*)pix, 1);\n  fillRect(dest, buf);\n}\n\nvoid ModifiablePixelBuffer::imageRect(const PixelFormat& pf, const Rect &dest,\n                                      const void* pixels, int stride)\n{\n  rdr::U8* dstBuffer;\n  int dstStride;\n\n  if (!dest.enclosed_by(getRect()))\n    throw rfb::Exception(\"Destination rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         dest.width(), dest.height(),\n                         dest.tl.x, dest.tl.y, width(), height());\n\n  if (stride == 0)\n    stride = dest.width();\n\n  dstBuffer = getBufferRW(dest, &dstStride);\n  format.bufferFromBuffer(dstBuffer, pf, (const rdr::U8*)pixels,\n                          dest.width(), dest.height(),\n                          dstStride, stride);\n  commitBufferRW(dest);\n}\n\n// -=- Simple pixel buffer with a continuous block of memory\n\nFullFramePixelBuffer::FullFramePixelBuffer(const PixelFormat& pf, int w, int h,\n                                           rdr::U8* data_, int stride_)\n  : ModifiablePixelBuffer(pf, w, h), data(data_), stride(stride_)\n{\n}\n\nFullFramePixelBuffer::FullFramePixelBuffer() : data(0) {}\n\nFullFramePixelBuffer::~FullFramePixelBuffer() {}\n\nrdr::U8* FullFramePixelBuffer::getBufferRW(const Rect& r, int* stride_)\n{\n  if (!r.enclosed_by(getRect()))\n    throw rfb::Exception(\"Pixel buffer request %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         r.width(), r.height(),\n                         r.tl.x, r.tl.y, width(), height());\n\n  *stride_ = stride;\n  return &data[(r.tl.x + (r.tl.y * stride)) * (format.bpp/8)];\n}\n\nvoid FullFramePixelBuffer::commitBufferRW(const Rect& r)\n{\n}\n\nconst rdr::U8* FullFramePixelBuffer::getBuffer(const Rect& r, int* stride_) const\n{\n  if (!r.enclosed_by(getRect()))\n    throw rfb::Exception(\"Pixel buffer request %dx%d at %d,%d exceeds framebuffer %dx%d\",\n                         r.width(), r.height(),\n                         r.tl.x, r.tl.y, width(), height());\n\n  *stride_ = stride;\n  return &data[(r.tl.x + (r.tl.y * stride)) * (format.bpp/8)];\n}\n\nvoid FullFramePixelBuffer::setBuffer(int width, int height,\n                                     rdr::U8* data_, int stride_)\n{\n  if ((width < 0) || (width > maxPixelBufferWidth))\n    throw rfb::Exception(\"Invalid PixelBuffer width of %d pixels requested\", width);\n  if ((height < 0) || (height > maxPixelBufferHeight))\n    throw rfb::Exception(\"Invalid PixelBuffer height of %d pixels requested\", height);\n  if ((stride_ < 0) || (stride_ > maxPixelBufferStride) || (stride_ < width))\n    throw rfb::Exception(\"Invalid PixelBuffer stride of %d pixels requested\", stride_);\n  if ((width != 0) && (height != 0) && (data_ == NULL))\n    throw rfb::Exception(\"PixelBuffer requested without a valid memory area\");\n\n  ModifiablePixelBuffer::setSize(width, height);\n  stride = stride_;\n  data = data_;\n}\n\nvoid FullFramePixelBuffer::setSize(int w, int h)\n{\n  // setBuffer() should be used\n  throw rfb::Exception(\"Invalid call to FullFramePixelBuffer::setSize()\");\n}\n\n// -=- Managed pixel buffer class\n// Automatically allocates enough space for the specified format & area\n\nManagedPixelBuffer::ManagedPixelBuffer()\n  : data_(NULL), datasize(0)\n{\n}\n\nManagedPixelBuffer::ManagedPixelBuffer(const PixelFormat& pf, int w, int h)\n  : FullFramePixelBuffer(pf, 0, 0, NULL, 0), data_(NULL), datasize(0)\n{\n  setSize(w, h);\n}\n\nManagedPixelBuffer::~ManagedPixelBuffer()\n{\n  if (data_)\n    delete [] data_;\n}\n\nvoid ManagedPixelBuffer::setPF(const PixelFormat &pf)\n{\n  format = pf;\n  setSize(width(), height());\n}\n\nvoid ManagedPixelBuffer::setSize(int w, int h)\n{\n  unsigned long new_datasize = w * h * (format.bpp/8);\n\n  new_datasize = w * h * (format.bpp/8);\n  if (datasize < new_datasize) {\n    if (data_) {\n      delete [] data_;\n      data_ = NULL;\n      datasize = 0;\n    }\n    if (new_datasize) {\n      data_ = new U8[new_datasize];\n      datasize = new_datasize;\n    }\n  }\n\n  setBuffer(w, h, data_, w);\n}\n"], "filenames": ["common/rfb/PixelBuffer.cxx"], "buggy_code_start_loc": [33], "buggy_code_end_loc": [342], "fixing_code_start_loc": [34], "fixing_code_end_loc": [365], "type": "CWE-787", "message": "TigerVNC version prior to 1.10.1 is vulnerable to heap buffer overflow. Vulnerability could be triggered from CopyRectDecoder due to incorrect value checks. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.", "other": {"cve": {"id": "CVE-2019-15692", "sourceIdentifier": "vulnerability@kaspersky.com", "published": "2019-12-26T15:15:11.147", "lastModified": "2022-12-22T20:22:52.230", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TigerVNC version prior to 1.10.1 is vulnerable to heap buffer overflow. Vulnerability could be triggered from CopyRectDecoder due to incorrect value checks. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity."}, {"lang": "es", "value": "TigerVNC versiones anteriores a 1.10.1, es vulnerable al desbordamiento de b\u00fafer de la pila. La vulnerabilidad podr\u00eda ser activada desde la funci\u00f3n CopyRectDecoder debido a comprobaciones de valores incorrectas. La explotaci\u00f3n de esta vulnerabilidad podr\u00eda resultar potencialmente en una ejecuci\u00f3n de c\u00f3digo remota. Este ataque parece ser explotable a trav\u00e9s de la conectividad de red."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "vulnerability@kaspersky.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tigervnc:tigervnc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.1", "matchCriteriaId": "5DB31840-DC35-40A5-8126-FF5FDD81EAD7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-01/msg00039.html", "source": "vulnerability@kaspersky.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/CendioOssman/tigervnc/commit/996356b6c65ca165ee1ea46a571c32a1dc3c3821", "source": "vulnerability@kaspersky.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TigerVNC/tigervnc/releases/tag/v1.10.1", "source": "vulnerability@kaspersky.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2019/12/20/2", "source": "vulnerability@kaspersky.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/CendioOssman/tigervnc/commit/996356b6c65ca165ee1ea46a571c32a1dc3c3821"}}