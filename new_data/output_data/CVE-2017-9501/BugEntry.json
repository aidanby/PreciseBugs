{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                     IIIII  M   M   AAA    GGGG  EEEEE                       %\n%                       I    MM MM  A   A  G      E                           %\n%                       I    M M M  AAAAA  G  GG  EEE                         %\n%                       I    M   M  A   A  G   G  E                           %\n%                     IIIII  M   M  A   A   GGGG  EEEEE                       %\n%                                                                             %\n%                                                                             %\n%                           MagickCore Image Methods                          %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/animate.h\"\n#include \"magick/artifact.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/cache-private.h\"\n#include \"magick/cache-view.h\"\n#include \"magick/channel.h\"\n#include \"magick/client.h\"\n#include \"magick/color.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/composite.h\"\n#include \"magick/composite-private.h\"\n#include \"magick/compress.h\"\n#include \"magick/constitute.h\"\n#include \"magick/delegate.h\"\n#include \"magick/deprecate.h\"\n#include \"magick/display.h\"\n#include \"magick/draw.h\"\n#include \"magick/enhance.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/gem.h\"\n#include \"magick/geometry.h\"\n#include \"magick/histogram.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magic.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/module.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/paint.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/pixel-private.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantize.h\"\n#include \"magick/random_.h\"\n#include \"magick/resource_.h\"\n#include \"magick/segment.h\"\n#include \"magick/semaphore.h\"\n#include \"magick/signature-private.h\"\n#include \"magick/statistic.h\"\n#include \"magick/string_.h\"\n#include \"magick/string-private.h\"\n#include \"magick/thread-private.h\"\n#include \"magick/threshold.h\"\n#include \"magick/timer.h\"\n#include \"magick/token.h\"\n#include \"magick/utility.h\"\n#include \"magick/version.h\"\n#include \"magick/xwindow-private.h\"\n\f\n/*\n  Constant declaration.\n*/\nconst char\n  BackgroundColor[] = \"#ffffff\",  /* white */\n  BorderColor[] = \"#dfdfdf\",  /* gray */\n  DefaultTileFrame[] = \"15x15+3+3\",\n  DefaultTileGeometry[] = \"120x120+4+3>\",\n  DefaultTileLabel[] = \"%f\\n%G\\n%b\",\n  ForegroundColor[] = \"#000\",  /* black */\n  LoadImageTag[] = \"Load/Image\",\n  LoadImagesTag[] = \"Load/Images\",\n  MatteColor[] = \"#bdbdbd\",  /* gray */\n  PSDensityGeometry[] = \"72.0x72.0\",\n  PSPageGeometry[] = \"612x792\",\n  SaveImageTag[] = \"Save/Image\",\n  SaveImagesTag[] = \"Save/Images\",\n  TransparentColor[] = \"#00000000\";  /* transparent black */\n\nconst double\n  DefaultResolution = 72.0;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireImage() returns a pointer to an image structure initialized to\n%  default values.\n%\n%  The format of the AcquireImage method is:\n%\n%      Image *AcquireImage(const ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Many of the image default values are set from this\n%      structure.  For example, filename, compression, depth, background color,\n%      and others.\n%\n*/\nMagickExport Image *AcquireImage(const ImageInfo *image_info)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  MagickStatusType\n    flags;\n\n  /*\n    Allocate image structure.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  image=(Image *) AcquireMagickMemory(sizeof(*image));\n  if (image == (Image *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(image,0,sizeof(*image));\n  /*\n    Initialize Image structure.\n  */\n  (void) CopyMagickString(image->magick,\"MIFF\",MaxTextExtent);\n  image->storage_class=DirectClass;\n  image->depth=MAGICKCORE_QUANTUM_DEPTH;\n  image->colorspace=sRGBColorspace;\n  image->rendering_intent=PerceptualIntent;\n  image->gamma=1.000f/2.200f;\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.red_primary.z=0.0300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.green_primary.z=0.1000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.blue_primary.y=0.0600f;\n  image->chromaticity.blue_primary.z=0.7900f;\n  image->chromaticity.white_point.x=0.3127f;\n  image->chromaticity.white_point.y=0.3290f;\n  image->chromaticity.white_point.z=0.3583f;\n  image->interlace=NoInterlace;\n  image->ticks_per_second=UndefinedTicksPerSecond;\n  image->compose=OverCompositeOp;\n  image->blur=1.0;\n  InitializeExceptionInfo(&image->exception);\n  (void) QueryColorDatabase(BackgroundColor,&image->background_color,\n    &image->exception);\n  (void) QueryColorDatabase(BorderColor,&image->border_color,&image->exception);\n  (void) QueryColorDatabase(MatteColor,&image->matte_color,&image->exception);\n  (void) QueryColorDatabase(TransparentColor,&image->transparent_color,\n    &image->exception);\n  GetTimerInfo(&image->timer);\n  image->ping=MagickFalse;\n  image->cache=AcquirePixelCache(0);\n  image->blob=CloneBlobInfo((BlobInfo *) NULL);\n  image->timestamp=time((time_t *) NULL);\n  image->debug=IsEventLogging();\n  image->reference_count=1;\n  image->semaphore=AllocateSemaphoreInfo();\n  image->signature=MagickSignature;\n  if (image_info == (ImageInfo *) NULL)\n    return(image);\n  /*\n    Transfer image info.\n  */\n  SetBlobExempt(image,image_info->file != (FILE *) NULL ? MagickTrue :\n    MagickFalse);\n  (void) CopyMagickString(image->filename,image_info->filename,MaxTextExtent);\n  (void) CopyMagickString(image->magick_filename,image_info->filename,\n    MaxTextExtent);\n  (void) CopyMagickString(image->magick,image_info->magick,MaxTextExtent);\n  if (image_info->size != (char *) NULL)\n    {\n      (void) ParseAbsoluteGeometry(image_info->size,&image->extract_info);\n      image->columns=image->extract_info.width;\n      image->rows=image->extract_info.height;\n      image->offset=image->extract_info.x;\n      image->extract_info.x=0;\n      image->extract_info.y=0;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n        {\n          image->extract_info=geometry;\n          Swap(image->columns,image->extract_info.width);\n          Swap(image->rows,image->extract_info.height);\n        }\n    }\n  image->compression=image_info->compression;\n  image->quality=image_info->quality;\n  image->endian=image_info->endian;\n  image->interlace=image_info->interlace;\n  image->units=image_info->units;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n    }\n  if (image_info->page != (char *) NULL)\n    {\n      char\n        *geometry;\n\n      image->page=image->extract_info;\n      geometry=GetPageGeometry(image_info->page);\n      (void) ParseAbsoluteGeometry(geometry,&image->page);\n      geometry=DestroyString(geometry);\n    }\n  if (image_info->depth != 0)\n    image->depth=image_info->depth;\n  image->dither=image_info->dither;\n  image->background_color=image_info->background_color;\n  image->border_color=image_info->border_color;\n  image->matte_color=image_info->matte_color;\n  image->transparent_color=image_info->transparent_color;\n  image->ping=image_info->ping;\n  image->progress_monitor=image_info->progress_monitor;\n  image->client_data=image_info->client_data;\n  if (image_info->cache != (void *) NULL)\n    ClonePixelCacheMethods(image->cache,image_info->cache);\n  (void) SyncImageSettings(image_info,image);\n  option=GetImageOption(image_info,\"delay\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & GreaterValue) != 0)\n        {\n          if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n            image->delay=(size_t) floor(geometry_info.rho+0.5);\n        }\n      else\n        if ((flags & LessValue) != 0)\n          {\n            if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n              image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          }\n        else\n          image->delay=(size_t) floor(geometry_info.rho+0.5);\n      if ((flags & SigmaValue) != 0)\n        image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n    }\n  option=GetImageOption(image_info,\"dispose\");\n  if (option != (const char *) NULL)\n    image->dispose=(DisposeType) ParseCommandOption(MagickDisposeOptions,\n      MagickFalse,option);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e I m a g e I n f o                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireImageInfo() allocates the ImageInfo structure.\n%\n%  The format of the AcquireImageInfo method is:\n%\n%      ImageInfo *AcquireImageInfo(void)\n%\n*/\nMagickExport ImageInfo *AcquireImageInfo(void)\n{\n  ImageInfo\n    *image_info;\n\n  image_info=(ImageInfo *) AcquireMagickMemory(sizeof(*image_info));\n  if (image_info == (ImageInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  GetImageInfo(image_info);\n  return(image_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e N e x t I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireNextImage() initializes the next image in a sequence to\n%  default values.  The next member of image points to the newly allocated\n%  image.  If there is a memory shortage, next is assigned NULL.\n%\n%  The format of the AcquireNextImage method is:\n%\n%      void AcquireNextImage(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Many of the image default values are set from this\n%      structure.  For example, filename, compression, depth, background color,\n%      and others.\n%\n%    o image: the image.\n%\n*/\nMagickExport void AcquireNextImage(const ImageInfo *image_info,Image *image)\n{\n  /*\n    Allocate image structure.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  image->next=AcquireImage(image_info);\n  if (GetNextImageInList(image) == (Image *) NULL)\n    return;\n  (void) CopyMagickString(GetNextImageInList(image)->filename,image->filename,\n    MaxTextExtent);\n  if (image_info != (ImageInfo *) NULL)\n    (void) CopyMagickString(GetNextImageInList(image)->filename,\n      image_info->filename,MaxTextExtent);\n  DestroyBlob(GetNextImageInList(image));\n  image->next->blob=ReferenceBlob(image->blob);\n  image->next->endian=image->endian;\n  image->next->scene=image->scene+1;\n  image->next->previous=image;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     A p p e n d I m a g e s                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AppendImages() takes all images from the current image pointer to the end\n%  of the image list and appends them to each other top-to-bottom if the\n%  stack parameter is true, otherwise left-to-right.\n%\n%  The current gravity setting now effects how the image is justified in the\n%  final image.\n%\n%  The format of the AppendImages method is:\n%\n%      Image *AppendImages(const Image *images,const MagickBooleanType stack,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o images: the image sequence.\n%\n%    o stack: A value other than 0 stacks the images top-to-bottom.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *AppendImages(const Image *images,\n  const MagickBooleanType stack,ExceptionInfo *exception)\n{\n#define AppendImageTag  \"Append/Image\"\n\n  CacheView\n    *append_view;\n\n  Image\n    *append_image;\n\n  MagickBooleanType\n    homogeneous_colorspace,\n    matte,\n    status;\n\n  MagickOffsetType\n    n;\n\n  RectangleInfo\n    geometry;\n\n  register const Image\n    *next;\n\n  size_t\n    depth,\n    height,\n    number_images,\n    width;\n\n  ssize_t\n    x_offset,\n    y,\n    y_offset;\n\n  /*\n    Compute maximum area of appended area.\n  */\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  matte=images->matte;\n  number_images=1;\n  width=images->columns;\n  height=images->rows;\n  depth=images->depth;\n  homogeneous_colorspace=MagickTrue;\n  next=GetNextImageInList(images);\n  for ( ; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    if (next->depth > depth)\n      depth=next->depth;\n    if (next->colorspace != images->colorspace)\n      homogeneous_colorspace=MagickFalse;\n    if (next->matte != MagickFalse)\n      matte=MagickTrue;\n    number_images++;\n    if (stack != MagickFalse)\n      {\n        if (next->columns > width)\n          width=next->columns;\n        height+=next->rows;\n        continue;\n      }\n    width+=next->columns;\n    if (next->rows > height)\n      height=next->rows;\n  }\n  /*\n    Append images.\n  */\n  append_image=CloneImage(images,width,height,MagickTrue,exception);\n  if (append_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(append_image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&append_image->exception);\n      append_image=DestroyImage(append_image);\n      return((Image *) NULL);\n    }\n  if (homogeneous_colorspace == MagickFalse)\n    (void) SetImageColorspace(append_image,sRGBColorspace);\n  append_image->depth=depth;\n  append_image->matte=matte;\n  append_image->page=images->page;\n  (void) SetImageBackgroundColor(append_image);\n  status=MagickTrue;\n  x_offset=0;\n  y_offset=0;\n  next=images;\n  append_view=AcquireAuthenticCacheView(append_image,exception);\n  for (n=0; n < (MagickOffsetType) number_images; n++)\n  {\n    CacheView\n      *image_view;\n\n    MagickBooleanType\n      proceed;\n\n    SetGeometry(append_image,&geometry);\n    GravityAdjustGeometry(next->columns,next->rows,next->gravity,&geometry);\n    if (stack != MagickFalse)\n      x_offset-=geometry.x;\n    else\n      y_offset-=geometry.y;\n    image_view=AcquireVirtualCacheView(next,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n    #pragma omp parallel for schedule(static,4) shared(status) \\\n      magick_threads(next,next,next->rows,1)\n#endif\n    for (y=0; y < (ssize_t) next->rows; y++)\n    {\n      MagickBooleanType\n        sync;\n\n      register const IndexPacket\n        *magick_restrict indexes;\n\n      register const PixelPacket\n        *magick_restrict p;\n\n      register IndexPacket\n        *magick_restrict append_indexes;\n\n      register PixelPacket\n        *magick_restrict q;\n\n      register ssize_t\n        x;\n\n      if (status == MagickFalse)\n        continue;\n      p=GetCacheViewVirtualPixels(image_view,0,y,next->columns,1,exception);\n      q=QueueCacheViewAuthenticPixels(append_view,x_offset,y+y_offset,\n        next->columns,1,exception);\n      if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))\n        {\n          status=MagickFalse;\n          continue;\n        }\n      indexes=GetCacheViewVirtualIndexQueue(image_view);\n      append_indexes=GetCacheViewAuthenticIndexQueue(append_view);\n      for (x=0; x < (ssize_t) next->columns; x++)\n      {\n        SetPixelRed(q,GetPixelRed(p));\n        SetPixelGreen(q,GetPixelGreen(p));\n        SetPixelBlue(q,GetPixelBlue(p));\n        SetPixelOpacity(q,OpaqueOpacity);\n        if (next->matte != MagickFalse)\n          SetPixelOpacity(q,GetPixelOpacity(p));\n        if ((next->colorspace == CMYKColorspace) &&\n            (append_image->colorspace == CMYKColorspace))\n          SetPixelIndex(append_indexes+x,GetPixelIndex(indexes+x));\n        p++;\n        q++;\n      }\n      sync=SyncCacheViewAuthenticPixels(append_view,exception);\n      if (sync == MagickFalse)\n        status=MagickFalse;\n    }\n    image_view=DestroyCacheView(image_view);\n    if (stack == MagickFalse)\n      {\n        x_offset+=(ssize_t) next->columns;\n        y_offset=0;\n      }\n    else\n      {\n        x_offset=0;\n        y_offset+=(ssize_t) next->rows;\n      }\n    proceed=SetImageProgress(append_image,AppendImageTag,n,number_images);\n    if (proceed == MagickFalse)\n      break;\n    next=GetNextImageInList(next);\n  }\n  append_view=DestroyCacheView(append_view);\n  if (status == MagickFalse)\n    append_image=DestroyImage(append_image);\n  return(append_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C a t c h I m a g e E x c e p t i o n                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CatchImageException() returns if no exceptions are found in the image\n%  sequence, otherwise it determines the most severe exception and reports\n%  it as a warning or error depending on the severity.\n%\n%  The format of the CatchImageException method is:\n%\n%      ExceptionType CatchImageException(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: An image sequence.\n%\n*/\nMagickExport ExceptionType CatchImageException(Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  ExceptionType\n    severity;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  exception=AcquireExceptionInfo();\n  GetImageException(image,exception);\n  CatchException(exception);\n  severity=exception->severity;\n  exception=DestroyExceptionInfo(exception);\n  return(severity);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l i p I m a g e P a t h                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClipImagePath() sets the image clip mask based any clipping path information\n%  if it exists.\n%\n%  The format of the ClipImagePath method is:\n%\n%      MagickBooleanType ClipImagePath(Image *image,const char *pathname,\n%        const MagickBooleanType inside)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o pathname: name of clipping path resource. If name is preceded by #, use\n%      clipping path numbered by name.\n%\n%    o inside: if non-zero, later operations take effect inside clipping path.\n%      Otherwise later operations take effect outside clipping path.\n%\n*/\n\nMagickExport MagickBooleanType ClipImage(Image *image)\n{\n  return(ClipImagePath(image,\"#1\",MagickTrue));\n}\n\nMagickExport MagickBooleanType ClipImagePath(Image *image,const char *pathname,\n  const MagickBooleanType inside)\n{\n#define ClipImagePathTag  \"ClipPath/Image\"\n\n  char\n    *property;\n\n  const char\n    *value;\n\n  Image\n    *clip_mask;\n\n  ImageInfo\n    *image_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pathname != NULL);\n  property=AcquireString(pathname);\n  (void) FormatLocaleString(property,MaxTextExtent,\"8BIM:1999,2998:%s\",\n    pathname);\n  value=GetImageProperty(image,property);\n  property=DestroyString(property);\n  if (value == (const char *) NULL)\n    {\n      ThrowFileException(&image->exception,OptionError,\"NoClipPathDefined\",\n        image->filename);\n      return(MagickFalse);\n    }\n  image_info=AcquireImageInfo();\n  (void) CopyMagickString(image_info->filename,image->filename,MaxTextExtent);\n  (void) ConcatenateMagickString(image_info->filename,pathname,MaxTextExtent);\n  clip_mask=BlobToImage(image_info,value,strlen(value),&image->exception);\n  image_info=DestroyImageInfo(image_info);\n  if (clip_mask == (Image *) NULL)\n    return(MagickFalse);\n  if (clip_mask->storage_class == PseudoClass)\n    {\n      (void) SyncImage(clip_mask);\n      if (SetImageStorageClass(clip_mask,DirectClass) == MagickFalse)\n        return(MagickFalse);\n    }\n  if (inside == MagickFalse)\n    (void) NegateImage(clip_mask,MagickFalse);\n  (void) FormatLocaleString(clip_mask->magick_filename,MaxTextExtent,\n    \"8BIM:1999,2998:%s\\nPS\",pathname);\n  (void) SetImageClipMask(image,clip_mask);\n  clip_mask=DestroyImage(clip_mask);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImage() copies an image and returns the copy as a new image object.\n%\n%  If the specified columns and rows is 0, an exact copy of the image is\n%  returned, otherwise the pixel data is undefined and must be initialized\n%  with the QueueAuthenticPixels() and SyncAuthenticPixels() methods.  On\n%  failure, a NULL image is returned and exception describes the reason for the\n%  failure.\n%\n%  The format of the CloneImage method is:\n%\n%      Image *CloneImage(const Image *image,const size_t columns,\n%        const size_t rows,const MagickBooleanType orphan,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o columns: the number of columns in the cloned image.\n%\n%    o rows: the number of rows in the cloned image.\n%\n%    o detach:  With a value other than 0, the cloned image is detached from\n%      its parent I/O stream.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *CloneImage(const Image *image,const size_t columns,\n  const size_t rows,const MagickBooleanType detach,ExceptionInfo *exception)\n{\n  double\n    scale;\n\n  Image\n    *clone_image;\n\n  size_t\n    length;\n\n  /*\n    Clone the image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  if ((image->columns == 0) || (image->rows == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"NegativeOrZeroImageSize\",\"`%s'\",image->filename);\n      return((Image *) NULL);\n    }\n  clone_image=(Image *) AcquireMagickMemory(sizeof(*clone_image));\n  if (clone_image == (Image *) NULL)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(clone_image,0,sizeof(*clone_image));\n  clone_image->signature=MagickSignature;\n  clone_image->storage_class=image->storage_class;\n  clone_image->channels=image->channels;\n  clone_image->colorspace=image->colorspace;\n  clone_image->matte=image->matte;\n  clone_image->columns=image->columns;\n  clone_image->rows=image->rows;\n  clone_image->dither=image->dither;\n  if (image->colormap != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate and copy the image colormap.\n      */\n      clone_image->colors=image->colors;\n      length=(size_t) image->colors;\n      clone_image->colormap=(PixelPacket *) AcquireQuantumMemory(length,\n        sizeof(*clone_image->colormap));\n      if (clone_image->colormap == (PixelPacket *) NULL)\n        {\n          clone_image=DestroyImage(clone_image);\n          ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      (void) CopyMagickMemory(clone_image->colormap,image->colormap,length*\n        sizeof(*clone_image->colormap));\n    }\n  (void) CloneImageProfiles(clone_image,image);\n  (void) CloneImageProperties(clone_image,image);\n  (void) CloneImageArtifacts(clone_image,image);\n  GetTimerInfo(&clone_image->timer);\n  InitializeExceptionInfo(&clone_image->exception);\n  InheritException(&clone_image->exception,&image->exception);\n  if (image->ascii85 != (void *) NULL)\n    Ascii85Initialize(clone_image);\n  clone_image->magick_columns=image->magick_columns;\n  clone_image->magick_rows=image->magick_rows;\n  clone_image->type=image->type;\n  (void) CopyMagickString(clone_image->magick_filename,image->magick_filename,\n    MaxTextExtent);\n  (void) CopyMagickString(clone_image->magick,image->magick,MaxTextExtent);\n  (void) CopyMagickString(clone_image->filename,image->filename,MaxTextExtent);\n  clone_image->progress_monitor=image->progress_monitor;\n  clone_image->client_data=image->client_data;\n  clone_image->reference_count=1;\n  clone_image->next=image->next;\n  clone_image->previous=image->previous;\n  clone_image->list=NewImageList();\n  clone_image->clip_mask=NewImageList();\n  clone_image->mask=NewImageList();\n  if (detach == MagickFalse)\n    clone_image->blob=ReferenceBlob(image->blob);\n  else\n    {\n      clone_image->next=NewImageList();\n      clone_image->previous=NewImageList();\n      clone_image->blob=CloneBlobInfo((BlobInfo *) NULL);\n    }\n  clone_image->ping=image->ping;\n  clone_image->debug=IsEventLogging();\n  clone_image->semaphore=AllocateSemaphoreInfo();\n  if ((columns == 0) || (rows == 0))\n    {\n      if (image->montage != (char *) NULL)\n        (void) CloneString(&clone_image->montage,image->montage);\n      if (image->directory != (char *) NULL)\n        (void) CloneString(&clone_image->directory,image->directory);\n      if (image->clip_mask != (Image *) NULL)\n        clone_image->clip_mask=CloneImage(image->clip_mask,0,0,MagickTrue,\n          exception);\n      if (image->mask != (Image *) NULL)\n        clone_image->mask=CloneImage(image->mask,0,0,MagickTrue,exception);\n      clone_image->cache=ReferencePixelCache(image->cache);\n      return(clone_image);\n    }\n  if ((columns == image->columns) && (rows == image->rows))\n    {\n      if (image->clip_mask != (Image *) NULL)\n        clone_image->clip_mask=CloneImage(image->clip_mask,0,0,MagickTrue,\n          exception);\n      if (image->mask != (Image *) NULL)\n        clone_image->mask=CloneImage(image->mask,0,0,MagickTrue,exception);\n    }\n  scale=1.0;\n  if (image->columns != 0)\n    scale=(double) columns/(double) image->columns;\n  clone_image->page.width=(size_t) floor(scale*image->page.width+0.5);\n  clone_image->page.x=(ssize_t) ceil(scale*image->page.x-0.5);\n  clone_image->tile_offset.x=(ssize_t) ceil(scale*image->tile_offset.x-0.5);\n  scale=1.0;\n  if (image->rows != 0)\n    scale=(double) rows/(double) image->rows;\n  clone_image->page.height=(size_t) floor(scale*image->page.height+0.5);\n  clone_image->page.y=(ssize_t) ceil(scale*image->page.y-0.5);\n  clone_image->tile_offset.y=(ssize_t) ceil(scale*image->tile_offset.y-0.5);\n  clone_image->cache=ClonePixelCache(image->cache);\n  if (SetImageExtent(clone_image,columns,rows) == MagickFalse)\n    {\n      InheritException(exception,&clone_image->exception);\n      clone_image=DestroyImage(clone_image);\n    }\n  return(clone_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e I n f o                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageInfo() makes a copy of the given image info structure.  If\n%  NULL is specified, a new image info structure is created initialized to\n%  default values.\n%\n%  The format of the CloneImageInfo method is:\n%\n%      ImageInfo *CloneImageInfo(const ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport ImageInfo *CloneImageInfo(const ImageInfo *image_info)\n{\n  ImageInfo\n    *clone_info;\n\n  clone_info=AcquireImageInfo();\n  if (image_info == (ImageInfo *) NULL)\n    return(clone_info);\n  clone_info->compression=image_info->compression;\n  clone_info->temporary=image_info->temporary;\n  clone_info->adjoin=image_info->adjoin;\n  clone_info->antialias=image_info->antialias;\n  clone_info->scene=image_info->scene;\n  clone_info->number_scenes=image_info->number_scenes;\n  clone_info->depth=image_info->depth;\n  (void) CloneString(&clone_info->size,image_info->size);\n  (void) CloneString(&clone_info->extract,image_info->extract);\n  (void) CloneString(&clone_info->scenes,image_info->scenes);\n  (void) CloneString(&clone_info->page,image_info->page);\n  clone_info->interlace=image_info->interlace;\n  clone_info->endian=image_info->endian;\n  clone_info->units=image_info->units;\n  clone_info->quality=image_info->quality;\n  (void) CloneString(&clone_info->sampling_factor,image_info->sampling_factor);\n  (void) CloneString(&clone_info->server_name,image_info->server_name);\n  (void) CloneString(&clone_info->font,image_info->font);\n  (void) CloneString(&clone_info->texture,image_info->texture);\n  (void) CloneString(&clone_info->density,image_info->density);\n  clone_info->pointsize=image_info->pointsize;\n  clone_info->fuzz=image_info->fuzz;\n  clone_info->pen=image_info->pen;\n  clone_info->background_color=image_info->background_color;\n  clone_info->border_color=image_info->border_color;\n  clone_info->matte_color=image_info->matte_color;\n  clone_info->transparent_color=image_info->transparent_color;\n  clone_info->dither=image_info->dither;\n  clone_info->monochrome=image_info->monochrome;\n  clone_info->colors=image_info->colors;\n  clone_info->colorspace=image_info->colorspace;\n  clone_info->type=image_info->type;\n  clone_info->orientation=image_info->orientation;\n  clone_info->preview_type=image_info->preview_type;\n  clone_info->group=image_info->group;\n  clone_info->ping=image_info->ping;\n  clone_info->verbose=image_info->verbose;\n  (void) CloneString(&clone_info->view,image_info->view);\n  (void) CloneString(&clone_info->authenticate,image_info->authenticate);\n  (void) CloneImageOptions(clone_info,image_info);\n  clone_info->progress_monitor=image_info->progress_monitor;\n  clone_info->client_data=image_info->client_data;\n  clone_info->cache=image_info->cache;\n  if (image_info->cache != (void *) NULL)\n    clone_info->cache=ReferencePixelCache(image_info->cache);\n  if (image_info->profile != (void *) NULL)\n    clone_info->profile=(void *) CloneStringInfo((StringInfo *)\n      image_info->profile);\n  SetImageInfoFile(clone_info,image_info->file);\n  SetImageInfoBlob(clone_info,image_info->blob,image_info->length);\n  clone_info->stream=image_info->stream;\n  clone_info->virtual_pixel_method=image_info->virtual_pixel_method;\n  (void) CopyMagickString(clone_info->magick,image_info->magick,MaxTextExtent);\n  (void) CopyMagickString(clone_info->unique,image_info->unique,MaxTextExtent);\n  (void) CopyMagickString(clone_info->zero,image_info->zero,MaxTextExtent);\n  (void) CopyMagickString(clone_info->filename,image_info->filename,\n    MaxTextExtent);\n  clone_info->subimage=image_info->scene;  /* deprecated */\n  clone_info->subrange=image_info->number_scenes;  /* deprecated */\n  clone_info->channel=image_info->channel;\n  clone_info->debug=IsEventLogging();\n  clone_info->signature=image_info->signature;\n  return(clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o p y I m a g e P i x e l s                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CopyImagePixels() copies pixels from the source image as defined by the\n%  geometry the destination image at the specified offset.\n%\n%  The format of the CopyImagePixels method is:\n%\n%      MagickBooleanType CopyImagePixels(Image *image,const Image *source_image,\n%        const RectangleInfo *geometry,const OffsetInfo *offset,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the destination image.\n%\n%    o source_image: the source image.\n%\n%    o geometry: define the dimensions of the source pixel rectangle.\n%\n%    o offset: define the offset in the destination image.\n%\n%    o exception: return the highest severity exception.\n%\n*/\nMagickExport MagickBooleanType CopyImagePixels(Image *image,\n  const Image *source_image,const RectangleInfo *geometry,\n  const OffsetInfo *offset,ExceptionInfo *exception)\n{\n#define CopyImageTag  \"Copy/Image\"\n\n  CacheView\n    *image_view,\n    *source_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(source_image != (Image *) NULL);\n  assert(geometry != (RectangleInfo *) NULL);\n  assert(offset != (OffsetInfo *) NULL);\n  if ((offset->x < 0) || (offset->y < 0) ||\n      ((ssize_t) (offset->x+geometry->width) > (ssize_t) image->columns) ||\n      ((ssize_t) (offset->y+geometry->height) > (ssize_t) image->rows))\n    ThrowBinaryException(OptionError,\"GeometryDoesNotContainImage\",\n      image->filename);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    return(MagickFalse);\n  /*\n    Copy image pixels.\n  */\n  status=MagickTrue;\n  progress=0;\n  source_view=AcquireVirtualCacheView(source_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(source_image,image,geometry->height,1)\n#endif\n  for (y=0; y < (ssize_t) geometry->height; y++)\n  {\n    register const IndexPacket\n      *magick_restrict source_indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(source_view,geometry->x,y+geometry->y,\n      geometry->width,1,exception);\n    q=GetCacheViewAuthenticPixels(image_view,offset->x,y+offset->y,\n      geometry->width,1,exception);\n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    source_indexes=GetCacheViewVirtualIndexQueue(source_view);\n    indexes=GetCacheViewAuthenticIndexQueue(image_view);\n    for (x=0; x < (ssize_t) geometry->width; x++)\n    {\n      *q=(*p);\n      if (image->colorspace == CMYKColorspace)\n        indexes[x]=source_indexes[x];\n      p++;\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_CopyImagePixels)\n#endif\n        proceed=SetImageProgress(image,CopyImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  source_view=DestroyCacheView(source_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImage() dereferences an image, deallocating memory associated with\n%  the image if the reference count becomes zero.\n%\n%  The format of the DestroyImage method is:\n%\n%      Image *DestroyImage(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport Image *DestroyImage(Image *image)\n{\n  MagickBooleanType\n    destroy;\n\n  /*\n    Dereference image.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  destroy=MagickFalse;\n  LockSemaphoreInfo(image->semaphore);\n  image->reference_count--;\n  if (image->reference_count == 0)\n    destroy=MagickTrue;\n  UnlockSemaphoreInfo(image->semaphore);\n  if (destroy == MagickFalse)\n    return((Image *) NULL);\n  /*\n    Destroy image.\n  */\n  DestroyImagePixels(image);\n  if (image->clip_mask != (Image *) NULL)\n    image->clip_mask=DestroyImage(image->clip_mask);\n  if (image->mask != (Image *) NULL)\n    image->mask=DestroyImage(image->mask);\n  if (image->montage != (char *) NULL)\n    image->montage=DestroyString(image->montage);\n  if (image->directory != (char *) NULL)\n    image->directory=DestroyString(image->directory);\n  if (image->colormap != (PixelPacket *) NULL)\n    image->colormap=(PixelPacket *) RelinquishMagickMemory(image->colormap);\n  if (image->geometry != (char *) NULL)\n    image->geometry=DestroyString(image->geometry);\n  DestroyImageProfiles(image);\n  DestroyImageProperties(image);\n  DestroyImageArtifacts(image);\n  if (image->ascii85 != (Ascii85Info*) NULL)\n    image->ascii85=(Ascii85Info *) RelinquishMagickMemory(image->ascii85);\n  DestroyBlob(image);\n  (void) ClearExceptionInfo(&image->exception,MagickTrue);\n  if (image->semaphore != (SemaphoreInfo *) NULL)\n    DestroySemaphoreInfo(&image->semaphore);\n  image->signature=(~MagickSignature);\n  image=(Image *) RelinquishMagickMemory(image);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e I n f o                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageInfo() deallocates memory associated with an ImageInfo\n%  structure.\n%\n%  The format of the DestroyImageInfo method is:\n%\n%      ImageInfo *DestroyImageInfo(ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport ImageInfo *DestroyImageInfo(ImageInfo *image_info)\n{\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  if (image_info->size != (char *) NULL)\n    image_info->size=DestroyString(image_info->size);\n  if (image_info->extract != (char *) NULL)\n    image_info->extract=DestroyString(image_info->extract);\n  if (image_info->scenes != (char *) NULL)\n    image_info->scenes=DestroyString(image_info->scenes);\n  if (image_info->page != (char *) NULL)\n    image_info->page=DestroyString(image_info->page);\n  if (image_info->sampling_factor != (char *) NULL)\n    image_info->sampling_factor=DestroyString(\n      image_info->sampling_factor);\n  if (image_info->server_name != (char *) NULL)\n    image_info->server_name=DestroyString(\n      image_info->server_name);\n  if (image_info->font != (char *) NULL)\n    image_info->font=DestroyString(image_info->font);\n  if (image_info->texture != (char *) NULL)\n    image_info->texture=DestroyString(image_info->texture);\n  if (image_info->density != (char *) NULL)\n    image_info->density=DestroyString(image_info->density);\n  if (image_info->view != (char *) NULL)\n    image_info->view=DestroyString(image_info->view);\n  if (image_info->authenticate != (char *) NULL)\n    image_info->authenticate=DestroyString(\n      image_info->authenticate);\n  DestroyImageOptions(image_info);\n  if (image_info->cache != (void *) NULL)\n    image_info->cache=DestroyPixelCache(image_info->cache);\n  if (image_info->profile != (StringInfo *) NULL)\n    image_info->profile=(void *) DestroyStringInfo((StringInfo *)\n      image_info->profile);\n  image_info->signature=(~MagickSignature);\n  image_info=(ImageInfo *) RelinquishMagickMemory(image_info);\n  return(image_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D i s a s s o c i a t e I m a g e S t r e a m                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DisassociateImageStream() disassociates the image stream.  It checks if the\n%  blob of the specified image is referenced by other images. If the reference\n%  count is higher then 1 a new blob is assigned to the specified image.\n%\n%  The format of the DisassociateImageStream method is:\n%\n%      void DisassociateImageStream(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DisassociateImageStream(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  DisassociateBlob(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C l i p M a s k                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageClipMask() returns the clip path associated with the image.\n%\n%  The format of the GetImageClipMask method is:\n%\n%      Image *GetImageClipMask(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport Image *GetImageClipMask(const Image *image,\n  ExceptionInfo *exception)\n{\n  assert(image != (const Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  if (image->clip_mask == (Image *) NULL)\n    return((Image *) NULL);\n  return(CloneImage(image->clip_mask,0,0,MagickTrue,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e E x c e p t i o n                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageException() traverses an image sequence and returns any\n%  error more severe than noted by the exception parameter.\n%\n%  The format of the GetImageException method is:\n%\n%      void GetImageException(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: Specifies a pointer to a list of one or more images.\n%\n%    o exception: return the highest severity exception.\n%\n*/\nMagickExport void GetImageException(Image *image,ExceptionInfo *exception)\n{\n  register Image\n    *next;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    if (next->exception.severity == UndefinedException)\n      continue;\n    if (next->exception.severity > exception->severity)\n      InheritException(exception,&next->exception);\n    next->exception.severity=UndefinedException;\n  }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e I n f o                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageInfo() initializes image_info to default values.\n%\n%  The format of the GetImageInfo method is:\n%\n%      void GetImageInfo(ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport void GetImageInfo(ImageInfo *image_info)\n{\n  char\n    *synchronize;\n\n  ExceptionInfo\n    *exception;\n\n  /*\n    File and image dimension members.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image_info != (ImageInfo *) NULL);\n  (void) ResetMagickMemory(image_info,0,sizeof(*image_info));\n  image_info->adjoin=MagickTrue;\n  image_info->interlace=NoInterlace;\n  image_info->channel=DefaultChannels;\n  image_info->quality=UndefinedCompressionQuality;\n  image_info->antialias=MagickTrue;\n  image_info->dither=MagickTrue;\n  synchronize=GetEnvironmentValue(\"MAGICK_SYNCHRONIZE\");\n  if (synchronize != (const char *) NULL)\n    {\n      image_info->synchronize=IsStringTrue(synchronize);\n      synchronize=DestroyString(synchronize);\n    }\n  exception=AcquireExceptionInfo();\n  (void) QueryColorDatabase(BackgroundColor,&image_info->background_color,\n    exception);\n  (void) QueryColorDatabase(BorderColor,&image_info->border_color,exception);\n  (void) QueryColorDatabase(MatteColor,&image_info->matte_color,exception);\n  (void) QueryColorDatabase(TransparentColor,&image_info->transparent_color,\n    exception);\n  exception=DestroyExceptionInfo(exception);\n  image_info->debug=IsEventLogging();\n  image_info->signature=MagickSignature;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e I n f o F i l e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageInfoFile() returns the image info file member.\n%\n%  The format of the GetImageInfoFile method is:\n%\n%      FILE *GetImageInfoFile(const ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport FILE *GetImageInfoFile(const ImageInfo *image_info)\n{\n  return(image_info->file);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e M a s k                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageMask() returns the mask associated with the image.\n%\n%  The format of the GetImageMask method is:\n%\n%      Image *GetImageMask(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport Image *GetImageMask(const Image *image,ExceptionInfo *exception)\n{\n  assert(image != (const Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  if (image->mask == (Image *) NULL)\n    return((Image *) NULL);\n  return(CloneImage(image->mask,0,0,MagickTrue,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannels() returns the number of pixel channels associated with the\n%  specified image.\n%\n%  The format of the GetChannels method is:\n%\n%      size_t GetImageChannels(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport size_t GetImageChannels(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(image->channels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e R e f e r e n c e C o u n t                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageReferenceCount() returns the image reference count.\n%\n%  The format of the GetReferenceCount method is:\n%\n%      ssize_t GetImageReferenceCount(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport ssize_t GetImageReferenceCount(Image *image)\n{\n  ssize_t\n    reference_count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  LockSemaphoreInfo(image->semaphore);\n  reference_count=image->reference_count;\n  UnlockSemaphoreInfo(image->semaphore);\n  return(reference_count);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e V i r t u a l P i x e l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageVirtualPixelMethod() gets the \"virtual pixels\" method for the\n%  image.  A virtual pixel is any pixel access that is outside the boundaries\n%  of the image cache.\n%\n%  The format of the GetImageVirtualPixelMethod() method is:\n%\n%      VirtualPixelMethod GetImageVirtualPixelMethod(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport VirtualPixelMethod GetImageVirtualPixelMethod(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(GetPixelCacheVirtualMethod(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  I n t e r p r e t I m a g e F i l e n a m e                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InterpretImageFilename() interprets embedded characters in an image filename.\n%  The filename length is returned.\n%\n%  The format of the InterpretImageFilename method is:\n%\n%      size_t InterpretImageFilename(const ImageInfo *image_info,Image *image,\n%        const char *format,int value,char *filename)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info..\n%\n%    o image: the image.\n%\n%    o format:  A filename describing the format to use to write the numeric\n%      argument. Only the first numeric format identifier is replaced.\n%\n%    o value:  Numeric value to substitute into format filename.\n%\n%    o filename:  return the formatted filename in this character buffer.\n%\n*/\nMagickExport size_t InterpretImageFilename(const ImageInfo *image_info,\n  Image *image,const char *format,int value,char *filename)\n{\n  char\n    *q;\n\n  int\n    c;\n\n  MagickBooleanType\n    canonical;\n\n  register const char\n    *p;\n\n  size_t\n    length;\n\n  canonical=MagickFalse;\n  length=0;\n  (void) CopyMagickString(filename,format,MaxTextExtent);\n  for (p=strchr(format,'%'); p != (char *) NULL; p=strchr(p+1,'%'))\n  {\n    q=(char *) p+1;\n    if (*q == '%')\n      {\n        p=q+1;\n        continue;\n      }\n    if (*q == '0')\n      {\n        ssize_t\n          value;\n\n        value=(ssize_t) strtol(q,&q,10);\n        (void) value;\n      }\n    switch (*q)\n    {\n      case 'd':\n      case 'o':\n      case 'x':\n      {\n        q++;\n        c=(*q);\n        *q='\\0';\n        (void) FormatLocaleString(filename+(p-format),(size_t) (MaxTextExtent-\n          (p-format)),p,value);\n        *q=c;\n        (void) ConcatenateMagickString(filename,q,MaxTextExtent);\n        canonical=MagickTrue;\n        if (*(q-1) != '%')\n          break;\n        p++;\n        break;\n      }\n      case '[':\n      {\n        char\n          pattern[MaxTextExtent];\n\n        const char\n          *value;\n\n        register char\n          *r;\n\n        register ssize_t\n          i;\n\n        ssize_t\n          depth;\n\n        /*\n          Image option.\n        */\n        if (strchr(p,']') == (char *) NULL)\n          break;\n        depth=1;\n        r=q+1;\n        for (i=0; (i < (MaxTextExtent-1L)) && (*r != '\\0'); i++)\n        {\n          if (*r == '[')\n            depth++;\n          if (*r == ']')\n            depth--;\n          if (depth <= 0)\n            break;\n          pattern[i]=(*r++);\n        }\n        pattern[i]='\\0';\n        if (LocaleNCompare(pattern,\"filename:\",9) != 0)\n          break;\n        value=(const char *) NULL;\n#if 0\n        /* FUTURE: remove this code. -- Anthony  29 Arpil 2012\n           Removed as GetMagickProperty() will will never match a \"filename:\"\n           string as this is not a 'known' image property.\n        */\n        if ((image_info != (const ImageInfo *) NULL) &&\n            (image != (const Image *) NULL))\n          value=GetMagickProperty(image_info,image,pattern);\n        else\n#endif\n        if (image != (Image *) NULL)\n          value=GetImageProperty(image,pattern);\n        if ((value == (const char *) NULL) &&\n            (image != (Image *) NULL))\n          value=GetImageArtifact(image,pattern);\n        if ((value == (const char *) NULL) &&\n            (image_info != (ImageInfo *) NULL))\n          value=GetImageOption(image_info,pattern);\n        if (value == (const char *) NULL)\n          break;\n        q--;\n        c=(*q);\n        *q='\\0';\n        (void) CopyMagickString(filename+(p-format-length),value,(size_t)\n          (MaxTextExtent-(p-format-length)));\n        length+=strlen(pattern)-1;\n        *q=c;\n        (void) ConcatenateMagickString(filename,r+1,MaxTextExtent);\n        canonical=MagickTrue;\n        if (*(q-1) != '%')\n          break;\n        p++;\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  for (q=filename; *q != '\\0'; q++)\n    if ((*q == '%') && (*(q+1) == '%'))\n      {\n        (void) CopyMagickString(q,q+1,(size_t) (MaxTextExtent-(q-filename)));\n        canonical=MagickTrue;\n      }\n  if (canonical == MagickFalse)\n    (void) CopyMagickString(filename,format,MaxTextExtent);\n  return(strlen(filename));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s H i g h D y n a m i c R a n g e I m a g e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsHighDynamicRangeImage() returns MagickTrue if any pixel component is\n%  non-integer or exceeds the bounds of the quantum depth (e.g. for Q16\n%  0..65535.\n%\n%  The format of the IsHighDynamicRangeImage method is:\n%\n%      MagickBooleanType IsHighDynamicRangeImage(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType IsHighDynamicRangeImage(const Image *image,\n  ExceptionInfo *exception)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  (void) image;\n  (void) exception;\n  return(MagickFalse);\n#else\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickPixelPacket\n    zero;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=MagickTrue;\n  GetMagickPixelPacket(image,&zero);\n  image_view=AcquireVirtualCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    MagickPixelPacket\n      pixel;\n\n    register const IndexPacket\n      *indexes;\n\n    register const PixelPacket\n      *p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewVirtualIndexQueue(image_view);\n    pixel=zero;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetMagickPixelPacket(image,p,indexes+x,&pixel);\n      if ((pixel.red < 0.0) || (pixel.red > QuantumRange) ||\n          (pixel.red != (QuantumAny) pixel.red))\n        break;\n      if ((pixel.green < 0.0) || (pixel.green > QuantumRange) ||\n          (pixel.green != (QuantumAny) pixel.green))\n        break;\n      if ((pixel.blue < 0.0) || (pixel.blue > QuantumRange) ||\n          (pixel.blue != (QuantumAny) pixel.blue))\n        break;\n      if (pixel.matte != MagickFalse)\n        {\n          if ((pixel.opacity < 0.0) || (pixel.opacity > QuantumRange) ||\n              (pixel.opacity != (QuantumAny) pixel.opacity))\n            break;\n        }\n      if (pixel.colorspace == CMYKColorspace)\n        {\n          if ((pixel.index < 0.0) || (pixel.index > QuantumRange) ||\n              (pixel.index != (QuantumAny) pixel.index))\n            break;\n        }\n      p++;\n    }\n    if (x < (ssize_t) image->columns)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status != MagickFalse ? MagickFalse : MagickTrue);\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I s I m a g e O b j e c t                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsImageObject() returns MagickTrue if the image sequence contains a valid\n%  set of image objects.\n%\n%  The format of the IsImageObject method is:\n%\n%      MagickBooleanType IsImageObject(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsImageObject(const Image *image)\n{\n  register const Image\n    *p;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  for (p=image; p != (Image *) NULL; p=GetNextImageInList(p))\n    if (p->signature != MagickSignature)\n      return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I s T a i n t I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTaintImage() returns MagickTrue any pixel in the image has been altered\n%  since it was first constituted.\n%\n%  The format of the IsTaintImage method is:\n%\n%      MagickBooleanType IsTaintImage(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsTaintImage(const Image *image)\n{\n  char\n    magick[MaxTextExtent],\n    filename[MaxTextExtent];\n\n  register const Image\n    *p;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  (void) CopyMagickString(magick,image->magick,MaxTextExtent);\n  (void) CopyMagickString(filename,image->filename,MaxTextExtent);\n  for (p=image; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    if (p->taint != MagickFalse)\n      return(MagickTrue);\n    if (LocaleCompare(p->magick,magick) != 0)\n      return(MagickTrue);\n    if (LocaleCompare(p->filename,filename) != 0)\n      return(MagickTrue);\n  }\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   M o d i f y I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ModifyImage() ensures that there is only a single reference to the image\n%  to be modified, updating the provided image pointer to point to a clone of\n%  the original image if necessary.\n%\n%  The format of the ModifyImage method is:\n%\n%      MagickBooleanType ModifyImage(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ModifyImage(Image **image,\n  ExceptionInfo *exception)\n{\n  Image\n    *clone_image;\n\n  assert(image != (Image **) NULL);\n  assert(*image != (Image *) NULL);\n  assert((*image)->signature == MagickSignature);\n  if ((*image)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*image)->filename);\n  if (GetImageReferenceCount(*image) <= 1)\n    return(MagickTrue);\n  clone_image=CloneImage(*image,0,0,MagickTrue,exception);\n  LockSemaphoreInfo((*image)->semaphore);\n  (*image)->reference_count--;\n  UnlockSemaphoreInfo((*image)->semaphore);\n  *image=clone_image;\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   N e w M a g i c k I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  NewMagickImage() creates a blank image canvas of the specified size and\n%  background color.\n%\n%  The format of the NewMagickImage method is:\n%\n%      Image *NewMagickImage(const ImageInfo *image_info,const size_t width,\n%        const size_t height,const MagickPixelPacket *background)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width: the image width.\n%\n%    o height: the image height.\n%\n%    o background: the image color.\n%\n*/\nMagickExport Image *NewMagickImage(const ImageInfo *image_info,\n  const size_t width,const size_t height,const MagickPixelPacket *background)\n{\n  CacheView\n    *image_view;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image_info->signature == MagickSignature);\n  assert(background != (const MagickPixelPacket *) NULL);\n  image=AcquireImage(image_info);\n  image->columns=width;\n  image->rows=height;\n  image->colorspace=background->colorspace;\n  image->matte=background->matte;\n  image->fuzz=background->fuzz;\n  image->depth=background->depth;\n  status=MagickTrue;\n  exception=(&image->exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewAuthenticIndexQueue(image_view);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelPacket(image,background,q,indexes+x);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e f e r e n c e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReferenceImage() increments the reference count associated with an image\n%  returning a pointer to the image.\n%\n%  The format of the ReferenceImage method is:\n%\n%      Image *ReferenceImage(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport Image *ReferenceImage(Image *image)\n{\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  LockSemaphoreInfo(image->semaphore);\n  image->reference_count++;\n  UnlockSemaphoreInfo(image->semaphore);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t I m a g e P a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImagePage() resets the image page canvas and position.\n%\n%  The format of the ResetImagePage method is:\n%\n%      MagickBooleanType ResetImagePage(Image *image,const char *page)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o page: the relative page specification.\n%\n*/\nMagickExport MagickBooleanType ResetImagePage(Image *image,const char *page)\n{\n  MagickStatusType\n    flags;\n\n  RectangleInfo\n    geometry;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  flags=ParseAbsoluteGeometry(page,&geometry);\n  if ((flags & WidthValue) != 0)\n    {\n      if ((flags & HeightValue) == 0)\n        geometry.height=geometry.width;\n      image->page.width=geometry.width;\n      image->page.height=geometry.height;\n    }\n  if ((flags & AspectValue) != 0)\n    {\n      if ((flags & XValue) != 0)\n        image->page.x+=geometry.x;\n      if ((flags & YValue) != 0)\n        image->page.y+=geometry.y;\n    }\n  else\n    {\n      if ((flags & XValue) != 0)\n        {\n          image->page.x=geometry.x;\n          if ((image->page.width == 0) && (geometry.x > 0))\n            image->page.width=image->columns+geometry.x;\n        }\n      if ((flags & YValue) != 0)\n        {\n          image->page.y=geometry.y;\n          if ((image->page.height == 0) && (geometry.y > 0))\n            image->page.height=image->rows+geometry.y;\n        }\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e B a c k g r o u n d C o l o r                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageBackgroundColor() initializes the image pixels to the image\n%  background color.  The background color is defined by the background_color\n%  member of the image structure.\n%\n%  The format of the SetImage method is:\n%\n%      MagickBooleanType SetImageBackgroundColor(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType SetImageBackgroundColor(Image *image)\n{\n  CacheView\n    *image_view;\n\n  ExceptionInfo\n    *exception;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  MagickPixelPacket\n    background;\n\n  PixelPacket\n    pixel;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    return(MagickFalse);\n  if ((IsPixelGray(&image->background_color) == MagickFalse) &&\n      (IsGrayColorspace(image->colorspace) != MagickFalse))\n    (void) TransformImageColorspace(image,RGBColorspace);\n  if ((image->background_color.opacity != OpaqueOpacity) &&\n      (image->matte == MagickFalse))\n    (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n  GetMagickPixelPacket(image,&background);\n  SetMagickPixelPacket(image,&image->background_color,(const IndexPacket *)\n    NULL,&background);\n  if (image->colorspace == CMYKColorspace)\n    ConvertRGBToCMYK(&background);\n  index=0;\n  pixel.opacity=OpaqueOpacity;\n  SetPixelPacket(image,&background,&pixel,&index);\n  /*\n    Set image background color.\n  */\n  status=MagickTrue;\n  exception=(&image->exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n      *q++=pixel;\n    if (image->colorspace == CMYKColorspace)\n      {\n        register IndexPacket\n          *magick_restrict indexes;\n\n        indexes=GetCacheViewAuthenticIndexQueue(image_view);\n        for (x=0; x < (ssize_t) image->columns; x++)\n          SetPixelIndex(indexes+x,index);\n      }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e C h a n n e l s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageChannels() sets the number of pixels channels associated with the\n%  image.\n%\n%  The format of the SetImageChannels method is:\n%\n%      MagickBooleanType SetImageChannels(Image *image,const size_t channels)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channels:  The number of pixel channels.\n%\n*/\nMagickExport MagickBooleanType SetImageChannels(Image *image,\n  const size_t channels)\n{\n  image->channels=channels;\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e C o l o r                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageColor() set the entire image canvas to the specified color.\n%\n%  The format of the SetImageColor method is:\n%\n%      MagickBooleanType SetImageColor(Image *image,\n%        const MagickPixelPacket *color)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o background: the image color.\n%\n*/\nMagickExport MagickBooleanType SetImageColor(Image *image,\n  const MagickPixelPacket *color)\n{\n  CacheView\n    *image_view;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  assert(color != (const MagickPixelPacket *) NULL);\n  image->colorspace=color->colorspace;\n  image->matte=color->matte;\n  image->fuzz=color->fuzz;\n  image->depth=color->depth;\n  status=MagickTrue;\n  exception=(&image->exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewAuthenticIndexQueue(image_view);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelPacket(image,color,q,indexes+x);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e S t o r a g e C l a s s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageStorageClass() sets the image class: DirectClass for true color\n%  images or PseudoClass for colormapped images.\n%\n%  The format of the SetImageStorageClass method is:\n%\n%      MagickBooleanType SetImageStorageClass(Image *image,\n%        const ClassType storage_class)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o storage_class:  The image class.\n%\n*/\nMagickExport MagickBooleanType SetImageStorageClass(Image *image,\n  const ClassType storage_class)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  image->storage_class=storage_class;\n  return(SyncImagePixelCache(image,&image->exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e C l i p M a s k                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageClipMask() associates a clip path with the image.  The clip path\n%  must be the same dimensions as the image.  Set any pixel component of\n%  the clip path to TransparentOpacity to prevent that corresponding image\n%  pixel component from being updated when SyncAuthenticPixels() is applied.\n%\n%  The format of the SetImageClipMask method is:\n%\n%      MagickBooleanType SetImageClipMask(Image *image,const Image *clip_mask)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clip_mask: the image clip path.\n%\n*/\nMagickExport MagickBooleanType SetImageClipMask(Image *image,\n  const Image *clip_mask)\n{\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  if (clip_mask != (const Image *) NULL)\n    if ((clip_mask->columns != image->columns) ||\n        (clip_mask->rows != image->rows))\n      ThrowBinaryException(ImageError,\"ImageSizeDiffers\",image->filename);\n  if (image->clip_mask != (Image *) NULL)\n    image->clip_mask=DestroyImage(image->clip_mask);\n  image->clip_mask=NewImageList();\n  if (clip_mask == (Image *) NULL)\n    return(MagickTrue);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    return(MagickFalse);\n  image->clip_mask=CloneImage(clip_mask,0,0,MagickTrue,&image->exception);\n  if (image->clip_mask == (Image *) NULL)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e E x t e n t                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageExtent() sets the image size (i.e. columns & rows).\n%\n%  The format of the SetImageExtent method is:\n%\n%      MagickBooleanType SetImageExtent(Image *image,const size_t columns,\n%        const size_t rows)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o columns:  The image width in pixels.\n%\n%    o rows:  The image height in pixels.\n%\n*/\nMagickExport MagickBooleanType SetImageExtent(Image *image,const size_t columns,\n  const size_t rows)\n{\n  if ((columns == 0) || (rows == 0))\n    ThrowBinaryException(ImageError,\"NegativeOrZeroImageSize\",image->filename);\n  image->columns=columns;\n  image->rows=rows;\n  if (image->depth > (8*sizeof(MagickSizeType)))\n    ThrowBinaryException(ImageError,\"ImageDepthNotSupported\",image->filename);\n  return(SyncImagePixelCache(image,&image->exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S e t I m a g e I n f o                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageInfo() initializes the `magick' field of the ImageInfo structure.\n%  It is set to a type of image format based on the prefix or suffix of the\n%  filename.  For example, `ps:image' returns PS indicating a Postscript image.\n%  JPEG is returned for this filename: `image.jpg'.  The filename prefix has\n%  precendence over the suffix.  Use an optional index enclosed in brackets\n%  after a file name to specify a desired scene of a multi-resolution image\n%  format like Photo CD (e.g. img0001.pcd[4]).  A True (non-zero) return value\n%  indicates success.\n%\n%  The format of the SetImageInfo method is:\n%\n%      MagickBooleanType SetImageInfo(ImageInfo *image_info,\n%        const unsigned int frames,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o frames: the number of images you intend to write.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageInfo(ImageInfo *image_info,\n  const unsigned int frames,ExceptionInfo *exception)\n{\n  char\n    extension[MaxTextExtent],\n    filename[MaxTextExtent],\n    magic[MaxTextExtent],\n    *q,\n    subimage[MaxTextExtent];\n\n  const MagicInfo\n    *magic_info;\n\n  const MagickInfo\n    *magick_info;\n\n  ExceptionInfo\n    *sans_exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register const char\n    *p;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[2*MaxTextExtent];\n\n  /*\n    Look for 'image.format' in filename.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  *subimage='\\0';\n  GetPathComponent(image_info->filename,SubimagePath,subimage);\n  if (*subimage != '\\0')\n    {\n      /*\n        Look for scene specification (e.g. img0001.pcd[4]).\n      */\n      if (IsSceneGeometry(subimage,MagickFalse) == MagickFalse)\n        {\n          if (IsGeometry(subimage) != MagickFalse)\n            (void) CloneString(&image_info->extract,subimage);\n        }\n      else\n        {\n          size_t\n            first,\n            last;\n\n          (void) CloneString(&image_info->scenes,subimage);\n          image_info->scene=StringToUnsignedLong(image_info->scenes);\n          image_info->number_scenes=image_info->scene;\n          p=image_info->scenes;\n          for (q=(char *) image_info->scenes; *q != '\\0'; p++)\n          {\n            while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n              p++;\n            first=(size_t) strtol(p,&q,10);\n            last=first;\n            while (isspace((int) ((unsigned char) *q)) != 0)\n              q++;\n            if (*q == '-')\n              last=(size_t) strtol(q+1,&q,10);\n            if (first > last)\n              Swap(first,last);\n            if (first < image_info->scene)\n              image_info->scene=first;\n            if (last > image_info->number_scenes)\n              image_info->number_scenes=last;\n            p=q;\n          }\n          image_info->number_scenes-=image_info->scene-1;\n          image_info->subimage=image_info->scene;\n          image_info->subrange=image_info->number_scenes;\n        }\n    }\n  *extension='\\0';\n  if (*image_info->magick == '\\0')\n    GetPathComponent(image_info->filename,ExtensionPath,extension);\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n  if (*extension != '\\0')\n    if ((LocaleCompare(extension,\"gz\") == 0) ||\n        (LocaleCompare(extension,\"Z\") == 0) ||\n        (LocaleCompare(extension,\"svgz\") == 0) ||\n        (LocaleCompare(extension,\"wmz\") == 0))\n      {\n        char\n          path[MaxTextExtent];\n\n        (void) CopyMagickString(path,image_info->filename,MaxTextExtent);\n        path[strlen(path)-strlen(extension)-1]='\\0';\n        GetPathComponent(path,ExtensionPath,extension);\n      }\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n  if (*extension != '\\0')\n    if (LocaleCompare(extension,\"bz2\") == 0)\n      {\n        char\n          path[MaxTextExtent];\n\n        (void) CopyMagickString(path,image_info->filename,MaxTextExtent);\n        path[strlen(path)-strlen(extension)-1]='\\0';\n        GetPathComponent(path,ExtensionPath,extension);\n      }\n#endif\n  image_info->affirm=MagickFalse;\n  sans_exception=AcquireExceptionInfo();\n  if (*extension != '\\0')\n    {\n      MagickFormatType\n        format_type;\n\n      register ssize_t\n        i;\n\n      static const char\n        *format_type_formats[] =\n        {\n          \"AUTOTRACE\",\n          \"BROWSE\",\n          \"DCRAW\",\n          \"EDIT\",\n          \"LAUNCH\",\n          \"MPEG:DECODE\",\n          \"MPEG:ENCODE\",\n          \"PRINT\",\n          \"PS:ALPHA\",\n          \"PS:CMYK\",\n          \"PS:COLOR\",\n          \"PS:GRAY\",\n          \"PS:MONO\",\n          \"SCAN\",\n          \"SHOW\",\n          \"WIN\",\n          (char *) NULL\n        };\n\n      /*\n        User specified image format.\n      */\n      (void) CopyMagickString(magic,extension,MaxTextExtent);\n      LocaleUpper(magic);\n      /*\n        Look for explicit image formats.\n      */\n      format_type=UndefinedFormatType;\n      i=0;\n      while ((format_type == UndefinedFormatType) &&\n             (format_type_formats[i] != (char *) NULL))\n      {\n        if ((*magic == *format_type_formats[i]) &&\n            (LocaleCompare(magic,format_type_formats[i]) == 0))\n          format_type=ExplicitFormatType;\n        i++;\n      }\n      magick_info=GetMagickInfo(magic,sans_exception);\n      if ((magick_info != (const MagickInfo *) NULL) &&\n          (magick_info->format_type != UndefinedFormatType))\n        format_type=magick_info->format_type;\n      if (format_type == UndefinedFormatType)\n        (void) CopyMagickString(image_info->magick,magic,MaxTextExtent);\n      else\n        if (format_type == ExplicitFormatType)\n          {\n            image_info->affirm=MagickTrue;\n            (void) CopyMagickString(image_info->magick,magic,MaxTextExtent);\n          }\n      if (LocaleCompare(magic,\"RGB\") == 0)\n        image_info->affirm=MagickFalse;  /* maybe SGI disguised as RGB */\n    }\n  /*\n    Look for explicit 'format:image' in filename.\n  */\n  *magic='\\0';\n  GetPathComponent(image_info->filename,MagickPath,magic);\n  if (*magic == '\\0')\n    {\n      (void) CopyMagickString(magic,image_info->magick,MaxTextExtent);\n      magick_info=GetMagickInfo(magic,sans_exception);\n      GetPathComponent(image_info->filename,CanonicalPath,filename);\n      (void) CopyMagickString(image_info->filename,filename,MaxTextExtent);\n    }\n  else\n    {\n      const DelegateInfo\n        *delegate_info;\n\n      /*\n        User specified image format.\n      */\n      LocaleUpper(magic);\n      magick_info=GetMagickInfo(magic,sans_exception);\n      delegate_info=GetDelegateInfo(magic,\"*\",sans_exception);\n      if (delegate_info == (const DelegateInfo *) NULL)\n        delegate_info=GetDelegateInfo(\"*\",magic,sans_exception);\n      if (((magick_info != (const MagickInfo *) NULL) ||\n           (delegate_info != (const DelegateInfo *) NULL)) &&\n          (IsMagickConflict(magic) == MagickFalse))\n        {\n          image_info->affirm=MagickTrue;\n          (void) CopyMagickString(image_info->magick,magic,MaxTextExtent);\n          GetPathComponent(image_info->filename,CanonicalPath,filename);\n          (void) CopyMagickString(image_info->filename,filename,MaxTextExtent);\n        }\n    }\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if ((magick_info == (const MagickInfo *) NULL) ||\n      (GetMagickEndianSupport(magick_info) == MagickFalse))\n    image_info->endian=UndefinedEndian;\n  if ((image_info->adjoin != MagickFalse) && (frames > 1))\n    {\n      /*\n        Test for multiple image support (e.g. image%02d.png).\n      */\n      (void) InterpretImageFilename(image_info,(Image *) NULL,\n        image_info->filename,(int) image_info->scene,filename);\n      if ((LocaleCompare(filename,image_info->filename) != 0) &&\n          (strchr(filename,'%') == (char *) NULL))\n        image_info->adjoin=MagickFalse;\n    }\n  if ((image_info->adjoin != MagickFalse) && (frames > 0))\n    {\n      /*\n        Some image formats do not support multiple frames per file.\n      */\n      magick_info=GetMagickInfo(magic,exception);\n      if (magick_info != (const MagickInfo *) NULL)\n        if (GetMagickAdjoin(magick_info) == MagickFalse)\n          image_info->adjoin=MagickFalse;\n    }\n  if (image_info->affirm != MagickFalse)\n    return(MagickTrue);\n  if (frames == 0)\n    {\n      /*\n        Determine the image format from the first few bytes of the file.\n      */\n      image=AcquireImage(image_info);\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MaxTextExtent);\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          image=DestroyImage(image);\n          return(MagickFalse);\n        }\n      if ((IsBlobSeekable(image) == MagickFalse) ||\n          (IsBlobExempt(image) != MagickFalse))\n        {\n          /*\n            Copy standard input or pipe to temporary file.\n          */\n          *filename='\\0';\n          status=ImageToFile(image,filename,exception);\n          (void) CloseBlob(image);\n          if (status == MagickFalse)\n            {\n              image=DestroyImage(image);\n              return(MagickFalse);\n            }\n          SetImageInfoFile(image_info,(FILE *) NULL);\n          (void) CopyMagickString(image->filename,filename,MaxTextExtent);\n          status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n          if (status == MagickFalse)\n            {\n              image=DestroyImage(image);\n              return(MagickFalse);\n            }\n          (void) CopyMagickString(image_info->filename,filename,MaxTextExtent);\n          image_info->temporary=MagickTrue;\n        }\n      (void) ResetMagickMemory(magick,0,sizeof(magick));\n      count=ReadBlob(image,2*MaxTextExtent,magick);\n      (void) SeekBlob(image,-((MagickOffsetType) count),SEEK_CUR);\n      (void) CloseBlob(image);\n      image=DestroyImage(image);\n      /*\n        Check magic.xml configuration file.\n      */\n      sans_exception=AcquireExceptionInfo();\n      magic_info=GetMagicInfo(magick,(size_t) count,sans_exception);\n      if ((magic_info != (const MagicInfo *) NULL) &&\n          (GetMagicName(magic_info) != (char *) NULL))\n        {\n          (void) CopyMagickString(image_info->magick,GetMagicName(magic_info),\n            MaxTextExtent);\n          magick_info=GetMagickInfo(image_info->magick,sans_exception);\n          if ((magick_info == (const MagickInfo *) NULL) ||\n              (GetMagickEndianSupport(magick_info) == MagickFalse))\n            image_info->endian=UndefinedEndian;\n          sans_exception=DestroyExceptionInfo(sans_exception);\n          return(MagickTrue);\n        }\n      magick_info=GetMagickInfo(image_info->magick,sans_exception);\n      if ((magick_info == (const MagickInfo *) NULL) ||\n          (GetMagickEndianSupport(magick_info) == MagickFalse))\n        image_info->endian=UndefinedEndian;\n      sans_exception=DestroyExceptionInfo(sans_exception);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e I n f o B l o b                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageInfoBlob() sets the image info blob member.\n%\n%  The format of the SetImageInfoBlob method is:\n%\n%      void SetImageInfoBlob(ImageInfo *image_info,const void *blob,\n%        const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o blob: the blob.\n%\n%    o length: the blob length.\n%\n*/\nMagickExport void SetImageInfoBlob(ImageInfo *image_info,const void *blob,\n  const size_t length)\n{\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image_info->blob=(void *) blob;\n  image_info->length=length;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e I n f o F i l e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageInfoFile() sets the image info file member.\n%\n%  The format of the SetImageInfoFile method is:\n%\n%      void SetImageInfoFile(ImageInfo *image_info,FILE *file)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o file: the file.\n%\n*/\nMagickExport void SetImageInfoFile(ImageInfo *image_info,FILE *file)\n{\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image_info->file=file;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e M a s k                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageMask() associates a mask with the image.  The mask must be the same\n%  dimensions as the image.\n%\n%  The format of the SetImageMask method is:\n%\n%      MagickBooleanType SetImageMask(Image *image,const Image *mask)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o mask: the image mask.\n%\n*/\nMagickExport MagickBooleanType SetImageMask(Image *image,const Image *mask)\n{\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  if (mask != (const Image *) NULL)\n    if ((mask->columns != image->columns) || (mask->rows != image->rows))\n      ThrowBinaryException(ImageError,\"ImageSizeDiffers\",image->filename);\n  if (image->mask != (Image *) NULL)\n    image->mask=DestroyImage(image->mask);\n  image->mask=NewImageList();\n  if (mask == (Image *) NULL)\n    return(MagickTrue);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    return(MagickFalse);\n  image->mask=CloneImage(mask,0,0,MagickTrue,&image->exception);\n  if (image->mask == (Image *) NULL)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S e t I m a g e O p a c i t y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageOpacity() sets the opacity levels of the image.\n%\n%  The format of the SetImageOpacity method is:\n%\n%      MagickBooleanType SetImageOpacity(Image *image,const Quantum opacity)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o opacity: the level of transparency: 0 is fully opaque and QuantumRange is\n%      fully transparent.\n%\n*/\nMagickExport MagickBooleanType SetImageOpacity(Image *image,\n  const Quantum opacity)\n{\n  CacheView\n    *image_view;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  image->matte=MagickTrue;\n  status=MagickTrue;\n  exception=(&image->exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelOpacity(q,opacity);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e V i r t u a l P i x e l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageVirtualPixelMethod() sets the \"virtual pixels\" method for the\n%  image and returns the previous setting.  A virtual pixel is any pixel access\n%  that is outside the boundaries of the image cache.\n%\n%  The format of the SetImageVirtualPixelMethod() method is:\n%\n%      VirtualPixelMethod SetImageVirtualPixelMethod(const Image *image,\n%        const VirtualPixelMethod virtual_pixel_method)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: choose the type of virtual pixel.\n%\n*/\nMagickExport VirtualPixelMethod SetImageVirtualPixelMethod(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(SetPixelCacheVirtualMethod(image,virtual_pixel_method));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S m u s h I m a g e s                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SmushImages() takes all images from the current image pointer to the end\n%  of the image list and smushes them to each other top-to-bottom if the\n%  stack parameter is true, otherwise left-to-right.\n%\n%  The current gravity setting now effects how the image is justified in the\n%  final image.\n%\n%  The format of the SmushImages method is:\n%\n%      Image *SmushImages(const Image *images,const MagickBooleanType stack,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o images: the image sequence.\n%\n%    o stack: A value other than 0 stacks the images top-to-bottom.\n%\n%    o offset: minimum distance in pixels between images.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic ssize_t SmushXGap(const Image *smush_image,const Image *images,\n  const ssize_t offset,ExceptionInfo *exception)\n{\n  CacheView\n    *left_view,\n    *right_view;\n\n  const Image\n    *left_image,\n    *right_image;\n\n  RectangleInfo\n    left_geometry,\n    right_geometry;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    i,\n    y;\n\n  size_t\n    gap;\n\n  ssize_t\n    x;\n\n  if (images->previous == (Image *) NULL)\n    return(0);\n  right_image=images;\n  SetGeometry(smush_image,&right_geometry);\n  GravityAdjustGeometry(right_image->columns,right_image->rows,\n    right_image->gravity,&right_geometry);\n  left_image=images->previous;\n  SetGeometry(smush_image,&left_geometry);\n  GravityAdjustGeometry(left_image->columns,left_image->rows,\n    left_image->gravity,&left_geometry);\n  gap=right_image->columns;\n  left_view=AcquireVirtualCacheView(left_image,exception);\n  right_view=AcquireVirtualCacheView(right_image,exception);\n  for (y=0; y < (ssize_t) smush_image->rows; y++)\n  {\n    for (x=(ssize_t) left_image->columns-1; x > 0; x--)\n    {\n      p=GetCacheViewVirtualPixels(left_view,x,left_geometry.y+y,1,1,exception);\n      if ((p == (const PixelPacket *) NULL) ||\n          (GetPixelOpacity(p) != TransparentOpacity) ||\n          ((left_image->columns-x-1) >= gap))\n        break;\n    }\n    i=(ssize_t) left_image->columns-x-1;\n    for (x=0; x < (ssize_t) right_image->columns; x++)\n    {\n      p=GetCacheViewVirtualPixels(right_view,x,right_geometry.y+y,1,1,\n        exception);\n      if ((p == (const PixelPacket *) NULL) ||\n          (GetPixelOpacity(p) != TransparentOpacity) ||\n          ((x+i) >= (ssize_t) gap))\n        break;\n    }\n    if ((x+i) < (ssize_t) gap)\n      gap=(size_t) (x+i);\n  }\n  right_view=DestroyCacheView(right_view);\n  left_view=DestroyCacheView(left_view);\n  if (y < (ssize_t) smush_image->rows)\n    return(offset);\n  return((ssize_t) gap-offset);\n}\n\nstatic ssize_t SmushYGap(const Image *smush_image,const Image *images,\n  const ssize_t offset,ExceptionInfo *exception)\n{\n  CacheView\n    *bottom_view,\n    *top_view;\n\n  const Image\n    *bottom_image,\n    *top_image;\n\n  RectangleInfo\n    bottom_geometry,\n    top_geometry;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    gap;\n\n  ssize_t\n    y;\n\n  if (images->previous == (Image *) NULL)\n    return(0);\n  bottom_image=images;\n  SetGeometry(smush_image,&bottom_geometry);\n  GravityAdjustGeometry(bottom_image->columns,bottom_image->rows,\n    bottom_image->gravity,&bottom_geometry);\n  top_image=images->previous;\n  SetGeometry(smush_image,&top_geometry);\n  GravityAdjustGeometry(top_image->columns,top_image->rows,top_image->gravity,\n    &top_geometry);\n  gap=bottom_image->rows;\n  top_view=AcquireVirtualCacheView(top_image,exception);\n  bottom_view=AcquireVirtualCacheView(bottom_image,exception);\n  for (x=0; x < (ssize_t) smush_image->columns; x++)\n  {\n    for (y=(ssize_t) top_image->rows-1; y > 0; y--)\n    {\n      p=GetCacheViewVirtualPixels(top_view,top_geometry.x+x,y,1,1,exception);\n      if ((p == (const PixelPacket *) NULL) ||\n          (GetPixelOpacity(p) != TransparentOpacity) ||\n          ((top_image->rows-y-1) >= gap))\n        break;\n    }\n    i=(ssize_t) top_image->rows-y-1;\n    for (y=0; y < (ssize_t) bottom_image->rows; y++)\n    {\n      p=GetCacheViewVirtualPixels(bottom_view,bottom_geometry.x+x,y,1,1,\n        exception);\n      if ((p == (const PixelPacket *) NULL) ||\n          (GetPixelOpacity(p) != TransparentOpacity) ||\n          ((y+i) >= (ssize_t) gap))\n        break;\n    }\n    if ((y+i) < (ssize_t) gap)\n      gap=(size_t) (y+i);\n  }\n  bottom_view=DestroyCacheView(bottom_view);\n  top_view=DestroyCacheView(top_view);\n  if (x < (ssize_t) smush_image->columns)\n    return(offset);\n  return((ssize_t) gap-offset);\n}\n\nMagickExport Image *SmushImages(const Image *images,\n  const MagickBooleanType stack,const ssize_t offset,ExceptionInfo *exception)\n{\n#define SmushImageTag  \"Smush/Image\"\n\n  CacheView\n    *smush_view;\n\n  const Image\n    *image;\n\n  Image\n    *smush_image;\n\n  MagickBooleanType\n    matte,\n    proceed,\n    status;\n\n  MagickOffsetType\n    n;\n\n  RectangleInfo\n    geometry;\n\n  register const Image\n    *next;\n\n  size_t\n    height,\n    number_images,\n    width;\n\n  ssize_t\n    x_offset,\n    y_offset;\n\n  /*\n    Compute maximum area of smushed area.\n  */\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=images;\n  matte=image->matte;\n  number_images=1;\n  width=image->columns;\n  height=image->rows;\n  next=GetNextImageInList(image);\n  for ( ; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    if (next->matte != MagickFalse)\n      matte=MagickTrue;\n    number_images++;\n    if (stack != MagickFalse)\n      {\n        if (next->columns > width)\n          width=next->columns;\n        height+=next->rows;\n        if (next->previous != (Image *) NULL)\n          height+=offset;\n        continue;\n      }\n    width+=next->columns;\n    if (next->previous != (Image *) NULL)\n      width+=offset;\n    if (next->rows > height)\n      height=next->rows;\n  }\n  /*\n    Smush images.\n  */\n  smush_image=CloneImage(image,width,height,MagickTrue,exception);\n  if (smush_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(smush_image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&smush_image->exception);\n      smush_image=DestroyImage(smush_image);\n      return((Image *) NULL);\n    }\n  smush_image->matte=matte;\n  (void) SetImageBackgroundColor(smush_image);\n  status=MagickTrue;\n  x_offset=0;\n  y_offset=0;\n  smush_view=AcquireVirtualCacheView(smush_image,exception);\n  for (n=0; n < (MagickOffsetType) number_images; n++)\n  {\n    SetGeometry(smush_image,&geometry);\n    GravityAdjustGeometry(image->columns,image->rows,image->gravity,&geometry);\n    if (stack != MagickFalse)\n      {\n        x_offset-=geometry.x;\n        y_offset-=SmushYGap(smush_image,image,offset,exception);\n      }\n    else\n      {\n        x_offset-=SmushXGap(smush_image,image,offset,exception);\n        y_offset-=geometry.y;\n      }\n    status=CompositeImage(smush_image,OverCompositeOp,image,x_offset,y_offset);\n    proceed=SetImageProgress(image,SmushImageTag,n,number_images);\n    if (proceed == MagickFalse)\n      break;\n    if (stack == MagickFalse)\n      {\n        x_offset+=(ssize_t) image->columns;\n        y_offset=0;\n      }\n    else\n      {\n        x_offset=0;\n        y_offset+=(ssize_t) image->rows;\n      }\n    image=GetNextImageInList(image);\n  }\n  if (stack == MagickFalse)\n    smush_image->columns=(size_t) x_offset;\n  else\n    smush_image->rows=(size_t) y_offset;\n  smush_view=DestroyCacheView(smush_view);\n  if (status == MagickFalse)\n    smush_image=DestroyImage(smush_image);\n  return(smush_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S t r i p I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  StripImage() strips an image of all profiles and comments.\n%\n%  The format of the StripImage method is:\n%\n%      MagickBooleanType StripImage(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType StripImage(Image *image)\n{\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  DestroyImageProfiles(image);\n  (void) DeleteImageProperty(image,\"comment\");\n  (void) DeleteImageProperty(image,\"date:create\");\n  (void) DeleteImageProperty(image,\"date:modify\");\n  status=SetImageArtifact(image,\"png:exclude-chunk\",\n    \"bKGD,cHRM,EXIF,gAMA,iCCP,iTXt,sRGB,tEXt,zCCP,zTXt,date\");\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImage() initializes the red, green, and blue intensities of each pixel\n%  as defined by the colormap index.\n%\n%  The format of the SyncImage method is:\n%\n%      MagickBooleanType SyncImage(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\n\nstatic inline IndexPacket PushColormapIndex(Image *image,\n  const size_t index,MagickBooleanType *range_exception)\n{\n  if (index < image->colors)\n    return((IndexPacket) index);\n  *range_exception=MagickTrue;\n  return((IndexPacket) 0);\n}\n\nMagickExport MagickBooleanType SyncImage(Image *image)\n{\n  CacheView\n    *image_view;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    range_exception,\n    status,\n    taint;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  if (image->ping != MagickFalse)\n    return(MagickTrue);\n  if (image->storage_class != PseudoClass)\n    return(MagickFalse);\n  assert(image->colormap != (PixelPacket *) NULL);\n  range_exception=MagickFalse;\n  status=MagickTrue;\n  taint=image->taint;\n  exception=(&image->exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(range_exception,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    IndexPacket\n      index;\n\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewAuthenticIndexQueue(image_view);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      index=PushColormapIndex(image,(size_t) GetPixelIndex(indexes+x),\n        &range_exception);\n      if (image->matte == MagickFalse)\n        SetPixelRgb(q,image->colormap+(ssize_t) index)\n      else\n        SetPixelRGBO(q,image->colormap+(ssize_t) index);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  image->taint=taint;\n  if ((image->ping == MagickFalse) && (range_exception != MagickFalse))\n    (void) ThrowMagickException(&image->exception,GetMagickModule(),\n      CorruptImageWarning,\"InvalidColormapIndex\",\"`%s'\",image->filename);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S y n c I m a g e S e t t i n g s                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImageSettings() syncs image_info options into per-image attributes.\n%\n%  The format of the SyncImageSettings method is:\n%\n%      MagickBooleanType SyncImageSettings(const ImageInfo *image_info,\n%        Image *image)\n%      MagickBooleanType SyncImagesSettings(const ImageInfo *image_info,\n%        Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n*/\n\nMagickExport MagickBooleanType SyncImagesSettings(ImageInfo *image_info,\n  Image *images)\n{\n  Image\n    *image;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  image=images;\n  for ( ; image != (Image *) NULL; image=GetNextImageInList(image))\n    (void) SyncImageSettings(image_info,image);\n  (void) DeleteImageOption(image_info,\"page\");\n  return(MagickTrue);\n}\n\nMagickExport MagickBooleanType SyncImageSettings(const ImageInfo *image_info,\n  Image *image)\n{\n  char\n    property[MaxTextExtent];\n\n  const char\n    *option,\n    *value;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickStatusType\n    flags;\n\n  ResolutionType\n    units;\n\n  /*\n    Sync image options.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  option=GetImageOption(image_info,\"background\");\n  if (option != (const char *) NULL)\n    (void) QueryColorDatabase(option,&image->background_color,\n      &image->exception);\n  option=GetImageOption(image_info,\"bias\");\n  if (option != (const char *) NULL)\n    image->bias=StringToDoubleInterval(option,(double) QuantumRange+1.0);\n  option=GetImageOption(image_info,\"black-point-compensation\");\n  if (option != (const char *) NULL)\n    image->black_point_compensation=(MagickBooleanType) ParseCommandOption(\n      MagickBooleanOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"blue-primary\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.blue_primary.x=geometry_info.rho;\n      image->chromaticity.blue_primary.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.blue_primary.y=image->chromaticity.blue_primary.x;\n    }\n  option=GetImageOption(image_info,\"bordercolor\");\n  if (option != (const char *) NULL)\n    (void) QueryColorDatabase(option,&image->border_color,&image->exception);\n  option=GetImageOption(image_info,\"colors\");\n  if (option != (const char *) NULL)\n    image->colors=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"compose\");\n  if (option != (const char *) NULL)\n    image->compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"compress\");\n  if (option != (const char *) NULL)\n    image->compression=(CompressionType) ParseCommandOption(\n      MagickCompressOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"debug\");\n  if (option != (const char *) NULL)\n    image->debug=(MagickBooleanType) ParseCommandOption(MagickBooleanOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"density\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      /*\n        Set image density.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n    }\n  option=GetImageOption(image_info,\"depth\");\n  if (option != (const char *) NULL)\n    image->depth=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"endian\");\n  if (option != (const char *) NULL)\n    image->endian=(EndianType) ParseCommandOption(MagickEndianOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"filter\");\n  if (option != (const char *) NULL)\n    image->filter=(FilterTypes) ParseCommandOption(MagickFilterOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"fuzz\");\n  if (option != (const char *) NULL)\n    image->fuzz=StringToDoubleInterval(option,(double) QuantumRange+1.0);\n  option=GetImageOption(image_info,\"gravity\");\n  if (option != (const char *) NULL)\n    image->gravity=(GravityType) ParseCommandOption(MagickGravityOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"green-primary\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.green_primary.x=geometry_info.rho;\n      image->chromaticity.green_primary.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.green_primary.y=image->chromaticity.green_primary.x;\n    }\n  option=GetImageOption(image_info,\"intensity\");\n  if (option != (const char *) NULL)\n    image->intensity=(PixelIntensityMethod) ParseCommandOption(\n      MagickPixelIntensityOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"intent\");\n  if (option != (const char *) NULL)\n    image->rendering_intent=(RenderingIntent) ParseCommandOption(\n      MagickIntentOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"interlace\");\n  if (option != (const char *) NULL)\n    image->interlace=(InterlaceType) ParseCommandOption(MagickInterlaceOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"interpolate\");\n  if (option != (const char *) NULL)\n    image->interpolate=(InterpolatePixelMethod) ParseCommandOption(\n      MagickInterpolateOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"loop\");\n  if (option != (const char *) NULL)\n    image->iterations=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"mattecolor\");\n  if (option != (const char *) NULL)\n    (void) QueryColorDatabase(option,&image->matte_color,&image->exception);\n  option=GetImageOption(image_info,\"orient\");\n  if (option != (const char *) NULL)\n    image->orientation=(OrientationType) ParseCommandOption(\n      MagickOrientationOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"page\");\n  if (option != (const char *) NULL)\n    {\n      char\n        *geometry;\n\n      geometry=GetPageGeometry(option);\n      flags=ParseAbsoluteGeometry(geometry,&image->page);\n      geometry=DestroyString(geometry);\n    }\n  option=GetImageOption(image_info,\"quality\");\n  if (option != (const char *) NULL)\n    image->quality=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"red-primary\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.red_primary.x=geometry_info.rho;\n      image->chromaticity.red_primary.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.red_primary.y=image->chromaticity.red_primary.x;\n    }\n  if (image_info->quality != UndefinedCompressionQuality)\n    image->quality=image_info->quality;\n  option=GetImageOption(image_info,\"scene\");\n  if (option != (const char *) NULL)\n    image->scene=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"taint\");\n  if (option != (const char *) NULL)\n    image->taint=(MagickBooleanType) ParseCommandOption(MagickBooleanOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"tile-offset\");\n  if (option != (const char *) NULL)\n    {\n      char\n        *geometry;\n\n      geometry=GetPageGeometry(option);\n      flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);\n      geometry=DestroyString(geometry);\n    }\n  option=GetImageOption(image_info,\"transparent-color\");\n  if (option != (const char *) NULL)\n    (void) QueryColorDatabase(option,&image->transparent_color,\n      &image->exception);\n  option=GetImageOption(image_info,\"type\");\n  if (option != (const char *) NULL)\n    image->type=(ImageType) ParseCommandOption(MagickTypeOptions,MagickFalse,\n      option);\n  option=GetImageOption(image_info,\"units\");\n  if (option != (const char *) NULL)\n    units=(ResolutionType) ParseCommandOption(MagickResolutionOptions,\n      MagickFalse,option);\n  else\n    units = image_info->units;\n  if (units != UndefinedResolution)\n    {\n      if (image->units != units)\n        switch (image->units)\n        {\n          case PixelsPerInchResolution:\n          {\n            if (units == PixelsPerCentimeterResolution)\n              {\n                image->x_resolution/=2.54;\n                image->y_resolution/=2.54;\n              }\n            break;\n          }\n          case PixelsPerCentimeterResolution:\n          {\n            if (units == PixelsPerInchResolution)\n              {\n                image->x_resolution=(double) ((size_t) (100.0*2.54*\n                  image->x_resolution+0.5))/100.0;\n                image->y_resolution=(double) ((size_t) (100.0*2.54*\n                  image->y_resolution+0.5))/100.0;\n              }\n            break;\n          }\n          default:\n            break;\n        }\n      image->units=units;\n    }\n  option=GetImageOption(image_info,\"white-point\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.white_point.x=geometry_info.rho;\n      image->chromaticity.white_point.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.white_point.y=image->chromaticity.white_point.x;\n    }\n  ResetImageOptionIterator(image_info);\n  for (option=GetNextImageOption(image_info); option != (const char *) NULL; )\n  {\n    value=GetImageOption(image_info,option);\n    if (value != (const char *) NULL)\n      {\n        (void) FormatLocaleString(property,MaxTextExtent,\"%s\",option);\n        (void) SetImageArtifact(image,property,value);\n      }\n    option=GetNextImageOption(image_info);\n  }\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                     IIIII  M   M   AAA    GGGG  EEEEE                       %\n%                       I    MM MM  A   A  G      E                           %\n%                       I    M M M  AAAAA  G  GG  EEE                         %\n%                       I    M   M  A   A  G   G  E                           %\n%                     IIIII  M   M  A   A   GGGG  EEEEE                       %\n%                                                                             %\n%                                                                             %\n%                           MagickCore Image Methods                          %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/animate.h\"\n#include \"magick/artifact.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/cache-private.h\"\n#include \"magick/cache-view.h\"\n#include \"magick/channel.h\"\n#include \"magick/client.h\"\n#include \"magick/color.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/composite.h\"\n#include \"magick/composite-private.h\"\n#include \"magick/compress.h\"\n#include \"magick/constitute.h\"\n#include \"magick/delegate.h\"\n#include \"magick/deprecate.h\"\n#include \"magick/display.h\"\n#include \"magick/draw.h\"\n#include \"magick/enhance.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/gem.h\"\n#include \"magick/geometry.h\"\n#include \"magick/histogram.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magic.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/module.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/paint.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/pixel-private.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantize.h\"\n#include \"magick/random_.h\"\n#include \"magick/resource_.h\"\n#include \"magick/segment.h\"\n#include \"magick/semaphore.h\"\n#include \"magick/signature-private.h\"\n#include \"magick/statistic.h\"\n#include \"magick/string_.h\"\n#include \"magick/string-private.h\"\n#include \"magick/thread-private.h\"\n#include \"magick/threshold.h\"\n#include \"magick/timer.h\"\n#include \"magick/token.h\"\n#include \"magick/utility.h\"\n#include \"magick/version.h\"\n#include \"magick/xwindow-private.h\"\n\f\n/*\n  Constant declaration.\n*/\nconst char\n  BackgroundColor[] = \"#ffffff\",  /* white */\n  BorderColor[] = \"#dfdfdf\",  /* gray */\n  DefaultTileFrame[] = \"15x15+3+3\",\n  DefaultTileGeometry[] = \"120x120+4+3>\",\n  DefaultTileLabel[] = \"%f\\n%G\\n%b\",\n  ForegroundColor[] = \"#000\",  /* black */\n  LoadImageTag[] = \"Load/Image\",\n  LoadImagesTag[] = \"Load/Images\",\n  MatteColor[] = \"#bdbdbd\",  /* gray */\n  PSDensityGeometry[] = \"72.0x72.0\",\n  PSPageGeometry[] = \"612x792\",\n  SaveImageTag[] = \"Save/Image\",\n  SaveImagesTag[] = \"Save/Images\",\n  TransparentColor[] = \"#00000000\";  /* transparent black */\n\nconst double\n  DefaultResolution = 72.0;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireImage() returns a pointer to an image structure initialized to\n%  default values.\n%\n%  The format of the AcquireImage method is:\n%\n%      Image *AcquireImage(const ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Many of the image default values are set from this\n%      structure.  For example, filename, compression, depth, background color,\n%      and others.\n%\n*/\nMagickExport Image *AcquireImage(const ImageInfo *image_info)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  MagickStatusType\n    flags;\n\n  /*\n    Allocate image structure.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  image=(Image *) AcquireMagickMemory(sizeof(*image));\n  if (image == (Image *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(image,0,sizeof(*image));\n  /*\n    Initialize Image structure.\n  */\n  (void) CopyMagickString(image->magick,\"MIFF\",MaxTextExtent);\n  image->storage_class=DirectClass;\n  image->depth=MAGICKCORE_QUANTUM_DEPTH;\n  image->colorspace=sRGBColorspace;\n  image->rendering_intent=PerceptualIntent;\n  image->gamma=1.000f/2.200f;\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.red_primary.z=0.0300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.green_primary.z=0.1000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.blue_primary.y=0.0600f;\n  image->chromaticity.blue_primary.z=0.7900f;\n  image->chromaticity.white_point.x=0.3127f;\n  image->chromaticity.white_point.y=0.3290f;\n  image->chromaticity.white_point.z=0.3583f;\n  image->interlace=NoInterlace;\n  image->ticks_per_second=UndefinedTicksPerSecond;\n  image->compose=OverCompositeOp;\n  image->blur=1.0;\n  InitializeExceptionInfo(&image->exception);\n  (void) QueryColorDatabase(BackgroundColor,&image->background_color,\n    &image->exception);\n  (void) QueryColorDatabase(BorderColor,&image->border_color,&image->exception);\n  (void) QueryColorDatabase(MatteColor,&image->matte_color,&image->exception);\n  (void) QueryColorDatabase(TransparentColor,&image->transparent_color,\n    &image->exception);\n  GetTimerInfo(&image->timer);\n  image->ping=MagickFalse;\n  image->cache=AcquirePixelCache(0);\n  image->blob=CloneBlobInfo((BlobInfo *) NULL);\n  image->timestamp=time((time_t *) NULL);\n  image->debug=IsEventLogging();\n  image->reference_count=1;\n  image->semaphore=AllocateSemaphoreInfo();\n  image->signature=MagickSignature;\n  if (image_info == (ImageInfo *) NULL)\n    return(image);\n  /*\n    Transfer image info.\n  */\n  SetBlobExempt(image,image_info->file != (FILE *) NULL ? MagickTrue :\n    MagickFalse);\n  (void) CopyMagickString(image->filename,image_info->filename,MaxTextExtent);\n  (void) CopyMagickString(image->magick_filename,image_info->filename,\n    MaxTextExtent);\n  (void) CopyMagickString(image->magick,image_info->magick,MaxTextExtent);\n  if (image_info->size != (char *) NULL)\n    {\n      (void) ParseAbsoluteGeometry(image_info->size,&image->extract_info);\n      image->columns=image->extract_info.width;\n      image->rows=image->extract_info.height;\n      image->offset=image->extract_info.x;\n      image->extract_info.x=0;\n      image->extract_info.y=0;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n        {\n          image->extract_info=geometry;\n          Swap(image->columns,image->extract_info.width);\n          Swap(image->rows,image->extract_info.height);\n        }\n    }\n  image->compression=image_info->compression;\n  image->quality=image_info->quality;\n  image->endian=image_info->endian;\n  image->interlace=image_info->interlace;\n  image->units=image_info->units;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n    }\n  if (image_info->page != (char *) NULL)\n    {\n      char\n        *geometry;\n\n      image->page=image->extract_info;\n      geometry=GetPageGeometry(image_info->page);\n      (void) ParseAbsoluteGeometry(geometry,&image->page);\n      geometry=DestroyString(geometry);\n    }\n  if (image_info->depth != 0)\n    image->depth=image_info->depth;\n  image->dither=image_info->dither;\n  image->background_color=image_info->background_color;\n  image->border_color=image_info->border_color;\n  image->matte_color=image_info->matte_color;\n  image->transparent_color=image_info->transparent_color;\n  image->ping=image_info->ping;\n  image->progress_monitor=image_info->progress_monitor;\n  image->client_data=image_info->client_data;\n  if (image_info->cache != (void *) NULL)\n    ClonePixelCacheMethods(image->cache,image_info->cache);\n  (void) SyncImageSettings(image_info,image);\n  option=GetImageOption(image_info,\"delay\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & GreaterValue) != 0)\n        {\n          if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n            image->delay=(size_t) floor(geometry_info.rho+0.5);\n        }\n      else\n        if ((flags & LessValue) != 0)\n          {\n            if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n              image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          }\n        else\n          image->delay=(size_t) floor(geometry_info.rho+0.5);\n      if ((flags & SigmaValue) != 0)\n        image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n    }\n  option=GetImageOption(image_info,\"dispose\");\n  if (option != (const char *) NULL)\n    image->dispose=(DisposeType) ParseCommandOption(MagickDisposeOptions,\n      MagickFalse,option);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e I m a g e I n f o                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireImageInfo() allocates the ImageInfo structure.\n%\n%  The format of the AcquireImageInfo method is:\n%\n%      ImageInfo *AcquireImageInfo(void)\n%\n*/\nMagickExport ImageInfo *AcquireImageInfo(void)\n{\n  ImageInfo\n    *image_info;\n\n  image_info=(ImageInfo *) AcquireMagickMemory(sizeof(*image_info));\n  if (image_info == (ImageInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  GetImageInfo(image_info);\n  return(image_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e N e x t I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireNextImage() initializes the next image in a sequence to\n%  default values.  The next member of image points to the newly allocated\n%  image.  If there is a memory shortage, next is assigned NULL.\n%\n%  The format of the AcquireNextImage method is:\n%\n%      void AcquireNextImage(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Many of the image default values are set from this\n%      structure.  For example, filename, compression, depth, background color,\n%      and others.\n%\n%    o image: the image.\n%\n*/\nMagickExport void AcquireNextImage(const ImageInfo *image_info,Image *image)\n{\n  /*\n    Allocate image structure.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  image->next=AcquireImage(image_info);\n  if (GetNextImageInList(image) == (Image *) NULL)\n    return;\n  (void) CopyMagickString(GetNextImageInList(image)->filename,image->filename,\n    MaxTextExtent);\n  if (image_info != (ImageInfo *) NULL)\n    (void) CopyMagickString(GetNextImageInList(image)->filename,\n      image_info->filename,MaxTextExtent);\n  DestroyBlob(GetNextImageInList(image));\n  image->next->blob=ReferenceBlob(image->blob);\n  image->next->endian=image->endian;\n  image->next->scene=image->scene+1;\n  image->next->previous=image;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     A p p e n d I m a g e s                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AppendImages() takes all images from the current image pointer to the end\n%  of the image list and appends them to each other top-to-bottom if the\n%  stack parameter is true, otherwise left-to-right.\n%\n%  The current gravity setting now effects how the image is justified in the\n%  final image.\n%\n%  The format of the AppendImages method is:\n%\n%      Image *AppendImages(const Image *images,const MagickBooleanType stack,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o images: the image sequence.\n%\n%    o stack: A value other than 0 stacks the images top-to-bottom.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *AppendImages(const Image *images,\n  const MagickBooleanType stack,ExceptionInfo *exception)\n{\n#define AppendImageTag  \"Append/Image\"\n\n  CacheView\n    *append_view;\n\n  Image\n    *append_image;\n\n  MagickBooleanType\n    homogeneous_colorspace,\n    matte,\n    status;\n\n  MagickOffsetType\n    n;\n\n  RectangleInfo\n    geometry;\n\n  register const Image\n    *next;\n\n  size_t\n    depth,\n    height,\n    number_images,\n    width;\n\n  ssize_t\n    x_offset,\n    y,\n    y_offset;\n\n  /*\n    Compute maximum area of appended area.\n  */\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  matte=images->matte;\n  number_images=1;\n  width=images->columns;\n  height=images->rows;\n  depth=images->depth;\n  homogeneous_colorspace=MagickTrue;\n  next=GetNextImageInList(images);\n  for ( ; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    if (next->depth > depth)\n      depth=next->depth;\n    if (next->colorspace != images->colorspace)\n      homogeneous_colorspace=MagickFalse;\n    if (next->matte != MagickFalse)\n      matte=MagickTrue;\n    number_images++;\n    if (stack != MagickFalse)\n      {\n        if (next->columns > width)\n          width=next->columns;\n        height+=next->rows;\n        continue;\n      }\n    width+=next->columns;\n    if (next->rows > height)\n      height=next->rows;\n  }\n  /*\n    Append images.\n  */\n  append_image=CloneImage(images,width,height,MagickTrue,exception);\n  if (append_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(append_image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&append_image->exception);\n      append_image=DestroyImage(append_image);\n      return((Image *) NULL);\n    }\n  if (homogeneous_colorspace == MagickFalse)\n    (void) SetImageColorspace(append_image,sRGBColorspace);\n  append_image->depth=depth;\n  append_image->matte=matte;\n  append_image->page=images->page;\n  (void) SetImageBackgroundColor(append_image);\n  status=MagickTrue;\n  x_offset=0;\n  y_offset=0;\n  next=images;\n  append_view=AcquireAuthenticCacheView(append_image,exception);\n  for (n=0; n < (MagickOffsetType) number_images; n++)\n  {\n    CacheView\n      *image_view;\n\n    MagickBooleanType\n      proceed;\n\n    SetGeometry(append_image,&geometry);\n    GravityAdjustGeometry(next->columns,next->rows,next->gravity,&geometry);\n    if (stack != MagickFalse)\n      x_offset-=geometry.x;\n    else\n      y_offset-=geometry.y;\n    image_view=AcquireVirtualCacheView(next,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n    #pragma omp parallel for schedule(static,4) shared(status) \\\n      magick_threads(next,next,next->rows,1)\n#endif\n    for (y=0; y < (ssize_t) next->rows; y++)\n    {\n      MagickBooleanType\n        sync;\n\n      register const IndexPacket\n        *magick_restrict indexes;\n\n      register const PixelPacket\n        *magick_restrict p;\n\n      register IndexPacket\n        *magick_restrict append_indexes;\n\n      register PixelPacket\n        *magick_restrict q;\n\n      register ssize_t\n        x;\n\n      if (status == MagickFalse)\n        continue;\n      p=GetCacheViewVirtualPixels(image_view,0,y,next->columns,1,exception);\n      q=QueueCacheViewAuthenticPixels(append_view,x_offset,y+y_offset,\n        next->columns,1,exception);\n      if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))\n        {\n          status=MagickFalse;\n          continue;\n        }\n      indexes=GetCacheViewVirtualIndexQueue(image_view);\n      append_indexes=GetCacheViewAuthenticIndexQueue(append_view);\n      for (x=0; x < (ssize_t) next->columns; x++)\n      {\n        SetPixelRed(q,GetPixelRed(p));\n        SetPixelGreen(q,GetPixelGreen(p));\n        SetPixelBlue(q,GetPixelBlue(p));\n        SetPixelOpacity(q,OpaqueOpacity);\n        if (next->matte != MagickFalse)\n          SetPixelOpacity(q,GetPixelOpacity(p));\n        if ((next->colorspace == CMYKColorspace) &&\n            (append_image->colorspace == CMYKColorspace))\n          SetPixelIndex(append_indexes+x,GetPixelIndex(indexes+x));\n        p++;\n        q++;\n      }\n      sync=SyncCacheViewAuthenticPixels(append_view,exception);\n      if (sync == MagickFalse)\n        status=MagickFalse;\n    }\n    image_view=DestroyCacheView(image_view);\n    if (stack == MagickFalse)\n      {\n        x_offset+=(ssize_t) next->columns;\n        y_offset=0;\n      }\n    else\n      {\n        x_offset=0;\n        y_offset+=(ssize_t) next->rows;\n      }\n    proceed=SetImageProgress(append_image,AppendImageTag,n,number_images);\n    if (proceed == MagickFalse)\n      break;\n    next=GetNextImageInList(next);\n  }\n  append_view=DestroyCacheView(append_view);\n  if (status == MagickFalse)\n    append_image=DestroyImage(append_image);\n  return(append_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C a t c h I m a g e E x c e p t i o n                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CatchImageException() returns if no exceptions are found in the image\n%  sequence, otherwise it determines the most severe exception and reports\n%  it as a warning or error depending on the severity.\n%\n%  The format of the CatchImageException method is:\n%\n%      ExceptionType CatchImageException(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: An image sequence.\n%\n*/\nMagickExport ExceptionType CatchImageException(Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  ExceptionType\n    severity;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  exception=AcquireExceptionInfo();\n  GetImageException(image,exception);\n  CatchException(exception);\n  severity=exception->severity;\n  exception=DestroyExceptionInfo(exception);\n  return(severity);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l i p I m a g e P a t h                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClipImagePath() sets the image clip mask based any clipping path information\n%  if it exists.\n%\n%  The format of the ClipImagePath method is:\n%\n%      MagickBooleanType ClipImagePath(Image *image,const char *pathname,\n%        const MagickBooleanType inside)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o pathname: name of clipping path resource. If name is preceded by #, use\n%      clipping path numbered by name.\n%\n%    o inside: if non-zero, later operations take effect inside clipping path.\n%      Otherwise later operations take effect outside clipping path.\n%\n*/\n\nMagickExport MagickBooleanType ClipImage(Image *image)\n{\n  return(ClipImagePath(image,\"#1\",MagickTrue));\n}\n\nMagickExport MagickBooleanType ClipImagePath(Image *image,const char *pathname,\n  const MagickBooleanType inside)\n{\n#define ClipImagePathTag  \"ClipPath/Image\"\n\n  char\n    *property;\n\n  const char\n    *value;\n\n  Image\n    *clip_mask;\n\n  ImageInfo\n    *image_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pathname != NULL);\n  property=AcquireString(pathname);\n  (void) FormatLocaleString(property,MaxTextExtent,\"8BIM:1999,2998:%s\",\n    pathname);\n  value=GetImageProperty(image,property);\n  property=DestroyString(property);\n  if (value == (const char *) NULL)\n    {\n      ThrowFileException(&image->exception,OptionError,\"NoClipPathDefined\",\n        image->filename);\n      return(MagickFalse);\n    }\n  image_info=AcquireImageInfo();\n  (void) CopyMagickString(image_info->filename,image->filename,MaxTextExtent);\n  (void) ConcatenateMagickString(image_info->filename,pathname,MaxTextExtent);\n  clip_mask=BlobToImage(image_info,value,strlen(value),&image->exception);\n  image_info=DestroyImageInfo(image_info);\n  if (clip_mask == (Image *) NULL)\n    return(MagickFalse);\n  if (clip_mask->storage_class == PseudoClass)\n    {\n      (void) SyncImage(clip_mask);\n      if (SetImageStorageClass(clip_mask,DirectClass) == MagickFalse)\n        return(MagickFalse);\n    }\n  if (inside == MagickFalse)\n    (void) NegateImage(clip_mask,MagickFalse);\n  (void) FormatLocaleString(clip_mask->magick_filename,MaxTextExtent,\n    \"8BIM:1999,2998:%s\\nPS\",pathname);\n  (void) SetImageClipMask(image,clip_mask);\n  clip_mask=DestroyImage(clip_mask);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImage() copies an image and returns the copy as a new image object.\n%\n%  If the specified columns and rows is 0, an exact copy of the image is\n%  returned, otherwise the pixel data is undefined and must be initialized\n%  with the QueueAuthenticPixels() and SyncAuthenticPixels() methods.  On\n%  failure, a NULL image is returned and exception describes the reason for the\n%  failure.\n%\n%  The format of the CloneImage method is:\n%\n%      Image *CloneImage(const Image *image,const size_t columns,\n%        const size_t rows,const MagickBooleanType orphan,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o columns: the number of columns in the cloned image.\n%\n%    o rows: the number of rows in the cloned image.\n%\n%    o detach:  With a value other than 0, the cloned image is detached from\n%      its parent I/O stream.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *CloneImage(const Image *image,const size_t columns,\n  const size_t rows,const MagickBooleanType detach,ExceptionInfo *exception)\n{\n  double\n    scale;\n\n  Image\n    *clone_image;\n\n  size_t\n    length;\n\n  /*\n    Clone the image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  if ((image->columns == 0) || (image->rows == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"NegativeOrZeroImageSize\",\"`%s'\",image->filename);\n      return((Image *) NULL);\n    }\n  clone_image=(Image *) AcquireMagickMemory(sizeof(*clone_image));\n  if (clone_image == (Image *) NULL)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(clone_image,0,sizeof(*clone_image));\n  clone_image->signature=MagickSignature;\n  clone_image->storage_class=image->storage_class;\n  clone_image->channels=image->channels;\n  clone_image->colorspace=image->colorspace;\n  clone_image->matte=image->matte;\n  clone_image->columns=image->columns;\n  clone_image->rows=image->rows;\n  clone_image->dither=image->dither;\n  if (image->colormap != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate and copy the image colormap.\n      */\n      clone_image->colors=image->colors;\n      length=(size_t) image->colors;\n      clone_image->colormap=(PixelPacket *) AcquireQuantumMemory(length,\n        sizeof(*clone_image->colormap));\n      if (clone_image->colormap == (PixelPacket *) NULL)\n        {\n          image=(Image *) RelinquishMagickMemory(image);\n          ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      (void) CopyMagickMemory(clone_image->colormap,image->colormap,length*\n        sizeof(*clone_image->colormap));\n    }\n  (void) CloneImageProfiles(clone_image,image);\n  (void) CloneImageProperties(clone_image,image);\n  (void) CloneImageArtifacts(clone_image,image);\n  GetTimerInfo(&clone_image->timer);\n  InitializeExceptionInfo(&clone_image->exception);\n  InheritException(&clone_image->exception,&image->exception);\n  if (image->ascii85 != (void *) NULL)\n    Ascii85Initialize(clone_image);\n  clone_image->magick_columns=image->magick_columns;\n  clone_image->magick_rows=image->magick_rows;\n  clone_image->type=image->type;\n  (void) CopyMagickString(clone_image->magick_filename,image->magick_filename,\n    MaxTextExtent);\n  (void) CopyMagickString(clone_image->magick,image->magick,MaxTextExtent);\n  (void) CopyMagickString(clone_image->filename,image->filename,MaxTextExtent);\n  clone_image->progress_monitor=image->progress_monitor;\n  clone_image->client_data=image->client_data;\n  clone_image->reference_count=1;\n  clone_image->next=image->next;\n  clone_image->previous=image->previous;\n  clone_image->list=NewImageList();\n  clone_image->clip_mask=NewImageList();\n  clone_image->mask=NewImageList();\n  if (detach == MagickFalse)\n    clone_image->blob=ReferenceBlob(image->blob);\n  else\n    {\n      clone_image->next=NewImageList();\n      clone_image->previous=NewImageList();\n      clone_image->blob=CloneBlobInfo((BlobInfo *) NULL);\n    }\n  clone_image->ping=image->ping;\n  clone_image->debug=IsEventLogging();\n  clone_image->semaphore=AllocateSemaphoreInfo();\n  if ((columns == 0) || (rows == 0))\n    {\n      if (image->montage != (char *) NULL)\n        (void) CloneString(&clone_image->montage,image->montage);\n      if (image->directory != (char *) NULL)\n        (void) CloneString(&clone_image->directory,image->directory);\n      if (image->clip_mask != (Image *) NULL)\n        clone_image->clip_mask=CloneImage(image->clip_mask,0,0,MagickTrue,\n          exception);\n      if (image->mask != (Image *) NULL)\n        clone_image->mask=CloneImage(image->mask,0,0,MagickTrue,exception);\n      clone_image->cache=ReferencePixelCache(image->cache);\n      return(clone_image);\n    }\n  if ((columns == image->columns) && (rows == image->rows))\n    {\n      if (image->clip_mask != (Image *) NULL)\n        clone_image->clip_mask=CloneImage(image->clip_mask,0,0,MagickTrue,\n          exception);\n      if (image->mask != (Image *) NULL)\n        clone_image->mask=CloneImage(image->mask,0,0,MagickTrue,exception);\n    }\n  scale=1.0;\n  if (image->columns != 0)\n    scale=(double) columns/(double) image->columns;\n  clone_image->page.width=(size_t) floor(scale*image->page.width+0.5);\n  clone_image->page.x=(ssize_t) ceil(scale*image->page.x-0.5);\n  clone_image->tile_offset.x=(ssize_t) ceil(scale*image->tile_offset.x-0.5);\n  scale=1.0;\n  if (image->rows != 0)\n    scale=(double) rows/(double) image->rows;\n  clone_image->page.height=(size_t) floor(scale*image->page.height+0.5);\n  clone_image->page.y=(ssize_t) ceil(scale*image->page.y-0.5);\n  clone_image->tile_offset.y=(ssize_t) ceil(scale*image->tile_offset.y-0.5);\n  clone_image->cache=ClonePixelCache(image->cache);\n  if (SetImageExtent(clone_image,columns,rows) == MagickFalse)\n    {\n      InheritException(exception,&clone_image->exception);\n      clone_image=DestroyImage(clone_image);\n    }\n  return(clone_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e I n f o                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageInfo() makes a copy of the given image info structure.  If\n%  NULL is specified, a new image info structure is created initialized to\n%  default values.\n%\n%  The format of the CloneImageInfo method is:\n%\n%      ImageInfo *CloneImageInfo(const ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport ImageInfo *CloneImageInfo(const ImageInfo *image_info)\n{\n  ImageInfo\n    *clone_info;\n\n  clone_info=AcquireImageInfo();\n  if (image_info == (ImageInfo *) NULL)\n    return(clone_info);\n  clone_info->compression=image_info->compression;\n  clone_info->temporary=image_info->temporary;\n  clone_info->adjoin=image_info->adjoin;\n  clone_info->antialias=image_info->antialias;\n  clone_info->scene=image_info->scene;\n  clone_info->number_scenes=image_info->number_scenes;\n  clone_info->depth=image_info->depth;\n  (void) CloneString(&clone_info->size,image_info->size);\n  (void) CloneString(&clone_info->extract,image_info->extract);\n  (void) CloneString(&clone_info->scenes,image_info->scenes);\n  (void) CloneString(&clone_info->page,image_info->page);\n  clone_info->interlace=image_info->interlace;\n  clone_info->endian=image_info->endian;\n  clone_info->units=image_info->units;\n  clone_info->quality=image_info->quality;\n  (void) CloneString(&clone_info->sampling_factor,image_info->sampling_factor);\n  (void) CloneString(&clone_info->server_name,image_info->server_name);\n  (void) CloneString(&clone_info->font,image_info->font);\n  (void) CloneString(&clone_info->texture,image_info->texture);\n  (void) CloneString(&clone_info->density,image_info->density);\n  clone_info->pointsize=image_info->pointsize;\n  clone_info->fuzz=image_info->fuzz;\n  clone_info->pen=image_info->pen;\n  clone_info->background_color=image_info->background_color;\n  clone_info->border_color=image_info->border_color;\n  clone_info->matte_color=image_info->matte_color;\n  clone_info->transparent_color=image_info->transparent_color;\n  clone_info->dither=image_info->dither;\n  clone_info->monochrome=image_info->monochrome;\n  clone_info->colors=image_info->colors;\n  clone_info->colorspace=image_info->colorspace;\n  clone_info->type=image_info->type;\n  clone_info->orientation=image_info->orientation;\n  clone_info->preview_type=image_info->preview_type;\n  clone_info->group=image_info->group;\n  clone_info->ping=image_info->ping;\n  clone_info->verbose=image_info->verbose;\n  (void) CloneString(&clone_info->view,image_info->view);\n  (void) CloneString(&clone_info->authenticate,image_info->authenticate);\n  (void) CloneImageOptions(clone_info,image_info);\n  clone_info->progress_monitor=image_info->progress_monitor;\n  clone_info->client_data=image_info->client_data;\n  clone_info->cache=image_info->cache;\n  if (image_info->cache != (void *) NULL)\n    clone_info->cache=ReferencePixelCache(image_info->cache);\n  if (image_info->profile != (void *) NULL)\n    clone_info->profile=(void *) CloneStringInfo((StringInfo *)\n      image_info->profile);\n  SetImageInfoFile(clone_info,image_info->file);\n  SetImageInfoBlob(clone_info,image_info->blob,image_info->length);\n  clone_info->stream=image_info->stream;\n  clone_info->virtual_pixel_method=image_info->virtual_pixel_method;\n  (void) CopyMagickString(clone_info->magick,image_info->magick,MaxTextExtent);\n  (void) CopyMagickString(clone_info->unique,image_info->unique,MaxTextExtent);\n  (void) CopyMagickString(clone_info->zero,image_info->zero,MaxTextExtent);\n  (void) CopyMagickString(clone_info->filename,image_info->filename,\n    MaxTextExtent);\n  clone_info->subimage=image_info->scene;  /* deprecated */\n  clone_info->subrange=image_info->number_scenes;  /* deprecated */\n  clone_info->channel=image_info->channel;\n  clone_info->debug=IsEventLogging();\n  clone_info->signature=image_info->signature;\n  return(clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o p y I m a g e P i x e l s                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CopyImagePixels() copies pixels from the source image as defined by the\n%  geometry the destination image at the specified offset.\n%\n%  The format of the CopyImagePixels method is:\n%\n%      MagickBooleanType CopyImagePixels(Image *image,const Image *source_image,\n%        const RectangleInfo *geometry,const OffsetInfo *offset,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the destination image.\n%\n%    o source_image: the source image.\n%\n%    o geometry: define the dimensions of the source pixel rectangle.\n%\n%    o offset: define the offset in the destination image.\n%\n%    o exception: return the highest severity exception.\n%\n*/\nMagickExport MagickBooleanType CopyImagePixels(Image *image,\n  const Image *source_image,const RectangleInfo *geometry,\n  const OffsetInfo *offset,ExceptionInfo *exception)\n{\n#define CopyImageTag  \"Copy/Image\"\n\n  CacheView\n    *image_view,\n    *source_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(source_image != (Image *) NULL);\n  assert(geometry != (RectangleInfo *) NULL);\n  assert(offset != (OffsetInfo *) NULL);\n  if ((offset->x < 0) || (offset->y < 0) ||\n      ((ssize_t) (offset->x+geometry->width) > (ssize_t) image->columns) ||\n      ((ssize_t) (offset->y+geometry->height) > (ssize_t) image->rows))\n    ThrowBinaryException(OptionError,\"GeometryDoesNotContainImage\",\n      image->filename);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    return(MagickFalse);\n  /*\n    Copy image pixels.\n  */\n  status=MagickTrue;\n  progress=0;\n  source_view=AcquireVirtualCacheView(source_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(source_image,image,geometry->height,1)\n#endif\n  for (y=0; y < (ssize_t) geometry->height; y++)\n  {\n    register const IndexPacket\n      *magick_restrict source_indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(source_view,geometry->x,y+geometry->y,\n      geometry->width,1,exception);\n    q=GetCacheViewAuthenticPixels(image_view,offset->x,y+offset->y,\n      geometry->width,1,exception);\n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    source_indexes=GetCacheViewVirtualIndexQueue(source_view);\n    indexes=GetCacheViewAuthenticIndexQueue(image_view);\n    for (x=0; x < (ssize_t) geometry->width; x++)\n    {\n      *q=(*p);\n      if (image->colorspace == CMYKColorspace)\n        indexes[x]=source_indexes[x];\n      p++;\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_CopyImagePixels)\n#endif\n        proceed=SetImageProgress(image,CopyImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  source_view=DestroyCacheView(source_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImage() dereferences an image, deallocating memory associated with\n%  the image if the reference count becomes zero.\n%\n%  The format of the DestroyImage method is:\n%\n%      Image *DestroyImage(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport Image *DestroyImage(Image *image)\n{\n  MagickBooleanType\n    destroy;\n\n  /*\n    Dereference image.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  destroy=MagickFalse;\n  LockSemaphoreInfo(image->semaphore);\n  image->reference_count--;\n  if (image->reference_count == 0)\n    destroy=MagickTrue;\n  UnlockSemaphoreInfo(image->semaphore);\n  if (destroy == MagickFalse)\n    return((Image *) NULL);\n  /*\n    Destroy image.\n  */\n  DestroyImagePixels(image);\n  if (image->clip_mask != (Image *) NULL)\n    image->clip_mask=DestroyImage(image->clip_mask);\n  if (image->mask != (Image *) NULL)\n    image->mask=DestroyImage(image->mask);\n  if (image->montage != (char *) NULL)\n    image->montage=DestroyString(image->montage);\n  if (image->directory != (char *) NULL)\n    image->directory=DestroyString(image->directory);\n  if (image->colormap != (PixelPacket *) NULL)\n    image->colormap=(PixelPacket *) RelinquishMagickMemory(image->colormap);\n  if (image->geometry != (char *) NULL)\n    image->geometry=DestroyString(image->geometry);\n  DestroyImageProfiles(image);\n  DestroyImageProperties(image);\n  DestroyImageArtifacts(image);\n  if (image->ascii85 != (Ascii85Info*) NULL)\n    image->ascii85=(Ascii85Info *) RelinquishMagickMemory(image->ascii85);\n  DestroyBlob(image);\n  (void) ClearExceptionInfo(&image->exception,MagickTrue);\n  if (image->semaphore != (SemaphoreInfo *) NULL)\n    DestroySemaphoreInfo(&image->semaphore);\n  image->signature=(~MagickSignature);\n  image=(Image *) RelinquishMagickMemory(image);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e I n f o                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageInfo() deallocates memory associated with an ImageInfo\n%  structure.\n%\n%  The format of the DestroyImageInfo method is:\n%\n%      ImageInfo *DestroyImageInfo(ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport ImageInfo *DestroyImageInfo(ImageInfo *image_info)\n{\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  if (image_info->size != (char *) NULL)\n    image_info->size=DestroyString(image_info->size);\n  if (image_info->extract != (char *) NULL)\n    image_info->extract=DestroyString(image_info->extract);\n  if (image_info->scenes != (char *) NULL)\n    image_info->scenes=DestroyString(image_info->scenes);\n  if (image_info->page != (char *) NULL)\n    image_info->page=DestroyString(image_info->page);\n  if (image_info->sampling_factor != (char *) NULL)\n    image_info->sampling_factor=DestroyString(\n      image_info->sampling_factor);\n  if (image_info->server_name != (char *) NULL)\n    image_info->server_name=DestroyString(\n      image_info->server_name);\n  if (image_info->font != (char *) NULL)\n    image_info->font=DestroyString(image_info->font);\n  if (image_info->texture != (char *) NULL)\n    image_info->texture=DestroyString(image_info->texture);\n  if (image_info->density != (char *) NULL)\n    image_info->density=DestroyString(image_info->density);\n  if (image_info->view != (char *) NULL)\n    image_info->view=DestroyString(image_info->view);\n  if (image_info->authenticate != (char *) NULL)\n    image_info->authenticate=DestroyString(\n      image_info->authenticate);\n  DestroyImageOptions(image_info);\n  if (image_info->cache != (void *) NULL)\n    image_info->cache=DestroyPixelCache(image_info->cache);\n  if (image_info->profile != (StringInfo *) NULL)\n    image_info->profile=(void *) DestroyStringInfo((StringInfo *)\n      image_info->profile);\n  image_info->signature=(~MagickSignature);\n  image_info=(ImageInfo *) RelinquishMagickMemory(image_info);\n  return(image_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D i s a s s o c i a t e I m a g e S t r e a m                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DisassociateImageStream() disassociates the image stream.  It checks if the\n%  blob of the specified image is referenced by other images. If the reference\n%  count is higher then 1 a new blob is assigned to the specified image.\n%\n%  The format of the DisassociateImageStream method is:\n%\n%      void DisassociateImageStream(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DisassociateImageStream(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  DisassociateBlob(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C l i p M a s k                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageClipMask() returns the clip path associated with the image.\n%\n%  The format of the GetImageClipMask method is:\n%\n%      Image *GetImageClipMask(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport Image *GetImageClipMask(const Image *image,\n  ExceptionInfo *exception)\n{\n  assert(image != (const Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  if (image->clip_mask == (Image *) NULL)\n    return((Image *) NULL);\n  return(CloneImage(image->clip_mask,0,0,MagickTrue,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e E x c e p t i o n                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageException() traverses an image sequence and returns any\n%  error more severe than noted by the exception parameter.\n%\n%  The format of the GetImageException method is:\n%\n%      void GetImageException(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: Specifies a pointer to a list of one or more images.\n%\n%    o exception: return the highest severity exception.\n%\n*/\nMagickExport void GetImageException(Image *image,ExceptionInfo *exception)\n{\n  register Image\n    *next;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    if (next->exception.severity == UndefinedException)\n      continue;\n    if (next->exception.severity > exception->severity)\n      InheritException(exception,&next->exception);\n    next->exception.severity=UndefinedException;\n  }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e I n f o                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageInfo() initializes image_info to default values.\n%\n%  The format of the GetImageInfo method is:\n%\n%      void GetImageInfo(ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport void GetImageInfo(ImageInfo *image_info)\n{\n  char\n    *synchronize;\n\n  ExceptionInfo\n    *exception;\n\n  /*\n    File and image dimension members.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image_info != (ImageInfo *) NULL);\n  (void) ResetMagickMemory(image_info,0,sizeof(*image_info));\n  image_info->adjoin=MagickTrue;\n  image_info->interlace=NoInterlace;\n  image_info->channel=DefaultChannels;\n  image_info->quality=UndefinedCompressionQuality;\n  image_info->antialias=MagickTrue;\n  image_info->dither=MagickTrue;\n  synchronize=GetEnvironmentValue(\"MAGICK_SYNCHRONIZE\");\n  if (synchronize != (const char *) NULL)\n    {\n      image_info->synchronize=IsStringTrue(synchronize);\n      synchronize=DestroyString(synchronize);\n    }\n  exception=AcquireExceptionInfo();\n  (void) QueryColorDatabase(BackgroundColor,&image_info->background_color,\n    exception);\n  (void) QueryColorDatabase(BorderColor,&image_info->border_color,exception);\n  (void) QueryColorDatabase(MatteColor,&image_info->matte_color,exception);\n  (void) QueryColorDatabase(TransparentColor,&image_info->transparent_color,\n    exception);\n  exception=DestroyExceptionInfo(exception);\n  image_info->debug=IsEventLogging();\n  image_info->signature=MagickSignature;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e I n f o F i l e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageInfoFile() returns the image info file member.\n%\n%  The format of the GetImageInfoFile method is:\n%\n%      FILE *GetImageInfoFile(const ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport FILE *GetImageInfoFile(const ImageInfo *image_info)\n{\n  return(image_info->file);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e M a s k                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageMask() returns the mask associated with the image.\n%\n%  The format of the GetImageMask method is:\n%\n%      Image *GetImageMask(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport Image *GetImageMask(const Image *image,ExceptionInfo *exception)\n{\n  assert(image != (const Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  if (image->mask == (Image *) NULL)\n    return((Image *) NULL);\n  return(CloneImage(image->mask,0,0,MagickTrue,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageChannels() returns the number of pixel channels associated with the\n%  specified image.\n%\n%  The format of the GetChannels method is:\n%\n%      size_t GetImageChannels(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport size_t GetImageChannels(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(image->channels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e R e f e r e n c e C o u n t                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageReferenceCount() returns the image reference count.\n%\n%  The format of the GetReferenceCount method is:\n%\n%      ssize_t GetImageReferenceCount(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport ssize_t GetImageReferenceCount(Image *image)\n{\n  ssize_t\n    reference_count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  LockSemaphoreInfo(image->semaphore);\n  reference_count=image->reference_count;\n  UnlockSemaphoreInfo(image->semaphore);\n  return(reference_count);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e V i r t u a l P i x e l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageVirtualPixelMethod() gets the \"virtual pixels\" method for the\n%  image.  A virtual pixel is any pixel access that is outside the boundaries\n%  of the image cache.\n%\n%  The format of the GetImageVirtualPixelMethod() method is:\n%\n%      VirtualPixelMethod GetImageVirtualPixelMethod(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport VirtualPixelMethod GetImageVirtualPixelMethod(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(GetPixelCacheVirtualMethod(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  I n t e r p r e t I m a g e F i l e n a m e                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InterpretImageFilename() interprets embedded characters in an image filename.\n%  The filename length is returned.\n%\n%  The format of the InterpretImageFilename method is:\n%\n%      size_t InterpretImageFilename(const ImageInfo *image_info,Image *image,\n%        const char *format,int value,char *filename)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info..\n%\n%    o image: the image.\n%\n%    o format:  A filename describing the format to use to write the numeric\n%      argument. Only the first numeric format identifier is replaced.\n%\n%    o value:  Numeric value to substitute into format filename.\n%\n%    o filename:  return the formatted filename in this character buffer.\n%\n*/\nMagickExport size_t InterpretImageFilename(const ImageInfo *image_info,\n  Image *image,const char *format,int value,char *filename)\n{\n  char\n    *q;\n\n  int\n    c;\n\n  MagickBooleanType\n    canonical;\n\n  register const char\n    *p;\n\n  size_t\n    length;\n\n  canonical=MagickFalse;\n  length=0;\n  (void) CopyMagickString(filename,format,MaxTextExtent);\n  for (p=strchr(format,'%'); p != (char *) NULL; p=strchr(p+1,'%'))\n  {\n    q=(char *) p+1;\n    if (*q == '%')\n      {\n        p=q+1;\n        continue;\n      }\n    if (*q == '0')\n      {\n        ssize_t\n          value;\n\n        value=(ssize_t) strtol(q,&q,10);\n        (void) value;\n      }\n    switch (*q)\n    {\n      case 'd':\n      case 'o':\n      case 'x':\n      {\n        q++;\n        c=(*q);\n        *q='\\0';\n        (void) FormatLocaleString(filename+(p-format),(size_t) (MaxTextExtent-\n          (p-format)),p,value);\n        *q=c;\n        (void) ConcatenateMagickString(filename,q,MaxTextExtent);\n        canonical=MagickTrue;\n        if (*(q-1) != '%')\n          break;\n        p++;\n        break;\n      }\n      case '[':\n      {\n        char\n          pattern[MaxTextExtent];\n\n        const char\n          *value;\n\n        register char\n          *r;\n\n        register ssize_t\n          i;\n\n        ssize_t\n          depth;\n\n        /*\n          Image option.\n        */\n        if (strchr(p,']') == (char *) NULL)\n          break;\n        depth=1;\n        r=q+1;\n        for (i=0; (i < (MaxTextExtent-1L)) && (*r != '\\0'); i++)\n        {\n          if (*r == '[')\n            depth++;\n          if (*r == ']')\n            depth--;\n          if (depth <= 0)\n            break;\n          pattern[i]=(*r++);\n        }\n        pattern[i]='\\0';\n        if (LocaleNCompare(pattern,\"filename:\",9) != 0)\n          break;\n        value=(const char *) NULL;\n#if 0\n        /* FUTURE: remove this code. -- Anthony  29 Arpil 2012\n           Removed as GetMagickProperty() will will never match a \"filename:\"\n           string as this is not a 'known' image property.\n        */\n        if ((image_info != (const ImageInfo *) NULL) &&\n            (image != (const Image *) NULL))\n          value=GetMagickProperty(image_info,image,pattern);\n        else\n#endif\n        if (image != (Image *) NULL)\n          value=GetImageProperty(image,pattern);\n        if ((value == (const char *) NULL) &&\n            (image != (Image *) NULL))\n          value=GetImageArtifact(image,pattern);\n        if ((value == (const char *) NULL) &&\n            (image_info != (ImageInfo *) NULL))\n          value=GetImageOption(image_info,pattern);\n        if (value == (const char *) NULL)\n          break;\n        q--;\n        c=(*q);\n        *q='\\0';\n        (void) CopyMagickString(filename+(p-format-length),value,(size_t)\n          (MaxTextExtent-(p-format-length)));\n        length+=strlen(pattern)-1;\n        *q=c;\n        (void) ConcatenateMagickString(filename,r+1,MaxTextExtent);\n        canonical=MagickTrue;\n        if (*(q-1) != '%')\n          break;\n        p++;\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  for (q=filename; *q != '\\0'; q++)\n    if ((*q == '%') && (*(q+1) == '%'))\n      {\n        (void) CopyMagickString(q,q+1,(size_t) (MaxTextExtent-(q-filename)));\n        canonical=MagickTrue;\n      }\n  if (canonical == MagickFalse)\n    (void) CopyMagickString(filename,format,MaxTextExtent);\n  return(strlen(filename));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s H i g h D y n a m i c R a n g e I m a g e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsHighDynamicRangeImage() returns MagickTrue if any pixel component is\n%  non-integer or exceeds the bounds of the quantum depth (e.g. for Q16\n%  0..65535.\n%\n%  The format of the IsHighDynamicRangeImage method is:\n%\n%      MagickBooleanType IsHighDynamicRangeImage(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType IsHighDynamicRangeImage(const Image *image,\n  ExceptionInfo *exception)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  (void) image;\n  (void) exception;\n  return(MagickFalse);\n#else\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickPixelPacket\n    zero;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=MagickTrue;\n  GetMagickPixelPacket(image,&zero);\n  image_view=AcquireVirtualCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    MagickPixelPacket\n      pixel;\n\n    register const IndexPacket\n      *indexes;\n\n    register const PixelPacket\n      *p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewVirtualIndexQueue(image_view);\n    pixel=zero;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetMagickPixelPacket(image,p,indexes+x,&pixel);\n      if ((pixel.red < 0.0) || (pixel.red > QuantumRange) ||\n          (pixel.red != (QuantumAny) pixel.red))\n        break;\n      if ((pixel.green < 0.0) || (pixel.green > QuantumRange) ||\n          (pixel.green != (QuantumAny) pixel.green))\n        break;\n      if ((pixel.blue < 0.0) || (pixel.blue > QuantumRange) ||\n          (pixel.blue != (QuantumAny) pixel.blue))\n        break;\n      if (pixel.matte != MagickFalse)\n        {\n          if ((pixel.opacity < 0.0) || (pixel.opacity > QuantumRange) ||\n              (pixel.opacity != (QuantumAny) pixel.opacity))\n            break;\n        }\n      if (pixel.colorspace == CMYKColorspace)\n        {\n          if ((pixel.index < 0.0) || (pixel.index > QuantumRange) ||\n              (pixel.index != (QuantumAny) pixel.index))\n            break;\n        }\n      p++;\n    }\n    if (x < (ssize_t) image->columns)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status != MagickFalse ? MagickFalse : MagickTrue);\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I s I m a g e O b j e c t                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsImageObject() returns MagickTrue if the image sequence contains a valid\n%  set of image objects.\n%\n%  The format of the IsImageObject method is:\n%\n%      MagickBooleanType IsImageObject(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsImageObject(const Image *image)\n{\n  register const Image\n    *p;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  for (p=image; p != (Image *) NULL; p=GetNextImageInList(p))\n    if (p->signature != MagickSignature)\n      return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I s T a i n t I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTaintImage() returns MagickTrue any pixel in the image has been altered\n%  since it was first constituted.\n%\n%  The format of the IsTaintImage method is:\n%\n%      MagickBooleanType IsTaintImage(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsTaintImage(const Image *image)\n{\n  char\n    magick[MaxTextExtent],\n    filename[MaxTextExtent];\n\n  register const Image\n    *p;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  (void) CopyMagickString(magick,image->magick,MaxTextExtent);\n  (void) CopyMagickString(filename,image->filename,MaxTextExtent);\n  for (p=image; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    if (p->taint != MagickFalse)\n      return(MagickTrue);\n    if (LocaleCompare(p->magick,magick) != 0)\n      return(MagickTrue);\n    if (LocaleCompare(p->filename,filename) != 0)\n      return(MagickTrue);\n  }\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   M o d i f y I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ModifyImage() ensures that there is only a single reference to the image\n%  to be modified, updating the provided image pointer to point to a clone of\n%  the original image if necessary.\n%\n%  The format of the ModifyImage method is:\n%\n%      MagickBooleanType ModifyImage(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ModifyImage(Image **image,\n  ExceptionInfo *exception)\n{\n  Image\n    *clone_image;\n\n  assert(image != (Image **) NULL);\n  assert(*image != (Image *) NULL);\n  assert((*image)->signature == MagickSignature);\n  if ((*image)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*image)->filename);\n  if (GetImageReferenceCount(*image) <= 1)\n    return(MagickTrue);\n  clone_image=CloneImage(*image,0,0,MagickTrue,exception);\n  LockSemaphoreInfo((*image)->semaphore);\n  (*image)->reference_count--;\n  UnlockSemaphoreInfo((*image)->semaphore);\n  *image=clone_image;\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   N e w M a g i c k I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  NewMagickImage() creates a blank image canvas of the specified size and\n%  background color.\n%\n%  The format of the NewMagickImage method is:\n%\n%      Image *NewMagickImage(const ImageInfo *image_info,const size_t width,\n%        const size_t height,const MagickPixelPacket *background)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width: the image width.\n%\n%    o height: the image height.\n%\n%    o background: the image color.\n%\n*/\nMagickExport Image *NewMagickImage(const ImageInfo *image_info,\n  const size_t width,const size_t height,const MagickPixelPacket *background)\n{\n  CacheView\n    *image_view;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image_info->signature == MagickSignature);\n  assert(background != (const MagickPixelPacket *) NULL);\n  image=AcquireImage(image_info);\n  image->columns=width;\n  image->rows=height;\n  image->colorspace=background->colorspace;\n  image->matte=background->matte;\n  image->fuzz=background->fuzz;\n  image->depth=background->depth;\n  status=MagickTrue;\n  exception=(&image->exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewAuthenticIndexQueue(image_view);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelPacket(image,background,q,indexes+x);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e f e r e n c e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReferenceImage() increments the reference count associated with an image\n%  returning a pointer to the image.\n%\n%  The format of the ReferenceImage method is:\n%\n%      Image *ReferenceImage(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport Image *ReferenceImage(Image *image)\n{\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  LockSemaphoreInfo(image->semaphore);\n  image->reference_count++;\n  UnlockSemaphoreInfo(image->semaphore);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t I m a g e P a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImagePage() resets the image page canvas and position.\n%\n%  The format of the ResetImagePage method is:\n%\n%      MagickBooleanType ResetImagePage(Image *image,const char *page)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o page: the relative page specification.\n%\n*/\nMagickExport MagickBooleanType ResetImagePage(Image *image,const char *page)\n{\n  MagickStatusType\n    flags;\n\n  RectangleInfo\n    geometry;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  flags=ParseAbsoluteGeometry(page,&geometry);\n  if ((flags & WidthValue) != 0)\n    {\n      if ((flags & HeightValue) == 0)\n        geometry.height=geometry.width;\n      image->page.width=geometry.width;\n      image->page.height=geometry.height;\n    }\n  if ((flags & AspectValue) != 0)\n    {\n      if ((flags & XValue) != 0)\n        image->page.x+=geometry.x;\n      if ((flags & YValue) != 0)\n        image->page.y+=geometry.y;\n    }\n  else\n    {\n      if ((flags & XValue) != 0)\n        {\n          image->page.x=geometry.x;\n          if ((image->page.width == 0) && (geometry.x > 0))\n            image->page.width=image->columns+geometry.x;\n        }\n      if ((flags & YValue) != 0)\n        {\n          image->page.y=geometry.y;\n          if ((image->page.height == 0) && (geometry.y > 0))\n            image->page.height=image->rows+geometry.y;\n        }\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e B a c k g r o u n d C o l o r                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageBackgroundColor() initializes the image pixels to the image\n%  background color.  The background color is defined by the background_color\n%  member of the image structure.\n%\n%  The format of the SetImage method is:\n%\n%      MagickBooleanType SetImageBackgroundColor(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType SetImageBackgroundColor(Image *image)\n{\n  CacheView\n    *image_view;\n\n  ExceptionInfo\n    *exception;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  MagickPixelPacket\n    background;\n\n  PixelPacket\n    pixel;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    return(MagickFalse);\n  if ((IsPixelGray(&image->background_color) == MagickFalse) &&\n      (IsGrayColorspace(image->colorspace) != MagickFalse))\n    (void) TransformImageColorspace(image,RGBColorspace);\n  if ((image->background_color.opacity != OpaqueOpacity) &&\n      (image->matte == MagickFalse))\n    (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n  GetMagickPixelPacket(image,&background);\n  SetMagickPixelPacket(image,&image->background_color,(const IndexPacket *)\n    NULL,&background);\n  if (image->colorspace == CMYKColorspace)\n    ConvertRGBToCMYK(&background);\n  index=0;\n  pixel.opacity=OpaqueOpacity;\n  SetPixelPacket(image,&background,&pixel,&index);\n  /*\n    Set image background color.\n  */\n  status=MagickTrue;\n  exception=(&image->exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n      *q++=pixel;\n    if (image->colorspace == CMYKColorspace)\n      {\n        register IndexPacket\n          *magick_restrict indexes;\n\n        indexes=GetCacheViewAuthenticIndexQueue(image_view);\n        for (x=0; x < (ssize_t) image->columns; x++)\n          SetPixelIndex(indexes+x,index);\n      }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e C h a n n e l s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageChannels() sets the number of pixels channels associated with the\n%  image.\n%\n%  The format of the SetImageChannels method is:\n%\n%      MagickBooleanType SetImageChannels(Image *image,const size_t channels)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channels:  The number of pixel channels.\n%\n*/\nMagickExport MagickBooleanType SetImageChannels(Image *image,\n  const size_t channels)\n{\n  image->channels=channels;\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e C o l o r                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageColor() set the entire image canvas to the specified color.\n%\n%  The format of the SetImageColor method is:\n%\n%      MagickBooleanType SetImageColor(Image *image,\n%        const MagickPixelPacket *color)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o background: the image color.\n%\n*/\nMagickExport MagickBooleanType SetImageColor(Image *image,\n  const MagickPixelPacket *color)\n{\n  CacheView\n    *image_view;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  assert(color != (const MagickPixelPacket *) NULL);\n  image->colorspace=color->colorspace;\n  image->matte=color->matte;\n  image->fuzz=color->fuzz;\n  image->depth=color->depth;\n  status=MagickTrue;\n  exception=(&image->exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewAuthenticIndexQueue(image_view);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelPacket(image,color,q,indexes+x);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e S t o r a g e C l a s s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageStorageClass() sets the image class: DirectClass for true color\n%  images or PseudoClass for colormapped images.\n%\n%  The format of the SetImageStorageClass method is:\n%\n%      MagickBooleanType SetImageStorageClass(Image *image,\n%        const ClassType storage_class)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o storage_class:  The image class.\n%\n*/\nMagickExport MagickBooleanType SetImageStorageClass(Image *image,\n  const ClassType storage_class)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  image->storage_class=storage_class;\n  return(SyncImagePixelCache(image,&image->exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e C l i p M a s k                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageClipMask() associates a clip path with the image.  The clip path\n%  must be the same dimensions as the image.  Set any pixel component of\n%  the clip path to TransparentOpacity to prevent that corresponding image\n%  pixel component from being updated when SyncAuthenticPixels() is applied.\n%\n%  The format of the SetImageClipMask method is:\n%\n%      MagickBooleanType SetImageClipMask(Image *image,const Image *clip_mask)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clip_mask: the image clip path.\n%\n*/\nMagickExport MagickBooleanType SetImageClipMask(Image *image,\n  const Image *clip_mask)\n{\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  if (clip_mask != (const Image *) NULL)\n    if ((clip_mask->columns != image->columns) ||\n        (clip_mask->rows != image->rows))\n      ThrowBinaryException(ImageError,\"ImageSizeDiffers\",image->filename);\n  if (image->clip_mask != (Image *) NULL)\n    image->clip_mask=DestroyImage(image->clip_mask);\n  image->clip_mask=NewImageList();\n  if (clip_mask == (Image *) NULL)\n    return(MagickTrue);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    return(MagickFalse);\n  image->clip_mask=CloneImage(clip_mask,0,0,MagickTrue,&image->exception);\n  if (image->clip_mask == (Image *) NULL)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e E x t e n t                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageExtent() sets the image size (i.e. columns & rows).\n%\n%  The format of the SetImageExtent method is:\n%\n%      MagickBooleanType SetImageExtent(Image *image,const size_t columns,\n%        const size_t rows)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o columns:  The image width in pixels.\n%\n%    o rows:  The image height in pixels.\n%\n*/\nMagickExport MagickBooleanType SetImageExtent(Image *image,const size_t columns,\n  const size_t rows)\n{\n  if ((columns == 0) || (rows == 0))\n    ThrowBinaryException(ImageError,\"NegativeOrZeroImageSize\",image->filename);\n  image->columns=columns;\n  image->rows=rows;\n  if (image->depth > (8*sizeof(MagickSizeType)))\n    ThrowBinaryException(ImageError,\"ImageDepthNotSupported\",image->filename);\n  return(SyncImagePixelCache(image,&image->exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S e t I m a g e I n f o                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageInfo() initializes the `magick' field of the ImageInfo structure.\n%  It is set to a type of image format based on the prefix or suffix of the\n%  filename.  For example, `ps:image' returns PS indicating a Postscript image.\n%  JPEG is returned for this filename: `image.jpg'.  The filename prefix has\n%  precendence over the suffix.  Use an optional index enclosed in brackets\n%  after a file name to specify a desired scene of a multi-resolution image\n%  format like Photo CD (e.g. img0001.pcd[4]).  A True (non-zero) return value\n%  indicates success.\n%\n%  The format of the SetImageInfo method is:\n%\n%      MagickBooleanType SetImageInfo(ImageInfo *image_info,\n%        const unsigned int frames,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o frames: the number of images you intend to write.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageInfo(ImageInfo *image_info,\n  const unsigned int frames,ExceptionInfo *exception)\n{\n  char\n    extension[MaxTextExtent],\n    filename[MaxTextExtent],\n    magic[MaxTextExtent],\n    *q,\n    subimage[MaxTextExtent];\n\n  const MagicInfo\n    *magic_info;\n\n  const MagickInfo\n    *magick_info;\n\n  ExceptionInfo\n    *sans_exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register const char\n    *p;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[2*MaxTextExtent];\n\n  /*\n    Look for 'image.format' in filename.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  *subimage='\\0';\n  GetPathComponent(image_info->filename,SubimagePath,subimage);\n  if (*subimage != '\\0')\n    {\n      /*\n        Look for scene specification (e.g. img0001.pcd[4]).\n      */\n      if (IsSceneGeometry(subimage,MagickFalse) == MagickFalse)\n        {\n          if (IsGeometry(subimage) != MagickFalse)\n            (void) CloneString(&image_info->extract,subimage);\n        }\n      else\n        {\n          size_t\n            first,\n            last;\n\n          (void) CloneString(&image_info->scenes,subimage);\n          image_info->scene=StringToUnsignedLong(image_info->scenes);\n          image_info->number_scenes=image_info->scene;\n          p=image_info->scenes;\n          for (q=(char *) image_info->scenes; *q != '\\0'; p++)\n          {\n            while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n              p++;\n            first=(size_t) strtol(p,&q,10);\n            last=first;\n            while (isspace((int) ((unsigned char) *q)) != 0)\n              q++;\n            if (*q == '-')\n              last=(size_t) strtol(q+1,&q,10);\n            if (first > last)\n              Swap(first,last);\n            if (first < image_info->scene)\n              image_info->scene=first;\n            if (last > image_info->number_scenes)\n              image_info->number_scenes=last;\n            p=q;\n          }\n          image_info->number_scenes-=image_info->scene-1;\n          image_info->subimage=image_info->scene;\n          image_info->subrange=image_info->number_scenes;\n        }\n    }\n  *extension='\\0';\n  if (*image_info->magick == '\\0')\n    GetPathComponent(image_info->filename,ExtensionPath,extension);\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n  if (*extension != '\\0')\n    if ((LocaleCompare(extension,\"gz\") == 0) ||\n        (LocaleCompare(extension,\"Z\") == 0) ||\n        (LocaleCompare(extension,\"svgz\") == 0) ||\n        (LocaleCompare(extension,\"wmz\") == 0))\n      {\n        char\n          path[MaxTextExtent];\n\n        (void) CopyMagickString(path,image_info->filename,MaxTextExtent);\n        path[strlen(path)-strlen(extension)-1]='\\0';\n        GetPathComponent(path,ExtensionPath,extension);\n      }\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n  if (*extension != '\\0')\n    if (LocaleCompare(extension,\"bz2\") == 0)\n      {\n        char\n          path[MaxTextExtent];\n\n        (void) CopyMagickString(path,image_info->filename,MaxTextExtent);\n        path[strlen(path)-strlen(extension)-1]='\\0';\n        GetPathComponent(path,ExtensionPath,extension);\n      }\n#endif\n  image_info->affirm=MagickFalse;\n  sans_exception=AcquireExceptionInfo();\n  if (*extension != '\\0')\n    {\n      MagickFormatType\n        format_type;\n\n      register ssize_t\n        i;\n\n      static const char\n        *format_type_formats[] =\n        {\n          \"AUTOTRACE\",\n          \"BROWSE\",\n          \"DCRAW\",\n          \"EDIT\",\n          \"LAUNCH\",\n          \"MPEG:DECODE\",\n          \"MPEG:ENCODE\",\n          \"PRINT\",\n          \"PS:ALPHA\",\n          \"PS:CMYK\",\n          \"PS:COLOR\",\n          \"PS:GRAY\",\n          \"PS:MONO\",\n          \"SCAN\",\n          \"SHOW\",\n          \"WIN\",\n          (char *) NULL\n        };\n\n      /*\n        User specified image format.\n      */\n      (void) CopyMagickString(magic,extension,MaxTextExtent);\n      LocaleUpper(magic);\n      /*\n        Look for explicit image formats.\n      */\n      format_type=UndefinedFormatType;\n      i=0;\n      while ((format_type == UndefinedFormatType) &&\n             (format_type_formats[i] != (char *) NULL))\n      {\n        if ((*magic == *format_type_formats[i]) &&\n            (LocaleCompare(magic,format_type_formats[i]) == 0))\n          format_type=ExplicitFormatType;\n        i++;\n      }\n      magick_info=GetMagickInfo(magic,sans_exception);\n      if ((magick_info != (const MagickInfo *) NULL) &&\n          (magick_info->format_type != UndefinedFormatType))\n        format_type=magick_info->format_type;\n      if (format_type == UndefinedFormatType)\n        (void) CopyMagickString(image_info->magick,magic,MaxTextExtent);\n      else\n        if (format_type == ExplicitFormatType)\n          {\n            image_info->affirm=MagickTrue;\n            (void) CopyMagickString(image_info->magick,magic,MaxTextExtent);\n          }\n      if (LocaleCompare(magic,\"RGB\") == 0)\n        image_info->affirm=MagickFalse;  /* maybe SGI disguised as RGB */\n    }\n  /*\n    Look for explicit 'format:image' in filename.\n  */\n  *magic='\\0';\n  GetPathComponent(image_info->filename,MagickPath,magic);\n  if (*magic == '\\0')\n    {\n      (void) CopyMagickString(magic,image_info->magick,MaxTextExtent);\n      magick_info=GetMagickInfo(magic,sans_exception);\n      GetPathComponent(image_info->filename,CanonicalPath,filename);\n      (void) CopyMagickString(image_info->filename,filename,MaxTextExtent);\n    }\n  else\n    {\n      const DelegateInfo\n        *delegate_info;\n\n      /*\n        User specified image format.\n      */\n      LocaleUpper(magic);\n      magick_info=GetMagickInfo(magic,sans_exception);\n      delegate_info=GetDelegateInfo(magic,\"*\",sans_exception);\n      if (delegate_info == (const DelegateInfo *) NULL)\n        delegate_info=GetDelegateInfo(\"*\",magic,sans_exception);\n      if (((magick_info != (const MagickInfo *) NULL) ||\n           (delegate_info != (const DelegateInfo *) NULL)) &&\n          (IsMagickConflict(magic) == MagickFalse))\n        {\n          image_info->affirm=MagickTrue;\n          (void) CopyMagickString(image_info->magick,magic,MaxTextExtent);\n          GetPathComponent(image_info->filename,CanonicalPath,filename);\n          (void) CopyMagickString(image_info->filename,filename,MaxTextExtent);\n        }\n    }\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if ((magick_info == (const MagickInfo *) NULL) ||\n      (GetMagickEndianSupport(magick_info) == MagickFalse))\n    image_info->endian=UndefinedEndian;\n  if ((image_info->adjoin != MagickFalse) && (frames > 1))\n    {\n      /*\n        Test for multiple image support (e.g. image%02d.png).\n      */\n      (void) InterpretImageFilename(image_info,(Image *) NULL,\n        image_info->filename,(int) image_info->scene,filename);\n      if ((LocaleCompare(filename,image_info->filename) != 0) &&\n          (strchr(filename,'%') == (char *) NULL))\n        image_info->adjoin=MagickFalse;\n    }\n  if ((image_info->adjoin != MagickFalse) && (frames > 0))\n    {\n      /*\n        Some image formats do not support multiple frames per file.\n      */\n      magick_info=GetMagickInfo(magic,exception);\n      if (magick_info != (const MagickInfo *) NULL)\n        if (GetMagickAdjoin(magick_info) == MagickFalse)\n          image_info->adjoin=MagickFalse;\n    }\n  if (image_info->affirm != MagickFalse)\n    return(MagickTrue);\n  if (frames == 0)\n    {\n      /*\n        Determine the image format from the first few bytes of the file.\n      */\n      image=AcquireImage(image_info);\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MaxTextExtent);\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          image=DestroyImage(image);\n          return(MagickFalse);\n        }\n      if ((IsBlobSeekable(image) == MagickFalse) ||\n          (IsBlobExempt(image) != MagickFalse))\n        {\n          /*\n            Copy standard input or pipe to temporary file.\n          */\n          *filename='\\0';\n          status=ImageToFile(image,filename,exception);\n          (void) CloseBlob(image);\n          if (status == MagickFalse)\n            {\n              image=DestroyImage(image);\n              return(MagickFalse);\n            }\n          SetImageInfoFile(image_info,(FILE *) NULL);\n          (void) CopyMagickString(image->filename,filename,MaxTextExtent);\n          status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n          if (status == MagickFalse)\n            {\n              image=DestroyImage(image);\n              return(MagickFalse);\n            }\n          (void) CopyMagickString(image_info->filename,filename,MaxTextExtent);\n          image_info->temporary=MagickTrue;\n        }\n      (void) ResetMagickMemory(magick,0,sizeof(magick));\n      count=ReadBlob(image,2*MaxTextExtent,magick);\n      (void) SeekBlob(image,-((MagickOffsetType) count),SEEK_CUR);\n      (void) CloseBlob(image);\n      image=DestroyImage(image);\n      /*\n        Check magic.xml configuration file.\n      */\n      sans_exception=AcquireExceptionInfo();\n      magic_info=GetMagicInfo(magick,(size_t) count,sans_exception);\n      if ((magic_info != (const MagicInfo *) NULL) &&\n          (GetMagicName(magic_info) != (char *) NULL))\n        {\n          (void) CopyMagickString(image_info->magick,GetMagicName(magic_info),\n            MaxTextExtent);\n          magick_info=GetMagickInfo(image_info->magick,sans_exception);\n          if ((magick_info == (const MagickInfo *) NULL) ||\n              (GetMagickEndianSupport(magick_info) == MagickFalse))\n            image_info->endian=UndefinedEndian;\n          sans_exception=DestroyExceptionInfo(sans_exception);\n          return(MagickTrue);\n        }\n      magick_info=GetMagickInfo(image_info->magick,sans_exception);\n      if ((magick_info == (const MagickInfo *) NULL) ||\n          (GetMagickEndianSupport(magick_info) == MagickFalse))\n        image_info->endian=UndefinedEndian;\n      sans_exception=DestroyExceptionInfo(sans_exception);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e I n f o B l o b                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageInfoBlob() sets the image info blob member.\n%\n%  The format of the SetImageInfoBlob method is:\n%\n%      void SetImageInfoBlob(ImageInfo *image_info,const void *blob,\n%        const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o blob: the blob.\n%\n%    o length: the blob length.\n%\n*/\nMagickExport void SetImageInfoBlob(ImageInfo *image_info,const void *blob,\n  const size_t length)\n{\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image_info->blob=(void *) blob;\n  image_info->length=length;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e I n f o F i l e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageInfoFile() sets the image info file member.\n%\n%  The format of the SetImageInfoFile method is:\n%\n%      void SetImageInfoFile(ImageInfo *image_info,FILE *file)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o file: the file.\n%\n*/\nMagickExport void SetImageInfoFile(ImageInfo *image_info,FILE *file)\n{\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image_info->file=file;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e M a s k                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageMask() associates a mask with the image.  The mask must be the same\n%  dimensions as the image.\n%\n%  The format of the SetImageMask method is:\n%\n%      MagickBooleanType SetImageMask(Image *image,const Image *mask)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o mask: the image mask.\n%\n*/\nMagickExport MagickBooleanType SetImageMask(Image *image,const Image *mask)\n{\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  if (mask != (const Image *) NULL)\n    if ((mask->columns != image->columns) || (mask->rows != image->rows))\n      ThrowBinaryException(ImageError,\"ImageSizeDiffers\",image->filename);\n  if (image->mask != (Image *) NULL)\n    image->mask=DestroyImage(image->mask);\n  image->mask=NewImageList();\n  if (mask == (Image *) NULL)\n    return(MagickTrue);\n  if (SetImageStorageClass(image,DirectClass) == MagickFalse)\n    return(MagickFalse);\n  image->mask=CloneImage(mask,0,0,MagickTrue,&image->exception);\n  if (image->mask == (Image *) NULL)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S e t I m a g e O p a c i t y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageOpacity() sets the opacity levels of the image.\n%\n%  The format of the SetImageOpacity method is:\n%\n%      MagickBooleanType SetImageOpacity(Image *image,const Quantum opacity)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o opacity: the level of transparency: 0 is fully opaque and QuantumRange is\n%      fully transparent.\n%\n*/\nMagickExport MagickBooleanType SetImageOpacity(Image *image,\n  const Quantum opacity)\n{\n  CacheView\n    *image_view;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  image->matte=MagickTrue;\n  status=MagickTrue;\n  exception=(&image->exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelOpacity(q,opacity);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e V i r t u a l P i x e l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageVirtualPixelMethod() sets the \"virtual pixels\" method for the\n%  image and returns the previous setting.  A virtual pixel is any pixel access\n%  that is outside the boundaries of the image cache.\n%\n%  The format of the SetImageVirtualPixelMethod() method is:\n%\n%      VirtualPixelMethod SetImageVirtualPixelMethod(const Image *image,\n%        const VirtualPixelMethod virtual_pixel_method)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: choose the type of virtual pixel.\n%\n*/\nMagickExport VirtualPixelMethod SetImageVirtualPixelMethod(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(SetPixelCacheVirtualMethod(image,virtual_pixel_method));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S m u s h I m a g e s                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SmushImages() takes all images from the current image pointer to the end\n%  of the image list and smushes them to each other top-to-bottom if the\n%  stack parameter is true, otherwise left-to-right.\n%\n%  The current gravity setting now effects how the image is justified in the\n%  final image.\n%\n%  The format of the SmushImages method is:\n%\n%      Image *SmushImages(const Image *images,const MagickBooleanType stack,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o images: the image sequence.\n%\n%    o stack: A value other than 0 stacks the images top-to-bottom.\n%\n%    o offset: minimum distance in pixels between images.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic ssize_t SmushXGap(const Image *smush_image,const Image *images,\n  const ssize_t offset,ExceptionInfo *exception)\n{\n  CacheView\n    *left_view,\n    *right_view;\n\n  const Image\n    *left_image,\n    *right_image;\n\n  RectangleInfo\n    left_geometry,\n    right_geometry;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    i,\n    y;\n\n  size_t\n    gap;\n\n  ssize_t\n    x;\n\n  if (images->previous == (Image *) NULL)\n    return(0);\n  right_image=images;\n  SetGeometry(smush_image,&right_geometry);\n  GravityAdjustGeometry(right_image->columns,right_image->rows,\n    right_image->gravity,&right_geometry);\n  left_image=images->previous;\n  SetGeometry(smush_image,&left_geometry);\n  GravityAdjustGeometry(left_image->columns,left_image->rows,\n    left_image->gravity,&left_geometry);\n  gap=right_image->columns;\n  left_view=AcquireVirtualCacheView(left_image,exception);\n  right_view=AcquireVirtualCacheView(right_image,exception);\n  for (y=0; y < (ssize_t) smush_image->rows; y++)\n  {\n    for (x=(ssize_t) left_image->columns-1; x > 0; x--)\n    {\n      p=GetCacheViewVirtualPixels(left_view,x,left_geometry.y+y,1,1,exception);\n      if ((p == (const PixelPacket *) NULL) ||\n          (GetPixelOpacity(p) != TransparentOpacity) ||\n          ((left_image->columns-x-1) >= gap))\n        break;\n    }\n    i=(ssize_t) left_image->columns-x-1;\n    for (x=0; x < (ssize_t) right_image->columns; x++)\n    {\n      p=GetCacheViewVirtualPixels(right_view,x,right_geometry.y+y,1,1,\n        exception);\n      if ((p == (const PixelPacket *) NULL) ||\n          (GetPixelOpacity(p) != TransparentOpacity) ||\n          ((x+i) >= (ssize_t) gap))\n        break;\n    }\n    if ((x+i) < (ssize_t) gap)\n      gap=(size_t) (x+i);\n  }\n  right_view=DestroyCacheView(right_view);\n  left_view=DestroyCacheView(left_view);\n  if (y < (ssize_t) smush_image->rows)\n    return(offset);\n  return((ssize_t) gap-offset);\n}\n\nstatic ssize_t SmushYGap(const Image *smush_image,const Image *images,\n  const ssize_t offset,ExceptionInfo *exception)\n{\n  CacheView\n    *bottom_view,\n    *top_view;\n\n  const Image\n    *bottom_image,\n    *top_image;\n\n  RectangleInfo\n    bottom_geometry,\n    top_geometry;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    gap;\n\n  ssize_t\n    y;\n\n  if (images->previous == (Image *) NULL)\n    return(0);\n  bottom_image=images;\n  SetGeometry(smush_image,&bottom_geometry);\n  GravityAdjustGeometry(bottom_image->columns,bottom_image->rows,\n    bottom_image->gravity,&bottom_geometry);\n  top_image=images->previous;\n  SetGeometry(smush_image,&top_geometry);\n  GravityAdjustGeometry(top_image->columns,top_image->rows,top_image->gravity,\n    &top_geometry);\n  gap=bottom_image->rows;\n  top_view=AcquireVirtualCacheView(top_image,exception);\n  bottom_view=AcquireVirtualCacheView(bottom_image,exception);\n  for (x=0; x < (ssize_t) smush_image->columns; x++)\n  {\n    for (y=(ssize_t) top_image->rows-1; y > 0; y--)\n    {\n      p=GetCacheViewVirtualPixels(top_view,top_geometry.x+x,y,1,1,exception);\n      if ((p == (const PixelPacket *) NULL) ||\n          (GetPixelOpacity(p) != TransparentOpacity) ||\n          ((top_image->rows-y-1) >= gap))\n        break;\n    }\n    i=(ssize_t) top_image->rows-y-1;\n    for (y=0; y < (ssize_t) bottom_image->rows; y++)\n    {\n      p=GetCacheViewVirtualPixels(bottom_view,bottom_geometry.x+x,y,1,1,\n        exception);\n      if ((p == (const PixelPacket *) NULL) ||\n          (GetPixelOpacity(p) != TransparentOpacity) ||\n          ((y+i) >= (ssize_t) gap))\n        break;\n    }\n    if ((y+i) < (ssize_t) gap)\n      gap=(size_t) (y+i);\n  }\n  bottom_view=DestroyCacheView(bottom_view);\n  top_view=DestroyCacheView(top_view);\n  if (x < (ssize_t) smush_image->columns)\n    return(offset);\n  return((ssize_t) gap-offset);\n}\n\nMagickExport Image *SmushImages(const Image *images,\n  const MagickBooleanType stack,const ssize_t offset,ExceptionInfo *exception)\n{\n#define SmushImageTag  \"Smush/Image\"\n\n  CacheView\n    *smush_view;\n\n  const Image\n    *image;\n\n  Image\n    *smush_image;\n\n  MagickBooleanType\n    matte,\n    proceed,\n    status;\n\n  MagickOffsetType\n    n;\n\n  RectangleInfo\n    geometry;\n\n  register const Image\n    *next;\n\n  size_t\n    height,\n    number_images,\n    width;\n\n  ssize_t\n    x_offset,\n    y_offset;\n\n  /*\n    Compute maximum area of smushed area.\n  */\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=images;\n  matte=image->matte;\n  number_images=1;\n  width=image->columns;\n  height=image->rows;\n  next=GetNextImageInList(image);\n  for ( ; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    if (next->matte != MagickFalse)\n      matte=MagickTrue;\n    number_images++;\n    if (stack != MagickFalse)\n      {\n        if (next->columns > width)\n          width=next->columns;\n        height+=next->rows;\n        if (next->previous != (Image *) NULL)\n          height+=offset;\n        continue;\n      }\n    width+=next->columns;\n    if (next->previous != (Image *) NULL)\n      width+=offset;\n    if (next->rows > height)\n      height=next->rows;\n  }\n  /*\n    Smush images.\n  */\n  smush_image=CloneImage(image,width,height,MagickTrue,exception);\n  if (smush_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(smush_image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&smush_image->exception);\n      smush_image=DestroyImage(smush_image);\n      return((Image *) NULL);\n    }\n  smush_image->matte=matte;\n  (void) SetImageBackgroundColor(smush_image);\n  status=MagickTrue;\n  x_offset=0;\n  y_offset=0;\n  smush_view=AcquireVirtualCacheView(smush_image,exception);\n  for (n=0; n < (MagickOffsetType) number_images; n++)\n  {\n    SetGeometry(smush_image,&geometry);\n    GravityAdjustGeometry(image->columns,image->rows,image->gravity,&geometry);\n    if (stack != MagickFalse)\n      {\n        x_offset-=geometry.x;\n        y_offset-=SmushYGap(smush_image,image,offset,exception);\n      }\n    else\n      {\n        x_offset-=SmushXGap(smush_image,image,offset,exception);\n        y_offset-=geometry.y;\n      }\n    status=CompositeImage(smush_image,OverCompositeOp,image,x_offset,y_offset);\n    proceed=SetImageProgress(image,SmushImageTag,n,number_images);\n    if (proceed == MagickFalse)\n      break;\n    if (stack == MagickFalse)\n      {\n        x_offset+=(ssize_t) image->columns;\n        y_offset=0;\n      }\n    else\n      {\n        x_offset=0;\n        y_offset+=(ssize_t) image->rows;\n      }\n    image=GetNextImageInList(image);\n  }\n  if (stack == MagickFalse)\n    smush_image->columns=(size_t) x_offset;\n  else\n    smush_image->rows=(size_t) y_offset;\n  smush_view=DestroyCacheView(smush_view);\n  if (status == MagickFalse)\n    smush_image=DestroyImage(smush_image);\n  return(smush_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S t r i p I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  StripImage() strips an image of all profiles and comments.\n%\n%  The format of the StripImage method is:\n%\n%      MagickBooleanType StripImage(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType StripImage(Image *image)\n{\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  DestroyImageProfiles(image);\n  (void) DeleteImageProperty(image,\"comment\");\n  (void) DeleteImageProperty(image,\"date:create\");\n  (void) DeleteImageProperty(image,\"date:modify\");\n  status=SetImageArtifact(image,\"png:exclude-chunk\",\n    \"bKGD,cHRM,EXIF,gAMA,iCCP,iTXt,sRGB,tEXt,zCCP,zTXt,date\");\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImage() initializes the red, green, and blue intensities of each pixel\n%  as defined by the colormap index.\n%\n%  The format of the SyncImage method is:\n%\n%      MagickBooleanType SyncImage(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\n\nstatic inline IndexPacket PushColormapIndex(Image *image,\n  const size_t index,MagickBooleanType *range_exception)\n{\n  if (index < image->colors)\n    return((IndexPacket) index);\n  *range_exception=MagickTrue;\n  return((IndexPacket) 0);\n}\n\nMagickExport MagickBooleanType SyncImage(Image *image)\n{\n  CacheView\n    *image_view;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    range_exception,\n    status,\n    taint;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  if (image->ping != MagickFalse)\n    return(MagickTrue);\n  if (image->storage_class != PseudoClass)\n    return(MagickFalse);\n  assert(image->colormap != (PixelPacket *) NULL);\n  range_exception=MagickFalse;\n  status=MagickTrue;\n  taint=image->taint;\n  exception=(&image->exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(range_exception,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    IndexPacket\n      index;\n\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewAuthenticIndexQueue(image_view);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      index=PushColormapIndex(image,(size_t) GetPixelIndex(indexes+x),\n        &range_exception);\n      if (image->matte == MagickFalse)\n        SetPixelRgb(q,image->colormap+(ssize_t) index)\n      else\n        SetPixelRGBO(q,image->colormap+(ssize_t) index);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  image->taint=taint;\n  if ((image->ping == MagickFalse) && (range_exception != MagickFalse))\n    (void) ThrowMagickException(&image->exception,GetMagickModule(),\n      CorruptImageWarning,\"InvalidColormapIndex\",\"`%s'\",image->filename);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S y n c I m a g e S e t t i n g s                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImageSettings() syncs image_info options into per-image attributes.\n%\n%  The format of the SyncImageSettings method is:\n%\n%      MagickBooleanType SyncImageSettings(const ImageInfo *image_info,\n%        Image *image)\n%      MagickBooleanType SyncImagesSettings(const ImageInfo *image_info,\n%        Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n*/\n\nMagickExport MagickBooleanType SyncImagesSettings(ImageInfo *image_info,\n  Image *images)\n{\n  Image\n    *image;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  image=images;\n  for ( ; image != (Image *) NULL; image=GetNextImageInList(image))\n    (void) SyncImageSettings(image_info,image);\n  (void) DeleteImageOption(image_info,\"page\");\n  return(MagickTrue);\n}\n\nMagickExport MagickBooleanType SyncImageSettings(const ImageInfo *image_info,\n  Image *image)\n{\n  char\n    property[MaxTextExtent];\n\n  const char\n    *option,\n    *value;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickStatusType\n    flags;\n\n  ResolutionType\n    units;\n\n  /*\n    Sync image options.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  option=GetImageOption(image_info,\"background\");\n  if (option != (const char *) NULL)\n    (void) QueryColorDatabase(option,&image->background_color,\n      &image->exception);\n  option=GetImageOption(image_info,\"bias\");\n  if (option != (const char *) NULL)\n    image->bias=StringToDoubleInterval(option,(double) QuantumRange+1.0);\n  option=GetImageOption(image_info,\"black-point-compensation\");\n  if (option != (const char *) NULL)\n    image->black_point_compensation=(MagickBooleanType) ParseCommandOption(\n      MagickBooleanOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"blue-primary\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.blue_primary.x=geometry_info.rho;\n      image->chromaticity.blue_primary.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.blue_primary.y=image->chromaticity.blue_primary.x;\n    }\n  option=GetImageOption(image_info,\"bordercolor\");\n  if (option != (const char *) NULL)\n    (void) QueryColorDatabase(option,&image->border_color,&image->exception);\n  option=GetImageOption(image_info,\"colors\");\n  if (option != (const char *) NULL)\n    image->colors=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"compose\");\n  if (option != (const char *) NULL)\n    image->compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"compress\");\n  if (option != (const char *) NULL)\n    image->compression=(CompressionType) ParseCommandOption(\n      MagickCompressOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"debug\");\n  if (option != (const char *) NULL)\n    image->debug=(MagickBooleanType) ParseCommandOption(MagickBooleanOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"density\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      /*\n        Set image density.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n    }\n  option=GetImageOption(image_info,\"depth\");\n  if (option != (const char *) NULL)\n    image->depth=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"endian\");\n  if (option != (const char *) NULL)\n    image->endian=(EndianType) ParseCommandOption(MagickEndianOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"filter\");\n  if (option != (const char *) NULL)\n    image->filter=(FilterTypes) ParseCommandOption(MagickFilterOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"fuzz\");\n  if (option != (const char *) NULL)\n    image->fuzz=StringToDoubleInterval(option,(double) QuantumRange+1.0);\n  option=GetImageOption(image_info,\"gravity\");\n  if (option != (const char *) NULL)\n    image->gravity=(GravityType) ParseCommandOption(MagickGravityOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"green-primary\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.green_primary.x=geometry_info.rho;\n      image->chromaticity.green_primary.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.green_primary.y=image->chromaticity.green_primary.x;\n    }\n  option=GetImageOption(image_info,\"intensity\");\n  if (option != (const char *) NULL)\n    image->intensity=(PixelIntensityMethod) ParseCommandOption(\n      MagickPixelIntensityOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"intent\");\n  if (option != (const char *) NULL)\n    image->rendering_intent=(RenderingIntent) ParseCommandOption(\n      MagickIntentOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"interlace\");\n  if (option != (const char *) NULL)\n    image->interlace=(InterlaceType) ParseCommandOption(MagickInterlaceOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"interpolate\");\n  if (option != (const char *) NULL)\n    image->interpolate=(InterpolatePixelMethod) ParseCommandOption(\n      MagickInterpolateOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"loop\");\n  if (option != (const char *) NULL)\n    image->iterations=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"mattecolor\");\n  if (option != (const char *) NULL)\n    (void) QueryColorDatabase(option,&image->matte_color,&image->exception);\n  option=GetImageOption(image_info,\"orient\");\n  if (option != (const char *) NULL)\n    image->orientation=(OrientationType) ParseCommandOption(\n      MagickOrientationOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"page\");\n  if (option != (const char *) NULL)\n    {\n      char\n        *geometry;\n\n      geometry=GetPageGeometry(option);\n      flags=ParseAbsoluteGeometry(geometry,&image->page);\n      geometry=DestroyString(geometry);\n    }\n  option=GetImageOption(image_info,\"quality\");\n  if (option != (const char *) NULL)\n    image->quality=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"red-primary\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.red_primary.x=geometry_info.rho;\n      image->chromaticity.red_primary.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.red_primary.y=image->chromaticity.red_primary.x;\n    }\n  if (image_info->quality != UndefinedCompressionQuality)\n    image->quality=image_info->quality;\n  option=GetImageOption(image_info,\"scene\");\n  if (option != (const char *) NULL)\n    image->scene=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"taint\");\n  if (option != (const char *) NULL)\n    image->taint=(MagickBooleanType) ParseCommandOption(MagickBooleanOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"tile-offset\");\n  if (option != (const char *) NULL)\n    {\n      char\n        *geometry;\n\n      geometry=GetPageGeometry(option);\n      flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);\n      geometry=DestroyString(geometry);\n    }\n  option=GetImageOption(image_info,\"transparent-color\");\n  if (option != (const char *) NULL)\n    (void) QueryColorDatabase(option,&image->transparent_color,\n      &image->exception);\n  option=GetImageOption(image_info,\"type\");\n  if (option != (const char *) NULL)\n    image->type=(ImageType) ParseCommandOption(MagickTypeOptions,MagickFalse,\n      option);\n  option=GetImageOption(image_info,\"units\");\n  if (option != (const char *) NULL)\n    units=(ResolutionType) ParseCommandOption(MagickResolutionOptions,\n      MagickFalse,option);\n  else\n    units = image_info->units;\n  if (units != UndefinedResolution)\n    {\n      if (image->units != units)\n        switch (image->units)\n        {\n          case PixelsPerInchResolution:\n          {\n            if (units == PixelsPerCentimeterResolution)\n              {\n                image->x_resolution/=2.54;\n                image->y_resolution/=2.54;\n              }\n            break;\n          }\n          case PixelsPerCentimeterResolution:\n          {\n            if (units == PixelsPerInchResolution)\n              {\n                image->x_resolution=(double) ((size_t) (100.0*2.54*\n                  image->x_resolution+0.5))/100.0;\n                image->y_resolution=(double) ((size_t) (100.0*2.54*\n                  image->y_resolution+0.5))/100.0;\n              }\n            break;\n          }\n          default:\n            break;\n        }\n      image->units=units;\n    }\n  option=GetImageOption(image_info,\"white-point\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.white_point.x=geometry_info.rho;\n      image->chromaticity.white_point.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.white_point.y=image->chromaticity.white_point.x;\n    }\n  ResetImageOptionIterator(image_info);\n  for (option=GetNextImageOption(image_info); option != (const char *) NULL; )\n  {\n    value=GetImageOption(image_info,option);\n    if (value != (const char *) NULL)\n      {\n        (void) FormatLocaleString(property,MaxTextExtent,\"%s\",option);\n        (void) SetImageArtifact(image,property,value);\n      }\n    option=GetNextImageOption(image_info);\n  }\n  return(MagickTrue);\n}\n"], "filenames": ["magick/image.c"], "buggy_code_start_loc": [845], "buggy_code_end_loc": [846], "fixing_code_start_loc": [845], "fixing_code_end_loc": [846], "type": "CWE-617", "message": "In ImageMagick 7.0.5-7 Q16, an assertion failure was found in the function LockSemaphoreInfo, which allows attackers to cause a denial of service via a crafted file.", "other": {"cve": {"id": "CVE-2017-9501", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-07T14:29:00.477", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In ImageMagick 7.0.5-7 Q16, an assertion failure was found in the function LockSemaphoreInfo, which allows attackers to cause a denial of service via a crafted file."}, {"lang": "es", "value": "En ImageMagick versi\u00f3n 7.0.5-7 Q16, se encontr\u00f3 un fallo en la funci\u00f3n LockSemaphoreInfo, que permite a los atacantes causar una denegaci\u00f3n de servicio por medio  de un archivo especialmente dise\u00f1ado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-7:*:*:*:*:*:*:*", "matchCriteriaId": "A2C0242E-0292-4DF7-A3FC-BE96DA95E7D4"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/98943", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/01843366d6a7b96e22ad7bb67f3df7d9fd4d5d74", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/491", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/01843366d6a7b96e22ad7bb67f3df7d9fd4d5d74"}}