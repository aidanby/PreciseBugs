{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * move.c: Functions for moving the cursor and scrolling text.\n *\n * There are two ways to move the cursor:\n * 1. Move the cursor directly, the text is scrolled to keep the cursor in the\n *    window.\n * 2. Scroll the text, the cursor is moved into the text visible in the\n *    window.\n * The 'scrolloff' option makes this a bit complicated.\n */\n\n#include \"vim.h\"\n\nstatic int scrolljump_value(void);\nstatic int check_top_offset(void);\nstatic void curs_rows(win_T *wp);\n\ntypedef struct\n{\n    linenr_T\t    lnum;\t// line number\n#ifdef FEAT_DIFF\n    int\t\t    fill;\t// filler lines\n#endif\n    int\t\t    height;\t// height of added line\n} lineoff_T;\n\nstatic void topline_back(lineoff_T *lp);\nstatic void botline_forw(lineoff_T *lp);\n\n/*\n * Compute wp->w_botline for the current wp->w_topline.  Can be called after\n * wp->w_topline changed.\n */\n    static void\ncomp_botline(win_T *wp)\n{\n    int\t\tn;\n    linenr_T\tlnum;\n    int\t\tdone;\n#ifdef FEAT_FOLDING\n    linenr_T    last;\n    int\t\tfolded;\n#endif\n\n    /*\n     * If w_cline_row is valid, start there.\n     * Otherwise have to start at w_topline.\n     */\n    check_cursor_moved(wp);\n    if (wp->w_valid & VALID_CROW)\n    {\n\tlnum = wp->w_cursor.lnum;\n\tdone = wp->w_cline_row;\n    }\n    else\n    {\n\tlnum = wp->w_topline;\n\tdone = 0;\n    }\n\n    for ( ; lnum <= wp->w_buffer->b_ml.ml_line_count; ++lnum)\n    {\n#ifdef FEAT_FOLDING\n\tlast = lnum;\n\tfolded = FALSE;\n\tif (hasFoldingWin(wp, lnum, NULL, &last, TRUE, NULL))\n\t{\n\t    n = 1;\n\t    folded = TRUE;\n\t}\n\telse\n#endif\n#ifdef FEAT_DIFF\n\t    if (lnum == wp->w_topline)\n\t\tn = plines_win_nofill(wp, lnum, TRUE) + wp->w_topfill;\n\t    else\n#endif\n\t\tn = plines_win(wp, lnum, TRUE);\n\tif (\n#ifdef FEAT_FOLDING\n\t\tlnum <= wp->w_cursor.lnum && last >= wp->w_cursor.lnum\n#else\n\t\tlnum == wp->w_cursor.lnum\n#endif\n\t   )\n\t{\n\t    wp->w_cline_row = done;\n\t    wp->w_cline_height = n;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = folded;\n#endif\n\t    redraw_for_cursorline(wp);\n\t    wp->w_valid |= (VALID_CROW|VALID_CHEIGHT);\n\t}\n\tif (done + n > wp->w_height)\n\t    break;\n\tdone += n;\n#ifdef FEAT_FOLDING\n\tlnum = last;\n#endif\n    }\n\n    // wp->w_botline is the line that is just below the window\n    wp->w_botline = lnum;\n    wp->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\n    set_empty_rows(wp, done);\n}\n\n#ifdef FEAT_SYN_HL\n    void\nreset_cursorline(void)\n{\n    curwin->w_last_cursorline = 0;\n}\n#endif\n\n/*\n * Redraw when w_cline_row changes and 'relativenumber' or 'cursorline' is\n * set.\n */\n    void\nredraw_for_cursorline(win_T *wp)\n{\n    if ((wp->w_p_rnu\n#ifdef FEAT_SYN_HL\n\t\t|| wp->w_p_cul\n#endif\n\t\t)\n\t    && (wp->w_valid & VALID_CROW) == 0\n\t    && !pum_visible())\n    {\n\tif (wp->w_p_rnu)\n\t    // win_line() will redraw the number column only.\n\t    redraw_win_later(wp, VALID);\n#ifdef FEAT_SYN_HL\n\tif (wp->w_p_cul)\n\t{\n\t    if (wp->w_redr_type <= VALID && wp->w_last_cursorline != 0)\n\t    {\n\t\t// \"w_last_cursorline\" may be outdated, worst case we redraw\n\t\t// too much.  This is optimized for moving the cursor around in\n\t\t// the current window.\n\t\tredrawWinline(wp, wp->w_last_cursorline);\n\t\tredrawWinline(wp, wp->w_cursor.lnum);\n\t    }\n\t    else\n\t\tredraw_win_later(wp, SOME_VALID);\n\t}\n#endif\n    }\n}\n\n/*\n * Update curwin->w_topline and redraw if necessary.\n * Used to update the screen before printing a message.\n */\n    void\nupdate_topline_redraw(void)\n{\n    update_topline();\n    if (must_redraw)\n\tupdate_screen(0);\n}\n\n/*\n * Update curwin->w_topline to move the cursor onto the screen.\n */\n    void\nupdate_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n    linenr_T\told_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill;\n#endif\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t     >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t   + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tif (curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_skipcol = 0;\n\t    redraw_later(NOT_VALID);\n\t}\n\telse\n\t    redraw_later(VALID);\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}\n\n/*\n * Return the scrolljump value to use for the current window.\n * When 'scrolljump' is positive use it as-is.\n * When 'scrolljump' is negative use it as a percentage of the window height.\n */\n    static int\nscrolljump_value(void)\n{\n    if (p_sj >= 0)\n\treturn (int)p_sj;\n    return (curwin->w_height * -p_sj) / 100;\n}\n\n/*\n * Return TRUE when there are not 'scrolloff' lines above the cursor for the\n * current window.\n */\n    static int\ncheck_top_offset(void)\n{\n    lineoff_T\tloff;\n    int\t\tn;\n    long        so = get_scrolloff_value();\n\n    if (curwin->w_cursor.lnum < curwin->w_topline + so\n#ifdef FEAT_FOLDING\n\t\t    || hasAnyFolding(curwin)\n#endif\n\t    )\n    {\n\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n\tn = curwin->w_topfill;\t    // always have this context\n#else\n\tn = 0;\n#endif\n\t// Count the visible screen lines above the cursor line.\n\twhile (n < so)\n\t{\n\t    topline_back(&loff);\n\t    // Stop when included a line above the window.\n\t    if (loff.lnum < curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t    || (loff.lnum == curwin->w_topline && loff.fill > 0)\n#endif\n\t\t    )\n\t\tbreak;\n\t    n += loff.height;\n\t}\n\tif (n < so)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n    void\nupdate_curswant(void)\n{\n    if (curwin->w_set_curswant)\n    {\n\tvalidate_virtcol();\n\tcurwin->w_curswant = curwin->w_virtcol;\n\tcurwin->w_set_curswant = FALSE;\n    }\n}\n\n/*\n * Check if the cursor has moved.  Set the w_valid flag accordingly.\n */\n    void\ncheck_cursor_moved(win_T *wp)\n{\n    if (wp->w_cursor.lnum != wp->w_valid_cursor.lnum)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t     |VALID_CHEIGHT|VALID_CROW|VALID_TOPLINE);\n\twp->w_valid_cursor = wp->w_cursor;\n\twp->w_valid_leftcol = wp->w_leftcol;\n    }\n    else if (wp->w_cursor.col != wp->w_valid_cursor.col\n\t     || wp->w_leftcol != wp->w_valid_leftcol\n\t     || wp->w_cursor.coladd != wp->w_valid_cursor.coladd)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\twp->w_valid_cursor.col = wp->w_cursor.col;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_cursor.coladd = wp->w_cursor.coladd;\n    }\n}\n\n/*\n * Call this function when some window settings have changed, which require\n * the cursor position, botline and topline to be recomputed and the window to\n * be redrawn.  E.g, when changing the 'wrap' option or folding.\n */\n    void\nchanged_window_setting(void)\n{\n    changed_window_setting_win(curwin);\n}\n\n    void\nchanged_window_setting_win(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP|VALID_TOPLINE);\n    redraw_win_later(wp, NOT_VALID);\n}\n\n/*\n * Set wp->w_topline to a certain number.\n */\n    void\nset_topline(win_T *wp, linenr_T lnum)\n{\n#ifdef FEAT_DIFF\n    linenr_T prev_topline = wp->w_topline;\n#endif\n\n#ifdef FEAT_FOLDING\n    // go to first of folded lines\n    (void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n    // Approximate the value of w_botline\n    wp->w_botline += lnum - wp->w_topline;\n    if (wp->w_botline > wp->w_buffer->b_ml.ml_line_count + 1)\n\twp->w_botline = wp->w_buffer->b_ml.ml_line_count + 1;\n    wp->w_topline = lnum;\n    wp->w_topline_was_set = TRUE;\n#ifdef FEAT_DIFF\n    if (lnum != prev_topline)\n\t// Keep the filler lines when the topline didn't change.\n\twp->w_topfill = 0;\n#endif\n    wp->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE);\n    // Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.\n    redraw_later(VALID);\n}\n\n/*\n * Call this function when the length of the cursor line (in screen\n * characters) has changed, and the change is before the cursor.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_cline_bef_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_cline_bef_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n/*\n * Call this function when the length of a line (in screen characters) above\n * the cursor have changed.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_line_abv_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_line_abv_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n/*\n * Make sure the value of curwin->w_botline is valid.\n */\n    void\nvalidate_botline(void)\n{\n    validate_botline_win(curwin);\n}\n\n/*\n * Make sure the value of wp->w_botline is valid.\n */\n    void\nvalidate_botline_win(win_T *wp)\n{\n    if (!(wp->w_valid & VALID_BOTLINE))\n\tcomp_botline(wp);\n}\n\n/*\n * Mark curwin->w_botline as invalid (because of some change in the buffer).\n */\n    void\ninvalidate_botline(void)\n{\n    curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\ninvalidate_botline_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\napproximate_botline_win(\n    win_T\t*wp)\n{\n    wp->w_valid &= ~VALID_BOTLINE;\n}\n\n/*\n * Return TRUE if curwin->w_wrow and curwin->w_wcol are valid.\n */\n    int\ncursor_valid(void)\n{\n    check_cursor_moved(curwin);\n    return ((curwin->w_valid & (VALID_WROW|VALID_WCOL)) ==\n\t\t\t\t\t\t      (VALID_WROW|VALID_WCOL));\n}\n\n/*\n * Validate cursor position.  Makes sure w_wrow and w_wcol are valid.\n * w_topline must be valid, you may need to call update_topline() first!\n */\n    void\nvalidate_cursor(void)\n{\n    check_cursor_moved(curwin);\n    if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))\n\tcurs_columns(TRUE);\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * validate w_cline_row.\n */\n    void\nvalidate_cline_row(void)\n{\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    update_topline();\n    check_cursor_moved(curwin);\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n}\n#endif\n\n/*\n * Compute wp->w_cline_row and wp->w_cline_height, based on the current value\n * of wp->w_topline.\n */\n    static void\ncurs_rows(win_T *wp)\n{\n    linenr_T\tlnum;\n    int\t\ti;\n    int\t\tall_invalid;\n    int\t\tvalid;\n#ifdef FEAT_FOLDING\n    long\tfold_count;\n#endif\n\n    // Check if wp->w_lines[].wl_size is invalid\n    all_invalid = (!redrawing()\n\t\t\t|| wp->w_lines_valid == 0\n\t\t\t|| wp->w_lines[0].wl_lnum > wp->w_topline);\n    i = 0;\n    wp->w_cline_row = 0;\n    for (lnum = wp->w_topline; lnum < wp->w_cursor.lnum; ++i)\n    {\n\tvalid = FALSE;\n\tif (!all_invalid && i < wp->w_lines_valid)\n\t{\n\t    if (wp->w_lines[i].wl_lnum < lnum || !wp->w_lines[i].wl_valid)\n\t\tcontinue;\t\t// skip changed or deleted lines\n\t    if (wp->w_lines[i].wl_lnum == lnum)\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Check for newly inserted lines below this row, in which\n\t\t// case we need to check for folded lines.\n\t\tif (!wp->w_buffer->b_mod_set\n\t\t\t|| wp->w_lines[i].wl_lastlnum < wp->w_cursor.lnum\n\t\t\t|| wp->w_buffer->b_mod_top\n\t\t\t\t\t     > wp->w_lines[i].wl_lastlnum + 1)\n#endif\n\t\tvalid = TRUE;\n\t    }\n\t    else if (wp->w_lines[i].wl_lnum > lnum)\n\t\t--i;\t\t\t// hold at inserted lines\n\t}\n\tif (valid\n#ifdef FEAT_DIFF\n\t\t&& (lnum != wp->w_topline || !wp->w_p_diff)\n#endif\n\t\t)\n\t{\n#ifdef FEAT_FOLDING\n\t    lnum = wp->w_lines[i].wl_lastlnum + 1;\n\t    // Cursor inside folded lines, don't count this row\n\t    if (lnum > wp->w_cursor.lnum)\n\t\tbreak;\n#else\n\t    ++lnum;\n#endif\n\t    wp->w_cline_row += wp->w_lines[i].wl_size;\n\t}\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    fold_count = foldedCount(wp, lnum, NULL);\n\t    if (fold_count)\n\t    {\n\t\tlnum += fold_count;\n\t\tif (lnum > wp->w_cursor.lnum)\n\t\t    break;\n\t\t++wp->w_cline_row;\n\t    }\n\t    else\n#endif\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    wp->w_cline_row += plines_win_nofill(wp, lnum++, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    wp->w_cline_row += plines_win(wp, lnum++, TRUE);\n\t}\n    }\n\n    check_cursor_moved(wp);\n    if (!(wp->w_valid & VALID_CHEIGHT))\n    {\n\tif (all_invalid\n\t\t|| i == wp->w_lines_valid\n\t\t|| (i < wp->w_lines_valid\n\t\t    && (!wp->w_lines[i].wl_valid\n\t\t\t|| wp->w_lines[i].wl_lnum != wp->w_cursor.lnum)))\n\t{\n#ifdef FEAT_DIFF\n\t    if (wp->w_cursor.lnum == wp->w_topline)\n\t\twp->w_cline_height = plines_win_nofill(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t\tTRUE) + wp->w_topfill;\n\t    else\n#endif\n\t\twp->w_cline_height = plines_win(wp, wp->w_cursor.lnum, TRUE);\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse if (i > wp->w_lines_valid)\n\t{\n\t    // a line that is too long to fit on the last screen line\n\t    wp->w_cline_height = 0;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse\n\t{\n\t    wp->w_cline_height = wp->w_lines[i].wl_size;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = wp->w_lines[i].wl_folded;\n#endif\n\t}\n    }\n\n    redraw_for_cursorline(curwin);\n    wp->w_valid |= VALID_CROW|VALID_CHEIGHT;\n\n}\n\n/*\n * Validate curwin->w_virtcol only.\n */\n    void\nvalidate_virtcol(void)\n{\n    validate_virtcol_win(curwin);\n}\n\n/*\n * Validate wp->w_virtcol only.\n */\n    void\nvalidate_virtcol_win(win_T *wp)\n{\n    check_cursor_moved(wp);\n    if (!(wp->w_valid & VALID_VIRTCOL))\n    {\n\tgetvvcol(wp, &wp->w_cursor, NULL, &(wp->w_virtcol), NULL);\n\twp->w_valid |= VALID_VIRTCOL;\n#ifdef FEAT_SYN_HL\n\tif (wp->w_p_cuc && !pum_visible())\n\t    redraw_win_later(wp, SOME_VALID);\n#endif\n    }\n}\n\n/*\n * Validate curwin->w_cline_height only.\n */\n    void\nvalidate_cheight(void)\n{\n    check_cursor_moved(curwin);\n    if (!(curwin->w_valid & VALID_CHEIGHT))\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    curwin->w_cline_height = plines_nofill(curwin->w_cursor.lnum)\n\t\t\t\t\t\t\t  + curwin->w_topfill;\n\telse\n#endif\n\t    curwin->w_cline_height = plines(curwin->w_cursor.lnum);\n#ifdef FEAT_FOLDING\n\tcurwin->w_cline_folded = hasFolding(curwin->w_cursor.lnum, NULL, NULL);\n#endif\n\tcurwin->w_valid |= VALID_CHEIGHT;\n    }\n}\n\n/*\n * Validate w_wcol and w_virtcol only.\n */\n    void\nvalidate_cursor_col(void)\n{\n    colnr_T off;\n    colnr_T col;\n    int     width;\n\n    validate_virtcol();\n    if (!(curwin->w_valid & VALID_WCOL))\n    {\n\tcol = curwin->w_virtcol;\n\toff = curwin_col_off();\n\tcol += off;\n\twidth = curwin->w_width - off + curwin_col_off2();\n\n\t// long line wrapping, adjust curwin->w_wrow\n\tif (curwin->w_p_wrap\n\t\t&& col >= (colnr_T)curwin->w_width\n\t\t&& width > 0)\n\t    // use same formula as what is used in curs_columns()\n\t    col -= ((col - curwin->w_width) / width + 1) * width;\n\tif (col > (int)curwin->w_leftcol)\n\t    col -= curwin->w_leftcol;\n\telse\n\t    col = 0;\n\tcurwin->w_wcol = col;\n\n\tcurwin->w_valid |= VALID_WCOL;\n#ifdef FEAT_PROP_POPUP\n\tcurwin->w_flags &= ~WFLAG_WCOL_OFF_ADDED;\n#endif\n    }\n}\n\n/*\n * Compute offset of a window, occupied by absolute or relative line number,\n * fold column and sign column (these don't move when scrolling horizontally).\n */\n    int\nwin_col_off(win_T *wp)\n{\n    return (((wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) + 1 : 0)\n#ifdef FEAT_CMDWIN\n\t    + (cmdwin_type == 0 || wp != curwin ? 0 : 1)\n#endif\n#ifdef FEAT_FOLDING\n\t    + wp->w_p_fdc\n#endif\n#ifdef FEAT_SIGNS\n\t    + (signcolumn_on(wp) ? 2 : 0)\n#endif\n\t   );\n}\n\n    int\ncurwin_col_off(void)\n{\n    return win_col_off(curwin);\n}\n\n/*\n * Return the difference in column offset for the second screen line of a\n * wrapped line.  It's 8 if 'number' or 'relativenumber' is on and 'n' is in\n * 'cpoptions'.\n */\n    int\nwin_col_off2(win_T *wp)\n{\n    if ((wp->w_p_nu || wp->w_p_rnu) && vim_strchr(p_cpo, CPO_NUMCOL) != NULL)\n\treturn number_width(wp) + 1;\n    return 0;\n}\n\n    int\ncurwin_col_off2(void)\n{\n    return win_col_off2(curwin);\n}\n\n/*\n * Compute curwin->w_wcol and curwin->w_virtcol.\n * Also updates curwin->w_wrow and curwin->w_cline_row.\n * Also updates curwin->w_leftcol.\n */\n    void\ncurs_columns(\n    int\t\tmay_scroll)\t// when TRUE, may scroll horizontally\n{\n    int\t\tdiff;\n    int\t\textra;\t\t// offset for first screen line\n    int\t\toff_left, off_right;\n    int\t\tn;\n    int\t\tp_lines;\n    int\t\twidth = 0;\n    int\t\ttextwidth;\n    int\t\tnew_leftcol;\n    colnr_T\tstartcol;\n    colnr_T\tendcol;\n    colnr_T\tprev_skipcol;\n    long        so = get_scrolloff_value();\n    long        siso = get_sidescrolloff_value();\n\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    update_topline();\n\n    /*\n     * Next make sure that w_cline_row is valid.\n     */\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n\n    /*\n     * Compute the number of virtual columns.\n     */\n#ifdef FEAT_FOLDING\n    if (curwin->w_cline_folded)\n\t// In a folded line the cursor is always in the first column\n\tstartcol = curwin->w_virtcol = endcol = curwin->w_leftcol;\n    else\n#endif\n\tgetvvcol(curwin, &curwin->w_cursor,\n\t\t\t\t&startcol, &(curwin->w_virtcol), &endcol);\n\n    // remove '$' from change command when cursor moves onto it\n    if (startcol > dollar_vcol)\n\tdollar_vcol = -1;\n\n    extra = curwin_col_off();\n    curwin->w_wcol = curwin->w_virtcol + extra;\n    endcol += extra;\n\n    /*\n     * Now compute w_wrow, counting screen lines from w_cline_row.\n     */\n    curwin->w_wrow = curwin->w_cline_row;\n\n    textwidth = curwin->w_width - extra;\n    if (textwidth <= 0)\n    {\n\t// No room for text, put cursor in last char of window.\n\t// If not wrapping, the last non-empty line.\n\tcurwin->w_wcol = curwin->w_width - 1;\n\tif (curwin->w_p_wrap)\n\t    curwin->w_wrow = curwin->w_height - 1;\n\telse\n\t    curwin->w_wrow = curwin->w_height - 1 - curwin->w_empty_rows;\n    }\n    else if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\twidth = textwidth + curwin_col_off2();\n\n\t// long line wrapping, adjust curwin->w_wrow\n\tif (curwin->w_wcol >= curwin->w_width)\n\t{\n#ifdef FEAT_LINEBREAK\n\t    char_u *sbr;\n#endif\n\n\t    // this same formula is used in validate_cursor_col()\n\t    n = (curwin->w_wcol - curwin->w_width) / width + 1;\n\t    curwin->w_wcol -= n * width;\n\t    curwin->w_wrow += n;\n\n#ifdef FEAT_LINEBREAK\n\t    // When cursor wraps to first char of next line in Insert\n\t    // mode, the 'showbreak' string isn't shown, backup to first\n\t    // column\n\t    sbr = get_showbreak_value(curwin);\n\t    if (*sbr && *ml_get_cursor() == NUL\n\t\t\t\t    && curwin->w_wcol == vim_strsize(sbr))\n\t\tcurwin->w_wcol = 0;\n#endif\n\t}\n    }\n\n    // No line wrapping: compute curwin->w_leftcol if scrolling is on and line\n    // is not folded.\n    // If scrolling is off, curwin->w_leftcol is assumed to be 0\n    else if (may_scroll\n#ifdef FEAT_FOLDING\n\t    && !curwin->w_cline_folded\n#endif\n\t    )\n    {\n\t/*\n\t * If Cursor is left of the screen, scroll rightwards.\n\t * If Cursor is right of the screen, scroll leftwards\n\t * If we get closer to the edge than 'sidescrolloff', scroll a little\n\t * extra\n\t */\n\toff_left = (int)startcol - (int)curwin->w_leftcol - siso;\n\toff_right = (int)endcol - (int)(curwin->w_leftcol + curwin->w_width\n\t\t\t\t\t\t\t\t- siso) + 1;\n\tif (off_left < 0 || off_right > 0)\n\t{\n\t    if (off_left < 0)\n\t\tdiff = -off_left;\n\t    else\n\t\tdiff = off_right;\n\n\t    // When far off or not enough room on either side, put cursor in\n\t    // middle of window.\n\t    if (p_ss == 0 || diff >= textwidth / 2 || off_right >= off_left)\n\t\tnew_leftcol = curwin->w_wcol - extra - textwidth / 2;\n\t    else\n\t    {\n\t\tif (diff < p_ss)\n\t\t    diff = p_ss;\n\t\tif (off_left < 0)\n\t\t    new_leftcol = curwin->w_leftcol - diff;\n\t\telse\n\t\t    new_leftcol = curwin->w_leftcol + diff;\n\t    }\n\t    if (new_leftcol < 0)\n\t\tnew_leftcol = 0;\n\t    if (new_leftcol != (int)curwin->w_leftcol)\n\t    {\n\t\tcurwin->w_leftcol = new_leftcol;\n\t\t// screen has to be redrawn with new curwin->w_leftcol\n\t\tredraw_later(NOT_VALID);\n\t    }\n\t}\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    }\n    else if (curwin->w_wcol > (int)curwin->w_leftcol)\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    else\n\tcurwin->w_wcol = 0;\n\n#ifdef FEAT_DIFF\n    // Skip over filler lines.  At the top use w_topfill, there\n    // may be some filler lines above the window.\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_wrow += curwin->w_topfill;\n    else\n\tcurwin->w_wrow += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    prev_skipcol = curwin->w_skipcol;\n\n    p_lines = 0;\n\n    if ((curwin->w_wrow >= curwin->w_height\n\t\t|| ((prev_skipcol > 0\n\t\t\t|| curwin->w_wrow + so >= curwin->w_height)\n\t\t    && (p_lines =\n#ifdef FEAT_DIFF\n\t\t\tplines_win_nofill\n#else\n\t\t\tplines_win\n#endif\n\t\t\t(curwin, curwin->w_cursor.lnum, FALSE))\n\t\t\t\t\t\t    - 1 >= curwin->w_height))\n\t    && curwin->w_height != 0\n\t    && curwin->w_cursor.lnum == curwin->w_topline\n\t    && width > 0\n\t    && curwin->w_width != 0)\n    {\n\t// Cursor past end of screen.  Happens with a single line that does\n\t// not fit on screen.  Find a skipcol to show the text around the\n\t// cursor.  Avoid scrolling all the time. compute value of \"extra\":\n\t// 1: Less than 'scrolloff' lines above\n\t// 2: Less than 'scrolloff' lines below\n\t// 3: both of them\n\textra = 0;\n\tif (curwin->w_skipcol + so * width > curwin->w_virtcol)\n\t    extra = 1;\n\t// Compute last display line of the buffer line that we want at the\n\t// bottom of the window.\n\tif (p_lines == 0)\n\t    p_lines = plines_win(curwin, curwin->w_cursor.lnum, FALSE);\n\t--p_lines;\n\tif (p_lines > curwin->w_wrow + so)\n\t    n = curwin->w_wrow + so;\n\telse\n\t    n = p_lines;\n\tif ((colnr_T)n >= curwin->w_height + curwin->w_skipcol / width - so)\n\t    extra += 2;\n\n\tif (extra == 3 || p_lines <= so * 2)\n\t{\n\t    // not enough room for 'scrolloff', put cursor in the middle\n\t    n = curwin->w_virtcol / width;\n\t    if (n > curwin->w_height / 2)\n\t\tn -= curwin->w_height / 2;\n\t    else\n\t\tn = 0;\n\t    // don't skip more than necessary\n\t    if (n > p_lines - curwin->w_height + 1)\n\t\tn = p_lines - curwin->w_height + 1;\n\t    curwin->w_skipcol = n * width;\n\t}\n\telse if (extra == 1)\n\t{\n\t    // less then 'scrolloff' lines above, decrease skipcol\n\t    extra = (curwin->w_skipcol + so * width - curwin->w_virtcol\n\t\t\t\t     + width - 1) / width;\n\t    if (extra > 0)\n\t    {\n\t\tif ((colnr_T)(extra * width) > curwin->w_skipcol)\n\t\t    extra = curwin->w_skipcol / width;\n\t\tcurwin->w_skipcol -= extra * width;\n\t    }\n\t}\n\telse if (extra == 2)\n\t{\n\t    // less then 'scrolloff' lines below, increase skipcol\n\t    endcol = (n - curwin->w_height + 1) * width;\n\t    while (endcol > curwin->w_virtcol)\n\t\tendcol -= width;\n\t    if (endcol > curwin->w_skipcol)\n\t\tcurwin->w_skipcol = endcol;\n\t}\n\n\tcurwin->w_wrow -= curwin->w_skipcol / width;\n\tif (curwin->w_wrow >= curwin->w_height)\n\t{\n\t    // small window, make sure cursor is in it\n\t    extra = curwin->w_wrow - curwin->w_height + 1;\n\t    curwin->w_skipcol += extra * width;\n\t    curwin->w_wrow -= extra;\n\t}\n\n\textra = ((int)prev_skipcol - (int)curwin->w_skipcol) / width;\n\tif (extra > 0)\n\t    win_ins_lines(curwin, 0, extra, FALSE, FALSE);\n\telse if (extra < 0)\n\t    win_del_lines(curwin, 0, -extra, FALSE, FALSE, 0);\n    }\n    else\n\tcurwin->w_skipcol = 0;\n    if (prev_skipcol != curwin->w_skipcol)\n\tredraw_later(NOT_VALID);\n\n#ifdef FEAT_SYN_HL\n    // Redraw when w_virtcol changes and 'cursorcolumn' is set\n    if (curwin->w_p_cuc && (curwin->w_valid & VALID_VIRTCOL) == 0\n\t    && !pum_visible())\n\tredraw_later(SOME_VALID);\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\n    if (popup_is_popup(curwin) && curbuf->b_term != NULL)\n    {\n\tcurwin->w_wrow += popup_top_extra(curwin);\n\tcurwin->w_wcol += popup_left_extra(curwin);\n\tcurwin->w_flags |= WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED;\n    }\n    else\n\tcurwin->w_flags &= ~(WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED);\n#endif\n\n    // now w_leftcol is valid, avoid check_cursor_moved() thinking otherwise\n    curwin->w_valid_leftcol = curwin->w_leftcol;\n\n    curwin->w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;\n}\n\n#if (defined(FEAT_EVAL) || defined(FEAT_PROP_POPUP)) || defined(PROTO)\n/*\n * Compute the screen position of text character at \"pos\" in window \"wp\"\n * The resulting values are one-based, zero when character is not visible.\n */\n    void\ntextpos2screenpos(\n\twin_T\t*wp,\n\tpos_T\t*pos,\n\tint\t*rowp,\t// screen row\n\tint\t*scolp,\t// start screen column\n\tint\t*ccolp,\t// cursor screen column\n\tint\t*ecolp)\t// end screen column\n{\n    colnr_T\tscol = 0, ccol = 0, ecol = 0;\n    int\t\trow = 0;\n    int\t\trowoff = 0;\n    colnr_T\tcoloff = 0;\n\n    if (pos->lnum >= wp->w_topline && pos->lnum <= wp->w_botline)\n    {\n\tcolnr_T off;\n\tcolnr_T col;\n\tint     width;\n\n\trow = plines_m_win(wp, wp->w_topline, pos->lnum - 1) + 1;\n\tgetvcol(wp, pos, &scol, &ccol, &ecol);\n\n\t// similar to what is done in validate_cursor_col()\n\tcol = scol;\n\toff = win_col_off(wp);\n\tcol += off;\n\twidth = wp->w_width - off + win_col_off2(wp);\n\n\t// long line wrapping, adjust row\n\tif (wp->w_p_wrap\n\t\t&& col >= (colnr_T)wp->w_width\n\t\t&& width > 0)\n\t{\n\t    // use same formula as what is used in curs_columns()\n\t    rowoff = ((col - wp->w_width) / width + 1);\n\t    col -= rowoff * width;\n\t}\n\tcol -= wp->w_leftcol;\n\tif (col >= wp->w_width)\n\t    col = -1;\n\tif (col >= 0 && row + rowoff <= wp->w_height)\n\t    coloff = col - scol + wp->w_wincol + 1;\n\telse\n\t    // character is left, right or below of the window\n\t    row = rowoff = scol = ccol = ecol = 0;\n    }\n    *rowp = W_WINROW(wp) + row + rowoff;\n    *scolp = scol + coloff;\n    *ccolp = ccol + coloff;\n    *ecolp = ecol + coloff;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"screenpos({winid}, {lnum}, {col})\" function\n */\n    void\nf_screenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    dict_T\t*dict;\n    win_T\t*wp;\n    pos_T\tpos;\n    int\t\trow = 0;\n    int\t\tscol = 0, ccol = 0, ecol = 0;\n\n    if (rettv_dict_alloc(rettv) != OK)\n\treturn;\n    dict = rettv->vval.v_dict;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    pos.lnum = tv_get_number(&argvars[1]);\n    pos.col = tv_get_number(&argvars[2]) - 1;\n    pos.coladd = 0;\n    textpos2screenpos(wp, &pos, &row, &scol, &ccol, &ecol);\n\n    dict_add_number(dict, \"row\", row);\n    dict_add_number(dict, \"col\", scol);\n    dict_add_number(dict, \"curscol\", ccol);\n    dict_add_number(dict, \"endcol\", ecol);\n}\n#endif\n\n/*\n * Scroll the current window down by \"line_count\" logical lines.  \"CTRL-Y\"\n */\n    void\nscrolldown(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n    long\tdone = 0;\t// total # of physical lines done\n    int\t\twrow;\n    int\t\tmoved = FALSE;\n\n#ifdef FEAT_FOLDING\n    linenr_T\tfirst;\n\n    // Make sure w_topline is at the first of a sequence of folded lines.\n    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    validate_cursor();\t\t// w_wrow needs to be valid\n    while (line_count-- > 0)\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill < diff_check(curwin, curwin->w_topline)\n\t\t&& curwin->w_topfill < curwin->w_height - 1)\n\t{\n\t    ++curwin->w_topfill;\n\t    ++done;\n\t}\n\telse\n#endif\n\t{\n\t    if (curwin->w_topline == 1)\n\t\tbreak;\n\t    --curwin->w_topline;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = 0;\n#endif\n#ifdef FEAT_FOLDING\n\t    // A sequence of folded lines only counts for one logical line\n\t    if (hasFolding(curwin->w_topline, &first, NULL))\n\t    {\n\t\t++done;\n\t\tif (!byfold)\n\t\t    line_count -= curwin->w_topline - first - 1;\n\t\tcurwin->w_botline -= curwin->w_topline - first;\n\t\tcurwin->w_topline = first;\n\t    }\n\t    else\n#endif\n\t\tdone += PLINES_NOFILL(curwin->w_topline);\n\t}\n\t--curwin->w_botline;\t\t// approximate w_botline\n\tinvalidate_botline();\n    }\n    curwin->w_wrow += done;\t\t// keep w_wrow updated\n    curwin->w_cline_row += done;\t// keep w_cline_row updated\n\n#ifdef FEAT_DIFF\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_cline_row = 0;\n    check_topfill(curwin, TRUE);\n#endif\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and move the cursor onto the displayed part of the window.\n     */\n    wrow = curwin->w_wrow;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tvalidate_cheight();\n\twrow += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    while (wrow >= curwin->w_height && curwin->w_cursor.lnum > 1)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(curwin->w_cursor.lnum, &first, NULL))\n\t{\n\t    --wrow;\n\t    if (first == 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n\t\tcurwin->w_cursor.lnum = first - 1;\n\t}\n\telse\n#endif\n\t    wrow -= plines(curwin->w_cursor.lnum--);\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tmoved = TRUE;\n    }\n    if (moved)\n    {\n#ifdef FEAT_FOLDING\n\t// Move cursor to first line of closed fold.\n\tfoldAdjustCursor();\n#endif\n\tcoladvance(curwin->w_curswant);\n    }\n}\n\n/*\n * Scroll the current window up by \"line_count\" logical lines.  \"CTRL-E\"\n */\n    void\nscrollup(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n#if defined(FEAT_FOLDING) || defined(FEAT_DIFF)\n    linenr_T\tlnum;\n\n    if (\n# ifdef FEAT_FOLDING\n\t    (byfold && hasAnyFolding(curwin))\n#  ifdef FEAT_DIFF\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_DIFF\n\t    curwin->w_p_diff\n# endif\n\t    )\n    {\n\t// count each sequence of folded lines as one logical line\n\tlnum = curwin->w_topline;\n\twhile (line_count--)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t\t--curwin->w_topfill;\n\t    else\n# endif\n\t    {\n# ifdef FEAT_FOLDING\n\t\tif (byfold)\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n# endif\n\t\tif (lnum >= curbuf->b_ml.ml_line_count)\n\t\t    break;\n\t\t++lnum;\n# ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = diff_check_fill(curwin, lnum);\n# endif\n\t    }\n\t}\n\t// approximate w_botline\n\tcurwin->w_botline += lnum - curwin->w_topline;\n\tcurwin->w_topline = lnum;\n    }\n    else\n#endif\n    {\n\tcurwin->w_topline += line_count;\n\tcurwin->w_botline += line_count;\t// approximate w_botline\n    }\n\n    if (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n    if (curwin->w_botline > curbuf->b_ml.ml_line_count + 1)\n\tcurwin->w_botline = curbuf->b_ml.ml_line_count + 1;\n\n#ifdef FEAT_DIFF\n    check_topfill(curwin, FALSE);\n#endif\n\n#ifdef FEAT_FOLDING\n    if (hasAnyFolding(curwin))\n\t// Make sure w_topline is at the first of a sequence of folded lines.\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n    {\n\tcurwin->w_cursor.lnum = curwin->w_topline;\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tcoladvance(curwin->w_curswant);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Don't end up with too many filler lines in the window.\n */\n    void\ncheck_topfill(\n    win_T\t*wp,\n    int\t\tdown)\t// when TRUE scroll down when not enough space\n{\n    int\t\tn;\n\n    if (wp->w_topfill > 0)\n    {\n\tn = plines_win_nofill(wp, wp->w_topline, TRUE);\n\tif (wp->w_topfill + n > wp->w_height)\n\t{\n\t    if (down && wp->w_topline > 1)\n\t    {\n\t\t--wp->w_topline;\n\t\twp->w_topfill = 0;\n\t    }\n\t    else\n\t    {\n\t\twp->w_topfill = wp->w_height - n;\n\t\tif (wp->w_topfill < 0)\n\t\t    wp->w_topfill = 0;\n\t    }\n\t}\n    }\n}\n\n/*\n * Use as many filler lines as possible for w_topline.  Make sure w_topline\n * is still visible.\n */\n    static void\nmax_topfill(void)\n{\n    int\t\tn;\n\n    n = plines_nofill(curwin->w_topline);\n    if (n >= curwin->w_height)\n\tcurwin->w_topfill = 0;\n    else\n    {\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill + n > curwin->w_height)\n\t    curwin->w_topfill = curwin->w_height - n;\n    }\n}\n#endif\n\n/*\n * Scroll the screen one line down, but don't do it if it would move the\n * cursor off the screen.\n */\n    void\nscrolldown_clamp(void)\n{\n    int\t\tend_row;\n#ifdef FEAT_DIFF\n    int\t\tcan_fill = (curwin->w_topfill\n\t\t\t\t< diff_check_fill(curwin, curwin->w_topline));\n#endif\n\n    if (curwin->w_topline <= 1\n#ifdef FEAT_DIFF\n\t    && !can_fill\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go past 'scrolloff' lines from the screen end.\n     */\n    end_row = curwin->w_wrow;\n#ifdef FEAT_DIFF\n    if (can_fill)\n\t++end_row;\n    else\n\tend_row += plines_nofill(curwin->w_topline - 1);\n#else\n    end_row += plines(curwin->w_topline - 1);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_cheight();\n\tvalidate_virtcol();\n\tend_row += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    if (end_row < curwin->w_height - get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (can_fill)\n\t{\n\t    ++curwin->w_topfill;\n\t    check_topfill(curwin, TRUE);\n\t}\n\telse\n\t{\n\t    --curwin->w_topline;\n\t    curwin->w_topfill = 0;\n\t}\n#else\n\t--curwin->w_topline;\n#endif\n#ifdef FEAT_FOLDING\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t--curwin->w_botline;\t    // approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Scroll the screen one line up, but don't do it if it would move the cursor\n * off the screen.\n */\n    void\nscrollup_clamp(void)\n{\n    int\t    start_row;\n\n    if (curwin->w_topline == curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t    && curwin->w_topfill == 0\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the first row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go before 'scrolloff' lines from the screen start.\n     */\n#ifdef FEAT_DIFF\n    start_row = curwin->w_wrow - plines_nofill(curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#else\n    start_row = curwin->w_wrow - plines(curwin->w_topline);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tstart_row -= curwin->w_virtcol / curwin->w_width;\n    }\n    if (start_row >= get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill > 0)\n\t    --curwin->w_topfill;\n\telse\n#endif\n\t{\n#ifdef FEAT_FOLDING\n\t    (void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t    ++curwin->w_topline;\n\t}\n\t++curwin->w_botline;\t\t// approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Add one line above \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines above the first one are incredibly high: MAXCOL.\n */\n    static void\ntopline_back(lineoff_T *lp)\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t--lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum < 1)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, &lp->lnum, NULL))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_NOFILL(lp->lnum);\n    }\n}\n\n/*\n * Add one line below \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines below the last one are incredibly high.\n */\n    static void\nbotline_forw(lineoff_T *lp)\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum + 1))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t++lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum > curbuf->b_ml.ml_line_count)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, NULL, &lp->lnum))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_NOFILL(lp->lnum);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Switch from including filler lines below lp->lnum to including filler\n * lines above loff.lnum + 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\nbotline_topline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\t++lp->lnum;\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n    }\n}\n\n/*\n * Switch from including filler lines above lp->lnum to including filler\n * lines below loff.lnum - 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\ntopline_botline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n\t--lp->lnum;\n    }\n}\n#endif\n\n/*\n * Recompute topline to put the cursor at the top of the window.\n * Scroll at least \"min_scroll\" lines.\n * If \"always\" is TRUE, always set topline (for \"zt\").\n */\n    void\nscroll_cursor_top(int min_scroll, int always)\n{\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\tused;\n    int\t\ti;\n    linenr_T\ttop;\t\t// just above displayed lines\n    linenr_T\tbot;\t\t// just below displayed lines\n    linenr_T\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    linenr_T\told_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tnew_topline;\n    int\t\toff = get_scrolloff_value();\n\n    if (mouse_dragging > 0)\n\toff = mouse_dragging - 1;\n\n    /*\n     * Decrease topline until:\n     * - it has become 1\n     * - (part of) the cursor line is moved off the screen or\n     * - moved at least 'scrolljump' lines and\n     * - at least 'scrolloff' lines above and below the cursor\n     */\n    validate_cheight();\n    used = curwin->w_cline_height; // includes filler lines above\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n\tscrolled = used;\n\n#ifdef FEAT_FOLDING\n    if (hasFolding(curwin->w_cursor.lnum, &top, &bot))\n    {\n\t--top;\n\t++bot;\n    }\n    else\n#endif\n    {\n\ttop = curwin->w_cursor.lnum - 1;\n\tbot = curwin->w_cursor.lnum + 1;\n    }\n    new_topline = top + 1;\n\n#ifdef FEAT_DIFF\n    // \"used\" already contains the number of filler lines above, don't add it\n    // again.\n    // Hide filler lines above cursor line by adding them to \"extra\".\n    extra += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    /*\n     * Check if the lines from \"top\" to \"bot\" fit in the window.  If they do,\n     * set new_topline and advance \"top\" and \"bot\" to include more lines.\n     */\n    while (top > 0)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(top, &top, NULL))\n\t    // count one logical line for a sequence of folded lines\n\t    i = 1;\n\telse\n#endif\n\t    i = PLINES_NOFILL(top);\n\tused += i;\n\tif (extra + i <= off && bot < curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(bot, NULL, &bot))\n\t\t// count one logical line for a sequence of folded lines\n\t\t++used;\n\t    else\n#endif\n\t\tused += plines(bot);\n\t}\n\tif (used > curwin->w_height)\n\t    break;\n\tif (top < curwin->w_topline)\n\t    scrolled += i;\n\n\t/*\n\t * If scrolling is needed, scroll at least 'sj' lines.\n\t */\n\tif ((new_topline >= curwin->w_topline || scrolled > min_scroll)\n\t\t&& extra >= off)\n\t    break;\n\n\textra += i;\n\tnew_topline = top;\n\t--top;\n\t++bot;\n    }\n\n    /*\n     * If we don't have enough space, put cursor in the middle.\n     * This makes sure we get the same position when using \"k\" and \"j\"\n     * in a small window.\n     */\n    if (used > curwin->w_height)\n\tscroll_cursor_halfway(FALSE);\n    else\n    {\n\t/*\n\t * If \"always\" is FALSE, only adjust topline to a lower value, higher\n\t * value may happen with wrapping lines\n\t */\n\tif (new_topline < curwin->w_topline || always)\n\t    curwin->w_topline = new_topline;\n\tif (curwin->w_topline > curwin->w_cursor.lnum)\n\t    curwin->w_topline = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill > 0 && extra > off)\n\t{\n\t    curwin->w_topfill -= extra - off;\n\t    if (curwin->w_topfill < 0)\n\t\tcurwin->w_topfill = 0;\n\t}\n\tcheck_topfill(curwin, FALSE);\n#endif\n\tif (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t)\n\t    curwin->w_valid &=\n\t\t      ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\tcurwin->w_valid |= VALID_TOPLINE;\n    }\n}\n\n/*\n * Set w_empty_rows and w_filler_rows for window \"wp\", having used up \"used\"\n * screen lines for text lines.\n */\n    void\nset_empty_rows(win_T *wp, int used)\n{\n#ifdef FEAT_DIFF\n    wp->w_filler_rows = 0;\n#endif\n    if (used == 0)\n\twp->w_empty_rows = 0;\t// single line that doesn't fit\n    else\n    {\n\twp->w_empty_rows = wp->w_height - used;\n#ifdef FEAT_DIFF\n\tif (wp->w_botline <= wp->w_buffer->b_ml.ml_line_count)\n\t{\n\t    wp->w_filler_rows = diff_check_fill(wp, wp->w_botline);\n\t    if (wp->w_empty_rows > wp->w_filler_rows)\n\t\twp->w_empty_rows -= wp->w_filler_rows;\n\t    else\n\t    {\n\t\twp->w_filler_rows = wp->w_empty_rows;\n\t\twp->w_empty_rows = 0;\n\t    }\n\t}\n#endif\n    }\n}\n\n/*\n * Recompute topline to put the cursor at the bottom of the window.\n * Scroll at least \"min_scroll\" lines.\n * If \"set_topbot\" is TRUE, set topline and botline first (for \"zb\").\n * This is messy stuff!!!\n */\n    void\nscroll_cursor_bot(int min_scroll, int set_topbot)\n{\n    int\t\tused;\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\ti;\n    linenr_T\tline_count;\n    linenr_T\told_topline = curwin->w_topline;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n    int\t\tfill_below_window;\n#endif\n    linenr_T\told_botline = curwin->w_botline;\n    linenr_T\told_valid = curwin->w_valid;\n    int\t\told_empty_rows = curwin->w_empty_rows;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    long        so = get_scrolloff_value();\n\n    cln = curwin->w_cursor.lnum;\n    if (set_topbot)\n    {\n\tused = 0;\n\tcurwin->w_botline = cln + 1;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tfor (curwin->w_topline = curwin->w_botline;\n\t\tcurwin->w_topline > 1;\n\t\tcurwin->w_topline = loff.lnum)\n\t{\n\t    loff.lnum = curwin->w_topline;\n\t    topline_back(&loff);\n\t    if (loff.height == MAXCOL || used + loff.height > curwin->w_height)\n\t\tbreak;\n\t    used += loff.height;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = loff.fill;\n#endif\n\t}\n\tset_empty_rows(curwin, used);\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tif (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t)\n\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n    }\n    else\n\tvalidate_botline();\n\n    // The lines of the cursor line itself are always used.\n#ifdef FEAT_DIFF\n    used = plines_nofill(cln);\n#else\n    validate_cheight();\n    used = curwin->w_cline_height;\n#endif\n\n    // If the cursor is below botline, we will at least scroll by the height\n    // of the cursor line.  Correct for empty lines, which are really part of\n    // botline.\n    if (cln >= curwin->w_botline)\n    {\n\tscrolled = used;\n\tif (cln == curwin->w_botline)\n\t    scrolled -= curwin->w_empty_rows;\n    }\n\n    /*\n     * Stop counting lines to scroll when\n     * - hitting start of the file\n     * - scrolled nothing or at least 'sj' lines\n     * - at least 'scrolloff' lines below the cursor\n     * - lines between botline and cursor have been counted\n     */\n#ifdef FEAT_FOLDING\n    if (!hasFolding(curwin->w_cursor.lnum, &loff.lnum, &boff.lnum))\n#endif\n    {\n\tloff.lnum = cln;\n\tboff.lnum = cln;\n    }\n#ifdef FEAT_DIFF\n    loff.fill = 0;\n    boff.fill = 0;\n    fill_below_window = diff_check_fill(curwin, curwin->w_botline)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\n    while (loff.lnum > 1)\n    {\n\t// Stop when scrolled nothing or at least \"min_scroll\", found \"extra\"\n\t// context for 'scrolloff' and counted all lines below the window.\n\tif ((((scrolled <= 0 || scrolled >= min_scroll)\n\t\t    && extra >= (mouse_dragging > 0 ? mouse_dragging - 1 : so))\n\t\t    || boff.lnum + 1 > curbuf->b_ml.ml_line_count)\n\t\t&& loff.lnum <= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum < curwin->w_botline\n\t\t    || loff.fill >= fill_below_window)\n#endif\n\t\t)\n\t    break;\n\n\t// Add one line above\n\ttopline_back(&loff);\n\tif (loff.height == MAXCOL)\n\t    used = MAXCOL;\n\telse\n\t    used += loff.height;\n\tif (used > curwin->w_height)\n\t    break;\n\tif (loff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum > curwin->w_botline\n\t\t    || loff.fill <= fill_below_window)\n#endif\n\t\t)\n\t{\n\t    // Count screen lines that are below the window.\n\t    scrolled += loff.height;\n\t    if (loff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && loff.fill == 0\n#endif\n\t\t    )\n\t\tscrolled -= curwin->w_empty_rows;\n\t}\n\n\tif (boff.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    // Add one line below\n\t    botline_forw(&boff);\n\t    used += boff.height;\n\t    if (used > curwin->w_height)\n\t\tbreak;\n\t    if (extra < ( mouse_dragging > 0 ? mouse_dragging - 1 : so)\n\t\t    || scrolled < min_scroll)\n\t    {\n\t\textra += boff.height;\n\t\tif (boff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t|| (boff.lnum + 1 == curwin->w_botline\n\t\t\t    && boff.fill > curwin->w_filler_rows)\n#endif\n\t\t   )\n\t\t{\n\t\t    // Count screen lines that are below the window.\n\t\t    scrolled += boff.height;\n\t\t    if (boff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && boff.fill == 0\n#endif\n\t\t\t    )\n\t\t\tscrolled -= curwin->w_empty_rows;\n\t\t}\n\t    }\n\t}\n    }\n\n    // curwin->w_empty_rows is larger, no need to scroll\n    if (scrolled <= 0)\n\tline_count = 0;\n    // more than a screenfull, don't scroll but redraw\n    else if (used > curwin->w_height)\n\tline_count = used;\n    // scroll minimal number of lines\n    else\n    {\n\tline_count = 0;\n#ifdef FEAT_DIFF\n\tboff.fill = curwin->w_topfill;\n#endif\n\tboff.lnum = curwin->w_topline - 1;\n\tfor (i = 0; i < scrolled && boff.lnum < curwin->w_botline; )\n\t{\n\t    botline_forw(&boff);\n\t    i += boff.height;\n\t    ++line_count;\n\t}\n\tif (i < scrolled)\t// below curwin->w_botline, don't scroll\n\t    line_count = 9999;\n    }\n\n    /*\n     * Scroll up if the cursor is off the bottom of the screen a bit.\n     * Otherwise put it at 1/2 of the screen.\n     */\n    if (line_count >= curwin->w_height && line_count > min_scroll)\n\tscroll_cursor_halfway(FALSE);\n    else\n\tscrollup(line_count, TRUE);\n\n    /*\n     * If topline didn't change we need to restore w_botline and w_empty_rows\n     * (we changed them).\n     * If topline did change, update_screen() will set botline.\n     */\n    if (curwin->w_topline == old_topline && set_topbot)\n    {\n\tcurwin->w_botline = old_botline;\n\tcurwin->w_empty_rows = old_empty_rows;\n\tcurwin->w_valid = old_valid;\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Recompute topline to put the cursor halfway the window\n * If \"atend\" is TRUE, also put it halfway at the end of the file.\n */\n    void\nscroll_cursor_halfway(int atend)\n{\n    int\t\tabove = 0;\n    linenr_T\ttopline;\n#ifdef FEAT_DIFF\n    int\t\ttopfill = 0;\n#endif\n    int\t\tbelow = 0;\n    int\t\tused;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    linenr_T\told_topline = curwin->w_topline;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    // if the width changed this needs to be updated first\n    may_update_popup_position();\n#endif\n    loff.lnum = boff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n    (void)hasFolding(loff.lnum, &loff.lnum, &boff.lnum);\n#endif\n#ifdef FEAT_DIFF\n    used = plines_nofill(loff.lnum);\n    loff.fill = 0;\n    boff.fill = 0;\n#else\n    used = plines(loff.lnum);\n#endif\n    topline = loff.lnum;\n    while (topline > 1)\n    {\n\tif (below <= above)\t    // add a line below the cursor first\n\t{\n\t    if (boff.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tbotline_forw(&boff);\n\t\tused += boff.height;\n\t\tif (used > curwin->w_height)\n\t\t    break;\n\t\tbelow += boff.height;\n\t    }\n\t    else\n\t    {\n\t\t++below;\t    // count a \"~\" line\n\t\tif (atend)\n\t\t    ++used;\n\t    }\n\t}\n\n\tif (below > above)\t    // add a line above the cursor\n\t{\n\t    topline_back(&loff);\n\t    if (loff.height == MAXCOL)\n\t\tused = MAXCOL;\n\t    else\n\t\tused += loff.height;\n\t    if (used > curwin->w_height)\n\t\tbreak;\n\t    above += loff.height;\n\t    topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t    topfill = loff.fill;\n#endif\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (!hasFolding(topline, &curwin->w_topline, NULL))\n#endif\n\tcurwin->w_topline = topline;\n#ifdef FEAT_DIFF\n    curwin->w_topfill = topfill;\n    if (old_topline > curwin->w_topline + curwin->w_height)\n\tcurwin->w_botfill = FALSE;\n    check_topfill(curwin, FALSE);\n#endif\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Correct the cursor position so that it is in a part of the screen at least\n * 'scrolloff' lines from the top and bottom, if possible.\n * If not possible, put it at the same position as scroll_cursor_halfway().\n * When called topline must be valid!\n */\n    void\ncursor_correct(void)\n{\n    int\t\tabove = 0;\t    // screen lines above topline\n    linenr_T\ttopline;\n    int\t\tbelow = 0;\t    // screen lines below botline\n    linenr_T\tbotline;\n    int\t\tabove_wanted, below_wanted;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    int\t\tmax_off;\n    long        so = get_scrolloff_value();\n\n    /*\n     * How many lines we would like to have above/below the cursor depends on\n     * whether the first/last line of the file is on screen.\n     */\n    above_wanted = so;\n    below_wanted = so;\n    if (mouse_dragging > 0)\n    {\n\tabove_wanted = mouse_dragging - 1;\n\tbelow_wanted = mouse_dragging - 1;\n    }\n    if (curwin->w_topline == 1)\n    {\n\tabove_wanted = 0;\n\tmax_off = curwin->w_height / 2;\n\tif (below_wanted > max_off)\n\t    below_wanted = max_off;\n    }\n    validate_botline();\n    if (curwin->w_botline == curbuf->b_ml.ml_line_count + 1\n\t    && mouse_dragging == 0)\n    {\n\tbelow_wanted = 0;\n\tmax_off = (curwin->w_height - 1) / 2;\n\tif (above_wanted > max_off)\n\t    above_wanted = max_off;\n    }\n\n    /*\n     * If there are sufficient file-lines above and below the cursor, we can\n     * return now.\n     */\n    cln = curwin->w_cursor.lnum;\n    if (cln >= curwin->w_topline + above_wanted\n\t    && cln < curwin->w_botline - below_wanted\n#ifdef FEAT_FOLDING\n\t    && !hasAnyFolding(curwin)\n#endif\n\t    )\n\treturn;\n\n    /*\n     * Narrow down the area where the cursor can be put by taking lines from\n     * the top and the bottom until:\n     * - the desired context lines are found\n     * - the lines from the top is past the lines from the bottom\n     */\n    topline = curwin->w_topline;\n    botline = curwin->w_botline - 1;\n#ifdef FEAT_DIFF\n    // count filler lines as context\n    above = curwin->w_topfill;\n    below = curwin->w_filler_rows;\n#endif\n    while ((above < above_wanted || below < below_wanted) && topline < botline)\n    {\n\tif (below < below_wanted && (below <= above || above >= above_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(botline, &botline, NULL))\n\t\t++below;\n\t    else\n#endif\n\t\tbelow += plines(botline);\n\t    --botline;\n\t}\n\tif (above < above_wanted && (above < below || below >= below_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(topline, NULL, &topline))\n\t\t++above;\n\t    else\n#endif\n\t\tabove += PLINES_NOFILL(topline);\n#ifdef FEAT_DIFF\n\t    // Count filler lines below this line as context.\n\t    if (topline < botline)\n\t\tabove += diff_check_fill(curwin, topline + 1);\n#endif\n\t    ++topline;\n\t}\n    }\n    if (topline == botline || botline == 0)\n\tcurwin->w_cursor.lnum = topline;\n    else if (topline > botline)\n\tcurwin->w_cursor.lnum = botline;\n    else\n    {\n\tif (cln < topline && curwin->w_topline > 1)\n\t{\n\t    curwin->w_cursor.lnum = topline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n\tif (cln > botline && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_cursor.lnum = botline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\nstatic void get_scroll_overlap(lineoff_T *lp, int dir);\n\n/*\n * move screen 'count' pages up or down and update screen\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nonepage(int dir, long count)\n{\n    long\tn;\n    int\t\tretval = OK;\n    lineoff_T\tloff;\n    linenr_T\told_topline = curwin->w_topline;\n    long        so = get_scrolloff_value();\n\n    if (curbuf->b_ml.ml_line_count == 1)    // nothing to do\n    {\n\tbeep_flush();\n\treturn FAIL;\n    }\n\n    for ( ; count > 0; --count)\n    {\n\tvalidate_botline();\n\t/*\n\t * It's an error to move a page up when the first line is already on\n\t * the screen.\tIt's an error to move a page down when the last line\n\t * is on the screen and the topline is 'scrolloff' lines from the\n\t * last line.\n\t */\n\tif (dir == FORWARD\n\t\t? ((curwin->w_topline >= curbuf->b_ml.ml_line_count - so)\n\t\t    && curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t: (curwin->w_topline == 1\n#ifdef FEAT_DIFF\n\t\t    && curwin->w_topfill ==\n\t\t\t\t    diff_check_fill(curwin, curwin->w_topline)\n#endif\n\t\t    ))\n\t{\n\t    beep_flush();\n\t    retval = FAIL;\n\t    break;\n\t}\n\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tif (dir == FORWARD)\n\t{\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling\n\t\tif (p_window <= 2)\n\t\t    ++curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline += p_window - 2;\n\t\tif (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_topline = curbuf->b_ml.ml_line_count;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t    }\n\t    else if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// at end of file\n\t\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t    }\n\t    else\n\t    {\n\t\t// For the overlap, start with the line just below the window\n\t\t// and go upwards.\n\t\tloff.lnum = curwin->w_botline;\n#ifdef FEAT_DIFF\n\t\tloff.fill = diff_check_fill(curwin, loff.lnum)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\t\tget_scroll_overlap(&loff, -1);\n\t\tcurwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = loff.fill;\n\t\tcheck_topfill(curwin, FALSE);\n#endif\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t\tcurwin->w_valid &= ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|\n\t\t\t\t   VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    }\n\t}\n\telse\t// dir == BACKWARDS\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topline == 1)\n\t    {\n\t\t// Include max number of filler lines\n\t\tmax_topfill();\n\t\tcontinue;\n\t    }\n#endif\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling (sort of)\n\t\tif (p_window <= 2)\n\t\t    --curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline -= p_window - 2;\n\t\tif (curwin->w_topline < 1)\n\t\t    curwin->w_topline = 1;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline + p_window - 1;\n\t\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcontinue;\n\t    }\n\n\t    // Find the line at the top of the window that is going to be the\n\t    // line at the bottom of the window.  Make sure this results in\n\t    // the same line as before doing CTRL-F.\n\t    loff.lnum = curwin->w_topline - 1;\n#ifdef FEAT_DIFF\n\t    loff.fill = diff_check_fill(curwin, loff.lnum + 1)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    get_scroll_overlap(&loff, 1);\n\n\t    if (loff.lnum >= curbuf->b_ml.ml_line_count)\n\t    {\n\t\tloff.lnum = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t    }\n\t    else\n\t    {\n\t\tbotline_topline(&loff);\n#endif\n\t    }\n\t    curwin->w_cursor.lnum = loff.lnum;\n\n\t    // Find the line just above the new topline to get the right line\n\t    // at the bottom of the window.\n\t    n = 0;\n\t    while (n <= curwin->w_height && loff.lnum >= 1)\n\t    {\n\t\ttopline_back(&loff);\n\t\tif (loff.height == MAXCOL)\n\t\t    n = MAXCOL;\n\t\telse\n\t\t    n += loff.height;\n\t    }\n\t    if (loff.lnum < 1)\t\t\t// at begin of file\n\t    {\n\t\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\t\tmax_topfill();\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t    }\n\t    else\n\t    {\n\t\t// Go two lines forward again.\n#ifdef FEAT_DIFF\n\t\ttopline_botline(&loff);\n#endif\n\t\tbotline_forw(&loff);\n\t\tbotline_forw(&loff);\n#ifdef FEAT_DIFF\n\t\tbotline_topline(&loff);\n#endif\n#ifdef FEAT_FOLDING\n\t\t// We're at the wrong end of a fold now.\n\t\t(void)hasFolding(loff.lnum, &loff.lnum, NULL);\n#endif\n\n\t\t// Always scroll at least one line.  Avoid getting stuck on\n\t\t// very long lines.\n\t\tif (loff.lnum >= curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum > curwin->w_topline\n\t\t\t    || loff.fill >= curwin->w_topfill)\n#endif\n\t\t\t)\n\t\t{\n#ifdef FEAT_DIFF\n\t\t    // First try using the maximum number of filler lines.  If\n\t\t    // that's not enough, backup one line.\n\t\t    loff.fill = curwin->w_topfill;\n\t\t    if (curwin->w_topfill < diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t\t\tmax_topfill();\n\t\t    if (curwin->w_topfill == loff.fill)\n#endif\n\t\t    {\n\t\t\t--curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\t\tcurwin->w_topfill = 0;\n#endif\n\t\t    }\n\t\t    comp_botline(curwin);\n\t\t    curwin->w_cursor.lnum = curwin->w_botline - 1;\n\t\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|VALID_CROW);\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\t    curwin->w_topfill = loff.fill;\n\t\t    check_topfill(curwin, FALSE);\n#endif\n\t\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t\t}\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    foldAdjustCursor();\n#endif\n    cursor_correct();\n    check_cursor_col();\n    if (retval == OK)\n\tbeginline(BL_SOL | BL_FIX);\n    curwin->w_valid &= ~(VALID_WCOL|VALID_WROW|VALID_VIRTCOL);\n\n    if (retval == OK && dir == FORWARD)\n    {\n\t// Avoid the screen jumping up and down when 'scrolloff' is non-zero.\n\t// But make sure we scroll at least one line (happens with mix of long\n\t// wrapping lines and non-wrapping line).\n\tif (check_top_offset())\n\t{\n\t    scroll_cursor_top(1, FALSE);\n\t    if (curwin->w_topline <= old_topline\n\t\t\t\t  && old_topline < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_topline = old_topline + 1;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    }\n\t}\n#ifdef FEAT_FOLDING\n\telse if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    }\n\n    redraw_later(VALID);\n    return retval;\n}\n\n/*\n * Decide how much overlap to use for page-up or page-down scrolling.\n * This is symmetric, so that doing both keeps the same lines displayed.\n * Three lines are examined:\n *\n *  before CTRL-F\t    after CTRL-F / before CTRL-B\n *     etc.\t\t\tl1\n *  l1 last but one line\t------------\n *  l2 last text line\t\tl2 top text line\n *  -------------\t\tl3 second text line\n *  l3\t\t\t\t   etc.\n */\n    static void\nget_scroll_overlap(lineoff_T *lp, int dir)\n{\n    int\t\th1, h2, h3, h4;\n    int\t\tmin_height = curwin->w_height - 2;\n    lineoff_T\tloff0, loff1, loff2;\n\n#ifdef FEAT_DIFF\n    if (lp->fill > 0)\n\tlp->height = 1;\n    else\n\tlp->height = plines_nofill(lp->lnum);\n#else\n    lp->height = plines(lp->lnum);\n#endif\n    h1 = lp->height;\n    if (h1 > min_height)\n\treturn;\t\t// no overlap\n\n    loff0 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h2 = lp->height;\n    if (h2 == MAXCOL || h2 + h1 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff1 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h3 = lp->height;\n    if (h3 == MAXCOL || h3 + h2 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff2 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h4 = lp->height;\n    if (h4 == MAXCOL || h4 + h3 + h2 > min_height || h3 + h2 + h1 > min_height)\n\t*lp = loff1;\t// 1 line overlap\n    else\n\t*lp = loff2;\t// 2 lines overlap\n}\n\n/*\n * Scroll 'scroll' lines up or down.\n */\n    void\nhalfpage(int flag, linenr_T Prenum)\n{\n    long\tscrolled = 0;\n    int\t\ti;\n    int\t\tn;\n    int\t\troom;\n\n    if (Prenum)\n\tcurwin->w_p_scr = (Prenum > curwin->w_height) ?\n\t\t\t\t\t\tcurwin->w_height : Prenum;\n    n = (curwin->w_p_scr <= curwin->w_height) ?\n\t\t\t\t    curwin->w_p_scr : curwin->w_height;\n\n    update_topline();\n    validate_botline();\n    room = curwin->w_empty_rows;\n#ifdef FEAT_DIFF\n    room += curwin->w_filler_rows;\n#endif\n    if (flag)\n    {\n\t/*\n\t * scroll the text up\n\t */\n\twhile (n > 0 && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t--curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t\t++curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n#endif\n\n\t\tif (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_valid &=\n\t\t\t\t    ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t\t}\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW);\n\t    scrolled += i;\n\n\t    /*\n\t     * Correct w_botline for changed w_topline.\n\t     * Won't work when there are filler lines.\n\t     */\n#ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    else\n#endif\n\t    {\n\t\troom += i;\n\t\tdo\n\t\t{\n\t\t    i = plines(curwin->w_botline);\n\t\t    if (i > room)\n\t\t\tbreak;\n#ifdef FEAT_FOLDING\n\t\t    (void)hasFolding(curwin->w_botline, NULL,\n\t\t\t\t\t\t\t  &curwin->w_botline);\n#endif\n\t\t    ++curwin->w_botline;\n\t\t    room -= i;\n\t\t} while (curwin->w_botline <= curbuf->b_ml.ml_line_count);\n\t    }\n\t}\n\n\t/*\n\t * When hit bottom of the file: move cursor down.\n\t */\n\tif (n > 0)\n\t{\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n\t\t    ++curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum += n;\n\t    check_cursor_lnum();\n\t}\n    }\n    else\n    {\n\t/*\n\t * scroll the text down\n\t */\n\twhile (n > 0 && curwin->w_topline > 1)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill < diff_check_fill(curwin, curwin->w_topline))\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t++curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline - 1);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n\t\t--curwin->w_topline;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW|\n\t\t\t\t\t      VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    scrolled += i;\n\t    if (curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--curwin->w_cursor.lnum;\n\t\tcurwin->w_valid &= ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t    }\n\t}\n\n\t/*\n\t * When hit top of the file: move cursor up.\n\t */\n\tif (n > 0)\n\t{\n\t    if (curwin->w_cursor.lnum <= (linenr_T)n)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0 && curwin->w_cursor.lnum > 1)\n\t\t{\n\t\t    --curwin->w_cursor.lnum;\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum -= n;\n\t}\n    }\n# ifdef FEAT_FOLDING\n    // Move cursor to first line of closed fold.\n    foldAdjustCursor();\n# endif\n#ifdef FEAT_DIFF\n    check_topfill(curwin, !flag);\n#endif\n    cursor_correct();\n    beginline(BL_SOL | BL_FIX);\n    redraw_later(VALID);\n}\n\n    void\ndo_check_cursorbind(void)\n{\n    linenr_T\tline = curwin->w_cursor.lnum;\n    colnr_T\tcol = curwin->w_cursor.col;\n    colnr_T\tcoladd = curwin->w_cursor.coladd;\n    colnr_T\tcurswant = curwin->w_curswant;\n    int\t\tset_curswant = curwin->w_set_curswant;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\trestart_edit_save;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n\n    /*\n     * loop through the cursorbound windows\n     */\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window  and windows with 'noscrollbind'\n\tif (curwin != old_curwin && curwin->w_p_crb)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_cursor.lnum =\n\t\t\t\t diff_get_corresponding_line(old_curbuf, line);\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum = line;\n\t    curwin->w_cursor.col = col;\n\t    curwin->w_cursor.coladd = coladd;\n\t    curwin->w_curswant = curswant;\n\t    curwin->w_set_curswant = set_curswant;\n\n\t    // Make sure the cursor is in a valid position.  Temporarily set\n\t    // \"restart_edit\" to allow the cursor to be beyond the EOL.\n\t    restart_edit_save = restart_edit;\n\t    restart_edit = TRUE;\n\t    check_cursor();\n# ifdef FEAT_SYN_HL\n\t    if (curwin->w_p_cul || curwin->w_p_cuc)\n\t\tvalidate_cursor();\n# endif\n\t    restart_edit = restart_edit_save;\n\t    // Correct cursor for multi-byte character.\n\t    if (has_mbyte)\n\t\tmb_adjust_cursor();\n\t    redraw_later(VALID);\n\n\t    // Only scroll when 'scrollbind' hasn't done this.\n\t    if (!curwin->w_p_scb)\n\t\tupdate_topline();\n\t    curwin->w_redr_status = TRUE;\n\t}\n    }\n\n    /*\n     * reset current-window\n     */\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n", "\" Test for various Normal mode commands\n\nsource shared.vim\nsource check.vim\nsource view_util.vim\n\nfunc Setup_NewWindow()\n  10new\n  call setline(1, range(1,100))\nendfunc\n\nfunc MyFormatExpr()\n  \" Adds '->$' at lines having numbers followed by trailing whitespace\n  for ln in range(v:lnum, v:lnum+v:count-1)\n    let line = getline(ln)\n    if getline(ln) =~# '\\d\\s\\+$'\n      call setline(ln, substitute(line, '\\s\\+$', '', '') . '->$')\n    endif\n  endfor\nendfunc\n\nfunc CountSpaces(type, ...)\n  \" for testing operatorfunc\n  \" will count the number of spaces\n  \" and return the result in g:a\n  let sel_save = &selection\n  let &selection = \"inclusive\"\n  let reg_save = @@\n\n  if a:0  \" Invoked from Visual mode, use gv command.\n    silent exe \"normal! gvy\"\n  elseif a:type == 'line'\n    silent exe \"normal! '[V']y\"\n  else\n    silent exe \"normal! `[v`]y\"\n  endif\n  let g:a=strlen(substitute(@@, '[^ ]', '', 'g'))\n  let &selection = sel_save\n  let @@ = reg_save\nendfunc\n\nfunc OpfuncDummy(type, ...)\n  \" for testing operatorfunc\n  let g:opt=&linebreak\n\n  if a:0  \" Invoked from Visual mode, use gv command.\n    silent exe \"normal! gvy\"\n  elseif a:type == 'line'\n    silent exe \"normal! '[V']y\"\n  else\n    silent exe \"normal! `[v`]y\"\n  endif\n  \" Create a new dummy window\n  new\n  let g:bufnr=bufnr('%')\nendfunc\n\nfunc Test_normal00_optrans()\n  new\n  call append(0, ['1 This is a simple test: abcd', '2 This is the second line', '3 this is the third line'])\n  1\n  exe \"norm! Sfoobar\\<esc>\"\n  call assert_equal(['foobar', '2 This is the second line', '3 this is the third line', ''], getline(1,'$'))\n  2\n  exe \"norm! $vbsone\"\n  call assert_equal(['foobar', '2 This is the second one', '3 this is the third line', ''], getline(1,'$'))\n  norm! VS Second line here\n  call assert_equal(['foobar', ' Second line here', '3 this is the third line', ''], getline(1, '$'))\n  %d\n  call append(0, ['4 This is a simple test: abcd', '5 This is the second line', '6 this is the third line'])\n  call append(0, ['1 This is a simple test: abcd', '2 This is the second line', '3 this is the third line'])\n\n  1\n  norm! 2D\n  call assert_equal(['3 this is the third line', '4 This is a simple test: abcd', '5 This is the second line', '6 this is the third line', ''], getline(1,'$'))\n  set cpo+=#\n  norm! 4D\n  call assert_equal(['', '4 This is a simple test: abcd', '5 This is the second line', '6 this is the third line', ''], getline(1,'$'))\n\n  \" clean up\n  set cpo-=#\n  bw!\nendfunc\n\nfunc Test_normal01_keymodel()\n  call Setup_NewWindow()\n  \" Test 1: depending on 'keymodel' <s-down> does something different\n  50\n  call feedkeys(\"V\\<S-Up>y\", 'tx')\n  call assert_equal(['47', '48', '49', '50'], getline(\"'<\", \"'>\"))\n  set keymodel=startsel\n  50\n  call feedkeys(\"V\\<S-Up>y\", 'tx')\n  call assert_equal(['49', '50'], getline(\"'<\", \"'>\"))\n  \" Start visual mode when keymodel = startsel\n  50\n  call feedkeys(\"\\<S-Up>y\", 'tx')\n  call assert_equal(['49', '5'], getreg(0, 0, 1))\n  \" Use the different Shift special keys\n  50\n  call feedkeys(\"\\<S-Right>\\<S-Left>\\<S-Up>\\<S-Down>\\<S-Home>\\<S-End>y\", 'tx')\n  call assert_equal(['50'], getline(\"'<\", \"'>\"))\n  call assert_equal(['50', ''], getreg(0, 0, 1))\n\n  \" Do not start visual mode when keymodel=\n  set keymodel=\n  50\n  call feedkeys(\"\\<S-Up>y$\", 'tx')\n  call assert_equal(['42'], getreg(0, 0, 1))\n  \" Stop visual mode when keymodel=stopsel\n  set keymodel=stopsel\n  50\n  call feedkeys(\"Vkk\\<Up>yy\", 'tx')\n  call assert_equal(['47'], getreg(0, 0, 1))\n\n  set keymodel=\n  50\n  call feedkeys(\"Vkk\\<Up>yy\", 'tx')\n  call assert_equal(['47', '48', '49', '50'], getreg(0, 0, 1))\n\n  \" Test for using special keys to start visual selection\n  %d\n  call setline(1, ['red fox tail', 'red fox tail', 'red fox tail'])\n  set keymodel=startsel\n  \" Test for <S-PageUp> and <S-PageDown>\n  call cursor(1, 1)\n  call feedkeys(\"\\<S-PageDown>y\", 'xt')\n  call assert_equal([0, 1, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 3, 1, 0], getpos(\"'>\"))\n  call feedkeys(\"Gz\\<CR>8|\\<S-PageUp>y\", 'xt')\n  call assert_equal([0, 2, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 3, 8, 0], getpos(\"'>\"))\n  \" Test for <S-C-Home> and <S-C-End>\n  call cursor(2, 12)\n  call feedkeys(\"\\<S-C-Home>y\", 'xt')\n  call assert_equal([0, 1, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 2, 12, 0], getpos(\"'>\"))\n  call cursor(1, 4)\n  call feedkeys(\"\\<S-C-End>y\", 'xt')\n  call assert_equal([0, 1, 4, 0], getpos(\"'<\"))\n  call assert_equal([0, 3, 13, 0], getpos(\"'>\"))\n  \" Test for <S-C-Left> and <S-C-Right>\n  call cursor(2, 5)\n  call feedkeys(\"\\<S-C-Right>y\", 'xt')\n  call assert_equal([0, 2, 5, 0], getpos(\"'<\"))\n  call assert_equal([0, 2, 9, 0], getpos(\"'>\"))\n  call cursor(2, 9)\n  call feedkeys(\"\\<S-C-Left>y\", 'xt')\n  call assert_equal([0, 2, 5, 0], getpos(\"'<\"))\n  call assert_equal([0, 2, 9, 0], getpos(\"'>\"))\n\n  set keymodel&\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal03_join()\n  \" basic join test\n  call Setup_NewWindow()\n  50\n  norm! VJ\n  call assert_equal('50 51', getline('.'))\n  $\n  norm! J\n  call assert_equal('100', getline('.'))\n  $\n  norm! V9-gJ\n  call assert_equal('919293949596979899100', getline('.'))\n  call setline(1, range(1,100))\n  $\n  :j 10\n  call assert_equal('100', getline('.'))\n  call assert_beeps('normal GVJ')\n  \" clean up\n  bw!\nendfunc\n\n\" basic filter test\nfunc Test_normal04_filter()\n  \" only test on non windows platform\n  CheckNotMSWindows\n  call Setup_NewWindow()\n  1\n  call feedkeys(\"!!sed -e 's/^/|    /'\\n\", 'tx')\n  call assert_equal('|    1', getline('.'))\n  90\n  :sil :!echo one\n  call feedkeys('.', 'tx')\n  call assert_equal('|    90', getline('.'))\n  95\n  set cpo+=!\n  \" 2 <CR>, 1: for executing the command,\n  \"         2: clear hit-enter-prompt\n  call feedkeys(\"!!\\n\", 'tx')\n  call feedkeys(\":!echo one\\n\\n\", 'tx')\n  call feedkeys(\".\", 'tx')\n  call assert_equal('one', getline('.'))\n  set cpo-=!\n  bw!\nendfunc\n\nfunc Test_normal05_formatexpr()\n  \" basic formatexpr test\n  call Setup_NewWindow()\n  %d_\n  call setline(1, ['here: 1   ', '2', 'here: 3   ', '4', 'not here:   '])\n  1\n  set formatexpr=MyFormatExpr()\n  norm! gqG\n  call assert_equal(['here: 1->$', '2', 'here: 3->$', '4', 'not here:   '], getline(1,'$'))\n  set formatexpr=\n  bw!\nendfunc\n\nfunc Test_normal05_formatexpr_newbuf()\n  \" Edit another buffer in the 'formatexpr' function\n  new\n  func! Format()\n    edit another\n  endfunc\n  set formatexpr=Format()\n  norm gqG\n  bw!\n  set formatexpr=\nendfunc\n\nfunc Test_normal05_formatexpr_setopt()\n  \" Change the 'formatexpr' value in the function\n  new\n  func! Format()\n    set formatexpr=\n  endfunc\n  set formatexpr=Format()\n  norm gqG\n  bw!\n  set formatexpr=\nendfunc\n\n\" When 'formatexpr' returns non-zero, internal formatting is used.\nfunc Test_normal_formatexpr_returns_nonzero()\n  new\n  call setline(1, ['one', 'two'])\n  func! Format()\n    return 1\n  endfunc\n  setlocal formatexpr=Format()\n  normal VGgq\n  call assert_equal(['one two'], getline(1, '$'))\n  setlocal formatexpr=\n  delfunc Format\n  close!\nendfunc\n\n\" basic test for formatprg\nfunc Test_normal06_formatprg()\n  \" only test on non windows platform\n  CheckNotMSWindows\n\n  \" uses sed to number non-empty lines\n  call writefile(['#!/bin/sh', 'sed ''/./=''|sed ''/./{', 'N', 's/\\n/    /', '}'''], 'Xsed_format.sh')\n  call system('chmod +x ./Xsed_format.sh')\n  let text = ['a', '', 'c', '', ' ', 'd', 'e']\n  let expected = ['1    a', '', '3    c', '', '5     ', '6    d', '7    e']\n\n  10new\n  call setline(1, text)\n  set formatprg=./Xsed_format.sh\n  norm! gggqG\n  call assert_equal(expected, getline(1, '$'))\n  %d\n\n  call setline(1, text)\n  set formatprg=donothing\n  setlocal formatprg=./Xsed_format.sh\n  norm! gggqG\n  call assert_equal(expected, getline(1, '$'))\n  %d\n\n  \" Check for the command-line ranges added to 'formatprg'\n  set formatprg=cat\n  call setline(1, ['one', 'two', 'three', 'four', 'five'])\n  call feedkeys('gggqG', 'xt')\n  call assert_equal('.,$!cat', @:)\n  call feedkeys('2Ggq2j', 'xt')\n  call assert_equal('.,.+2!cat', @:)\n\n  bw!\n  \" clean up\n  set formatprg=\n  setlocal formatprg=\n  call delete('Xsed_format.sh')\nendfunc\n\nfunc Test_normal07_internalfmt()\n  \" basic test for internal formmatter to textwidth of 12\n  let list=range(1,11)\n  call map(list, 'v:val.\"    \"')\n  10new\n  call setline(1, list)\n  set tw=12\n  norm! ggVGgq\n  call assert_equal(['1    2    3', '4    5    6', '7    8    9', '10    11    '], getline(1, '$'))\n  \" clean up\n  set tw=0\n  bw!\nendfunc\n\n\" basic tests for foldopen/folddelete\nfunc Test_normal08_fold()\n  CheckFeature folding\n  call Setup_NewWindow()\n  50\n  setl foldenable fdm=marker\n  \" First fold\n  norm! V4jzf\n  \" check that folds have been created\n  call assert_equal(['50/*{{{*/', '51', '52', '53', '54/*}}}*/'], getline(50,54))\n  \" Second fold\n  46\n  norm! V10jzf\n  \" check that folds have been created\n  call assert_equal('46/*{{{*/', getline(46))\n  call assert_equal('60/*}}}*/', getline(60))\n  norm! k\n  call assert_equal('45', getline('.'))\n  norm! j\n  call assert_equal('46/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('61', getline('.'))\n  norm! k\n  \" open a fold\n  norm! Vzo\n  norm! k\n  call assert_equal('45', getline('.'))\n  norm! j\n  call assert_equal('46/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('47', getline('.'))\n  norm! k\n  norm! zcVzO\n  call assert_equal('46/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('47', getline('.'))\n  norm! j\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51', getline('.'))\n  \" delete folds\n  :46\n  \" collapse fold\n  norm! V14jzC\n  \" delete all folds recursively\n  norm! VzD\n  call assert_equal(['46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '60'], getline(46,60))\n\n  \" clean up\n  setl nofoldenable fdm=marker\n  bw!\nendfunc\n\nfunc Test_normal09_operatorfunc()\n  \" Test operatorfunc\n  call Setup_NewWindow()\n  \" Add some spaces for counting\n  50,60s/$/  /\n  unlet! g:a\n  let g:a=0\n  nmap <buffer><silent> ,, :set opfunc=CountSpaces<CR>g@\n  vmap <buffer><silent> ,, :<C-U>call CountSpaces(visualmode(), 1)<CR>\n  50\n  norm V2j,,\n  call assert_equal(6, g:a)\n  norm V,,\n  call assert_equal(2, g:a)\n  norm ,,l\n  call assert_equal(0, g:a)\n  50\n  exe \"norm 0\\<c-v>10j2l,,\"\n  call assert_equal(11, g:a)\n  50\n  norm V10j,,\n  call assert_equal(22, g:a)\n\n  \" clean up\n  unmap <buffer> ,,\n  set opfunc=\n  unlet! g:a\n  bw!\nendfunc\n\nfunc Test_normal09a_operatorfunc()\n  \" Test operatorfunc\n  call Setup_NewWindow()\n  \" Add some spaces for counting\n  50,60s/$/  /\n  unlet! g:opt\n  set linebreak\n  nmap <buffer><silent> ,, :set opfunc=OpfuncDummy<CR>g@\n  50\n  norm ,,j\n  exe \"bd!\" g:bufnr\n  call assert_true(&linebreak)\n  call assert_equal(g:opt, &linebreak)\n  set nolinebreak\n  norm ,,j\n  exe \"bd!\" g:bufnr\n  call assert_false(&linebreak)\n  call assert_equal(g:opt, &linebreak)\n\n  \" clean up\n  unmap <buffer> ,,\n  set opfunc=\n  call assert_fails('normal Vg@', 'E774:')\n  bw!\n  unlet! g:opt\nendfunc\n\nfunc Test_normal10_expand()\n  \" Test for expand()\n  10new\n  call setline(1, ['1', 'ifooar,,cbar'])\n  2\n  norm! $\n  call assert_equal('cbar', expand('<cword>'))\n  call assert_equal('ifooar,,cbar', expand('<cWORD>'))\n\n  call setline(1, ['prx = list[idx];'])\n  1\n  let expected = ['', 'prx', 'prx', 'prx',\n\t\\ 'list', 'list', 'list', 'list', 'list', 'list', 'list',\n\t\\ 'idx', 'idx', 'idx', 'idx',\n\t\\ 'list[idx]',\n\t\\ '];',\n\t\\ ]\n  for i in range(1, 16)\n    exe 'norm ' . i . '|'\n    call assert_equal(expected[i], expand('<cexpr>'), 'i == ' . i)\n  endfor\n\n  \" Test for <cexpr> in state.val and ptr->val\n  call setline(1, 'x = state.val;')\n  call cursor(1, 10)\n  call assert_equal('state.val', expand('<cexpr>'))\n  call setline(1, 'x = ptr->val;')\n  call cursor(1, 9)\n  call assert_equal('ptr->val', expand('<cexpr>'))\n\n  if executable('echo')\n    \" Test expand(`...`) i.e. backticks command expansion.\n    call assert_equal('abcde', expand('`echo abcde`'))\n  endif\n\n  \" Test expand(`=...`) i.e. backticks expression expansion\n  call assert_equal('5', expand('`=2+3`'))\n  call assert_equal('3.14', expand('`=3.14`'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for expand() in latin1 encoding\nfunc Test_normal_expand_latin1()\n  new\n  let save_enc = &encoding\n  set encoding=latin1\n  call setline(1, 'val = item->color;')\n  call cursor(1, 11)\n  call assert_equal('color', expand(\"<cword>\"))\n  call assert_equal('item->color', expand(\"<cexpr>\"))\n  let &encoding = save_enc\n  bw!\nendfunc\n\nfunc Test_normal11_showcmd()\n  \" test for 'showcmd'\n  10new\n  exe \"norm! ofoobar\\<esc>\"\n  call assert_equal(2, line('$'))\n  set showcmd\n  exe \"norm! ofoobar2\\<esc>\"\n  call assert_equal(3, line('$'))\n  exe \"norm! VAfoobar3\\<esc>\"\n  call assert_equal(3, line('$'))\n  exe \"norm! 0d3\\<del>2l\"\n  call assert_equal('obar2foobar3', getline('.'))\n  \" test for the visual block size displayed in the status line\n  call setline(1, ['aaaaa', 'bbbbb', 'ccccc'])\n  call feedkeys(\"ggl\\<C-V>lljj\", 'xt')\n  redraw!\n  call assert_match('3x3$', Screenline(&lines))\n  call feedkeys(\"\\<C-V>\", 'xt')\n  \" test for visually selecting a multi-byte character\n  call setline(1, [\"\\U2206\"])\n  call feedkeys(\"ggv\", 'xt')\n  redraw!\n  call assert_match('1-3$', Screenline(&lines))\n  call feedkeys(\"v\", 'xt')\n  \" test for visually selecting the end of line\n  call setline(1, [\"foobar\"])\n  call feedkeys(\"$vl\", 'xt')\n  redraw!\n  call assert_match('2$', Screenline(&lines))\n  call feedkeys(\"y\", 'xt')\n  call assert_equal(\"r\\n\", @\")\n  bw!\nendfunc\n\n\" Test for nv_error and normal command errors\nfunc Test_normal12_nv_error()\n  10new\n  call setline(1, range(1,5))\n  \" should not do anything, just beep\n  call assert_beeps('exe \"norm! <c-k>\"')\n  call assert_equal(map(range(1,5), 'string(v:val)'), getline(1,'$'))\n  call assert_beeps('normal! G2dd')\n  call assert_beeps(\"normal! g\\<C-A>\")\n  call assert_beeps(\"normal! g\\<C-X>\")\n  call assert_beeps(\"normal! g\\<C-B>\")\n  call assert_beeps(\"normal! vQ\\<Esc>\")\n  call assert_beeps(\"normal! 2[[\")\n  call assert_beeps(\"normal! 2]]\")\n  call assert_beeps(\"normal! 2[]\")\n  call assert_beeps(\"normal! 2][\")\n  call assert_beeps(\"normal! 4[z\")\n  call assert_beeps(\"normal! 4]z\")\n  call assert_beeps(\"normal! 4[c\")\n  call assert_beeps(\"normal! 4]c\")\n  call assert_beeps(\"normal! 200%\")\n  call assert_beeps(\"normal! %\")\n  call assert_beeps(\"normal! 2{\")\n  call assert_beeps(\"normal! 2}\")\n  call assert_beeps(\"normal! r\\<Right>\")\n  call assert_beeps(\"normal! 8ry\")\n  call assert_beeps('normal! \"@')\n  bw!\nendfunc\n\nfunc Test_normal13_help()\n  \" Test for F1\n  call assert_equal(1, winnr())\n  call feedkeys(\"\\<f1>\", 'txi')\n  call assert_match('help\\.txt', bufname('%'))\n  call assert_equal(2, winnr('$'))\n  bw!\nendfunc\n\nfunc Test_normal14_page()\n  \" basic test for Ctrl-F and Ctrl-B\n  call Setup_NewWindow()\n  exe \"norm! \\<c-f>\"\n  call assert_equal('9', getline('.'))\n  exe \"norm! 2\\<c-f>\"\n  call assert_equal('25', getline('.'))\n  exe \"norm! 2\\<c-b>\"\n  call assert_equal('18', getline('.'))\n  1\n  set scrolloff=5\n  exe \"norm! 2\\<c-f>\"\n  call assert_equal('21', getline('.'))\n  exe \"norm! \\<c-b>\"\n  call assert_equal('13', getline('.'))\n  1\n  set scrolloff=99\n  exe \"norm! \\<c-f>\"\n  call assert_equal('13', getline('.'))\n  set scrolloff=0\n  100\n  exe \"norm! $\\<c-b>\"\n  call assert_equal('92', getline('.'))\n  call assert_equal([0, 92, 1, 0, 1], getcurpos())\n  100\n  set nostartofline\n  exe \"norm! $\\<c-b>\"\n  call assert_equal('92', getline('.'))\n  call assert_equal([0, 92, 2, 0, 2147483647], getcurpos())\n  \" cleanup\n  set startofline\n  bw!\nendfunc\n\nfunc Test_normal14_page_eol()\n  10new\n  norm oxxxxxxx\n  exe \"norm 2\\<c-f>\"\n  \" check with valgrind that cursor is put back in column 1\n  exe \"norm 2\\<c-b>\"\n  bw!\nendfunc\n\n\" Test for errors with z command\nfunc Test_normal_z_error()\n  call assert_beeps('normal! z2p')\n  call assert_beeps('normal! zq')\nendfunc\n\nfunc Test_normal15_z_scroll_vert()\n  \" basic test for z commands that scroll the window\n  call Setup_NewWindow()\n  100\n  norm! >>\n  \" Test for z<cr>\n  exe \"norm! z\\<cr>\"\n  call assert_equal('\t100', getline('.'))\n  call assert_equal(100, winsaveview()['topline'])\n  call assert_equal([0, 100, 2, 0, 9], getcurpos())\n\n  \" Test for zt\n  21\n  norm! >>0zt\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 21, 1, 0, 8], getcurpos())\n\n  \" Test for zb\n  30\n  norm! >>$ztzb\n  call assert_equal('\t30', getline('.'))\n  call assert_equal(30, winsaveview()['topline']+winheight(0)-1)\n  call assert_equal([0, 30, 3, 0, 2147483647], getcurpos())\n\n  \" Test for z-\n  1\n  30\n  norm! 0z-\n  call assert_equal('\t30', getline('.'))\n  call assert_equal(30, winsaveview()['topline']+winheight(0)-1)\n  call assert_equal([0, 30, 2, 0, 9], getcurpos())\n\n  \" Test for z{height}<cr>\n  call assert_equal(10, winheight(0))\n  exe \"norm! z12\\<cr>\"\n  call assert_equal(12, winheight(0))\n  exe \"norm! z10\\<cr>\"\n  call assert_equal(10, winheight(0))\n\n  \" Test for z.\n  1\n  21\n  norm! 0z.\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(17, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for zz\n  1\n  21\n  norm! 0zz\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(17, winsaveview()['topline'])\n  call assert_equal([0, 21, 1, 0, 8], getcurpos())\n\n  \" Test for z+\n  11\n  norm! zt\n  norm! z+\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for [count]z+\n  1\n  norm! 21z+\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for z+ with [count] greater than buffer size\n  1\n  norm! 1000z+\n  call assert_equal('\t100', getline('.'))\n  call assert_equal(100, winsaveview()['topline'])\n  call assert_equal([0, 100, 2, 0, 9], getcurpos())\n\n  \" Test for z+ from the last buffer line\n  norm! Gz.z+\n  call assert_equal('\t100', getline('.'))\n  call assert_equal(100, winsaveview()['topline'])\n  call assert_equal([0, 100, 2, 0, 9], getcurpos())\n\n  \" Test for z^\n  norm! 22z+0\n  norm! z^\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(12, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for z^ from first buffer line\n  norm! ggz^\n  call assert_equal('1', getline('.'))\n  call assert_equal(1, winsaveview()['topline'])\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n\n  \" Test for [count]z^\n  1\n  norm! 30z^\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(12, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" cleanup\n  bw!\nendfunc\n\nfunc Test_normal16_z_scroll_hor()\n  \" basic test for z commands that scroll the window\n  10new\n  15vsp\n  set nowrap listchars=\n  let lineA='abcdefghijklmnopqrstuvwxyz'\n  let lineB='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  $put =lineA\n  $put =lineB\n  1d\n\n  \" Test for zl and zh with a count\n  norm! 0z10l\n  call assert_equal([11, 1], [col('.'), wincol()])\n  norm! z4h\n  call assert_equal([11, 5], [col('.'), wincol()])\n  normal! 2gg\n\n  \" Test for zl\n  1\n  norm! 5zl\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(6, col('.'))\n  call assert_equal(5, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('f', @0)\n\n  \" Test for zh\n  norm! 2zh\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(6, col('.'))\n  norm! yl\n  call assert_equal('f', @0)\n  call assert_equal(3, winsaveview()['leftcol'])\n\n  \" Test for zL\n  norm! zL\n  call assert_equal(11, col('.'))\n  norm! yl\n  call assert_equal('k', @0)\n  call assert_equal(10, winsaveview()['leftcol'])\n  norm! 2zL\n  call assert_equal(25, col('.'))\n  norm! yl\n  call assert_equal('y', @0)\n  call assert_equal(24, winsaveview()['leftcol'])\n\n  \" Test for zH\n  norm! 2zH\n  call assert_equal(25, col('.'))\n  call assert_equal(10, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('y', @0)\n\n  \" Test for zs\n  norm! $zs\n  call assert_equal(26, col('.'))\n  call assert_equal(25, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" Test for ze\n  norm! ze\n  call assert_equal(26, col('.'))\n  call assert_equal(11, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" Test for zs and ze with folds\n  %fold\n  norm! $zs\n  call assert_equal(26, col('.'))\n  call assert_equal(0, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n  norm! ze\n  call assert_equal(26, col('.'))\n  call assert_equal(0, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" cleanup\n  set wrap listchars=eol:$\n  bw!\nendfunc\n\nfunc Test_normal17_z_scroll_hor2()\n  \" basic test for z commands that scroll the window\n  \" using 'sidescrolloff' setting\n  10new\n  20vsp\n  set nowrap listchars= sidescrolloff=5\n  let lineA='abcdefghijklmnopqrstuvwxyz'\n  let lineB='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  $put =lineA\n  $put =lineB\n  1d\n\n  \" Test for zl\n  1\n  norm! 5zl\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(11, col('.'))\n  call assert_equal(5, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('k', @0)\n\n  \" Test for zh\n  norm! 2zh\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(11, col('.'))\n  norm! yl\n  call assert_equal('k', @0)\n  call assert_equal(3, winsaveview()['leftcol'])\n\n  \" Test for zL\n  norm! 0zL\n  call assert_equal(16, col('.'))\n  norm! yl\n  call assert_equal('p', @0)\n  call assert_equal(10, winsaveview()['leftcol'])\n  norm! 2zL\n  call assert_equal(26, col('.'))\n  norm! yl\n  call assert_equal('z', @0)\n  call assert_equal(15, winsaveview()['leftcol'])\n\n  \" Test for zH\n  norm! 2zH\n  call assert_equal(15, col('.'))\n  call assert_equal(0, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('o', @0)\n\n  \" Test for zs\n  norm! $zs\n  call assert_equal(26, col('.'))\n  call assert_equal(20, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" Test for ze\n  norm! ze\n  call assert_equal(26, col('.'))\n  call assert_equal(11, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" cleanup\n  set wrap listchars=eol:$ sidescrolloff=0\n  bw!\nendfunc\n\n\" Test for commands that scroll the window horizontally. Test with folds.\n\"   H, M, L, CTRL-E, CTRL-Y, CTRL-U, CTRL-D, PageUp, PageDown commands\nfunc Test_vert_scroll_cmds()\n  15new\n  call setline(1, range(1, 100))\n  exe \"normal! 30ggz\\<CR>\"\n  set foldenable\n  33,36fold\n  40,43fold\n  46,49fold\n  let h = winheight(0)\n\n  \" Test for H, M and L commands\n  \" Top of the screen = 30\n  \" Folded lines = 9\n  \" Bottom of the screen = 30 + h + 9 - 1\n  normal! 4L\n  call assert_equal(35 + h, line('.'))\n  normal! 4H\n  call assert_equal(33, line('.'))\n\n  \" Test for using a large count value\n  %d\n  call setline(1, range(1, 4))\n  norm! 6H\n  call assert_equal(4, line('.'))\n\n  \" Test for 'M' with folded lines\n  %d\n  call setline(1, range(1, 20))\n  1,5fold\n  norm! LM\n  call assert_equal(12, line('.'))\n\n  \" Test for the CTRL-E and CTRL-Y commands with folds\n  %d\n  call setline(1, range(1, 10))\n  3,5fold\n  exe \"normal 6G3\\<C-E>\"\n  call assert_equal(6, line('w0'))\n  exe \"normal 2\\<C-Y>\"\n  call assert_equal(2, line('w0'))\n\n  \" Test for CTRL-Y on a folded line\n  %d\n  call setline(1, range(1, 100))\n  exe (h + 2) .. \",\" .. (h + 4) .. \"fold\"\n  exe h + 5\n  normal z-\n  exe \"normal \\<C-Y>\\<C-Y>\"\n  call assert_equal(h + 1, line('w$'))\n\n  \" Test for CTRL-Y from the first line and CTRL-E from the last line\n  %d\n  set scrolloff=2\n  call setline(1, range(1, 4))\n  exe \"normal gg\\<C-Y>\"\n  call assert_equal(1, line('w0'))\n  call assert_equal(1, line('.'))\n  exe \"normal G4\\<C-E>\\<C-E>\"\n  call assert_equal(4, line('w$'))\n  call assert_equal(4, line('.'))\n  set scrolloff&\n\n  \" Using <PageUp> and <PageDown> in an empty buffer should beep\n  %d\n  call assert_beeps('exe \"normal \\<PageUp>\"')\n  call assert_beeps('exe \"normal \\<C-B>\"')\n  call assert_beeps('exe \"normal \\<PageDown>\"')\n  call assert_beeps('exe \"normal \\<C-F>\"')\n\n  \" Test for <C-U> and <C-D> with fold\n  %d\n  call setline(1, range(1, 100))\n  10,35fold\n  set scroll=10\n  exe \"normal \\<C-D>\"\n  call assert_equal(36, line('.'))\n  exe \"normal \\<C-D>\"\n  call assert_equal(46, line('.'))\n  exe \"normal \\<C-U>\"\n  call assert_equal(36, line('.'))\n  exe \"normal \\<C-U>\"\n  call assert_equal(10, line('.'))\n  exe \"normal \\<C-U>\"\n  call assert_equal(1, line('.'))\n  set scroll&\n\n  \" Test for scrolling to the top of the file with <C-U> and a fold\n  10\n  normal ztL\n  exe \"normal \\<C-U>\\<C-U>\"\n  call assert_equal(1, line('w0'))\n\n  \" Test for CTRL-D on a folded line\n  %d\n  call setline(1, range(1, 100))\n  50,100fold\n  75\n  normal z-\n  exe \"normal \\<C-D>\"\n  call assert_equal(50, line('.'))\n  call assert_equal(100, line('w$'))\n  normal z.\n  let lnum = winline()\n  exe \"normal \\<C-D>\"\n  call assert_equal(lnum, winline())\n  call assert_equal(50, line('.'))\n  normal zt\n  exe \"normal \\<C-D>\"\n  call assert_equal(50, line('w0'))\n\n  \" Test for <S-CR>. Page down.\n  %d\n  call setline(1, range(1, 100))\n  call feedkeys(\"\\<S-CR>\", 'xt')\n  call assert_equal(14, line('w0'))\n  call assert_equal(28, line('w$'))\n\n  \" Test for <S-->. Page up.\n  call feedkeys(\"\\<S-->\", 'xt')\n  call assert_equal(1, line('w0'))\n  call assert_equal(15, line('w$'))\n\n  set foldenable&\n  close!\nendfunc\n\n\" Test for the 'sidescroll' option\nfunc Test_sidescroll_opt()\n  new\n  20vnew\n\n  \" scroll by 2 characters horizontally\n  set sidescroll=2 nowrap\n  call setline(1, repeat('a', 40))\n  normal g$l\n  call assert_equal(19, screenpos(0, 1, 21).col)\n  normal l\n  call assert_equal(20, screenpos(0, 1, 22).col)\n  normal g0h\n  call assert_equal(2, screenpos(0, 1, 2).col)\n  call assert_equal(20, screenpos(0, 1, 20).col)\n\n  \" when 'sidescroll' is 0, cursor positioned at the center\n  set sidescroll=0\n  normal g$l\n  call assert_equal(11, screenpos(0, 1, 21).col)\n  normal g0h\n  call assert_equal(10, screenpos(0, 1, 10).col)\n\n  %bw!\n  set wrap& sidescroll&\nendfunc\n\n\" basic tests for foldopen/folddelete\nfunc Test_normal18_z_fold()\n  CheckFeature folding\n  call Setup_NewWindow()\n  50\n  setl foldenable fdm=marker foldlevel=5\n\n  call assert_beeps('normal! zj')\n  call assert_beeps('normal! zk')\n\n  \" Test for zF\n  \" First fold\n  norm! 4zF\n  \" check that folds have been created\n  call assert_equal(['50/*{{{*/', '51', '52', '53/*}}}*/'], getline(50,53))\n\n  \" Test for zd\n  51\n  norm! 2zF\n  call assert_equal(2, foldlevel('.'))\n  norm! kzd\n  call assert_equal(['50', '51/*{{{*/', '52/*}}}*/', '53'], getline(50,53))\n  norm! j\n  call assert_equal(1, foldlevel('.'))\n\n  \" Test for zD\n  \" also deletes partially selected folds recursively\n  51\n  norm! zF\n  call assert_equal(2, foldlevel('.'))\n  norm! kV2jzD\n  call assert_equal(['50', '51', '52', '53'], getline(50,53))\n\n  \" Test for zE\n  85\n  norm! 4zF\n  86\n  norm! 2zF\n  90\n  norm! 4zF\n  call assert_equal(['85/*{{{*/', '86/*{{{*/', '87/*}}}*/', '88/*}}}*/', '89', '90/*{{{*/', '91', '92', '93/*}}}*/'], getline(85,93))\n  norm! zE\n  call assert_equal(['85', '86', '87', '88', '89', '90', '91', '92', '93'], getline(85,93))\n\n  \" Test for zn\n  50\n  set foldlevel=0\n  norm! 2zF\n  norm! zn\n  norm! k\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  call assert_equal(0, &foldenable)\n\n  \" Test for zN\n  49\n  norm! zN\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  call assert_equal(1, &foldenable)\n\n  \" Test for zi\n  norm! zi\n  call assert_equal(0, &foldenable)\n  norm! zi\n  call assert_equal(1, &foldenable)\n  norm! zi\n  call assert_equal(0, &foldenable)\n  norm! zi\n  call assert_equal(1, &foldenable)\n\n  \" Test for za\n  50\n  norm! za\n  norm! k\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  50\n  norm! za\n  norm! k\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  49\n  norm! 5zF\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n  49\n  norm! za\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  set nofoldenable\n  \" close fold and set foldenable\n  norm! za\n  call assert_equal(1, &foldenable)\n\n  50\n  \" have to use {count}za to open all folds and make the cursor visible\n  norm! 2za\n  norm! 2k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" Test for zA\n  49\n  set foldlevel=0\n  50\n  norm! zA\n  norm! 2k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" zA on a opened fold when foldenable is not set\n  50\n  set nofoldenable\n  norm! zA\n  call assert_equal(1, &foldenable)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zc\n  norm! zE\n  50\n  norm! 2zF\n  49\n  norm! 5zF\n  set nofoldenable\n  50\n  \" There most likely is a bug somewhere:\n  \" https://groups.google.com/d/msg/vim_dev/v2EkfJ_KQjI/u-Cvv94uCAAJ\n  \" TODO: Should this only close the inner most fold or both folds?\n  norm! zc\n  call assert_equal(1, &foldenable)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n  set nofoldenable\n  50\n  norm! Vjzc\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zC\n  set nofoldenable\n  50\n  norm! zCk\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zx\n  \" 1) close folds at line 49-54\n  set nofoldenable\n  48\n  norm! zx\n  call assert_equal(1, &foldenable)\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" 2) do not close fold under cursor\n  51\n  set nofoldenable\n  norm! zx\n  call assert_equal(1, &foldenable)\n  norm! 3k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  norm! j\n  call assert_equal('53', getline('.'))\n  norm! j\n  call assert_equal('54/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" 3) close one level of folds\n  48\n  set nofoldenable\n  set foldlevel=1\n  norm! zx\n  call assert_equal(1, &foldenable)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  norm! j\n  call assert_equal('53', getline('.'))\n  norm! j\n  call assert_equal('54/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zX\n  \" Close all folds\n  set foldlevel=0 nofoldenable\n  50\n  norm! zX\n  call assert_equal(1, &foldenable)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zm\n  50\n  set nofoldenable foldlevel=2\n  norm! zm\n  call assert_equal(1, &foldenable)\n  call assert_equal(1, &foldlevel)\n  norm! zm\n  call assert_equal(0, &foldlevel)\n  norm! zm\n  call assert_equal(0, &foldlevel)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zm with a count\n  50\n  set foldlevel=2\n  norm! 3zm\n  call assert_equal(0, &foldlevel)\n  call assert_equal(49, foldclosed(line('.')))\n\n  \" Test for zM\n  48\n  set nofoldenable foldlevel=99\n  norm! zM\n  call assert_equal(1, &foldenable)\n  call assert_equal(0, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zr\n  48\n  set nofoldenable foldlevel=0\n  norm! zr\n  call assert_equal(0, &foldenable)\n  call assert_equal(1, &foldlevel)\n  set foldlevel=0 foldenable\n  norm! zr\n  call assert_equal(1, &foldenable)\n  call assert_equal(1, &foldlevel)\n  norm! zr\n  call assert_equal(2, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" Test for zR\n  48\n  set nofoldenable foldlevel=0\n  norm! zR\n  call assert_equal(0, &foldenable)\n  call assert_equal(2, &foldlevel)\n  set foldenable foldlevel=0\n  norm! zR\n  call assert_equal(1, &foldenable)\n  call assert_equal(2, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  call append(50, ['a /*{{{*/', 'b /*}}}*/'])\n  48\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('a /*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  48\n  norm! zR\n  call assert_equal(1, &foldenable)\n  call assert_equal(3, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('a /*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('b /*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" clean up\n  setl nofoldenable fdm=marker foldlevel=0\n  bw!\nendfunc\n\nfunc Test_normal20_exmode()\n  \" Reading from redirected file doesn't work on MS-Windows\n  CheckNotMSWindows\n  call writefile(['1a', 'foo', 'bar', '.', 'w! Xfile2', 'q!'], 'Xscript')\n  call writefile(['1', '2'], 'Xfile')\n  call system(GetVimCommand() .. ' -e -s < Xscript Xfile')\n  let a=readfile('Xfile2')\n  call assert_equal(['1', 'foo', 'bar', '2'], a)\n\n  \" clean up\n  for file in ['Xfile', 'Xfile2', 'Xscript']\n    call delete(file)\n  endfor\n  bw!\nendfunc\n\nfunc Test_normal21_nv_hat()\n\n  \" Edit a fresh file and wipe the buffer list so that there is no alternate\n  \" file present.  Next, check for the expected command failures.\n  edit Xfoo | %bw\n  call assert_fails(':buffer #', 'E86:')\n  call assert_fails(':execute \"normal! \\<C-^>\"', 'E23:')\n  call assert_fails(\"normal i\\<C-R>#\", 'E23:')\n\n  \" Test for the expected behavior when switching between two named buffers.\n  edit Xfoo | edit Xbar\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('Xfoo', fnamemodify(bufname('%'), ':t'))\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('Xbar', fnamemodify(bufname('%'), ':t'))\n\n  \" Test for the expected behavior when only one buffer is named.\n  enew | let l:nr = bufnr('%')\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('Xbar', fnamemodify(bufname('%'), ':t'))\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('', bufname('%'))\n  call assert_equal(l:nr, bufnr('%'))\n\n  \" Test that no action is taken by \"<C-^>\" when an operator is pending.\n  edit Xfoo\n  call feedkeys(\"ci\\<C-^>\", 'tx')\n  call assert_equal('Xfoo', fnamemodify(bufname('%'), ':t'))\n\n  %bw!\nendfunc\n\nfunc Test_normal22_zet()\n  \" Test for ZZ\n  \" let shell = &shell\n  \" let &shell = 'sh'\n  call writefile(['1', '2'], 'Xfile')\n  let args = ' -N -i NONE --noplugins -X --not-a-term'\n  call system(GetVimCommand() .. args .. ' -c \"%d\" -c \":norm! ZZ\" Xfile')\n  let a = readfile('Xfile')\n  call assert_equal([], a)\n  \" Test for ZQ\n  call writefile(['1', '2'], 'Xfile')\n  call system(GetVimCommand() . args . ' -c \"%d\" -c \":norm! ZQ\" Xfile')\n  let a = readfile('Xfile')\n  call assert_equal(['1', '2'], a)\n\n  \" Unsupported Z command\n  call assert_beeps('normal! ZW')\n\n  \" clean up\n  for file in ['Xfile']\n    call delete(file)\n  endfor\n  \" let &shell = shell\nendfunc\n\nfunc Test_normal23_K()\n  \" Test for K command\n  new\n  call append(0, ['version8.txt', 'man', 'aa%bb', 'cc|dd'])\n  let k = &keywordprg\n  set keywordprg=:help\n  1\n  norm! VK\n  call assert_equal('version8.txt', fnamemodify(bufname('%'), ':t'))\n  call assert_equal('help', &ft)\n  call assert_match('\\*version8.txt\\*', getline('.'))\n  helpclose\n  norm! 0K\n  call assert_equal('version8.txt', fnamemodify(bufname('%'), ':t'))\n  call assert_equal('help', &ft)\n  call assert_match('\\*version8\\.\\d\\*', getline('.'))\n  helpclose\n\n  set keywordprg=:new\n  set iskeyword+=%\n  set iskeyword+=\\|\n  2\n  norm! K\n  call assert_equal('man', fnamemodify(bufname('%'), ':t'))\n  bwipe!\n  3\n  norm! K\n  call assert_equal('aa%bb', fnamemodify(bufname('%'), ':t'))\n  bwipe!\n  if !has('win32')\n    4\n    norm! K\n    call assert_equal('cc|dd', fnamemodify(bufname('%'), ':t'))\n    bwipe!\n  endif\n  set iskeyword-=%\n  set iskeyword-=\\|\n\n  \" Test for specifying a count to K\n  1\n  com! -nargs=* Kprog let g:Kprog_Args = <q-args>\n  set keywordprg=:Kprog\n  norm! 3K\n  call assert_equal('3 version8', g:Kprog_Args)\n  delcom Kprog\n\n  \" Only expect \"man\" to work on Unix\n  if !has(\"unix\")\n    let &keywordprg = k\n    bw!\n    return\n  endif\n\n  let not_gnu_man = has('mac') || has('bsd')\n  if not_gnu_man\n    \" In MacOS and BSD, the option for specifying a pager is different\n    set keywordprg=man\\ -P\\ cat\n  else\n    set keywordprg=man\\ --pager=cat\n  endif\n  \" Test for using man\n  2\n  let a = execute('unsilent norm! K')\n  if not_gnu_man\n    call assert_match(\"man -P cat 'man'\", a)\n  else\n    call assert_match(\"man --pager=cat 'man'\", a)\n  endif\n\n  \" Error cases\n  call setline(1, '#$#')\n  call assert_fails('normal! ggK', 'E349:')\n  call setline(1, '---')\n  call assert_fails('normal! ggv2lK', 'E349:')\n  call setline(1, ['abc', 'xyz'])\n  call assert_fails(\"normal! gg2lv2h\\<C-]>\", 'E433:')\n  call assert_beeps(\"normal! ggVjK\")\n  norm! V\n  call assert_beeps(\"norm! cK\")\n\n  \" clean up\n  let &keywordprg = k\n  bw!\nendfunc\n\nfunc Test_normal24_rot13()\n  \" Testing for g?? g?g?\n  new\n  call append(0, 'abcdefghijklmnopqrstuvwxyz\u00e4\u00fc\u00f6')\n  1\n  norm! g??\n  call assert_equal('nopqrstuvwxyzabcdefghijklm\u00e4\u00fc\u00f6', getline('.'))\n  norm! g?g?\n  call assert_equal('abcdefghijklmnopqrstuvwxyz\u00e4\u00fc\u00f6', getline('.'))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal25_tag()\n  CheckFeature quickfix\n\n  \" Testing for CTRL-] g CTRL-] g]\n  \" CTRL-W g] CTRL-W CTRL-] CTRL-W g CTRL-]\n  h\n  \" Test for CTRL-]\n  call search('\\<x\\>$')\n  exe \"norm! \\<c-]>\"\n  call assert_equal(\"change.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*x*\", @0)\n  exe \":norm \\<c-o>\"\n\n  \" Test for g_CTRL-]\n  call search('\\<v_u\\>$')\n  exe \"norm! g\\<c-]>\"\n  call assert_equal(\"change.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*v_u*\", @0)\n  exe \":norm \\<c-o>\"\n\n  \" Test for g]\n  call search('\\<i_<Esc>$')\n  let a = execute(\":norm! g]\")\n  call assert_match('i_<Esc>.*insert.txt', a)\n\n  if !empty(exepath('cscope')) && has('cscope')\n    \" setting cscopetag changes how g] works\n    set cst\n    exe \"norm! g]\"\n    call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n    norm! yiW\n    call assert_equal(\"*i_<Esc>*\", @0)\n    exe \":norm \\<c-o>\"\n    \" Test for CTRL-W g]\n    exe \"norm! \\<C-W>g]\"\n    call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n    norm! yiW\n    call assert_equal(\"*i_<Esc>*\", @0)\n    call assert_equal(3, winnr('$'))\n    helpclose\n    set nocst\n  endif\n\n  \" Test for CTRL-W g]\n  let a = execute(\"norm! \\<C-W>g]\")\n  call assert_match('i_<Esc>.*insert.txt', a)\n\n  \" Test for CTRL-W CTRL-]\n  exe \"norm! \\<C-W>\\<C-]>\"\n  call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*i_<Esc>*\", @0)\n  call assert_equal(3, winnr('$'))\n  helpclose\n\n  \" Test for CTRL-W g CTRL-]\n  exe \"norm! \\<C-W>g\\<C-]>\"\n  call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*i_<Esc>*\", @0)\n  call assert_equal(3, winnr('$'))\n  helpclose\n\n  \" clean up\n  helpclose\nendfunc\n\nfunc Test_normal26_put()\n  \" Test for ]p ]P [p and [P\n  new\n  call append(0, ['while read LINE', 'do', '  ((count++))', '  if [ $? -ne 0 ]; then', \"    echo 'Error writing file'\", '  fi', 'done'])\n  1\n  /Error/y a\n  2\n  norm! \"a]pj\"a[p\n  call assert_equal(['do', \"echo 'Error writing file'\", \"  echo 'Error writing file'\", '  ((count++))'], getline(2,5))\n  1\n  /^\\s\\{4}/\n  exe \"norm!  \\\"a]P3Eldt'\"\n  exe \"norm! j\\\"a[P2Eldt'\"\n  call assert_equal(['  if [ $? -ne 0 ]; then', \"    echo 'Error writing'\", \"    echo 'Error'\", \"    echo 'Error writing file'\", '  fi'], getline(6,10))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal27_bracket()\n  \" Test for [' [` ]' ]`\n  call Setup_NewWindow()\n  1,21s/.\\+/  &   b/\n  1\n  norm! $ma\n  5\n  norm! $mb\n  10\n  norm! $mc\n  15\n  norm! $md\n  20\n  norm! $me\n\n  \" Test for ['\n  9\n  norm! 2['\n  call assert_equal('  1   b', getline('.'))\n  call assert_equal(1, line('.'))\n  call assert_equal(3, col('.'))\n\n  \" Test for ]'\n  norm! ]'\n  call assert_equal('  5   b', getline('.'))\n  call assert_equal(5, line('.'))\n  call assert_equal(3, col('.'))\n\n  \" No mark after line 21, cursor moves to first non blank on current line\n  21\n  norm! $]'\n  call assert_equal('  21   b', getline('.'))\n  call assert_equal(21, line('.'))\n  call assert_equal(3, col('.'))\n\n  \" Test for [`\n  norm! 2[`\n  call assert_equal('  15   b', getline('.'))\n  call assert_equal(15, line('.'))\n  call assert_equal(8, col('.'))\n\n  \" Test for ]`\n  norm! ]`\n  call assert_equal('  20   b', getline('.'))\n  call assert_equal(20, line('.'))\n  call assert_equal(8, col('.'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for ( and ) sentence movements\nfunc Test_normal28_parenthesis()\n  new\n  call append(0, ['This is a test. With some sentences!', '', 'Even with a question? And one more. And no sentence here'])\n\n  $\n  norm! d(\n  call assert_equal(['This is a test. With some sentences!', '', 'Even with a question? And one more. ', ''], getline(1, '$'))\n  norm! 2d(\n  call assert_equal(['This is a test. With some sentences!', '', ' ', ''], getline(1, '$'))\n  1\n  norm! 0d)\n  call assert_equal(['With some sentences!', '', ' ', ''], getline(1, '$'))\n\n  call append('$', ['This is a long sentence', '', 'spanning', 'over several lines. '])\n  $\n  norm! $d(\n  call assert_equal(['With some sentences!', '', ' ', '', 'This is a long sentence', ''], getline(1, '$'))\n\n  \" Move to the next sentence from a paragraph macro\n  %d\n  call setline(1, ['.LP', 'blue sky!. blue sky.', 'blue sky. blue sky.'])\n  call cursor(1, 1)\n  normal )\n  call assert_equal([2, 1], [line('.'), col('.')])\n  normal )\n  call assert_equal([2, 12], [line('.'), col('.')])\n  normal ((\n  call assert_equal([1, 1], [line('.'), col('.')])\n\n  \" It is an error if a next sentence is not found\n  %d\n  call setline(1, '.SH')\n  call assert_beeps('normal )')\n\n  \" If only dot is present, don't treat that as a sentence\n  call setline(1, '. This is a sentence.')\n  normal $((\n  call assert_equal(3, col('.'))\n\n  \" Jumping to a fold should open the fold\n  call setline(1, ['', '', 'one', 'two', 'three'])\n  set foldenable\n  2,$fold\n  call feedkeys(')', 'xt')\n  call assert_equal(3, line('.'))\n  call assert_equal(1, foldlevel('.'))\n  call assert_equal(-1, foldclosed('.'))\n  set foldenable&\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for { and } paragraph movements\nfunc Test_normal29_brace()\n  let text =<< trim [DATA]\n    A paragraph begins after each empty line, and also at each of a set of\n    paragraph macros, specified by the pairs of characters in the 'paragraphs'\n    option.  The default is \"IPLPPPQPP TPHPLIPpLpItpplpipbp\", which corresponds to\n    the macros \".IP\", \".LP\", etc.  (These are nroff macros, so the dot must be in\n    the first column).  A section boundary is also a paragraph boundary.\n    Note that a blank line (only containing white space) is NOT a paragraph\n    boundary.\n\n\n    Also note that this does not include a '{' or '}' in the first column.  When\n    the '{' flag is in 'cpoptions' then '{' in the first column is used as a\n    paragraph boundary |posix|.\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n  [DATA]\n\n  new\n  call append(0, text)\n  1\n  norm! 0d2}\n\n  let expected =<< trim [DATA]\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  norm! 0d}\n\n  let expected =<< trim [DATA]\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n  \n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  $\n  norm! d{\n\n  let expected =<< trim [DATA]\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  norm! d{\n\n  let expected =<< trim [DATA]\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test with { in cpooptions\n  %d\n  call append(0, text)\n  set cpo+={\n  1\n  norm! 0d2}\n\n  let expected =<< trim [DATA]\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  $\n  norm! d}\n\n  let expected =<< trim [DATA]\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  norm! gg}\n  norm! d5}\n\n  let expected =<< trim [DATA]\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Jumping to a fold should open the fold\n  %d\n  call setline(1, ['', 'one', 'two', ''])\n  set foldenable\n  2,$fold\n  call feedkeys('}', 'xt')\n  call assert_equal(4, line('.'))\n  call assert_equal(1, foldlevel('.'))\n  call assert_equal(-1, foldclosed('.'))\n  set foldenable&\n\n  \" clean up\n  set cpo-={\n  bw!\nendfunc\n\n\" Test for section movements\nfunc Test_normal_section()\n  new\n  let lines =<< trim [END]\n    int foo()\n    {\n      if (1)\n      {\n        a = 1;\n      }\n    }\n  [END]\n  call setline(1, lines)\n\n  \" jumping to a folded line using [[ should open the fold\n  2,3fold\n  call cursor(5, 1)\n  call feedkeys(\"[[\", 'xt')\n  call assert_equal(2, line('.'))\n  call assert_equal(-1, foldclosedend(line('.')))\n\n  close!\nendfunc\n\n\" Test for changing case using u, U, gu, gU and ~ (tilde) commands\nfunc Test_normal30_changecase()\n  new\n  call append(0, 'This is a simple test: \u00e4\u00fc\u00f6\u00df')\n  norm! 1ggVu\n  call assert_equal('this is a simple test: \u00e4\u00fc\u00f6\u00df', getline('.'))\n  norm! VU\n  call assert_equal('THIS IS A SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! guu\n  call assert_equal('this is a simple test: \u00e4\u00fc\u00f6ss', getline('.'))\n  norm! gUgU\n  call assert_equal('THIS IS A SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! gugu\n  call assert_equal('this is a simple test: \u00e4\u00fc\u00f6ss', getline('.'))\n  norm! gUU\n  call assert_equal('THIS IS A SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! 010~\n  call assert_equal('this is a SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! V~\n  call assert_equal('THIS IS A simple test: \u00e4\u00fc\u00f6ss', getline('.'))\n  call assert_beeps('norm! c~')\n  %d\n  call assert_beeps('norm! ~')\n\n  \" Test for changing case across lines using 'whichwrap'\n  call setline(1, ['aaaaaa', 'aaaaaa'])\n  normal! gg10~\n  call assert_equal(['AAAAAA', 'aaaaaa'], getline(1, 2))\n  set whichwrap+=~\n  normal! gg10~\n  call assert_equal(['aaaaaa', 'AAAAaa'], getline(1, 2))\n  set whichwrap&\n\n  \" try changing the case with a double byte encoding (DBCS)\n  %bw!\n  let enc = &enc\n  set encoding=cp932\n  call setline(1, \"\\u8470\")\n  normal ~\n  normal gU$gu$gUgUg~g~gugu\n  call assert_equal(\"\\u8470\", getline(1))\n  let &encoding = enc\n\n  \" clean up\n  bw!\nendfunc\n\n\" Turkish ASCII turns to multi-byte.  On some systems Turkish locale\n\" is available but toupper()/tolower() don't do the right thing.\nfunc Test_normal_changecase_turkish()\n  new\n  try\n    lang tr_TR.UTF-8\n    set casemap=\n    let iupper = toupper('i')\n    if iupper == \"\\u0130\"\n      call setline(1, 'iI')\n      1normal gUU\n      call assert_equal(\"\\u0130I\", getline(1))\n      call assert_equal(\"\\u0130I\", toupper(\"iI\"))\n\n      call setline(1, 'iI')\n      1normal guu\n      call assert_equal(\"i\\u0131\", getline(1))\n      call assert_equal(\"i\\u0131\", tolower(\"iI\"))\n    elseif iupper == \"I\"\n      call setline(1, 'iI')\n      1normal gUU\n      call assert_equal(\"II\", getline(1))\n      call assert_equal(\"II\", toupper(\"iI\"))\n\n      call setline(1, 'iI')\n      1normal guu\n      call assert_equal(\"ii\", getline(1))\n      call assert_equal(\"ii\", tolower(\"iI\"))\n    else\n      call assert_true(false, \"expected toupper('i') to be either 'I' or '\\u0130'\")\n    endif\n    set casemap&\n    call setline(1, 'iI')\n    1normal gUU\n    call assert_equal(\"II\", getline(1))\n    call assert_equal(\"II\", toupper(\"iI\"))\n\n    call setline(1, 'iI')\n    1normal guu\n    call assert_equal(\"ii\", getline(1))\n    call assert_equal(\"ii\", tolower(\"iI\"))\n\n    lang en_US.UTF-8\n  catch /E197:/\n    \" can't use Turkish locale\n    throw 'Skipped: Turkish locale not available'\n  endtry\n  close!\nendfunc\n\n\" Test for r (replace) command\nfunc Test_normal31_r_cmd()\n  new\n  call append(0, 'This is a simple test: abcd')\n  exe \"norm! 1gg$r\\<cr>\"\n  call assert_equal(['This is a simple test: abc', '', ''], getline(1,'$'))\n  exe \"norm! 1gg2wlr\\<cr>\"\n  call assert_equal(['This is a', 'simple test: abc', '', ''], getline(1,'$'))\n  exe \"norm! 2gg0W5r\\<cr>\"\n  call assert_equal(['This is a', 'simple ', ' abc', '', ''], getline('1', '$'))\n  set autoindent\n  call setline(2, ['simple test: abc', ''])\n  exe \"norm! 2gg0W5r\\<cr>\"\n  call assert_equal(['This is a', 'simple ', 'abc', '', '', ''], getline('1', '$'))\n  exe \"norm! 1ggVr\\<cr>\"\n  call assert_equal('^M^M^M^M^M^M^M^M^M', strtrans(getline(1)))\n  call setline(1, 'This is a')\n  exe \"norm! 1gg05rf\"\n  call assert_equal('fffffis a', getline(1))\n\n  \" When replacing characters, copy characters from above and below lines\n  \" using CTRL-Y and CTRL-E.\n  \" Different code paths are used for utf-8 and latin1 encodings\n  set showmatch\n  for enc in ['latin1', 'utf-8']\n    enew!\n    let &encoding = enc\n    call setline(1, [' {a}', 'xxxxxxxxxx', '      [b]'])\n    exe \"norm! 2gg5r\\<C-Y>l5r\\<C-E>\"\n    call assert_equal(' {a}x [b]x', getline(2))\n  endfor\n  set showmatch&\n\n  \" r command should fail in operator pending mode\n  call assert_beeps('normal! cr')\n\n  \" replace a tab character in visual mode\n  %d\n  call setline(1, [\"a\\tb\", \"c\\td\", \"e\\tf\"])\n  normal gglvjjrx\n  call assert_equal(['axx', 'xxx', 'xxf'], getline(1, '$'))\n\n  \" replace with a multibyte character (with multiple composing characters)\n  %d\n  new\n  call setline(1, 'aaa')\n  exe \"normal $ra\\u0328\\u0301\"\n  call assert_equal(\"aaa\\u0328\\u0301\", getline(1))\n\n  \" clean up\n  set noautoindent\n  bw!\nendfunc\n\n\" Test for g*, g#\nfunc Test_normal32_g_cmd1()\n  new\n  call append(0, ['abc.x_foo', 'x_foobar.abc'])\n  1\n  norm! $g*\n  call assert_equal('x_foo', @/)\n  call assert_equal('x_foobar.abc', getline('.'))\n  norm! $g#\n  call assert_equal('abc', @/)\n  call assert_equal('abc.x_foo', getline('.'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for g`, g;, g,, g&, gv, gk, gj, gJ, g0, g^, g_, gm, g$, gM, g CTRL-G,\n\" gi and gI commands\nfunc Test_normal33_g_cmd2()\n  CheckFeature jumplist\n  call Setup_NewWindow()\n  \" Test for g`\n  clearjumps\n  norm! ma10j\n  let a=execute(':jumps')\n  \" empty jumplist\n  call assert_equal('>', a[-1:])\n  norm! g`a\n  call assert_equal('>', a[-1:])\n  call assert_equal(1, line('.'))\n  call assert_equal('1', getline('.'))\n  call cursor(10, 1)\n  norm! g'a\n  call assert_equal('>', a[-1:])\n  call assert_equal(1, line('.'))\n\n  \" Test for g; and g,\n  norm! g;\n  \" there is only one change in the changelist\n  \" currently, when we setup the window\n  call assert_equal(2, line('.'))\n  call assert_fails(':norm! g;', 'E662:')\n  call assert_fails(':norm! g,', 'E663:')\n  let &ul=&ul\n  call append('$', ['a', 'b', 'c', 'd'])\n  let &ul=&ul\n  call append('$', ['Z', 'Y', 'X', 'W'])\n  let a = execute(':changes')\n  call assert_match('2\\s\\+0\\s\\+2', a)\n  call assert_match('101\\s\\+0\\s\\+a', a)\n  call assert_match('105\\s\\+0\\s\\+Z', a)\n  norm! 3g;\n  call assert_equal(2, line('.'))\n  norm! 2g,\n  call assert_equal(105, line('.'))\n\n  \" Test for g& - global substitute\n  %d\n  call setline(1, range(1,10))\n  call append('$', ['a', 'b', 'c', 'd'])\n  $s/\\w/&&/g\n  exe \"norm! /[1-8]\\<cr>\"\n  norm! g&\n  call assert_equal(['11', '22', '33', '44', '55', '66', '77', '88', '9', '110', 'a', 'b', 'c', 'dd'], getline(1, '$'))\n\n  \" Jumping to a fold using gg should open the fold\n  set foldenable\n  set foldopen+=jump\n  5,8fold\n  call feedkeys('6gg', 'xt')\n  call assert_equal(1, foldlevel('.'))\n  call assert_equal(-1, foldclosed('.'))\n  set foldopen-=jump\n  set foldenable&\n\n  \" Test for gv\n  %d\n  call append('$', repeat(['abcdefgh'], 8))\n  exe \"norm! 2gg02l\\<c-v>2j2ly\"\n  call assert_equal(['cde', 'cde', 'cde'], getreg(0, 1, 1))\n  \" in visual mode, gv swaps current and last selected region\n  exe \"norm! G0\\<c-v>4k4lgvd\"\n  call assert_equal(['', 'abfgh', 'abfgh', 'abfgh', 'abcdefgh', 'abcdefgh', 'abcdefgh', 'abcdefgh', 'abcdefgh'], getline(1,'$'))\n  exe \"norm! G0\\<c-v>4k4ly\"\n  exe \"norm! gvood\"\n  call assert_equal(['', 'abfgh', 'abfgh', 'abfgh', 'fgh', 'fgh', 'fgh', 'fgh', 'fgh'], getline(1,'$'))\n  \" gv cannot be used  in operator pending mode\n  call assert_beeps('normal! cgv')\n  \" gv should beep without a previously selected visual area\n  new\n  call assert_beeps('normal! gv')\n  close\n\n  \" Test for gk/gj\n  %d\n  15vsp\n  set wrap listchars= sbr=\n  let lineA = 'abcdefghijklmnopqrstuvwxyz'\n  let lineB = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  let lineC = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n  $put =lineA\n  $put =lineB\n\n  norm! 3gg0dgk\n  call assert_equal(['', 'abcdefghijklmno', '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'], getline(1, '$'))\n  set nu\n  norm! 3gg0gjdgj\n  call assert_equal(['', 'abcdefghijklmno', '0123456789AMNOPQRSTUVWXYZ'], getline(1,'$'))\n\n  \" Test for gJ\n  norm! 2gggJ\n  call assert_equal(['', 'abcdefghijklmno0123456789AMNOPQRSTUVWXYZ'], getline(1,'$'))\n  call assert_equal(16, col('.'))\n  \" shouldn't do anything\n  norm! 10gJ\n  call assert_equal(1, col('.'))\n\n  \" Test for g0 g^ gm g$\n  exe \"norm! 2gg0gji   \"\n  call assert_equal(['', 'abcdefghijk   lmno0123456789AMNOPQRSTUVWXYZ'], getline(1,'$'))\n  norm! g0yl\n  call assert_equal(12, col('.'))\n  call assert_equal(' ', getreg(0))\n  norm! g$yl\n  call assert_equal(22, col('.'))\n  call assert_equal('3', getreg(0))\n  norm! gmyl\n  call assert_equal(17, col('.'))\n  call assert_equal('n', getreg(0))\n  norm! g^yl\n  call assert_equal(15, col('.'))\n  call assert_equal('l', getreg(0))\n  call assert_beeps('normal 5g$')\n\n  \" Test for g$ with double-width character half displayed\n  vsplit\n  9wincmd |\n  setlocal nowrap nonumber\n  call setline(2, 'asdfasdf\u30e8')\n  2\n  normal 0g$\n  call assert_equal(8, col('.'))\n  10wincmd |\n  normal 0g$\n  call assert_equal(9, col('.'))\n\n  setlocal signcolumn=yes\n  11wincmd |\n  normal 0g$\n  call assert_equal(8, col('.'))\n  12wincmd |\n  normal 0g$\n  call assert_equal(9, col('.'))\n\n  close\n\n  \" Test for g_\n  call assert_beeps('normal! 100g_')\n  call setline(2, ['  foo  ', '  foobar  '])\n  normal! 2ggg_\n  call assert_equal(5, col('.'))\n  normal! 2g_\n  call assert_equal(8, col('.'))\n\n  norm! 2ggdG\n  $put =lineC\n\n  \" Test for gM\n  norm! gMyl\n  call assert_equal(73, col('.'))\n  call assert_equal('0', getreg(0))\n  \" Test for 20gM\n  norm! 20gMyl\n  call assert_equal(29, col('.'))\n  call assert_equal('S', getreg(0))\n  \" Test for 60gM\n  norm! 60gMyl\n  call assert_equal(87, col('.'))\n  call assert_equal('E', getreg(0))\n\n  \" Test for g Ctrl-G\n  set ff=unix\n  let a=execute(\":norm! g\\<c-g>\")\n  call assert_match('Col 87 of 144; Line 2 of 2; Word 1 of 1; Byte 88 of 146', a)\n\n  \" Test for gI\n  norm! gIfoo\n  call assert_equal(['', 'foo0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'], getline(1,'$'))\n\n  \" Test for gi\n  wincmd c\n  %d\n  set tw=0\n  call setline(1, ['foobar', 'new line'])\n  norm! A next word\n  $put ='third line'\n  norm! gi another word\n  call assert_equal(['foobar next word another word', 'new line', 'third line'], getline(1,'$'))\n  call setline(1, 'foobar')\n  normal! Ggifirst line\n  call assert_equal('foobarfirst line', getline(1))\n  \" Test gi in 'virtualedit' mode with cursor after the end of the line\n  set virtualedit=all\n  call setline(1, 'foo')\n  exe \"normal! Abar\\<Right>\\<Right>\\<Right>\\<Right>\"\n  call setline(1, 'foo')\n  normal! Ggifirst line\n  call assert_equal('foo       first line', getline(1))\n  set virtualedit&\n\n  \" Test for aboring a g command using CTRL-\\ CTRL-G\n  exe \"normal! g\\<C-\\>\\<C-G>\"\n  call assert_equal('foo       first line', getline('.'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for g CTRL-G\nfunc Test_g_ctrl_g()\n  new\n\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\n--No lines in buffer--\", a)\n\n  \" Test for CTRL-G (same as :file)\n  let a = execute(\":norm! \\<c-g>\")\n  call assert_equal(\"\\n\\n\\\"[No Name]\\\" --No lines in buffer--\", a)\n\n  call setline(1, ['first line', 'second line'])\n\n  \" Test g CTRL-g with dos, mac and unix file type.\n  norm! gojll\n  set ff=dos\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 3 of 11; Line 2 of 2; Word 3 of 4; Byte 15 of 25\", a)\n\n  set ff=mac\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 3 of 11; Line 2 of 2; Word 3 of 4; Byte 14 of 23\", a)\n\n  set ff=unix\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 3 of 11; Line 2 of 2; Word 3 of 4; Byte 14 of 23\", a)\n\n  \" Test g CTRL-g in visual mode (v)\n  let a = execute(\":norm! gojllvlg\\<c-g>\")\n  call assert_equal(\"\\nSelected 1 of 2 Lines; 1 of 4 Words; 2 of 23 Bytes\", a)\n\n  \" Test g CTRL-g in visual mode (CTRL-V) with end col > start col\n  let a = execute(\":norm! \\<Esc>gojll\\<C-V>kllg\\<c-g>\")\n  call assert_equal(\"\\nSelected 3 Cols; 2 of 2 Lines; 2 of 4 Words; 6 of 23 Bytes\", a)\n\n  \" Test g_CTRL-g in visual mode (CTRL-V) with end col < start col\n  let a = execute(\":norm! \\<Esc>goll\\<C-V>jhhg\\<c-g>\")\n  call assert_equal(\"\\nSelected 3 Cols; 2 of 2 Lines; 2 of 4 Words; 6 of 23 Bytes\", a)\n\n  \" Test g CTRL-g in visual mode (CTRL-V) with end_vcol being MAXCOL\n  let a = execute(\":norm! \\<Esc>gojll\\<C-V>k$g\\<c-g>\")\n  call assert_equal(\"\\nSelected 2 of 2 Lines; 4 of 4 Words; 17 of 23 Bytes\", a)\n\n  \" There should be one byte less with noeol\n  set bin noeol\n  let a = execute(\":norm! \\<Esc>gog\\<c-g>\")\n  call assert_equal(\"\\nCol 1 of 10; Line 1 of 2; Word 1 of 4; Char 1 of 23; Byte 1 of 22\", a)\n  set bin & eol&\n\n  call setline(1, ['Fran\u00e7ais', '\u65e5\u672c\u8a9e'])\n\n  let a = execute(\":norm! \\<Esc>gojlg\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20\", a)\n\n  let a = execute(\":norm! \\<Esc>gojvlg\\<c-g>\")\n  call assert_equal(\"\\nSelected 1 of 2 Lines; 1 of 2 Words; 2 of 13 Chars; 6 of 20 Bytes\", a)\n\n  let a = execute(\":norm! \\<Esc>goll\\<c-v>jlg\\<c-g>\")\n  call assert_equal(\"\\nSelected 4 Cols; 2 of 2 Lines; 2 of 2 Words; 6 of 13 Chars; 11 of 20 Bytes\", a)\n\n  set fenc=utf8 bomb\n  let a = execute(\":norm! \\<Esc>gojlg\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20(+3 for BOM)\", a)\n\n  set fenc=utf16 bomb\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20(+2 for BOM)\", a)\n\n  set fenc=utf32 bomb\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20(+4 for BOM)\", a)\n\n  set fenc& bomb&\n\n  set ff&\n  bwipe!\nendfunc\n\n\" Test for g8\nfunc Test_normal34_g_cmd3()\n  new\n  let a=execute(':norm! 1G0g8')\n  call assert_equal(\"\\nNUL\", a)\n\n  call setline(1, 'abcdefghijklmnopqrstuvwxyz\u00e4\u00fc\u00f6')\n  let a=execute(':norm! 1G$g8')\n  call assert_equal(\"\\nc3 b6 \", a)\n\n  call setline(1, \"a\\u0302\")\n  let a=execute(':norm! 1G0g8')\n  call assert_equal(\"\\n61 + cc 82 \", a)\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test 8g8 which finds invalid utf8 at or after the cursor.\nfunc Test_normal_8g8()\n  new\n\n  \" With invalid byte.\n  call setline(1, \"___\\xff___\")\n  norm! 1G08g8g\n  call assert_equal([0, 1, 4, 0, 1], getcurpos())\n\n  \" With invalid byte before the cursor.\n  call setline(1, \"___\\xff___\")\n  norm! 1G$h8g8g\n  call assert_equal([0, 1, 6, 0, 9], getcurpos())\n\n  \" With truncated sequence.\n  call setline(1, \"___\\xE2\\x82___\")\n  norm! 1G08g8g\n  call assert_equal([0, 1, 4, 0, 1], getcurpos())\n\n  \" With overlong sequence.\n  call setline(1, \"___\\xF0\\x82\\x82\\xAC___\")\n  norm! 1G08g8g\n  call assert_equal([0, 1, 4, 0, 1], getcurpos())\n\n  \" With valid utf8.\n  call setline(1, \"caf\u00e9\")\n  norm! 1G08g8\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n\n  bw!\nendfunc\n\n\" Test for g<\nfunc Test_normal35_g_cmd4()\n  \" Cannot capture its output,\n  \" probably a bug, therefore, test disabled:\n  throw \"Skipped: output of g< can't be tested currently\"\n  echo \"a\\nb\\nc\\nd\"\n  let b=execute(':norm! g<')\n  call assert_true(!empty(b), 'failed `execute(g<)`')\nendfunc\n\n\" Test for gp gP go\nfunc Test_normal36_g_cmd5()\n  new\n  call append(0, 'abcdefghijklmnopqrstuvwxyz')\n  set ff=unix\n  \" Test for gp gP\n  call append(1, range(1,10))\n  1\n  norm! 1yy\n  3\n  norm! gp\n  call assert_equal([0, 5, 1, 0, 1], getcurpos())\n  $\n  norm! gP\n  call assert_equal([0, 14, 1, 0, 1], getcurpos())\n\n  \" Test for go\n  norm! 26go\n  call assert_equal([0, 1, 26, 0, 26], getcurpos())\n  norm! 27go\n  call assert_equal([0, 1, 26, 0, 26], getcurpos())\n  norm! 28go\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n  set ff=dos\n  norm! 29go\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n  set ff=unix\n  norm! gg0\n  norm! 101go\n  call assert_equal([0, 13, 26, 0, 26], getcurpos())\n  norm! 103go\n  call assert_equal([0, 14, 1, 0, 1], getcurpos())\n  \" count > buffer content\n  norm! 120go\n  call assert_equal([0, 14, 1, 0, 2147483647], getcurpos())\n  \" clean up\n  bw!\nendfunc\n\n\" Test for gt and gT\nfunc Test_normal37_g_cmd6()\n  tabnew 1.txt\n  tabnew 2.txt\n  tabnew 3.txt\n  norm! 1gt\n  call assert_equal(1, tabpagenr())\n  norm! 3gt\n  call assert_equal(3, tabpagenr())\n  norm! 1gT\n  \" count gT goes not to the absolute tabpagenumber\n  \" but, but goes to the count previous tabpagenumber\n  call assert_equal(2, tabpagenr())\n  \" wrap around\n  norm! 3gT\n  call assert_equal(3, tabpagenr())\n  \" gt does not wrap around\n  norm! 5gt\n  call assert_equal(3, tabpagenr())\n\n  for i in range(3)\n    tabclose\n  endfor\n  \" clean up\n  call assert_fails(':tabclose', 'E784:')\nendfunc\n\n\" Test for <Home> and <C-Home> key\nfunc Test_normal38_nvhome()\n  new\n  call setline(1, range(10))\n  $\n  setl et sw=2\n  norm! V10>$\n  \" count is ignored\n  exe \"norm! 10\\<home>\"\n  call assert_equal(1, col('.'))\n  exe \"norm! \\<home>\"\n  call assert_equal([0, 10, 1, 0, 1], getcurpos())\n  exe \"norm! 5\\<c-home>\"\n  call assert_equal([0, 5, 1, 0, 1], getcurpos())\n  exe \"norm! \\<c-home>\"\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  exe \"norm! G\\<c-kHome>\"\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for <End> and <C-End> keys\nfunc Test_normal_nvend()\n  new\n  call setline(1, map(range(1, 10), '\"line\" .. v:val'))\n  exe \"normal! \\<End>\"\n  call assert_equal(5, col('.'))\n  exe \"normal! 4\\<End>\"\n  call assert_equal([4, 5], [line('.'), col('.')])\n  exe \"normal! \\<C-End>\"\n  call assert_equal([10, 6], [line('.'), col('.')])\n  close!\nendfunc\n\n\" Test for cw cW ce\nfunc Test_normal39_cw()\n  \" Test for cw and cW on whitespace\n  new\n  set tw=0\n  call append(0, 'here      are   some words')\n  norm! 1gg0elcwZZZ\n  call assert_equal('hereZZZare   some words', getline('.'))\n  norm! 1gg0elcWYYY\n  call assert_equal('hereZZZareYYYsome words', getline('.'))\n  norm! 2gg0cwfoo\n  call assert_equal('foo', getline('.'))\n\n  call setline(1, 'one; two')\n  call cursor(1, 1)\n  call feedkeys('cwvim', 'xt')\n  call assert_equal('vim; two', getline(1))\n  call feedkeys('0cWone', 'xt')\n  call assert_equal('one two', getline(1))\n  \"When cursor is at the end of a word 'ce' will change until the end of the\n  \"next word, but 'cw' will change only one character\n  call setline(1, 'one two')\n  call feedkeys('0ecwce', 'xt')\n  call assert_equal('once two', getline(1))\n  call setline(1, 'one two')\n  call feedkeys('0ecely', 'xt')\n  call assert_equal('only', getline(1))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for CTRL-\\ commands\nfunc Test_normal40_ctrl_bsl()\n  new\n  call append(0, 'here      are   some words')\n  exe \"norm! 1gg0a\\<C-\\>\\<C-N>\"\n  call assert_equal('n', mode())\n  call assert_equal(1, col('.'))\n  call assert_equal('', visualmode())\n  exe \"norm! 1gg0viw\\<C-\\>\\<C-N>\"\n  call assert_equal('n', mode())\n  call assert_equal(4, col('.'))\n  exe \"norm! 1gg0a\\<C-\\>\\<C-G>\"\n  call assert_equal('n', mode())\n  call assert_equal(1, col('.'))\n  \"imap <buffer> , <c-\\><c-n>\n  set im\n  exe \":norm! \\<c-\\>\\<c-n>dw\"\n  set noim\n  call assert_equal('are   some words', getline(1))\n  call assert_false(&insertmode)\n  call assert_beeps(\"normal! \\<C-\\>\\<C-A>\")\n\n  if has('cmdwin')\n    \" Using CTRL-\\ CTRL-N in cmd window should close the window\n    call feedkeys(\"q:\\<C-\\>\\<C-N>\", 'xt')\n    call assert_equal('', getcmdwintype())\n  endif\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for <c-r>=, <c-r><c-r>= and <c-r><c-o>= in insert mode\nfunc Test_normal41_insert_reg()\n  new\n  set sts=2 sw=2 ts=8 tw=0\n  call append(0, [\"aaa\\tbbb\\tccc\", '', '', ''])\n  let a=getline(1)\n  norm! 2gg0\n  exe \"norm! a\\<c-r>=a\\<cr>\"\n  norm! 3gg0\n  exe \"norm! a\\<c-r>\\<c-r>=a\\<cr>\"\n  norm! 4gg0\n  exe \"norm! a\\<c-r>\\<c-o>=a\\<cr>\"\n  call assert_equal(['aaa\tbbb\tccc', 'aaa bbb\tccc', 'aaa bbb\tccc', 'aaa\tbbb\tccc', ''], getline(1, '$'))\n\n  \" clean up\n  set sts=0 sw=8 ts=8\n  bw!\nendfunc\n\n\" Test for Ctrl-D and Ctrl-U\nfunc Test_normal42_halfpage()\n  call Setup_NewWindow()\n  call assert_equal(5, &scroll)\n  exe \"norm! \\<c-d>\"\n  call assert_equal('6', getline('.'))\n  exe \"norm! 2\\<c-d>\"\n  call assert_equal('8', getline('.'))\n  call assert_equal(2, &scroll)\n  set scroll=5\n  exe \"norm! \\<c-u>\"\n  call assert_equal('3', getline('.'))\n  1\n  set scrolloff=5\n  exe \"norm! \\<c-d>\"\n  call assert_equal('10', getline('.'))\n  exe \"norm! \\<c-u>\"\n  call assert_equal('5', getline('.'))\n  1\n  set scrolloff=99\n  exe \"norm! \\<c-d>\"\n  call assert_equal('10', getline('.'))\n  set scrolloff=0\n  100\n  exe \"norm! $\\<c-u>\"\n  call assert_equal('95', getline('.'))\n  call assert_equal([0, 95, 1, 0, 1], getcurpos())\n  100\n  set nostartofline\n  exe \"norm! $\\<c-u>\"\n  call assert_equal('95', getline('.'))\n  call assert_equal([0, 95, 2, 0, 2147483647], getcurpos())\n  \" cleanup\n  set startofline\n  bw!\nendfunc\n\nfunc Test_normal45_drop()\n  if !has('dnd')\n    \" The ~ register does not exist\n    call assert_beeps('norm! \"~')\n    return\n  endif\n\n  \" basic test for drag-n-drop\n  \" unfortunately, without a gui, we can't really test much here,\n  \" so simply test that ~p fails (which uses the drop register)\n  new\n  call assert_fails(':norm! \"~p', 'E353:')\n  call assert_equal([],  getreg('~', 1, 1))\n  \" the ~ register is read only\n  call assert_fails(':let @~=\"1\"', 'E354:')\n  bw!\nendfunc\n\nfunc Test_normal46_ignore()\n  new\n  \" How to test this?\n  \" let's just for now test, that the buffer\n  \" does not change\n  call feedkeys(\"\\<c-s>\", 't')\n  call assert_equal([''], getline(1,'$'))\n\n  \" no valid commands\n  exe \"norm! \\<char-0x100>\"\n  call assert_equal([''], getline(1,'$'))\n\n  exe \"norm! \u00e4\"\n  call assert_equal([''], getline(1,'$'))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal47_visual_buf_wipe()\n  \" This was causing a crash or ml_get error.\n  enew!\n  call setline(1,'xxx')\n  normal $\n  new\n  call setline(1, range(1,2))\n  2\n  exe \"norm \\<C-V>$\"\n  bw!\n  norm yp\n  set nomodified\nendfunc\n\nfunc Test_normal48_wincmd()\n  new\n  exe \"norm! \\<c-w>c\"\n  call assert_equal(1, winnr('$'))\n  call assert_fails(\":norm! \\<c-w>c\", 'E444:')\nendfunc\n\nfunc Test_normal49_counts()\n  new\n  call setline(1, 'one two three four five six seven eight nine ten')\n  1\n  norm! 3d2w\n  call assert_equal('seven eight nine ten', getline(1))\n  bw!\nendfunc\n\nfunc Test_normal50_commandline()\n  CheckFeature timers\n  CheckFeature cmdline_hist\n  func! DoTimerWork(id)\n    call assert_equal('[Command Line]', bufname(''))\n    \" should fail, with E11, but does fail with E23?\n    \"call feedkeys(\"\\<c-^>\", 'tm')\n\n    \" should also fail with E11\n    call assert_fails(\":wincmd p\", 'E11:')\n    \" return from commandline window\n    call feedkeys(\"\\<cr>\")\n  endfunc\n\n  let oldlang=v:lang\n  lang C\n  set updatetime=20\n  call timer_start(100, 'DoTimerWork')\n  try\n    \" throws E23, for whatever reason...\n    call feedkeys('q:', 'x!')\n  catch /E23/\n    \" no-op\n  endtry\n  \" clean up\n  set updatetime=4000\n  exe \"lang\" oldlang\n  bw!\nendfunc\n\nfunc Test_normal51_FileChangedRO()\n  CheckFeature autocmd\n  \" Don't sleep after the warning message.\n  call test_settime(1)\n  call writefile(['foo'], 'Xreadonly.log')\n  new Xreadonly.log\n  setl ro\n  au FileChangedRO <buffer> :call feedkeys(\"\\<c-^>\", 'tix')\n  call assert_fails(\":norm! Af\", 'E788:')\n  call assert_equal(['foo'], getline(1,'$'))\n  call assert_equal('Xreadonly.log', bufname(''))\n\n  \" cleanup\n  call test_settime(0)\n  bw!\n  call delete(\"Xreadonly.log\")\nendfunc\n\nfunc Test_normal52_rl()\n  CheckFeature rightleft\n  new\n  call setline(1, 'abcde fghij klmnopq')\n  norm! 1gg$\n  set rl\n  call assert_equal(19, col('.'))\n  call feedkeys('l', 'tx')\n  call assert_equal(18, col('.'))\n  call feedkeys('h', 'tx')\n  call assert_equal(19, col('.'))\n  call feedkeys(\"\\<right>\", 'tx')\n  call assert_equal(18, col('.'))\n  call feedkeys(\"\\<left>\", 'tx')\n  call assert_equal(19, col('.'))\n  call feedkeys(\"\\<s-right>\", 'tx')\n  call assert_equal(13, col('.'))\n  call feedkeys(\"\\<c-right>\", 'tx')\n  call assert_equal(7, col('.'))\n  call feedkeys(\"\\<c-left>\", 'tx')\n  call assert_equal(13, col('.'))\n  call feedkeys(\"\\<s-left>\", 'tx')\n  call assert_equal(19, col('.'))\n  call feedkeys(\"<<\", 'tx')\n  call assert_equal('\tabcde fghij klmnopq',getline(1))\n  call feedkeys(\">>\", 'tx')\n  call assert_equal('abcde fghij klmnopq',getline(1))\n\n  \" cleanup\n  set norl\n  bw!\nendfunc\n\nfunc Test_normal54_Ctrl_bsl()\n  new\n  call setline(1, 'abcdefghijklmn')\n  exe \"norm! df\\<c-\\>\\<c-n>\"\n  call assert_equal(['abcdefghijklmn'], getline(1,'$'))\n  exe \"norm! df\\<c-\\>\\<c-g>\"\n  call assert_equal(['abcdefghijklmn'], getline(1,'$'))\n  exe \"norm! df\\<c-\\>m\"\n  call assert_equal(['abcdefghijklmn'], getline(1,'$'))\n\n  call setline(2, 'abcdefghijklmn\u0101f')\n  norm! 2gg0\n  exe \"norm! df\\<Char-0x101>\"\n  call assert_equal(['abcdefghijklmn', 'f'], getline(1,'$'))\n  norm! 1gg0\n  exe \"norm! df\\<esc>\"\n  call assert_equal(['abcdefghijklmn', 'f'], getline(1,'$'))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal_large_count()\n  \" This may fail with 32bit long, how do we detect that?\n  new\n  normal o\n  normal 6666666666dL\n  bwipe!\nendfunc\n\nfunc Test_delete_until_paragraph()\n  new\n  normal gr\u00e1dv}\n  call assert_equal('\u00e1', getline(1))\n  normal gr\u00e1d}\n  call assert_equal('', getline(1))\n  bwipe!\nendfunc\n\n\" Test for the gr (virtual replace) command\n\" Test for the bug fixed by 7.4.387\nfunc Test_gr_command()\n  enew!\n  let save_cpo = &cpo\n  call append(0, ['First line', 'Second line', 'Third line'])\n  exe \"normal i\\<C-G>u\"\n  call cursor(2, 1)\n  set cpo-=X\n  normal 4gro\n  call assert_equal('oooond line', getline(2))\n  undo\n  set cpo+=X\n  normal 4gro\n  call assert_equal('ooooecond line', getline(2))\n  let &cpo = save_cpo\n  normal! ggvegrx\n  call assert_equal('xxxxx line', getline(1))\n  exe \"normal! gggr\\<C-V>122\"\n  call assert_equal('zxxxx line', getline(1))\n  set virtualedit=all\n  normal! 15|grl\n  call assert_equal('zxxxx line    l', getline(1))\n  set virtualedit&\n  set nomodifiable\n  call assert_fails('normal! grx', 'E21:')\n  call assert_fails('normal! gRx', 'E21:')\n  set modifiable&\n  enew!\nendfunc\n\n\" When splitting a window the changelist position is wrong.\n\" Test the changelist position after splitting a window.\n\" Test for the bug fixed by 7.4.386\nfunc Test_changelist()\n  let save_ul = &ul\n  enew!\n  call append('$', ['1', '2'])\n  exe \"normal i\\<C-G>u\"\n  exe \"normal Gkylpa\\<C-G>u\"\n  set ul=100\n  exe \"normal Gylpa\\<C-G>u\"\n  set ul=100\n  normal gg\n  vsplit\n  normal g;\n  call assert_equal([3, 2], [line('.'), col('.')])\n  normal g;\n  call assert_equal([2, 2], [line('.'), col('.')])\n  call assert_fails('normal g;', 'E662:')\n  new\n  call assert_fails('normal g;', 'E664:')\n  %bwipe!\n  let &ul = save_ul\nendfunc\n\nfunc Test_nv_hat_count()\n  %bwipeout!\n  let l:nr = bufnr('%') + 1\n  call assert_fails(':execute \"normal! ' . l:nr . '\\<C-^>\"', 'E92:')\n\n  edit Xfoo\n  let l:foo_nr = bufnr('Xfoo')\n\n  edit Xbar\n  let l:bar_nr = bufnr('Xbar')\n\n  \" Make sure we are not just using the alternate file.\n  edit Xbaz\n\n  call feedkeys(l:foo_nr . \"\\<C-^>\", 'tx')\n  call assert_equal('Xfoo', fnamemodify(bufname('%'), ':t'))\n\n  call feedkeys(l:bar_nr . \"\\<C-^>\", 'tx')\n  call assert_equal('Xbar', fnamemodify(bufname('%'), ':t'))\n\n  %bwipeout!\nendfunc\n\nfunc Test_message_when_using_ctrl_c()\n  \" Make sure no buffers are changed.\n  %bwipe!\n\n  exe \"normal \\<C-C>\"\n  call assert_match(\"Type  :qa  and press <Enter> to exit Vim\", Screenline(&lines))\n\n  new\n  cal setline(1, 'hi!')\n  exe \"normal \\<C-C>\"\n  call assert_match(\"Type  :qa!  and press <Enter> to abandon all changes and exit Vim\", Screenline(&lines))\n\n  bwipe!\nendfunc\n\n\" Test for '[m', ']m', '[M' and ']M'\n\" Jumping to beginning and end of methods in Java-like languages\nfunc Test_java_motion()\n  new\n  call assert_beeps('normal! [m')\n  call assert_beeps('normal! ]m')\n  call assert_beeps('normal! [M')\n  call assert_beeps('normal! ]M')\n  let lines =<< trim [CODE]\n\tPiece of Java\n\t{\n\t\ttt m1 {\n\t\t\tt1;\n\t\t} e1\n\n\t\ttt m2 {\n\t\t\tt2;\n\t\t} e2\n\n\t\ttt m3 {\n\t\t\tif (x)\n\t\t\t{\n\t\t\t\tt3;\n\t\t\t}\n\t\t} e3\n\t}\n  [CODE]\n  call setline(1, lines)\n\n  normal gg\n\n  normal 2]maA\n  call assert_equal(\"\\ttt m1 {A\", getline('.'))\n  call assert_equal([3, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal j]maB\n  call assert_equal(\"\\ttt m2 {B\", getline('.'))\n  call assert_equal([7, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal ]maC\n  call assert_equal(\"\\ttt m3 {C\", getline('.'))\n  call assert_equal([11, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal [maD\n  call assert_equal(\"\\ttt m3 {DC\", getline('.'))\n  call assert_equal([11, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal k2[maE\n  call assert_equal(\"\\ttt m1 {EA\", getline('.'))\n  call assert_equal([3, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal 3[maF\n  call assert_equal(\"{F\", getline('.'))\n  call assert_equal([2, 2, 2], [line('.'), col('.'), virtcol('.')])\n\n  normal ]MaG\n  call assert_equal(\"\\t}G e1\", getline('.'))\n  call assert_equal([5, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal j2]MaH\n  call assert_equal(\"\\t}H e3\", getline('.'))\n  call assert_equal([16, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal ]M]M\n  normal aI\n  call assert_equal(\"}I\", getline('.'))\n  call assert_equal([17, 2, 2], [line('.'), col('.'), virtcol('.')])\n\n  normal 2[MaJ\n  call assert_equal(\"\\t}JH e3\", getline('.'))\n  call assert_equal([16, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal k[MaK\n  call assert_equal(\"\\t}K e2\", getline('.'))\n  call assert_equal([9, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal 3[MaL\n  call assert_equal(\"{LF\", getline('.'))\n  call assert_equal([2, 2, 2], [line('.'), col('.'), virtcol('.')])\n\n  call cursor(2, 1)\n  call assert_beeps('norm! 5]m')\n\n  \" jumping to a method in a fold should open the fold\n  6,10fold\n  call feedkeys(\"gg3]m\", 'xt')\n  call assert_equal([7, 8, 15], [line('.'), col('.'), virtcol('.')])\n  call assert_equal(-1, foldclosedend(7))\n\n  close!\nendfunc\n\n\" Tests for g cmds\nfunc Test_normal_gdollar_cmd()\n  CheckFeature jumplist\n  call Setup_NewWindow()\n  \" Make long lines that will wrap\n  %s/$/\\=repeat(' foobar', 10)/\n  20vsp\n  set wrap\n  \" Test for g$ with count\n  norm! gg\n  norm! 0vg$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foob', getreg(0))\n  norm! gg\n  norm! 0v4g$y\n  call assert_equal(72, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'..\"\\n\", getreg(0))\n  norm! gg\n  norm! 0v6g$y\n  call assert_equal(40, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n\t\t  \\ '2 foobar foobar foobar foobar foobar foo', getreg(0))\n  set nowrap\n  \" clean up\n  norm! gg\n  norm! 0vg$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foob', getreg(0))\n  norm! gg\n  norm! 0v4g$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '2 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '3 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '4 foobar foobar foob', getreg(0))\n  norm! gg\n  norm! 0v6g$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '2 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '3 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '4 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '5 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '6 foobar foobar foob', getreg(0))\n  \" Move to last line, also down movement is not possible, should still move\n  \" the cursor to the last visible char\n  norm! G\n  norm! 0v6g$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('100 foobar foobar fo', getreg(0))\n  bw!\nendfunc\n\nfunc Test_normal_gk_gj()\n  \" needs 80 column new window\n  new\n  vert 80new\n  call assert_beeps('normal gk')\n  put =[repeat('x',90)..' {{{1', 'x {{{1']\n  norm! gk\n  \" In a 80 column wide terminal the window will be only 78 char\n  \" (because Vim will leave space for the other window),\n  \" but if the terminal is larger, it will be 80 chars, so verify the\n  \" cursor column correctly.\n  call assert_equal(winwidth(0)+1, col('.'))\n  call assert_equal(winwidth(0)+1, virtcol('.'))\n  norm! j\n  call assert_equal(6, col('.'))\n  call assert_equal(6, virtcol('.'))\n  norm! gk\n  call assert_equal(95, col('.'))\n  call assert_equal(95, virtcol('.'))\n  %bw!\n\n  \" needs 80 column new window\n  new\n  vert 80new\n  call assert_beeps('normal gj')\n  set number\n  set numberwidth=10\n  set cpoptions+=n\n  put =[repeat('0',90), repeat('1',90)]\n  norm! 075l\n  call assert_equal(76, col('.'))\n  norm! gk\n  call assert_equal(1, col('.'))\n  norm! gk\n  call assert_equal(76, col('.'))\n  norm! gk\n  call assert_equal(1, col('.'))\n  norm! gj\n  call assert_equal(76, col('.'))\n  norm! gj\n  call assert_equal(1, col('.'))\n  norm! gj\n  call assert_equal(76, col('.'))\n  \" When 'nowrap' is set, gk and gj behave like k and j\n  set nowrap\n  normal! gk\n  call assert_equal([2, 76], [line('.'), col('.')])\n  normal! gj\n  call assert_equal([3, 76], [line('.'), col('.')])\n  %bw!\n  set cpoptions& number& numberwidth& wrap&\nendfunc\n\n\" Test for using : to run a multi-line Ex command in operator pending mode\nfunc Test_normal_yank_with_excmd()\n  new\n  call setline(1, ['foo', 'bar', 'baz'])\n  let @a = ''\n  call feedkeys(\"\\\"ay:if v:true\\<CR>normal l\\<CR>endif\\<CR>\", 'xt')\n  call assert_equal('f', @a)\n  close!\nendfunc\n\n\" Test for supplying a count to a normal-mode command across a cursorhold call\nfunc Test_normal_cursorhold_with_count()\n  func s:cHold()\n    let g:cHold_Called += 1\n  endfunc\n  new\n  augroup normalcHoldTest\n    au!\n    au CursorHold <buffer> call s:cHold()\n  augroup END\n  let g:cHold_Called = 0\n  call feedkeys(\"3\\<CursorHold>2ix\", 'xt')\n  call assert_equal(1, g:cHold_Called)\n  call assert_equal(repeat('x', 32), getline(1))\n  augroup normalcHoldTest\n    au!\n  augroup END\n  au! normalcHoldTest\n  close!\n  delfunc s:cHold\nendfunc\n\n\" Test for using a count and a command with CTRL-W\nfunc Test_wincmd_with_count()\n  call feedkeys(\"\\<C-W>12n\", 'xt')\n  call assert_equal(12, winheight(0))\nendfunc\n\n\" Test for 'b', 'B' 'ge' and 'gE' commands\nfunc Test_horiz_motion()\n  new\n  normal! gg\n  call assert_beeps('normal! b')\n  call assert_beeps('normal! B')\n  call assert_beeps('normal! gE')\n  call assert_beeps('normal! ge')\n  \" <S-Backspace> moves one word left and <C-Backspace> moves one WORD left\n  call setline(1, 'one ,two ,three')\n  exe \"normal! $\\<S-BS>\"\n  call assert_equal(11, col('.'))\n  exe \"normal! $\\<C-BS>\"\n  call assert_equal(10, col('.'))\n  close!\nendfunc\n\n\" Test for using a : command in operator pending mode\nfunc Test_normal_colon_op()\n  new\n  call setline(1, ['one', 'two'])\n  call assert_beeps(\"normal! Gc:d\\<CR>\")\n  close!\nendfunc\n\n\" Test for d and D commands\nfunc Test_normal_delete_cmd()\n  new\n  \" D in an empty line\n  call setline(1, '')\n  normal D\n  call assert_equal('', getline(1))\n  \" D in an empty line in virtualedit mode\n  set virtualedit=all\n  normal D\n  call assert_equal('', getline(1))\n  set virtualedit&\n  \" delete to a readonly register\n  call setline(1, ['abcd'])\n  call assert_beeps('normal \":d2l')\n\n  \" D and d with 'nomodifiable'\n  call setline(1, ['abcd'])\n  setlocal nomodifiable\n  call assert_fails('normal D', 'E21:')\n  call assert_fails('normal d$', 'E21:')\n\n  close!\nendfunc\n\n\" Test for deleting or changing characters across lines with 'whichwrap'\n\" containing 's'. Should count <EOL> as one character.\nfunc Test_normal_op_across_lines()\n  new\n  set whichwrap&\n  call setline(1, ['one two', 'three four'])\n  exe \"norm! $3d\\<Space>\"\n  call assert_equal(['one twhree four'], getline(1, '$'))\n\n  call setline(1, ['one two', 'three four'])\n  exe \"norm! $3c\\<Space>x\"\n  call assert_equal(['one twxhree four'], getline(1, '$'))\n\n  set whichwrap+=l\n  call setline(1, ['one two', 'three four'])\n  exe \"norm! $3x\"\n  call assert_equal(['one twhree four'], getline(1, '$'))\n  close!\n  set whichwrap&\nendfunc\n\n\" Test for 'w' and 'b' commands\nfunc Test_normal_word_move()\n  new\n  call setline(1, ['foo bar a', '', 'foo bar b'])\n  \" copy a single character word at the end of a line\n  normal 1G$yw\n  call assert_equal('a', @\")\n  \" copy a single character word at the end of a file\n  normal G$yw\n  call assert_equal('b', @\")\n  \" check for a word movement handling an empty line properly\n  normal 1G$vwy\n  call assert_equal(\"a\\n\\n\", @\")\n\n  \" copy using 'b' command\n  %d\n  \" non-empty blank line at the start of file\n  call setline(1, ['  ', 'foo bar'])\n  normal 2Gyb\n  call assert_equal(\"  \\n\", @\")\n  \" try to copy backwards from the start of the file\n  call setline(1, ['one two', 'foo bar'])\n  call assert_beeps('normal ggyb')\n  \" 'b' command should stop at an empty line\n  call setline(1, ['one two', '', 'foo bar'])\n  normal 3Gyb\n  call assert_equal(\"\\n\", @\")\n  normal 3Gy2b\n  call assert_equal(\"two\\n\", @\")\n  \" 'b' command should not stop at a non-empty blank line\n  call setline(1, ['one two', '  ', 'foo bar'])\n  normal 3Gyb\n  call assert_equal(\"two\\n  \", @\")\n\n  close!\nendfunc\n\n\" Test for 'scrolloff' with a long line that doesn't fit in the screen\nfunc Test_normal_scroloff()\n  10new\n  80vnew\n  call setline(1, repeat('a', 1000))\n  set scrolloff=10\n  normal gg10gj\n  call assert_equal(8, winline())\n  normal 10gj\n  call assert_equal(10, winline())\n  normal 10gk\n  call assert_equal(3, winline())\n  set scrolloff&\n  close!\nendfunc\n\n\" Test for vertical scrolling with CTRL-F and CTRL-B with a long line\nfunc Test_normal_vert_scroll_longline()\n  10new\n  80vnew\n  call setline(1, range(1, 10))\n  call append(5, repeat('a', 1000))\n  exe \"normal gg\\<C-F>\"\n  call assert_equal(6, line('.'))\n  exe \"normal \\<C-F>\\<C-F>\"\n  call assert_equal(11, line('.'))\n  call assert_equal(1, winline())\n  exe \"normal \\<C-B>\"\n  call assert_equal(10, line('.'))\n  call assert_equal(3, winline())\n  exe \"normal \\<C-B>\\<C-B>\"\n  call assert_equal(5, line('.'))\n  call assert_equal(5, winline())\n  close!\nendfunc\n\n\" Test for jumping in a file using %\nfunc Test_normal_percent_jump()\n  new\n  call setline(1, range(1, 100))\n\n  \" jumping to a folded line should open the fold\n  25,75fold\n  call feedkeys('50%', 'xt')\n  call assert_equal(50, line('.'))\n  call assert_equal(-1, foldclosedend(50))\n  close!\nendfunc\n\n\" Test for << and >> commands to shift text by 'shiftwidth'\nfunc Test_normal_shift_rightleft()\n  new\n  call setline(1, ['one', '', \"\\t\", '  two', \"\\tthree\", '      four'])\n  set shiftwidth=2 tabstop=8\n  normal gg6>>\n  call assert_equal(['  one', '', \"\\t  \", '    two', \"\\t  three\", \"\\tfour\"],\n        \\ getline(1, '$'))\n  normal ggVG2>>\n  call assert_equal(['      one', '', \"\\t      \", \"\\ttwo\",\n        \\ \"\\t      three\", \"\\t    four\"], getline(1, '$'))\n  normal gg6<<\n  call assert_equal(['    one', '', \"\\t    \", '      two', \"\\t    three\",\n        \\ \"\\t  four\"], getline(1, '$'))\n  normal ggVG2<<\n  call assert_equal(['one', '', \"\\t\", '  two', \"\\tthree\", '      four'],\n        \\ getline(1, '$'))\n  set shiftwidth& tabstop&\n  bw!\nendfunc\n\n\" Some commands like yy, cc, dd, >>, << and !! accept a count after\n\" typing the first letter of the command.\nfunc Test_normal_count_after_operator()\n  new\n  setlocal shiftwidth=4 tabstop=8 autoindent\n  call setline(1, ['one', 'two', 'three', 'four', 'five'])\n  let @a = ''\n  normal! j\"ay4y\n  call assert_equal(\"two\\nthree\\nfour\\nfive\\n\", @a)\n  normal! 3G>2>\n  call assert_equal(['one', 'two', '    three', '    four', 'five'],\n        \\ getline(1, '$'))\n  exe \"normal! 3G0c2cred\\nblue\"\n  call assert_equal(['one', 'two', '    red', '    blue', 'five'],\n        \\ getline(1, '$'))\n  exe \"normal! gg<8<\"\n  call assert_equal(['one', 'two', 'red', 'blue', 'five'],\n        \\ getline(1, '$'))\n  exe \"normal! ggd3d\"\n  call assert_equal(['blue', 'five'], getline(1, '$'))\n  call setline(1, range(1, 4))\n  call feedkeys(\"gg!3!\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\".,.+2!', @:)\n  call feedkeys(\"gg!1!\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\".!', @:)\n  call feedkeys(\"gg!9!\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\".,$!', @:)\n  bw!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * move.c: Functions for moving the cursor and scrolling text.\n *\n * There are two ways to move the cursor:\n * 1. Move the cursor directly, the text is scrolled to keep the cursor in the\n *    window.\n * 2. Scroll the text, the cursor is moved into the text visible in the\n *    window.\n * The 'scrolloff' option makes this a bit complicated.\n */\n\n#include \"vim.h\"\n\nstatic int scrolljump_value(void);\nstatic int check_top_offset(void);\nstatic void curs_rows(win_T *wp);\n\ntypedef struct\n{\n    linenr_T\t    lnum;\t// line number\n#ifdef FEAT_DIFF\n    int\t\t    fill;\t// filler lines\n#endif\n    int\t\t    height;\t// height of added line\n} lineoff_T;\n\nstatic void topline_back(lineoff_T *lp);\nstatic void botline_forw(lineoff_T *lp);\n\n/*\n * Compute wp->w_botline for the current wp->w_topline.  Can be called after\n * wp->w_topline changed.\n */\n    static void\ncomp_botline(win_T *wp)\n{\n    int\t\tn;\n    linenr_T\tlnum;\n    int\t\tdone;\n#ifdef FEAT_FOLDING\n    linenr_T    last;\n    int\t\tfolded;\n#endif\n\n    /*\n     * If w_cline_row is valid, start there.\n     * Otherwise have to start at w_topline.\n     */\n    check_cursor_moved(wp);\n    if (wp->w_valid & VALID_CROW)\n    {\n\tlnum = wp->w_cursor.lnum;\n\tdone = wp->w_cline_row;\n    }\n    else\n    {\n\tlnum = wp->w_topline;\n\tdone = 0;\n    }\n\n    for ( ; lnum <= wp->w_buffer->b_ml.ml_line_count; ++lnum)\n    {\n#ifdef FEAT_FOLDING\n\tlast = lnum;\n\tfolded = FALSE;\n\tif (hasFoldingWin(wp, lnum, NULL, &last, TRUE, NULL))\n\t{\n\t    n = 1;\n\t    folded = TRUE;\n\t}\n\telse\n#endif\n#ifdef FEAT_DIFF\n\t    if (lnum == wp->w_topline)\n\t\tn = plines_win_nofill(wp, lnum, TRUE) + wp->w_topfill;\n\t    else\n#endif\n\t\tn = plines_win(wp, lnum, TRUE);\n\tif (\n#ifdef FEAT_FOLDING\n\t\tlnum <= wp->w_cursor.lnum && last >= wp->w_cursor.lnum\n#else\n\t\tlnum == wp->w_cursor.lnum\n#endif\n\t   )\n\t{\n\t    wp->w_cline_row = done;\n\t    wp->w_cline_height = n;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = folded;\n#endif\n\t    redraw_for_cursorline(wp);\n\t    wp->w_valid |= (VALID_CROW|VALID_CHEIGHT);\n\t}\n\tif (done + n > wp->w_height)\n\t    break;\n\tdone += n;\n#ifdef FEAT_FOLDING\n\tlnum = last;\n#endif\n    }\n\n    // wp->w_botline is the line that is just below the window\n    wp->w_botline = lnum;\n    wp->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\n    set_empty_rows(wp, done);\n}\n\n#ifdef FEAT_SYN_HL\n    void\nreset_cursorline(void)\n{\n    curwin->w_last_cursorline = 0;\n}\n#endif\n\n/*\n * Redraw when w_cline_row changes and 'relativenumber' or 'cursorline' is\n * set.\n */\n    void\nredraw_for_cursorline(win_T *wp)\n{\n    if ((wp->w_p_rnu\n#ifdef FEAT_SYN_HL\n\t\t|| wp->w_p_cul\n#endif\n\t\t)\n\t    && (wp->w_valid & VALID_CROW) == 0\n\t    && !pum_visible())\n    {\n\tif (wp->w_p_rnu)\n\t    // win_line() will redraw the number column only.\n\t    redraw_win_later(wp, VALID);\n#ifdef FEAT_SYN_HL\n\tif (wp->w_p_cul)\n\t{\n\t    if (wp->w_redr_type <= VALID && wp->w_last_cursorline != 0)\n\t    {\n\t\t// \"w_last_cursorline\" may be outdated, worst case we redraw\n\t\t// too much.  This is optimized for moving the cursor around in\n\t\t// the current window.\n\t\tredrawWinline(wp, wp->w_last_cursorline);\n\t\tredrawWinline(wp, wp->w_cursor.lnum);\n\t    }\n\t    else\n\t\tredraw_win_later(wp, SOME_VALID);\n\t}\n#endif\n    }\n}\n\n/*\n * Update curwin->w_topline and redraw if necessary.\n * Used to update the screen before printing a message.\n */\n    void\nupdate_topline_redraw(void)\n{\n    update_topline();\n    if (must_redraw)\n\tupdate_screen(0);\n}\n\n/*\n * Update curwin->w_topline to move the cursor onto the screen.\n */\n    void\nupdate_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n    linenr_T\told_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill;\n#endif\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t     >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t   + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tif (curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_skipcol = 0;\n\t    redraw_later(NOT_VALID);\n\t}\n\telse\n\t    redraw_later(VALID);\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}\n\n/*\n * Return the scrolljump value to use for the current window.\n * When 'scrolljump' is positive use it as-is.\n * When 'scrolljump' is negative use it as a percentage of the window height.\n */\n    static int\nscrolljump_value(void)\n{\n    if (p_sj >= 0)\n\treturn (int)p_sj;\n    return (curwin->w_height * -p_sj) / 100;\n}\n\n/*\n * Return TRUE when there are not 'scrolloff' lines above the cursor for the\n * current window.\n */\n    static int\ncheck_top_offset(void)\n{\n    lineoff_T\tloff;\n    int\t\tn;\n    long        so = get_scrolloff_value();\n\n    if (curwin->w_cursor.lnum < curwin->w_topline + so\n#ifdef FEAT_FOLDING\n\t\t    || hasAnyFolding(curwin)\n#endif\n\t    )\n    {\n\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n\tn = curwin->w_topfill;\t    // always have this context\n#else\n\tn = 0;\n#endif\n\t// Count the visible screen lines above the cursor line.\n\twhile (n < so)\n\t{\n\t    topline_back(&loff);\n\t    // Stop when included a line above the window.\n\t    if (loff.lnum < curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t    || (loff.lnum == curwin->w_topline && loff.fill > 0)\n#endif\n\t\t    )\n\t\tbreak;\n\t    n += loff.height;\n\t}\n\tif (n < so)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n    void\nupdate_curswant(void)\n{\n    if (curwin->w_set_curswant)\n    {\n\tvalidate_virtcol();\n\tcurwin->w_curswant = curwin->w_virtcol;\n\tcurwin->w_set_curswant = FALSE;\n    }\n}\n\n/*\n * Check if the cursor has moved.  Set the w_valid flag accordingly.\n */\n    void\ncheck_cursor_moved(win_T *wp)\n{\n    if (wp->w_cursor.lnum != wp->w_valid_cursor.lnum)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t     |VALID_CHEIGHT|VALID_CROW|VALID_TOPLINE);\n\twp->w_valid_cursor = wp->w_cursor;\n\twp->w_valid_leftcol = wp->w_leftcol;\n    }\n    else if (wp->w_cursor.col != wp->w_valid_cursor.col\n\t     || wp->w_leftcol != wp->w_valid_leftcol\n\t     || wp->w_cursor.coladd != wp->w_valid_cursor.coladd)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\twp->w_valid_cursor.col = wp->w_cursor.col;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_cursor.coladd = wp->w_cursor.coladd;\n    }\n}\n\n/*\n * Call this function when some window settings have changed, which require\n * the cursor position, botline and topline to be recomputed and the window to\n * be redrawn.  E.g, when changing the 'wrap' option or folding.\n */\n    void\nchanged_window_setting(void)\n{\n    changed_window_setting_win(curwin);\n}\n\n    void\nchanged_window_setting_win(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP|VALID_TOPLINE);\n    redraw_win_later(wp, NOT_VALID);\n}\n\n/*\n * Set wp->w_topline to a certain number.\n */\n    void\nset_topline(win_T *wp, linenr_T lnum)\n{\n#ifdef FEAT_DIFF\n    linenr_T prev_topline = wp->w_topline;\n#endif\n\n#ifdef FEAT_FOLDING\n    // go to first of folded lines\n    (void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n    // Approximate the value of w_botline\n    wp->w_botline += lnum - wp->w_topline;\n    if (wp->w_botline > wp->w_buffer->b_ml.ml_line_count + 1)\n\twp->w_botline = wp->w_buffer->b_ml.ml_line_count + 1;\n    wp->w_topline = lnum;\n    wp->w_topline_was_set = TRUE;\n#ifdef FEAT_DIFF\n    if (lnum != prev_topline)\n\t// Keep the filler lines when the topline didn't change.\n\twp->w_topfill = 0;\n#endif\n    wp->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE);\n    // Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.\n    redraw_later(VALID);\n}\n\n/*\n * Call this function when the length of the cursor line (in screen\n * characters) has changed, and the change is before the cursor.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_cline_bef_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_cline_bef_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n/*\n * Call this function when the length of a line (in screen characters) above\n * the cursor have changed.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_line_abv_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_line_abv_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n/*\n * Make sure the value of curwin->w_botline is valid.\n */\n    void\nvalidate_botline(void)\n{\n    validate_botline_win(curwin);\n}\n\n/*\n * Make sure the value of wp->w_botline is valid.\n */\n    void\nvalidate_botline_win(win_T *wp)\n{\n    if (!(wp->w_valid & VALID_BOTLINE))\n\tcomp_botline(wp);\n}\n\n/*\n * Mark curwin->w_botline as invalid (because of some change in the buffer).\n */\n    void\ninvalidate_botline(void)\n{\n    curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\ninvalidate_botline_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\napproximate_botline_win(\n    win_T\t*wp)\n{\n    wp->w_valid &= ~VALID_BOTLINE;\n}\n\n/*\n * Return TRUE if curwin->w_wrow and curwin->w_wcol are valid.\n */\n    int\ncursor_valid(void)\n{\n    check_cursor_moved(curwin);\n    return ((curwin->w_valid & (VALID_WROW|VALID_WCOL)) ==\n\t\t\t\t\t\t      (VALID_WROW|VALID_WCOL));\n}\n\n/*\n * Validate cursor position.  Makes sure w_wrow and w_wcol are valid.\n * w_topline must be valid, you may need to call update_topline() first!\n */\n    void\nvalidate_cursor(void)\n{\n    check_cursor_moved(curwin);\n    if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))\n\tcurs_columns(TRUE);\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * validate w_cline_row.\n */\n    void\nvalidate_cline_row(void)\n{\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    update_topline();\n    check_cursor_moved(curwin);\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n}\n#endif\n\n/*\n * Compute wp->w_cline_row and wp->w_cline_height, based on the current value\n * of wp->w_topline.\n */\n    static void\ncurs_rows(win_T *wp)\n{\n    linenr_T\tlnum;\n    int\t\ti;\n    int\t\tall_invalid;\n    int\t\tvalid;\n#ifdef FEAT_FOLDING\n    long\tfold_count;\n#endif\n\n    // Check if wp->w_lines[].wl_size is invalid\n    all_invalid = (!redrawing()\n\t\t\t|| wp->w_lines_valid == 0\n\t\t\t|| wp->w_lines[0].wl_lnum > wp->w_topline);\n    i = 0;\n    wp->w_cline_row = 0;\n    for (lnum = wp->w_topline; lnum < wp->w_cursor.lnum; ++i)\n    {\n\tvalid = FALSE;\n\tif (!all_invalid && i < wp->w_lines_valid)\n\t{\n\t    if (wp->w_lines[i].wl_lnum < lnum || !wp->w_lines[i].wl_valid)\n\t\tcontinue;\t\t// skip changed or deleted lines\n\t    if (wp->w_lines[i].wl_lnum == lnum)\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Check for newly inserted lines below this row, in which\n\t\t// case we need to check for folded lines.\n\t\tif (!wp->w_buffer->b_mod_set\n\t\t\t|| wp->w_lines[i].wl_lastlnum < wp->w_cursor.lnum\n\t\t\t|| wp->w_buffer->b_mod_top\n\t\t\t\t\t     > wp->w_lines[i].wl_lastlnum + 1)\n#endif\n\t\tvalid = TRUE;\n\t    }\n\t    else if (wp->w_lines[i].wl_lnum > lnum)\n\t\t--i;\t\t\t// hold at inserted lines\n\t}\n\tif (valid\n#ifdef FEAT_DIFF\n\t\t&& (lnum != wp->w_topline || !wp->w_p_diff)\n#endif\n\t\t)\n\t{\n#ifdef FEAT_FOLDING\n\t    lnum = wp->w_lines[i].wl_lastlnum + 1;\n\t    // Cursor inside folded lines, don't count this row\n\t    if (lnum > wp->w_cursor.lnum)\n\t\tbreak;\n#else\n\t    ++lnum;\n#endif\n\t    wp->w_cline_row += wp->w_lines[i].wl_size;\n\t}\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    fold_count = foldedCount(wp, lnum, NULL);\n\t    if (fold_count)\n\t    {\n\t\tlnum += fold_count;\n\t\tif (lnum > wp->w_cursor.lnum)\n\t\t    break;\n\t\t++wp->w_cline_row;\n\t    }\n\t    else\n#endif\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    wp->w_cline_row += plines_win_nofill(wp, lnum++, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    wp->w_cline_row += plines_win(wp, lnum++, TRUE);\n\t}\n    }\n\n    check_cursor_moved(wp);\n    if (!(wp->w_valid & VALID_CHEIGHT))\n    {\n\tif (all_invalid\n\t\t|| i == wp->w_lines_valid\n\t\t|| (i < wp->w_lines_valid\n\t\t    && (!wp->w_lines[i].wl_valid\n\t\t\t|| wp->w_lines[i].wl_lnum != wp->w_cursor.lnum)))\n\t{\n#ifdef FEAT_DIFF\n\t    if (wp->w_cursor.lnum == wp->w_topline)\n\t\twp->w_cline_height = plines_win_nofill(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t\tTRUE) + wp->w_topfill;\n\t    else\n#endif\n\t\twp->w_cline_height = plines_win(wp, wp->w_cursor.lnum, TRUE);\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse if (i > wp->w_lines_valid)\n\t{\n\t    // a line that is too long to fit on the last screen line\n\t    wp->w_cline_height = 0;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse\n\t{\n\t    wp->w_cline_height = wp->w_lines[i].wl_size;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = wp->w_lines[i].wl_folded;\n#endif\n\t}\n    }\n\n    redraw_for_cursorline(curwin);\n    wp->w_valid |= VALID_CROW|VALID_CHEIGHT;\n\n}\n\n/*\n * Validate curwin->w_virtcol only.\n */\n    void\nvalidate_virtcol(void)\n{\n    validate_virtcol_win(curwin);\n}\n\n/*\n * Validate wp->w_virtcol only.\n */\n    void\nvalidate_virtcol_win(win_T *wp)\n{\n    check_cursor_moved(wp);\n    if (!(wp->w_valid & VALID_VIRTCOL))\n    {\n\tgetvvcol(wp, &wp->w_cursor, NULL, &(wp->w_virtcol), NULL);\n\twp->w_valid |= VALID_VIRTCOL;\n#ifdef FEAT_SYN_HL\n\tif (wp->w_p_cuc && !pum_visible())\n\t    redraw_win_later(wp, SOME_VALID);\n#endif\n    }\n}\n\n/*\n * Validate curwin->w_cline_height only.\n */\n    void\nvalidate_cheight(void)\n{\n    check_cursor_moved(curwin);\n    if (!(curwin->w_valid & VALID_CHEIGHT))\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    curwin->w_cline_height = plines_nofill(curwin->w_cursor.lnum)\n\t\t\t\t\t\t\t  + curwin->w_topfill;\n\telse\n#endif\n\t    curwin->w_cline_height = plines(curwin->w_cursor.lnum);\n#ifdef FEAT_FOLDING\n\tcurwin->w_cline_folded = hasFolding(curwin->w_cursor.lnum, NULL, NULL);\n#endif\n\tcurwin->w_valid |= VALID_CHEIGHT;\n    }\n}\n\n/*\n * Validate w_wcol and w_virtcol only.\n */\n    void\nvalidate_cursor_col(void)\n{\n    colnr_T off;\n    colnr_T col;\n    int     width;\n\n    validate_virtcol();\n    if (!(curwin->w_valid & VALID_WCOL))\n    {\n\tcol = curwin->w_virtcol;\n\toff = curwin_col_off();\n\tcol += off;\n\twidth = curwin->w_width - off + curwin_col_off2();\n\n\t// long line wrapping, adjust curwin->w_wrow\n\tif (curwin->w_p_wrap\n\t\t&& col >= (colnr_T)curwin->w_width\n\t\t&& width > 0)\n\t    // use same formula as what is used in curs_columns()\n\t    col -= ((col - curwin->w_width) / width + 1) * width;\n\tif (col > (int)curwin->w_leftcol)\n\t    col -= curwin->w_leftcol;\n\telse\n\t    col = 0;\n\tcurwin->w_wcol = col;\n\n\tcurwin->w_valid |= VALID_WCOL;\n#ifdef FEAT_PROP_POPUP\n\tcurwin->w_flags &= ~WFLAG_WCOL_OFF_ADDED;\n#endif\n    }\n}\n\n/*\n * Compute offset of a window, occupied by absolute or relative line number,\n * fold column and sign column (these don't move when scrolling horizontally).\n */\n    int\nwin_col_off(win_T *wp)\n{\n    return (((wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) + 1 : 0)\n#ifdef FEAT_CMDWIN\n\t    + (cmdwin_type == 0 || wp != curwin ? 0 : 1)\n#endif\n#ifdef FEAT_FOLDING\n\t    + wp->w_p_fdc\n#endif\n#ifdef FEAT_SIGNS\n\t    + (signcolumn_on(wp) ? 2 : 0)\n#endif\n\t   );\n}\n\n    int\ncurwin_col_off(void)\n{\n    return win_col_off(curwin);\n}\n\n/*\n * Return the difference in column offset for the second screen line of a\n * wrapped line.  It's 8 if 'number' or 'relativenumber' is on and 'n' is in\n * 'cpoptions'.\n */\n    int\nwin_col_off2(win_T *wp)\n{\n    if ((wp->w_p_nu || wp->w_p_rnu) && vim_strchr(p_cpo, CPO_NUMCOL) != NULL)\n\treturn number_width(wp) + 1;\n    return 0;\n}\n\n    int\ncurwin_col_off2(void)\n{\n    return win_col_off2(curwin);\n}\n\n/*\n * Compute curwin->w_wcol and curwin->w_virtcol.\n * Also updates curwin->w_wrow and curwin->w_cline_row.\n * Also updates curwin->w_leftcol.\n */\n    void\ncurs_columns(\n    int\t\tmay_scroll)\t// when TRUE, may scroll horizontally\n{\n    int\t\tdiff;\n    int\t\textra;\t\t// offset for first screen line\n    int\t\toff_left, off_right;\n    int\t\tn;\n    int\t\tp_lines;\n    int\t\twidth = 0;\n    int\t\ttextwidth;\n    int\t\tnew_leftcol;\n    colnr_T\tstartcol;\n    colnr_T\tendcol;\n    colnr_T\tprev_skipcol;\n    long        so = get_scrolloff_value();\n    long        siso = get_sidescrolloff_value();\n\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    update_topline();\n\n    /*\n     * Next make sure that w_cline_row is valid.\n     */\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n\n    /*\n     * Compute the number of virtual columns.\n     */\n#ifdef FEAT_FOLDING\n    if (curwin->w_cline_folded)\n\t// In a folded line the cursor is always in the first column\n\tstartcol = curwin->w_virtcol = endcol = curwin->w_leftcol;\n    else\n#endif\n\tgetvvcol(curwin, &curwin->w_cursor,\n\t\t\t\t&startcol, &(curwin->w_virtcol), &endcol);\n\n    // remove '$' from change command when cursor moves onto it\n    if (startcol > dollar_vcol)\n\tdollar_vcol = -1;\n\n    extra = curwin_col_off();\n    curwin->w_wcol = curwin->w_virtcol + extra;\n    endcol += extra;\n\n    /*\n     * Now compute w_wrow, counting screen lines from w_cline_row.\n     */\n    curwin->w_wrow = curwin->w_cline_row;\n\n    textwidth = curwin->w_width - extra;\n    if (textwidth <= 0)\n    {\n\t// No room for text, put cursor in last char of window.\n\t// If not wrapping, the last non-empty line.\n\tcurwin->w_wcol = curwin->w_width - 1;\n\tif (curwin->w_p_wrap)\n\t    curwin->w_wrow = curwin->w_height - 1;\n\telse\n\t    curwin->w_wrow = curwin->w_height - 1 - curwin->w_empty_rows;\n    }\n    else if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\twidth = textwidth + curwin_col_off2();\n\n\t// long line wrapping, adjust curwin->w_wrow\n\tif (curwin->w_wcol >= curwin->w_width)\n\t{\n#ifdef FEAT_LINEBREAK\n\t    char_u *sbr;\n#endif\n\n\t    // this same formula is used in validate_cursor_col()\n\t    n = (curwin->w_wcol - curwin->w_width) / width + 1;\n\t    curwin->w_wcol -= n * width;\n\t    curwin->w_wrow += n;\n\n#ifdef FEAT_LINEBREAK\n\t    // When cursor wraps to first char of next line in Insert\n\t    // mode, the 'showbreak' string isn't shown, backup to first\n\t    // column\n\t    sbr = get_showbreak_value(curwin);\n\t    if (*sbr && *ml_get_cursor() == NUL\n\t\t\t\t    && curwin->w_wcol == vim_strsize(sbr))\n\t\tcurwin->w_wcol = 0;\n#endif\n\t}\n    }\n\n    // No line wrapping: compute curwin->w_leftcol if scrolling is on and line\n    // is not folded.\n    // If scrolling is off, curwin->w_leftcol is assumed to be 0\n    else if (may_scroll\n#ifdef FEAT_FOLDING\n\t    && !curwin->w_cline_folded\n#endif\n\t    )\n    {\n\t/*\n\t * If Cursor is left of the screen, scroll rightwards.\n\t * If Cursor is right of the screen, scroll leftwards\n\t * If we get closer to the edge than 'sidescrolloff', scroll a little\n\t * extra\n\t */\n\toff_left = (int)startcol - (int)curwin->w_leftcol - siso;\n\toff_right = (int)endcol - (int)(curwin->w_leftcol + curwin->w_width\n\t\t\t\t\t\t\t\t- siso) + 1;\n\tif (off_left < 0 || off_right > 0)\n\t{\n\t    if (off_left < 0)\n\t\tdiff = -off_left;\n\t    else\n\t\tdiff = off_right;\n\n\t    // When far off or not enough room on either side, put cursor in\n\t    // middle of window.\n\t    if (p_ss == 0 || diff >= textwidth / 2 || off_right >= off_left)\n\t\tnew_leftcol = curwin->w_wcol - extra - textwidth / 2;\n\t    else\n\t    {\n\t\tif (diff < p_ss)\n\t\t    diff = p_ss;\n\t\tif (off_left < 0)\n\t\t    new_leftcol = curwin->w_leftcol - diff;\n\t\telse\n\t\t    new_leftcol = curwin->w_leftcol + diff;\n\t    }\n\t    if (new_leftcol < 0)\n\t\tnew_leftcol = 0;\n\t    if (new_leftcol != (int)curwin->w_leftcol)\n\t    {\n\t\tcurwin->w_leftcol = new_leftcol;\n\t\t// screen has to be redrawn with new curwin->w_leftcol\n\t\tredraw_later(NOT_VALID);\n\t    }\n\t}\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    }\n    else if (curwin->w_wcol > (int)curwin->w_leftcol)\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    else\n\tcurwin->w_wcol = 0;\n\n#ifdef FEAT_DIFF\n    // Skip over filler lines.  At the top use w_topfill, there\n    // may be some filler lines above the window.\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_wrow += curwin->w_topfill;\n    else\n\tcurwin->w_wrow += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    prev_skipcol = curwin->w_skipcol;\n\n    p_lines = 0;\n\n    if ((curwin->w_wrow >= curwin->w_height\n\t\t|| ((prev_skipcol > 0\n\t\t\t|| curwin->w_wrow + so >= curwin->w_height)\n\t\t    && (p_lines =\n#ifdef FEAT_DIFF\n\t\t\tplines_win_nofill\n#else\n\t\t\tplines_win\n#endif\n\t\t\t(curwin, curwin->w_cursor.lnum, FALSE))\n\t\t\t\t\t\t    - 1 >= curwin->w_height))\n\t    && curwin->w_height != 0\n\t    && curwin->w_cursor.lnum == curwin->w_topline\n\t    && width > 0\n\t    && curwin->w_width != 0)\n    {\n\t// Cursor past end of screen.  Happens with a single line that does\n\t// not fit on screen.  Find a skipcol to show the text around the\n\t// cursor.  Avoid scrolling all the time. compute value of \"extra\":\n\t// 1: Less than 'scrolloff' lines above\n\t// 2: Less than 'scrolloff' lines below\n\t// 3: both of them\n\textra = 0;\n\tif (curwin->w_skipcol + so * width > curwin->w_virtcol)\n\t    extra = 1;\n\t// Compute last display line of the buffer line that we want at the\n\t// bottom of the window.\n\tif (p_lines == 0)\n\t    p_lines = plines_win(curwin, curwin->w_cursor.lnum, FALSE);\n\t--p_lines;\n\tif (p_lines > curwin->w_wrow + so)\n\t    n = curwin->w_wrow + so;\n\telse\n\t    n = p_lines;\n\tif ((colnr_T)n >= curwin->w_height + curwin->w_skipcol / width - so)\n\t    extra += 2;\n\n\tif (extra == 3 || p_lines <= so * 2)\n\t{\n\t    // not enough room for 'scrolloff', put cursor in the middle\n\t    n = curwin->w_virtcol / width;\n\t    if (n > curwin->w_height / 2)\n\t\tn -= curwin->w_height / 2;\n\t    else\n\t\tn = 0;\n\t    // don't skip more than necessary\n\t    if (n > p_lines - curwin->w_height + 1)\n\t\tn = p_lines - curwin->w_height + 1;\n\t    curwin->w_skipcol = n * width;\n\t}\n\telse if (extra == 1)\n\t{\n\t    // less then 'scrolloff' lines above, decrease skipcol\n\t    extra = (curwin->w_skipcol + so * width - curwin->w_virtcol\n\t\t\t\t     + width - 1) / width;\n\t    if (extra > 0)\n\t    {\n\t\tif ((colnr_T)(extra * width) > curwin->w_skipcol)\n\t\t    extra = curwin->w_skipcol / width;\n\t\tcurwin->w_skipcol -= extra * width;\n\t    }\n\t}\n\telse if (extra == 2)\n\t{\n\t    // less then 'scrolloff' lines below, increase skipcol\n\t    endcol = (n - curwin->w_height + 1) * width;\n\t    while (endcol > curwin->w_virtcol)\n\t\tendcol -= width;\n\t    if (endcol > curwin->w_skipcol)\n\t\tcurwin->w_skipcol = endcol;\n\t}\n\n\tcurwin->w_wrow -= curwin->w_skipcol / width;\n\tif (curwin->w_wrow >= curwin->w_height)\n\t{\n\t    // small window, make sure cursor is in it\n\t    extra = curwin->w_wrow - curwin->w_height + 1;\n\t    curwin->w_skipcol += extra * width;\n\t    curwin->w_wrow -= extra;\n\t}\n\n\textra = ((int)prev_skipcol - (int)curwin->w_skipcol) / width;\n\tif (extra > 0)\n\t    win_ins_lines(curwin, 0, extra, FALSE, FALSE);\n\telse if (extra < 0)\n\t    win_del_lines(curwin, 0, -extra, FALSE, FALSE, 0);\n    }\n    else\n\tcurwin->w_skipcol = 0;\n    if (prev_skipcol != curwin->w_skipcol)\n\tredraw_later(NOT_VALID);\n\n#ifdef FEAT_SYN_HL\n    // Redraw when w_virtcol changes and 'cursorcolumn' is set\n    if (curwin->w_p_cuc && (curwin->w_valid & VALID_VIRTCOL) == 0\n\t    && !pum_visible())\n\tredraw_later(SOME_VALID);\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\n    if (popup_is_popup(curwin) && curbuf->b_term != NULL)\n    {\n\tcurwin->w_wrow += popup_top_extra(curwin);\n\tcurwin->w_wcol += popup_left_extra(curwin);\n\tcurwin->w_flags |= WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED;\n    }\n    else\n\tcurwin->w_flags &= ~(WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED);\n#endif\n\n    // now w_leftcol is valid, avoid check_cursor_moved() thinking otherwise\n    curwin->w_valid_leftcol = curwin->w_leftcol;\n\n    curwin->w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;\n}\n\n#if (defined(FEAT_EVAL) || defined(FEAT_PROP_POPUP)) || defined(PROTO)\n/*\n * Compute the screen position of text character at \"pos\" in window \"wp\"\n * The resulting values are one-based, zero when character is not visible.\n */\n    void\ntextpos2screenpos(\n\twin_T\t*wp,\n\tpos_T\t*pos,\n\tint\t*rowp,\t// screen row\n\tint\t*scolp,\t// start screen column\n\tint\t*ccolp,\t// cursor screen column\n\tint\t*ecolp)\t// end screen column\n{\n    colnr_T\tscol = 0, ccol = 0, ecol = 0;\n    int\t\trow = 0;\n    int\t\trowoff = 0;\n    colnr_T\tcoloff = 0;\n\n    if (pos->lnum >= wp->w_topline && pos->lnum <= wp->w_botline)\n    {\n\tcolnr_T off;\n\tcolnr_T col;\n\tint     width;\n\n\trow = plines_m_win(wp, wp->w_topline, pos->lnum - 1) + 1;\n\tgetvcol(wp, pos, &scol, &ccol, &ecol);\n\n\t// similar to what is done in validate_cursor_col()\n\tcol = scol;\n\toff = win_col_off(wp);\n\tcol += off;\n\twidth = wp->w_width - off + win_col_off2(wp);\n\n\t// long line wrapping, adjust row\n\tif (wp->w_p_wrap\n\t\t&& col >= (colnr_T)wp->w_width\n\t\t&& width > 0)\n\t{\n\t    // use same formula as what is used in curs_columns()\n\t    rowoff = ((col - wp->w_width) / width + 1);\n\t    col -= rowoff * width;\n\t}\n\tcol -= wp->w_leftcol;\n\tif (col >= wp->w_width)\n\t    col = -1;\n\tif (col >= 0 && row + rowoff <= wp->w_height)\n\t    coloff = col - scol + wp->w_wincol + 1;\n\telse\n\t    // character is left, right or below of the window\n\t    row = rowoff = scol = ccol = ecol = 0;\n    }\n    *rowp = W_WINROW(wp) + row + rowoff;\n    *scolp = scol + coloff;\n    *ccolp = ccol + coloff;\n    *ecolp = ecol + coloff;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"screenpos({winid}, {lnum}, {col})\" function\n */\n    void\nf_screenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    dict_T\t*dict;\n    win_T\t*wp;\n    pos_T\tpos;\n    int\t\trow = 0;\n    int\t\tscol = 0, ccol = 0, ecol = 0;\n\n    if (rettv_dict_alloc(rettv) != OK)\n\treturn;\n    dict = rettv->vval.v_dict;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    pos.lnum = tv_get_number(&argvars[1]);\n    pos.col = tv_get_number(&argvars[2]) - 1;\n    pos.coladd = 0;\n    textpos2screenpos(wp, &pos, &row, &scol, &ccol, &ecol);\n\n    dict_add_number(dict, \"row\", row);\n    dict_add_number(dict, \"col\", scol);\n    dict_add_number(dict, \"curscol\", ccol);\n    dict_add_number(dict, \"endcol\", ecol);\n}\n#endif\n\n/*\n * Scroll the current window down by \"line_count\" logical lines.  \"CTRL-Y\"\n */\n    void\nscrolldown(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n    long\tdone = 0;\t// total # of physical lines done\n    int\t\twrow;\n    int\t\tmoved = FALSE;\n\n#ifdef FEAT_FOLDING\n    linenr_T\tfirst;\n\n    // Make sure w_topline is at the first of a sequence of folded lines.\n    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    validate_cursor();\t\t// w_wrow needs to be valid\n    while (line_count-- > 0)\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill < diff_check(curwin, curwin->w_topline)\n\t\t&& curwin->w_topfill < curwin->w_height - 1)\n\t{\n\t    ++curwin->w_topfill;\n\t    ++done;\n\t}\n\telse\n#endif\n\t{\n\t    if (curwin->w_topline == 1)\n\t\tbreak;\n\t    --curwin->w_topline;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = 0;\n#endif\n#ifdef FEAT_FOLDING\n\t    // A sequence of folded lines only counts for one logical line\n\t    if (hasFolding(curwin->w_topline, &first, NULL))\n\t    {\n\t\t++done;\n\t\tif (!byfold)\n\t\t    line_count -= curwin->w_topline - first - 1;\n\t\tcurwin->w_botline -= curwin->w_topline - first;\n\t\tcurwin->w_topline = first;\n\t    }\n\t    else\n#endif\n\t\tdone += PLINES_NOFILL(curwin->w_topline);\n\t}\n\t--curwin->w_botline;\t\t// approximate w_botline\n\tinvalidate_botline();\n    }\n    curwin->w_wrow += done;\t\t// keep w_wrow updated\n    curwin->w_cline_row += done;\t// keep w_cline_row updated\n\n#ifdef FEAT_DIFF\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_cline_row = 0;\n    check_topfill(curwin, TRUE);\n#endif\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and move the cursor onto the displayed part of the window.\n     */\n    wrow = curwin->w_wrow;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tvalidate_cheight();\n\twrow += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    while (wrow >= curwin->w_height && curwin->w_cursor.lnum > 1)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(curwin->w_cursor.lnum, &first, NULL))\n\t{\n\t    --wrow;\n\t    if (first == 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n\t\tcurwin->w_cursor.lnum = first - 1;\n\t}\n\telse\n#endif\n\t    wrow -= plines(curwin->w_cursor.lnum--);\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tmoved = TRUE;\n    }\n    if (moved)\n    {\n#ifdef FEAT_FOLDING\n\t// Move cursor to first line of closed fold.\n\tfoldAdjustCursor();\n#endif\n\tcoladvance(curwin->w_curswant);\n    }\n}\n\n/*\n * Scroll the current window up by \"line_count\" logical lines.  \"CTRL-E\"\n */\n    void\nscrollup(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n#if defined(FEAT_FOLDING) || defined(FEAT_DIFF)\n    linenr_T\tlnum;\n\n    if (\n# ifdef FEAT_FOLDING\n\t    (byfold && hasAnyFolding(curwin))\n#  ifdef FEAT_DIFF\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_DIFF\n\t    curwin->w_p_diff\n# endif\n\t    )\n    {\n\t// count each sequence of folded lines as one logical line\n\tlnum = curwin->w_topline;\n\twhile (line_count--)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t\t--curwin->w_topfill;\n\t    else\n# endif\n\t    {\n# ifdef FEAT_FOLDING\n\t\tif (byfold)\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n# endif\n\t\tif (lnum >= curbuf->b_ml.ml_line_count)\n\t\t    break;\n\t\t++lnum;\n# ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = diff_check_fill(curwin, lnum);\n# endif\n\t    }\n\t}\n\t// approximate w_botline\n\tcurwin->w_botline += lnum - curwin->w_topline;\n\tcurwin->w_topline = lnum;\n    }\n    else\n#endif\n    {\n\tcurwin->w_topline += line_count;\n\tcurwin->w_botline += line_count;\t// approximate w_botline\n    }\n\n    if (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n    if (curwin->w_botline > curbuf->b_ml.ml_line_count + 1)\n\tcurwin->w_botline = curbuf->b_ml.ml_line_count + 1;\n\n#ifdef FEAT_DIFF\n    check_topfill(curwin, FALSE);\n#endif\n\n#ifdef FEAT_FOLDING\n    if (hasAnyFolding(curwin))\n\t// Make sure w_topline is at the first of a sequence of folded lines.\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n    {\n\tcurwin->w_cursor.lnum = curwin->w_topline;\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tcoladvance(curwin->w_curswant);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Don't end up with too many filler lines in the window.\n */\n    void\ncheck_topfill(\n    win_T\t*wp,\n    int\t\tdown)\t// when TRUE scroll down when not enough space\n{\n    int\t\tn;\n\n    if (wp->w_topfill > 0)\n    {\n\tn = plines_win_nofill(wp, wp->w_topline, TRUE);\n\tif (wp->w_topfill + n > wp->w_height)\n\t{\n\t    if (down && wp->w_topline > 1)\n\t    {\n\t\t--wp->w_topline;\n\t\twp->w_topfill = 0;\n\t    }\n\t    else\n\t    {\n\t\twp->w_topfill = wp->w_height - n;\n\t\tif (wp->w_topfill < 0)\n\t\t    wp->w_topfill = 0;\n\t    }\n\t}\n    }\n}\n\n/*\n * Use as many filler lines as possible for w_topline.  Make sure w_topline\n * is still visible.\n */\n    static void\nmax_topfill(void)\n{\n    int\t\tn;\n\n    n = plines_nofill(curwin->w_topline);\n    if (n >= curwin->w_height)\n\tcurwin->w_topfill = 0;\n    else\n    {\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill + n > curwin->w_height)\n\t    curwin->w_topfill = curwin->w_height - n;\n    }\n}\n#endif\n\n/*\n * Scroll the screen one line down, but don't do it if it would move the\n * cursor off the screen.\n */\n    void\nscrolldown_clamp(void)\n{\n    int\t\tend_row;\n#ifdef FEAT_DIFF\n    int\t\tcan_fill = (curwin->w_topfill\n\t\t\t\t< diff_check_fill(curwin, curwin->w_topline));\n#endif\n\n    if (curwin->w_topline <= 1\n#ifdef FEAT_DIFF\n\t    && !can_fill\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go past 'scrolloff' lines from the screen end.\n     */\n    end_row = curwin->w_wrow;\n#ifdef FEAT_DIFF\n    if (can_fill)\n\t++end_row;\n    else\n\tend_row += plines_nofill(curwin->w_topline - 1);\n#else\n    end_row += plines(curwin->w_topline - 1);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_cheight();\n\tvalidate_virtcol();\n\tend_row += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    if (end_row < curwin->w_height - get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (can_fill)\n\t{\n\t    ++curwin->w_topfill;\n\t    check_topfill(curwin, TRUE);\n\t}\n\telse\n\t{\n\t    --curwin->w_topline;\n\t    curwin->w_topfill = 0;\n\t}\n#else\n\t--curwin->w_topline;\n#endif\n#ifdef FEAT_FOLDING\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t--curwin->w_botline;\t    // approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Scroll the screen one line up, but don't do it if it would move the cursor\n * off the screen.\n */\n    void\nscrollup_clamp(void)\n{\n    int\t    start_row;\n\n    if (curwin->w_topline == curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t    && curwin->w_topfill == 0\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the first row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go before 'scrolloff' lines from the screen start.\n     */\n#ifdef FEAT_DIFF\n    start_row = curwin->w_wrow - plines_nofill(curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#else\n    start_row = curwin->w_wrow - plines(curwin->w_topline);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tstart_row -= curwin->w_virtcol / curwin->w_width;\n    }\n    if (start_row >= get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill > 0)\n\t    --curwin->w_topfill;\n\telse\n#endif\n\t{\n#ifdef FEAT_FOLDING\n\t    (void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t    ++curwin->w_topline;\n\t}\n\t++curwin->w_botline;\t\t// approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Add one line above \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines above the first one are incredibly high: MAXCOL.\n */\n    static void\ntopline_back(lineoff_T *lp)\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t--lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum < 1)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, &lp->lnum, NULL))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_NOFILL(lp->lnum);\n    }\n}\n\n/*\n * Add one line below \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines below the last one are incredibly high.\n */\n    static void\nbotline_forw(lineoff_T *lp)\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum + 1))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t++lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum > curbuf->b_ml.ml_line_count)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, NULL, &lp->lnum))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_NOFILL(lp->lnum);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Switch from including filler lines below lp->lnum to including filler\n * lines above loff.lnum + 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\nbotline_topline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\t++lp->lnum;\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n    }\n}\n\n/*\n * Switch from including filler lines above lp->lnum to including filler\n * lines below loff.lnum - 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\ntopline_botline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n\t--lp->lnum;\n    }\n}\n#endif\n\n/*\n * Recompute topline to put the cursor at the top of the window.\n * Scroll at least \"min_scroll\" lines.\n * If \"always\" is TRUE, always set topline (for \"zt\").\n */\n    void\nscroll_cursor_top(int min_scroll, int always)\n{\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\tused;\n    int\t\ti;\n    linenr_T\ttop;\t\t// just above displayed lines\n    linenr_T\tbot;\t\t// just below displayed lines\n    linenr_T\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    linenr_T\told_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tnew_topline;\n    int\t\toff = get_scrolloff_value();\n\n    if (mouse_dragging > 0)\n\toff = mouse_dragging - 1;\n\n    /*\n     * Decrease topline until:\n     * - it has become 1\n     * - (part of) the cursor line is moved off the screen or\n     * - moved at least 'scrolljump' lines and\n     * - at least 'scrolloff' lines above and below the cursor\n     */\n    validate_cheight();\n    used = curwin->w_cline_height; // includes filler lines above\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n\tscrolled = used;\n\n#ifdef FEAT_FOLDING\n    if (hasFolding(curwin->w_cursor.lnum, &top, &bot))\n    {\n\t--top;\n\t++bot;\n    }\n    else\n#endif\n    {\n\ttop = curwin->w_cursor.lnum - 1;\n\tbot = curwin->w_cursor.lnum + 1;\n    }\n    new_topline = top + 1;\n\n#ifdef FEAT_DIFF\n    // \"used\" already contains the number of filler lines above, don't add it\n    // again.\n    // Hide filler lines above cursor line by adding them to \"extra\".\n    extra += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    /*\n     * Check if the lines from \"top\" to \"bot\" fit in the window.  If they do,\n     * set new_topline and advance \"top\" and \"bot\" to include more lines.\n     */\n    while (top > 0)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(top, &top, NULL))\n\t    // count one logical line for a sequence of folded lines\n\t    i = 1;\n\telse\n#endif\n\t    i = PLINES_NOFILL(top);\n\tused += i;\n\tif (extra + i <= off && bot < curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(bot, NULL, &bot))\n\t\t// count one logical line for a sequence of folded lines\n\t\t++used;\n\t    else\n#endif\n\t\tused += plines(bot);\n\t}\n\tif (used > curwin->w_height)\n\t    break;\n\tif (top < curwin->w_topline)\n\t    scrolled += i;\n\n\t/*\n\t * If scrolling is needed, scroll at least 'sj' lines.\n\t */\n\tif ((new_topline >= curwin->w_topline || scrolled > min_scroll)\n\t\t&& extra >= off)\n\t    break;\n\n\textra += i;\n\tnew_topline = top;\n\t--top;\n\t++bot;\n    }\n\n    /*\n     * If we don't have enough space, put cursor in the middle.\n     * This makes sure we get the same position when using \"k\" and \"j\"\n     * in a small window.\n     */\n    if (used > curwin->w_height)\n\tscroll_cursor_halfway(FALSE);\n    else\n    {\n\t/*\n\t * If \"always\" is FALSE, only adjust topline to a lower value, higher\n\t * value may happen with wrapping lines\n\t */\n\tif (new_topline < curwin->w_topline || always)\n\t    curwin->w_topline = new_topline;\n\tif (curwin->w_topline > curwin->w_cursor.lnum)\n\t    curwin->w_topline = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill > 0 && extra > off)\n\t{\n\t    curwin->w_topfill -= extra - off;\n\t    if (curwin->w_topfill < 0)\n\t\tcurwin->w_topfill = 0;\n\t}\n\tcheck_topfill(curwin, FALSE);\n#endif\n\tif (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t)\n\t    curwin->w_valid &=\n\t\t      ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\tcurwin->w_valid |= VALID_TOPLINE;\n    }\n}\n\n/*\n * Set w_empty_rows and w_filler_rows for window \"wp\", having used up \"used\"\n * screen lines for text lines.\n */\n    void\nset_empty_rows(win_T *wp, int used)\n{\n#ifdef FEAT_DIFF\n    wp->w_filler_rows = 0;\n#endif\n    if (used == 0)\n\twp->w_empty_rows = 0;\t// single line that doesn't fit\n    else\n    {\n\twp->w_empty_rows = wp->w_height - used;\n#ifdef FEAT_DIFF\n\tif (wp->w_botline <= wp->w_buffer->b_ml.ml_line_count)\n\t{\n\t    wp->w_filler_rows = diff_check_fill(wp, wp->w_botline);\n\t    if (wp->w_empty_rows > wp->w_filler_rows)\n\t\twp->w_empty_rows -= wp->w_filler_rows;\n\t    else\n\t    {\n\t\twp->w_filler_rows = wp->w_empty_rows;\n\t\twp->w_empty_rows = 0;\n\t    }\n\t}\n#endif\n    }\n}\n\n/*\n * Recompute topline to put the cursor at the bottom of the window.\n * Scroll at least \"min_scroll\" lines.\n * If \"set_topbot\" is TRUE, set topline and botline first (for \"zb\").\n * This is messy stuff!!!\n */\n    void\nscroll_cursor_bot(int min_scroll, int set_topbot)\n{\n    int\t\tused;\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\ti;\n    linenr_T\tline_count;\n    linenr_T\told_topline = curwin->w_topline;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n    int\t\tfill_below_window;\n#endif\n    linenr_T\told_botline = curwin->w_botline;\n    linenr_T\told_valid = curwin->w_valid;\n    int\t\told_empty_rows = curwin->w_empty_rows;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    long        so = get_scrolloff_value();\n\n    cln = curwin->w_cursor.lnum;\n    if (set_topbot)\n    {\n\tused = 0;\n\tcurwin->w_botline = cln + 1;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tfor (curwin->w_topline = curwin->w_botline;\n\t\tcurwin->w_topline > 1;\n\t\tcurwin->w_topline = loff.lnum)\n\t{\n\t    loff.lnum = curwin->w_topline;\n\t    topline_back(&loff);\n\t    if (loff.height == MAXCOL || used + loff.height > curwin->w_height)\n\t\tbreak;\n\t    used += loff.height;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = loff.fill;\n#endif\n\t}\n\tset_empty_rows(curwin, used);\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tif (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t)\n\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n    }\n    else\n\tvalidate_botline();\n\n    // The lines of the cursor line itself are always used.\n#ifdef FEAT_DIFF\n    used = plines_nofill(cln);\n#else\n    validate_cheight();\n    used = curwin->w_cline_height;\n#endif\n\n    // If the cursor is below botline, we will at least scroll by the height\n    // of the cursor line.  Correct for empty lines, which are really part of\n    // botline.\n    if (cln >= curwin->w_botline)\n    {\n\tscrolled = used;\n\tif (cln == curwin->w_botline)\n\t    scrolled -= curwin->w_empty_rows;\n    }\n\n    /*\n     * Stop counting lines to scroll when\n     * - hitting start of the file\n     * - scrolled nothing or at least 'sj' lines\n     * - at least 'scrolloff' lines below the cursor\n     * - lines between botline and cursor have been counted\n     */\n#ifdef FEAT_FOLDING\n    if (!hasFolding(curwin->w_cursor.lnum, &loff.lnum, &boff.lnum))\n#endif\n    {\n\tloff.lnum = cln;\n\tboff.lnum = cln;\n    }\n#ifdef FEAT_DIFF\n    loff.fill = 0;\n    boff.fill = 0;\n    fill_below_window = diff_check_fill(curwin, curwin->w_botline)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\n    while (loff.lnum > 1)\n    {\n\t// Stop when scrolled nothing or at least \"min_scroll\", found \"extra\"\n\t// context for 'scrolloff' and counted all lines below the window.\n\tif ((((scrolled <= 0 || scrolled >= min_scroll)\n\t\t    && extra >= (mouse_dragging > 0 ? mouse_dragging - 1 : so))\n\t\t    || boff.lnum + 1 > curbuf->b_ml.ml_line_count)\n\t\t&& loff.lnum <= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum < curwin->w_botline\n\t\t    || loff.fill >= fill_below_window)\n#endif\n\t\t)\n\t    break;\n\n\t// Add one line above\n\ttopline_back(&loff);\n\tif (loff.height == MAXCOL)\n\t    used = MAXCOL;\n\telse\n\t    used += loff.height;\n\tif (used > curwin->w_height)\n\t    break;\n\tif (loff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum > curwin->w_botline\n\t\t    || loff.fill <= fill_below_window)\n#endif\n\t\t)\n\t{\n\t    // Count screen lines that are below the window.\n\t    scrolled += loff.height;\n\t    if (loff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && loff.fill == 0\n#endif\n\t\t    )\n\t\tscrolled -= curwin->w_empty_rows;\n\t}\n\n\tif (boff.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    // Add one line below\n\t    botline_forw(&boff);\n\t    used += boff.height;\n\t    if (used > curwin->w_height)\n\t\tbreak;\n\t    if (extra < ( mouse_dragging > 0 ? mouse_dragging - 1 : so)\n\t\t    || scrolled < min_scroll)\n\t    {\n\t\textra += boff.height;\n\t\tif (boff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t|| (boff.lnum + 1 == curwin->w_botline\n\t\t\t    && boff.fill > curwin->w_filler_rows)\n#endif\n\t\t   )\n\t\t{\n\t\t    // Count screen lines that are below the window.\n\t\t    scrolled += boff.height;\n\t\t    if (boff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && boff.fill == 0\n#endif\n\t\t\t    )\n\t\t\tscrolled -= curwin->w_empty_rows;\n\t\t}\n\t    }\n\t}\n    }\n\n    // curwin->w_empty_rows is larger, no need to scroll\n    if (scrolled <= 0)\n\tline_count = 0;\n    // more than a screenfull, don't scroll but redraw\n    else if (used > curwin->w_height)\n\tline_count = used;\n    // scroll minimal number of lines\n    else\n    {\n\tline_count = 0;\n#ifdef FEAT_DIFF\n\tboff.fill = curwin->w_topfill;\n#endif\n\tboff.lnum = curwin->w_topline - 1;\n\tfor (i = 0; i < scrolled && boff.lnum < curwin->w_botline; )\n\t{\n\t    botline_forw(&boff);\n\t    i += boff.height;\n\t    ++line_count;\n\t}\n\tif (i < scrolled)\t// below curwin->w_botline, don't scroll\n\t    line_count = 9999;\n    }\n\n    /*\n     * Scroll up if the cursor is off the bottom of the screen a bit.\n     * Otherwise put it at 1/2 of the screen.\n     */\n    if (line_count >= curwin->w_height && line_count > min_scroll)\n\tscroll_cursor_halfway(FALSE);\n    else\n\tscrollup(line_count, TRUE);\n\n    /*\n     * If topline didn't change we need to restore w_botline and w_empty_rows\n     * (we changed them).\n     * If topline did change, update_screen() will set botline.\n     */\n    if (curwin->w_topline == old_topline && set_topbot)\n    {\n\tcurwin->w_botline = old_botline;\n\tcurwin->w_empty_rows = old_empty_rows;\n\tcurwin->w_valid = old_valid;\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Recompute topline to put the cursor halfway the window\n * If \"atend\" is TRUE, also put it halfway at the end of the file.\n */\n    void\nscroll_cursor_halfway(int atend)\n{\n    int\t\tabove = 0;\n    linenr_T\ttopline;\n#ifdef FEAT_DIFF\n    int\t\ttopfill = 0;\n#endif\n    int\t\tbelow = 0;\n    int\t\tused;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    linenr_T\told_topline = curwin->w_topline;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    // if the width changed this needs to be updated first\n    may_update_popup_position();\n#endif\n    loff.lnum = boff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n    (void)hasFolding(loff.lnum, &loff.lnum, &boff.lnum);\n#endif\n#ifdef FEAT_DIFF\n    used = plines_nofill(loff.lnum);\n    loff.fill = 0;\n    boff.fill = 0;\n#else\n    used = plines(loff.lnum);\n#endif\n    topline = loff.lnum;\n    while (topline > 1)\n    {\n\tif (below <= above)\t    // add a line below the cursor first\n\t{\n\t    if (boff.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tbotline_forw(&boff);\n\t\tused += boff.height;\n\t\tif (used > curwin->w_height)\n\t\t    break;\n\t\tbelow += boff.height;\n\t    }\n\t    else\n\t    {\n\t\t++below;\t    // count a \"~\" line\n\t\tif (atend)\n\t\t    ++used;\n\t    }\n\t}\n\n\tif (below > above)\t    // add a line above the cursor\n\t{\n\t    topline_back(&loff);\n\t    if (loff.height == MAXCOL)\n\t\tused = MAXCOL;\n\t    else\n\t\tused += loff.height;\n\t    if (used > curwin->w_height)\n\t\tbreak;\n\t    above += loff.height;\n\t    topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t    topfill = loff.fill;\n#endif\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (!hasFolding(topline, &curwin->w_topline, NULL))\n#endif\n\tcurwin->w_topline = topline;\n#ifdef FEAT_DIFF\n    curwin->w_topfill = topfill;\n    if (old_topline > curwin->w_topline + curwin->w_height)\n\tcurwin->w_botfill = FALSE;\n    check_topfill(curwin, FALSE);\n#endif\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Correct the cursor position so that it is in a part of the screen at least\n * 'scrolloff' lines from the top and bottom, if possible.\n * If not possible, put it at the same position as scroll_cursor_halfway().\n * When called topline must be valid!\n */\n    void\ncursor_correct(void)\n{\n    int\t\tabove = 0;\t    // screen lines above topline\n    linenr_T\ttopline;\n    int\t\tbelow = 0;\t    // screen lines below botline\n    linenr_T\tbotline;\n    int\t\tabove_wanted, below_wanted;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    int\t\tmax_off;\n    long        so = get_scrolloff_value();\n\n    /*\n     * How many lines we would like to have above/below the cursor depends on\n     * whether the first/last line of the file is on screen.\n     */\n    above_wanted = so;\n    below_wanted = so;\n    if (mouse_dragging > 0)\n    {\n\tabove_wanted = mouse_dragging - 1;\n\tbelow_wanted = mouse_dragging - 1;\n    }\n    if (curwin->w_topline == 1)\n    {\n\tabove_wanted = 0;\n\tmax_off = curwin->w_height / 2;\n\tif (below_wanted > max_off)\n\t    below_wanted = max_off;\n    }\n    validate_botline();\n    if (curwin->w_botline == curbuf->b_ml.ml_line_count + 1\n\t    && mouse_dragging == 0)\n    {\n\tbelow_wanted = 0;\n\tmax_off = (curwin->w_height - 1) / 2;\n\tif (above_wanted > max_off)\n\t    above_wanted = max_off;\n    }\n\n    /*\n     * If there are sufficient file-lines above and below the cursor, we can\n     * return now.\n     */\n    cln = curwin->w_cursor.lnum;\n    if (cln >= curwin->w_topline + above_wanted\n\t    && cln < curwin->w_botline - below_wanted\n#ifdef FEAT_FOLDING\n\t    && !hasAnyFolding(curwin)\n#endif\n\t    )\n\treturn;\n\n    /*\n     * Narrow down the area where the cursor can be put by taking lines from\n     * the top and the bottom until:\n     * - the desired context lines are found\n     * - the lines from the top is past the lines from the bottom\n     */\n    topline = curwin->w_topline;\n    botline = curwin->w_botline - 1;\n#ifdef FEAT_DIFF\n    // count filler lines as context\n    above = curwin->w_topfill;\n    below = curwin->w_filler_rows;\n#endif\n    while ((above < above_wanted || below < below_wanted) && topline < botline)\n    {\n\tif (below < below_wanted && (below <= above || above >= above_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(botline, &botline, NULL))\n\t\t++below;\n\t    else\n#endif\n\t\tbelow += plines(botline);\n\t    --botline;\n\t}\n\tif (above < above_wanted && (above < below || below >= below_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(topline, NULL, &topline))\n\t\t++above;\n\t    else\n#endif\n\t\tabove += PLINES_NOFILL(topline);\n#ifdef FEAT_DIFF\n\t    // Count filler lines below this line as context.\n\t    if (topline < botline)\n\t\tabove += diff_check_fill(curwin, topline + 1);\n#endif\n\t    ++topline;\n\t}\n    }\n    if (topline == botline || botline == 0)\n\tcurwin->w_cursor.lnum = topline;\n    else if (topline > botline)\n\tcurwin->w_cursor.lnum = botline;\n    else\n    {\n\tif (cln < topline && curwin->w_topline > 1)\n\t{\n\t    curwin->w_cursor.lnum = topline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n\tif (cln > botline && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_cursor.lnum = botline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\nstatic void get_scroll_overlap(lineoff_T *lp, int dir);\n\n/*\n * move screen 'count' pages up or down and update screen\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nonepage(int dir, long count)\n{\n    long\tn;\n    int\t\tretval = OK;\n    lineoff_T\tloff;\n    linenr_T\told_topline = curwin->w_topline;\n    long        so = get_scrolloff_value();\n\n    if (curbuf->b_ml.ml_line_count == 1)    // nothing to do\n    {\n\tbeep_flush();\n\treturn FAIL;\n    }\n\n    for ( ; count > 0; --count)\n    {\n\tvalidate_botline();\n\t/*\n\t * It's an error to move a page up when the first line is already on\n\t * the screen.\tIt's an error to move a page down when the last line\n\t * is on the screen and the topline is 'scrolloff' lines from the\n\t * last line.\n\t */\n\tif (dir == FORWARD\n\t\t? ((curwin->w_topline >= curbuf->b_ml.ml_line_count - so)\n\t\t    && curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t: (curwin->w_topline == 1\n#ifdef FEAT_DIFF\n\t\t    && curwin->w_topfill ==\n\t\t\t\t    diff_check_fill(curwin, curwin->w_topline)\n#endif\n\t\t    ))\n\t{\n\t    beep_flush();\n\t    retval = FAIL;\n\t    break;\n\t}\n\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tif (dir == FORWARD)\n\t{\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling\n\t\tif (p_window <= 2)\n\t\t    ++curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline += p_window - 2;\n\t\tif (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_topline = curbuf->b_ml.ml_line_count;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t    }\n\t    else if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// at end of file\n\t\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t    }\n\t    else\n\t    {\n\t\t// For the overlap, start with the line just below the window\n\t\t// and go upwards.\n\t\tloff.lnum = curwin->w_botline;\n#ifdef FEAT_DIFF\n\t\tloff.fill = diff_check_fill(curwin, loff.lnum)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\t\tget_scroll_overlap(&loff, -1);\n\t\tcurwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = loff.fill;\n\t\tcheck_topfill(curwin, FALSE);\n#endif\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t\tcurwin->w_valid &= ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|\n\t\t\t\t   VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    }\n\t}\n\telse\t// dir == BACKWARDS\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topline == 1)\n\t    {\n\t\t// Include max number of filler lines\n\t\tmax_topfill();\n\t\tcontinue;\n\t    }\n#endif\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling (sort of)\n\t\tif (p_window <= 2)\n\t\t    --curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline -= p_window - 2;\n\t\tif (curwin->w_topline < 1)\n\t\t    curwin->w_topline = 1;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline + p_window - 1;\n\t\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcontinue;\n\t    }\n\n\t    // Find the line at the top of the window that is going to be the\n\t    // line at the bottom of the window.  Make sure this results in\n\t    // the same line as before doing CTRL-F.\n\t    loff.lnum = curwin->w_topline - 1;\n#ifdef FEAT_DIFF\n\t    loff.fill = diff_check_fill(curwin, loff.lnum + 1)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    get_scroll_overlap(&loff, 1);\n\n\t    if (loff.lnum >= curbuf->b_ml.ml_line_count)\n\t    {\n\t\tloff.lnum = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t    }\n\t    else\n\t    {\n\t\tbotline_topline(&loff);\n#endif\n\t    }\n\t    curwin->w_cursor.lnum = loff.lnum;\n\n\t    // Find the line just above the new topline to get the right line\n\t    // at the bottom of the window.\n\t    n = 0;\n\t    while (n <= curwin->w_height && loff.lnum >= 1)\n\t    {\n\t\ttopline_back(&loff);\n\t\tif (loff.height == MAXCOL)\n\t\t    n = MAXCOL;\n\t\telse\n\t\t    n += loff.height;\n\t    }\n\t    if (loff.lnum < 1)\t\t\t// at begin of file\n\t    {\n\t\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\t\tmax_topfill();\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t    }\n\t    else\n\t    {\n\t\t// Go two lines forward again.\n#ifdef FEAT_DIFF\n\t\ttopline_botline(&loff);\n#endif\n\t\tbotline_forw(&loff);\n\t\tbotline_forw(&loff);\n#ifdef FEAT_DIFF\n\t\tbotline_topline(&loff);\n#endif\n#ifdef FEAT_FOLDING\n\t\t// We're at the wrong end of a fold now.\n\t\t(void)hasFolding(loff.lnum, &loff.lnum, NULL);\n#endif\n\n\t\t// Always scroll at least one line.  Avoid getting stuck on\n\t\t// very long lines.\n\t\tif (loff.lnum >= curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum > curwin->w_topline\n\t\t\t    || loff.fill >= curwin->w_topfill)\n#endif\n\t\t\t)\n\t\t{\n#ifdef FEAT_DIFF\n\t\t    // First try using the maximum number of filler lines.  If\n\t\t    // that's not enough, backup one line.\n\t\t    loff.fill = curwin->w_topfill;\n\t\t    if (curwin->w_topfill < diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t\t\tmax_topfill();\n\t\t    if (curwin->w_topfill == loff.fill)\n#endif\n\t\t    {\n\t\t\t--curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\t\tcurwin->w_topfill = 0;\n#endif\n\t\t    }\n\t\t    comp_botline(curwin);\n\t\t    curwin->w_cursor.lnum = curwin->w_botline - 1;\n\t\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|VALID_CROW);\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\t    curwin->w_topfill = loff.fill;\n\t\t    check_topfill(curwin, FALSE);\n#endif\n\t\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t\t}\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    foldAdjustCursor();\n#endif\n    cursor_correct();\n    check_cursor_col();\n    if (retval == OK)\n\tbeginline(BL_SOL | BL_FIX);\n    curwin->w_valid &= ~(VALID_WCOL|VALID_WROW|VALID_VIRTCOL);\n\n    if (retval == OK && dir == FORWARD)\n    {\n\t// Avoid the screen jumping up and down when 'scrolloff' is non-zero.\n\t// But make sure we scroll at least one line (happens with mix of long\n\t// wrapping lines and non-wrapping line).\n\tif (check_top_offset())\n\t{\n\t    scroll_cursor_top(1, FALSE);\n\t    if (curwin->w_topline <= old_topline\n\t\t\t\t  && old_topline < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_topline = old_topline + 1;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    }\n\t}\n#ifdef FEAT_FOLDING\n\telse if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    }\n\n    redraw_later(VALID);\n    return retval;\n}\n\n/*\n * Decide how much overlap to use for page-up or page-down scrolling.\n * This is symmetric, so that doing both keeps the same lines displayed.\n * Three lines are examined:\n *\n *  before CTRL-F\t    after CTRL-F / before CTRL-B\n *     etc.\t\t\tl1\n *  l1 last but one line\t------------\n *  l2 last text line\t\tl2 top text line\n *  -------------\t\tl3 second text line\n *  l3\t\t\t\t   etc.\n */\n    static void\nget_scroll_overlap(lineoff_T *lp, int dir)\n{\n    int\t\th1, h2, h3, h4;\n    int\t\tmin_height = curwin->w_height - 2;\n    lineoff_T\tloff0, loff1, loff2;\n\n#ifdef FEAT_DIFF\n    if (lp->fill > 0)\n\tlp->height = 1;\n    else\n\tlp->height = plines_nofill(lp->lnum);\n#else\n    lp->height = plines(lp->lnum);\n#endif\n    h1 = lp->height;\n    if (h1 > min_height)\n\treturn;\t\t// no overlap\n\n    loff0 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h2 = lp->height;\n    if (h2 == MAXCOL || h2 + h1 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff1 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h3 = lp->height;\n    if (h3 == MAXCOL || h3 + h2 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff2 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h4 = lp->height;\n    if (h4 == MAXCOL || h4 + h3 + h2 > min_height || h3 + h2 + h1 > min_height)\n\t*lp = loff1;\t// 1 line overlap\n    else\n\t*lp = loff2;\t// 2 lines overlap\n}\n\n/*\n * Scroll 'scroll' lines up or down.\n */\n    void\nhalfpage(int flag, linenr_T Prenum)\n{\n    long\tscrolled = 0;\n    int\t\ti;\n    int\t\tn;\n    int\t\troom;\n\n    if (Prenum)\n\tcurwin->w_p_scr = (Prenum > curwin->w_height) ?\n\t\t\t\t\t\tcurwin->w_height : Prenum;\n    n = (curwin->w_p_scr <= curwin->w_height) ?\n\t\t\t\t    curwin->w_p_scr : curwin->w_height;\n\n    update_topline();\n    validate_botline();\n    room = curwin->w_empty_rows;\n#ifdef FEAT_DIFF\n    room += curwin->w_filler_rows;\n#endif\n    if (flag)\n    {\n\t/*\n\t * scroll the text up\n\t */\n\twhile (n > 0 && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t--curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t\t++curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n#endif\n\n\t\tif (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_valid &=\n\t\t\t\t    ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t\t}\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW);\n\t    scrolled += i;\n\n\t    /*\n\t     * Correct w_botline for changed w_topline.\n\t     * Won't work when there are filler lines.\n\t     */\n#ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    else\n#endif\n\t    {\n\t\troom += i;\n\t\tdo\n\t\t{\n\t\t    i = plines(curwin->w_botline);\n\t\t    if (i > room)\n\t\t\tbreak;\n#ifdef FEAT_FOLDING\n\t\t    (void)hasFolding(curwin->w_botline, NULL,\n\t\t\t\t\t\t\t  &curwin->w_botline);\n#endif\n\t\t    ++curwin->w_botline;\n\t\t    room -= i;\n\t\t} while (curwin->w_botline <= curbuf->b_ml.ml_line_count);\n\t    }\n\t}\n\n\t/*\n\t * When hit bottom of the file: move cursor down.\n\t */\n\tif (n > 0)\n\t{\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n\t\t    ++curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum += n;\n\t    check_cursor_lnum();\n\t}\n    }\n    else\n    {\n\t/*\n\t * scroll the text down\n\t */\n\twhile (n > 0 && curwin->w_topline > 1)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill < diff_check_fill(curwin, curwin->w_topline))\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t++curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline - 1);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n\t\t--curwin->w_topline;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW|\n\t\t\t\t\t      VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    scrolled += i;\n\t    if (curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--curwin->w_cursor.lnum;\n\t\tcurwin->w_valid &= ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t    }\n\t}\n\n\t/*\n\t * When hit top of the file: move cursor up.\n\t */\n\tif (n > 0)\n\t{\n\t    if (curwin->w_cursor.lnum <= (linenr_T)n)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0 && curwin->w_cursor.lnum > 1)\n\t\t{\n\t\t    --curwin->w_cursor.lnum;\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum -= n;\n\t}\n    }\n# ifdef FEAT_FOLDING\n    // Move cursor to first line of closed fold.\n    foldAdjustCursor();\n# endif\n#ifdef FEAT_DIFF\n    check_topfill(curwin, !flag);\n#endif\n    cursor_correct();\n    beginline(BL_SOL | BL_FIX);\n    redraw_later(VALID);\n}\n\n    void\ndo_check_cursorbind(void)\n{\n    linenr_T\tline = curwin->w_cursor.lnum;\n    colnr_T\tcol = curwin->w_cursor.col;\n    colnr_T\tcoladd = curwin->w_cursor.coladd;\n    colnr_T\tcurswant = curwin->w_curswant;\n    int\t\tset_curswant = curwin->w_set_curswant;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\trestart_edit_save;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n\n    /*\n     * loop through the cursorbound windows\n     */\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window  and windows with 'noscrollbind'\n\tif (curwin != old_curwin && curwin->w_p_crb)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_cursor.lnum =\n\t\t\t\t diff_get_corresponding_line(old_curbuf, line);\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum = line;\n\t    curwin->w_cursor.col = col;\n\t    curwin->w_cursor.coladd = coladd;\n\t    curwin->w_curswant = curswant;\n\t    curwin->w_set_curswant = set_curswant;\n\n\t    // Make sure the cursor is in a valid position.  Temporarily set\n\t    // \"restart_edit\" to allow the cursor to be beyond the EOL.\n\t    restart_edit_save = restart_edit;\n\t    restart_edit = TRUE;\n\t    check_cursor();\n# ifdef FEAT_SYN_HL\n\t    if (curwin->w_p_cul || curwin->w_p_cuc)\n\t\tvalidate_cursor();\n# endif\n\t    restart_edit = restart_edit_save;\n\t    // Correct cursor for multi-byte character.\n\t    if (has_mbyte)\n\t\tmb_adjust_cursor();\n\t    redraw_later(VALID);\n\n\t    // Only scroll when 'scrollbind' hasn't done this.\n\t    if (!curwin->w_p_scb)\n\t\tupdate_topline();\n\t    curwin->w_redr_status = TRUE;\n\t}\n    }\n\n    /*\n     * reset current-window\n     */\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n", "\" Test for various Normal mode commands\n\nsource shared.vim\nsource check.vim\nsource view_util.vim\n\nfunc Setup_NewWindow()\n  10new\n  call setline(1, range(1,100))\nendfunc\n\nfunc MyFormatExpr()\n  \" Adds '->$' at lines having numbers followed by trailing whitespace\n  for ln in range(v:lnum, v:lnum+v:count-1)\n    let line = getline(ln)\n    if getline(ln) =~# '\\d\\s\\+$'\n      call setline(ln, substitute(line, '\\s\\+$', '', '') . '->$')\n    endif\n  endfor\nendfunc\n\nfunc CountSpaces(type, ...)\n  \" for testing operatorfunc\n  \" will count the number of spaces\n  \" and return the result in g:a\n  let sel_save = &selection\n  let &selection = \"inclusive\"\n  let reg_save = @@\n\n  if a:0  \" Invoked from Visual mode, use gv command.\n    silent exe \"normal! gvy\"\n  elseif a:type == 'line'\n    silent exe \"normal! '[V']y\"\n  else\n    silent exe \"normal! `[v`]y\"\n  endif\n  let g:a = strlen(substitute(@@, '[^ ]', '', 'g'))\n  let &selection = sel_save\n  let @@ = reg_save\nendfunc\n\nfunc OpfuncDummy(type, ...)\n  \" for testing operatorfunc\n  let g:opt = &linebreak\n\n  if a:0  \" Invoked from Visual mode, use gv command.\n    silent exe \"normal! gvy\"\n  elseif a:type == 'line'\n    silent exe \"normal! '[V']y\"\n  else\n    silent exe \"normal! `[v`]y\"\n  endif\n  \" Create a new dummy window\n  new\n  let g:bufnr = bufnr('%')\nendfunc\n\nfunc Test_normal00_optrans()\n  new\n  call append(0, ['1 This is a simple test: abcd', '2 This is the second line', '3 this is the third line'])\n  1\n  exe \"norm! Sfoobar\\<esc>\"\n  call assert_equal(['foobar', '2 This is the second line', '3 this is the third line', ''], getline(1,'$'))\n  2\n  exe \"norm! $vbsone\"\n  call assert_equal(['foobar', '2 This is the second one', '3 this is the third line', ''], getline(1,'$'))\n  norm! VS Second line here\n  call assert_equal(['foobar', ' Second line here', '3 this is the third line', ''], getline(1, '$'))\n  %d\n  call append(0, ['4 This is a simple test: abcd', '5 This is the second line', '6 this is the third line'])\n  call append(0, ['1 This is a simple test: abcd', '2 This is the second line', '3 this is the third line'])\n\n  1\n  norm! 2D\n  call assert_equal(['3 this is the third line', '4 This is a simple test: abcd', '5 This is the second line', '6 this is the third line', ''], getline(1,'$'))\n  set cpo+=#\n  norm! 4D\n  call assert_equal(['', '4 This is a simple test: abcd', '5 This is the second line', '6 this is the third line', ''], getline(1,'$'))\n\n  \" clean up\n  set cpo-=#\n  bw!\nendfunc\n\nfunc Test_normal01_keymodel()\n  call Setup_NewWindow()\n  \" Test 1: depending on 'keymodel' <s-down> does something different\n  50\n  call feedkeys(\"V\\<S-Up>y\", 'tx')\n  call assert_equal(['47', '48', '49', '50'], getline(\"'<\", \"'>\"))\n  set keymodel=startsel\n  50\n  call feedkeys(\"V\\<S-Up>y\", 'tx')\n  call assert_equal(['49', '50'], getline(\"'<\", \"'>\"))\n  \" Start visual mode when keymodel = startsel\n  50\n  call feedkeys(\"\\<S-Up>y\", 'tx')\n  call assert_equal(['49', '5'], getreg(0, 0, 1))\n  \" Use the different Shift special keys\n  50\n  call feedkeys(\"\\<S-Right>\\<S-Left>\\<S-Up>\\<S-Down>\\<S-Home>\\<S-End>y\", 'tx')\n  call assert_equal(['50'], getline(\"'<\", \"'>\"))\n  call assert_equal(['50', ''], getreg(0, 0, 1))\n\n  \" Do not start visual mode when keymodel=\n  set keymodel=\n  50\n  call feedkeys(\"\\<S-Up>y$\", 'tx')\n  call assert_equal(['42'], getreg(0, 0, 1))\n  \" Stop visual mode when keymodel=stopsel\n  set keymodel=stopsel\n  50\n  call feedkeys(\"Vkk\\<Up>yy\", 'tx')\n  call assert_equal(['47'], getreg(0, 0, 1))\n\n  set keymodel=\n  50\n  call feedkeys(\"Vkk\\<Up>yy\", 'tx')\n  call assert_equal(['47', '48', '49', '50'], getreg(0, 0, 1))\n\n  \" Test for using special keys to start visual selection\n  %d\n  call setline(1, ['red fox tail', 'red fox tail', 'red fox tail'])\n  set keymodel=startsel\n  \" Test for <S-PageUp> and <S-PageDown>\n  call cursor(1, 1)\n  call feedkeys(\"\\<S-PageDown>y\", 'xt')\n  call assert_equal([0, 1, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 3, 1, 0], getpos(\"'>\"))\n  call feedkeys(\"Gz\\<CR>8|\\<S-PageUp>y\", 'xt')\n  call assert_equal([0, 2, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 3, 8, 0], getpos(\"'>\"))\n  \" Test for <S-C-Home> and <S-C-End>\n  call cursor(2, 12)\n  call feedkeys(\"\\<S-C-Home>y\", 'xt')\n  call assert_equal([0, 1, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 2, 12, 0], getpos(\"'>\"))\n  call cursor(1, 4)\n  call feedkeys(\"\\<S-C-End>y\", 'xt')\n  call assert_equal([0, 1, 4, 0], getpos(\"'<\"))\n  call assert_equal([0, 3, 13, 0], getpos(\"'>\"))\n  \" Test for <S-C-Left> and <S-C-Right>\n  call cursor(2, 5)\n  call feedkeys(\"\\<S-C-Right>y\", 'xt')\n  call assert_equal([0, 2, 5, 0], getpos(\"'<\"))\n  call assert_equal([0, 2, 9, 0], getpos(\"'>\"))\n  call cursor(2, 9)\n  call feedkeys(\"\\<S-C-Left>y\", 'xt')\n  call assert_equal([0, 2, 5, 0], getpos(\"'<\"))\n  call assert_equal([0, 2, 9, 0], getpos(\"'>\"))\n\n  set keymodel&\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal03_join()\n  \" basic join test\n  call Setup_NewWindow()\n  50\n  norm! VJ\n  call assert_equal('50 51', getline('.'))\n  $\n  norm! J\n  call assert_equal('100', getline('.'))\n  $\n  norm! V9-gJ\n  call assert_equal('919293949596979899100', getline('.'))\n  call setline(1, range(1,100))\n  $\n  :j 10\n  call assert_equal('100', getline('.'))\n  call assert_beeps('normal GVJ')\n  \" clean up\n  bw!\nendfunc\n\n\" basic filter test\nfunc Test_normal04_filter()\n  \" only test on non windows platform\n  CheckNotMSWindows\n  call Setup_NewWindow()\n  1\n  call feedkeys(\"!!sed -e 's/^/|    /'\\n\", 'tx')\n  call assert_equal('|    1', getline('.'))\n  90\n  :sil :!echo one\n  call feedkeys('.', 'tx')\n  call assert_equal('|    90', getline('.'))\n  95\n  set cpo+=!\n  \" 2 <CR>, 1: for executing the command,\n  \"         2: clear hit-enter-prompt\n  call feedkeys(\"!!\\n\", 'tx')\n  call feedkeys(\":!echo one\\n\\n\", 'tx')\n  call feedkeys(\".\", 'tx')\n  call assert_equal('one', getline('.'))\n  set cpo-=!\n  bw!\nendfunc\n\nfunc Test_normal05_formatexpr()\n  \" basic formatexpr test\n  call Setup_NewWindow()\n  %d_\n  call setline(1, ['here: 1   ', '2', 'here: 3   ', '4', 'not here:   '])\n  1\n  set formatexpr=MyFormatExpr()\n  norm! gqG\n  call assert_equal(['here: 1->$', '2', 'here: 3->$', '4', 'not here:   '], getline(1,'$'))\n  set formatexpr=\n  bw!\nendfunc\n\nfunc Test_normal05_formatexpr_newbuf()\n  \" Edit another buffer in the 'formatexpr' function\n  new\n  func! Format()\n    edit another\n  endfunc\n  set formatexpr=Format()\n  norm gqG\n  bw!\n  set formatexpr=\nendfunc\n\nfunc Test_normal05_formatexpr_setopt()\n  \" Change the 'formatexpr' value in the function\n  new\n  func! Format()\n    set formatexpr=\n  endfunc\n  set formatexpr=Format()\n  norm gqG\n  bw!\n  set formatexpr=\nendfunc\n\n\" When 'formatexpr' returns non-zero, internal formatting is used.\nfunc Test_normal_formatexpr_returns_nonzero()\n  new\n  call setline(1, ['one', 'two'])\n  func! Format()\n    return 1\n  endfunc\n  setlocal formatexpr=Format()\n  normal VGgq\n  call assert_equal(['one two'], getline(1, '$'))\n  setlocal formatexpr=\n  delfunc Format\n  close!\nendfunc\n\n\" basic test for formatprg\nfunc Test_normal06_formatprg()\n  \" only test on non windows platform\n  CheckNotMSWindows\n\n  \" uses sed to number non-empty lines\n  call writefile(['#!/bin/sh', 'sed ''/./=''|sed ''/./{', 'N', 's/\\n/    /', '}'''], 'Xsed_format.sh')\n  call system('chmod +x ./Xsed_format.sh')\n  let text = ['a', '', 'c', '', ' ', 'd', 'e']\n  let expected = ['1    a', '', '3    c', '', '5     ', '6    d', '7    e']\n\n  10new\n  call setline(1, text)\n  set formatprg=./Xsed_format.sh\n  norm! gggqG\n  call assert_equal(expected, getline(1, '$'))\n  %d\n\n  call setline(1, text)\n  set formatprg=donothing\n  setlocal formatprg=./Xsed_format.sh\n  norm! gggqG\n  call assert_equal(expected, getline(1, '$'))\n  %d\n\n  \" Check for the command-line ranges added to 'formatprg'\n  set formatprg=cat\n  call setline(1, ['one', 'two', 'three', 'four', 'five'])\n  call feedkeys('gggqG', 'xt')\n  call assert_equal('.,$!cat', @:)\n  call feedkeys('2Ggq2j', 'xt')\n  call assert_equal('.,.+2!cat', @:)\n\n  bw!\n  \" clean up\n  set formatprg=\n  setlocal formatprg=\n  call delete('Xsed_format.sh')\nendfunc\n\nfunc Test_normal07_internalfmt()\n  \" basic test for internal formmatter to textwidth of 12\n  let list=range(1,11)\n  call map(list, 'v:val.\"    \"')\n  10new\n  call setline(1, list)\n  set tw=12\n  norm! ggVGgq\n  call assert_equal(['1    2    3', '4    5    6', '7    8    9', '10    11    '], getline(1, '$'))\n  \" clean up\n  set tw=0\n  bw!\nendfunc\n\n\" basic tests for foldopen/folddelete\nfunc Test_normal08_fold()\n  CheckFeature folding\n  call Setup_NewWindow()\n  50\n  setl foldenable fdm=marker\n  \" First fold\n  norm! V4jzf\n  \" check that folds have been created\n  call assert_equal(['50/*{{{*/', '51', '52', '53', '54/*}}}*/'], getline(50,54))\n  \" Second fold\n  46\n  norm! V10jzf\n  \" check that folds have been created\n  call assert_equal('46/*{{{*/', getline(46))\n  call assert_equal('60/*}}}*/', getline(60))\n  norm! k\n  call assert_equal('45', getline('.'))\n  norm! j\n  call assert_equal('46/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('61', getline('.'))\n  norm! k\n  \" open a fold\n  norm! Vzo\n  norm! k\n  call assert_equal('45', getline('.'))\n  norm! j\n  call assert_equal('46/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('47', getline('.'))\n  norm! k\n  norm! zcVzO\n  call assert_equal('46/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('47', getline('.'))\n  norm! j\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51', getline('.'))\n  \" delete folds\n  :46\n  \" collapse fold\n  norm! V14jzC\n  \" delete all folds recursively\n  norm! VzD\n  call assert_equal(['46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '60'], getline(46,60))\n\n  \" clean up\n  setl nofoldenable fdm=marker\n  bw!\nendfunc\n\nfunc Test_normal09_operatorfunc()\n  \" Test operatorfunc\n  call Setup_NewWindow()\n  \" Add some spaces for counting\n  50,60s/$/  /\n  unlet! g:a\n  let g:a=0\n  nmap <buffer><silent> ,, :set opfunc=CountSpaces<CR>g@\n  vmap <buffer><silent> ,, :<C-U>call CountSpaces(visualmode(), 1)<CR>\n  50\n  norm V2j,,\n  call assert_equal(6, g:a)\n  norm V,,\n  call assert_equal(2, g:a)\n  norm ,,l\n  call assert_equal(0, g:a)\n  50\n  exe \"norm 0\\<c-v>10j2l,,\"\n  call assert_equal(11, g:a)\n  50\n  norm V10j,,\n  call assert_equal(22, g:a)\n\n  \" clean up\n  unmap <buffer> ,,\n  set opfunc=\n  unlet! g:a\n  bw!\nendfunc\n\nfunc Test_normal09a_operatorfunc()\n  \" Test operatorfunc\n  call Setup_NewWindow()\n  \" Add some spaces for counting\n  50,60s/$/  /\n  unlet! g:opt\n  set linebreak\n  nmap <buffer><silent> ,, :set opfunc=OpfuncDummy<CR>g@\n  50\n  norm ,,j\n  exe \"bd!\" g:bufnr\n  call assert_true(&linebreak)\n  call assert_equal(g:opt, &linebreak)\n  set nolinebreak\n  norm ,,j\n  exe \"bd!\" g:bufnr\n  call assert_false(&linebreak)\n  call assert_equal(g:opt, &linebreak)\n\n  \" clean up\n  unmap <buffer> ,,\n  set opfunc=\n  call assert_fails('normal Vg@', 'E774:')\n  bw!\n  unlet! g:opt\nendfunc\n\nfunc Test_normal10_expand()\n  \" Test for expand()\n  10new\n  call setline(1, ['1', 'ifooar,,cbar'])\n  2\n  norm! $\n  call assert_equal('cbar', expand('<cword>'))\n  call assert_equal('ifooar,,cbar', expand('<cWORD>'))\n\n  call setline(1, ['prx = list[idx];'])\n  1\n  let expected = ['', 'prx', 'prx', 'prx',\n\t\\ 'list', 'list', 'list', 'list', 'list', 'list', 'list',\n\t\\ 'idx', 'idx', 'idx', 'idx',\n\t\\ 'list[idx]',\n\t\\ '];',\n\t\\ ]\n  for i in range(1, 16)\n    exe 'norm ' . i . '|'\n    call assert_equal(expected[i], expand('<cexpr>'), 'i == ' . i)\n  endfor\n\n  \" Test for <cexpr> in state.val and ptr->val\n  call setline(1, 'x = state.val;')\n  call cursor(1, 10)\n  call assert_equal('state.val', expand('<cexpr>'))\n  call setline(1, 'x = ptr->val;')\n  call cursor(1, 9)\n  call assert_equal('ptr->val', expand('<cexpr>'))\n\n  if executable('echo')\n    \" Test expand(`...`) i.e. backticks command expansion.\n    call assert_equal('abcde', expand('`echo abcde`'))\n  endif\n\n  \" Test expand(`=...`) i.e. backticks expression expansion\n  call assert_equal('5', expand('`=2+3`'))\n  call assert_equal('3.14', expand('`=3.14`'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for expand() in latin1 encoding\nfunc Test_normal_expand_latin1()\n  new\n  let save_enc = &encoding\n  set encoding=latin1\n  call setline(1, 'val = item->color;')\n  call cursor(1, 11)\n  call assert_equal('color', expand(\"<cword>\"))\n  call assert_equal('item->color', expand(\"<cexpr>\"))\n  let &encoding = save_enc\n  bw!\nendfunc\n\nfunc Test_normal11_showcmd()\n  \" test for 'showcmd'\n  10new\n  exe \"norm! ofoobar\\<esc>\"\n  call assert_equal(2, line('$'))\n  set showcmd\n  exe \"norm! ofoobar2\\<esc>\"\n  call assert_equal(3, line('$'))\n  exe \"norm! VAfoobar3\\<esc>\"\n  call assert_equal(3, line('$'))\n  exe \"norm! 0d3\\<del>2l\"\n  call assert_equal('obar2foobar3', getline('.'))\n  \" test for the visual block size displayed in the status line\n  call setline(1, ['aaaaa', 'bbbbb', 'ccccc'])\n  call feedkeys(\"ggl\\<C-V>lljj\", 'xt')\n  redraw!\n  call assert_match('3x3$', Screenline(&lines))\n  call feedkeys(\"\\<C-V>\", 'xt')\n  \" test for visually selecting a multi-byte character\n  call setline(1, [\"\\U2206\"])\n  call feedkeys(\"ggv\", 'xt')\n  redraw!\n  call assert_match('1-3$', Screenline(&lines))\n  call feedkeys(\"v\", 'xt')\n  \" test for visually selecting the end of line\n  call setline(1, [\"foobar\"])\n  call feedkeys(\"$vl\", 'xt')\n  redraw!\n  call assert_match('2$', Screenline(&lines))\n  call feedkeys(\"y\", 'xt')\n  call assert_equal(\"r\\n\", @\")\n  bw!\nendfunc\n\n\" Test for nv_error and normal command errors\nfunc Test_normal12_nv_error()\n  10new\n  call setline(1, range(1,5))\n  \" should not do anything, just beep\n  call assert_beeps('exe \"norm! <c-k>\"')\n  call assert_equal(map(range(1,5), 'string(v:val)'), getline(1,'$'))\n  call assert_beeps('normal! G2dd')\n  call assert_beeps(\"normal! g\\<C-A>\")\n  call assert_beeps(\"normal! g\\<C-X>\")\n  call assert_beeps(\"normal! g\\<C-B>\")\n  call assert_beeps(\"normal! vQ\\<Esc>\")\n  call assert_beeps(\"normal! 2[[\")\n  call assert_beeps(\"normal! 2]]\")\n  call assert_beeps(\"normal! 2[]\")\n  call assert_beeps(\"normal! 2][\")\n  call assert_beeps(\"normal! 4[z\")\n  call assert_beeps(\"normal! 4]z\")\n  call assert_beeps(\"normal! 4[c\")\n  call assert_beeps(\"normal! 4]c\")\n  call assert_beeps(\"normal! 200%\")\n  call assert_beeps(\"normal! %\")\n  call assert_beeps(\"normal! 2{\")\n  call assert_beeps(\"normal! 2}\")\n  call assert_beeps(\"normal! r\\<Right>\")\n  call assert_beeps(\"normal! 8ry\")\n  call assert_beeps('normal! \"@')\n  bw!\nendfunc\n\nfunc Test_normal13_help()\n  \" Test for F1\n  call assert_equal(1, winnr())\n  call feedkeys(\"\\<f1>\", 'txi')\n  call assert_match('help\\.txt', bufname('%'))\n  call assert_equal(2, winnr('$'))\n  bw!\nendfunc\n\nfunc Test_normal14_page()\n  \" basic test for Ctrl-F and Ctrl-B\n  call Setup_NewWindow()\n  exe \"norm! \\<c-f>\"\n  call assert_equal('9', getline('.'))\n  exe \"norm! 2\\<c-f>\"\n  call assert_equal('25', getline('.'))\n  exe \"norm! 2\\<c-b>\"\n  call assert_equal('18', getline('.'))\n  1\n  set scrolloff=5\n  exe \"norm! 2\\<c-f>\"\n  call assert_equal('21', getline('.'))\n  exe \"norm! \\<c-b>\"\n  call assert_equal('13', getline('.'))\n  1\n  set scrolloff=99\n  exe \"norm! \\<c-f>\"\n  call assert_equal('13', getline('.'))\n  set scrolloff=0\n  100\n  exe \"norm! $\\<c-b>\"\n  call assert_equal('92', getline('.'))\n  call assert_equal([0, 92, 1, 0, 1], getcurpos())\n  100\n  set nostartofline\n  exe \"norm! $\\<c-b>\"\n  call assert_equal('92', getline('.'))\n  call assert_equal([0, 92, 2, 0, 2147483647], getcurpos())\n  \" cleanup\n  set startofline\n  bw!\nendfunc\n\nfunc Test_normal14_page_eol()\n  10new\n  norm oxxxxxxx\n  exe \"norm 2\\<c-f>\"\n  \" check with valgrind that cursor is put back in column 1\n  exe \"norm 2\\<c-b>\"\n  bw!\nendfunc\n\n\" Test for errors with z command\nfunc Test_normal_z_error()\n  call assert_beeps('normal! z2p')\n  call assert_beeps('normal! zq')\nendfunc\n\nfunc Test_normal15_z_scroll_vert()\n  \" basic test for z commands that scroll the window\n  call Setup_NewWindow()\n  100\n  norm! >>\n  \" Test for z<cr>\n  exe \"norm! z\\<cr>\"\n  call assert_equal('\t100', getline('.'))\n  call assert_equal(100, winsaveview()['topline'])\n  call assert_equal([0, 100, 2, 0, 9], getcurpos())\n\n  \" Test for zt\n  21\n  norm! >>0zt\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 21, 1, 0, 8], getcurpos())\n\n  \" Test for zb\n  30\n  norm! >>$ztzb\n  call assert_equal('\t30', getline('.'))\n  call assert_equal(30, winsaveview()['topline']+winheight(0)-1)\n  call assert_equal([0, 30, 3, 0, 2147483647], getcurpos())\n\n  \" Test for z-\n  1\n  30\n  norm! 0z-\n  call assert_equal('\t30', getline('.'))\n  call assert_equal(30, winsaveview()['topline']+winheight(0)-1)\n  call assert_equal([0, 30, 2, 0, 9], getcurpos())\n\n  \" Test for z{height}<cr>\n  call assert_equal(10, winheight(0))\n  exe \"norm! z12\\<cr>\"\n  call assert_equal(12, winheight(0))\n  exe \"norm! z10\\<cr>\"\n  call assert_equal(10, winheight(0))\n\n  \" Test for z.\n  1\n  21\n  norm! 0z.\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(17, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for zz\n  1\n  21\n  norm! 0zz\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(17, winsaveview()['topline'])\n  call assert_equal([0, 21, 1, 0, 8], getcurpos())\n\n  \" Test for z+\n  11\n  norm! zt\n  norm! z+\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for [count]z+\n  1\n  norm! 21z+\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for z+ with [count] greater than buffer size\n  1\n  norm! 1000z+\n  call assert_equal('\t100', getline('.'))\n  call assert_equal(100, winsaveview()['topline'])\n  call assert_equal([0, 100, 2, 0, 9], getcurpos())\n\n  \" Test for z+ from the last buffer line\n  norm! Gz.z+\n  call assert_equal('\t100', getline('.'))\n  call assert_equal(100, winsaveview()['topline'])\n  call assert_equal([0, 100, 2, 0, 9], getcurpos())\n\n  \" Test for z^\n  norm! 22z+0\n  norm! z^\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(12, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for z^ from first buffer line\n  norm! ggz^\n  call assert_equal('1', getline('.'))\n  call assert_equal(1, winsaveview()['topline'])\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n\n  \" Test for [count]z^\n  1\n  norm! 30z^\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(12, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" cleanup\n  bw!\nendfunc\n\nfunc Test_normal16_z_scroll_hor()\n  \" basic test for z commands that scroll the window\n  10new\n  15vsp\n  set nowrap listchars=\n  let lineA='abcdefghijklmnopqrstuvwxyz'\n  let lineB='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  $put =lineA\n  $put =lineB\n  1d\n\n  \" Test for zl and zh with a count\n  norm! 0z10l\n  call assert_equal([11, 1], [col('.'), wincol()])\n  norm! z4h\n  call assert_equal([11, 5], [col('.'), wincol()])\n  normal! 2gg\n\n  \" Test for zl\n  1\n  norm! 5zl\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(6, col('.'))\n  call assert_equal(5, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('f', @0)\n\n  \" Test for zh\n  norm! 2zh\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(6, col('.'))\n  norm! yl\n  call assert_equal('f', @0)\n  call assert_equal(3, winsaveview()['leftcol'])\n\n  \" Test for zL\n  norm! zL\n  call assert_equal(11, col('.'))\n  norm! yl\n  call assert_equal('k', @0)\n  call assert_equal(10, winsaveview()['leftcol'])\n  norm! 2zL\n  call assert_equal(25, col('.'))\n  norm! yl\n  call assert_equal('y', @0)\n  call assert_equal(24, winsaveview()['leftcol'])\n\n  \" Test for zH\n  norm! 2zH\n  call assert_equal(25, col('.'))\n  call assert_equal(10, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('y', @0)\n\n  \" Test for zs\n  norm! $zs\n  call assert_equal(26, col('.'))\n  call assert_equal(25, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" Test for ze\n  norm! ze\n  call assert_equal(26, col('.'))\n  call assert_equal(11, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" Test for zs and ze with folds\n  %fold\n  norm! $zs\n  call assert_equal(26, col('.'))\n  call assert_equal(0, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n  norm! ze\n  call assert_equal(26, col('.'))\n  call assert_equal(0, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" cleanup\n  set wrap listchars=eol:$\n  bw!\nendfunc\n\nfunc Test_normal17_z_scroll_hor2()\n  \" basic test for z commands that scroll the window\n  \" using 'sidescrolloff' setting\n  10new\n  20vsp\n  set nowrap listchars= sidescrolloff=5\n  let lineA='abcdefghijklmnopqrstuvwxyz'\n  let lineB='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  $put =lineA\n  $put =lineB\n  1d\n\n  \" Test for zl\n  1\n  norm! 5zl\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(11, col('.'))\n  call assert_equal(5, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('k', @0)\n\n  \" Test for zh\n  norm! 2zh\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(11, col('.'))\n  norm! yl\n  call assert_equal('k', @0)\n  call assert_equal(3, winsaveview()['leftcol'])\n\n  \" Test for zL\n  norm! 0zL\n  call assert_equal(16, col('.'))\n  norm! yl\n  call assert_equal('p', @0)\n  call assert_equal(10, winsaveview()['leftcol'])\n  norm! 2zL\n  call assert_equal(26, col('.'))\n  norm! yl\n  call assert_equal('z', @0)\n  call assert_equal(15, winsaveview()['leftcol'])\n\n  \" Test for zH\n  norm! 2zH\n  call assert_equal(15, col('.'))\n  call assert_equal(0, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('o', @0)\n\n  \" Test for zs\n  norm! $zs\n  call assert_equal(26, col('.'))\n  call assert_equal(20, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" Test for ze\n  norm! ze\n  call assert_equal(26, col('.'))\n  call assert_equal(11, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" cleanup\n  set wrap listchars=eol:$ sidescrolloff=0\n  bw!\nendfunc\n\n\" Test for commands that scroll the window horizontally. Test with folds.\n\"   H, M, L, CTRL-E, CTRL-Y, CTRL-U, CTRL-D, PageUp, PageDown commands\nfunc Test_vert_scroll_cmds()\n  15new\n  call setline(1, range(1, 100))\n  exe \"normal! 30ggz\\<CR>\"\n  set foldenable\n  33,36fold\n  40,43fold\n  46,49fold\n  let h = winheight(0)\n\n  \" Test for H, M and L commands\n  \" Top of the screen = 30\n  \" Folded lines = 9\n  \" Bottom of the screen = 30 + h + 9 - 1\n  normal! 4L\n  call assert_equal(35 + h, line('.'))\n  normal! 4H\n  call assert_equal(33, line('.'))\n\n  \" Test for using a large count value\n  %d\n  call setline(1, range(1, 4))\n  norm! 6H\n  call assert_equal(4, line('.'))\n\n  \" Test for 'M' with folded lines\n  %d\n  call setline(1, range(1, 20))\n  1,5fold\n  norm! LM\n  call assert_equal(12, line('.'))\n\n  \" Test for the CTRL-E and CTRL-Y commands with folds\n  %d\n  call setline(1, range(1, 10))\n  3,5fold\n  exe \"normal 6G3\\<C-E>\"\n  call assert_equal(6, line('w0'))\n  exe \"normal 2\\<C-Y>\"\n  call assert_equal(2, line('w0'))\n\n  \" Test for CTRL-Y on a folded line\n  %d\n  call setline(1, range(1, 100))\n  exe (h + 2) .. \",\" .. (h + 4) .. \"fold\"\n  exe h + 5\n  normal z-\n  exe \"normal \\<C-Y>\\<C-Y>\"\n  call assert_equal(h + 1, line('w$'))\n\n  \" Test for CTRL-Y from the first line and CTRL-E from the last line\n  %d\n  set scrolloff=2\n  call setline(1, range(1, 4))\n  exe \"normal gg\\<C-Y>\"\n  call assert_equal(1, line('w0'))\n  call assert_equal(1, line('.'))\n  exe \"normal G4\\<C-E>\\<C-E>\"\n  call assert_equal(4, line('w$'))\n  call assert_equal(4, line('.'))\n  set scrolloff&\n\n  \" Using <PageUp> and <PageDown> in an empty buffer should beep\n  %d\n  call assert_beeps('exe \"normal \\<PageUp>\"')\n  call assert_beeps('exe \"normal \\<C-B>\"')\n  call assert_beeps('exe \"normal \\<PageDown>\"')\n  call assert_beeps('exe \"normal \\<C-F>\"')\n\n  \" Test for <C-U> and <C-D> with fold\n  %d\n  call setline(1, range(1, 100))\n  10,35fold\n  set scroll=10\n  exe \"normal \\<C-D>\"\n  call assert_equal(36, line('.'))\n  exe \"normal \\<C-D>\"\n  call assert_equal(46, line('.'))\n  exe \"normal \\<C-U>\"\n  call assert_equal(36, line('.'))\n  exe \"normal \\<C-U>\"\n  call assert_equal(10, line('.'))\n  exe \"normal \\<C-U>\"\n  call assert_equal(1, line('.'))\n  set scroll&\n\n  \" Test for scrolling to the top of the file with <C-U> and a fold\n  10\n  normal ztL\n  exe \"normal \\<C-U>\\<C-U>\"\n  call assert_equal(1, line('w0'))\n\n  \" Test for CTRL-D on a folded line\n  %d\n  call setline(1, range(1, 100))\n  50,100fold\n  75\n  normal z-\n  exe \"normal \\<C-D>\"\n  call assert_equal(50, line('.'))\n  call assert_equal(100, line('w$'))\n  normal z.\n  let lnum = winline()\n  exe \"normal \\<C-D>\"\n  call assert_equal(lnum, winline())\n  call assert_equal(50, line('.'))\n  normal zt\n  exe \"normal \\<C-D>\"\n  call assert_equal(50, line('w0'))\n\n  \" Test for <S-CR>. Page down.\n  %d\n  call setline(1, range(1, 100))\n  call feedkeys(\"\\<S-CR>\", 'xt')\n  call assert_equal(14, line('w0'))\n  call assert_equal(28, line('w$'))\n\n  \" Test for <S-->. Page up.\n  call feedkeys(\"\\<S-->\", 'xt')\n  call assert_equal(1, line('w0'))\n  call assert_equal(15, line('w$'))\n\n  set foldenable&\n  close!\nendfunc\n\nfunc Test_scroll_in_ex_mode()\n  \" This was using invalid memory because w_botline was invalid.\n  let lines =<< trim END\n      diffsplit\n      norm os0\u00030(\u0004\n      call writefile(['done'], 'Xdone')\n      qa!\n  END\n  call writefile(lines, 'Xscript')\n  call assert_equal(1, RunVim([], [], '--clean -X -Z -e -s -S Xscript'))\n  call assert_equal(['done'], readfile('Xdone'))\n\n  call delete('Xscript')\n  call delete('Xdone')\nendfunc\n\n\" Test for the 'sidescroll' option\nfunc Test_sidescroll_opt()\n  new\n  20vnew\n\n  \" scroll by 2 characters horizontally\n  set sidescroll=2 nowrap\n  call setline(1, repeat('a', 40))\n  normal g$l\n  call assert_equal(19, screenpos(0, 1, 21).col)\n  normal l\n  call assert_equal(20, screenpos(0, 1, 22).col)\n  normal g0h\n  call assert_equal(2, screenpos(0, 1, 2).col)\n  call assert_equal(20, screenpos(0, 1, 20).col)\n\n  \" when 'sidescroll' is 0, cursor positioned at the center\n  set sidescroll=0\n  normal g$l\n  call assert_equal(11, screenpos(0, 1, 21).col)\n  normal g0h\n  call assert_equal(10, screenpos(0, 1, 10).col)\n\n  %bw!\n  set wrap& sidescroll&\nendfunc\n\n\" basic tests for foldopen/folddelete\nfunc Test_normal18_z_fold()\n  CheckFeature folding\n  call Setup_NewWindow()\n  50\n  setl foldenable fdm=marker foldlevel=5\n\n  call assert_beeps('normal! zj')\n  call assert_beeps('normal! zk')\n\n  \" Test for zF\n  \" First fold\n  norm! 4zF\n  \" check that folds have been created\n  call assert_equal(['50/*{{{*/', '51', '52', '53/*}}}*/'], getline(50,53))\n\n  \" Test for zd\n  51\n  norm! 2zF\n  call assert_equal(2, foldlevel('.'))\n  norm! kzd\n  call assert_equal(['50', '51/*{{{*/', '52/*}}}*/', '53'], getline(50,53))\n  norm! j\n  call assert_equal(1, foldlevel('.'))\n\n  \" Test for zD\n  \" also deletes partially selected folds recursively\n  51\n  norm! zF\n  call assert_equal(2, foldlevel('.'))\n  norm! kV2jzD\n  call assert_equal(['50', '51', '52', '53'], getline(50,53))\n\n  \" Test for zE\n  85\n  norm! 4zF\n  86\n  norm! 2zF\n  90\n  norm! 4zF\n  call assert_equal(['85/*{{{*/', '86/*{{{*/', '87/*}}}*/', '88/*}}}*/', '89', '90/*{{{*/', '91', '92', '93/*}}}*/'], getline(85,93))\n  norm! zE\n  call assert_equal(['85', '86', '87', '88', '89', '90', '91', '92', '93'], getline(85,93))\n\n  \" Test for zn\n  50\n  set foldlevel=0\n  norm! 2zF\n  norm! zn\n  norm! k\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  call assert_equal(0, &foldenable)\n\n  \" Test for zN\n  49\n  norm! zN\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  call assert_equal(1, &foldenable)\n\n  \" Test for zi\n  norm! zi\n  call assert_equal(0, &foldenable)\n  norm! zi\n  call assert_equal(1, &foldenable)\n  norm! zi\n  call assert_equal(0, &foldenable)\n  norm! zi\n  call assert_equal(1, &foldenable)\n\n  \" Test for za\n  50\n  norm! za\n  norm! k\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  50\n  norm! za\n  norm! k\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  49\n  norm! 5zF\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n  49\n  norm! za\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  set nofoldenable\n  \" close fold and set foldenable\n  norm! za\n  call assert_equal(1, &foldenable)\n\n  50\n  \" have to use {count}za to open all folds and make the cursor visible\n  norm! 2za\n  norm! 2k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" Test for zA\n  49\n  set foldlevel=0\n  50\n  norm! zA\n  norm! 2k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" zA on a opened fold when foldenable is not set\n  50\n  set nofoldenable\n  norm! zA\n  call assert_equal(1, &foldenable)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zc\n  norm! zE\n  50\n  norm! 2zF\n  49\n  norm! 5zF\n  set nofoldenable\n  50\n  \" There most likely is a bug somewhere:\n  \" https://groups.google.com/d/msg/vim_dev/v2EkfJ_KQjI/u-Cvv94uCAAJ\n  \" TODO: Should this only close the inner most fold or both folds?\n  norm! zc\n  call assert_equal(1, &foldenable)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n  set nofoldenable\n  50\n  norm! Vjzc\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zC\n  set nofoldenable\n  50\n  norm! zCk\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zx\n  \" 1) close folds at line 49-54\n  set nofoldenable\n  48\n  norm! zx\n  call assert_equal(1, &foldenable)\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" 2) do not close fold under cursor\n  51\n  set nofoldenable\n  norm! zx\n  call assert_equal(1, &foldenable)\n  norm! 3k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  norm! j\n  call assert_equal('53', getline('.'))\n  norm! j\n  call assert_equal('54/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" 3) close one level of folds\n  48\n  set nofoldenable\n  set foldlevel=1\n  norm! zx\n  call assert_equal(1, &foldenable)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  norm! j\n  call assert_equal('53', getline('.'))\n  norm! j\n  call assert_equal('54/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zX\n  \" Close all folds\n  set foldlevel=0 nofoldenable\n  50\n  norm! zX\n  call assert_equal(1, &foldenable)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zm\n  50\n  set nofoldenable foldlevel=2\n  norm! zm\n  call assert_equal(1, &foldenable)\n  call assert_equal(1, &foldlevel)\n  norm! zm\n  call assert_equal(0, &foldlevel)\n  norm! zm\n  call assert_equal(0, &foldlevel)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zm with a count\n  50\n  set foldlevel=2\n  norm! 3zm\n  call assert_equal(0, &foldlevel)\n  call assert_equal(49, foldclosed(line('.')))\n\n  \" Test for zM\n  48\n  set nofoldenable foldlevel=99\n  norm! zM\n  call assert_equal(1, &foldenable)\n  call assert_equal(0, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zr\n  48\n  set nofoldenable foldlevel=0\n  norm! zr\n  call assert_equal(0, &foldenable)\n  call assert_equal(1, &foldlevel)\n  set foldlevel=0 foldenable\n  norm! zr\n  call assert_equal(1, &foldenable)\n  call assert_equal(1, &foldlevel)\n  norm! zr\n  call assert_equal(2, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" Test for zR\n  48\n  set nofoldenable foldlevel=0\n  norm! zR\n  call assert_equal(0, &foldenable)\n  call assert_equal(2, &foldlevel)\n  set foldenable foldlevel=0\n  norm! zR\n  call assert_equal(1, &foldenable)\n  call assert_equal(2, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  call append(50, ['a /*{{{*/', 'b /*}}}*/'])\n  48\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('a /*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  48\n  norm! zR\n  call assert_equal(1, &foldenable)\n  call assert_equal(3, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('a /*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('b /*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" clean up\n  setl nofoldenable fdm=marker foldlevel=0\n  bw!\nendfunc\n\nfunc Test_normal20_exmode()\n  \" Reading from redirected file doesn't work on MS-Windows\n  CheckNotMSWindows\n  call writefile(['1a', 'foo', 'bar', '.', 'w! Xfile2', 'q!'], 'Xscript')\n  call writefile(['1', '2'], 'Xfile')\n  call system(GetVimCommand() .. ' -e -s < Xscript Xfile')\n  let a=readfile('Xfile2')\n  call assert_equal(['1', 'foo', 'bar', '2'], a)\n\n  \" clean up\n  for file in ['Xfile', 'Xfile2', 'Xscript']\n    call delete(file)\n  endfor\n  bw!\nendfunc\n\nfunc Test_normal21_nv_hat()\n\n  \" Edit a fresh file and wipe the buffer list so that there is no alternate\n  \" file present.  Next, check for the expected command failures.\n  edit Xfoo | %bw\n  call assert_fails(':buffer #', 'E86:')\n  call assert_fails(':execute \"normal! \\<C-^>\"', 'E23:')\n  call assert_fails(\"normal i\\<C-R>#\", 'E23:')\n\n  \" Test for the expected behavior when switching between two named buffers.\n  edit Xfoo | edit Xbar\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('Xfoo', fnamemodify(bufname('%'), ':t'))\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('Xbar', fnamemodify(bufname('%'), ':t'))\n\n  \" Test for the expected behavior when only one buffer is named.\n  enew | let l:nr = bufnr('%')\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('Xbar', fnamemodify(bufname('%'), ':t'))\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('', bufname('%'))\n  call assert_equal(l:nr, bufnr('%'))\n\n  \" Test that no action is taken by \"<C-^>\" when an operator is pending.\n  edit Xfoo\n  call feedkeys(\"ci\\<C-^>\", 'tx')\n  call assert_equal('Xfoo', fnamemodify(bufname('%'), ':t'))\n\n  %bw!\nendfunc\n\nfunc Test_normal22_zet()\n  \" Test for ZZ\n  \" let shell = &shell\n  \" let &shell = 'sh'\n  call writefile(['1', '2'], 'Xfile')\n  let args = ' -N -i NONE --noplugins -X --not-a-term'\n  call system(GetVimCommand() .. args .. ' -c \"%d\" -c \":norm! ZZ\" Xfile')\n  let a = readfile('Xfile')\n  call assert_equal([], a)\n  \" Test for ZQ\n  call writefile(['1', '2'], 'Xfile')\n  call system(GetVimCommand() . args . ' -c \"%d\" -c \":norm! ZQ\" Xfile')\n  let a = readfile('Xfile')\n  call assert_equal(['1', '2'], a)\n\n  \" Unsupported Z command\n  call assert_beeps('normal! ZW')\n\n  \" clean up\n  for file in ['Xfile']\n    call delete(file)\n  endfor\n  \" let &shell = shell\nendfunc\n\nfunc Test_normal23_K()\n  \" Test for K command\n  new\n  call append(0, ['version8.txt', 'man', 'aa%bb', 'cc|dd'])\n  let k = &keywordprg\n  set keywordprg=:help\n  1\n  norm! VK\n  call assert_equal('version8.txt', fnamemodify(bufname('%'), ':t'))\n  call assert_equal('help', &ft)\n  call assert_match('\\*version8.txt\\*', getline('.'))\n  helpclose\n  norm! 0K\n  call assert_equal('version8.txt', fnamemodify(bufname('%'), ':t'))\n  call assert_equal('help', &ft)\n  call assert_match('\\*version8\\.\\d\\*', getline('.'))\n  helpclose\n\n  set keywordprg=:new\n  set iskeyword+=%\n  set iskeyword+=\\|\n  2\n  norm! K\n  call assert_equal('man', fnamemodify(bufname('%'), ':t'))\n  bwipe!\n  3\n  norm! K\n  call assert_equal('aa%bb', fnamemodify(bufname('%'), ':t'))\n  bwipe!\n  if !has('win32')\n    4\n    norm! K\n    call assert_equal('cc|dd', fnamemodify(bufname('%'), ':t'))\n    bwipe!\n  endif\n  set iskeyword-=%\n  set iskeyword-=\\|\n\n  \" Test for specifying a count to K\n  1\n  com! -nargs=* Kprog let g:Kprog_Args = <q-args>\n  set keywordprg=:Kprog\n  norm! 3K\n  call assert_equal('3 version8', g:Kprog_Args)\n  delcom Kprog\n\n  \" Only expect \"man\" to work on Unix\n  if !has(\"unix\")\n    let &keywordprg = k\n    bw!\n    return\n  endif\n\n  let not_gnu_man = has('mac') || has('bsd')\n  if not_gnu_man\n    \" In MacOS and BSD, the option for specifying a pager is different\n    set keywordprg=man\\ -P\\ cat\n  else\n    set keywordprg=man\\ --pager=cat\n  endif\n  \" Test for using man\n  2\n  let a = execute('unsilent norm! K')\n  if not_gnu_man\n    call assert_match(\"man -P cat 'man'\", a)\n  else\n    call assert_match(\"man --pager=cat 'man'\", a)\n  endif\n\n  \" Error cases\n  call setline(1, '#$#')\n  call assert_fails('normal! ggK', 'E349:')\n  call setline(1, '---')\n  call assert_fails('normal! ggv2lK', 'E349:')\n  call setline(1, ['abc', 'xyz'])\n  call assert_fails(\"normal! gg2lv2h\\<C-]>\", 'E433:')\n  call assert_beeps(\"normal! ggVjK\")\n  norm! V\n  call assert_beeps(\"norm! cK\")\n\n  \" clean up\n  let &keywordprg = k\n  bw!\nendfunc\n\nfunc Test_normal24_rot13()\n  \" Testing for g?? g?g?\n  new\n  call append(0, 'abcdefghijklmnopqrstuvwxyz\u00e4\u00fc\u00f6')\n  1\n  norm! g??\n  call assert_equal('nopqrstuvwxyzabcdefghijklm\u00e4\u00fc\u00f6', getline('.'))\n  norm! g?g?\n  call assert_equal('abcdefghijklmnopqrstuvwxyz\u00e4\u00fc\u00f6', getline('.'))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal25_tag()\n  CheckFeature quickfix\n\n  \" Testing for CTRL-] g CTRL-] g]\n  \" CTRL-W g] CTRL-W CTRL-] CTRL-W g CTRL-]\n  h\n  \" Test for CTRL-]\n  call search('\\<x\\>$')\n  exe \"norm! \\<c-]>\"\n  call assert_equal(\"change.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*x*\", @0)\n  exe \":norm \\<c-o>\"\n\n  \" Test for g_CTRL-]\n  call search('\\<v_u\\>$')\n  exe \"norm! g\\<c-]>\"\n  call assert_equal(\"change.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*v_u*\", @0)\n  exe \":norm \\<c-o>\"\n\n  \" Test for g]\n  call search('\\<i_<Esc>$')\n  let a = execute(\":norm! g]\")\n  call assert_match('i_<Esc>.*insert.txt', a)\n\n  if !empty(exepath('cscope')) && has('cscope')\n    \" setting cscopetag changes how g] works\n    set cst\n    exe \"norm! g]\"\n    call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n    norm! yiW\n    call assert_equal(\"*i_<Esc>*\", @0)\n    exe \":norm \\<c-o>\"\n    \" Test for CTRL-W g]\n    exe \"norm! \\<C-W>g]\"\n    call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n    norm! yiW\n    call assert_equal(\"*i_<Esc>*\", @0)\n    call assert_equal(3, winnr('$'))\n    helpclose\n    set nocst\n  endif\n\n  \" Test for CTRL-W g]\n  let a = execute(\"norm! \\<C-W>g]\")\n  call assert_match('i_<Esc>.*insert.txt', a)\n\n  \" Test for CTRL-W CTRL-]\n  exe \"norm! \\<C-W>\\<C-]>\"\n  call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*i_<Esc>*\", @0)\n  call assert_equal(3, winnr('$'))\n  helpclose\n\n  \" Test for CTRL-W g CTRL-]\n  exe \"norm! \\<C-W>g\\<C-]>\"\n  call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*i_<Esc>*\", @0)\n  call assert_equal(3, winnr('$'))\n  helpclose\n\n  \" clean up\n  helpclose\nendfunc\n\nfunc Test_normal26_put()\n  \" Test for ]p ]P [p and [P\n  new\n  call append(0, ['while read LINE', 'do', '  ((count++))', '  if [ $? -ne 0 ]; then', \"    echo 'Error writing file'\", '  fi', 'done'])\n  1\n  /Error/y a\n  2\n  norm! \"a]pj\"a[p\n  call assert_equal(['do', \"echo 'Error writing file'\", \"  echo 'Error writing file'\", '  ((count++))'], getline(2,5))\n  1\n  /^\\s\\{4}/\n  exe \"norm!  \\\"a]P3Eldt'\"\n  exe \"norm! j\\\"a[P2Eldt'\"\n  call assert_equal(['  if [ $? -ne 0 ]; then', \"    echo 'Error writing'\", \"    echo 'Error'\", \"    echo 'Error writing file'\", '  fi'], getline(6,10))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal27_bracket()\n  \" Test for [' [` ]' ]`\n  call Setup_NewWindow()\n  1,21s/.\\+/  &   b/\n  1\n  norm! $ma\n  5\n  norm! $mb\n  10\n  norm! $mc\n  15\n  norm! $md\n  20\n  norm! $me\n\n  \" Test for ['\n  9\n  norm! 2['\n  call assert_equal('  1   b', getline('.'))\n  call assert_equal(1, line('.'))\n  call assert_equal(3, col('.'))\n\n  \" Test for ]'\n  norm! ]'\n  call assert_equal('  5   b', getline('.'))\n  call assert_equal(5, line('.'))\n  call assert_equal(3, col('.'))\n\n  \" No mark after line 21, cursor moves to first non blank on current line\n  21\n  norm! $]'\n  call assert_equal('  21   b', getline('.'))\n  call assert_equal(21, line('.'))\n  call assert_equal(3, col('.'))\n\n  \" Test for [`\n  norm! 2[`\n  call assert_equal('  15   b', getline('.'))\n  call assert_equal(15, line('.'))\n  call assert_equal(8, col('.'))\n\n  \" Test for ]`\n  norm! ]`\n  call assert_equal('  20   b', getline('.'))\n  call assert_equal(20, line('.'))\n  call assert_equal(8, col('.'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for ( and ) sentence movements\nfunc Test_normal28_parenthesis()\n  new\n  call append(0, ['This is a test. With some sentences!', '', 'Even with a question? And one more. And no sentence here'])\n\n  $\n  norm! d(\n  call assert_equal(['This is a test. With some sentences!', '', 'Even with a question? And one more. ', ''], getline(1, '$'))\n  norm! 2d(\n  call assert_equal(['This is a test. With some sentences!', '', ' ', ''], getline(1, '$'))\n  1\n  norm! 0d)\n  call assert_equal(['With some sentences!', '', ' ', ''], getline(1, '$'))\n\n  call append('$', ['This is a long sentence', '', 'spanning', 'over several lines. '])\n  $\n  norm! $d(\n  call assert_equal(['With some sentences!', '', ' ', '', 'This is a long sentence', ''], getline(1, '$'))\n\n  \" Move to the next sentence from a paragraph macro\n  %d\n  call setline(1, ['.LP', 'blue sky!. blue sky.', 'blue sky. blue sky.'])\n  call cursor(1, 1)\n  normal )\n  call assert_equal([2, 1], [line('.'), col('.')])\n  normal )\n  call assert_equal([2, 12], [line('.'), col('.')])\n  normal ((\n  call assert_equal([1, 1], [line('.'), col('.')])\n\n  \" It is an error if a next sentence is not found\n  %d\n  call setline(1, '.SH')\n  call assert_beeps('normal )')\n\n  \" If only dot is present, don't treat that as a sentence\n  call setline(1, '. This is a sentence.')\n  normal $((\n  call assert_equal(3, col('.'))\n\n  \" Jumping to a fold should open the fold\n  call setline(1, ['', '', 'one', 'two', 'three'])\n  set foldenable\n  2,$fold\n  call feedkeys(')', 'xt')\n  call assert_equal(3, line('.'))\n  call assert_equal(1, foldlevel('.'))\n  call assert_equal(-1, foldclosed('.'))\n  set foldenable&\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for { and } paragraph movements\nfunc Test_normal29_brace()\n  let text =<< trim [DATA]\n    A paragraph begins after each empty line, and also at each of a set of\n    paragraph macros, specified by the pairs of characters in the 'paragraphs'\n    option.  The default is \"IPLPPPQPP TPHPLIPpLpItpplpipbp\", which corresponds to\n    the macros \".IP\", \".LP\", etc.  (These are nroff macros, so the dot must be in\n    the first column).  A section boundary is also a paragraph boundary.\n    Note that a blank line (only containing white space) is NOT a paragraph\n    boundary.\n\n\n    Also note that this does not include a '{' or '}' in the first column.  When\n    the '{' flag is in 'cpoptions' then '{' in the first column is used as a\n    paragraph boundary |posix|.\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n  [DATA]\n\n  new\n  call append(0, text)\n  1\n  norm! 0d2}\n\n  let expected =<< trim [DATA]\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  norm! 0d}\n\n  let expected =<< trim [DATA]\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n  \n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  $\n  norm! d{\n\n  let expected =<< trim [DATA]\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  norm! d{\n\n  let expected =<< trim [DATA]\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test with { in cpooptions\n  %d\n  call append(0, text)\n  set cpo+={\n  1\n  norm! 0d2}\n\n  let expected =<< trim [DATA]\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  $\n  norm! d}\n\n  let expected =<< trim [DATA]\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  norm! gg}\n  norm! d5}\n\n  let expected =<< trim [DATA]\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Jumping to a fold should open the fold\n  %d\n  call setline(1, ['', 'one', 'two', ''])\n  set foldenable\n  2,$fold\n  call feedkeys('}', 'xt')\n  call assert_equal(4, line('.'))\n  call assert_equal(1, foldlevel('.'))\n  call assert_equal(-1, foldclosed('.'))\n  set foldenable&\n\n  \" clean up\n  set cpo-={\n  bw!\nendfunc\n\n\" Test for section movements\nfunc Test_normal_section()\n  new\n  let lines =<< trim [END]\n    int foo()\n    {\n      if (1)\n      {\n        a = 1;\n      }\n    }\n  [END]\n  call setline(1, lines)\n\n  \" jumping to a folded line using [[ should open the fold\n  2,3fold\n  call cursor(5, 1)\n  call feedkeys(\"[[\", 'xt')\n  call assert_equal(2, line('.'))\n  call assert_equal(-1, foldclosedend(line('.')))\n\n  close!\nendfunc\n\n\" Test for changing case using u, U, gu, gU and ~ (tilde) commands\nfunc Test_normal30_changecase()\n  new\n  call append(0, 'This is a simple test: \u00e4\u00fc\u00f6\u00df')\n  norm! 1ggVu\n  call assert_equal('this is a simple test: \u00e4\u00fc\u00f6\u00df', getline('.'))\n  norm! VU\n  call assert_equal('THIS IS A SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! guu\n  call assert_equal('this is a simple test: \u00e4\u00fc\u00f6ss', getline('.'))\n  norm! gUgU\n  call assert_equal('THIS IS A SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! gugu\n  call assert_equal('this is a simple test: \u00e4\u00fc\u00f6ss', getline('.'))\n  norm! gUU\n  call assert_equal('THIS IS A SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! 010~\n  call assert_equal('this is a SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! V~\n  call assert_equal('THIS IS A simple test: \u00e4\u00fc\u00f6ss', getline('.'))\n  call assert_beeps('norm! c~')\n  %d\n  call assert_beeps('norm! ~')\n\n  \" Test for changing case across lines using 'whichwrap'\n  call setline(1, ['aaaaaa', 'aaaaaa'])\n  normal! gg10~\n  call assert_equal(['AAAAAA', 'aaaaaa'], getline(1, 2))\n  set whichwrap+=~\n  normal! gg10~\n  call assert_equal(['aaaaaa', 'AAAAaa'], getline(1, 2))\n  set whichwrap&\n\n  \" try changing the case with a double byte encoding (DBCS)\n  %bw!\n  let enc = &enc\n  set encoding=cp932\n  call setline(1, \"\\u8470\")\n  normal ~\n  normal gU$gu$gUgUg~g~gugu\n  call assert_equal(\"\\u8470\", getline(1))\n  let &encoding = enc\n\n  \" clean up\n  bw!\nendfunc\n\n\" Turkish ASCII turns to multi-byte.  On some systems Turkish locale\n\" is available but toupper()/tolower() don't do the right thing.\nfunc Test_normal_changecase_turkish()\n  new\n  try\n    lang tr_TR.UTF-8\n    set casemap=\n    let iupper = toupper('i')\n    if iupper == \"\\u0130\"\n      call setline(1, 'iI')\n      1normal gUU\n      call assert_equal(\"\\u0130I\", getline(1))\n      call assert_equal(\"\\u0130I\", toupper(\"iI\"))\n\n      call setline(1, 'iI')\n      1normal guu\n      call assert_equal(\"i\\u0131\", getline(1))\n      call assert_equal(\"i\\u0131\", tolower(\"iI\"))\n    elseif iupper == \"I\"\n      call setline(1, 'iI')\n      1normal gUU\n      call assert_equal(\"II\", getline(1))\n      call assert_equal(\"II\", toupper(\"iI\"))\n\n      call setline(1, 'iI')\n      1normal guu\n      call assert_equal(\"ii\", getline(1))\n      call assert_equal(\"ii\", tolower(\"iI\"))\n    else\n      call assert_true(false, \"expected toupper('i') to be either 'I' or '\\u0130'\")\n    endif\n    set casemap&\n    call setline(1, 'iI')\n    1normal gUU\n    call assert_equal(\"II\", getline(1))\n    call assert_equal(\"II\", toupper(\"iI\"))\n\n    call setline(1, 'iI')\n    1normal guu\n    call assert_equal(\"ii\", getline(1))\n    call assert_equal(\"ii\", tolower(\"iI\"))\n\n    lang en_US.UTF-8\n  catch /E197:/\n    \" can't use Turkish locale\n    throw 'Skipped: Turkish locale not available'\n  endtry\n  close!\nendfunc\n\n\" Test for r (replace) command\nfunc Test_normal31_r_cmd()\n  new\n  call append(0, 'This is a simple test: abcd')\n  exe \"norm! 1gg$r\\<cr>\"\n  call assert_equal(['This is a simple test: abc', '', ''], getline(1,'$'))\n  exe \"norm! 1gg2wlr\\<cr>\"\n  call assert_equal(['This is a', 'simple test: abc', '', ''], getline(1,'$'))\n  exe \"norm! 2gg0W5r\\<cr>\"\n  call assert_equal(['This is a', 'simple ', ' abc', '', ''], getline('1', '$'))\n  set autoindent\n  call setline(2, ['simple test: abc', ''])\n  exe \"norm! 2gg0W5r\\<cr>\"\n  call assert_equal(['This is a', 'simple ', 'abc', '', '', ''], getline('1', '$'))\n  exe \"norm! 1ggVr\\<cr>\"\n  call assert_equal('^M^M^M^M^M^M^M^M^M', strtrans(getline(1)))\n  call setline(1, 'This is a')\n  exe \"norm! 1gg05rf\"\n  call assert_equal('fffffis a', getline(1))\n\n  \" When replacing characters, copy characters from above and below lines\n  \" using CTRL-Y and CTRL-E.\n  \" Different code paths are used for utf-8 and latin1 encodings\n  set showmatch\n  for enc in ['latin1', 'utf-8']\n    enew!\n    let &encoding = enc\n    call setline(1, [' {a}', 'xxxxxxxxxx', '      [b]'])\n    exe \"norm! 2gg5r\\<C-Y>l5r\\<C-E>\"\n    call assert_equal(' {a}x [b]x', getline(2))\n  endfor\n  set showmatch&\n\n  \" r command should fail in operator pending mode\n  call assert_beeps('normal! cr')\n\n  \" replace a tab character in visual mode\n  %d\n  call setline(1, [\"a\\tb\", \"c\\td\", \"e\\tf\"])\n  normal gglvjjrx\n  call assert_equal(['axx', 'xxx', 'xxf'], getline(1, '$'))\n\n  \" replace with a multibyte character (with multiple composing characters)\n  %d\n  new\n  call setline(1, 'aaa')\n  exe \"normal $ra\\u0328\\u0301\"\n  call assert_equal(\"aaa\\u0328\\u0301\", getline(1))\n\n  \" clean up\n  set noautoindent\n  bw!\nendfunc\n\n\" Test for g*, g#\nfunc Test_normal32_g_cmd1()\n  new\n  call append(0, ['abc.x_foo', 'x_foobar.abc'])\n  1\n  norm! $g*\n  call assert_equal('x_foo', @/)\n  call assert_equal('x_foobar.abc', getline('.'))\n  norm! $g#\n  call assert_equal('abc', @/)\n  call assert_equal('abc.x_foo', getline('.'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for g`, g;, g,, g&, gv, gk, gj, gJ, g0, g^, g_, gm, g$, gM, g CTRL-G,\n\" gi and gI commands\nfunc Test_normal33_g_cmd2()\n  CheckFeature jumplist\n  call Setup_NewWindow()\n  \" Test for g`\n  clearjumps\n  norm! ma10j\n  let a=execute(':jumps')\n  \" empty jumplist\n  call assert_equal('>', a[-1:])\n  norm! g`a\n  call assert_equal('>', a[-1:])\n  call assert_equal(1, line('.'))\n  call assert_equal('1', getline('.'))\n  call cursor(10, 1)\n  norm! g'a\n  call assert_equal('>', a[-1:])\n  call assert_equal(1, line('.'))\n\n  \" Test for g; and g,\n  norm! g;\n  \" there is only one change in the changelist\n  \" currently, when we setup the window\n  call assert_equal(2, line('.'))\n  call assert_fails(':norm! g;', 'E662:')\n  call assert_fails(':norm! g,', 'E663:')\n  let &ul=&ul\n  call append('$', ['a', 'b', 'c', 'd'])\n  let &ul=&ul\n  call append('$', ['Z', 'Y', 'X', 'W'])\n  let a = execute(':changes')\n  call assert_match('2\\s\\+0\\s\\+2', a)\n  call assert_match('101\\s\\+0\\s\\+a', a)\n  call assert_match('105\\s\\+0\\s\\+Z', a)\n  norm! 3g;\n  call assert_equal(2, line('.'))\n  norm! 2g,\n  call assert_equal(105, line('.'))\n\n  \" Test for g& - global substitute\n  %d\n  call setline(1, range(1,10))\n  call append('$', ['a', 'b', 'c', 'd'])\n  $s/\\w/&&/g\n  exe \"norm! /[1-8]\\<cr>\"\n  norm! g&\n  call assert_equal(['11', '22', '33', '44', '55', '66', '77', '88', '9', '110', 'a', 'b', 'c', 'dd'], getline(1, '$'))\n\n  \" Jumping to a fold using gg should open the fold\n  set foldenable\n  set foldopen+=jump\n  5,8fold\n  call feedkeys('6gg', 'xt')\n  call assert_equal(1, foldlevel('.'))\n  call assert_equal(-1, foldclosed('.'))\n  set foldopen-=jump\n  set foldenable&\n\n  \" Test for gv\n  %d\n  call append('$', repeat(['abcdefgh'], 8))\n  exe \"norm! 2gg02l\\<c-v>2j2ly\"\n  call assert_equal(['cde', 'cde', 'cde'], getreg(0, 1, 1))\n  \" in visual mode, gv swaps current and last selected region\n  exe \"norm! G0\\<c-v>4k4lgvd\"\n  call assert_equal(['', 'abfgh', 'abfgh', 'abfgh', 'abcdefgh', 'abcdefgh', 'abcdefgh', 'abcdefgh', 'abcdefgh'], getline(1,'$'))\n  exe \"norm! G0\\<c-v>4k4ly\"\n  exe \"norm! gvood\"\n  call assert_equal(['', 'abfgh', 'abfgh', 'abfgh', 'fgh', 'fgh', 'fgh', 'fgh', 'fgh'], getline(1,'$'))\n  \" gv cannot be used  in operator pending mode\n  call assert_beeps('normal! cgv')\n  \" gv should beep without a previously selected visual area\n  new\n  call assert_beeps('normal! gv')\n  close\n\n  \" Test for gk/gj\n  %d\n  15vsp\n  set wrap listchars= sbr=\n  let lineA = 'abcdefghijklmnopqrstuvwxyz'\n  let lineB = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  let lineC = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n  $put =lineA\n  $put =lineB\n\n  norm! 3gg0dgk\n  call assert_equal(['', 'abcdefghijklmno', '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'], getline(1, '$'))\n  set nu\n  norm! 3gg0gjdgj\n  call assert_equal(['', 'abcdefghijklmno', '0123456789AMNOPQRSTUVWXYZ'], getline(1,'$'))\n\n  \" Test for gJ\n  norm! 2gggJ\n  call assert_equal(['', 'abcdefghijklmno0123456789AMNOPQRSTUVWXYZ'], getline(1,'$'))\n  call assert_equal(16, col('.'))\n  \" shouldn't do anything\n  norm! 10gJ\n  call assert_equal(1, col('.'))\n\n  \" Test for g0 g^ gm g$\n  exe \"norm! 2gg0gji   \"\n  call assert_equal(['', 'abcdefghijk   lmno0123456789AMNOPQRSTUVWXYZ'], getline(1,'$'))\n  norm! g0yl\n  call assert_equal(12, col('.'))\n  call assert_equal(' ', getreg(0))\n  norm! g$yl\n  call assert_equal(22, col('.'))\n  call assert_equal('3', getreg(0))\n  norm! gmyl\n  call assert_equal(17, col('.'))\n  call assert_equal('n', getreg(0))\n  norm! g^yl\n  call assert_equal(15, col('.'))\n  call assert_equal('l', getreg(0))\n  call assert_beeps('normal 5g$')\n\n  \" Test for g$ with double-width character half displayed\n  vsplit\n  9wincmd |\n  setlocal nowrap nonumber\n  call setline(2, 'asdfasdf\u30e8')\n  2\n  normal 0g$\n  call assert_equal(8, col('.'))\n  10wincmd |\n  normal 0g$\n  call assert_equal(9, col('.'))\n\n  setlocal signcolumn=yes\n  11wincmd |\n  normal 0g$\n  call assert_equal(8, col('.'))\n  12wincmd |\n  normal 0g$\n  call assert_equal(9, col('.'))\n\n  close\n\n  \" Test for g_\n  call assert_beeps('normal! 100g_')\n  call setline(2, ['  foo  ', '  foobar  '])\n  normal! 2ggg_\n  call assert_equal(5, col('.'))\n  normal! 2g_\n  call assert_equal(8, col('.'))\n\n  norm! 2ggdG\n  $put =lineC\n\n  \" Test for gM\n  norm! gMyl\n  call assert_equal(73, col('.'))\n  call assert_equal('0', getreg(0))\n  \" Test for 20gM\n  norm! 20gMyl\n  call assert_equal(29, col('.'))\n  call assert_equal('S', getreg(0))\n  \" Test for 60gM\n  norm! 60gMyl\n  call assert_equal(87, col('.'))\n  call assert_equal('E', getreg(0))\n\n  \" Test for g Ctrl-G\n  set ff=unix\n  let a=execute(\":norm! g\\<c-g>\")\n  call assert_match('Col 87 of 144; Line 2 of 2; Word 1 of 1; Byte 88 of 146', a)\n\n  \" Test for gI\n  norm! gIfoo\n  call assert_equal(['', 'foo0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'], getline(1,'$'))\n\n  \" Test for gi\n  wincmd c\n  %d\n  set tw=0\n  call setline(1, ['foobar', 'new line'])\n  norm! A next word\n  $put ='third line'\n  norm! gi another word\n  call assert_equal(['foobar next word another word', 'new line', 'third line'], getline(1,'$'))\n  call setline(1, 'foobar')\n  normal! Ggifirst line\n  call assert_equal('foobarfirst line', getline(1))\n  \" Test gi in 'virtualedit' mode with cursor after the end of the line\n  set virtualedit=all\n  call setline(1, 'foo')\n  exe \"normal! Abar\\<Right>\\<Right>\\<Right>\\<Right>\"\n  call setline(1, 'foo')\n  normal! Ggifirst line\n  call assert_equal('foo       first line', getline(1))\n  set virtualedit&\n\n  \" Test for aboring a g command using CTRL-\\ CTRL-G\n  exe \"normal! g\\<C-\\>\\<C-G>\"\n  call assert_equal('foo       first line', getline('.'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for g CTRL-G\nfunc Test_g_ctrl_g()\n  new\n\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\n--No lines in buffer--\", a)\n\n  \" Test for CTRL-G (same as :file)\n  let a = execute(\":norm! \\<c-g>\")\n  call assert_equal(\"\\n\\n\\\"[No Name]\\\" --No lines in buffer--\", a)\n\n  call setline(1, ['first line', 'second line'])\n\n  \" Test g CTRL-g with dos, mac and unix file type.\n  norm! gojll\n  set ff=dos\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 3 of 11; Line 2 of 2; Word 3 of 4; Byte 15 of 25\", a)\n\n  set ff=mac\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 3 of 11; Line 2 of 2; Word 3 of 4; Byte 14 of 23\", a)\n\n  set ff=unix\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 3 of 11; Line 2 of 2; Word 3 of 4; Byte 14 of 23\", a)\n\n  \" Test g CTRL-g in visual mode (v)\n  let a = execute(\":norm! gojllvlg\\<c-g>\")\n  call assert_equal(\"\\nSelected 1 of 2 Lines; 1 of 4 Words; 2 of 23 Bytes\", a)\n\n  \" Test g CTRL-g in visual mode (CTRL-V) with end col > start col\n  let a = execute(\":norm! \\<Esc>gojll\\<C-V>kllg\\<c-g>\")\n  call assert_equal(\"\\nSelected 3 Cols; 2 of 2 Lines; 2 of 4 Words; 6 of 23 Bytes\", a)\n\n  \" Test g_CTRL-g in visual mode (CTRL-V) with end col < start col\n  let a = execute(\":norm! \\<Esc>goll\\<C-V>jhhg\\<c-g>\")\n  call assert_equal(\"\\nSelected 3 Cols; 2 of 2 Lines; 2 of 4 Words; 6 of 23 Bytes\", a)\n\n  \" Test g CTRL-g in visual mode (CTRL-V) with end_vcol being MAXCOL\n  let a = execute(\":norm! \\<Esc>gojll\\<C-V>k$g\\<c-g>\")\n  call assert_equal(\"\\nSelected 2 of 2 Lines; 4 of 4 Words; 17 of 23 Bytes\", a)\n\n  \" There should be one byte less with noeol\n  set bin noeol\n  let a = execute(\":norm! \\<Esc>gog\\<c-g>\")\n  call assert_equal(\"\\nCol 1 of 10; Line 1 of 2; Word 1 of 4; Char 1 of 23; Byte 1 of 22\", a)\n  set bin & eol&\n\n  call setline(1, ['Fran\u00e7ais', '\u65e5\u672c\u8a9e'])\n\n  let a = execute(\":norm! \\<Esc>gojlg\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20\", a)\n\n  let a = execute(\":norm! \\<Esc>gojvlg\\<c-g>\")\n  call assert_equal(\"\\nSelected 1 of 2 Lines; 1 of 2 Words; 2 of 13 Chars; 6 of 20 Bytes\", a)\n\n  let a = execute(\":norm! \\<Esc>goll\\<c-v>jlg\\<c-g>\")\n  call assert_equal(\"\\nSelected 4 Cols; 2 of 2 Lines; 2 of 2 Words; 6 of 13 Chars; 11 of 20 Bytes\", a)\n\n  set fenc=utf8 bomb\n  let a = execute(\":norm! \\<Esc>gojlg\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20(+3 for BOM)\", a)\n\n  set fenc=utf16 bomb\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20(+2 for BOM)\", a)\n\n  set fenc=utf32 bomb\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20(+4 for BOM)\", a)\n\n  set fenc& bomb&\n\n  set ff&\n  bwipe!\nendfunc\n\n\" Test for g8\nfunc Test_normal34_g_cmd3()\n  new\n  let a=execute(':norm! 1G0g8')\n  call assert_equal(\"\\nNUL\", a)\n\n  call setline(1, 'abcdefghijklmnopqrstuvwxyz\u00e4\u00fc\u00f6')\n  let a=execute(':norm! 1G$g8')\n  call assert_equal(\"\\nc3 b6 \", a)\n\n  call setline(1, \"a\\u0302\")\n  let a=execute(':norm! 1G0g8')\n  call assert_equal(\"\\n61 + cc 82 \", a)\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test 8g8 which finds invalid utf8 at or after the cursor.\nfunc Test_normal_8g8()\n  new\n\n  \" With invalid byte.\n  call setline(1, \"___\\xff___\")\n  norm! 1G08g8g\n  call assert_equal([0, 1, 4, 0, 1], getcurpos())\n\n  \" With invalid byte before the cursor.\n  call setline(1, \"___\\xff___\")\n  norm! 1G$h8g8g\n  call assert_equal([0, 1, 6, 0, 9], getcurpos())\n\n  \" With truncated sequence.\n  call setline(1, \"___\\xE2\\x82___\")\n  norm! 1G08g8g\n  call assert_equal([0, 1, 4, 0, 1], getcurpos())\n\n  \" With overlong sequence.\n  call setline(1, \"___\\xF0\\x82\\x82\\xAC___\")\n  norm! 1G08g8g\n  call assert_equal([0, 1, 4, 0, 1], getcurpos())\n\n  \" With valid utf8.\n  call setline(1, \"caf\u00e9\")\n  norm! 1G08g8\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n\n  bw!\nendfunc\n\n\" Test for g<\nfunc Test_normal35_g_cmd4()\n  \" Cannot capture its output,\n  \" probably a bug, therefore, test disabled:\n  throw \"Skipped: output of g< can't be tested currently\"\n  echo \"a\\nb\\nc\\nd\"\n  let b=execute(':norm! g<')\n  call assert_true(!empty(b), 'failed `execute(g<)`')\nendfunc\n\n\" Test for gp gP go\nfunc Test_normal36_g_cmd5()\n  new\n  call append(0, 'abcdefghijklmnopqrstuvwxyz')\n  set ff=unix\n  \" Test for gp gP\n  call append(1, range(1,10))\n  1\n  norm! 1yy\n  3\n  norm! gp\n  call assert_equal([0, 5, 1, 0, 1], getcurpos())\n  $\n  norm! gP\n  call assert_equal([0, 14, 1, 0, 1], getcurpos())\n\n  \" Test for go\n  norm! 26go\n  call assert_equal([0, 1, 26, 0, 26], getcurpos())\n  norm! 27go\n  call assert_equal([0, 1, 26, 0, 26], getcurpos())\n  norm! 28go\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n  set ff=dos\n  norm! 29go\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n  set ff=unix\n  norm! gg0\n  norm! 101go\n  call assert_equal([0, 13, 26, 0, 26], getcurpos())\n  norm! 103go\n  call assert_equal([0, 14, 1, 0, 1], getcurpos())\n  \" count > buffer content\n  norm! 120go\n  call assert_equal([0, 14, 1, 0, 2147483647], getcurpos())\n  \" clean up\n  bw!\nendfunc\n\n\" Test for gt and gT\nfunc Test_normal37_g_cmd6()\n  tabnew 1.txt\n  tabnew 2.txt\n  tabnew 3.txt\n  norm! 1gt\n  call assert_equal(1, tabpagenr())\n  norm! 3gt\n  call assert_equal(3, tabpagenr())\n  norm! 1gT\n  \" count gT goes not to the absolute tabpagenumber\n  \" but, but goes to the count previous tabpagenumber\n  call assert_equal(2, tabpagenr())\n  \" wrap around\n  norm! 3gT\n  call assert_equal(3, tabpagenr())\n  \" gt does not wrap around\n  norm! 5gt\n  call assert_equal(3, tabpagenr())\n\n  for i in range(3)\n    tabclose\n  endfor\n  \" clean up\n  call assert_fails(':tabclose', 'E784:')\nendfunc\n\n\" Test for <Home> and <C-Home> key\nfunc Test_normal38_nvhome()\n  new\n  call setline(1, range(10))\n  $\n  setl et sw=2\n  norm! V10>$\n  \" count is ignored\n  exe \"norm! 10\\<home>\"\n  call assert_equal(1, col('.'))\n  exe \"norm! \\<home>\"\n  call assert_equal([0, 10, 1, 0, 1], getcurpos())\n  exe \"norm! 5\\<c-home>\"\n  call assert_equal([0, 5, 1, 0, 1], getcurpos())\n  exe \"norm! \\<c-home>\"\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  exe \"norm! G\\<c-kHome>\"\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for <End> and <C-End> keys\nfunc Test_normal_nvend()\n  new\n  call setline(1, map(range(1, 10), '\"line\" .. v:val'))\n  exe \"normal! \\<End>\"\n  call assert_equal(5, col('.'))\n  exe \"normal! 4\\<End>\"\n  call assert_equal([4, 5], [line('.'), col('.')])\n  exe \"normal! \\<C-End>\"\n  call assert_equal([10, 6], [line('.'), col('.')])\n  close!\nendfunc\n\n\" Test for cw cW ce\nfunc Test_normal39_cw()\n  \" Test for cw and cW on whitespace\n  new\n  set tw=0\n  call append(0, 'here      are   some words')\n  norm! 1gg0elcwZZZ\n  call assert_equal('hereZZZare   some words', getline('.'))\n  norm! 1gg0elcWYYY\n  call assert_equal('hereZZZareYYYsome words', getline('.'))\n  norm! 2gg0cwfoo\n  call assert_equal('foo', getline('.'))\n\n  call setline(1, 'one; two')\n  call cursor(1, 1)\n  call feedkeys('cwvim', 'xt')\n  call assert_equal('vim; two', getline(1))\n  call feedkeys('0cWone', 'xt')\n  call assert_equal('one two', getline(1))\n  \"When cursor is at the end of a word 'ce' will change until the end of the\n  \"next word, but 'cw' will change only one character\n  call setline(1, 'one two')\n  call feedkeys('0ecwce', 'xt')\n  call assert_equal('once two', getline(1))\n  call setline(1, 'one two')\n  call feedkeys('0ecely', 'xt')\n  call assert_equal('only', getline(1))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for CTRL-\\ commands\nfunc Test_normal40_ctrl_bsl()\n  new\n  call append(0, 'here      are   some words')\n  exe \"norm! 1gg0a\\<C-\\>\\<C-N>\"\n  call assert_equal('n', mode())\n  call assert_equal(1, col('.'))\n  call assert_equal('', visualmode())\n  exe \"norm! 1gg0viw\\<C-\\>\\<C-N>\"\n  call assert_equal('n', mode())\n  call assert_equal(4, col('.'))\n  exe \"norm! 1gg0a\\<C-\\>\\<C-G>\"\n  call assert_equal('n', mode())\n  call assert_equal(1, col('.'))\n  \"imap <buffer> , <c-\\><c-n>\n  set im\n  exe \":norm! \\<c-\\>\\<c-n>dw\"\n  set noim\n  call assert_equal('are   some words', getline(1))\n  call assert_false(&insertmode)\n  call assert_beeps(\"normal! \\<C-\\>\\<C-A>\")\n\n  if has('cmdwin')\n    \" Using CTRL-\\ CTRL-N in cmd window should close the window\n    call feedkeys(\"q:\\<C-\\>\\<C-N>\", 'xt')\n    call assert_equal('', getcmdwintype())\n  endif\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for <c-r>=, <c-r><c-r>= and <c-r><c-o>= in insert mode\nfunc Test_normal41_insert_reg()\n  new\n  set sts=2 sw=2 ts=8 tw=0\n  call append(0, [\"aaa\\tbbb\\tccc\", '', '', ''])\n  let a=getline(1)\n  norm! 2gg0\n  exe \"norm! a\\<c-r>=a\\<cr>\"\n  norm! 3gg0\n  exe \"norm! a\\<c-r>\\<c-r>=a\\<cr>\"\n  norm! 4gg0\n  exe \"norm! a\\<c-r>\\<c-o>=a\\<cr>\"\n  call assert_equal(['aaa\tbbb\tccc', 'aaa bbb\tccc', 'aaa bbb\tccc', 'aaa\tbbb\tccc', ''], getline(1, '$'))\n\n  \" clean up\n  set sts=0 sw=8 ts=8\n  bw!\nendfunc\n\n\" Test for Ctrl-D and Ctrl-U\nfunc Test_normal42_halfpage()\n  call Setup_NewWindow()\n  call assert_equal(5, &scroll)\n  exe \"norm! \\<c-d>\"\n  call assert_equal('6', getline('.'))\n  exe \"norm! 2\\<c-d>\"\n  call assert_equal('8', getline('.'))\n  call assert_equal(2, &scroll)\n  set scroll=5\n  exe \"norm! \\<c-u>\"\n  call assert_equal('3', getline('.'))\n  1\n  set scrolloff=5\n  exe \"norm! \\<c-d>\"\n  call assert_equal('10', getline('.'))\n  exe \"norm! \\<c-u>\"\n  call assert_equal('5', getline('.'))\n  1\n  set scrolloff=99\n  exe \"norm! \\<c-d>\"\n  call assert_equal('10', getline('.'))\n  set scrolloff=0\n  100\n  exe \"norm! $\\<c-u>\"\n  call assert_equal('95', getline('.'))\n  call assert_equal([0, 95, 1, 0, 1], getcurpos())\n  100\n  set nostartofline\n  exe \"norm! $\\<c-u>\"\n  call assert_equal('95', getline('.'))\n  call assert_equal([0, 95, 2, 0, 2147483647], getcurpos())\n  \" cleanup\n  set startofline\n  bw!\nendfunc\n\nfunc Test_normal45_drop()\n  if !has('dnd')\n    \" The ~ register does not exist\n    call assert_beeps('norm! \"~')\n    return\n  endif\n\n  \" basic test for drag-n-drop\n  \" unfortunately, without a gui, we can't really test much here,\n  \" so simply test that ~p fails (which uses the drop register)\n  new\n  call assert_fails(':norm! \"~p', 'E353:')\n  call assert_equal([],  getreg('~', 1, 1))\n  \" the ~ register is read only\n  call assert_fails(':let @~=\"1\"', 'E354:')\n  bw!\nendfunc\n\nfunc Test_normal46_ignore()\n  new\n  \" How to test this?\n  \" let's just for now test, that the buffer\n  \" does not change\n  call feedkeys(\"\\<c-s>\", 't')\n  call assert_equal([''], getline(1,'$'))\n\n  \" no valid commands\n  exe \"norm! \\<char-0x100>\"\n  call assert_equal([''], getline(1,'$'))\n\n  exe \"norm! \u00e4\"\n  call assert_equal([''], getline(1,'$'))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal47_visual_buf_wipe()\n  \" This was causing a crash or ml_get error.\n  enew!\n  call setline(1,'xxx')\n  normal $\n  new\n  call setline(1, range(1,2))\n  2\n  exe \"norm \\<C-V>$\"\n  bw!\n  norm yp\n  set nomodified\nendfunc\n\nfunc Test_normal48_wincmd()\n  new\n  exe \"norm! \\<c-w>c\"\n  call assert_equal(1, winnr('$'))\n  call assert_fails(\":norm! \\<c-w>c\", 'E444:')\nendfunc\n\nfunc Test_normal49_counts()\n  new\n  call setline(1, 'one two three four five six seven eight nine ten')\n  1\n  norm! 3d2w\n  call assert_equal('seven eight nine ten', getline(1))\n  bw!\nendfunc\n\nfunc Test_normal50_commandline()\n  CheckFeature timers\n  CheckFeature cmdline_hist\n  func! DoTimerWork(id)\n    call assert_equal('[Command Line]', bufname(''))\n    \" should fail, with E11, but does fail with E23?\n    \"call feedkeys(\"\\<c-^>\", 'tm')\n\n    \" should also fail with E11\n    call assert_fails(\":wincmd p\", 'E11:')\n    \" return from commandline window\n    call feedkeys(\"\\<cr>\")\n  endfunc\n\n  let oldlang=v:lang\n  lang C\n  set updatetime=20\n  call timer_start(100, 'DoTimerWork')\n  try\n    \" throws E23, for whatever reason...\n    call feedkeys('q:', 'x!')\n  catch /E23/\n    \" no-op\n  endtry\n  \" clean up\n  set updatetime=4000\n  exe \"lang\" oldlang\n  bw!\nendfunc\n\nfunc Test_normal51_FileChangedRO()\n  CheckFeature autocmd\n  \" Don't sleep after the warning message.\n  call test_settime(1)\n  call writefile(['foo'], 'Xreadonly.log')\n  new Xreadonly.log\n  setl ro\n  au FileChangedRO <buffer> :call feedkeys(\"\\<c-^>\", 'tix')\n  call assert_fails(\":norm! Af\", 'E788:')\n  call assert_equal(['foo'], getline(1,'$'))\n  call assert_equal('Xreadonly.log', bufname(''))\n\n  \" cleanup\n  call test_settime(0)\n  bw!\n  call delete(\"Xreadonly.log\")\nendfunc\n\nfunc Test_normal52_rl()\n  CheckFeature rightleft\n  new\n  call setline(1, 'abcde fghij klmnopq')\n  norm! 1gg$\n  set rl\n  call assert_equal(19, col('.'))\n  call feedkeys('l', 'tx')\n  call assert_equal(18, col('.'))\n  call feedkeys('h', 'tx')\n  call assert_equal(19, col('.'))\n  call feedkeys(\"\\<right>\", 'tx')\n  call assert_equal(18, col('.'))\n  call feedkeys(\"\\<left>\", 'tx')\n  call assert_equal(19, col('.'))\n  call feedkeys(\"\\<s-right>\", 'tx')\n  call assert_equal(13, col('.'))\n  call feedkeys(\"\\<c-right>\", 'tx')\n  call assert_equal(7, col('.'))\n  call feedkeys(\"\\<c-left>\", 'tx')\n  call assert_equal(13, col('.'))\n  call feedkeys(\"\\<s-left>\", 'tx')\n  call assert_equal(19, col('.'))\n  call feedkeys(\"<<\", 'tx')\n  call assert_equal('\tabcde fghij klmnopq',getline(1))\n  call feedkeys(\">>\", 'tx')\n  call assert_equal('abcde fghij klmnopq',getline(1))\n\n  \" cleanup\n  set norl\n  bw!\nendfunc\n\nfunc Test_normal54_Ctrl_bsl()\n  new\n  call setline(1, 'abcdefghijklmn')\n  exe \"norm! df\\<c-\\>\\<c-n>\"\n  call assert_equal(['abcdefghijklmn'], getline(1,'$'))\n  exe \"norm! df\\<c-\\>\\<c-g>\"\n  call assert_equal(['abcdefghijklmn'], getline(1,'$'))\n  exe \"norm! df\\<c-\\>m\"\n  call assert_equal(['abcdefghijklmn'], getline(1,'$'))\n\n  call setline(2, 'abcdefghijklmn\u0101f')\n  norm! 2gg0\n  exe \"norm! df\\<Char-0x101>\"\n  call assert_equal(['abcdefghijklmn', 'f'], getline(1,'$'))\n  norm! 1gg0\n  exe \"norm! df\\<esc>\"\n  call assert_equal(['abcdefghijklmn', 'f'], getline(1,'$'))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal_large_count()\n  \" This may fail with 32bit long, how do we detect that?\n  new\n  normal o\n  normal 6666666666dL\n  bwipe!\nendfunc\n\nfunc Test_delete_until_paragraph()\n  new\n  normal gr\u00e1dv}\n  call assert_equal('\u00e1', getline(1))\n  normal gr\u00e1d}\n  call assert_equal('', getline(1))\n  bwipe!\nendfunc\n\n\" Test for the gr (virtual replace) command\n\" Test for the bug fixed by 7.4.387\nfunc Test_gr_command()\n  enew!\n  let save_cpo = &cpo\n  call append(0, ['First line', 'Second line', 'Third line'])\n  exe \"normal i\\<C-G>u\"\n  call cursor(2, 1)\n  set cpo-=X\n  normal 4gro\n  call assert_equal('oooond line', getline(2))\n  undo\n  set cpo+=X\n  normal 4gro\n  call assert_equal('ooooecond line', getline(2))\n  let &cpo = save_cpo\n  normal! ggvegrx\n  call assert_equal('xxxxx line', getline(1))\n  exe \"normal! gggr\\<C-V>122\"\n  call assert_equal('zxxxx line', getline(1))\n  set virtualedit=all\n  normal! 15|grl\n  call assert_equal('zxxxx line    l', getline(1))\n  set virtualedit&\n  set nomodifiable\n  call assert_fails('normal! grx', 'E21:')\n  call assert_fails('normal! gRx', 'E21:')\n  set modifiable&\n  enew!\nendfunc\n\n\" When splitting a window the changelist position is wrong.\n\" Test the changelist position after splitting a window.\n\" Test for the bug fixed by 7.4.386\nfunc Test_changelist()\n  let save_ul = &ul\n  enew!\n  call append('$', ['1', '2'])\n  exe \"normal i\\<C-G>u\"\n  exe \"normal Gkylpa\\<C-G>u\"\n  set ul=100\n  exe \"normal Gylpa\\<C-G>u\"\n  set ul=100\n  normal gg\n  vsplit\n  normal g;\n  call assert_equal([3, 2], [line('.'), col('.')])\n  normal g;\n  call assert_equal([2, 2], [line('.'), col('.')])\n  call assert_fails('normal g;', 'E662:')\n  new\n  call assert_fails('normal g;', 'E664:')\n  %bwipe!\n  let &ul = save_ul\nendfunc\n\nfunc Test_nv_hat_count()\n  %bwipeout!\n  let l:nr = bufnr('%') + 1\n  call assert_fails(':execute \"normal! ' . l:nr . '\\<C-^>\"', 'E92:')\n\n  edit Xfoo\n  let l:foo_nr = bufnr('Xfoo')\n\n  edit Xbar\n  let l:bar_nr = bufnr('Xbar')\n\n  \" Make sure we are not just using the alternate file.\n  edit Xbaz\n\n  call feedkeys(l:foo_nr . \"\\<C-^>\", 'tx')\n  call assert_equal('Xfoo', fnamemodify(bufname('%'), ':t'))\n\n  call feedkeys(l:bar_nr . \"\\<C-^>\", 'tx')\n  call assert_equal('Xbar', fnamemodify(bufname('%'), ':t'))\n\n  %bwipeout!\nendfunc\n\nfunc Test_message_when_using_ctrl_c()\n  \" Make sure no buffers are changed.\n  %bwipe!\n\n  exe \"normal \\<C-C>\"\n  call assert_match(\"Type  :qa  and press <Enter> to exit Vim\", Screenline(&lines))\n\n  new\n  cal setline(1, 'hi!')\n  exe \"normal \\<C-C>\"\n  call assert_match(\"Type  :qa!  and press <Enter> to abandon all changes and exit Vim\", Screenline(&lines))\n\n  bwipe!\nendfunc\n\n\" Test for '[m', ']m', '[M' and ']M'\n\" Jumping to beginning and end of methods in Java-like languages\nfunc Test_java_motion()\n  new\n  call assert_beeps('normal! [m')\n  call assert_beeps('normal! ]m')\n  call assert_beeps('normal! [M')\n  call assert_beeps('normal! ]M')\n  let lines =<< trim [CODE]\n\tPiece of Java\n\t{\n\t\ttt m1 {\n\t\t\tt1;\n\t\t} e1\n\n\t\ttt m2 {\n\t\t\tt2;\n\t\t} e2\n\n\t\ttt m3 {\n\t\t\tif (x)\n\t\t\t{\n\t\t\t\tt3;\n\t\t\t}\n\t\t} e3\n\t}\n  [CODE]\n  call setline(1, lines)\n\n  normal gg\n\n  normal 2]maA\n  call assert_equal(\"\\ttt m1 {A\", getline('.'))\n  call assert_equal([3, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal j]maB\n  call assert_equal(\"\\ttt m2 {B\", getline('.'))\n  call assert_equal([7, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal ]maC\n  call assert_equal(\"\\ttt m3 {C\", getline('.'))\n  call assert_equal([11, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal [maD\n  call assert_equal(\"\\ttt m3 {DC\", getline('.'))\n  call assert_equal([11, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal k2[maE\n  call assert_equal(\"\\ttt m1 {EA\", getline('.'))\n  call assert_equal([3, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal 3[maF\n  call assert_equal(\"{F\", getline('.'))\n  call assert_equal([2, 2, 2], [line('.'), col('.'), virtcol('.')])\n\n  normal ]MaG\n  call assert_equal(\"\\t}G e1\", getline('.'))\n  call assert_equal([5, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal j2]MaH\n  call assert_equal(\"\\t}H e3\", getline('.'))\n  call assert_equal([16, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal ]M]M\n  normal aI\n  call assert_equal(\"}I\", getline('.'))\n  call assert_equal([17, 2, 2], [line('.'), col('.'), virtcol('.')])\n\n  normal 2[MaJ\n  call assert_equal(\"\\t}JH e3\", getline('.'))\n  call assert_equal([16, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal k[MaK\n  call assert_equal(\"\\t}K e2\", getline('.'))\n  call assert_equal([9, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal 3[MaL\n  call assert_equal(\"{LF\", getline('.'))\n  call assert_equal([2, 2, 2], [line('.'), col('.'), virtcol('.')])\n\n  call cursor(2, 1)\n  call assert_beeps('norm! 5]m')\n\n  \" jumping to a method in a fold should open the fold\n  6,10fold\n  call feedkeys(\"gg3]m\", 'xt')\n  call assert_equal([7, 8, 15], [line('.'), col('.'), virtcol('.')])\n  call assert_equal(-1, foldclosedend(7))\n\n  close!\nendfunc\n\n\" Tests for g cmds\nfunc Test_normal_gdollar_cmd()\n  CheckFeature jumplist\n  call Setup_NewWindow()\n  \" Make long lines that will wrap\n  %s/$/\\=repeat(' foobar', 10)/\n  20vsp\n  set wrap\n  \" Test for g$ with count\n  norm! gg\n  norm! 0vg$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foob', getreg(0))\n  norm! gg\n  norm! 0v4g$y\n  call assert_equal(72, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'..\"\\n\", getreg(0))\n  norm! gg\n  norm! 0v6g$y\n  call assert_equal(40, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n\t\t  \\ '2 foobar foobar foobar foobar foobar foo', getreg(0))\n  set nowrap\n  \" clean up\n  norm! gg\n  norm! 0vg$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foob', getreg(0))\n  norm! gg\n  norm! 0v4g$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '2 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '3 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '4 foobar foobar foob', getreg(0))\n  norm! gg\n  norm! 0v6g$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '2 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '3 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '4 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '5 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '6 foobar foobar foob', getreg(0))\n  \" Move to last line, also down movement is not possible, should still move\n  \" the cursor to the last visible char\n  norm! G\n  norm! 0v6g$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('100 foobar foobar fo', getreg(0))\n  bw!\nendfunc\n\nfunc Test_normal_gk_gj()\n  \" needs 80 column new window\n  new\n  vert 80new\n  call assert_beeps('normal gk')\n  put =[repeat('x',90)..' {{{1', 'x {{{1']\n  norm! gk\n  \" In a 80 column wide terminal the window will be only 78 char\n  \" (because Vim will leave space for the other window),\n  \" but if the terminal is larger, it will be 80 chars, so verify the\n  \" cursor column correctly.\n  call assert_equal(winwidth(0)+1, col('.'))\n  call assert_equal(winwidth(0)+1, virtcol('.'))\n  norm! j\n  call assert_equal(6, col('.'))\n  call assert_equal(6, virtcol('.'))\n  norm! gk\n  call assert_equal(95, col('.'))\n  call assert_equal(95, virtcol('.'))\n  %bw!\n\n  \" needs 80 column new window\n  new\n  vert 80new\n  call assert_beeps('normal gj')\n  set number\n  set numberwidth=10\n  set cpoptions+=n\n  put =[repeat('0',90), repeat('1',90)]\n  norm! 075l\n  call assert_equal(76, col('.'))\n  norm! gk\n  call assert_equal(1, col('.'))\n  norm! gk\n  call assert_equal(76, col('.'))\n  norm! gk\n  call assert_equal(1, col('.'))\n  norm! gj\n  call assert_equal(76, col('.'))\n  norm! gj\n  call assert_equal(1, col('.'))\n  norm! gj\n  call assert_equal(76, col('.'))\n  \" When 'nowrap' is set, gk and gj behave like k and j\n  set nowrap\n  normal! gk\n  call assert_equal([2, 76], [line('.'), col('.')])\n  normal! gj\n  call assert_equal([3, 76], [line('.'), col('.')])\n  %bw!\n  set cpoptions& number& numberwidth& wrap&\nendfunc\n\n\" Test for using : to run a multi-line Ex command in operator pending mode\nfunc Test_normal_yank_with_excmd()\n  new\n  call setline(1, ['foo', 'bar', 'baz'])\n  let @a = ''\n  call feedkeys(\"\\\"ay:if v:true\\<CR>normal l\\<CR>endif\\<CR>\", 'xt')\n  call assert_equal('f', @a)\n  close!\nendfunc\n\n\" Test for supplying a count to a normal-mode command across a cursorhold call\nfunc Test_normal_cursorhold_with_count()\n  func s:cHold()\n    let g:cHold_Called += 1\n  endfunc\n  new\n  augroup normalcHoldTest\n    au!\n    au CursorHold <buffer> call s:cHold()\n  augroup END\n  let g:cHold_Called = 0\n  call feedkeys(\"3\\<CursorHold>2ix\", 'xt')\n  call assert_equal(1, g:cHold_Called)\n  call assert_equal(repeat('x', 32), getline(1))\n  augroup normalcHoldTest\n    au!\n  augroup END\n  au! normalcHoldTest\n  close!\n  delfunc s:cHold\nendfunc\n\n\" Test for using a count and a command with CTRL-W\nfunc Test_wincmd_with_count()\n  call feedkeys(\"\\<C-W>12n\", 'xt')\n  call assert_equal(12, winheight(0))\nendfunc\n\n\" Test for 'b', 'B' 'ge' and 'gE' commands\nfunc Test_horiz_motion()\n  new\n  normal! gg\n  call assert_beeps('normal! b')\n  call assert_beeps('normal! B')\n  call assert_beeps('normal! gE')\n  call assert_beeps('normal! ge')\n  \" <S-Backspace> moves one word left and <C-Backspace> moves one WORD left\n  call setline(1, 'one ,two ,three')\n  exe \"normal! $\\<S-BS>\"\n  call assert_equal(11, col('.'))\n  exe \"normal! $\\<C-BS>\"\n  call assert_equal(10, col('.'))\n  close!\nendfunc\n\n\" Test for using a : command in operator pending mode\nfunc Test_normal_colon_op()\n  new\n  call setline(1, ['one', 'two'])\n  call assert_beeps(\"normal! Gc:d\\<CR>\")\n  close!\nendfunc\n\n\" Test for d and D commands\nfunc Test_normal_delete_cmd()\n  new\n  \" D in an empty line\n  call setline(1, '')\n  normal D\n  call assert_equal('', getline(1))\n  \" D in an empty line in virtualedit mode\n  set virtualedit=all\n  normal D\n  call assert_equal('', getline(1))\n  set virtualedit&\n  \" delete to a readonly register\n  call setline(1, ['abcd'])\n  call assert_beeps('normal \":d2l')\n\n  \" D and d with 'nomodifiable'\n  call setline(1, ['abcd'])\n  setlocal nomodifiable\n  call assert_fails('normal D', 'E21:')\n  call assert_fails('normal d$', 'E21:')\n\n  close!\nendfunc\n\n\" Test for deleting or changing characters across lines with 'whichwrap'\n\" containing 's'. Should count <EOL> as one character.\nfunc Test_normal_op_across_lines()\n  new\n  set whichwrap&\n  call setline(1, ['one two', 'three four'])\n  exe \"norm! $3d\\<Space>\"\n  call assert_equal(['one twhree four'], getline(1, '$'))\n\n  call setline(1, ['one two', 'three four'])\n  exe \"norm! $3c\\<Space>x\"\n  call assert_equal(['one twxhree four'], getline(1, '$'))\n\n  set whichwrap+=l\n  call setline(1, ['one two', 'three four'])\n  exe \"norm! $3x\"\n  call assert_equal(['one twhree four'], getline(1, '$'))\n  close!\n  set whichwrap&\nendfunc\n\n\" Test for 'w' and 'b' commands\nfunc Test_normal_word_move()\n  new\n  call setline(1, ['foo bar a', '', 'foo bar b'])\n  \" copy a single character word at the end of a line\n  normal 1G$yw\n  call assert_equal('a', @\")\n  \" copy a single character word at the end of a file\n  normal G$yw\n  call assert_equal('b', @\")\n  \" check for a word movement handling an empty line properly\n  normal 1G$vwy\n  call assert_equal(\"a\\n\\n\", @\")\n\n  \" copy using 'b' command\n  %d\n  \" non-empty blank line at the start of file\n  call setline(1, ['  ', 'foo bar'])\n  normal 2Gyb\n  call assert_equal(\"  \\n\", @\")\n  \" try to copy backwards from the start of the file\n  call setline(1, ['one two', 'foo bar'])\n  call assert_beeps('normal ggyb')\n  \" 'b' command should stop at an empty line\n  call setline(1, ['one two', '', 'foo bar'])\n  normal 3Gyb\n  call assert_equal(\"\\n\", @\")\n  normal 3Gy2b\n  call assert_equal(\"two\\n\", @\")\n  \" 'b' command should not stop at a non-empty blank line\n  call setline(1, ['one two', '  ', 'foo bar'])\n  normal 3Gyb\n  call assert_equal(\"two\\n  \", @\")\n\n  close!\nendfunc\n\n\" Test for 'scrolloff' with a long line that doesn't fit in the screen\nfunc Test_normal_scroloff()\n  10new\n  80vnew\n  call setline(1, repeat('a', 1000))\n  set scrolloff=10\n  normal gg10gj\n  call assert_equal(8, winline())\n  normal 10gj\n  call assert_equal(10, winline())\n  normal 10gk\n  call assert_equal(3, winline())\n  set scrolloff&\n  close!\nendfunc\n\n\" Test for vertical scrolling with CTRL-F and CTRL-B with a long line\nfunc Test_normal_vert_scroll_longline()\n  10new\n  80vnew\n  call setline(1, range(1, 10))\n  call append(5, repeat('a', 1000))\n  exe \"normal gg\\<C-F>\"\n  call assert_equal(6, line('.'))\n  exe \"normal \\<C-F>\\<C-F>\"\n  call assert_equal(11, line('.'))\n  call assert_equal(1, winline())\n  exe \"normal \\<C-B>\"\n  call assert_equal(10, line('.'))\n  call assert_equal(3, winline())\n  exe \"normal \\<C-B>\\<C-B>\"\n  call assert_equal(5, line('.'))\n  call assert_equal(5, winline())\n  close!\nendfunc\n\n\" Test for jumping in a file using %\nfunc Test_normal_percent_jump()\n  new\n  call setline(1, range(1, 100))\n\n  \" jumping to a folded line should open the fold\n  25,75fold\n  call feedkeys('50%', 'xt')\n  call assert_equal(50, line('.'))\n  call assert_equal(-1, foldclosedend(50))\n  close!\nendfunc\n\n\" Test for << and >> commands to shift text by 'shiftwidth'\nfunc Test_normal_shift_rightleft()\n  new\n  call setline(1, ['one', '', \"\\t\", '  two', \"\\tthree\", '      four'])\n  set shiftwidth=2 tabstop=8\n  normal gg6>>\n  call assert_equal(['  one', '', \"\\t  \", '    two', \"\\t  three\", \"\\tfour\"],\n        \\ getline(1, '$'))\n  normal ggVG2>>\n  call assert_equal(['      one', '', \"\\t      \", \"\\ttwo\",\n        \\ \"\\t      three\", \"\\t    four\"], getline(1, '$'))\n  normal gg6<<\n  call assert_equal(['    one', '', \"\\t    \", '      two', \"\\t    three\",\n        \\ \"\\t  four\"], getline(1, '$'))\n  normal ggVG2<<\n  call assert_equal(['one', '', \"\\t\", '  two', \"\\tthree\", '      four'],\n        \\ getline(1, '$'))\n  set shiftwidth& tabstop&\n  bw!\nendfunc\n\n\" Some commands like yy, cc, dd, >>, << and !! accept a count after\n\" typing the first letter of the command.\nfunc Test_normal_count_after_operator()\n  new\n  setlocal shiftwidth=4 tabstop=8 autoindent\n  call setline(1, ['one', 'two', 'three', 'four', 'five'])\n  let @a = ''\n  normal! j\"ay4y\n  call assert_equal(\"two\\nthree\\nfour\\nfive\\n\", @a)\n  normal! 3G>2>\n  call assert_equal(['one', 'two', '    three', '    four', 'five'],\n        \\ getline(1, '$'))\n  exe \"normal! 3G0c2cred\\nblue\"\n  call assert_equal(['one', 'two', '    red', '    blue', 'five'],\n        \\ getline(1, '$'))\n  exe \"normal! gg<8<\"\n  call assert_equal(['one', 'two', 'red', 'blue', 'five'],\n        \\ getline(1, '$'))\n  exe \"normal! ggd3d\"\n  call assert_equal(['blue', 'five'], getline(1, '$'))\n  call setline(1, range(1, 4))\n  call feedkeys(\"gg!3!\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\".,.+2!', @:)\n  call feedkeys(\"gg!1!\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\".!', @:)\n  call feedkeys(\"gg!9!\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\".,$!', @:)\n  bw!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/move.c", "src/testdir/test_normal.vim", "src/version.c"], "buggy_code_start_loc": [202, 37, 759], "buggy_code_end_loc": [203, 987, 759], "fixing_code_start_loc": [201, 37, 760], "fixing_code_end_loc": [201, 1004, 762], "type": "CWE-122", "message": "vim is vulnerable to Heap-based Buffer Overflow", "other": {"cve": {"id": "CVE-2021-3903", "sourceIdentifier": "security@huntr.dev", "published": "2021-10-27T21:15:08.047", "lastModified": "2023-01-20T02:03:24.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vim is vulnerable to Heap-based Buffer Overflow"}, {"lang": "es", "value": "vim es vulnerable al desbordamiento del b\u00fafer en la regi\u00f3n Heap de la memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.3564", "matchCriteriaId": "1AD14F48-9F63-49C3-AB4E-B3AC1B136F50"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/01/15/1", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/777e7c21b7627be80961848ac560cb0a9978ff43", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/35738a4f-55ce-446c-b836-2fb0b39625f8", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/06/msg00014.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BN4EX7BPQU7RP6PXCNCSDORUZBXQ4JUH/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DU26T75PYA3OF7XJGNKMT2ZCQEU4UKP5/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FNXY7T5OORA7UJIMGSJBGHFMU6UZWS6P/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/777e7c21b7627be80961848ac560cb0a9978ff43"}}