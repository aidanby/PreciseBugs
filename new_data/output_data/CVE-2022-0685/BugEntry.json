{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n#if defined(HAVE_WCHAR_H)\n# include <wchar.h>\t    // for towupper() and towlower()\n#endif\nstatic int win_nolbr_chartabsize(win_T *wp, char_u *s, colnr_T col, int *headp);\n\nstatic unsigned nr2hex(unsigned c);\n\nstatic int    chartab_initialized = FALSE;\n\n// b_chartab[] is an array of 32 bytes, each bit representing one of the\n// characters 0-255.\n#define SET_CHARTAB(buf, c) (buf)->b_chartab[(unsigned)(c) >> 3] |= (1 << ((c) & 0x7))\n#define RESET_CHARTAB(buf, c) (buf)->b_chartab[(unsigned)(c) >> 3] &= ~(1 << ((c) & 0x7))\n#define GET_CHARTAB(buf, c) ((buf)->b_chartab[(unsigned)(c) >> 3] & (1 << ((c) & 0x7)))\n\n// table used below, see init_chartab() for an explanation\nstatic char_u\tg_chartab[256];\n\n/*\n * Flags for g_chartab[].\n */\n#define CT_CELL_MASK\t0x07\t// mask: nr of display cells (1, 2 or 4)\n#define CT_PRINT_CHAR\t0x10\t// flag: set for printable chars\n#define CT_ID_CHAR\t0x20\t// flag: set for ID chars\n#define CT_FNAME_CHAR\t0x40\t// flag: set for file name chars\n\nstatic int in_win_border(win_T *wp, colnr_T vcol);\n\n/*\n * Fill g_chartab[].  Also fills curbuf->b_chartab[] with flags for keyword\n * characters for current buffer.\n *\n * Depends on the option settings 'iskeyword', 'isident', 'isfname',\n * 'isprint' and 'encoding'.\n *\n * The index in g_chartab[] depends on 'encoding':\n * - For non-multi-byte index with the byte (same as the character).\n * - For DBCS index with the first byte.\n * - For UTF-8 index with the character (when first byte is up to 0x80 it is\n *   the same as the character, if the first byte is 0x80 and above it depends\n *   on further bytes).\n *\n * The contents of g_chartab[]:\n * - The lower two bits, masked by CT_CELL_MASK, give the number of display\n *   cells the character occupies (1 or 2).  Not valid for UTF-8 above 0x80.\n * - CT_PRINT_CHAR bit is set when the character is printable (no need to\n *   translate the character before displaying it).  Note that only DBCS\n *   characters can have 2 display cells and still be printable.\n * - CT_FNAME_CHAR bit is set when the character can be in a file name.\n * - CT_ID_CHAR bit is set when the character can be in an identifier.\n *\n * Return FAIL if 'iskeyword', 'isident', 'isfname' or 'isprint' option has an\n * error, OK otherwise.\n */\n    int\ninit_chartab(void)\n{\n    return buf_init_chartab(curbuf, TRUE);\n}\n\n    int\nbuf_init_chartab(\n    buf_T\t*buf,\n    int\t\tglobal)\t\t// FALSE: only set buf->b_chartab[]\n{\n    int\t\tc;\n    int\t\tc2;\n    char_u\t*p;\n    int\t\ti;\n    int\t\ttilde;\n    int\t\tdo_isalpha;\n\n    if (global)\n    {\n\t/*\n\t * Set the default size for printable characters:\n\t * From <Space> to '~' is 1 (printable), others are 2 (not printable).\n\t * This also inits all 'isident' and 'isfname' flags to FALSE.\n\t */\n\tc = 0;\n\twhile (c < ' ')\n\t    g_chartab[c++] = (dy_flags & DY_UHEX) ? 4 : 2;\n\twhile (c <= '~')\n\t    g_chartab[c++] = 1 + CT_PRINT_CHAR;\n\twhile (c < 256)\n\t{\n\t    // UTF-8: bytes 0xa0 - 0xff are printable (latin1)\n\t    if (enc_utf8 && c >= 0xa0)\n\t\tg_chartab[c++] = CT_PRINT_CHAR + 1;\n\t    // euc-jp characters starting with 0x8e are single width\n\t    else if (enc_dbcs == DBCS_JPNU && c == 0x8e)\n\t\tg_chartab[c++] = CT_PRINT_CHAR + 1;\n\t    // other double-byte chars can be printable AND double-width\n\t    else if (enc_dbcs != 0 && MB_BYTE2LEN(c) == 2)\n\t\tg_chartab[c++] = CT_PRINT_CHAR + 2;\n\t    else\n\t\t// the rest is unprintable by default\n\t\tg_chartab[c++] = (dy_flags & DY_UHEX) ? 4 : 2;\n\t}\n\n\t// Assume that every multi-byte char is a filename character.\n\tfor (c = 1; c < 256; ++c)\n\t    if ((enc_dbcs != 0 && MB_BYTE2LEN(c) > 1)\n\t\t    || (enc_dbcs == DBCS_JPNU && c == 0x8e)\n\t\t    || (enc_utf8 && c >= 0xa0))\n\t\tg_chartab[c] |= CT_FNAME_CHAR;\n    }\n\n    /*\n     * Init word char flags all to FALSE\n     */\n    CLEAR_FIELD(buf->b_chartab);\n    if (enc_dbcs != 0)\n\tfor (c = 0; c < 256; ++c)\n\t{\n\t    // double-byte characters are probably word characters\n\t    if (MB_BYTE2LEN(c) == 2)\n\t\tSET_CHARTAB(buf, c);\n\t}\n\n#ifdef FEAT_LISP\n    /*\n     * In lisp mode the '-' character is included in keywords.\n     */\n    if (buf->b_p_lisp)\n\tSET_CHARTAB(buf, '-');\n#endif\n\n    // Walk through the 'isident', 'iskeyword', 'isfname' and 'isprint'\n    // options Each option is a list of characters, character numbers or\n    // ranges, separated by commas, e.g.: \"200-210,x,#-178,-\"\n    for (i = global ? 0 : 3; i <= 3; ++i)\n    {\n\tif (i == 0)\n\t    p = p_isi;\t\t// first round: 'isident'\n\telse if (i == 1)\n\t    p = p_isp;\t\t// second round: 'isprint'\n\telse if (i == 2)\n\t    p = p_isf;\t\t// third round: 'isfname'\n\telse\t// i == 3\n\t    p = buf->b_p_isk;\t// fourth round: 'iskeyword'\n\n\twhile (*p)\n\t{\n\t    tilde = FALSE;\n\t    do_isalpha = FALSE;\n\t    if (*p == '^' && p[1] != NUL)\n\t    {\n\t\ttilde = TRUE;\n\t\t++p;\n\t    }\n\t    if (VIM_ISDIGIT(*p))\n\t\tc = getdigits(&p);\n\t    else if (has_mbyte)\n\t\tc = mb_ptr2char_adv(&p);\n\t    else\n\t\tc = *p++;\n\t    c2 = -1;\n\t    if (*p == '-' && p[1] != NUL)\n\t    {\n\t\t++p;\n\t\tif (VIM_ISDIGIT(*p))\n\t\t    c2 = getdigits(&p);\n\t\telse if (has_mbyte)\n\t\t    c2 = mb_ptr2char_adv(&p);\n\t\telse\n\t\t    c2 = *p++;\n\t    }\n\t    if (c <= 0 || c >= 256 || (c2 < c && c2 != -1) || c2 >= 256\n\t\t\t\t\t\t || !(*p == NUL || *p == ','))\n\t\treturn FAIL;\n\n\t    if (c2 == -1)\t// not a range\n\t    {\n\t\t/*\n\t\t * A single '@' (not \"@-@\"):\n\t\t * Decide on letters being ID/printable/keyword chars with\n\t\t * standard function isalpha(). This takes care of locale for\n\t\t * single-byte characters).\n\t\t */\n\t\tif (c == '@')\n\t\t{\n\t\t    do_isalpha = TRUE;\n\t\t    c = 1;\n\t\t    c2 = 255;\n\t\t}\n\t\telse\n\t\t    c2 = c;\n\t    }\n\t    while (c <= c2)\n\t    {\n\t\t// Use the MB_ functions here, because isalpha() doesn't\n\t\t// work properly when 'encoding' is \"latin1\" and the locale is\n\t\t// \"C\".\n\t\tif (!do_isalpha || MB_ISLOWER(c) || MB_ISUPPER(c))\n\t\t{\n\t\t    if (i == 0)\t\t\t// (re)set ID flag\n\t\t    {\n\t\t\tif (tilde)\n\t\t\t    g_chartab[c] &= ~CT_ID_CHAR;\n\t\t\telse\n\t\t\t    g_chartab[c] |= CT_ID_CHAR;\n\t\t    }\n\t\t    else if (i == 1)\t\t// (re)set printable\n\t\t    {\n\t\t\tif ((c < ' ' || c > '~'\n\t\t\t\t// For double-byte we keep the cell width, so\n\t\t\t\t// that we can detect it from the first byte.\n\t\t\t    ) && !(enc_dbcs && MB_BYTE2LEN(c) == 2))\n\t\t\t{\n\t\t\t    if (tilde)\n\t\t\t    {\n\t\t\t\tg_chartab[c] = (g_chartab[c] & ~CT_CELL_MASK)\n\t\t\t\t\t     + ((dy_flags & DY_UHEX) ? 4 : 2);\n\t\t\t\tg_chartab[c] &= ~CT_PRINT_CHAR;\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tg_chartab[c] = (g_chartab[c] & ~CT_CELL_MASK) + 1;\n\t\t\t\tg_chartab[c] |= CT_PRINT_CHAR;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (i == 2)\t\t// (re)set fname flag\n\t\t    {\n\t\t\tif (tilde)\n\t\t\t    g_chartab[c] &= ~CT_FNAME_CHAR;\n\t\t\telse\n\t\t\t    g_chartab[c] |= CT_FNAME_CHAR;\n\t\t    }\n\t\t    else // i == 3\t\t (re)set keyword flag\n\t\t    {\n\t\t\tif (tilde)\n\t\t\t    RESET_CHARTAB(buf, c);\n\t\t\telse\n\t\t\t    SET_CHARTAB(buf, c);\n\t\t    }\n\t\t}\n\t\t++c;\n\t    }\n\n\t    c = *p;\n\t    p = skip_to_option_part(p);\n\t    if (c == ',' && *p == NUL)\n\t\t// Trailing comma is not allowed.\n\t\treturn FAIL;\n\t}\n    }\n    chartab_initialized = TRUE;\n    return OK;\n}\n\n/*\n * Translate any special characters in buf[bufsize] in-place.\n * The result is a string with only printable characters, but if there is not\n * enough room, not all characters will be translated.\n */\n    void\ntrans_characters(\n    char_u\t*buf,\n    int\t\tbufsize)\n{\n    int\t\tlen;\t\t// length of string needing translation\n    int\t\troom;\t\t// room in buffer after string\n    char_u\t*trs;\t\t// translated character\n    int\t\ttrs_len;\t// length of trs[]\n\n    len = (int)STRLEN(buf);\n    room = bufsize - len;\n    while (*buf != 0)\n    {\n\t// Assume a multi-byte character doesn't need translation.\n\tif (has_mbyte && (trs_len = (*mb_ptr2len)(buf)) > 1)\n\t    len -= trs_len;\n\telse\n\t{\n\t    trs = transchar_byte(*buf);\n\t    trs_len = (int)STRLEN(trs);\n\t    if (trs_len > 1)\n\t    {\n\t\troom -= trs_len - 1;\n\t\tif (room <= 0)\n\t\t    return;\n\t\tmch_memmove(buf + trs_len, buf + 1, (size_t)len);\n\t    }\n\t    mch_memmove(buf, trs, (size_t)trs_len);\n\t    --len;\n\t}\n\tbuf += trs_len;\n    }\n}\n\n/*\n * Translate a string into allocated memory, replacing special chars with\n * printable chars.  Returns NULL when out of memory.\n */\n    char_u *\ntransstr(char_u *s)\n{\n    char_u\t*res;\n    char_u\t*p;\n    int\t\tl, len, c;\n    char_u\thexbuf[11];\n\n    if (has_mbyte)\n    {\n\t// Compute the length of the result, taking account of unprintable\n\t// multi-byte characters.\n\tlen = 0;\n\tp = s;\n\twhile (*p != NUL)\n\t{\n\t    if ((l = (*mb_ptr2len)(p)) > 1)\n\t    {\n\t\tc = (*mb_ptr2char)(p);\n\t\tp += l;\n\t\tif (vim_isprintc(c))\n\t\t    len += l;\n\t\telse\n\t\t{\n\t\t    transchar_hex(hexbuf, c);\n\t\t    len += (int)STRLEN(hexbuf);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tl = byte2cells(*p++);\n\t\tif (l > 0)\n\t\t    len += l;\n\t\telse\n\t\t    len += 4;\t// illegal byte sequence\n\t    }\n\t}\n\tres = alloc(len + 1);\n    }\n    else\n\tres = alloc(vim_strsize(s) + 1);\n    if (res != NULL)\n    {\n\t*res = NUL;\n\tp = s;\n\twhile (*p != NUL)\n\t{\n\t    if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t    {\n\t\tc = (*mb_ptr2char)(p);\n\t\tif (vim_isprintc(c))\n\t\t    STRNCAT(res, p, l);\t// append printable multi-byte char\n\t\telse\n\t\t    transchar_hex(res + STRLEN(res), c);\n\t\tp += l;\n\t    }\n\t    else\n\t\tSTRCAT(res, transchar_byte(*p++));\n\t}\n    }\n    return res;\n}\n\n/*\n * Convert the string \"str[orglen]\" to do ignore-case comparing.  Uses the\n * current locale.\n * When \"buf\" is NULL returns an allocated string (NULL for out-of-memory).\n * Otherwise puts the result in \"buf[buflen]\".\n */\n    char_u *\nstr_foldcase(\n    char_u\t*str,\n    int\t\torglen,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    garray_T\tga;\n    int\t\ti;\n    int\t\tlen = orglen;\n\n#define GA_CHAR(i)  ((char_u *)ga.ga_data)[i]\n#define GA_PTR(i)   ((char_u *)ga.ga_data + (i))\n#define STR_CHAR(i)  (buf == NULL ? GA_CHAR(i) : buf[i])\n#define STR_PTR(i)   (buf == NULL ? GA_PTR(i) : buf + (i))\n\n    // Copy \"str\" into \"buf\" or allocated memory, unmodified.\n    if (buf == NULL)\n    {\n\tga_init2(&ga, 1, 10);\n\tif (ga_grow(&ga, len + 1) == FAIL)\n\t    return NULL;\n\tmch_memmove(ga.ga_data, str, (size_t)len);\n\tga.ga_len = len;\n    }\n    else\n    {\n\tif (len >= buflen)\t    // Ugly!\n\t    len = buflen - 1;\n\tmch_memmove(buf, str, (size_t)len);\n    }\n    if (buf == NULL)\n\tGA_CHAR(len) = NUL;\n    else\n\tbuf[len] = NUL;\n\n    // Make each character lower case.\n    i = 0;\n    while (STR_CHAR(i) != NUL)\n    {\n\tif (enc_utf8 || (has_mbyte && MB_BYTE2LEN(STR_CHAR(i)) > 1))\n\t{\n\t    if (enc_utf8)\n\t    {\n\t\tint\tc = utf_ptr2char(STR_PTR(i));\n\t\tint\tolen = utf_ptr2len(STR_PTR(i));\n\t\tint\tlc = utf_tolower(c);\n\n\t\t// Only replace the character when it is not an invalid\n\t\t// sequence (ASCII character or more than one byte) and\n\t\t// utf_tolower() doesn't return the original character.\n\t\tif ((c < 0x80 || olen > 1) && c != lc)\n\t\t{\n\t\t    int\t    nlen = utf_char2len(lc);\n\n\t\t    // If the byte length changes need to shift the following\n\t\t    // characters forward or backward.\n\t\t    if (olen != nlen)\n\t\t    {\n\t\t\tif (nlen > olen)\n\t\t\t{\n\t\t\t    if (buf == NULL\n\t\t\t\t    ? ga_grow(&ga, nlen - olen + 1) == FAIL\n\t\t\t\t    : len + nlen - olen >= buflen)\n\t\t\t    {\n\t\t\t\t// out of memory, keep old char\n\t\t\t\tlc = c;\n\t\t\t\tnlen = olen;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (olen != nlen)\n\t\t\t{\n\t\t\t    if (buf == NULL)\n\t\t\t    {\n\t\t\t\tSTRMOVE(GA_PTR(i) + nlen, GA_PTR(i) + olen);\n\t\t\t\tga.ga_len += nlen - olen;\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tSTRMOVE(buf + i + nlen, buf + i + olen);\n\t\t\t\tlen += nlen - olen;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    (void)utf_char2bytes(lc, STR_PTR(i));\n\t\t}\n\t    }\n\t    // skip to next multi-byte char\n\t    i += (*mb_ptr2len)(STR_PTR(i));\n\t}\n\telse\n\t{\n\t    if (buf == NULL)\n\t\tGA_CHAR(i) = TOLOWER_LOC(GA_CHAR(i));\n\t    else\n\t\tbuf[i] = TOLOWER_LOC(buf[i]);\n\t    ++i;\n\t}\n    }\n\n    if (buf == NULL)\n\treturn (char_u *)ga.ga_data;\n    return buf;\n}\n\n/*\n * Catch 22: g_chartab[] can't be initialized before the options are\n * initialized, and initializing options may cause transchar() to be called!\n * When chartab_initialized == FALSE don't use g_chartab[].\n * Does NOT work for multi-byte characters, c must be <= 255.\n * Also doesn't work for the first byte of a multi-byte, \"c\" must be a\n * character!\n */\nstatic char_u\ttranschar_charbuf[7];\n\n    char_u *\ntranschar(int c)\n{\n    return transchar_buf(curbuf, c);\n}\n\n    char_u *\ntranschar_buf(buf_T *buf, int c)\n{\n    int\t\t\ti;\n\n    i = 0;\n    if (IS_SPECIAL(c))\t    // special key code, display as ~@ char\n    {\n\ttranschar_charbuf[0] = '~';\n\ttranschar_charbuf[1] = '@';\n\ti = 2;\n\tc = K_SECOND(c);\n    }\n\n    if ((!chartab_initialized && ((c >= ' ' && c <= '~')))\n\t\t\t\t\t|| (c < 256 && vim_isprintc_strict(c)))\n    {\n\t// printable character\n\ttranschar_charbuf[i] = c;\n\ttranschar_charbuf[i + 1] = NUL;\n    }\n    else\n\ttranschar_nonprint(buf, transchar_charbuf + i, c);\n    return transchar_charbuf;\n}\n\n/*\n * Like transchar(), but called with a byte instead of a character.  Checks\n * for an illegal UTF-8 byte.\n */\n    char_u *\ntranschar_byte(int c)\n{\n    if (enc_utf8 && c >= 0x80)\n    {\n\ttranschar_nonprint(curbuf, transchar_charbuf, c);\n\treturn transchar_charbuf;\n    }\n    return transchar(c);\n}\n\n/*\n * Convert non-printable character to two or more printable characters in\n * \"buf[]\".  \"charbuf\" needs to be able to hold five bytes.\n * Does NOT work for multi-byte characters, c must be <= 255.\n */\n    void\ntranschar_nonprint(buf_T *buf, char_u *charbuf, int c)\n{\n    if (c == NL)\n\tc = NUL;\t\t// we use newline in place of a NUL\n    else if (c == CAR && get_fileformat(buf) == EOL_MAC)\n\tc = NL;\t\t\t// we use CR in place of  NL in this case\n\n    if (dy_flags & DY_UHEX)\t\t// 'display' has \"uhex\"\n\ttranschar_hex(charbuf, c);\n\n    else if (c <= 0x7f)\t\t\t// 0x00 - 0x1f and 0x7f\n    {\n\tcharbuf[0] = '^';\n\tcharbuf[1] = c ^ 0x40;\t\t// DEL displayed as ^?\n\tcharbuf[2] = NUL;\n    }\n    else if (enc_utf8 && c >= 0x80)\n    {\n\ttranschar_hex(charbuf, c);\n    }\n    else if (c >= ' ' + 0x80 && c <= '~' + 0x80)    // 0xa0 - 0xfe\n    {\n\tcharbuf[0] = '|';\n\tcharbuf[1] = c - 0x80;\n\tcharbuf[2] = NUL;\n    }\n    else\t\t\t\t\t    // 0x80 - 0x9f and 0xff\n    {\n\tcharbuf[0] = '~';\n\tcharbuf[1] = (c - 0x80) ^ 0x40;\t// 0xff displayed as ~?\n\tcharbuf[2] = NUL;\n    }\n}\n\n    void\ntranschar_hex(char_u *buf, int c)\n{\n    int\t\ti = 0;\n\n    buf[0] = '<';\n    if (c > 255)\n    {\n\tbuf[++i] = nr2hex((unsigned)c >> 12);\n\tbuf[++i] = nr2hex((unsigned)c >> 8);\n    }\n    buf[++i] = nr2hex((unsigned)c >> 4);\n    buf[++i] = nr2hex((unsigned)c);\n    buf[++i] = '>';\n    buf[++i] = NUL;\n}\n\n/*\n * Convert the lower 4 bits of byte \"c\" to its hex character.\n * Lower case letters are used to avoid the confusion of <F1> being 0xf1 or\n * function key 1.\n */\n    static unsigned\nnr2hex(unsigned c)\n{\n    if ((c & 0xf) <= 9)\n\treturn (c & 0xf) + '0';\n    return (c & 0xf) - 10 + 'a';\n}\n\n/*\n * Return number of display cells occupied by byte \"b\".\n * Caller must make sure 0 <= b <= 255.\n * For multi-byte mode \"b\" must be the first byte of a character.\n * A TAB is counted as two cells: \"^I\".\n * For UTF-8 mode this will return 0 for bytes >= 0x80, because the number of\n * cells depends on further bytes.\n */\n    int\nbyte2cells(int b)\n{\n    if (enc_utf8 && b >= 0x80)\n\treturn 0;\n    return (g_chartab[b] & CT_CELL_MASK);\n}\n\n/*\n * Return number of display cells occupied by character \"c\".\n * \"c\" can be a special key (negative number) in which case 3 or 4 is returned.\n * A TAB is counted as two cells: \"^I\" or four: \"<09>\".\n */\n    int\nchar2cells(int c)\n{\n    if (IS_SPECIAL(c))\n\treturn char2cells(K_SECOND(c)) + 2;\n    if (c >= 0x80)\n    {\n\t// UTF-8: above 0x80 need to check the value\n\tif (enc_utf8)\n\t    return utf_char2cells(c);\n\t// DBCS: double-byte means double-width, except for euc-jp with first\n\t// byte 0x8e\n\tif (enc_dbcs != 0 && c >= 0x100)\n\t{\n\t    if (enc_dbcs == DBCS_JPNU && ((unsigned)c >> 8) == 0x8e)\n\t\treturn 1;\n\t    return 2;\n\t}\n    }\n    return (g_chartab[c & 0xff] & CT_CELL_MASK);\n}\n\n/*\n * Return number of display cells occupied by character at \"*p\".\n * A TAB is counted as two cells: \"^I\" or four: \"<09>\".\n */\n    int\nptr2cells(char_u *p)\n{\n    // For UTF-8 we need to look at more bytes if the first byte is >= 0x80.\n    if (enc_utf8 && *p >= 0x80)\n\treturn utf_ptr2cells(p);\n    // For DBCS we can tell the cell count from the first byte.\n    return (g_chartab[*p] & CT_CELL_MASK);\n}\n\n/*\n * Return the number of character cells string \"s\" will take on the screen,\n * counting TABs as two characters: \"^I\".\n */\n    int\nvim_strsize(char_u *s)\n{\n    return vim_strnsize(s, (int)MAXCOL);\n}\n\n/*\n * Return the number of character cells string \"s[len]\" will take on the\n * screen, counting TABs as two characters: \"^I\".\n */\n    int\nvim_strnsize(char_u *s, int len)\n{\n    int\t\tsize = 0;\n\n    while (*s != NUL && --len >= 0)\n\tif (has_mbyte)\n\t{\n\t    int\t    l = (*mb_ptr2len)(s);\n\n\t    size += ptr2cells(s);\n\t    s += l;\n\t    len -= l - 1;\n\t}\n\telse\n\t    size += byte2cells(*s++);\n\n    return size;\n}\n\n/*\n * Return the number of characters 'c' will take on the screen, taking\n * into account the size of a tab.\n * Use a define to make it fast, this is used very often!!!\n * Also see getvcol() below.\n */\n\n#ifdef FEAT_VARTABS\n# define RET_WIN_BUF_CHARTABSIZE(wp, buf, p, col) \\\n    if (*(p) == TAB && (!(wp)->w_p_list || (wp)->w_lcs_chars.tab1)) \\\n    { \\\n\treturn tabstop_padding(col, (buf)->b_p_ts, (buf)->b_p_vts_array); \\\n    } \\\n    else \\\n\treturn ptr2cells(p);\n#else\n# define RET_WIN_BUF_CHARTABSIZE(wp, buf, p, col) \\\n    if (*(p) == TAB && (!(wp)->w_p_list || wp->w_lcs_chars.tab1)) \\\n    { \\\n\tint ts; \\\n\tts = (buf)->b_p_ts; \\\n\treturn (int)(ts - (col % ts)); \\\n    } \\\n    else \\\n\treturn ptr2cells(p);\n#endif\n\n    int\nchartabsize(char_u *p, colnr_T col)\n{\n    RET_WIN_BUF_CHARTABSIZE(curwin, curbuf, p, col)\n}\n\n#ifdef FEAT_LINEBREAK\n    static int\nwin_chartabsize(win_T *wp, char_u *p, colnr_T col)\n{\n    RET_WIN_BUF_CHARTABSIZE(wp, wp->w_buffer, p, col)\n}\n#endif\n\n/*\n * Return the number of characters the string 's' will take on the screen,\n * taking into account the size of a tab.\n */\n    int\nlinetabsize(char_u *s)\n{\n    return linetabsize_col(0, s);\n}\n\n/*\n * Like linetabsize(), but starting at column \"startcol\".\n */\n    int\nlinetabsize_col(int startcol, char_u *s)\n{\n    colnr_T\tcol = startcol;\n    char_u\t*line = s; // pointer to start of line, for breakindent\n\n    while (*s != NUL)\n\tcol += lbr_chartabsize_adv(line, &s, col);\n    return (int)col;\n}\n\n/*\n * Like linetabsize(), but for a given window instead of the current one.\n */\n    int\nwin_linetabsize(win_T *wp, char_u *line, colnr_T len)\n{\n    colnr_T\tcol = 0;\n    char_u\t*s;\n\n    for (s = line; *s != NUL && (len == MAXCOL || s < line + len);\n\t\t\t\t\t\t\t\tMB_PTR_ADV(s))\n\tcol += win_lbr_chartabsize(wp, line, s, col, NULL);\n    return (int)col;\n}\n\n/*\n * Return TRUE if 'c' is a normal identifier character:\n * Letters and characters from the 'isident' option.\n */\n    int\nvim_isIDc(int c)\n{\n    return (c > 0 && c < 0x100 && (g_chartab[c] & CT_ID_CHAR));\n}\n\n/*\n * Like vim_isIDc() but not using the 'isident' option: letters, numbers and\n * underscore.\n */\n    int\nvim_isNormalIDc(int c)\n{\n    return ASCII_ISALNUM(c) || c == '_';\n}\n\n/*\n * return TRUE if 'c' is a keyword character: Letters and characters from\n * 'iskeyword' option for the current buffer.\n * For multi-byte characters mb_get_class() is used (builtin rules).\n */\n    int\nvim_iswordc(int c)\n{\n    return vim_iswordc_buf(c, curbuf);\n}\n\n    int\nvim_iswordc_buf(int c, buf_T *buf)\n{\n    if (c >= 0x100)\n    {\n\tif (enc_dbcs != 0)\n\t    return dbcs_class((unsigned)c >> 8, (unsigned)(c & 0xff)) >= 2;\n\tif (enc_utf8)\n\t    return utf_class_buf(c, buf) >= 2;\n\treturn FALSE;\n    }\n    return (c > 0 && GET_CHARTAB(buf, c) != 0);\n}\n\n/*\n * Just like vim_iswordc() but uses a pointer to the (multi-byte) character.\n */\n    int\nvim_iswordp(char_u *p)\n{\n    return vim_iswordp_buf(p, curbuf);\n}\n\n    int\nvim_iswordp_buf(char_u *p, buf_T *buf)\n{\n    int\tc = *p;\n\n    if (has_mbyte && MB_BYTE2LEN(c) > 1)\n\tc = (*mb_ptr2char)(p);\n    return vim_iswordc_buf(c, buf);\n}\n\n/*\n * return TRUE if 'c' is a valid file-name character\n * Assume characters above 0x100 are valid (multi-byte).\n */\n    int\nvim_isfilec(int c)\n{\n    return (c >= 0x100 || (c > 0 && (g_chartab[c] & CT_FNAME_CHAR)));\n}\n\n/*\n * return TRUE if 'c' is a valid file-name character or a wildcard character\n * Assume characters above 0x100 are valid (multi-byte).\n * Explicitly interpret ']' as a wildcard character as mch_has_wildcard(\"]\")\n * returns false.\n */\n    int\nvim_isfilec_or_wc(int c)\n{\n    char_u buf[2];\n\n    buf[0] = (char_u)c;\n    buf[1] = NUL;\n    return vim_isfilec(c) || c == ']' || mch_has_wildcard(buf);\n}\n\n/*\n * Return TRUE if 'c' is a printable character.\n * Assume characters above 0x100 are printable (multi-byte), except for\n * Unicode.\n */\n    int\nvim_isprintc(int c)\n{\n    if (enc_utf8 && c >= 0x100)\n\treturn utf_printable(c);\n    return (c >= 0x100 || (c > 0 && (g_chartab[c] & CT_PRINT_CHAR)));\n}\n\n/*\n * Strict version of vim_isprintc(c), don't return TRUE if \"c\" is the head\n * byte of a double-byte character.\n */\n    int\nvim_isprintc_strict(int c)\n{\n    if (enc_dbcs != 0 && c < 0x100 && MB_BYTE2LEN(c) > 1)\n\treturn FALSE;\n    if (enc_utf8 && c >= 0x100)\n\treturn utf_printable(c);\n    return (c >= 0x100 || (c > 0 && (g_chartab[c] & CT_PRINT_CHAR)));\n}\n\n/*\n * like chartabsize(), but also check for line breaks on the screen\n */\n    int\nlbr_chartabsize(\n    char_u\t\t*line UNUSED, // start of the line\n    unsigned char\t*s,\n    colnr_T\t\tcol)\n{\n#ifdef FEAT_LINEBREAK\n    if (!curwin->w_p_lbr && *get_showbreak_value(curwin) == NUL\n\t\t\t\t\t\t\t   && !curwin->w_p_bri)\n    {\n#endif\n\tif (curwin->w_p_wrap)\n\t    return win_nolbr_chartabsize(curwin, s, col, NULL);\n\tRET_WIN_BUF_CHARTABSIZE(curwin, curbuf, s, col)\n#ifdef FEAT_LINEBREAK\n    }\n    return win_lbr_chartabsize(curwin, line == NULL ? s : line, s, col, NULL);\n#endif\n}\n\n/*\n * Call lbr_chartabsize() and advance the pointer.\n */\n    int\nlbr_chartabsize_adv(\n    char_u\t*line, // start of the line\n    char_u\t**s,\n    colnr_T\tcol)\n{\n    int\t\tretval;\n\n    retval = lbr_chartabsize(line, *s, col);\n    MB_PTR_ADV(*s);\n    return retval;\n}\n\n/*\n * This function is used very often, keep it fast!!!!\n *\n * If \"headp\" not NULL, set *headp to the size of what we for 'showbreak'\n * string at start of line.  Warning: *headp is only set if it's a non-zero\n * value, init to 0 before calling.\n */\n    int\nwin_lbr_chartabsize(\n    win_T\t*wp,\n    char_u\t*line UNUSED, // start of the line\n    char_u\t*s,\n    colnr_T\tcol,\n    int\t\t*headp UNUSED)\n{\n#ifdef FEAT_LINEBREAK\n    int\t\tc;\n    int\t\tsize;\n    colnr_T\tcol2;\n    colnr_T\tcol_adj = 0; // col + screen size of tab\n    colnr_T\tcolmax;\n    int\t\tadded;\n    int\t\tmb_added = 0;\n    int\t\tnumberextra;\n    char_u\t*ps;\n    int\t\ttab_corr = (*s == TAB);\n    int\t\tn;\n    char_u\t*sbr;\n\n    /*\n     * No 'linebreak', 'showbreak' and 'breakindent': return quickly.\n     */\n    if (!wp->w_p_lbr && !wp->w_p_bri && *get_showbreak_value(wp) == NUL)\n#endif\n    {\n\tif (wp->w_p_wrap)\n\t    return win_nolbr_chartabsize(wp, s, col, headp);\n\tRET_WIN_BUF_CHARTABSIZE(wp, wp->w_buffer, s, col)\n    }\n\n#ifdef FEAT_LINEBREAK\n    /*\n     * First get normal size, without 'linebreak'\n     */\n    size = win_chartabsize(wp, s, col);\n    c = *s;\n    if (tab_corr)\n\tcol_adj = size - 1;\n\n    /*\n     * If 'linebreak' set check at a blank before a non-blank if the line\n     * needs a break here\n     */\n    if (wp->w_p_lbr\n\t    && VIM_ISBREAK(c)\n\t    && !VIM_ISBREAK((int)s[1])\n\t    && wp->w_p_wrap\n\t    && wp->w_width != 0)\n    {\n\t/*\n\t * Count all characters from first non-blank after a blank up to next\n\t * non-blank after a blank.\n\t */\n\tnumberextra = win_col_off(wp);\n\tcol2 = col;\n\tcolmax = (colnr_T)(wp->w_width - numberextra - col_adj);\n\tif (col >= colmax)\n\t{\n\t    colmax += col_adj;\n\t    n = colmax +  win_col_off2(wp);\n\t    if (n > 0)\n\t\tcolmax += (((col - colmax) / n) + 1) * n - col_adj;\n\t}\n\n\tfor (;;)\n\t{\n\t    ps = s;\n\t    MB_PTR_ADV(s);\n\t    c = *s;\n\t    if (!(c != NUL\n\t\t    && (VIM_ISBREAK(c)\n\t\t\t|| (!VIM_ISBREAK(c)\n\t\t\t    && (col2 == col || !VIM_ISBREAK((int)*ps))))))\n\t\tbreak;\n\n\t    col2 += win_chartabsize(wp, s, col2);\n\t    if (col2 >= colmax)\t\t// doesn't fit\n\t    {\n\t\tsize = colmax - col + col_adj;\n\t\tbreak;\n\t    }\n\t}\n    }\n    else if (has_mbyte && size == 2 && MB_BYTE2LEN(*s) > 1\n\t\t\t\t    && wp->w_p_wrap && in_win_border(wp, col))\n    {\n\t++size;\t\t// Count the \">\" in the last column.\n\tmb_added = 1;\n    }\n\n    /*\n     * May have to add something for 'breakindent' and/or 'showbreak'\n     * string at start of line.\n     * Set *headp to the size of what we add.\n     */\n    added = 0;\n    sbr = get_showbreak_value(wp);\n    if ((*sbr != NUL || wp->w_p_bri) && wp->w_p_wrap && col != 0)\n    {\n\tcolnr_T sbrlen = 0;\n\tint\tnumberwidth = win_col_off(wp);\n\n\tnumberextra = numberwidth;\n\tcol += numberextra + mb_added;\n\tif (col >= (colnr_T)wp->w_width)\n\t{\n\t    col -= wp->w_width;\n\t    numberextra = wp->w_width - (numberextra - win_col_off2(wp));\n\t    if (col >= numberextra && numberextra > 0)\n\t\tcol %= numberextra;\n\t    if (*sbr != NUL)\n\t    {\n\t\tsbrlen = (colnr_T)MB_CHARLEN(sbr);\n\t\tif (col >= sbrlen)\n\t\t    col -= sbrlen;\n\t    }\n\t    if (col >= numberextra && numberextra > 0)\n\t\tcol = col % numberextra;\n\t    else if (col > 0 && numberextra > 0)\n\t\tcol += numberwidth - win_col_off2(wp);\n\n\t    numberwidth -= win_col_off2(wp);\n\t}\n\tif (col == 0 || col + size + sbrlen > (colnr_T)wp->w_width)\n\t{\n\t    added = 0;\n\t    if (*sbr != NUL)\n\t    {\n\t\tif (size + sbrlen + numberwidth > (colnr_T)wp->w_width)\n\t\t{\n\t\t    // calculate effective window width\n\t\t    int width = (colnr_T)wp->w_width - sbrlen - numberwidth;\n\t\t    int prev_width = col\n\t\t\t\t ? ((colnr_T)wp->w_width - (sbrlen + col)) : 0;\n\n\t\t    if (width <= 0)\n\t\t\twidth = (colnr_T)1;\n\t\t    added += ((size - prev_width) / width) * vim_strsize(sbr);\n\t\t    if ((size - prev_width) % width)\n\t\t\t// wrapped, add another length of 'sbr'\n\t\t\tadded += vim_strsize(sbr);\n\t\t}\n\t\telse\n\t\t    added += vim_strsize(sbr);\n\t    }\n\t    if (wp->w_p_bri)\n\t\tadded += get_breakindent_win(wp, line);\n\n\t    size += added;\n\t    if (col != 0)\n\t\tadded = 0;\n\t}\n    }\n    if (headp != NULL)\n\t*headp = added + mb_added;\n    return size;\n#endif\n}\n\n/*\n * Like win_lbr_chartabsize(), except that we know 'linebreak' is off and\n * 'wrap' is on.  This means we need to check for a double-byte character that\n * doesn't fit at the end of the screen line.\n */\n    static int\nwin_nolbr_chartabsize(\n    win_T\t*wp,\n    char_u\t*s,\n    colnr_T\tcol,\n    int\t\t*headp)\n{\n    int\t\tn;\n\n    if (*s == TAB && (!wp->w_p_list || wp->w_lcs_chars.tab1))\n    {\n# ifdef FEAT_VARTABS\n\treturn tabstop_padding(col, wp->w_buffer->b_p_ts,\n\t\t\t\t    wp->w_buffer->b_p_vts_array);\n# else\n\tn = wp->w_buffer->b_p_ts;\n\treturn (int)(n - (col % n));\n# endif\n    }\n    n = ptr2cells(s);\n    // Add one cell for a double-width character in the last column of the\n    // window, displayed with a \">\".\n    if (n == 2 && MB_BYTE2LEN(*s) > 1 && in_win_border(wp, col))\n    {\n\tif (headp != NULL)\n\t    *headp = 1;\n\treturn 3;\n    }\n    return n;\n}\n\n/*\n * Return TRUE if virtual column \"vcol\" is in the rightmost column of window\n * \"wp\".\n */\n    static int\nin_win_border(win_T *wp, colnr_T vcol)\n{\n    int\t\twidth1;\t\t// width of first line (after line number)\n    int\t\twidth2;\t\t// width of further lines\n\n    if (wp->w_width == 0)\t// there is no border\n\treturn FALSE;\n    width1 = wp->w_width - win_col_off(wp);\n    if ((int)vcol < width1 - 1)\n\treturn FALSE;\n    if ((int)vcol == width1 - 1)\n\treturn TRUE;\n    width2 = width1 + win_col_off2(wp);\n    if (width2 <= 0)\n\treturn FALSE;\n    return ((vcol - width1) % width2 == width2 - 1);\n}\n\n/*\n * Get virtual column number of pos.\n *  start: on the first position of this character (TAB, ctrl)\n * cursor: where the cursor is on this character (first char, except for TAB)\n *    end: on the last position of this character (TAB, ctrl)\n *\n * This is used very often, keep it fast!\n */\n    void\ngetvcol(\n    win_T\t*wp,\n    pos_T\t*pos,\n    colnr_T\t*start,\n    colnr_T\t*cursor,\n    colnr_T\t*end)\n{\n    colnr_T\tvcol;\n    char_u\t*ptr;\t\t// points to current char\n    char_u\t*posptr;\t// points to char at pos->col\n    char_u\t*line;\t\t// start of the line\n    int\t\tincr;\n    int\t\thead;\n#ifdef FEAT_VARTABS\n    int\t\t*vts = wp->w_buffer->b_p_vts_array;\n#endif\n    int\t\tts = wp->w_buffer->b_p_ts;\n    int\t\tc;\n\n    vcol = 0;\n    line = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);\n    if (pos->col == MAXCOL)\n\tposptr = NULL;  // continue until the NUL\n    else\n    {\n\tcolnr_T i;\n\n\t// In a few cases the position can be beyond the end of the line.\n\tfor (i = 0; i < pos->col; ++i)\n\t    if (ptr[i] == NUL)\n\t    {\n\t\tpos->col = i;\n\t\tbreak;\n\t    }\n\tposptr = ptr + pos->col;\n\tif (has_mbyte)\n\t    // always start on the first byte\n\t    posptr -= (*mb_head_off)(line, posptr);\n    }\n\n    /*\n     * This function is used very often, do some speed optimizations.\n     * When 'list', 'linebreak', 'showbreak' and 'breakindent' are not set\n     * use a simple loop.\n     * Also use this when 'list' is set but tabs take their normal size.\n     */\n    if ((!wp->w_p_list || wp->w_lcs_chars.tab1 != NUL)\n#ifdef FEAT_LINEBREAK\n\t    && !wp->w_p_lbr && *get_showbreak_value(wp) == NUL && !wp->w_p_bri\n#endif\n       )\n    {\n\tfor (;;)\n\t{\n\t    head = 0;\n\t    c = *ptr;\n\t    // make sure we don't go past the end of the line\n\t    if (c == NUL)\n\t    {\n\t\tincr = 1;\t// NUL at end of line only takes one column\n\t\tbreak;\n\t    }\n\t    // A tab gets expanded, depending on the current column\n\t    if (c == TAB)\n#ifdef FEAT_VARTABS\n\t\tincr = tabstop_padding(vcol, ts, vts);\n#else\n\t\tincr = ts - (vcol % ts);\n#endif\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    // For utf-8, if the byte is >= 0x80, need to look at\n\t\t    // further bytes to find the cell width.\n\t\t    if (enc_utf8 && c >= 0x80)\n\t\t\tincr = utf_ptr2cells(ptr);\n\t\t    else\n\t\t\tincr = g_chartab[c] & CT_CELL_MASK;\n\n\t\t    // If a double-cell char doesn't fit at the end of a line\n\t\t    // it wraps to the next line, it's like this char is three\n\t\t    // cells wide.\n\t\t    if (incr == 2 && wp->w_p_wrap && MB_BYTE2LEN(*ptr) > 1\n\t\t\t    && in_win_border(wp, vcol))\n\t\t    {\n\t\t\t++incr;\n\t\t\thead = 1;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    incr = g_chartab[c] & CT_CELL_MASK;\n\t    }\n\n\t    if (posptr != NULL && ptr >= posptr) // character at pos->col\n\t\tbreak;\n\n\t    vcol += incr;\n\t    MB_PTR_ADV(ptr);\n\t}\n    }\n    else\n    {\n\tfor (;;)\n\t{\n\t    // A tab gets expanded, depending on the current column\n\t    head = 0;\n\t    incr = win_lbr_chartabsize(wp, line, ptr, vcol, &head);\n\t    // make sure we don't go past the end of the line\n\t    if (*ptr == NUL)\n\t    {\n\t\tincr = 1;\t// NUL at end of line only takes one column\n\t\tbreak;\n\t    }\n\n\t    if (posptr != NULL && ptr >= posptr) // character at pos->col\n\t\tbreak;\n\n\t    vcol += incr;\n\t    MB_PTR_ADV(ptr);\n\t}\n    }\n    if (start != NULL)\n\t*start = vcol + head;\n    if (end != NULL)\n\t*end = vcol + incr - 1;\n    if (cursor != NULL)\n    {\n\tif (*ptr == TAB\n\t\t&& (State & NORMAL)\n\t\t&& !wp->w_p_list\n\t\t&& !virtual_active()\n\t\t&& !(VIsual_active\n\t\t\t\t&& (*p_sel == 'e' || LTOREQ_POS(*pos, VIsual)))\n\t\t)\n\t    *cursor = vcol + incr - 1;\t    // cursor at end\n\telse\n\t    *cursor = vcol + head;\t    // cursor at start\n    }\n}\n\n/*\n * Get virtual cursor column in the current window, pretending 'list' is off.\n */\n    colnr_T\ngetvcol_nolist(pos_T *posp)\n{\n    int\t\tlist_save = curwin->w_p_list;\n    colnr_T\tvcol;\n\n    curwin->w_p_list = FALSE;\n    if (posp->coladd)\n\tgetvvcol(curwin, posp, NULL, &vcol, NULL);\n    else\n\tgetvcol(curwin, posp, NULL, &vcol, NULL);\n    curwin->w_p_list = list_save;\n    return vcol;\n}\n\n/*\n * Get virtual column in virtual mode.\n */\n    void\ngetvvcol(\n    win_T\t*wp,\n    pos_T\t*pos,\n    colnr_T\t*start,\n    colnr_T\t*cursor,\n    colnr_T\t*end)\n{\n    colnr_T\tcol;\n    colnr_T\tcoladd;\n    colnr_T\tendadd;\n    char_u\t*ptr;\n\n    if (virtual_active())\n    {\n\t// For virtual mode, only want one value\n\tgetvcol(wp, pos, &col, NULL, NULL);\n\n\tcoladd = pos->coladd;\n\tendadd = 0;\n\t// Cannot put the cursor on part of a wide character.\n\tptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);\n\tif (pos->col < (colnr_T)STRLEN(ptr))\n\t{\n\t    int c = (*mb_ptr2char)(ptr + pos->col);\n\n\t    if (c != TAB && vim_isprintc(c))\n\t    {\n\t\tendadd = (colnr_T)(char2cells(c) - 1);\n\t\tif (coladd > endadd)\t// past end of line\n\t\t    endadd = 0;\n\t\telse\n\t\t    coladd = 0;\n\t    }\n\t}\n\tcol += coladd;\n\tif (start != NULL)\n\t    *start = col;\n\tif (cursor != NULL)\n\t    *cursor = col;\n\tif (end != NULL)\n\t    *end = col + endadd;\n    }\n    else\n\tgetvcol(wp, pos, start, cursor, end);\n}\n\n/*\n * Get the leftmost and rightmost virtual column of pos1 and pos2.\n * Used for Visual block mode.\n */\n    void\ngetvcols(\n    win_T\t*wp,\n    pos_T\t*pos1,\n    pos_T\t*pos2,\n    colnr_T\t*left,\n    colnr_T\t*right)\n{\n    colnr_T\tfrom1, from2, to1, to2;\n\n    if (LT_POSP(pos1, pos2))\n    {\n\tgetvvcol(wp, pos1, &from1, NULL, &to1);\n\tgetvvcol(wp, pos2, &from2, NULL, &to2);\n    }\n    else\n    {\n\tgetvvcol(wp, pos2, &from1, NULL, &to1);\n\tgetvvcol(wp, pos1, &from2, NULL, &to2);\n    }\n    if (from2 < from1)\n\t*left = from2;\n    else\n\t*left = from1;\n    if (to2 > to1)\n    {\n\tif (*p_sel == 'e' && from2 - 1 >= to1)\n\t    *right = from2 - 1;\n\telse\n\t    *right = to2;\n    }\n    else\n\t*right = to1;\n}\n\n/*\n * Skip over ' ' and '\\t'.\n */\n    char_u *\nskipwhite(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (VIM_ISWHITE(*p))\n\t++p;\n    return p;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * skip over ' ', '\\t' and '\\n'.\n */\n    char_u *\nskipwhite_and_nl(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (VIM_ISWHITE(*p) || *p == NL)\n\t++p;\n    return p;\n}\n#endif\n\n/*\n * getwhitecols: return the number of whitespace\n * columns (bytes) at the start of a given line\n */\n    int\ngetwhitecols_curline()\n{\n    return getwhitecols(ml_get_curline());\n}\n\n    int\ngetwhitecols(char_u *p)\n{\n    return skipwhite(p) - p;\n}\n\n/*\n * skip over digits\n */\n    char_u *\nskipdigits(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (VIM_ISDIGIT(*p))\t// skip to next non-digit\n\t++p;\n    return p;\n}\n\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * skip over binary digits\n */\n    char_u *\nskipbin(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (vim_isbdigit(*p))\t// skip to next non-digit\n\t++p;\n    return p;\n}\n\n/*\n * skip over digits and hex characters\n */\n    char_u *\nskiphex(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (vim_isxdigit(*p))\t// skip to next non-digit\n\t++p;\n    return p;\n}\n#endif\n\n/*\n * skip to bin digit (or NUL after the string)\n */\n    char_u *\nskiptobin(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (*p != NUL && !vim_isbdigit(*p))\t// skip to next digit\n\t++p;\n    return p;\n}\n\n/*\n * skip to digit (or NUL after the string)\n */\n    char_u *\nskiptodigit(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (*p != NUL && !VIM_ISDIGIT(*p))\t// skip to next digit\n\t++p;\n    return p;\n}\n\n/*\n * skip to hex character (or NUL after the string)\n */\n    char_u *\nskiptohex(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (*p != NUL && !vim_isxdigit(*p))\t// skip to next digit\n\t++p;\n    return p;\n}\n\n/*\n * Variant of isdigit() that can handle characters > 0x100.\n * We don't use isdigit() here, because on some systems it also considers\n * superscript 1 to be a digit.\n * Use the VIM_ISDIGIT() macro for simple arguments.\n */\n    int\nvim_isdigit(int c)\n{\n    return (c >= '0' && c <= '9');\n}\n\n/*\n * Variant of isxdigit() that can handle characters > 0x100.\n * We don't use isxdigit() here, because on some systems it also considers\n * superscript 1 to be a digit.\n */\n    int\nvim_isxdigit(int c)\n{\n    return (c >= '0' && c <= '9')\n\t|| (c >= 'a' && c <= 'f')\n\t|| (c >= 'A' && c <= 'F');\n}\n\n/*\n * Corollary of vim_isdigit and vim_isxdigit() that can handle\n * characters > 0x100.\n */\n    int\nvim_isbdigit(int c)\n{\n    return (c == '0' || c == '1');\n}\n\n    static int\nvim_isodigit(int c)\n{\n    return (c >= '0' && c <= '7');\n}\n\n/*\n * Vim's own character class functions.  These exist because many library\n * islower()/toupper() etc. do not work properly: they crash when used with\n * invalid values or can't handle latin1 when the locale is C.\n * Speed is most important here.\n */\n#define LATIN1LOWER 'l'\n#define LATIN1UPPER 'U'\n\nstatic char_u latin1flags[257] = \"                                                                 UUUUUUUUUUUUUUUUUUUUUUUUUU      llllllllllllllllllllllllll                                                                     UUUUUUUUUUUUUUUUUUUUUUU UUUUUUUllllllllllllllllllllllll llllllll\";\nstatic char_u latin1upper[257] = \"                                 !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xf7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xff\";\nstatic char_u latin1lower[257] = \"                                 !\\\"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xd7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\";\n\n    int\nvim_islower(int c)\n{\n    if (c <= '@')\n\treturn FALSE;\n    if (c >= 0x80)\n    {\n\tif (enc_utf8)\n\t    return utf_islower(c);\n\tif (c >= 0x100)\n\t{\n#ifdef HAVE_ISWLOWER\n\t    if (has_mbyte)\n\t\treturn iswlower(c);\n#endif\n\t    // islower() can't handle these chars and may crash\n\t    return FALSE;\n\t}\n\tif (enc_latin1like)\n\t    return (latin1flags[c] & LATIN1LOWER) == LATIN1LOWER;\n    }\n    return islower(c);\n}\n\n    int\nvim_isupper(int c)\n{\n    if (c <= '@')\n\treturn FALSE;\n    if (c >= 0x80)\n    {\n\tif (enc_utf8)\n\t    return utf_isupper(c);\n\tif (c >= 0x100)\n\t{\n#ifdef HAVE_ISWUPPER\n\t    if (has_mbyte)\n\t\treturn iswupper(c);\n#endif\n\t    // islower() can't handle these chars and may crash\n\t    return FALSE;\n\t}\n\tif (enc_latin1like)\n\t    return (latin1flags[c] & LATIN1UPPER) == LATIN1UPPER;\n    }\n    return isupper(c);\n}\n\n    int\nvim_toupper(int c)\n{\n    if (c <= '@')\n\treturn c;\n    if (c >= 0x80 || !(cmp_flags & CMP_KEEPASCII))\n    {\n\tif (enc_utf8)\n\t    return utf_toupper(c);\n\tif (c >= 0x100)\n\t{\n#ifdef HAVE_TOWUPPER\n\t    if (has_mbyte)\n\t\treturn towupper(c);\n#endif\n\t    // toupper() can't handle these chars and may crash\n\t    return c;\n\t}\n\tif (enc_latin1like)\n\t    return latin1upper[c];\n    }\n    if (c < 0x80 && (cmp_flags & CMP_KEEPASCII))\n\treturn TOUPPER_ASC(c);\n    return TOUPPER_LOC(c);\n}\n\n    int\nvim_tolower(int c)\n{\n    if (c <= '@')\n\treturn c;\n    if (c >= 0x80 || !(cmp_flags & CMP_KEEPASCII))\n    {\n\tif (enc_utf8)\n\t    return utf_tolower(c);\n\tif (c >= 0x100)\n\t{\n#ifdef HAVE_TOWLOWER\n\t    if (has_mbyte)\n\t\treturn towlower(c);\n#endif\n\t    // tolower() can't handle these chars and may crash\n\t    return c;\n\t}\n\tif (enc_latin1like)\n\t    return latin1lower[c];\n    }\n    if (c < 0x80 && (cmp_flags & CMP_KEEPASCII))\n\treturn TOLOWER_ASC(c);\n    return TOLOWER_LOC(c);\n}\n\n/*\n * skiptowhite: skip over text until ' ' or '\\t' or NUL.\n */\n    char_u *\nskiptowhite(char_u *p)\n{\n    while (*p != ' ' && *p != '\\t' && *p != NUL)\n\t++p;\n    return p;\n}\n\n/*\n * skiptowhite_esc: Like skiptowhite(), but also skip escaped chars\n */\n    char_u *\nskiptowhite_esc(char_u *p)\n{\n    while (*p != ' ' && *p != '\\t' && *p != NUL)\n    {\n\tif ((*p == '\\\\' || *p == Ctrl_V) && *(p + 1) != NUL)\n\t    ++p;\n\t++p;\n    }\n    return p;\n}\n\n/*\n * Get a number from a string and skip over it.\n * Note: the argument is a pointer to a char_u pointer!\n */\n    long\ngetdigits(char_u **pp)\n{\n    char_u\t*p;\n    long\tretval;\n\n    p = *pp;\n    retval = atol((char *)p);\n    if (*p == '-')\t\t// skip negative sign\n\t++p;\n    p = skipdigits(p);\t\t// skip to next non-digit\n    *pp = p;\n    return retval;\n}\n\n/*\n * Like getdigits() but allow for embedded single quotes.\n */\n    long\ngetdigits_quoted(char_u **pp)\n{\n    char_u\t*p = *pp;\n    long\tretval = 0;\n\n    if (*p == '-')\n\t++p;\n    while (VIM_ISDIGIT(*p))\n    {\n\tif (retval >= LONG_MAX / 10 - 10)\n\t    retval = LONG_MAX;\n\telse\n\t    retval = retval * 10 - '0' + *p;\n\t++p;\n\tif (in_vim9script() && *p == '\\'' && VIM_ISDIGIT(p[1]))\n\t    ++p;\n    }\n    if (**pp == '-')\n    {\n\tif (retval == LONG_MAX)\n\t    retval = LONG_MIN;\n\telse\n\t    retval = -retval;\n    }\n    *pp = p;\n    return retval;\n}\n\n/*\n * Return TRUE if \"lbuf\" is empty or only contains blanks.\n */\n    int\nvim_isblankline(char_u *lbuf)\n{\n    char_u\t*p;\n\n    p = skipwhite(lbuf);\n    return (*p == NUL || *p == '\\r' || *p == '\\n');\n}\n\n/*\n * Convert a string into a long and/or unsigned long, taking care of\n * hexadecimal, octal, and binary numbers.  Accepts a '-' sign.\n * If \"prep\" is not NULL, returns a flag to indicate the type of the number:\n *  0\t    decimal\n *  '0'\t    octal\n *  'O'\t    octal\n *  'o'\t    octal\n *  'B'\t    bin\n *  'b'\t    bin\n *  'X'\t    hex\n *  'x'\t    hex\n * If \"len\" is not NULL, the length of the number in characters is returned.\n * If \"nptr\" is not NULL, the signed result is returned in it.\n * If \"unptr\" is not NULL, the unsigned result is returned in it.\n * If \"what\" contains STR2NR_BIN recognize binary numbers\n * If \"what\" contains STR2NR_OCT recognize octal numbers\n * If \"what\" contains STR2NR_HEX recognize hex numbers\n * If \"what\" contains STR2NR_FORCE always assume bin/oct/hex.\n * If \"what\" contains STR2NR_QUOTE ignore embedded single quotes\n * If maxlen > 0, check at a maximum maxlen chars.\n * If strict is TRUE, check the number strictly. return *len = 0 if fail.\n */\n    void\nvim_str2nr(\n    char_u\t\t*start,\n    int\t\t\t*prep,\t    // return: type of number 0 = decimal, 'x'\n\t\t\t\t    // or 'X' is hex, '0', 'o' or 'O' is octal,\n\t\t\t\t    // 'b' or 'B' is bin\n    int\t\t\t*len,\t    // return: detected length of number\n    int\t\t\twhat,\t    // what numbers to recognize\n    varnumber_T\t\t*nptr,\t    // return: signed result\n    uvarnumber_T\t*unptr,\t    // return: unsigned result\n    int\t\t\tmaxlen,     // max length of string to check\n    int\t\t\tstrict)     // check strictly\n{\n    char_u\t    *ptr = start;\n    int\t\t    pre = 0;\t\t// default is decimal\n    int\t\t    negative = FALSE;\n    uvarnumber_T    un = 0;\n    int\t\t    n;\n\n    if (len != NULL)\n\t*len = 0;\n\n    if (ptr[0] == '-')\n    {\n\tnegative = TRUE;\n\t++ptr;\n    }\n\n    // Recognize hex, octal, and bin.\n    if (ptr[0] == '0' && ptr[1] != '8' && ptr[1] != '9'\n\t\t\t\t\t       && (maxlen == 0 || maxlen > 1))\n    {\n\tpre = ptr[1];\n\tif ((what & STR2NR_HEX)\n\t\t&& (pre == 'X' || pre == 'x') && vim_isxdigit(ptr[2])\n\t\t&& (maxlen == 0 || maxlen > 2))\n\t    // hexadecimal\n\t    ptr += 2;\n\telse if ((what & STR2NR_BIN)\n\t\t&& (pre == 'B' || pre == 'b') && vim_isbdigit(ptr[2])\n\t\t&& (maxlen == 0 || maxlen > 2))\n\t    // binary\n\t    ptr += 2;\n\telse if ((what & STR2NR_OOCT)\n\t\t&& (pre == 'O' || pre == 'o') && vim_isodigit(ptr[2])\n\t\t&& (maxlen == 0 || maxlen > 2))\n\t    // octal with prefix \"0o\"\n\t    ptr += 2;\n\telse\n\t{\n\t    // decimal or octal, default is decimal\n\t    pre = 0;\n\t    if (what & STR2NR_OCT)\n\t    {\n\t\t// Don't interpret \"0\", \"08\" or \"0129\" as octal.\n\t\tfor (n = 1; n != maxlen && VIM_ISDIGIT(ptr[n]); ++n)\n\t\t{\n\t\t    if (ptr[n] > '7')\n\t\t    {\n\t\t\tpre = 0;\t// can't be octal\n\t\t\tbreak;\n\t\t    }\n\t\t    pre = '0';\t// assume octal\n\t\t}\n\t    }\n\t}\n    }\n\n    // Do the conversion manually to avoid sscanf() quirks.\n    n = 1;\n    if (pre == 'B' || pre == 'b'\n\t\t\t     || ((what & STR2NR_BIN) && (what & STR2NR_FORCE)))\n    {\n\t// bin\n\tif (pre != 0)\n\t    n += 2;\t    // skip over \"0b\"\n\twhile ('0' <= *ptr && *ptr <= '1')\n\t{\n\t    // avoid ubsan error for overflow\n\t    if (un <= UVARNUM_MAX / 2)\n\t\tun = 2 * un + (uvarnumber_T)(*ptr - '0');\n\t    else\n\t\tun = UVARNUM_MAX;\n\t    ++ptr;\n\t    if (n++ == maxlen)\n\t\tbreak;\n\t    if ((what & STR2NR_QUOTE) && *ptr == '\\''\n\t\t\t\t\t     && '0' <= ptr[1] && ptr[1] <= '1')\n\t    {\n\t\t++ptr;\n\t\tif (n++ == maxlen)\n\t\t    break;\n\t    }\n\t}\n    }\n    else if (pre == 'O' || pre == 'o' ||\n\t\tpre == '0' || ((what & STR2NR_OCT) && (what & STR2NR_FORCE)))\n    {\n\t// octal\n\tif (pre != 0 && pre != '0')\n\t    n += 2;\t    // skip over \"0o\"\n\twhile ('0' <= *ptr && *ptr <= '7')\n\t{\n\t    // avoid ubsan error for overflow\n\t    if (un <= UVARNUM_MAX / 8)\n\t\tun = 8 * un + (uvarnumber_T)(*ptr - '0');\n\t    else\n\t\tun = UVARNUM_MAX;\n\t    ++ptr;\n\t    if (n++ == maxlen)\n\t\tbreak;\n\t    if ((what & STR2NR_QUOTE) && *ptr == '\\''\n\t\t\t\t\t     && '0' <= ptr[1] && ptr[1] <= '7')\n\t    {\n\t\t++ptr;\n\t\tif (n++ == maxlen)\n\t\t    break;\n\t    }\n\t}\n    }\n    else if (pre != 0 || ((what & STR2NR_HEX) && (what & STR2NR_FORCE)))\n    {\n\t// hex\n\tif (pre != 0)\n\t    n += 2;\t    // skip over \"0x\"\n\twhile (vim_isxdigit(*ptr))\n\t{\n\t    // avoid ubsan error for overflow\n\t    if (un <= UVARNUM_MAX / 16)\n\t\tun = 16 * un + (uvarnumber_T)hex2nr(*ptr);\n\t    else\n\t\tun = UVARNUM_MAX;\n\t    ++ptr;\n\t    if (n++ == maxlen)\n\t\tbreak;\n\t    if ((what & STR2NR_QUOTE) && *ptr == '\\'' && vim_isxdigit(ptr[1]))\n\t    {\n\t\t++ptr;\n\t\tif (n++ == maxlen)\n\t\t    break;\n\t    }\n\t}\n    }\n    else\n    {\n\t// decimal\n\twhile (VIM_ISDIGIT(*ptr))\n\t{\n\t    uvarnumber_T    digit = (uvarnumber_T)(*ptr - '0');\n\n\t    // avoid ubsan error for overflow\n\t    if (un < UVARNUM_MAX / 10\n\t\t    || (un == UVARNUM_MAX / 10 && digit <= UVARNUM_MAX % 10))\n\t\tun = 10 * un + digit;\n\t    else\n\t\tun = UVARNUM_MAX;\n\t    ++ptr;\n\t    if (n++ == maxlen)\n\t\tbreak;\n\t    if ((what & STR2NR_QUOTE) && *ptr == '\\'' && VIM_ISDIGIT(ptr[1]))\n\t    {\n\t\t++ptr;\n\t\tif (n++ == maxlen)\n\t\t    break;\n\t    }\n\t}\n    }\n\n    // Check for an alphanumeric character immediately following, that is\n    // most likely a typo.\n    if (strict && n - 1 != maxlen && ASCII_ISALNUM(*ptr))\n\treturn;\n\n    if (prep != NULL)\n\t*prep = pre;\n    if (len != NULL)\n\t*len = (int)(ptr - start);\n    if (nptr != NULL)\n    {\n\tif (negative)   // account for leading '-' for decimal numbers\n\t{\n\t    // avoid ubsan error for overflow\n\t    if (un > VARNUM_MAX)\n\t\t*nptr = VARNUM_MIN;\n\t    else\n\t\t*nptr = -(varnumber_T)un;\n\t}\n\telse\n\t{\n\t    if (un > VARNUM_MAX)\n\t\tun = VARNUM_MAX;\n\t    *nptr = (varnumber_T)un;\n\t}\n    }\n    if (unptr != NULL)\n\t*unptr = un;\n}\n\n/*\n * Return the value of a single hex character.\n * Only valid when the argument is '0' - '9', 'A' - 'F' or 'a' - 'f'.\n */\n    int\nhex2nr(int c)\n{\n    if (c >= 'a' && c <= 'f')\n\treturn c - 'a' + 10;\n    if (c >= 'A' && c <= 'F')\n\treturn c - 'A' + 10;\n    return c - '0';\n}\n\n/*\n * Convert two hex characters to a byte.\n * Return -1 if one of the characters is not hex.\n */\n    int\nhexhex2nr(char_u *p)\n{\n    if (!vim_isxdigit(p[0]) || !vim_isxdigit(p[1]))\n\treturn -1;\n    return (hex2nr(p[0]) << 4) + hex2nr(p[1]);\n}\n\n/*\n * Return TRUE if \"str\" starts with a backslash that should be removed.\n * For MS-DOS, MSWIN and OS/2 this is only done when the character after the\n * backslash is not a normal file name character.\n * '$' is a valid file name character, we don't remove the backslash before\n * it.  This means it is not possible to use an environment variable after a\n * backslash.  \"C:\\$VIM\\doc\" is taken literally, only \"$VIM\\doc\" works.\n * Although \"\\ name\" is valid, the backslash in \"Program\\ files\" must be\n * removed.  Assume a file name doesn't start with a space.\n * For multi-byte names, never remove a backslash before a non-ascii\n * character, assume that all multi-byte characters are valid file name\n * characters.\n */\n    int\nrem_backslash(char_u *str)\n{\n#ifdef BACKSLASH_IN_FILENAME\n    return (str[0] == '\\\\'\n\t    && str[1] < 0x80\n\t    && (str[1] == ' '\n\t\t|| (str[1] != NUL\n\t\t    && str[1] != '*'\n\t\t    && str[1] != '?'\n\t\t    && !vim_isfilec(str[1]))));\n#else\n    return (str[0] == '\\\\' && str[1] != NUL);\n#endif\n}\n\n/*\n * Halve the number of backslashes in a file name argument.\n * For MS-DOS we only do this if the character after the backslash\n * is not a normal file character.\n */\n    void\nbackslash_halve(char_u *p)\n{\n    for ( ; *p; ++p)\n\tif (rem_backslash(p))\n\t    STRMOVE(p, p + 1);\n}\n\n/*\n * backslash_halve() plus save the result in allocated memory.\n * However, returns \"p\" when out of memory.\n */\n    char_u *\nbackslash_halve_save(char_u *p)\n{\n    char_u\t*res;\n\n    res = vim_strsave(p);\n    if (res == NULL)\n\treturn p;\n    backslash_halve(res);\n    return res;\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * filepath.c: dealing with file names and paths.\n */\n\n#include \"vim.h\"\n\n#ifdef MSWIN\n/*\n * Functions for \":8\" filename modifier: get 8.3 version of a filename.\n */\n\n/*\n * Get the short path (8.3) for the filename in \"fnamep\".\n * Only works for a valid file name.\n * When the path gets longer \"fnamep\" is changed and the allocated buffer\n * is put in \"bufp\".\n * *fnamelen is the length of \"fnamep\" and set to 0 for a nonexistent path.\n * Returns OK on success, FAIL on failure.\n */\n    static int\nget_short_pathname(char_u **fnamep, char_u **bufp, int *fnamelen)\n{\n    int\t\tl, len;\n    WCHAR\t*newbuf;\n    WCHAR\t*wfname;\n\n    len = MAXPATHL;\n    newbuf = malloc(len * sizeof(*newbuf));\n    if (newbuf == NULL)\n\treturn FAIL;\n\n    wfname = enc_to_utf16(*fnamep, NULL);\n    if (wfname == NULL)\n    {\n\tvim_free(newbuf);\n\treturn FAIL;\n    }\n\n    l = GetShortPathNameW(wfname, newbuf, len);\n    if (l > len - 1)\n    {\n\t// If that doesn't work (not enough space), then save the string\n\t// and try again with a new buffer big enough.\n\tWCHAR *newbuf_t = newbuf;\n\tnewbuf = vim_realloc(newbuf, (l + 1) * sizeof(*newbuf));\n\tif (newbuf == NULL)\n\t{\n\t    vim_free(wfname);\n\t    vim_free(newbuf_t);\n\t    return FAIL;\n\t}\n\t// Really should always succeed, as the buffer is big enough.\n\tl = GetShortPathNameW(wfname, newbuf, l+1);\n    }\n    if (l != 0)\n    {\n\tchar_u *p = utf16_to_enc(newbuf, NULL);\n\n\tif (p != NULL)\n\t{\n\t    vim_free(*bufp);\n\t    *fnamep = *bufp = p;\n\t}\n\telse\n\t{\n\t    vim_free(wfname);\n\t    vim_free(newbuf);\n\t    return FAIL;\n\t}\n    }\n    vim_free(wfname);\n    vim_free(newbuf);\n\n    *fnamelen = l == 0 ? l : (int)STRLEN(*bufp);\n    return OK;\n}\n\n/*\n * Get the short path (8.3) for the filename in \"fname\". The converted\n * path is returned in \"bufp\".\n *\n * Some of the directories specified in \"fname\" may not exist. This function\n * will shorten the existing directories at the beginning of the path and then\n * append the remaining non-existing path.\n *\n * fname - Pointer to the filename to shorten.  On return, contains the\n *\t   pointer to the shortened pathname\n * bufp -  Pointer to an allocated buffer for the filename.\n * fnamelen - Length of the filename pointed to by fname\n *\n * Returns OK on success (or nothing done) and FAIL on failure (out of memory).\n */\n    static int\nshortpath_for_invalid_fname(\n    char_u\t**fname,\n    char_u\t**bufp,\n    int\t\t*fnamelen)\n{\n    char_u\t*short_fname, *save_fname, *pbuf_unused;\n    char_u\t*endp, *save_endp;\n    char_u\tch;\n    int\t\told_len, len;\n    int\t\tnew_len, sfx_len;\n    int\t\tretval = OK;\n\n    // Make a copy\n    old_len = *fnamelen;\n    save_fname = vim_strnsave(*fname, old_len);\n    pbuf_unused = NULL;\n    short_fname = NULL;\n\n    endp = save_fname + old_len - 1; // Find the end of the copy\n    save_endp = endp;\n\n    /*\n     * Try shortening the supplied path till it succeeds by removing one\n     * directory at a time from the tail of the path.\n     */\n    len = 0;\n    for (;;)\n    {\n\t// go back one path-separator\n\twhile (endp > save_fname && !after_pathsep(save_fname, endp + 1))\n\t    --endp;\n\tif (endp <= save_fname)\n\t    break;\t\t// processed the complete path\n\n\t/*\n\t * Replace the path separator with a NUL and try to shorten the\n\t * resulting path.\n\t */\n\tch = *endp;\n\t*endp = 0;\n\tshort_fname = save_fname;\n\tlen = (int)STRLEN(short_fname) + 1;\n\tif (get_short_pathname(&short_fname, &pbuf_unused, &len) == FAIL)\n\t{\n\t    retval = FAIL;\n\t    goto theend;\n\t}\n\t*endp = ch;\t// preserve the string\n\n\tif (len > 0)\n\t    break;\t// successfully shortened the path\n\n\t// failed to shorten the path. Skip the path separator\n\t--endp;\n    }\n\n    if (len > 0)\n    {\n\t/*\n\t * Succeeded in shortening the path. Now concatenate the shortened\n\t * path with the remaining path at the tail.\n\t */\n\n\t// Compute the length of the new path.\n\tsfx_len = (int)(save_endp - endp) + 1;\n\tnew_len = len + sfx_len;\n\n\t*fnamelen = new_len;\n\tvim_free(*bufp);\n\tif (new_len > old_len)\n\t{\n\t    // There is not enough space in the currently allocated string,\n\t    // copy it to a buffer big enough.\n\t    *fname = *bufp = vim_strnsave(short_fname, new_len);\n\t    if (*fname == NULL)\n\t    {\n\t\tretval = FAIL;\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    // Transfer short_fname to the main buffer (it's big enough),\n\t    // unless get_short_pathname() did its work in-place.\n\t    *fname = *bufp = save_fname;\n\t    if (short_fname != save_fname)\n\t\tvim_strncpy(save_fname, short_fname, len);\n\t    save_fname = NULL;\n\t}\n\n\t// concat the not-shortened part of the path\n\tvim_strncpy(*fname + len, endp, sfx_len);\n\t(*fname)[new_len] = NUL;\n    }\n\ntheend:\n    vim_free(pbuf_unused);\n    vim_free(save_fname);\n\n    return retval;\n}\n\n/*\n * Get a pathname for a partial path.\n * Returns OK for success, FAIL for failure.\n */\n    static int\nshortpath_for_partial(\n    char_u\t**fnamep,\n    char_u\t**bufp,\n    int\t\t*fnamelen)\n{\n    int\t\tsepcount, len, tflen;\n    char_u\t*p;\n    char_u\t*pbuf, *tfname;\n    int\t\thasTilde;\n\n    // Count up the path separators from the RHS.. so we know which part\n    // of the path to return.\n    sepcount = 0;\n    for (p = *fnamep; p < *fnamep + *fnamelen; MB_PTR_ADV(p))\n\tif (vim_ispathsep(*p))\n\t    ++sepcount;\n\n    // Need full path first (use expand_env() to remove a \"~/\")\n    hasTilde = (**fnamep == '~');\n    if (hasTilde)\n\tpbuf = tfname = expand_env_save(*fnamep);\n    else\n\tpbuf = tfname = FullName_save(*fnamep, FALSE);\n\n    len = tflen = (int)STRLEN(tfname);\n\n    if (get_short_pathname(&tfname, &pbuf, &len) == FAIL)\n\treturn FAIL;\n\n    if (len == 0)\n    {\n\t// Don't have a valid filename, so shorten the rest of the\n\t// path if we can. This CAN give us invalid 8.3 filenames, but\n\t// there's not a lot of point in guessing what it might be.\n\tlen = tflen;\n\tif (shortpath_for_invalid_fname(&tfname, &pbuf, &len) == FAIL)\n\t    return FAIL;\n    }\n\n    // Count the paths backward to find the beginning of the desired string.\n    for (p = tfname + len - 1; p >= tfname; --p)\n    {\n\tif (has_mbyte)\n\t    p -= mb_head_off(tfname, p);\n\tif (vim_ispathsep(*p))\n\t{\n\t    if (sepcount == 0 || (hasTilde && sepcount == 1))\n\t\tbreak;\n\t    else\n\t\tsepcount --;\n\t}\n    }\n    if (hasTilde)\n    {\n\t--p;\n\tif (p >= tfname)\n\t    *p = '~';\n\telse\n\t    return FAIL;\n    }\n    else\n\t++p;\n\n    // Copy in the string - p indexes into tfname - allocated at pbuf\n    vim_free(*bufp);\n    *fnamelen = (int)STRLEN(p);\n    *bufp = pbuf;\n    *fnamep = p;\n\n    return OK;\n}\n#endif // MSWIN\n\n/*\n * Adjust a filename, according to a string of modifiers.\n * *fnamep must be NUL terminated when called.  When returning, the length is\n * determined by *fnamelen.\n * Returns VALID_ flags or -1 for failure.\n * When there is an error, *fnamep is set to NULL.\n */\n    int\nmodify_fname(\n    char_u\t*src,\t\t// string with modifiers\n    int\t\ttilde_file,\t// \"~\" is a file name, not $HOME\n    int\t\t*usedlen,\t// characters after src that are used\n    char_u\t**fnamep,\t// file name so far\n    char_u\t**bufp,\t\t// buffer for allocated file name or NULL\n    int\t\t*fnamelen)\t// length of fnamep\n{\n    int\t\tvalid = 0;\n    char_u\t*tail;\n    char_u\t*s, *p, *pbuf;\n    char_u\tdirname[MAXPATHL];\n    int\t\tc;\n    int\t\thas_fullname = 0;\n    int\t\thas_homerelative = 0;\n#ifdef MSWIN\n    char_u\t*fname_start = *fnamep;\n    int\t\thas_shortname = 0;\n#endif\n\nrepeat:\n    // \":p\" - full path/file_name\n    if (src[*usedlen] == ':' && src[*usedlen + 1] == 'p')\n    {\n\thas_fullname = 1;\n\n\tvalid |= VALID_PATH;\n\t*usedlen += 2;\n\n\t// Expand \"~/path\" for all systems and \"~user/path\" for Unix and VMS\n\tif ((*fnamep)[0] == '~'\n#if !defined(UNIX) && !(defined(VMS) && defined(USER_HOME))\n\t\t&& ((*fnamep)[1] == '/'\n# ifdef BACKSLASH_IN_FILENAME\n\t\t    || (*fnamep)[1] == '\\\\'\n# endif\n\t\t    || (*fnamep)[1] == NUL)\n#endif\n\t\t&& !(tilde_file && (*fnamep)[1] == NUL)\n\t   )\n\t{\n\t    *fnamep = expand_env_save(*fnamep);\n\t    vim_free(*bufp);\t// free any allocated file name\n\t    *bufp = *fnamep;\n\t    if (*fnamep == NULL)\n\t\treturn -1;\n\t}\n\n\t// When \"/.\" or \"/..\" is used: force expansion to get rid of it.\n\tfor (p = *fnamep; *p != NUL; MB_PTR_ADV(p))\n\t{\n\t    if (vim_ispathsep(*p)\n\t\t    && p[1] == '.'\n\t\t    && (p[2] == NUL\n\t\t\t|| vim_ispathsep(p[2])\n\t\t\t|| (p[2] == '.'\n\t\t\t    && (p[3] == NUL || vim_ispathsep(p[3])))))\n\t\tbreak;\n\t}\n\n\t// FullName_save() is slow, don't use it when not needed.\n\tif (*p != NUL || !vim_isAbsName(*fnamep))\n\t{\n\t    *fnamep = FullName_save(*fnamep, *p != NUL);\n\t    vim_free(*bufp);\t// free any allocated file name\n\t    *bufp = *fnamep;\n\t    if (*fnamep == NULL)\n\t\treturn -1;\n\t}\n\n#ifdef MSWIN\n# if _WIN32_WINNT >= 0x0500\n\tif (vim_strchr(*fnamep, '~') != NULL)\n\t{\n\t    // Expand 8.3 filename to full path.  Needed to make sure the same\n\t    // file does not have two different names.\n\t    // Note: problem does not occur if _WIN32_WINNT < 0x0500.\n\t    WCHAR *wfname = enc_to_utf16(*fnamep, NULL);\n\t    WCHAR buf[_MAX_PATH];\n\n\t    if (wfname != NULL)\n\t    {\n\t\tif (GetLongPathNameW(wfname, buf, _MAX_PATH))\n\t\t{\n\t\t    char_u *q = utf16_to_enc(buf, NULL);\n\n\t\t    if (q != NULL)\n\t\t    {\n\t\t\tvim_free(*bufp);    // free any allocated file name\n\t\t\t*bufp = *fnamep = q;\n\t\t    }\n\t\t}\n\t\tvim_free(wfname);\n\t    }\n\t}\n# endif\n#endif\n\t// Append a path separator to a directory.\n\tif (mch_isdir(*fnamep))\n\t{\n\t    // Make room for one or two extra characters.\n\t    *fnamep = vim_strnsave(*fnamep, STRLEN(*fnamep) + 2);\n\t    vim_free(*bufp);\t// free any allocated file name\n\t    *bufp = *fnamep;\n\t    if (*fnamep == NULL)\n\t\treturn -1;\n\t    add_pathsep(*fnamep);\n\t}\n    }\n\n    // \":.\" - path relative to the current directory\n    // \":~\" - path relative to the home directory\n    // \":8\" - shortname path - postponed till after\n    while (src[*usedlen] == ':'\n\t\t  && ((c = src[*usedlen + 1]) == '.' || c == '~' || c == '8'))\n    {\n\t*usedlen += 2;\n\tif (c == '8')\n\t{\n#ifdef MSWIN\n\t    has_shortname = 1; // Postpone this.\n#endif\n\t    continue;\n\t}\n\tpbuf = NULL;\n\t// Need full path first (use expand_env() to remove a \"~/\")\n\tif (!has_fullname && !has_homerelative)\n\t{\n\t    if (**fnamep == '~')\n\t\tp = pbuf = expand_env_save(*fnamep);\n\t    else\n\t\tp = pbuf = FullName_save(*fnamep, FALSE);\n\t}\n\telse\n\t    p = *fnamep;\n\n\thas_fullname = 0;\n\n\tif (p != NULL)\n\t{\n\t    if (c == '.')\n\t    {\n\t\tsize_t\tnamelen;\n\n\t\tmch_dirname(dirname, MAXPATHL);\n\t\tif (has_homerelative)\n\t\t{\n\t\t    s = vim_strsave(dirname);\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\thome_replace(NULL, s, dirname, MAXPATHL, TRUE);\n\t\t\tvim_free(s);\n\t\t    }\n\t\t}\n\t\tnamelen = STRLEN(dirname);\n\n\t\t// Do not call shorten_fname() here since it removes the prefix\n\t\t// even though the path does not have a prefix.\n\t\tif (fnamencmp(p, dirname, namelen) == 0)\n\t\t{\n\t\t    p += namelen;\n\t\t    if (vim_ispathsep(*p))\n\t\t    {\n\t\t\twhile (*p && vim_ispathsep(*p))\n\t\t\t    ++p;\n\t\t\t*fnamep = p;\n\t\t\tif (pbuf != NULL)\n\t\t\t{\n\t\t\t    // free any allocated file name\n\t\t\t    vim_free(*bufp);\n\t\t\t    *bufp = pbuf;\n\t\t\t    pbuf = NULL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\thome_replace(NULL, p, dirname, MAXPATHL, TRUE);\n\t\t// Only replace it when it starts with '~'\n\t\tif (*dirname == '~')\n\t\t{\n\t\t    s = vim_strsave(dirname);\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\t*fnamep = s;\n\t\t\tvim_free(*bufp);\n\t\t\t*bufp = s;\n\t\t\thas_homerelative = TRUE;\n\t\t    }\n\t\t}\n\t    }\n\t    vim_free(pbuf);\n\t}\n    }\n\n    tail = gettail(*fnamep);\n    *fnamelen = (int)STRLEN(*fnamep);\n\n    // \":h\" - head, remove \"/file_name\", can be repeated\n    // Don't remove the first \"/\" or \"c:\\\"\n    while (src[*usedlen] == ':' && src[*usedlen + 1] == 'h')\n    {\n\tvalid |= VALID_HEAD;\n\t*usedlen += 2;\n\ts = get_past_head(*fnamep);\n\twhile (tail > s && after_pathsep(s, tail))\n\t    MB_PTR_BACK(*fnamep, tail);\n\t*fnamelen = (int)(tail - *fnamep);\n#ifdef VMS\n\tif (*fnamelen > 0)\n\t    *fnamelen += 1; // the path separator is part of the path\n#endif\n\tif (*fnamelen == 0)\n\t{\n\t    // Result is empty.  Turn it into \".\" to make \":cd %:h\" work.\n\t    p = vim_strsave((char_u *)\".\");\n\t    if (p == NULL)\n\t\treturn -1;\n\t    vim_free(*bufp);\n\t    *bufp = *fnamep = tail = p;\n\t    *fnamelen = 1;\n\t}\n\telse\n\t{\n\t    while (tail > s && !after_pathsep(s, tail))\n\t\tMB_PTR_BACK(*fnamep, tail);\n\t}\n    }\n\n    // \":8\" - shortname\n    if (src[*usedlen] == ':' && src[*usedlen + 1] == '8')\n    {\n\t*usedlen += 2;\n#ifdef MSWIN\n\thas_shortname = 1;\n#endif\n    }\n\n#ifdef MSWIN\n    /*\n     * Handle \":8\" after we have done 'heads' and before we do 'tails'.\n     */\n    if (has_shortname)\n    {\n\t// Copy the string if it is shortened by :h and when it wasn't copied\n\t// yet, because we are going to change it in place.  Avoids changing\n\t// the buffer name for \"%:8\".\n\tif (*fnamelen < (int)STRLEN(*fnamep) || *fnamep == fname_start)\n\t{\n\t    p = vim_strnsave(*fnamep, *fnamelen);\n\t    if (p == NULL)\n\t\treturn -1;\n\t    vim_free(*bufp);\n\t    *bufp = *fnamep = p;\n\t}\n\n\t// Split into two implementations - makes it easier.  First is where\n\t// there isn't a full name already, second is where there is.\n\tif (!has_fullname && !vim_isAbsName(*fnamep))\n\t{\n\t    if (shortpath_for_partial(fnamep, bufp, fnamelen) == FAIL)\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t    int\t\tl = *fnamelen;\n\n\t    // Simple case, already have the full-name.\n\t    // Nearly always shorter, so try first time.\n\t    if (get_short_pathname(fnamep, bufp, &l) == FAIL)\n\t\treturn -1;\n\n\t    if (l == 0)\n\t    {\n\t\t// Couldn't find the filename, search the paths.\n\t\tl = *fnamelen;\n\t\tif (shortpath_for_invalid_fname(fnamep, bufp, &l) == FAIL)\n\t\t    return -1;\n\t    }\n\t    *fnamelen = l;\n\t}\n    }\n#endif // MSWIN\n\n    // \":t\" - tail, just the basename\n    if (src[*usedlen] == ':' && src[*usedlen + 1] == 't')\n    {\n\t*usedlen += 2;\n\t*fnamelen -= (int)(tail - *fnamep);\n\t*fnamep = tail;\n    }\n\n    // \":e\" - extension, can be repeated\n    // \":r\" - root, without extension, can be repeated\n    while (src[*usedlen] == ':'\n\t    && (src[*usedlen + 1] == 'e' || src[*usedlen + 1] == 'r'))\n    {\n\t// find a '.' in the tail:\n\t// - for second :e: before the current fname\n\t// - otherwise: The last '.'\n\tif (src[*usedlen + 1] == 'e' && *fnamep > tail)\n\t    s = *fnamep - 2;\n\telse\n\t    s = *fnamep + *fnamelen - 1;\n\tfor ( ; s > tail; --s)\n\t    if (s[0] == '.')\n\t\tbreak;\n\tif (src[*usedlen + 1] == 'e')\t\t// :e\n\t{\n\t    if (s > tail)\n\t    {\n\t\t*fnamelen += (int)(*fnamep - (s + 1));\n\t\t*fnamep = s + 1;\n#ifdef VMS\n\t\t// cut version from the extension\n\t\ts = *fnamep + *fnamelen - 1;\n\t\tfor ( ; s > *fnamep; --s)\n\t\t    if (s[0] == ';')\n\t\t\tbreak;\n\t\tif (s > *fnamep)\n\t\t    *fnamelen = s - *fnamep;\n#endif\n\t    }\n\t    else if (*fnamep <= tail)\n\t\t*fnamelen = 0;\n\t}\n\telse\t\t\t\t// :r\n\t{\n\t    char_u *limit = *fnamep;\n\n\t    if (limit < tail)\n\t\tlimit = tail;\n\t    if (s > limit)\t// remove one extension\n\t\t*fnamelen = (int)(s - *fnamep);\n\t}\n\t*usedlen += 2;\n    }\n\n    // \":s?pat?foo?\" - substitute\n    // \":gs?pat?foo?\" - global substitute\n    if (src[*usedlen] == ':'\n\t    && (src[*usedlen + 1] == 's'\n\t\t|| (src[*usedlen + 1] == 'g' && src[*usedlen + 2] == 's')))\n    {\n\tchar_u\t    *str;\n\tchar_u\t    *pat;\n\tchar_u\t    *sub;\n\tint\t    sep;\n\tchar_u\t    *flags;\n\tint\t    didit = FALSE;\n\n\tflags = (char_u *)\"\";\n\ts = src + *usedlen + 2;\n\tif (src[*usedlen + 1] == 'g')\n\t{\n\t    flags = (char_u *)\"g\";\n\t    ++s;\n\t}\n\n\tsep = *s++;\n\tif (sep)\n\t{\n\t    // find end of pattern\n\t    p = vim_strchr(s, sep);\n\t    if (p != NULL)\n\t    {\n\t\tpat = vim_strnsave(s, p - s);\n\t\tif (pat != NULL)\n\t\t{\n\t\t    s = p + 1;\n\t\t    // find end of substitution\n\t\t    p = vim_strchr(s, sep);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tsub = vim_strnsave(s, p - s);\n\t\t\tstr = vim_strnsave(*fnamep, *fnamelen);\n\t\t\tif (sub != NULL && str != NULL)\n\t\t\t{\n\t\t\t    *usedlen = (int)(p + 1 - src);\n\t\t\t    s = do_string_sub(str, pat, sub, NULL, flags);\n\t\t\t    if (s != NULL)\n\t\t\t    {\n\t\t\t\t*fnamep = s;\n\t\t\t\t*fnamelen = (int)STRLEN(s);\n\t\t\t\tvim_free(*bufp);\n\t\t\t\t*bufp = s;\n\t\t\t\tdidit = TRUE;\n\t\t\t    }\n\t\t\t}\n\t\t\tvim_free(sub);\n\t\t\tvim_free(str);\n\t\t    }\n\t\t    vim_free(pat);\n\t\t}\n\t    }\n\t    // after using \":s\", repeat all the modifiers\n\t    if (didit)\n\t\tgoto repeat;\n\t}\n    }\n\n    if (src[*usedlen] == ':' && src[*usedlen + 1] == 'S')\n    {\n\t// vim_strsave_shellescape() needs a NUL terminated string.\n\tc = (*fnamep)[*fnamelen];\n\tif (c != NUL)\n\t    (*fnamep)[*fnamelen] = NUL;\n\tp = vim_strsave_shellescape(*fnamep, FALSE, FALSE);\n\tif (c != NUL)\n\t    (*fnamep)[*fnamelen] = c;\n\tif (p == NULL)\n\t    return -1;\n\tvim_free(*bufp);\n\t*bufp = *fnamep = p;\n\t*fnamelen = (int)STRLEN(p);\n\t*usedlen += 2;\n    }\n\n    return valid;\n}\n\n/*\n * Shorten the path of a file from \"~/foo/../.bar/fname\" to \"~/f/../.b/fname\"\n * \"trim_len\" specifies how many characters to keep for each directory.\n * Must be 1 or more.\n * It's done in-place.\n */\n    static void\nshorten_dir_len(char_u *str, int trim_len)\n{\n    char_u\t*tail, *s, *d;\n    int\t\tskip = FALSE;\n    int\t\tdirchunk_len = 0;\n\n    tail = gettail(str);\n    d = str;\n    for (s = str; ; ++s)\n    {\n\tif (s >= tail)\t\t    // copy the whole tail\n\t{\n\t    *d++ = *s;\n\t    if (*s == NUL)\n\t\tbreak;\n\t}\n\telse if (vim_ispathsep(*s))\t    // copy '/' and next char\n\t{\n\t    *d++ = *s;\n\t    skip = FALSE;\n\t    dirchunk_len = 0;\n\t}\n\telse if (!skip)\n\t{\n\t    *d++ = *s;\t\t\t// copy next char\n\t    if (*s != '~' && *s != '.') // and leading \"~\" and \".\"\n\t    {\n\t\t++dirchunk_len; // only count word chars for the size\n\n\t\t// keep copying chars until we have our preferred length (or\n\t\t// until the above if/else branches move us along)\n\t\tif (dirchunk_len >= trim_len)\n\t\t    skip = TRUE;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tint l = mb_ptr2len(s);\n\n\t\twhile (--l > 0)\n\t\t    *d++ = *++s;\n\t    }\n\t}\n    }\n}\n\n/*\n * Shorten the path of a file from \"~/foo/../.bar/fname\" to \"~/f/../.b/fname\"\n * It's done in-place.\n */\n    void\nshorten_dir(char_u *str)\n{\n    shorten_dir_len(str, 1);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * \"chdir(dir)\" function\n */\n    void\nf_chdir(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*cwd;\n    cdscope_T\tscope = CDSCOPE_GLOBAL;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (argvars[0].v_type != VAR_STRING)\n    {\n\t// Returning an empty string means it failed.\n\t// No error message, for historic reasons.\n\tif (in_vim9script())\n\t    (void) check_for_string_arg(argvars, 0);\n\treturn;\n    }\n\n    // Return the current directory\n    cwd = alloc(MAXPATHL);\n    if (cwd != NULL)\n    {\n\tif (mch_dirname(cwd, MAXPATHL) != FAIL)\n\t{\n#ifdef BACKSLASH_IN_FILENAME\n\t    slash_adjust(cwd);\n#endif\n\t    rettv->vval.v_string = vim_strsave(cwd);\n\t}\n\tvim_free(cwd);\n    }\n\n    if (curwin->w_localdir != NULL)\n\tscope = CDSCOPE_WINDOW;\n    else if (curtab->tp_localdir != NULL)\n\tscope = CDSCOPE_TABPAGE;\n\n    if (!changedir_func(argvars[0].vval.v_string, TRUE, scope))\n\t// Directory change failed\n\tVIM_CLEAR(rettv->vval.v_string);\n}\n\n/*\n * \"delete()\" function\n */\n    void\nf_delete(typval_T *argvars, typval_T *rettv)\n{\n    char_u\tnbuf[NUMBUFLEN];\n    char_u\t*name;\n    char_u\t*flags;\n\n    rettv->vval.v_number = -1;\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    name = tv_get_string(&argvars[0]);\n    if (name == NULL || *name == NUL)\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n\tflags = tv_get_string_buf(&argvars[1], nbuf);\n    else\n\tflags = (char_u *)\"\";\n\n    if (*flags == NUL)\n\t// delete a file\n\trettv->vval.v_number = mch_remove(name) == 0 ? 0 : -1;\n    else if (STRCMP(flags, \"d\") == 0)\n\t// delete an empty directory\n\trettv->vval.v_number = mch_rmdir(name) == 0 ? 0 : -1;\n    else if (STRCMP(flags, \"rf\") == 0)\n\t// delete a directory recursively\n\trettv->vval.v_number = delete_recursive(name);\n    else\n\tsemsg(_(e_invalid_expression_str), flags);\n}\n\n/*\n * \"executable()\" function\n */\n    void\nf_executable(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    // Check in $PATH and also check directly if there is a directory name.\n    rettv->vval.v_number = mch_can_exe(tv_get_string(&argvars[0]), NULL, TRUE);\n}\n\n/*\n * \"exepath()\" function\n */\n    void\nf_exepath(typval_T *argvars, typval_T *rettv)\n{\n    char_u *p = NULL;\n\n    if (in_vim9script() && check_for_nonempty_string_arg(argvars, 0) == FAIL)\n\treturn;\n    (void)mch_can_exe(tv_get_string(&argvars[0]), &p, TRUE);\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = p;\n}\n\n/*\n * \"filereadable()\" function\n */\n    void\nf_filereadable(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tfd;\n    char_u\t*p;\n    int\t\tn;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n#ifndef O_NONBLOCK\n# define O_NONBLOCK 0\n#endif\n    p = tv_get_string(&argvars[0]);\n    if (*p && !mch_isdir(p) && (fd = mch_open((char *)p,\n\t\t\t\t\t      O_RDONLY | O_NONBLOCK, 0)) >= 0)\n    {\n\tn = TRUE;\n\tclose(fd);\n    }\n    else\n\tn = FALSE;\n\n    rettv->vval.v_number = n;\n}\n\n/*\n * Return 0 for not writable, 1 for writable file, 2 for a dir which we have\n * rights to write into.\n */\n    void\nf_filewritable(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n    rettv->vval.v_number = filewritable(tv_get_string(&argvars[0]));\n}\n\n    static void\nfindfilendir(\n    typval_T\t*argvars UNUSED,\n    typval_T\t*rettv,\n    int\t\tfind_what UNUSED)\n{\n#ifdef FEAT_SEARCHPATH\n    char_u\t*fname;\n    char_u\t*fresult = NULL;\n    char_u\t*path = *curbuf->b_p_path == NUL ? p_path : curbuf->b_p_path;\n    char_u\t*p;\n    char_u\tpathbuf[NUMBUFLEN];\n    int\t\tcount = 1;\n    int\t\tfirst = TRUE;\n    int\t\terror = FALSE;\n#endif\n\n    rettv->vval.v_string = NULL;\n    rettv->v_type = VAR_STRING;\n    if (in_vim9script()\n\t    && (check_for_nonempty_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_number_arg(argvars, 2) == FAIL)))\n\treturn;\n\n#ifdef FEAT_SEARCHPATH\n    fname = tv_get_string(&argvars[0]);\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tp = tv_get_string_buf_chk(&argvars[1], pathbuf);\n\tif (p == NULL)\n\t    error = TRUE;\n\telse\n\t{\n\t    if (*p != NUL)\n\t\tpath = p;\n\n\t    if (argvars[2].v_type != VAR_UNKNOWN)\n\t\tcount = (int)tv_get_number_chk(&argvars[2], &error);\n\t}\n    }\n\n    if (count < 0 && rettv_list_alloc(rettv) == FAIL)\n\terror = TRUE;\n\n    if (*fname != NUL && !error)\n    {\n\tdo\n\t{\n\t    if (rettv->v_type == VAR_STRING || rettv->v_type == VAR_LIST)\n\t\tvim_free(fresult);\n\t    fresult = find_file_in_path_option(first ? fname : NULL,\n\t\t\t\t\t       first ? (int)STRLEN(fname) : 0,\n\t\t\t\t\t0, first, path,\n\t\t\t\t\tfind_what,\n\t\t\t\t\tcurbuf->b_ffname,\n\t\t\t\t\tfind_what == FINDFILE_DIR\n\t\t\t\t\t    ? (char_u *)\"\" : curbuf->b_p_sua);\n\t    first = FALSE;\n\n\t    if (fresult != NULL && rettv->v_type == VAR_LIST)\n\t\tlist_append_string(rettv->vval.v_list, fresult, -1);\n\n\t} while ((rettv->v_type == VAR_LIST || --count > 0) && fresult != NULL);\n    }\n\n    if (rettv->v_type == VAR_STRING)\n\trettv->vval.v_string = fresult;\n#endif\n}\n\n/*\n * \"finddir({fname}[, {path}[, {count}]])\" function\n */\n    void\nf_finddir(typval_T *argvars, typval_T *rettv)\n{\n    findfilendir(argvars, rettv, FINDFILE_DIR);\n}\n\n/*\n * \"findfile({fname}[, {path}[, {count}]])\" function\n */\n    void\nf_findfile(typval_T *argvars, typval_T *rettv)\n{\n    findfilendir(argvars, rettv, FINDFILE_FILE);\n}\n\n/*\n * \"fnamemodify({fname}, {mods})\" function\n */\n    void\nf_fnamemodify(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*fname;\n    char_u\t*mods;\n    int\t\tusedlen = 0;\n    int\t\tlen = 0;\n    char_u\t*fbuf = NULL;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    fname = tv_get_string_chk(&argvars[0]);\n    mods = tv_get_string_buf_chk(&argvars[1], buf);\n    if (mods == NULL || fname == NULL)\n\tfname = NULL;\n    else\n    {\n\tlen = (int)STRLEN(fname);\n\tif (mods != NULL && *mods != NUL)\n\t    (void)modify_fname(mods, FALSE, &usedlen, &fname, &fbuf, &len);\n    }\n\n    rettv->v_type = VAR_STRING;\n    if (fname == NULL)\n\trettv->vval.v_string = NULL;\n    else\n\trettv->vval.v_string = vim_strnsave(fname, len);\n    vim_free(fbuf);\n}\n\n/*\n * \"getcwd()\" function\n *\n * Return the current working directory of a window in a tab page.\n * First optional argument 'winnr' is the window number or -1 and the second\n * optional argument 'tabnr' is the tab page number.\n *\n * If no arguments are supplied, then return the directory of the current\n * window.\n * If only 'winnr' is specified and is not -1 or 0 then return the directory of\n * the specified window.\n * If 'winnr' is 0 then return the directory of the current window.\n * If both 'winnr and 'tabnr' are specified and 'winnr' is -1 then return the\n * directory of the specified tab page.  Otherwise return the directory of the\n * specified window in the specified tab page.\n * If the window or the tab page doesn't exist then return NULL.\n */\n    void\nf_getcwd(typval_T *argvars, typval_T *rettv)\n{\n    win_T\t*wp = NULL;\n    tabpage_T\t*tp = NULL;\n    char_u\t*cwd;\n    int\t\tglobal = FALSE;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script()\n\t    && (check_for_opt_number_arg(argvars, 0) == FAIL\n\t\t|| (argvars[0].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_number_arg(argvars, 1) == FAIL)))\n\treturn;\n\n    if (argvars[0].v_type == VAR_NUMBER\n\t    && argvars[0].vval.v_number == -1\n\t    && argvars[1].v_type == VAR_UNKNOWN)\n\tglobal = TRUE;\n    else\n\twp = find_tabwin(&argvars[0], &argvars[1], &tp);\n\n    if (wp != NULL && wp->w_localdir != NULL\n\t\t\t\t\t   && argvars[0].v_type != VAR_UNKNOWN)\n\trettv->vval.v_string = vim_strsave(wp->w_localdir);\n    else if (tp != NULL && tp->tp_localdir != NULL\n\t\t\t\t\t   && argvars[0].v_type != VAR_UNKNOWN)\n\trettv->vval.v_string = vim_strsave(tp->tp_localdir);\n    else if (wp != NULL || tp != NULL || global)\n    {\n\tif (globaldir != NULL && argvars[0].v_type != VAR_UNKNOWN)\n\t    rettv->vval.v_string = vim_strsave(globaldir);\n\telse\n\t{\n\t    cwd = alloc(MAXPATHL);\n\t    if (cwd != NULL)\n\t    {\n\t\tif (mch_dirname(cwd, MAXPATHL) != FAIL)\n\t\t    rettv->vval.v_string = vim_strsave(cwd);\n\t\tvim_free(cwd);\n\t    }\n\t}\n    }\n#ifdef BACKSLASH_IN_FILENAME\n    if (rettv->vval.v_string != NULL)\n\tslash_adjust(rettv->vval.v_string);\n#endif\n}\n\n/*\n * Convert \"st\" to file permission string.\n */\n    char_u *\ngetfpermst(stat_T *st, char_u *perm)\n{\n    char_u\t    flags[] = \"rwx\";\n    int\t\t    i;\n\n    for (i = 0; i < 9; i++)\n    {\n\tif (st->st_mode & (1 << (8 - i)))\n\t    perm[i] = flags[i % 3];\n\telse\n\t    perm[i] = '-';\n    }\n    return perm;\n}\n\n/*\n * \"getfperm({fname})\" function\n */\n    void\nf_getfperm(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*fname;\n    stat_T\tst;\n    char_u\t*perm = NULL;\n    char_u\tpermbuf[] = \"---------\";\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    fname = tv_get_string(&argvars[0]);\n\n    rettv->v_type = VAR_STRING;\n    if (mch_stat((char *)fname, &st) >= 0)\n\tperm = vim_strsave(getfpermst(&st, permbuf));\n    rettv->vval.v_string = perm;\n}\n\n/*\n * \"getfsize({fname})\" function\n */\n    void\nf_getfsize(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*fname;\n    stat_T\tst;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    fname = tv_get_string(&argvars[0]);\n    if (mch_stat((char *)fname, &st) >= 0)\n    {\n\tif (mch_isdir(fname))\n\t    rettv->vval.v_number = 0;\n\telse\n\t{\n\t    rettv->vval.v_number = (varnumber_T)st.st_size;\n\n\t    // non-perfect check for overflow\n\t    if ((off_T)rettv->vval.v_number != (off_T)st.st_size)\n\t\trettv->vval.v_number = -2;\n\t}\n    }\n    else\n\t  rettv->vval.v_number = -1;\n}\n\n/*\n * \"getftime({fname})\" function\n */\n    void\nf_getftime(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*fname;\n    stat_T\tst;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    fname = tv_get_string(&argvars[0]);\n    if (mch_stat((char *)fname, &st) >= 0)\n\trettv->vval.v_number = (varnumber_T)st.st_mtime;\n    else\n\trettv->vval.v_number = -1;\n}\n\n/*\n * Convert \"st\" to file type string.\n */\n    char_u *\ngetftypest(stat_T *st)\n{\n    char    *t;\n\n    if (S_ISREG(st->st_mode))\n\tt = \"file\";\n    else if (S_ISDIR(st->st_mode))\n\tt = \"dir\";\n    else if (S_ISLNK(st->st_mode))\n\tt = \"link\";\n    else if (S_ISBLK(st->st_mode))\n\tt = \"bdev\";\n    else if (S_ISCHR(st->st_mode))\n\tt = \"cdev\";\n    else if (S_ISFIFO(st->st_mode))\n\tt = \"fifo\";\n    else if (S_ISSOCK(st->st_mode))\n\tt = \"socket\";\n    else\n\tt = \"other\";\n    return (char_u*)t;\n}\n\n/*\n * \"getftype({fname})\" function\n */\n    void\nf_getftype(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*fname;\n    stat_T\tst;\n    char_u\t*type = NULL;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    fname = tv_get_string(&argvars[0]);\n\n    rettv->v_type = VAR_STRING;\n    if (mch_lstat((char *)fname, &st) >= 0)\n\ttype = vim_strsave(getftypest(&st));\n    rettv->vval.v_string = type;\n}\n\n/*\n * \"glob()\" function\n */\n    void\nf_glob(typval_T *argvars, typval_T *rettv)\n{\n    int\t\toptions = WILD_SILENT|WILD_USE_NL;\n    expand_T\txpc;\n    int\t\terror = FALSE;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_bool_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && (check_for_opt_bool_arg(argvars, 2) == FAIL\n\t\t\t|| (argvars[2].v_type != VAR_UNKNOWN\n\t\t\t    && check_for_opt_bool_arg(argvars, 3) == FAIL)))))\n\treturn;\n\n    // When the optional second argument is non-zero, don't remove matches\n    // for 'wildignore' and don't put matches for 'suffixes' at the end.\n    rettv->v_type = VAR_STRING;\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tif (tv_get_bool_chk(&argvars[1], &error))\n\t    options |= WILD_KEEP_ALL;\n\tif (argvars[2].v_type != VAR_UNKNOWN)\n\t{\n\t    if (tv_get_bool_chk(&argvars[2], &error))\n\t\trettv_list_set(rettv, NULL);\n\t    if (argvars[3].v_type != VAR_UNKNOWN\n\t\t\t\t    && tv_get_bool_chk(&argvars[3], &error))\n\t\toptions |= WILD_ALLLINKS;\n\t}\n    }\n    if (!error)\n    {\n\tExpandInit(&xpc);\n\txpc.xp_context = EXPAND_FILES;\n\tif (p_wic)\n\t    options += WILD_ICASE;\n\tif (rettv->v_type == VAR_STRING)\n\t    rettv->vval.v_string = ExpandOne(&xpc, tv_get_string(&argvars[0]),\n\t\t\t\t\t\t     NULL, options, WILD_ALL);\n\telse if (rettv_list_alloc(rettv) != FAIL)\n\t{\n\t  int i;\n\n\t  ExpandOne(&xpc, tv_get_string(&argvars[0]),\n\t\t\t\t\t\tNULL, options, WILD_ALL_KEEP);\n\t  for (i = 0; i < xpc.xp_numfiles; i++)\n\t      list_append_string(rettv->vval.v_list, xpc.xp_files[i], -1);\n\n\t  ExpandCleanup(&xpc);\n\t}\n    }\n    else\n\trettv->vval.v_string = NULL;\n}\n\n/*\n * \"glob2regpat()\" function\n */\n    void\nf_glob2regpat(typval_T *argvars, typval_T *rettv)\n{\n    char_u\tbuf[NUMBUFLEN];\n    char_u\t*pat;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pat = tv_get_string_buf_chk_strict(&argvars[0], buf, in_vim9script());\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = (pat == NULL)\n\t\t\t ? NULL : file_pat_to_reg_pat(pat, NULL, NULL, FALSE);\n}\n\n/*\n * \"globpath()\" function\n */\n    void\nf_globpath(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tflags = WILD_IGNORE_COMPLETESLASH;\n    char_u\tbuf1[NUMBUFLEN];\n    char_u\t*file;\n    int\t\terror = FALSE;\n    garray_T\tga;\n    int\t\ti;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_bool_arg(argvars, 2) == FAIL\n\t\t|| (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && (check_for_opt_bool_arg(argvars, 3) == FAIL\n\t\t\t|| (argvars[3].v_type != VAR_UNKNOWN\n\t\t\t    && check_for_opt_bool_arg(argvars, 4) == FAIL)))))\n\treturn;\n\n    file = tv_get_string_buf_chk(&argvars[1], buf1);\n\n    // When the optional second argument is non-zero, don't remove matches\n    // for 'wildignore' and don't put matches for 'suffixes' at the end.\n    rettv->v_type = VAR_STRING;\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tif (tv_get_bool_chk(&argvars[2], &error))\n\t    flags |= WILD_KEEP_ALL;\n\tif (argvars[3].v_type != VAR_UNKNOWN)\n\t{\n\t    if (tv_get_bool_chk(&argvars[3], &error))\n\t\trettv_list_set(rettv, NULL);\n\t    if (argvars[4].v_type != VAR_UNKNOWN\n\t\t\t\t    && tv_get_bool_chk(&argvars[4], &error))\n\t\tflags |= WILD_ALLLINKS;\n\t}\n    }\n    if (file != NULL && !error)\n    {\n\tga_init2(&ga, sizeof(char_u *), 10);\n\tglobpath(tv_get_string(&argvars[0]), file, &ga, flags);\n\tif (rettv->v_type == VAR_STRING)\n\t    rettv->vval.v_string = ga_concat_strings(&ga, \"\\n\");\n\telse if (rettv_list_alloc(rettv) != FAIL)\n\t    for (i = 0; i < ga.ga_len; ++i)\n\t\tlist_append_string(rettv->vval.v_list,\n\t\t\t\t\t    ((char_u **)(ga.ga_data))[i], -1);\n\tga_clear_strings(&ga);\n    }\n    else\n\trettv->vval.v_string = NULL;\n}\n\n/*\n * \"isdirectory()\" function\n */\n    void\nf_isdirectory(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = mch_isdir(tv_get_string(&argvars[0]));\n}\n\n/*\n * Create the directory in which \"dir\" is located, and higher levels when\n * needed.\n * Return OK or FAIL.\n */\n    static int\nmkdir_recurse(char_u *dir, int prot)\n{\n    char_u\t*p;\n    char_u\t*updir;\n    int\t\tr = FAIL;\n\n    // Get end of directory name in \"dir\".\n    // We're done when it's \"/\" or \"c:/\".\n    p = gettail_sep(dir);\n    if (p <= get_past_head(dir))\n\treturn OK;\n\n    // If the directory exists we're done.  Otherwise: create it.\n    updir = vim_strnsave(dir, p - dir);\n    if (updir == NULL)\n\treturn FAIL;\n    if (mch_isdir(updir))\n\tr = OK;\n    else if (mkdir_recurse(updir, prot) == OK)\n\tr = vim_mkdir_emsg(updir, prot);\n    vim_free(updir);\n    return r;\n}\n\n/*\n * \"mkdir()\" function\n */\n    void\nf_mkdir(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*dir;\n    char_u\tbuf[NUMBUFLEN];\n    int\t\tprot = 0755;\n\n    rettv->vval.v_number = FAIL;\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_nonempty_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_number_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    dir = tv_get_string_buf(&argvars[0], buf);\n    if (*dir == NUL)\n\treturn;\n\n    if (*gettail(dir) == NUL)\n\t// remove trailing slashes\n\t*gettail_sep(dir) = NUL;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tif (argvars[2].v_type != VAR_UNKNOWN)\n\t{\n\t    prot = (int)tv_get_number_chk(&argvars[2], NULL);\n\t    if (prot == -1)\n\t\treturn;\n\t}\n\tif (STRCMP(tv_get_string(&argvars[1]), \"p\") == 0)\n\t{\n\t    if (mch_isdir(dir))\n\t    {\n\t\t// With the \"p\" flag it's OK if the dir already exists.\n\t\trettv->vval.v_number = OK;\n\t\treturn;\n\t    }\n\t    mkdir_recurse(dir, prot);\n\t}\n    }\n    rettv->vval.v_number = vim_mkdir_emsg(dir, prot);\n}\n\n/*\n * \"pathshorten()\" function\n */\n    void\nf_pathshorten(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*p;\n    int\t\ttrim_len = 1;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\ttrim_len = (int)tv_get_number(&argvars[1]);\n\tif (trim_len < 1)\n\t    trim_len = 1;\n    }\n\n    rettv->v_type = VAR_STRING;\n    p = tv_get_string_chk(&argvars[0]);\n\n    if (p == NULL)\n\trettv->vval.v_string = NULL;\n    else\n    {\n\tp = vim_strsave(p);\n\trettv->vval.v_string = p;\n\tif (p != NULL)\n\t    shorten_dir_len(p, trim_len);\n    }\n}\n\n/*\n * Common code for readdir_checkitem() and readdirex_checkitem().\n * Either \"name\" or \"dict\" is NULL.\n */\n    static int\ncheckitem_common(void *context, char_u *name, dict_T *dict)\n{\n    typval_T\t*expr = (typval_T *)context;\n    typval_T\tsave_val;\n    typval_T\trettv;\n    typval_T\targv[2];\n    int\t\tretval = 0;\n    int\t\terror = FALSE;\n\n    prepare_vimvar(VV_VAL, &save_val);\n    if (name != NULL)\n    {\n\tset_vim_var_string(VV_VAL, name, -1);\n\targv[0].v_type = VAR_STRING;\n\targv[0].vval.v_string = name;\n    }\n    else\n    {\n\tset_vim_var_dict(VV_VAL, dict);\n\targv[0].v_type = VAR_DICT;\n\targv[0].vval.v_dict = dict;\n    }\n\n    if (eval_expr_typval(expr, argv, 1, &rettv) == FAIL)\n\tgoto theend;\n\n    // We want to use -1, but also true/false should be allowed.\n    if (rettv.v_type == VAR_SPECIAL || rettv.v_type == VAR_BOOL)\n    {\n\trettv.v_type = VAR_NUMBER;\n\trettv.vval.v_number = rettv.vval.v_number == VVAL_TRUE;\n    }\n    retval = tv_get_number_chk(&rettv, &error);\n    if (error)\n\tretval = -1;\n    clear_tv(&rettv);\n\ntheend:\n    if (name != NULL)\n\tset_vim_var_string(VV_VAL, NULL, 0);\n    else\n\tset_vim_var_dict(VV_VAL, NULL);\n    restore_vimvar(VV_VAL, &save_val);\n    return retval;\n}\n\n/*\n * Evaluate \"expr\" (= \"context\") for readdir().\n */\n    static int\nreaddir_checkitem(void *context, void *item)\n{\n    char_u\t*name = (char_u *)item;\n\n    return checkitem_common(context, name, NULL);\n}\n\n    static int\nreaddirex_dict_arg(typval_T *tv, int *cmp)\n{\n    char_u     *compare;\n\n    if (tv->v_type != VAR_DICT)\n    {\n\temsg(_(e_dictionary_required));\n\treturn FAIL;\n    }\n\n    if (dict_find(tv->vval.v_dict, (char_u *)\"sort\", -1) != NULL)\n\tcompare = dict_get_string(tv->vval.v_dict, (char_u *)\"sort\", FALSE);\n    else\n    {\n\tsemsg(_(e_dictionary_key_str_required), \"sort\");\n\treturn FAIL;\n    }\n\n    if (STRCMP(compare, (char_u *) \"none\") == 0)\n\t*cmp = READDIR_SORT_NONE;\n    else if (STRCMP(compare, (char_u *) \"case\") == 0)\n\t*cmp = READDIR_SORT_BYTE;\n    else if (STRCMP(compare, (char_u *) \"icase\") == 0)\n\t*cmp = READDIR_SORT_IC;\n    else if (STRCMP(compare, (char_u *) \"collate\") == 0)\n\t*cmp = READDIR_SORT_COLLATE;\n    return OK;\n}\n\n/*\n * \"readdir()\" function\n */\n    void\nf_readdir(typval_T *argvars, typval_T *rettv)\n{\n    typval_T\t*expr;\n    int\t\tret;\n    char_u\t*path;\n    char_u\t*p;\n    garray_T\tga;\n    int\t\ti;\n    int         sort = READDIR_SORT_BYTE;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_dict_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    path = tv_get_string(&argvars[0]);\n    expr = &argvars[1];\n\n    if (argvars[1].v_type != VAR_UNKNOWN && argvars[2].v_type != VAR_UNKNOWN &&\n\t    readdirex_dict_arg(&argvars[2], &sort) == FAIL)\n\treturn;\n\n    ret = readdir_core(&ga, path, FALSE, (void *)expr,\n\t    (expr->v_type == VAR_UNKNOWN) ? NULL : readdir_checkitem, sort);\n    if (ret == OK)\n    {\n\tfor (i = 0; i < ga.ga_len; i++)\n\t{\n\t    p = ((char_u **)ga.ga_data)[i];\n\t    list_append_string(rettv->vval.v_list, p, -1);\n\t}\n    }\n    ga_clear_strings(&ga);\n}\n\n/*\n * Evaluate \"expr\" (= \"context\") for readdirex().\n */\n    static int\nreaddirex_checkitem(void *context, void *item)\n{\n    dict_T\t*dict = (dict_T*)item;\n\n    return checkitem_common(context, NULL, dict);\n}\n\n/*\n * \"readdirex()\" function\n */\n    void\nf_readdirex(typval_T *argvars, typval_T *rettv)\n{\n    typval_T\t*expr;\n    int\t\tret;\n    char_u\t*path;\n    garray_T\tga;\n    int\t\ti;\n    int         sort = READDIR_SORT_BYTE;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_dict_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    path = tv_get_string(&argvars[0]);\n    expr = &argvars[1];\n\n    if (argvars[1].v_type != VAR_UNKNOWN && argvars[2].v_type != VAR_UNKNOWN &&\n\t    readdirex_dict_arg(&argvars[2], &sort) == FAIL)\n\treturn;\n\n    ret = readdir_core(&ga, path, TRUE, (void *)expr,\n\t    (expr->v_type == VAR_UNKNOWN) ? NULL : readdirex_checkitem, sort);\n    if (ret == OK)\n    {\n\tfor (i = 0; i < ga.ga_len; i++)\n\t{\n\t    dict_T  *dict = ((dict_T**)ga.ga_data)[i];\n\t    list_append_dict(rettv->vval.v_list, dict);\n\t    dict_unref(dict);\n\t}\n    }\n    ga_clear(&ga);\n}\n\n/*\n * \"readfile()\" function\n */\n    static void\nread_file_or_blob(typval_T *argvars, typval_T *rettv, int always_blob)\n{\n    int\t\tbinary = FALSE;\n    int\t\tblob = always_blob;\n    int\t\tfailed = FALSE;\n    char_u\t*fname;\n    FILE\t*fd;\n    char_u\tbuf[(IOSIZE/256)*256];\t// rounded to avoid odd + 1\n    int\t\tio_size = sizeof(buf);\n    int\t\treadlen;\t\t// size of last fread()\n    char_u\t*prev\t = NULL;\t// previously read bytes, if any\n    long\tprevlen  = 0;\t\t// length of data in prev\n    long\tprevsize = 0;\t\t// size of prev buffer\n    long\tmaxline  = MAXLNUM;\n    long\tcnt\t = 0;\n    char_u\t*p;\t\t\t// position in buf\n    char_u\t*start;\t\t\t// start of current line\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tif (STRCMP(tv_get_string(&argvars[1]), \"b\") == 0)\n\t    binary = TRUE;\n\tif (STRCMP(tv_get_string(&argvars[1]), \"B\") == 0)\n\t    blob = TRUE;\n\n\tif (argvars[2].v_type != VAR_UNKNOWN)\n\t    maxline = (long)tv_get_number(&argvars[2]);\n    }\n\n    if ((blob ? rettv_blob_alloc(rettv) : rettv_list_alloc(rettv)) == FAIL)\n\treturn;\n\n    // Always open the file in binary mode, library functions have a mind of\n    // their own about CR-LF conversion.\n    fname = tv_get_string(&argvars[0]);\n\n    if (mch_isdir(fname))\n    {\n\tsemsg(_(e_src_is_directory), fname);\n\treturn;\n    }\n    if (*fname == NUL || (fd = mch_fopen((char *)fname, READBIN)) == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), *fname == NUL ? (char_u *)_(\"<empty>\") : fname);\n\treturn;\n    }\n\n    if (blob)\n    {\n\tif (read_blob(fd, rettv->vval.v_blob) == FAIL)\n\t{\n\t    semsg(_(e_cant_read_file_str), fname);\n\t    // An empty blob is returned on error.\n\t    blob_free(rettv->vval.v_blob);\n\t    rettv->vval.v_blob = NULL;\n\t}\n\tfclose(fd);\n\treturn;\n    }\n\n    while (cnt < maxline || maxline < 0)\n    {\n\treadlen = (int)fread(buf, 1, io_size, fd);\n\n\t// This for loop processes what was read, but is also entered at end\n\t// of file so that either:\n\t// - an incomplete line gets written\n\t// - a \"binary\" file gets an empty line at the end if it ends in a\n\t//   newline.\n\tfor (p = buf, start = buf;\n\t\tp < buf + readlen || (readlen <= 0 && (prevlen > 0 || binary));\n\t\t++p)\n\t{\n\t    if (readlen <= 0 || *p == '\\n')\n\t    {\n\t\tlistitem_T  *li;\n\t\tchar_u\t    *s\t= NULL;\n\t\tlong_u\t    len = p - start;\n\n\t\t// Finished a line.  Remove CRs before NL.\n\t\tif (readlen > 0 && !binary)\n\t\t{\n\t\t    while (len > 0 && start[len - 1] == '\\r')\n\t\t\t--len;\n\t\t    // removal may cross back to the \"prev\" string\n\t\t    if (len == 0)\n\t\t\twhile (prevlen > 0 && prev[prevlen - 1] == '\\r')\n\t\t\t    --prevlen;\n\t\t}\n\t\tif (prevlen == 0)\n\t\t    s = vim_strnsave(start, len);\n\t\telse\n\t\t{\n\t\t    // Change \"prev\" buffer to be the right size.  This way\n\t\t    // the bytes are only copied once, and very long lines are\n\t\t    // allocated only once.\n\t\t    if ((s = vim_realloc(prev, prevlen + len + 1)) != NULL)\n\t\t    {\n\t\t\tmch_memmove(s + prevlen, start, len);\n\t\t\ts[prevlen + len] = NUL;\n\t\t\tprev = NULL; // the list will own the string\n\t\t\tprevlen = prevsize = 0;\n\t\t    }\n\t\t}\n\t\tif (s == NULL)\n\t\t{\n\t\t    do_outofmem_msg((long_u) prevlen + len + 1);\n\t\t    failed = TRUE;\n\t\t    break;\n\t\t}\n\n\t\tif ((li = listitem_alloc()) == NULL)\n\t\t{\n\t\t    vim_free(s);\n\t\t    failed = TRUE;\n\t\t    break;\n\t\t}\n\t\tli->li_tv.v_type = VAR_STRING;\n\t\tli->li_tv.v_lock = 0;\n\t\tli->li_tv.vval.v_string = s;\n\t\tlist_append(rettv->vval.v_list, li);\n\n\t\tstart = p + 1; // step over newline\n\t\tif ((++cnt >= maxline && maxline >= 0) || readlen <= 0)\n\t\t    break;\n\t    }\n\t    else if (*p == NUL)\n\t\t*p = '\\n';\n\t    // Check for utf8 \"bom\"; U+FEFF is encoded as EF BB BF.  Do this\n\t    // when finding the BF and check the previous two bytes.\n\t    else if (*p == 0xbf && enc_utf8 && !binary)\n\t    {\n\t\t// Find the two bytes before the 0xbf.\tIf p is at buf, or buf\n\t\t// + 1, these may be in the \"prev\" string.\n\t\tchar_u back1 = p >= buf + 1 ? p[-1]\n\t\t\t\t     : prevlen >= 1 ? prev[prevlen - 1] : NUL;\n\t\tchar_u back2 = p >= buf + 2 ? p[-2]\n\t\t\t  : p == buf + 1 && prevlen >= 1 ? prev[prevlen - 1]\n\t\t\t  : prevlen >= 2 ? prev[prevlen - 2] : NUL;\n\n\t\tif (back2 == 0xef && back1 == 0xbb)\n\t\t{\n\t\t    char_u *dest = p - 2;\n\n\t\t    // Usually a BOM is at the beginning of a file, and so at\n\t\t    // the beginning of a line; then we can just step over it.\n\t\t    if (start == dest)\n\t\t\tstart = p + 1;\n\t\t    else\n\t\t    {\n\t\t\t// have to shuffle buf to close gap\n\t\t\tint adjust_prevlen = 0;\n\n\t\t\tif (dest < buf)\n\t\t\t{\n\t\t\t    // must be 1 or 2\n\t\t\t    adjust_prevlen = (int)(buf - dest);\n\t\t\t    dest = buf;\n\t\t\t}\n\t\t\tif (readlen > p - buf + 1)\n\t\t\t    mch_memmove(dest, p + 1, readlen - (p - buf) - 1);\n\t\t\treadlen -= 3 - adjust_prevlen;\n\t\t\tprevlen -= adjust_prevlen;\n\t\t\tp = dest - 1;\n\t\t    }\n\t\t}\n\t    }\n\t} // for\n\n\tif (failed || (cnt >= maxline && maxline >= 0) || readlen <= 0)\n\t    break;\n\tif (start < p)\n\t{\n\t    // There's part of a line in buf, store it in \"prev\".\n\t    if (p - start + prevlen >= prevsize)\n\t    {\n\t\t// need bigger \"prev\" buffer\n\t\tchar_u *newprev;\n\n\t\t// A common use case is ordinary text files and \"prev\" gets a\n\t\t// fragment of a line, so the first allocation is made\n\t\t// small, to avoid repeatedly 'allocing' large and\n\t\t// 'reallocing' small.\n\t\tif (prevsize == 0)\n\t\t    prevsize = (long)(p - start);\n\t\telse\n\t\t{\n\t\t    long grow50pc = (prevsize * 3) / 2;\n\t\t    long growmin  = (long)((p - start) * 2 + prevlen);\n\t\t    prevsize = grow50pc > growmin ? grow50pc : growmin;\n\t\t}\n\t\tnewprev = vim_realloc(prev, prevsize);\n\t\tif (newprev == NULL)\n\t\t{\n\t\t    do_outofmem_msg((long_u)prevsize);\n\t\t    failed = TRUE;\n\t\t    break;\n\t\t}\n\t\tprev = newprev;\n\t    }\n\t    // Add the line part to end of \"prev\".\n\t    mch_memmove(prev + prevlen, start, p - start);\n\t    prevlen += (long)(p - start);\n\t}\n    } // while\n\n    // For a negative line count use only the lines at the end of the file,\n    // free the rest.\n    if (!failed && maxline < 0)\n\twhile (cnt > -maxline)\n\t{\n\t    listitem_remove(rettv->vval.v_list, rettv->vval.v_list->lv_first);\n\t    --cnt;\n\t}\n\n    if (failed)\n    {\n\t// an empty list is returned on error\n\tlist_free(rettv->vval.v_list);\n\trettv_list_alloc(rettv);\n    }\n\n    vim_free(prev);\n    fclose(fd);\n}\n\n/*\n * \"readblob()\" function\n */\n    void\nf_readblob(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    read_file_or_blob(argvars, rettv, TRUE);\n}\n\n/*\n * \"readfile()\" function\n */\n    void\nf_readfile(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && (check_for_nonempty_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_number_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    read_file_or_blob(argvars, rettv, FALSE);\n}\n\n/*\n * \"resolve()\" function\n */\n    void\nf_resolve(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*p;\n#ifdef HAVE_READLINK\n    char_u\t*buf = NULL;\n#endif\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    p = tv_get_string(&argvars[0]);\n#ifdef FEAT_SHORTCUT\n    {\n\tchar_u\t*v = NULL;\n\n\tv = mch_resolve_path(p, TRUE);\n\tif (v != NULL)\n\t    rettv->vval.v_string = v;\n\telse\n\t    rettv->vval.v_string = vim_strsave(p);\n    }\n#else\n# ifdef HAVE_READLINK\n    {\n\tchar_u\t*cpy;\n\tint\tlen;\n\tchar_u\t*remain = NULL;\n\tchar_u\t*q;\n\tint\tis_relative_to_current = FALSE;\n\tint\thas_trailing_pathsep = FALSE;\n\tint\tlimit = 100;\n\n\tp = vim_strsave(p);\n\tif (p == NULL)\n\t    goto fail;\n\tif (p[0] == '.' && (vim_ispathsep(p[1])\n\t\t\t\t   || (p[1] == '.' && (vim_ispathsep(p[2])))))\n\t    is_relative_to_current = TRUE;\n\n\tlen = STRLEN(p);\n\tif (len > 1 && after_pathsep(p, p + len))\n\t{\n\t    has_trailing_pathsep = TRUE;\n\t    p[len - 1] = NUL; // the trailing slash breaks readlink()\n\t}\n\n\tq = getnextcomp(p);\n\tif (*q != NUL)\n\t{\n\t    // Separate the first path component in \"p\", and keep the\n\t    // remainder (beginning with the path separator).\n\t    remain = vim_strsave(q - 1);\n\t    q[-1] = NUL;\n\t}\n\n\tbuf = alloc(MAXPATHL + 1);\n\tif (buf == NULL)\n\t{\n\t    vim_free(p);\n\t    goto fail;\n\t}\n\n\tfor (;;)\n\t{\n\t    for (;;)\n\t    {\n\t\tlen = readlink((char *)p, (char *)buf, MAXPATHL);\n\t\tif (len <= 0)\n\t\t    break;\n\t\tbuf[len] = NUL;\n\n\t\tif (limit-- == 0)\n\t\t{\n\t\t    vim_free(p);\n\t\t    vim_free(remain);\n\t\t    emsg(_(e_too_many_symbolic_links_cycle));\n\t\t    rettv->vval.v_string = NULL;\n\t\t    goto fail;\n\t\t}\n\n\t\t// Ensure that the result will have a trailing path separator\n\t\t// if the argument has one.\n\t\tif (remain == NULL && has_trailing_pathsep)\n\t\t    add_pathsep(buf);\n\n\t\t// Separate the first path component in the link value and\n\t\t// concatenate the remainders.\n\t\tq = getnextcomp(vim_ispathsep(*buf) ? buf + 1 : buf);\n\t\tif (*q != NUL)\n\t\t{\n\t\t    if (remain == NULL)\n\t\t\tremain = vim_strsave(q - 1);\n\t\t    else\n\t\t    {\n\t\t\tcpy = concat_str(q - 1, remain);\n\t\t\tif (cpy != NULL)\n\t\t\t{\n\t\t\t    vim_free(remain);\n\t\t\t    remain = cpy;\n\t\t\t}\n\t\t    }\n\t\t    q[-1] = NUL;\n\t\t}\n\n\t\tq = gettail(p);\n\t\tif (q > p && *q == NUL)\n\t\t{\n\t\t    // Ignore trailing path separator.\n\t\t    q[-1] = NUL;\n\t\t    q = gettail(p);\n\t\t}\n\t\tif (q > p && !mch_isFullName(buf))\n\t\t{\n\t\t    // symlink is relative to directory of argument\n\t\t    cpy = alloc(STRLEN(p) + STRLEN(buf) + 1);\n\t\t    if (cpy != NULL)\n\t\t    {\n\t\t\tSTRCPY(cpy, p);\n\t\t\tSTRCPY(gettail(cpy), buf);\n\t\t\tvim_free(p);\n\t\t\tp = cpy;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    vim_free(p);\n\t\t    p = vim_strsave(buf);\n\t\t}\n\t    }\n\n\t    if (remain == NULL)\n\t\tbreak;\n\n\t    // Append the first path component of \"remain\" to \"p\".\n\t    q = getnextcomp(remain + 1);\n\t    len = q - remain - (*q != NUL);\n\t    cpy = vim_strnsave(p, STRLEN(p) + len);\n\t    if (cpy != NULL)\n\t    {\n\t\tSTRNCAT(cpy, remain, len);\n\t\tvim_free(p);\n\t\tp = cpy;\n\t    }\n\t    // Shorten \"remain\".\n\t    if (*q != NUL)\n\t\tSTRMOVE(remain, q - 1);\n\t    else\n\t\tVIM_CLEAR(remain);\n\t}\n\n\t// If the result is a relative path name, make it explicitly relative to\n\t// the current directory if and only if the argument had this form.\n\tif (!vim_ispathsep(*p))\n\t{\n\t    if (is_relative_to_current\n\t\t    && *p != NUL\n\t\t    && !(p[0] == '.'\n\t\t\t&& (p[1] == NUL\n\t\t\t    || vim_ispathsep(p[1])\n\t\t\t    || (p[1] == '.'\n\t\t\t\t&& (p[2] == NUL\n\t\t\t\t    || vim_ispathsep(p[2]))))))\n\t    {\n\t\t// Prepend \"./\".\n\t\tcpy = concat_str((char_u *)\"./\", p);\n\t\tif (cpy != NULL)\n\t\t{\n\t\t    vim_free(p);\n\t\t    p = cpy;\n\t\t}\n\t    }\n\t    else if (!is_relative_to_current)\n\t    {\n\t\t// Strip leading \"./\".\n\t\tq = p;\n\t\twhile (q[0] == '.' && vim_ispathsep(q[1]))\n\t\t    q += 2;\n\t\tif (q > p)\n\t\t    STRMOVE(p, p + 2);\n\t    }\n\t}\n\n\t// Ensure that the result will have no trailing path separator\n\t// if the argument had none.  But keep \"/\" or \"//\".\n\tif (!has_trailing_pathsep)\n\t{\n\t    q = p + STRLEN(p);\n\t    if (after_pathsep(p, q))\n\t\t*gettail_sep(p) = NUL;\n\t}\n\n\trettv->vval.v_string = p;\n    }\n# else\n    rettv->vval.v_string = vim_strsave(p);\n# endif\n#endif\n\n    simplify_filename(rettv->vval.v_string);\n\n#ifdef HAVE_READLINK\nfail:\n    vim_free(buf);\n#endif\n    rettv->v_type = VAR_STRING;\n}\n\n/*\n * \"tempname()\" function\n */\n    void\nf_tempname(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    static int\tx = 'A';\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = vim_tempname(x, FALSE);\n\n    // Advance 'x' to use A-Z and 0-9, so that there are at least 34 different\n    // names.  Skip 'I' and 'O', they are used for shell redirection.\n    do\n    {\n\tif (x == 'Z')\n\t    x = '0';\n\telse if (x == '9')\n\t    x = 'A';\n\telse\n\t    ++x;\n    } while (x == 'I' || x == 'O');\n}\n\n/*\n * \"writefile()\" function\n */\n    void\nf_writefile(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tbinary = FALSE;\n    int\t\tappend = FALSE;\n#ifdef HAVE_FSYNC\n    int\t\tdo_fsync = p_fs;\n#endif\n    char_u\t*fname;\n    FILE\t*fd;\n    int\t\tret = 0;\n    listitem_T\t*li;\n    list_T\t*list = NULL;\n    blob_T\t*blob = NULL;\n\n    rettv->vval.v_number = -1;\n    if (check_secure())\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_list_or_blob_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 2) == FAIL))\n\treturn;\n\n    if (argvars[0].v_type == VAR_LIST)\n    {\n\tlist = argvars[0].vval.v_list;\n\tif (list == NULL)\n\t    return;\n\tCHECK_LIST_MATERIALIZE(list);\n\tFOR_ALL_LIST_ITEMS(list, li)\n\t    if (tv_get_string_chk(&li->li_tv) == NULL)\n\t\treturn;\n    }\n    else if (argvars[0].v_type == VAR_BLOB)\n    {\n\tblob = argvars[0].vval.v_blob;\n\tif (blob == NULL)\n\t    return;\n    }\n    else\n    {\n\tsemsg(_(e_invalid_argument_str),\n\t\t_(\"writefile() first argument must be a List or a Blob\"));\n\treturn;\n    }\n\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tchar_u *arg2 = tv_get_string_chk(&argvars[2]);\n\n\tif (arg2 == NULL)\n\t    return;\n\tif (vim_strchr(arg2, 'b') != NULL)\n\t    binary = TRUE;\n\tif (vim_strchr(arg2, 'a') != NULL)\n\t    append = TRUE;\n#ifdef HAVE_FSYNC\n\tif (vim_strchr(arg2, 's') != NULL)\n\t    do_fsync = TRUE;\n\telse if (vim_strchr(arg2, 'S') != NULL)\n\t    do_fsync = FALSE;\n#endif\n    }\n\n    fname = tv_get_string_chk(&argvars[1]);\n    if (fname == NULL)\n\treturn;\n\n    // Always open the file in binary mode, library functions have a mind of\n    // their own about CR-LF conversion.\n    if (*fname == NUL || (fd = mch_fopen((char *)fname,\n\t\t\t\t      append ? APPENDBIN : WRITEBIN)) == NULL)\n    {\n\tsemsg(_(e_cant_create_file_str), *fname == NUL ? (char_u *)_(\"<empty>\") : fname);\n\tret = -1;\n    }\n    else if (blob)\n    {\n\tif (write_blob(fd, blob) == FAIL)\n\t    ret = -1;\n#ifdef HAVE_FSYNC\n\telse if (do_fsync)\n\t    // Ignore the error, the user wouldn't know what to do about it.\n\t    // May happen for a device.\n\t    vim_ignored = vim_fsync(fileno(fd));\n#endif\n\tfclose(fd);\n    }\n    else\n    {\n\tif (write_list(fd, list, binary) == FAIL)\n\t    ret = -1;\n#ifdef HAVE_FSYNC\n\telse if (do_fsync)\n\t    // Ignore the error, the user wouldn't know what to do about it.\n\t    // May happen for a device.\n\t    vim_ignored = vim_fsync(fileno(fd));\n#endif\n\tfclose(fd);\n    }\n\n    rettv->vval.v_number = ret;\n}\n\n#endif // FEAT_EVAL\n\n#if defined(FEAT_BROWSE) || defined(PROTO)\n/*\n * Generic browse function.  Calls gui_mch_browse() when possible.\n * Later this may pop-up a non-GUI file selector (external command?).\n */\n    char_u *\ndo_browse(\n    int\t\tflags,\t\t// BROWSE_SAVE and BROWSE_DIR\n    char_u\t*title,\t\t// title for the window\n    char_u\t*dflt,\t\t// default file name (may include directory)\n    char_u\t*ext,\t\t// extension added\n    char_u\t*initdir,\t// initial directory, NULL for current dir or\n\t\t\t\t// when using path from \"dflt\"\n    char_u\t*filter,\t// file name filter\n    buf_T\t*buf)\t\t// buffer to read/write for\n{\n    char_u\t\t*fname;\n    static char_u\t*last_dir = NULL;    // last used directory\n    char_u\t\t*tofree = NULL;\n    int\t\t\tsave_cmod_flags = cmdmod.cmod_flags;\n\n    // Must turn off browse to avoid that autocommands will get the\n    // flag too!\n    cmdmod.cmod_flags &= ~CMOD_BROWSE;\n\n    if (title == NULL || *title == NUL)\n    {\n\tif (flags & BROWSE_DIR)\n\t    title = (char_u *)_(\"Select Directory dialog\");\n\telse if (flags & BROWSE_SAVE)\n\t    title = (char_u *)_(\"Save File dialog\");\n\telse\n\t    title = (char_u *)_(\"Open File dialog\");\n    }\n\n    // When no directory specified, use default file name, default dir, buffer\n    // dir, last dir or current dir\n    if ((initdir == NULL || *initdir == NUL) && dflt != NULL && *dflt != NUL)\n    {\n\tif (mch_isdir(dflt))\t\t// default file name is a directory\n\t{\n\t    initdir = dflt;\n\t    dflt = NULL;\n\t}\n\telse if (gettail(dflt) != dflt)\t// default file name includes a path\n\t{\n\t    tofree = vim_strsave(dflt);\n\t    if (tofree != NULL)\n\t    {\n\t\tinitdir = tofree;\n\t\t*gettail(initdir) = NUL;\n\t\tdflt = gettail(dflt);\n\t    }\n\t}\n    }\n\n    if (initdir == NULL || *initdir == NUL)\n    {\n\t// When 'browsedir' is a directory, use it\n\tif (STRCMP(p_bsdir, \"last\") != 0\n\t\t&& STRCMP(p_bsdir, \"buffer\") != 0\n\t\t&& STRCMP(p_bsdir, \"current\") != 0\n\t\t&& mch_isdir(p_bsdir))\n\t    initdir = p_bsdir;\n\t// When saving or 'browsedir' is \"buffer\", use buffer fname\n\telse if (((flags & BROWSE_SAVE) || *p_bsdir == 'b')\n\t\t&& buf != NULL && buf->b_ffname != NULL)\n\t{\n\t    if (dflt == NULL || *dflt == NUL)\n\t\tdflt = gettail(curbuf->b_ffname);\n\t    tofree = vim_strsave(curbuf->b_ffname);\n\t    if (tofree != NULL)\n\t    {\n\t\tinitdir = tofree;\n\t\t*gettail(initdir) = NUL;\n\t    }\n\t}\n\t// When 'browsedir' is \"last\", use dir from last browse\n\telse if (*p_bsdir == 'l')\n\t    initdir = last_dir;\n\t// When 'browsedir is \"current\", use current directory.  This is the\n\t// default already, leave initdir empty.\n    }\n\n# ifdef FEAT_GUI\n    if (gui.in_use)\t\t// when this changes, also adjust f_has()!\n    {\n\tif (filter == NULL\n#  ifdef FEAT_EVAL\n\t\t&& (filter = get_var_value((char_u *)\"b:browsefilter\")) == NULL\n\t\t&& (filter = get_var_value((char_u *)\"g:browsefilter\")) == NULL\n#  endif\n\t)\n\t    filter = BROWSE_FILTER_DEFAULT;\n\tif (flags & BROWSE_DIR)\n\t{\n#  if defined(FEAT_GUI_GTK) || defined(MSWIN)\n\t    // For systems that have a directory dialog.\n\t    fname = gui_mch_browsedir(title, initdir);\n#  else\n\t    // Generic solution for selecting a directory: select a file and\n\t    // remove the file name.\n\t    fname = gui_mch_browse(0, title, dflt, ext, initdir, (char_u *)\"\");\n#  endif\n#  if !defined(FEAT_GUI_GTK)\n\t    // Win32 adds a dummy file name, others return an arbitrary file\n\t    // name.  GTK+ 2 returns only the directory,\n\t    if (fname != NULL && *fname != NUL && !mch_isdir(fname))\n\t    {\n\t\t// Remove the file name.\n\t\tchar_u\t    *tail = gettail_sep(fname);\n\n\t\tif (tail == fname)\n\t\t    *tail++ = '.';\t// use current dir\n\t\t*tail = NUL;\n\t    }\n#  endif\n\t}\n\telse\n\t    fname = gui_mch_browse(flags & BROWSE_SAVE,\n\t\t\t       title, dflt, ext, initdir, (char_u *)_(filter));\n\n\t// We hang around in the dialog for a while, the user might do some\n\t// things to our files.  The Win32 dialog allows deleting or renaming\n\t// a file, check timestamps.\n\tneed_check_timestamps = TRUE;\n\tdid_check_timestamps = FALSE;\n    }\n    else\n# endif\n    {\n\t// TODO: non-GUI file selector here\n\temsg(_(e_sorry_no_file_browser_in_console_mode));\n\tfname = NULL;\n    }\n\n    // keep the directory for next time\n    if (fname != NULL)\n    {\n\tvim_free(last_dir);\n\tlast_dir = vim_strsave(fname);\n\tif (last_dir != NULL && !(flags & BROWSE_DIR))\n\t{\n\t    *gettail(last_dir) = NUL;\n\t    if (*last_dir == NUL)\n\t    {\n\t\t// filename only returned, must be in current dir\n\t\tvim_free(last_dir);\n\t\tlast_dir = alloc(MAXPATHL);\n\t\tif (last_dir != NULL)\n\t\t    mch_dirname(last_dir, MAXPATHL);\n\t    }\n\t}\n    }\n\n    vim_free(tofree);\n    cmdmod.cmod_flags = save_cmod_flags;\n\n    return fname;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * \"browse(save, title, initdir, default)\" function\n */\n    void\nf_browse(typval_T *argvars UNUSED, typval_T *rettv)\n{\n# ifdef FEAT_BROWSE\n    int\t\tsave;\n    char_u\t*title;\n    char_u\t*initdir;\n    char_u\t*defname;\n    char_u\tbuf[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    int\t\terror = FALSE;\n\n    if (in_vim9script()\n\t    && (check_for_bool_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_string_arg(argvars, 2) == FAIL\n\t\t|| check_for_string_arg(argvars, 3) == FAIL))\n\treturn;\n\n    save = (int)tv_get_number_chk(&argvars[0], &error);\n    title = tv_get_string_chk(&argvars[1]);\n    initdir = tv_get_string_buf_chk(&argvars[2], buf);\n    defname = tv_get_string_buf_chk(&argvars[3], buf2);\n\n    if (error || title == NULL || initdir == NULL || defname == NULL)\n\trettv->vval.v_string = NULL;\n    else\n\trettv->vval.v_string =\n\t\t do_browse(save ? BROWSE_SAVE : 0,\n\t\t\t\t title, defname, NULL, initdir, NULL, curbuf);\n# else\n    rettv->vval.v_string = NULL;\n# endif\n    rettv->v_type = VAR_STRING;\n}\n\n/*\n * \"browsedir(title, initdir)\" function\n */\n    void\nf_browsedir(typval_T *argvars UNUSED, typval_T *rettv)\n{\n# ifdef FEAT_BROWSE\n    char_u\t*title;\n    char_u\t*initdir;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    title = tv_get_string_chk(&argvars[0]);\n    initdir = tv_get_string_buf_chk(&argvars[1], buf);\n\n    if (title == NULL || initdir == NULL)\n\trettv->vval.v_string = NULL;\n    else\n\trettv->vval.v_string = do_browse(BROWSE_DIR,\n\t\t\t\t    title, NULL, NULL, initdir, NULL, curbuf);\n# else\n    rettv->vval.v_string = NULL;\n# endif\n    rettv->v_type = VAR_STRING;\n}\n\n#endif // FEAT_EVAL\n\n/*\n * Replace home directory by \"~\" in each space or comma separated file name in\n * 'src'.\n * If anything fails (except when out of space) dst equals src.\n */\n    void\nhome_replace(\n    buf_T\t*buf,\t// when not NULL, check for help files\n    char_u\t*src,\t// input file name\n    char_u\t*dst,\t// where to put the result\n    int\t\tdstlen,\t// maximum length of the result\n    int\t\tone)\t// if TRUE, only replace one file name, include\n\t\t\t// spaces and commas in the file name.\n{\n    size_t\tdirlen = 0, envlen = 0;\n    size_t\tlen;\n    char_u\t*homedir_env, *homedir_env_orig;\n    char_u\t*p;\n\n    if (src == NULL)\n    {\n\t*dst = NUL;\n\treturn;\n    }\n\n    /*\n     * If the file is a help file, remove the path completely.\n     */\n    if (buf != NULL && buf->b_help)\n    {\n\tvim_snprintf((char *)dst, dstlen, \"%s\", gettail(src));\n\treturn;\n    }\n\n    /*\n     * We check both the value of the $HOME environment variable and the\n     * \"real\" home directory.\n     */\n    if (homedir != NULL)\n\tdirlen = STRLEN(homedir);\n\n#ifdef VMS\n    homedir_env_orig = homedir_env = mch_getenv((char_u *)\"SYS$LOGIN\");\n#else\n    homedir_env_orig = homedir_env = mch_getenv((char_u *)\"HOME\");\n#endif\n#ifdef MSWIN\n    if (homedir_env == NULL)\n\thomedir_env_orig = homedir_env = mch_getenv((char_u *)\"USERPROFILE\");\n#endif\n    // Empty is the same as not set.\n    if (homedir_env != NULL && *homedir_env == NUL)\n\thomedir_env = NULL;\n\n    if (homedir_env != NULL && *homedir_env == '~')\n    {\n\tint\tusedlen = 0;\n\tint\tflen;\n\tchar_u\t*fbuf = NULL;\n\n\tflen = (int)STRLEN(homedir_env);\n\t(void)modify_fname((char_u *)\":p\", FALSE, &usedlen,\n\t\t\t\t\t\t  &homedir_env, &fbuf, &flen);\n\tflen = (int)STRLEN(homedir_env);\n\tif (flen > 0 && vim_ispathsep(homedir_env[flen - 1]))\n\t    // Remove the trailing / that is added to a directory.\n\t    homedir_env[flen - 1] = NUL;\n    }\n\n    if (homedir_env != NULL)\n\tenvlen = STRLEN(homedir_env);\n\n    if (!one)\n\tsrc = skipwhite(src);\n    while (*src && dstlen > 0)\n    {\n\t/*\n\t * Here we are at the beginning of a file name.\n\t * First, check to see if the beginning of the file name matches\n\t * $HOME or the \"real\" home directory. Check that there is a '/'\n\t * after the match (so that if e.g. the file is \"/home/pieter/bla\",\n\t * and the home directory is \"/home/piet\", the file does not end up\n\t * as \"~er/bla\" (which would seem to indicate the file \"bla\" in user\n\t * er's home directory)).\n\t */\n\tp = homedir;\n\tlen = dirlen;\n\tfor (;;)\n\t{\n\t    if (   len\n\t\t&& fnamencmp(src, p, len) == 0\n\t\t&& (vim_ispathsep(src[len])\n\t\t    || (!one && (src[len] == ',' || src[len] == ' '))\n\t\t    || src[len] == NUL))\n\t    {\n\t\tsrc += len;\n\t\tif (--dstlen > 0)\n\t\t    *dst++ = '~';\n\n\t\t// Do not add directory separator into dst, because dst is\n\t\t// expected to just return the directory name without the\n\t\t// directory separator '/'.\n\t\tbreak;\n\t    }\n\t    if (p == homedir_env)\n\t\tbreak;\n\t    p = homedir_env;\n\t    len = envlen;\n\t}\n\n\t// if (!one) skip to separator: space or comma\n\twhile (*src && (one || (*src != ',' && *src != ' ')) && --dstlen > 0)\n\t    *dst++ = *src++;\n\t// skip separator\n\twhile ((*src == ' ' || *src == ',') && --dstlen > 0)\n\t    *dst++ = *src++;\n    }\n    // if (dstlen == 0) out of space, what to do???\n\n    *dst = NUL;\n\n    if (homedir_env != homedir_env_orig)\n\tvim_free(homedir_env);\n}\n\n/*\n * Like home_replace, store the replaced string in allocated memory.\n * When something fails, NULL is returned.\n */\n    char_u  *\nhome_replace_save(\n    buf_T\t*buf,\t// when not NULL, check for help files\n    char_u\t*src)\t// input file name\n{\n    char_u\t*dst;\n    unsigned\tlen;\n\n    len = 3;\t\t\t// space for \"~/\" and trailing NUL\n    if (src != NULL)\t\t// just in case\n\tlen += (unsigned)STRLEN(src);\n    dst = alloc(len);\n    if (dst != NULL)\n\thome_replace(buf, src, dst, len, TRUE);\n    return dst;\n}\n\n/*\n * Compare two file names and return:\n * FPC_SAME   if they both exist and are the same file.\n * FPC_SAMEX  if they both don't exist and have the same file name.\n * FPC_DIFF   if they both exist and are different files.\n * FPC_NOTX   if they both don't exist.\n * FPC_DIFFX  if one of them doesn't exist.\n * For the first name environment variables are expanded if \"expandenv\" is\n * TRUE.\n */\n    int\nfullpathcmp(\n    char_u *s1,\n    char_u *s2,\n    int\t    checkname,\t\t// when both don't exist, check file names\n    int\t    expandenv)\n{\n#ifdef UNIX\n    char_u\t    exp1[MAXPATHL];\n    char_u\t    full1[MAXPATHL];\n    char_u\t    full2[MAXPATHL];\n    stat_T\t    st1, st2;\n    int\t\t    r1, r2;\n\n    if (expandenv)\n\texpand_env(s1, exp1, MAXPATHL);\n    else\n\tvim_strncpy(exp1, s1, MAXPATHL - 1);\n    r1 = mch_stat((char *)exp1, &st1);\n    r2 = mch_stat((char *)s2, &st2);\n    if (r1 != 0 && r2 != 0)\n    {\n\t// if mch_stat() doesn't work, may compare the names\n\tif (checkname)\n\t{\n\t    if (fnamecmp(exp1, s2) == 0)\n\t\treturn FPC_SAMEX;\n\t    r1 = vim_FullName(exp1, full1, MAXPATHL, FALSE);\n\t    r2 = vim_FullName(s2, full2, MAXPATHL, FALSE);\n\t    if (r1 == OK && r2 == OK && fnamecmp(full1, full2) == 0)\n\t\treturn FPC_SAMEX;\n\t}\n\treturn FPC_NOTX;\n    }\n    if (r1 != 0 || r2 != 0)\n\treturn FPC_DIFFX;\n    if (st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino)\n\treturn FPC_SAME;\n    return FPC_DIFF;\n#else\n    char_u  *exp1;\t\t// expanded s1\n    char_u  *full1;\t\t// full path of s1\n    char_u  *full2;\t\t// full path of s2\n    int\t    retval = FPC_DIFF;\n    int\t    r1, r2;\n\n    // allocate one buffer to store three paths (alloc()/free() is slow!)\n    if ((exp1 = alloc(MAXPATHL * 3)) != NULL)\n    {\n\tfull1 = exp1 + MAXPATHL;\n\tfull2 = full1 + MAXPATHL;\n\n\tif (expandenv)\n\t    expand_env(s1, exp1, MAXPATHL);\n\telse\n\t    vim_strncpy(exp1, s1, MAXPATHL - 1);\n\tr1 = vim_FullName(exp1, full1, MAXPATHL, FALSE);\n\tr2 = vim_FullName(s2, full2, MAXPATHL, FALSE);\n\n\t// If vim_FullName() fails, the file probably doesn't exist.\n\tif (r1 != OK && r2 != OK)\n\t{\n\t    if (checkname && fnamecmp(exp1, s2) == 0)\n\t\tretval = FPC_SAMEX;\n\t    else\n\t\tretval = FPC_NOTX;\n\t}\n\telse if (r1 != OK || r2 != OK)\n\t    retval = FPC_DIFFX;\n\telse if (fnamecmp(full1, full2))\n\t    retval = FPC_DIFF;\n\telse\n\t    retval = FPC_SAME;\n\tvim_free(exp1);\n    }\n    return retval;\n#endif\n}\n\n/*\n * Get the tail of a path: the file name.\n * When the path ends in a path separator the tail is the NUL after it.\n * Fail safe: never returns NULL.\n */\n    char_u *\ngettail(char_u *fname)\n{\n    char_u  *p1, *p2;\n\n    if (fname == NULL)\n\treturn (char_u *)\"\";\n    for (p1 = p2 = get_past_head(fname); *p2; )\t// find last part of path\n    {\n\tif (vim_ispathsep_nocolon(*p2))\n\t    p1 = p2 + 1;\n\tMB_PTR_ADV(p2);\n    }\n    return p1;\n}\n\n/*\n * Get pointer to tail of \"fname\", including path separators.  Putting a NUL\n * here leaves the directory name.  Takes care of \"c:/\" and \"//\".\n * Always returns a valid pointer.\n */\n    char_u *\ngettail_sep(char_u *fname)\n{\n    char_u\t*p;\n    char_u\t*t;\n\n    p = get_past_head(fname);\t// don't remove the '/' from \"c:/file\"\n    t = gettail(fname);\n    while (t > p && after_pathsep(fname, t))\n\t--t;\n#ifdef VMS\n    // path separator is part of the path\n    ++t;\n#endif\n    return t;\n}\n\n/*\n * get the next path component (just after the next path separator).\n */\n    char_u *\ngetnextcomp(char_u *fname)\n{\n    while (*fname && !vim_ispathsep(*fname))\n\tMB_PTR_ADV(fname);\n    if (*fname)\n\t++fname;\n    return fname;\n}\n\n/*\n * Get a pointer to one character past the head of a path name.\n * Unix: after \"/\"; DOS: after \"c:\\\"; Amiga: after \"disk:/\"; Mac: no head.\n * If there is no head, path is returned.\n */\n    char_u *\nget_past_head(char_u *path)\n{\n    char_u  *retval;\n\n#if defined(MSWIN)\n    // may skip \"c:\"\n    if (isalpha(path[0]) && path[1] == ':')\n\tretval = path + 2;\n    else\n\tretval = path;\n#else\n# if defined(AMIGA)\n    // may skip \"label:\"\n    retval = vim_strchr(path, ':');\n    if (retval == NULL)\n\tretval = path;\n# else\t// Unix\n    retval = path;\n# endif\n#endif\n\n    while (vim_ispathsep(*retval))\n\t++retval;\n\n    return retval;\n}\n\n/*\n * Return TRUE if 'c' is a path separator.\n * Note that for MS-Windows this includes the colon.\n */\n    int\nvim_ispathsep(int c)\n{\n#ifdef UNIX\n    return (c == '/');\t    // UNIX has ':' inside file names\n#else\n# ifdef BACKSLASH_IN_FILENAME\n    return (c == ':' || c == '/' || c == '\\\\');\n# else\n#  ifdef VMS\n    // server\"user passwd\"::device:[full.path.name]fname.extension;version\"\n    return (c == ':' || c == '[' || c == ']' || c == '/'\n\t    || c == '<' || c == '>' || c == '\"' );\n#  else\n    return (c == ':' || c == '/');\n#  endif // VMS\n# endif\n#endif\n}\n\n/*\n * Like vim_ispathsep(c), but exclude the colon for MS-Windows.\n */\n    int\nvim_ispathsep_nocolon(int c)\n{\n    return vim_ispathsep(c)\n#ifdef BACKSLASH_IN_FILENAME\n\t&& c != ':'\n#endif\n\t;\n}\n\n/*\n * Return TRUE if the directory of \"fname\" exists, FALSE otherwise.\n * Also returns TRUE if there is no directory name.\n * \"fname\" must be writable!.\n */\n    int\ndir_of_file_exists(char_u *fname)\n{\n    char_u\t*p;\n    int\t\tc;\n    int\t\tretval;\n\n    p = gettail_sep(fname);\n    if (p == fname)\n\treturn TRUE;\n    c = *p;\n    *p = NUL;\n    retval = mch_isdir(fname);\n    *p = c;\n    return retval;\n}\n\n/*\n * Versions of fnamecmp() and fnamencmp() that handle '/' and '\\' equally\n * and deal with 'fileignorecase'.\n */\n    int\nvim_fnamecmp(char_u *x, char_u *y)\n{\n#ifdef BACKSLASH_IN_FILENAME\n    return vim_fnamencmp(x, y, MAXPATHL);\n#else\n    if (p_fic)\n\treturn MB_STRICMP(x, y);\n    return STRCMP(x, y);\n#endif\n}\n\n    int\nvim_fnamencmp(char_u *x, char_u *y, size_t len)\n{\n#ifdef BACKSLASH_IN_FILENAME\n    char_u\t*px = x;\n    char_u\t*py = y;\n    int\t\tcx = NUL;\n    int\t\tcy = NUL;\n\n    while (len > 0)\n    {\n\tcx = PTR2CHAR(px);\n\tcy = PTR2CHAR(py);\n\tif (cx == NUL || cy == NUL\n\t    || ((p_fic ? MB_TOLOWER(cx) != MB_TOLOWER(cy) : cx != cy)\n\t\t&& !(cx == '/' && cy == '\\\\')\n\t\t&& !(cx == '\\\\' && cy == '/')))\n\t    break;\n\tlen -= mb_ptr2len(px);\n\tpx += mb_ptr2len(px);\n\tpy += mb_ptr2len(py);\n    }\n    if (len == 0)\n\treturn 0;\n    return (cx - cy);\n#else\n    if (p_fic)\n\treturn MB_STRNICMP(x, y, len);\n    return STRNCMP(x, y, len);\n#endif\n}\n\n/*\n * Concatenate file names fname1 and fname2 into allocated memory.\n * Only add a '/' or '\\\\' when 'sep' is TRUE and it is necessary.\n */\n    char_u  *\nconcat_fnames(char_u *fname1, char_u *fname2, int sep)\n{\n    char_u  *dest;\n\n    dest = alloc(STRLEN(fname1) + STRLEN(fname2) + 3);\n    if (dest != NULL)\n    {\n\tSTRCPY(dest, fname1);\n\tif (sep)\n\t    add_pathsep(dest);\n\tSTRCAT(dest, fname2);\n    }\n    return dest;\n}\n\n/*\n * Add a path separator to a file name, unless it already ends in a path\n * separator.\n */\n    void\nadd_pathsep(char_u *p)\n{\n    if (*p != NUL && !after_pathsep(p, p + STRLEN(p)))\n\tSTRCAT(p, PATHSEPSTR);\n}\n\n/*\n * FullName_save - Make an allocated copy of a full file name.\n * Returns NULL when out of memory.\n */\n    char_u  *\nFullName_save(\n    char_u\t*fname,\n    int\t\tforce)\t\t// force expansion, even when it already looks\n\t\t\t\t// like a full path name\n{\n    char_u\t*buf;\n    char_u\t*new_fname = NULL;\n\n    if (fname == NULL)\n\treturn NULL;\n\n    buf = alloc(MAXPATHL);\n    if (buf != NULL)\n    {\n\tif (vim_FullName(fname, buf, MAXPATHL, force) != FAIL)\n\t    new_fname = vim_strsave(buf);\n\telse\n\t    new_fname = vim_strsave(fname);\n\tvim_free(buf);\n    }\n    return new_fname;\n}\n\n/*\n * return TRUE if \"fname\" exists.\n */\n    int\nvim_fexists(char_u *fname)\n{\n    stat_T st;\n\n    if (mch_stat((char *)fname, &st))\n\treturn FALSE;\n    return TRUE;\n}\n\n/*\n * Invoke expand_wildcards() for one pattern.\n * Expand items like \"%:h\" before the expansion.\n * Returns OK or FAIL.\n */\n    int\nexpand_wildcards_eval(\n    char_u\t **pat,\t\t// pointer to input pattern\n    int\t\t  *num_file,\t// resulting number of files\n    char_u\t***file,\t// array of resulting files\n    int\t\t   flags)\t// EW_DIR, etc.\n{\n    int\t\tret = FAIL;\n    char_u\t*eval_pat = NULL;\n    char_u\t*exp_pat = *pat;\n    char      *ignored_msg;\n    int\t\tusedlen;\n\n    if (*exp_pat == '%' || *exp_pat == '#' || *exp_pat == '<')\n    {\n\t++emsg_off;\n\teval_pat = eval_vars(exp_pat, exp_pat, &usedlen,\n\t\t\t\t\t\t    NULL, &ignored_msg, NULL);\n\t--emsg_off;\n\tif (eval_pat != NULL)\n\t    exp_pat = concat_str(eval_pat, exp_pat + usedlen);\n    }\n\n    if (exp_pat != NULL)\n\tret = expand_wildcards(1, &exp_pat, num_file, file, flags);\n\n    if (eval_pat != NULL)\n    {\n\tvim_free(exp_pat);\n\tvim_free(eval_pat);\n    }\n\n    return ret;\n}\n\n/*\n * Expand wildcards.  Calls gen_expand_wildcards() and removes files matching\n * 'wildignore'.\n * Returns OK or FAIL.  When FAIL then \"num_files\" won't be set.\n */\n    int\nexpand_wildcards(\n    int\t\t   num_pat,\t// number of input patterns\n    char_u\t **pat,\t\t// array of input patterns\n    int\t\t  *num_files,\t// resulting number of files\n    char_u\t***files,\t// array of resulting files\n    int\t\t   flags)\t// EW_DIR, etc.\n{\n    int\t\tretval;\n    int\t\ti, j;\n    char_u\t*p;\n    int\t\tnon_suf_match;\t// number without matching suffix\n\n    retval = gen_expand_wildcards(num_pat, pat, num_files, files, flags);\n\n    // When keeping all matches, return here\n    if ((flags & EW_KEEPALL) || retval == FAIL)\n\treturn retval;\n\n#ifdef FEAT_WILDIGN\n    /*\n     * Remove names that match 'wildignore'.\n     */\n    if (*p_wig)\n    {\n\tchar_u\t*ffname;\n\n\t// check all files in (*files)[]\n\tfor (i = 0; i < *num_files; ++i)\n\t{\n\t    ffname = FullName_save((*files)[i], FALSE);\n\t    if (ffname == NULL)\t\t// out of memory\n\t\tbreak;\n# ifdef VMS\n\t    vms_remove_version(ffname);\n# endif\n\t    if (match_file_list(p_wig, (*files)[i], ffname))\n\t    {\n\t\t// remove this matching file from the list\n\t\tvim_free((*files)[i]);\n\t\tfor (j = i; j + 1 < *num_files; ++j)\n\t\t    (*files)[j] = (*files)[j + 1];\n\t\t--*num_files;\n\t\t--i;\n\t    }\n\t    vim_free(ffname);\n\t}\n\n\t// If the number of matches is now zero, we fail.\n\tif (*num_files == 0)\n\t{\n\t    VIM_CLEAR(*files);\n\t    return FAIL;\n\t}\n    }\n#endif\n\n    /*\n     * Move the names where 'suffixes' match to the end.\n     */\n    if (*num_files > 1)\n    {\n\tnon_suf_match = 0;\n\tfor (i = 0; i < *num_files; ++i)\n\t{\n\t    if (!match_suffix((*files)[i]))\n\t    {\n\t\t/*\n\t\t * Move the name without matching suffix to the front\n\t\t * of the list.\n\t\t */\n\t\tp = (*files)[i];\n\t\tfor (j = i; j > non_suf_match; --j)\n\t\t    (*files)[j] = (*files)[j - 1];\n\t\t(*files)[non_suf_match++] = p;\n\t    }\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if \"fname\" matches with an entry in 'suffixes'.\n */\n    int\nmatch_suffix(char_u *fname)\n{\n    int\t\tfnamelen, setsuflen;\n    char_u\t*setsuf;\n#define MAXSUFLEN 30\t    // maximum length of a file suffix\n    char_u\tsuf_buf[MAXSUFLEN];\n\n    fnamelen = (int)STRLEN(fname);\n    setsuflen = 0;\n    for (setsuf = p_su; *setsuf; )\n    {\n\tsetsuflen = copy_option_part(&setsuf, suf_buf, MAXSUFLEN, \".,\");\n\tif (setsuflen == 0)\n\t{\n\t    char_u *tail = gettail(fname);\n\n\t    // empty entry: match name without a '.'\n\t    if (vim_strchr(tail, '.') == NULL)\n\t    {\n\t\tsetsuflen = 1;\n\t\tbreak;\n\t    }\n\t}\n\telse\n\t{\n\t    if (fnamelen >= setsuflen\n\t\t    && fnamencmp(suf_buf, fname + fnamelen - setsuflen,\n\t\t\t\t\t\t  (size_t)setsuflen) == 0)\n\t\tbreak;\n\t    setsuflen = 0;\n\t}\n    }\n    return (setsuflen != 0);\n}\n\n#ifdef VIM_BACKTICK\n\n/*\n * Return TRUE if we can expand this backtick thing here.\n */\n    static int\nvim_backtick(char_u *p)\n{\n    return (*p == '`' && *(p + 1) != NUL && *(p + STRLEN(p) - 1) == '`');\n}\n\n/*\n * Expand an item in `backticks` by executing it as a command.\n * Currently only works when pat[] starts and ends with a `.\n * Returns number of file names found, -1 if an error is encountered.\n */\n    static int\nexpand_backtick(\n    garray_T\t*gap,\n    char_u\t*pat,\n    int\t\tflags)\t// EW_* flags\n{\n    char_u\t*p;\n    char_u\t*cmd;\n    char_u\t*buffer;\n    int\t\tcnt = 0;\n    int\t\ti;\n\n    // Create the command: lop off the backticks.\n    cmd = vim_strnsave(pat + 1, STRLEN(pat) - 2);\n    if (cmd == NULL)\n\treturn -1;\n\n#ifdef FEAT_EVAL\n    if (*cmd == '=')\t    // `={expr}`: Expand expression\n\tbuffer = eval_to_string(cmd + 1, TRUE);\n    else\n#endif\n\tbuffer = get_cmd_output(cmd, NULL,\n\t\t\t\t(flags & EW_SILENT) ? SHELL_SILENT : 0, NULL);\n    vim_free(cmd);\n    if (buffer == NULL)\n\treturn -1;\n\n    cmd = buffer;\n    while (*cmd != NUL)\n    {\n\tcmd = skipwhite(cmd);\t\t// skip over white space\n\tp = cmd;\n\twhile (*p != NUL && *p != '\\r' && *p != '\\n') // skip over entry\n\t    ++p;\n\t// add an entry if it is not empty\n\tif (p > cmd)\n\t{\n\t    i = *p;\n\t    *p = NUL;\n\t    addfile(gap, cmd, flags);\n\t    *p = i;\n\t    ++cnt;\n\t}\n\tcmd = p;\n\twhile (*cmd != NUL && (*cmd == '\\r' || *cmd == '\\n'))\n\t    ++cmd;\n    }\n\n    vim_free(buffer);\n    return cnt;\n}\n#endif // VIM_BACKTICK\n\n#if defined(MSWIN)\n/*\n * File name expansion code for MS-DOS, Win16 and Win32.  It's here because\n * it's shared between these systems.\n */\n\n/*\n * comparison function for qsort in dos_expandpath()\n */\n    static int\npstrcmp(const void *a, const void *b)\n{\n    return (pathcmp(*(char **)a, *(char **)b, -1));\n}\n\n/*\n * Recursively expand one path component into all matching files and/or\n * directories.  Adds matches to \"gap\".  Handles \"*\", \"?\", \"[a-z]\", \"**\", etc.\n * Return the number of matches found.\n * \"path\" has backslashes before chars that are not to be expanded, starting\n * at \"path[wildoff]\".\n * Return the number of matches found.\n * NOTE: much of this is identical to unix_expandpath(), keep in sync!\n */\n    static int\ndos_expandpath(\n    garray_T\t*gap,\n    char_u\t*path,\n    int\t\twildoff,\n    int\t\tflags,\t\t// EW_* flags\n    int\t\tdidstar)\t// expanded \"**\" once already\n{\n    char_u\t*buf;\n    char_u\t*path_end;\n    char_u\t*p, *s, *e;\n    int\t\tstart_len = gap->ga_len;\n    char_u\t*pat;\n    regmatch_T\tregmatch;\n    int\t\tstarts_with_dot;\n    int\t\tmatches;\n    int\t\tlen;\n    int\t\tstarstar = FALSE;\n    static int\tstardepth = 0;\t    // depth for \"**\" expansion\n    HANDLE\t\thFind = INVALID_HANDLE_VALUE;\n    WIN32_FIND_DATAW    wfb;\n    WCHAR\t\t*wn = NULL;\t// UCS-2 name, NULL when not used.\n    char_u\t\t*matchname;\n    int\t\t\tok;\n    char_u\t\t*p_alt;\n\n    // Expanding \"**\" may take a long time, check for CTRL-C.\n    if (stardepth > 0)\n    {\n\tui_breakcheck();\n\tif (got_int)\n\t    return 0;\n    }\n\n    // Make room for file name.  When doing encoding conversion the actual\n    // length may be quite a bit longer, thus use the maximum possible length.\n    buf = alloc(MAXPATHL);\n    if (buf == NULL)\n\treturn 0;\n\n    /*\n     * Find the first part in the path name that contains a wildcard or a ~1.\n     * Copy it into buf, including the preceding characters.\n     */\n    p = buf;\n    s = buf;\n    e = NULL;\n    path_end = path;\n    while (*path_end != NUL)\n    {\n\t// May ignore a wildcard that has a backslash before it; it will\n\t// be removed by rem_backslash() or file_pat_to_reg_pat() below.\n\tif (path_end >= path + wildoff && rem_backslash(path_end))\n\t    *p++ = *path_end++;\n\telse if (*path_end == '\\\\' || *path_end == ':' || *path_end == '/')\n\t{\n\t    if (e != NULL)\n\t\tbreak;\n\t    s = p + 1;\n\t}\n\telse if (path_end >= path + wildoff\n\t\t\t && vim_strchr((char_u *)\"*?[~\", *path_end) != NULL)\n\t    e = p;\n\tif (has_mbyte)\n\t{\n\t    len = (*mb_ptr2len)(path_end);\n\t    STRNCPY(p, path_end, len);\n\t    p += len;\n\t    path_end += len;\n\t}\n\telse\n\t    *p++ = *path_end++;\n    }\n    e = p;\n    *e = NUL;\n\n    // now we have one wildcard component between s and e\n    // Remove backslashes between \"wildoff\" and the start of the wildcard\n    // component.\n    for (p = buf + wildoff; p < s; ++p)\n\tif (rem_backslash(p))\n\t{\n\t    STRMOVE(p, p + 1);\n\t    --e;\n\t    --s;\n\t}\n\n    // Check for \"**\" between \"s\" and \"e\".\n    for (p = s; p < e; ++p)\n\tif (p[0] == '*' && p[1] == '*')\n\t    starstar = TRUE;\n\n    starts_with_dot = *s == '.';\n    pat = file_pat_to_reg_pat(s, e, NULL, FALSE);\n    if (pat == NULL)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // compile the regexp into a program\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t++emsg_silent;\n    regmatch.rm_ic = TRUE;\t\t// Always ignore case\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC);\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t--emsg_silent;\n    vim_free(pat);\n\n    if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // remember the pattern or file name being looked for\n    matchname = vim_strsave(s);\n\n    // If \"**\" is by itself, this is the first time we encounter it and more\n    // is following then find matches without any directory.\n    if (!didstar && stardepth < 100 && starstar && e - s == 2\n\t\t\t\t\t\t\t  && *path_end == '/')\n    {\n\tSTRCPY(s, path_end + 1);\n\t++stardepth;\n\t(void)dos_expandpath(gap, buf, (int)(s - buf), flags, TRUE);\n\t--stardepth;\n    }\n\n    // Scan all files in the directory with \"dir/ *.*\"\n    STRCPY(s, \"*.*\");\n    wn = enc_to_utf16(buf, NULL);\n    if (wn != NULL)\n\thFind = FindFirstFileW(wn, &wfb);\n    ok = (hFind != INVALID_HANDLE_VALUE);\n\n    while (ok)\n    {\n\tp = utf16_to_enc(wfb.cFileName, NULL);   // p is allocated here\n\n\tif (p == NULL)\n\t    break;  // out of memory\n\n\t// Do not use the alternate filename when the file name ends in '~',\n\t// because it picks up backup files: short name for \"foo.vim~\" is\n\t// \"foo~1.vim\", which matches \"*.vim\".\n\tif (*wfb.cAlternateFileName == NUL || p[STRLEN(p) - 1] == '~')\n\t    p_alt = NULL;\n\telse\n\t    p_alt = utf16_to_enc(wfb.cAlternateFileName, NULL);\n\n\t// Ignore entries starting with a dot, unless when asked for.  Accept\n\t// all entries found with \"matchname\".\n\tif ((p[0] != '.' || starts_with_dot\n\t\t\t || ((flags & EW_DODOT)\n\t\t\t     && p[1] != NUL && (p[1] != '.' || p[2] != NUL)))\n\t\t&& (matchname == NULL\n\t\t  || (regmatch.regprog != NULL\n\t\t      && (vim_regexec(&regmatch, p, (colnr_T)0)\n\t\t\t || (p_alt != NULL\n\t\t\t\t&& vim_regexec(&regmatch, p_alt, (colnr_T)0))))\n\t\t  || ((flags & EW_NOTWILD)\n\t\t     && fnamencmp(path + (s - buf), p, e - s) == 0)))\n\t{\n\t    STRCPY(s, p);\n\t    len = (int)STRLEN(buf);\n\n\t    if (starstar && stardepth < 100\n\t\t\t  && (wfb.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))\n\t    {\n\t\t// For \"**\" in the pattern first go deeper in the tree to\n\t\t// find matches.\n\t\tSTRCPY(buf + len, \"/**\");\n\t\tSTRCPY(buf + len + 3, path_end);\n\t\t++stardepth;\n\t\t(void)dos_expandpath(gap, buf, len + 1, flags, TRUE);\n\t\t--stardepth;\n\t    }\n\n\t    STRCPY(buf + len, path_end);\n\t    if (mch_has_exp_wildcard(path_end))\n\t    {\n\t\t// need to expand another component of the path\n\t\t// remove backslashes for the remaining components only\n\t\t(void)dos_expandpath(gap, buf, len + 1, flags, FALSE);\n\t    }\n\t    else\n\t    {\n\t\t// no more wildcards, check if there is a match\n\t\t// remove backslashes for the remaining components only\n\t\tif (*path_end != 0)\n\t\t    backslash_halve(buf + len + 1);\n\t\tif (mch_getperm(buf) >= 0)\t// add existing file\n\t\t    addfile(gap, buf, flags);\n\t    }\n\t}\n\n\tvim_free(p_alt);\n\tvim_free(p);\n\tok = FindNextFileW(hFind, &wfb);\n    }\n\n    FindClose(hFind);\n    vim_free(wn);\n    vim_free(buf);\n    vim_regfree(regmatch.regprog);\n    vim_free(matchname);\n\n    matches = gap->ga_len - start_len;\n    if (matches > 0)\n\tqsort(((char_u **)gap->ga_data) + start_len, (size_t)matches,\n\t\t\t\t\t\t   sizeof(char_u *), pstrcmp);\n    return matches;\n}\n\n    int\nmch_expandpath(\n    garray_T\t*gap,\n    char_u\t*path,\n    int\t\tflags)\t\t// EW_* flags\n{\n    return dos_expandpath(gap, path, 0, flags, FALSE);\n}\n#endif // MSWIN\n\n#if (defined(UNIX) && !defined(VMS)) || defined(USE_UNIXFILENAME) \\\n\t|| defined(PROTO)\n/*\n * Unix style wildcard expansion code.\n * It's here because it's used both for Unix and Mac.\n */\n    static int\npstrcmp(const void *a, const void *b)\n{\n    return (pathcmp(*(char **)a, *(char **)b, -1));\n}\n\n/*\n * Recursively expand one path component into all matching files and/or\n * directories.  Adds matches to \"gap\".  Handles \"*\", \"?\", \"[a-z]\", \"**\", etc.\n * \"path\" has backslashes before chars that are not to be expanded, starting\n * at \"path + wildoff\".\n * Return the number of matches found.\n * NOTE: much of this is identical to dos_expandpath(), keep in sync!\n */\n    int\nunix_expandpath(\n    garray_T\t*gap,\n    char_u\t*path,\n    int\t\twildoff,\n    int\t\tflags,\t\t// EW_* flags\n    int\t\tdidstar)\t// expanded \"**\" once already\n{\n    char_u\t*buf;\n    char_u\t*path_end;\n    char_u\t*p, *s, *e;\n    int\t\tstart_len = gap->ga_len;\n    char_u\t*pat;\n    regmatch_T\tregmatch;\n    int\t\tstarts_with_dot;\n    int\t\tmatches;\n    int\t\tlen;\n    int\t\tstarstar = FALSE;\n    static int\tstardepth = 0;\t    // depth for \"**\" expansion\n\n    DIR\t\t*dirp;\n    struct dirent *dp;\n\n    // Expanding \"**\" may take a long time, check for CTRL-C.\n    if (stardepth > 0)\n    {\n\tui_breakcheck();\n\tif (got_int)\n\t    return 0;\n    }\n\n    // make room for file name\n    buf = alloc(STRLEN(path) + BASENAMELEN + 5);\n    if (buf == NULL)\n\treturn 0;\n\n    /*\n     * Find the first part in the path name that contains a wildcard.\n     * When EW_ICASE is set every letter is considered to be a wildcard.\n     * Copy it into \"buf\", including the preceding characters.\n     */\n    p = buf;\n    s = buf;\n    e = NULL;\n    path_end = path;\n    while (*path_end != NUL)\n    {\n\t// May ignore a wildcard that has a backslash before it; it will\n\t// be removed by rem_backslash() or file_pat_to_reg_pat() below.\n\tif (path_end >= path + wildoff && rem_backslash(path_end))\n\t    *p++ = *path_end++;\n\telse if (*path_end == '/')\n\t{\n\t    if (e != NULL)\n\t\tbreak;\n\t    s = p + 1;\n\t}\n\telse if (path_end >= path + wildoff\n\t\t\t && (vim_strchr((char_u *)\"*?[{~$\", *path_end) != NULL\n\t\t\t     || (!p_fic && (flags & EW_ICASE)\n\t\t\t\t\t     && isalpha(PTR2CHAR(path_end)))))\n\t    e = p;\n\tif (has_mbyte)\n\t{\n\t    len = (*mb_ptr2len)(path_end);\n\t    STRNCPY(p, path_end, len);\n\t    p += len;\n\t    path_end += len;\n\t}\n\telse\n\t    *p++ = *path_end++;\n    }\n    e = p;\n    *e = NUL;\n\n    // Now we have one wildcard component between \"s\" and \"e\".\n    // Remove backslashes between \"wildoff\" and the start of the wildcard\n    // component.\n    for (p = buf + wildoff; p < s; ++p)\n\tif (rem_backslash(p))\n\t{\n\t    STRMOVE(p, p + 1);\n\t    --e;\n\t    --s;\n\t}\n\n    // Check for \"**\" between \"s\" and \"e\".\n    for (p = s; p < e; ++p)\n\tif (p[0] == '*' && p[1] == '*')\n\t    starstar = TRUE;\n\n    // convert the file pattern to a regexp pattern\n    starts_with_dot = *s == '.';\n    pat = file_pat_to_reg_pat(s, e, NULL, FALSE);\n    if (pat == NULL)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // compile the regexp into a program\n    if (flags & EW_ICASE)\n\tregmatch.rm_ic = TRUE;\t\t// 'wildignorecase' set\n    else\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t++emsg_silent;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC);\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t--emsg_silent;\n    vim_free(pat);\n\n    if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // If \"**\" is by itself, this is the first time we encounter it and more\n    // is following then find matches without any directory.\n    if (!didstar && stardepth < 100 && starstar && e - s == 2\n\t\t\t\t\t\t\t  && *path_end == '/')\n    {\n\tSTRCPY(s, path_end + 1);\n\t++stardepth;\n\t(void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE);\n\t--stardepth;\n    }\n\n    // open the directory for scanning\n    *s = NUL;\n    dirp = opendir(*buf == NUL ? \".\" : (char *)buf);\n\n    // Find all matching entries\n    if (dirp != NULL)\n    {\n\tfor (;;)\n\t{\n\t    dp = readdir(dirp);\n\t    if (dp == NULL)\n\t\tbreak;\n\t    if ((dp->d_name[0] != '.' || starts_with_dot\n\t\t\t|| ((flags & EW_DODOT)\n\t\t\t    && dp->d_name[1] != NUL\n\t\t\t    && (dp->d_name[1] != '.' || dp->d_name[2] != NUL)))\n\t\t && ((regmatch.regprog != NULL && vim_regexec(&regmatch,\n\t\t\t\t\t     (char_u *)dp->d_name, (colnr_T)0))\n\t\t   || ((flags & EW_NOTWILD)\n\t\t     && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0)))\n\t    {\n\t\tSTRCPY(s, dp->d_name);\n\t\tlen = STRLEN(buf);\n\n\t\tif (starstar && stardepth < 100)\n\t\t{\n\t\t    // For \"**\" in the pattern first go deeper in the tree to\n\t\t    // find matches.\n\t\t    STRCPY(buf + len, \"/**\");\n\t\t    STRCPY(buf + len + 3, path_end);\n\t\t    ++stardepth;\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, TRUE);\n\t\t    --stardepth;\n\t\t}\n\n\t\tSTRCPY(buf + len, path_end);\n\t\tif (mch_has_exp_wildcard(path_end)) // handle more wildcards\n\t\t{\n\t\t    // need to expand another component of the path\n\t\t    // remove backslashes for the remaining components only\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    stat_T  sb;\n\n\t\t    // no more wildcards, check if there is a match\n\t\t    // remove backslashes for the remaining components only\n\t\t    if (*path_end != NUL)\n\t\t\tbackslash_halve(buf + len + 1);\n\t\t    // add existing file or symbolic link\n\t\t    if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0\n\t\t\t\t\t\t      : mch_getperm(buf) >= 0)\n\t\t    {\n#ifdef MACOS_CONVERT\n\t\t\tsize_t precomp_len = STRLEN(buf)+1;\n\t\t\tchar_u *precomp_buf =\n\t\t\t    mac_precompose_path(buf, precomp_len, &precomp_len);\n\n\t\t\tif (precomp_buf)\n\t\t\t{\n\t\t\t    mch_memmove(buf, precomp_buf, precomp_len);\n\t\t\t    vim_free(precomp_buf);\n\t\t\t}\n#endif\n\t\t\taddfile(gap, buf, flags);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tclosedir(dirp);\n    }\n\n    vim_free(buf);\n    vim_regfree(regmatch.regprog);\n\n    matches = gap->ga_len - start_len;\n    if (matches > 0)\n\tqsort(((char_u **)gap->ga_data) + start_len, matches,\n\t\t\t\t\t\t   sizeof(char_u *), pstrcmp);\n    return matches;\n}\n#endif\n\n/*\n * Return TRUE if \"p\" contains what looks like an environment variable.\n * Allowing for escaping.\n */\n    static int\nhas_env_var(char_u *p)\n{\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t    ++p;\n\telse if (vim_strchr((char_u *)\n#if defined(MSWIN)\n\t\t\t\t    \"$%\"\n#else\n\t\t\t\t    \"$\"\n#endif\n\t\t\t\t\t, *p) != NULL)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n#ifdef SPECIAL_WILDCHAR\n/*\n * Return TRUE if \"p\" contains a special wildcard character, one that Vim\n * cannot expand, requires using a shell.\n */\n    static int\nhas_special_wildchar(char_u *p)\n{\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\t// Disallow line break characters.\n\tif (*p == '\\r' || *p == '\\n')\n\t    break;\n\t// Allow for escaping.\n\tif (*p == '\\\\' && p[1] != NUL && p[1] != '\\r' && p[1] != '\\n')\n\t    ++p;\n\telse if (vim_strchr((char_u *)SPECIAL_WILDCHAR, *p) != NULL)\n\t{\n\t    // A { must be followed by a matching }.\n\t    if (*p == '{' && vim_strchr(p, '}') == NULL)\n\t\tcontinue;\n\t    // A quote and backtick must be followed by another one.\n\t    if ((*p == '`' || *p == '\\'') && vim_strchr(p, *p) == NULL)\n\t\tcontinue;\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Generic wildcard expansion code.\n *\n * Characters in \"pat\" that should not be expanded must be preceded with a\n * backslash. E.g., \"/path\\ with\\ spaces/my\\*star*\"\n *\n * Return FAIL when no single file was found.  In this case \"num_file\" is not\n * set, and \"file\" may contain an error message.\n * Return OK when some files found.  \"num_file\" is set to the number of\n * matches, \"file\" to the array of matches.  Call FreeWild() later.\n */\n    int\ngen_expand_wildcards(\n    int\t\tnum_pat,\t// number of input patterns\n    char_u\t**pat,\t\t// array of input patterns\n    int\t\t*num_file,\t// resulting number of files\n    char_u\t***file,\t// array of resulting files\n    int\t\tflags)\t\t// EW_* flags\n{\n    int\t\t\ti;\n    garray_T\t\tga;\n    char_u\t\t*p;\n    static int\t\trecursive = FALSE;\n    int\t\t\tadd_pat;\n    int\t\t\tretval = OK;\n#if defined(FEAT_SEARCHPATH)\n    int\t\t\tdid_expand_in_path = FALSE;\n#endif\n\n    /*\n     * expand_env() is called to expand things like \"~user\".  If this fails,\n     * it calls ExpandOne(), which brings us back here.  In this case, always\n     * call the machine specific expansion function, if possible.  Otherwise,\n     * return FAIL.\n     */\n    if (recursive)\n#ifdef SPECIAL_WILDCHAR\n\treturn mch_expand_wildcards(num_pat, pat, num_file, file, flags);\n#else\n\treturn FAIL;\n#endif\n\n#ifdef SPECIAL_WILDCHAR\n    /*\n     * If there are any special wildcard characters which we cannot handle\n     * here, call machine specific function for all the expansion.  This\n     * avoids starting the shell for each argument separately.\n     * For `=expr` do use the internal function.\n     */\n    for (i = 0; i < num_pat; i++)\n    {\n\tif (has_special_wildchar(pat[i])\n# ifdef VIM_BACKTICK\n\t\t&& !(vim_backtick(pat[i]) && pat[i][1] == '=')\n# endif\n\t   )\n\t    return mch_expand_wildcards(num_pat, pat, num_file, file, flags);\n    }\n#endif\n\n    recursive = TRUE;\n\n    /*\n     * The matching file names are stored in a growarray.  Init it empty.\n     */\n    ga_init2(&ga, sizeof(char_u *), 30);\n\n    for (i = 0; i < num_pat; ++i)\n    {\n\tadd_pat = -1;\n\tp = pat[i];\n\n#ifdef VIM_BACKTICK\n\tif (vim_backtick(p))\n\t{\n\t    add_pat = expand_backtick(&ga, p, flags);\n\t    if (add_pat == -1)\n\t\tretval = FAIL;\n\t}\n\telse\n#endif\n\t{\n\t    /*\n\t     * First expand environment variables, \"~/\" and \"~user/\".\n\t     */\n\t    if ((has_env_var(p) && !(flags & EW_NOTENV)) || *p == '~')\n\t    {\n\t\tp = expand_env_save_opt(p, TRUE);\n\t\tif (p == NULL)\n\t\t    p = pat[i];\n#ifdef UNIX\n\t\t/*\n\t\t * On Unix, if expand_env() can't expand an environment\n\t\t * variable, use the shell to do that.  Discard previously\n\t\t * found file names and start all over again.\n\t\t */\n\t\telse if (has_env_var(p) || *p == '~')\n\t\t{\n\t\t    vim_free(p);\n\t\t    ga_clear_strings(&ga);\n\t\t    i = mch_expand_wildcards(num_pat, pat, num_file, file,\n\t\t\t\t\t\t\t flags|EW_KEEPDOLLAR);\n\t\t    recursive = FALSE;\n\t\t    return i;\n\t\t}\n#endif\n\t    }\n\n\t    /*\n\t     * If there are wildcards: Expand file names and add each match to\n\t     * the list.  If there is no match, and EW_NOTFOUND is given, add\n\t     * the pattern.\n\t     * If there are no wildcards: Add the file name if it exists or\n\t     * when EW_NOTFOUND is given.\n\t     */\n\t    if (mch_has_exp_wildcard(p))\n\t    {\n#if defined(FEAT_SEARCHPATH)\n\t\tif ((flags & EW_PATH)\n\t\t\t&& !mch_isFullName(p)\n\t\t\t&& !(p[0] == '.'\n\t\t\t    && (vim_ispathsep(p[1])\n\t\t\t\t|| (p[1] == '.' && vim_ispathsep(p[2]))))\n\t\t   )\n\t\t{\n\t\t    // :find completion where 'path' is used.\n\t\t    // Recursiveness is OK here.\n\t\t    recursive = FALSE;\n\t\t    add_pat = expand_in_path(&ga, p, flags);\n\t\t    recursive = TRUE;\n\t\t    did_expand_in_path = TRUE;\n\t\t}\n\t\telse\n#endif\n\t\t    add_pat = mch_expandpath(&ga, p, flags);\n\t    }\n\t}\n\n\tif (add_pat == -1 || (add_pat == 0 && (flags & EW_NOTFOUND)))\n\t{\n\t    char_u\t*t = backslash_halve_save(p);\n\n\t    // When EW_NOTFOUND is used, always add files and dirs.  Makes\n\t    // \"vim c:/\" work.\n\t    if (flags & EW_NOTFOUND)\n\t\taddfile(&ga, t, flags | EW_DIR | EW_FILE);\n\t    else\n\t\taddfile(&ga, t, flags);\n\n\t    if (t != p)\n\t\tvim_free(t);\n\t}\n\n#if defined(FEAT_SEARCHPATH)\n\tif (did_expand_in_path && ga.ga_len > 0 && (flags & EW_PATH))\n\t    uniquefy_paths(&ga, p);\n#endif\n\tif (p != pat[i])\n\t    vim_free(p);\n    }\n\n    // When returning FAIL the array must be freed here.\n    if (retval == FAIL)\n\tga_clear(&ga);\n\n    *num_file = ga.ga_len;\n    *file = (ga.ga_data != NULL) ? (char_u **)ga.ga_data\n\t\t\t\t\t\t  : (char_u **)_(\"no matches\");\n\n    recursive = FALSE;\n\n    return ((flags & EW_EMPTYOK) || ga.ga_data != NULL) ? retval : FAIL;\n}\n\n/*\n * Add a file to a file list.  Accepted flags:\n * EW_DIR\tadd directories\n * EW_FILE\tadd files\n * EW_EXEC\tadd executable files\n * EW_NOTFOUND\tadd even when it doesn't exist\n * EW_ADDSLASH\tadd slash after directory name\n * EW_ALLLINKS\tadd symlink also when the referred file does not exist\n */\n    void\naddfile(\n    garray_T\t*gap,\n    char_u\t*f,\t// filename\n    int\t\tflags)\n{\n    char_u\t*p;\n    int\t\tisdir;\n    stat_T\tsb;\n\n    // if the file/dir/link doesn't exist, may not add it\n    if (!(flags & EW_NOTFOUND) && ((flags & EW_ALLLINKS)\n\t\t\t? mch_lstat((char *)f, &sb) < 0 : mch_getperm(f) < 0))\n\treturn;\n\n#ifdef FNAME_ILLEGAL\n    // if the file/dir contains illegal characters, don't add it\n    if (vim_strpbrk(f, (char_u *)FNAME_ILLEGAL) != NULL)\n\treturn;\n#endif\n\n    isdir = mch_isdir(f);\n    if ((isdir && !(flags & EW_DIR)) || (!isdir && !(flags & EW_FILE)))\n\treturn;\n\n    // If the file isn't executable, may not add it.  Do accept directories.\n    // When invoked from expand_shellcmd() do not use $PATH.\n    if (!isdir && (flags & EW_EXEC)\n\t\t\t     && !mch_can_exe(f, NULL, !(flags & EW_SHELLCMD)))\n\treturn;\n\n    // Make room for another item in the file list.\n    if (ga_grow(gap, 1) == FAIL)\n\treturn;\n\n    p = alloc(STRLEN(f) + 1 + isdir);\n    if (p == NULL)\n\treturn;\n\n    STRCPY(p, f);\n#ifdef BACKSLASH_IN_FILENAME\n    slash_adjust(p);\n#endif\n    /*\n     * Append a slash or backslash after directory names if none is present.\n     */\n#ifndef DONT_ADD_PATHSEP_TO_DIR\n    if (isdir && (flags & EW_ADDSLASH))\n\tadd_pathsep(p);\n#endif\n    ((char_u **)gap->ga_data)[gap->ga_len++] = p;\n}\n\n/*\n * Free the list of files returned by expand_wildcards() or other expansion\n * functions.\n */\n    void\nFreeWild(int count, char_u **files)\n{\n    if (count <= 0 || files == NULL)\n\treturn;\n    while (count--)\n\tvim_free(files[count]);\n    vim_free(files);\n}\n\n/*\n * Compare path \"p[]\" to \"q[]\".\n * If \"maxlen\" >= 0 compare \"p[maxlen]\" to \"q[maxlen]\"\n * Return value like strcmp(p, q), but consider path separators.\n */\n    int\npathcmp(const char *p, const char *q, int maxlen)\n{\n    int\t\ti, j;\n    int\t\tc1, c2;\n    const char\t*s = NULL;\n\n    for (i = 0, j = 0; maxlen < 0 || (i < maxlen && j < maxlen);)\n    {\n\tc1 = PTR2CHAR((char_u *)p + i);\n\tc2 = PTR2CHAR((char_u *)q + j);\n\n\t// End of \"p\": check if \"q\" also ends or just has a slash.\n\tif (c1 == NUL)\n\t{\n\t    if (c2 == NUL)  // full match\n\t\treturn 0;\n\t    s = q;\n\t    i = j;\n\t    break;\n\t}\n\n\t// End of \"q\": check if \"p\" just has a slash.\n\tif (c2 == NUL)\n\t{\n\t    s = p;\n\t    break;\n\t}\n\n\tif ((p_fic ? MB_TOUPPER(c1) != MB_TOUPPER(c2) : c1 != c2)\n#ifdef BACKSLASH_IN_FILENAME\n\t\t// consider '/' and '\\\\' to be equal\n\t\t&& !((c1 == '/' && c2 == '\\\\')\n\t\t    || (c1 == '\\\\' && c2 == '/'))\n#endif\n\t\t)\n\t{\n\t    if (vim_ispathsep(c1))\n\t\treturn -1;\n\t    if (vim_ispathsep(c2))\n\t\treturn 1;\n\t    return p_fic ? MB_TOUPPER(c1) - MB_TOUPPER(c2)\n\t\t    : c1 - c2;  // no match\n\t}\n\n\ti += mb_ptr2len((char_u *)p + i);\n\tj += mb_ptr2len((char_u *)q + j);\n    }\n    if (s == NULL)\t// \"i\" or \"j\" ran into \"maxlen\"\n\treturn 0;\n\n    c1 = PTR2CHAR((char_u *)s + i);\n    c2 = PTR2CHAR((char_u *)s + i + mb_ptr2len((char_u *)s + i));\n    // ignore a trailing slash, but not \"//\" or \":/\"\n    if (c2 == NUL\n\t    && i > 0\n\t    && !after_pathsep((char_u *)s, (char_u *)s + i)\n#ifdef BACKSLASH_IN_FILENAME\n\t    && (c1 == '/' || c1 == '\\\\')\n#else\n\t    && c1 == '/'\n#endif\n       )\n\treturn 0;   // match with trailing slash\n    if (s == q)\n\treturn -1;\t    // no match\n    return 1;\n}\n\n/*\n * Return TRUE if \"name\" is a full (absolute) path name or URL.\n */\n    int\nvim_isAbsName(char_u *name)\n{\n    return (path_with_url(name) != 0 || mch_isFullName(name));\n}\n\n/*\n * Get absolute file name into buffer \"buf[len]\".\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nvim_FullName(\n    char_u\t*fname,\n    char_u\t*buf,\n    int\t\tlen,\n    int\t\tforce)\t    // force expansion even when already absolute\n{\n    int\t\tretval = OK;\n    int\t\turl;\n\n    *buf = NUL;\n    if (fname == NULL)\n\treturn FAIL;\n\n    url = path_with_url(fname);\n    if (!url)\n\tretval = mch_FullName(fname, buf, len, force);\n    if (url || retval == FAIL)\n    {\n\t// something failed; use the file name (truncate when too long)\n\tvim_strncpy(buf, fname, len - 1);\n    }\n#if defined(MSWIN)\n    slash_adjust(buf);\n#endif\n    return retval;\n}\n", "/* charset.c */\nint init_chartab(void);\nint buf_init_chartab(buf_T *buf, int global);\nvoid trans_characters(char_u *buf, int bufsize);\nchar_u *transstr(char_u *s);\nchar_u *str_foldcase(char_u *str, int orglen, char_u *buf, int buflen);\nchar_u *transchar(int c);\nchar_u *transchar_buf(buf_T *buf, int c);\nchar_u *transchar_byte(int c);\nvoid transchar_nonprint(buf_T *buf, char_u *charbuf, int c);\nvoid transchar_hex(char_u *buf, int c);\nint byte2cells(int b);\nint char2cells(int c);\nint ptr2cells(char_u *p);\nint vim_strsize(char_u *s);\nint vim_strnsize(char_u *s, int len);\nint chartabsize(char_u *p, colnr_T col);\nint linetabsize(char_u *s);\nint linetabsize_col(int startcol, char_u *s);\nint win_linetabsize(win_T *wp, char_u *line, colnr_T len);\nint vim_isIDc(int c);\nint vim_isNormalIDc(int c);\nint vim_iswordc(int c);\nint vim_iswordc_buf(int c, buf_T *buf);\nint vim_iswordp(char_u *p);\nint vim_iswordp_buf(char_u *p, buf_T *buf);\nint vim_isfilec(int c);\nint vim_isfilec_or_wc(int c);\nint vim_isprintc(int c);\nint vim_isprintc_strict(int c);\nint lbr_chartabsize(char_u *line, unsigned char *s, colnr_T col);\nint lbr_chartabsize_adv(char_u *line, char_u **s, colnr_T col);\nint win_lbr_chartabsize(win_T *wp, char_u *line, char_u *s, colnr_T col, int *headp);\nvoid getvcol(win_T *wp, pos_T *pos, colnr_T *start, colnr_T *cursor, colnr_T *end);\ncolnr_T getvcol_nolist(pos_T *posp);\nvoid getvvcol(win_T *wp, pos_T *pos, colnr_T *start, colnr_T *cursor, colnr_T *end);\nvoid getvcols(win_T *wp, pos_T *pos1, pos_T *pos2, colnr_T *left, colnr_T *right);\nchar_u *skipwhite(char_u *q);\nchar_u *skipwhite_and_nl(char_u *q);\nint getwhitecols_curline(void);\nint getwhitecols(char_u *p);\nchar_u *skipdigits(char_u *q);\nchar_u *skipbin(char_u *q);\nchar_u *skiphex(char_u *q);\nchar_u *skiptobin(char_u *q);\nchar_u *skiptodigit(char_u *q);\nchar_u *skiptohex(char_u *q);\nint vim_isdigit(int c);\nint vim_isxdigit(int c);\nint vim_isbdigit(int c);\nint vim_islower(int c);\nint vim_isupper(int c);\nint vim_toupper(int c);\nint vim_tolower(int c);\nchar_u *skiptowhite(char_u *p);\nchar_u *skiptowhite_esc(char_u *p);\nlong getdigits(char_u **pp);\nlong getdigits_quoted(char_u **pp);\nint vim_isblankline(char_u *lbuf);\nvoid vim_str2nr(char_u *start, int *prep, int *len, int what, varnumber_T *nptr, uvarnumber_T *unptr, int maxlen, int strict);\nint hex2nr(int c);\nint hexhex2nr(char_u *p);\nint rem_backslash(char_u *str);\nvoid backslash_halve(char_u *p);\nchar_u *backslash_halve_save(char_u *p);\nvoid ebcdic2ascii(char_u *buffer, int len);\n/* vim: set ft=c : */\n", "\" Test 'autochdir' behavior\n\nsource check.vim\nCheckOption autochdir\n\nfunc Test_set_filename()\n  let cwd = getcwd()\n  call test_autochdir()\n  set acd\n\n  let s:li = []\n  autocmd DirChanged auto call add(s:li, \"autocd\")\n  autocmd DirChanged auto call add(s:li, expand(\"<afile>\"))\n\n  new\n  w samples/Xtest\n  call assert_equal(\"Xtest\", expand('%'))\n  call assert_equal(\"samples\", substitute(getcwd(), '.*/\\(\\k*\\)', '\\1', ''))\n  call assert_equal([\"autocd\", getcwd()], s:li)\n\n  bwipe!\n  au! DirChanged\n  set noacd\n  call chdir(cwd)\n  call delete('samples/Xtest')\nendfunc\n\nfunc Test_set_filename_other_window()\n  let cwd = getcwd()\n  call test_autochdir()\n  call mkdir('Xa')\n  call mkdir('Xb')\n  call mkdir('Xc')\n  try\n    args Xa/aaa.txt Xb/bbb.txt\n    set acd\n    let winid = win_getid()\n    snext\n    call assert_equal('Xb', substitute(getcwd(), '.*/\\([^/]*\\)$', '\\1', ''))\n    call win_execute(winid, 'file ' .. cwd .. '/Xc/ccc.txt')\n    call assert_equal('Xb', substitute(getcwd(), '.*/\\([^/]*\\)$', '\\1', ''))\n  finally\n    set noacd\n    call chdir(cwd)\n    bwipe! aaa.txt\n    bwipe! bbb.txt\n    bwipe! ccc.txt\n    call delete('Xa', 'rf')\n    call delete('Xb', 'rf')\n    call delete('Xc', 'rf')\n  endtry\nendfunc\n\nfunc Test_acd_win_execute()\n  let cwd = getcwd()\n  set acd\n  call test_autochdir()\n\n  call mkdir('Xfile')\n  let winid = win_getid()\n  new Xfile/file\n  call assert_match('testdir.Xfile$', getcwd())\n  cd ..\n  call assert_match('testdir$', getcwd())\n  call win_execute(winid, 'echo')\n  call assert_match('testdir$', getcwd())\n\n  bwipe!\n  set noacd\n  call chdir(cwd)\n  call delete('Xfile', 'rf')\nendfunc\n\nfunc Test_verbose_pwd()\n  let cwd = getcwd()\n  call test_autochdir()\n\n  edit global.txt\n  call assert_match('\\[global\\].*testdir$', execute('verbose pwd'))\n\n  call mkdir('Xautodir')\n  split Xautodir/local.txt\n  lcd Xautodir\n  call assert_match('\\[window\\].*testdir[/\\\\]Xautodir', execute('verbose pwd'))\n\n  set acd\n  wincmd w\n  call assert_match('\\[autochdir\\].*testdir$', execute('verbose pwd'))\n  execute 'lcd' cwd\n  call assert_match('\\[window\\].*testdir$', execute('verbose pwd'))\n  execute 'tcd' cwd\n  call assert_match('\\[tabpage\\].*testdir$', execute('verbose pwd'))\n  execute 'cd' cwd\n  call assert_match('\\[global\\].*testdir$', execute('verbose pwd'))\n  edit\n  call assert_match('\\[autochdir\\].*testdir$', execute('verbose pwd'))\n  wincmd w\n  call assert_match('\\[autochdir\\].*testdir[/\\\\]Xautodir', execute('verbose pwd'))\n  set noacd\n  call assert_match('\\[autochdir\\].*testdir[/\\\\]Xautodir', execute('verbose pwd'))\n  wincmd w\n  call assert_match('\\[autochdir\\].*testdir[/\\\\]Xautodir', execute('verbose pwd'))\n  execute 'cd' cwd\n  call assert_match('\\[global\\].*testdir', execute('verbose pwd'))\n  wincmd w\n  call assert_match('\\[window\\].*testdir[/\\\\]Xautodir', execute('verbose pwd'))\n\n  bwipe!\n  call chdir(cwd)\n  call delete('Xautodir', 'rf')\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n#if defined(HAVE_WCHAR_H)\n# include <wchar.h>\t    // for towupper() and towlower()\n#endif\nstatic int win_nolbr_chartabsize(win_T *wp, char_u *s, colnr_T col, int *headp);\n\nstatic unsigned nr2hex(unsigned c);\n\nstatic int    chartab_initialized = FALSE;\n\n// b_chartab[] is an array of 32 bytes, each bit representing one of the\n// characters 0-255.\n#define SET_CHARTAB(buf, c) (buf)->b_chartab[(unsigned)(c) >> 3] |= (1 << ((c) & 0x7))\n#define RESET_CHARTAB(buf, c) (buf)->b_chartab[(unsigned)(c) >> 3] &= ~(1 << ((c) & 0x7))\n#define GET_CHARTAB(buf, c) ((buf)->b_chartab[(unsigned)(c) >> 3] & (1 << ((c) & 0x7)))\n\n// table used below, see init_chartab() for an explanation\nstatic char_u\tg_chartab[256];\n\n/*\n * Flags for g_chartab[].\n */\n#define CT_CELL_MASK\t0x07\t// mask: nr of display cells (1, 2 or 4)\n#define CT_PRINT_CHAR\t0x10\t// flag: set for printable chars\n#define CT_ID_CHAR\t0x20\t// flag: set for ID chars\n#define CT_FNAME_CHAR\t0x40\t// flag: set for file name chars\n\nstatic int in_win_border(win_T *wp, colnr_T vcol);\n\n/*\n * Fill g_chartab[].  Also fills curbuf->b_chartab[] with flags for keyword\n * characters for current buffer.\n *\n * Depends on the option settings 'iskeyword', 'isident', 'isfname',\n * 'isprint' and 'encoding'.\n *\n * The index in g_chartab[] depends on 'encoding':\n * - For non-multi-byte index with the byte (same as the character).\n * - For DBCS index with the first byte.\n * - For UTF-8 index with the character (when first byte is up to 0x80 it is\n *   the same as the character, if the first byte is 0x80 and above it depends\n *   on further bytes).\n *\n * The contents of g_chartab[]:\n * - The lower two bits, masked by CT_CELL_MASK, give the number of display\n *   cells the character occupies (1 or 2).  Not valid for UTF-8 above 0x80.\n * - CT_PRINT_CHAR bit is set when the character is printable (no need to\n *   translate the character before displaying it).  Note that only DBCS\n *   characters can have 2 display cells and still be printable.\n * - CT_FNAME_CHAR bit is set when the character can be in a file name.\n * - CT_ID_CHAR bit is set when the character can be in an identifier.\n *\n * Return FAIL if 'iskeyword', 'isident', 'isfname' or 'isprint' option has an\n * error, OK otherwise.\n */\n    int\ninit_chartab(void)\n{\n    return buf_init_chartab(curbuf, TRUE);\n}\n\n    int\nbuf_init_chartab(\n    buf_T\t*buf,\n    int\t\tglobal)\t\t// FALSE: only set buf->b_chartab[]\n{\n    int\t\tc;\n    int\t\tc2;\n    char_u\t*p;\n    int\t\ti;\n    int\t\ttilde;\n    int\t\tdo_isalpha;\n\n    if (global)\n    {\n\t/*\n\t * Set the default size for printable characters:\n\t * From <Space> to '~' is 1 (printable), others are 2 (not printable).\n\t * This also inits all 'isident' and 'isfname' flags to FALSE.\n\t */\n\tc = 0;\n\twhile (c < ' ')\n\t    g_chartab[c++] = (dy_flags & DY_UHEX) ? 4 : 2;\n\twhile (c <= '~')\n\t    g_chartab[c++] = 1 + CT_PRINT_CHAR;\n\twhile (c < 256)\n\t{\n\t    // UTF-8: bytes 0xa0 - 0xff are printable (latin1)\n\t    if (enc_utf8 && c >= 0xa0)\n\t\tg_chartab[c++] = CT_PRINT_CHAR + 1;\n\t    // euc-jp characters starting with 0x8e are single width\n\t    else if (enc_dbcs == DBCS_JPNU && c == 0x8e)\n\t\tg_chartab[c++] = CT_PRINT_CHAR + 1;\n\t    // other double-byte chars can be printable AND double-width\n\t    else if (enc_dbcs != 0 && MB_BYTE2LEN(c) == 2)\n\t\tg_chartab[c++] = CT_PRINT_CHAR + 2;\n\t    else\n\t\t// the rest is unprintable by default\n\t\tg_chartab[c++] = (dy_flags & DY_UHEX) ? 4 : 2;\n\t}\n\n\t// Assume that every multi-byte char is a filename character.\n\tfor (c = 1; c < 256; ++c)\n\t    if ((enc_dbcs != 0 && MB_BYTE2LEN(c) > 1)\n\t\t    || (enc_dbcs == DBCS_JPNU && c == 0x8e)\n\t\t    || (enc_utf8 && c >= 0xa0))\n\t\tg_chartab[c] |= CT_FNAME_CHAR;\n    }\n\n    /*\n     * Init word char flags all to FALSE\n     */\n    CLEAR_FIELD(buf->b_chartab);\n    if (enc_dbcs != 0)\n\tfor (c = 0; c < 256; ++c)\n\t{\n\t    // double-byte characters are probably word characters\n\t    if (MB_BYTE2LEN(c) == 2)\n\t\tSET_CHARTAB(buf, c);\n\t}\n\n#ifdef FEAT_LISP\n    /*\n     * In lisp mode the '-' character is included in keywords.\n     */\n    if (buf->b_p_lisp)\n\tSET_CHARTAB(buf, '-');\n#endif\n\n    // Walk through the 'isident', 'iskeyword', 'isfname' and 'isprint'\n    // options Each option is a list of characters, character numbers or\n    // ranges, separated by commas, e.g.: \"200-210,x,#-178,-\"\n    for (i = global ? 0 : 3; i <= 3; ++i)\n    {\n\tif (i == 0)\n\t    p = p_isi;\t\t// first round: 'isident'\n\telse if (i == 1)\n\t    p = p_isp;\t\t// second round: 'isprint'\n\telse if (i == 2)\n\t    p = p_isf;\t\t// third round: 'isfname'\n\telse\t// i == 3\n\t    p = buf->b_p_isk;\t// fourth round: 'iskeyword'\n\n\twhile (*p)\n\t{\n\t    tilde = FALSE;\n\t    do_isalpha = FALSE;\n\t    if (*p == '^' && p[1] != NUL)\n\t    {\n\t\ttilde = TRUE;\n\t\t++p;\n\t    }\n\t    if (VIM_ISDIGIT(*p))\n\t\tc = getdigits(&p);\n\t    else if (has_mbyte)\n\t\tc = mb_ptr2char_adv(&p);\n\t    else\n\t\tc = *p++;\n\t    c2 = -1;\n\t    if (*p == '-' && p[1] != NUL)\n\t    {\n\t\t++p;\n\t\tif (VIM_ISDIGIT(*p))\n\t\t    c2 = getdigits(&p);\n\t\telse if (has_mbyte)\n\t\t    c2 = mb_ptr2char_adv(&p);\n\t\telse\n\t\t    c2 = *p++;\n\t    }\n\t    if (c <= 0 || c >= 256 || (c2 < c && c2 != -1) || c2 >= 256\n\t\t\t\t\t\t || !(*p == NUL || *p == ','))\n\t\treturn FAIL;\n\n\t    if (c2 == -1)\t// not a range\n\t    {\n\t\t/*\n\t\t * A single '@' (not \"@-@\"):\n\t\t * Decide on letters being ID/printable/keyword chars with\n\t\t * standard function isalpha(). This takes care of locale for\n\t\t * single-byte characters).\n\t\t */\n\t\tif (c == '@')\n\t\t{\n\t\t    do_isalpha = TRUE;\n\t\t    c = 1;\n\t\t    c2 = 255;\n\t\t}\n\t\telse\n\t\t    c2 = c;\n\t    }\n\t    while (c <= c2)\n\t    {\n\t\t// Use the MB_ functions here, because isalpha() doesn't\n\t\t// work properly when 'encoding' is \"latin1\" and the locale is\n\t\t// \"C\".\n\t\tif (!do_isalpha || MB_ISLOWER(c) || MB_ISUPPER(c))\n\t\t{\n\t\t    if (i == 0)\t\t\t// (re)set ID flag\n\t\t    {\n\t\t\tif (tilde)\n\t\t\t    g_chartab[c] &= ~CT_ID_CHAR;\n\t\t\telse\n\t\t\t    g_chartab[c] |= CT_ID_CHAR;\n\t\t    }\n\t\t    else if (i == 1)\t\t// (re)set printable\n\t\t    {\n\t\t\tif ((c < ' ' || c > '~'\n\t\t\t\t// For double-byte we keep the cell width, so\n\t\t\t\t// that we can detect it from the first byte.\n\t\t\t    ) && !(enc_dbcs && MB_BYTE2LEN(c) == 2))\n\t\t\t{\n\t\t\t    if (tilde)\n\t\t\t    {\n\t\t\t\tg_chartab[c] = (g_chartab[c] & ~CT_CELL_MASK)\n\t\t\t\t\t     + ((dy_flags & DY_UHEX) ? 4 : 2);\n\t\t\t\tg_chartab[c] &= ~CT_PRINT_CHAR;\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tg_chartab[c] = (g_chartab[c] & ~CT_CELL_MASK) + 1;\n\t\t\t\tg_chartab[c] |= CT_PRINT_CHAR;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (i == 2)\t\t// (re)set fname flag\n\t\t    {\n\t\t\tif (tilde)\n\t\t\t    g_chartab[c] &= ~CT_FNAME_CHAR;\n\t\t\telse\n\t\t\t    g_chartab[c] |= CT_FNAME_CHAR;\n\t\t    }\n\t\t    else // i == 3\t\t (re)set keyword flag\n\t\t    {\n\t\t\tif (tilde)\n\t\t\t    RESET_CHARTAB(buf, c);\n\t\t\telse\n\t\t\t    SET_CHARTAB(buf, c);\n\t\t    }\n\t\t}\n\t\t++c;\n\t    }\n\n\t    c = *p;\n\t    p = skip_to_option_part(p);\n\t    if (c == ',' && *p == NUL)\n\t\t// Trailing comma is not allowed.\n\t\treturn FAIL;\n\t}\n    }\n    chartab_initialized = TRUE;\n    return OK;\n}\n\n/*\n * Translate any special characters in buf[bufsize] in-place.\n * The result is a string with only printable characters, but if there is not\n * enough room, not all characters will be translated.\n */\n    void\ntrans_characters(\n    char_u\t*buf,\n    int\t\tbufsize)\n{\n    int\t\tlen;\t\t// length of string needing translation\n    int\t\troom;\t\t// room in buffer after string\n    char_u\t*trs;\t\t// translated character\n    int\t\ttrs_len;\t// length of trs[]\n\n    len = (int)STRLEN(buf);\n    room = bufsize - len;\n    while (*buf != 0)\n    {\n\t// Assume a multi-byte character doesn't need translation.\n\tif (has_mbyte && (trs_len = (*mb_ptr2len)(buf)) > 1)\n\t    len -= trs_len;\n\telse\n\t{\n\t    trs = transchar_byte(*buf);\n\t    trs_len = (int)STRLEN(trs);\n\t    if (trs_len > 1)\n\t    {\n\t\troom -= trs_len - 1;\n\t\tif (room <= 0)\n\t\t    return;\n\t\tmch_memmove(buf + trs_len, buf + 1, (size_t)len);\n\t    }\n\t    mch_memmove(buf, trs, (size_t)trs_len);\n\t    --len;\n\t}\n\tbuf += trs_len;\n    }\n}\n\n/*\n * Translate a string into allocated memory, replacing special chars with\n * printable chars.  Returns NULL when out of memory.\n */\n    char_u *\ntransstr(char_u *s)\n{\n    char_u\t*res;\n    char_u\t*p;\n    int\t\tl, len, c;\n    char_u\thexbuf[11];\n\n    if (has_mbyte)\n    {\n\t// Compute the length of the result, taking account of unprintable\n\t// multi-byte characters.\n\tlen = 0;\n\tp = s;\n\twhile (*p != NUL)\n\t{\n\t    if ((l = (*mb_ptr2len)(p)) > 1)\n\t    {\n\t\tc = (*mb_ptr2char)(p);\n\t\tp += l;\n\t\tif (vim_isprintc(c))\n\t\t    len += l;\n\t\telse\n\t\t{\n\t\t    transchar_hex(hexbuf, c);\n\t\t    len += (int)STRLEN(hexbuf);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tl = byte2cells(*p++);\n\t\tif (l > 0)\n\t\t    len += l;\n\t\telse\n\t\t    len += 4;\t// illegal byte sequence\n\t    }\n\t}\n\tres = alloc(len + 1);\n    }\n    else\n\tres = alloc(vim_strsize(s) + 1);\n    if (res != NULL)\n    {\n\t*res = NUL;\n\tp = s;\n\twhile (*p != NUL)\n\t{\n\t    if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t    {\n\t\tc = (*mb_ptr2char)(p);\n\t\tif (vim_isprintc(c))\n\t\t    STRNCAT(res, p, l);\t// append printable multi-byte char\n\t\telse\n\t\t    transchar_hex(res + STRLEN(res), c);\n\t\tp += l;\n\t    }\n\t    else\n\t\tSTRCAT(res, transchar_byte(*p++));\n\t}\n    }\n    return res;\n}\n\n/*\n * Convert the string \"str[orglen]\" to do ignore-case comparing.  Uses the\n * current locale.\n * When \"buf\" is NULL returns an allocated string (NULL for out-of-memory).\n * Otherwise puts the result in \"buf[buflen]\".\n */\n    char_u *\nstr_foldcase(\n    char_u\t*str,\n    int\t\torglen,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    garray_T\tga;\n    int\t\ti;\n    int\t\tlen = orglen;\n\n#define GA_CHAR(i)  ((char_u *)ga.ga_data)[i]\n#define GA_PTR(i)   ((char_u *)ga.ga_data + (i))\n#define STR_CHAR(i)  (buf == NULL ? GA_CHAR(i) : buf[i])\n#define STR_PTR(i)   (buf == NULL ? GA_PTR(i) : buf + (i))\n\n    // Copy \"str\" into \"buf\" or allocated memory, unmodified.\n    if (buf == NULL)\n    {\n\tga_init2(&ga, 1, 10);\n\tif (ga_grow(&ga, len + 1) == FAIL)\n\t    return NULL;\n\tmch_memmove(ga.ga_data, str, (size_t)len);\n\tga.ga_len = len;\n    }\n    else\n    {\n\tif (len >= buflen)\t    // Ugly!\n\t    len = buflen - 1;\n\tmch_memmove(buf, str, (size_t)len);\n    }\n    if (buf == NULL)\n\tGA_CHAR(len) = NUL;\n    else\n\tbuf[len] = NUL;\n\n    // Make each character lower case.\n    i = 0;\n    while (STR_CHAR(i) != NUL)\n    {\n\tif (enc_utf8 || (has_mbyte && MB_BYTE2LEN(STR_CHAR(i)) > 1))\n\t{\n\t    if (enc_utf8)\n\t    {\n\t\tint\tc = utf_ptr2char(STR_PTR(i));\n\t\tint\tolen = utf_ptr2len(STR_PTR(i));\n\t\tint\tlc = utf_tolower(c);\n\n\t\t// Only replace the character when it is not an invalid\n\t\t// sequence (ASCII character or more than one byte) and\n\t\t// utf_tolower() doesn't return the original character.\n\t\tif ((c < 0x80 || olen > 1) && c != lc)\n\t\t{\n\t\t    int\t    nlen = utf_char2len(lc);\n\n\t\t    // If the byte length changes need to shift the following\n\t\t    // characters forward or backward.\n\t\t    if (olen != nlen)\n\t\t    {\n\t\t\tif (nlen > olen)\n\t\t\t{\n\t\t\t    if (buf == NULL\n\t\t\t\t    ? ga_grow(&ga, nlen - olen + 1) == FAIL\n\t\t\t\t    : len + nlen - olen >= buflen)\n\t\t\t    {\n\t\t\t\t// out of memory, keep old char\n\t\t\t\tlc = c;\n\t\t\t\tnlen = olen;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (olen != nlen)\n\t\t\t{\n\t\t\t    if (buf == NULL)\n\t\t\t    {\n\t\t\t\tSTRMOVE(GA_PTR(i) + nlen, GA_PTR(i) + olen);\n\t\t\t\tga.ga_len += nlen - olen;\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tSTRMOVE(buf + i + nlen, buf + i + olen);\n\t\t\t\tlen += nlen - olen;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    (void)utf_char2bytes(lc, STR_PTR(i));\n\t\t}\n\t    }\n\t    // skip to next multi-byte char\n\t    i += (*mb_ptr2len)(STR_PTR(i));\n\t}\n\telse\n\t{\n\t    if (buf == NULL)\n\t\tGA_CHAR(i) = TOLOWER_LOC(GA_CHAR(i));\n\t    else\n\t\tbuf[i] = TOLOWER_LOC(buf[i]);\n\t    ++i;\n\t}\n    }\n\n    if (buf == NULL)\n\treturn (char_u *)ga.ga_data;\n    return buf;\n}\n\n/*\n * Catch 22: g_chartab[] can't be initialized before the options are\n * initialized, and initializing options may cause transchar() to be called!\n * When chartab_initialized == FALSE don't use g_chartab[].\n * Does NOT work for multi-byte characters, c must be <= 255.\n * Also doesn't work for the first byte of a multi-byte, \"c\" must be a\n * character!\n */\nstatic char_u\ttranschar_charbuf[7];\n\n    char_u *\ntranschar(int c)\n{\n    return transchar_buf(curbuf, c);\n}\n\n    char_u *\ntranschar_buf(buf_T *buf, int c)\n{\n    int\t\t\ti;\n\n    i = 0;\n    if (IS_SPECIAL(c))\t    // special key code, display as ~@ char\n    {\n\ttranschar_charbuf[0] = '~';\n\ttranschar_charbuf[1] = '@';\n\ti = 2;\n\tc = K_SECOND(c);\n    }\n\n    if ((!chartab_initialized && ((c >= ' ' && c <= '~')))\n\t\t\t\t\t|| (c < 256 && vim_isprintc_strict(c)))\n    {\n\t// printable character\n\ttranschar_charbuf[i] = c;\n\ttranschar_charbuf[i + 1] = NUL;\n    }\n    else\n\ttranschar_nonprint(buf, transchar_charbuf + i, c);\n    return transchar_charbuf;\n}\n\n/*\n * Like transchar(), but called with a byte instead of a character.  Checks\n * for an illegal UTF-8 byte.\n */\n    char_u *\ntranschar_byte(int c)\n{\n    if (enc_utf8 && c >= 0x80)\n    {\n\ttranschar_nonprint(curbuf, transchar_charbuf, c);\n\treturn transchar_charbuf;\n    }\n    return transchar(c);\n}\n\n/*\n * Convert non-printable character to two or more printable characters in\n * \"buf[]\".  \"charbuf\" needs to be able to hold five bytes.\n * Does NOT work for multi-byte characters, c must be <= 255.\n */\n    void\ntranschar_nonprint(buf_T *buf, char_u *charbuf, int c)\n{\n    if (c == NL)\n\tc = NUL;\t\t// we use newline in place of a NUL\n    else if (c == CAR && get_fileformat(buf) == EOL_MAC)\n\tc = NL;\t\t\t// we use CR in place of  NL in this case\n\n    if (dy_flags & DY_UHEX)\t\t// 'display' has \"uhex\"\n\ttranschar_hex(charbuf, c);\n\n    else if (c <= 0x7f)\t\t\t// 0x00 - 0x1f and 0x7f\n    {\n\tcharbuf[0] = '^';\n\tcharbuf[1] = c ^ 0x40;\t\t// DEL displayed as ^?\n\tcharbuf[2] = NUL;\n    }\n    else if (enc_utf8 && c >= 0x80)\n    {\n\ttranschar_hex(charbuf, c);\n    }\n    else if (c >= ' ' + 0x80 && c <= '~' + 0x80)    // 0xa0 - 0xfe\n    {\n\tcharbuf[0] = '|';\n\tcharbuf[1] = c - 0x80;\n\tcharbuf[2] = NUL;\n    }\n    else\t\t\t\t\t    // 0x80 - 0x9f and 0xff\n    {\n\tcharbuf[0] = '~';\n\tcharbuf[1] = (c - 0x80) ^ 0x40;\t// 0xff displayed as ~?\n\tcharbuf[2] = NUL;\n    }\n}\n\n    void\ntranschar_hex(char_u *buf, int c)\n{\n    int\t\ti = 0;\n\n    buf[0] = '<';\n    if (c > 255)\n    {\n\tbuf[++i] = nr2hex((unsigned)c >> 12);\n\tbuf[++i] = nr2hex((unsigned)c >> 8);\n    }\n    buf[++i] = nr2hex((unsigned)c >> 4);\n    buf[++i] = nr2hex((unsigned)c);\n    buf[++i] = '>';\n    buf[++i] = NUL;\n}\n\n/*\n * Convert the lower 4 bits of byte \"c\" to its hex character.\n * Lower case letters are used to avoid the confusion of <F1> being 0xf1 or\n * function key 1.\n */\n    static unsigned\nnr2hex(unsigned c)\n{\n    if ((c & 0xf) <= 9)\n\treturn (c & 0xf) + '0';\n    return (c & 0xf) - 10 + 'a';\n}\n\n/*\n * Return number of display cells occupied by byte \"b\".\n * Caller must make sure 0 <= b <= 255.\n * For multi-byte mode \"b\" must be the first byte of a character.\n * A TAB is counted as two cells: \"^I\".\n * For UTF-8 mode this will return 0 for bytes >= 0x80, because the number of\n * cells depends on further bytes.\n */\n    int\nbyte2cells(int b)\n{\n    if (enc_utf8 && b >= 0x80)\n\treturn 0;\n    return (g_chartab[b] & CT_CELL_MASK);\n}\n\n/*\n * Return number of display cells occupied by character \"c\".\n * \"c\" can be a special key (negative number) in which case 3 or 4 is returned.\n * A TAB is counted as two cells: \"^I\" or four: \"<09>\".\n */\n    int\nchar2cells(int c)\n{\n    if (IS_SPECIAL(c))\n\treturn char2cells(K_SECOND(c)) + 2;\n    if (c >= 0x80)\n    {\n\t// UTF-8: above 0x80 need to check the value\n\tif (enc_utf8)\n\t    return utf_char2cells(c);\n\t// DBCS: double-byte means double-width, except for euc-jp with first\n\t// byte 0x8e\n\tif (enc_dbcs != 0 && c >= 0x100)\n\t{\n\t    if (enc_dbcs == DBCS_JPNU && ((unsigned)c >> 8) == 0x8e)\n\t\treturn 1;\n\t    return 2;\n\t}\n    }\n    return (g_chartab[c & 0xff] & CT_CELL_MASK);\n}\n\n/*\n * Return number of display cells occupied by character at \"*p\".\n * A TAB is counted as two cells: \"^I\" or four: \"<09>\".\n */\n    int\nptr2cells(char_u *p)\n{\n    // For UTF-8 we need to look at more bytes if the first byte is >= 0x80.\n    if (enc_utf8 && *p >= 0x80)\n\treturn utf_ptr2cells(p);\n    // For DBCS we can tell the cell count from the first byte.\n    return (g_chartab[*p] & CT_CELL_MASK);\n}\n\n/*\n * Return the number of character cells string \"s\" will take on the screen,\n * counting TABs as two characters: \"^I\".\n */\n    int\nvim_strsize(char_u *s)\n{\n    return vim_strnsize(s, (int)MAXCOL);\n}\n\n/*\n * Return the number of character cells string \"s[len]\" will take on the\n * screen, counting TABs as two characters: \"^I\".\n */\n    int\nvim_strnsize(char_u *s, int len)\n{\n    int\t\tsize = 0;\n\n    while (*s != NUL && --len >= 0)\n\tif (has_mbyte)\n\t{\n\t    int\t    l = (*mb_ptr2len)(s);\n\n\t    size += ptr2cells(s);\n\t    s += l;\n\t    len -= l - 1;\n\t}\n\telse\n\t    size += byte2cells(*s++);\n\n    return size;\n}\n\n/*\n * Return the number of characters 'c' will take on the screen, taking\n * into account the size of a tab.\n * Use a define to make it fast, this is used very often!!!\n * Also see getvcol() below.\n */\n\n#ifdef FEAT_VARTABS\n# define RET_WIN_BUF_CHARTABSIZE(wp, buf, p, col) \\\n    if (*(p) == TAB && (!(wp)->w_p_list || (wp)->w_lcs_chars.tab1)) \\\n    { \\\n\treturn tabstop_padding(col, (buf)->b_p_ts, (buf)->b_p_vts_array); \\\n    } \\\n    else \\\n\treturn ptr2cells(p);\n#else\n# define RET_WIN_BUF_CHARTABSIZE(wp, buf, p, col) \\\n    if (*(p) == TAB && (!(wp)->w_p_list || wp->w_lcs_chars.tab1)) \\\n    { \\\n\tint ts; \\\n\tts = (buf)->b_p_ts; \\\n\treturn (int)(ts - (col % ts)); \\\n    } \\\n    else \\\n\treturn ptr2cells(p);\n#endif\n\n    int\nchartabsize(char_u *p, colnr_T col)\n{\n    RET_WIN_BUF_CHARTABSIZE(curwin, curbuf, p, col)\n}\n\n#ifdef FEAT_LINEBREAK\n    static int\nwin_chartabsize(win_T *wp, char_u *p, colnr_T col)\n{\n    RET_WIN_BUF_CHARTABSIZE(wp, wp->w_buffer, p, col)\n}\n#endif\n\n/*\n * Return the number of characters the string 's' will take on the screen,\n * taking into account the size of a tab.\n */\n    int\nlinetabsize(char_u *s)\n{\n    return linetabsize_col(0, s);\n}\n\n/*\n * Like linetabsize(), but starting at column \"startcol\".\n */\n    int\nlinetabsize_col(int startcol, char_u *s)\n{\n    colnr_T\tcol = startcol;\n    char_u\t*line = s; // pointer to start of line, for breakindent\n\n    while (*s != NUL)\n\tcol += lbr_chartabsize_adv(line, &s, col);\n    return (int)col;\n}\n\n/*\n * Like linetabsize(), but for a given window instead of the current one.\n */\n    int\nwin_linetabsize(win_T *wp, char_u *line, colnr_T len)\n{\n    colnr_T\tcol = 0;\n    char_u\t*s;\n\n    for (s = line; *s != NUL && (len == MAXCOL || s < line + len);\n\t\t\t\t\t\t\t\tMB_PTR_ADV(s))\n\tcol += win_lbr_chartabsize(wp, line, s, col, NULL);\n    return (int)col;\n}\n\n/*\n * Return TRUE if 'c' is a normal identifier character:\n * Letters and characters from the 'isident' option.\n */\n    int\nvim_isIDc(int c)\n{\n    return (c > 0 && c < 0x100 && (g_chartab[c] & CT_ID_CHAR));\n}\n\n/*\n * Like vim_isIDc() but not using the 'isident' option: letters, numbers and\n * underscore.\n */\n    int\nvim_isNormalIDc(int c)\n{\n    return ASCII_ISALNUM(c) || c == '_';\n}\n\n/*\n * return TRUE if 'c' is a keyword character: Letters and characters from\n * 'iskeyword' option for the current buffer.\n * For multi-byte characters mb_get_class() is used (builtin rules).\n */\n    int\nvim_iswordc(int c)\n{\n    return vim_iswordc_buf(c, curbuf);\n}\n\n    int\nvim_iswordc_buf(int c, buf_T *buf)\n{\n    if (c >= 0x100)\n    {\n\tif (enc_dbcs != 0)\n\t    return dbcs_class((unsigned)c >> 8, (unsigned)(c & 0xff)) >= 2;\n\tif (enc_utf8)\n\t    return utf_class_buf(c, buf) >= 2;\n\treturn FALSE;\n    }\n    return (c > 0 && GET_CHARTAB(buf, c) != 0);\n}\n\n/*\n * Just like vim_iswordc() but uses a pointer to the (multi-byte) character.\n */\n    int\nvim_iswordp(char_u *p)\n{\n    return vim_iswordp_buf(p, curbuf);\n}\n\n    int\nvim_iswordp_buf(char_u *p, buf_T *buf)\n{\n    int\tc = *p;\n\n    if (has_mbyte && MB_BYTE2LEN(c) > 1)\n\tc = (*mb_ptr2char)(p);\n    return vim_iswordc_buf(c, buf);\n}\n\n/*\n * return TRUE if 'c' is a valid file-name character\n * Assume characters above 0x100 are valid (multi-byte).\n */\n    int\nvim_isfilec(int c)\n{\n    return (c >= 0x100 || (c > 0 && (g_chartab[c] & CT_FNAME_CHAR)));\n}\n\n/*\n * return TRUE if 'c' is a valid file-name character or a wildcard character\n * Assume characters above 0x100 are valid (multi-byte).\n * Explicitly interpret ']' as a wildcard character as mch_has_wildcard(\"]\")\n * returns false.\n */\n    int\nvim_isfilec_or_wc(int c)\n{\n    char_u buf[2];\n\n    buf[0] = (char_u)c;\n    buf[1] = NUL;\n    return vim_isfilec(c) || c == ']' || mch_has_wildcard(buf);\n}\n\n/*\n * Return TRUE if 'c' is a printable character.\n * Assume characters above 0x100 are printable (multi-byte), except for\n * Unicode.\n */\n    int\nvim_isprintc(int c)\n{\n    if (enc_utf8 && c >= 0x100)\n\treturn utf_printable(c);\n    return (c >= 0x100 || (c > 0 && (g_chartab[c] & CT_PRINT_CHAR)));\n}\n\n/*\n * Strict version of vim_isprintc(c), don't return TRUE if \"c\" is the head\n * byte of a double-byte character.\n */\n    int\nvim_isprintc_strict(int c)\n{\n    if (enc_dbcs != 0 && c < 0x100 && MB_BYTE2LEN(c) > 1)\n\treturn FALSE;\n    if (enc_utf8 && c >= 0x100)\n\treturn utf_printable(c);\n    return (c >= 0x100 || (c > 0 && (g_chartab[c] & CT_PRINT_CHAR)));\n}\n\n/*\n * like chartabsize(), but also check for line breaks on the screen\n */\n    int\nlbr_chartabsize(\n    char_u\t\t*line UNUSED, // start of the line\n    unsigned char\t*s,\n    colnr_T\t\tcol)\n{\n#ifdef FEAT_LINEBREAK\n    if (!curwin->w_p_lbr && *get_showbreak_value(curwin) == NUL\n\t\t\t\t\t\t\t   && !curwin->w_p_bri)\n    {\n#endif\n\tif (curwin->w_p_wrap)\n\t    return win_nolbr_chartabsize(curwin, s, col, NULL);\n\tRET_WIN_BUF_CHARTABSIZE(curwin, curbuf, s, col)\n#ifdef FEAT_LINEBREAK\n    }\n    return win_lbr_chartabsize(curwin, line == NULL ? s : line, s, col, NULL);\n#endif\n}\n\n/*\n * Call lbr_chartabsize() and advance the pointer.\n */\n    int\nlbr_chartabsize_adv(\n    char_u\t*line, // start of the line\n    char_u\t**s,\n    colnr_T\tcol)\n{\n    int\t\tretval;\n\n    retval = lbr_chartabsize(line, *s, col);\n    MB_PTR_ADV(*s);\n    return retval;\n}\n\n/*\n * This function is used very often, keep it fast!!!!\n *\n * If \"headp\" not NULL, set *headp to the size of what we for 'showbreak'\n * string at start of line.  Warning: *headp is only set if it's a non-zero\n * value, init to 0 before calling.\n */\n    int\nwin_lbr_chartabsize(\n    win_T\t*wp,\n    char_u\t*line UNUSED, // start of the line\n    char_u\t*s,\n    colnr_T\tcol,\n    int\t\t*headp UNUSED)\n{\n#ifdef FEAT_LINEBREAK\n    int\t\tc;\n    int\t\tsize;\n    colnr_T\tcol2;\n    colnr_T\tcol_adj = 0; // col + screen size of tab\n    colnr_T\tcolmax;\n    int\t\tadded;\n    int\t\tmb_added = 0;\n    int\t\tnumberextra;\n    char_u\t*ps;\n    int\t\ttab_corr = (*s == TAB);\n    int\t\tn;\n    char_u\t*sbr;\n\n    /*\n     * No 'linebreak', 'showbreak' and 'breakindent': return quickly.\n     */\n    if (!wp->w_p_lbr && !wp->w_p_bri && *get_showbreak_value(wp) == NUL)\n#endif\n    {\n\tif (wp->w_p_wrap)\n\t    return win_nolbr_chartabsize(wp, s, col, headp);\n\tRET_WIN_BUF_CHARTABSIZE(wp, wp->w_buffer, s, col)\n    }\n\n#ifdef FEAT_LINEBREAK\n    /*\n     * First get normal size, without 'linebreak'\n     */\n    size = win_chartabsize(wp, s, col);\n    c = *s;\n    if (tab_corr)\n\tcol_adj = size - 1;\n\n    /*\n     * If 'linebreak' set check at a blank before a non-blank if the line\n     * needs a break here\n     */\n    if (wp->w_p_lbr\n\t    && VIM_ISBREAK(c)\n\t    && !VIM_ISBREAK((int)s[1])\n\t    && wp->w_p_wrap\n\t    && wp->w_width != 0)\n    {\n\t/*\n\t * Count all characters from first non-blank after a blank up to next\n\t * non-blank after a blank.\n\t */\n\tnumberextra = win_col_off(wp);\n\tcol2 = col;\n\tcolmax = (colnr_T)(wp->w_width - numberextra - col_adj);\n\tif (col >= colmax)\n\t{\n\t    colmax += col_adj;\n\t    n = colmax +  win_col_off2(wp);\n\t    if (n > 0)\n\t\tcolmax += (((col - colmax) / n) + 1) * n - col_adj;\n\t}\n\n\tfor (;;)\n\t{\n\t    ps = s;\n\t    MB_PTR_ADV(s);\n\t    c = *s;\n\t    if (!(c != NUL\n\t\t    && (VIM_ISBREAK(c)\n\t\t\t|| (!VIM_ISBREAK(c)\n\t\t\t    && (col2 == col || !VIM_ISBREAK((int)*ps))))))\n\t\tbreak;\n\n\t    col2 += win_chartabsize(wp, s, col2);\n\t    if (col2 >= colmax)\t\t// doesn't fit\n\t    {\n\t\tsize = colmax - col + col_adj;\n\t\tbreak;\n\t    }\n\t}\n    }\n    else if (has_mbyte && size == 2 && MB_BYTE2LEN(*s) > 1\n\t\t\t\t    && wp->w_p_wrap && in_win_border(wp, col))\n    {\n\t++size;\t\t// Count the \">\" in the last column.\n\tmb_added = 1;\n    }\n\n    /*\n     * May have to add something for 'breakindent' and/or 'showbreak'\n     * string at start of line.\n     * Set *headp to the size of what we add.\n     */\n    added = 0;\n    sbr = get_showbreak_value(wp);\n    if ((*sbr != NUL || wp->w_p_bri) && wp->w_p_wrap && col != 0)\n    {\n\tcolnr_T sbrlen = 0;\n\tint\tnumberwidth = win_col_off(wp);\n\n\tnumberextra = numberwidth;\n\tcol += numberextra + mb_added;\n\tif (col >= (colnr_T)wp->w_width)\n\t{\n\t    col -= wp->w_width;\n\t    numberextra = wp->w_width - (numberextra - win_col_off2(wp));\n\t    if (col >= numberextra && numberextra > 0)\n\t\tcol %= numberextra;\n\t    if (*sbr != NUL)\n\t    {\n\t\tsbrlen = (colnr_T)MB_CHARLEN(sbr);\n\t\tif (col >= sbrlen)\n\t\t    col -= sbrlen;\n\t    }\n\t    if (col >= numberextra && numberextra > 0)\n\t\tcol = col % numberextra;\n\t    else if (col > 0 && numberextra > 0)\n\t\tcol += numberwidth - win_col_off2(wp);\n\n\t    numberwidth -= win_col_off2(wp);\n\t}\n\tif (col == 0 || col + size + sbrlen > (colnr_T)wp->w_width)\n\t{\n\t    added = 0;\n\t    if (*sbr != NUL)\n\t    {\n\t\tif (size + sbrlen + numberwidth > (colnr_T)wp->w_width)\n\t\t{\n\t\t    // calculate effective window width\n\t\t    int width = (colnr_T)wp->w_width - sbrlen - numberwidth;\n\t\t    int prev_width = col\n\t\t\t\t ? ((colnr_T)wp->w_width - (sbrlen + col)) : 0;\n\n\t\t    if (width <= 0)\n\t\t\twidth = (colnr_T)1;\n\t\t    added += ((size - prev_width) / width) * vim_strsize(sbr);\n\t\t    if ((size - prev_width) % width)\n\t\t\t// wrapped, add another length of 'sbr'\n\t\t\tadded += vim_strsize(sbr);\n\t\t}\n\t\telse\n\t\t    added += vim_strsize(sbr);\n\t    }\n\t    if (wp->w_p_bri)\n\t\tadded += get_breakindent_win(wp, line);\n\n\t    size += added;\n\t    if (col != 0)\n\t\tadded = 0;\n\t}\n    }\n    if (headp != NULL)\n\t*headp = added + mb_added;\n    return size;\n#endif\n}\n\n/*\n * Like win_lbr_chartabsize(), except that we know 'linebreak' is off and\n * 'wrap' is on.  This means we need to check for a double-byte character that\n * doesn't fit at the end of the screen line.\n */\n    static int\nwin_nolbr_chartabsize(\n    win_T\t*wp,\n    char_u\t*s,\n    colnr_T\tcol,\n    int\t\t*headp)\n{\n    int\t\tn;\n\n    if (*s == TAB && (!wp->w_p_list || wp->w_lcs_chars.tab1))\n    {\n# ifdef FEAT_VARTABS\n\treturn tabstop_padding(col, wp->w_buffer->b_p_ts,\n\t\t\t\t    wp->w_buffer->b_p_vts_array);\n# else\n\tn = wp->w_buffer->b_p_ts;\n\treturn (int)(n - (col % n));\n# endif\n    }\n    n = ptr2cells(s);\n    // Add one cell for a double-width character in the last column of the\n    // window, displayed with a \">\".\n    if (n == 2 && MB_BYTE2LEN(*s) > 1 && in_win_border(wp, col))\n    {\n\tif (headp != NULL)\n\t    *headp = 1;\n\treturn 3;\n    }\n    return n;\n}\n\n/*\n * Return TRUE if virtual column \"vcol\" is in the rightmost column of window\n * \"wp\".\n */\n    static int\nin_win_border(win_T *wp, colnr_T vcol)\n{\n    int\t\twidth1;\t\t// width of first line (after line number)\n    int\t\twidth2;\t\t// width of further lines\n\n    if (wp->w_width == 0)\t// there is no border\n\treturn FALSE;\n    width1 = wp->w_width - win_col_off(wp);\n    if ((int)vcol < width1 - 1)\n\treturn FALSE;\n    if ((int)vcol == width1 - 1)\n\treturn TRUE;\n    width2 = width1 + win_col_off2(wp);\n    if (width2 <= 0)\n\treturn FALSE;\n    return ((vcol - width1) % width2 == width2 - 1);\n}\n\n/*\n * Get virtual column number of pos.\n *  start: on the first position of this character (TAB, ctrl)\n * cursor: where the cursor is on this character (first char, except for TAB)\n *    end: on the last position of this character (TAB, ctrl)\n *\n * This is used very often, keep it fast!\n */\n    void\ngetvcol(\n    win_T\t*wp,\n    pos_T\t*pos,\n    colnr_T\t*start,\n    colnr_T\t*cursor,\n    colnr_T\t*end)\n{\n    colnr_T\tvcol;\n    char_u\t*ptr;\t\t// points to current char\n    char_u\t*posptr;\t// points to char at pos->col\n    char_u\t*line;\t\t// start of the line\n    int\t\tincr;\n    int\t\thead;\n#ifdef FEAT_VARTABS\n    int\t\t*vts = wp->w_buffer->b_p_vts_array;\n#endif\n    int\t\tts = wp->w_buffer->b_p_ts;\n    int\t\tc;\n\n    vcol = 0;\n    line = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);\n    if (pos->col == MAXCOL)\n\tposptr = NULL;  // continue until the NUL\n    else\n    {\n\tcolnr_T i;\n\n\t// In a few cases the position can be beyond the end of the line.\n\tfor (i = 0; i < pos->col; ++i)\n\t    if (ptr[i] == NUL)\n\t    {\n\t\tpos->col = i;\n\t\tbreak;\n\t    }\n\tposptr = ptr + pos->col;\n\tif (has_mbyte)\n\t    // always start on the first byte\n\t    posptr -= (*mb_head_off)(line, posptr);\n    }\n\n    /*\n     * This function is used very often, do some speed optimizations.\n     * When 'list', 'linebreak', 'showbreak' and 'breakindent' are not set\n     * use a simple loop.\n     * Also use this when 'list' is set but tabs take their normal size.\n     */\n    if ((!wp->w_p_list || wp->w_lcs_chars.tab1 != NUL)\n#ifdef FEAT_LINEBREAK\n\t    && !wp->w_p_lbr && *get_showbreak_value(wp) == NUL && !wp->w_p_bri\n#endif\n       )\n    {\n\tfor (;;)\n\t{\n\t    head = 0;\n\t    c = *ptr;\n\t    // make sure we don't go past the end of the line\n\t    if (c == NUL)\n\t    {\n\t\tincr = 1;\t// NUL at end of line only takes one column\n\t\tbreak;\n\t    }\n\t    // A tab gets expanded, depending on the current column\n\t    if (c == TAB)\n#ifdef FEAT_VARTABS\n\t\tincr = tabstop_padding(vcol, ts, vts);\n#else\n\t\tincr = ts - (vcol % ts);\n#endif\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    // For utf-8, if the byte is >= 0x80, need to look at\n\t\t    // further bytes to find the cell width.\n\t\t    if (enc_utf8 && c >= 0x80)\n\t\t\tincr = utf_ptr2cells(ptr);\n\t\t    else\n\t\t\tincr = g_chartab[c] & CT_CELL_MASK;\n\n\t\t    // If a double-cell char doesn't fit at the end of a line\n\t\t    // it wraps to the next line, it's like this char is three\n\t\t    // cells wide.\n\t\t    if (incr == 2 && wp->w_p_wrap && MB_BYTE2LEN(*ptr) > 1\n\t\t\t    && in_win_border(wp, vcol))\n\t\t    {\n\t\t\t++incr;\n\t\t\thead = 1;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    incr = g_chartab[c] & CT_CELL_MASK;\n\t    }\n\n\t    if (posptr != NULL && ptr >= posptr) // character at pos->col\n\t\tbreak;\n\n\t    vcol += incr;\n\t    MB_PTR_ADV(ptr);\n\t}\n    }\n    else\n    {\n\tfor (;;)\n\t{\n\t    // A tab gets expanded, depending on the current column\n\t    head = 0;\n\t    incr = win_lbr_chartabsize(wp, line, ptr, vcol, &head);\n\t    // make sure we don't go past the end of the line\n\t    if (*ptr == NUL)\n\t    {\n\t\tincr = 1;\t// NUL at end of line only takes one column\n\t\tbreak;\n\t    }\n\n\t    if (posptr != NULL && ptr >= posptr) // character at pos->col\n\t\tbreak;\n\n\t    vcol += incr;\n\t    MB_PTR_ADV(ptr);\n\t}\n    }\n    if (start != NULL)\n\t*start = vcol + head;\n    if (end != NULL)\n\t*end = vcol + incr - 1;\n    if (cursor != NULL)\n    {\n\tif (*ptr == TAB\n\t\t&& (State & NORMAL)\n\t\t&& !wp->w_p_list\n\t\t&& !virtual_active()\n\t\t&& !(VIsual_active\n\t\t\t\t&& (*p_sel == 'e' || LTOREQ_POS(*pos, VIsual)))\n\t\t)\n\t    *cursor = vcol + incr - 1;\t    // cursor at end\n\telse\n\t    *cursor = vcol + head;\t    // cursor at start\n    }\n}\n\n/*\n * Get virtual cursor column in the current window, pretending 'list' is off.\n */\n    colnr_T\ngetvcol_nolist(pos_T *posp)\n{\n    int\t\tlist_save = curwin->w_p_list;\n    colnr_T\tvcol;\n\n    curwin->w_p_list = FALSE;\n    if (posp->coladd)\n\tgetvvcol(curwin, posp, NULL, &vcol, NULL);\n    else\n\tgetvcol(curwin, posp, NULL, &vcol, NULL);\n    curwin->w_p_list = list_save;\n    return vcol;\n}\n\n/*\n * Get virtual column in virtual mode.\n */\n    void\ngetvvcol(\n    win_T\t*wp,\n    pos_T\t*pos,\n    colnr_T\t*start,\n    colnr_T\t*cursor,\n    colnr_T\t*end)\n{\n    colnr_T\tcol;\n    colnr_T\tcoladd;\n    colnr_T\tendadd;\n    char_u\t*ptr;\n\n    if (virtual_active())\n    {\n\t// For virtual mode, only want one value\n\tgetvcol(wp, pos, &col, NULL, NULL);\n\n\tcoladd = pos->coladd;\n\tendadd = 0;\n\t// Cannot put the cursor on part of a wide character.\n\tptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);\n\tif (pos->col < (colnr_T)STRLEN(ptr))\n\t{\n\t    int c = (*mb_ptr2char)(ptr + pos->col);\n\n\t    if (c != TAB && vim_isprintc(c))\n\t    {\n\t\tendadd = (colnr_T)(char2cells(c) - 1);\n\t\tif (coladd > endadd)\t// past end of line\n\t\t    endadd = 0;\n\t\telse\n\t\t    coladd = 0;\n\t    }\n\t}\n\tcol += coladd;\n\tif (start != NULL)\n\t    *start = col;\n\tif (cursor != NULL)\n\t    *cursor = col;\n\tif (end != NULL)\n\t    *end = col + endadd;\n    }\n    else\n\tgetvcol(wp, pos, start, cursor, end);\n}\n\n/*\n * Get the leftmost and rightmost virtual column of pos1 and pos2.\n * Used for Visual block mode.\n */\n    void\ngetvcols(\n    win_T\t*wp,\n    pos_T\t*pos1,\n    pos_T\t*pos2,\n    colnr_T\t*left,\n    colnr_T\t*right)\n{\n    colnr_T\tfrom1, from2, to1, to2;\n\n    if (LT_POSP(pos1, pos2))\n    {\n\tgetvvcol(wp, pos1, &from1, NULL, &to1);\n\tgetvvcol(wp, pos2, &from2, NULL, &to2);\n    }\n    else\n    {\n\tgetvvcol(wp, pos2, &from1, NULL, &to1);\n\tgetvvcol(wp, pos1, &from2, NULL, &to2);\n    }\n    if (from2 < from1)\n\t*left = from2;\n    else\n\t*left = from1;\n    if (to2 > to1)\n    {\n\tif (*p_sel == 'e' && from2 - 1 >= to1)\n\t    *right = from2 - 1;\n\telse\n\t    *right = to2;\n    }\n    else\n\t*right = to1;\n}\n\n/*\n * Skip over ' ' and '\\t'.\n */\n    char_u *\nskipwhite(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (VIM_ISWHITE(*p))\n\t++p;\n    return p;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * skip over ' ', '\\t' and '\\n'.\n */\n    char_u *\nskipwhite_and_nl(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (VIM_ISWHITE(*p) || *p == NL)\n\t++p;\n    return p;\n}\n#endif\n\n/*\n * getwhitecols: return the number of whitespace\n * columns (bytes) at the start of a given line\n */\n    int\ngetwhitecols_curline()\n{\n    return getwhitecols(ml_get_curline());\n}\n\n    int\ngetwhitecols(char_u *p)\n{\n    return skipwhite(p) - p;\n}\n\n/*\n * skip over digits\n */\n    char_u *\nskipdigits(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (VIM_ISDIGIT(*p))\t// skip to next non-digit\n\t++p;\n    return p;\n}\n\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * skip over binary digits\n */\n    char_u *\nskipbin(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (vim_isbdigit(*p))\t// skip to next non-digit\n\t++p;\n    return p;\n}\n\n/*\n * skip over digits and hex characters\n */\n    char_u *\nskiphex(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (vim_isxdigit(*p))\t// skip to next non-digit\n\t++p;\n    return p;\n}\n#endif\n\n/*\n * skip to bin digit (or NUL after the string)\n */\n    char_u *\nskiptobin(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (*p != NUL && !vim_isbdigit(*p))\t// skip to next digit\n\t++p;\n    return p;\n}\n\n/*\n * skip to digit (or NUL after the string)\n */\n    char_u *\nskiptodigit(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (*p != NUL && !VIM_ISDIGIT(*p))\t// skip to next digit\n\t++p;\n    return p;\n}\n\n/*\n * skip to hex character (or NUL after the string)\n */\n    char_u *\nskiptohex(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (*p != NUL && !vim_isxdigit(*p))\t// skip to next digit\n\t++p;\n    return p;\n}\n\n/*\n * Variant of isdigit() that can handle characters > 0x100.\n * We don't use isdigit() here, because on some systems it also considers\n * superscript 1 to be a digit.\n * Use the VIM_ISDIGIT() macro for simple arguments.\n */\n    int\nvim_isdigit(int c)\n{\n    return (c >= '0' && c <= '9');\n}\n\n/*\n * Variant of isxdigit() that can handle characters > 0x100.\n * We don't use isxdigit() here, because on some systems it also considers\n * superscript 1 to be a digit.\n */\n    int\nvim_isxdigit(int c)\n{\n    return (c >= '0' && c <= '9')\n\t|| (c >= 'a' && c <= 'f')\n\t|| (c >= 'A' && c <= 'F');\n}\n\n/*\n * Corollary of vim_isdigit and vim_isxdigit() that can handle\n * characters > 0x100.\n */\n    int\nvim_isbdigit(int c)\n{\n    return (c == '0' || c == '1');\n}\n\n    static int\nvim_isodigit(int c)\n{\n    return (c >= '0' && c <= '7');\n}\n\n/*\n * Vim's own character class functions.  These exist because many library\n * islower()/toupper() etc. do not work properly: they crash when used with\n * invalid values or can't handle latin1 when the locale is C.\n * Speed is most important here.\n */\n#define LATIN1LOWER 'l'\n#define LATIN1UPPER 'U'\n\nstatic char_u latin1flags[257] = \"                                                                 UUUUUUUUUUUUUUUUUUUUUUUUUU      llllllllllllllllllllllllll                                                                     UUUUUUUUUUUUUUUUUUUUUUU UUUUUUUllllllllllllllllllllllll llllllll\";\nstatic char_u latin1upper[257] = \"                                 !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xf7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xff\";\nstatic char_u latin1lower[257] = \"                                 !\\\"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xd7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\";\n\n    int\nvim_islower(int c)\n{\n    if (c <= '@')\n\treturn FALSE;\n    if (c >= 0x80)\n    {\n\tif (enc_utf8)\n\t    return utf_islower(c);\n\tif (c >= 0x100)\n\t{\n#ifdef HAVE_ISWLOWER\n\t    if (has_mbyte)\n\t\treturn iswlower(c);\n#endif\n\t    // islower() can't handle these chars and may crash\n\t    return FALSE;\n\t}\n\tif (enc_latin1like)\n\t    return (latin1flags[c] & LATIN1LOWER) == LATIN1LOWER;\n    }\n    return islower(c);\n}\n\n    int\nvim_isupper(int c)\n{\n    if (c <= '@')\n\treturn FALSE;\n    if (c >= 0x80)\n    {\n\tif (enc_utf8)\n\t    return utf_isupper(c);\n\tif (c >= 0x100)\n\t{\n#ifdef HAVE_ISWUPPER\n\t    if (has_mbyte)\n\t\treturn iswupper(c);\n#endif\n\t    // islower() can't handle these chars and may crash\n\t    return FALSE;\n\t}\n\tif (enc_latin1like)\n\t    return (latin1flags[c] & LATIN1UPPER) == LATIN1UPPER;\n    }\n    return isupper(c);\n}\n\n    int\nvim_isalpha(int c)\n{\n    return vim_islower(c) || vim_isupper(c);\n}\n\n    int\nvim_toupper(int c)\n{\n    if (c <= '@')\n\treturn c;\n    if (c >= 0x80 || !(cmp_flags & CMP_KEEPASCII))\n    {\n\tif (enc_utf8)\n\t    return utf_toupper(c);\n\tif (c >= 0x100)\n\t{\n#ifdef HAVE_TOWUPPER\n\t    if (has_mbyte)\n\t\treturn towupper(c);\n#endif\n\t    // toupper() can't handle these chars and may crash\n\t    return c;\n\t}\n\tif (enc_latin1like)\n\t    return latin1upper[c];\n    }\n    if (c < 0x80 && (cmp_flags & CMP_KEEPASCII))\n\treturn TOUPPER_ASC(c);\n    return TOUPPER_LOC(c);\n}\n\n    int\nvim_tolower(int c)\n{\n    if (c <= '@')\n\treturn c;\n    if (c >= 0x80 || !(cmp_flags & CMP_KEEPASCII))\n    {\n\tif (enc_utf8)\n\t    return utf_tolower(c);\n\tif (c >= 0x100)\n\t{\n#ifdef HAVE_TOWLOWER\n\t    if (has_mbyte)\n\t\treturn towlower(c);\n#endif\n\t    // tolower() can't handle these chars and may crash\n\t    return c;\n\t}\n\tif (enc_latin1like)\n\t    return latin1lower[c];\n    }\n    if (c < 0x80 && (cmp_flags & CMP_KEEPASCII))\n\treturn TOLOWER_ASC(c);\n    return TOLOWER_LOC(c);\n}\n\n/*\n * skiptowhite: skip over text until ' ' or '\\t' or NUL.\n */\n    char_u *\nskiptowhite(char_u *p)\n{\n    while (*p != ' ' && *p != '\\t' && *p != NUL)\n\t++p;\n    return p;\n}\n\n/*\n * skiptowhite_esc: Like skiptowhite(), but also skip escaped chars\n */\n    char_u *\nskiptowhite_esc(char_u *p)\n{\n    while (*p != ' ' && *p != '\\t' && *p != NUL)\n    {\n\tif ((*p == '\\\\' || *p == Ctrl_V) && *(p + 1) != NUL)\n\t    ++p;\n\t++p;\n    }\n    return p;\n}\n\n/*\n * Get a number from a string and skip over it.\n * Note: the argument is a pointer to a char_u pointer!\n */\n    long\ngetdigits(char_u **pp)\n{\n    char_u\t*p;\n    long\tretval;\n\n    p = *pp;\n    retval = atol((char *)p);\n    if (*p == '-')\t\t// skip negative sign\n\t++p;\n    p = skipdigits(p);\t\t// skip to next non-digit\n    *pp = p;\n    return retval;\n}\n\n/*\n * Like getdigits() but allow for embedded single quotes.\n */\n    long\ngetdigits_quoted(char_u **pp)\n{\n    char_u\t*p = *pp;\n    long\tretval = 0;\n\n    if (*p == '-')\n\t++p;\n    while (VIM_ISDIGIT(*p))\n    {\n\tif (retval >= LONG_MAX / 10 - 10)\n\t    retval = LONG_MAX;\n\telse\n\t    retval = retval * 10 - '0' + *p;\n\t++p;\n\tif (in_vim9script() && *p == '\\'' && VIM_ISDIGIT(p[1]))\n\t    ++p;\n    }\n    if (**pp == '-')\n    {\n\tif (retval == LONG_MAX)\n\t    retval = LONG_MIN;\n\telse\n\t    retval = -retval;\n    }\n    *pp = p;\n    return retval;\n}\n\n/*\n * Return TRUE if \"lbuf\" is empty or only contains blanks.\n */\n    int\nvim_isblankline(char_u *lbuf)\n{\n    char_u\t*p;\n\n    p = skipwhite(lbuf);\n    return (*p == NUL || *p == '\\r' || *p == '\\n');\n}\n\n/*\n * Convert a string into a long and/or unsigned long, taking care of\n * hexadecimal, octal, and binary numbers.  Accepts a '-' sign.\n * If \"prep\" is not NULL, returns a flag to indicate the type of the number:\n *  0\t    decimal\n *  '0'\t    octal\n *  'O'\t    octal\n *  'o'\t    octal\n *  'B'\t    bin\n *  'b'\t    bin\n *  'X'\t    hex\n *  'x'\t    hex\n * If \"len\" is not NULL, the length of the number in characters is returned.\n * If \"nptr\" is not NULL, the signed result is returned in it.\n * If \"unptr\" is not NULL, the unsigned result is returned in it.\n * If \"what\" contains STR2NR_BIN recognize binary numbers\n * If \"what\" contains STR2NR_OCT recognize octal numbers\n * If \"what\" contains STR2NR_HEX recognize hex numbers\n * If \"what\" contains STR2NR_FORCE always assume bin/oct/hex.\n * If \"what\" contains STR2NR_QUOTE ignore embedded single quotes\n * If maxlen > 0, check at a maximum maxlen chars.\n * If strict is TRUE, check the number strictly. return *len = 0 if fail.\n */\n    void\nvim_str2nr(\n    char_u\t\t*start,\n    int\t\t\t*prep,\t    // return: type of number 0 = decimal, 'x'\n\t\t\t\t    // or 'X' is hex, '0', 'o' or 'O' is octal,\n\t\t\t\t    // 'b' or 'B' is bin\n    int\t\t\t*len,\t    // return: detected length of number\n    int\t\t\twhat,\t    // what numbers to recognize\n    varnumber_T\t\t*nptr,\t    // return: signed result\n    uvarnumber_T\t*unptr,\t    // return: unsigned result\n    int\t\t\tmaxlen,     // max length of string to check\n    int\t\t\tstrict)     // check strictly\n{\n    char_u\t    *ptr = start;\n    int\t\t    pre = 0;\t\t// default is decimal\n    int\t\t    negative = FALSE;\n    uvarnumber_T    un = 0;\n    int\t\t    n;\n\n    if (len != NULL)\n\t*len = 0;\n\n    if (ptr[0] == '-')\n    {\n\tnegative = TRUE;\n\t++ptr;\n    }\n\n    // Recognize hex, octal, and bin.\n    if (ptr[0] == '0' && ptr[1] != '8' && ptr[1] != '9'\n\t\t\t\t\t       && (maxlen == 0 || maxlen > 1))\n    {\n\tpre = ptr[1];\n\tif ((what & STR2NR_HEX)\n\t\t&& (pre == 'X' || pre == 'x') && vim_isxdigit(ptr[2])\n\t\t&& (maxlen == 0 || maxlen > 2))\n\t    // hexadecimal\n\t    ptr += 2;\n\telse if ((what & STR2NR_BIN)\n\t\t&& (pre == 'B' || pre == 'b') && vim_isbdigit(ptr[2])\n\t\t&& (maxlen == 0 || maxlen > 2))\n\t    // binary\n\t    ptr += 2;\n\telse if ((what & STR2NR_OOCT)\n\t\t&& (pre == 'O' || pre == 'o') && vim_isodigit(ptr[2])\n\t\t&& (maxlen == 0 || maxlen > 2))\n\t    // octal with prefix \"0o\"\n\t    ptr += 2;\n\telse\n\t{\n\t    // decimal or octal, default is decimal\n\t    pre = 0;\n\t    if (what & STR2NR_OCT)\n\t    {\n\t\t// Don't interpret \"0\", \"08\" or \"0129\" as octal.\n\t\tfor (n = 1; n != maxlen && VIM_ISDIGIT(ptr[n]); ++n)\n\t\t{\n\t\t    if (ptr[n] > '7')\n\t\t    {\n\t\t\tpre = 0;\t// can't be octal\n\t\t\tbreak;\n\t\t    }\n\t\t    pre = '0';\t// assume octal\n\t\t}\n\t    }\n\t}\n    }\n\n    // Do the conversion manually to avoid sscanf() quirks.\n    n = 1;\n    if (pre == 'B' || pre == 'b'\n\t\t\t     || ((what & STR2NR_BIN) && (what & STR2NR_FORCE)))\n    {\n\t// bin\n\tif (pre != 0)\n\t    n += 2;\t    // skip over \"0b\"\n\twhile ('0' <= *ptr && *ptr <= '1')\n\t{\n\t    // avoid ubsan error for overflow\n\t    if (un <= UVARNUM_MAX / 2)\n\t\tun = 2 * un + (uvarnumber_T)(*ptr - '0');\n\t    else\n\t\tun = UVARNUM_MAX;\n\t    ++ptr;\n\t    if (n++ == maxlen)\n\t\tbreak;\n\t    if ((what & STR2NR_QUOTE) && *ptr == '\\''\n\t\t\t\t\t     && '0' <= ptr[1] && ptr[1] <= '1')\n\t    {\n\t\t++ptr;\n\t\tif (n++ == maxlen)\n\t\t    break;\n\t    }\n\t}\n    }\n    else if (pre == 'O' || pre == 'o' ||\n\t\tpre == '0' || ((what & STR2NR_OCT) && (what & STR2NR_FORCE)))\n    {\n\t// octal\n\tif (pre != 0 && pre != '0')\n\t    n += 2;\t    // skip over \"0o\"\n\twhile ('0' <= *ptr && *ptr <= '7')\n\t{\n\t    // avoid ubsan error for overflow\n\t    if (un <= UVARNUM_MAX / 8)\n\t\tun = 8 * un + (uvarnumber_T)(*ptr - '0');\n\t    else\n\t\tun = UVARNUM_MAX;\n\t    ++ptr;\n\t    if (n++ == maxlen)\n\t\tbreak;\n\t    if ((what & STR2NR_QUOTE) && *ptr == '\\''\n\t\t\t\t\t     && '0' <= ptr[1] && ptr[1] <= '7')\n\t    {\n\t\t++ptr;\n\t\tif (n++ == maxlen)\n\t\t    break;\n\t    }\n\t}\n    }\n    else if (pre != 0 || ((what & STR2NR_HEX) && (what & STR2NR_FORCE)))\n    {\n\t// hex\n\tif (pre != 0)\n\t    n += 2;\t    // skip over \"0x\"\n\twhile (vim_isxdigit(*ptr))\n\t{\n\t    // avoid ubsan error for overflow\n\t    if (un <= UVARNUM_MAX / 16)\n\t\tun = 16 * un + (uvarnumber_T)hex2nr(*ptr);\n\t    else\n\t\tun = UVARNUM_MAX;\n\t    ++ptr;\n\t    if (n++ == maxlen)\n\t\tbreak;\n\t    if ((what & STR2NR_QUOTE) && *ptr == '\\'' && vim_isxdigit(ptr[1]))\n\t    {\n\t\t++ptr;\n\t\tif (n++ == maxlen)\n\t\t    break;\n\t    }\n\t}\n    }\n    else\n    {\n\t// decimal\n\twhile (VIM_ISDIGIT(*ptr))\n\t{\n\t    uvarnumber_T    digit = (uvarnumber_T)(*ptr - '0');\n\n\t    // avoid ubsan error for overflow\n\t    if (un < UVARNUM_MAX / 10\n\t\t    || (un == UVARNUM_MAX / 10 && digit <= UVARNUM_MAX % 10))\n\t\tun = 10 * un + digit;\n\t    else\n\t\tun = UVARNUM_MAX;\n\t    ++ptr;\n\t    if (n++ == maxlen)\n\t\tbreak;\n\t    if ((what & STR2NR_QUOTE) && *ptr == '\\'' && VIM_ISDIGIT(ptr[1]))\n\t    {\n\t\t++ptr;\n\t\tif (n++ == maxlen)\n\t\t    break;\n\t    }\n\t}\n    }\n\n    // Check for an alphanumeric character immediately following, that is\n    // most likely a typo.\n    if (strict && n - 1 != maxlen && ASCII_ISALNUM(*ptr))\n\treturn;\n\n    if (prep != NULL)\n\t*prep = pre;\n    if (len != NULL)\n\t*len = (int)(ptr - start);\n    if (nptr != NULL)\n    {\n\tif (negative)   // account for leading '-' for decimal numbers\n\t{\n\t    // avoid ubsan error for overflow\n\t    if (un > VARNUM_MAX)\n\t\t*nptr = VARNUM_MIN;\n\t    else\n\t\t*nptr = -(varnumber_T)un;\n\t}\n\telse\n\t{\n\t    if (un > VARNUM_MAX)\n\t\tun = VARNUM_MAX;\n\t    *nptr = (varnumber_T)un;\n\t}\n    }\n    if (unptr != NULL)\n\t*unptr = un;\n}\n\n/*\n * Return the value of a single hex character.\n * Only valid when the argument is '0' - '9', 'A' - 'F' or 'a' - 'f'.\n */\n    int\nhex2nr(int c)\n{\n    if (c >= 'a' && c <= 'f')\n\treturn c - 'a' + 10;\n    if (c >= 'A' && c <= 'F')\n\treturn c - 'A' + 10;\n    return c - '0';\n}\n\n/*\n * Convert two hex characters to a byte.\n * Return -1 if one of the characters is not hex.\n */\n    int\nhexhex2nr(char_u *p)\n{\n    if (!vim_isxdigit(p[0]) || !vim_isxdigit(p[1]))\n\treturn -1;\n    return (hex2nr(p[0]) << 4) + hex2nr(p[1]);\n}\n\n/*\n * Return TRUE if \"str\" starts with a backslash that should be removed.\n * For MS-DOS, MSWIN and OS/2 this is only done when the character after the\n * backslash is not a normal file name character.\n * '$' is a valid file name character, we don't remove the backslash before\n * it.  This means it is not possible to use an environment variable after a\n * backslash.  \"C:\\$VIM\\doc\" is taken literally, only \"$VIM\\doc\" works.\n * Although \"\\ name\" is valid, the backslash in \"Program\\ files\" must be\n * removed.  Assume a file name doesn't start with a space.\n * For multi-byte names, never remove a backslash before a non-ascii\n * character, assume that all multi-byte characters are valid file name\n * characters.\n */\n    int\nrem_backslash(char_u *str)\n{\n#ifdef BACKSLASH_IN_FILENAME\n    return (str[0] == '\\\\'\n\t    && str[1] < 0x80\n\t    && (str[1] == ' '\n\t\t|| (str[1] != NUL\n\t\t    && str[1] != '*'\n\t\t    && str[1] != '?'\n\t\t    && !vim_isfilec(str[1]))));\n#else\n    return (str[0] == '\\\\' && str[1] != NUL);\n#endif\n}\n\n/*\n * Halve the number of backslashes in a file name argument.\n * For MS-DOS we only do this if the character after the backslash\n * is not a normal file character.\n */\n    void\nbackslash_halve(char_u *p)\n{\n    for ( ; *p; ++p)\n\tif (rem_backslash(p))\n\t    STRMOVE(p, p + 1);\n}\n\n/*\n * backslash_halve() plus save the result in allocated memory.\n * However, returns \"p\" when out of memory.\n */\n    char_u *\nbackslash_halve_save(char_u *p)\n{\n    char_u\t*res;\n\n    res = vim_strsave(p);\n    if (res == NULL)\n\treturn p;\n    backslash_halve(res);\n    return res;\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * filepath.c: dealing with file names and paths.\n */\n\n#include \"vim.h\"\n\n#ifdef MSWIN\n/*\n * Functions for \":8\" filename modifier: get 8.3 version of a filename.\n */\n\n/*\n * Get the short path (8.3) for the filename in \"fnamep\".\n * Only works for a valid file name.\n * When the path gets longer \"fnamep\" is changed and the allocated buffer\n * is put in \"bufp\".\n * *fnamelen is the length of \"fnamep\" and set to 0 for a nonexistent path.\n * Returns OK on success, FAIL on failure.\n */\n    static int\nget_short_pathname(char_u **fnamep, char_u **bufp, int *fnamelen)\n{\n    int\t\tl, len;\n    WCHAR\t*newbuf;\n    WCHAR\t*wfname;\n\n    len = MAXPATHL;\n    newbuf = malloc(len * sizeof(*newbuf));\n    if (newbuf == NULL)\n\treturn FAIL;\n\n    wfname = enc_to_utf16(*fnamep, NULL);\n    if (wfname == NULL)\n    {\n\tvim_free(newbuf);\n\treturn FAIL;\n    }\n\n    l = GetShortPathNameW(wfname, newbuf, len);\n    if (l > len - 1)\n    {\n\t// If that doesn't work (not enough space), then save the string\n\t// and try again with a new buffer big enough.\n\tWCHAR *newbuf_t = newbuf;\n\tnewbuf = vim_realloc(newbuf, (l + 1) * sizeof(*newbuf));\n\tif (newbuf == NULL)\n\t{\n\t    vim_free(wfname);\n\t    vim_free(newbuf_t);\n\t    return FAIL;\n\t}\n\t// Really should always succeed, as the buffer is big enough.\n\tl = GetShortPathNameW(wfname, newbuf, l+1);\n    }\n    if (l != 0)\n    {\n\tchar_u *p = utf16_to_enc(newbuf, NULL);\n\n\tif (p != NULL)\n\t{\n\t    vim_free(*bufp);\n\t    *fnamep = *bufp = p;\n\t}\n\telse\n\t{\n\t    vim_free(wfname);\n\t    vim_free(newbuf);\n\t    return FAIL;\n\t}\n    }\n    vim_free(wfname);\n    vim_free(newbuf);\n\n    *fnamelen = l == 0 ? l : (int)STRLEN(*bufp);\n    return OK;\n}\n\n/*\n * Get the short path (8.3) for the filename in \"fname\". The converted\n * path is returned in \"bufp\".\n *\n * Some of the directories specified in \"fname\" may not exist. This function\n * will shorten the existing directories at the beginning of the path and then\n * append the remaining non-existing path.\n *\n * fname - Pointer to the filename to shorten.  On return, contains the\n *\t   pointer to the shortened pathname\n * bufp -  Pointer to an allocated buffer for the filename.\n * fnamelen - Length of the filename pointed to by fname\n *\n * Returns OK on success (or nothing done) and FAIL on failure (out of memory).\n */\n    static int\nshortpath_for_invalid_fname(\n    char_u\t**fname,\n    char_u\t**bufp,\n    int\t\t*fnamelen)\n{\n    char_u\t*short_fname, *save_fname, *pbuf_unused;\n    char_u\t*endp, *save_endp;\n    char_u\tch;\n    int\t\told_len, len;\n    int\t\tnew_len, sfx_len;\n    int\t\tretval = OK;\n\n    // Make a copy\n    old_len = *fnamelen;\n    save_fname = vim_strnsave(*fname, old_len);\n    pbuf_unused = NULL;\n    short_fname = NULL;\n\n    endp = save_fname + old_len - 1; // Find the end of the copy\n    save_endp = endp;\n\n    /*\n     * Try shortening the supplied path till it succeeds by removing one\n     * directory at a time from the tail of the path.\n     */\n    len = 0;\n    for (;;)\n    {\n\t// go back one path-separator\n\twhile (endp > save_fname && !after_pathsep(save_fname, endp + 1))\n\t    --endp;\n\tif (endp <= save_fname)\n\t    break;\t\t// processed the complete path\n\n\t/*\n\t * Replace the path separator with a NUL and try to shorten the\n\t * resulting path.\n\t */\n\tch = *endp;\n\t*endp = 0;\n\tshort_fname = save_fname;\n\tlen = (int)STRLEN(short_fname) + 1;\n\tif (get_short_pathname(&short_fname, &pbuf_unused, &len) == FAIL)\n\t{\n\t    retval = FAIL;\n\t    goto theend;\n\t}\n\t*endp = ch;\t// preserve the string\n\n\tif (len > 0)\n\t    break;\t// successfully shortened the path\n\n\t// failed to shorten the path. Skip the path separator\n\t--endp;\n    }\n\n    if (len > 0)\n    {\n\t/*\n\t * Succeeded in shortening the path. Now concatenate the shortened\n\t * path with the remaining path at the tail.\n\t */\n\n\t// Compute the length of the new path.\n\tsfx_len = (int)(save_endp - endp) + 1;\n\tnew_len = len + sfx_len;\n\n\t*fnamelen = new_len;\n\tvim_free(*bufp);\n\tif (new_len > old_len)\n\t{\n\t    // There is not enough space in the currently allocated string,\n\t    // copy it to a buffer big enough.\n\t    *fname = *bufp = vim_strnsave(short_fname, new_len);\n\t    if (*fname == NULL)\n\t    {\n\t\tretval = FAIL;\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    // Transfer short_fname to the main buffer (it's big enough),\n\t    // unless get_short_pathname() did its work in-place.\n\t    *fname = *bufp = save_fname;\n\t    if (short_fname != save_fname)\n\t\tvim_strncpy(save_fname, short_fname, len);\n\t    save_fname = NULL;\n\t}\n\n\t// concat the not-shortened part of the path\n\tvim_strncpy(*fname + len, endp, sfx_len);\n\t(*fname)[new_len] = NUL;\n    }\n\ntheend:\n    vim_free(pbuf_unused);\n    vim_free(save_fname);\n\n    return retval;\n}\n\n/*\n * Get a pathname for a partial path.\n * Returns OK for success, FAIL for failure.\n */\n    static int\nshortpath_for_partial(\n    char_u\t**fnamep,\n    char_u\t**bufp,\n    int\t\t*fnamelen)\n{\n    int\t\tsepcount, len, tflen;\n    char_u\t*p;\n    char_u\t*pbuf, *tfname;\n    int\t\thasTilde;\n\n    // Count up the path separators from the RHS.. so we know which part\n    // of the path to return.\n    sepcount = 0;\n    for (p = *fnamep; p < *fnamep + *fnamelen; MB_PTR_ADV(p))\n\tif (vim_ispathsep(*p))\n\t    ++sepcount;\n\n    // Need full path first (use expand_env() to remove a \"~/\")\n    hasTilde = (**fnamep == '~');\n    if (hasTilde)\n\tpbuf = tfname = expand_env_save(*fnamep);\n    else\n\tpbuf = tfname = FullName_save(*fnamep, FALSE);\n\n    len = tflen = (int)STRLEN(tfname);\n\n    if (get_short_pathname(&tfname, &pbuf, &len) == FAIL)\n\treturn FAIL;\n\n    if (len == 0)\n    {\n\t// Don't have a valid filename, so shorten the rest of the\n\t// path if we can. This CAN give us invalid 8.3 filenames, but\n\t// there's not a lot of point in guessing what it might be.\n\tlen = tflen;\n\tif (shortpath_for_invalid_fname(&tfname, &pbuf, &len) == FAIL)\n\t    return FAIL;\n    }\n\n    // Count the paths backward to find the beginning of the desired string.\n    for (p = tfname + len - 1; p >= tfname; --p)\n    {\n\tif (has_mbyte)\n\t    p -= mb_head_off(tfname, p);\n\tif (vim_ispathsep(*p))\n\t{\n\t    if (sepcount == 0 || (hasTilde && sepcount == 1))\n\t\tbreak;\n\t    else\n\t\tsepcount --;\n\t}\n    }\n    if (hasTilde)\n    {\n\t--p;\n\tif (p >= tfname)\n\t    *p = '~';\n\telse\n\t    return FAIL;\n    }\n    else\n\t++p;\n\n    // Copy in the string - p indexes into tfname - allocated at pbuf\n    vim_free(*bufp);\n    *fnamelen = (int)STRLEN(p);\n    *bufp = pbuf;\n    *fnamep = p;\n\n    return OK;\n}\n#endif // MSWIN\n\n/*\n * Adjust a filename, according to a string of modifiers.\n * *fnamep must be NUL terminated when called.  When returning, the length is\n * determined by *fnamelen.\n * Returns VALID_ flags or -1 for failure.\n * When there is an error, *fnamep is set to NULL.\n */\n    int\nmodify_fname(\n    char_u\t*src,\t\t// string with modifiers\n    int\t\ttilde_file,\t// \"~\" is a file name, not $HOME\n    int\t\t*usedlen,\t// characters after src that are used\n    char_u\t**fnamep,\t// file name so far\n    char_u\t**bufp,\t\t// buffer for allocated file name or NULL\n    int\t\t*fnamelen)\t// length of fnamep\n{\n    int\t\tvalid = 0;\n    char_u\t*tail;\n    char_u\t*s, *p, *pbuf;\n    char_u\tdirname[MAXPATHL];\n    int\t\tc;\n    int\t\thas_fullname = 0;\n    int\t\thas_homerelative = 0;\n#ifdef MSWIN\n    char_u\t*fname_start = *fnamep;\n    int\t\thas_shortname = 0;\n#endif\n\nrepeat:\n    // \":p\" - full path/file_name\n    if (src[*usedlen] == ':' && src[*usedlen + 1] == 'p')\n    {\n\thas_fullname = 1;\n\n\tvalid |= VALID_PATH;\n\t*usedlen += 2;\n\n\t// Expand \"~/path\" for all systems and \"~user/path\" for Unix and VMS\n\tif ((*fnamep)[0] == '~'\n#if !defined(UNIX) && !(defined(VMS) && defined(USER_HOME))\n\t\t&& ((*fnamep)[1] == '/'\n# ifdef BACKSLASH_IN_FILENAME\n\t\t    || (*fnamep)[1] == '\\\\'\n# endif\n\t\t    || (*fnamep)[1] == NUL)\n#endif\n\t\t&& !(tilde_file && (*fnamep)[1] == NUL)\n\t   )\n\t{\n\t    *fnamep = expand_env_save(*fnamep);\n\t    vim_free(*bufp);\t// free any allocated file name\n\t    *bufp = *fnamep;\n\t    if (*fnamep == NULL)\n\t\treturn -1;\n\t}\n\n\t// When \"/.\" or \"/..\" is used: force expansion to get rid of it.\n\tfor (p = *fnamep; *p != NUL; MB_PTR_ADV(p))\n\t{\n\t    if (vim_ispathsep(*p)\n\t\t    && p[1] == '.'\n\t\t    && (p[2] == NUL\n\t\t\t|| vim_ispathsep(p[2])\n\t\t\t|| (p[2] == '.'\n\t\t\t    && (p[3] == NUL || vim_ispathsep(p[3])))))\n\t\tbreak;\n\t}\n\n\t// FullName_save() is slow, don't use it when not needed.\n\tif (*p != NUL || !vim_isAbsName(*fnamep))\n\t{\n\t    *fnamep = FullName_save(*fnamep, *p != NUL);\n\t    vim_free(*bufp);\t// free any allocated file name\n\t    *bufp = *fnamep;\n\t    if (*fnamep == NULL)\n\t\treturn -1;\n\t}\n\n#ifdef MSWIN\n# if _WIN32_WINNT >= 0x0500\n\tif (vim_strchr(*fnamep, '~') != NULL)\n\t{\n\t    // Expand 8.3 filename to full path.  Needed to make sure the same\n\t    // file does not have two different names.\n\t    // Note: problem does not occur if _WIN32_WINNT < 0x0500.\n\t    WCHAR *wfname = enc_to_utf16(*fnamep, NULL);\n\t    WCHAR buf[_MAX_PATH];\n\n\t    if (wfname != NULL)\n\t    {\n\t\tif (GetLongPathNameW(wfname, buf, _MAX_PATH))\n\t\t{\n\t\t    char_u *q = utf16_to_enc(buf, NULL);\n\n\t\t    if (q != NULL)\n\t\t    {\n\t\t\tvim_free(*bufp);    // free any allocated file name\n\t\t\t*bufp = *fnamep = q;\n\t\t    }\n\t\t}\n\t\tvim_free(wfname);\n\t    }\n\t}\n# endif\n#endif\n\t// Append a path separator to a directory.\n\tif (mch_isdir(*fnamep))\n\t{\n\t    // Make room for one or two extra characters.\n\t    *fnamep = vim_strnsave(*fnamep, STRLEN(*fnamep) + 2);\n\t    vim_free(*bufp);\t// free any allocated file name\n\t    *bufp = *fnamep;\n\t    if (*fnamep == NULL)\n\t\treturn -1;\n\t    add_pathsep(*fnamep);\n\t}\n    }\n\n    // \":.\" - path relative to the current directory\n    // \":~\" - path relative to the home directory\n    // \":8\" - shortname path - postponed till after\n    while (src[*usedlen] == ':'\n\t\t  && ((c = src[*usedlen + 1]) == '.' || c == '~' || c == '8'))\n    {\n\t*usedlen += 2;\n\tif (c == '8')\n\t{\n#ifdef MSWIN\n\t    has_shortname = 1; // Postpone this.\n#endif\n\t    continue;\n\t}\n\tpbuf = NULL;\n\t// Need full path first (use expand_env() to remove a \"~/\")\n\tif (!has_fullname && !has_homerelative)\n\t{\n\t    if (**fnamep == '~')\n\t\tp = pbuf = expand_env_save(*fnamep);\n\t    else\n\t\tp = pbuf = FullName_save(*fnamep, FALSE);\n\t}\n\telse\n\t    p = *fnamep;\n\n\thas_fullname = 0;\n\n\tif (p != NULL)\n\t{\n\t    if (c == '.')\n\t    {\n\t\tsize_t\tnamelen;\n\n\t\tmch_dirname(dirname, MAXPATHL);\n\t\tif (has_homerelative)\n\t\t{\n\t\t    s = vim_strsave(dirname);\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\thome_replace(NULL, s, dirname, MAXPATHL, TRUE);\n\t\t\tvim_free(s);\n\t\t    }\n\t\t}\n\t\tnamelen = STRLEN(dirname);\n\n\t\t// Do not call shorten_fname() here since it removes the prefix\n\t\t// even though the path does not have a prefix.\n\t\tif (fnamencmp(p, dirname, namelen) == 0)\n\t\t{\n\t\t    p += namelen;\n\t\t    if (vim_ispathsep(*p))\n\t\t    {\n\t\t\twhile (*p && vim_ispathsep(*p))\n\t\t\t    ++p;\n\t\t\t*fnamep = p;\n\t\t\tif (pbuf != NULL)\n\t\t\t{\n\t\t\t    // free any allocated file name\n\t\t\t    vim_free(*bufp);\n\t\t\t    *bufp = pbuf;\n\t\t\t    pbuf = NULL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\thome_replace(NULL, p, dirname, MAXPATHL, TRUE);\n\t\t// Only replace it when it starts with '~'\n\t\tif (*dirname == '~')\n\t\t{\n\t\t    s = vim_strsave(dirname);\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\t*fnamep = s;\n\t\t\tvim_free(*bufp);\n\t\t\t*bufp = s;\n\t\t\thas_homerelative = TRUE;\n\t\t    }\n\t\t}\n\t    }\n\t    vim_free(pbuf);\n\t}\n    }\n\n    tail = gettail(*fnamep);\n    *fnamelen = (int)STRLEN(*fnamep);\n\n    // \":h\" - head, remove \"/file_name\", can be repeated\n    // Don't remove the first \"/\" or \"c:\\\"\n    while (src[*usedlen] == ':' && src[*usedlen + 1] == 'h')\n    {\n\tvalid |= VALID_HEAD;\n\t*usedlen += 2;\n\ts = get_past_head(*fnamep);\n\twhile (tail > s && after_pathsep(s, tail))\n\t    MB_PTR_BACK(*fnamep, tail);\n\t*fnamelen = (int)(tail - *fnamep);\n#ifdef VMS\n\tif (*fnamelen > 0)\n\t    *fnamelen += 1; // the path separator is part of the path\n#endif\n\tif (*fnamelen == 0)\n\t{\n\t    // Result is empty.  Turn it into \".\" to make \":cd %:h\" work.\n\t    p = vim_strsave((char_u *)\".\");\n\t    if (p == NULL)\n\t\treturn -1;\n\t    vim_free(*bufp);\n\t    *bufp = *fnamep = tail = p;\n\t    *fnamelen = 1;\n\t}\n\telse\n\t{\n\t    while (tail > s && !after_pathsep(s, tail))\n\t\tMB_PTR_BACK(*fnamep, tail);\n\t}\n    }\n\n    // \":8\" - shortname\n    if (src[*usedlen] == ':' && src[*usedlen + 1] == '8')\n    {\n\t*usedlen += 2;\n#ifdef MSWIN\n\thas_shortname = 1;\n#endif\n    }\n\n#ifdef MSWIN\n    /*\n     * Handle \":8\" after we have done 'heads' and before we do 'tails'.\n     */\n    if (has_shortname)\n    {\n\t// Copy the string if it is shortened by :h and when it wasn't copied\n\t// yet, because we are going to change it in place.  Avoids changing\n\t// the buffer name for \"%:8\".\n\tif (*fnamelen < (int)STRLEN(*fnamep) || *fnamep == fname_start)\n\t{\n\t    p = vim_strnsave(*fnamep, *fnamelen);\n\t    if (p == NULL)\n\t\treturn -1;\n\t    vim_free(*bufp);\n\t    *bufp = *fnamep = p;\n\t}\n\n\t// Split into two implementations - makes it easier.  First is where\n\t// there isn't a full name already, second is where there is.\n\tif (!has_fullname && !vim_isAbsName(*fnamep))\n\t{\n\t    if (shortpath_for_partial(fnamep, bufp, fnamelen) == FAIL)\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t    int\t\tl = *fnamelen;\n\n\t    // Simple case, already have the full-name.\n\t    // Nearly always shorter, so try first time.\n\t    if (get_short_pathname(fnamep, bufp, &l) == FAIL)\n\t\treturn -1;\n\n\t    if (l == 0)\n\t    {\n\t\t// Couldn't find the filename, search the paths.\n\t\tl = *fnamelen;\n\t\tif (shortpath_for_invalid_fname(fnamep, bufp, &l) == FAIL)\n\t\t    return -1;\n\t    }\n\t    *fnamelen = l;\n\t}\n    }\n#endif // MSWIN\n\n    // \":t\" - tail, just the basename\n    if (src[*usedlen] == ':' && src[*usedlen + 1] == 't')\n    {\n\t*usedlen += 2;\n\t*fnamelen -= (int)(tail - *fnamep);\n\t*fnamep = tail;\n    }\n\n    // \":e\" - extension, can be repeated\n    // \":r\" - root, without extension, can be repeated\n    while (src[*usedlen] == ':'\n\t    && (src[*usedlen + 1] == 'e' || src[*usedlen + 1] == 'r'))\n    {\n\t// find a '.' in the tail:\n\t// - for second :e: before the current fname\n\t// - otherwise: The last '.'\n\tif (src[*usedlen + 1] == 'e' && *fnamep > tail)\n\t    s = *fnamep - 2;\n\telse\n\t    s = *fnamep + *fnamelen - 1;\n\tfor ( ; s > tail; --s)\n\t    if (s[0] == '.')\n\t\tbreak;\n\tif (src[*usedlen + 1] == 'e')\t\t// :e\n\t{\n\t    if (s > tail)\n\t    {\n\t\t*fnamelen += (int)(*fnamep - (s + 1));\n\t\t*fnamep = s + 1;\n#ifdef VMS\n\t\t// cut version from the extension\n\t\ts = *fnamep + *fnamelen - 1;\n\t\tfor ( ; s > *fnamep; --s)\n\t\t    if (s[0] == ';')\n\t\t\tbreak;\n\t\tif (s > *fnamep)\n\t\t    *fnamelen = s - *fnamep;\n#endif\n\t    }\n\t    else if (*fnamep <= tail)\n\t\t*fnamelen = 0;\n\t}\n\telse\t\t\t\t// :r\n\t{\n\t    char_u *limit = *fnamep;\n\n\t    if (limit < tail)\n\t\tlimit = tail;\n\t    if (s > limit)\t// remove one extension\n\t\t*fnamelen = (int)(s - *fnamep);\n\t}\n\t*usedlen += 2;\n    }\n\n    // \":s?pat?foo?\" - substitute\n    // \":gs?pat?foo?\" - global substitute\n    if (src[*usedlen] == ':'\n\t    && (src[*usedlen + 1] == 's'\n\t\t|| (src[*usedlen + 1] == 'g' && src[*usedlen + 2] == 's')))\n    {\n\tchar_u\t    *str;\n\tchar_u\t    *pat;\n\tchar_u\t    *sub;\n\tint\t    sep;\n\tchar_u\t    *flags;\n\tint\t    didit = FALSE;\n\n\tflags = (char_u *)\"\";\n\ts = src + *usedlen + 2;\n\tif (src[*usedlen + 1] == 'g')\n\t{\n\t    flags = (char_u *)\"g\";\n\t    ++s;\n\t}\n\n\tsep = *s++;\n\tif (sep)\n\t{\n\t    // find end of pattern\n\t    p = vim_strchr(s, sep);\n\t    if (p != NULL)\n\t    {\n\t\tpat = vim_strnsave(s, p - s);\n\t\tif (pat != NULL)\n\t\t{\n\t\t    s = p + 1;\n\t\t    // find end of substitution\n\t\t    p = vim_strchr(s, sep);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tsub = vim_strnsave(s, p - s);\n\t\t\tstr = vim_strnsave(*fnamep, *fnamelen);\n\t\t\tif (sub != NULL && str != NULL)\n\t\t\t{\n\t\t\t    *usedlen = (int)(p + 1 - src);\n\t\t\t    s = do_string_sub(str, pat, sub, NULL, flags);\n\t\t\t    if (s != NULL)\n\t\t\t    {\n\t\t\t\t*fnamep = s;\n\t\t\t\t*fnamelen = (int)STRLEN(s);\n\t\t\t\tvim_free(*bufp);\n\t\t\t\t*bufp = s;\n\t\t\t\tdidit = TRUE;\n\t\t\t    }\n\t\t\t}\n\t\t\tvim_free(sub);\n\t\t\tvim_free(str);\n\t\t    }\n\t\t    vim_free(pat);\n\t\t}\n\t    }\n\t    // after using \":s\", repeat all the modifiers\n\t    if (didit)\n\t\tgoto repeat;\n\t}\n    }\n\n    if (src[*usedlen] == ':' && src[*usedlen + 1] == 'S')\n    {\n\t// vim_strsave_shellescape() needs a NUL terminated string.\n\tc = (*fnamep)[*fnamelen];\n\tif (c != NUL)\n\t    (*fnamep)[*fnamelen] = NUL;\n\tp = vim_strsave_shellescape(*fnamep, FALSE, FALSE);\n\tif (c != NUL)\n\t    (*fnamep)[*fnamelen] = c;\n\tif (p == NULL)\n\t    return -1;\n\tvim_free(*bufp);\n\t*bufp = *fnamep = p;\n\t*fnamelen = (int)STRLEN(p);\n\t*usedlen += 2;\n    }\n\n    return valid;\n}\n\n/*\n * Shorten the path of a file from \"~/foo/../.bar/fname\" to \"~/f/../.b/fname\"\n * \"trim_len\" specifies how many characters to keep for each directory.\n * Must be 1 or more.\n * It's done in-place.\n */\n    static void\nshorten_dir_len(char_u *str, int trim_len)\n{\n    char_u\t*tail, *s, *d;\n    int\t\tskip = FALSE;\n    int\t\tdirchunk_len = 0;\n\n    tail = gettail(str);\n    d = str;\n    for (s = str; ; ++s)\n    {\n\tif (s >= tail)\t\t    // copy the whole tail\n\t{\n\t    *d++ = *s;\n\t    if (*s == NUL)\n\t\tbreak;\n\t}\n\telse if (vim_ispathsep(*s))\t    // copy '/' and next char\n\t{\n\t    *d++ = *s;\n\t    skip = FALSE;\n\t    dirchunk_len = 0;\n\t}\n\telse if (!skip)\n\t{\n\t    *d++ = *s;\t\t\t// copy next char\n\t    if (*s != '~' && *s != '.') // and leading \"~\" and \".\"\n\t    {\n\t\t++dirchunk_len; // only count word chars for the size\n\n\t\t// keep copying chars until we have our preferred length (or\n\t\t// until the above if/else branches move us along)\n\t\tif (dirchunk_len >= trim_len)\n\t\t    skip = TRUE;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tint l = mb_ptr2len(s);\n\n\t\twhile (--l > 0)\n\t\t    *d++ = *++s;\n\t    }\n\t}\n    }\n}\n\n/*\n * Shorten the path of a file from \"~/foo/../.bar/fname\" to \"~/f/../.b/fname\"\n * It's done in-place.\n */\n    void\nshorten_dir(char_u *str)\n{\n    shorten_dir_len(str, 1);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * \"chdir(dir)\" function\n */\n    void\nf_chdir(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*cwd;\n    cdscope_T\tscope = CDSCOPE_GLOBAL;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (argvars[0].v_type != VAR_STRING)\n    {\n\t// Returning an empty string means it failed.\n\t// No error message, for historic reasons.\n\tif (in_vim9script())\n\t    (void) check_for_string_arg(argvars, 0);\n\treturn;\n    }\n\n    // Return the current directory\n    cwd = alloc(MAXPATHL);\n    if (cwd != NULL)\n    {\n\tif (mch_dirname(cwd, MAXPATHL) != FAIL)\n\t{\n#ifdef BACKSLASH_IN_FILENAME\n\t    slash_adjust(cwd);\n#endif\n\t    rettv->vval.v_string = vim_strsave(cwd);\n\t}\n\tvim_free(cwd);\n    }\n\n    if (curwin->w_localdir != NULL)\n\tscope = CDSCOPE_WINDOW;\n    else if (curtab->tp_localdir != NULL)\n\tscope = CDSCOPE_TABPAGE;\n\n    if (!changedir_func(argvars[0].vval.v_string, TRUE, scope))\n\t// Directory change failed\n\tVIM_CLEAR(rettv->vval.v_string);\n}\n\n/*\n * \"delete()\" function\n */\n    void\nf_delete(typval_T *argvars, typval_T *rettv)\n{\n    char_u\tnbuf[NUMBUFLEN];\n    char_u\t*name;\n    char_u\t*flags;\n\n    rettv->vval.v_number = -1;\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    name = tv_get_string(&argvars[0]);\n    if (name == NULL || *name == NUL)\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n\tflags = tv_get_string_buf(&argvars[1], nbuf);\n    else\n\tflags = (char_u *)\"\";\n\n    if (*flags == NUL)\n\t// delete a file\n\trettv->vval.v_number = mch_remove(name) == 0 ? 0 : -1;\n    else if (STRCMP(flags, \"d\") == 0)\n\t// delete an empty directory\n\trettv->vval.v_number = mch_rmdir(name) == 0 ? 0 : -1;\n    else if (STRCMP(flags, \"rf\") == 0)\n\t// delete a directory recursively\n\trettv->vval.v_number = delete_recursive(name);\n    else\n\tsemsg(_(e_invalid_expression_str), flags);\n}\n\n/*\n * \"executable()\" function\n */\n    void\nf_executable(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    // Check in $PATH and also check directly if there is a directory name.\n    rettv->vval.v_number = mch_can_exe(tv_get_string(&argvars[0]), NULL, TRUE);\n}\n\n/*\n * \"exepath()\" function\n */\n    void\nf_exepath(typval_T *argvars, typval_T *rettv)\n{\n    char_u *p = NULL;\n\n    if (in_vim9script() && check_for_nonempty_string_arg(argvars, 0) == FAIL)\n\treturn;\n    (void)mch_can_exe(tv_get_string(&argvars[0]), &p, TRUE);\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = p;\n}\n\n/*\n * \"filereadable()\" function\n */\n    void\nf_filereadable(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tfd;\n    char_u\t*p;\n    int\t\tn;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n#ifndef O_NONBLOCK\n# define O_NONBLOCK 0\n#endif\n    p = tv_get_string(&argvars[0]);\n    if (*p && !mch_isdir(p) && (fd = mch_open((char *)p,\n\t\t\t\t\t      O_RDONLY | O_NONBLOCK, 0)) >= 0)\n    {\n\tn = TRUE;\n\tclose(fd);\n    }\n    else\n\tn = FALSE;\n\n    rettv->vval.v_number = n;\n}\n\n/*\n * Return 0 for not writable, 1 for writable file, 2 for a dir which we have\n * rights to write into.\n */\n    void\nf_filewritable(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n    rettv->vval.v_number = filewritable(tv_get_string(&argvars[0]));\n}\n\n    static void\nfindfilendir(\n    typval_T\t*argvars UNUSED,\n    typval_T\t*rettv,\n    int\t\tfind_what UNUSED)\n{\n#ifdef FEAT_SEARCHPATH\n    char_u\t*fname;\n    char_u\t*fresult = NULL;\n    char_u\t*path = *curbuf->b_p_path == NUL ? p_path : curbuf->b_p_path;\n    char_u\t*p;\n    char_u\tpathbuf[NUMBUFLEN];\n    int\t\tcount = 1;\n    int\t\tfirst = TRUE;\n    int\t\terror = FALSE;\n#endif\n\n    rettv->vval.v_string = NULL;\n    rettv->v_type = VAR_STRING;\n    if (in_vim9script()\n\t    && (check_for_nonempty_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_number_arg(argvars, 2) == FAIL)))\n\treturn;\n\n#ifdef FEAT_SEARCHPATH\n    fname = tv_get_string(&argvars[0]);\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tp = tv_get_string_buf_chk(&argvars[1], pathbuf);\n\tif (p == NULL)\n\t    error = TRUE;\n\telse\n\t{\n\t    if (*p != NUL)\n\t\tpath = p;\n\n\t    if (argvars[2].v_type != VAR_UNKNOWN)\n\t\tcount = (int)tv_get_number_chk(&argvars[2], &error);\n\t}\n    }\n\n    if (count < 0 && rettv_list_alloc(rettv) == FAIL)\n\terror = TRUE;\n\n    if (*fname != NUL && !error)\n    {\n\tdo\n\t{\n\t    if (rettv->v_type == VAR_STRING || rettv->v_type == VAR_LIST)\n\t\tvim_free(fresult);\n\t    fresult = find_file_in_path_option(first ? fname : NULL,\n\t\t\t\t\t       first ? (int)STRLEN(fname) : 0,\n\t\t\t\t\t0, first, path,\n\t\t\t\t\tfind_what,\n\t\t\t\t\tcurbuf->b_ffname,\n\t\t\t\t\tfind_what == FINDFILE_DIR\n\t\t\t\t\t    ? (char_u *)\"\" : curbuf->b_p_sua);\n\t    first = FALSE;\n\n\t    if (fresult != NULL && rettv->v_type == VAR_LIST)\n\t\tlist_append_string(rettv->vval.v_list, fresult, -1);\n\n\t} while ((rettv->v_type == VAR_LIST || --count > 0) && fresult != NULL);\n    }\n\n    if (rettv->v_type == VAR_STRING)\n\trettv->vval.v_string = fresult;\n#endif\n}\n\n/*\n * \"finddir({fname}[, {path}[, {count}]])\" function\n */\n    void\nf_finddir(typval_T *argvars, typval_T *rettv)\n{\n    findfilendir(argvars, rettv, FINDFILE_DIR);\n}\n\n/*\n * \"findfile({fname}[, {path}[, {count}]])\" function\n */\n    void\nf_findfile(typval_T *argvars, typval_T *rettv)\n{\n    findfilendir(argvars, rettv, FINDFILE_FILE);\n}\n\n/*\n * \"fnamemodify({fname}, {mods})\" function\n */\n    void\nf_fnamemodify(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*fname;\n    char_u\t*mods;\n    int\t\tusedlen = 0;\n    int\t\tlen = 0;\n    char_u\t*fbuf = NULL;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    fname = tv_get_string_chk(&argvars[0]);\n    mods = tv_get_string_buf_chk(&argvars[1], buf);\n    if (mods == NULL || fname == NULL)\n\tfname = NULL;\n    else\n    {\n\tlen = (int)STRLEN(fname);\n\tif (mods != NULL && *mods != NUL)\n\t    (void)modify_fname(mods, FALSE, &usedlen, &fname, &fbuf, &len);\n    }\n\n    rettv->v_type = VAR_STRING;\n    if (fname == NULL)\n\trettv->vval.v_string = NULL;\n    else\n\trettv->vval.v_string = vim_strnsave(fname, len);\n    vim_free(fbuf);\n}\n\n/*\n * \"getcwd()\" function\n *\n * Return the current working directory of a window in a tab page.\n * First optional argument 'winnr' is the window number or -1 and the second\n * optional argument 'tabnr' is the tab page number.\n *\n * If no arguments are supplied, then return the directory of the current\n * window.\n * If only 'winnr' is specified and is not -1 or 0 then return the directory of\n * the specified window.\n * If 'winnr' is 0 then return the directory of the current window.\n * If both 'winnr and 'tabnr' are specified and 'winnr' is -1 then return the\n * directory of the specified tab page.  Otherwise return the directory of the\n * specified window in the specified tab page.\n * If the window or the tab page doesn't exist then return NULL.\n */\n    void\nf_getcwd(typval_T *argvars, typval_T *rettv)\n{\n    win_T\t*wp = NULL;\n    tabpage_T\t*tp = NULL;\n    char_u\t*cwd;\n    int\t\tglobal = FALSE;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script()\n\t    && (check_for_opt_number_arg(argvars, 0) == FAIL\n\t\t|| (argvars[0].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_number_arg(argvars, 1) == FAIL)))\n\treturn;\n\n    if (argvars[0].v_type == VAR_NUMBER\n\t    && argvars[0].vval.v_number == -1\n\t    && argvars[1].v_type == VAR_UNKNOWN)\n\tglobal = TRUE;\n    else\n\twp = find_tabwin(&argvars[0], &argvars[1], &tp);\n\n    if (wp != NULL && wp->w_localdir != NULL\n\t\t\t\t\t   && argvars[0].v_type != VAR_UNKNOWN)\n\trettv->vval.v_string = vim_strsave(wp->w_localdir);\n    else if (tp != NULL && tp->tp_localdir != NULL\n\t\t\t\t\t   && argvars[0].v_type != VAR_UNKNOWN)\n\trettv->vval.v_string = vim_strsave(tp->tp_localdir);\n    else if (wp != NULL || tp != NULL || global)\n    {\n\tif (globaldir != NULL && argvars[0].v_type != VAR_UNKNOWN)\n\t    rettv->vval.v_string = vim_strsave(globaldir);\n\telse\n\t{\n\t    cwd = alloc(MAXPATHL);\n\t    if (cwd != NULL)\n\t    {\n\t\tif (mch_dirname(cwd, MAXPATHL) != FAIL)\n\t\t    rettv->vval.v_string = vim_strsave(cwd);\n\t\tvim_free(cwd);\n\t    }\n\t}\n    }\n#ifdef BACKSLASH_IN_FILENAME\n    if (rettv->vval.v_string != NULL)\n\tslash_adjust(rettv->vval.v_string);\n#endif\n}\n\n/*\n * Convert \"st\" to file permission string.\n */\n    char_u *\ngetfpermst(stat_T *st, char_u *perm)\n{\n    char_u\t    flags[] = \"rwx\";\n    int\t\t    i;\n\n    for (i = 0; i < 9; i++)\n    {\n\tif (st->st_mode & (1 << (8 - i)))\n\t    perm[i] = flags[i % 3];\n\telse\n\t    perm[i] = '-';\n    }\n    return perm;\n}\n\n/*\n * \"getfperm({fname})\" function\n */\n    void\nf_getfperm(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*fname;\n    stat_T\tst;\n    char_u\t*perm = NULL;\n    char_u\tpermbuf[] = \"---------\";\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    fname = tv_get_string(&argvars[0]);\n\n    rettv->v_type = VAR_STRING;\n    if (mch_stat((char *)fname, &st) >= 0)\n\tperm = vim_strsave(getfpermst(&st, permbuf));\n    rettv->vval.v_string = perm;\n}\n\n/*\n * \"getfsize({fname})\" function\n */\n    void\nf_getfsize(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*fname;\n    stat_T\tst;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    fname = tv_get_string(&argvars[0]);\n    if (mch_stat((char *)fname, &st) >= 0)\n    {\n\tif (mch_isdir(fname))\n\t    rettv->vval.v_number = 0;\n\telse\n\t{\n\t    rettv->vval.v_number = (varnumber_T)st.st_size;\n\n\t    // non-perfect check for overflow\n\t    if ((off_T)rettv->vval.v_number != (off_T)st.st_size)\n\t\trettv->vval.v_number = -2;\n\t}\n    }\n    else\n\t  rettv->vval.v_number = -1;\n}\n\n/*\n * \"getftime({fname})\" function\n */\n    void\nf_getftime(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*fname;\n    stat_T\tst;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    fname = tv_get_string(&argvars[0]);\n    if (mch_stat((char *)fname, &st) >= 0)\n\trettv->vval.v_number = (varnumber_T)st.st_mtime;\n    else\n\trettv->vval.v_number = -1;\n}\n\n/*\n * Convert \"st\" to file type string.\n */\n    char_u *\ngetftypest(stat_T *st)\n{\n    char    *t;\n\n    if (S_ISREG(st->st_mode))\n\tt = \"file\";\n    else if (S_ISDIR(st->st_mode))\n\tt = \"dir\";\n    else if (S_ISLNK(st->st_mode))\n\tt = \"link\";\n    else if (S_ISBLK(st->st_mode))\n\tt = \"bdev\";\n    else if (S_ISCHR(st->st_mode))\n\tt = \"cdev\";\n    else if (S_ISFIFO(st->st_mode))\n\tt = \"fifo\";\n    else if (S_ISSOCK(st->st_mode))\n\tt = \"socket\";\n    else\n\tt = \"other\";\n    return (char_u*)t;\n}\n\n/*\n * \"getftype({fname})\" function\n */\n    void\nf_getftype(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*fname;\n    stat_T\tst;\n    char_u\t*type = NULL;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    fname = tv_get_string(&argvars[0]);\n\n    rettv->v_type = VAR_STRING;\n    if (mch_lstat((char *)fname, &st) >= 0)\n\ttype = vim_strsave(getftypest(&st));\n    rettv->vval.v_string = type;\n}\n\n/*\n * \"glob()\" function\n */\n    void\nf_glob(typval_T *argvars, typval_T *rettv)\n{\n    int\t\toptions = WILD_SILENT|WILD_USE_NL;\n    expand_T\txpc;\n    int\t\terror = FALSE;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_bool_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && (check_for_opt_bool_arg(argvars, 2) == FAIL\n\t\t\t|| (argvars[2].v_type != VAR_UNKNOWN\n\t\t\t    && check_for_opt_bool_arg(argvars, 3) == FAIL)))))\n\treturn;\n\n    // When the optional second argument is non-zero, don't remove matches\n    // for 'wildignore' and don't put matches for 'suffixes' at the end.\n    rettv->v_type = VAR_STRING;\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tif (tv_get_bool_chk(&argvars[1], &error))\n\t    options |= WILD_KEEP_ALL;\n\tif (argvars[2].v_type != VAR_UNKNOWN)\n\t{\n\t    if (tv_get_bool_chk(&argvars[2], &error))\n\t\trettv_list_set(rettv, NULL);\n\t    if (argvars[3].v_type != VAR_UNKNOWN\n\t\t\t\t    && tv_get_bool_chk(&argvars[3], &error))\n\t\toptions |= WILD_ALLLINKS;\n\t}\n    }\n    if (!error)\n    {\n\tExpandInit(&xpc);\n\txpc.xp_context = EXPAND_FILES;\n\tif (p_wic)\n\t    options += WILD_ICASE;\n\tif (rettv->v_type == VAR_STRING)\n\t    rettv->vval.v_string = ExpandOne(&xpc, tv_get_string(&argvars[0]),\n\t\t\t\t\t\t     NULL, options, WILD_ALL);\n\telse if (rettv_list_alloc(rettv) != FAIL)\n\t{\n\t  int i;\n\n\t  ExpandOne(&xpc, tv_get_string(&argvars[0]),\n\t\t\t\t\t\tNULL, options, WILD_ALL_KEEP);\n\t  for (i = 0; i < xpc.xp_numfiles; i++)\n\t      list_append_string(rettv->vval.v_list, xpc.xp_files[i], -1);\n\n\t  ExpandCleanup(&xpc);\n\t}\n    }\n    else\n\trettv->vval.v_string = NULL;\n}\n\n/*\n * \"glob2regpat()\" function\n */\n    void\nf_glob2regpat(typval_T *argvars, typval_T *rettv)\n{\n    char_u\tbuf[NUMBUFLEN];\n    char_u\t*pat;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pat = tv_get_string_buf_chk_strict(&argvars[0], buf, in_vim9script());\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = (pat == NULL)\n\t\t\t ? NULL : file_pat_to_reg_pat(pat, NULL, NULL, FALSE);\n}\n\n/*\n * \"globpath()\" function\n */\n    void\nf_globpath(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tflags = WILD_IGNORE_COMPLETESLASH;\n    char_u\tbuf1[NUMBUFLEN];\n    char_u\t*file;\n    int\t\terror = FALSE;\n    garray_T\tga;\n    int\t\ti;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_bool_arg(argvars, 2) == FAIL\n\t\t|| (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && (check_for_opt_bool_arg(argvars, 3) == FAIL\n\t\t\t|| (argvars[3].v_type != VAR_UNKNOWN\n\t\t\t    && check_for_opt_bool_arg(argvars, 4) == FAIL)))))\n\treturn;\n\n    file = tv_get_string_buf_chk(&argvars[1], buf1);\n\n    // When the optional second argument is non-zero, don't remove matches\n    // for 'wildignore' and don't put matches for 'suffixes' at the end.\n    rettv->v_type = VAR_STRING;\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tif (tv_get_bool_chk(&argvars[2], &error))\n\t    flags |= WILD_KEEP_ALL;\n\tif (argvars[3].v_type != VAR_UNKNOWN)\n\t{\n\t    if (tv_get_bool_chk(&argvars[3], &error))\n\t\trettv_list_set(rettv, NULL);\n\t    if (argvars[4].v_type != VAR_UNKNOWN\n\t\t\t\t    && tv_get_bool_chk(&argvars[4], &error))\n\t\tflags |= WILD_ALLLINKS;\n\t}\n    }\n    if (file != NULL && !error)\n    {\n\tga_init2(&ga, sizeof(char_u *), 10);\n\tglobpath(tv_get_string(&argvars[0]), file, &ga, flags);\n\tif (rettv->v_type == VAR_STRING)\n\t    rettv->vval.v_string = ga_concat_strings(&ga, \"\\n\");\n\telse if (rettv_list_alloc(rettv) != FAIL)\n\t    for (i = 0; i < ga.ga_len; ++i)\n\t\tlist_append_string(rettv->vval.v_list,\n\t\t\t\t\t    ((char_u **)(ga.ga_data))[i], -1);\n\tga_clear_strings(&ga);\n    }\n    else\n\trettv->vval.v_string = NULL;\n}\n\n/*\n * \"isdirectory()\" function\n */\n    void\nf_isdirectory(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = mch_isdir(tv_get_string(&argvars[0]));\n}\n\n/*\n * Create the directory in which \"dir\" is located, and higher levels when\n * needed.\n * Return OK or FAIL.\n */\n    static int\nmkdir_recurse(char_u *dir, int prot)\n{\n    char_u\t*p;\n    char_u\t*updir;\n    int\t\tr = FAIL;\n\n    // Get end of directory name in \"dir\".\n    // We're done when it's \"/\" or \"c:/\".\n    p = gettail_sep(dir);\n    if (p <= get_past_head(dir))\n\treturn OK;\n\n    // If the directory exists we're done.  Otherwise: create it.\n    updir = vim_strnsave(dir, p - dir);\n    if (updir == NULL)\n\treturn FAIL;\n    if (mch_isdir(updir))\n\tr = OK;\n    else if (mkdir_recurse(updir, prot) == OK)\n\tr = vim_mkdir_emsg(updir, prot);\n    vim_free(updir);\n    return r;\n}\n\n/*\n * \"mkdir()\" function\n */\n    void\nf_mkdir(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*dir;\n    char_u\tbuf[NUMBUFLEN];\n    int\t\tprot = 0755;\n\n    rettv->vval.v_number = FAIL;\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_nonempty_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_number_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    dir = tv_get_string_buf(&argvars[0], buf);\n    if (*dir == NUL)\n\treturn;\n\n    if (*gettail(dir) == NUL)\n\t// remove trailing slashes\n\t*gettail_sep(dir) = NUL;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tif (argvars[2].v_type != VAR_UNKNOWN)\n\t{\n\t    prot = (int)tv_get_number_chk(&argvars[2], NULL);\n\t    if (prot == -1)\n\t\treturn;\n\t}\n\tif (STRCMP(tv_get_string(&argvars[1]), \"p\") == 0)\n\t{\n\t    if (mch_isdir(dir))\n\t    {\n\t\t// With the \"p\" flag it's OK if the dir already exists.\n\t\trettv->vval.v_number = OK;\n\t\treturn;\n\t    }\n\t    mkdir_recurse(dir, prot);\n\t}\n    }\n    rettv->vval.v_number = vim_mkdir_emsg(dir, prot);\n}\n\n/*\n * \"pathshorten()\" function\n */\n    void\nf_pathshorten(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*p;\n    int\t\ttrim_len = 1;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\ttrim_len = (int)tv_get_number(&argvars[1]);\n\tif (trim_len < 1)\n\t    trim_len = 1;\n    }\n\n    rettv->v_type = VAR_STRING;\n    p = tv_get_string_chk(&argvars[0]);\n\n    if (p == NULL)\n\trettv->vval.v_string = NULL;\n    else\n    {\n\tp = vim_strsave(p);\n\trettv->vval.v_string = p;\n\tif (p != NULL)\n\t    shorten_dir_len(p, trim_len);\n    }\n}\n\n/*\n * Common code for readdir_checkitem() and readdirex_checkitem().\n * Either \"name\" or \"dict\" is NULL.\n */\n    static int\ncheckitem_common(void *context, char_u *name, dict_T *dict)\n{\n    typval_T\t*expr = (typval_T *)context;\n    typval_T\tsave_val;\n    typval_T\trettv;\n    typval_T\targv[2];\n    int\t\tretval = 0;\n    int\t\terror = FALSE;\n\n    prepare_vimvar(VV_VAL, &save_val);\n    if (name != NULL)\n    {\n\tset_vim_var_string(VV_VAL, name, -1);\n\targv[0].v_type = VAR_STRING;\n\targv[0].vval.v_string = name;\n    }\n    else\n    {\n\tset_vim_var_dict(VV_VAL, dict);\n\targv[0].v_type = VAR_DICT;\n\targv[0].vval.v_dict = dict;\n    }\n\n    if (eval_expr_typval(expr, argv, 1, &rettv) == FAIL)\n\tgoto theend;\n\n    // We want to use -1, but also true/false should be allowed.\n    if (rettv.v_type == VAR_SPECIAL || rettv.v_type == VAR_BOOL)\n    {\n\trettv.v_type = VAR_NUMBER;\n\trettv.vval.v_number = rettv.vval.v_number == VVAL_TRUE;\n    }\n    retval = tv_get_number_chk(&rettv, &error);\n    if (error)\n\tretval = -1;\n    clear_tv(&rettv);\n\ntheend:\n    if (name != NULL)\n\tset_vim_var_string(VV_VAL, NULL, 0);\n    else\n\tset_vim_var_dict(VV_VAL, NULL);\n    restore_vimvar(VV_VAL, &save_val);\n    return retval;\n}\n\n/*\n * Evaluate \"expr\" (= \"context\") for readdir().\n */\n    static int\nreaddir_checkitem(void *context, void *item)\n{\n    char_u\t*name = (char_u *)item;\n\n    return checkitem_common(context, name, NULL);\n}\n\n    static int\nreaddirex_dict_arg(typval_T *tv, int *cmp)\n{\n    char_u     *compare;\n\n    if (tv->v_type != VAR_DICT)\n    {\n\temsg(_(e_dictionary_required));\n\treturn FAIL;\n    }\n\n    if (dict_find(tv->vval.v_dict, (char_u *)\"sort\", -1) != NULL)\n\tcompare = dict_get_string(tv->vval.v_dict, (char_u *)\"sort\", FALSE);\n    else\n    {\n\tsemsg(_(e_dictionary_key_str_required), \"sort\");\n\treturn FAIL;\n    }\n\n    if (STRCMP(compare, (char_u *) \"none\") == 0)\n\t*cmp = READDIR_SORT_NONE;\n    else if (STRCMP(compare, (char_u *) \"case\") == 0)\n\t*cmp = READDIR_SORT_BYTE;\n    else if (STRCMP(compare, (char_u *) \"icase\") == 0)\n\t*cmp = READDIR_SORT_IC;\n    else if (STRCMP(compare, (char_u *) \"collate\") == 0)\n\t*cmp = READDIR_SORT_COLLATE;\n    return OK;\n}\n\n/*\n * \"readdir()\" function\n */\n    void\nf_readdir(typval_T *argvars, typval_T *rettv)\n{\n    typval_T\t*expr;\n    int\t\tret;\n    char_u\t*path;\n    char_u\t*p;\n    garray_T\tga;\n    int\t\ti;\n    int         sort = READDIR_SORT_BYTE;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_dict_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    path = tv_get_string(&argvars[0]);\n    expr = &argvars[1];\n\n    if (argvars[1].v_type != VAR_UNKNOWN && argvars[2].v_type != VAR_UNKNOWN &&\n\t    readdirex_dict_arg(&argvars[2], &sort) == FAIL)\n\treturn;\n\n    ret = readdir_core(&ga, path, FALSE, (void *)expr,\n\t    (expr->v_type == VAR_UNKNOWN) ? NULL : readdir_checkitem, sort);\n    if (ret == OK)\n    {\n\tfor (i = 0; i < ga.ga_len; i++)\n\t{\n\t    p = ((char_u **)ga.ga_data)[i];\n\t    list_append_string(rettv->vval.v_list, p, -1);\n\t}\n    }\n    ga_clear_strings(&ga);\n}\n\n/*\n * Evaluate \"expr\" (= \"context\") for readdirex().\n */\n    static int\nreaddirex_checkitem(void *context, void *item)\n{\n    dict_T\t*dict = (dict_T*)item;\n\n    return checkitem_common(context, NULL, dict);\n}\n\n/*\n * \"readdirex()\" function\n */\n    void\nf_readdirex(typval_T *argvars, typval_T *rettv)\n{\n    typval_T\t*expr;\n    int\t\tret;\n    char_u\t*path;\n    garray_T\tga;\n    int\t\ti;\n    int         sort = READDIR_SORT_BYTE;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_dict_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    path = tv_get_string(&argvars[0]);\n    expr = &argvars[1];\n\n    if (argvars[1].v_type != VAR_UNKNOWN && argvars[2].v_type != VAR_UNKNOWN &&\n\t    readdirex_dict_arg(&argvars[2], &sort) == FAIL)\n\treturn;\n\n    ret = readdir_core(&ga, path, TRUE, (void *)expr,\n\t    (expr->v_type == VAR_UNKNOWN) ? NULL : readdirex_checkitem, sort);\n    if (ret == OK)\n    {\n\tfor (i = 0; i < ga.ga_len; i++)\n\t{\n\t    dict_T  *dict = ((dict_T**)ga.ga_data)[i];\n\t    list_append_dict(rettv->vval.v_list, dict);\n\t    dict_unref(dict);\n\t}\n    }\n    ga_clear(&ga);\n}\n\n/*\n * \"readfile()\" function\n */\n    static void\nread_file_or_blob(typval_T *argvars, typval_T *rettv, int always_blob)\n{\n    int\t\tbinary = FALSE;\n    int\t\tblob = always_blob;\n    int\t\tfailed = FALSE;\n    char_u\t*fname;\n    FILE\t*fd;\n    char_u\tbuf[(IOSIZE/256)*256];\t// rounded to avoid odd + 1\n    int\t\tio_size = sizeof(buf);\n    int\t\treadlen;\t\t// size of last fread()\n    char_u\t*prev\t = NULL;\t// previously read bytes, if any\n    long\tprevlen  = 0;\t\t// length of data in prev\n    long\tprevsize = 0;\t\t// size of prev buffer\n    long\tmaxline  = MAXLNUM;\n    long\tcnt\t = 0;\n    char_u\t*p;\t\t\t// position in buf\n    char_u\t*start;\t\t\t// start of current line\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tif (STRCMP(tv_get_string(&argvars[1]), \"b\") == 0)\n\t    binary = TRUE;\n\tif (STRCMP(tv_get_string(&argvars[1]), \"B\") == 0)\n\t    blob = TRUE;\n\n\tif (argvars[2].v_type != VAR_UNKNOWN)\n\t    maxline = (long)tv_get_number(&argvars[2]);\n    }\n\n    if ((blob ? rettv_blob_alloc(rettv) : rettv_list_alloc(rettv)) == FAIL)\n\treturn;\n\n    // Always open the file in binary mode, library functions have a mind of\n    // their own about CR-LF conversion.\n    fname = tv_get_string(&argvars[0]);\n\n    if (mch_isdir(fname))\n    {\n\tsemsg(_(e_src_is_directory), fname);\n\treturn;\n    }\n    if (*fname == NUL || (fd = mch_fopen((char *)fname, READBIN)) == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), *fname == NUL ? (char_u *)_(\"<empty>\") : fname);\n\treturn;\n    }\n\n    if (blob)\n    {\n\tif (read_blob(fd, rettv->vval.v_blob) == FAIL)\n\t{\n\t    semsg(_(e_cant_read_file_str), fname);\n\t    // An empty blob is returned on error.\n\t    blob_free(rettv->vval.v_blob);\n\t    rettv->vval.v_blob = NULL;\n\t}\n\tfclose(fd);\n\treturn;\n    }\n\n    while (cnt < maxline || maxline < 0)\n    {\n\treadlen = (int)fread(buf, 1, io_size, fd);\n\n\t// This for loop processes what was read, but is also entered at end\n\t// of file so that either:\n\t// - an incomplete line gets written\n\t// - a \"binary\" file gets an empty line at the end if it ends in a\n\t//   newline.\n\tfor (p = buf, start = buf;\n\t\tp < buf + readlen || (readlen <= 0 && (prevlen > 0 || binary));\n\t\t++p)\n\t{\n\t    if (readlen <= 0 || *p == '\\n')\n\t    {\n\t\tlistitem_T  *li;\n\t\tchar_u\t    *s\t= NULL;\n\t\tlong_u\t    len = p - start;\n\n\t\t// Finished a line.  Remove CRs before NL.\n\t\tif (readlen > 0 && !binary)\n\t\t{\n\t\t    while (len > 0 && start[len - 1] == '\\r')\n\t\t\t--len;\n\t\t    // removal may cross back to the \"prev\" string\n\t\t    if (len == 0)\n\t\t\twhile (prevlen > 0 && prev[prevlen - 1] == '\\r')\n\t\t\t    --prevlen;\n\t\t}\n\t\tif (prevlen == 0)\n\t\t    s = vim_strnsave(start, len);\n\t\telse\n\t\t{\n\t\t    // Change \"prev\" buffer to be the right size.  This way\n\t\t    // the bytes are only copied once, and very long lines are\n\t\t    // allocated only once.\n\t\t    if ((s = vim_realloc(prev, prevlen + len + 1)) != NULL)\n\t\t    {\n\t\t\tmch_memmove(s + prevlen, start, len);\n\t\t\ts[prevlen + len] = NUL;\n\t\t\tprev = NULL; // the list will own the string\n\t\t\tprevlen = prevsize = 0;\n\t\t    }\n\t\t}\n\t\tif (s == NULL)\n\t\t{\n\t\t    do_outofmem_msg((long_u) prevlen + len + 1);\n\t\t    failed = TRUE;\n\t\t    break;\n\t\t}\n\n\t\tif ((li = listitem_alloc()) == NULL)\n\t\t{\n\t\t    vim_free(s);\n\t\t    failed = TRUE;\n\t\t    break;\n\t\t}\n\t\tli->li_tv.v_type = VAR_STRING;\n\t\tli->li_tv.v_lock = 0;\n\t\tli->li_tv.vval.v_string = s;\n\t\tlist_append(rettv->vval.v_list, li);\n\n\t\tstart = p + 1; // step over newline\n\t\tif ((++cnt >= maxline && maxline >= 0) || readlen <= 0)\n\t\t    break;\n\t    }\n\t    else if (*p == NUL)\n\t\t*p = '\\n';\n\t    // Check for utf8 \"bom\"; U+FEFF is encoded as EF BB BF.  Do this\n\t    // when finding the BF and check the previous two bytes.\n\t    else if (*p == 0xbf && enc_utf8 && !binary)\n\t    {\n\t\t// Find the two bytes before the 0xbf.\tIf p is at buf, or buf\n\t\t// + 1, these may be in the \"prev\" string.\n\t\tchar_u back1 = p >= buf + 1 ? p[-1]\n\t\t\t\t     : prevlen >= 1 ? prev[prevlen - 1] : NUL;\n\t\tchar_u back2 = p >= buf + 2 ? p[-2]\n\t\t\t  : p == buf + 1 && prevlen >= 1 ? prev[prevlen - 1]\n\t\t\t  : prevlen >= 2 ? prev[prevlen - 2] : NUL;\n\n\t\tif (back2 == 0xef && back1 == 0xbb)\n\t\t{\n\t\t    char_u *dest = p - 2;\n\n\t\t    // Usually a BOM is at the beginning of a file, and so at\n\t\t    // the beginning of a line; then we can just step over it.\n\t\t    if (start == dest)\n\t\t\tstart = p + 1;\n\t\t    else\n\t\t    {\n\t\t\t// have to shuffle buf to close gap\n\t\t\tint adjust_prevlen = 0;\n\n\t\t\tif (dest < buf)\n\t\t\t{\n\t\t\t    // must be 1 or 2\n\t\t\t    adjust_prevlen = (int)(buf - dest);\n\t\t\t    dest = buf;\n\t\t\t}\n\t\t\tif (readlen > p - buf + 1)\n\t\t\t    mch_memmove(dest, p + 1, readlen - (p - buf) - 1);\n\t\t\treadlen -= 3 - adjust_prevlen;\n\t\t\tprevlen -= adjust_prevlen;\n\t\t\tp = dest - 1;\n\t\t    }\n\t\t}\n\t    }\n\t} // for\n\n\tif (failed || (cnt >= maxline && maxline >= 0) || readlen <= 0)\n\t    break;\n\tif (start < p)\n\t{\n\t    // There's part of a line in buf, store it in \"prev\".\n\t    if (p - start + prevlen >= prevsize)\n\t    {\n\t\t// need bigger \"prev\" buffer\n\t\tchar_u *newprev;\n\n\t\t// A common use case is ordinary text files and \"prev\" gets a\n\t\t// fragment of a line, so the first allocation is made\n\t\t// small, to avoid repeatedly 'allocing' large and\n\t\t// 'reallocing' small.\n\t\tif (prevsize == 0)\n\t\t    prevsize = (long)(p - start);\n\t\telse\n\t\t{\n\t\t    long grow50pc = (prevsize * 3) / 2;\n\t\t    long growmin  = (long)((p - start) * 2 + prevlen);\n\t\t    prevsize = grow50pc > growmin ? grow50pc : growmin;\n\t\t}\n\t\tnewprev = vim_realloc(prev, prevsize);\n\t\tif (newprev == NULL)\n\t\t{\n\t\t    do_outofmem_msg((long_u)prevsize);\n\t\t    failed = TRUE;\n\t\t    break;\n\t\t}\n\t\tprev = newprev;\n\t    }\n\t    // Add the line part to end of \"prev\".\n\t    mch_memmove(prev + prevlen, start, p - start);\n\t    prevlen += (long)(p - start);\n\t}\n    } // while\n\n    // For a negative line count use only the lines at the end of the file,\n    // free the rest.\n    if (!failed && maxline < 0)\n\twhile (cnt > -maxline)\n\t{\n\t    listitem_remove(rettv->vval.v_list, rettv->vval.v_list->lv_first);\n\t    --cnt;\n\t}\n\n    if (failed)\n    {\n\t// an empty list is returned on error\n\tlist_free(rettv->vval.v_list);\n\trettv_list_alloc(rettv);\n    }\n\n    vim_free(prev);\n    fclose(fd);\n}\n\n/*\n * \"readblob()\" function\n */\n    void\nf_readblob(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    read_file_or_blob(argvars, rettv, TRUE);\n}\n\n/*\n * \"readfile()\" function\n */\n    void\nf_readfile(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && (check_for_nonempty_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_number_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    read_file_or_blob(argvars, rettv, FALSE);\n}\n\n/*\n * \"resolve()\" function\n */\n    void\nf_resolve(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*p;\n#ifdef HAVE_READLINK\n    char_u\t*buf = NULL;\n#endif\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    p = tv_get_string(&argvars[0]);\n#ifdef FEAT_SHORTCUT\n    {\n\tchar_u\t*v = NULL;\n\n\tv = mch_resolve_path(p, TRUE);\n\tif (v != NULL)\n\t    rettv->vval.v_string = v;\n\telse\n\t    rettv->vval.v_string = vim_strsave(p);\n    }\n#else\n# ifdef HAVE_READLINK\n    {\n\tchar_u\t*cpy;\n\tint\tlen;\n\tchar_u\t*remain = NULL;\n\tchar_u\t*q;\n\tint\tis_relative_to_current = FALSE;\n\tint\thas_trailing_pathsep = FALSE;\n\tint\tlimit = 100;\n\n\tp = vim_strsave(p);\n\tif (p == NULL)\n\t    goto fail;\n\tif (p[0] == '.' && (vim_ispathsep(p[1])\n\t\t\t\t   || (p[1] == '.' && (vim_ispathsep(p[2])))))\n\t    is_relative_to_current = TRUE;\n\n\tlen = STRLEN(p);\n\tif (len > 1 && after_pathsep(p, p + len))\n\t{\n\t    has_trailing_pathsep = TRUE;\n\t    p[len - 1] = NUL; // the trailing slash breaks readlink()\n\t}\n\n\tq = getnextcomp(p);\n\tif (*q != NUL)\n\t{\n\t    // Separate the first path component in \"p\", and keep the\n\t    // remainder (beginning with the path separator).\n\t    remain = vim_strsave(q - 1);\n\t    q[-1] = NUL;\n\t}\n\n\tbuf = alloc(MAXPATHL + 1);\n\tif (buf == NULL)\n\t{\n\t    vim_free(p);\n\t    goto fail;\n\t}\n\n\tfor (;;)\n\t{\n\t    for (;;)\n\t    {\n\t\tlen = readlink((char *)p, (char *)buf, MAXPATHL);\n\t\tif (len <= 0)\n\t\t    break;\n\t\tbuf[len] = NUL;\n\n\t\tif (limit-- == 0)\n\t\t{\n\t\t    vim_free(p);\n\t\t    vim_free(remain);\n\t\t    emsg(_(e_too_many_symbolic_links_cycle));\n\t\t    rettv->vval.v_string = NULL;\n\t\t    goto fail;\n\t\t}\n\n\t\t// Ensure that the result will have a trailing path separator\n\t\t// if the argument has one.\n\t\tif (remain == NULL && has_trailing_pathsep)\n\t\t    add_pathsep(buf);\n\n\t\t// Separate the first path component in the link value and\n\t\t// concatenate the remainders.\n\t\tq = getnextcomp(vim_ispathsep(*buf) ? buf + 1 : buf);\n\t\tif (*q != NUL)\n\t\t{\n\t\t    if (remain == NULL)\n\t\t\tremain = vim_strsave(q - 1);\n\t\t    else\n\t\t    {\n\t\t\tcpy = concat_str(q - 1, remain);\n\t\t\tif (cpy != NULL)\n\t\t\t{\n\t\t\t    vim_free(remain);\n\t\t\t    remain = cpy;\n\t\t\t}\n\t\t    }\n\t\t    q[-1] = NUL;\n\t\t}\n\n\t\tq = gettail(p);\n\t\tif (q > p && *q == NUL)\n\t\t{\n\t\t    // Ignore trailing path separator.\n\t\t    q[-1] = NUL;\n\t\t    q = gettail(p);\n\t\t}\n\t\tif (q > p && !mch_isFullName(buf))\n\t\t{\n\t\t    // symlink is relative to directory of argument\n\t\t    cpy = alloc(STRLEN(p) + STRLEN(buf) + 1);\n\t\t    if (cpy != NULL)\n\t\t    {\n\t\t\tSTRCPY(cpy, p);\n\t\t\tSTRCPY(gettail(cpy), buf);\n\t\t\tvim_free(p);\n\t\t\tp = cpy;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    vim_free(p);\n\t\t    p = vim_strsave(buf);\n\t\t}\n\t    }\n\n\t    if (remain == NULL)\n\t\tbreak;\n\n\t    // Append the first path component of \"remain\" to \"p\".\n\t    q = getnextcomp(remain + 1);\n\t    len = q - remain - (*q != NUL);\n\t    cpy = vim_strnsave(p, STRLEN(p) + len);\n\t    if (cpy != NULL)\n\t    {\n\t\tSTRNCAT(cpy, remain, len);\n\t\tvim_free(p);\n\t\tp = cpy;\n\t    }\n\t    // Shorten \"remain\".\n\t    if (*q != NUL)\n\t\tSTRMOVE(remain, q - 1);\n\t    else\n\t\tVIM_CLEAR(remain);\n\t}\n\n\t// If the result is a relative path name, make it explicitly relative to\n\t// the current directory if and only if the argument had this form.\n\tif (!vim_ispathsep(*p))\n\t{\n\t    if (is_relative_to_current\n\t\t    && *p != NUL\n\t\t    && !(p[0] == '.'\n\t\t\t&& (p[1] == NUL\n\t\t\t    || vim_ispathsep(p[1])\n\t\t\t    || (p[1] == '.'\n\t\t\t\t&& (p[2] == NUL\n\t\t\t\t    || vim_ispathsep(p[2]))))))\n\t    {\n\t\t// Prepend \"./\".\n\t\tcpy = concat_str((char_u *)\"./\", p);\n\t\tif (cpy != NULL)\n\t\t{\n\t\t    vim_free(p);\n\t\t    p = cpy;\n\t\t}\n\t    }\n\t    else if (!is_relative_to_current)\n\t    {\n\t\t// Strip leading \"./\".\n\t\tq = p;\n\t\twhile (q[0] == '.' && vim_ispathsep(q[1]))\n\t\t    q += 2;\n\t\tif (q > p)\n\t\t    STRMOVE(p, p + 2);\n\t    }\n\t}\n\n\t// Ensure that the result will have no trailing path separator\n\t// if the argument had none.  But keep \"/\" or \"//\".\n\tif (!has_trailing_pathsep)\n\t{\n\t    q = p + STRLEN(p);\n\t    if (after_pathsep(p, q))\n\t\t*gettail_sep(p) = NUL;\n\t}\n\n\trettv->vval.v_string = p;\n    }\n# else\n    rettv->vval.v_string = vim_strsave(p);\n# endif\n#endif\n\n    simplify_filename(rettv->vval.v_string);\n\n#ifdef HAVE_READLINK\nfail:\n    vim_free(buf);\n#endif\n    rettv->v_type = VAR_STRING;\n}\n\n/*\n * \"tempname()\" function\n */\n    void\nf_tempname(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    static int\tx = 'A';\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = vim_tempname(x, FALSE);\n\n    // Advance 'x' to use A-Z and 0-9, so that there are at least 34 different\n    // names.  Skip 'I' and 'O', they are used for shell redirection.\n    do\n    {\n\tif (x == 'Z')\n\t    x = '0';\n\telse if (x == '9')\n\t    x = 'A';\n\telse\n\t    ++x;\n    } while (x == 'I' || x == 'O');\n}\n\n/*\n * \"writefile()\" function\n */\n    void\nf_writefile(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tbinary = FALSE;\n    int\t\tappend = FALSE;\n#ifdef HAVE_FSYNC\n    int\t\tdo_fsync = p_fs;\n#endif\n    char_u\t*fname;\n    FILE\t*fd;\n    int\t\tret = 0;\n    listitem_T\t*li;\n    list_T\t*list = NULL;\n    blob_T\t*blob = NULL;\n\n    rettv->vval.v_number = -1;\n    if (check_secure())\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_list_or_blob_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 2) == FAIL))\n\treturn;\n\n    if (argvars[0].v_type == VAR_LIST)\n    {\n\tlist = argvars[0].vval.v_list;\n\tif (list == NULL)\n\t    return;\n\tCHECK_LIST_MATERIALIZE(list);\n\tFOR_ALL_LIST_ITEMS(list, li)\n\t    if (tv_get_string_chk(&li->li_tv) == NULL)\n\t\treturn;\n    }\n    else if (argvars[0].v_type == VAR_BLOB)\n    {\n\tblob = argvars[0].vval.v_blob;\n\tif (blob == NULL)\n\t    return;\n    }\n    else\n    {\n\tsemsg(_(e_invalid_argument_str),\n\t\t_(\"writefile() first argument must be a List or a Blob\"));\n\treturn;\n    }\n\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tchar_u *arg2 = tv_get_string_chk(&argvars[2]);\n\n\tif (arg2 == NULL)\n\t    return;\n\tif (vim_strchr(arg2, 'b') != NULL)\n\t    binary = TRUE;\n\tif (vim_strchr(arg2, 'a') != NULL)\n\t    append = TRUE;\n#ifdef HAVE_FSYNC\n\tif (vim_strchr(arg2, 's') != NULL)\n\t    do_fsync = TRUE;\n\telse if (vim_strchr(arg2, 'S') != NULL)\n\t    do_fsync = FALSE;\n#endif\n    }\n\n    fname = tv_get_string_chk(&argvars[1]);\n    if (fname == NULL)\n\treturn;\n\n    // Always open the file in binary mode, library functions have a mind of\n    // their own about CR-LF conversion.\n    if (*fname == NUL || (fd = mch_fopen((char *)fname,\n\t\t\t\t      append ? APPENDBIN : WRITEBIN)) == NULL)\n    {\n\tsemsg(_(e_cant_create_file_str), *fname == NUL ? (char_u *)_(\"<empty>\") : fname);\n\tret = -1;\n    }\n    else if (blob)\n    {\n\tif (write_blob(fd, blob) == FAIL)\n\t    ret = -1;\n#ifdef HAVE_FSYNC\n\telse if (do_fsync)\n\t    // Ignore the error, the user wouldn't know what to do about it.\n\t    // May happen for a device.\n\t    vim_ignored = vim_fsync(fileno(fd));\n#endif\n\tfclose(fd);\n    }\n    else\n    {\n\tif (write_list(fd, list, binary) == FAIL)\n\t    ret = -1;\n#ifdef HAVE_FSYNC\n\telse if (do_fsync)\n\t    // Ignore the error, the user wouldn't know what to do about it.\n\t    // May happen for a device.\n\t    vim_ignored = vim_fsync(fileno(fd));\n#endif\n\tfclose(fd);\n    }\n\n    rettv->vval.v_number = ret;\n}\n\n#endif // FEAT_EVAL\n\n#if defined(FEAT_BROWSE) || defined(PROTO)\n/*\n * Generic browse function.  Calls gui_mch_browse() when possible.\n * Later this may pop-up a non-GUI file selector (external command?).\n */\n    char_u *\ndo_browse(\n    int\t\tflags,\t\t// BROWSE_SAVE and BROWSE_DIR\n    char_u\t*title,\t\t// title for the window\n    char_u\t*dflt,\t\t// default file name (may include directory)\n    char_u\t*ext,\t\t// extension added\n    char_u\t*initdir,\t// initial directory, NULL for current dir or\n\t\t\t\t// when using path from \"dflt\"\n    char_u\t*filter,\t// file name filter\n    buf_T\t*buf)\t\t// buffer to read/write for\n{\n    char_u\t\t*fname;\n    static char_u\t*last_dir = NULL;    // last used directory\n    char_u\t\t*tofree = NULL;\n    int\t\t\tsave_cmod_flags = cmdmod.cmod_flags;\n\n    // Must turn off browse to avoid that autocommands will get the\n    // flag too!\n    cmdmod.cmod_flags &= ~CMOD_BROWSE;\n\n    if (title == NULL || *title == NUL)\n    {\n\tif (flags & BROWSE_DIR)\n\t    title = (char_u *)_(\"Select Directory dialog\");\n\telse if (flags & BROWSE_SAVE)\n\t    title = (char_u *)_(\"Save File dialog\");\n\telse\n\t    title = (char_u *)_(\"Open File dialog\");\n    }\n\n    // When no directory specified, use default file name, default dir, buffer\n    // dir, last dir or current dir\n    if ((initdir == NULL || *initdir == NUL) && dflt != NULL && *dflt != NUL)\n    {\n\tif (mch_isdir(dflt))\t\t// default file name is a directory\n\t{\n\t    initdir = dflt;\n\t    dflt = NULL;\n\t}\n\telse if (gettail(dflt) != dflt)\t// default file name includes a path\n\t{\n\t    tofree = vim_strsave(dflt);\n\t    if (tofree != NULL)\n\t    {\n\t\tinitdir = tofree;\n\t\t*gettail(initdir) = NUL;\n\t\tdflt = gettail(dflt);\n\t    }\n\t}\n    }\n\n    if (initdir == NULL || *initdir == NUL)\n    {\n\t// When 'browsedir' is a directory, use it\n\tif (STRCMP(p_bsdir, \"last\") != 0\n\t\t&& STRCMP(p_bsdir, \"buffer\") != 0\n\t\t&& STRCMP(p_bsdir, \"current\") != 0\n\t\t&& mch_isdir(p_bsdir))\n\t    initdir = p_bsdir;\n\t// When saving or 'browsedir' is \"buffer\", use buffer fname\n\telse if (((flags & BROWSE_SAVE) || *p_bsdir == 'b')\n\t\t&& buf != NULL && buf->b_ffname != NULL)\n\t{\n\t    if (dflt == NULL || *dflt == NUL)\n\t\tdflt = gettail(curbuf->b_ffname);\n\t    tofree = vim_strsave(curbuf->b_ffname);\n\t    if (tofree != NULL)\n\t    {\n\t\tinitdir = tofree;\n\t\t*gettail(initdir) = NUL;\n\t    }\n\t}\n\t// When 'browsedir' is \"last\", use dir from last browse\n\telse if (*p_bsdir == 'l')\n\t    initdir = last_dir;\n\t// When 'browsedir is \"current\", use current directory.  This is the\n\t// default already, leave initdir empty.\n    }\n\n# ifdef FEAT_GUI\n    if (gui.in_use)\t\t// when this changes, also adjust f_has()!\n    {\n\tif (filter == NULL\n#  ifdef FEAT_EVAL\n\t\t&& (filter = get_var_value((char_u *)\"b:browsefilter\")) == NULL\n\t\t&& (filter = get_var_value((char_u *)\"g:browsefilter\")) == NULL\n#  endif\n\t)\n\t    filter = BROWSE_FILTER_DEFAULT;\n\tif (flags & BROWSE_DIR)\n\t{\n#  if defined(FEAT_GUI_GTK) || defined(MSWIN)\n\t    // For systems that have a directory dialog.\n\t    fname = gui_mch_browsedir(title, initdir);\n#  else\n\t    // Generic solution for selecting a directory: select a file and\n\t    // remove the file name.\n\t    fname = gui_mch_browse(0, title, dflt, ext, initdir, (char_u *)\"\");\n#  endif\n#  if !defined(FEAT_GUI_GTK)\n\t    // Win32 adds a dummy file name, others return an arbitrary file\n\t    // name.  GTK+ 2 returns only the directory,\n\t    if (fname != NULL && *fname != NUL && !mch_isdir(fname))\n\t    {\n\t\t// Remove the file name.\n\t\tchar_u\t    *tail = gettail_sep(fname);\n\n\t\tif (tail == fname)\n\t\t    *tail++ = '.';\t// use current dir\n\t\t*tail = NUL;\n\t    }\n#  endif\n\t}\n\telse\n\t    fname = gui_mch_browse(flags & BROWSE_SAVE,\n\t\t\t       title, dflt, ext, initdir, (char_u *)_(filter));\n\n\t// We hang around in the dialog for a while, the user might do some\n\t// things to our files.  The Win32 dialog allows deleting or renaming\n\t// a file, check timestamps.\n\tneed_check_timestamps = TRUE;\n\tdid_check_timestamps = FALSE;\n    }\n    else\n# endif\n    {\n\t// TODO: non-GUI file selector here\n\temsg(_(e_sorry_no_file_browser_in_console_mode));\n\tfname = NULL;\n    }\n\n    // keep the directory for next time\n    if (fname != NULL)\n    {\n\tvim_free(last_dir);\n\tlast_dir = vim_strsave(fname);\n\tif (last_dir != NULL && !(flags & BROWSE_DIR))\n\t{\n\t    *gettail(last_dir) = NUL;\n\t    if (*last_dir == NUL)\n\t    {\n\t\t// filename only returned, must be in current dir\n\t\tvim_free(last_dir);\n\t\tlast_dir = alloc(MAXPATHL);\n\t\tif (last_dir != NULL)\n\t\t    mch_dirname(last_dir, MAXPATHL);\n\t    }\n\t}\n    }\n\n    vim_free(tofree);\n    cmdmod.cmod_flags = save_cmod_flags;\n\n    return fname;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * \"browse(save, title, initdir, default)\" function\n */\n    void\nf_browse(typval_T *argvars UNUSED, typval_T *rettv)\n{\n# ifdef FEAT_BROWSE\n    int\t\tsave;\n    char_u\t*title;\n    char_u\t*initdir;\n    char_u\t*defname;\n    char_u\tbuf[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    int\t\terror = FALSE;\n\n    if (in_vim9script()\n\t    && (check_for_bool_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_string_arg(argvars, 2) == FAIL\n\t\t|| check_for_string_arg(argvars, 3) == FAIL))\n\treturn;\n\n    save = (int)tv_get_number_chk(&argvars[0], &error);\n    title = tv_get_string_chk(&argvars[1]);\n    initdir = tv_get_string_buf_chk(&argvars[2], buf);\n    defname = tv_get_string_buf_chk(&argvars[3], buf2);\n\n    if (error || title == NULL || initdir == NULL || defname == NULL)\n\trettv->vval.v_string = NULL;\n    else\n\trettv->vval.v_string =\n\t\t do_browse(save ? BROWSE_SAVE : 0,\n\t\t\t\t title, defname, NULL, initdir, NULL, curbuf);\n# else\n    rettv->vval.v_string = NULL;\n# endif\n    rettv->v_type = VAR_STRING;\n}\n\n/*\n * \"browsedir(title, initdir)\" function\n */\n    void\nf_browsedir(typval_T *argvars UNUSED, typval_T *rettv)\n{\n# ifdef FEAT_BROWSE\n    char_u\t*title;\n    char_u\t*initdir;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    title = tv_get_string_chk(&argvars[0]);\n    initdir = tv_get_string_buf_chk(&argvars[1], buf);\n\n    if (title == NULL || initdir == NULL)\n\trettv->vval.v_string = NULL;\n    else\n\trettv->vval.v_string = do_browse(BROWSE_DIR,\n\t\t\t\t    title, NULL, NULL, initdir, NULL, curbuf);\n# else\n    rettv->vval.v_string = NULL;\n# endif\n    rettv->v_type = VAR_STRING;\n}\n\n#endif // FEAT_EVAL\n\n/*\n * Replace home directory by \"~\" in each space or comma separated file name in\n * 'src'.\n * If anything fails (except when out of space) dst equals src.\n */\n    void\nhome_replace(\n    buf_T\t*buf,\t// when not NULL, check for help files\n    char_u\t*src,\t// input file name\n    char_u\t*dst,\t// where to put the result\n    int\t\tdstlen,\t// maximum length of the result\n    int\t\tone)\t// if TRUE, only replace one file name, include\n\t\t\t// spaces and commas in the file name.\n{\n    size_t\tdirlen = 0, envlen = 0;\n    size_t\tlen;\n    char_u\t*homedir_env, *homedir_env_orig;\n    char_u\t*p;\n\n    if (src == NULL)\n    {\n\t*dst = NUL;\n\treturn;\n    }\n\n    /*\n     * If the file is a help file, remove the path completely.\n     */\n    if (buf != NULL && buf->b_help)\n    {\n\tvim_snprintf((char *)dst, dstlen, \"%s\", gettail(src));\n\treturn;\n    }\n\n    /*\n     * We check both the value of the $HOME environment variable and the\n     * \"real\" home directory.\n     */\n    if (homedir != NULL)\n\tdirlen = STRLEN(homedir);\n\n#ifdef VMS\n    homedir_env_orig = homedir_env = mch_getenv((char_u *)\"SYS$LOGIN\");\n#else\n    homedir_env_orig = homedir_env = mch_getenv((char_u *)\"HOME\");\n#endif\n#ifdef MSWIN\n    if (homedir_env == NULL)\n\thomedir_env_orig = homedir_env = mch_getenv((char_u *)\"USERPROFILE\");\n#endif\n    // Empty is the same as not set.\n    if (homedir_env != NULL && *homedir_env == NUL)\n\thomedir_env = NULL;\n\n    if (homedir_env != NULL && *homedir_env == '~')\n    {\n\tint\tusedlen = 0;\n\tint\tflen;\n\tchar_u\t*fbuf = NULL;\n\n\tflen = (int)STRLEN(homedir_env);\n\t(void)modify_fname((char_u *)\":p\", FALSE, &usedlen,\n\t\t\t\t\t\t  &homedir_env, &fbuf, &flen);\n\tflen = (int)STRLEN(homedir_env);\n\tif (flen > 0 && vim_ispathsep(homedir_env[flen - 1]))\n\t    // Remove the trailing / that is added to a directory.\n\t    homedir_env[flen - 1] = NUL;\n    }\n\n    if (homedir_env != NULL)\n\tenvlen = STRLEN(homedir_env);\n\n    if (!one)\n\tsrc = skipwhite(src);\n    while (*src && dstlen > 0)\n    {\n\t/*\n\t * Here we are at the beginning of a file name.\n\t * First, check to see if the beginning of the file name matches\n\t * $HOME or the \"real\" home directory. Check that there is a '/'\n\t * after the match (so that if e.g. the file is \"/home/pieter/bla\",\n\t * and the home directory is \"/home/piet\", the file does not end up\n\t * as \"~er/bla\" (which would seem to indicate the file \"bla\" in user\n\t * er's home directory)).\n\t */\n\tp = homedir;\n\tlen = dirlen;\n\tfor (;;)\n\t{\n\t    if (   len\n\t\t&& fnamencmp(src, p, len) == 0\n\t\t&& (vim_ispathsep(src[len])\n\t\t    || (!one && (src[len] == ',' || src[len] == ' '))\n\t\t    || src[len] == NUL))\n\t    {\n\t\tsrc += len;\n\t\tif (--dstlen > 0)\n\t\t    *dst++ = '~';\n\n\t\t// Do not add directory separator into dst, because dst is\n\t\t// expected to just return the directory name without the\n\t\t// directory separator '/'.\n\t\tbreak;\n\t    }\n\t    if (p == homedir_env)\n\t\tbreak;\n\t    p = homedir_env;\n\t    len = envlen;\n\t}\n\n\t// if (!one) skip to separator: space or comma\n\twhile (*src && (one || (*src != ',' && *src != ' ')) && --dstlen > 0)\n\t    *dst++ = *src++;\n\t// skip separator\n\twhile ((*src == ' ' || *src == ',') && --dstlen > 0)\n\t    *dst++ = *src++;\n    }\n    // if (dstlen == 0) out of space, what to do???\n\n    *dst = NUL;\n\n    if (homedir_env != homedir_env_orig)\n\tvim_free(homedir_env);\n}\n\n/*\n * Like home_replace, store the replaced string in allocated memory.\n * When something fails, NULL is returned.\n */\n    char_u  *\nhome_replace_save(\n    buf_T\t*buf,\t// when not NULL, check for help files\n    char_u\t*src)\t// input file name\n{\n    char_u\t*dst;\n    unsigned\tlen;\n\n    len = 3;\t\t\t// space for \"~/\" and trailing NUL\n    if (src != NULL)\t\t// just in case\n\tlen += (unsigned)STRLEN(src);\n    dst = alloc(len);\n    if (dst != NULL)\n\thome_replace(buf, src, dst, len, TRUE);\n    return dst;\n}\n\n/*\n * Compare two file names and return:\n * FPC_SAME   if they both exist and are the same file.\n * FPC_SAMEX  if they both don't exist and have the same file name.\n * FPC_DIFF   if they both exist and are different files.\n * FPC_NOTX   if they both don't exist.\n * FPC_DIFFX  if one of them doesn't exist.\n * For the first name environment variables are expanded if \"expandenv\" is\n * TRUE.\n */\n    int\nfullpathcmp(\n    char_u *s1,\n    char_u *s2,\n    int\t    checkname,\t\t// when both don't exist, check file names\n    int\t    expandenv)\n{\n#ifdef UNIX\n    char_u\t    exp1[MAXPATHL];\n    char_u\t    full1[MAXPATHL];\n    char_u\t    full2[MAXPATHL];\n    stat_T\t    st1, st2;\n    int\t\t    r1, r2;\n\n    if (expandenv)\n\texpand_env(s1, exp1, MAXPATHL);\n    else\n\tvim_strncpy(exp1, s1, MAXPATHL - 1);\n    r1 = mch_stat((char *)exp1, &st1);\n    r2 = mch_stat((char *)s2, &st2);\n    if (r1 != 0 && r2 != 0)\n    {\n\t// if mch_stat() doesn't work, may compare the names\n\tif (checkname)\n\t{\n\t    if (fnamecmp(exp1, s2) == 0)\n\t\treturn FPC_SAMEX;\n\t    r1 = vim_FullName(exp1, full1, MAXPATHL, FALSE);\n\t    r2 = vim_FullName(s2, full2, MAXPATHL, FALSE);\n\t    if (r1 == OK && r2 == OK && fnamecmp(full1, full2) == 0)\n\t\treturn FPC_SAMEX;\n\t}\n\treturn FPC_NOTX;\n    }\n    if (r1 != 0 || r2 != 0)\n\treturn FPC_DIFFX;\n    if (st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino)\n\treturn FPC_SAME;\n    return FPC_DIFF;\n#else\n    char_u  *exp1;\t\t// expanded s1\n    char_u  *full1;\t\t// full path of s1\n    char_u  *full2;\t\t// full path of s2\n    int\t    retval = FPC_DIFF;\n    int\t    r1, r2;\n\n    // allocate one buffer to store three paths (alloc()/free() is slow!)\n    if ((exp1 = alloc(MAXPATHL * 3)) != NULL)\n    {\n\tfull1 = exp1 + MAXPATHL;\n\tfull2 = full1 + MAXPATHL;\n\n\tif (expandenv)\n\t    expand_env(s1, exp1, MAXPATHL);\n\telse\n\t    vim_strncpy(exp1, s1, MAXPATHL - 1);\n\tr1 = vim_FullName(exp1, full1, MAXPATHL, FALSE);\n\tr2 = vim_FullName(s2, full2, MAXPATHL, FALSE);\n\n\t// If vim_FullName() fails, the file probably doesn't exist.\n\tif (r1 != OK && r2 != OK)\n\t{\n\t    if (checkname && fnamecmp(exp1, s2) == 0)\n\t\tretval = FPC_SAMEX;\n\t    else\n\t\tretval = FPC_NOTX;\n\t}\n\telse if (r1 != OK || r2 != OK)\n\t    retval = FPC_DIFFX;\n\telse if (fnamecmp(full1, full2))\n\t    retval = FPC_DIFF;\n\telse\n\t    retval = FPC_SAME;\n\tvim_free(exp1);\n    }\n    return retval;\n#endif\n}\n\n/*\n * Get the tail of a path: the file name.\n * When the path ends in a path separator the tail is the NUL after it.\n * Fail safe: never returns NULL.\n */\n    char_u *\ngettail(char_u *fname)\n{\n    char_u  *p1, *p2;\n\n    if (fname == NULL)\n\treturn (char_u *)\"\";\n    for (p1 = p2 = get_past_head(fname); *p2; )\t// find last part of path\n    {\n\tif (vim_ispathsep_nocolon(*p2))\n\t    p1 = p2 + 1;\n\tMB_PTR_ADV(p2);\n    }\n    return p1;\n}\n\n/*\n * Get pointer to tail of \"fname\", including path separators.  Putting a NUL\n * here leaves the directory name.  Takes care of \"c:/\" and \"//\".\n * Always returns a valid pointer.\n */\n    char_u *\ngettail_sep(char_u *fname)\n{\n    char_u\t*p;\n    char_u\t*t;\n\n    p = get_past_head(fname);\t// don't remove the '/' from \"c:/file\"\n    t = gettail(fname);\n    while (t > p && after_pathsep(fname, t))\n\t--t;\n#ifdef VMS\n    // path separator is part of the path\n    ++t;\n#endif\n    return t;\n}\n\n/*\n * get the next path component (just after the next path separator).\n */\n    char_u *\ngetnextcomp(char_u *fname)\n{\n    while (*fname && !vim_ispathsep(*fname))\n\tMB_PTR_ADV(fname);\n    if (*fname)\n\t++fname;\n    return fname;\n}\n\n/*\n * Get a pointer to one character past the head of a path name.\n * Unix: after \"/\"; DOS: after \"c:\\\"; Amiga: after \"disk:/\"; Mac: no head.\n * If there is no head, path is returned.\n */\n    char_u *\nget_past_head(char_u *path)\n{\n    char_u  *retval;\n\n#if defined(MSWIN)\n    // may skip \"c:\"\n    if (isalpha(path[0]) && path[1] == ':')\n\tretval = path + 2;\n    else\n\tretval = path;\n#else\n# if defined(AMIGA)\n    // may skip \"label:\"\n    retval = vim_strchr(path, ':');\n    if (retval == NULL)\n\tretval = path;\n# else\t// Unix\n    retval = path;\n# endif\n#endif\n\n    while (vim_ispathsep(*retval))\n\t++retval;\n\n    return retval;\n}\n\n/*\n * Return TRUE if 'c' is a path separator.\n * Note that for MS-Windows this includes the colon.\n */\n    int\nvim_ispathsep(int c)\n{\n#ifdef UNIX\n    return (c == '/');\t    // UNIX has ':' inside file names\n#else\n# ifdef BACKSLASH_IN_FILENAME\n    return (c == ':' || c == '/' || c == '\\\\');\n# else\n#  ifdef VMS\n    // server\"user passwd\"::device:[full.path.name]fname.extension;version\"\n    return (c == ':' || c == '[' || c == ']' || c == '/'\n\t    || c == '<' || c == '>' || c == '\"' );\n#  else\n    return (c == ':' || c == '/');\n#  endif // VMS\n# endif\n#endif\n}\n\n/*\n * Like vim_ispathsep(c), but exclude the colon for MS-Windows.\n */\n    int\nvim_ispathsep_nocolon(int c)\n{\n    return vim_ispathsep(c)\n#ifdef BACKSLASH_IN_FILENAME\n\t&& c != ':'\n#endif\n\t;\n}\n\n/*\n * Return TRUE if the directory of \"fname\" exists, FALSE otherwise.\n * Also returns TRUE if there is no directory name.\n * \"fname\" must be writable!.\n */\n    int\ndir_of_file_exists(char_u *fname)\n{\n    char_u\t*p;\n    int\t\tc;\n    int\t\tretval;\n\n    p = gettail_sep(fname);\n    if (p == fname)\n\treturn TRUE;\n    c = *p;\n    *p = NUL;\n    retval = mch_isdir(fname);\n    *p = c;\n    return retval;\n}\n\n/*\n * Versions of fnamecmp() and fnamencmp() that handle '/' and '\\' equally\n * and deal with 'fileignorecase'.\n */\n    int\nvim_fnamecmp(char_u *x, char_u *y)\n{\n#ifdef BACKSLASH_IN_FILENAME\n    return vim_fnamencmp(x, y, MAXPATHL);\n#else\n    if (p_fic)\n\treturn MB_STRICMP(x, y);\n    return STRCMP(x, y);\n#endif\n}\n\n    int\nvim_fnamencmp(char_u *x, char_u *y, size_t len)\n{\n#ifdef BACKSLASH_IN_FILENAME\n    char_u\t*px = x;\n    char_u\t*py = y;\n    int\t\tcx = NUL;\n    int\t\tcy = NUL;\n\n    while (len > 0)\n    {\n\tcx = PTR2CHAR(px);\n\tcy = PTR2CHAR(py);\n\tif (cx == NUL || cy == NUL\n\t    || ((p_fic ? MB_TOLOWER(cx) != MB_TOLOWER(cy) : cx != cy)\n\t\t&& !(cx == '/' && cy == '\\\\')\n\t\t&& !(cx == '\\\\' && cy == '/')))\n\t    break;\n\tlen -= mb_ptr2len(px);\n\tpx += mb_ptr2len(px);\n\tpy += mb_ptr2len(py);\n    }\n    if (len == 0)\n\treturn 0;\n    return (cx - cy);\n#else\n    if (p_fic)\n\treturn MB_STRNICMP(x, y, len);\n    return STRNCMP(x, y, len);\n#endif\n}\n\n/*\n * Concatenate file names fname1 and fname2 into allocated memory.\n * Only add a '/' or '\\\\' when 'sep' is TRUE and it is necessary.\n */\n    char_u  *\nconcat_fnames(char_u *fname1, char_u *fname2, int sep)\n{\n    char_u  *dest;\n\n    dest = alloc(STRLEN(fname1) + STRLEN(fname2) + 3);\n    if (dest != NULL)\n    {\n\tSTRCPY(dest, fname1);\n\tif (sep)\n\t    add_pathsep(dest);\n\tSTRCAT(dest, fname2);\n    }\n    return dest;\n}\n\n/*\n * Add a path separator to a file name, unless it already ends in a path\n * separator.\n */\n    void\nadd_pathsep(char_u *p)\n{\n    if (*p != NUL && !after_pathsep(p, p + STRLEN(p)))\n\tSTRCAT(p, PATHSEPSTR);\n}\n\n/*\n * FullName_save - Make an allocated copy of a full file name.\n * Returns NULL when out of memory.\n */\n    char_u  *\nFullName_save(\n    char_u\t*fname,\n    int\t\tforce)\t\t// force expansion, even when it already looks\n\t\t\t\t// like a full path name\n{\n    char_u\t*buf;\n    char_u\t*new_fname = NULL;\n\n    if (fname == NULL)\n\treturn NULL;\n\n    buf = alloc(MAXPATHL);\n    if (buf != NULL)\n    {\n\tif (vim_FullName(fname, buf, MAXPATHL, force) != FAIL)\n\t    new_fname = vim_strsave(buf);\n\telse\n\t    new_fname = vim_strsave(fname);\n\tvim_free(buf);\n    }\n    return new_fname;\n}\n\n/*\n * return TRUE if \"fname\" exists.\n */\n    int\nvim_fexists(char_u *fname)\n{\n    stat_T st;\n\n    if (mch_stat((char *)fname, &st))\n\treturn FALSE;\n    return TRUE;\n}\n\n/*\n * Invoke expand_wildcards() for one pattern.\n * Expand items like \"%:h\" before the expansion.\n * Returns OK or FAIL.\n */\n    int\nexpand_wildcards_eval(\n    char_u\t **pat,\t\t// pointer to input pattern\n    int\t\t  *num_file,\t// resulting number of files\n    char_u\t***file,\t// array of resulting files\n    int\t\t   flags)\t// EW_DIR, etc.\n{\n    int\t\tret = FAIL;\n    char_u\t*eval_pat = NULL;\n    char_u\t*exp_pat = *pat;\n    char      *ignored_msg;\n    int\t\tusedlen;\n\n    if (*exp_pat == '%' || *exp_pat == '#' || *exp_pat == '<')\n    {\n\t++emsg_off;\n\teval_pat = eval_vars(exp_pat, exp_pat, &usedlen,\n\t\t\t\t\t\t    NULL, &ignored_msg, NULL);\n\t--emsg_off;\n\tif (eval_pat != NULL)\n\t    exp_pat = concat_str(eval_pat, exp_pat + usedlen);\n    }\n\n    if (exp_pat != NULL)\n\tret = expand_wildcards(1, &exp_pat, num_file, file, flags);\n\n    if (eval_pat != NULL)\n    {\n\tvim_free(exp_pat);\n\tvim_free(eval_pat);\n    }\n\n    return ret;\n}\n\n/*\n * Expand wildcards.  Calls gen_expand_wildcards() and removes files matching\n * 'wildignore'.\n * Returns OK or FAIL.  When FAIL then \"num_files\" won't be set.\n */\n    int\nexpand_wildcards(\n    int\t\t   num_pat,\t// number of input patterns\n    char_u\t **pat,\t\t// array of input patterns\n    int\t\t  *num_files,\t// resulting number of files\n    char_u\t***files,\t// array of resulting files\n    int\t\t   flags)\t// EW_DIR, etc.\n{\n    int\t\tretval;\n    int\t\ti, j;\n    char_u\t*p;\n    int\t\tnon_suf_match;\t// number without matching suffix\n\n    retval = gen_expand_wildcards(num_pat, pat, num_files, files, flags);\n\n    // When keeping all matches, return here\n    if ((flags & EW_KEEPALL) || retval == FAIL)\n\treturn retval;\n\n#ifdef FEAT_WILDIGN\n    /*\n     * Remove names that match 'wildignore'.\n     */\n    if (*p_wig)\n    {\n\tchar_u\t*ffname;\n\n\t// check all files in (*files)[]\n\tfor (i = 0; i < *num_files; ++i)\n\t{\n\t    ffname = FullName_save((*files)[i], FALSE);\n\t    if (ffname == NULL)\t\t// out of memory\n\t\tbreak;\n# ifdef VMS\n\t    vms_remove_version(ffname);\n# endif\n\t    if (match_file_list(p_wig, (*files)[i], ffname))\n\t    {\n\t\t// remove this matching file from the list\n\t\tvim_free((*files)[i]);\n\t\tfor (j = i; j + 1 < *num_files; ++j)\n\t\t    (*files)[j] = (*files)[j + 1];\n\t\t--*num_files;\n\t\t--i;\n\t    }\n\t    vim_free(ffname);\n\t}\n\n\t// If the number of matches is now zero, we fail.\n\tif (*num_files == 0)\n\t{\n\t    VIM_CLEAR(*files);\n\t    return FAIL;\n\t}\n    }\n#endif\n\n    /*\n     * Move the names where 'suffixes' match to the end.\n     */\n    if (*num_files > 1)\n    {\n\tnon_suf_match = 0;\n\tfor (i = 0; i < *num_files; ++i)\n\t{\n\t    if (!match_suffix((*files)[i]))\n\t    {\n\t\t/*\n\t\t * Move the name without matching suffix to the front\n\t\t * of the list.\n\t\t */\n\t\tp = (*files)[i];\n\t\tfor (j = i; j > non_suf_match; --j)\n\t\t    (*files)[j] = (*files)[j - 1];\n\t\t(*files)[non_suf_match++] = p;\n\t    }\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if \"fname\" matches with an entry in 'suffixes'.\n */\n    int\nmatch_suffix(char_u *fname)\n{\n    int\t\tfnamelen, setsuflen;\n    char_u\t*setsuf;\n#define MAXSUFLEN 30\t    // maximum length of a file suffix\n    char_u\tsuf_buf[MAXSUFLEN];\n\n    fnamelen = (int)STRLEN(fname);\n    setsuflen = 0;\n    for (setsuf = p_su; *setsuf; )\n    {\n\tsetsuflen = copy_option_part(&setsuf, suf_buf, MAXSUFLEN, \".,\");\n\tif (setsuflen == 0)\n\t{\n\t    char_u *tail = gettail(fname);\n\n\t    // empty entry: match name without a '.'\n\t    if (vim_strchr(tail, '.') == NULL)\n\t    {\n\t\tsetsuflen = 1;\n\t\tbreak;\n\t    }\n\t}\n\telse\n\t{\n\t    if (fnamelen >= setsuflen\n\t\t    && fnamencmp(suf_buf, fname + fnamelen - setsuflen,\n\t\t\t\t\t\t  (size_t)setsuflen) == 0)\n\t\tbreak;\n\t    setsuflen = 0;\n\t}\n    }\n    return (setsuflen != 0);\n}\n\n#ifdef VIM_BACKTICK\n\n/*\n * Return TRUE if we can expand this backtick thing here.\n */\n    static int\nvim_backtick(char_u *p)\n{\n    return (*p == '`' && *(p + 1) != NUL && *(p + STRLEN(p) - 1) == '`');\n}\n\n/*\n * Expand an item in `backticks` by executing it as a command.\n * Currently only works when pat[] starts and ends with a `.\n * Returns number of file names found, -1 if an error is encountered.\n */\n    static int\nexpand_backtick(\n    garray_T\t*gap,\n    char_u\t*pat,\n    int\t\tflags)\t// EW_* flags\n{\n    char_u\t*p;\n    char_u\t*cmd;\n    char_u\t*buffer;\n    int\t\tcnt = 0;\n    int\t\ti;\n\n    // Create the command: lop off the backticks.\n    cmd = vim_strnsave(pat + 1, STRLEN(pat) - 2);\n    if (cmd == NULL)\n\treturn -1;\n\n#ifdef FEAT_EVAL\n    if (*cmd == '=')\t    // `={expr}`: Expand expression\n\tbuffer = eval_to_string(cmd + 1, TRUE);\n    else\n#endif\n\tbuffer = get_cmd_output(cmd, NULL,\n\t\t\t\t(flags & EW_SILENT) ? SHELL_SILENT : 0, NULL);\n    vim_free(cmd);\n    if (buffer == NULL)\n\treturn -1;\n\n    cmd = buffer;\n    while (*cmd != NUL)\n    {\n\tcmd = skipwhite(cmd);\t\t// skip over white space\n\tp = cmd;\n\twhile (*p != NUL && *p != '\\r' && *p != '\\n') // skip over entry\n\t    ++p;\n\t// add an entry if it is not empty\n\tif (p > cmd)\n\t{\n\t    i = *p;\n\t    *p = NUL;\n\t    addfile(gap, cmd, flags);\n\t    *p = i;\n\t    ++cnt;\n\t}\n\tcmd = p;\n\twhile (*cmd != NUL && (*cmd == '\\r' || *cmd == '\\n'))\n\t    ++cmd;\n    }\n\n    vim_free(buffer);\n    return cnt;\n}\n#endif // VIM_BACKTICK\n\n#if defined(MSWIN)\n/*\n * File name expansion code for MS-DOS, Win16 and Win32.  It's here because\n * it's shared between these systems.\n */\n\n/*\n * comparison function for qsort in dos_expandpath()\n */\n    static int\npstrcmp(const void *a, const void *b)\n{\n    return (pathcmp(*(char **)a, *(char **)b, -1));\n}\n\n/*\n * Recursively expand one path component into all matching files and/or\n * directories.  Adds matches to \"gap\".  Handles \"*\", \"?\", \"[a-z]\", \"**\", etc.\n * Return the number of matches found.\n * \"path\" has backslashes before chars that are not to be expanded, starting\n * at \"path[wildoff]\".\n * Return the number of matches found.\n * NOTE: much of this is identical to unix_expandpath(), keep in sync!\n */\n    static int\ndos_expandpath(\n    garray_T\t*gap,\n    char_u\t*path,\n    int\t\twildoff,\n    int\t\tflags,\t\t// EW_* flags\n    int\t\tdidstar)\t// expanded \"**\" once already\n{\n    char_u\t*buf;\n    char_u\t*path_end;\n    char_u\t*p, *s, *e;\n    int\t\tstart_len = gap->ga_len;\n    char_u\t*pat;\n    regmatch_T\tregmatch;\n    int\t\tstarts_with_dot;\n    int\t\tmatches;\n    int\t\tlen;\n    int\t\tstarstar = FALSE;\n    static int\tstardepth = 0;\t    // depth for \"**\" expansion\n    HANDLE\t\thFind = INVALID_HANDLE_VALUE;\n    WIN32_FIND_DATAW    wfb;\n    WCHAR\t\t*wn = NULL;\t// UCS-2 name, NULL when not used.\n    char_u\t\t*matchname;\n    int\t\t\tok;\n    char_u\t\t*p_alt;\n\n    // Expanding \"**\" may take a long time, check for CTRL-C.\n    if (stardepth > 0)\n    {\n\tui_breakcheck();\n\tif (got_int)\n\t    return 0;\n    }\n\n    // Make room for file name.  When doing encoding conversion the actual\n    // length may be quite a bit longer, thus use the maximum possible length.\n    buf = alloc(MAXPATHL);\n    if (buf == NULL)\n\treturn 0;\n\n    /*\n     * Find the first part in the path name that contains a wildcard or a ~1.\n     * Copy it into buf, including the preceding characters.\n     */\n    p = buf;\n    s = buf;\n    e = NULL;\n    path_end = path;\n    while (*path_end != NUL)\n    {\n\t// May ignore a wildcard that has a backslash before it; it will\n\t// be removed by rem_backslash() or file_pat_to_reg_pat() below.\n\tif (path_end >= path + wildoff && rem_backslash(path_end))\n\t    *p++ = *path_end++;\n\telse if (*path_end == '\\\\' || *path_end == ':' || *path_end == '/')\n\t{\n\t    if (e != NULL)\n\t\tbreak;\n\t    s = p + 1;\n\t}\n\telse if (path_end >= path + wildoff\n\t\t\t && vim_strchr((char_u *)\"*?[~\", *path_end) != NULL)\n\t    e = p;\n\tif (has_mbyte)\n\t{\n\t    len = (*mb_ptr2len)(path_end);\n\t    STRNCPY(p, path_end, len);\n\t    p += len;\n\t    path_end += len;\n\t}\n\telse\n\t    *p++ = *path_end++;\n    }\n    e = p;\n    *e = NUL;\n\n    // now we have one wildcard component between s and e\n    // Remove backslashes between \"wildoff\" and the start of the wildcard\n    // component.\n    for (p = buf + wildoff; p < s; ++p)\n\tif (rem_backslash(p))\n\t{\n\t    STRMOVE(p, p + 1);\n\t    --e;\n\t    --s;\n\t}\n\n    // Check for \"**\" between \"s\" and \"e\".\n    for (p = s; p < e; ++p)\n\tif (p[0] == '*' && p[1] == '*')\n\t    starstar = TRUE;\n\n    starts_with_dot = *s == '.';\n    pat = file_pat_to_reg_pat(s, e, NULL, FALSE);\n    if (pat == NULL)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // compile the regexp into a program\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t++emsg_silent;\n    regmatch.rm_ic = TRUE;\t\t// Always ignore case\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC);\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t--emsg_silent;\n    vim_free(pat);\n\n    if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // remember the pattern or file name being looked for\n    matchname = vim_strsave(s);\n\n    // If \"**\" is by itself, this is the first time we encounter it and more\n    // is following then find matches without any directory.\n    if (!didstar && stardepth < 100 && starstar && e - s == 2\n\t\t\t\t\t\t\t  && *path_end == '/')\n    {\n\tSTRCPY(s, path_end + 1);\n\t++stardepth;\n\t(void)dos_expandpath(gap, buf, (int)(s - buf), flags, TRUE);\n\t--stardepth;\n    }\n\n    // Scan all files in the directory with \"dir/ *.*\"\n    STRCPY(s, \"*.*\");\n    wn = enc_to_utf16(buf, NULL);\n    if (wn != NULL)\n\thFind = FindFirstFileW(wn, &wfb);\n    ok = (hFind != INVALID_HANDLE_VALUE);\n\n    while (ok)\n    {\n\tp = utf16_to_enc(wfb.cFileName, NULL);   // p is allocated here\n\n\tif (p == NULL)\n\t    break;  // out of memory\n\n\t// Do not use the alternate filename when the file name ends in '~',\n\t// because it picks up backup files: short name for \"foo.vim~\" is\n\t// \"foo~1.vim\", which matches \"*.vim\".\n\tif (*wfb.cAlternateFileName == NUL || p[STRLEN(p) - 1] == '~')\n\t    p_alt = NULL;\n\telse\n\t    p_alt = utf16_to_enc(wfb.cAlternateFileName, NULL);\n\n\t// Ignore entries starting with a dot, unless when asked for.  Accept\n\t// all entries found with \"matchname\".\n\tif ((p[0] != '.' || starts_with_dot\n\t\t\t || ((flags & EW_DODOT)\n\t\t\t     && p[1] != NUL && (p[1] != '.' || p[2] != NUL)))\n\t\t&& (matchname == NULL\n\t\t  || (regmatch.regprog != NULL\n\t\t      && (vim_regexec(&regmatch, p, (colnr_T)0)\n\t\t\t || (p_alt != NULL\n\t\t\t\t&& vim_regexec(&regmatch, p_alt, (colnr_T)0))))\n\t\t  || ((flags & EW_NOTWILD)\n\t\t     && fnamencmp(path + (s - buf), p, e - s) == 0)))\n\t{\n\t    STRCPY(s, p);\n\t    len = (int)STRLEN(buf);\n\n\t    if (starstar && stardepth < 100\n\t\t\t  && (wfb.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))\n\t    {\n\t\t// For \"**\" in the pattern first go deeper in the tree to\n\t\t// find matches.\n\t\tSTRCPY(buf + len, \"/**\");\n\t\tSTRCPY(buf + len + 3, path_end);\n\t\t++stardepth;\n\t\t(void)dos_expandpath(gap, buf, len + 1, flags, TRUE);\n\t\t--stardepth;\n\t    }\n\n\t    STRCPY(buf + len, path_end);\n\t    if (mch_has_exp_wildcard(path_end))\n\t    {\n\t\t// need to expand another component of the path\n\t\t// remove backslashes for the remaining components only\n\t\t(void)dos_expandpath(gap, buf, len + 1, flags, FALSE);\n\t    }\n\t    else\n\t    {\n\t\t// no more wildcards, check if there is a match\n\t\t// remove backslashes for the remaining components only\n\t\tif (*path_end != 0)\n\t\t    backslash_halve(buf + len + 1);\n\t\tif (mch_getperm(buf) >= 0)\t// add existing file\n\t\t    addfile(gap, buf, flags);\n\t    }\n\t}\n\n\tvim_free(p_alt);\n\tvim_free(p);\n\tok = FindNextFileW(hFind, &wfb);\n    }\n\n    FindClose(hFind);\n    vim_free(wn);\n    vim_free(buf);\n    vim_regfree(regmatch.regprog);\n    vim_free(matchname);\n\n    matches = gap->ga_len - start_len;\n    if (matches > 0)\n\tqsort(((char_u **)gap->ga_data) + start_len, (size_t)matches,\n\t\t\t\t\t\t   sizeof(char_u *), pstrcmp);\n    return matches;\n}\n\n    int\nmch_expandpath(\n    garray_T\t*gap,\n    char_u\t*path,\n    int\t\tflags)\t\t// EW_* flags\n{\n    return dos_expandpath(gap, path, 0, flags, FALSE);\n}\n#endif // MSWIN\n\n#if (defined(UNIX) && !defined(VMS)) || defined(USE_UNIXFILENAME) \\\n\t|| defined(PROTO)\n/*\n * Unix style wildcard expansion code.\n * It's here because it's used both for Unix and Mac.\n */\n    static int\npstrcmp(const void *a, const void *b)\n{\n    return (pathcmp(*(char **)a, *(char **)b, -1));\n}\n\n/*\n * Recursively expand one path component into all matching files and/or\n * directories.  Adds matches to \"gap\".  Handles \"*\", \"?\", \"[a-z]\", \"**\", etc.\n * \"path\" has backslashes before chars that are not to be expanded, starting\n * at \"path + wildoff\".\n * Return the number of matches found.\n * NOTE: much of this is identical to dos_expandpath(), keep in sync!\n */\n    int\nunix_expandpath(\n    garray_T\t*gap,\n    char_u\t*path,\n    int\t\twildoff,\n    int\t\tflags,\t\t// EW_* flags\n    int\t\tdidstar)\t// expanded \"**\" once already\n{\n    char_u\t*buf;\n    char_u\t*path_end;\n    char_u\t*p, *s, *e;\n    int\t\tstart_len = gap->ga_len;\n    char_u\t*pat;\n    regmatch_T\tregmatch;\n    int\t\tstarts_with_dot;\n    int\t\tmatches;\n    int\t\tlen;\n    int\t\tstarstar = FALSE;\n    static int\tstardepth = 0;\t    // depth for \"**\" expansion\n\n    DIR\t\t*dirp;\n    struct dirent *dp;\n\n    // Expanding \"**\" may take a long time, check for CTRL-C.\n    if (stardepth > 0)\n    {\n\tui_breakcheck();\n\tif (got_int)\n\t    return 0;\n    }\n\n    // make room for file name\n    buf = alloc(STRLEN(path) + BASENAMELEN + 5);\n    if (buf == NULL)\n\treturn 0;\n\n    /*\n     * Find the first part in the path name that contains a wildcard.\n     * When EW_ICASE is set every letter is considered to be a wildcard.\n     * Copy it into \"buf\", including the preceding characters.\n     */\n    p = buf;\n    s = buf;\n    e = NULL;\n    path_end = path;\n    while (*path_end != NUL)\n    {\n\t// May ignore a wildcard that has a backslash before it; it will\n\t// be removed by rem_backslash() or file_pat_to_reg_pat() below.\n\tif (path_end >= path + wildoff && rem_backslash(path_end))\n\t    *p++ = *path_end++;\n\telse if (*path_end == '/')\n\t{\n\t    if (e != NULL)\n\t\tbreak;\n\t    s = p + 1;\n\t}\n\telse if (path_end >= path + wildoff\n\t\t\t && (vim_strchr((char_u *)\"*?[{~$\", *path_end) != NULL\n\t\t\t     || (!p_fic && (flags & EW_ICASE)\n\t\t\t\t\t  && vim_isalpha(PTR2CHAR(path_end)))))\n\t    e = p;\n\tif (has_mbyte)\n\t{\n\t    len = (*mb_ptr2len)(path_end);\n\t    STRNCPY(p, path_end, len);\n\t    p += len;\n\t    path_end += len;\n\t}\n\telse\n\t    *p++ = *path_end++;\n    }\n    e = p;\n    *e = NUL;\n\n    // Now we have one wildcard component between \"s\" and \"e\".\n    // Remove backslashes between \"wildoff\" and the start of the wildcard\n    // component.\n    for (p = buf + wildoff; p < s; ++p)\n\tif (rem_backslash(p))\n\t{\n\t    STRMOVE(p, p + 1);\n\t    --e;\n\t    --s;\n\t}\n\n    // Check for \"**\" between \"s\" and \"e\".\n    for (p = s; p < e; ++p)\n\tif (p[0] == '*' && p[1] == '*')\n\t    starstar = TRUE;\n\n    // convert the file pattern to a regexp pattern\n    starts_with_dot = *s == '.';\n    pat = file_pat_to_reg_pat(s, e, NULL, FALSE);\n    if (pat == NULL)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // compile the regexp into a program\n    if (flags & EW_ICASE)\n\tregmatch.rm_ic = TRUE;\t\t// 'wildignorecase' set\n    else\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t++emsg_silent;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC);\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t--emsg_silent;\n    vim_free(pat);\n\n    if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // If \"**\" is by itself, this is the first time we encounter it and more\n    // is following then find matches without any directory.\n    if (!didstar && stardepth < 100 && starstar && e - s == 2\n\t\t\t\t\t\t\t  && *path_end == '/')\n    {\n\tSTRCPY(s, path_end + 1);\n\t++stardepth;\n\t(void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE);\n\t--stardepth;\n    }\n\n    // open the directory for scanning\n    *s = NUL;\n    dirp = opendir(*buf == NUL ? \".\" : (char *)buf);\n\n    // Find all matching entries\n    if (dirp != NULL)\n    {\n\tfor (;;)\n\t{\n\t    dp = readdir(dirp);\n\t    if (dp == NULL)\n\t\tbreak;\n\t    if ((dp->d_name[0] != '.' || starts_with_dot\n\t\t\t|| ((flags & EW_DODOT)\n\t\t\t    && dp->d_name[1] != NUL\n\t\t\t    && (dp->d_name[1] != '.' || dp->d_name[2] != NUL)))\n\t\t && ((regmatch.regprog != NULL && vim_regexec(&regmatch,\n\t\t\t\t\t     (char_u *)dp->d_name, (colnr_T)0))\n\t\t   || ((flags & EW_NOTWILD)\n\t\t     && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0)))\n\t    {\n\t\tSTRCPY(s, dp->d_name);\n\t\tlen = STRLEN(buf);\n\n\t\tif (starstar && stardepth < 100)\n\t\t{\n\t\t    // For \"**\" in the pattern first go deeper in the tree to\n\t\t    // find matches.\n\t\t    STRCPY(buf + len, \"/**\");\n\t\t    STRCPY(buf + len + 3, path_end);\n\t\t    ++stardepth;\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, TRUE);\n\t\t    --stardepth;\n\t\t}\n\n\t\tSTRCPY(buf + len, path_end);\n\t\tif (mch_has_exp_wildcard(path_end)) // handle more wildcards\n\t\t{\n\t\t    // need to expand another component of the path\n\t\t    // remove backslashes for the remaining components only\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    stat_T  sb;\n\n\t\t    // no more wildcards, check if there is a match\n\t\t    // remove backslashes for the remaining components only\n\t\t    if (*path_end != NUL)\n\t\t\tbackslash_halve(buf + len + 1);\n\t\t    // add existing file or symbolic link\n\t\t    if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0\n\t\t\t\t\t\t      : mch_getperm(buf) >= 0)\n\t\t    {\n#ifdef MACOS_CONVERT\n\t\t\tsize_t precomp_len = STRLEN(buf)+1;\n\t\t\tchar_u *precomp_buf =\n\t\t\t    mac_precompose_path(buf, precomp_len, &precomp_len);\n\n\t\t\tif (precomp_buf)\n\t\t\t{\n\t\t\t    mch_memmove(buf, precomp_buf, precomp_len);\n\t\t\t    vim_free(precomp_buf);\n\t\t\t}\n#endif\n\t\t\taddfile(gap, buf, flags);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tclosedir(dirp);\n    }\n\n    vim_free(buf);\n    vim_regfree(regmatch.regprog);\n\n    matches = gap->ga_len - start_len;\n    if (matches > 0)\n\tqsort(((char_u **)gap->ga_data) + start_len, matches,\n\t\t\t\t\t\t   sizeof(char_u *), pstrcmp);\n    return matches;\n}\n#endif\n\n/*\n * Return TRUE if \"p\" contains what looks like an environment variable.\n * Allowing for escaping.\n */\n    static int\nhas_env_var(char_u *p)\n{\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t    ++p;\n\telse if (vim_strchr((char_u *)\n#if defined(MSWIN)\n\t\t\t\t    \"$%\"\n#else\n\t\t\t\t    \"$\"\n#endif\n\t\t\t\t\t, *p) != NULL)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n#ifdef SPECIAL_WILDCHAR\n/*\n * Return TRUE if \"p\" contains a special wildcard character, one that Vim\n * cannot expand, requires using a shell.\n */\n    static int\nhas_special_wildchar(char_u *p)\n{\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\t// Disallow line break characters.\n\tif (*p == '\\r' || *p == '\\n')\n\t    break;\n\t// Allow for escaping.\n\tif (*p == '\\\\' && p[1] != NUL && p[1] != '\\r' && p[1] != '\\n')\n\t    ++p;\n\telse if (vim_strchr((char_u *)SPECIAL_WILDCHAR, *p) != NULL)\n\t{\n\t    // A { must be followed by a matching }.\n\t    if (*p == '{' && vim_strchr(p, '}') == NULL)\n\t\tcontinue;\n\t    // A quote and backtick must be followed by another one.\n\t    if ((*p == '`' || *p == '\\'') && vim_strchr(p, *p) == NULL)\n\t\tcontinue;\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Generic wildcard expansion code.\n *\n * Characters in \"pat\" that should not be expanded must be preceded with a\n * backslash. E.g., \"/path\\ with\\ spaces/my\\*star*\"\n *\n * Return FAIL when no single file was found.  In this case \"num_file\" is not\n * set, and \"file\" may contain an error message.\n * Return OK when some files found.  \"num_file\" is set to the number of\n * matches, \"file\" to the array of matches.  Call FreeWild() later.\n */\n    int\ngen_expand_wildcards(\n    int\t\tnum_pat,\t// number of input patterns\n    char_u\t**pat,\t\t// array of input patterns\n    int\t\t*num_file,\t// resulting number of files\n    char_u\t***file,\t// array of resulting files\n    int\t\tflags)\t\t// EW_* flags\n{\n    int\t\t\ti;\n    garray_T\t\tga;\n    char_u\t\t*p;\n    static int\t\trecursive = FALSE;\n    int\t\t\tadd_pat;\n    int\t\t\tretval = OK;\n#if defined(FEAT_SEARCHPATH)\n    int\t\t\tdid_expand_in_path = FALSE;\n#endif\n\n    /*\n     * expand_env() is called to expand things like \"~user\".  If this fails,\n     * it calls ExpandOne(), which brings us back here.  In this case, always\n     * call the machine specific expansion function, if possible.  Otherwise,\n     * return FAIL.\n     */\n    if (recursive)\n#ifdef SPECIAL_WILDCHAR\n\treturn mch_expand_wildcards(num_pat, pat, num_file, file, flags);\n#else\n\treturn FAIL;\n#endif\n\n#ifdef SPECIAL_WILDCHAR\n    /*\n     * If there are any special wildcard characters which we cannot handle\n     * here, call machine specific function for all the expansion.  This\n     * avoids starting the shell for each argument separately.\n     * For `=expr` do use the internal function.\n     */\n    for (i = 0; i < num_pat; i++)\n    {\n\tif (has_special_wildchar(pat[i])\n# ifdef VIM_BACKTICK\n\t\t&& !(vim_backtick(pat[i]) && pat[i][1] == '=')\n# endif\n\t   )\n\t    return mch_expand_wildcards(num_pat, pat, num_file, file, flags);\n    }\n#endif\n\n    recursive = TRUE;\n\n    /*\n     * The matching file names are stored in a growarray.  Init it empty.\n     */\n    ga_init2(&ga, sizeof(char_u *), 30);\n\n    for (i = 0; i < num_pat; ++i)\n    {\n\tadd_pat = -1;\n\tp = pat[i];\n\n#ifdef VIM_BACKTICK\n\tif (vim_backtick(p))\n\t{\n\t    add_pat = expand_backtick(&ga, p, flags);\n\t    if (add_pat == -1)\n\t\tretval = FAIL;\n\t}\n\telse\n#endif\n\t{\n\t    /*\n\t     * First expand environment variables, \"~/\" and \"~user/\".\n\t     */\n\t    if ((has_env_var(p) && !(flags & EW_NOTENV)) || *p == '~')\n\t    {\n\t\tp = expand_env_save_opt(p, TRUE);\n\t\tif (p == NULL)\n\t\t    p = pat[i];\n#ifdef UNIX\n\t\t/*\n\t\t * On Unix, if expand_env() can't expand an environment\n\t\t * variable, use the shell to do that.  Discard previously\n\t\t * found file names and start all over again.\n\t\t */\n\t\telse if (has_env_var(p) || *p == '~')\n\t\t{\n\t\t    vim_free(p);\n\t\t    ga_clear_strings(&ga);\n\t\t    i = mch_expand_wildcards(num_pat, pat, num_file, file,\n\t\t\t\t\t\t\t flags|EW_KEEPDOLLAR);\n\t\t    recursive = FALSE;\n\t\t    return i;\n\t\t}\n#endif\n\t    }\n\n\t    /*\n\t     * If there are wildcards: Expand file names and add each match to\n\t     * the list.  If there is no match, and EW_NOTFOUND is given, add\n\t     * the pattern.\n\t     * If there are no wildcards: Add the file name if it exists or\n\t     * when EW_NOTFOUND is given.\n\t     */\n\t    if (mch_has_exp_wildcard(p))\n\t    {\n#if defined(FEAT_SEARCHPATH)\n\t\tif ((flags & EW_PATH)\n\t\t\t&& !mch_isFullName(p)\n\t\t\t&& !(p[0] == '.'\n\t\t\t    && (vim_ispathsep(p[1])\n\t\t\t\t|| (p[1] == '.' && vim_ispathsep(p[2]))))\n\t\t   )\n\t\t{\n\t\t    // :find completion where 'path' is used.\n\t\t    // Recursiveness is OK here.\n\t\t    recursive = FALSE;\n\t\t    add_pat = expand_in_path(&ga, p, flags);\n\t\t    recursive = TRUE;\n\t\t    did_expand_in_path = TRUE;\n\t\t}\n\t\telse\n#endif\n\t\t    add_pat = mch_expandpath(&ga, p, flags);\n\t    }\n\t}\n\n\tif (add_pat == -1 || (add_pat == 0 && (flags & EW_NOTFOUND)))\n\t{\n\t    char_u\t*t = backslash_halve_save(p);\n\n\t    // When EW_NOTFOUND is used, always add files and dirs.  Makes\n\t    // \"vim c:/\" work.\n\t    if (flags & EW_NOTFOUND)\n\t\taddfile(&ga, t, flags | EW_DIR | EW_FILE);\n\t    else\n\t\taddfile(&ga, t, flags);\n\n\t    if (t != p)\n\t\tvim_free(t);\n\t}\n\n#if defined(FEAT_SEARCHPATH)\n\tif (did_expand_in_path && ga.ga_len > 0 && (flags & EW_PATH))\n\t    uniquefy_paths(&ga, p);\n#endif\n\tif (p != pat[i])\n\t    vim_free(p);\n    }\n\n    // When returning FAIL the array must be freed here.\n    if (retval == FAIL)\n\tga_clear(&ga);\n\n    *num_file = ga.ga_len;\n    *file = (ga.ga_data != NULL) ? (char_u **)ga.ga_data\n\t\t\t\t\t\t  : (char_u **)_(\"no matches\");\n\n    recursive = FALSE;\n\n    return ((flags & EW_EMPTYOK) || ga.ga_data != NULL) ? retval : FAIL;\n}\n\n/*\n * Add a file to a file list.  Accepted flags:\n * EW_DIR\tadd directories\n * EW_FILE\tadd files\n * EW_EXEC\tadd executable files\n * EW_NOTFOUND\tadd even when it doesn't exist\n * EW_ADDSLASH\tadd slash after directory name\n * EW_ALLLINKS\tadd symlink also when the referred file does not exist\n */\n    void\naddfile(\n    garray_T\t*gap,\n    char_u\t*f,\t// filename\n    int\t\tflags)\n{\n    char_u\t*p;\n    int\t\tisdir;\n    stat_T\tsb;\n\n    // if the file/dir/link doesn't exist, may not add it\n    if (!(flags & EW_NOTFOUND) && ((flags & EW_ALLLINKS)\n\t\t\t? mch_lstat((char *)f, &sb) < 0 : mch_getperm(f) < 0))\n\treturn;\n\n#ifdef FNAME_ILLEGAL\n    // if the file/dir contains illegal characters, don't add it\n    if (vim_strpbrk(f, (char_u *)FNAME_ILLEGAL) != NULL)\n\treturn;\n#endif\n\n    isdir = mch_isdir(f);\n    if ((isdir && !(flags & EW_DIR)) || (!isdir && !(flags & EW_FILE)))\n\treturn;\n\n    // If the file isn't executable, may not add it.  Do accept directories.\n    // When invoked from expand_shellcmd() do not use $PATH.\n    if (!isdir && (flags & EW_EXEC)\n\t\t\t     && !mch_can_exe(f, NULL, !(flags & EW_SHELLCMD)))\n\treturn;\n\n    // Make room for another item in the file list.\n    if (ga_grow(gap, 1) == FAIL)\n\treturn;\n\n    p = alloc(STRLEN(f) + 1 + isdir);\n    if (p == NULL)\n\treturn;\n\n    STRCPY(p, f);\n#ifdef BACKSLASH_IN_FILENAME\n    slash_adjust(p);\n#endif\n    /*\n     * Append a slash or backslash after directory names if none is present.\n     */\n#ifndef DONT_ADD_PATHSEP_TO_DIR\n    if (isdir && (flags & EW_ADDSLASH))\n\tadd_pathsep(p);\n#endif\n    ((char_u **)gap->ga_data)[gap->ga_len++] = p;\n}\n\n/*\n * Free the list of files returned by expand_wildcards() or other expansion\n * functions.\n */\n    void\nFreeWild(int count, char_u **files)\n{\n    if (count <= 0 || files == NULL)\n\treturn;\n    while (count--)\n\tvim_free(files[count]);\n    vim_free(files);\n}\n\n/*\n * Compare path \"p[]\" to \"q[]\".\n * If \"maxlen\" >= 0 compare \"p[maxlen]\" to \"q[maxlen]\"\n * Return value like strcmp(p, q), but consider path separators.\n */\n    int\npathcmp(const char *p, const char *q, int maxlen)\n{\n    int\t\ti, j;\n    int\t\tc1, c2;\n    const char\t*s = NULL;\n\n    for (i = 0, j = 0; maxlen < 0 || (i < maxlen && j < maxlen);)\n    {\n\tc1 = PTR2CHAR((char_u *)p + i);\n\tc2 = PTR2CHAR((char_u *)q + j);\n\n\t// End of \"p\": check if \"q\" also ends or just has a slash.\n\tif (c1 == NUL)\n\t{\n\t    if (c2 == NUL)  // full match\n\t\treturn 0;\n\t    s = q;\n\t    i = j;\n\t    break;\n\t}\n\n\t// End of \"q\": check if \"p\" just has a slash.\n\tif (c2 == NUL)\n\t{\n\t    s = p;\n\t    break;\n\t}\n\n\tif ((p_fic ? MB_TOUPPER(c1) != MB_TOUPPER(c2) : c1 != c2)\n#ifdef BACKSLASH_IN_FILENAME\n\t\t// consider '/' and '\\\\' to be equal\n\t\t&& !((c1 == '/' && c2 == '\\\\')\n\t\t    || (c1 == '\\\\' && c2 == '/'))\n#endif\n\t\t)\n\t{\n\t    if (vim_ispathsep(c1))\n\t\treturn -1;\n\t    if (vim_ispathsep(c2))\n\t\treturn 1;\n\t    return p_fic ? MB_TOUPPER(c1) - MB_TOUPPER(c2)\n\t\t    : c1 - c2;  // no match\n\t}\n\n\ti += mb_ptr2len((char_u *)p + i);\n\tj += mb_ptr2len((char_u *)q + j);\n    }\n    if (s == NULL)\t// \"i\" or \"j\" ran into \"maxlen\"\n\treturn 0;\n\n    c1 = PTR2CHAR((char_u *)s + i);\n    c2 = PTR2CHAR((char_u *)s + i + mb_ptr2len((char_u *)s + i));\n    // ignore a trailing slash, but not \"//\" or \":/\"\n    if (c2 == NUL\n\t    && i > 0\n\t    && !after_pathsep((char_u *)s, (char_u *)s + i)\n#ifdef BACKSLASH_IN_FILENAME\n\t    && (c1 == '/' || c1 == '\\\\')\n#else\n\t    && c1 == '/'\n#endif\n       )\n\treturn 0;   // match with trailing slash\n    if (s == q)\n\treturn -1;\t    // no match\n    return 1;\n}\n\n/*\n * Return TRUE if \"name\" is a full (absolute) path name or URL.\n */\n    int\nvim_isAbsName(char_u *name)\n{\n    return (path_with_url(name) != 0 || mch_isFullName(name));\n}\n\n/*\n * Get absolute file name into buffer \"buf[len]\".\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nvim_FullName(\n    char_u\t*fname,\n    char_u\t*buf,\n    int\t\tlen,\n    int\t\tforce)\t    // force expansion even when already absolute\n{\n    int\t\tretval = OK;\n    int\t\turl;\n\n    *buf = NUL;\n    if (fname == NULL)\n\treturn FAIL;\n\n    url = path_with_url(fname);\n    if (!url)\n\tretval = mch_FullName(fname, buf, len, force);\n    if (url || retval == FAIL)\n    {\n\t// something failed; use the file name (truncate when too long)\n\tvim_strncpy(buf, fname, len - 1);\n    }\n#if defined(MSWIN)\n    slash_adjust(buf);\n#endif\n    return retval;\n}\n", "/* charset.c */\nint init_chartab(void);\nint buf_init_chartab(buf_T *buf, int global);\nvoid trans_characters(char_u *buf, int bufsize);\nchar_u *transstr(char_u *s);\nchar_u *str_foldcase(char_u *str, int orglen, char_u *buf, int buflen);\nchar_u *transchar(int c);\nchar_u *transchar_buf(buf_T *buf, int c);\nchar_u *transchar_byte(int c);\nvoid transchar_nonprint(buf_T *buf, char_u *charbuf, int c);\nvoid transchar_hex(char_u *buf, int c);\nint byte2cells(int b);\nint char2cells(int c);\nint ptr2cells(char_u *p);\nint vim_strsize(char_u *s);\nint vim_strnsize(char_u *s, int len);\nint chartabsize(char_u *p, colnr_T col);\nint linetabsize(char_u *s);\nint linetabsize_col(int startcol, char_u *s);\nint win_linetabsize(win_T *wp, char_u *line, colnr_T len);\nint vim_isIDc(int c);\nint vim_isNormalIDc(int c);\nint vim_iswordc(int c);\nint vim_iswordc_buf(int c, buf_T *buf);\nint vim_iswordp(char_u *p);\nint vim_iswordp_buf(char_u *p, buf_T *buf);\nint vim_isfilec(int c);\nint vim_isfilec_or_wc(int c);\nint vim_isprintc(int c);\nint vim_isprintc_strict(int c);\nint lbr_chartabsize(char_u *line, unsigned char *s, colnr_T col);\nint lbr_chartabsize_adv(char_u *line, char_u **s, colnr_T col);\nint win_lbr_chartabsize(win_T *wp, char_u *line, char_u *s, colnr_T col, int *headp);\nvoid getvcol(win_T *wp, pos_T *pos, colnr_T *start, colnr_T *cursor, colnr_T *end);\ncolnr_T getvcol_nolist(pos_T *posp);\nvoid getvvcol(win_T *wp, pos_T *pos, colnr_T *start, colnr_T *cursor, colnr_T *end);\nvoid getvcols(win_T *wp, pos_T *pos1, pos_T *pos2, colnr_T *left, colnr_T *right);\nchar_u *skipwhite(char_u *q);\nchar_u *skipwhite_and_nl(char_u *q);\nint getwhitecols_curline(void);\nint getwhitecols(char_u *p);\nchar_u *skipdigits(char_u *q);\nchar_u *skipbin(char_u *q);\nchar_u *skiphex(char_u *q);\nchar_u *skiptobin(char_u *q);\nchar_u *skiptodigit(char_u *q);\nchar_u *skiptohex(char_u *q);\nint vim_isdigit(int c);\nint vim_isxdigit(int c);\nint vim_isbdigit(int c);\nint vim_islower(int c);\nint vim_isupper(int c);\nint vim_isalpha(int c);\nint vim_toupper(int c);\nint vim_tolower(int c);\nchar_u *skiptowhite(char_u *p);\nchar_u *skiptowhite_esc(char_u *p);\nlong getdigits(char_u **pp);\nlong getdigits_quoted(char_u **pp);\nint vim_isblankline(char_u *lbuf);\nvoid vim_str2nr(char_u *start, int *prep, int *len, int what, varnumber_T *nptr, uvarnumber_T *unptr, int maxlen, int strict);\nint hex2nr(int c);\nint hexhex2nr(char_u *p);\nint rem_backslash(char_u *str);\nvoid backslash_halve(char_u *p);\nchar_u *backslash_halve_save(char_u *p);\n/* vim: set ft=c : */\n", "\" Test 'autochdir' behavior\n\nsource check.vim\nCheckOption autochdir\n\nfunc Test_set_filename()\n  let cwd = getcwd()\n  call test_autochdir()\n  set acd\n\n  let s:li = []\n  autocmd DirChanged auto call add(s:li, \"autocd\")\n  autocmd DirChanged auto call add(s:li, expand(\"<afile>\"))\n\n  new\n  w samples/Xtest\n  call assert_equal(\"Xtest\", expand('%'))\n  call assert_equal(\"samples\", substitute(getcwd(), '.*/\\(\\k*\\)', '\\1', ''))\n  call assert_equal([\"autocd\", getcwd()], s:li)\n\n  bwipe!\n  au! DirChanged\n  set noacd\n  call chdir(cwd)\n  call delete('samples/Xtest')\nendfunc\n\nfunc Test_set_filename_other_window()\n  let cwd = getcwd()\n  call test_autochdir()\n  call mkdir('Xa')\n  call mkdir('Xb')\n  call mkdir('Xc')\n  try\n    args Xa/aaa.txt Xb/bbb.txt\n    set acd\n    let winid = win_getid()\n    snext\n    call assert_equal('Xb', substitute(getcwd(), '.*/\\([^/]*\\)$', '\\1', ''))\n    call win_execute(winid, 'file ' .. cwd .. '/Xc/ccc.txt')\n    call assert_equal('Xb', substitute(getcwd(), '.*/\\([^/]*\\)$', '\\1', ''))\n  finally\n    set noacd\n    call chdir(cwd)\n    bwipe! aaa.txt\n    bwipe! bbb.txt\n    bwipe! ccc.txt\n    call delete('Xa', 'rf')\n    call delete('Xb', 'rf')\n    call delete('Xc', 'rf')\n  endtry\nendfunc\n\nfunc Test_acd_win_execute()\n  let cwd = getcwd()\n  set acd\n  call test_autochdir()\n\n  call mkdir('Xfile')\n  let winid = win_getid()\n  new Xfile/file\n  call assert_match('testdir.Xfile$', getcwd())\n  cd ..\n  call assert_match('testdir$', getcwd())\n  call win_execute(winid, 'echo')\n  call assert_match('testdir$', getcwd())\n\n  bwipe!\n  set noacd\n  call chdir(cwd)\n  call delete('Xfile', 'rf')\nendfunc\n\nfunc Test_verbose_pwd()\n  let cwd = getcwd()\n  call test_autochdir()\n\n  edit global.txt\n  call assert_match('\\[global\\].*testdir$', execute('verbose pwd'))\n\n  call mkdir('Xautodir')\n  split Xautodir/local.txt\n  lcd Xautodir\n  call assert_match('\\[window\\].*testdir[/\\\\]Xautodir', execute('verbose pwd'))\n\n  set acd\n  wincmd w\n  call assert_match('\\[autochdir\\].*testdir$', execute('verbose pwd'))\n  execute 'lcd' cwd\n  call assert_match('\\[window\\].*testdir$', execute('verbose pwd'))\n  execute 'tcd' cwd\n  call assert_match('\\[tabpage\\].*testdir$', execute('verbose pwd'))\n  execute 'cd' cwd\n  call assert_match('\\[global\\].*testdir$', execute('verbose pwd'))\n  edit\n  call assert_match('\\[autochdir\\].*testdir$', execute('verbose pwd'))\n  wincmd w\n  call assert_match('\\[autochdir\\].*testdir[/\\\\]Xautodir', execute('verbose pwd'))\n  set noacd\n  call assert_match('\\[autochdir\\].*testdir[/\\\\]Xautodir', execute('verbose pwd'))\n  wincmd w\n  call assert_match('\\[autochdir\\].*testdir[/\\\\]Xautodir', execute('verbose pwd'))\n  execute 'cd' cwd\n  call assert_match('\\[global\\].*testdir', execute('verbose pwd'))\n  wincmd w\n  call assert_match('\\[window\\].*testdir[/\\\\]Xautodir', execute('verbose pwd'))\n\n  bwipe!\n  call chdir(cwd)\n  call delete('Xautodir', 'rf')\nendfunc\n\nfunc Test_multibyte()\n  \" using an invalid character should not cause a crash\n  set wic\n  call assert_fails('tc \u0171\u0164\u0164\u0164\u00a6*', 'E344:')\n  set nowic\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/charset.c", "src/filepath.c", "src/proto/charset.pro", "src/testdir/test_autochdir.vim", "src/version.c"], "buggy_code_start_loc": [1647, 3629, 52, 112, 752], "buggy_code_end_loc": [1647, 3630, 67, 112, 752], "fixing_code_start_loc": [1648, 3629, 53, 113, 753], "fixing_code_end_loc": [1654, 3630, 66, 121, 755], "type": "CWE-823", "message": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 8.2.4418.", "other": {"cve": {"id": "CVE-2022-0685", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-20T11:15:07.373", "lastModified": "2022-12-14T16:44:44.430", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 8.2.4418."}, {"lang": "es", "value": "Un Uso de un Desplazamiento de Puntero Fuera de Rango en el repositorio de GitHub vim/vim versiones anteriores a 8.2.4418"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-823"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.4418", "matchCriteriaId": "C923A938-C6B8-4642-969F-13D3236C21AF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "13.0", "matchCriteriaId": "71E032AD-F827-4944-9699-BB1E6D4233FC"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Oct/28", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/41", "source": "security@huntr.dev", "tags": ["Mailing List", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/5921aeb5741fc6e84c870d68c7c35b93ad0c9f87", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/27230da3-9b1a-4d5d-8cdf-4b1e62fcd782", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213488", "source": "security@huntr.dev", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/5921aeb5741fc6e84c870d68c7c35b93ad0c9f87"}}