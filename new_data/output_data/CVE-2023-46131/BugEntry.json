{"buggy_code": ["/*\n * Copyright 2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage grails.databinding;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\n/**\n * This annotation may be applied to a a field to\n * customize initialization of object properties in the data binding process.\n *\n * When the annotation is applied to a field, the value assigned to the\n * annotation should be a Closure which accepts 1 parameter.  The \n * parameter is the object that data binding is being applied to.  \n * The value returned by the Closure will be bound to the field.  The\n * following code demonstrates using this technique to bind a contact\n * to user with the same account as the user.\n *\n<pre>\nclass Contact{\n  Account account\n  String firstName\n} \nclass User {\n    &#064;BindInitializer({\n        obj -> new Contact(account:obj.account)\n    })\n    Contact contact\n    Account account\n}\n</pre>\n \n *\n * @since 3.2.11\n * @see BindingHelper\n * @see DataBindingSource\n */\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface BindInitializer {\n    Class<?> value();\n}\n", "/*\n * Copyright 2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage grails.databinding;\n\nimport grails.databinding.BindingHelper;\nimport grails.databinding.DataBindingSource;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\n/**\n * This annotation may be applied to a class or to a field to\n * customize the data binding process.\n *\n * When the annotation is applied to a field, the value assigned to the\n * annotation should be a Closure which accepts 2 parameters.  The first\n * parameter is the object that data binding is being applied to.  The second\n * parameter is a {@link org.grails.databinding.DataBindingSource} containing the values being bound to the object.\n * The value returned by the Closure will be bound to the field.  The\n * following code demonstrates using this technique to bind an upper\n * case version of the value in the DataBindingSource to the field.\n *\n<pre>\nclass SomeClass {\n    &#064;BindUsing({\n        obj, source -> source['name']?.toUpperCase()\n    })\n    String name\n}\n</pre>\n *\n * When the annotation is applied to a class, the value assigned to the\n * annotation should be a class which implements the {@link BindingHelper}\n * interface.  An instance of that class will be used any time a value\n * is bound to a property in the class that this annotation has been\n * applied to.\n<pre>\n&#064;BindUsing(SomeClassWhichImplementsBindingHelper)\nclass SomeClass {\n    String someProperty\n    Integer someOtherProperty\n}\n</pre>\n *\n * @author Jeff Brown\n * @since 2.3\n * @see BindingHelper\n * @see DataBindingSource\n */\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface BindUsing {\n    Class<?> value();\n}\n", "/*\n * Copyright 2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage grails.databinding\n\nimport grails.databinding.converters.FormattedValueConverter\nimport grails.databinding.converters.ValueConverter\nimport grails.databinding.events.DataBindingListener\nimport grails.databinding.initializers.ValueInitializer\nimport groovy.transform.CompileStatic\nimport groovy.transform.TypeCheckingMode\nimport groovy.util.slurpersupport.GPathResult\nimport org.grails.databinding.ClosureValueConverter\nimport org.grails.databinding.ClosureValueInitializer\nimport org.grails.databinding.IndexedPropertyReferenceDescriptor\nimport org.grails.databinding.converters.*\nimport org.grails.databinding.errors.SimpleBindingError\nimport org.grails.databinding.xml.GPathResultMap\n\nimport java.lang.annotation.Annotation\nimport java.lang.reflect.Array\nimport java.lang.reflect.Field\nimport java.lang.reflect.Modifier\nimport java.lang.reflect.ParameterizedType\nimport java.security.ProtectionDomain\n\n/**\n * A data binder that will bind nested Maps to an object.\n *\n <pre>\n class Person {\n     String firstName\n     Address homeAddress\n }\n\n class Address {\n     String city\n     String state\n }\n\n def person = new Person()\n def binder = new SimpleDataBinder()\n binder.bind person, [firstName: 'Steven', homeAddress: [city: 'St. Louis', state: 'Missouri']]\n assert person.firstName == 'Steven'\n assert person.homeAddress.city == 'St. Louis'\n assert person.homeAddress.state == 'Missouri'\n\n </pre>\n *\n * @author Jeff Brown\n * @author Graeme Rocher\n *\n * @since 3.0\n */\n@CompileStatic\nclass SimpleDataBinder implements DataBinder {\n\n    protected Map<Class, StructuredBindingEditor> structuredEditors = new HashMap<Class, StructuredBindingEditor>()\n    ConversionService conversionService\n    protected Map<Class, List<ValueConverter>> conversionHelpers = [:].withDefault { c -> [] }\n    protected Map<Class, FormattedValueConverter> formattedValueConversionHelpers = new HashMap<Class, FormattedValueConverter>()\n    protected static final List<Class> BASIC_TYPES = [\n        String,\n        Boolean,\n        Byte,\n        Short,\n        Integer,\n        Long,\n        Float,\n        Double,\n        Character\n    ]\n\n    static final INDEXED_PROPERTY_REGEX = /(.*)\\[\\s*([^\\s]*)\\s*\\]\\s*$/\n\n    int autoGrowCollectionLimit = 256\n\n    SimpleDataBinder() {\n        registerStructuredEditor Date, new StructuredDateBindingEditor()\n        registerStructuredEditor java.sql.Date, new StructuredSqlDateBindingEditor()\n        registerStructuredEditor Calendar, new StructuredCalendarBindingEditor()\n\n        registerFormattedValueConverter new FormattedDateValueConverter()\n    }\n\n    void registerStructuredEditor(Class clazz, StructuredBindingEditor editor) {\n        structuredEditors[clazz] = editor\n    }\n\n    void registerConverter(ValueConverter converter) {\n        conversionHelpers[converter.targetType] << converter\n    }\n    void registerFormattedValueConverter(FormattedValueConverter converter) {\n        formattedValueConversionHelpers[converter.targetType] = converter\n    }\n\n    /**\n     * \n     * @param obj The object being bound to\n     * @param source The data binding source\n     * @see DataBindingSource\n     */\n    void bind(obj, DataBindingSource source) {\n        bind obj, source, null, null, null, null\n    }\n\n    /**\n     * \n     * @param obj The object being bound to\n     * @param source The data binding source\n     * @param listener A listener which will be notified of data binding events triggered\n     * by this binding\n     * @see DataBindingSource\n     * @see DataBindingListener\n     */\n    void bind(obj, DataBindingSource source, DataBindingListener listener) {\n        bind obj, source, null, null, null, listener\n    }\n\n    /**\n     * \n     * @param obj The object being bound to\n     * @param source The data binding source\n     * @param whiteList A list of property names to be included during this \n     * data binding.  All other properties represented in the binding source \n     * will be ignored\n     * @see DataBindingSource\n     */\n    void bind(obj, DataBindingSource source, List whiteList) {\n        bind obj, source, null, whiteList, null, null\n    }\n\n    /**\n     * \n     * @param obj The object being bound to\n     * @param source The data binding source\n     * @param whiteList A list of property names to be included during this \n     * data binding.  All other properties represented in the binding source \n     * will be ignored\n     * @param blackList A list of properties names to be excluded during\n     * this data binding.  \n     * @see DataBindingSource\n     */\n    void bind(obj, DataBindingSource source, List whiteList, List blackList) {\n        bind obj, source, null, whiteList, blackList, null\n    }\n\n    /**\n     * \n     * @param obj The object being bound to\n     * @param gpath A GPathResult which represents the data being bound.  \n     * @see DataBindingSource\n     */\n    void bind(obj, GPathResult gpath) {\n        bind obj, new SimpleMapDataBindingSource(new GPathResultMap(gpath))\n    }\n\n    /**\n     * \n     * @param obj The object being bound to\n     * @param source The data binding source\n     * @param filter Only properties beginning with filter will be included in the\n     * data binding.  For example, if filter is &quot;person&quot; and the binding\n     * source contains data for properties &quot;person.name&quot; and &quot;author.name&quot;\n     * the value of &quot;person.name&quot; will be bound to obj.name.  The value of\n     * &quot;author.name&quot; will be ignored.\n     * @param whiteList A list of property names to be included during this \n     * data binding.  All other properties represented in the binding source \n     * will be ignored\n     * @param blackList A list of properties names to be excluded during\n     * this data binding.  \n     * @see DataBindingSource\n     */\n    void bind(obj, DataBindingSource source, String filter, List whiteList, List blackList) {\n        bind obj, source, filter, whiteList, blackList, null\n    }\n\n    /**\n     * \n     * @param obj The object being bound to\n     * @param source The data binding source\n     * @param filter Only properties beginning with filter will be included in the\n     * data binding.  For example, if filter is &quot;person&quot; and the binding\n     * source contains data for properties &quot;person.name&quot; and &quot;author.name&quot;\n     * the value of &quot;person.name&quot; will be bound to obj.name.  The value of\n     * &quot;author.name&quot; will be ignored.\n     * @param whiteList A list of property names to be included during this \n     * data binding.  All other properties represented in the binding source \n     * will be ignored\n     * @param blackList A list of properties names to be excluded during\n     * this data binding.  \n     * @param listener A listener which will be notified of data binding events triggered\n     * by this binding\n     * @see DataBindingSource\n     * @see DataBindingListener\n     */\n    void bind(obj, DataBindingSource source, String filter, List whiteList, List blackList, DataBindingListener listener) {\n        doBind obj, source, filter, whiteList, blackList, listener, null\n    }\n\n    protected void doBind(obj, DataBindingSource source, String filter, List whiteList, List blackList, DataBindingListener listener, errors) {\n\n        def keys = source.getPropertyNames()\n        for (String key in keys) {\n            if (!filter || key.startsWith(filter + '.')) {\n                String propName = key\n                if (filter) {\n                    propName = key[(1+filter.size())..-1]\n                }\n                def metaProperty = obj.metaClass.getMetaProperty propName\n\n                if (metaProperty) { // normal property\n                    if (isOkToBind(metaProperty, whiteList, blackList)) {\n                        def val = source[key]\n                        try {\n                            def converter = getValueConverter(obj, metaProperty.name)\n                            if(converter) {\n                                bindProperty obj, source, metaProperty, converter.convert(source), listener, errors\n                            } else {\n                                processProperty obj, metaProperty, preprocessValue(val), source, listener, errors\n                            }\n                        } catch (Exception e) {\n                            addBindingError(obj, propName, val, e, listener, errors)\n                        }\n                    }\n                } else {\n                    def descriptor = getIndexedPropertyReferenceDescriptor propName\n                    if (descriptor) { // indexed property\n                        metaProperty = obj.metaClass.getMetaProperty descriptor.propertyName\n                        if (metaProperty && isOkToBind(metaProperty, whiteList, blackList)) {\n                            def val = source.getPropertyValue key\n                            processIndexedProperty obj, metaProperty, descriptor, val, source, listener, errors\n                        }\n                    } else if (propName.startsWith('_') && propName.length() > 1) { // boolean special handling\n                        def restOfPropertyName = propName[1..-1]\n                        if (!source.containsProperty(restOfPropertyName)) {\n                            metaProperty = obj.metaClass.getMetaProperty restOfPropertyName\n                            if (metaProperty && isOkToBind(metaProperty, whiteList, blackList)) {\n                                if ((Boolean == metaProperty.type || Boolean.TYPE == metaProperty.type)) {\n                                    bindProperty obj, source, metaProperty, false, listener, errors\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    protected boolean isOkToBind(String propName, List whiteList, List blackList) {\n        'class' != propName && 'classLoader' != propName && 'protectionDomain' != propName && 'metaClass' != propName && !blackList?.contains(propName) && (!whiteList || whiteList.contains(propName) || whiteList.find { it -> it?.toString()?.startsWith(propName + '.')})\n    }\n\n    protected boolean isOkToBind(MetaProperty property, List whitelist, List blacklist) {\n        isOkToBind(property.name, whitelist, blacklist) &&\n                (property.type != null) &&\n                !Modifier.isStatic(property.modifiers) &&\n                !(ClassLoader.class.isAssignableFrom(property.type) || ProtectionDomain.class.isAssignableFrom(property.type))\n    }\n\n    protected IndexedPropertyReferenceDescriptor getIndexedPropertyReferenceDescriptor(propName) {\n        IndexedPropertyReferenceDescriptor descriptor\n        def matcher = propName =~ INDEXED_PROPERTY_REGEX\n        if (matcher) {\n            def indexedPropertyName = matcher.group(1)\n            def index = matcher.group(2)\n            if (index.size() > 2 && ((index.startsWith(\"'\") && index.endsWith(\"'\")) || (index.startsWith('\"') && index.endsWith('\"')))) {\n                index = index[1..-2]\n            }\n            descriptor = new IndexedPropertyReferenceDescriptor(propertyName: indexedPropertyName, index: index)\n        }\n        descriptor\n    }\n\n    protected processProperty(obj, MetaProperty metaProperty, val, DataBindingSource source, DataBindingListener listener, errors) {\n        def propName = metaProperty.name\n        def propertyType = metaProperty.type\n        if (structuredEditors.containsKey(propertyType) && ('struct' == val || 'date.struct' == val)) {\n            def structuredEditor = structuredEditors[propertyType]\n            val = structuredEditor.getPropertyValue obj, propName, source\n        }\n        bindProperty obj, source, metaProperty, val, listener, errors\n    }\n\n    protected SimpleMapDataBindingSource splitIndexedStruct(IndexedPropertyReferenceDescriptor indexedPropertyReferenceDescriptor, DataBindingSource source) {\n        def propName = indexedPropertyReferenceDescriptor.propertyName\n        Map structValues = new HashMap()\n        String prefix = indexedPropertyReferenceDescriptor.toString()\n        for (String propertyName: source.propertyNames) {\n            if (propertyName.startsWith(prefix)) {\n                String deIndexedPropertyName = propName\n                String[] parts = propertyName.split('_')\n                if (parts.length > 1) {\n                    deIndexedPropertyName = deIndexedPropertyName + '_' + parts[1]\n                }\n                structValues.put(deIndexedPropertyName, source.getPropertyValue(propertyName))\n            }\n        }\n        new SimpleMapDataBindingSource(structValues)\n    }\n\n    protected processIndexedProperty(obj, MetaProperty metaProperty, IndexedPropertyReferenceDescriptor indexedPropertyReferenceDescriptor,\n        val, DataBindingSource source, DataBindingListener listener, errors) {\n\n        def propName = indexedPropertyReferenceDescriptor.propertyName\n        def propertyType = metaProperty.type\n        Class genericType = getReferencedTypeForCollection(propName, obj)\n\n        if (structuredEditors.containsKey(genericType) && ('struct' == val || 'date.struct' == val)) {\n            def structuredEditor = structuredEditors[genericType]\n            val = structuredEditor.getPropertyValue obj, propName, splitIndexedStruct(indexedPropertyReferenceDescriptor, source)\n        }\n\n        if (propertyType.isArray()) {\n            def index = Integer.parseInt(indexedPropertyReferenceDescriptor.index)\n            def array = initializeArray(obj, propName, propertyType.componentType, index)\n            if (array != null) {\n                addElementToArrayAt array, index, val\n            }\n        } else if (Collection.isAssignableFrom(propertyType)) {\n            def index = Integer.parseInt(indexedPropertyReferenceDescriptor.index)\n            Collection collectionInstance = initializeCollection obj, propName, propertyType\n            def indexedInstance = null\n            if(!(Set.isAssignableFrom(propertyType))) {\n                indexedInstance = collectionInstance[index]\n            }\n            if (indexedInstance == null) {\n                if (genericType) {\n                    if (genericType.isAssignableFrom(val?.getClass())) {\n                        addElementToCollectionAt obj, propName, collectionInstance, index, val\n                    } else if (isBasicType(genericType)) {\n                        addElementToCollectionAt obj, propName, collectionInstance, index, convert(genericType, val)\n                    } else if (val instanceof Map){\n                        indexedInstance = genericType.newInstance()\n                        bind indexedInstance, new SimpleMapDataBindingSource(val), listener\n                        addElementToCollectionAt obj, propName, collectionInstance, index, indexedInstance\n                    } else if (val instanceof DataBindingSource) {\n                        indexedInstance = genericType.newInstance()\n                        bind indexedInstance, val, listener\n                        addElementToCollectionAt obj, propName, collectionInstance, index, indexedInstance\n                    } else if(genericType.isEnum() && val instanceof CharSequence) {\n                        def enumValue = convertStringToEnum(genericType, val.toString())\n                        addElementToCollectionAt obj, propName, collectionInstance, index, enumValue\n                    } else {\n                        addElementToCollectionAt obj, propName, collectionInstance, index, convert(genericType, val)\n                    }\n                } else {\n                    addElementToCollectionAt obj, propName, collectionInstance, index, val\n                }\n            } else {\n                if (val instanceof Map) {\n                    bind indexedInstance, new SimpleMapDataBindingSource(val), listener\n                } else if (val instanceof DataBindingSource) {\n                    bind indexedInstance, val, listener\n                } else if (val == null && indexedInstance != null) {\n                    addElementToCollectionAt obj, propName, collectionInstance, index, null\n                }\n            }\n        } else if (Map.isAssignableFrom(propertyType)) {\n            Map mapInstance = initializeMap obj, propName\n            if (mapInstance.size() < autoGrowCollectionLimit || mapInstance.containsKey(indexedPropertyReferenceDescriptor.index)) {\n                def referencedType = getReferencedTypeForCollection propName, obj\n                if (referencedType != null) {\n                    if(val instanceof Map) {\n                        mapInstance[indexedPropertyReferenceDescriptor.index] = referencedType.newInstance(val)\n                    } else {\n                        mapInstance[indexedPropertyReferenceDescriptor.index] = convert(referencedType, val)\n                    }\n                } else {\n                    mapInstance[indexedPropertyReferenceDescriptor.index] = val\n                }\n            }\n        }\n    }\n\n        \n    @CompileStatic(TypeCheckingMode.SKIP)\n    protected initializeArray(obj, String propertyName, Class arrayType, int index) {\n        Object[] array = obj[propertyName]\n        if (array == null && index < autoGrowCollectionLimit) {\n            array = Array.newInstance(arrayType, index + 1)\n            obj[propertyName] = array\n        } else if (array != null && array.length <= index && index < autoGrowCollectionLimit) {\n            def newArray = Array.newInstance(arrayType, index + 1)\n            System.arraycopy(array, 0, newArray, 0, array.length)\n            array = newArray\n            obj[propertyName] = newArray\n        }\n        array\n    }\n\n    protected boolean isBasicType(Class c) {\n        BASIC_TYPES.contains(c) || c.isPrimitive()\n    }\n    \n    \n    protected Class<?> getReferencedTypeForCollectionInClass(String propertyName, Class clazz) {\n        Class referencedType\n        def field = getField(clazz, propertyName)\n        if(field) {\n            def genericType = field.genericType\n            if (genericType instanceof ParameterizedType) {\n                ParameterizedType pt = (ParameterizedType)genericType\n                Class rawType = pt.getRawType()\n                if(Map.isAssignableFrom(rawType)) {\n                    referencedType = pt.getActualTypeArguments()[1]\n                } else {\n                    referencedType = pt.getActualTypeArguments()[0]\n                }\n            }\n        }\n        referencedType\n    }\n\n    protected Class<?> getReferencedTypeForCollection(String propertyName, Object obj) {\n        getReferencedTypeForCollectionInClass propertyName, obj.getClass()\n    }\n\n    protected boolean isOkToAddElementAt(Collection collection, int index) {\n        boolean isOk\n        if (collection instanceof Set) {\n            isOk = collection.size() < autoGrowCollectionLimit\n        } else {\n            isOk = (index < autoGrowCollectionLimit || index < collection.size())\n        }\n        return isOk\n    }\n\n    @CompileStatic(TypeCheckingMode.SKIP)\n    protected addElementToCollectionAt(obj, String propertyName, Collection collection, index, val) {\n        if (isOkToAddElementAt(collection, index)) {\n            if (collection instanceof Set) {\n                collection.add val\n            } else {\n                collection[index] = val\n            }\n        }\n    }\n\n    @CompileStatic(TypeCheckingMode.SKIP)\n    protected addElementToArrayAt(array, index, val) {\n        if (array.length > index) {\n            array[index] = convert(array.class.componentType, val)\n        }\n    }\n\n    protected Map initializeMap(obj, String propertyName) {\n        if (obj[propertyName] == null) {\n            obj[propertyName] = [:]\n        }\n        return (Map)obj[propertyName]\n    }\n\n    protected Collection initializeCollection(obj, String propertyName, Class type, boolean reuseExistingCollectionIfExists = true) {\n        def val = null\n        if(reuseExistingCollectionIfExists) {\n            val = obj[propertyName]\n        }\n        if (val == null) {\n            val = getDefaultCollectionInstanceForType(type)\n            obj[propertyName] = val\n        }\n        return (Collection)val\n    }\n    \n    protected getDefaultCollectionInstanceForType(Class type) {\n        def val\n        if (List.isAssignableFrom(type)) {\n            val = []\n        } else if (SortedSet.isAssignableFrom(type)) {\n            val = new TreeSet()\n        } else if (LinkedHashSet.isAssignableFrom(type)) {\n            val = new LinkedHashSet()\n        } else if (Collection.isAssignableFrom(type)) {\n            val = new HashSet()\n        }\n        val\n    }\n\n    /**\n     * Get a ValueConverter for field\n     *\n     * @param field The field to retrieve a converter for\n     * @param formattingValue The format that the converter will use\n     * @return a ValueConverter for field which uses formattingValue for its format\n     * @see BindingFormat\n     */\n    protected ValueConverter getFormattedConverter(Field field, String formattingValue) {\n        def converter\n        def formattedConverter = formattedValueConversionHelpers[field.type]\n        if (formattedConverter) {\n            converter = { SimpleMapDataBindingSource source ->\n                def value = preprocessValue(source.getPropertyValue(field.name))\n                def convertedValue = null\n                if(value != null) {\n                    convertedValue = formattedConverter.convert (value, formattingValue)\n                }\n                convertedValue\n            } as ValueConverter\n        }\n        converter\n    }\n\n    protected Field getField(Class clazz, String fieldName) {\n        Field field = null\n        try {\n            field = clazz.getDeclaredField(fieldName)\n        } catch (NoSuchFieldException nsfe) {\n            def superClass = clazz.getSuperclass()\n            if(superClass != Object) {\n                field = getField(superClass, fieldName)\n            }\n        }\n        return field\n    }\n\n    protected ValueConverter getValueConverterForField(obj, String propName) {\n        def converter\n        try {\n            def field = getField(obj.getClass(), propName)\n            if (field) {\n                def annotation = field.getAnnotation(BindUsing)\n                if (annotation) {\n                    def valueClass = getValueOfBindUsing(annotation)\n                    if (Closure.isAssignableFrom(valueClass)) {\n                        Closure closure = (Closure)valueClass.newInstance(null, null)\n                        converter = new ClosureValueConverter(converterClosure: closure.curry(obj), targetType: field.type)\n                    }\n                } else {\n                    annotation = field.getAnnotation(BindingFormat)\n                    if (annotation) {\n                        converter = getFormattedConverter field, getFormatString(annotation)\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n        converter\n    }\n    \n    /**\n     * @param annotation An instance of grails.databinding.BindingUsing or org.grails.databinding.BindingUsing\n     * @return the value Class of the annotation\n     */\n    protected Class getValueOfBindUsing(Annotation annotation) {\n        assert annotation instanceof BindUsing\n        def value\n        if(annotation instanceof BindUsing) {\n            value = ((BindUsing)annotation).value()\n        }\n        value\n    }\n    \n    /**\n     * @param annotation An instance of grails.databinding.BindingFormat or org.grails.databinding.BindingFormat\n     * @return the value String of the annotation\n     */\n    protected String getFormatString(Annotation annotation) {\n        assert annotation instanceof BindingFormat\n        String formatString\n        if(annotation instanceof BindingFormat) {\n            formatString = ((BindingFormat)annotation).value()\n        }\n        formatString\n    }\n\n    protected ValueConverter getValueConverterForClass(obj, String propName) {\n        def converter\n        def objClass = obj.getClass()\n        def annotation = objClass.getAnnotation(BindUsing)\n        if (annotation) {\n            def valueClass = getValueOfBindUsing(annotation)\n            if (BindingHelper.isAssignableFrom(valueClass)) {\n                BindingHelper dataConverter = (BindingHelper)valueClass.newInstance()\n                converter = new ClosureValueConverter(converterClosure: { DataBindingSource it -> dataConverter.getPropertyValue(obj, propName, it) })\n            }\n        }\n        converter\n    }\n\n    protected ValueConverter getValueConverter(obj, String propName) {\n        def converter = getValueConverterForField obj, propName\n        if (!converter) {\n            converter = getValueConverterForClass obj, propName\n        }\n        converter\n    }\n\n    @CompileStatic(TypeCheckingMode.SKIP)\n    protected convertStringToEnum(Class<? extends Enum> enumClass, String value) {\n        try {\n            enumClass.valueOf(value)\n        } catch (IllegalArgumentException iae) {}\n    }\n    \n    protected preprocessValue(propertyValue) {\n        propertyValue\n    }\n\n    protected setPropertyValue(obj, DataBindingSource source, MetaProperty metaProperty, propertyValue, DataBindingListener listener) {\n        def convertCollectionElements = false\n        if(propertyValue instanceof Collection) {\n            def referencedType = getReferencedTypeForCollection(metaProperty.name, obj)\n            if(referencedType) {\n                def nonAssignableValue = propertyValue.find { it != null && !(referencedType.isAssignableFrom(it.getClass()))}\n                if(nonAssignableValue != null) {\n                    convertCollectionElements = true\n                }\n            }\n        }\n        \n        setPropertyValue obj, source, metaProperty, propertyValue, listener, convertCollectionElements\n    }\n    \n    protected setPropertyValue(obj, DataBindingSource source, MetaProperty metaProperty, propertyValue, DataBindingListener listener, boolean convertCollectionElements) {\n        def propName = metaProperty.name\n        def propertyType\n        def propertyGetter\n        if (metaProperty instanceof MetaBeanProperty) {\n            def mbp = (MetaBeanProperty)metaProperty\n            propertyType = mbp.getter?.returnType ?: mbp.field?.type\n            propertyGetter = mbp.getter\n        }\n        if (propertyType == null || propertyType == Object) {\n            propertyType = metaProperty.type\n            if(propertyType == null || propertyType == Object) {\n                propertyType = getField(obj.getClass(), propName)?.type ?: Object\n            }\n        }\n        if (propertyValue == null || propertyType == Object || propertyType.isAssignableFrom(propertyValue.getClass())) {\n            if (convertCollectionElements && ((!(propertyValue instanceof Range) && propertyValue instanceof Collection && Collection.isAssignableFrom(propertyType) && propertyGetter))) {\n                addElementsToCollection(obj, propName, propertyValue, true)\n            } else {\n                obj[propName] = propertyValue\n            }\n        } else if (propertyValue instanceof List &&\n                  Set.isAssignableFrom(propertyType) &&\n                  !SortedSet.isAssignableFrom(propertyType)) {\n            addElementsToCollection(obj, propName, propertyValue, true)\n        } else {\n            if (propertyValue instanceof Map) {\n                if (Collection.isAssignableFrom(propertyType) &&\n                   propertyValue.size() == 1 &&\n                   ((Map)propertyValue)[propertyValue.keySet()[0]] instanceof List) {\n                    def key = propertyValue.keySet()[0]\n                    List list = (List)((Map)propertyValue)[key]\n                    addElementsToCollection(obj, propName, list)\n                } else {\n                    if (obj[propName] == null) {\n                        initializeProperty(obj, propName, propertyType, source)\n                    }\n                    bind obj[propName], new SimpleMapDataBindingSource(propertyValue), listener\n                }\n            } else if (propertyValue instanceof DataBindingSource) {\n                if (Collection.isAssignableFrom(propertyType) &&\n                   propertyValue.size() == 1 &&\n                   ((Map)propertyValue)[propertyValue.getPropertyNames()[0]] instanceof List) {\n                    def key = propertyValue.getPropertyNames()[0]\n                    List list = (List)((Map)propertyValue)[key]\n                    addElementsToCollection(obj, propName, list)\n                } else {\n                    if (obj[propName] == null) {\n                        initializeProperty(obj, propName, propertyType, source)\n                    }\n                    bind obj[propName], propertyValue, listener\n                }\n            } else if(Collection.isAssignableFrom(propertyType) && propertyValue instanceof String) {\n                addElementToCollection obj, propName, propertyType, propertyValue, true\n            } else if(Collection.isAssignableFrom(propertyType) && propertyValue instanceof Number) {\n                addElementToCollection obj, propName, propertyType, propertyValue, true\n            } else if(Collection.isAssignableFrom(propertyType) && propertyValue.getClass().isArray()) {\n                addElementsToCollection obj, propName, propertyValue as Collection, true\n            } else {\n                obj[propName] = convert(propertyType, propertyValue)\n            }\n        }\n    }\n    protected addElementToCollection(obj, String propName, Class propertyType, propertyValue, boolean clearCollection) {\n        boolean isSet = false\n        def coll = initializeCollection obj, propName, propertyType\n        if (coll != null) {\n            if (clearCollection) {\n                coll.clear()\n            }\n            def referencedType = getReferencedTypeForCollection propName, obj\n            if (referencedType != null) {\n                if (propertyValue == null || referencedType.isAssignableFrom(propertyValue.getClass())) {\n                    coll << propertyValue\n                    isSet = true\n                } else {\n                    coll << convert(referencedType, propertyValue)\n                    isSet = true\n                }\n            }\n        }\n        isSet\n    }\n\n    protected bindProperty(obj, DataBindingSource source, MetaProperty metaProperty, propertyValue, DataBindingListener listener, errors) {\n        def propName = metaProperty.name\n        if (listener == null || listener.beforeBinding(obj, propName, propertyValue, errors) != false) {\n            try {\n                setPropertyValue obj, source, metaProperty, propertyValue, listener\n            } catch (Exception e) {\n                addBindingError(obj, propName, propertyValue, e, listener, errors)\n            }\n        } else if (listener != null && propertyValue instanceof Map && obj[propName] != null) {\n            bind obj[propName], new SimpleMapDataBindingSource(propertyValue)\n        }\n        listener?.afterBinding obj, propName, errors\n    }\n\n    protected addBindingError(obj, String propName, propertyValue, Exception e, DataBindingListener listener, errors) {\n        if (listener) {\n            def error = new SimpleBindingError(obj, propName, propertyValue, e.cause ?: e)\n            listener.bindingError error, errors\n        }\n    }\n\n    private void addElementsToCollection(obj, String collectionPropertyName, Collection collection, boolean removeExistingElements = false) {\n        Class propertyType = obj.metaClass.getMetaProperty(collectionPropertyName).type\n        def referencedType = getReferencedTypeForCollection(collectionPropertyName, obj)\n        def coll = initializeCollection(obj, collectionPropertyName, propertyType, !removeExistingElements)\n        if (removeExistingElements == true) {\n            coll.clear()\n        }\n        for(element in collection) {\n            if (element == null || referencedType == null || referencedType.isAssignableFrom(element.getClass())) {\n                coll << element\n            } else {\n                coll << convert(referencedType, element)\n            }\n        }\n        obj[collectionPropertyName] = coll\n    }\n\n    protected initializeProperty(obj, String propName, Class propertyType, DataBindingSource source) {\n        def initializer = getPropertyInitializer(obj,propName)\n        if(initializer){\n            obj[propName] = initializer.initialize()\n        }\n        else{\n            obj[propName] = propertyType.newInstance()\n        }        \n    }\n    \n    protected ValueInitializer getPropertyInitializer(obj, String propName){\n        def initializer = getValueInitializerForField obj, propName\n        initializer\n    }\n\n    protected ValueInitializer getValueInitializerForField(obj, String propName) {\n        def initializer\n        try {\n            def field = getField(obj.getClass(), propName)\n            if (field) {\n                def annotation = field.getAnnotation(BindInitializer)\n                if (annotation) {\n                    def valueClass = getValueOfBindInitializer(annotation)\n                    if (Closure.isAssignableFrom(valueClass)) {\n                        Closure closure = (Closure)valueClass.newInstance(null, null)\n                        initializer = new ClosureValueInitializer(initializerClosure: closure.curry(obj), targetType: field.type)\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n        initializer\n    }\n    /**\n     * @param annotation An instance of grails.databinding.BindInitializer \n     * @return the value Class of the annotation\n     */\n    protected Class getValueOfBindInitializer(Annotation annotation) {\n        assert annotation instanceof BindInitializer\n        def value\n        if(annotation instanceof BindInitializer) {\n            value = ((BindInitializer)annotation).value()\n        }\n        value\n    }\n    \n    protected convert(Class typeToConvertTo, value) {\n        if (value == null || typeToConvertTo.isAssignableFrom(value?.getClass())) {\n            return value\n        }\n        if (conversionHelpers.containsKey(typeToConvertTo)) {\n            ValueConverter converter = getConverter(typeToConvertTo, value)\n            if (converter) {\n                return converter.convert(value)\n            }\n        }\n        if (conversionService?.canConvert(value.getClass(), typeToConvertTo)) {\n            return conversionService.convert(value, typeToConvertTo)\n        }\n        if (Collection.isAssignableFrom(typeToConvertTo) && value instanceof String[]) {\n            if (Set == typeToConvertTo) {\n                return value as Set\n            }\n            if (List == typeToConvertTo) {\n                return value as List\n            }\n        } else if (typeToConvertTo.isPrimitive() || typeToConvertTo.isArray()) {\n            return value\n        } else if (value instanceof Map) {\n            def obj = typeToConvertTo.newInstance()\n            bind obj, new SimpleMapDataBindingSource(value)\n            return obj\n        } else if (Enum.isAssignableFrom(typeToConvertTo) && value instanceof String) {\n            return convertStringToEnum(typeToConvertTo, value)\n        }\n        typeToConvertTo.newInstance value\n    }\n\n    protected ValueConverter getConverter(Class typeToConvertTo, value) {\n        def converters = conversionHelpers.get(typeToConvertTo)\n        converters?.find { ValueConverter c -> c.canConvert(value) }\n    }\n}\n", "/*\n * Copyright 2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage grails.databinding;\n\n\n/**\n * StructuredBindingEditors convert structured data in a Map\n * into an object.  Typically a structured editor will pull\n * several values out of the Map that are necessary to initialize\n * the state of the object.\n<pre>\nclass Address {\n    String state\n    String city\n}\nclass StructuredAddressBindingEditor implements StructuredBindingEditor {\n\n    public Object getPropertyValue(Object obj, String propertyName, Map<String, Object> source) {\n        def address = new Address()\n\n        address.state = source[propertyName + '_someState']\n        address.city = source[propertyName + '_someCity']\n\n        address\n    }\n}\n\ndef binder = new SimpleDataBinder()\nbinder.registerStructuredEditor Address, new StructuredAddressBindingEditor()\ndef resident = new Resident()\ndef bindingSource = [:]\nbindingSource.name = 'Scott'\nbindingSource.homeAddress_someCity = \"Scott's Home City\"\nbindingSource.homeAddress_someState = \"Scott's Home State\"\nbindingSource.workAddress_someState = \"Scott's Work State\"\nbindingSource.workAddress = 'struct'\nbindingSource.homeAddress = 'struct'\n\nbinder.bind resident, bindingSource\n\nresident.name == 'Scott'\nresident.homeAddress\nassert resident.homeAddress.city == \"Scott's Home City\"\nassert resident.homeAddress.state == \"Scott's Home State\"\nassert resident.workAddress\nassert resident.workAddress.state == \"Scott's Work State\"\nassert resident.workAddress.city == null\n</pre>\n *\n * @author Jeff Brown\n * @since 3.0\n * @see SimpleDataBinder#registerStructuredEditor(Class, StructuredBindingEditor)\n */\npublic interface StructuredBindingEditor<T> extends BindingHelper<T> {\n    /**\n     * The value returned from this method will be bound to\n     * the property specified by propertyName.\n     *\n     * @param obj The object that data binding is being applied to\n     * @param propertyName The name of the property data binding is being applied to\n     * @param source The source containing all of the values being bound to this object\n     * @return The value which should be bound to propertyName\n     */\n    T getPropertyValue(Object obj, String propertyName, DataBindingSource source);\n}\n", "/*\n * Copyright 2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage grails.databinding.converters;\n\n/**\n * Classes which implement this interface may participate\n * in the data binding process as formatted value converters.\n<pre>\nimport org.grails.databinding.converters.FormattedValueConverter\n\nclass FormattedStringValueConverter implements FormattedValueConverter {\n    def convert(value, String format) {\n        if('UPPERCASE' == format) {\n            value = value.toUpperCase()\n        } else if('LOWERCASE' == format) {\n            value = value.toLowerCase()\n        }\n        value\n    }\n\n    Class getTargetType() {\n        // specifies the type to which this converter may be applied\n        String\n    }\n}\n</pre>\n *\n * @author Jeff Brown\n * @since 3.0\n * @see grails.databinding.BindingFormat\n * @see org.grails.databinding.SimpleDataBinder\n * @see org.grails.databinding.SimpleDataBinder#registerFormattedValueConverter(FormattedValueConverter)\n */\npublic interface FormattedValueConverter {\n    /**\n     * Return a formatted value\n     *\n     * @param value The value to be formatted\n     * @param format The format String\n     * @return the formatted value\n     */\n    Object convert(Object value, String format);\n\n    /**\n     * @return the output type of this converter\n     */\n    Class<?> getTargetType();\n}\n", "/*\n * Copyright 2009 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.grails.buffer;\n\nimport groovy.lang.GroovyObject;\nimport groovy.lang.MetaClass;\nimport groovy.lang.Writable;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Writer;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.grails.charsequences.CharSequences;\nimport org.grails.encoder.EncodedAppender;\nimport org.grails.encoder.EncodedAppenderFactory;\nimport org.grails.encoder.EncodedAppenderWriter;\nimport org.grails.encoder.EncodedAppenderWriterFactory;\nimport org.grails.encoder.Encoder;\nimport org.grails.encoder.EncodingStateRegistry;\nimport org.grails.encoder.StreamingEncoder;\nimport org.grails.encoder.StreamingEncoderWriter;\nimport org.codehaus.groovy.runtime.GStringImpl;\nimport org.codehaus.groovy.runtime.InvokerHelper;\nimport org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;\n\n/**\n * PrintWriter implementation that doesn't have synchronization. null object\n * references are ignored in print methods (nothing gets printed)\n *\n * @author Lari Hotari, Sagire Software Oy\n */\npublic class GrailsPrintWriter extends Writer implements GrailsWrappedWriter, EncodedAppenderWriterFactory, GroovyObject {\n    protected static final Log LOG = LogFactory.getLog(GrailsPrintWriter.class);\n    protected static final char CRLF[] = { '\\r', '\\n' };\n    protected boolean trouble = false;\n    protected Writer out;\n    protected boolean allowUnwrappingOut = true;\n    protected boolean usageFlag = false;\n    protected Writer streamCharBufferTarget = null;\n    protected Writer previousOut = null;\n\n    public GrailsPrintWriter(Writer out) {\n        this.metaClass = InvokerHelper.getMetaClass(this.getClass());\n        setOut(out);\n    }\n\n    public boolean isAllowUnwrappingOut() {\n        return allowUnwrappingOut;\n    }\n\n    public Writer unwrap() {\n        if (isAllowUnwrappingOut()) {\n            return getOut();\n        }\n        return this;\n    }\n\n    public boolean isDestinationActivated() {\n        return out != null;\n    }\n\n    public Writer getOut() {\n        return out;\n    }\n\n    public void setOut(Writer newOut) {\n        this.out = unwrapWriter(newOut);\n        this.lock = this.out != null ? this.out : this;\n        this.streamCharBufferTarget = null;\n        this.previousOut = null;\n    }\n\n    protected Writer unwrapWriter(Writer writer) {\n        if (writer instanceof GrailsWrappedWriter ) {\n            return ((GrailsWrappedWriter)writer).unwrap();\n        }\n        return writer;\n    }\n\n    /**\n     * Provides Groovy << left shift operator, but intercepts call to make sure\n     * nulls are converted to \"\" strings\n     *\n     * @param obj The value\n     * @return Returns this object\n     * @throws IOException\n     */\n    public GrailsPrintWriter leftShift(Object obj) throws IOException {\n        if (trouble || obj == null) {\n            usageFlag = true;\n            return this;\n        }\n\n        Class<?> clazz = obj.getClass();\n        if (clazz == String.class) {\n            write((String)obj);\n        }\n        else if (clazz == StreamCharBuffer.class) {\n            write((StreamCharBuffer)obj);\n        }\n        else if (clazz == GStringImpl.class) {\n            write((Writable)obj);\n        }\n        else if (obj instanceof Writable) {\n            write((Writable)obj);\n        }\n        else if (obj instanceof CharSequence) {\n            try {\n                usageFlag = true;\n                CharSequences.writeCharSequence(getOut(), (CharSequence) obj);\n            }\n            catch (IOException e) {\n                handleIOException(e);\n            }\n        }\n        else {        \n            InvokerHelper.write(this, obj);\n        }\n        return this;\n    }\n\n    public GrailsPrintWriter plus(Object value) throws IOException {\n        usageFlag = true;\n        return leftShift(value);\n    }\n\n    /**\n     * Flush the stream if it's not closed and check its error state. Errors are\n     * cumulative; once the stream encounters an error, this routine will return\n     * true on all successive calls.\n     *\n     * @return true if the print stream has encountered an error, either on the\n     *         underlying output stream or during a format conversion.\n     */\n    public boolean checkError() {\n        return trouble;\n    }\n\n    public void setError() {\n        trouble = true;\n    }\n\n    /**\n     * Flush the stream.\n     *\n     * @see #checkError()\n     */\n    @Override\n    public synchronized void flush() {\n        if (trouble) {\n            return;\n        }\n\n        if (isDestinationActivated()) {\n            try {\n                getOut().flush();\n            }\n            catch (IOException e) {\n                handleIOException(e);\n            }\n        }\n    }\n\n    boolean isTrouble() {\n        return trouble;\n    }\n\n    void handleIOException(IOException e) {\n        if (trouble) {\n            return;\n        }\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"I/O exception in GrailsPrintWriter: \" + e.getMessage(), e);\n        }\n        trouble = true;\n        setError();\n    }\n\n    /**\n     * Print an object. The string produced by the <code>{@link\n     * java.lang.String#valueOf(Object)}</code> method is translated into bytes\n     * according to the platform's default character encoding, and these bytes\n     * are written in exactly the manner of the <code>{@link #write(int)}</code>\n     * method.\n     *\n     * @param obj The <code>Object</code> to be printed\n     * @see java.lang.Object#toString()\n     */\n    public void print(final Object obj) {\n        if (trouble || obj == null) {\n            usageFlag = true;\n            return;\n        }\n\n        Class<?> clazz = obj.getClass();\n        if (clazz == String.class) {\n            write((String)obj);\n        }\n        else if (clazz == StreamCharBuffer.class) {\n            write((StreamCharBuffer)obj);\n        }\n        else if (clazz == GStringImpl.class) {\n            write((Writable)obj);\n        }\n        else if (obj instanceof Writable) {\n            write((Writable)obj);\n        }\n        else if (obj instanceof CharSequence) {\n            try {\n                usageFlag = true;\n                CharSequences.writeCharSequence(getOut(), (CharSequence)obj);\n            }\n            catch (IOException e) {\n                handleIOException(e);\n            }\n        }\n        else {\n            write(String.valueOf(obj));\n        }\n    }\n\n    /**\n     * Print a string. If the argument is <code>null</code> then the string\n     * <code>\"\"</code> is printed. Otherwise, the string's characters are\n     * converted into bytes according to the platform's default character\n     * encoding, and these bytes are written in exactly the manner of the\n     * <code>{@link #write(int)}</code> method.\n     *\n     * @param s The <code>String</code> to be printed\n     */\n    public void print(final String s) {\n        if (s == null) {\n            usageFlag = true;\n            return;\n        }\n        write(s);\n    }\n\n    /**\n     * Writes a string. If the argument is <code>null</code> then the string\n     * <code>\"\"</code> is printed.\n     *\n     * @param s The <code>String</code> to be printed\n     */\n    @Override\n    public void write(final String s) {\n        usageFlag = true;\n        if (trouble || s == null) {\n            return;\n        }\n\n        try {\n            getOut().write(s);\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n    }\n\n    /**\n     * Write a single character.\n     *\n     * @param c int specifying a character to be written.\n     */\n    @Override\n    public void write(final int c) {\n        usageFlag = true;\n        if (trouble)\n            return;\n\n        try {\n            getOut().write(c);\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n    }\n\n    /**\n     * Write a portion of an array of characters.\n     *\n     * @param buf Array of characters\n     * @param off Offset from which to start writing characters\n     * @param len Number of characters to write\n     */\n    @Override\n    public void write(final char buf[], final int off, final int len) {\n        usageFlag = true;\n        if (trouble || buf == null || len == 0)\n            return;\n        try {\n            getOut().write(buf, off, len);\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n    }\n\n    /**\n     * Write a portion of a string.\n     *\n     * @param s A String\n     * @param off Offset from which to start writing characters\n     * @param len Number of characters to write\n     */\n    @Override\n    public void write(final String s, final int off, final int len) {\n        usageFlag = true;\n        if (trouble || s == null || s.length() == 0)\n            return;\n\n        try {\n            getOut().write(s, off, len);\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n    }\n\n    @Override\n    public void write(final char buf[]) {\n        write(buf, 0, buf.length);\n    }\n\n    /** delegate methods, not synchronized **/\n\n    public void print(final boolean b) {\n        if (b) {\n            write(\"true\");\n        }\n        else {\n            write(\"false\");\n        }\n    }\n\n    public void print(final char c) {\n        write(c);\n    }\n\n    public void print(final int i) {\n        write(String.valueOf(i));\n    }\n\n    public void print(final long l) {\n        write(String.valueOf(l));\n    }\n\n    public void print(final float f) {\n        write(String.valueOf(f));\n    }\n\n    public void print(final double d) {\n        write(String.valueOf(d));\n    }\n\n    public void print(final char s[]) {\n        write(s);\n    }\n\n    public void println() {\n        usageFlag = true;\n        write(CRLF);\n    }\n\n    public void println(final boolean b) {\n        print(b);\n        println();\n    }\n\n    public void println(final char c) {\n        print(c);\n        println();\n    }\n\n    public void println(final int i) {\n        print(i);\n        println();\n    }\n\n    public void println(final long l) {\n        print(l);\n        println();\n    }\n\n    public void println(final float f) {\n        print(f);\n        println();\n    }\n\n    public void println(final double d) {\n        print(d);\n        println();\n    }\n\n    public void println(final char c[]) {\n        print(c);\n        println();\n    }\n\n    public void println(final String s) {\n        print(s);\n        println();\n    }\n\n    public void println(final Object o) {\n        print(o);\n        println();\n    }\n\n    @Override\n    public GrailsPrintWriter append(final char c) {\n        try {\n            usageFlag = true;\n            getOut().append(c);\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n        return this;\n    }\n\n    @Override\n    public GrailsPrintWriter append(final CharSequence csq, final int start, final int end) {\n        try {\n            usageFlag = true;\n            if (csq == null)\n                appendNullCharSequence();\n            else\n                CharSequences.writeCharSequence(getOut(), csq, start, end);\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n        return this;\n    }\n\n    protected void appendNullCharSequence() throws IOException {\n        getOut().append(null);\n    }\n\n    @Override\n    public GrailsPrintWriter append(final CharSequence csq) {\n        try {\n            usageFlag = true;\n            if (csq == null)\n                appendNullCharSequence();\n            else\n                CharSequences.writeCharSequence(getOut(), csq);\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n        return this;\n    }\n\n    public GrailsPrintWriter append(final Object obj) {\n        print(obj);\n        return this;\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        throw new CloneNotSupportedException();\n    }\n\n    public void write(final StreamCharBuffer otherBuffer) {\n        usageFlag = true;\n        if (trouble)\n            return;\n\n        try {\n            otherBuffer.writeTo(findStreamCharBufferTarget(true));\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n    }\n\n    protected Writer findStreamCharBufferTarget(boolean markUsed) {\n        boolean allowCaching = markUsed;\n\n        Writer currentOut = getOut();\n        if (allowCaching && streamCharBufferTarget != null && previousOut == currentOut) {\n            return streamCharBufferTarget;\n        }\n\n        Writer target = currentOut;\n        while (target instanceof GrailsWrappedWriter) {\n            GrailsWrappedWriter gpr = ((GrailsWrappedWriter)target);\n            if (gpr.isAllowUnwrappingOut()) {\n                if (markUsed) {\n                    gpr.markUsed();\n                }\n                target = gpr.unwrap();\n            }\n            else {\n                break;\n            }\n        }\n\n        Writer result;\n        if (target instanceof StreamCharBuffer.StreamCharBufferWriter) {\n            result = target;\n        }\n        else {\n            result = currentOut;\n        }\n\n        if (allowCaching) {\n            streamCharBufferTarget = result;\n            previousOut = currentOut;\n        }\n\n        return result;\n    }\n\n    public void print(final StreamCharBuffer otherBuffer) {\n        write(otherBuffer);\n    }\n\n    public void append(final StreamCharBuffer otherBuffer) {\n        write(otherBuffer);\n    }\n\n    public void println(final StreamCharBuffer otherBuffer) {\n        write(otherBuffer);\n        println();\n    }\n\n    public GrailsPrintWriter leftShift(final StreamCharBuffer otherBuffer) {\n        if (otherBuffer != null) {\n            write(otherBuffer);\n        }\n        return this;\n    }\n\n    public void write(final Writable writable) {\n        writeWritable(writable);\n    }\n\n    protected void writeWritable(final Writable writable) {\n        if(writable.getClass() == StreamCharBuffer.class) {\n            write((StreamCharBuffer)writable);\n            return;\n        }\n        \n        usageFlag = true;\n        if (trouble)\n            return;\n\n        try {\n            writable.writeTo(getOut());\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n    }\n\n    public void print(final Writable writable) {\n        writeWritable(writable);\n    }\n\n    public GrailsPrintWriter leftShift(final Writable writable) {\n        writeWritable(writable);\n        return this;\n    }\n\n    public void print(final GStringImpl gstring) {\n        writeWritable(gstring);\n    }\n\n    public GrailsPrintWriter leftShift(final GStringImpl gstring) {\n        writeWritable(gstring);\n        return this;\n    }\n\n    public GrailsPrintWriter leftShift(final String string) {\n        print(string);\n        return this;\n    }\n\n    public boolean isUsed() {\n        if (usageFlag) {\n            return true;\n        }\n\n        Writer target = findStreamCharBufferTarget(false);\n        if (target instanceof StreamCharBuffer.StreamCharBufferWriter) {\n            StreamCharBuffer buffer = ((StreamCharBuffer.StreamCharBufferWriter)target).getBuffer();\n            if (!buffer.isEmpty()) {\n                return true;\n            }\n        }\n        return usageFlag;\n    }\n\n    public void setUsed(boolean newUsed) {\n        usageFlag = newUsed;\n    }\n\n    public boolean resetUsed() {\n        boolean prevUsed = usageFlag;\n        usageFlag = false;\n        return prevUsed;\n    }\n\n    @Override\n    public void close() {\n        if (isDestinationActivated()) {\n            try {\n                getOut().close();\n            }\n            catch (IOException e) {\n                handleIOException(e);\n            }\n        }\n    }\n\n    public void markUsed() {\n        setUsed(true);\n    }\n\n    public Object asType(Class<?> clazz) {\n        if (clazz == PrintWriter.class) {\n            return asPrintWriter();\n        }\n        if (clazz == Writer.class) {\n            return this;\n        }\n        return DefaultTypeTransformation.castToType(this, clazz);\n    }\n\n    public PrintWriter asPrintWriter() {\n        return GrailsPrintWriterAdapter.newInstance(this);\n    }\n\n    public Writer getWriterForEncoder(Encoder encoder, EncodingStateRegistry encodingStateRegistry) {\n        Writer target = null;\n        if (getOut() instanceof EncodedAppenderWriterFactory && getOut() != this) {\n            target = getOut();\n        } else {\n            target = findStreamCharBufferTarget(false);\n        }\n        if (target instanceof EncodedAppenderWriterFactory && target != this) {\n            return ((EncodedAppenderWriterFactory)target).getWriterForEncoder(encoder, encodingStateRegistry);\n        } else if (target instanceof EncodedAppenderFactory) {\n            EncodedAppender encodedAppender=((EncodedAppenderFactory)target).getEncodedAppender();\n            if (encodedAppender != null) {\n                return new EncodedAppenderWriter(encodedAppender, encoder, encodingStateRegistry);\n            }\n        }\n        if (target != null) {\n            if (encoder instanceof StreamingEncoder) {\n                return new StreamingEncoderWriter(target, (StreamingEncoder)encoder, encodingStateRegistry);\n            } else {\n                return new CodecPrintWriter(target, encoder, encodingStateRegistry);\n            }\n        } else {\n            return null;\n        }\n    }\n\n    // GroovyObject interface implementation to speed up metaclass operations\n    private transient MetaClass metaClass;\n\n    public Object getProperty(String property) {\n        return getMetaClass().getProperty(this, property);\n    }\n\n    public void setProperty(String property, Object newValue) {\n        getMetaClass().setProperty(this, property, newValue);\n    }\n\n    public Object invokeMethod(String name, Object args) {\n        return getMetaClass().invokeMethod(this, name, args);\n    }\n\n    public MetaClass getMetaClass() {\n        if (metaClass == null) {\n            metaClass = InvokerHelper.getMetaClass(getClass());\n        }\n        return metaClass;\n    }\n\n    public void setMetaClass(MetaClass metaClass) {\n        this.metaClass = metaClass;\n    }\n}\n", "/*\n * Copyright 2009 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.grails.buffer;\n\nimport groovy.lang.GroovyObjectSupport;\nimport groovy.lang.Writable;\n\nimport java.io.EOFException;\nimport java.io.Externalizable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.lang.ref.SoftReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.codehaus.groovy.runtime.DefaultGroovyMethods;\nimport org.codehaus.groovy.runtime.InvokerHelper;\nimport org.codehaus.groovy.runtime.StringGroovyMethods;\nimport org.grails.encoder.AbstractEncodedAppender;\nimport org.grails.encoder.ChainedEncoders;\nimport org.grails.charsequences.CharArrayAccessible;\nimport org.grails.charsequences.CharSequences;\nimport org.grails.encoder.CodecIdentifier;\nimport org.grails.encoder.DefaultCodecIdentifier;\nimport org.grails.encoder.Encodeable;\nimport org.grails.encoder.EncodedAppender;\nimport org.grails.encoder.EncodedAppenderFactory;\nimport org.grails.encoder.EncodedAppenderWriter;\nimport org.grails.encoder.EncodedAppenderWriterFactory;\nimport org.grails.encoder.Encoder;\nimport org.grails.encoder.EncoderAware;\nimport org.grails.encoder.EncodesToWriter;\nimport org.grails.encoder.EncodingState;\nimport org.grails.encoder.EncodingStateImpl;\nimport org.grails.encoder.EncodingStateRegistry;\nimport org.grails.encoder.EncodingStateRegistryLookup;\nimport org.grails.encoder.EncodingStateRegistryLookupHolder;\nimport org.grails.encoder.StreamEncodeable;\nimport org.grails.encoder.StreamingEncoder;\nimport org.grails.encoder.StreamingEncoderWritable;\nimport org.grails.encoder.WriterEncodedAppender;\n\n/**\n * <p>\n * StreamCharBuffer is a multipurpose in-memory buffer that can replace JDK\n * in-memory buffers (StringBuffer, StringBuilder, StringWriter).\n * </p>\n *\n * <p>\n * Grails GSP rendering uses this class as a buffer that is optimized for performance.\n * </p>\n *\n * <p>\n * StreamCharBuffer keeps the buffer in a linked list of \"chunks\". The main\n * difference compared to JDK in-memory buffers (StringBuffer, StringBuilder &\n * StringWriter) is that the buffer can be held in several smaller buffers\n * (\"chunks\" here). In JDK in-memory buffers, the buffer has to be expanded\n * whenever it gets filled up. The old buffer's data is copied to the new one\n * and the old one is discarded. In StreamCharBuffer, there are several ways to\n * prevent unnecessary allocation & copy operations. The StreamCharBuffer\n * contains a linked list of different type of chunks: char arrays,\n * java.lang.String chunks and other StreamCharBuffers as sub chunks. A\n * StringChunk is appended to the linked list whenever a java.lang.String of a\n * length that exceeds the \"stringChunkMinSize\" value is written to the buffer.\n * </p>\n *\n * <p>\n * Grails tag libraries also use a StreamCharBuffer to \"capture\" the output of\n * the taglib and return it to the caller. The buffer can be appended to it's\n * parent buffer directly without extra object generation (like converting to\n * java.lang.String in between).\n *\n * for example this line of code in a taglib would just append the buffer\n * returned from the body closure evaluation to the buffer of the taglib:<br>\n * <code>\n * out << body()\n * </code><br>\n * other example:<br>\n * <code>\n * out << g.render(template: '/some/template', model:[somebean: somebean])\n * </code><br>\n * There's no extra java.lang.String generation overhead.\n *\n * </p>\n *\n * <p>\n * There's a java.io.Writer interface for appending character data to the buffer\n * and a java.io.Reader interface for reading data.\n * </p>\n *\n * <p>\n * Each {@link #getReader()} call will create a new reader instance that keeps\n * it own state.<br>\n * There is a alternative method {@link #getReader(boolean)} for creating the\n * reader. When reader is created by calling getReader(true), the reader will\n * remove already read characters from the buffer. In this mode only a single\n * reader instance is supported.\n * </p>\n *\n * <p>\n * There's also several other options for reading data:<br>\n * {@link #readAsCharArray()} reads the buffer to a char[] array<br>\n * {@link #readAsString()} reads the buffer and wraps the char[] data as a\n * String<br>\n * {@link #writeTo(Writer)} writes the buffer to a java.io.Writer<br>\n * {@link #toCharArray()} returns the buffer as a char[] array, caches the\n * return value internally so that this method can be called several times.<br>\n * {@link #toString()} returns the buffer as a String, caches the return value\n * internally<br>\n * </p>\n *\n * <p>\n * By using the \"connectTo\" method, one can connect the buffer directly to a\n * target java.io.Writer. The internal buffer gets flushed automaticly to the\n * target whenever the buffer gets filled up. See connectTo(Writer).\n * </p>\n *\n * <p>\n * <b>This class is not thread-safe.</b> Object instances of this class are\n * intended to be used by a single Thread. The Reader and Writer interfaces can\n * be open simultaneous and the same Thread can write and read several times.\n * </p>\n *\n * <p>\n * Main operation principle:<br>\n * </p>\n * <p>\n * StreamCharBuffer keeps the buffer in a linked link of \"chunks\".<br>\n * The main difference compared to JDK in-memory buffers (StringBuffer,\n * StringBuilder & StringWriter) is that the buffer can be held in several\n * smaller buffers (\"chunks\" here).<br>\n * In JDK in-memory buffers, the buffer has to be expanded whenever it gets\n * filled up. The old buffer's data is copied to the new one and the old one is\n * discarded.<br>\n * In StreamCharBuffer, there are several ways to prevent unnecessary allocation\n * & copy operations.\n * </p>\n * <p>\n * There can be several different type of chunks: char arrays (\n * {@code CharBufferChunk}), String chunks ({@code StringChunk}) and other\n * StreamCharBuffers as sub chunks ({@code StreamCharBufferSubChunk}).\n * </p>\n * <p>\n * Child StreamCharBuffers can be changed after adding to parent buffer. The\n * flush() method must be called on the child buffer's Writer to notify the\n * parent that the child buffer's content has been changed (used for calculating\n * total size).\n * </p>\n * <p>\n * A StringChunk is appended to the linked list whenever a java.lang.String of a\n * length that exceeds the \"stringChunkMinSize\" value is written to the buffer.\n * </p>\n * <p>\n * If the buffer is in \"connectTo\" mode, any String or char[] that's length is\n * over writeDirectlyToConnectedMinSize gets written directly to the target. The\n * buffer content will get fully flushed to the target before writing the String\n * or char[].\n * </p>\n * <p>\n * There can be several targets \"listening\" the buffer in \"connectTo\" mode. The\n * same content will be written to all targets.\n * <p>\n * <p>\n * Growable chunksize: By default, a newly allocated chunk's size will grow\n * based on the total size of all written chunks.<br>\n * The default growProcent value is 100. If the total size is currently 1024,\n * the newly created chunk will have a internal buffer that's size is 1024.<br>\n * Growable chunksize can be turned off by setting the growProcent to 0.<br>\n * There's a default maximum chunksize of 1MB by default. The minimum size is\n * the initial chunksize size.<br>\n * </p>\n *\n * <p>\n * System properties to change default configuration parameters:<br>\n * <table>\n * <tr>\n * <th>System Property name</th>\n * <th>Description</th>\n * <th>Default value</th>\n * </tr>\n * <tr>\n * <td>streamcharbuffer.chunksize</td>\n * <td>default chunk size - the size the first allocated buffer</td>\n * <td>512</td>\n * </tr>\n * <tr>\n * <td>streamcharbuffer.maxchunksize</td>\n * <td>maximum chunk size - the maximum size of the allocated buffer</td>\n * <td>1048576</td>\n * </tr>\n * <tr>\n * <td>streamcharbuffer.growprocent</td>\n * <td>growing buffer percentage - the newly allocated buffer is defined by\n * total_size * (growpercent/100)</td>\n * <td>100</td>\n * </tr>\n * <tr>\n * <td>streamcharbuffer.subbufferchunkminsize</td>\n * <td>minimum size of child StreamCharBuffer chunk - if the size is smaller,\n * the content is copied to the parent buffer</td>\n * <td>512</td>\n * </tr>\n * <tr>\n * <td>streamcharbuffer.substringchunkminsize</td>\n * <td>minimum size of String chunks - if the size is smaller, the content is\n * copied to the buffer</td>\n * <td>512</td>\n * </tr>\n * <tr>\n * <td>streamcharbuffer.chunkminsize</td>\n * <td>minimum size of chunk that gets written directly to the target in\n * connected mode.</td>\n * <td>256</td>\n * </tr>\n * </table>\n *\n * Configuration values can also be changed for each instance of\n * StreamCharBuffer individually. Default values are defined with System\n * Properties.\n *\n * </p>\n *\n * @author Lari Hotari, Sagire Software Oy\n */\npublic class StreamCharBuffer extends GroovyObjectSupport implements Writable, CharSequence, Externalizable, Encodeable, StreamEncodeable, StreamingEncoderWritable, EncodedAppenderWriterFactory, Cloneable {\n    private static final int EXTERNALIZABLE_VERSION = 2;\n    static final long serialVersionUID = EXTERNALIZABLE_VERSION;\n    private static final Log log=LogFactory.getLog(StreamCharBuffer.class);\n\n    private static final int DEFAULT_CHUNK_SIZE = Integer.getInteger(\"streamcharbuffer.chunksize\", 512);\n    private static final int DEFAULT_MAX_CHUNK_SIZE = Integer.getInteger(\"streamcharbuffer.maxchunksize\", 1024*1024);\n    private static final int DEFAULT_CHUNK_SIZE_GROW_PROCENT = Integer.getInteger(\"streamcharbuffer.growprocent\", 100);\n    private static final int SUB_BUFFERCHUNK_MIN_SIZE = Integer.getInteger(\"streamcharbuffer.subbufferchunkminsize\", 512);\n    private static final int SUB_STRINGCHUNK_MIN_SIZE = Integer.getInteger(\"streamcharbuffer.substringchunkminsize\", 512);\n    private static final int WRITE_DIRECT_MIN_SIZE = Integer.getInteger(\"streamcharbuffer.writedirectminsize\", 1024);\n    private static final int CHUNK_MIN_SIZE = Integer.getInteger(\"streamcharbuffer.chunkminsize\", 256);\n\n    private final int firstChunkSize;\n    private final int growProcent;\n    private final int maxChunkSize;\n    private int subStringChunkMinSize = SUB_STRINGCHUNK_MIN_SIZE;\n    private int subBufferChunkMinSize = SUB_BUFFERCHUNK_MIN_SIZE;\n    private int writeDirectlyToConnectedMinSize = WRITE_DIRECT_MIN_SIZE;\n    private int chunkMinSize = CHUNK_MIN_SIZE;\n\n    private int chunkSize;\n    private int totalChunkSize;\n\n    private final StreamCharBufferWriter writer;\n    private List<ConnectToWriter> connectToWriters;\n    private ConnectedWritersWriter connectedWritersWriter;\n    private Boolean notConnectedToEncodeAwareWriters=null;\n\n    boolean preferSubChunkWhenWritingToOtherBuffer=false;\n\n    private AllocatedBuffer allocBuffer;\n    private AbstractChunk firstChunk;\n    private AbstractChunk lastChunk;\n    private int totalCharsInList;\n    private int totalCharsInDynamicChunks;\n    private int sizeAtLeast;\n    private StreamCharBufferKey bufferKey = new StreamCharBufferKey();\n    private Map<StreamCharBufferKey, StreamCharBufferSubChunk> dynamicChunkMap;\n\n    private Set<SoftReference<StreamCharBufferKey>> parentBuffers;\n    int allocatedBufferIdSequence = 0;\n    int readerCount = 0;\n    boolean hasReaders = false;\n    int bufferChangesCounter = 0;\n\n    boolean notifyParentBuffersEnabled = true;\n    boolean subBuffersEnabled = true;\n\n    public StreamCharBuffer() {\n        this(DEFAULT_CHUNK_SIZE, DEFAULT_CHUNK_SIZE_GROW_PROCENT, DEFAULT_MAX_CHUNK_SIZE);\n    }\n\n    public StreamCharBuffer(int chunkSize) {\n        this(chunkSize, DEFAULT_CHUNK_SIZE_GROW_PROCENT, DEFAULT_MAX_CHUNK_SIZE);\n    }\n\n    public StreamCharBuffer(int chunkSize, int growProcent) {\n        this(chunkSize, growProcent, DEFAULT_MAX_CHUNK_SIZE);\n    }\n\n    public StreamCharBuffer(int chunkSize, int growProcent, int maxChunkSize) {\n        this.firstChunkSize = chunkSize;\n        this.growProcent = growProcent;\n        this.maxChunkSize = maxChunkSize;\n        writer = new StreamCharBufferWriter();\n        reset(true);\n    }\n\n    private class StreamCharBufferKey {\n        StreamCharBuffer getBuffer() { return StreamCharBuffer.this; }\n    }\n\n    public boolean isPreferSubChunkWhenWritingToOtherBuffer() {\n        return preferSubChunkWhenWritingToOtherBuffer;\n    }\n\n    public void setPreferSubChunkWhenWritingToOtherBuffer(boolean prefer) {\n        preferSubChunkWhenWritingToOtherBuffer = prefer;\n        notifyPreferSubChunkEnabled();\n    }\n\n    protected void notifyPreferSubChunkEnabled() {\n        if(isPreferSubChunkWhenWritingToOtherBuffer() && parentBuffers != null && isNotifyParentBuffersEnabled()) {\n            for(StreamCharBuffer parentBuffer : getCurrentParentBuffers()) {\n                if(!parentBuffer.isPreferSubChunkWhenWritingToOtherBuffer()) {\n                    parentBuffer.setPreferSubChunkWhenWritingToOtherBuffer(true);\n                }\n            }\n        }\n    }\n\n    public final void reset() {\n        reset(true);\n    }\n\n    /**\n     * resets the state of this buffer (empties it)\n     *\n     * @param resetChunkSize\n     */\n    public final void reset(boolean resetChunkSize) {\n        markBufferChanged();\n        firstChunk = null;\n        lastChunk = null;\n        totalCharsInList = 0;\n        totalCharsInDynamicChunks = -1;\n        sizeAtLeast = -1;\n        if (resetChunkSize) {\n            chunkSize = firstChunkSize;\n            totalChunkSize = 0;\n        }\n        if (allocBuffer == null) {\n            allocBuffer = new AllocatedBuffer(chunkSize);\n        } else {\n            allocBuffer.clear();\n        }\n        if (dynamicChunkMap == null) {\n            dynamicChunkMap = new HashMap<StreamCharBufferKey, StreamCharBufferSubChunk>();\n        } else {\n            dynamicChunkMap.clear();\n        }\n    }\n\n    /**\n     * Clears the buffer and notifies the parents of this buffer of the change.\n     */\n    public final void clear() {\n        reset();\n        notifyBufferChange();\n    }\n\n    /**\n     * Connect this buffer to a target Writer.\n     *\n     * When the buffer (a chunk) get filled up, it will automaticly write it's content to the Writer\n     *\n     * @param w\n     */\n    public final void connectTo(Writer w) {\n        connectTo(w, true);\n    }\n\n    public final void connectTo(Writer w, boolean autoFlush) {\n        initConnected();\n        connectToWriters.add(new ConnectToWriter(w, autoFlush));\n        initConnectedWritersWriter();\n    }\n\n    public final void encodeInStreamingModeTo(final EncoderAware encoderLookup, final EncodingStateRegistryLookup encodingStateRegistryLookup, boolean autoFlush, final Writer w) {\n        encodeInStreamingModeTo(encoderLookup, encodingStateRegistryLookup, autoFlush, new LazyInitializingWriter() {\n            public Writer getWriter() throws IOException {\n                return w;\n            }\n        });\n    }\n\n    public final void encodeInStreamingModeTo(final EncoderAware encoderLookup, final EncodingStateRegistryLookup encodingStateRegistryLookup, final boolean autoFlush, final LazyInitializingWriter... writers) {\n        LazyInitializingWriter encodingWriterInitializer = createEncodingInitializer(encoderLookup,\n                encodingStateRegistryLookup, writers);\n        connectTo(encodingWriterInitializer, autoFlush);\n    }\n\n    public LazyInitializingWriter createEncodingInitializer(final EncoderAware encoderLookup,\n            final EncodingStateRegistryLookup encodingStateRegistryLookup, final LazyInitializingWriter... writers) {\n        LazyInitializingWriter encodingWriterInitializer=new LazyInitializingMultipleWriter() {\n            Writer lazyWriter;\n\n            public Writer getWriter() throws IOException {\n                return lazyWriter;\n            }\n\n            public LazyInitializingWriter[] initializeMultiple(StreamCharBuffer buffer, boolean autoFlushMode) throws IOException {\n                Encoder encoder = encoderLookup.getEncoder();\n                if (encoder != null) {\n                    EncodingStateRegistry encodingStateRegistry = encodingStateRegistryLookup.lookup();\n                    StreamCharBuffer encodeBuffer=new StreamCharBuffer(chunkSize, growProcent, maxChunkSize);\n                    encodeBuffer.setAllowSubBuffers(false);\n                    lazyWriter=encodeBuffer.getWriterForEncoder(encoder, encodingStateRegistry);\n                    for(LazyInitializingWriter w : writers) {\n                        encodeBuffer.connectTo(w, autoFlushMode);\n                    }\n                    return new LazyInitializingWriter[]{this};\n                } else {\n                    return writers;\n                }\n            }\n        };\n        return encodingWriterInitializer;\n    }\n\n    private void initConnectedWritersWriter() {\n        notConnectedToEncodeAwareWriters = null;\n        connectedWritersWriter = null;\n        setNotifyParentBuffersEnabled(false);\n    }\n\n    private void startUsingConnectedWritersWriter() throws IOException {\n        if (connectedWritersWriter == null) {\n            List<ConnectedWriter> connectedWriters=new ArrayList<ConnectedWriter>();\n\n            for(ConnectToWriter connectToWriter : connectToWriters) {\n                for(Writer writer : connectToWriter.getWriters()) {\n                    Writer target=writer;\n                    if (target instanceof GrailsWrappedWriter) {\n                        target = ((GrailsWrappedWriter)target).unwrap();\n                    }\n                    if (target==null) {\n                        throw new NullPointerException(\"target is null\");\n                    }\n                    connectedWriters.add(new ConnectedWriter(target, connectToWriter.isAutoFlush()));\n                }\n            }\n\n            if (connectedWriters.size() > 1) {\n                connectedWritersWriter = new MultiOutputWriter(connectedWriters);\n            }\n            else {\n                connectedWritersWriter = new SingleOutputWriter(connectedWriters.get(0));\n            }\n        }\n    }\n\n    public final void connectTo(LazyInitializingWriter w) {\n        connectTo(w, true);\n    }\n\n    public final void connectTo(LazyInitializingWriter w, boolean autoFlush) {\n        initConnected();\n        connectToWriters.add(new ConnectToWriter(w, autoFlush));\n        initConnectedWritersWriter();\n    }\n\n    public final void removeConnections() {\n        if (connectToWriters != null) {\n            connectToWriters = null;\n            connectedWritersWriter = null;\n            notConnectedToEncodeAwareWriters = null;\n        }\n    }\n\n    private void initConnected() {\n        if (connectToWriters == null) {\n            connectToWriters = new ArrayList<ConnectToWriter>(2);\n        }\n    }\n\n    public int getSubStringChunkMinSize() {\n        return subStringChunkMinSize;\n    }\n\n    /**\n     * Minimum size for a String to be added as a StringChunk instead of copying content to the char[] buffer of the current StreamCharBufferChunk\n     *\n     * @param size\n     */\n    public void setSubStringChunkMinSize(int size) {\n        subStringChunkMinSize = size;\n    }\n\n    public int getSubBufferChunkMinSize() {\n        return subBufferChunkMinSize;\n    }\n\n    public void setSubBufferChunkMinSize(int size) {\n        subBufferChunkMinSize = size;\n    }\n\n    public int getWriteDirectlyToConnectedMinSize() {\n        return writeDirectlyToConnectedMinSize;\n    }\n\n    /**\n     * Minimum size for a String or char[] to get written directly to connected writer (in \"connectTo\" mode).\n     *\n     * @param size\n     */\n    public void setWriteDirectlyToConnectedMinSize(int size) {\n        writeDirectlyToConnectedMinSize = size;\n    }\n\n    public int getChunkMinSize() {\n        return chunkMinSize;\n    }\n\n    public void setChunkMinSize(int size) {\n        chunkMinSize = size;\n    }\n\n    /**\n     * Writer interface for adding/writing data to the buffer.\n     *\n     * @return the Writer\n     */\n    public Writer getWriter() {\n        return writer;\n    }\n\n    /**\n     * Creates a new Reader instance for reading/consuming data from the buffer.\n     * Each call creates a new instance that will keep it's reading state. There can be several readers on the buffer. (single thread only supported)\n     *\n     * @return the Reader\n     */\n    public Reader getReader() {\n        return getReader(false);\n    }\n\n    /**\n     * Like getReader(), but when removeAfterReading is true, the read data will be removed from the buffer.\n     *\n     * @param removeAfterReading\n     * @return the Reader\n     */\n    public Reader getReader(boolean removeAfterReading) {\n        readerCount++;\n        hasReaders = true;\n        return new StreamCharBufferReader(removeAfterReading);\n    }\n\n    /**\n     * Writes the buffer content to a target java.io.Writer\n     *\n     * @param target\n     * @throws IOException\n     */\n    public Writer writeTo(Writer target) throws IOException {\n        writeTo(target, false, false);\n        return target;\n    }\n\n    /**\n     * Writes the buffer content to a target java.io.Writer\n     *\n     * @param target Writer\n     * @param flushTarget calls target.flush() before finishing\n     * @param emptyAfter empties the buffer if true\n     * @throws IOException\n     */\n    public void writeTo(Writer target, boolean flushTarget, boolean emptyAfter) throws IOException {\n        if (target instanceof GrailsWrappedWriter) {\n            GrailsWrappedWriter wrappedWriter = ((GrailsWrappedWriter)target);\n            if (wrappedWriter.isAllowUnwrappingOut()) {\n                target = wrappedWriter.unwrap();\n            }\n        }\n        if (target == writer) {\n            throw new IllegalArgumentException(\"Cannot write buffer to itself.\");\n        }\n        if (!emptyAfter && target instanceof StreamCharBufferWriter) {\n            ((StreamCharBufferWriter)target).write(this, null);\n            return;\n        } else if (writeToEncodedAppender(this, target, writer.getEncodedAppender(), true)) {\n            if (emptyAfter) {\n                emptyAfterReading();\n            }\n            if (flushTarget) {\n                target.flush();\n            }\n            return;\n        }\n        writeToImpl(target, flushTarget, emptyAfter);\n    }\n\n    private static boolean writeToEncodedAppender(StreamCharBuffer source, Writer target, EncodedAppender notAllowedAppender, boolean flush) throws IOException {\n        if (target instanceof EncodedAppenderFactory) {\n            EncodedAppenderFactory eaw = (EncodedAppenderFactory)target;\n            EncodedAppender appender = eaw.getEncodedAppender();\n            if (appender != null) {\n                if (appender == notAllowedAppender) {\n                    throw new IllegalArgumentException(\"Cannot write buffer to itself.\");\n                }\n                Encoder encoder = null;\n\n                if (target instanceof EncoderAware) {\n                    encoder = ((EncoderAware)target).getEncoder();\n                }\n\n                if (encoder == null && appender instanceof EncoderAware) {\n                    encoder = ((EncoderAware)appender).getEncoder();\n                }\n\n                source.encodeTo(appender, encoder);\n                if(flush) {\n                appender.flush();\n                }\n                return true;\n                }\n            }\n        return false;\n        }\n\n    private void writeToImpl(Writer target, boolean flushTarget, boolean emptyAfter) throws IOException {\n        AbstractChunk current = firstChunk;\n        while (current != null) {\n            current.writeTo(target);\n            current = current.next;\n        }\n        allocBuffer.writeTo(target);\n        if (emptyAfter) {\n            emptyAfterReading();\n        }\n        if (flushTarget) {\n            target.flush();\n        }\n    }\n\n    protected void emptyAfterReading() {\n        firstChunk = null;\n        lastChunk = null;\n        totalCharsInList = 0;\n        totalCharsInDynamicChunks = -1;\n        sizeAtLeast = -1;\n        dynamicChunkMap.clear();\n        allocBuffer.clear();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Reads (and empties) the buffer to a String, but caches the return value for subsequent calls.\n     * If more content has been added between 2 calls, the returned value will be joined from the previously cached value and the data read from the buffer.\n     *\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        StringChunk stringChunk = readToSingleStringChunk(true);\n        if (stringChunk != null) {\n            return stringChunk.str;\n        } else {\n            return \"\";\n        }\n    }\n\n    public StringChunk readToSingleStringChunk(boolean registerEncodingState) {\n        if (firstChunk == lastChunk && firstChunk instanceof StringChunk && allocBuffer.charsUsed() == 0 &&\n                ((StringChunk)firstChunk).isSingleBuffer()) {\n            StringChunk chunk = ((StringChunk)firstChunk);\n            if (registerEncodingState) {\n                markEncoded(chunk);\n            }\n            return chunk;\n        }\n\n        int initialReaderCount = readerCount;\n        MultipartCharBufferChunk chunk = readToSingleChunk();\n        MultipartStringChunk stringChunk = (chunk != null) ? chunk.asStringChunk() : null;\n        if (initialReaderCount == 0) {\n            // if there are no readers, the result can be cached\n            reset();\n            if (stringChunk != null) {\n                addChunk(stringChunk);\n            }\n        }\n\n        if (registerEncodingState) {\n            markEncoded(stringChunk);\n        }\n\n        return stringChunk;\n    }\n\n    public void markEncoded(StringChunk strChunk) {\n        if (strChunk instanceof MultipartStringChunk) {\n            MultipartStringChunk stringChunk = (MultipartStringChunk)strChunk;\n            if (stringChunk.isSingleEncoding()) {\n                EncodingState encodingState = stringChunk.firstPart.encodingState;\n                if (encodingState != null && encodingState.getEncoders() != null && encodingState.getEncoders().size() > 0) {\n                    Encoder encoder=encodingState.getEncoders().iterator().next();\n                    if (encoder != null)\n                        encoder.markEncoded(stringChunk.str);\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Uses String's hashCode to support compatibility with String instances in maps, sets, etc.\n     *\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        return toString().hashCode();\n    }\n\n    /**\n     * equals uses String.equals to check for equality to support compatibility with String instances in maps, sets, etc.\n     *\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (o==this) return true;\n\n        if (!(o instanceof CharSequence)) return false;\n\n        CharSequence other = (CharSequence) o;\n\n        return toString().equals(other.toString());\n    }\n\n    public String plus(String value) {\n        return toString() + value;\n    }\n\n    public String plus(Object value) {\n        return toString() + value;\n    }\n\n    /**\n     * Reads the buffer to a char[].\n     *\n     * Caches the result if there aren't any readers.\n     *\n     * @return the chars\n     */\n    public char[] toCharArray() {\n        // check if there is a cached single charbuffer\n        if (firstChunk == lastChunk && firstChunk instanceof CharBufferChunk && allocBuffer.charsUsed()==0 && ((CharBufferChunk)firstChunk).isSingleBuffer()) {\n            return ((CharBufferChunk)firstChunk).buffer;\n        }\n\n        int initialReaderCount = readerCount;\n        MultipartCharBufferChunk chunk = readToSingleChunk();\n        if (initialReaderCount == 0) {\n            // if there are no readers, the result can be cached\n            reset();\n            if (chunk != null) {\n                addChunk(chunk);\n            }\n        }\n        if(chunk != null) {\n            return chunk.buffer;\n        } else {\n            return new char[0];\n        }\n    }\n\n    public static final class EncodedPart {\n        private final EncodingState encodingState;\n        private final String part;\n\n        public EncodedPart(EncodingState encodingState, String part) {\n            this.encodingState = encodingState;\n            this.part = part;\n        }\n\n        public EncodingState getEncodingState() {\n            return encodingState;\n        }\n\n        public String getPart() {\n            return part;\n        }\n\n        @Override\n        public String toString() {\n            return \"EncodedPart [encodingState='\" + encodingState + \"', part='\" + part + \"']\";\n        }\n    }\n\n    public List<EncodedPart> dumpEncodedParts() {\n        List<EncodedPart> encodedParts = new ArrayList<StreamCharBuffer.EncodedPart>();\n        MultipartStringChunk mpStringChunk = readToSingleChunk().asStringChunk();\n        if (mpStringChunk.firstPart != null) {\n            EncodingStatePart current = mpStringChunk.firstPart;\n            int offset = 0;\n            char[] buf=StringCharArrayAccessor.getValue(mpStringChunk.str);\n            while (current != null) {\n                encodedParts.add(new EncodedPart(current.encodingState, new String(buf, offset, current.len)));\n                offset += current.len;\n                current = current.next;\n            }\n        }\n        return encodedParts;\n    }\n\n    private MultipartCharBufferChunk readToSingleChunk() {\n        int currentSize = size();\n        if (currentSize == 0) {\n            return null;\n        }\n\n        FixedCharArrayEncodedAppender appender=new FixedCharArrayEncodedAppender(currentSize);\n        try {\n            encodeTo(appender, null);\n        }\n        catch (IOException e) {\n            throw new RuntimeException(\"Unexpected IOException\", e);\n        }\n        appender.finish();\n        return appender.chunk;\n    }\n    \n    boolean hasQuicklyCalcutableSize() {\n        return totalCharsInDynamicChunks != -1 || dynamicChunkMap.size() == 0;\n    }\n\n    public int size() {\n        int total = totalCharsInList;\n        if (totalCharsInDynamicChunks == -1) {\n            totalCharsInDynamicChunks = 0;\n            for (StreamCharBufferSubChunk chunk : dynamicChunkMap.values()) {\n                totalCharsInDynamicChunks += chunk.size();\n            }\n        }\n        total += totalCharsInDynamicChunks;\n        total += allocBuffer.charsUsed();\n        sizeAtLeast = total;\n        return total;\n    }\n\n    public boolean isEmpty() {\n        return !isNotEmpty();\n    }\n\n    boolean isNotEmpty() {\n        if (totalCharsInList > 0) {\n            return true;\n        }\n        if (totalCharsInDynamicChunks > 0) {\n            return true;\n        }\n        if (allocBuffer.charsUsed() > 0) {\n            return true;\n        }\n        if (totalCharsInDynamicChunks == -1) {\n            for (StreamCharBufferSubChunk chunk : dynamicChunkMap.values()) {\n                if (chunk.getSourceBuffer().isNotEmpty()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    boolean isSizeLarger(int minSize) {\n        if (minSize <= sizeAtLeast) {\n            return true;\n        }\n\n        boolean retval = calculateIsSizeLarger(minSize);\n        if (retval && minSize > sizeAtLeast) {\n            sizeAtLeast = minSize;\n        }\n        return retval;\n    }\n\n    private boolean calculateIsSizeLarger(int minSize) {\n        int total = totalCharsInList;\n        total += allocBuffer.charsUsed();\n        if (total > minSize) {\n            return true;\n        }\n        if (totalCharsInDynamicChunks != -1) {\n            total += totalCharsInDynamicChunks;\n            if (total > minSize) {\n                return true;\n            }\n        } else {\n            for (StreamCharBufferSubChunk chunk : dynamicChunkMap.values()) {\n                int remaining = minSize - total;\n                if (!chunk.hasCachedSize() && (chunk.getSourceBuffer().isSizeLarger(remaining) || (chunk.getEncodedBuffer() != chunk.getSourceBuffer() && chunk.getEncodedBuffer().isSizeLarger(remaining)))) {\n                    return true;\n                }\n                total += chunk.size();\n                if (total > minSize) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    int allocateSpace(EncodingState encodingState) throws IOException {\n        int spaceLeft = allocBuffer.spaceLeft(encodingState);\n        if (spaceLeft == 0) {\n            spaceLeft = appendCharBufferChunk(encodingState, true, true);\n        }\n        return spaceLeft;\n    }\n\n    private int appendCharBufferChunk(EncodingState encodingState, boolean flushInConnected, boolean allocate) throws IOException {\n        int spaceLeft = 0;\n        if (flushInConnected && isConnectedMode()) {\n            flushToConnected(false);\n            if (!isChunkSizeResizeable()) {\n                allocBuffer.reuseBuffer(encodingState);\n            }\n        }\n        else {\n            if (allocBuffer.hasChunk()) {\n                addChunk(allocBuffer.createChunk());\n            }\n        }\n        spaceLeft = allocBuffer.spaceLeft(encodingState);\n        if (allocate && spaceLeft == 0) {\n            totalChunkSize += allocBuffer.chunkSize();\n            resizeChunkSizeAsProcentageOfTotalSize();\n            allocBuffer = new AllocatedBuffer(chunkSize);\n            spaceLeft = allocBuffer.spaceLeft(encodingState);\n        }\n        return spaceLeft;\n    }\n\n    void appendStringChunk(EncodingState encodingState, String str, int off, int len) throws IOException {\n        appendCharBufferChunk(encodingState, false, false);\n        addChunk(new StringChunk(str, off, len)).setEncodingState(encodingState);\n    }\n    \n    public void appendStreamCharBufferChunk(StreamCharBuffer subBuffer) throws IOException {\n        appendStreamCharBufferChunk(subBuffer, null);\n    }\n\n    public void appendStreamCharBufferChunk(StreamCharBuffer subBuffer, List<Encoder> encoders) throws IOException {\n        appendCharBufferChunk(null, false, false);\n        addChunk(new StreamCharBufferSubChunk(subBuffer, encoders));\n    }\n\n    AbstractChunk addChunk(AbstractChunk newChunk) {\n        if (lastChunk != null) {\n            lastChunk.next = newChunk;\n            if (hasReaders) {\n                // double link only if there are active readers since backwards iterating is only required for simultaneous writer & reader\n                newChunk.prev = lastChunk;\n            }\n        }\n        lastChunk = newChunk;\n        if (firstChunk == null) {\n            firstChunk = newChunk;\n        }\n        if (newChunk instanceof StreamCharBufferSubChunk) {\n            StreamCharBufferSubChunk bufSubChunk = (StreamCharBufferSubChunk)newChunk;\n            dynamicChunkMap.put(bufSubChunk.getSourceBuffer().bufferKey, bufSubChunk);\n        }\n        else {\n            totalCharsInList += newChunk.size();\n        }\n        return newChunk;\n    }\n\n    public boolean isConnectedMode() {\n        return connectToWriters != null && !connectToWriters.isEmpty();\n    }\n\n    private void flushToConnected(boolean forceFlush) throws IOException {\n        startUsingConnectedWritersWriter();\n        if (notConnectedToEncodeAwareWriters==null) {\n            notConnectedToEncodeAwareWriters = !connectedWritersWriter.isEncoderAware();\n        }\n        writeTo(connectedWritersWriter, forceFlush, true);\n        if (forceFlush) {\n            connectedWritersWriter.forceFlush();\n        }\n    }\n\n    protected boolean isChunkSizeResizeable() {\n        return (growProcent > 0 && chunkSize < maxChunkSize);\n    }\n\n    protected void resizeChunkSizeAsProcentageOfTotalSize() {\n        if (growProcent == 0) {\n            return;\n        }\n\n        if (growProcent==100) {\n            chunkSize = Math.min(totalChunkSize, maxChunkSize);\n        }\n        else if (growProcent == 200) {\n            chunkSize = Math.min(totalChunkSize << 1, maxChunkSize);\n        }\n        else if (growProcent > 0) {\n            chunkSize = Math.max(Math.min((totalChunkSize * growProcent)/100, maxChunkSize), firstChunkSize);\n        }\n    }\n\n    protected static final void arrayCopy(char[] src, int srcPos, char[] dest, int destPos, int length) {\n        if (length == 1) {\n            dest[destPos]=src[srcPos];\n        }\n        else {\n            System.arraycopy(src, srcPos, dest, destPos, length);\n        }\n    }\n\n    /**\n     * This is the java.io.Writer implementation for StreamCharBuffer\n     *\n     * @author Lari Hotari, Sagire Software Oy\n     */\n    public final class StreamCharBufferWriter extends Writer implements EncodedAppenderFactory, EncodedAppenderWriterFactory {\n        boolean closed = false;\n        int writerUsedCounter = 0;\n        boolean increaseCounter = true;\n        EncodedAppender encodedAppender;\n\n        @Override\n        public final void write(final char[] b, final int off, final int len) throws IOException {\n            write(null, b, off, len);\n        }\n\n        private final void write(EncodingState encodingState, final char[] b, final int off, final int len) throws IOException {\n            if (b == null) {\n                throw new NullPointerException();\n            }\n\n            if ((off < 0) || (off > b.length) || (len < 0) ||\n                    ((off + len) > b.length) || ((off + len) < 0)) {\n                throw new IndexOutOfBoundsException();\n            }\n\n            if (len == 0) {\n                return;\n            }\n\n            markUsed();\n            if (shouldWriteDirectly(len)) {\n                appendCharBufferChunk(encodingState,true,true);\n                startUsingConnectedWritersWriter();\n                connectedWritersWriter.write(b, off, len);\n            }\n            else {\n                int charsLeft = len;\n                int currentOffset = off;\n                while (charsLeft > 0) {\n                    int spaceLeft = allocateSpace(encodingState);\n                    int writeChars = Math.min(spaceLeft, charsLeft);\n                    allocBuffer.write(b, currentOffset, writeChars);\n                    charsLeft -= writeChars;\n                    currentOffset += writeChars;\n                }\n            }\n        }\n\n        private final boolean shouldWriteDirectly(final int len) {\n            if (!isConnectedMode()) {\n                return false;\n            }\n\n            if (!(writeDirectlyToConnectedMinSize >= 0 && len >= writeDirectlyToConnectedMinSize)) {\n                return false;\n            }\n\n            return isNextChunkBigEnough(len);\n        }\n\n        private final boolean isNextChunkBigEnough(final int len) {\n            return (len > getNewChunkMinSize());\n        }\n\n        private final int getDirectChunkMinSize() {\n            if (!isConnectedMode()) {\n                return -1;\n            }\n            if (writeDirectlyToConnectedMinSize >= 0) {\n                return writeDirectlyToConnectedMinSize;\n            }\n\n            return getNewChunkMinSize();\n        }\n\n        private final int getNewChunkMinSize() {\n            if (chunkMinSize <= 0 || allocBuffer.charsUsed() == 0 || allocBuffer.charsUsed() >= chunkMinSize) {\n                return 0;\n            }\n            return allocBuffer.spaceLeft(null);\n        }\n\n        @Override\n        public final void write(final String str) throws IOException {\n            write(null, str, 0, str.length());\n        }\n\n        @Override\n        public final void write(final String str, final int off, final int len) throws IOException {\n            write(null, str, off, len);\n        }\n\n        private final void write(EncodingState encodingState, final String str, final int off, final int len) throws IOException {\n            if (len==0) return;\n            markUsed();\n            if (shouldWriteDirectly(len)) {\n                appendCharBufferChunk(encodingState,true,false);\n                startUsingConnectedWritersWriter();\n                connectedWritersWriter.write(str, off, len);\n            }\n            else if (len >= subStringChunkMinSize && isNextChunkBigEnough(len)) {\n                appendStringChunk(encodingState, str, off, len);\n            }\n            else {\n                int charsLeft = len;\n                int currentOffset = off;\n                while (charsLeft > 0) {\n                    int spaceLeft = allocateSpace(encodingState);\n                    int writeChars = Math.min(spaceLeft, charsLeft);\n                    allocBuffer.writeString(str, currentOffset, writeChars);\n                    charsLeft -= writeChars;\n                    currentOffset += writeChars;\n                }\n            }\n        }\n        \n        public final void write(StreamCharBuffer subBuffer) throws IOException {\n            write(subBuffer, null);\n        }\n\n        public final void write(StreamCharBuffer subBuffer, List<Encoder> encoders) throws IOException {\n            markUsed();\n            int directChunkMinSize = getDirectChunkMinSize();\n            if (encoders == null\n                    && (directChunkMinSize == 0 || (directChunkMinSize != -1 && subBuffer\n                            .isSizeLarger(directChunkMinSize)))) {\n                appendCharBufferChunk(null, true, false);\n                startUsingConnectedWritersWriter();\n                subBuffer.writeToImpl(connectedWritersWriter, false, false);\n            }\n            else if (!appendSubBuffer(subBuffer, encoders)) {\n                ChainedEncoders.chainEncode(subBuffer, this.getEncodedAppender(), encoders);\n            }\n        }\n\n        boolean appendSubBuffer(StreamCharBuffer subBuffer, List<Encoder> encoders) throws IOException {\n            if (isAllowSubBuffers() && subBuffer.isPreferSubChunkWhenWritingToOtherBuffer()\n                    || subBuffer.isSizeLarger(Math.max(subBufferChunkMinSize, getNewChunkMinSize()))) {\n                if (subBuffer.isPreferSubChunkWhenWritingToOtherBuffer()) {\n                    StreamCharBuffer.this.setPreferSubChunkWhenWritingToOtherBuffer(true);\n                }\n                markUsed();\n                appendStreamCharBufferChunk(subBuffer, encoders);\n                subBuffer.addParentBuffer(StreamCharBuffer.this);\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public final Writer append(final CharSequence csq, final int start, final int end)\n                throws IOException {\n            markUsed();\n            if (csq == null) {\n                write(\"null\");\n            }\n            else {\n                appendCharSequence(null, csq, start, end);\n            }\n            return this;\n        }\n\n        protected void appendCharSequence(final EncodingState encodingState, final CharSequence csq, final int start, final int end) throws IOException {\n            final Class<?> csqClass = csq.getClass();\n            if (csqClass == String.class || csqClass == StringBuffer.class || csqClass == StringBuilder.class || csq instanceof CharArrayAccessible) {\n                int len = end-start;\n                int charsLeft = len;\n                int currentOffset = start;\n                while (charsLeft > 0) {\n                    int spaceLeft = allocateSpace(encodingState);\n                    int writeChars = Math.min(spaceLeft, charsLeft);\n                    if (csqClass == String.class) {\n                        allocBuffer.writeString((String)csq, currentOffset, writeChars);\n                    }\n                    else if (csqClass == StringBuffer.class) {\n                        allocBuffer.writeStringBuffer((StringBuffer)csq, currentOffset, writeChars);\n                    }\n                    else if (csqClass == StringBuilder.class) {\n                        allocBuffer.writeStringBuilder((StringBuilder)csq, currentOffset, writeChars);\n                    }\n                    else if (csq instanceof CharArrayAccessible) {\n                        allocBuffer.writeCharArrayAccessible((CharArrayAccessible)csq, currentOffset, writeChars);\n                    }\n                    charsLeft -= writeChars;\n                    currentOffset += writeChars;\n                }\n            } else {\n                String str=csq.subSequence(start, end).toString();\n                write(encodingState, str, 0, str.length());\n            }\n        }\n\n        @Override\n        public final Writer append(final CharSequence csq) throws IOException {\n            markUsed();\n            if (csq==null) {\n                write(\"null\");\n            } else {\n                append(csq, 0, csq.length());\n\n            }\n            return this;\n        }\n\n        @Override\n        public void close() throws IOException {\n            closed = true;\n            flushWriter(true);\n        }\n\n        public boolean isClosed() {\n            return closed;\n        }\n\n        public boolean isUsed() {\n            return writerUsedCounter > 0;\n        }\n\n        public final void markUsed() {\n            if (increaseCounter) {\n                writerUsedCounter++;\n                if (!hasReaders) {\n                    increaseCounter=false;\n                }\n            }\n        }\n\n        public int resetUsed() {\n            int prevUsed = writerUsedCounter;\n            writerUsedCounter = 0;\n            increaseCounter = true;\n            return prevUsed;\n        }\n\n        @Override\n        public void write(final int b) throws IOException {\n            markUsed();\n            allocateSpace(null);\n            allocBuffer.write((char) b);\n        }\n\n        void flushWriter(boolean forceFlush) throws IOException {\n            if (isConnectedMode()) {\n                flushToConnected(forceFlush);\n            }\n            notifyBufferChange();\n        }\n\n        public final StreamCharBuffer getBuffer() {\n            return StreamCharBuffer.this;\n        }\n\n        public void append(EncodingState encodingState, char character) throws IOException {\n            markUsed();\n            allocateSpace(isNotConnectedToEncoderAwareWriters() || encodingState == null ? EncodingStateImpl.UNDEFINED_ENCODING_STATE : encodingState);\n            allocBuffer.write(character);\n        }\n\n        public Writer getWriterForEncoder(Encoder encoder, EncodingStateRegistry encodingStateRegistry) {\n            return StreamCharBuffer.this.getWriterForEncoder(encoder, encodingStateRegistry);\n        }\n\n        public EncodedAppender getEncodedAppender() {\n            if (encodedAppender==null) {\n                encodedAppender = new StreamCharBufferEncodedAppender(this);\n            }\n            return encodedAppender;\n        }\n\n        @Override\n        public void flush() throws IOException {\n            flushWriter(false);\n        }\n    }\n\n    private boolean isNotConnectedToEncoderAwareWriters() {\n        return notConnectedToEncodeAwareWriters != null && notConnectedToEncodeAwareWriters;\n    }\n\n    private final static class StreamCharBufferEncodedAppender extends AbstractEncodedAppender {\n        StreamCharBufferWriter writer;\n        StreamCharBufferEncodedAppender(StreamCharBufferWriter writer) {\n            this.writer=writer;\n        }\n\n        public StreamCharBufferWriter getWriter() {\n            return writer;\n        }\n\n        @Override\n        public void flush() throws IOException {\n            writer.flush();\n        }\n\n        @Override\n        protected void write(EncodingState encodingState, char[] b, int off, int len) throws IOException {\n            writer.write(encodingState, b, off, len);\n        }\n\n        @Override\n        protected void write(EncodingState encodingState, String str, int off, int len) throws IOException {\n            writer.write(encodingState, str, off, len);\n\n        }\n\n        @Override\n        protected void appendCharSequence(EncodingState encodingState, CharSequence str, int start, int end)\n                throws IOException {\n            writer.appendCharSequence(encodingState, str, start, end);\n        }\n\n        public void close() throws IOException {\n            writer.close();\n        }\n    }\n\n    /**\n     * This is the java.io.Reader implementation for StreamCharBuffer\n     *\n     * @author Lari Hotari, Sagire Software Oy\n     */\n\n    final public class StreamCharBufferReader extends Reader {\n        boolean eofException=false;\n        int eofReachedCounter=0;\n        ChunkReader chunkReader;\n        ChunkReader lastChunkReader;\n        boolean removeAfterReading;\n\n        public StreamCharBufferReader(boolean remove) {\n            removeAfterReading = remove;\n        }\n\n        private int prepareRead(int len) {\n            if (hasReaders && eofReachedCounter != 0) {\n                if (eofReachedCounter != writer.writerUsedCounter) {\n                    eofReachedCounter = 0;\n                    eofException = false;\n                    repositionChunkReader();\n                }\n            }\n            if (chunkReader == null && eofReachedCounter == 0) {\n                if (firstChunk != null) {\n                    chunkReader = firstChunk.getChunkReader(removeAfterReading);\n                    if (removeAfterReading) {\n                        firstChunk.subtractFromTotalCount();\n                    }\n                }\n                else {\n                    chunkReader = new AllocatedBufferReader(allocBuffer, removeAfterReading);\n                }\n            }\n            int available = 0;\n            if (chunkReader != null) {\n                available = chunkReader.getReadLenLimit(len);\n                while (available == 0 && chunkReader != null) {\n                    chunkReader = chunkReader.next();\n                    if (chunkReader != null) {\n                        available = chunkReader.getReadLenLimit(len);\n                    } else {\n                        available = 0;\n                    }\n                }\n            }\n            if (chunkReader == null) {\n                if (hasReaders) {\n                    eofReachedCounter=writer.writerUsedCounter;\n                } else {\n                    eofReachedCounter = 1;\n                }\n            } else if (hasReaders) {\n                lastChunkReader=chunkReader;\n            }\n            return available;\n        }\n\n        /* adds support for reading and writing simultaneously in the same thread */\n        private void repositionChunkReader() {\n            if (lastChunkReader instanceof AllocatedBufferReader) {\n                if (lastChunkReader.isValid()) {\n                    chunkReader=lastChunkReader;\n                } else {\n                    AllocatedBufferReader allocBufferReader = (AllocatedBufferReader)lastChunkReader;\n                    // find out what is the CharBufferChunk that was read by the AllocatedBufferReader already\n                    int currentPosition = allocBufferReader.position;\n                    AbstractChunk chunk = lastChunk;\n                    while (chunk != null && chunk.writerUsedCounter >= lastChunkReader.getWriterUsedCounter()) {\n                        if (chunk instanceof CharBufferChunk) {\n                            CharBufferChunk charBufChunk = (CharBufferChunk)chunk;\n                            if (charBufChunk.allocatedBufferId == allocBufferReader.parent.id) {\n                                if (currentPosition >= charBufChunk.offset && currentPosition <= charBufChunk.lastposition) {\n                                    CharBufferChunkReader charBufChunkReader = (CharBufferChunkReader)charBufChunk.getChunkReader(removeAfterReading);\n                                    int oldpointer = charBufChunkReader.pointer;\n                                    // skip the already chars\n                                    charBufChunkReader.pointer = currentPosition;\n                                    if (removeAfterReading) {\n                                        int diff = charBufChunkReader.pointer - oldpointer;\n                                        totalCharsInList -= diff;\n                                        charBufChunk.subtractFromTotalCount();\n                                    }\n                                    chunkReader = charBufChunkReader;\n                                    break;\n                                }\n                            }\n                        }\n                        chunk = chunk.prev;\n                    }\n                }\n            }\n        }\n\n        @Override\n        public boolean ready() throws IOException {\n            return true;\n        }\n\n        @Override\n        public final int read(final char[] b, final int off, final int len) throws IOException {\n            return readImpl(b, off, len);\n        }\n\n        final int readImpl(final char[] b, final int off, final int len) throws IOException {\n            if (b == null) {\n                throw new NullPointerException();\n            }\n\n            if ((off < 0) || (off > b.length) || (len < 0) ||\n                    ((off + len) > b.length) || ((off + len) < 0)) {\n                throw new IndexOutOfBoundsException();\n            }\n\n            if (len == 0) {\n                return 0;\n            }\n\n            int charsLeft = len;\n            int currentOffset = off;\n            int readChars = prepareRead(charsLeft);\n            if (eofException) {\n                throw new EOFException();\n            }\n\n            int totalCharsRead = 0;\n            while (charsLeft > 0 && readChars > 0) {\n                chunkReader.read(b, currentOffset, readChars);\n                charsLeft -= readChars;\n                currentOffset += readChars;\n                totalCharsRead += readChars;\n                if (charsLeft > 0) {\n                    readChars = prepareRead(charsLeft);\n                }\n            }\n\n            if (totalCharsRead > 0) {\n                return totalCharsRead;\n            }\n\n            eofException = true;\n            return -1;\n        }\n\n        @Override\n        public void close() throws IOException {\n            // do nothing\n        }\n\n        public final StreamCharBuffer getBuffer() {\n            return StreamCharBuffer.this;\n        }\n\n        public int getReadLenLimit(int askedAmount) {\n            return prepareRead(askedAmount);\n        }\n    }\n\n    abstract class AbstractChunk implements StreamEncodeable, StreamingEncoderWritable {\n        AbstractChunk next;\n        AbstractChunk prev;\n        int writerUsedCounter;\n        EncodingState encodingState;\n\n        public AbstractChunk() {\n            if (hasReaders) {\n                writerUsedCounter = writer.writerUsedCounter;\n            }\n            else {\n                writerUsedCounter = 1;\n            }\n        }\n\n        public abstract void writeTo(Writer target) throws IOException;\n        public abstract ChunkReader getChunkReader(boolean removeAfterReading);\n        public abstract int size();\n        public int getWriterUsedCounter() {\n            return writerUsedCounter;\n        }\n\n        public void subtractFromTotalCount() {\n            totalCharsInList -= size();\n        }\n\n        public EncodingState getEncodingState() {\n            return encodingState;\n        }\n\n        public void setEncodingState(EncodingState encodingState) {\n            this.encodingState = encodingState;\n        }\n    }\n\n    // keep read state in this class\n    static abstract class ChunkReader {\n        public abstract int read(char[] ch, int off, int len) throws IOException;\n        public abstract int getReadLenLimit(int askedAmount);\n        public abstract ChunkReader next();\n        public abstract int getWriterUsedCounter();\n        public abstract boolean isValid();\n    }\n\n    final class AllocatedBuffer {\n        private int id=allocatedBufferIdSequence++;\n        private int size;\n        private char[] buffer;\n        private int used = 0;\n        private int chunkStart = 0;\n        private EncodingState encodingState;\n        private EncodingState nextEncoders;\n\n        public AllocatedBuffer(int size) {\n            this.size = size;\n            buffer = new char[size];\n        }\n\n        public void clear() {\n            reuseBuffer(null);\n        }\n\n        public int charsUsed() {\n            return used-chunkStart;\n        }\n\n        public void writeTo(Writer target) throws IOException {\n            if (used-chunkStart > 0) {\n                target.write(buffer, chunkStart, used-chunkStart);\n            }\n        }\n\n        public void reuseBuffer(EncodingState encodingState) {\n            used=0;\n            chunkStart=0;\n            this.encodingState=null;\n            this.nextEncoders=encodingState;\n        }\n\n        public int chunkSize() {\n            return buffer.length;\n        }\n\n        public int spaceLeft(EncodingState encodingState) {\n            if(encodingState == null) {\n                encodingState = EncodingStateImpl.UNDEFINED_ENCODING_STATE;\n            }\n            if (this.encodingState != null && (encodingState == null || !this.encodingState.equals(encodingState)) && hasChunk() && !isNotConnectedToEncoderAwareWriters()) {\n                addChunk(allocBuffer.createChunk());\n                this.encodingState = null;\n            }\n            this.nextEncoders = encodingState;\n            return size - used;\n        }\n\n        private final void applyEncoders() throws IOException {\n            if (encodingState==nextEncoders) {\n                return ;\n            }\n            if (encodingState != null && !isNotConnectedToEncoderAwareWriters() && (nextEncoders == null || !encodingState.equals(nextEncoders))) {\n                throw new IOException(\"Illegal operation in AllocatedBuffer\");\n            }\n            encodingState = nextEncoders;\n        }\n\n        public boolean write(final char ch) throws IOException {\n            if (used < size) {\n                applyEncoders();\n                buffer[used++] = ch;\n                return true;\n            }\n\n            return false;\n        }\n\n        public final void write(final char[] ch, final int off, final int len) throws IOException {\n            applyEncoders();\n            arrayCopy(ch, off, buffer, used, len);\n            used += len;\n        }\n\n        public final void writeString(final String str, final int off, final int len) throws IOException {\n            applyEncoders();\n            str.getChars(off, off+len, buffer, used);\n            used += len;\n        }\n\n        public final void writeStringBuilder(final StringBuilder stringBuilder, final int off, final int len) throws IOException {\n            applyEncoders();\n            stringBuilder.getChars(off, off+len, buffer, used);\n            used += len;\n        }\n\n        public final void writeStringBuffer(final StringBuffer stringBuffer, final int off, final int len) throws IOException {\n            applyEncoders();\n            stringBuffer.getChars(off, off+len, buffer, used);\n            used += len;\n        }\n\n        public final void writeCharArrayAccessible(final CharArrayAccessible charArrayAccessible, final int off, final int len) throws IOException {\n            applyEncoders();\n            charArrayAccessible.getChars(off, off+len, buffer, used);\n            used += len;\n        }\n\n        /**\n         * Creates a new chunk from the content written to the buffer (used before adding StringChunk or StreamCharBufferChunk).\n         *\n         * @return the chunk\n         */\n        public CharBufferChunk createChunk() {\n            CharBufferChunk chunk=new CharBufferChunk(id, buffer, chunkStart, used-chunkStart);\n            chunk.setEncodingState(encodingState);\n            chunkStart=used;\n            return chunk;\n        }\n\n        public boolean hasChunk() {\n            return (used > chunkStart);\n        }\n\n        public void encodeTo(EncodedAppender appender, Encoder encoder) throws IOException {\n            if (used-chunkStart > 0) {\n                appender.append(encoder, encodingState, buffer, chunkStart, used-chunkStart);\n            }\n        }\n\n        public EncodingState getEncodingState() {\n            return encodingState;\n        }\n\n        public void encodeTo(Writer writer, EncodesToWriter encoder) throws IOException {\n            if (used-chunkStart > 0) {\n                encoder.encodeToWriter(buffer, chunkStart, used-chunkStart, writer, getEncodingState());\n            }\n        }\n    }\n\n    /**\n     * The data in the buffer is stored in a linked list of StreamCharBufferChunks.\n     *\n     * This class contains data & read/write state for the \"chunk level\".\n     * It contains methods for reading & writing to the chunk level.\n     *\n     * Underneath the chunk is one more level, the StringChunkGroup + StringChunk.\n     * StringChunk makes it possible to directly store the java.lang.String objects.\n     *\n     * @author Lari Hotari\n     *\n     */\n    class CharBufferChunk extends AbstractChunk {\n        int allocatedBufferId;\n        char[] buffer;\n        int offset;\n        int lastposition;\n        int length;\n\n        public CharBufferChunk(int allocatedBufferId, char[] buffer, int offset, int len) {\n            super();\n            this.allocatedBufferId = allocatedBufferId;\n            this.buffer = buffer;\n            this.offset = offset;\n            this.lastposition = offset + len;\n            this.length = len;\n        }\n\n        @Override\n        public void writeTo(final Writer target) throws IOException {\n            target.write(buffer, offset, length);\n        }\n\n        @Override\n        public ChunkReader getChunkReader(boolean removeAfterReading) {\n            return new CharBufferChunkReader(this, removeAfterReading);\n        }\n\n        @Override\n        public int size() {\n            return length;\n        }\n\n        public boolean isSingleBuffer() {\n            return offset == 0 && length == buffer.length;\n        }\n\n        @Override\n        public void encodeTo(EncodedAppender appender, Encoder encoder) throws IOException {\n            appender.append(encoder, getEncodingState(), buffer, offset, length);\n        }\n\n        @Override\n        public void encodeTo(Writer writer, EncodesToWriter encoder) throws IOException {\n            encoder.encodeToWriter(buffer, offset, length, writer, getEncodingState());\n        }\n    }\n\n    class MultipartStringChunk extends StringChunk {\n        EncodingStatePart firstPart=null;\n        EncodingStatePart lastPart=null;\n\n        public MultipartStringChunk(String str) {\n            super(str, 0, str.length());\n        }\n\n        @Override\n        public void encodeTo(EncodedAppender appender, Encoder encoder) throws IOException {\n            if (firstPart != null) {\n                EncodingStatePart current = firstPart;\n                int offset = 0;\n                char[] buf=StringCharArrayAccessor.getValue(str);\n                while (current != null) {\n                    appender.append(encoder, current.encodingState, buf, offset, current.len);\n                    offset += current.len;\n                    current = current.next;\n                }\n            } else {\n                super.encodeTo(appender, encoder);\n            }\n        }\n        \n        @Override\n        public void encodeTo(Writer writer, EncodesToWriter encoder) throws IOException {\n            if (firstPart != null) {\n                EncodingStatePart current = firstPart;\n                int offset = 0;\n                char[] buf=StringCharArrayAccessor.getValue(str);\n                while (current != null) {\n                    encoder.encodeToWriter(buf, offset, current.len, writer, current.encodingState);\n                    offset += current.len;\n                    current = current.next;\n                }\n            } else {\n                super.encodeTo(writer, encoder);\n            }\n        }\n\n        public boolean isSingleEncoding() {\n            return (firstPart==lastPart);\n        }\n\n        public int partCount() {\n            int partCount=0;\n            EncodingStatePart current = firstPart;\n            while (current != null) {\n                partCount++;\n                current = current.next;\n            }\n            return partCount;\n        }\n\n        public void appendEncodingStatePart(EncodingStatePart current) {\n            if (firstPart==null) {\n                firstPart = current;\n                lastPart = current;\n            } else {\n                lastPart.next = current;\n                lastPart = current;\n            }\n        }\n    }\n\n    class MultipartCharBufferChunk extends CharBufferChunk {\n        EncodingStatePart firstPart=null;\n        EncodingStatePart lastPart=null;\n\n        public MultipartCharBufferChunk(char[] buffer) {\n            super(-1, buffer, 0, buffer.length);\n        }\n\n        @Override\n        public void encodeTo(EncodedAppender appender, Encoder encoder) throws IOException {\n            if (firstPart != null) {\n                EncodingStatePart current = firstPart;\n                int offset = 0;\n                while (current != null) {\n                    appender.append(encoder, current.encodingState, buffer, offset, current.len);\n                    offset += current.len;\n                    current = current.next;\n                }\n            } else {\n                super.encodeTo(appender, encoder);\n            }\n        }\n\n        public MultipartStringChunk asStringChunk() {\n            String str = StringCharArrayAccessor.createString(buffer);\n            MultipartStringChunk chunk = new MultipartStringChunk(str);\n            chunk.firstPart = firstPart;\n            chunk.lastPart = lastPart;\n            return chunk;\n        }\n    }\n\n    static final class EncodingStatePart {\n        EncodingStatePart next;\n        EncodingState encodingState;\n        int len=-1;\n    }\n\n    abstract class AbstractChunkReader extends ChunkReader {\n        private AbstractChunk parentChunk;\n        private boolean removeAfterReading;\n\n        public AbstractChunkReader(AbstractChunk parentChunk, boolean removeAfterReading) {\n            this.parentChunk = parentChunk;\n            this.removeAfterReading = removeAfterReading;\n        }\n\n        @Override\n        public boolean isValid() {\n            return true;\n        }\n\n        @Override\n        public ChunkReader next() {\n            if (removeAfterReading) {\n                if (firstChunk == parentChunk) {\n                    firstChunk = null;\n                }\n                if (lastChunk == parentChunk) {\n                    lastChunk = null;\n                }\n            }\n            AbstractChunk nextChunk=parentChunk.next;\n            if (nextChunk != null) {\n                if (removeAfterReading) {\n                    if (firstChunk==null) {\n                        firstChunk=nextChunk;\n                    }\n                    if (lastChunk==null) {\n                        lastChunk=nextChunk;\n                    }\n                    nextChunk.prev=null;\n                    nextChunk.subtractFromTotalCount();\n                }\n                return nextChunk.getChunkReader(removeAfterReading);\n            }\n\n            return new AllocatedBufferReader(allocBuffer, removeAfterReading);\n        }\n\n        @Override\n        public int getWriterUsedCounter() {\n            return parentChunk.getWriterUsedCounter();\n        }\n    }\n\n    final class CharBufferChunkReader extends AbstractChunkReader {\n        CharBufferChunk parent;\n        int pointer;\n\n        public CharBufferChunkReader(CharBufferChunk parent, boolean removeAfterReading) {\n            super(parent, removeAfterReading);\n            this.parent = parent;\n            pointer = parent.offset;\n        }\n\n        @Override\n        public int read(final char[] ch, final int off, final int len) throws IOException {\n            arrayCopy(parent.buffer, pointer, ch, off, len);\n            pointer += len;\n            return len;\n        }\n\n        @Override\n        public int getReadLenLimit(int askedAmount) {\n            return Math.min(parent.lastposition-pointer, askedAmount);\n        }\n    }\n\n    /**\n     * StringChunk is a wrapper for java.lang.String.\n     *\n     * It also keeps state of the read offset and the number of unread characters.\n     *\n     * There's methods that StringChunkGroup uses for reading data.\n     *\n     * @author Lari Hotari\n     *\n     */\n    class StringChunk extends AbstractChunk {\n        String str;\n        int offset;\n        int lastposition;\n        int length;\n\n        public StringChunk(String str, int offset, int length) {\n            this.str = str;\n            this.offset = offset;\n            this.length = length;\n            this.lastposition = offset + length;\n        }\n\n        @Override\n        public ChunkReader getChunkReader(boolean removeAfterReading) {\n            return new StringChunkReader(this, removeAfterReading);\n        }\n\n        @Override\n        public void writeTo(Writer target) throws IOException {\n            target.write(str, offset, length);\n        }\n\n        @Override\n        public int size() {\n            return length;\n        }\n\n        public boolean isSingleBuffer() {\n            return offset==0 && length==str.length();\n        }\n\n        @Override\n        public void encodeTo(EncodedAppender appender, Encoder encoder) throws IOException {\n            appender.append(encoder, getEncodingState(), str, offset, length);\n        }\n\n        @Override\n        public void encodeTo(Writer writer, EncodesToWriter encoder) throws IOException {\n            encoder.encodeToWriter(toCharSequence(), 0, length, writer, getEncodingState());\n        }\n\n        public CharSequence toCharSequence() {\n            if(isSingleBuffer()) { \n                return str;\n            } else {\n                return CharSequences.createCharSequence(str, offset, length);\n            }\n        }\n    }\n\n    final class StringChunkReader extends AbstractChunkReader {\n        StringChunk parent;\n        int position;\n\n        public StringChunkReader(StringChunk parent, boolean removeAfterReading) {\n            super(parent, removeAfterReading);\n            this.parent = parent;\n            this.position = parent.offset;\n        }\n\n        @Override\n        public int read(final char[] ch, final int off, final int len) {\n            parent.str.getChars(position, (position + len), ch, off);\n            position += len;\n            return len;\n        }\n\n        @Override\n        public int getReadLenLimit(int askedAmount) {\n            return Math.min(parent.lastposition - position, askedAmount);\n        }\n    }\n\n    final class StreamCharBufferSubChunk extends AbstractChunk {\n        private StreamCharBuffer sourceBuffer;\n        private List<Encoder> encoders;\n        private StreamCharBuffer encodedBuffer;\n        int cachedSize;\n        int encodedSourceChangesCounter = -1;\n\n        public StreamCharBufferSubChunk(StreamCharBuffer sourceBuffer, List<Encoder> encoders) {\n            this.sourceBuffer = sourceBuffer;\n            this.encoders = encoders;\n            if (encoders == null && hasQuicklyCalcutableSize() && sourceBuffer.hasQuicklyCalcutableSize()) {\n                cachedSize = sourceBuffer.size();\n                if(totalCharsInDynamicChunks == -1) {\n                    totalCharsInDynamicChunks = 0;\n                }\n                totalCharsInDynamicChunks += cachedSize;\n            } else {\n                totalCharsInDynamicChunks = -1;\n                cachedSize = -1;\n            }\n            if (encoders == null || sourceBuffer.isEmpty()) {\n                encodedBuffer = sourceBuffer;\n                encodedSourceChangesCounter = sourceBuffer.getBufferChangesCounter();\n            }\n        }\n\n        @Override\n        public ChunkReader getChunkReader(boolean removeAfterReading) {\n            return new StreamCharBufferSubChunkReader(this, removeAfterReading);\n        }\n\n        @Override\n        public int size() {\n            if (cachedSize == -1) {\n                cachedSize = getEncodedBuffer().size();\n            }\n            return cachedSize;\n        }\n\n        public boolean hasCachedSize() {\n            return (cachedSize != -1);\n        }\n\n        public StreamCharBuffer getSourceBuffer() {\n            return sourceBuffer;\n        }\n\n        @Override\n        public void writeTo(Writer target) throws IOException {\n            if (encoders == null || hasEncodedBufferAvailable() || !hasOnlyStreamingEncoders()) {\n                getEncodedBuffer().writeTo(target);\n            }\n            else {\n                EncodedAppender appender;\n                if (target instanceof EncodedAppender) {\n                    appender = ((EncodedAppender)target);\n                } else if (target instanceof EncodedAppenderFactory) {\n                    appender = ((EncodedAppenderFactory)target).getEncodedAppender();\n                }\n                else {\n                    appender = new WriterEncodedAppender(target);\n                }\n                ChainedEncoders.chainEncode(getSourceBuffer(), appender, encoders);\n            }\n        }\n\n        @Override\n        public void encodeTo(EncodedAppender appender, Encoder encodeToEncoder) throws IOException {\n            if (appender instanceof StreamCharBufferEncodedAppender\n                    && getSourceBuffer().isPreferSubChunkWhenWritingToOtherBuffer() \n                    && ((StreamCharBufferEncodedAppender)appender).getWriter().getBuffer().isAllowSubBuffers() ) {\n                List<Encoder> nextEncoders = ChainedEncoders.appendEncoder(encoders, encodeToEncoder);\n                ((StreamCharBufferEncodedAppender)appender).getWriter().write(getSourceBuffer(), nextEncoders);\n            }\n            else {\n                if (hasEncodedBufferAvailable() || !hasOnlyStreamingEncoders()) {\n                    appender.append(encodeToEncoder, getEncodedBuffer());\n                }\n                else {\n                    ChainedEncoders.chainEncode(getSourceBuffer(), appender, ChainedEncoders.appendEncoder(encoders, encodeToEncoder));\n                }\n            }\n        }\n        \n        protected boolean hasOnlyStreamingEncoders() {\n            if(encoders == null || encoders.isEmpty()) {\n                return false;\n            }\n            for(Encoder encoder : encoders) {\n                if(!(encoder instanceof StreamingEncoder)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public StreamCharBuffer getEncodedBuffer() {\n            if (!hasEncodedBufferAvailable()) {\n                if (encoders == null || sourceBuffer.isEmpty()) {\n                    encodedBuffer = sourceBuffer;\n                    encodedSourceChangesCounter = sourceBuffer.getBufferChangesCounter();\n                }\n                else {\n                    encodedBuffer = new StreamCharBuffer(chunkSize, growProcent, maxChunkSize);\n                    encodedBuffer.setAllowSubBuffers(isAllowSubBuffers());\n                    encodedBuffer.setNotifyParentBuffersEnabled(getSourceBuffer().isNotifyParentBuffersEnabled());\n                    encodeToEncodedBuffer();\n                }\n            }\n            return encodedBuffer;\n        }\n\n        private void encodeToEncodedBuffer() {\n            boolean previousAllowSubBuffer = encodedBuffer.isAllowSubBuffers();\n            encodedBuffer.setAllowSubBuffers(false);\n            encodedSourceChangesCounter = sourceBuffer.getBufferChangesCounter();\n            try {\n                ChainedEncoders.chainEncode(getSourceBuffer(), encodedBuffer.writer.getEncodedAppender(), encoders);\n            }\n            catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            encodedBuffer.setAllowSubBuffers(previousAllowSubBuffer);\n            encodedBuffer.setPreferSubChunkWhenWritingToOtherBuffer(getSourceBuffer().isPreferSubChunkWhenWritingToOtherBuffer());\n            encodedBuffer.notifyBufferChange();\n        }\n\n        protected boolean hasEncodedBufferAvailable() {\n            return encodedBuffer != null && encodedSourceChangesCounter == sourceBuffer.getBufferChangesCounter();\n        }\n\n        public boolean resetSubBuffer() {\n            if (cachedSize != -1 || encodedBuffer != sourceBuffer) {\n                cachedSize = -1;\n                encodedSourceChangesCounter = -1;\n                if(encodedBuffer != sourceBuffer && encodedBuffer != null) {\n                    encodedBuffer.clear();\n                    encodeToEncodedBuffer();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void subtractFromTotalCount() {\n            totalCharsInDynamicChunks = -1;\n            dynamicChunkMap.remove(sourceBuffer.bufferKey);\n        }\n\n        @Override\n        public void encodeTo(Writer writer, EncodesToWriter encoder) throws IOException {\n            if (hasEncodedBufferAvailable() || !hasOnlyStreamingEncoders() || encoders == null) {\n                getEncodedBuffer().encodeTo(writer, encoder);\n            } else {\n                List<StreamingEncoder> streamingEncoders=new ArrayList<StreamingEncoder>(encoders.size());\n                for(Encoder e : encoders) {\n                    streamingEncoders.add((StreamingEncoder)e);\n                }\n                getSourceBuffer().encodeTo(writer, encoder.createChainingEncodesToWriter(streamingEncoders, true));\n            }\n        }\n    }\n\n    final class StreamCharBufferSubChunkReader extends AbstractChunkReader {\n        StreamCharBufferSubChunk parent;\n        private StreamCharBufferReader reader;\n\n        public StreamCharBufferSubChunkReader(StreamCharBufferSubChunk parent, boolean removeAfterReading) {\n            super(parent, removeAfterReading);\n            this.parent = parent;\n            reader = (StreamCharBufferReader)parent.getEncodedBuffer().getReader();\n        }\n\n        @Override\n        public int getReadLenLimit(int askedAmount) {\n            return reader.getReadLenLimit(askedAmount);\n        }\n\n        @Override\n        public int read(char[] ch, int off, int len) throws IOException {\n            return reader.read(ch, off, len);\n        }\n    }\n\n    final class AllocatedBufferReader extends ChunkReader {\n        AllocatedBuffer parent;\n        int position;\n        int writerUsedCounter;\n        boolean removeAfterReading;\n\n        public AllocatedBufferReader(AllocatedBuffer parent, boolean removeAfterReading) {\n            this.parent = parent;\n            position = parent.chunkStart;\n            if (hasReaders) {\n                writerUsedCounter = writer.writerUsedCounter;\n            } else {\n                writerUsedCounter = 1;\n            }\n            this.removeAfterReading = removeAfterReading;\n        }\n\n        @Override\n        public int getReadLenLimit(int askedAmount) {\n            return Math.min(parent.used - position, askedAmount);\n        }\n\n        @Override\n        public int read(char[] ch, int off, int len) throws IOException {\n            arrayCopy(parent.buffer, position, ch, off, len);\n            position += len;\n            if (removeAfterReading) {\n                parent.chunkStart = position;\n            }\n            return len;\n        }\n\n        @Override\n        public ChunkReader next() {\n            return null;\n        }\n\n        @Override\n        public int getWriterUsedCounter() {\n            return writerUsedCounter;\n        }\n\n        @Override\n        public boolean isValid() {\n            return (allocBuffer == parent && (lastChunk == null || lastChunk.writerUsedCounter < writerUsedCounter));\n        }\n    }\n\n    private final class FixedCharArrayEncodedAppender extends AbstractEncodedAppender {\n        char buf[];\n        int count = 0;\n        int currentStart = 0;\n        EncodingState currentState;\n        MultipartCharBufferChunk chunk;\n\n        public FixedCharArrayEncodedAppender(int fixedSize) {\n            buf = new char[fixedSize];\n            chunk = new MultipartCharBufferChunk(buf);\n        }\n\n        private void checkEncodingChange(EncodingState encodingState) {\n            if(encodingState == null) {\n                encodingState = EncodingStateImpl.UNDEFINED_ENCODING_STATE;\n            }\n            if (currentState != null && !currentState.equals(encodingState)) {\n                addPart();\n            }\n            if (currentState==null) {\n                currentState = encodingState;\n            }\n        }\n\n        public void finish() {\n            addPart();\n        }\n\n        private void addPart() {\n            if (count - currentStart > 0) {\n                EncodingStatePart newPart = new EncodingStatePart();\n                newPart.encodingState = currentState;\n                newPart.len = count - currentStart;\n                if (chunk.lastPart==null) {\n                    chunk.firstPart = newPart;\n                    chunk.lastPart = newPart;\n                } else {\n                    chunk.lastPart.next = newPart;\n                    chunk.lastPart = newPart;\n                }\n                currentState = null;\n                currentStart = count;\n            }\n        }\n\n        @Override\n        protected void write(EncodingState encodingState, char[] b, int off, int len) throws IOException {\n            checkEncodingChange(encodingState);\n            arrayCopy(b, off, buf, count, len);\n            count += len;\n        }\n\n        @Override\n        protected void write(EncodingState encodingState, String str, int off, int len) throws IOException {\n            checkEncodingChange(encodingState);\n            str.getChars(off, off + len, buf, count);\n            count += len;\n        }\n\n        @Override\n        protected void appendCharSequence(EncodingState encodingState, CharSequence csq, int start, int end)\n                throws IOException {\n            checkEncodingChange(encodingState);\n            final Class<?> csqClass = csq.getClass();\n            if (csqClass == String.class) {\n                write(encodingState, (String)csq, start, end-start);\n            }\n            else if (csqClass == StringBuffer.class) {\n                ((StringBuffer)csq).getChars(start, end, buf, count);\n                count += end-start;\n            }\n            else if (csqClass == StringBuilder.class) {\n                ((StringBuilder)csq).getChars(start, end, buf, count);\n                count += end-start;\n            }\n            else if (csq instanceof CharArrayAccessible) {\n                ((CharArrayAccessible)csq).getChars(start, end, buf, count);\n                count += end-start;\n            }\n            else {\n                String str=csq.subSequence(start, end).toString();\n                write(encodingState, str, 0, str.length());\n            }\n        }\n\n        public void close() throws IOException {\n            finish();\n        }\n    }\n\n    /**\n     * Interface for a Writer that gets initialized if it is used\n     * Can be used for passing in to \"connectTo\" method of StreamCharBuffer\n     *\n     * @author Lari Hotari\n     *\n     */\n    public static interface LazyInitializingWriter {\n        public Writer getWriter() throws IOException;\n    }\n\n    public static interface LazyInitializingMultipleWriter extends LazyInitializingWriter {\n        /**\n         * initialize underlying writer\n         *\n         * @return false if this writer entry should be removed after calling this callback method\n         */\n        public LazyInitializingWriter[] initializeMultiple(StreamCharBuffer buffer, boolean autoFlush) throws IOException;\n    }\n\n    final class ConnectToWriter {\n        final Writer writer;\n        final LazyInitializingWriter lazyInitializingWriter;\n        final boolean autoFlush;\n        Boolean encoderAware;\n\n        ConnectToWriter(final Writer writer, final boolean autoFlush) {\n            this.writer = writer;\n            this.lazyInitializingWriter = null;\n            this.autoFlush = autoFlush;\n        }\n\n        ConnectToWriter(final LazyInitializingWriter lazyInitializingWriter, final boolean autoFlush) {\n            this.lazyInitializingWriter = lazyInitializingWriter;\n            this.writer = null;\n            this.autoFlush = autoFlush;\n        }\n\n        Writer[] getWriters() throws IOException {\n            if (writer != null) {\n                return new Writer[]{writer};\n            } else {\n                Set<Writer> writerList = resolveLazyInitializers(new HashSet<Integer>(), lazyInitializingWriter);\n                return writerList.toArray(new Writer[writerList.size()]);\n            }\n        }\n\n        private Set<Writer> resolveLazyInitializers(Set<Integer> resolved, LazyInitializingWriter lazyInitializingWriter) throws IOException {\n            Set<Writer> writerList = Collections.emptySet();\n            Integer identityHashCode = System.identityHashCode(lazyInitializingWriter);\n            if (!resolved.contains(identityHashCode) && lazyInitializingWriter instanceof LazyInitializingMultipleWriter) {\n                resolved.add(identityHashCode);\n                writerList = new LinkedHashSet<Writer>();\n                LazyInitializingWriter[] writers = ((LazyInitializingMultipleWriter)lazyInitializingWriter).initializeMultiple(StreamCharBuffer.this, autoFlush);\n                for(LazyInitializingWriter writer : writers) {\n                    writerList.addAll(resolveLazyInitializers(resolved, writer));\n                }\n            } else {\n                writerList = Collections.singleton(lazyInitializingWriter.getWriter());\n            }\n            return writerList;\n        }\n\n        public boolean isAutoFlush() {\n            return autoFlush;\n        }\n    }\n\n    /**\n     * Simple holder class for the connected writer\n     *\n     * @author Lari Hotari\n     *\n     */\n    static final class ConnectedWriter {\n        final Writer writer;\n        final boolean autoFlush;\n        final boolean encoderAware;\n\n        ConnectedWriter(final Writer writer, final boolean autoFlush) {\n            this.writer = writer;\n            this.autoFlush = autoFlush;\n            this.encoderAware = (writer instanceof EncodedAppenderFactory || writer instanceof EncodedAppenderWriterFactory);\n        }\n\n        Writer getWriter() {\n            return writer;\n        }\n\n        public void flush() throws IOException {\n            if (autoFlush) {\n                writer.flush();\n            }\n        }\n\n        public boolean isEncoderAware() {\n            return encoderAware;\n        }\n    }\n\n    static final class SingleOutputWriter extends ConnectedWritersWriter implements GrailsWrappedWriter {\n        private final ConnectedWriter connectedWriter;\n        private final Writer writer;\n        private final boolean encoderAware;\n\n        public SingleOutputWriter(ConnectedWriter connectedWriter) {\n            this.connectedWriter = connectedWriter;\n            this.writer = connectedWriter.getWriter();\n            this.encoderAware = connectedWriter.isEncoderAware();\n        }\n\n        @Override\n        public void close() throws IOException {\n            // do nothing\n        }\n\n        @Override\n        public void flush() throws IOException {\n            connectedWriter.flush();\n        }\n\n        @Override\n        public void write(final char[] cbuf, final int off, final int len) throws IOException {\n            writer.write(cbuf, off, len);\n        }\n\n        @Override\n        public Writer append(final CharSequence csq, final int start, final int end)\n                throws IOException {\n            writer.append(csq, start, end);\n            return this;\n        }\n\n        @Override\n        public void write(String str, int off, int len) throws IOException {\n            if (!encoderAware) {\n                StringCharArrayAccessor.writeStringAsCharArray(writer, str, off, len);\n            } else {\n                writer.write(str, off, len);\n            }\n        }\n\n        @Override\n        public boolean isEncoderAware() throws IOException {\n            return encoderAware;\n        }\n\n        public boolean isAllowUnwrappingOut() {\n            return true;\n        }\n\n        public Writer unwrap() {\n            return writer;\n        }\n\n        public void markUsed() {\n        }\n\n        @Override\n        public void forceFlush() throws IOException {\n            writer.flush();\n        }\n    }\n\n    static abstract class ConnectedWritersWriter extends Writer {\n        public abstract boolean isEncoderAware() throws IOException;\n        public abstract void forceFlush() throws IOException;\n    }\n\n    /**\n     * delegates to several writers, used in \"connectTo\" mode.\n     */\n    static final class MultiOutputWriter extends ConnectedWritersWriter {\n        final List<ConnectedWriter> connectedWriters;\n        final List<Writer> writers;\n\n        public MultiOutputWriter(final List<ConnectedWriter> connectedWriters) {\n            this.connectedWriters = connectedWriters;\n            this.writers = new ArrayList<Writer>(connectedWriters.size());\n            for (ConnectedWriter connectedWriter : connectedWriters) {\n                writers.add(connectedWriter.getWriter());\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            // do nothing\n        }\n\n        @Override\n        public void flush() throws IOException {\n            for (ConnectedWriter connectedWriter : connectedWriters) {\n                connectedWriter.flush();\n            }\n        }\n\n        @Override\n        public void write(final char[] cbuf, final int off, final int len) throws IOException {\n            for (Writer writer : writers) {\n                writer.write(cbuf, off, len);\n            }\n        }\n\n        @Override\n        public Writer append(final CharSequence csq, final int start, final int end)\n                throws IOException {\n            for (Writer writer : writers) {\n                writer.append(csq, start, end);\n            }\n            return this;\n        }\n\n        @Override\n        public void write(String str, int off, int len) throws IOException {\n            if (isEncoderAware()) {\n                for (ConnectedWriter connectedWriter : connectedWriters) {\n                    if (!connectedWriter.isEncoderAware()) {\n                        StringCharArrayAccessor.writeStringAsCharArray(connectedWriter.getWriter(), str, off, len);\n                    } else {\n                        connectedWriter.getWriter().write(str, off, len);\n                    }\n                }\n            } else {\n                for (Writer writer : writers) {\n                    writer.write(str, off, len);\n                }\n            }\n        }\n\n        Boolean encoderAware;\n        @Override\n        public boolean isEncoderAware() throws IOException {\n            if (encoderAware==null) {\n                encoderAware = false;\n                for (ConnectedWriter writer : connectedWriters) {\n                    if (writer.isEncoderAware()) {\n                        encoderAware = true;\n                        break;\n                    }\n                }\n            }\n            return encoderAware;\n        }\n\n        @Override\n        public void forceFlush() throws IOException {\n            for (Writer writer : writers) {\n                writer.flush();\n            }\n        }\n    }\n\n    /* Compatibility methods so that StreamCharBuffer will behave more like java.lang.String in groovy code */\n\n    public char charAt(int index) {\n        return toString().charAt(index);\n    }\n\n    public int length() {\n        return size();\n    }\n\n    public CharSequence subSequence(int start, int end) {\n        return toString().subSequence(start, end);\n    }\n\n    public boolean asBoolean() {\n        return isNotEmpty();\n    }\n\n    /* methods for notifying child (sub) StreamCharBuffer changes to the parent StreamCharBuffer */\n\n    void addParentBuffer(StreamCharBuffer parent) {\n        if (!notifyParentBuffersEnabled) return;\n\n        if (parentBuffers==null) {\n            parentBuffers=new HashSet<SoftReference<StreamCharBufferKey>>();\n        }\n        parentBuffers.add(new SoftReference<StreamCharBufferKey>(parent.bufferKey));\n    }\n\n    protected boolean bufferChanged(StreamCharBuffer buffer) {\n        markBufferChanged();\n\n        StreamCharBufferSubChunk subChunk=dynamicChunkMap.get(buffer.bufferKey);\n        if (subChunk==null) {\n            // buffer isn't a subchunk in this buffer any more\n            return false;\n        }\n        // reset cached size;\n        if (subChunk.resetSubBuffer()) {\n            totalCharsInDynamicChunks=-1;\n            sizeAtLeast=-1;\n            // notify parents too\n            notifyBufferChange();\n        }\n        return true;\n    }\n    \n    protected List<StreamCharBuffer> getCurrentParentBuffers() {\n        List<StreamCharBuffer> currentParentBuffers = new ArrayList<StreamCharBuffer>();\n        if(parentBuffers != null) {\n            for (Iterator<SoftReference<StreamCharBufferKey>> i = parentBuffers.iterator(); i.hasNext();) {\n                SoftReference<StreamCharBufferKey> ref = i.next();\n                final StreamCharBuffer.StreamCharBufferKey parentKey = ref.get();\n                if (parentKey != null) {\n                    currentParentBuffers.add(parentKey.getBuffer());\n                }\n            }\n        }\n        return currentParentBuffers;\n    }\n    \n\n    protected void notifyBufferChange() {\n        markBufferChanged();\n\n        if (!notifyParentBuffersEnabled)\n            return;\n\n        if (parentBuffers == null || parentBuffers.isEmpty()) {\n            return;\n        }\n\n        List<SoftReference<StreamCharBufferKey>> parentBuffersList = new ArrayList<>(parentBuffers);\n        for (SoftReference<StreamCharBufferKey> ref : parentBuffersList) {\n            final StreamCharBuffer.StreamCharBufferKey parentKey = ref.get();\n            boolean removeIt = true;\n            if (parentKey != null) {\n                StreamCharBuffer parent = parentKey.getBuffer();\n                removeIt = !parent.bufferChanged(this);\n            }\n            if (removeIt) {\n                parentBuffers.remove(ref);\n            }\n        }\n    }\n\n    public int getBufferChangesCounter() {\n        return bufferChangesCounter;\n    }\n\n    protected int markBufferChanged() {\n        return bufferChangesCounter++;\n    }\n\n    @Override\n    public StreamCharBuffer clone() {\n        StreamCharBuffer cloned=new StreamCharBuffer();\n        cloned.setNotifyParentBuffersEnabled(false);\n        cloned.setAllowSubBuffers(false);\n        if (this.size() > 0) {\n            cloned.addChunk(readToSingleChunk());\n        }\n        cloned.setAllowSubBuffers(true);\n        return cloned;\n    }\n\n    public void readExternal(ObjectInput in) throws IOException,\n            ClassNotFoundException {\n        int version = in.readInt();\n        if (version != EXTERNALIZABLE_VERSION) {\n            throw new IOException(\"Uncompatible version in serialization stream.\");\n        }\n        reset();\n        int len = in.readInt();\n        if (len > 0) {\n            char[] buf=new char[len];\n            Reader reader = new InputStreamReader((InputStream)in, \"UTF-8\");\n            reader.read(buf);\n            String str=StringCharArrayAccessor.createString(buf);\n            MultipartStringChunk mpStringChunk=new MultipartStringChunk(str);\n            int partCount = in.readInt();\n            for(int i=0;i < partCount;i++) {\n                EncodingStatePart current = new EncodingStatePart();\n                mpStringChunk.appendEncodingStatePart(current);\n                current.len = in.readInt();\n                int encodersSize = in.readInt();\n                Set<Encoder> encoders = null;\n                if (encodersSize > 0) {\n                    encoders = new LinkedHashSet<Encoder>();\n                    for (int j=0;j < encodersSize;j++) {\n                        String codecName=in.readUTF();\n                        boolean safe=in.readBoolean();\n                        encoders.add(new SavedEncoder(codecName, safe));\n                    }\n                }\n                current.encodingState = new EncodingStateImpl(encoders, null);\n            }\n            addChunk(mpStringChunk);\n        }\n    }\n\n    private static final class SavedEncoder implements Encoder {\n        private CodecIdentifier codecIdentifier;\n        private boolean safe;\n\n        public SavedEncoder(String codecName, boolean safe) {\n            this.codecIdentifier=new DefaultCodecIdentifier(codecName);\n            this.safe=safe;\n        }\n\n        public CodecIdentifier getCodecIdentifier() {\n            return codecIdentifier;\n        }\n\n        public boolean isSafe() {\n            return safe;\n        }\n\n        public Object encode(Object o) {\n            throw new UnsupportedOperationException(\"encode isn't supported for SavedEncoder\");\n        }\n\n        public void markEncoded(CharSequence string) {\n            throw new UnsupportedOperationException(\"markEncoded isn't supported for SavedEncoder\");\n        }\n\n        public boolean isApplyToSafelyEncoded() {\n            return false;\n        }\n    }\n\n    public void writeExternal(ObjectOutput out) throws IOException {\n        out.writeInt(EXTERNALIZABLE_VERSION);\n        StringChunk stringChunk = readToSingleStringChunk(false);\n        if (stringChunk != null && stringChunk.str.length() > 0) {\n            char[] buf = StringCharArrayAccessor.getValue(stringChunk.str);\n            out.writeInt(buf.length);\n            Writer writer = new OutputStreamWriter((OutputStream)out, \"UTF-8\");\n            writer.write(buf);\n            writer.flush();\n            if (stringChunk instanceof MultipartStringChunk) {\n                MultipartStringChunk mpStringChunk = (MultipartStringChunk)stringChunk;\n                out.writeInt(mpStringChunk.partCount());\n                EncodingStatePart current = mpStringChunk.firstPart;\n                while (current != null) {\n                    out.writeInt(current.len);\n                    if (current.encodingState != null && current.encodingState.getEncoders() != null && current.encodingState.getEncoders().size() > 0) {\n                        out.writeInt(current.encodingState.getEncoders().size());\n                        for(Encoder encoder : current.encodingState.getEncoders()) {\n                            out.writeUTF(encoder.getCodecIdentifier().getCodecName());\n                            out.writeBoolean(encoder.isSafe());\n                        }\n                    } else {\n                        out.writeInt(0);\n                    }\n                    current = current.next;\n                }\n            } else {\n                out.writeInt(0);\n            }\n        } else {\n            out.writeInt(0);\n        }\n    }\n    \n    public StreamCharBuffer encodeToBuffer(Encoder encoder) {\n        return encodeToBuffer(encoder, isAllowSubBuffers(), isNotifyParentBuffersEnabled());\n    }\n    \n    public StreamCharBuffer encodeToBuffer(Encoder encoder, boolean allowSubBuffers, boolean notifyParentBuffersEnabled) {\n        StreamCharBuffer coded = new StreamCharBuffer(Math.min(Math.max(totalChunkSize, chunkSize) * 12 / 10, maxChunkSize));\n        coded.setAllowSubBuffers(allowSubBuffers);\n        coded.setNotifyParentBuffersEnabled(notifyParentBuffersEnabled);\n        EncodedAppender codedWriter = coded.writer.getEncodedAppender();\n        try {\n            encodeTo(codedWriter, encoder);\n        } catch (IOException e) {\n            // Should not ever happen\n            log.error(\"IOException in StreamCharBuffer.encodeToBuffer\", e);\n        }\n        return coded;\n    }\n    \n    public StreamCharBuffer encodeToBuffer(List<Encoder> encoders) {\n        return encodeToBuffer(encoders, isAllowSubBuffers(), isNotifyParentBuffersEnabled());\n    }\n    \n    public StreamCharBuffer encodeToBuffer(List<Encoder> encoders, boolean allowSubBuffers, boolean notifyParentBuffersEnabled) {\n        StreamCharBuffer currentBuffer=this;\n        for(Encoder encoder : encoders) {\n            currentBuffer = currentBuffer.encodeToBuffer(encoder, allowSubBuffers, notifyParentBuffersEnabled);\n        }\n        return currentBuffer;\n    }\n\n    public void encodeTo(EncodedAppender appender, Encoder encoder) throws IOException {\n        if(isPreferSubChunkWhenWritingToOtherBuffer() && appender instanceof StreamCharBufferEncodedAppender) {\n            StreamCharBufferWriter writer = ((StreamCharBufferEncodedAppender)appender).getWriter();\n            if(writer.appendSubBuffer(this, encoder != null ? Collections.singletonList(encoder) : null)) {\n                // subbuffer was appended, so return\n                return;\n            }\n        }\n        AbstractChunk current = firstChunk;\n        while (current != null) {\n            current.encodeTo(appender, encoder);\n            current = current.next;\n        }\n        allocBuffer.encodeTo(appender, encoder);\n    }\n\n    public boolean isAllowSubBuffers() {\n        return subBuffersEnabled && !isConnectedMode();\n    }\n    \n    public void setAllowSubBuffers(boolean allowSubBuffers) {\n        this.subBuffersEnabled = allowSubBuffers;\n    }\n\n    public CharSequence encode(Encoder encoder) {\n        return encodeToBuffer(encoder);\n    }\n\n    public Writer getWriterForEncoder() {\n        return getWriterForEncoder(null);\n    }\n\n    public Writer getWriterForEncoder(Encoder encoder) {\n        return getWriterForEncoder(encoder, lookupDefaultEncodingStateRegistry());\n    }\n\n    protected EncodingStateRegistry lookupDefaultEncodingStateRegistry() {\n        EncodingStateRegistryLookup encodingStateRegistryLookup = EncodingStateRegistryLookupHolder.getEncodingStateRegistryLookup();\n        return encodingStateRegistryLookup != null ? encodingStateRegistryLookup.lookup() : null;\n    }\n\n    public Writer getWriterForEncoder(Encoder encoder, EncodingStateRegistry encodingStateRegistry) {\n        return getWriterForEncoder(encoder, encodingStateRegistry, false);\n    }\n\n    public Writer getWriterForEncoder(Encoder encoder, EncodingStateRegistry encodingStateRegistry, boolean ignoreEncodingState) {\n        EncodedAppender encodedAppender = writer.getEncodedAppender();\n        encodedAppender.setIgnoreEncodingState(ignoreEncodingState);\n        return new EncodedAppenderWriter(encodedAppender, encoder, encodingStateRegistry);\n    }\n\n    public boolean isNotifyParentBuffersEnabled() {\n        return notifyParentBuffersEnabled;\n    }\n\n    /**\n     * By default the parent buffers (a buffer where this buffer has been appended to) get notified of changed to this buffer.\n     *\n     * You can control the notification behavior with this property.\n     * Setting this property to false will also clear the references to parent buffers if there are any.\n     *\n     * @param notifyParentBuffersEnabled\n     */\n    public void setNotifyParentBuffersEnabled(boolean notifyParentBuffersEnabled) {\n        this.notifyParentBuffersEnabled = notifyParentBuffersEnabled;\n        if (!notifyParentBuffersEnabled && parentBuffers != null) {\n            parentBuffers.clear();\n        }\n    }\n\n    @Override\n    public void encodeTo(Writer writer, EncodesToWriter encoder) throws IOException {\n        AbstractChunk current = firstChunk;\n        while (current != null) {\n            current.encodeTo(writer, encoder);\n            current = current.next;\n        }\n        allocBuffer.encodeTo(writer, encoder);\n    }\n\n    /**\n     * Delegates methodMissing to String object\n     *\n     * @param name The name of the method\n     * @param args The arguments\n     * @return The return value\n     */\n    public Object methodMissing(String name, Object args) {\n        String str = this.toString();\n        return InvokerHelper.invokeMethod(str, name, args);\n    }\n\n    public Object asType(Class clazz) {\n        if (clazz == String.class) {\n            return toString();\n        } else if (clazz == char[].class) {\n            return toCharArray();\n        } else if (clazz == Boolean.class || clazz == boolean.class ) {\n            return asBoolean();\n        } else {\n            return StringGroovyMethods.asType(toString(), clazz);\n        }\n    }\n}\n", "/*\n * Copyright 2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.grails.databinding.bindingsource;\n\n\n\n/**\n * Thrown if an unrecoverable problem occurs creating a DataBindingSource.\n *\n * @since 2.3\n * @see org.grails.databinding.DataBindingSource\n * @see DataBindingSourceCreator\n */\npublic class DataBindingSourceCreationException extends RuntimeException {\n\n    public DataBindingSourceCreationException(Throwable cause) {\n        super(cause);\n    }\n}\n", "package org.grails.web.json;\n\n/*\nCopyright (c) 2002 JSON.org\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nThe Software shall be used for Good, not Evil.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nimport groovy.lang.Writable;\nimport org.grails.encoder.EncodesToWriter;\nimport org.grails.encoder.StreamingEncoder;\nimport org.grails.encoder.StreamingEncoderWritable;\nimport org.grails.encoder.StreamingEncoderWriter;\nimport org.springframework.util.ClassUtils;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.*;\n\n/**\n * A JSONObject is an unordered collection of name/value pairs. Its\n * external form is a string wrapped in curly braces with colons between the\n * names and values, and commas between the values  and names. The internal form\n * is an object having <code>get</code> and <code>opt</code> methods for\n * accessing the values by name, and <code>put</code> methods for adding or\n * replacing values by name. The values can be any of these types:\n * <code>Boolean</code>, <code>JSONArray</code>, <code>JSONObject</code>,\n * <code>Number</code>, or <code>String</code>. A JSONObject constructor can be used to convert an external form\n * JSON text into an internal form whose values can be retrieved with the\n * <code>get</code> and <code>opt</code> methods, or to convert values into a\n * JSON text using the <code>put</code> and <code>toString</code> methods.\n * A <code>get</code> method returns a value if one can be found, and throws an\n * exception if one cannot be found. An <code>opt</code> method returns a\n * default value instead of throwing an exception, and so is useful for\n * obtaining optional values.\n * <p/>\n * The generic <code>get()</code> and <code>opt()</code> methods return an\n * object, which you can cast or query for type. There are also typed\n * <code>get</code> and <code>opt</code> methods that do type checking and type\n * coersion for you.\n * <p/>\n * The <code>put</code> methods adds values to an object. For example, <pre>\n *     myString = new JSONObject().put(\"JSON\", \"Hello, World!\").toString();</pre>\n * produces the string <code>{\"JSON\": \"Hello, World\"}</code>.\n * <p/>\n * The texts produced by the <code>toString</code> methods strictly conform to\n * the JSON sysntax rules.\n * The constructors are more forgiving in the texts they will accept:\n * <ul>\n * <li>An extra <code>,</code>&nbsp;<small>(comma)</small> may appear just\n * before the closing brace.</li>\n * <li>Strings may be quoted with <code>'</code>&nbsp;<small>(single\n * quote)</small>.</li>\n * <li>Strings do not need to be quoted at all if they do not begin with a quote\n * or single quote, and if they do not contain leading or trailing spaces,\n * and if they do not contain any of these characters:\n * <code>{ } [ ] / \\ : , = ; #</code> and if they do not look like numbers\n * and if they are not the reserved words <code>true</code>,\n * <code>false</code>, or <code>null</code>.</li>\n * <li>Keys can be followed by <code>=</code> or <code>=></code> as well as\n * by <code>:</code>.</li>\n * <li>Values can be followed by <code>;</code> <small>(semicolon)</small> as\n * well as by <code>,</code> <small>(comma)</small>.</li>\n * <li>Numbers may have the <code>0-</code> <small>(octal)</small> or\n * <code>0x-</code> <small>(hex)</small> prefix.</li>\n * <li>Comments written in the slashshlash, slashstar, and hash conventions\n * will be ignored.</li>\n * </ul>\n *\n * @author JSON.org\n * @version 2\n */\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic class JSONObject implements JSONElement, Map {\n    private static EncodesToWriter javascriptEncoderStateless;\n    private static StreamingEncoder javascriptEncoder;\n    private static boolean useStreamingJavascriptEncoder=false;\n    static {\n        try {\n            javascriptEncoder = (StreamingEncoder)ClassUtils.forName(\"org.grails.plugins.codecs.JSONEncoder\", JSONObject.class.getClassLoader()).newInstance();\n            javascriptEncoderStateless = (EncodesToWriter)javascriptEncoder;\n            useStreamingJavascriptEncoder = true;\n        }\n        catch (Exception e) {\n            // ignore\n        }\n    }\n\n    /**\n     * The hash map where the JSONObject's properties are kept.\n     */\n    private HashMap myHashMap;\n\n    /**\n     * Construct an empty JSONObject.\n     */\n    public JSONObject() {\n        this.myHashMap = new HashMap();\n    }\n\n\n    /**\n     * Construct a JSONObject from a subset of another JSONObject.\n     * An array of strings is used to identify the keys that should be copied.\n     * Missing keys are ignored.\n     *\n     * @param jo A JSONObject.\n     * @param sa An array of strings.\n     * @throws JSONException If a value is a non-finite number.\n     */\n    public JSONObject(JSONObject jo, String[] sa) throws JSONException {\n        this();\n        for (int i = 0; i < sa.length; i += 1) {\n            putOpt(sa[i], jo.opt(sa[i]));\n        }\n    }\n\n\n    /**\n     * Construct a JSONObject from a JSONTokener.\n     *\n     * @param x A JSONTokener object containing the source string.\n     * @throws JSONException If there is a syntax error in the source string.\n     */\n    public JSONObject(JSONTokener x) throws JSONException {\n        this();\n        char c;\n        String key;\n\n        if (x.nextClean() != '{') {\n            throw x.syntaxError(\"A JSONObject text must begin with '{'\");\n        }\n        for (; ;) {\n            c = x.nextClean();\n            switch (c) {\n                case 0:\n                    throw x.syntaxError(\"A JSONObject text must end with '}'\");\n                case '}':\n                    return;\n                default:\n                    x.back();\n                    key = x.nextValue().toString();\n            }\n\n            /*\n             * The key is followed by ':'. We will also tolerate '=' or '=>'.\n             */\n\n            c = x.nextClean();\n            if (c == '=') {\n                if (x.next() != '>') {\n                    x.back();\n                }\n            } else if (c != ':') {\n                throw x.syntaxError(\"Expected a ':' after a key\");\n            }\n            this.myHashMap.put(key, x.nextValue());\n\n            /*\n             * Pairs are separated by ','. We will also tolerate ';'.\n             */\n\n            switch (x.nextClean()) {\n                case ';':\n                case ',':\n                    if (x.nextClean() == '}') {\n                        return;\n                    }\n                    x.back();\n                    break;\n                case '}':\n                    return;\n                default:\n                    throw x.syntaxError(\"Expected a ',' or '}'\");\n            }\n        }\n    }\n\n\n    /**\n     * Construct a JSONObject from a Map.\n     *\n     * @param map A map object that can be used to initialize the contents of\n     *            the JSONObject.\n     */\n    public JSONObject(Map map) {\n        this.myHashMap = new HashMap(map);\n    }\n\n\n    /**\n     * Construct a JSONObject from a string.\n     * This is the most commonly used JSONObject constructor.\n     *\n     * @param string A string beginning\n     *               with <code>{</code>&nbsp;<small>(left brace)</small> and ending\n     *               with <code>}</code>&nbsp;<small>(right brace)</small>.\n     * @throws JSONException If there is a syntax error in the source string.\n     */\n    public JSONObject(String string) throws JSONException {\n        this(new JSONTokener(string));\n    }\n\n\n    /**\n     * Accumulate values under a key. It is similar to the put method except\n     * that if there is already an object stored under the key then a\n     * JSONArray is stored under the key to hold all of the accumulated values.\n     * If there is already a JSONArray, then the new value is appended to it.\n     * In contrast, the put method replaces the previous value.\n     *\n     * @param key   A key string.\n     * @param value An object to be accumulated under the key.\n     * @return this\n     * @throws JSONException If the value is an invalid number\n     *                       or if the key is null.\n     */\n    public JSONObject accumulate(String key, Object value)\n            throws JSONException {\n        testValidity(value);\n        Object o = opt(key);\n        if (o == null) {\n            put(key, value);\n        } else if (o instanceof JSONArray) {\n            ((JSONArray) o).put(value);\n        } else {\n            put(key, new JSONArray().put(o).put(value));\n        }\n        return this;\n    }\n\n\n    /**\n     * Get the value object associated with a key.\n     *\n     * @param key A key string.\n     * @return The object associated with the key.\n     * @throws JSONException if the key is not found.\n     */\n    public Object get(String key) throws JSONException {\n        if(!myHashMap.containsKey(key)) {\n            throw new JSONException(\"JSONObject[\" + quote(key) +\n                    \"] not found.\");\n        }\n        return opt(key);\n    }\n\n\n    /**\n     * Get the boolean value associated with a key.\n     *\n     * @param key A key string.\n     * @return The truth.\n     * @throws JSONException if the value is not a Boolean or the String \"true\" or \"false\".\n     */\n    public boolean getBoolean(String key) throws JSONException {\n        Object o = get(key);\n        if (o.equals(Boolean.FALSE) ||\n                (o instanceof String &&\n                        ((String) o).equalsIgnoreCase(\"false\"))) {\n            return false;\n        } else if (o.equals(Boolean.TRUE) ||\n                (o instanceof String &&\n                        ((String) o).equalsIgnoreCase(\"true\"))) {\n            return true;\n        }\n        throw new JSONException(\"JSONObject[\" + quote(key) +\n                \"] is not a Boolean.\");\n    }\n\n\n    /**\n     * Get the double value associated with a key.\n     *\n     * @param key A key string.\n     * @return The numeric value.\n     * @throws JSONException if the key is not found or\n     *                       if the value is not a Number object and cannot be converted to a number.\n     */\n    public double getDouble(String key) throws JSONException {\n        Object o = get(key);\n        try {\n            return o instanceof Number ?\n                    ((Number) o).doubleValue() : Double.parseDouble((String) o);\n        } catch (Exception e) {\n            throw new JSONException(\"JSONObject[\" + quote(key) +\n                    \"] is not a number.\");\n        }\n    }\n\n\n    /**\n     * Get the int value associated with a key. If the number value is too\n     * large for an int, it will be clipped.\n     *\n     * @param key A key string.\n     * @return The integer value.\n     * @throws JSONException if the key is not found or if the value cannot\n     *                       be converted to an integer.\n     */\n    public int getInt(String key) throws JSONException {\n        Object o = get(key);\n        return o instanceof Number ?\n                ((Number) o).intValue() : (int) getDouble(key);\n    }\n\n\n    /**\n     * Get the JSONArray value associated with a key.\n     *\n     * @param key A key string.\n     * @return A JSONArray which is the value.\n     * @throws JSONException if the key is not found or\n     *                       if the value is not a JSONArray.\n     */\n    public JSONArray getJSONArray(String key) throws JSONException {\n        Object o = get(key);\n        if (o instanceof JSONArray) {\n            return (JSONArray) o;\n        }\n        throw new JSONException(\"JSONObject[\" + quote(key) +\n                \"] is not a JSONArray.\");\n    }\n\n\n    /**\n     * Get the JSONObject value associated with a key.\n     *\n     * @param key A key string.\n     * @return A JSONObject which is the value.\n     * @throws JSONException if the key is not found or\n     *                       if the value is not a JSONObject.\n     */\n    public JSONObject getJSONObject(String key) throws JSONException {\n        Object o = get(key);\n        if (o instanceof JSONObject) {\n            return (JSONObject) o;\n        }\n        throw new JSONException(\"JSONObject[\" + quote(key) +\n                \"] is not a JSONObject.\");\n    }\n\n\n    /**\n     * Get the long value associated with a key. If the number value is too\n     * long for a long, it will be clipped.\n     *\n     * @param key A key string.\n     * @return The long value.\n     * @throws JSONException if the key is not found or if the value cannot\n     *                       be converted to a long.\n     */\n    public long getLong(String key) throws JSONException {\n        Object o = get(key);\n        return o instanceof Number ?\n                ((Number) o).longValue() : (long) getDouble(key);\n    }\n\n\n    /**\n     * Get the string associated with a key.\n     *\n     * @param key A key string.\n     * @return A string which is the value.\n     * @throws JSONException if the key is not found.\n     */\n    public String getString(String key) throws JSONException {\n        return get(key).toString();\n    }\n\n\n    /**\n     * Determine if the JSONObject contains a specific key.\n     *\n     * @param key A key string.\n     * @return true if the key exists in the JSONObject.\n     */\n    public boolean has(String key) {\n        return myHashMap.containsKey(key);\n    }\n\n\n    /**\n     * Determine if the value associated with the key is null or if there is\n     * no value.\n     *\n     * @param key A key string.\n     * @return true if there is no value associated with the key or if\n     *         the value is the JSONObject.NULL object.\n     */\n    public boolean isNull(String key) {\n        return opt(key) == null;\n    }\n\n\n    /**\n     * Get an enumeration of the keys of the JSONObject.\n     *\n     * @return An iterator of the keys.\n     */\n    public Iterator keys() {\n        return myHashMap.keySet().iterator();\n    }\n\n\n    /**\n     * Get the number of keys stored in the JSONObject.\n     *\n     * @return The number of keys in the JSONObject.\n     */\n    public int length() {\n        return myHashMap.size();\n    }\n\n\n    /**\n     * Produce a JSONArray containing the names of the elements of this\n     * JSONObject.\n     *\n     * @return A JSONArray containing the key strings, or null if the JSONObject\n     *         is empty.\n     */\n    public JSONArray names() {\n        JSONArray ja = new JSONArray();\n        Iterator keys = keys();\n        while (keys.hasNext()) {\n            ja.put(keys.next());\n        }\n        return ja.length() == 0 ? null : ja;\n    }\n\n    /**\n     * Produce a string from a number.\n     *\n     * @param n A Number\n     * @return A String.\n     * @throws JSONException If n is a non-finite number.\n     */\n    static public String numberToString(Number n)\n            throws JSONException {\n        if (n == null) {\n            throw new JSONException(\"Null pointer\");\n        }\n        testValidity(n);\n\n// Shave off trailing zeros and decimal point, if possible.\n\n        String s = n.toString();\n        if (s.indexOf('.') > 0 && s.indexOf('e') < 0 && s.indexOf('E') < 0) {\n            while (s.endsWith(\"0\")) {\n                s = s.substring(0, s.length() - 1);\n            }\n            if (s.endsWith(\".\")) {\n                s = s.substring(0, s.length() - 1);\n            }\n        }\n        return s;\n    }\n\n    static public String dateToString(Date d) throws JSONException {\n        return \"new Date(\" + d.getTime() + \")\";\n    }\n\n    static public String collectionToString(Collection c) {\n        StringBuilder sb = new StringBuilder(\"[\");\n        boolean first = true;\n        Iterator iterator = c.iterator();\n        while(iterator.hasNext()) {\n            if (!first) {\n                sb.append(',');\n            }\n            sb.append(valueToString(iterator.next()));\n            first = false;\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n\n    /**\n     * Get an optional value associated with a key.\n     *\n     * @param key A key string.\n     * @return An object which is the value, or null if there is no value.\n     */\n    public Object opt(String key) {\n        return key == null ? null : this.myHashMap.get(key);\n    }\n\n\n    /**\n     * Get an optional boolean associated with a key.\n     * It returns false if there is no such key, or if the value is not\n     * Boolean.TRUE or the String \"true\".\n     *\n     * @param key A key string.\n     * @return The truth.\n     */\n    public boolean optBoolean(String key) {\n        return optBoolean(key, false);\n    }\n\n\n    /**\n     * Get an optional boolean associated with a key.\n     * It returns the defaultValue if there is no such key, or if it is not\n     * a Boolean or the String \"true\" or \"false\" (case insensitive).\n     *\n     * @param key          A key string.\n     * @param defaultValue The default.\n     * @return The truth.\n     */\n    public boolean optBoolean(String key, boolean defaultValue) {\n        try {\n            return getBoolean(key);\n        } catch (Exception e) {\n            return defaultValue;\n        }\n    }\n\n\n    /**\n     * Get an optional double associated with a key,\n     * or NaN if there is no such key or if its value is not a number.\n     * If the value is a string, an attempt will be made to evaluate it as\n     * a number.\n     *\n     * @param key A string which is the key.\n     * @return An object which is the value.\n     */\n    public double optDouble(String key) {\n        return optDouble(key, Double.NaN);\n    }\n\n\n    /**\n     * Get an optional double associated with a key, or the\n     * defaultValue if there is no such key or if its value is not a number.\n     * If the value is a string, an attempt will be made to evaluate it as\n     * a number.\n     *\n     * @param key          A key string.\n     * @param defaultValue The default.\n     * @return An object which is the value.\n     */\n    public double optDouble(String key, double defaultValue) {\n        try {\n            Object o = opt(key);\n            return o instanceof Number ? ((Number) o).doubleValue() :\n                    Double.valueOf((String) o);\n        } catch (Exception e) {\n            return defaultValue;\n        }\n    }\n\n\n    /**\n     * Get an optional int value associated with a key,\n     * or zero if there is no such key or if the value is not a number.\n     * If the value is a string, an attempt will be made to evaluate it as\n     * a number.\n     *\n     * @param key A key string.\n     * @return An object which is the value.\n     */\n    public int optInt(String key) {\n        return optInt(key, 0);\n    }\n\n\n    /**\n     * Get an optional int value associated with a key,\n     * or the default if there is no such key or if the value is not a number.\n     * If the value is a string, an attempt will be made to evaluate it as\n     * a number.\n     *\n     * @param key          A key string.\n     * @param defaultValue The default.\n     * @return An object which is the value.\n     */\n    public int optInt(String key, int defaultValue) {\n        try {\n            return getInt(key);\n        } catch (Exception e) {\n            return defaultValue;\n        }\n    }\n\n\n    /**\n     * Get an optional JSONArray associated with a key.\n     * It returns null if there is no such key, or if its value is not a\n     * JSONArray.\n     *\n     * @param key A key string.\n     * @return A JSONArray which is the value.\n     */\n    public JSONArray optJSONArray(String key) {\n        Object o = opt(key);\n        return o instanceof JSONArray ? (JSONArray) o : null;\n    }\n\n\n    /**\n     * Get an optional JSONObject associated with a key.\n     * It returns null if there is no such key, or if its value is not a\n     * JSONObject.\n     *\n     * @param key A key string.\n     * @return A JSONObject which is the value.\n     */\n    public JSONObject optJSONObject(String key) {\n        Object o = opt(key);\n        return o instanceof JSONObject ? (JSONObject) o : null;\n    }\n\n\n    /**\n     * Get an optional long value associated with a key,\n     * or zero if there is no such key or if the value is not a number.\n     * If the value is a string, an attempt will be made to evaluate it as\n     * a number.\n     *\n     * @param key A key string.\n     * @return An object which is the value.\n     */\n    public long optLong(String key) {\n        return optLong(key, 0);\n    }\n\n\n    /**\n     * Get an optional long value associated with a key,\n     * or the default if there is no such key or if the value is not a number.\n     * If the value is a string, an attempt will be made to evaluate it as\n     * a number.\n     *\n     * @param key          A key string.\n     * @param defaultValue The default.\n     * @return An object which is the value.\n     */\n    public long optLong(String key, long defaultValue) {\n        try {\n            return getLong(key);\n        } catch (Exception e) {\n            return defaultValue;\n        }\n    }\n\n\n    /**\n     * Get an optional string associated with a key.\n     * It returns an empty string if there is no such key. If the value is not\n     * a string and is not null, then it is coverted to a string.\n     *\n     * @param key A key string.\n     * @return A string which is the value.\n     */\n    public String optString(String key) {\n        return optString(key, \"\");\n    }\n\n\n    /**\n     * Get an optional string associated with a key.\n     * It returns the defaultValue if there is no such key.\n     *\n     * @param key          A key string.\n     * @param defaultValue The default.\n     * @return A string which is the value.\n     */\n    public String optString(String key, String defaultValue) {\n        Object o = opt(key);\n        return o != null ? o.toString() : defaultValue;\n    }\n\n\n    /**\n     * Put a key/boolean pair in the JSONObject.\n     *\n     * @param key   A key string.\n     * @param value A boolean which is the value.\n     * @return this\n     * @throws JSONException If the key is null.\n     */\n    public JSONObject put(String key, boolean value) throws JSONException {\n        put(key, value ? Boolean.TRUE : Boolean.FALSE);\n        return this;\n    }\n\n\n    /**\n     * Put a key/double pair in the JSONObject.\n     *\n     * @param key   A key string.\n     * @param value A double which is the value.\n     * @return this\n     * @throws JSONException If the key is null or if the number is invalid.\n     */\n    public JSONObject put(String key, double value) throws JSONException {\n        put(key, Double.valueOf(value));\n        return this;\n    }\n\n\n    /**\n     * Put a key/int pair in the JSONObject.\n     *\n     * @param key   A key string.\n     * @param value An int which is the value.\n     * @return this\n     * @throws JSONException If the key is null.\n     */\n    public JSONObject put(String key, int value) throws JSONException {\n        put(key, Integer.valueOf(value));\n        return this;\n    }\n\n\n    /**\n     * Put a key/long pair in the JSONObject.\n     *\n     * @param key   A key string.\n     * @param value A long which is the value.\n     * @return this\n     * @throws JSONException If the key is null.\n     */\n    public JSONObject put(String key, long value) throws JSONException {\n        put(key, Long.valueOf(value));\n        return this;\n    }\n\n\n    /**\n     * Put a key/value pair in the JSONObject. If the value is null,\n     * then the key will be removed from the JSONObject if it is present.\n     *\n     * @param key   A key string.\n     * @param value An object which is the value. It should be of one of these\n     *              types: Boolean, Double, Integer, JSONArray, JSONObject, Long, String,\n     *              or the JSONObject.NULL object.\n     * @return this\n     * @throws JSONException If the value is non-finite number\n     *                       or if the key is null.\n     */\n    public JSONObject put(String key, Object value) throws JSONException {\n        if (key == null) {\n            throw new JSONException(\"Null key.\");\n        }\n        if (value != null) {\n            testValidity(value);\n            this.myHashMap.put(key, value);\n        } else {\n            remove(key);\n        }\n        return this;\n    }\n\n\n    /**\n     * Put a key/value pair in the JSONObject, but only if the\n     * key and the value are both non-null.\n     *\n     * @param key   A key string.\n     * @param value An object which is the value. It should be of one of these\n     *              types: Boolean, Double, Integer, JSONArray, JSONObject, Long, String,\n     *              or the JSONObject.NULL object.\n     * @return this\n     * @throws JSONException If the value is a non-finite number.\n     */\n    public JSONObject putOpt(String key, Object value) throws JSONException {\n        if (key != null && value != null) {\n            put(key, value);\n        }\n        return this;\n    }\n\n\n    /**\n     * Produce a string in double quotes with backslash sequences in all the\n     * right places. A backslash will be inserted within </, allowing JSON\n     * text to be delivered in HTML. In JSON text, a string cannot contain a\n     * control character or an unescaped quote or backslash.\n     *\n     * @param string A String\n     * @return A String correctly formatted for insertion in a JSON text.\n     */\n    public static String quote(String string) {\n        if (string == null || string.length() == 0) {\n            return \"\\\"\\\"\";\n        }\n\n        char b;\n        char c = 0;\n        int i;\n        int len = string.length();\n        StringBuilder sb = new StringBuilder(len + 4);\n        String t;\n\n        sb.append('\"');\n        for (i = 0; i < len; i += 1) {\n            b = c;\n            c = string.charAt(i);\n            switch (c) {\n                case '\\\\':\n                case '\"':\n                    sb.append('\\\\');\n                    sb.append(c);\n                    break;\n                case '/':\n                    if (b == '<') {\n                        sb.append('\\\\');\n                    }\n                    sb.append(c);\n                    break;\n                case '\\b':\n                    sb.append(\"\\\\b\");\n                    break;\n                case '\\t':\n                    sb.append(\"\\\\t\");\n                    break;\n                case '\\n':\n                    sb.append(\"\\\\n\");\n                    break;\n                case '\\f':\n                    sb.append(\"\\\\f\");\n                    break;\n                case '\\r':\n                    sb.append(\"\\\\r\");\n                    break;\n                default:\n                    if (c < ' ') {\n                        t = \"000\" + Integer.toHexString(c);\n                        sb.append(\"\\\\u\" + t.substring(t.length() - 4));\n                    } else {\n                        sb.append(c);\n                    }\n            }\n        }\n        sb.append('\"');\n        return sb.toString();\n    }\n\n    /**\n     * Remove a name and its value, if present.\n     *\n     * @param key The name to be removed.\n     * @return The value that was associated with the name,\n     *         or null if there was no value.\n     */\n    public Object remove(String key) {\n        return myHashMap.remove(key);\n    }\n\n    /**\n     * Throw an exception if the object is an NaN or infinite number.\n     *\n     * @param o The object to test.\n     * @throws JSONException If o is a non-finite number.\n     */\n    static void testValidity(Object o) throws JSONException {\n        if (o != null) {\n            if (o instanceof Double) {\n                if (((Double) o).isInfinite() || ((Double) o).isNaN()) {\n                    throw new JSONException(\n                            \"JSON does not allow non-finite numbers\");\n                }\n            } else if (o instanceof Float) {\n                if (((Float) o).isInfinite() || ((Float) o).isNaN()) {\n                    throw new JSONException(\n                            \"JSON does not allow non-finite numbers.\");\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Produce a JSONArray containing the values of the members of this\n     * JSONObject.\n     *\n     * @param names A JSONArray containing a list of key strings. This\n     *              determines the sequence of the values in the result.\n     * @return A JSONArray of values.\n     * @throws JSONException If any of the values are non-finite numbers.\n     */\n    public JSONArray toJSONArray(JSONArray names) throws JSONException {\n        if (names == null || names.length() == 0) {\n            return null;\n        }\n        JSONArray ja = new JSONArray();\n        for (int i = 0; i < names.length(); i += 1) {\n            ja.put(this.opt(names.getString(i)));\n        }\n        return ja;\n    }\n\n    /**\n     * Make an JSON text of this JSONObject. For compactness, no whitespace\n     * is added. If this would not result in a syntactically correct JSON text,\n     * then null will be returned instead.\n     * <p/>\n     * Warning: This method assumes that the data structure is acyclical.\n     *\n     * @return a printable, displayable, portable, transmittable\n     *         representation of the object, beginning\n     *         with <code>{</code>&nbsp;<small>(left brace)</small> and ending\n     *         with <code>}</code>&nbsp;<small>(right brace)</small>.\n     */\n    @Override\n    public String toString() {\n        try {\n            Iterator keys = keys();\n            StringBuilder sb = new StringBuilder(\"{\");\n\n            while (keys.hasNext()) {\n                if (sb.length() > 1) {\n                    sb.append(',');\n                }\n                Object o = keys.next();\n                sb.append(quote(o.toString()));\n                sb.append(':');\n                sb.append(valueToString(this.myHashMap.get(o)));\n            }\n            sb.append('}');\n            return sb.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n\n    /**\n     * Make a prettyprinted JSON text of this JSONObject.\n     * <p/>\n     * Warning: This method assumes that the data structure is acyclical.\n     *\n     * @param indentFactor The number of spaces to add to each level of\n     *                     indentation.\n     * @return a printable, displayable, portable, transmittable\n     *         representation of the object, beginning\n     *         with <code>{</code>&nbsp;<small>(left brace)</small> and ending\n     *         with <code>}</code>&nbsp;<small>(right brace)</small>.\n     * @throws JSONException If the object contains an invalid number.\n     */\n    public String toString(int indentFactor) throws JSONException {\n        return toString(indentFactor, 0);\n    }\n\n\n    /**\n     * Make a prettyprinted JSON text of this JSONObject.\n     * <p/>\n     * Warning: This method assumes that the data structure is acyclical.\n     *\n     * @param indentFactor The number of spaces to add to each level of\n     *                     indentation.\n     * @param indent       The indentation of the top level.\n     * @return a printable, displayable, transmittable\n     *         representation of the object, beginning\n     *         with <code>{</code>&nbsp;<small>(left brace)</small> and ending\n     *         with <code>}</code>&nbsp;<small>(right brace)</small>.\n     * @throws JSONException If the object contains an invalid number.\n     */\n    String toString(int indentFactor, int indent) throws JSONException {\n        int i;\n        int n = length();\n        if (n == 0) {\n            return \"{}\";\n        }\n        Iterator keys = keys();\n        StringBuilder sb = new StringBuilder(\"{\");\n        int newindent = indent + indentFactor;\n        Object o;\n        if (n == 1) {\n            o = keys.next();\n            sb.append(quote(o.toString()));\n            sb.append(\": \");\n            sb.append(valueToString(this.myHashMap.get(o), indentFactor,\n                    indent));\n        } else {\n            while (keys.hasNext()) {\n                o = keys.next();\n                if (sb.length() > 1) {\n                    sb.append(\",\\n\");\n                } else {\n                    sb.append('\\n');\n                }\n                for (i = 0; i < newindent; i += 1) {\n                    sb.append(' ');\n                }\n                sb.append(quote(o.toString()));\n                sb.append(\": \");\n                sb.append(valueToString(this.myHashMap.get(o), indentFactor,\n                        newindent));\n            }\n            if (sb.length() > 1) {\n                sb.append('\\n');\n                for (i = 0; i < indent; i += 1) {\n                    sb.append(' ');\n                }\n            }\n        }\n        sb.append('}');\n        return sb.toString();\n    }\n\n\n    /**\n     * Make a JSON text of an object value.\n     * <p/>\n     * Warning: This method assumes that the data structure is acyclical.\n     *\n     * @param value The value to be serialized.\n     * @return a printable, displayable, transmittable\n     *         representation of the object, beginning\n     *         with <code>{</code>&nbsp;<small>(left brace)</small> and ending\n     *         with <code>}</code>&nbsp;<small>(right brace)</small>.\n     * @throws JSONException If the value is or contains an invalid number.\n     */\n    static String valueToString(Object value) throws JSONException {\n        if (value == null || value.equals(null)) {\n            return \"null\";\n        }\n        if (value instanceof Number) {\n            return numberToString((Number) value);\n        }\n        if (value instanceof Date) {\n            return dateToString((Date) value);\n        }\n        if (value instanceof Boolean || value instanceof JSONObject) {\n            return value.toString();\n        }\n        if (value instanceof Collection) {\n            return collectionToString((Collection) value);\n        }\n        return quote(value.toString());\n    }\n\n    static void writeValue(Writer writer, Object value) throws IOException {\n        if (value == null || value.equals(null)) {\n            writer.write(\"null\");\n        } else if (value instanceof Number) {\n            writeNumber(writer, (Number) value);\n        } else if (value instanceof Date) {\n            writeDate(writer, (Date) value);\n        } else if (value instanceof Boolean) {\n            writer.write(value.toString());\n        } else if (value instanceof JSONElement) {\n            ((JSONElement)value).writeTo(writer);\n        } else {\n            writeQuoted(writer, value);\n        }\n    }\n\n    static void writeQuoted(Writer writer, Object value) throws IOException {\n        if (useStreamingJavascriptEncoder) {\n            writer.write(\"\\\"\");\n            if (value.getClass() == String.class || value.getClass() == StringBuilder.class || value.getClass() == StringBuffer.class) {\n                encodeToWriter((CharSequence)value, writer);\n            } else if(value instanceof StreamingEncoderWritable) {\n                ((StreamingEncoderWritable)value).encodeTo(writer, javascriptEncoderStateless);\n            } else if (value instanceof Writable) {\n                ((Writable)value).writeTo(new StreamingEncoderWriter(writer, javascriptEncoder, null));\n            }\n            else{\n                encodeToWriter(value.toString(), writer);\n            }\n            writer.write(\"\\\"\");\n        }\n        else {\n            writer.write(valueToString(value));\n        }\n    }\n\n\n    protected static void encodeToWriter(CharSequence str, Writer writer) throws IOException {\n        javascriptEncoderStateless.encodeToWriter(str, 0, str.length(), writer, null);\n    }\n\n    static void writeDate(Writer writer, Date d) throws IOException {\n        writer.write(\"new Date(\");\n        writer.write(String.valueOf(d.getTime()));\n        writer.write(\")\");\n    }\n\n    static void writeNumber(Writer writer, Number value) throws IOException {\n        writer.write(String.valueOf(value));\n    }\n\n    /**\n     * Make a prettyprinted JSON text of an object value.\n     * <p/>\n     * Warning: This method assumes that the data structure is acyclical.\n     *\n     * @param value        The value to be serialized.\n     * @param indentFactor The number of spaces to add to each level of\n     *                     indentation.\n     * @param indent       The indentation of the top level.\n     * @return a printable, displayable, transmittable\n     *         representation of the object, beginning\n     *         with <code>{</code>&nbsp;<small>(left brace)</small> and ending\n     *         with <code>}</code>&nbsp;<small>(right brace)</small>.\n     * @throws JSONException If the object contains an invalid number.\n     */\n    static String valueToString(Object value, int indentFactor, int indent)\n            throws JSONException {\n        if (value == null || value.equals(null)) {\n            return \"null\";\n        }\n        if (value instanceof Number) {\n            return numberToString((Number) value);\n        }\n        if (value instanceof Date) {\n            return dateToString((Date) value);\n        }\n        if (value instanceof Boolean) {\n            return value.toString();\n        }\n        if (value instanceof JSONObject) {\n            return ((JSONObject) value).toString(indentFactor, indent);\n        }\n        if (value instanceof JSONArray) {\n            return ((JSONArray) value).toString(indentFactor, indent);\n        }\n        return quote(value.toString());\n    }\n\n\n    /**\n     * Write the contents of the JSONObject as JSON text to a writer.\n     * For compactness, no whitespace is added.\n     * <p/>\n     * Warning: This method assumes that the data structure is acyclical.\n     *\n     * @return The writer.\n     * @throws JSONException\n     */\n    public Writer write(Writer writer) throws JSONException {\n        try {\n            boolean notFirst = false;\n            writer.write('{');\n            for(Iterator it = myHashMap.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Entry)it.next();\n                if (notFirst) {\n                    writer.write(',');\n                }\n                writeQuoted(writer, entry.getKey());\n                writer.write(':');\n                writeValue(writer, entry.getValue());\n                notFirst = true;\n            }\n            writer.write('}');\n            return writer;\n        } catch (IOException e) {\n            throw new JSONException(e);\n        }\n    }\n\n    public int size() {\n        return myHashMap.size();\n    }\n\n    public boolean isEmpty() {\n        return myHashMap.isEmpty();\n    }\n\n    public boolean containsKey(Object o) {\n        return myHashMap.containsKey(o);\n    }\n\n    public boolean containsValue(Object o) {\n        return myHashMap.containsValue(o);\n    }\n\n    public Object get(Object o) {\n        return myHashMap.get(o);\n    }\n\n    public Object put(Object o, Object o1) {\n        return myHashMap.put(o, o1);\n    }\n\n    public Object remove(Object o) {\n        return myHashMap.remove(o);\n    }\n\n    public void putAll(Map map) {\n        this.myHashMap.putAll(map);\n    }\n\n    public void clear() {\n        this.myHashMap.clear();\n    }\n\n    public Set keySet() {\n        return myHashMap.keySet();\n    }\n\n    public Collection values() {\n        return myHashMap.values();\n    }\n\n    public Set entrySet() {\n        return myHashMap.entrySet();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        JSONObject that = (JSONObject) o;\n\n        if (myHashMap != null ? !myHashMap.equals(that.myHashMap) : that.myHashMap != null) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return (myHashMap != null ? myHashMap.hashCode() : 0);\n    }\n\n\n    @Override\n    public Writer writeTo(Writer out) throws IOException {\n        return write(out);\n    }\n}\n", "/*\n * Copyright 2004-2005 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.grails.web.servlet.mvc;\n\nimport grails.util.Holders;\nimport grails.validation.DeferredBindingActions;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.lang.reflect.Constructor;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport grails.web.servlet.mvc.GrailsHttpSession;\nimport grails.web.servlet.mvc.GrailsParameterMap;\nimport grails.core.GrailsApplication;\nimport grails.core.GrailsControllerClass;\nimport org.grails.core.artefact.ControllerArtefactHandler;\nimport org.grails.core.io.support.GrailsFactoriesLoader;\nimport org.grails.encoder.CodecLookupHelper;\nimport org.grails.encoder.DefaultEncodingStateRegistry;\nimport org.grails.encoder.Encoder;\nimport org.grails.encoder.EncodingStateRegistry;\nimport org.grails.encoder.EncodingStateRegistryLookup;\nimport org.grails.encoder.EncodingStateRegistryLookupHolder;\nimport org.grails.web.beans.PropertyEditorRegistryUtils;\nimport org.grails.web.pages.FilteringCodecsByContentTypeSettings;\nimport grails.web.mvc.FlashScope;\nimport org.grails.web.util.GrailsApplicationAttributes;\nimport org.grails.web.servlet.mvc.exceptions.ControllerExecutionException;\nimport org.springframework.beans.PropertyEditorRegistry;\nimport org.springframework.beans.PropertyEditorRegistrySupport;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.web.context.request.RequestAttributes;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.servlet.handler.DispatcherServletWebRequest;\nimport org.springframework.web.servlet.support.RequestContextUtils;\nimport org.springframework.web.util.UrlPathHelper;\n\n/**\n * Encapsulates a Grails request. An instance of this class is bound to the current thread using\n * Spring's RequestContextHolder which can later be retrieved using:\n *\n * def webRequest = RequestContextHolder.currentRequestAttributes()\n *\n * @author Graeme Rocher\n * @since 3.0\n */\npublic class GrailsWebRequest extends DispatcherServletWebRequest  {\n\n    private static final String REDIRECT_CALLED = GrailsApplicationAttributes.REDIRECT_ISSUED;\n\n    private static final Class<? extends GrailsApplicationAttributes> grailsApplicationAttributesClass = GrailsFactoriesLoader.loadFactoryClasses(GrailsApplicationAttributes.class, GrailsWebRequest.class.getClassLoader()).get(0);\n    private static final Constructor<? extends GrailsApplicationAttributes> grailsApplicationAttributesConstructor = ClassUtils.getConstructorIfAvailable(grailsApplicationAttributesClass, ServletContext.class);\n    private GrailsApplicationAttributes attributes;\n    private GrailsParameterMap params;\n    private GrailsParameterMap originalParams;\n    private GrailsHttpSession session;\n    private boolean renderView = true;\n    private boolean skipFilteringCodec = false;\n    private Encoder filteringEncoder;\n    public static final String ID_PARAMETER = \"id\";\n    private final List<ParameterCreationListener> parameterCreationListeners = new ArrayList<ParameterCreationListener>();\n    private final UrlPathHelper urlHelper = new UrlPathHelper();\n    private ApplicationContext applicationContext;\n    private String baseUrl;\n    private HttpServletResponse wrappedResponse;\n\n    private EncodingStateRegistry encodingStateRegistry;\n    private HttpServletRequest multipartRequest;\n\n    public GrailsWebRequest(HttpServletRequest request, HttpServletResponse response, GrailsApplicationAttributes attributes) {\n        super(request, response);\n        this.attributes = attributes;\n        this.applicationContext = attributes.getApplicationContext();\n        inheritEncodingStateRegistry();\n    }\n\n    public GrailsWebRequest(HttpServletRequest request, HttpServletResponse response, ServletContext servletContext) {\n        super(request, response);\n        try {\n            attributes = grailsApplicationAttributesConstructor.newInstance(servletContext);\n            this.applicationContext = attributes.getApplicationContext();\n        }\n        catch (Exception e) {\n            ReflectionUtils.rethrowRuntimeException(e);\n        }\n        inheritEncodingStateRegistry();\n    }\n\n    public GrailsWebRequest(HttpServletRequest request, HttpServletResponse response, ServletContext servletContext, ApplicationContext applicationContext) {\n        this(request, response, servletContext);\n        this.applicationContext = applicationContext;\n    }\n\n\n    /**\n     * Holds a reference to the {@link org.springframework.web.multipart.MultipartRequest}\n     *\n     * @param multipartRequest The multipart request\n     */\n    public void setMultipartRequest(HttpServletRequest multipartRequest) {\n        this.multipartRequest = multipartRequest;\n    }\n\n    private void inheritEncodingStateRegistry() {\n        GrailsWebRequest parentRequest = GrailsWebRequest.lookup(getRequest());\n        if(parentRequest != null) {\n            this.encodingStateRegistry = parentRequest.getEncodingStateRegistry();\n        }\n    }\n\n    /**\n     * Overriden to return the GrailsParameterMap instance,\n     *\n     * @return An instance of GrailsParameterMap\n     */\n    @Override\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public Map getParameterMap() {\n        if (params == null) {\n            resetParams();\n        }\n        return params;\n    }\n\n    @Override\n    public void requestCompleted() {\n        super.requestCompleted();\n        DeferredBindingActions.clear();\n    }\n\n    /**\n     * @return the out\n     */\n    public Writer getOut() {\n        Writer out = attributes.getOut(getCurrentRequest());\n        if (out == null) {\n            try {\n                return getCurrentResponse().getWriter();\n            } catch (IOException e) {\n                throw new ControllerExecutionException(\"Error retrieving response writer: \" + e.getMessage(), e);\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Whether the web request is still active\n     * @return true if it is\n     */\n    public boolean isActive() {\n        return super.isRequestActive();\n    }\n\n    /**\n     * @param out the out to set\n     */\n    public void setOut(Writer out) {\n        attributes.setOut(getCurrentRequest(), out);\n    }\n\n    /**\n     * @return The ServletContext instance\n     */\n    public ServletContext getServletContext() {\n        return attributes.getServletContext();\n    }\n\n    /**\n     * Returns the context path of the request.\n     * @return the path\n     */\n    @Override\n    public String getContextPath() {\n        final HttpServletRequest request = getCurrentRequest();\n        String appUri = (String) request.getAttribute(GrailsApplicationAttributes.APP_URI_ATTRIBUTE);\n        if (appUri == null) {\n            appUri = urlHelper.getContextPath(request);\n        }\n        return appUri;\n    }\n\n    /**\n     * @return The FlashScope instance for the current request\n     */\n    public FlashScope getFlashScope() {\n        return attributes.getFlashScope(getRequest());\n    }\n\n    /**\n     * @return The currently executing request\n     */\n    public HttpServletRequest getCurrentRequest() {\n        if(multipartRequest != null) {\n            return multipartRequest;\n        }\n        else {\n            return getRequest();\n        }\n    }\n\n    public HttpServletResponse getCurrentResponse() {\n        if(wrappedResponse != null) {\n            return wrappedResponse;\n        } else {\n            return getResponse();\n        }\n    }\n\n    public HttpServletResponse getWrappedResponse() {\n        return wrappedResponse;\n    }\n\n    public void setWrappedResponse(HttpServletResponse wrappedResponse) {\n        this.wrappedResponse = wrappedResponse;\n    }\n\n    /**\n     * @return The Grails params object\n     */\n    public GrailsParameterMap getParams() {\n        if (params == null) {\n            resetParams();\n        }\n        return params;\n    }\n\n    /**\n     * @return The Grails params object\n     */\n    public GrailsParameterMap getOriginalParams() {\n        if (originalParams == null) {\n            originalParams = new GrailsParameterMap(getCurrentRequest());\n        }\n        return originalParams;\n    }\n\n    /**\n     * Reset params by re-reading & initializing parameters from request\n     */\n    public void resetParams() {\n        params = (GrailsParameterMap)getOriginalParams().clone();\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    public void addParametersFrom(Map previousParams) {\n        if (previousParams instanceof GrailsParameterMap) {\n            getParams().addParametersFrom((GrailsParameterMap)previousParams);\n        } else {\n            for (Object key : previousParams.keySet()) {\n                String name = String.valueOf(key);\n                getParams().put(name, previousParams.get(key));\n            }\n        }\n    }\n\n    /**\n     * Informs any parameter creation listeners.\n     */\n    public void informParameterCreationListeners() {\n        for (ParameterCreationListener parameterCreationListener : parameterCreationListeners) {\n            parameterCreationListener.paramsCreated(getParams());\n        }\n    }\n\n    /**\n     * @return The Grails session object\n     */\n    public GrailsHttpSession getSession() {\n        if (session == null) {\n            session = new GrailsHttpSession(getCurrentRequest());\n        }\n\n        return session;\n    }\n\n    /**\n     * @return The GrailsApplicationAttributes instance\n     */\n    public GrailsApplicationAttributes getAttributes() {\n        return attributes;\n    }\n\n    public void setActionName(String actionName) {\n        getCurrentRequest().setAttribute(GrailsApplicationAttributes.ACTION_NAME_ATTRIBUTE, actionName);\n    }\n\n    public void setControllerName(String controllerName) {\n        getCurrentRequest().setAttribute(GrailsApplicationAttributes.CONTROLLER_NAME_ATTRIBUTE, controllerName);\n    }\n\n    public void setControllerNamespace(String controllerNamespace) {\n        getCurrentRequest().setAttribute(GrailsApplicationAttributes.CONTROLLER_NAMESPACE_ATTRIBUTE, controllerNamespace);\n    }\n\n    /**\n     * @return the actionName\n     */\n    public String getActionName() {\n        return (String)getCurrentRequest().getAttribute(GrailsApplicationAttributes.ACTION_NAME_ATTRIBUTE);\n    }\n\n    /**\n     * @return the controllerName\n     */\n    public String getControllerName() {\n        return (String)getCurrentRequest().getAttribute(GrailsApplicationAttributes.CONTROLLER_NAME_ATTRIBUTE);\n    }\n\n    /**\n     * @return the controllerClass\n     */\n    public GrailsControllerClass getControllerClass() {\n        HttpServletRequest currentRequest = getCurrentRequest();\n        GrailsControllerClass controllerClass = (GrailsControllerClass) currentRequest.getAttribute(GrailsApplicationAttributes.GRAILS_CONTROLLER_CLASS);\n        if(controllerClass == null) {\n            Object controllerNameObject = currentRequest.getAttribute(GrailsApplicationAttributes.CONTROLLER_NAME_ATTRIBUTE);\n            if(controllerNameObject != null) {\n                controllerClass = (GrailsControllerClass)getAttributes()\n                                                            .getGrailsApplication()\n                                                            .getArtefactByLogicalPropertyName(ControllerArtefactHandler.TYPE, controllerNameObject.toString());\n                if(controllerClass != null) {\n                    currentRequest.setAttribute(GrailsApplicationAttributes.GRAILS_CONTROLLER_CLASS, controllerClass);\n                }\n            }\n        }\n        return controllerClass;\n    }\n\n    /**\n    * @return the controllerNamespace\n    */\n    public String getControllerNamespace() {\n        return (String)getCurrentRequest().getAttribute(GrailsApplicationAttributes.CONTROLLER_NAMESPACE_ATTRIBUTE);\n    }\n\n    public void setRenderView(boolean renderView) {\n        this.renderView = renderView;\n    }\n\n    /**\n     * @return true if the view for this GrailsWebRequest should be rendered\n     */\n    public boolean isRenderView() {\n        final HttpServletRequest currentRequest = getCurrentRequest();\n        HttpServletResponse currentResponse = getCurrentResponse();\n        return renderView &&\n                !currentResponse.isCommitted() &&\n                currentResponse.getStatus() < 300 &&\n                currentRequest.getAttribute(REDIRECT_CALLED) == null;\n    }\n\n    public String getId() {\n        Object id = getParams().get(ID_PARAMETER);\n        return id == null ? null : id.toString();\n    }\n\n    /**\n     * Returns true if the current executing request is a flow request\n     *\n     * @return true if it is a flow request\n     */\n    public boolean isFlowRequest() {\n        GrailsApplication application = getAttributes().getGrailsApplication();\n        Object controllerClassObject = getControllerClass();\n        GrailsControllerClass controllerClass = null;\n        if(controllerClassObject instanceof GrailsControllerClass) {\n            controllerClass = (GrailsControllerClass) controllerClassObject;\n        }\n\n        if (controllerClass == null) return false;\n\n        String actionName = getActionName();\n        if (actionName == null) actionName = controllerClass.getDefaultAction();\n        if (actionName == null) return false;\n\n        return false;\n    }\n\n    public void addParameterListener(ParameterCreationListener creationListener) {\n        parameterCreationListeners.add(creationListener);\n    }\n\n    /**\n     * Obtains the ApplicationContext object.\n     *\n     * @return The ApplicationContext\n     */\n    public ApplicationContext getApplicationContext() {\n        return applicationContext == null ? getAttributes().getApplicationContext() : applicationContext;\n    }\n\n    /**\n     * Obtains the PropertyEditorRegistry instance.\n     * @return The PropertyEditorRegistry\n     */\n    public PropertyEditorRegistry getPropertyEditorRegistry() {\n        final HttpServletRequest servletRequest = getCurrentRequest();\n        PropertyEditorRegistry registry = (PropertyEditorRegistry) servletRequest.getAttribute(GrailsApplicationAttributes.PROPERTY_REGISTRY);\n        if (registry == null) {\n            registry = new PropertyEditorRegistrySupport();\n            PropertyEditorRegistryUtils.registerCustomEditors(this, registry, RequestContextUtils.getLocale(servletRequest));\n            servletRequest.setAttribute(GrailsApplicationAttributes.PROPERTY_REGISTRY, registry);\n        }\n        return registry;\n    }\n\n    /**\n     * Looks up the GrailsWebRequest from the current request.\n     * @param request The current request\n     * @return The GrailsWebRequest\n     */\n    public static GrailsWebRequest lookup(HttpServletRequest request) {\n        GrailsWebRequest webRequest = (GrailsWebRequest) request.getAttribute(GrailsApplicationAttributes.WEB_REQUEST);\n        return webRequest == null ? lookup() : webRequest;\n    }\n\n    /**\n     * Looks up the current Grails WebRequest instance\n     * @return The GrailsWebRequest instance\n     */\n    public static GrailsWebRequest lookup() {\n        GrailsWebRequest webRequest = null;\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n        if (requestAttributes instanceof GrailsWebRequest) {\n            webRequest = (GrailsWebRequest) requestAttributes;\n        }\n        return webRequest;\n    }\n\n    /**\n     * Sets the id of the request.\n     * @param id The id\n     */\n    public void setId(Object id) {\n        getParams().put(GrailsWebRequest.ID_PARAMETER, id);\n    }\n\n    public String getBaseUrl() {\n        if (baseUrl == null) {\n            HttpServletRequest request=getCurrentRequest();\n            String scheme =request.getScheme();\n            StringBuilder sb=new StringBuilder();\n            sb.append(scheme).append(\"://\").append(request.getServerName());\n            int port = request.getServerPort();\n            if ((\"http\".equals(scheme) && port != 80) || (\"https\".equals(scheme) && port != 443)) {\n                sb.append(\":\").append(port);\n            }\n            String contextPath = request.getContextPath();\n            if (contextPath != null) {\n                sb.append(contextPath);\n            }\n            baseUrl = sb.toString();\n        }\n        return baseUrl;\n    }\n\n    public EncodingStateRegistry getEncodingStateRegistry() {\n        if (encodingStateRegistry == null) {\n            encodingStateRegistry = new DefaultEncodingStateRegistry();\n        }\n        return encodingStateRegistry;\n    }\n\n    private static final class DefaultEncodingStateRegistryLookup implements EncodingStateRegistryLookup {\n        public EncodingStateRegistry lookup() {\n            GrailsWebRequest webRequest = GrailsWebRequest.lookup();\n            return webRequest == null ? null : webRequest.getEncodingStateRegistry();\n        }\n    }\n\n    static {\n        EncodingStateRegistryLookupHolder.setEncodingStateRegistryLookup(new DefaultEncodingStateRegistryLookup());\n    }\n\n    /**\n     * @return true if grails.views.filteringCodecForMimeType settings should be ignored for this request\n     */\n    public boolean isSkipFilteringCodec() {\n        return skipFilteringCodec;\n    }\n\n    public void setSkipFilteringCodec(boolean skipCodec) {\n        this.skipFilteringCodec = skipCodec;\n    }\n\n    public String getFilteringCodec() {\n        return filteringEncoder != null ? filteringEncoder.getCodecIdentifier().getCodecName() : null;\n    }\n    public void setFilteringCodec(String codecName) {\n        filteringEncoder=codecName != null ? CodecLookupHelper.lookupEncoder(attributes.getGrailsApplication(), codecName) : null;\n    }\n\n    public Encoder lookupFilteringEncoder() {\n        if (filteringEncoder == null && applicationContext != null && applicationContext.containsBean(FilteringCodecsByContentTypeSettings.BEAN_NAME)) {\n            filteringEncoder = applicationContext.getBean(FilteringCodecsByContentTypeSettings.BEAN_NAME, FilteringCodecsByContentTypeSettings.class).getEncoderForContentType(getResponse().getContentType());\n        }\n        return filteringEncoder;\n    }\n\n    public Encoder getFilteringEncoder() {\n        return filteringEncoder;\n    }\n\n    public void setFilteringEncoder(Encoder filteringEncoder) {\n        this.filteringEncoder = filteringEncoder;\n    }\n}\n", "/*\n * Copyright 2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.grails.web.servlet.view;\n\nimport groovy.text.Template;\n\nimport java.lang.reflect.UndeclaredThrowableException;\nimport java.util.Map;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.grails.web.util.GrailsApplicationAttributes;\nimport org.grails.web.servlet.mvc.GrailsWebRequest;\nimport org.grails.web.util.WebUtils;\nimport org.springframework.web.context.request.RequestAttributes;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.servlet.view.AbstractUrlBasedView;\n\n\n/**\n * A view applied to a Grails application that ensures an appropriate web request is bound\n *\n * @author Lari Hotari\n * @since 2.4\n */\npublic abstract class AbstractGrailsView extends AbstractUrlBasedView {\n    /**\n     * Delegates to renderMergedOutputModel(..)\n     *\n     * @see #renderMergedOutputModel(java.util.Map, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     *\n     * @param model The view model\n     * @param request The HttpServletRequest\n     * @param response The HttpServletResponse\n     * @throws Exception When an error occurs rendering the view\n     */\n    @Override\n    protected final void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        exposeModelAsRequestAttributes(model, request);\n        renderWithinGrailsWebRequest(model, request, response);\n    }\n\n    private void renderWithinGrailsWebRequest(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response)\n            throws Exception {\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n        boolean attributesChanged = false;\n        try {\n            GrailsWebRequest webRequest;\n            if(!(requestAttributes instanceof GrailsWebRequest)) {\n                webRequest = createGrailsWebRequest(request, response, request.getServletContext());\n                attributesChanged = true;\n                WebUtils.storeGrailsWebRequest(webRequest);\n            } else {\n                webRequest = (GrailsWebRequest)requestAttributes;\n            }\n            renderTemplate(model, webRequest, request, response);\n        } finally {\n            if(attributesChanged) {\n                request.removeAttribute(GrailsApplicationAttributes.WEB_REQUEST);\n                RequestContextHolder.setRequestAttributes(requestAttributes);\n            }\n        }\n    }    \n    \n    /**\n     * Renders a page with the specified TemplateEngine, mode and response.\n     * @param model The model to use\n     * @param request The HttpServletRequest\n     * @param response The HttpServletResponse instance\n     * @param engine The TemplateEngine to use\n     *\n     * @throws java.io.IOException Thrown when an error occurs writing the response\n     */\n    abstract protected void renderTemplate(Map<String, Object> model, GrailsWebRequest webRequest, HttpServletRequest request, HttpServletResponse response) throws Exception;\n    \n    protected GrailsWebRequest createGrailsWebRequest(HttpServletRequest request, HttpServletResponse response,\n            ServletContext servletContext) {\n        return new GrailsWebRequest(request, response, servletContext);\n    }    \n\n    public void rethrowRenderException(Throwable ex, String message) {\n        if (ex instanceof Error) {\n            throw (Error) ex;\n        }        \n        if (ex instanceof RuntimeException) {\n            throw (RuntimeException) ex;\n        }\n        throw new UndeclaredThrowableException(ex, message);\n    }\n    \n    abstract public Template getTemplate();\n}\n"], "fixing_code": ["/*\n * Copyright 2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage grails.databinding;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\n/**\n * This annotation may be applied to a a field to\n * customize initialization of object properties in the data binding process.\n *\n * When the annotation is applied to a field, the value assigned to the\n * annotation should be a Closure which accepts 1 parameter.  The \n * parameter is the object that data binding is being applied to.  \n * The value returned by the Closure will be bound to the field.  The\n * following code demonstrates using this technique to bind a contact\n * to user with the same account as the user.\n *\n<pre>\nclass Contact{\n  Account account\n  String firstName\n} \nclass User {\n    &#064;BindInitializer({\n        obj -&gt; new Contact(account:obj.account)\n    })\n    Contact contact\n    Account account\n}\n</pre>\n \n *\n * @since 3.2.11\n * @see BindingHelper\n * @see DataBindingSource\n */\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface BindInitializer {\n    Class<?> value();\n}\n", "/*\n * Copyright 2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage grails.databinding;\n\nimport grails.databinding.BindingHelper;\nimport grails.databinding.DataBindingSource;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\n/**\n * This annotation may be applied to a class or to a field to\n * customize the data binding process.\n *\n * When the annotation is applied to a field, the value assigned to the\n * annotation should be a Closure which accepts 2 parameters.  The first\n * parameter is the object that data binding is being applied to.  The second\n * parameter is a {@link grails.databinding.DataBindingSource} containing the values being bound to the object.\n * The value returned by the Closure will be bound to the field.  The\n * following code demonstrates using this technique to bind an upper\n * case version of the value in the DataBindingSource to the field.\n *\n<pre>\nclass SomeClass {\n    &#064;BindUsing({\n        obj, source -&gt; source['name']?.toUpperCase()\n    })\n    String name\n}\n</pre>\n *\n * When the annotation is applied to a class, the value assigned to the\n * annotation should be a class which implements the {@link BindingHelper}\n * interface.  An instance of that class will be used any time a value\n * is bound to a property in the class that this annotation has been\n * applied to.\n<pre>\n&#064;BindUsing(SomeClassWhichImplementsBindingHelper)\nclass SomeClass {\n    String someProperty\n    Integer someOtherProperty\n}\n</pre>\n *\n * @author Jeff Brown\n * @since 2.3\n * @see BindingHelper\n * @see DataBindingSource\n */\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface BindUsing {\n    Class<?> value();\n}\n", "/*\n * Copyright 2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage grails.databinding\n\nimport grails.databinding.converters.FormattedValueConverter\nimport grails.databinding.converters.ValueConverter\nimport grails.databinding.events.DataBindingListener\nimport grails.databinding.initializers.ValueInitializer\nimport groovy.transform.CompileStatic\nimport groovy.transform.TypeCheckingMode\nimport groovy.util.slurpersupport.GPathResult\nimport org.codehaus.groovy.reflection.CachedMethod\nimport org.grails.databinding.ClosureValueConverter\nimport org.grails.databinding.ClosureValueInitializer\nimport org.grails.databinding.IndexedPropertyReferenceDescriptor\nimport org.grails.databinding.converters.*\nimport org.grails.databinding.errors.SimpleBindingError\nimport org.grails.databinding.xml.GPathResultMap\n\nimport java.lang.annotation.Annotation\nimport java.lang.reflect.Array\nimport java.lang.reflect.Field\nimport java.lang.reflect.Modifier\nimport java.lang.reflect.ParameterizedType\nimport java.security.ProtectionDomain\n\n/**\n * A data binder that will bind nested Maps to an object.\n *\n <pre>\n class Person {\n     String firstName\n     Address homeAddress\n }\n\n class Address {\n     String city\n     String state\n }\n\n def person = new Person()\n def binder = new SimpleDataBinder()\n binder.bind person, [firstName: 'Steven', homeAddress: [city: 'St. Louis', state: 'Missouri']]\n assert person.firstName == 'Steven'\n assert person.homeAddress.city == 'St. Louis'\n assert person.homeAddress.state == 'Missouri'\n\n </pre>\n *\n * @author Jeff Brown\n * @author Graeme Rocher\n *\n * @since 3.0\n */\n@CompileStatic\nclass SimpleDataBinder implements DataBinder {\n\n    protected Map<Class, StructuredBindingEditor> structuredEditors = new HashMap<Class, StructuredBindingEditor>()\n    ConversionService conversionService\n    protected Map<Class, List<ValueConverter>> conversionHelpers = [:].withDefault { c -> [] }\n    protected Map<Class, FormattedValueConverter> formattedValueConversionHelpers = new HashMap<Class, FormattedValueConverter>()\n    protected static final List<Class> BASIC_TYPES = [\n        String,\n        Boolean,\n        Byte,\n        Short,\n        Integer,\n        Long,\n        Float,\n        Double,\n        Character\n    ] as List<Class>\n\n    static final INDEXED_PROPERTY_REGEX = /(.*)\\[\\s*([^\\s]*)\\s*\\]\\s*$/\n\n    int autoGrowCollectionLimit = 256\n\n    SimpleDataBinder() {\n        registerStructuredEditor Date, new StructuredDateBindingEditor()\n        registerStructuredEditor java.sql.Date, new StructuredSqlDateBindingEditor()\n        registerStructuredEditor Calendar, new StructuredCalendarBindingEditor()\n\n        registerFormattedValueConverter new FormattedDateValueConverter()\n    }\n\n    void registerStructuredEditor(Class clazz, StructuredBindingEditor editor) {\n        structuredEditors[clazz] = editor\n    }\n\n    void registerConverter(ValueConverter converter) {\n        conversionHelpers[converter.targetType] << converter\n    }\n    void registerFormattedValueConverter(FormattedValueConverter converter) {\n        formattedValueConversionHelpers[converter.targetType] = converter\n    }\n\n    /**\n     * \n     * @param obj The object being bound to\n     * @param source The data binding source\n     * @see DataBindingSource\n     */\n    void bind(obj, DataBindingSource source) {\n        bind obj, source, null, null, null, null\n    }\n\n    /**\n     * \n     * @param obj The object being bound to\n     * @param source The data binding source\n     * @param listener A listener which will be notified of data binding events triggered\n     * by this binding\n     * @see DataBindingSource\n     * @see DataBindingListener\n     */\n    void bind(obj, DataBindingSource source, DataBindingListener listener) {\n        bind obj, source, null, null, null, listener\n    }\n\n    /**\n     * \n     * @param obj The object being bound to\n     * @param source The data binding source\n     * @param whiteList A list of property names to be included during this \n     * data binding.  All other properties represented in the binding source \n     * will be ignored\n     * @see DataBindingSource\n     */\n    void bind(obj, DataBindingSource source, List whiteList) {\n        bind obj, source, null, whiteList, null, null\n    }\n\n    /**\n     * \n     * @param obj The object being bound to\n     * @param source The data binding source\n     * @param whiteList A list of property names to be included during this \n     * data binding.  All other properties represented in the binding source \n     * will be ignored\n     * @param blackList A list of properties names to be excluded during\n     * this data binding.  \n     * @see DataBindingSource\n     */\n    void bind(obj, DataBindingSource source, List whiteList, List blackList) {\n        bind obj, source, null, whiteList, blackList, null\n    }\n\n    /**\n     * \n     * @param obj The object being bound to\n     * @param gpath A GPathResult which represents the data being bound.  \n     * @see DataBindingSource\n     */\n    void bind(obj, GPathResult gpath) {\n        bind obj, new SimpleMapDataBindingSource(new GPathResultMap(gpath))\n    }\n\n    /**\n     * \n     * @param obj The object being bound to\n     * @param source The data binding source\n     * @param filter Only properties beginning with filter will be included in the\n     * data binding.  For example, if filter is &quot;person&quot; and the binding\n     * source contains data for properties &quot;person.name&quot; and &quot;author.name&quot;\n     * the value of &quot;person.name&quot; will be bound to obj.name.  The value of\n     * &quot;author.name&quot; will be ignored.\n     * @param whiteList A list of property names to be included during this \n     * data binding.  All other properties represented in the binding source \n     * will be ignored\n     * @param blackList A list of properties names to be excluded during\n     * this data binding.  \n     * @see DataBindingSource\n     */\n    void bind(obj, DataBindingSource source, String filter, List whiteList, List blackList) {\n        bind obj, source, filter, whiteList, blackList, null\n    }\n\n    /**\n     * \n     * @param obj The object being bound to\n     * @param source The data binding source\n     * @param filter Only properties beginning with filter will be included in the\n     * data binding.  For example, if filter is &quot;person&quot; and the binding\n     * source contains data for properties &quot;person.name&quot; and &quot;author.name&quot;\n     * the value of &quot;person.name&quot; will be bound to obj.name.  The value of\n     * &quot;author.name&quot; will be ignored.\n     * @param whiteList A list of property names to be included during this \n     * data binding.  All other properties represented in the binding source \n     * will be ignored\n     * @param blackList A list of properties names to be excluded during\n     * this data binding.  \n     * @param listener A listener which will be notified of data binding events triggered\n     * by this binding\n     * @see DataBindingSource\n     * @see DataBindingListener\n     */\n    void bind(obj, DataBindingSource source, String filter, List whiteList, List blackList, DataBindingListener listener) {\n        doBind obj, source, filter, whiteList, blackList, listener, null\n    }\n\n    protected void doBind(obj, DataBindingSource source, String filter, List whiteList, List blackList, DataBindingListener listener, errors) {\n\n        def keys = source.getPropertyNames()\n        for (String key in keys) {\n            if (!filter || key.startsWith(filter + '.')) {\n                String propName = key\n                if (filter) {\n                    propName = key[(1+filter.size())..-1]\n                }\n                def metaProperty = obj.metaClass.getMetaProperty propName\n\n                if (metaProperty) { // normal property\n                    if (isOkToBind(metaProperty, whiteList, blackList)) {\n                        def val = source[key]\n                        try {\n                            def converter = getValueConverter(obj, metaProperty.name)\n                            if(converter) {\n                                bindProperty obj, source, metaProperty, converter.convert(source), listener, errors\n                            } else {\n                                processProperty obj, metaProperty, preprocessValue(val), source, listener, errors\n                            }\n                        } catch (Exception e) {\n                            addBindingError(obj, propName, val, e, listener, errors)\n                        }\n                    }\n                } else {\n                    def descriptor = getIndexedPropertyReferenceDescriptor propName\n                    if (descriptor) { // indexed property\n                        metaProperty = obj.metaClass.getMetaProperty descriptor.propertyName\n                        if (metaProperty && isOkToBind(metaProperty, whiteList, blackList)) {\n                            def val = source.getPropertyValue key\n                            processIndexedProperty obj, metaProperty, descriptor, val, source, listener, errors\n                        }\n                    } else if (propName.startsWith('_') && propName.length() > 1) { // boolean special handling\n                        def restOfPropertyName = propName[1..-1]\n                        if (!source.containsProperty(restOfPropertyName)) {\n                            metaProperty = obj.metaClass.getMetaProperty restOfPropertyName\n                            if (metaProperty && isOkToBind(metaProperty, whiteList, blackList)) {\n                                if ((Boolean == metaProperty.type || Boolean.TYPE == metaProperty.type)) {\n                                    bindProperty obj, source, metaProperty, false, listener, errors\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    protected boolean isOkToBind(String propName, List whiteList, List blackList) {\n        'class' != propName && 'classLoader' != propName && 'protectionDomain' != propName && 'metaClass' != propName && 'metaPropertyValues' != propName && 'properties' != propName && !blackList?.contains(propName) && (!whiteList || whiteList.contains(propName) || whiteList.find { it -> it?.toString()?.startsWith(propName + '.')})\n    }\n\n    protected boolean isOkToBind(MetaProperty property, List whitelist, List blacklist) {\n        isOkToBind(property.name, whitelist, blacklist) &&\n                (property.type != null) &&\n                !Modifier.isStatic(property.modifiers) &&\n                !(ClassLoader.class.isAssignableFrom(property.type) || ProtectionDomain.class.isAssignableFrom(property.type) || MetaProperty.class.isAssignableFrom(property.type) || CachedMethod.class.isAssignableFrom(property.type))\n    }\n\n    protected IndexedPropertyReferenceDescriptor getIndexedPropertyReferenceDescriptor(propName) {\n        IndexedPropertyReferenceDescriptor descriptor\n        def matcher = propName =~ INDEXED_PROPERTY_REGEX\n        if (matcher) {\n            def indexedPropertyName = matcher.group(1)\n            def index = matcher.group(2)\n            if (index.size() > 2 && ((index.startsWith(\"'\") && index.endsWith(\"'\")) || (index.startsWith('\"') && index.endsWith('\"')))) {\n                index = index[1..-2]\n            }\n            descriptor = new IndexedPropertyReferenceDescriptor(propertyName: indexedPropertyName, index: index)\n        }\n        descriptor\n    }\n\n    protected processProperty(obj, MetaProperty metaProperty, val, DataBindingSource source, DataBindingListener listener, errors) {\n        def propName = metaProperty.name\n        def propertyType = metaProperty.type\n        if (structuredEditors.containsKey(propertyType) && ('struct' == val || 'date.struct' == val)) {\n            def structuredEditor = structuredEditors[propertyType]\n            val = structuredEditor.getPropertyValue obj, propName, source\n        }\n        bindProperty obj, source, metaProperty, val, listener, errors\n    }\n\n    protected SimpleMapDataBindingSource splitIndexedStruct(IndexedPropertyReferenceDescriptor indexedPropertyReferenceDescriptor, DataBindingSource source) {\n        def propName = indexedPropertyReferenceDescriptor.propertyName\n        Map structValues = new HashMap()\n        String prefix = indexedPropertyReferenceDescriptor.toString()\n        for (String propertyName: source.propertyNames) {\n            if (propertyName.startsWith(prefix)) {\n                String deIndexedPropertyName = propName\n                String[] parts = propertyName.split('_')\n                if (parts.length > 1) {\n                    deIndexedPropertyName = deIndexedPropertyName + '_' + parts[1]\n                }\n                structValues.put(deIndexedPropertyName, source.getPropertyValue(propertyName))\n            }\n        }\n        new SimpleMapDataBindingSource(structValues)\n    }\n\n    protected processIndexedProperty(obj, MetaProperty metaProperty, IndexedPropertyReferenceDescriptor indexedPropertyReferenceDescriptor,\n        val, DataBindingSource source, DataBindingListener listener, errors) {\n\n        def propName = indexedPropertyReferenceDescriptor.propertyName\n        def propertyType = metaProperty.type\n        Class genericType = getReferencedTypeForCollection(propName, obj)\n\n        if (structuredEditors.containsKey(genericType) && ('struct' == val || 'date.struct' == val)) {\n            def structuredEditor = structuredEditors[genericType]\n            val = structuredEditor.getPropertyValue obj, propName, splitIndexedStruct(indexedPropertyReferenceDescriptor, source)\n        }\n\n        if (propertyType.isArray()) {\n            def index = Integer.parseInt(indexedPropertyReferenceDescriptor.index)\n            def array = initializeArray(obj, propName, propertyType.componentType, index)\n            if (array != null) {\n                addElementToArrayAt array, index, val\n            }\n        } else if (Collection.isAssignableFrom(propertyType)) {\n            def index = Integer.parseInt(indexedPropertyReferenceDescriptor.index)\n            Collection collectionInstance = initializeCollection obj, propName, propertyType\n            def indexedInstance = null\n            if(!(Set.isAssignableFrom(propertyType))) {\n                indexedInstance = collectionInstance[index]\n            }\n            if (indexedInstance == null) {\n                if (genericType) {\n                    if (genericType.isAssignableFrom(val?.getClass())) {\n                        addElementToCollectionAt obj, propName, collectionInstance, index, val\n                    } else if (isBasicType(genericType)) {\n                        addElementToCollectionAt obj, propName, collectionInstance, index, convert(genericType, val)\n                    } else if (val instanceof Map){\n                        indexedInstance = genericType.newInstance()\n                        bind indexedInstance, new SimpleMapDataBindingSource(val), listener\n                        addElementToCollectionAt obj, propName, collectionInstance, index, indexedInstance\n                    } else if (val instanceof DataBindingSource) {\n                        indexedInstance = genericType.newInstance()\n                        bind indexedInstance, val, listener\n                        addElementToCollectionAt obj, propName, collectionInstance, index, indexedInstance\n                    } else if(genericType.isEnum() && val instanceof CharSequence) {\n                        def enumValue = convertStringToEnum(genericType, val.toString())\n                        addElementToCollectionAt obj, propName, collectionInstance, index, enumValue\n                    } else {\n                        addElementToCollectionAt obj, propName, collectionInstance, index, convert(genericType, val)\n                    }\n                } else {\n                    addElementToCollectionAt obj, propName, collectionInstance, index, val\n                }\n            } else {\n                if (val instanceof Map) {\n                    bind indexedInstance, new SimpleMapDataBindingSource(val), listener\n                } else if (val instanceof DataBindingSource) {\n                    bind indexedInstance, val, listener\n                } else if (val == null && indexedInstance != null) {\n                    addElementToCollectionAt obj, propName, collectionInstance, index, null\n                }\n            }\n        } else if (Map.isAssignableFrom(propertyType)) {\n            Map mapInstance = initializeMap obj, propName\n            if (mapInstance.size() < autoGrowCollectionLimit || mapInstance.containsKey(indexedPropertyReferenceDescriptor.index)) {\n                def referencedType = getReferencedTypeForCollection propName, obj\n                if (referencedType != null) {\n                    if(val instanceof Map) {\n                        mapInstance[indexedPropertyReferenceDescriptor.index] = referencedType.newInstance(val)\n                    } else {\n                        mapInstance[indexedPropertyReferenceDescriptor.index] = convert(referencedType, val)\n                    }\n                } else {\n                    mapInstance[indexedPropertyReferenceDescriptor.index] = val\n                }\n            }\n        }\n    }\n\n        \n    @CompileStatic(TypeCheckingMode.SKIP)\n    protected initializeArray(obj, String propertyName, Class arrayType, int index) {\n        Object[] array = obj[propertyName]\n        if (array == null && index < autoGrowCollectionLimit) {\n            array = Array.newInstance(arrayType, index + 1)\n            obj[propertyName] = array\n        } else if (array != null && array.length <= index && index < autoGrowCollectionLimit) {\n            def newArray = Array.newInstance(arrayType, index + 1)\n            System.arraycopy(array, 0, newArray, 0, array.length)\n            array = newArray\n            obj[propertyName] = newArray\n        }\n        array\n    }\n\n    protected boolean isBasicType(Class c) {\n        BASIC_TYPES.contains(c) || c.isPrimitive()\n    }\n    \n    \n    protected Class<?> getReferencedTypeForCollectionInClass(String propertyName, Class clazz) {\n        Class referencedType\n        def field = getField(clazz, propertyName)\n        if(field) {\n            def genericType = field.genericType\n            if (genericType instanceof ParameterizedType) {\n                ParameterizedType pt = (ParameterizedType)genericType\n                Class rawType = pt.getRawType()\n                if(Map.isAssignableFrom(rawType)) {\n                    referencedType = pt.getActualTypeArguments()[1]\n                } else {\n                    referencedType = pt.getActualTypeArguments()[0]\n                }\n            }\n        }\n        referencedType\n    }\n\n    protected Class<?> getReferencedTypeForCollection(String propertyName, Object obj) {\n        getReferencedTypeForCollectionInClass propertyName, obj.getClass()\n    }\n\n    protected boolean isOkToAddElementAt(Collection collection, int index) {\n        boolean isOk\n        if (collection instanceof Set) {\n            isOk = collection.size() < autoGrowCollectionLimit\n        } else {\n            isOk = (index < autoGrowCollectionLimit || index < collection.size())\n        }\n        return isOk\n    }\n\n    @CompileStatic(TypeCheckingMode.SKIP)\n    protected addElementToCollectionAt(obj, String propertyName, Collection collection, index, val) {\n        if (isOkToAddElementAt(collection, index)) {\n            if (collection instanceof Set) {\n                collection.add val\n            } else {\n                collection[index] = val\n            }\n        }\n    }\n\n    @CompileStatic(TypeCheckingMode.SKIP)\n    protected addElementToArrayAt(array, index, val) {\n        if (array.length > index) {\n            array[index] = convert(array.class.componentType, val)\n        }\n    }\n\n    protected Map initializeMap(obj, String propertyName) {\n        if (obj[propertyName] == null) {\n            obj[propertyName] = [:]\n        }\n        return (Map)obj[propertyName]\n    }\n\n    protected Collection initializeCollection(obj, String propertyName, Class type, boolean reuseExistingCollectionIfExists = true) {\n        def val = null\n        if(reuseExistingCollectionIfExists) {\n            val = obj[propertyName]\n        }\n        if (val == null) {\n            val = getDefaultCollectionInstanceForType(type)\n            obj[propertyName] = val\n        }\n        return (Collection)val\n    }\n    \n    protected getDefaultCollectionInstanceForType(Class type) {\n        def val\n        if (List.isAssignableFrom(type)) {\n            val = []\n        } else if (SortedSet.isAssignableFrom(type)) {\n            val = new TreeSet()\n        } else if (LinkedHashSet.isAssignableFrom(type)) {\n            val = new LinkedHashSet()\n        } else if (Collection.isAssignableFrom(type)) {\n            val = new HashSet()\n        }\n        val\n    }\n\n    /**\n     * Get a ValueConverter for field\n     *\n     * @param field The field to retrieve a converter for\n     * @param formattingValue The format that the converter will use\n     * @return a ValueConverter for field which uses formattingValue for its format\n     * @see BindingFormat\n     */\n    protected ValueConverter getFormattedConverter(Field field, String formattingValue) {\n        ValueConverter converter\n        def formattedConverter = formattedValueConversionHelpers[field.type]\n        if (formattedConverter) {\n            converter = { SimpleMapDataBindingSource source ->\n                def value = preprocessValue(source.getPropertyValue(field.name))\n                def convertedValue = null\n                if(value != null) {\n                    convertedValue = formattedConverter.convert (value, formattingValue)\n                }\n                convertedValue\n            } as ValueConverter\n        }\n        converter\n    }\n\n    protected Field getField(Class clazz, String fieldName) {\n        Field field = null\n        try {\n            field = clazz.getDeclaredField(fieldName)\n        } catch (NoSuchFieldException ignored) {\n            def superClass = clazz.getSuperclass()\n            if(superClass != Object) {\n                field = getField(superClass, fieldName)\n            }\n        }\n        return field\n    }\n\n    protected ValueConverter getValueConverterForField(obj, String propName) {\n        ValueConverter converter\n        try {\n            def field = getField(obj.getClass(), propName)\n            if (field) {\n                def annotation = field.getAnnotation(BindUsing)\n                if (annotation) {\n                    def valueClass = getValueOfBindUsing(annotation)\n                    if (Closure.isAssignableFrom(valueClass)) {\n                        Closure closure = (Closure)valueClass.newInstance(null, null)\n                        converter = new ClosureValueConverter(converterClosure: closure.curry(obj), targetType: field.type)\n                    }\n                } else {\n                    annotation = field.getAnnotation(BindingFormat)\n                    if (annotation) {\n                        converter = getFormattedConverter field, getFormatString(annotation)\n                    }\n                }\n            }\n            return converter\n        } catch (Exception ignored) {\n        }\n    }\n    \n    /**\n     * @param annotation An instance of grails.databinding.BindingUsing or org.grails.databinding.BindingUsing\n     * @return the value Class of the annotation\n     */\n    protected Class getValueOfBindUsing(Annotation annotation) {\n        assert annotation instanceof BindUsing\n        if (annotation instanceof BindUsing) {\n            return ((BindUsing) annotation).value()\n        }\n    }\n    \n    /**\n     * @param annotation An instance of grails.databinding.BindingFormat or org.grails.databinding.BindingFormat\n     * @return the value String of the annotation\n     */\n    protected String getFormatString(Annotation annotation) {\n        assert annotation instanceof BindingFormat\n        if (annotation instanceof BindingFormat) {\n            return ((BindingFormat) annotation).value()\n        }\n    }\n\n    protected ValueConverter getValueConverterForClass(obj, String propName) {\n        ValueConverter converter\n        def objClass = obj.getClass()\n        def annotation = objClass.getAnnotation(BindUsing)\n        if (annotation) {\n            def valueClass = getValueOfBindUsing(annotation)\n            if (BindingHelper.isAssignableFrom(valueClass)) {\n                BindingHelper dataConverter = (BindingHelper) valueClass.getDeclaredConstructor().newInstance()\n                converter = new ClosureValueConverter(converterClosure: { DataBindingSource it -> dataConverter.getPropertyValue(obj, propName, it) })\n            }\n        }\n        converter\n    }\n\n    protected ValueConverter getValueConverter(obj, String propName) {\n        def converter = getValueConverterForField obj, propName\n        if (!converter) {\n            converter = getValueConverterForClass obj, propName\n        }\n        converter\n    }\n\n    @CompileStatic(TypeCheckingMode.SKIP)\n    protected convertStringToEnum(Class<? extends Enum> enumClass, String value) {\n        try {\n            enumClass.valueOf(value)\n        } catch (IllegalArgumentException iae) {}\n    }\n    \n    protected preprocessValue(propertyValue) {\n        propertyValue\n    }\n\n    protected setPropertyValue(obj, DataBindingSource source, MetaProperty metaProperty, propertyValue, DataBindingListener listener) {\n        def convertCollectionElements = false\n        if(propertyValue instanceof Collection) {\n            def referencedType = getReferencedTypeForCollection(metaProperty.name, obj)\n            if(referencedType) {\n                def nonAssignableValue = propertyValue.find { it != null && !(referencedType.isAssignableFrom(it.getClass()))}\n                if(nonAssignableValue != null) {\n                    convertCollectionElements = true\n                }\n            }\n        }\n        \n        setPropertyValue obj, source, metaProperty, propertyValue, listener, convertCollectionElements\n    }\n    \n    protected setPropertyValue(obj, DataBindingSource source, MetaProperty metaProperty, propertyValue, DataBindingListener listener, boolean convertCollectionElements) {\n        def propName = metaProperty.name\n        def propertyType\n        def propertyGetter\n        if (metaProperty instanceof MetaBeanProperty) {\n            def mbp = (MetaBeanProperty)metaProperty\n            propertyType = mbp.getter?.returnType ?: mbp.field?.type\n            propertyGetter = mbp.getter\n        }\n        if (propertyType == null || propertyType == Object) {\n            propertyType = metaProperty.type\n            if(propertyType == null || propertyType == Object) {\n                propertyType = getField(obj.getClass(), propName)?.type ?: Object\n            }\n        }\n        if (propertyValue == null || propertyType == Object || propertyType.isAssignableFrom(propertyValue.getClass())) {\n            if (convertCollectionElements && ((!(propertyValue instanceof Range) && propertyValue instanceof Collection && Collection.isAssignableFrom(propertyType) && propertyGetter))) {\n                addElementsToCollection(obj, propName, propertyValue, true)\n            } else {\n                obj[propName] = propertyValue\n            }\n        } else if (propertyValue instanceof List &&\n                  Set.isAssignableFrom(propertyType) &&\n                  !SortedSet.isAssignableFrom(propertyType)) {\n            addElementsToCollection(obj, propName, propertyValue, true)\n        } else {\n            if (propertyValue instanceof Map) {\n                if (Collection.isAssignableFrom(propertyType) &&\n                   propertyValue.size() == 1 &&\n                   ((Map)propertyValue)[propertyValue.keySet()[0]] instanceof List) {\n                    def key = propertyValue.keySet()[0]\n                    List list = (List)((Map)propertyValue)[key]\n                    addElementsToCollection(obj, propName, list)\n                } else {\n                    if (obj[propName] == null) {\n                        initializeProperty(obj, propName, propertyType, source)\n                    }\n                    bind obj[propName], new SimpleMapDataBindingSource(propertyValue), listener\n                }\n            } else if (propertyValue instanceof DataBindingSource) {\n                if (Collection.isAssignableFrom(propertyType) &&\n                   propertyValue.size() == 1 &&\n                   ((Map)propertyValue)[propertyValue.getPropertyNames()[0]] instanceof List) {\n                    def key = propertyValue.getPropertyNames()[0]\n                    List list = (List)((Map)propertyValue)[key]\n                    addElementsToCollection(obj, propName, list)\n                } else {\n                    if (obj[propName] == null) {\n                        initializeProperty(obj, propName, propertyType, source)\n                    }\n                    bind obj[propName], propertyValue, listener\n                }\n            } else if(Collection.isAssignableFrom(propertyType) && propertyValue instanceof String) {\n                addElementToCollection obj, propName, propertyType, propertyValue, true\n            } else if(Collection.isAssignableFrom(propertyType) && propertyValue instanceof Number) {\n                addElementToCollection obj, propName, propertyType, propertyValue, true\n            } else if(Collection.isAssignableFrom(propertyType) && propertyValue.getClass().isArray()) {\n                addElementsToCollection obj, propName, propertyValue as Collection, true\n            } else {\n                obj[propName] = convert(propertyType, propertyValue)\n            }\n        }\n    }\n    protected addElementToCollection(obj, String propName, Class propertyType, propertyValue, boolean clearCollection) {\n        boolean isSet = false\n        def coll = initializeCollection obj, propName, propertyType\n        if (coll != null) {\n            if (clearCollection) {\n                coll.clear()\n            }\n            def referencedType = getReferencedTypeForCollection propName, obj\n            if (referencedType != null) {\n                if (propertyValue == null || referencedType.isAssignableFrom(propertyValue.getClass())) {\n                    coll << propertyValue\n                    isSet = true\n                } else {\n                    coll << convert(referencedType, propertyValue)\n                    isSet = true\n                }\n            }\n        }\n        isSet\n    }\n\n    protected bindProperty(obj, DataBindingSource source, MetaProperty metaProperty, propertyValue, DataBindingListener listener, errors) {\n        def propName = metaProperty.name\n        if (listener == null || listener.beforeBinding(obj, propName, propertyValue, errors) != false) {\n            try {\n                setPropertyValue obj, source, metaProperty, propertyValue, listener\n            } catch (Exception e) {\n                addBindingError(obj, propName, propertyValue, e, listener, errors)\n            }\n        } else if (listener != null && propertyValue instanceof Map && obj[propName] != null) {\n            bind obj[propName], new SimpleMapDataBindingSource(propertyValue)\n        }\n        listener?.afterBinding obj, propName, errors\n    }\n\n    protected addBindingError(obj, String propName, propertyValue, Exception e, DataBindingListener listener, errors) {\n        if (listener) {\n            def error = new SimpleBindingError(obj, propName, propertyValue, e.cause ?: e)\n            listener.bindingError error, errors\n        }\n    }\n\n    private void addElementsToCollection(obj, String collectionPropertyName, Collection collection, boolean removeExistingElements = false) {\n        Class propertyType = obj.metaClass.getMetaProperty(collectionPropertyName).type\n        def referencedType = getReferencedTypeForCollection(collectionPropertyName, obj)\n        def coll = initializeCollection(obj, collectionPropertyName, propertyType, !removeExistingElements)\n        if (removeExistingElements == true) {\n            coll.clear()\n        }\n        for(element in collection) {\n            if (element == null || referencedType == null || referencedType.isAssignableFrom(element.getClass())) {\n                coll << element\n            } else {\n                coll << convert(referencedType, element)\n            }\n        }\n        obj[collectionPropertyName] = coll\n    }\n\n    protected initializeProperty(obj, String propName, Class propertyType, DataBindingSource source) {\n        def initializer = getPropertyInitializer(obj,propName)\n        if(initializer){\n            obj[propName] = initializer.initialize()\n        }\n        else{\n            obj[propName] = propertyType.newInstance()\n        }        \n    }\n    \n    protected ValueInitializer getPropertyInitializer(obj, String propName){\n        def initializer = getValueInitializerForField obj, propName\n        initializer\n    }\n\n    protected ValueInitializer getValueInitializerForField(obj, String propName) {\n        ValueInitializer initializer\n        try {\n            def field = getField(obj.getClass(), propName)\n            if (field) {\n                def annotation = field.getAnnotation(BindInitializer)\n                if (annotation) {\n                    def valueClass = getValueOfBindInitializer(annotation)\n                    if (Closure.isAssignableFrom(valueClass)) {\n                        Closure closure = (Closure)valueClass.newInstance(null, null)\n                        initializer = new ClosureValueInitializer(initializerClosure: closure.curry(obj), targetType: field.type)\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n        initializer\n    }\n    /**\n     * @param annotation An instance of grails.databinding.BindInitializer \n     * @return the value Class of the annotation\n     */\n    protected Class getValueOfBindInitializer(Annotation annotation) {\n        assert annotation instanceof BindInitializer\n        def value\n        if(annotation instanceof BindInitializer) {\n            value = ((BindInitializer)annotation).value()\n        }\n        value\n    }\n    \n    protected convert(Class typeToConvertTo, value) {\n        if (value == null || typeToConvertTo.isAssignableFrom(value?.getClass())) {\n            return value\n        }\n        if (conversionHelpers.containsKey(typeToConvertTo)) {\n            ValueConverter converter = getConverter(typeToConvertTo, value)\n            if (converter) {\n                return converter.convert(value)\n            }\n        }\n        if (conversionService?.canConvert(value.getClass(), typeToConvertTo)) {\n            return conversionService.convert(value, typeToConvertTo)\n        }\n        if (Collection.isAssignableFrom(typeToConvertTo) && value instanceof String[]) {\n            if (Set == typeToConvertTo) {\n                return value as Set\n            }\n            if (List == typeToConvertTo) {\n                return value as List\n            }\n        } else if (typeToConvertTo.isPrimitive() || typeToConvertTo.isArray()) {\n            return value\n        } else if (value instanceof Map) {\n            def obj = typeToConvertTo.newInstance()\n            bind obj, new SimpleMapDataBindingSource(value)\n            return obj\n        } else if (Enum.isAssignableFrom(typeToConvertTo) && value instanceof String) {\n            return convertStringToEnum((Class<? extends Enum>) typeToConvertTo, value)\n        }\n        typeToConvertTo.newInstance value\n    }\n\n    protected ValueConverter getConverter(Class typeToConvertTo, value) {\n        def converters = conversionHelpers.get(typeToConvertTo)\n        converters?.find { ValueConverter c -> c.canConvert(value) }\n    }\n}\n", "/*\n * Copyright 2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage grails.databinding;\n\n\n/**\n * StructuredBindingEditors convert structured data in a Map\n * into an object.  Typically a structured editor will pull\n * several values out of the Map that are necessary to initialize\n * the state of the object.\n<code>\nclass Address {\n    String state\n    String city\n}\nclass StructuredAddressBindingEditor implements StructuredBindingEditor {\n\n    public Object getPropertyValue(Object obj, String propertyName, Map&lt;String, Object&gt; source) {\n        def address = new Address()\n\n        address.state = source[propertyName + '_someState']\n        address.city = source[propertyName + '_someCity']\n\n        address\n    }\n}\n\ndef binder = new SimpleDataBinder()\nbinder.registerStructuredEditor Address, new StructuredAddressBindingEditor()\ndef resident = new Resident()\ndef bindingSource = [:]\nbindingSource.name = 'Scott'\nbindingSource.homeAddress_someCity = \"Scott's Home City\"\nbindingSource.homeAddress_someState = \"Scott's Home State\"\nbindingSource.workAddress_someState = \"Scott's Work State\"\nbindingSource.workAddress = 'struct'\nbindingSource.homeAddress = 'struct'\n\nbinder.bind resident, bindingSource\n\nresident.name == 'Scott'\nresident.homeAddress\nassert resident.homeAddress.city == \"Scott's Home City\"\nassert resident.homeAddress.state == \"Scott's Home State\"\nassert resident.workAddress\nassert resident.workAddress.state == \"Scott's Work State\"\nassert resident.workAddress.city == null\n</code>\n *\n * @author Jeff Brown\n * @since 3.0\n * @see SimpleDataBinder#registerStructuredEditor(Class, StructuredBindingEditor)\n */\npublic interface StructuredBindingEditor<T> extends BindingHelper<T> {\n    /**\n     * The value returned from this method will be bound to\n     * the property specified by propertyName.\n     *\n     * @param obj The object that data binding is being applied to\n     * @param propertyName The name of the property data binding is being applied to\n     * @param source The source containing all of the values being bound to this object\n     * @return The value which should be bound to propertyName\n     */\n    T getPropertyValue(Object obj, String propertyName, DataBindingSource source);\n}\n", "/*\n * Copyright 2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage grails.databinding.converters;\n\n/**\n * Classes which implement this interface may participate\n * in the data binding process as formatted value converters.\n<pre>\nimport org.grails.databinding.converters.FormattedValueConverter\n\nclass FormattedStringValueConverter implements FormattedValueConverter {\n    def convert(value, String format) {\n        if('UPPERCASE' == format) {\n            value = value.toUpperCase()\n        } else if('LOWERCASE' == format) {\n            value = value.toLowerCase()\n        }\n        value\n    }\n\n    Class getTargetType() {\n        // specifies the type to which this converter may be applied\n        String\n    }\n}\n</pre>\n *\n * @author Jeff Brown\n * @since 3.0\n * @see grails.databinding.BindingFormat\n * @see grails.databinding.SimpleDataBinder\n * @see grails.databinding.SimpleDataBinder#registerFormattedValueConverter(FormattedValueConverter)\n */\npublic interface FormattedValueConverter {\n    /**\n     * Return a formatted value\n     *\n     * @param value The value to be formatted\n     * @param format The format String\n     * @return the formatted value\n     */\n    Object convert(Object value, String format);\n\n    /**\n     * @return the output type of this converter\n     */\n    Class<?> getTargetType();\n}\n", "/*\n * Copyright 2009 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.grails.buffer;\n\nimport groovy.lang.GroovyObject;\nimport groovy.lang.MetaClass;\nimport groovy.lang.Writable;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Writer;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.grails.charsequences.CharSequences;\nimport org.grails.encoder.EncodedAppender;\nimport org.grails.encoder.EncodedAppenderFactory;\nimport org.grails.encoder.EncodedAppenderWriter;\nimport org.grails.encoder.EncodedAppenderWriterFactory;\nimport org.grails.encoder.Encoder;\nimport org.grails.encoder.EncodingStateRegistry;\nimport org.grails.encoder.StreamingEncoder;\nimport org.grails.encoder.StreamingEncoderWriter;\nimport org.codehaus.groovy.runtime.GStringImpl;\nimport org.codehaus.groovy.runtime.InvokerHelper;\nimport org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;\n\n/**\n * PrintWriter implementation that doesn't have synchronization. null object\n * references are ignored in print methods (nothing gets printed)\n *\n * @author Lari Hotari, Sagire Software Oy\n */\npublic class GrailsPrintWriter extends Writer implements GrailsWrappedWriter, EncodedAppenderWriterFactory, GroovyObject {\n    protected static final Log LOG = LogFactory.getLog(GrailsPrintWriter.class);\n    protected static final char CRLF[] = { '\\r', '\\n' };\n    protected boolean trouble = false;\n    protected Writer out;\n    protected boolean allowUnwrappingOut = true;\n    protected boolean usageFlag = false;\n    protected Writer streamCharBufferTarget = null;\n    protected Writer previousOut = null;\n\n    public GrailsPrintWriter(Writer out) {\n        this.metaClass = InvokerHelper.getMetaClass(this.getClass());\n        setOut(out);\n    }\n\n    public boolean isAllowUnwrappingOut() {\n        return allowUnwrappingOut;\n    }\n\n    public Writer unwrap() {\n        if (isAllowUnwrappingOut()) {\n            return getOut();\n        }\n        return this;\n    }\n\n    public boolean isDestinationActivated() {\n        return out != null;\n    }\n\n    public Writer getOut() {\n        return out;\n    }\n\n    public void setOut(Writer newOut) {\n        this.out = unwrapWriter(newOut);\n        this.lock = this.out != null ? this.out : this;\n        this.streamCharBufferTarget = null;\n        this.previousOut = null;\n    }\n\n    protected Writer unwrapWriter(Writer writer) {\n        if (writer instanceof GrailsWrappedWriter ) {\n            return ((GrailsWrappedWriter)writer).unwrap();\n        }\n        return writer;\n    }\n\n    /**\n     * Provides Groovy &lt;&lt; left shift operator, but intercepts call to make sure\n     * nulls are converted to \"\" strings\n     *\n     * @param obj The value\n     * @return Returns this object\n     * @throws IOException\n     */\n    public GrailsPrintWriter leftShift(Object obj) throws IOException {\n        if (trouble || obj == null) {\n            usageFlag = true;\n            return this;\n        }\n\n        Class<?> clazz = obj.getClass();\n        if (clazz == String.class) {\n            write((String)obj);\n        }\n        else if (clazz == StreamCharBuffer.class) {\n            write((StreamCharBuffer)obj);\n        }\n        else if (clazz == GStringImpl.class) {\n            write((Writable)obj);\n        }\n        else if (obj instanceof Writable) {\n            write((Writable)obj);\n        }\n        else if (obj instanceof CharSequence) {\n            try {\n                usageFlag = true;\n                CharSequences.writeCharSequence(getOut(), (CharSequence) obj);\n            }\n            catch (IOException e) {\n                handleIOException(e);\n            }\n        }\n        else {        \n            InvokerHelper.write(this, obj);\n        }\n        return this;\n    }\n\n    public GrailsPrintWriter plus(Object value) throws IOException {\n        usageFlag = true;\n        return leftShift(value);\n    }\n\n    /**\n     * Flush the stream if it's not closed and check its error state. Errors are\n     * cumulative; once the stream encounters an error, this routine will return\n     * true on all successive calls.\n     *\n     * @return true if the print stream has encountered an error, either on the\n     *         underlying output stream or during a format conversion.\n     */\n    public boolean checkError() {\n        return trouble;\n    }\n\n    public void setError() {\n        trouble = true;\n    }\n\n    /**\n     * Flush the stream.\n     *\n     * @see #checkError()\n     */\n    @Override\n    public synchronized void flush() {\n        if (trouble) {\n            return;\n        }\n\n        if (isDestinationActivated()) {\n            try {\n                getOut().flush();\n            }\n            catch (IOException e) {\n                handleIOException(e);\n            }\n        }\n    }\n\n    boolean isTrouble() {\n        return trouble;\n    }\n\n    void handleIOException(IOException e) {\n        if (trouble) {\n            return;\n        }\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"I/O exception in GrailsPrintWriter: \" + e.getMessage(), e);\n        }\n        trouble = true;\n        setError();\n    }\n\n    /**\n     * Print an object. The string produced by the <code>{@link\n     * java.lang.String#valueOf(Object)}</code> method is translated into bytes\n     * according to the platform's default character encoding, and these bytes\n     * are written in exactly the manner of the <code>{@link #write(int)}</code>\n     * method.\n     *\n     * @param obj The <code>Object</code> to be printed\n     * @see java.lang.Object#toString()\n     */\n    public void print(final Object obj) {\n        if (trouble || obj == null) {\n            usageFlag = true;\n            return;\n        }\n\n        Class<?> clazz = obj.getClass();\n        if (clazz == String.class) {\n            write((String)obj);\n        }\n        else if (clazz == StreamCharBuffer.class) {\n            write((StreamCharBuffer)obj);\n        }\n        else if (clazz == GStringImpl.class) {\n            write((Writable)obj);\n        }\n        else if (obj instanceof Writable) {\n            write((Writable)obj);\n        }\n        else if (obj instanceof CharSequence) {\n            try {\n                usageFlag = true;\n                CharSequences.writeCharSequence(getOut(), (CharSequence)obj);\n            }\n            catch (IOException e) {\n                handleIOException(e);\n            }\n        }\n        else {\n            write(String.valueOf(obj));\n        }\n    }\n\n    /**\n     * Print a string. If the argument is <code>null</code> then the string\n     * <code>\"\"</code> is printed. Otherwise, the string's characters are\n     * converted into bytes according to the platform's default character\n     * encoding, and these bytes are written in exactly the manner of the\n     * <code>{@link #write(int)}</code> method.\n     *\n     * @param s The <code>String</code> to be printed\n     */\n    public void print(final String s) {\n        if (s == null) {\n            usageFlag = true;\n            return;\n        }\n        write(s);\n    }\n\n    /**\n     * Writes a string. If the argument is <code>null</code> then the string\n     * <code>\"\"</code> is printed.\n     *\n     * @param s The <code>String</code> to be printed\n     */\n    @Override\n    public void write(final String s) {\n        usageFlag = true;\n        if (trouble || s == null) {\n            return;\n        }\n\n        try {\n            getOut().write(s);\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n    }\n\n    /**\n     * Write a single character.\n     *\n     * @param c int specifying a character to be written.\n     */\n    @Override\n    public void write(final int c) {\n        usageFlag = true;\n        if (trouble)\n            return;\n\n        try {\n            getOut().write(c);\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n    }\n\n    /**\n     * Write a portion of an array of characters.\n     *\n     * @param buf Array of characters\n     * @param off Offset from which to start writing characters\n     * @param len Number of characters to write\n     */\n    @Override\n    public void write(final char buf[], final int off, final int len) {\n        usageFlag = true;\n        if (trouble || buf == null || len == 0)\n            return;\n        try {\n            getOut().write(buf, off, len);\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n    }\n\n    /**\n     * Write a portion of a string.\n     *\n     * @param s A String\n     * @param off Offset from which to start writing characters\n     * @param len Number of characters to write\n     */\n    @Override\n    public void write(final String s, final int off, final int len) {\n        usageFlag = true;\n        if (trouble || s == null || s.length() == 0)\n            return;\n\n        try {\n            getOut().write(s, off, len);\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n    }\n\n    @Override\n    public void write(final char buf[]) {\n        write(buf, 0, buf.length);\n    }\n\n    /** delegate methods, not synchronized **/\n\n    public void print(final boolean b) {\n        if (b) {\n            write(\"true\");\n        }\n        else {\n            write(\"false\");\n        }\n    }\n\n    public void print(final char c) {\n        write(c);\n    }\n\n    public void print(final int i) {\n        write(String.valueOf(i));\n    }\n\n    public void print(final long l) {\n        write(String.valueOf(l));\n    }\n\n    public void print(final float f) {\n        write(String.valueOf(f));\n    }\n\n    public void print(final double d) {\n        write(String.valueOf(d));\n    }\n\n    public void print(final char s[]) {\n        write(s);\n    }\n\n    public void println() {\n        usageFlag = true;\n        write(CRLF);\n    }\n\n    public void println(final boolean b) {\n        print(b);\n        println();\n    }\n\n    public void println(final char c) {\n        print(c);\n        println();\n    }\n\n    public void println(final int i) {\n        print(i);\n        println();\n    }\n\n    public void println(final long l) {\n        print(l);\n        println();\n    }\n\n    public void println(final float f) {\n        print(f);\n        println();\n    }\n\n    public void println(final double d) {\n        print(d);\n        println();\n    }\n\n    public void println(final char c[]) {\n        print(c);\n        println();\n    }\n\n    public void println(final String s) {\n        print(s);\n        println();\n    }\n\n    public void println(final Object o) {\n        print(o);\n        println();\n    }\n\n    @Override\n    public GrailsPrintWriter append(final char c) {\n        try {\n            usageFlag = true;\n            getOut().append(c);\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n        return this;\n    }\n\n    @Override\n    public GrailsPrintWriter append(final CharSequence csq, final int start, final int end) {\n        try {\n            usageFlag = true;\n            if (csq == null)\n                appendNullCharSequence();\n            else\n                CharSequences.writeCharSequence(getOut(), csq, start, end);\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n        return this;\n    }\n\n    protected void appendNullCharSequence() throws IOException {\n        getOut().append(null);\n    }\n\n    @Override\n    public GrailsPrintWriter append(final CharSequence csq) {\n        try {\n            usageFlag = true;\n            if (csq == null)\n                appendNullCharSequence();\n            else\n                CharSequences.writeCharSequence(getOut(), csq);\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n        return this;\n    }\n\n    public GrailsPrintWriter append(final Object obj) {\n        print(obj);\n        return this;\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        throw new CloneNotSupportedException();\n    }\n\n    public void write(final StreamCharBuffer otherBuffer) {\n        usageFlag = true;\n        if (trouble)\n            return;\n\n        try {\n            otherBuffer.writeTo(findStreamCharBufferTarget(true));\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n    }\n\n    protected Writer findStreamCharBufferTarget(boolean markUsed) {\n        boolean allowCaching = markUsed;\n\n        Writer currentOut = getOut();\n        if (allowCaching && streamCharBufferTarget != null && previousOut == currentOut) {\n            return streamCharBufferTarget;\n        }\n\n        Writer target = currentOut;\n        while (target instanceof GrailsWrappedWriter) {\n            GrailsWrappedWriter gpr = ((GrailsWrappedWriter)target);\n            if (gpr.isAllowUnwrappingOut()) {\n                if (markUsed) {\n                    gpr.markUsed();\n                }\n                target = gpr.unwrap();\n            }\n            else {\n                break;\n            }\n        }\n\n        Writer result;\n        if (target instanceof StreamCharBuffer.StreamCharBufferWriter) {\n            result = target;\n        }\n        else {\n            result = currentOut;\n        }\n\n        if (allowCaching) {\n            streamCharBufferTarget = result;\n            previousOut = currentOut;\n        }\n\n        return result;\n    }\n\n    public void print(final StreamCharBuffer otherBuffer) {\n        write(otherBuffer);\n    }\n\n    public void append(final StreamCharBuffer otherBuffer) {\n        write(otherBuffer);\n    }\n\n    public void println(final StreamCharBuffer otherBuffer) {\n        write(otherBuffer);\n        println();\n    }\n\n    public GrailsPrintWriter leftShift(final StreamCharBuffer otherBuffer) {\n        if (otherBuffer != null) {\n            write(otherBuffer);\n        }\n        return this;\n    }\n\n    public void write(final Writable writable) {\n        writeWritable(writable);\n    }\n\n    protected void writeWritable(final Writable writable) {\n        if(writable.getClass() == StreamCharBuffer.class) {\n            write((StreamCharBuffer)writable);\n            return;\n        }\n        \n        usageFlag = true;\n        if (trouble)\n            return;\n\n        try {\n            writable.writeTo(getOut());\n        }\n        catch (IOException e) {\n            handleIOException(e);\n        }\n    }\n\n    public void print(final Writable writable) {\n        writeWritable(writable);\n    }\n\n    public GrailsPrintWriter leftShift(final Writable writable) {\n        writeWritable(writable);\n        return this;\n    }\n\n    public void print(final GStringImpl gstring) {\n        writeWritable(gstring);\n    }\n\n    public GrailsPrintWriter leftShift(final GStringImpl gstring) {\n        writeWritable(gstring);\n        return this;\n    }\n\n    public GrailsPrintWriter leftShift(final String string) {\n        print(string);\n        return this;\n    }\n\n    public boolean isUsed() {\n        if (usageFlag) {\n            return true;\n        }\n\n        Writer target = findStreamCharBufferTarget(false);\n        if (target instanceof StreamCharBuffer.StreamCharBufferWriter) {\n            StreamCharBuffer buffer = ((StreamCharBuffer.StreamCharBufferWriter)target).getBuffer();\n            if (!buffer.isEmpty()) {\n                return true;\n            }\n        }\n        return usageFlag;\n    }\n\n    public void setUsed(boolean newUsed) {\n        usageFlag = newUsed;\n    }\n\n    public boolean resetUsed() {\n        boolean prevUsed = usageFlag;\n        usageFlag = false;\n        return prevUsed;\n    }\n\n    @Override\n    public void close() {\n        if (isDestinationActivated()) {\n            try {\n                getOut().close();\n            }\n            catch (IOException e) {\n                handleIOException(e);\n            }\n        }\n    }\n\n    public void markUsed() {\n        setUsed(true);\n    }\n\n    public Object asType(Class<?> clazz) {\n        if (clazz == PrintWriter.class) {\n            return asPrintWriter();\n        }\n        if (clazz == Writer.class) {\n            return this;\n        }\n        return DefaultTypeTransformation.castToType(this, clazz);\n    }\n\n    public PrintWriter asPrintWriter() {\n        return GrailsPrintWriterAdapter.newInstance(this);\n    }\n\n    public Writer getWriterForEncoder(Encoder encoder, EncodingStateRegistry encodingStateRegistry) {\n        Writer target = null;\n        if (getOut() instanceof EncodedAppenderWriterFactory && getOut() != this) {\n            target = getOut();\n        } else {\n            target = findStreamCharBufferTarget(false);\n        }\n        if (target instanceof EncodedAppenderWriterFactory && target != this) {\n            return ((EncodedAppenderWriterFactory)target).getWriterForEncoder(encoder, encodingStateRegistry);\n        } else if (target instanceof EncodedAppenderFactory) {\n            EncodedAppender encodedAppender=((EncodedAppenderFactory)target).getEncodedAppender();\n            if (encodedAppender != null) {\n                return new EncodedAppenderWriter(encodedAppender, encoder, encodingStateRegistry);\n            }\n        }\n        if (target != null) {\n            if (encoder instanceof StreamingEncoder) {\n                return new StreamingEncoderWriter(target, (StreamingEncoder)encoder, encodingStateRegistry);\n            } else {\n                return new CodecPrintWriter(target, encoder, encodingStateRegistry);\n            }\n        } else {\n            return null;\n        }\n    }\n\n    // GroovyObject interface implementation to speed up metaclass operations\n    private transient MetaClass metaClass;\n\n    public Object getProperty(String property) {\n        return getMetaClass().getProperty(this, property);\n    }\n\n    public void setProperty(String property, Object newValue) {\n        getMetaClass().setProperty(this, property, newValue);\n    }\n\n    public Object invokeMethod(String name, Object args) {\n        return getMetaClass().invokeMethod(this, name, args);\n    }\n\n    public MetaClass getMetaClass() {\n        if (metaClass == null) {\n            metaClass = InvokerHelper.getMetaClass(getClass());\n        }\n        return metaClass;\n    }\n\n    public void setMetaClass(MetaClass metaClass) {\n        this.metaClass = metaClass;\n    }\n}\n", "/*\n * Copyright 2009 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.grails.buffer;\n\nimport groovy.lang.GroovyObjectSupport;\nimport groovy.lang.Writable;\n\nimport java.io.EOFException;\nimport java.io.Externalizable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.lang.ref.SoftReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.codehaus.groovy.runtime.DefaultGroovyMethods;\nimport org.codehaus.groovy.runtime.InvokerHelper;\nimport org.codehaus.groovy.runtime.StringGroovyMethods;\nimport org.grails.encoder.AbstractEncodedAppender;\nimport org.grails.encoder.ChainedEncoders;\nimport org.grails.charsequences.CharArrayAccessible;\nimport org.grails.charsequences.CharSequences;\nimport org.grails.encoder.CodecIdentifier;\nimport org.grails.encoder.DefaultCodecIdentifier;\nimport org.grails.encoder.Encodeable;\nimport org.grails.encoder.EncodedAppender;\nimport org.grails.encoder.EncodedAppenderFactory;\nimport org.grails.encoder.EncodedAppenderWriter;\nimport org.grails.encoder.EncodedAppenderWriterFactory;\nimport org.grails.encoder.Encoder;\nimport org.grails.encoder.EncoderAware;\nimport org.grails.encoder.EncodesToWriter;\nimport org.grails.encoder.EncodingState;\nimport org.grails.encoder.EncodingStateImpl;\nimport org.grails.encoder.EncodingStateRegistry;\nimport org.grails.encoder.EncodingStateRegistryLookup;\nimport org.grails.encoder.EncodingStateRegistryLookupHolder;\nimport org.grails.encoder.StreamEncodeable;\nimport org.grails.encoder.StreamingEncoder;\nimport org.grails.encoder.StreamingEncoderWritable;\nimport org.grails.encoder.WriterEncodedAppender;\n\n/**\n * <p>\n * StreamCharBuffer is a multipurpose in-memory buffer that can replace JDK\n * in-memory buffers (StringBuffer, StringBuilder, StringWriter).\n * </p>\n *\n * <p>\n * Grails GSP rendering uses this class as a buffer that is optimized for performance.\n * </p>\n *\n * <p>\n * StreamCharBuffer keeps the buffer in a linked list of \"chunks\". The main\n * difference compared to JDK in-memory buffers (StringBuffer, StringBuilder and\n * StringWriter) is that the buffer can be held in several smaller buffers\n * (\"chunks\" here). In JDK in-memory buffers, the buffer has to be expanded\n * whenever it gets filled up. The old buffer's data is copied to the new one\n * and the old one is discarded. In StreamCharBuffer, there are several ways to\n * prevent unnecessary allocation and copy operations. The StreamCharBuffer\n * contains a linked list of different type of chunks: char arrays,\n * java.lang.String chunks and other StreamCharBuffers as sub chunks. A\n * StringChunk is appended to the linked list whenever a java.lang.String of a\n * length that exceeds the \"stringChunkMinSize\" value is written to the buffer.\n * </p>\n *\n * <p>\n * Grails tag libraries also use a StreamCharBuffer to \"capture\" the output of\n * the taglib and return it to the caller. The buffer can be appended to it's\n * parent buffer directly without extra object generation (like converting to\n * java.lang.String in between).\n *\n * for example this line of code in a taglib would just append the buffer\n * returned from the body closure evaluation to the buffer of the taglib:<br>\n * <code>out &lt;&lt; body()</code>\n * <br>\n * other example:<br>\n * <code>out &lt;&lt; g.render(template: '/some/template', model:[somebean: somebean])</code>\n * <br>\n * There's no extra java.lang.String generation overhead.\n *\n * </p>\n *\n * <p>\n * There's a java.io.Writer interface for appending character data to the buffer\n * and a java.io.Reader interface for reading data.\n * </p>\n *\n * <p>\n * Each {@link #getReader()} call will create a new reader instance that keeps\n * it own state.<br>\n * There is a alternative method {@link #getReader(boolean)} for creating the\n * reader. When reader is created by calling getReader(true), the reader will\n * remove already read characters from the buffer. In this mode only a single\n * reader instance is supported.\n * </p>\n *\n * <p>\n * There's also several other options for reading data:<br>\n * readAsCharArray()reads the buffer to a char[] array<br>\n * readAsString() reads the buffer and wraps the char[] data as a\n * String<br>\n * {@link #writeTo(Writer)} writes the buffer to a java.io.Writer<br>\n * {@link #toCharArray()} returns the buffer as a char[] array, caches the\n * return value internally so that this method can be called several times.<br>\n * {@link #toString()} returns the buffer as a String, caches the return value\n * internally<br>\n * </p>\n *\n * <p>\n * By using the \"connectTo\" method, one can connect the buffer directly to a\n * target java.io.Writer. The internal buffer gets flushed automaticly to the\n * target whenever the buffer gets filled up. See connectTo(Writer).\n * </p>\n *\n * <p>\n * <b>This class is not thread-safe.</b> Object instances of this class are\n * intended to be used by a single Thread. The Reader and Writer interfaces can\n * be open simultaneous and the same Thread can write and read several times.\n * </p>\n *\n * <p>\n * Main operation principle:<br>\n * </p>\n * <p>\n * StreamCharBuffer keeps the buffer in a linked link of \"chunks\".<br>\n * The main difference compared to JDK in-memory buffers (StringBuffer,\n * StringBuilder and StringWriter) is that the buffer can be held in several\n * smaller buffers (\"chunks\" here).<br>\n * In JDK in-memory buffers, the buffer has to be expanded whenever it gets\n * filled up. The old buffer's data is copied to the new one and the old one is\n * discarded.<br>\n * In StreamCharBuffer, there are several ways to prevent unnecessary allocation\n * and copy operations.\n * </p>\n * <p>\n * There can be several different type of chunks: char arrays (\n * {@code CharBufferChunk}), String chunks ({@code StringChunk}) and other\n * StreamCharBuffers as sub chunks ({@code StreamCharBufferSubChunk}).\n * </p>\n * <p>\n * Child StreamCharBuffers can be changed after adding to parent buffer. The\n * flush() method must be called on the child buffer's Writer to notify the\n * parent that the child buffer's content has been changed (used for calculating\n * total size).\n * </p>\n * <p>\n * A StringChunk is appended to the linked list whenever a java.lang.String of a\n * length that exceeds the \"stringChunkMinSize\" value is written to the buffer.\n * </p>\n * <p>\n * If the buffer is in \"connectTo\" mode, any String or char[] that's length is\n * over writeDirectlyToConnectedMinSize gets written directly to the target. The\n * buffer content will get fully flushed to the target before writing the String\n * or char[].\n * </p>\n * <p>\n * There can be several targets \"listening\" the buffer in \"connectTo\" mode. The\n * same content will be written to all targets.\n * <p>\n * <p>\n * Growable chunksize: By default, a newly allocated chunk's size will grow\n * based on the total size of all written chunks.<br>\n * The default growProcent value is 100. If the total size is currently 1024,\n * the newly created chunk will have a internal buffer that's size is 1024.<br>\n * Growable chunksize can be turned off by setting the growProcent to 0.<br>\n * There's a default maximum chunksize of 1MB by default. The minimum size is\n * the initial chunksize size.<br>\n * </p>\n *\n * <p>\n * System properties to change default configuration parameters:<br>\n * <table>\n * <tr>\n * <th>System Property name</th>\n * <th>Description</th>\n * <th>Default value</th>\n * </tr>\n * <tr>\n * <td>streamcharbuffer.chunksize</td>\n * <td>default chunk size - the size the first allocated buffer</td>\n * <td>512</td>\n * </tr>\n * <tr>\n * <td>streamcharbuffer.maxchunksize</td>\n * <td>maximum chunk size - the maximum size of the allocated buffer</td>\n * <td>1048576</td>\n * </tr>\n * <tr>\n * <td>streamcharbuffer.growprocent</td>\n * <td>growing buffer percentage - the newly allocated buffer is defined by\n * total_size * (growpercent/100)</td>\n * <td>100</td>\n * </tr>\n * <tr>\n * <td>streamcharbuffer.subbufferchunkminsize</td>\n * <td>minimum size of child StreamCharBuffer chunk - if the size is smaller,\n * the content is copied to the parent buffer</td>\n * <td>512</td>\n * </tr>\n * <tr>\n * <td>streamcharbuffer.substringchunkminsize</td>\n * <td>minimum size of String chunks - if the size is smaller, the content is\n * copied to the buffer</td>\n * <td>512</td>\n * </tr>\n * <tr>\n * <td>streamcharbuffer.chunkminsize</td>\n * <td>minimum size of chunk that gets written directly to the target in\n * connected mode.</td>\n * <td>256</td>\n * </tr>\n * </table>\n *\n * Configuration values can also be changed for each instance of\n * StreamCharBuffer individually. Default values are defined with System\n * Properties.\n *\n * </p>\n *\n * @author Lari Hotari, Sagire Software Oy\n */\npublic class StreamCharBuffer extends GroovyObjectSupport implements Writable, CharSequence, Externalizable, Encodeable, StreamEncodeable, StreamingEncoderWritable, EncodedAppenderWriterFactory, Cloneable {\n    private static final int EXTERNALIZABLE_VERSION = 2;\n    static final long serialVersionUID = EXTERNALIZABLE_VERSION;\n    private static final Log log=LogFactory.getLog(StreamCharBuffer.class);\n\n    private static final int DEFAULT_CHUNK_SIZE = Integer.getInteger(\"streamcharbuffer.chunksize\", 512);\n    private static final int DEFAULT_MAX_CHUNK_SIZE = Integer.getInteger(\"streamcharbuffer.maxchunksize\", 1024*1024);\n    private static final int DEFAULT_CHUNK_SIZE_GROW_PROCENT = Integer.getInteger(\"streamcharbuffer.growprocent\", 100);\n    private static final int SUB_BUFFERCHUNK_MIN_SIZE = Integer.getInteger(\"streamcharbuffer.subbufferchunkminsize\", 512);\n    private static final int SUB_STRINGCHUNK_MIN_SIZE = Integer.getInteger(\"streamcharbuffer.substringchunkminsize\", 512);\n    private static final int WRITE_DIRECT_MIN_SIZE = Integer.getInteger(\"streamcharbuffer.writedirectminsize\", 1024);\n    private static final int CHUNK_MIN_SIZE = Integer.getInteger(\"streamcharbuffer.chunkminsize\", 256);\n\n    private final int firstChunkSize;\n    private final int growProcent;\n    private final int maxChunkSize;\n    private int subStringChunkMinSize = SUB_STRINGCHUNK_MIN_SIZE;\n    private int subBufferChunkMinSize = SUB_BUFFERCHUNK_MIN_SIZE;\n    private int writeDirectlyToConnectedMinSize = WRITE_DIRECT_MIN_SIZE;\n    private int chunkMinSize = CHUNK_MIN_SIZE;\n\n    private int chunkSize;\n    private int totalChunkSize;\n\n    private final StreamCharBufferWriter writer;\n    private List<ConnectToWriter> connectToWriters;\n    private ConnectedWritersWriter connectedWritersWriter;\n    private Boolean notConnectedToEncodeAwareWriters=null;\n\n    boolean preferSubChunkWhenWritingToOtherBuffer=false;\n\n    private AllocatedBuffer allocBuffer;\n    private AbstractChunk firstChunk;\n    private AbstractChunk lastChunk;\n    private int totalCharsInList;\n    private int totalCharsInDynamicChunks;\n    private int sizeAtLeast;\n    private StreamCharBufferKey bufferKey = new StreamCharBufferKey();\n    private Map<StreamCharBufferKey, StreamCharBufferSubChunk> dynamicChunkMap;\n\n    private Set<SoftReference<StreamCharBufferKey>> parentBuffers;\n    int allocatedBufferIdSequence = 0;\n    int readerCount = 0;\n    boolean hasReaders = false;\n    int bufferChangesCounter = 0;\n\n    boolean notifyParentBuffersEnabled = true;\n    boolean subBuffersEnabled = true;\n\n    public StreamCharBuffer() {\n        this(DEFAULT_CHUNK_SIZE, DEFAULT_CHUNK_SIZE_GROW_PROCENT, DEFAULT_MAX_CHUNK_SIZE);\n    }\n\n    public StreamCharBuffer(int chunkSize) {\n        this(chunkSize, DEFAULT_CHUNK_SIZE_GROW_PROCENT, DEFAULT_MAX_CHUNK_SIZE);\n    }\n\n    public StreamCharBuffer(int chunkSize, int growProcent) {\n        this(chunkSize, growProcent, DEFAULT_MAX_CHUNK_SIZE);\n    }\n\n    public StreamCharBuffer(int chunkSize, int growProcent, int maxChunkSize) {\n        this.firstChunkSize = chunkSize;\n        this.growProcent = growProcent;\n        this.maxChunkSize = maxChunkSize;\n        writer = new StreamCharBufferWriter();\n        reset(true);\n    }\n\n    private class StreamCharBufferKey {\n        StreamCharBuffer getBuffer() { return StreamCharBuffer.this; }\n    }\n\n    public boolean isPreferSubChunkWhenWritingToOtherBuffer() {\n        return preferSubChunkWhenWritingToOtherBuffer;\n    }\n\n    public void setPreferSubChunkWhenWritingToOtherBuffer(boolean prefer) {\n        preferSubChunkWhenWritingToOtherBuffer = prefer;\n        notifyPreferSubChunkEnabled();\n    }\n\n    protected void notifyPreferSubChunkEnabled() {\n        if(isPreferSubChunkWhenWritingToOtherBuffer() && parentBuffers != null && isNotifyParentBuffersEnabled()) {\n            for(StreamCharBuffer parentBuffer : getCurrentParentBuffers()) {\n                if(!parentBuffer.isPreferSubChunkWhenWritingToOtherBuffer()) {\n                    parentBuffer.setPreferSubChunkWhenWritingToOtherBuffer(true);\n                }\n            }\n        }\n    }\n\n    public final void reset() {\n        reset(true);\n    }\n\n    /**\n     * resets the state of this buffer (empties it)\n     *\n     * @param resetChunkSize\n     */\n    public final void reset(boolean resetChunkSize) {\n        markBufferChanged();\n        firstChunk = null;\n        lastChunk = null;\n        totalCharsInList = 0;\n        totalCharsInDynamicChunks = -1;\n        sizeAtLeast = -1;\n        if (resetChunkSize) {\n            chunkSize = firstChunkSize;\n            totalChunkSize = 0;\n        }\n        if (allocBuffer == null) {\n            allocBuffer = new AllocatedBuffer(chunkSize);\n        } else {\n            allocBuffer.clear();\n        }\n        if (dynamicChunkMap == null) {\n            dynamicChunkMap = new HashMap<StreamCharBufferKey, StreamCharBufferSubChunk>();\n        } else {\n            dynamicChunkMap.clear();\n        }\n    }\n\n    /**\n     * Clears the buffer and notifies the parents of this buffer of the change.\n     */\n    public final void clear() {\n        reset();\n        notifyBufferChange();\n    }\n\n    /**\n     * Connect this buffer to a target Writer.\n     *\n     * When the buffer (a chunk) get filled up, it will automaticly write it's content to the Writer\n     *\n     * @param w\n     */\n    public final void connectTo(Writer w) {\n        connectTo(w, true);\n    }\n\n    public final void connectTo(Writer w, boolean autoFlush) {\n        initConnected();\n        connectToWriters.add(new ConnectToWriter(w, autoFlush));\n        initConnectedWritersWriter();\n    }\n\n    public final void encodeInStreamingModeTo(final EncoderAware encoderLookup, final EncodingStateRegistryLookup encodingStateRegistryLookup, boolean autoFlush, final Writer w) {\n        encodeInStreamingModeTo(encoderLookup, encodingStateRegistryLookup, autoFlush, new LazyInitializingWriter() {\n            public Writer getWriter() throws IOException {\n                return w;\n            }\n        });\n    }\n\n    public final void encodeInStreamingModeTo(final EncoderAware encoderLookup, final EncodingStateRegistryLookup encodingStateRegistryLookup, final boolean autoFlush, final LazyInitializingWriter... writers) {\n        LazyInitializingWriter encodingWriterInitializer = createEncodingInitializer(encoderLookup,\n                encodingStateRegistryLookup, writers);\n        connectTo(encodingWriterInitializer, autoFlush);\n    }\n\n    public LazyInitializingWriter createEncodingInitializer(final EncoderAware encoderLookup,\n            final EncodingStateRegistryLookup encodingStateRegistryLookup, final LazyInitializingWriter... writers) {\n        LazyInitializingWriter encodingWriterInitializer=new LazyInitializingMultipleWriter() {\n            Writer lazyWriter;\n\n            public Writer getWriter() throws IOException {\n                return lazyWriter;\n            }\n\n            public LazyInitializingWriter[] initializeMultiple(StreamCharBuffer buffer, boolean autoFlushMode) throws IOException {\n                Encoder encoder = encoderLookup.getEncoder();\n                if (encoder != null) {\n                    EncodingStateRegistry encodingStateRegistry = encodingStateRegistryLookup.lookup();\n                    StreamCharBuffer encodeBuffer=new StreamCharBuffer(chunkSize, growProcent, maxChunkSize);\n                    encodeBuffer.setAllowSubBuffers(false);\n                    lazyWriter=encodeBuffer.getWriterForEncoder(encoder, encodingStateRegistry);\n                    for(LazyInitializingWriter w : writers) {\n                        encodeBuffer.connectTo(w, autoFlushMode);\n                    }\n                    return new LazyInitializingWriter[]{this};\n                } else {\n                    return writers;\n                }\n            }\n        };\n        return encodingWriterInitializer;\n    }\n\n    private void initConnectedWritersWriter() {\n        notConnectedToEncodeAwareWriters = null;\n        connectedWritersWriter = null;\n        setNotifyParentBuffersEnabled(false);\n    }\n\n    private void startUsingConnectedWritersWriter() throws IOException {\n        if (connectedWritersWriter == null) {\n            List<ConnectedWriter> connectedWriters=new ArrayList<ConnectedWriter>();\n\n            for(ConnectToWriter connectToWriter : connectToWriters) {\n                for(Writer writer : connectToWriter.getWriters()) {\n                    Writer target=writer;\n                    if (target instanceof GrailsWrappedWriter) {\n                        target = ((GrailsWrappedWriter)target).unwrap();\n                    }\n                    if (target==null) {\n                        throw new NullPointerException(\"target is null\");\n                    }\n                    connectedWriters.add(new ConnectedWriter(target, connectToWriter.isAutoFlush()));\n                }\n            }\n\n            if (connectedWriters.size() > 1) {\n                connectedWritersWriter = new MultiOutputWriter(connectedWriters);\n            }\n            else {\n                connectedWritersWriter = new SingleOutputWriter(connectedWriters.get(0));\n            }\n        }\n    }\n\n    public final void connectTo(LazyInitializingWriter w) {\n        connectTo(w, true);\n    }\n\n    public final void connectTo(LazyInitializingWriter w, boolean autoFlush) {\n        initConnected();\n        connectToWriters.add(new ConnectToWriter(w, autoFlush));\n        initConnectedWritersWriter();\n    }\n\n    public final void removeConnections() {\n        if (connectToWriters != null) {\n            connectToWriters = null;\n            connectedWritersWriter = null;\n            notConnectedToEncodeAwareWriters = null;\n        }\n    }\n\n    private void initConnected() {\n        if (connectToWriters == null) {\n            connectToWriters = new ArrayList<ConnectToWriter>(2);\n        }\n    }\n\n    public int getSubStringChunkMinSize() {\n        return subStringChunkMinSize;\n    }\n\n    /**\n     * Minimum size for a String to be added as a StringChunk instead of copying content to the char[] buffer of the current StreamCharBufferChunk\n     *\n     * @param size\n     */\n    public void setSubStringChunkMinSize(int size) {\n        subStringChunkMinSize = size;\n    }\n\n    public int getSubBufferChunkMinSize() {\n        return subBufferChunkMinSize;\n    }\n\n    public void setSubBufferChunkMinSize(int size) {\n        subBufferChunkMinSize = size;\n    }\n\n    public int getWriteDirectlyToConnectedMinSize() {\n        return writeDirectlyToConnectedMinSize;\n    }\n\n    /**\n     * Minimum size for a String or char[] to get written directly to connected writer (in \"connectTo\" mode).\n     *\n     * @param size\n     */\n    public void setWriteDirectlyToConnectedMinSize(int size) {\n        writeDirectlyToConnectedMinSize = size;\n    }\n\n    public int getChunkMinSize() {\n        return chunkMinSize;\n    }\n\n    public void setChunkMinSize(int size) {\n        chunkMinSize = size;\n    }\n\n    /**\n     * Writer interface for adding/writing data to the buffer.\n     *\n     * @return the Writer\n     */\n    public Writer getWriter() {\n        return writer;\n    }\n\n    /**\n     * Creates a new Reader instance for reading/consuming data from the buffer.\n     * Each call creates a new instance that will keep it's reading state. There can be several readers on the buffer. (single thread only supported)\n     *\n     * @return the Reader\n     */\n    public Reader getReader() {\n        return getReader(false);\n    }\n\n    /**\n     * Like getReader(), but when removeAfterReading is true, the read data will be removed from the buffer.\n     *\n     * @param removeAfterReading\n     * @return the Reader\n     */\n    public Reader getReader(boolean removeAfterReading) {\n        readerCount++;\n        hasReaders = true;\n        return new StreamCharBufferReader(removeAfterReading);\n    }\n\n    /**\n     * Writes the buffer content to a target java.io.Writer\n     *\n     * @param target\n     * @throws IOException\n     */\n    public Writer writeTo(Writer target) throws IOException {\n        writeTo(target, false, false);\n        return target;\n    }\n\n    /**\n     * Writes the buffer content to a target java.io.Writer\n     *\n     * @param target Writer\n     * @param flushTarget calls target.flush() before finishing\n     * @param emptyAfter empties the buffer if true\n     * @throws IOException\n     */\n    public void writeTo(Writer target, boolean flushTarget, boolean emptyAfter) throws IOException {\n        if (target instanceof GrailsWrappedWriter) {\n            GrailsWrappedWriter wrappedWriter = ((GrailsWrappedWriter)target);\n            if (wrappedWriter.isAllowUnwrappingOut()) {\n                target = wrappedWriter.unwrap();\n            }\n        }\n        if (target == writer) {\n            throw new IllegalArgumentException(\"Cannot write buffer to itself.\");\n        }\n        if (!emptyAfter && target instanceof StreamCharBufferWriter) {\n            ((StreamCharBufferWriter)target).write(this, null);\n            return;\n        } else if (writeToEncodedAppender(this, target, writer.getEncodedAppender(), true)) {\n            if (emptyAfter) {\n                emptyAfterReading();\n            }\n            if (flushTarget) {\n                target.flush();\n            }\n            return;\n        }\n        writeToImpl(target, flushTarget, emptyAfter);\n    }\n\n    private static boolean writeToEncodedAppender(StreamCharBuffer source, Writer target, EncodedAppender notAllowedAppender, boolean flush) throws IOException {\n        if (target instanceof EncodedAppenderFactory) {\n            EncodedAppenderFactory eaw = (EncodedAppenderFactory)target;\n            EncodedAppender appender = eaw.getEncodedAppender();\n            if (appender != null) {\n                if (appender == notAllowedAppender) {\n                    throw new IllegalArgumentException(\"Cannot write buffer to itself.\");\n                }\n                Encoder encoder = null;\n\n                if (target instanceof EncoderAware) {\n                    encoder = ((EncoderAware)target).getEncoder();\n                }\n\n                if (encoder == null && appender instanceof EncoderAware) {\n                    encoder = ((EncoderAware)appender).getEncoder();\n                }\n\n                source.encodeTo(appender, encoder);\n                if(flush) {\n                appender.flush();\n                }\n                return true;\n                }\n            }\n        return false;\n        }\n\n    private void writeToImpl(Writer target, boolean flushTarget, boolean emptyAfter) throws IOException {\n        AbstractChunk current = firstChunk;\n        while (current != null) {\n            current.writeTo(target);\n            current = current.next;\n        }\n        allocBuffer.writeTo(target);\n        if (emptyAfter) {\n            emptyAfterReading();\n        }\n        if (flushTarget) {\n            target.flush();\n        }\n    }\n\n    protected void emptyAfterReading() {\n        firstChunk = null;\n        lastChunk = null;\n        totalCharsInList = 0;\n        totalCharsInDynamicChunks = -1;\n        sizeAtLeast = -1;\n        dynamicChunkMap.clear();\n        allocBuffer.clear();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Reads (and empties) the buffer to a String, but caches the return value for subsequent calls.\n     * If more content has been added between 2 calls, the returned value will be joined from the previously cached value and the data read from the buffer.\n     *\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        StringChunk stringChunk = readToSingleStringChunk(true);\n        if (stringChunk != null) {\n            return stringChunk.str;\n        } else {\n            return \"\";\n        }\n    }\n\n    public StringChunk readToSingleStringChunk(boolean registerEncodingState) {\n        if (firstChunk == lastChunk && firstChunk instanceof StringChunk && allocBuffer.charsUsed() == 0 &&\n                ((StringChunk)firstChunk).isSingleBuffer()) {\n            StringChunk chunk = ((StringChunk)firstChunk);\n            if (registerEncodingState) {\n                markEncoded(chunk);\n            }\n            return chunk;\n        }\n\n        int initialReaderCount = readerCount;\n        MultipartCharBufferChunk chunk = readToSingleChunk();\n        MultipartStringChunk stringChunk = (chunk != null) ? chunk.asStringChunk() : null;\n        if (initialReaderCount == 0) {\n            // if there are no readers, the result can be cached\n            reset();\n            if (stringChunk != null) {\n                addChunk(stringChunk);\n            }\n        }\n\n        if (registerEncodingState) {\n            markEncoded(stringChunk);\n        }\n\n        return stringChunk;\n    }\n\n    public void markEncoded(StringChunk strChunk) {\n        if (strChunk instanceof MultipartStringChunk) {\n            MultipartStringChunk stringChunk = (MultipartStringChunk)strChunk;\n            if (stringChunk.isSingleEncoding()) {\n                EncodingState encodingState = stringChunk.firstPart.encodingState;\n                if (encodingState != null && encodingState.getEncoders() != null && encodingState.getEncoders().size() > 0) {\n                    Encoder encoder=encodingState.getEncoders().iterator().next();\n                    if (encoder != null)\n                        encoder.markEncoded(stringChunk.str);\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Uses String's hashCode to support compatibility with String instances in maps, sets, etc.\n     *\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        return toString().hashCode();\n    }\n\n    /**\n     * equals uses String.equals to check for equality to support compatibility with String instances in maps, sets, etc.\n     *\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (o==this) return true;\n\n        if (!(o instanceof CharSequence)) return false;\n\n        CharSequence other = (CharSequence) o;\n\n        return toString().equals(other.toString());\n    }\n\n    public String plus(String value) {\n        return toString() + value;\n    }\n\n    public String plus(Object value) {\n        return toString() + value;\n    }\n\n    /**\n     * Reads the buffer to a char[].\n     *\n     * Caches the result if there aren't any readers.\n     *\n     * @return the chars\n     */\n    public char[] toCharArray() {\n        // check if there is a cached single charbuffer\n        if (firstChunk == lastChunk && firstChunk instanceof CharBufferChunk && allocBuffer.charsUsed()==0 && ((CharBufferChunk)firstChunk).isSingleBuffer()) {\n            return ((CharBufferChunk)firstChunk).buffer;\n        }\n\n        int initialReaderCount = readerCount;\n        MultipartCharBufferChunk chunk = readToSingleChunk();\n        if (initialReaderCount == 0) {\n            // if there are no readers, the result can be cached\n            reset();\n            if (chunk != null) {\n                addChunk(chunk);\n            }\n        }\n        if(chunk != null) {\n            return chunk.buffer;\n        } else {\n            return new char[0];\n        }\n    }\n\n    public static final class EncodedPart {\n        private final EncodingState encodingState;\n        private final String part;\n\n        public EncodedPart(EncodingState encodingState, String part) {\n            this.encodingState = encodingState;\n            this.part = part;\n        }\n\n        public EncodingState getEncodingState() {\n            return encodingState;\n        }\n\n        public String getPart() {\n            return part;\n        }\n\n        @Override\n        public String toString() {\n            return \"EncodedPart [encodingState='\" + encodingState + \"', part='\" + part + \"']\";\n        }\n    }\n\n    public List<EncodedPart> dumpEncodedParts() {\n        List<EncodedPart> encodedParts = new ArrayList<StreamCharBuffer.EncodedPart>();\n        MultipartStringChunk mpStringChunk = readToSingleChunk().asStringChunk();\n        if (mpStringChunk.firstPart != null) {\n            EncodingStatePart current = mpStringChunk.firstPart;\n            int offset = 0;\n            char[] buf=StringCharArrayAccessor.getValue(mpStringChunk.str);\n            while (current != null) {\n                encodedParts.add(new EncodedPart(current.encodingState, new String(buf, offset, current.len)));\n                offset += current.len;\n                current = current.next;\n            }\n        }\n        return encodedParts;\n    }\n\n    private MultipartCharBufferChunk readToSingleChunk() {\n        int currentSize = size();\n        if (currentSize == 0) {\n            return null;\n        }\n\n        FixedCharArrayEncodedAppender appender=new FixedCharArrayEncodedAppender(currentSize);\n        try {\n            encodeTo(appender, null);\n        }\n        catch (IOException e) {\n            throw new RuntimeException(\"Unexpected IOException\", e);\n        }\n        appender.finish();\n        return appender.chunk;\n    }\n    \n    boolean hasQuicklyCalcutableSize() {\n        return totalCharsInDynamicChunks != -1 || dynamicChunkMap.size() == 0;\n    }\n\n    public int size() {\n        int total = totalCharsInList;\n        if (totalCharsInDynamicChunks == -1) {\n            totalCharsInDynamicChunks = 0;\n            for (StreamCharBufferSubChunk chunk : dynamicChunkMap.values()) {\n                totalCharsInDynamicChunks += chunk.size();\n            }\n        }\n        total += totalCharsInDynamicChunks;\n        total += allocBuffer.charsUsed();\n        sizeAtLeast = total;\n        return total;\n    }\n\n    public boolean isEmpty() {\n        return !isNotEmpty();\n    }\n\n    boolean isNotEmpty() {\n        if (totalCharsInList > 0) {\n            return true;\n        }\n        if (totalCharsInDynamicChunks > 0) {\n            return true;\n        }\n        if (allocBuffer.charsUsed() > 0) {\n            return true;\n        }\n        if (totalCharsInDynamicChunks == -1) {\n            for (StreamCharBufferSubChunk chunk : dynamicChunkMap.values()) {\n                if (chunk.getSourceBuffer().isNotEmpty()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    boolean isSizeLarger(int minSize) {\n        if (minSize <= sizeAtLeast) {\n            return true;\n        }\n\n        boolean retval = calculateIsSizeLarger(minSize);\n        if (retval && minSize > sizeAtLeast) {\n            sizeAtLeast = minSize;\n        }\n        return retval;\n    }\n\n    private boolean calculateIsSizeLarger(int minSize) {\n        int total = totalCharsInList;\n        total += allocBuffer.charsUsed();\n        if (total > minSize) {\n            return true;\n        }\n        if (totalCharsInDynamicChunks != -1) {\n            total += totalCharsInDynamicChunks;\n            if (total > minSize) {\n                return true;\n            }\n        } else {\n            for (StreamCharBufferSubChunk chunk : dynamicChunkMap.values()) {\n                int remaining = minSize - total;\n                if (!chunk.hasCachedSize() && (chunk.getSourceBuffer().isSizeLarger(remaining) || (chunk.getEncodedBuffer() != chunk.getSourceBuffer() && chunk.getEncodedBuffer().isSizeLarger(remaining)))) {\n                    return true;\n                }\n                total += chunk.size();\n                if (total > minSize) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    int allocateSpace(EncodingState encodingState) throws IOException {\n        int spaceLeft = allocBuffer.spaceLeft(encodingState);\n        if (spaceLeft == 0) {\n            spaceLeft = appendCharBufferChunk(encodingState, true, true);\n        }\n        return spaceLeft;\n    }\n\n    private int appendCharBufferChunk(EncodingState encodingState, boolean flushInConnected, boolean allocate) throws IOException {\n        int spaceLeft = 0;\n        if (flushInConnected && isConnectedMode()) {\n            flushToConnected(false);\n            if (!isChunkSizeResizeable()) {\n                allocBuffer.reuseBuffer(encodingState);\n            }\n        }\n        else {\n            if (allocBuffer.hasChunk()) {\n                addChunk(allocBuffer.createChunk());\n            }\n        }\n        spaceLeft = allocBuffer.spaceLeft(encodingState);\n        if (allocate && spaceLeft == 0) {\n            totalChunkSize += allocBuffer.chunkSize();\n            resizeChunkSizeAsProcentageOfTotalSize();\n            allocBuffer = new AllocatedBuffer(chunkSize);\n            spaceLeft = allocBuffer.spaceLeft(encodingState);\n        }\n        return spaceLeft;\n    }\n\n    void appendStringChunk(EncodingState encodingState, String str, int off, int len) throws IOException {\n        appendCharBufferChunk(encodingState, false, false);\n        addChunk(new StringChunk(str, off, len)).setEncodingState(encodingState);\n    }\n    \n    public void appendStreamCharBufferChunk(StreamCharBuffer subBuffer) throws IOException {\n        appendStreamCharBufferChunk(subBuffer, null);\n    }\n\n    public void appendStreamCharBufferChunk(StreamCharBuffer subBuffer, List<Encoder> encoders) throws IOException {\n        appendCharBufferChunk(null, false, false);\n        addChunk(new StreamCharBufferSubChunk(subBuffer, encoders));\n    }\n\n    AbstractChunk addChunk(AbstractChunk newChunk) {\n        if (lastChunk != null) {\n            lastChunk.next = newChunk;\n            if (hasReaders) {\n                // double link only if there are active readers since backwards iterating is only required for simultaneous writer & reader\n                newChunk.prev = lastChunk;\n            }\n        }\n        lastChunk = newChunk;\n        if (firstChunk == null) {\n            firstChunk = newChunk;\n        }\n        if (newChunk instanceof StreamCharBufferSubChunk) {\n            StreamCharBufferSubChunk bufSubChunk = (StreamCharBufferSubChunk)newChunk;\n            dynamicChunkMap.put(bufSubChunk.getSourceBuffer().bufferKey, bufSubChunk);\n        }\n        else {\n            totalCharsInList += newChunk.size();\n        }\n        return newChunk;\n    }\n\n    public boolean isConnectedMode() {\n        return connectToWriters != null && !connectToWriters.isEmpty();\n    }\n\n    private void flushToConnected(boolean forceFlush) throws IOException {\n        startUsingConnectedWritersWriter();\n        if (notConnectedToEncodeAwareWriters==null) {\n            notConnectedToEncodeAwareWriters = !connectedWritersWriter.isEncoderAware();\n        }\n        writeTo(connectedWritersWriter, forceFlush, true);\n        if (forceFlush) {\n            connectedWritersWriter.forceFlush();\n        }\n    }\n\n    protected boolean isChunkSizeResizeable() {\n        return (growProcent > 0 && chunkSize < maxChunkSize);\n    }\n\n    protected void resizeChunkSizeAsProcentageOfTotalSize() {\n        if (growProcent == 0) {\n            return;\n        }\n\n        if (growProcent==100) {\n            chunkSize = Math.min(totalChunkSize, maxChunkSize);\n        }\n        else if (growProcent == 200) {\n            chunkSize = Math.min(totalChunkSize << 1, maxChunkSize);\n        }\n        else if (growProcent > 0) {\n            chunkSize = Math.max(Math.min((totalChunkSize * growProcent)/100, maxChunkSize), firstChunkSize);\n        }\n    }\n\n    protected static final void arrayCopy(char[] src, int srcPos, char[] dest, int destPos, int length) {\n        if (length == 1) {\n            dest[destPos]=src[srcPos];\n        }\n        else {\n            System.arraycopy(src, srcPos, dest, destPos, length);\n        }\n    }\n\n    /**\n     * This is the java.io.Writer implementation for StreamCharBuffer\n     *\n     * @author Lari Hotari, Sagire Software Oy\n     */\n    public final class StreamCharBufferWriter extends Writer implements EncodedAppenderFactory, EncodedAppenderWriterFactory {\n        boolean closed = false;\n        int writerUsedCounter = 0;\n        boolean increaseCounter = true;\n        EncodedAppender encodedAppender;\n\n        @Override\n        public final void write(final char[] b, final int off, final int len) throws IOException {\n            write(null, b, off, len);\n        }\n\n        private final void write(EncodingState encodingState, final char[] b, final int off, final int len) throws IOException {\n            if (b == null) {\n                throw new NullPointerException();\n            }\n\n            if ((off < 0) || (off > b.length) || (len < 0) ||\n                    ((off + len) > b.length) || ((off + len) < 0)) {\n                throw new IndexOutOfBoundsException();\n            }\n\n            if (len == 0) {\n                return;\n            }\n\n            markUsed();\n            if (shouldWriteDirectly(len)) {\n                appendCharBufferChunk(encodingState,true,true);\n                startUsingConnectedWritersWriter();\n                connectedWritersWriter.write(b, off, len);\n            }\n            else {\n                int charsLeft = len;\n                int currentOffset = off;\n                while (charsLeft > 0) {\n                    int spaceLeft = allocateSpace(encodingState);\n                    int writeChars = Math.min(spaceLeft, charsLeft);\n                    allocBuffer.write(b, currentOffset, writeChars);\n                    charsLeft -= writeChars;\n                    currentOffset += writeChars;\n                }\n            }\n        }\n\n        private final boolean shouldWriteDirectly(final int len) {\n            if (!isConnectedMode()) {\n                return false;\n            }\n\n            if (!(writeDirectlyToConnectedMinSize >= 0 && len >= writeDirectlyToConnectedMinSize)) {\n                return false;\n            }\n\n            return isNextChunkBigEnough(len);\n        }\n\n        private final boolean isNextChunkBigEnough(final int len) {\n            return (len > getNewChunkMinSize());\n        }\n\n        private final int getDirectChunkMinSize() {\n            if (!isConnectedMode()) {\n                return -1;\n            }\n            if (writeDirectlyToConnectedMinSize >= 0) {\n                return writeDirectlyToConnectedMinSize;\n            }\n\n            return getNewChunkMinSize();\n        }\n\n        private final int getNewChunkMinSize() {\n            if (chunkMinSize <= 0 || allocBuffer.charsUsed() == 0 || allocBuffer.charsUsed() >= chunkMinSize) {\n                return 0;\n            }\n            return allocBuffer.spaceLeft(null);\n        }\n\n        @Override\n        public final void write(final String str) throws IOException {\n            write(null, str, 0, str.length());\n        }\n\n        @Override\n        public final void write(final String str, final int off, final int len) throws IOException {\n            write(null, str, off, len);\n        }\n\n        private final void write(EncodingState encodingState, final String str, final int off, final int len) throws IOException {\n            if (len==0) return;\n            markUsed();\n            if (shouldWriteDirectly(len)) {\n                appendCharBufferChunk(encodingState,true,false);\n                startUsingConnectedWritersWriter();\n                connectedWritersWriter.write(str, off, len);\n            }\n            else if (len >= subStringChunkMinSize && isNextChunkBigEnough(len)) {\n                appendStringChunk(encodingState, str, off, len);\n            }\n            else {\n                int charsLeft = len;\n                int currentOffset = off;\n                while (charsLeft > 0) {\n                    int spaceLeft = allocateSpace(encodingState);\n                    int writeChars = Math.min(spaceLeft, charsLeft);\n                    allocBuffer.writeString(str, currentOffset, writeChars);\n                    charsLeft -= writeChars;\n                    currentOffset += writeChars;\n                }\n            }\n        }\n        \n        public final void write(StreamCharBuffer subBuffer) throws IOException {\n            write(subBuffer, null);\n        }\n\n        public final void write(StreamCharBuffer subBuffer, List<Encoder> encoders) throws IOException {\n            markUsed();\n            int directChunkMinSize = getDirectChunkMinSize();\n            if (encoders == null\n                    && (directChunkMinSize == 0 || (directChunkMinSize != -1 && subBuffer\n                            .isSizeLarger(directChunkMinSize)))) {\n                appendCharBufferChunk(null, true, false);\n                startUsingConnectedWritersWriter();\n                subBuffer.writeToImpl(connectedWritersWriter, false, false);\n            }\n            else if (!appendSubBuffer(subBuffer, encoders)) {\n                ChainedEncoders.chainEncode(subBuffer, this.getEncodedAppender(), encoders);\n            }\n        }\n\n        boolean appendSubBuffer(StreamCharBuffer subBuffer, List<Encoder> encoders) throws IOException {\n            if (isAllowSubBuffers() && subBuffer.isPreferSubChunkWhenWritingToOtherBuffer()\n                    || subBuffer.isSizeLarger(Math.max(subBufferChunkMinSize, getNewChunkMinSize()))) {\n                if (subBuffer.isPreferSubChunkWhenWritingToOtherBuffer()) {\n                    StreamCharBuffer.this.setPreferSubChunkWhenWritingToOtherBuffer(true);\n                }\n                markUsed();\n                appendStreamCharBufferChunk(subBuffer, encoders);\n                subBuffer.addParentBuffer(StreamCharBuffer.this);\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public final Writer append(final CharSequence csq, final int start, final int end)\n                throws IOException {\n            markUsed();\n            if (csq == null) {\n                write(\"null\");\n            }\n            else {\n                appendCharSequence(null, csq, start, end);\n            }\n            return this;\n        }\n\n        protected void appendCharSequence(final EncodingState encodingState, final CharSequence csq, final int start, final int end) throws IOException {\n            final Class<?> csqClass = csq.getClass();\n            if (csqClass == String.class || csqClass == StringBuffer.class || csqClass == StringBuilder.class || csq instanceof CharArrayAccessible) {\n                int len = end-start;\n                int charsLeft = len;\n                int currentOffset = start;\n                while (charsLeft > 0) {\n                    int spaceLeft = allocateSpace(encodingState);\n                    int writeChars = Math.min(spaceLeft, charsLeft);\n                    if (csqClass == String.class) {\n                        allocBuffer.writeString((String)csq, currentOffset, writeChars);\n                    }\n                    else if (csqClass == StringBuffer.class) {\n                        allocBuffer.writeStringBuffer((StringBuffer)csq, currentOffset, writeChars);\n                    }\n                    else if (csqClass == StringBuilder.class) {\n                        allocBuffer.writeStringBuilder((StringBuilder)csq, currentOffset, writeChars);\n                    }\n                    else if (csq instanceof CharArrayAccessible) {\n                        allocBuffer.writeCharArrayAccessible((CharArrayAccessible)csq, currentOffset, writeChars);\n                    }\n                    charsLeft -= writeChars;\n                    currentOffset += writeChars;\n                }\n            } else {\n                String str=csq.subSequence(start, end).toString();\n                write(encodingState, str, 0, str.length());\n            }\n        }\n\n        @Override\n        public final Writer append(final CharSequence csq) throws IOException {\n            markUsed();\n            if (csq==null) {\n                write(\"null\");\n            } else {\n                append(csq, 0, csq.length());\n\n            }\n            return this;\n        }\n\n        @Override\n        public void close() throws IOException {\n            closed = true;\n            flushWriter(true);\n        }\n\n        public boolean isClosed() {\n            return closed;\n        }\n\n        public boolean isUsed() {\n            return writerUsedCounter > 0;\n        }\n\n        public final void markUsed() {\n            if (increaseCounter) {\n                writerUsedCounter++;\n                if (!hasReaders) {\n                    increaseCounter=false;\n                }\n            }\n        }\n\n        public int resetUsed() {\n            int prevUsed = writerUsedCounter;\n            writerUsedCounter = 0;\n            increaseCounter = true;\n            return prevUsed;\n        }\n\n        @Override\n        public void write(final int b) throws IOException {\n            markUsed();\n            allocateSpace(null);\n            allocBuffer.write((char) b);\n        }\n\n        void flushWriter(boolean forceFlush) throws IOException {\n            if (isConnectedMode()) {\n                flushToConnected(forceFlush);\n            }\n            notifyBufferChange();\n        }\n\n        public final StreamCharBuffer getBuffer() {\n            return StreamCharBuffer.this;\n        }\n\n        public void append(EncodingState encodingState, char character) throws IOException {\n            markUsed();\n            allocateSpace(isNotConnectedToEncoderAwareWriters() || encodingState == null ? EncodingStateImpl.UNDEFINED_ENCODING_STATE : encodingState);\n            allocBuffer.write(character);\n        }\n\n        public Writer getWriterForEncoder(Encoder encoder, EncodingStateRegistry encodingStateRegistry) {\n            return StreamCharBuffer.this.getWriterForEncoder(encoder, encodingStateRegistry);\n        }\n\n        public EncodedAppender getEncodedAppender() {\n            if (encodedAppender==null) {\n                encodedAppender = new StreamCharBufferEncodedAppender(this);\n            }\n            return encodedAppender;\n        }\n\n        @Override\n        public void flush() throws IOException {\n            flushWriter(false);\n        }\n    }\n\n    private boolean isNotConnectedToEncoderAwareWriters() {\n        return notConnectedToEncodeAwareWriters != null && notConnectedToEncodeAwareWriters;\n    }\n\n    private final static class StreamCharBufferEncodedAppender extends AbstractEncodedAppender {\n        StreamCharBufferWriter writer;\n        StreamCharBufferEncodedAppender(StreamCharBufferWriter writer) {\n            this.writer=writer;\n        }\n\n        public StreamCharBufferWriter getWriter() {\n            return writer;\n        }\n\n        @Override\n        public void flush() throws IOException {\n            writer.flush();\n        }\n\n        @Override\n        protected void write(EncodingState encodingState, char[] b, int off, int len) throws IOException {\n            writer.write(encodingState, b, off, len);\n        }\n\n        @Override\n        protected void write(EncodingState encodingState, String str, int off, int len) throws IOException {\n            writer.write(encodingState, str, off, len);\n\n        }\n\n        @Override\n        protected void appendCharSequence(EncodingState encodingState, CharSequence str, int start, int end)\n                throws IOException {\n            writer.appendCharSequence(encodingState, str, start, end);\n        }\n\n        public void close() throws IOException {\n            writer.close();\n        }\n    }\n\n    /**\n     * This is the java.io.Reader implementation for StreamCharBuffer\n     *\n     * @author Lari Hotari, Sagire Software Oy\n     */\n\n    final public class StreamCharBufferReader extends Reader {\n        boolean eofException=false;\n        int eofReachedCounter=0;\n        ChunkReader chunkReader;\n        ChunkReader lastChunkReader;\n        boolean removeAfterReading;\n\n        public StreamCharBufferReader(boolean remove) {\n            removeAfterReading = remove;\n        }\n\n        private int prepareRead(int len) {\n            if (hasReaders && eofReachedCounter != 0) {\n                if (eofReachedCounter != writer.writerUsedCounter) {\n                    eofReachedCounter = 0;\n                    eofException = false;\n                    repositionChunkReader();\n                }\n            }\n            if (chunkReader == null && eofReachedCounter == 0) {\n                if (firstChunk != null) {\n                    chunkReader = firstChunk.getChunkReader(removeAfterReading);\n                    if (removeAfterReading) {\n                        firstChunk.subtractFromTotalCount();\n                    }\n                }\n                else {\n                    chunkReader = new AllocatedBufferReader(allocBuffer, removeAfterReading);\n                }\n            }\n            int available = 0;\n            if (chunkReader != null) {\n                available = chunkReader.getReadLenLimit(len);\n                while (available == 0 && chunkReader != null) {\n                    chunkReader = chunkReader.next();\n                    if (chunkReader != null) {\n                        available = chunkReader.getReadLenLimit(len);\n                    } else {\n                        available = 0;\n                    }\n                }\n            }\n            if (chunkReader == null) {\n                if (hasReaders) {\n                    eofReachedCounter=writer.writerUsedCounter;\n                } else {\n                    eofReachedCounter = 1;\n                }\n            } else if (hasReaders) {\n                lastChunkReader=chunkReader;\n            }\n            return available;\n        }\n\n        /* adds support for reading and writing simultaneously in the same thread */\n        private void repositionChunkReader() {\n            if (lastChunkReader instanceof AllocatedBufferReader) {\n                if (lastChunkReader.isValid()) {\n                    chunkReader=lastChunkReader;\n                } else {\n                    AllocatedBufferReader allocBufferReader = (AllocatedBufferReader)lastChunkReader;\n                    // find out what is the CharBufferChunk that was read by the AllocatedBufferReader already\n                    int currentPosition = allocBufferReader.position;\n                    AbstractChunk chunk = lastChunk;\n                    while (chunk != null && chunk.writerUsedCounter >= lastChunkReader.getWriterUsedCounter()) {\n                        if (chunk instanceof CharBufferChunk) {\n                            CharBufferChunk charBufChunk = (CharBufferChunk)chunk;\n                            if (charBufChunk.allocatedBufferId == allocBufferReader.parent.id) {\n                                if (currentPosition >= charBufChunk.offset && currentPosition <= charBufChunk.lastposition) {\n                                    CharBufferChunkReader charBufChunkReader = (CharBufferChunkReader)charBufChunk.getChunkReader(removeAfterReading);\n                                    int oldpointer = charBufChunkReader.pointer;\n                                    // skip the already chars\n                                    charBufChunkReader.pointer = currentPosition;\n                                    if (removeAfterReading) {\n                                        int diff = charBufChunkReader.pointer - oldpointer;\n                                        totalCharsInList -= diff;\n                                        charBufChunk.subtractFromTotalCount();\n                                    }\n                                    chunkReader = charBufChunkReader;\n                                    break;\n                                }\n                            }\n                        }\n                        chunk = chunk.prev;\n                    }\n                }\n            }\n        }\n\n        @Override\n        public boolean ready() throws IOException {\n            return true;\n        }\n\n        @Override\n        public final int read(final char[] b, final int off, final int len) throws IOException {\n            return readImpl(b, off, len);\n        }\n\n        final int readImpl(final char[] b, final int off, final int len) throws IOException {\n            if (b == null) {\n                throw new NullPointerException();\n            }\n\n            if ((off < 0) || (off > b.length) || (len < 0) ||\n                    ((off + len) > b.length) || ((off + len) < 0)) {\n                throw new IndexOutOfBoundsException();\n            }\n\n            if (len == 0) {\n                return 0;\n            }\n\n            int charsLeft = len;\n            int currentOffset = off;\n            int readChars = prepareRead(charsLeft);\n            if (eofException) {\n                throw new EOFException();\n            }\n\n            int totalCharsRead = 0;\n            while (charsLeft > 0 && readChars > 0) {\n                chunkReader.read(b, currentOffset, readChars);\n                charsLeft -= readChars;\n                currentOffset += readChars;\n                totalCharsRead += readChars;\n                if (charsLeft > 0) {\n                    readChars = prepareRead(charsLeft);\n                }\n            }\n\n            if (totalCharsRead > 0) {\n                return totalCharsRead;\n            }\n\n            eofException = true;\n            return -1;\n        }\n\n        @Override\n        public void close() throws IOException {\n            // do nothing\n        }\n\n        public final StreamCharBuffer getBuffer() {\n            return StreamCharBuffer.this;\n        }\n\n        public int getReadLenLimit(int askedAmount) {\n            return prepareRead(askedAmount);\n        }\n    }\n\n    abstract class AbstractChunk implements StreamEncodeable, StreamingEncoderWritable {\n        AbstractChunk next;\n        AbstractChunk prev;\n        int writerUsedCounter;\n        EncodingState encodingState;\n\n        public AbstractChunk() {\n            if (hasReaders) {\n                writerUsedCounter = writer.writerUsedCounter;\n            }\n            else {\n                writerUsedCounter = 1;\n            }\n        }\n\n        public abstract void writeTo(Writer target) throws IOException;\n        public abstract ChunkReader getChunkReader(boolean removeAfterReading);\n        public abstract int size();\n        public int getWriterUsedCounter() {\n            return writerUsedCounter;\n        }\n\n        public void subtractFromTotalCount() {\n            totalCharsInList -= size();\n        }\n\n        public EncodingState getEncodingState() {\n            return encodingState;\n        }\n\n        public void setEncodingState(EncodingState encodingState) {\n            this.encodingState = encodingState;\n        }\n    }\n\n    // keep read state in this class\n    static abstract class ChunkReader {\n        public abstract int read(char[] ch, int off, int len) throws IOException;\n        public abstract int getReadLenLimit(int askedAmount);\n        public abstract ChunkReader next();\n        public abstract int getWriterUsedCounter();\n        public abstract boolean isValid();\n    }\n\n    final class AllocatedBuffer {\n        private int id=allocatedBufferIdSequence++;\n        private int size;\n        private char[] buffer;\n        private int used = 0;\n        private int chunkStart = 0;\n        private EncodingState encodingState;\n        private EncodingState nextEncoders;\n\n        public AllocatedBuffer(int size) {\n            this.size = size;\n            buffer = new char[size];\n        }\n\n        public void clear() {\n            reuseBuffer(null);\n        }\n\n        public int charsUsed() {\n            return used-chunkStart;\n        }\n\n        public void writeTo(Writer target) throws IOException {\n            if (used-chunkStart > 0) {\n                target.write(buffer, chunkStart, used-chunkStart);\n            }\n        }\n\n        public void reuseBuffer(EncodingState encodingState) {\n            used=0;\n            chunkStart=0;\n            this.encodingState=null;\n            this.nextEncoders=encodingState;\n        }\n\n        public int chunkSize() {\n            return buffer.length;\n        }\n\n        public int spaceLeft(EncodingState encodingState) {\n            if(encodingState == null) {\n                encodingState = EncodingStateImpl.UNDEFINED_ENCODING_STATE;\n            }\n            if (this.encodingState != null && (encodingState == null || !this.encodingState.equals(encodingState)) && hasChunk() && !isNotConnectedToEncoderAwareWriters()) {\n                addChunk(allocBuffer.createChunk());\n                this.encodingState = null;\n            }\n            this.nextEncoders = encodingState;\n            return size - used;\n        }\n\n        private final void applyEncoders() throws IOException {\n            if (encodingState==nextEncoders) {\n                return ;\n            }\n            if (encodingState != null && !isNotConnectedToEncoderAwareWriters() && (nextEncoders == null || !encodingState.equals(nextEncoders))) {\n                throw new IOException(\"Illegal operation in AllocatedBuffer\");\n            }\n            encodingState = nextEncoders;\n        }\n\n        public boolean write(final char ch) throws IOException {\n            if (used < size) {\n                applyEncoders();\n                buffer[used++] = ch;\n                return true;\n            }\n\n            return false;\n        }\n\n        public final void write(final char[] ch, final int off, final int len) throws IOException {\n            applyEncoders();\n            arrayCopy(ch, off, buffer, used, len);\n            used += len;\n        }\n\n        public final void writeString(final String str, final int off, final int len) throws IOException {\n            applyEncoders();\n            str.getChars(off, off+len, buffer, used);\n            used += len;\n        }\n\n        public final void writeStringBuilder(final StringBuilder stringBuilder, final int off, final int len) throws IOException {\n            applyEncoders();\n            stringBuilder.getChars(off, off+len, buffer, used);\n            used += len;\n        }\n\n        public final void writeStringBuffer(final StringBuffer stringBuffer, final int off, final int len) throws IOException {\n            applyEncoders();\n            stringBuffer.getChars(off, off+len, buffer, used);\n            used += len;\n        }\n\n        public final void writeCharArrayAccessible(final CharArrayAccessible charArrayAccessible, final int off, final int len) throws IOException {\n            applyEncoders();\n            charArrayAccessible.getChars(off, off+len, buffer, used);\n            used += len;\n        }\n\n        /**\n         * Creates a new chunk from the content written to the buffer (used before adding StringChunk or StreamCharBufferChunk).\n         *\n         * @return the chunk\n         */\n        public CharBufferChunk createChunk() {\n            CharBufferChunk chunk=new CharBufferChunk(id, buffer, chunkStart, used-chunkStart);\n            chunk.setEncodingState(encodingState);\n            chunkStart=used;\n            return chunk;\n        }\n\n        public boolean hasChunk() {\n            return (used > chunkStart);\n        }\n\n        public void encodeTo(EncodedAppender appender, Encoder encoder) throws IOException {\n            if (used-chunkStart > 0) {\n                appender.append(encoder, encodingState, buffer, chunkStart, used-chunkStart);\n            }\n        }\n\n        public EncodingState getEncodingState() {\n            return encodingState;\n        }\n\n        public void encodeTo(Writer writer, EncodesToWriter encoder) throws IOException {\n            if (used-chunkStart > 0) {\n                encoder.encodeToWriter(buffer, chunkStart, used-chunkStart, writer, getEncodingState());\n            }\n        }\n    }\n\n    /**\n     * The data in the buffer is stored in a linked list of StreamCharBufferChunks.\n     *\n     * This class contains data & read/write state for the \"chunk level\".\n     * It contains methods for reading & writing to the chunk level.\n     *\n     * Underneath the chunk is one more level, the StringChunkGroup + StringChunk.\n     * StringChunk makes it possible to directly store the java.lang.String objects.\n     *\n     * @author Lari Hotari\n     *\n     */\n    class CharBufferChunk extends AbstractChunk {\n        int allocatedBufferId;\n        char[] buffer;\n        int offset;\n        int lastposition;\n        int length;\n\n        public CharBufferChunk(int allocatedBufferId, char[] buffer, int offset, int len) {\n            super();\n            this.allocatedBufferId = allocatedBufferId;\n            this.buffer = buffer;\n            this.offset = offset;\n            this.lastposition = offset + len;\n            this.length = len;\n        }\n\n        @Override\n        public void writeTo(final Writer target) throws IOException {\n            target.write(buffer, offset, length);\n        }\n\n        @Override\n        public ChunkReader getChunkReader(boolean removeAfterReading) {\n            return new CharBufferChunkReader(this, removeAfterReading);\n        }\n\n        @Override\n        public int size() {\n            return length;\n        }\n\n        public boolean isSingleBuffer() {\n            return offset == 0 && length == buffer.length;\n        }\n\n        @Override\n        public void encodeTo(EncodedAppender appender, Encoder encoder) throws IOException {\n            appender.append(encoder, getEncodingState(), buffer, offset, length);\n        }\n\n        @Override\n        public void encodeTo(Writer writer, EncodesToWriter encoder) throws IOException {\n            encoder.encodeToWriter(buffer, offset, length, writer, getEncodingState());\n        }\n    }\n\n    class MultipartStringChunk extends StringChunk {\n        EncodingStatePart firstPart=null;\n        EncodingStatePart lastPart=null;\n\n        public MultipartStringChunk(String str) {\n            super(str, 0, str.length());\n        }\n\n        @Override\n        public void encodeTo(EncodedAppender appender, Encoder encoder) throws IOException {\n            if (firstPart != null) {\n                EncodingStatePart current = firstPart;\n                int offset = 0;\n                char[] buf=StringCharArrayAccessor.getValue(str);\n                while (current != null) {\n                    appender.append(encoder, current.encodingState, buf, offset, current.len);\n                    offset += current.len;\n                    current = current.next;\n                }\n            } else {\n                super.encodeTo(appender, encoder);\n            }\n        }\n        \n        @Override\n        public void encodeTo(Writer writer, EncodesToWriter encoder) throws IOException {\n            if (firstPart != null) {\n                EncodingStatePart current = firstPart;\n                int offset = 0;\n                char[] buf=StringCharArrayAccessor.getValue(str);\n                while (current != null) {\n                    encoder.encodeToWriter(buf, offset, current.len, writer, current.encodingState);\n                    offset += current.len;\n                    current = current.next;\n                }\n            } else {\n                super.encodeTo(writer, encoder);\n            }\n        }\n\n        public boolean isSingleEncoding() {\n            return (firstPart==lastPart);\n        }\n\n        public int partCount() {\n            int partCount=0;\n            EncodingStatePart current = firstPart;\n            while (current != null) {\n                partCount++;\n                current = current.next;\n            }\n            return partCount;\n        }\n\n        public void appendEncodingStatePart(EncodingStatePart current) {\n            if (firstPart==null) {\n                firstPart = current;\n                lastPart = current;\n            } else {\n                lastPart.next = current;\n                lastPart = current;\n            }\n        }\n    }\n\n    class MultipartCharBufferChunk extends CharBufferChunk {\n        EncodingStatePart firstPart=null;\n        EncodingStatePart lastPart=null;\n\n        public MultipartCharBufferChunk(char[] buffer) {\n            super(-1, buffer, 0, buffer.length);\n        }\n\n        @Override\n        public void encodeTo(EncodedAppender appender, Encoder encoder) throws IOException {\n            if (firstPart != null) {\n                EncodingStatePart current = firstPart;\n                int offset = 0;\n                while (current != null) {\n                    appender.append(encoder, current.encodingState, buffer, offset, current.len);\n                    offset += current.len;\n                    current = current.next;\n                }\n            } else {\n                super.encodeTo(appender, encoder);\n            }\n        }\n\n        public MultipartStringChunk asStringChunk() {\n            String str = StringCharArrayAccessor.createString(buffer);\n            MultipartStringChunk chunk = new MultipartStringChunk(str);\n            chunk.firstPart = firstPart;\n            chunk.lastPart = lastPart;\n            return chunk;\n        }\n    }\n\n    static final class EncodingStatePart {\n        EncodingStatePart next;\n        EncodingState encodingState;\n        int len=-1;\n    }\n\n    abstract class AbstractChunkReader extends ChunkReader {\n        private AbstractChunk parentChunk;\n        private boolean removeAfterReading;\n\n        public AbstractChunkReader(AbstractChunk parentChunk, boolean removeAfterReading) {\n            this.parentChunk = parentChunk;\n            this.removeAfterReading = removeAfterReading;\n        }\n\n        @Override\n        public boolean isValid() {\n            return true;\n        }\n\n        @Override\n        public ChunkReader next() {\n            if (removeAfterReading) {\n                if (firstChunk == parentChunk) {\n                    firstChunk = null;\n                }\n                if (lastChunk == parentChunk) {\n                    lastChunk = null;\n                }\n            }\n            AbstractChunk nextChunk=parentChunk.next;\n            if (nextChunk != null) {\n                if (removeAfterReading) {\n                    if (firstChunk==null) {\n                        firstChunk=nextChunk;\n                    }\n                    if (lastChunk==null) {\n                        lastChunk=nextChunk;\n                    }\n                    nextChunk.prev=null;\n                    nextChunk.subtractFromTotalCount();\n                }\n                return nextChunk.getChunkReader(removeAfterReading);\n            }\n\n            return new AllocatedBufferReader(allocBuffer, removeAfterReading);\n        }\n\n        @Override\n        public int getWriterUsedCounter() {\n            return parentChunk.getWriterUsedCounter();\n        }\n    }\n\n    final class CharBufferChunkReader extends AbstractChunkReader {\n        CharBufferChunk parent;\n        int pointer;\n\n        public CharBufferChunkReader(CharBufferChunk parent, boolean removeAfterReading) {\n            super(parent, removeAfterReading);\n            this.parent = parent;\n            pointer = parent.offset;\n        }\n\n        @Override\n        public int read(final char[] ch, final int off, final int len) throws IOException {\n            arrayCopy(parent.buffer, pointer, ch, off, len);\n            pointer += len;\n            return len;\n        }\n\n        @Override\n        public int getReadLenLimit(int askedAmount) {\n            return Math.min(parent.lastposition-pointer, askedAmount);\n        }\n    }\n\n    /**\n     * StringChunk is a wrapper for java.lang.String.\n     *\n     * It also keeps state of the read offset and the number of unread characters.\n     *\n     * There's methods that StringChunkGroup uses for reading data.\n     *\n     * @author Lari Hotari\n     *\n     */\n    class StringChunk extends AbstractChunk {\n        String str;\n        int offset;\n        int lastposition;\n        int length;\n\n        public StringChunk(String str, int offset, int length) {\n            this.str = str;\n            this.offset = offset;\n            this.length = length;\n            this.lastposition = offset + length;\n        }\n\n        @Override\n        public ChunkReader getChunkReader(boolean removeAfterReading) {\n            return new StringChunkReader(this, removeAfterReading);\n        }\n\n        @Override\n        public void writeTo(Writer target) throws IOException {\n            target.write(str, offset, length);\n        }\n\n        @Override\n        public int size() {\n            return length;\n        }\n\n        public boolean isSingleBuffer() {\n            return offset==0 && length==str.length();\n        }\n\n        @Override\n        public void encodeTo(EncodedAppender appender, Encoder encoder) throws IOException {\n            appender.append(encoder, getEncodingState(), str, offset, length);\n        }\n\n        @Override\n        public void encodeTo(Writer writer, EncodesToWriter encoder) throws IOException {\n            encoder.encodeToWriter(toCharSequence(), 0, length, writer, getEncodingState());\n        }\n\n        public CharSequence toCharSequence() {\n            if(isSingleBuffer()) { \n                return str;\n            } else {\n                return CharSequences.createCharSequence(str, offset, length);\n            }\n        }\n    }\n\n    final class StringChunkReader extends AbstractChunkReader {\n        StringChunk parent;\n        int position;\n\n        public StringChunkReader(StringChunk parent, boolean removeAfterReading) {\n            super(parent, removeAfterReading);\n            this.parent = parent;\n            this.position = parent.offset;\n        }\n\n        @Override\n        public int read(final char[] ch, final int off, final int len) {\n            parent.str.getChars(position, (position + len), ch, off);\n            position += len;\n            return len;\n        }\n\n        @Override\n        public int getReadLenLimit(int askedAmount) {\n            return Math.min(parent.lastposition - position, askedAmount);\n        }\n    }\n\n    final class StreamCharBufferSubChunk extends AbstractChunk {\n        private StreamCharBuffer sourceBuffer;\n        private List<Encoder> encoders;\n        private StreamCharBuffer encodedBuffer;\n        int cachedSize;\n        int encodedSourceChangesCounter = -1;\n\n        public StreamCharBufferSubChunk(StreamCharBuffer sourceBuffer, List<Encoder> encoders) {\n            this.sourceBuffer = sourceBuffer;\n            this.encoders = encoders;\n            if (encoders == null && hasQuicklyCalcutableSize() && sourceBuffer.hasQuicklyCalcutableSize()) {\n                cachedSize = sourceBuffer.size();\n                if(totalCharsInDynamicChunks == -1) {\n                    totalCharsInDynamicChunks = 0;\n                }\n                totalCharsInDynamicChunks += cachedSize;\n            } else {\n                totalCharsInDynamicChunks = -1;\n                cachedSize = -1;\n            }\n            if (encoders == null || sourceBuffer.isEmpty()) {\n                encodedBuffer = sourceBuffer;\n                encodedSourceChangesCounter = sourceBuffer.getBufferChangesCounter();\n            }\n        }\n\n        @Override\n        public ChunkReader getChunkReader(boolean removeAfterReading) {\n            return new StreamCharBufferSubChunkReader(this, removeAfterReading);\n        }\n\n        @Override\n        public int size() {\n            if (cachedSize == -1) {\n                cachedSize = getEncodedBuffer().size();\n            }\n            return cachedSize;\n        }\n\n        public boolean hasCachedSize() {\n            return (cachedSize != -1);\n        }\n\n        public StreamCharBuffer getSourceBuffer() {\n            return sourceBuffer;\n        }\n\n        @Override\n        public void writeTo(Writer target) throws IOException {\n            if (encoders == null || hasEncodedBufferAvailable() || !hasOnlyStreamingEncoders()) {\n                getEncodedBuffer().writeTo(target);\n            }\n            else {\n                EncodedAppender appender;\n                if (target instanceof EncodedAppender) {\n                    appender = ((EncodedAppender)target);\n                } else if (target instanceof EncodedAppenderFactory) {\n                    appender = ((EncodedAppenderFactory)target).getEncodedAppender();\n                }\n                else {\n                    appender = new WriterEncodedAppender(target);\n                }\n                ChainedEncoders.chainEncode(getSourceBuffer(), appender, encoders);\n            }\n        }\n\n        @Override\n        public void encodeTo(EncodedAppender appender, Encoder encodeToEncoder) throws IOException {\n            if (appender instanceof StreamCharBufferEncodedAppender\n                    && getSourceBuffer().isPreferSubChunkWhenWritingToOtherBuffer() \n                    && ((StreamCharBufferEncodedAppender)appender).getWriter().getBuffer().isAllowSubBuffers() ) {\n                List<Encoder> nextEncoders = ChainedEncoders.appendEncoder(encoders, encodeToEncoder);\n                ((StreamCharBufferEncodedAppender)appender).getWriter().write(getSourceBuffer(), nextEncoders);\n            }\n            else {\n                if (hasEncodedBufferAvailable() || !hasOnlyStreamingEncoders()) {\n                    appender.append(encodeToEncoder, getEncodedBuffer());\n                }\n                else {\n                    ChainedEncoders.chainEncode(getSourceBuffer(), appender, ChainedEncoders.appendEncoder(encoders, encodeToEncoder));\n                }\n            }\n        }\n        \n        protected boolean hasOnlyStreamingEncoders() {\n            if(encoders == null || encoders.isEmpty()) {\n                return false;\n            }\n            for(Encoder encoder : encoders) {\n                if(!(encoder instanceof StreamingEncoder)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public StreamCharBuffer getEncodedBuffer() {\n            if (!hasEncodedBufferAvailable()) {\n                if (encoders == null || sourceBuffer.isEmpty()) {\n                    encodedBuffer = sourceBuffer;\n                    encodedSourceChangesCounter = sourceBuffer.getBufferChangesCounter();\n                }\n                else {\n                    encodedBuffer = new StreamCharBuffer(chunkSize, growProcent, maxChunkSize);\n                    encodedBuffer.setAllowSubBuffers(isAllowSubBuffers());\n                    encodedBuffer.setNotifyParentBuffersEnabled(getSourceBuffer().isNotifyParentBuffersEnabled());\n                    encodeToEncodedBuffer();\n                }\n            }\n            return encodedBuffer;\n        }\n\n        private void encodeToEncodedBuffer() {\n            boolean previousAllowSubBuffer = encodedBuffer.isAllowSubBuffers();\n            encodedBuffer.setAllowSubBuffers(false);\n            encodedSourceChangesCounter = sourceBuffer.getBufferChangesCounter();\n            try {\n                ChainedEncoders.chainEncode(getSourceBuffer(), encodedBuffer.writer.getEncodedAppender(), encoders);\n            }\n            catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            encodedBuffer.setAllowSubBuffers(previousAllowSubBuffer);\n            encodedBuffer.setPreferSubChunkWhenWritingToOtherBuffer(getSourceBuffer().isPreferSubChunkWhenWritingToOtherBuffer());\n            encodedBuffer.notifyBufferChange();\n        }\n\n        protected boolean hasEncodedBufferAvailable() {\n            return encodedBuffer != null && encodedSourceChangesCounter == sourceBuffer.getBufferChangesCounter();\n        }\n\n        public boolean resetSubBuffer() {\n            if (cachedSize != -1 || encodedBuffer != sourceBuffer) {\n                cachedSize = -1;\n                encodedSourceChangesCounter = -1;\n                if(encodedBuffer != sourceBuffer && encodedBuffer != null) {\n                    encodedBuffer.clear();\n                    encodeToEncodedBuffer();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void subtractFromTotalCount() {\n            totalCharsInDynamicChunks = -1;\n            dynamicChunkMap.remove(sourceBuffer.bufferKey);\n        }\n\n        @Override\n        public void encodeTo(Writer writer, EncodesToWriter encoder) throws IOException {\n            if (hasEncodedBufferAvailable() || !hasOnlyStreamingEncoders() || encoders == null) {\n                getEncodedBuffer().encodeTo(writer, encoder);\n            } else {\n                List<StreamingEncoder> streamingEncoders=new ArrayList<StreamingEncoder>(encoders.size());\n                for(Encoder e : encoders) {\n                    streamingEncoders.add((StreamingEncoder)e);\n                }\n                getSourceBuffer().encodeTo(writer, encoder.createChainingEncodesToWriter(streamingEncoders, true));\n            }\n        }\n    }\n\n    final class StreamCharBufferSubChunkReader extends AbstractChunkReader {\n        StreamCharBufferSubChunk parent;\n        private StreamCharBufferReader reader;\n\n        public StreamCharBufferSubChunkReader(StreamCharBufferSubChunk parent, boolean removeAfterReading) {\n            super(parent, removeAfterReading);\n            this.parent = parent;\n            reader = (StreamCharBufferReader)parent.getEncodedBuffer().getReader();\n        }\n\n        @Override\n        public int getReadLenLimit(int askedAmount) {\n            return reader.getReadLenLimit(askedAmount);\n        }\n\n        @Override\n        public int read(char[] ch, int off, int len) throws IOException {\n            return reader.read(ch, off, len);\n        }\n    }\n\n    final class AllocatedBufferReader extends ChunkReader {\n        AllocatedBuffer parent;\n        int position;\n        int writerUsedCounter;\n        boolean removeAfterReading;\n\n        public AllocatedBufferReader(AllocatedBuffer parent, boolean removeAfterReading) {\n            this.parent = parent;\n            position = parent.chunkStart;\n            if (hasReaders) {\n                writerUsedCounter = writer.writerUsedCounter;\n            } else {\n                writerUsedCounter = 1;\n            }\n            this.removeAfterReading = removeAfterReading;\n        }\n\n        @Override\n        public int getReadLenLimit(int askedAmount) {\n            return Math.min(parent.used - position, askedAmount);\n        }\n\n        @Override\n        public int read(char[] ch, int off, int len) throws IOException {\n            arrayCopy(parent.buffer, position, ch, off, len);\n            position += len;\n            if (removeAfterReading) {\n                parent.chunkStart = position;\n            }\n            return len;\n        }\n\n        @Override\n        public ChunkReader next() {\n            return null;\n        }\n\n        @Override\n        public int getWriterUsedCounter() {\n            return writerUsedCounter;\n        }\n\n        @Override\n        public boolean isValid() {\n            return (allocBuffer == parent && (lastChunk == null || lastChunk.writerUsedCounter < writerUsedCounter));\n        }\n    }\n\n    private final class FixedCharArrayEncodedAppender extends AbstractEncodedAppender {\n        char buf[];\n        int count = 0;\n        int currentStart = 0;\n        EncodingState currentState;\n        MultipartCharBufferChunk chunk;\n\n        public FixedCharArrayEncodedAppender(int fixedSize) {\n            buf = new char[fixedSize];\n            chunk = new MultipartCharBufferChunk(buf);\n        }\n\n        private void checkEncodingChange(EncodingState encodingState) {\n            if(encodingState == null) {\n                encodingState = EncodingStateImpl.UNDEFINED_ENCODING_STATE;\n            }\n            if (currentState != null && !currentState.equals(encodingState)) {\n                addPart();\n            }\n            if (currentState==null) {\n                currentState = encodingState;\n            }\n        }\n\n        public void finish() {\n            addPart();\n        }\n\n        private void addPart() {\n            if (count - currentStart > 0) {\n                EncodingStatePart newPart = new EncodingStatePart();\n                newPart.encodingState = currentState;\n                newPart.len = count - currentStart;\n                if (chunk.lastPart==null) {\n                    chunk.firstPart = newPart;\n                    chunk.lastPart = newPart;\n                } else {\n                    chunk.lastPart.next = newPart;\n                    chunk.lastPart = newPart;\n                }\n                currentState = null;\n                currentStart = count;\n            }\n        }\n\n        @Override\n        protected void write(EncodingState encodingState, char[] b, int off, int len) throws IOException {\n            checkEncodingChange(encodingState);\n            arrayCopy(b, off, buf, count, len);\n            count += len;\n        }\n\n        @Override\n        protected void write(EncodingState encodingState, String str, int off, int len) throws IOException {\n            checkEncodingChange(encodingState);\n            str.getChars(off, off + len, buf, count);\n            count += len;\n        }\n\n        @Override\n        protected void appendCharSequence(EncodingState encodingState, CharSequence csq, int start, int end)\n                throws IOException {\n            checkEncodingChange(encodingState);\n            final Class<?> csqClass = csq.getClass();\n            if (csqClass == String.class) {\n                write(encodingState, (String)csq, start, end-start);\n            }\n            else if (csqClass == StringBuffer.class) {\n                ((StringBuffer)csq).getChars(start, end, buf, count);\n                count += end-start;\n            }\n            else if (csqClass == StringBuilder.class) {\n                ((StringBuilder)csq).getChars(start, end, buf, count);\n                count += end-start;\n            }\n            else if (csq instanceof CharArrayAccessible) {\n                ((CharArrayAccessible)csq).getChars(start, end, buf, count);\n                count += end-start;\n            }\n            else {\n                String str=csq.subSequence(start, end).toString();\n                write(encodingState, str, 0, str.length());\n            }\n        }\n\n        public void close() throws IOException {\n            finish();\n        }\n    }\n\n    /**\n     * Interface for a Writer that gets initialized if it is used\n     * Can be used for passing in to \"connectTo\" method of StreamCharBuffer\n     *\n     * @author Lari Hotari\n     *\n     */\n    public static interface LazyInitializingWriter {\n        public Writer getWriter() throws IOException;\n    }\n\n    public static interface LazyInitializingMultipleWriter extends LazyInitializingWriter {\n        /**\n         * initialize underlying writer\n         *\n         * @return false if this writer entry should be removed after calling this callback method\n         */\n        public LazyInitializingWriter[] initializeMultiple(StreamCharBuffer buffer, boolean autoFlush) throws IOException;\n    }\n\n    final class ConnectToWriter {\n        final Writer writer;\n        final LazyInitializingWriter lazyInitializingWriter;\n        final boolean autoFlush;\n        Boolean encoderAware;\n\n        ConnectToWriter(final Writer writer, final boolean autoFlush) {\n            this.writer = writer;\n            this.lazyInitializingWriter = null;\n            this.autoFlush = autoFlush;\n        }\n\n        ConnectToWriter(final LazyInitializingWriter lazyInitializingWriter, final boolean autoFlush) {\n            this.lazyInitializingWriter = lazyInitializingWriter;\n            this.writer = null;\n            this.autoFlush = autoFlush;\n        }\n\n        Writer[] getWriters() throws IOException {\n            if (writer != null) {\n                return new Writer[]{writer};\n            } else {\n                Set<Writer> writerList = resolveLazyInitializers(new HashSet<Integer>(), lazyInitializingWriter);\n                return writerList.toArray(new Writer[writerList.size()]);\n            }\n        }\n\n        private Set<Writer> resolveLazyInitializers(Set<Integer> resolved, LazyInitializingWriter lazyInitializingWriter) throws IOException {\n            Set<Writer> writerList = Collections.emptySet();\n            Integer identityHashCode = System.identityHashCode(lazyInitializingWriter);\n            if (!resolved.contains(identityHashCode) && lazyInitializingWriter instanceof LazyInitializingMultipleWriter) {\n                resolved.add(identityHashCode);\n                writerList = new LinkedHashSet<Writer>();\n                LazyInitializingWriter[] writers = ((LazyInitializingMultipleWriter)lazyInitializingWriter).initializeMultiple(StreamCharBuffer.this, autoFlush);\n                for(LazyInitializingWriter writer : writers) {\n                    writerList.addAll(resolveLazyInitializers(resolved, writer));\n                }\n            } else {\n                writerList = Collections.singleton(lazyInitializingWriter.getWriter());\n            }\n            return writerList;\n        }\n\n        public boolean isAutoFlush() {\n            return autoFlush;\n        }\n    }\n\n    /**\n     * Simple holder class for the connected writer\n     *\n     * @author Lari Hotari\n     *\n     */\n    static final class ConnectedWriter {\n        final Writer writer;\n        final boolean autoFlush;\n        final boolean encoderAware;\n\n        ConnectedWriter(final Writer writer, final boolean autoFlush) {\n            this.writer = writer;\n            this.autoFlush = autoFlush;\n            this.encoderAware = (writer instanceof EncodedAppenderFactory || writer instanceof EncodedAppenderWriterFactory);\n        }\n\n        Writer getWriter() {\n            return writer;\n        }\n\n        public void flush() throws IOException {\n            if (autoFlush) {\n                writer.flush();\n            }\n        }\n\n        public boolean isEncoderAware() {\n            return encoderAware;\n        }\n    }\n\n    static final class SingleOutputWriter extends ConnectedWritersWriter implements GrailsWrappedWriter {\n        private final ConnectedWriter connectedWriter;\n        private final Writer writer;\n        private final boolean encoderAware;\n\n        public SingleOutputWriter(ConnectedWriter connectedWriter) {\n            this.connectedWriter = connectedWriter;\n            this.writer = connectedWriter.getWriter();\n            this.encoderAware = connectedWriter.isEncoderAware();\n        }\n\n        @Override\n        public void close() throws IOException {\n            // do nothing\n        }\n\n        @Override\n        public void flush() throws IOException {\n            connectedWriter.flush();\n        }\n\n        @Override\n        public void write(final char[] cbuf, final int off, final int len) throws IOException {\n            writer.write(cbuf, off, len);\n        }\n\n        @Override\n        public Writer append(final CharSequence csq, final int start, final int end)\n                throws IOException {\n            writer.append(csq, start, end);\n            return this;\n        }\n\n        @Override\n        public void write(String str, int off, int len) throws IOException {\n            if (!encoderAware) {\n                StringCharArrayAccessor.writeStringAsCharArray(writer, str, off, len);\n            } else {\n                writer.write(str, off, len);\n            }\n        }\n\n        @Override\n        public boolean isEncoderAware() throws IOException {\n            return encoderAware;\n        }\n\n        public boolean isAllowUnwrappingOut() {\n            return true;\n        }\n\n        public Writer unwrap() {\n            return writer;\n        }\n\n        public void markUsed() {\n        }\n\n        @Override\n        public void forceFlush() throws IOException {\n            writer.flush();\n        }\n    }\n\n    static abstract class ConnectedWritersWriter extends Writer {\n        public abstract boolean isEncoderAware() throws IOException;\n        public abstract void forceFlush() throws IOException;\n    }\n\n    /**\n     * delegates to several writers, used in \"connectTo\" mode.\n     */\n    static final class MultiOutputWriter extends ConnectedWritersWriter {\n        final List<ConnectedWriter> connectedWriters;\n        final List<Writer> writers;\n\n        public MultiOutputWriter(final List<ConnectedWriter> connectedWriters) {\n            this.connectedWriters = connectedWriters;\n            this.writers = new ArrayList<Writer>(connectedWriters.size());\n            for (ConnectedWriter connectedWriter : connectedWriters) {\n                writers.add(connectedWriter.getWriter());\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            // do nothing\n        }\n\n        @Override\n        public void flush() throws IOException {\n            for (ConnectedWriter connectedWriter : connectedWriters) {\n                connectedWriter.flush();\n            }\n        }\n\n        @Override\n        public void write(final char[] cbuf, final int off, final int len) throws IOException {\n            for (Writer writer : writers) {\n                writer.write(cbuf, off, len);\n            }\n        }\n\n        @Override\n        public Writer append(final CharSequence csq, final int start, final int end)\n                throws IOException {\n            for (Writer writer : writers) {\n                writer.append(csq, start, end);\n            }\n            return this;\n        }\n\n        @Override\n        public void write(String str, int off, int len) throws IOException {\n            if (isEncoderAware()) {\n                for (ConnectedWriter connectedWriter : connectedWriters) {\n                    if (!connectedWriter.isEncoderAware()) {\n                        StringCharArrayAccessor.writeStringAsCharArray(connectedWriter.getWriter(), str, off, len);\n                    } else {\n                        connectedWriter.getWriter().write(str, off, len);\n                    }\n                }\n            } else {\n                for (Writer writer : writers) {\n                    writer.write(str, off, len);\n                }\n            }\n        }\n\n        Boolean encoderAware;\n        @Override\n        public boolean isEncoderAware() throws IOException {\n            if (encoderAware==null) {\n                encoderAware = false;\n                for (ConnectedWriter writer : connectedWriters) {\n                    if (writer.isEncoderAware()) {\n                        encoderAware = true;\n                        break;\n                    }\n                }\n            }\n            return encoderAware;\n        }\n\n        @Override\n        public void forceFlush() throws IOException {\n            for (Writer writer : writers) {\n                writer.flush();\n            }\n        }\n    }\n\n    /* Compatibility methods so that StreamCharBuffer will behave more like java.lang.String in groovy code */\n\n    public char charAt(int index) {\n        return toString().charAt(index);\n    }\n\n    public int length() {\n        return size();\n    }\n\n    public CharSequence subSequence(int start, int end) {\n        return toString().subSequence(start, end);\n    }\n\n    public boolean asBoolean() {\n        return isNotEmpty();\n    }\n\n    /* methods for notifying child (sub) StreamCharBuffer changes to the parent StreamCharBuffer */\n\n    void addParentBuffer(StreamCharBuffer parent) {\n        if (!notifyParentBuffersEnabled) return;\n\n        if (parentBuffers==null) {\n            parentBuffers=new HashSet<SoftReference<StreamCharBufferKey>>();\n        }\n        parentBuffers.add(new SoftReference<StreamCharBufferKey>(parent.bufferKey));\n    }\n\n    protected boolean bufferChanged(StreamCharBuffer buffer) {\n        markBufferChanged();\n\n        StreamCharBufferSubChunk subChunk=dynamicChunkMap.get(buffer.bufferKey);\n        if (subChunk==null) {\n            // buffer isn't a subchunk in this buffer any more\n            return false;\n        }\n        // reset cached size;\n        if (subChunk.resetSubBuffer()) {\n            totalCharsInDynamicChunks=-1;\n            sizeAtLeast=-1;\n            // notify parents too\n            notifyBufferChange();\n        }\n        return true;\n    }\n    \n    protected List<StreamCharBuffer> getCurrentParentBuffers() {\n        List<StreamCharBuffer> currentParentBuffers = new ArrayList<StreamCharBuffer>();\n        if(parentBuffers != null) {\n            for (Iterator<SoftReference<StreamCharBufferKey>> i = parentBuffers.iterator(); i.hasNext();) {\n                SoftReference<StreamCharBufferKey> ref = i.next();\n                final StreamCharBuffer.StreamCharBufferKey parentKey = ref.get();\n                if (parentKey != null) {\n                    currentParentBuffers.add(parentKey.getBuffer());\n                }\n            }\n        }\n        return currentParentBuffers;\n    }\n    \n\n    protected void notifyBufferChange() {\n        markBufferChanged();\n\n        if (!notifyParentBuffersEnabled)\n            return;\n\n        if (parentBuffers == null || parentBuffers.isEmpty()) {\n            return;\n        }\n\n        List<SoftReference<StreamCharBufferKey>> parentBuffersList = new ArrayList<>(parentBuffers);\n        for (SoftReference<StreamCharBufferKey> ref : parentBuffersList) {\n            final StreamCharBuffer.StreamCharBufferKey parentKey = ref.get();\n            boolean removeIt = true;\n            if (parentKey != null) {\n                StreamCharBuffer parent = parentKey.getBuffer();\n                removeIt = !parent.bufferChanged(this);\n            }\n            if (removeIt) {\n                parentBuffers.remove(ref);\n            }\n        }\n    }\n\n    public int getBufferChangesCounter() {\n        return bufferChangesCounter;\n    }\n\n    protected int markBufferChanged() {\n        return bufferChangesCounter++;\n    }\n\n    @Override\n    public StreamCharBuffer clone() {\n        StreamCharBuffer cloned=new StreamCharBuffer();\n        cloned.setNotifyParentBuffersEnabled(false);\n        cloned.setAllowSubBuffers(false);\n        if (this.size() > 0) {\n            cloned.addChunk(readToSingleChunk());\n        }\n        cloned.setAllowSubBuffers(true);\n        return cloned;\n    }\n\n    public void readExternal(ObjectInput in) throws IOException,\n            ClassNotFoundException {\n        int version = in.readInt();\n        if (version != EXTERNALIZABLE_VERSION) {\n            throw new IOException(\"Uncompatible version in serialization stream.\");\n        }\n        reset();\n        int len = in.readInt();\n        if (len > 0) {\n            char[] buf=new char[len];\n            Reader reader = new InputStreamReader((InputStream)in, \"UTF-8\");\n            reader.read(buf);\n            String str=StringCharArrayAccessor.createString(buf);\n            MultipartStringChunk mpStringChunk=new MultipartStringChunk(str);\n            int partCount = in.readInt();\n            for(int i=0;i < partCount;i++) {\n                EncodingStatePart current = new EncodingStatePart();\n                mpStringChunk.appendEncodingStatePart(current);\n                current.len = in.readInt();\n                int encodersSize = in.readInt();\n                Set<Encoder> encoders = null;\n                if (encodersSize > 0) {\n                    encoders = new LinkedHashSet<Encoder>();\n                    for (int j=0;j < encodersSize;j++) {\n                        String codecName=in.readUTF();\n                        boolean safe=in.readBoolean();\n                        encoders.add(new SavedEncoder(codecName, safe));\n                    }\n                }\n                current.encodingState = new EncodingStateImpl(encoders, null);\n            }\n            addChunk(mpStringChunk);\n        }\n    }\n\n    private static final class SavedEncoder implements Encoder {\n        private CodecIdentifier codecIdentifier;\n        private boolean safe;\n\n        public SavedEncoder(String codecName, boolean safe) {\n            this.codecIdentifier=new DefaultCodecIdentifier(codecName);\n            this.safe=safe;\n        }\n\n        public CodecIdentifier getCodecIdentifier() {\n            return codecIdentifier;\n        }\n\n        public boolean isSafe() {\n            return safe;\n        }\n\n        public Object encode(Object o) {\n            throw new UnsupportedOperationException(\"encode isn't supported for SavedEncoder\");\n        }\n\n        public void markEncoded(CharSequence string) {\n            throw new UnsupportedOperationException(\"markEncoded isn't supported for SavedEncoder\");\n        }\n\n        public boolean isApplyToSafelyEncoded() {\n            return false;\n        }\n    }\n\n    public void writeExternal(ObjectOutput out) throws IOException {\n        out.writeInt(EXTERNALIZABLE_VERSION);\n        StringChunk stringChunk = readToSingleStringChunk(false);\n        if (stringChunk != null && stringChunk.str.length() > 0) {\n            char[] buf = StringCharArrayAccessor.getValue(stringChunk.str);\n            out.writeInt(buf.length);\n            Writer writer = new OutputStreamWriter((OutputStream)out, \"UTF-8\");\n            writer.write(buf);\n            writer.flush();\n            if (stringChunk instanceof MultipartStringChunk) {\n                MultipartStringChunk mpStringChunk = (MultipartStringChunk)stringChunk;\n                out.writeInt(mpStringChunk.partCount());\n                EncodingStatePart current = mpStringChunk.firstPart;\n                while (current != null) {\n                    out.writeInt(current.len);\n                    if (current.encodingState != null && current.encodingState.getEncoders() != null && current.encodingState.getEncoders().size() > 0) {\n                        out.writeInt(current.encodingState.getEncoders().size());\n                        for(Encoder encoder : current.encodingState.getEncoders()) {\n                            out.writeUTF(encoder.getCodecIdentifier().getCodecName());\n                            out.writeBoolean(encoder.isSafe());\n                        }\n                    } else {\n                        out.writeInt(0);\n                    }\n                    current = current.next;\n                }\n            } else {\n                out.writeInt(0);\n            }\n        } else {\n            out.writeInt(0);\n        }\n    }\n    \n    public StreamCharBuffer encodeToBuffer(Encoder encoder) {\n        return encodeToBuffer(encoder, isAllowSubBuffers(), isNotifyParentBuffersEnabled());\n    }\n    \n    public StreamCharBuffer encodeToBuffer(Encoder encoder, boolean allowSubBuffers, boolean notifyParentBuffersEnabled) {\n        StreamCharBuffer coded = new StreamCharBuffer(Math.min(Math.max(totalChunkSize, chunkSize) * 12 / 10, maxChunkSize));\n        coded.setAllowSubBuffers(allowSubBuffers);\n        coded.setNotifyParentBuffersEnabled(notifyParentBuffersEnabled);\n        EncodedAppender codedWriter = coded.writer.getEncodedAppender();\n        try {\n            encodeTo(codedWriter, encoder);\n        } catch (IOException e) {\n            // Should not ever happen\n            log.error(\"IOException in StreamCharBuffer.encodeToBuffer\", e);\n        }\n        return coded;\n    }\n    \n    public StreamCharBuffer encodeToBuffer(List<Encoder> encoders) {\n        return encodeToBuffer(encoders, isAllowSubBuffers(), isNotifyParentBuffersEnabled());\n    }\n    \n    public StreamCharBuffer encodeToBuffer(List<Encoder> encoders, boolean allowSubBuffers, boolean notifyParentBuffersEnabled) {\n        StreamCharBuffer currentBuffer=this;\n        for(Encoder encoder : encoders) {\n            currentBuffer = currentBuffer.encodeToBuffer(encoder, allowSubBuffers, notifyParentBuffersEnabled);\n        }\n        return currentBuffer;\n    }\n\n    public void encodeTo(EncodedAppender appender, Encoder encoder) throws IOException {\n        if(isPreferSubChunkWhenWritingToOtherBuffer() && appender instanceof StreamCharBufferEncodedAppender) {\n            StreamCharBufferWriter writer = ((StreamCharBufferEncodedAppender)appender).getWriter();\n            if(writer.appendSubBuffer(this, encoder != null ? Collections.singletonList(encoder) : null)) {\n                // subbuffer was appended, so return\n                return;\n            }\n        }\n        AbstractChunk current = firstChunk;\n        while (current != null) {\n            current.encodeTo(appender, encoder);\n            current = current.next;\n        }\n        allocBuffer.encodeTo(appender, encoder);\n    }\n\n    public boolean isAllowSubBuffers() {\n        return subBuffersEnabled && !isConnectedMode();\n    }\n    \n    public void setAllowSubBuffers(boolean allowSubBuffers) {\n        this.subBuffersEnabled = allowSubBuffers;\n    }\n\n    public CharSequence encode(Encoder encoder) {\n        return encodeToBuffer(encoder);\n    }\n\n    public Writer getWriterForEncoder() {\n        return getWriterForEncoder(null);\n    }\n\n    public Writer getWriterForEncoder(Encoder encoder) {\n        return getWriterForEncoder(encoder, lookupDefaultEncodingStateRegistry());\n    }\n\n    protected EncodingStateRegistry lookupDefaultEncodingStateRegistry() {\n        EncodingStateRegistryLookup encodingStateRegistryLookup = EncodingStateRegistryLookupHolder.getEncodingStateRegistryLookup();\n        return encodingStateRegistryLookup != null ? encodingStateRegistryLookup.lookup() : null;\n    }\n\n    public Writer getWriterForEncoder(Encoder encoder, EncodingStateRegistry encodingStateRegistry) {\n        return getWriterForEncoder(encoder, encodingStateRegistry, false);\n    }\n\n    public Writer getWriterForEncoder(Encoder encoder, EncodingStateRegistry encodingStateRegistry, boolean ignoreEncodingState) {\n        EncodedAppender encodedAppender = writer.getEncodedAppender();\n        encodedAppender.setIgnoreEncodingState(ignoreEncodingState);\n        return new EncodedAppenderWriter(encodedAppender, encoder, encodingStateRegistry);\n    }\n\n    public boolean isNotifyParentBuffersEnabled() {\n        return notifyParentBuffersEnabled;\n    }\n\n    /**\n     * By default the parent buffers (a buffer where this buffer has been appended to) get notified of changed to this buffer.\n     *\n     * You can control the notification behavior with this property.\n     * Setting this property to false will also clear the references to parent buffers if there are any.\n     *\n     * @param notifyParentBuffersEnabled\n     */\n    public void setNotifyParentBuffersEnabled(boolean notifyParentBuffersEnabled) {\n        this.notifyParentBuffersEnabled = notifyParentBuffersEnabled;\n        if (!notifyParentBuffersEnabled && parentBuffers != null) {\n            parentBuffers.clear();\n        }\n    }\n\n    @Override\n    public void encodeTo(Writer writer, EncodesToWriter encoder) throws IOException {\n        AbstractChunk current = firstChunk;\n        while (current != null) {\n            current.encodeTo(writer, encoder);\n            current = current.next;\n        }\n        allocBuffer.encodeTo(writer, encoder);\n    }\n\n    /**\n     * Delegates methodMissing to String object\n     *\n     * @param name The name of the method\n     * @param args The arguments\n     * @return The return value\n     */\n    public Object methodMissing(String name, Object args) {\n        String str = this.toString();\n        return InvokerHelper.invokeMethod(str, name, args);\n    }\n\n    public Object asType(Class clazz) {\n        if (clazz == String.class) {\n            return toString();\n        } else if (clazz == char[].class) {\n            return toCharArray();\n        } else if (clazz == Boolean.class || clazz == boolean.class ) {\n            return asBoolean();\n        } else {\n            return StringGroovyMethods.asType(toString(), clazz);\n        }\n    }\n}\n", "/*\n * Copyright 2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.grails.databinding.bindingsource;\n\n\n\n/**\n * Thrown if an unrecoverable problem occurs creating a DataBindingSource.\n *\n * @since 2.3\n * @see grails.databinding.DataBindingSource\n * @see DataBindingSourceCreator\n */\npublic class DataBindingSourceCreationException extends RuntimeException {\n\n    public DataBindingSourceCreationException(Throwable cause) {\n        super(cause);\n    }\n}\n", "package org.grails.web.json;\n\n/*\nCopyright (c) 2002 JSON.org\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nThe Software shall be used for Good, not Evil.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nimport groovy.lang.Writable;\nimport org.grails.encoder.EncodesToWriter;\nimport org.grails.encoder.StreamingEncoder;\nimport org.grails.encoder.StreamingEncoderWritable;\nimport org.grails.encoder.StreamingEncoderWriter;\nimport org.springframework.util.ClassUtils;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.*;\n\n/**\n * A JSONObject is an unordered collection of name/value pairs. Its\n * external form is a string wrapped in curly braces with colons between the\n * names and values, and commas between the values  and names. The internal form\n * is an object having <code>get</code> and <code>opt</code> methods for\n * accessing the values by name, and <code>put</code> methods for adding or\n * replacing values by name. The values can be any of these types:\n * <code>Boolean</code>, <code>JSONArray</code>, <code>JSONObject</code>,\n * <code>Number</code>, or <code>String</code>. A JSONObject constructor can be used to convert an external form\n * JSON text into an internal form whose values can be retrieved with the\n * <code>get</code> and <code>opt</code> methods, or to convert values into a\n * JSON text using the <code>put</code> and <code>toString</code> methods.\n * A <code>get</code> method returns a value if one can be found, and throws an\n * exception if one cannot be found. An <code>opt</code> method returns a\n * default value instead of throwing an exception, and so is useful for\n * obtaining optional values.\n * <p/>\n * The generic <code>get()</code> and <code>opt()</code> methods return an\n * object, which you can cast or query for type. There are also typed\n * <code>get</code> and <code>opt</code> methods that do type checking and type\n * coersion for you.\n * <p/>\n * The <code>put</code> methods adds values to an object. For example, <pre>\n *     myString = new JSONObject().put(\"JSON\", \"Hello, World!\").toString();</pre>\n * produces the string <code>{\"JSON\": \"Hello, World\"}</code>.\n * <p/>\n * The texts produced by the <code>toString</code> methods strictly conform to\n * the JSON sysntax rules.\n * The constructors are more forgiving in the texts they will accept:\n * <ul>\n * <li>An extra <code>,</code>&nbsp;<small>(comma)</small> may appear just\n * before the closing brace.</li>\n * <li>Strings may be quoted with <code>'</code>&nbsp;<small>(single\n * quote)</small>.</li>\n * <li>Strings do not need to be quoted at all if they do not begin with a quote\n * or single quote, and if they do not contain leading or trailing spaces,\n * and if they do not contain any of these characters:\n * <code>{ } [ ] / \\ : , = ; #</code> and if they do not look like numbers\n * and if they are not the reserved words <code>true</code>,\n * <code>false</code>, or <code>null</code>.</li>\n * <li>Keys can be followed by <code>=</code> or <code>=$gt;</code> as well as\n * by <code>:</code>.</li>\n * <li>Values can be followed by <code>;</code> <small>(semicolon)</small> as\n * well as by <code>,</code> <small>(comma)</small>.</li>\n * <li>Numbers may have the <code>0-</code> <small>(octal)</small> or\n * <code>0x-</code> <small>(hex)</small> prefix.</li>\n * <li>Comments written in the slashshlash, slashstar, and hash conventions\n * will be ignored.</li>\n * </ul>\n *\n * @author JSON.org\n * @version 2\n */\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic class JSONObject implements JSONElement, Map {\n    private static EncodesToWriter javascriptEncoderStateless;\n    private static StreamingEncoder javascriptEncoder;\n    private static boolean useStreamingJavascriptEncoder=false;\n    static {\n        try {\n            javascriptEncoder = (StreamingEncoder)ClassUtils.forName(\"org.grails.plugins.codecs.JSONEncoder\", JSONObject.class.getClassLoader()).newInstance();\n            javascriptEncoderStateless = (EncodesToWriter)javascriptEncoder;\n            useStreamingJavascriptEncoder = true;\n        }\n        catch (Exception e) {\n            // ignore\n        }\n    }\n\n    /**\n     * The hash map where the JSONObject's properties are kept.\n     */\n    private HashMap myHashMap;\n\n    /**\n     * Construct an empty JSONObject.\n     */\n    public JSONObject() {\n        this.myHashMap = new HashMap();\n    }\n\n\n    /**\n     * Construct a JSONObject from a subset of another JSONObject.\n     * An array of strings is used to identify the keys that should be copied.\n     * Missing keys are ignored.\n     *\n     * @param jo A JSONObject.\n     * @param sa An array of strings.\n     * @throws JSONException If a value is a non-finite number.\n     */\n    public JSONObject(JSONObject jo, String[] sa) throws JSONException {\n        this();\n        for (int i = 0; i < sa.length; i += 1) {\n            putOpt(sa[i], jo.opt(sa[i]));\n        }\n    }\n\n\n    /**\n     * Construct a JSONObject from a JSONTokener.\n     *\n     * @param x A JSONTokener object containing the source string.\n     * @throws JSONException If there is a syntax error in the source string.\n     */\n    public JSONObject(JSONTokener x) throws JSONException {\n        this();\n        char c;\n        String key;\n\n        if (x.nextClean() != '{') {\n            throw x.syntaxError(\"A JSONObject text must begin with '{'\");\n        }\n        for (; ;) {\n            c = x.nextClean();\n            switch (c) {\n                case 0:\n                    throw x.syntaxError(\"A JSONObject text must end with '}'\");\n                case '}':\n                    return;\n                default:\n                    x.back();\n                    key = x.nextValue().toString();\n            }\n\n            /*\n             * The key is followed by ':'. We will also tolerate '=' or '=>'.\n             */\n\n            c = x.nextClean();\n            if (c == '=') {\n                if (x.next() != '>') {\n                    x.back();\n                }\n            } else if (c != ':') {\n                throw x.syntaxError(\"Expected a ':' after a key\");\n            }\n            this.myHashMap.put(key, x.nextValue());\n\n            /*\n             * Pairs are separated by ','. We will also tolerate ';'.\n             */\n\n            switch (x.nextClean()) {\n                case ';':\n                case ',':\n                    if (x.nextClean() == '}') {\n                        return;\n                    }\n                    x.back();\n                    break;\n                case '}':\n                    return;\n                default:\n                    throw x.syntaxError(\"Expected a ',' or '}'\");\n            }\n        }\n    }\n\n\n    /**\n     * Construct a JSONObject from a Map.\n     *\n     * @param map A map object that can be used to initialize the contents of\n     *            the JSONObject.\n     */\n    public JSONObject(Map map) {\n        this.myHashMap = new HashMap(map);\n    }\n\n\n    /**\n     * Construct a JSONObject from a string.\n     * This is the most commonly used JSONObject constructor.\n     *\n     * @param string A string beginning\n     *               with <code>{</code>&nbsp;<small>(left brace)</small> and ending\n     *               with <code>}</code>&nbsp;<small>(right brace)</small>.\n     * @throws JSONException If there is a syntax error in the source string.\n     */\n    public JSONObject(String string) throws JSONException {\n        this(new JSONTokener(string));\n    }\n\n\n    /**\n     * Accumulate values under a key. It is similar to the put method except\n     * that if there is already an object stored under the key then a\n     * JSONArray is stored under the key to hold all of the accumulated values.\n     * If there is already a JSONArray, then the new value is appended to it.\n     * In contrast, the put method replaces the previous value.\n     *\n     * @param key   A key string.\n     * @param value An object to be accumulated under the key.\n     * @return this\n     * @throws JSONException If the value is an invalid number\n     *                       or if the key is null.\n     */\n    public JSONObject accumulate(String key, Object value)\n            throws JSONException {\n        testValidity(value);\n        Object o = opt(key);\n        if (o == null) {\n            put(key, value);\n        } else if (o instanceof JSONArray) {\n            ((JSONArray) o).put(value);\n        } else {\n            put(key, new JSONArray().put(o).put(value));\n        }\n        return this;\n    }\n\n\n    /**\n     * Get the value object associated with a key.\n     *\n     * @param key A key string.\n     * @return The object associated with the key.\n     * @throws JSONException if the key is not found.\n     */\n    public Object get(String key) throws JSONException {\n        if(!myHashMap.containsKey(key)) {\n            throw new JSONException(\"JSONObject[\" + quote(key) +\n                    \"] not found.\");\n        }\n        return opt(key);\n    }\n\n\n    /**\n     * Get the boolean value associated with a key.\n     *\n     * @param key A key string.\n     * @return The truth.\n     * @throws JSONException if the value is not a Boolean or the String \"true\" or \"false\".\n     */\n    public boolean getBoolean(String key) throws JSONException {\n        Object o = get(key);\n        if (o.equals(Boolean.FALSE) ||\n                (o instanceof String &&\n                        ((String) o).equalsIgnoreCase(\"false\"))) {\n            return false;\n        } else if (o.equals(Boolean.TRUE) ||\n                (o instanceof String &&\n                        ((String) o).equalsIgnoreCase(\"true\"))) {\n            return true;\n        }\n        throw new JSONException(\"JSONObject[\" + quote(key) +\n                \"] is not a Boolean.\");\n    }\n\n\n    /**\n     * Get the double value associated with a key.\n     *\n     * @param key A key string.\n     * @return The numeric value.\n     * @throws JSONException if the key is not found or\n     *                       if the value is not a Number object and cannot be converted to a number.\n     */\n    public double getDouble(String key) throws JSONException {\n        Object o = get(key);\n        try {\n            return o instanceof Number ?\n                    ((Number) o).doubleValue() : Double.parseDouble((String) o);\n        } catch (Exception e) {\n            throw new JSONException(\"JSONObject[\" + quote(key) +\n                    \"] is not a number.\");\n        }\n    }\n\n\n    /**\n     * Get the int value associated with a key. If the number value is too\n     * large for an int, it will be clipped.\n     *\n     * @param key A key string.\n     * @return The integer value.\n     * @throws JSONException if the key is not found or if the value cannot\n     *                       be converted to an integer.\n     */\n    public int getInt(String key) throws JSONException {\n        Object o = get(key);\n        return o instanceof Number ?\n                ((Number) o).intValue() : (int) getDouble(key);\n    }\n\n\n    /**\n     * Get the JSONArray value associated with a key.\n     *\n     * @param key A key string.\n     * @return A JSONArray which is the value.\n     * @throws JSONException if the key is not found or\n     *                       if the value is not a JSONArray.\n     */\n    public JSONArray getJSONArray(String key) throws JSONException {\n        Object o = get(key);\n        if (o instanceof JSONArray) {\n            return (JSONArray) o;\n        }\n        throw new JSONException(\"JSONObject[\" + quote(key) +\n                \"] is not a JSONArray.\");\n    }\n\n\n    /**\n     * Get the JSONObject value associated with a key.\n     *\n     * @param key A key string.\n     * @return A JSONObject which is the value.\n     * @throws JSONException if the key is not found or\n     *                       if the value is not a JSONObject.\n     */\n    public JSONObject getJSONObject(String key) throws JSONException {\n        Object o = get(key);\n        if (o instanceof JSONObject) {\n            return (JSONObject) o;\n        }\n        throw new JSONException(\"JSONObject[\" + quote(key) +\n                \"] is not a JSONObject.\");\n    }\n\n\n    /**\n     * Get the long value associated with a key. If the number value is too\n     * long for a long, it will be clipped.\n     *\n     * @param key A key string.\n     * @return The long value.\n     * @throws JSONException if the key is not found or if the value cannot\n     *                       be converted to a long.\n     */\n    public long getLong(String key) throws JSONException {\n        Object o = get(key);\n        return o instanceof Number ?\n                ((Number) o).longValue() : (long) getDouble(key);\n    }\n\n\n    /**\n     * Get the string associated with a key.\n     *\n     * @param key A key string.\n     * @return A string which is the value.\n     * @throws JSONException if the key is not found.\n     */\n    public String getString(String key) throws JSONException {\n        return get(key).toString();\n    }\n\n\n    /**\n     * Determine if the JSONObject contains a specific key.\n     *\n     * @param key A key string.\n     * @return true if the key exists in the JSONObject.\n     */\n    public boolean has(String key) {\n        return myHashMap.containsKey(key);\n    }\n\n\n    /**\n     * Determine if the value associated with the key is null or if there is\n     * no value.\n     *\n     * @param key A key string.\n     * @return true if there is no value associated with the key or if\n     *         the value is the JSONObject.NULL object.\n     */\n    public boolean isNull(String key) {\n        return opt(key) == null;\n    }\n\n\n    /**\n     * Get an enumeration of the keys of the JSONObject.\n     *\n     * @return An iterator of the keys.\n     */\n    public Iterator keys() {\n        return myHashMap.keySet().iterator();\n    }\n\n\n    /**\n     * Get the number of keys stored in the JSONObject.\n     *\n     * @return The number of keys in the JSONObject.\n     */\n    public int length() {\n        return myHashMap.size();\n    }\n\n\n    /**\n     * Produce a JSONArray containing the names of the elements of this\n     * JSONObject.\n     *\n     * @return A JSONArray containing the key strings, or null if the JSONObject\n     *         is empty.\n     */\n    public JSONArray names() {\n        JSONArray ja = new JSONArray();\n        Iterator keys = keys();\n        while (keys.hasNext()) {\n            ja.put(keys.next());\n        }\n        return ja.length() == 0 ? null : ja;\n    }\n\n    /**\n     * Produce a string from a number.\n     *\n     * @param n A Number\n     * @return A String.\n     * @throws JSONException If n is a non-finite number.\n     */\n    static public String numberToString(Number n)\n            throws JSONException {\n        if (n == null) {\n            throw new JSONException(\"Null pointer\");\n        }\n        testValidity(n);\n\n// Shave off trailing zeros and decimal point, if possible.\n\n        String s = n.toString();\n        if (s.indexOf('.') > 0 && s.indexOf('e') < 0 && s.indexOf('E') < 0) {\n            while (s.endsWith(\"0\")) {\n                s = s.substring(0, s.length() - 1);\n            }\n            if (s.endsWith(\".\")) {\n                s = s.substring(0, s.length() - 1);\n            }\n        }\n        return s;\n    }\n\n    static public String dateToString(Date d) throws JSONException {\n        return \"new Date(\" + d.getTime() + \")\";\n    }\n\n    static public String collectionToString(Collection c) {\n        StringBuilder sb = new StringBuilder(\"[\");\n        boolean first = true;\n        Iterator iterator = c.iterator();\n        while(iterator.hasNext()) {\n            if (!first) {\n                sb.append(',');\n            }\n            sb.append(valueToString(iterator.next()));\n            first = false;\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n\n    /**\n     * Get an optional value associated with a key.\n     *\n     * @param key A key string.\n     * @return An object which is the value, or null if there is no value.\n     */\n    public Object opt(String key) {\n        return key == null ? null : this.myHashMap.get(key);\n    }\n\n\n    /**\n     * Get an optional boolean associated with a key.\n     * It returns false if there is no such key, or if the value is not\n     * Boolean.TRUE or the String \"true\".\n     *\n     * @param key A key string.\n     * @return The truth.\n     */\n    public boolean optBoolean(String key) {\n        return optBoolean(key, false);\n    }\n\n\n    /**\n     * Get an optional boolean associated with a key.\n     * It returns the defaultValue if there is no such key, or if it is not\n     * a Boolean or the String \"true\" or \"false\" (case insensitive).\n     *\n     * @param key          A key string.\n     * @param defaultValue The default.\n     * @return The truth.\n     */\n    public boolean optBoolean(String key, boolean defaultValue) {\n        try {\n            return getBoolean(key);\n        } catch (Exception e) {\n            return defaultValue;\n        }\n    }\n\n\n    /**\n     * Get an optional double associated with a key,\n     * or NaN if there is no such key or if its value is not a number.\n     * If the value is a string, an attempt will be made to evaluate it as\n     * a number.\n     *\n     * @param key A string which is the key.\n     * @return An object which is the value.\n     */\n    public double optDouble(String key) {\n        return optDouble(key, Double.NaN);\n    }\n\n\n    /**\n     * Get an optional double associated with a key, or the\n     * defaultValue if there is no such key or if its value is not a number.\n     * If the value is a string, an attempt will be made to evaluate it as\n     * a number.\n     *\n     * @param key          A key string.\n     * @param defaultValue The default.\n     * @return An object which is the value.\n     */\n    public double optDouble(String key, double defaultValue) {\n        try {\n            Object o = opt(key);\n            return o instanceof Number ? ((Number) o).doubleValue() :\n                    Double.valueOf((String) o);\n        } catch (Exception e) {\n            return defaultValue;\n        }\n    }\n\n\n    /**\n     * Get an optional int value associated with a key,\n     * or zero if there is no such key or if the value is not a number.\n     * If the value is a string, an attempt will be made to evaluate it as\n     * a number.\n     *\n     * @param key A key string.\n     * @return An object which is the value.\n     */\n    public int optInt(String key) {\n        return optInt(key, 0);\n    }\n\n\n    /**\n     * Get an optional int value associated with a key,\n     * or the default if there is no such key or if the value is not a number.\n     * If the value is a string, an attempt will be made to evaluate it as\n     * a number.\n     *\n     * @param key          A key string.\n     * @param defaultValue The default.\n     * @return An object which is the value.\n     */\n    public int optInt(String key, int defaultValue) {\n        try {\n            return getInt(key);\n        } catch (Exception e) {\n            return defaultValue;\n        }\n    }\n\n\n    /**\n     * Get an optional JSONArray associated with a key.\n     * It returns null if there is no such key, or if its value is not a\n     * JSONArray.\n     *\n     * @param key A key string.\n     * @return A JSONArray which is the value.\n     */\n    public JSONArray optJSONArray(String key) {\n        Object o = opt(key);\n        return o instanceof JSONArray ? (JSONArray) o : null;\n    }\n\n\n    /**\n     * Get an optional JSONObject associated with a key.\n     * It returns null if there is no such key, or if its value is not a\n     * JSONObject.\n     *\n     * @param key A key string.\n     * @return A JSONObject which is the value.\n     */\n    public JSONObject optJSONObject(String key) {\n        Object o = opt(key);\n        return o instanceof JSONObject ? (JSONObject) o : null;\n    }\n\n\n    /**\n     * Get an optional long value associated with a key,\n     * or zero if there is no such key or if the value is not a number.\n     * If the value is a string, an attempt will be made to evaluate it as\n     * a number.\n     *\n     * @param key A key string.\n     * @return An object which is the value.\n     */\n    public long optLong(String key) {\n        return optLong(key, 0);\n    }\n\n\n    /**\n     * Get an optional long value associated with a key,\n     * or the default if there is no such key or if the value is not a number.\n     * If the value is a string, an attempt will be made to evaluate it as\n     * a number.\n     *\n     * @param key          A key string.\n     * @param defaultValue The default.\n     * @return An object which is the value.\n     */\n    public long optLong(String key, long defaultValue) {\n        try {\n            return getLong(key);\n        } catch (Exception e) {\n            return defaultValue;\n        }\n    }\n\n\n    /**\n     * Get an optional string associated with a key.\n     * It returns an empty string if there is no such key. If the value is not\n     * a string and is not null, then it is coverted to a string.\n     *\n     * @param key A key string.\n     * @return A string which is the value.\n     */\n    public String optString(String key) {\n        return optString(key, \"\");\n    }\n\n\n    /**\n     * Get an optional string associated with a key.\n     * It returns the defaultValue if there is no such key.\n     *\n     * @param key          A key string.\n     * @param defaultValue The default.\n     * @return A string which is the value.\n     */\n    public String optString(String key, String defaultValue) {\n        Object o = opt(key);\n        return o != null ? o.toString() : defaultValue;\n    }\n\n\n    /**\n     * Put a key/boolean pair in the JSONObject.\n     *\n     * @param key   A key string.\n     * @param value A boolean which is the value.\n     * @return this\n     * @throws JSONException If the key is null.\n     */\n    public JSONObject put(String key, boolean value) throws JSONException {\n        put(key, value ? Boolean.TRUE : Boolean.FALSE);\n        return this;\n    }\n\n\n    /**\n     * Put a key/double pair in the JSONObject.\n     *\n     * @param key   A key string.\n     * @param value A double which is the value.\n     * @return this\n     * @throws JSONException If the key is null or if the number is invalid.\n     */\n    public JSONObject put(String key, double value) throws JSONException {\n        put(key, Double.valueOf(value));\n        return this;\n    }\n\n\n    /**\n     * Put a key/int pair in the JSONObject.\n     *\n     * @param key   A key string.\n     * @param value An int which is the value.\n     * @return this\n     * @throws JSONException If the key is null.\n     */\n    public JSONObject put(String key, int value) throws JSONException {\n        put(key, Integer.valueOf(value));\n        return this;\n    }\n\n\n    /**\n     * Put a key/long pair in the JSONObject.\n     *\n     * @param key   A key string.\n     * @param value A long which is the value.\n     * @return this\n     * @throws JSONException If the key is null.\n     */\n    public JSONObject put(String key, long value) throws JSONException {\n        put(key, Long.valueOf(value));\n        return this;\n    }\n\n\n    /**\n     * Put a key/value pair in the JSONObject. If the value is null,\n     * then the key will be removed from the JSONObject if it is present.\n     *\n     * @param key   A key string.\n     * @param value An object which is the value. It should be of one of these\n     *              types: Boolean, Double, Integer, JSONArray, JSONObject, Long, String,\n     *              or the JSONObject.NULL object.\n     * @return this\n     * @throws JSONException If the value is non-finite number\n     *                       or if the key is null.\n     */\n    public JSONObject put(String key, Object value) throws JSONException {\n        if (key == null) {\n            throw new JSONException(\"Null key.\");\n        }\n        if (value != null) {\n            testValidity(value);\n            this.myHashMap.put(key, value);\n        } else {\n            remove(key);\n        }\n        return this;\n    }\n\n\n    /**\n     * Put a key/value pair in the JSONObject, but only if the\n     * key and the value are both non-null.\n     *\n     * @param key   A key string.\n     * @param value An object which is the value. It should be of one of these\n     *              types: Boolean, Double, Integer, JSONArray, JSONObject, Long, String,\n     *              or the JSONObject.NULL object.\n     * @return this\n     * @throws JSONException If the value is a non-finite number.\n     */\n    public JSONObject putOpt(String key, Object value) throws JSONException {\n        if (key != null && value != null) {\n            put(key, value);\n        }\n        return this;\n    }\n\n\n    /**\n     * Produce a string in double quotes with backslash sequences in all the\n     * right places. A backslash will be inserted within &lt;/, allowing JSON\n     * text to be delivered in HTML. In JSON text, a string cannot contain a\n     * control character or an unescaped quote or backslash.\n     *\n     * @param string A String\n     * @return A String correctly formatted for insertion in a JSON text.\n     */\n    public static String quote(String string) {\n        if (string == null || string.length() == 0) {\n            return \"\\\"\\\"\";\n        }\n\n        char b;\n        char c = 0;\n        int i;\n        int len = string.length();\n        StringBuilder sb = new StringBuilder(len + 4);\n        String t;\n\n        sb.append('\"');\n        for (i = 0; i < len; i += 1) {\n            b = c;\n            c = string.charAt(i);\n            switch (c) {\n                case '\\\\':\n                case '\"':\n                    sb.append('\\\\');\n                    sb.append(c);\n                    break;\n                case '/':\n                    if (b == '<') {\n                        sb.append('\\\\');\n                    }\n                    sb.append(c);\n                    break;\n                case '\\b':\n                    sb.append(\"\\\\b\");\n                    break;\n                case '\\t':\n                    sb.append(\"\\\\t\");\n                    break;\n                case '\\n':\n                    sb.append(\"\\\\n\");\n                    break;\n                case '\\f':\n                    sb.append(\"\\\\f\");\n                    break;\n                case '\\r':\n                    sb.append(\"\\\\r\");\n                    break;\n                default:\n                    if (c < ' ') {\n                        t = \"000\" + Integer.toHexString(c);\n                        sb.append(\"\\\\u\" + t.substring(t.length() - 4));\n                    } else {\n                        sb.append(c);\n                    }\n            }\n        }\n        sb.append('\"');\n        return sb.toString();\n    }\n\n    /**\n     * Remove a name and its value, if present.\n     *\n     * @param key The name to be removed.\n     * @return The value that was associated with the name,\n     *         or null if there was no value.\n     */\n    public Object remove(String key) {\n        return myHashMap.remove(key);\n    }\n\n    /**\n     * Throw an exception if the object is an NaN or infinite number.\n     *\n     * @param o The object to test.\n     * @throws JSONException If o is a non-finite number.\n     */\n    static void testValidity(Object o) throws JSONException {\n        if (o != null) {\n            if (o instanceof Double) {\n                if (((Double) o).isInfinite() || ((Double) o).isNaN()) {\n                    throw new JSONException(\n                            \"JSON does not allow non-finite numbers\");\n                }\n            } else if (o instanceof Float) {\n                if (((Float) o).isInfinite() || ((Float) o).isNaN()) {\n                    throw new JSONException(\n                            \"JSON does not allow non-finite numbers.\");\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Produce a JSONArray containing the values of the members of this\n     * JSONObject.\n     *\n     * @param names A JSONArray containing a list of key strings. This\n     *              determines the sequence of the values in the result.\n     * @return A JSONArray of values.\n     * @throws JSONException If any of the values are non-finite numbers.\n     */\n    public JSONArray toJSONArray(JSONArray names) throws JSONException {\n        if (names == null || names.length() == 0) {\n            return null;\n        }\n        JSONArray ja = new JSONArray();\n        for (int i = 0; i < names.length(); i += 1) {\n            ja.put(this.opt(names.getString(i)));\n        }\n        return ja;\n    }\n\n    /**\n     * Make an JSON text of this JSONObject. For compactness, no whitespace\n     * is added. If this would not result in a syntactically correct JSON text,\n     * then null will be returned instead.\n     * <p/>\n     * Warning: This method assumes that the data structure is acyclical.\n     *\n     * @return a printable, displayable, portable, transmittable\n     *         representation of the object, beginning\n     *         with <code>{</code>&nbsp;<small>(left brace)</small> and ending\n     *         with <code>}</code>&nbsp;<small>(right brace)</small>.\n     */\n    @Override\n    public String toString() {\n        try {\n            Iterator keys = keys();\n            StringBuilder sb = new StringBuilder(\"{\");\n\n            while (keys.hasNext()) {\n                if (sb.length() > 1) {\n                    sb.append(',');\n                }\n                Object o = keys.next();\n                sb.append(quote(o.toString()));\n                sb.append(':');\n                sb.append(valueToString(this.myHashMap.get(o)));\n            }\n            sb.append('}');\n            return sb.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n\n    /**\n     * Make a prettyprinted JSON text of this JSONObject.\n     * <p/>\n     * Warning: This method assumes that the data structure is acyclical.\n     *\n     * @param indentFactor The number of spaces to add to each level of\n     *                     indentation.\n     * @return a printable, displayable, portable, transmittable\n     *         representation of the object, beginning\n     *         with <code>{</code>&nbsp;<small>(left brace)</small> and ending\n     *         with <code>}</code>&nbsp;<small>(right brace)</small>.\n     * @throws JSONException If the object contains an invalid number.\n     */\n    public String toString(int indentFactor) throws JSONException {\n        return toString(indentFactor, 0);\n    }\n\n\n    /**\n     * Make a prettyprinted JSON text of this JSONObject.\n     * <p/>\n     * Warning: This method assumes that the data structure is acyclical.\n     *\n     * @param indentFactor The number of spaces to add to each level of\n     *                     indentation.\n     * @param indent       The indentation of the top level.\n     * @return a printable, displayable, transmittable\n     *         representation of the object, beginning\n     *         with <code>{</code>&nbsp;<small>(left brace)</small> and ending\n     *         with <code>}</code>&nbsp;<small>(right brace)</small>.\n     * @throws JSONException If the object contains an invalid number.\n     */\n    String toString(int indentFactor, int indent) throws JSONException {\n        int i;\n        int n = length();\n        if (n == 0) {\n            return \"{}\";\n        }\n        Iterator keys = keys();\n        StringBuilder sb = new StringBuilder(\"{\");\n        int newindent = indent + indentFactor;\n        Object o;\n        if (n == 1) {\n            o = keys.next();\n            sb.append(quote(o.toString()));\n            sb.append(\": \");\n            sb.append(valueToString(this.myHashMap.get(o), indentFactor,\n                    indent));\n        } else {\n            while (keys.hasNext()) {\n                o = keys.next();\n                if (sb.length() > 1) {\n                    sb.append(\",\\n\");\n                } else {\n                    sb.append('\\n');\n                }\n                for (i = 0; i < newindent; i += 1) {\n                    sb.append(' ');\n                }\n                sb.append(quote(o.toString()));\n                sb.append(\": \");\n                sb.append(valueToString(this.myHashMap.get(o), indentFactor,\n                        newindent));\n            }\n            if (sb.length() > 1) {\n                sb.append('\\n');\n                for (i = 0; i < indent; i += 1) {\n                    sb.append(' ');\n                }\n            }\n        }\n        sb.append('}');\n        return sb.toString();\n    }\n\n\n    /**\n     * Make a JSON text of an object value.\n     * <p/>\n     * Warning: This method assumes that the data structure is acyclical.\n     *\n     * @param value The value to be serialized.\n     * @return a printable, displayable, transmittable\n     *         representation of the object, beginning\n     *         with <code>{</code>&nbsp;<small>(left brace)</small> and ending\n     *         with <code>}</code>&nbsp;<small>(right brace)</small>.\n     * @throws JSONException If the value is or contains an invalid number.\n     */\n    static String valueToString(Object value) throws JSONException {\n        if (value == null || value.equals(null)) {\n            return \"null\";\n        }\n        if (value instanceof Number) {\n            return numberToString((Number) value);\n        }\n        if (value instanceof Date) {\n            return dateToString((Date) value);\n        }\n        if (value instanceof Boolean || value instanceof JSONObject) {\n            return value.toString();\n        }\n        if (value instanceof Collection) {\n            return collectionToString((Collection) value);\n        }\n        return quote(value.toString());\n    }\n\n    static void writeValue(Writer writer, Object value) throws IOException {\n        if (value == null || value.equals(null)) {\n            writer.write(\"null\");\n        } else if (value instanceof Number) {\n            writeNumber(writer, (Number) value);\n        } else if (value instanceof Date) {\n            writeDate(writer, (Date) value);\n        } else if (value instanceof Boolean) {\n            writer.write(value.toString());\n        } else if (value instanceof JSONElement) {\n            ((JSONElement)value).writeTo(writer);\n        } else {\n            writeQuoted(writer, value);\n        }\n    }\n\n    static void writeQuoted(Writer writer, Object value) throws IOException {\n        if (useStreamingJavascriptEncoder) {\n            writer.write(\"\\\"\");\n            if (value.getClass() == String.class || value.getClass() == StringBuilder.class || value.getClass() == StringBuffer.class) {\n                encodeToWriter((CharSequence)value, writer);\n            } else if(value instanceof StreamingEncoderWritable) {\n                ((StreamingEncoderWritable)value).encodeTo(writer, javascriptEncoderStateless);\n            } else if (value instanceof Writable) {\n                ((Writable)value).writeTo(new StreamingEncoderWriter(writer, javascriptEncoder, null));\n            }\n            else{\n                encodeToWriter(value.toString(), writer);\n            }\n            writer.write(\"\\\"\");\n        }\n        else {\n            writer.write(valueToString(value));\n        }\n    }\n\n\n    protected static void encodeToWriter(CharSequence str, Writer writer) throws IOException {\n        javascriptEncoderStateless.encodeToWriter(str, 0, str.length(), writer, null);\n    }\n\n    static void writeDate(Writer writer, Date d) throws IOException {\n        writer.write(\"new Date(\");\n        writer.write(String.valueOf(d.getTime()));\n        writer.write(\")\");\n    }\n\n    static void writeNumber(Writer writer, Number value) throws IOException {\n        writer.write(String.valueOf(value));\n    }\n\n    /**\n     * Make a prettyprinted JSON text of an object value.\n     * <p/>\n     * Warning: This method assumes that the data structure is acyclical.\n     *\n     * @param value        The value to be serialized.\n     * @param indentFactor The number of spaces to add to each level of\n     *                     indentation.\n     * @param indent       The indentation of the top level.\n     * @return a printable, displayable, transmittable\n     *         representation of the object, beginning\n     *         with <code>{</code>&nbsp;<small>(left brace)</small> and ending\n     *         with <code>}</code>&nbsp;<small>(right brace)</small>.\n     * @throws JSONException If the object contains an invalid number.\n     */\n    static String valueToString(Object value, int indentFactor, int indent)\n            throws JSONException {\n        if (value == null || value.equals(null)) {\n            return \"null\";\n        }\n        if (value instanceof Number) {\n            return numberToString((Number) value);\n        }\n        if (value instanceof Date) {\n            return dateToString((Date) value);\n        }\n        if (value instanceof Boolean) {\n            return value.toString();\n        }\n        if (value instanceof JSONObject) {\n            return ((JSONObject) value).toString(indentFactor, indent);\n        }\n        if (value instanceof JSONArray) {\n            return ((JSONArray) value).toString(indentFactor, indent);\n        }\n        return quote(value.toString());\n    }\n\n\n    /**\n     * Write the contents of the JSONObject as JSON text to a writer.\n     * For compactness, no whitespace is added.\n     * <p/>\n     * Warning: This method assumes that the data structure is acyclical.\n     *\n     * @return The writer.\n     * @throws JSONException\n     */\n    public Writer write(Writer writer) throws JSONException {\n        try {\n            boolean notFirst = false;\n            writer.write('{');\n            for(Iterator it = myHashMap.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Entry)it.next();\n                if (notFirst) {\n                    writer.write(',');\n                }\n                writeQuoted(writer, entry.getKey());\n                writer.write(':');\n                writeValue(writer, entry.getValue());\n                notFirst = true;\n            }\n            writer.write('}');\n            return writer;\n        } catch (IOException e) {\n            throw new JSONException(e);\n        }\n    }\n\n    public int size() {\n        return myHashMap.size();\n    }\n\n    public boolean isEmpty() {\n        return myHashMap.isEmpty();\n    }\n\n    public boolean containsKey(Object o) {\n        return myHashMap.containsKey(o);\n    }\n\n    public boolean containsValue(Object o) {\n        return myHashMap.containsValue(o);\n    }\n\n    public Object get(Object o) {\n        return myHashMap.get(o);\n    }\n\n    public Object put(Object o, Object o1) {\n        return myHashMap.put(o, o1);\n    }\n\n    public Object remove(Object o) {\n        return myHashMap.remove(o);\n    }\n\n    public void putAll(Map map) {\n        this.myHashMap.putAll(map);\n    }\n\n    public void clear() {\n        this.myHashMap.clear();\n    }\n\n    public Set keySet() {\n        return myHashMap.keySet();\n    }\n\n    public Collection values() {\n        return myHashMap.values();\n    }\n\n    public Set entrySet() {\n        return myHashMap.entrySet();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        JSONObject that = (JSONObject) o;\n\n        if (myHashMap != null ? !myHashMap.equals(that.myHashMap) : that.myHashMap != null) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return (myHashMap != null ? myHashMap.hashCode() : 0);\n    }\n\n\n    @Override\n    public Writer writeTo(Writer out) throws IOException {\n        return write(out);\n    }\n}\n", "/*\n * Copyright 2004-2005 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.grails.web.servlet.mvc;\n\nimport grails.util.Holders;\nimport grails.validation.DeferredBindingActions;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.lang.reflect.Constructor;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport grails.web.servlet.mvc.GrailsHttpSession;\nimport grails.web.servlet.mvc.GrailsParameterMap;\nimport grails.core.GrailsApplication;\nimport grails.core.GrailsControllerClass;\nimport org.grails.core.artefact.ControllerArtefactHandler;\nimport org.grails.core.io.support.GrailsFactoriesLoader;\nimport org.grails.encoder.CodecLookupHelper;\nimport org.grails.encoder.DefaultEncodingStateRegistry;\nimport org.grails.encoder.Encoder;\nimport org.grails.encoder.EncodingStateRegistry;\nimport org.grails.encoder.EncodingStateRegistryLookup;\nimport org.grails.encoder.EncodingStateRegistryLookupHolder;\nimport org.grails.web.beans.PropertyEditorRegistryUtils;\nimport org.grails.web.pages.FilteringCodecsByContentTypeSettings;\nimport grails.web.mvc.FlashScope;\nimport org.grails.web.util.GrailsApplicationAttributes;\nimport org.grails.web.servlet.mvc.exceptions.ControllerExecutionException;\nimport org.springframework.beans.PropertyEditorRegistry;\nimport org.springframework.beans.PropertyEditorRegistrySupport;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.web.context.request.RequestAttributes;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.servlet.handler.DispatcherServletWebRequest;\nimport org.springframework.web.servlet.support.RequestContextUtils;\nimport org.springframework.web.util.UrlPathHelper;\n\n/**\n * Encapsulates a Grails request. An instance of this class is bound to the current thread using\n * Spring's RequestContextHolder which can later be retrieved using:\n *\n * def webRequest = RequestContextHolder.currentRequestAttributes()\n *\n * @author Graeme Rocher\n * @since 3.0\n */\npublic class GrailsWebRequest extends DispatcherServletWebRequest  {\n\n    private static final String REDIRECT_CALLED = GrailsApplicationAttributes.REDIRECT_ISSUED;\n\n    private static final Class<? extends GrailsApplicationAttributes> grailsApplicationAttributesClass = GrailsFactoriesLoader.loadFactoryClasses(GrailsApplicationAttributes.class, GrailsWebRequest.class.getClassLoader()).get(0);\n    private static final Constructor<? extends GrailsApplicationAttributes> grailsApplicationAttributesConstructor = ClassUtils.getConstructorIfAvailable(grailsApplicationAttributesClass, ServletContext.class);\n    private GrailsApplicationAttributes attributes;\n    private GrailsParameterMap params;\n    private GrailsParameterMap originalParams;\n    private GrailsHttpSession session;\n    private boolean renderView = true;\n    private boolean skipFilteringCodec = false;\n    private Encoder filteringEncoder;\n    public static final String ID_PARAMETER = \"id\";\n    private final List<ParameterCreationListener> parameterCreationListeners = new ArrayList<ParameterCreationListener>();\n    private final UrlPathHelper urlHelper = new UrlPathHelper();\n    private ApplicationContext applicationContext;\n    private String baseUrl;\n    private HttpServletResponse wrappedResponse;\n\n    private EncodingStateRegistry encodingStateRegistry;\n    private HttpServletRequest multipartRequest;\n\n    public GrailsWebRequest(HttpServletRequest request, HttpServletResponse response, GrailsApplicationAttributes attributes) {\n        super(request, response);\n        this.attributes = attributes;\n        this.applicationContext = attributes.getApplicationContext();\n        inheritEncodingStateRegistry();\n    }\n\n    public GrailsWebRequest(HttpServletRequest request, HttpServletResponse response, ServletContext servletContext) {\n        super(request, response);\n        try {\n            attributes = grailsApplicationAttributesConstructor.newInstance(servletContext);\n            this.applicationContext = attributes.getApplicationContext();\n        }\n        catch (Exception e) {\n            ReflectionUtils.rethrowRuntimeException(e);\n        }\n        inheritEncodingStateRegistry();\n    }\n\n    public GrailsWebRequest(HttpServletRequest request, HttpServletResponse response, ServletContext servletContext, ApplicationContext applicationContext) {\n        this(request, response, servletContext);\n        this.applicationContext = applicationContext;\n    }\n\n\n    /**\n     * Holds a reference to the {@link org.springframework.web.multipart.MultipartRequest}\n     *\n     * @param multipartRequest The multipart request\n     */\n    public void setMultipartRequest(HttpServletRequest multipartRequest) {\n        this.multipartRequest = multipartRequest;\n    }\n\n    private void inheritEncodingStateRegistry() {\n        GrailsWebRequest parentRequest = GrailsWebRequest.lookup(getRequest());\n        if(parentRequest != null) {\n            this.encodingStateRegistry = parentRequest.getEncodingStateRegistry();\n        }\n    }\n\n    /**\n     * Overriden to return the GrailsParameterMap instance,\n     *\n     * @return An instance of GrailsParameterMap\n     */\n    @Override\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public Map getParameterMap() {\n        if (params == null) {\n            resetParams();\n        }\n        return params;\n    }\n\n    @Override\n    public void requestCompleted() {\n        super.requestCompleted();\n        DeferredBindingActions.clear();\n    }\n\n    /**\n     * @return the out\n     */\n    public Writer getOut() {\n        Writer out = attributes.getOut(getCurrentRequest());\n        if (out == null) {\n            try {\n                return getCurrentResponse().getWriter();\n            } catch (IOException e) {\n                throw new ControllerExecutionException(\"Error retrieving response writer: \" + e.getMessage(), e);\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Whether the web request is still active\n     * @return true if it is\n     */\n    public boolean isActive() {\n        return super.isRequestActive();\n    }\n\n    /**\n     * @param out the out to set\n     */\n    public void setOut(Writer out) {\n        attributes.setOut(getCurrentRequest(), out);\n    }\n\n    /**\n     * @return The ServletContext instance\n     */\n    public ServletContext getServletContext() {\n        return attributes.getServletContext();\n    }\n\n    /**\n     * Returns the context path of the request.\n     * @return the path\n     */\n    @Override\n    public String getContextPath() {\n        final HttpServletRequest request = getCurrentRequest();\n        String appUri = (String) request.getAttribute(GrailsApplicationAttributes.APP_URI_ATTRIBUTE);\n        if (appUri == null) {\n            appUri = urlHelper.getContextPath(request);\n        }\n        return appUri;\n    }\n\n    /**\n     * @return The FlashScope instance for the current request\n     */\n    public FlashScope getFlashScope() {\n        return attributes.getFlashScope(getRequest());\n    }\n\n    /**\n     * @return The currently executing request\n     */\n    public HttpServletRequest getCurrentRequest() {\n        if(multipartRequest != null) {\n            return multipartRequest;\n        }\n        else {\n            return getRequest();\n        }\n    }\n\n    public HttpServletResponse getCurrentResponse() {\n        if(wrappedResponse != null) {\n            return wrappedResponse;\n        } else {\n            return getResponse();\n        }\n    }\n\n    public HttpServletResponse getWrappedResponse() {\n        return wrappedResponse;\n    }\n\n    public void setWrappedResponse(HttpServletResponse wrappedResponse) {\n        this.wrappedResponse = wrappedResponse;\n    }\n\n    /**\n     * @return The Grails params object\n     */\n    public GrailsParameterMap getParams() {\n        if (params == null) {\n            resetParams();\n        }\n        return params;\n    }\n\n    /**\n     * @return The Grails params object\n     */\n    public GrailsParameterMap getOriginalParams() {\n        if (originalParams == null) {\n            originalParams = new GrailsParameterMap(getCurrentRequest());\n        }\n        return originalParams;\n    }\n\n    /**\n     * Reset params by re-reading and initializing parameters from request\n     */\n    public void resetParams() {\n        params = (GrailsParameterMap)getOriginalParams().clone();\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    public void addParametersFrom(Map previousParams) {\n        if (previousParams instanceof GrailsParameterMap) {\n            getParams().addParametersFrom((GrailsParameterMap)previousParams);\n        } else {\n            for (Object key : previousParams.keySet()) {\n                String name = String.valueOf(key);\n                getParams().put(name, previousParams.get(key));\n            }\n        }\n    }\n\n    /**\n     * Informs any parameter creation listeners.\n     */\n    public void informParameterCreationListeners() {\n        for (ParameterCreationListener parameterCreationListener : parameterCreationListeners) {\n            parameterCreationListener.paramsCreated(getParams());\n        }\n    }\n\n    /**\n     * @return The Grails session object\n     */\n    public GrailsHttpSession getSession() {\n        if (session == null) {\n            session = new GrailsHttpSession(getCurrentRequest());\n        }\n\n        return session;\n    }\n\n    /**\n     * @return The GrailsApplicationAttributes instance\n     */\n    public GrailsApplicationAttributes getAttributes() {\n        return attributes;\n    }\n\n    public void setActionName(String actionName) {\n        getCurrentRequest().setAttribute(GrailsApplicationAttributes.ACTION_NAME_ATTRIBUTE, actionName);\n    }\n\n    public void setControllerName(String controllerName) {\n        getCurrentRequest().setAttribute(GrailsApplicationAttributes.CONTROLLER_NAME_ATTRIBUTE, controllerName);\n    }\n\n    public void setControllerNamespace(String controllerNamespace) {\n        getCurrentRequest().setAttribute(GrailsApplicationAttributes.CONTROLLER_NAMESPACE_ATTRIBUTE, controllerNamespace);\n    }\n\n    /**\n     * @return the actionName\n     */\n    public String getActionName() {\n        return (String)getCurrentRequest().getAttribute(GrailsApplicationAttributes.ACTION_NAME_ATTRIBUTE);\n    }\n\n    /**\n     * @return the controllerName\n     */\n    public String getControllerName() {\n        return (String)getCurrentRequest().getAttribute(GrailsApplicationAttributes.CONTROLLER_NAME_ATTRIBUTE);\n    }\n\n    /**\n     * @return the controllerClass\n     */\n    public GrailsControllerClass getControllerClass() {\n        HttpServletRequest currentRequest = getCurrentRequest();\n        GrailsControllerClass controllerClass = (GrailsControllerClass) currentRequest.getAttribute(GrailsApplicationAttributes.GRAILS_CONTROLLER_CLASS);\n        if(controllerClass == null) {\n            Object controllerNameObject = currentRequest.getAttribute(GrailsApplicationAttributes.CONTROLLER_NAME_ATTRIBUTE);\n            if(controllerNameObject != null) {\n                controllerClass = (GrailsControllerClass)getAttributes()\n                                                            .getGrailsApplication()\n                                                            .getArtefactByLogicalPropertyName(ControllerArtefactHandler.TYPE, controllerNameObject.toString());\n                if(controllerClass != null) {\n                    currentRequest.setAttribute(GrailsApplicationAttributes.GRAILS_CONTROLLER_CLASS, controllerClass);\n                }\n            }\n        }\n        return controllerClass;\n    }\n\n    /**\n    * @return the controllerNamespace\n    */\n    public String getControllerNamespace() {\n        return (String)getCurrentRequest().getAttribute(GrailsApplicationAttributes.CONTROLLER_NAMESPACE_ATTRIBUTE);\n    }\n\n    public void setRenderView(boolean renderView) {\n        this.renderView = renderView;\n    }\n\n    /**\n     * @return true if the view for this GrailsWebRequest should be rendered\n     */\n    public boolean isRenderView() {\n        final HttpServletRequest currentRequest = getCurrentRequest();\n        HttpServletResponse currentResponse = getCurrentResponse();\n        return renderView &&\n                !currentResponse.isCommitted() &&\n                currentResponse.getStatus() < 300 &&\n                currentRequest.getAttribute(REDIRECT_CALLED) == null;\n    }\n\n    public String getId() {\n        Object id = getParams().get(ID_PARAMETER);\n        return id == null ? null : id.toString();\n    }\n\n    /**\n     * Returns true if the current executing request is a flow request\n     *\n     * @return true if it is a flow request\n     */\n    public boolean isFlowRequest() {\n        GrailsApplication application = getAttributes().getGrailsApplication();\n        Object controllerClassObject = getControllerClass();\n        GrailsControllerClass controllerClass = null;\n        if(controllerClassObject instanceof GrailsControllerClass) {\n            controllerClass = (GrailsControllerClass) controllerClassObject;\n        }\n\n        if (controllerClass == null) return false;\n\n        String actionName = getActionName();\n        if (actionName == null) actionName = controllerClass.getDefaultAction();\n        if (actionName == null) return false;\n\n        return false;\n    }\n\n    public void addParameterListener(ParameterCreationListener creationListener) {\n        parameterCreationListeners.add(creationListener);\n    }\n\n    /**\n     * Obtains the ApplicationContext object.\n     *\n     * @return The ApplicationContext\n     */\n    public ApplicationContext getApplicationContext() {\n        return applicationContext == null ? getAttributes().getApplicationContext() : applicationContext;\n    }\n\n    /**\n     * Obtains the PropertyEditorRegistry instance.\n     * @return The PropertyEditorRegistry\n     */\n    public PropertyEditorRegistry getPropertyEditorRegistry() {\n        final HttpServletRequest servletRequest = getCurrentRequest();\n        PropertyEditorRegistry registry = (PropertyEditorRegistry) servletRequest.getAttribute(GrailsApplicationAttributes.PROPERTY_REGISTRY);\n        if (registry == null) {\n            registry = new PropertyEditorRegistrySupport();\n            PropertyEditorRegistryUtils.registerCustomEditors(this, registry, RequestContextUtils.getLocale(servletRequest));\n            servletRequest.setAttribute(GrailsApplicationAttributes.PROPERTY_REGISTRY, registry);\n        }\n        return registry;\n    }\n\n    /**\n     * Looks up the GrailsWebRequest from the current request.\n     * @param request The current request\n     * @return The GrailsWebRequest\n     */\n    public static GrailsWebRequest lookup(HttpServletRequest request) {\n        GrailsWebRequest webRequest = (GrailsWebRequest) request.getAttribute(GrailsApplicationAttributes.WEB_REQUEST);\n        return webRequest == null ? lookup() : webRequest;\n    }\n\n    /**\n     * Looks up the current Grails WebRequest instance\n     * @return The GrailsWebRequest instance\n     */\n    public static GrailsWebRequest lookup() {\n        GrailsWebRequest webRequest = null;\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n        if (requestAttributes instanceof GrailsWebRequest) {\n            webRequest = (GrailsWebRequest) requestAttributes;\n        }\n        return webRequest;\n    }\n\n    /**\n     * Sets the id of the request.\n     * @param id The id\n     */\n    public void setId(Object id) {\n        getParams().put(GrailsWebRequest.ID_PARAMETER, id);\n    }\n\n    public String getBaseUrl() {\n        if (baseUrl == null) {\n            HttpServletRequest request=getCurrentRequest();\n            String scheme =request.getScheme();\n            StringBuilder sb=new StringBuilder();\n            sb.append(scheme).append(\"://\").append(request.getServerName());\n            int port = request.getServerPort();\n            if ((\"http\".equals(scheme) && port != 80) || (\"https\".equals(scheme) && port != 443)) {\n                sb.append(\":\").append(port);\n            }\n            String contextPath = request.getContextPath();\n            if (contextPath != null) {\n                sb.append(contextPath);\n            }\n            baseUrl = sb.toString();\n        }\n        return baseUrl;\n    }\n\n    public EncodingStateRegistry getEncodingStateRegistry() {\n        if (encodingStateRegistry == null) {\n            encodingStateRegistry = new DefaultEncodingStateRegistry();\n        }\n        return encodingStateRegistry;\n    }\n\n    private static final class DefaultEncodingStateRegistryLookup implements EncodingStateRegistryLookup {\n        public EncodingStateRegistry lookup() {\n            GrailsWebRequest webRequest = GrailsWebRequest.lookup();\n            return webRequest == null ? null : webRequest.getEncodingStateRegistry();\n        }\n    }\n\n    static {\n        EncodingStateRegistryLookupHolder.setEncodingStateRegistryLookup(new DefaultEncodingStateRegistryLookup());\n    }\n\n    /**\n     * @return true if grails.views.filteringCodecForMimeType settings should be ignored for this request\n     */\n    public boolean isSkipFilteringCodec() {\n        return skipFilteringCodec;\n    }\n\n    public void setSkipFilteringCodec(boolean skipCodec) {\n        this.skipFilteringCodec = skipCodec;\n    }\n\n    public String getFilteringCodec() {\n        return filteringEncoder != null ? filteringEncoder.getCodecIdentifier().getCodecName() : null;\n    }\n    public void setFilteringCodec(String codecName) {\n        filteringEncoder=codecName != null ? CodecLookupHelper.lookupEncoder(attributes.getGrailsApplication(), codecName) : null;\n    }\n\n    public Encoder lookupFilteringEncoder() {\n        if (filteringEncoder == null && applicationContext != null && applicationContext.containsBean(FilteringCodecsByContentTypeSettings.BEAN_NAME)) {\n            filteringEncoder = applicationContext.getBean(FilteringCodecsByContentTypeSettings.BEAN_NAME, FilteringCodecsByContentTypeSettings.class).getEncoderForContentType(getResponse().getContentType());\n        }\n        return filteringEncoder;\n    }\n\n    public Encoder getFilteringEncoder() {\n        return filteringEncoder;\n    }\n\n    public void setFilteringEncoder(Encoder filteringEncoder) {\n        this.filteringEncoder = filteringEncoder;\n    }\n}\n", "/*\n * Copyright 2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.grails.web.servlet.view;\n\nimport groovy.text.Template;\n\nimport java.lang.reflect.UndeclaredThrowableException;\nimport java.util.Map;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.grails.web.util.GrailsApplicationAttributes;\nimport org.grails.web.servlet.mvc.GrailsWebRequest;\nimport org.grails.web.util.WebUtils;\nimport org.springframework.web.context.request.RequestAttributes;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.servlet.view.AbstractUrlBasedView;\n\n\n/**\n * A view applied to a Grails application that ensures an appropriate web request is bound\n *\n * @author Lari Hotari\n * @since 2.4\n */\npublic abstract class AbstractGrailsView extends AbstractUrlBasedView {\n    /**\n     * Delegates to renderMergedOutputModel(..)\n     *\n     * @see #renderMergedOutputModel(java.util.Map, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     *\n     * @param model The view model\n     * @param request The HttpServletRequest\n     * @param response The HttpServletResponse\n     * @throws Exception When an error occurs rendering the view\n     */\n    @Override\n    protected final void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        exposeModelAsRequestAttributes(model, request);\n        renderWithinGrailsWebRequest(model, request, response);\n    }\n\n    private void renderWithinGrailsWebRequest(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response)\n            throws Exception {\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n        boolean attributesChanged = false;\n        try {\n            GrailsWebRequest webRequest;\n            if(!(requestAttributes instanceof GrailsWebRequest)) {\n                webRequest = createGrailsWebRequest(request, response, request.getServletContext());\n                attributesChanged = true;\n                WebUtils.storeGrailsWebRequest(webRequest);\n            } else {\n                webRequest = (GrailsWebRequest)requestAttributes;\n            }\n            renderTemplate(model, webRequest, request, response);\n        } finally {\n            if(attributesChanged) {\n                request.removeAttribute(GrailsApplicationAttributes.WEB_REQUEST);\n                RequestContextHolder.setRequestAttributes(requestAttributes);\n            }\n        }\n    }    \n    \n    /**\n     * Renders a page with the specified TemplateEngine, mode and response.\n     * @param model The model to use\n     * @param webRequest The {@link org.grails.web.servlet.mvc.GrailsWebRequest}\n     * @param request The {@link javax.servlet.http.HttpServletRequest}\n     * @param response The {@link javax.servlet.http.HttpServletResponse} instance\n     *\n     * @throws java.io.IOException Thrown when an error occurs writing the response\n     */\n    abstract protected void renderTemplate(Map<String, Object> model, GrailsWebRequest webRequest, HttpServletRequest request, HttpServletResponse response) throws Exception;\n    \n    protected GrailsWebRequest createGrailsWebRequest(HttpServletRequest request, HttpServletResponse response,\n            ServletContext servletContext) {\n        return new GrailsWebRequest(request, response, servletContext);\n    }    \n\n    public void rethrowRenderException(Throwable ex, String message) {\n        if (ex instanceof Error) {\n            throw (Error) ex;\n        }        \n        if (ex instanceof RuntimeException) {\n            throw (RuntimeException) ex;\n        }\n        throw new UndeclaredThrowableException(ex, message);\n    }\n    \n    abstract public Template getTemplate();\n}\n"], "filenames": ["grails-databinding/src/main/groovy/grails/databinding/BindInitializer.java", "grails-databinding/src/main/groovy/grails/databinding/BindUsing.java", "grails-databinding/src/main/groovy/grails/databinding/SimpleDataBinder.groovy", "grails-databinding/src/main/groovy/grails/databinding/StructuredBindingEditor.java", "grails-databinding/src/main/groovy/grails/databinding/converters/FormattedValueConverter.java", "grails-encoder/src/main/groovy/org/grails/buffer/GrailsPrintWriter.java", "grails-encoder/src/main/groovy/org/grails/buffer/StreamCharBuffer.java", "grails-web-common/src/main/groovy/org/grails/databinding/bindingsource/DataBindingSourceCreationException.java", "grails-web-common/src/main/groovy/org/grails/web/json/JSONObject.java", "grails-web-common/src/main/groovy/org/grails/web/servlet/mvc/GrailsWebRequest.java", "grails-web-common/src/main/groovy/org/grails/web/servlet/view/AbstractGrailsView.java"], "buggy_code_start_loc": [39, 31, 24, 24, 44, 96, 84, 24, 78, 260, 83], "buggy_code_end_loc": [40, 40, 823, 62, 46, 97, 166, 25, 800, 261, 86], "fixing_code_start_loc": [39, 31, 25, 24, 44, 96, 84, 24, 78, 260, 83], "fixing_code_end_loc": [40, 40, 820, 62, 46, 97, 164, 25, 800, 261, 86], "type": "NVD-CWE-noinfo", "message": "Grails is a framework used to build web applications with the Groovy programming language. A specially crafted web request can lead to a JVM crash or denial of service. Any Grails framework application using Grails data binding is vulnerable. This issue has been patched in version 3.3.17, 4.1.3, 5.3.4, 6.1.0.\n", "other": {"cve": {"id": "CVE-2023-46131", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-21T00:15:25.813", "lastModified": "2024-01-02T16:39:07.700", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Grails is a framework used to build web applications with the Groovy programming language. A specially crafted web request can lead to a JVM crash or denial of service. Any Grails framework application using Grails data binding is vulnerable. This issue has been patched in version 3.3.17, 4.1.3, 5.3.4, 6.1.0.\n"}, {"lang": "es", "value": "Grails es un framework utilizado para crear aplicaciones web con el lenguaje de programaci\u00f3n Groovy. Una solicitud web especialmente manipulada puede provocar un fallo de JVM o una denegaci\u00f3n de servicio. Cualquier aplicaci\u00f3n del framework de Grails que utilice el enlace de datos de Grails es vulnerable. Este problema se solucion\u00f3 en las versiones 3.3.17, 4.1.3, 5.3.4, 6.1.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:grails:grails:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.3.17", "matchCriteriaId": "CAD6356E-B39D-4EA5-A9FB-D8140235D2B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grails:grails:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.1.3", "matchCriteriaId": "DFF18D31-5B0E-47FD-B30C-4FD4A32FC042"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grails:grails:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.3.4", "matchCriteriaId": "DED2D306-FEC4-4E15-BEB3-DDC7983539FC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grails:grails:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.1.0", "matchCriteriaId": "2E186C3B-2074-4B0E-92A1-44FEEDD1F73C"}]}]}], "references": [{"url": "https://github.com/grails/grails-core/commit/74326bdd2cf7dcb594092165e9464520f8366c60", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/grails/grails-core/commit/c401faaa6c24c021c758b95f72304a0e855a8db3", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/grails/grails-core/issues/13302", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/grails/grails-core/security/advisories/GHSA-3pjv-r7w4-2cf5", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://grails.org/blog/2023-12-20-cve-data-binding-dos.html", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/grails/grails-core/commit/74326bdd2cf7dcb594092165e9464520f8366c60"}}