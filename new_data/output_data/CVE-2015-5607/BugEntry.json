{"buggy_code": ["\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport logging\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web\n\nfrom tornado import gen\nfrom tornado.log import app_log\n\n\nimport IPython\nfrom IPython.utils.sysinfo import get_sys_info\n\nfrom IPython.config import Application\nfrom IPython.utils.path import filefind\nfrom IPython.utils.py3compat import string_types\nfrom IPython.html.utils import is_hidden, url_path_join, url_escape\n\nfrom IPython.html.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n    \n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n    \n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        if Application.initialized():\n            return Application.instance().log\n        else:\n            return app_log\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        return self.settings.get('mathjax_url', '')\n    \n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/contents'))\n        return self.settings.get('contents_js_source', 'services/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def cluster_manager(self):\n        return self.settings['cluster_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n    \n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n    \n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % name)\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warn(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":IPython.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', path)\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warn(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', path)\n        url = url_escape(url)\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n"], "fixing_code": ["\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web\n\nfrom tornado import gen\nfrom tornado.log import app_log\n\n\nimport IPython\nfrom IPython.utils.sysinfo import get_sys_info\n\nfrom IPython.config import Application\nfrom IPython.utils.path import filefind\nfrom IPython.utils.py3compat import string_types\nfrom IPython.html.utils import is_hidden, url_path_join, url_escape\n\nfrom IPython.html.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n    \n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n    \n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        if Application.initialized():\n            return Application.instance().log\n        else:\n            return app_log\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        return self.settings.get('mathjax_url', '')\n    \n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/contents'))\n        return self.settings.get('contents_js_source', 'services/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def cluster_manager(self):\n        return self.settings['cluster_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n    \n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n    \n    def check_origin(self):\n        \"\"\"Check Origin for cross-site API requests.\n        \n        Copied from WebSocket with changes:\n        \n        - allow unspecified host/origin (e.g. scripts)\n        \"\"\"\n        if self.allow_origin == '*':\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, assume it comes from a script/curl.\n        # We are only concerned with cross-site browser stuff here.\n        if origin is None or host is None:\n            return True\n        \n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n        \n        # OK if origin matches host\n        if origin_host == host:\n            return True\n        \n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warn(\"Blocking Cross Origin API request.  Origin: %s, Host: %s\",\n                origin, host,\n            )\n        return allow\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % name)\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warn(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":IPython.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', path)\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warn(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', path)\n        url = url_escape(url)\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n"], "filenames": ["IPython/html/base/handlers.py"], "buggy_code_start_loc": [8], "buggy_code_end_loc": [322], "fixing_code_start_loc": [7], "fixing_code_end_loc": [370], "type": "CWE-352", "message": "Cross-site request forgery in the REST API in IPython 2 and 3.", "other": {"cve": {"id": "CVE-2015-5607", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-20T16:29:00.753", "lastModified": "2017-10-05T14:31:18.307", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site request forgery in the REST API in IPython 2 and 3."}, {"lang": "es", "value": "Existe una vulnerabillidad de tipo Cross-Site Request Forgery (CSRF) en IPython 2 y 3."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "EF0DEE4D-458E-4D55-91C0-9E07C6BE1FE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:2.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "50660405-BD6C-47FA-84D1-602D046204E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:2.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "9FF16C33-8CEE-4E38-BF14-3E92BEF5A514"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:2.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "713D4937-4E9F-4792-AB53-C37D5EC4AFBD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:2.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "9BDA19F0-6B07-479A-BD1B-E8D1ABB33AD9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:2.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "63B100B7-E055-4A30-93E9-E8E9F17A4259"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:2.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "93892A0D-61CF-4048-873F-EFBAD362E3A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "790A7C14-145B-4683-AA47-E4B113CB97B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:3.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "B9B56190-B31B-46E3-82D0-07E19EE0B5A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:3.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "4A7E697C-F3B6-49A5-A161-2D0BCB4252B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "8BE5F8AA-DB37-455C-8464-8210FDBAF5A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "3EA1597B-DEEF-41C5-B38F-BF04E43556B1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "4C26A84F-A1E5-4586-A8F3-F6B3157FE5A9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:21:*:*:*:*:*:*:*", "matchCriteriaId": "56BDB5A0-0839-4A20-A003-B8CD56F48171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:22:*:*:*:*:*:*:*", "matchCriteriaId": "253C303A-E577-4488-93E6-68A8DD942C38"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-July/162671.html", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-July/162936.html", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/07/21/3", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1243842", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/ipython/ipython/commit/1415a9710407e7c14900531813c15ba6165f0816", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ipython/ipython/commit/a05fe052a18810e92d9be8c1185952c13fe4e5b0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ipython/ipython/commit/1415a9710407e7c14900531813c15ba6165f0816"}}