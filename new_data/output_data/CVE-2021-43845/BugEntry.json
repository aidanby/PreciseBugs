{"buggy_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n\n#include <pjmedia/rtcp_xr.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/rtcp.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/sock.h>\n#include <pj/string.h>\n\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n\n#define THIS_FILE \"rtcp_xr.c\"\n\n\n#if PJ_HAS_HIGH_RES_TIMER==0\n#   error \"High resolution timer needs to be enabled\"\n#endif\n\n\n/* RTCP XR payload type */\n#define RTCP_XR\t\t    207\n\n/* RTCP XR block types */\n#define BT_LOSS_RLE\t    1\n#define BT_DUP_RLE\t    2\n#define BT_RCPT_TIMES\t    3\n#define BT_RR_TIME\t    4\n#define BT_DLRR\t\t    5\n#define BT_STATS\t    6\n#define BT_VOIP_METRICS\t    7\n\n\n#define DEFAULT_GMIN\t    16\n\n\n#if 0\n#   define TRACE_(x)\tPJ_LOG(3,x)\n#else\n#   define TRACE_(x)\t;\n#endif\n\nvoid pjmedia_rtcp_xr_init( pjmedia_rtcp_xr_session *session, \n\t\t\t   struct pjmedia_rtcp_session *parent_session,\n\t\t\t   pj_uint8_t gmin,\n\t\t\t   unsigned frames_per_packet)\n{\n    pj_bzero(session, sizeof(pjmedia_rtcp_xr_session));\n\n    session->name = parent_session->name;\n    session->rtcp_session = parent_session;\n    pj_memcpy(&session->pkt.common, &session->rtcp_session->rtcp_sr_pkt.common,\n\t      sizeof(pjmedia_rtcp_common));\n    session->pkt.common.pt = RTCP_XR;\n\n    /* Init config */\n    session->stat.rx.voip_mtc.gmin = (pj_uint8_t)(gmin? gmin : DEFAULT_GMIN);\n    session->ptime = session->rtcp_session->pkt_size * 1000 / \n\t\t     session->rtcp_session->clock_rate;\n    session->frames_per_packet = frames_per_packet;\n\n    /* Init Statistics Summary fields which have non-zero default */\n    session->stat.rx.stat_sum.jitter.min = (unsigned) -1;\n    session->stat.rx.stat_sum.toh.min = (unsigned) -1;\n\n    /* Init VoIP Metrics fields which have non-zero default */\n    session->stat.rx.voip_mtc.signal_lvl = 127;\n    session->stat.rx.voip_mtc.noise_lvl = 127;\n    session->stat.rx.voip_mtc.rerl = 127;\n    session->stat.rx.voip_mtc.r_factor = 127;\n    session->stat.rx.voip_mtc.ext_r_factor = 127;\n    session->stat.rx.voip_mtc.mos_lq = 127;\n    session->stat.rx.voip_mtc.mos_cq = 127;\n\n    session->stat.tx.voip_mtc.signal_lvl = 127;\n    session->stat.tx.voip_mtc.noise_lvl = 127;\n    session->stat.tx.voip_mtc.rerl = 127;\n    session->stat.tx.voip_mtc.r_factor = 127;\n    session->stat.tx.voip_mtc.ext_r_factor = 127;\n    session->stat.tx.voip_mtc.mos_lq = 127;\n    session->stat.tx.voip_mtc.mos_cq = 127;\n}\n\nvoid pjmedia_rtcp_xr_fini(pjmedia_rtcp_xr_session *session)\n{\n    PJ_UNUSED_ARG(session);\n}\n\nPJ_DEF(void) pjmedia_rtcp_build_rtcp_xr( pjmedia_rtcp_xr_session *sess, \n\t\t\t\t\t unsigned rpt_types,\n\t\t\t\t\t void **rtcp_pkt, int *len)\n{\n    pj_uint16_t size = 0;\n\n    /* Receiver Reference Time Report Block */\n    /* Build this block if we have received packets since last build */\n    if ((rpt_types == 0 || (rpt_types & PJMEDIA_RTCP_XR_RR_TIME)) &&\n\tsess->rx_last_rr != sess->rtcp_session->stat.rx.pkt)\n    {\n\tpjmedia_rtcp_xr_rb_rr_time *r;\n\tpjmedia_rtcp_ntp_rec ntp;\n\n\tr = (pjmedia_rtcp_xr_rb_rr_time*) &sess->pkt.buf[size];\n\tpj_bzero(r, sizeof(pjmedia_rtcp_xr_rb_rr_time));\n\n\t/* Init block header */\n\tr->header.bt = BT_RR_TIME;\n\tr->header.specific = 0;\n\tr->header.length = pj_htons(2);\n\n\t/* Generate block contents */\n\tpjmedia_rtcp_get_ntp_time(sess->rtcp_session, &ntp);\n\tr->ntp_sec = pj_htonl(ntp.hi);\n\tr->ntp_frac = pj_htonl(ntp.lo);\n\n\t/* Finally */\n\tsize += sizeof(pjmedia_rtcp_xr_rb_rr_time);\n\tsess->rx_last_rr = sess->rtcp_session->stat.rx.pkt;\n    }\n\n    /* DLRR Report Block */\n    /* Build this block if we have received RR NTP (rx_lrr) before */\n    if ((rpt_types == 0 || (rpt_types & PJMEDIA_RTCP_XR_DLRR)) && \n\tsess->rx_lrr)\n    {\n\tpjmedia_rtcp_xr_rb_dlrr *r;\n\tpjmedia_rtcp_xr_rb_dlrr_item *dlrr_item;\n\tpj_timestamp ts;\n\n\tr = (pjmedia_rtcp_xr_rb_dlrr*) &sess->pkt.buf[size];\n\tpj_bzero(r, sizeof(pjmedia_rtcp_xr_rb_dlrr));\n\n\t/* Init block header */\n\tr->header.bt = BT_DLRR;\n\tr->header.specific = 0;\n\tr->header.length = pj_htons(sizeof(pjmedia_rtcp_xr_rb_dlrr)/4 - 1);\n\n\t/* Generate block contents */\n\tdlrr_item = &r->item;\n\tdlrr_item->ssrc = pj_htonl(sess->rtcp_session->peer_ssrc);\n\tdlrr_item->lrr = pj_htonl(sess->rx_lrr);\n\n\t/* Calculate DLRR */\n\tif (sess->rx_lrr != 0) {\n\t    pj_get_timestamp(&ts);\n\t    ts.u64 -= sess->rx_lrr_time.u64;\n\t\n\t    /* Convert DLRR time to 1/65536 seconds resolution */\n\t    ts.u64 = (ts.u64 << 16) / sess->rtcp_session->ts_freq.u64;\n\t    dlrr_item->dlrr = pj_htonl(ts.u32.lo);\n\t} else {\n\t    dlrr_item->dlrr = 0;\n\t}\n\n\t/* Finally */\n\tsize += sizeof(pjmedia_rtcp_xr_rb_dlrr);\n    }\n\n    /* Statistics Summary Block */\n    /* Build this block if we have received packets since last build */\n    if ((rpt_types == 0 || (rpt_types & PJMEDIA_RTCP_XR_STATS)) &&\n\tsess->stat.rx.stat_sum.count > 0)\n    {\n\tpjmedia_rtcp_xr_rb_stats *r;\n\tpj_uint8_t specific = 0;\n\n\tr = (pjmedia_rtcp_xr_rb_stats*) &sess->pkt.buf[size];\n\tpj_bzero(r, sizeof(pjmedia_rtcp_xr_rb_stats));\n\n\t/* Init block header */\n\tspecific |= sess->stat.rx.stat_sum.l ? (1 << 7) : 0;\n\tspecific |= sess->stat.rx.stat_sum.d ? (1 << 6) : 0;\n\tspecific |= sess->stat.rx.stat_sum.j ? (1 << 5) : 0;\n\tspecific |= (sess->stat.rx.stat_sum.t & 3) << 3;\n\tr->header.bt = BT_STATS;\n\tr->header.specific = specific;\n\tr->header.length = pj_htons(9);\n\n\t/* Generate block contents */\n\tr->ssrc = pj_htonl(sess->rtcp_session->peer_ssrc);\n\tr->begin_seq = pj_htons((pj_uint16_t)\n\t\t\t\t(sess->stat.rx.stat_sum.begin_seq & 0xFFFF));\n\tr->end_seq = pj_htons((pj_uint16_t)\n\t\t\t      (sess->stat.rx.stat_sum.end_seq & 0xFFFF));\n\tif (sess->stat.rx.stat_sum.l) {\n\t    r->lost = pj_htonl(sess->stat.rx.stat_sum.lost);\n\t}\n\tif (sess->stat.rx.stat_sum.d) {\n\t    r->dup = pj_htonl(sess->stat.rx.stat_sum.dup);\n\t}\n\tif (sess->stat.rx.stat_sum.j) {\n\t    r->jitter_min = pj_htonl(sess->stat.rx.stat_sum.jitter.min);\n\t    r->jitter_max = pj_htonl(sess->stat.rx.stat_sum.jitter.max);\n\t    r->jitter_mean = \n\t\tpj_htonl((unsigned)sess->stat.rx.stat_sum.jitter.mean);\n\t    r->jitter_dev = \n\t\tpj_htonl(pj_math_stat_get_stddev(&sess->stat.rx.stat_sum.jitter));\n\t}\n\tif (sess->stat.rx.stat_sum.t) {\n\t    r->toh_min = sess->stat.rx.stat_sum.toh.min;\n\t    r->toh_max = sess->stat.rx.stat_sum.toh.max;\n\t    r->toh_mean = (unsigned) sess->stat.rx.stat_sum.toh.mean;\n\t    r->toh_dev = pj_math_stat_get_stddev(&sess->stat.rx.stat_sum.toh);\n\t}\n\n\t/* Reset TX statistics summary each time built */\n\tpj_bzero(&sess->stat.rx.stat_sum, sizeof(sess->stat.rx.stat_sum));\n\tsess->stat.rx.stat_sum.jitter.min = (unsigned) -1;\n\tsess->stat.rx.stat_sum.toh.min = (unsigned) -1;\n\n\t/* Finally */\n\tsize += sizeof(pjmedia_rtcp_xr_rb_stats);\n\tpj_gettimeofday(&sess->stat.rx.stat_sum.update);\n    }\n\n    /* Voip Metrics Block */\n    /* Build this block if we have received packets */\n    if ((rpt_types == 0 || (rpt_types & PJMEDIA_RTCP_XR_VOIP_METRICS)) &&\n\tsess->rtcp_session->stat.rx.pkt)\n    {\n\tpjmedia_rtcp_xr_rb_voip_mtc *r;\n\tpj_uint32_t c11;\n\tpj_uint32_t c13;\n\tpj_uint32_t c14;\n\tpj_uint32_t c22;\n\tpj_uint32_t c23;\n\tpj_uint32_t c31;\n\tpj_uint32_t c32;\n\tpj_uint32_t c33;\n\tpj_uint32_t ctotal, m;\n\tunsigned est_extra_delay;\n\n\tr = (pjmedia_rtcp_xr_rb_voip_mtc*) &sess->pkt.buf[size];\n\tpj_bzero(r, sizeof(pjmedia_rtcp_xr_rb_voip_mtc));\n\n\t/* Init block header */\n\tr->header.bt = BT_VOIP_METRICS;\n\tr->header.specific = 0;\n\tr->header.length = pj_htons(8);\n\n\t/* Use temp vars for easiness. */\n\tc11 = sess->voip_mtc_stat.c11;\n\tc13 = sess->voip_mtc_stat.c13;\n\tc14 = sess->voip_mtc_stat.c14;\n\tc22 = sess->voip_mtc_stat.c22;\n\tc23 = sess->voip_mtc_stat.c23;\n\tc33 = sess->voip_mtc_stat.c33;\n\tm = sess->ptime * sess->frames_per_packet;\n\n\t/* Calculate additional transition counts. */\n\tc31 = c13;\n\tc32 = c23;\n\tctotal = c11 + c14 + c13 + c22 + c23 + c31 + c32 + c33;\n\n\tif (ctotal) {\n\t    pj_uint32_t p32, p23;\n\n\t    //original version:\n\t    //p32 = c32 / (c31 + c32 + c33);\n\t    if (c31 + c32 + c33 == 0)\n\t\tp32 = 0;\n\t    else\n\t\tp32 = (c32 << 16) / (c31 + c32 + c33);\n\n\t    //original version:\n\t    //if ((c22 + c23) < 1) {\n\t    //    p23 = 1;\n\t    //} else {\n\t    //    p23 = 1 - c22 / (c22 + c23);\n\t    //}\n\t    if (c23 == 0) {\n\t        p23 = 0;\n\t    } else {\n\t        p23 = (c23 << 16) / (c22 + c23);\n\t    }\n\n\t    /* Calculate loss/discard densities, scaled of 0-256 */\n\t    if (c11 == 0)\n\t\tsess->stat.rx.voip_mtc.gap_den = 0;\n\t    else\n\t\tsess->stat.rx.voip_mtc.gap_den = (pj_uint8_t)\n\t\t\t\t\t\t ((c14 << 8) / (c11 + c14));\n\t    if (p23 == 0)\n\t\tsess->stat.rx.voip_mtc.burst_den = 0;\n\t    else\n\t\tsess->stat.rx.voip_mtc.burst_den = (pj_uint8_t)\n\t\t\t\t\t\t   ((p23 << 8) / (p23 + p32));\n\n\t    /* Calculate (average) durations, in ms */\n\t    if (c13 == 0) {\n\t\tc13 = 1;\n\t\tctotal += 1;\n\t    }\n\t    sess->stat.rx.voip_mtc.gap_dur = (pj_uint16_t)\n\t\t\t\t\t    ((c11+c14+c13) * m / c13);\n\t    sess->stat.rx.voip_mtc.burst_dur = (pj_uint16_t)\n\t\t\t\t\t    ((ctotal - (c11+c14+c13)) * m / c13);\n\n\t    /* Callculate loss/discard rates, scaled 0-256 */\n\t    sess->stat.rx.voip_mtc.loss_rate = (pj_uint8_t)\n\t\t\t((sess->voip_mtc_stat.loss_count << 8) / ctotal);\n\t    sess->stat.rx.voip_mtc.discard_rate = (pj_uint8_t)\n\t\t\t((sess->voip_mtc_stat.discard_count << 8) / ctotal);\n\t} else {\n\t    /* No lost/discarded packet yet. */\n\t    sess->stat.rx.voip_mtc.gap_den = 0;\n\t    sess->stat.rx.voip_mtc.burst_den = 0;\n\t    sess->stat.rx.voip_mtc.gap_dur = 0;\n\t    sess->stat.rx.voip_mtc.burst_dur = 0;\n\t    sess->stat.rx.voip_mtc.loss_rate = 0;\n\t    sess->stat.rx.voip_mtc.discard_rate = 0;\n\t}\n\n\t/* Set round trip delay (in ms) to RTT calculated after receiving\n\t * DLRR or DLSR.\n\t */\n\tif (sess->stat.rtt.last)\n\t    sess->stat.rx.voip_mtc.rnd_trip_delay = (pj_uint16_t)\n\t\t\t\t    (sess->stat.rtt.last / 1000);\n\telse if (sess->rtcp_session->stat.rtt.last)\n\t    sess->stat.rx.voip_mtc.rnd_trip_delay = (pj_uint16_t)\n\t\t\t\t    (sess->rtcp_session->stat.rtt.last / 1000);\n\t\n\t/* End system delay = RTT/2 + current jitter buffer size + \n\t *                    EXTRA (estimated extra delay)\n\t * EXTRA will cover additional delay introduced by other components of\n\t * audio engine, e.g: sound device, codec, AEC, PLC, WSOLA.\n\t * Since it is difficult to get the exact value of EXTRA, estimation\n\t * is taken to be totally around 30ms + sound device latency.\n\t */\n\test_extra_delay = 30;\n\n#if !PJMEDIA_AUDIO_DEV_HAS_NULL_AUDIO\n\test_extra_delay += PJMEDIA_SND_DEFAULT_REC_LATENCY + \n\t\t\t   PJMEDIA_SND_DEFAULT_PLAY_LATENCY;\n#endif\n\n\tsess->stat.rx.voip_mtc.end_sys_delay = (pj_uint16_t)\n\t\t\t\t (sess->stat.rx.voip_mtc.rnd_trip_delay / 2 +\n\t\t\t\t sess->stat.rx.voip_mtc.jb_nom + \n\t\t\t\t est_extra_delay);\n\n\t/* Generate block contents */\n\tr->ssrc\t\t    = pj_htonl(sess->rtcp_session->peer_ssrc);\n\tr->loss_rate\t    = sess->stat.rx.voip_mtc.loss_rate;\n\tr->discard_rate\t    = sess->stat.rx.voip_mtc.discard_rate;\n\tr->burst_den\t    = sess->stat.rx.voip_mtc.burst_den;\n\tr->gap_den\t    = sess->stat.rx.voip_mtc.gap_den;\n\tr->burst_dur\t    = pj_htons(sess->stat.rx.voip_mtc.burst_dur);\n\tr->gap_dur\t    = pj_htons(sess->stat.rx.voip_mtc.gap_dur);\n\tr->rnd_trip_delay   = pj_htons(sess->stat.rx.voip_mtc.rnd_trip_delay);\n\tr->end_sys_delay    = pj_htons(sess->stat.rx.voip_mtc.end_sys_delay);\n\t/* signal & noise level encoded in two's complement form */\n\tr->signal_lvl\t    = (pj_uint8_t) \n\t\t\t      ((sess->stat.rx.voip_mtc.signal_lvl >= 0)?\n\t\t\t       sess->stat.rx.voip_mtc.signal_lvl :\n\t\t\t       (sess->stat.rx.voip_mtc.signal_lvl + 256));\n\tr->noise_lvl\t    = (pj_uint8_t)\n\t\t\t      ((sess->stat.rx.voip_mtc.noise_lvl >= 0)?\n\t\t\t       sess->stat.rx.voip_mtc.noise_lvl :\n\t\t\t       (sess->stat.rx.voip_mtc.noise_lvl + 256));\n\tr->rerl\t\t    = sess->stat.rx.voip_mtc.rerl;\n\tr->gmin\t\t    = sess->stat.rx.voip_mtc.gmin;\n\tr->r_factor\t    = sess->stat.rx.voip_mtc.r_factor;\n\tr->ext_r_factor\t    = sess->stat.rx.voip_mtc.ext_r_factor;\n\tr->mos_lq\t    = sess->stat.rx.voip_mtc.mos_lq;\n\tr->mos_cq\t    = sess->stat.rx.voip_mtc.mos_cq;\n\tr->rx_config\t    = sess->stat.rx.voip_mtc.rx_config;\n\tr->jb_nom\t    = pj_htons(sess->stat.rx.voip_mtc.jb_nom);\n\tr->jb_max\t    = pj_htons(sess->stat.rx.voip_mtc.jb_max);\n\tr->jb_abs_max\t    = pj_htons(sess->stat.rx.voip_mtc.jb_abs_max);\n\n\t/* Finally */\n\tsize += sizeof(pjmedia_rtcp_xr_rb_voip_mtc);\n\tpj_gettimeofday(&sess->stat.rx.voip_mtc.update);\n    }\n\n    /* Add RTCP XR header size */\n    size += sizeof(sess->pkt.common);\n\n    /* Set RTCP XR header 'length' to packet size in 32-bit unit minus one */\n    sess->pkt.common.length = pj_htons((pj_uint16_t)(size/4 - 1));\n\n    /* Set the return values */\n    *rtcp_pkt = (void*) &sess->pkt;\n    *len = size;\n}\n\n\nvoid pjmedia_rtcp_xr_rx_rtcp_xr( pjmedia_rtcp_xr_session *sess,\n\t\t\t\t const void *pkt,\n\t\t\t\t pj_size_t size)\n{\n    const pjmedia_rtcp_xr_pkt\t      *rtcp_xr = (pjmedia_rtcp_xr_pkt*) pkt;\n    const pjmedia_rtcp_xr_rb_rr_time  *rb_rr_time = NULL;\n    const pjmedia_rtcp_xr_rb_dlrr     *rb_dlrr = NULL;\n    const pjmedia_rtcp_xr_rb_stats    *rb_stats = NULL;\n    const pjmedia_rtcp_xr_rb_voip_mtc *rb_voip_mtc = NULL;\n    const pjmedia_rtcp_xr_rb_header   *rb_hdr = (pjmedia_rtcp_xr_rb_header*) \n\t\t\t\t\t\trtcp_xr->buf;\n    unsigned pkt_len, rb_len;\n\n    if (rtcp_xr->common.pt != RTCP_XR)\n\treturn;\n\n    pkt_len = pj_ntohs((pj_uint16_t)rtcp_xr->common.length);\n\n    if ((pkt_len + 1) > (size / 4))\n\treturn;\n\n    /* Parse report rpt_types */\n    while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)\n    {\t\n\trb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);\n\n\t/* Just skip any block with length == 0 (no report content) */\n\tif (rb_len) {\n\t    switch (rb_hdr->bt) {\n\t\tcase BT_RR_TIME:\n\t\t    rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*) rb_hdr;\n\t\t    break;\n\t\tcase BT_DLRR:\n\t\t    rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*) rb_hdr;\n\t\t    break;\n\t\tcase BT_STATS:\n\t\t    rb_stats = (pjmedia_rtcp_xr_rb_stats*) rb_hdr;\n\t\t    break;\n\t\tcase BT_VOIP_METRICS:\n\t\t    rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*) rb_hdr;\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n\trb_hdr = (pjmedia_rtcp_xr_rb_header*)\n\t\t ((pj_int32_t*)rb_hdr + rb_len + 1);\n    }\n\n    /* Receiving RR Time */\n    if (rb_rr_time) {\n\t/* Save LRR from NTP timestamp of the RR time block report */\n\tsess->rx_lrr = ((pj_ntohl(rb_rr_time->ntp_sec) & 0x0000FFFF) << 16) | \n\t\t       ((pj_ntohl(rb_rr_time->ntp_frac) >> 16) & 0xFFFF);\n\n\t/* Calculate RR arrival time for DLRR */\n\tpj_get_timestamp(&sess->rx_lrr_time);\n\n\tTRACE_((sess->name, \"Rx RTCP SR: ntp_ts=%p\", sess->rx_lrr,\n\t       (pj_uint32_t)(sess->rx_lrr_time.u64*65536/\n\t\t\t     sess->rtcp_session->ts_freq.u64)));\n    }\n\n    /* Receiving DLRR */\n    if (rb_dlrr) {\n\tpj_uint32_t lrr, now, dlrr;\n\tpj_uint64_t eedelay;\n\tpjmedia_rtcp_ntp_rec ntp;\n\n\t/* LRR is the middle 32bit of NTP. It has 1/65536 second \n\t * resolution \n\t */\n\tlrr = pj_ntohl(rb_dlrr->item.lrr);\n\n\t/* DLRR is delay since LRR, also in 1/65536 resolution */\n\tdlrr = pj_ntohl(rb_dlrr->item.dlrr);\n\n\t/* Get current time, and convert to 1/65536 resolution */\n\tpjmedia_rtcp_get_ntp_time(sess->rtcp_session, &ntp);\n\tnow = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);\n\n\t/* End-to-end delay is (now-lrr-dlrr) */\n\teedelay = now - lrr - dlrr;\n\n\t/* Convert end to end delay to usec (keeping the calculation in\n         * 64bit space)::\n\t *   sess->ee_delay = (eedelay * 1000) / 65536;\n\t */\n\tif (eedelay < 4294) {\n\t    eedelay = (eedelay * 1000000) >> 16;\n\t} else {\n\t    eedelay = (eedelay * 1000) >> 16;\n\t    eedelay *= 1000;\n\t}\n\n\tTRACE_((sess->name, \"Rx RTCP XR DLRR: lrr=%p, dlrr=%p (%d:%03dms), \"\n\t\t\t   \"now=%p, rtt=%p\",\n\t\tlrr, dlrr, dlrr/65536, (dlrr%65536)*1000/65536,\n\t\tnow, (pj_uint32_t)eedelay));\n\t\n\t/* Only save calculation if \"now\" is greater than lrr, or\n\t * otherwise rtt will be invalid \n\t */\n\tif (now-dlrr >= lrr) {\n\t    unsigned rtt = (pj_uint32_t)eedelay;\n\t    \n\t    /* Check that eedelay value really makes sense. \n\t     * We allow up to 30 seconds RTT!\n\t     */\n\t    if (eedelay <= 30 * 1000 * 1000UL) {\n\t\t/* \"Normalize\" rtt value that is exceptionally high.\n\t\t * For such values, \"normalize\" the rtt to be three times\n\t\t * the average value.\n\t\t */\n\t\tif (rtt>((unsigned)sess->stat.rtt.mean*3) && sess->stat.rtt.n!=0)\n\t\t{\n\t\t    unsigned orig_rtt = rtt;\n\t\t    rtt = (unsigned)sess->stat.rtt.mean*3;\n\t\t    PJ_LOG(5,(sess->name, \n\t\t\t      \"RTT value %d usec is normalized to %d usec\",\n\t\t\t      orig_rtt, rtt));\n\t\t}\n    \t\n\t\tTRACE_((sess->name, \"RTCP RTT is set to %d usec\", rtt));\n\t\tpj_math_stat_update(&sess->stat.rtt, rtt);\n\t    }\n\t} else {\n\t    PJ_LOG(5, (sess->name, \"Internal RTCP NTP clock skew detected: \"\n\t\t\t\t   \"lrr=%p, now=%p, dlrr=%p (%d:%03dms), \"\n\t\t\t\t   \"diff=%d\",\n\t\t\t\t   lrr, now, dlrr, dlrr/65536,\n\t\t\t\t   (dlrr%65536)*1000/65536,\n\t\t\t\t   dlrr-(now-lrr)));\n\t}\n    }\n\n    /* Receiving Statistics Summary */\n    if (rb_stats) {\n\tpj_uint8_t flags = rb_stats->header.specific;\n\n\tpj_bzero(&sess->stat.tx.stat_sum, sizeof(sess->stat.tx.stat_sum));\n\n\t/* Range of packets sequence reported in this blocks */\n\tsess->stat.tx.stat_sum.begin_seq = pj_ntohs(rb_stats->begin_seq);\n\tsess->stat.tx.stat_sum.end_seq   = pj_ntohs(rb_stats->end_seq);\n\n\t/* Get flags of valid fields */\n\tsess->stat.tx.stat_sum.l = (flags & (1 << 7)) != 0;\n\tsess->stat.tx.stat_sum.d = (flags & (1 << 6)) != 0;\n\tsess->stat.tx.stat_sum.j = (flags & (1 << 5)) != 0;\n\tsess->stat.tx.stat_sum.t = (flags & (3 << 3)) != 0;\n\n\t/* Fetch the reports info */\n\tif (sess->stat.tx.stat_sum.l) {\n\t    sess->stat.tx.stat_sum.lost = pj_ntohl(rb_stats->lost);\n\t}\n\n\tif (sess->stat.tx.stat_sum.d) {\n\t    sess->stat.tx.stat_sum.dup = pj_ntohl(rb_stats->dup);\n\t}\n\n\tif (sess->stat.tx.stat_sum.j) {\n\t    sess->stat.tx.stat_sum.jitter.min = pj_ntohl(rb_stats->jitter_min);\n\t    sess->stat.tx.stat_sum.jitter.max = pj_ntohl(rb_stats->jitter_max);\n\t    sess->stat.tx.stat_sum.jitter.mean= pj_ntohl(rb_stats->jitter_mean);\n\t    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.jitter, \n\t\t\t\t    pj_ntohl(rb_stats->jitter_dev));\n\t}\n\n\tif (sess->stat.tx.stat_sum.t) {\n\t    sess->stat.tx.stat_sum.toh.min = rb_stats->toh_min;\n\t    sess->stat.tx.stat_sum.toh.max = rb_stats->toh_max;\n\t    sess->stat.tx.stat_sum.toh.mean= rb_stats->toh_mean;\n\t    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.toh, \n\t\t\t\t    pj_ntohl(rb_stats->toh_dev));\n\t}\n\n\tpj_gettimeofday(&sess->stat.tx.stat_sum.update);\n    }\n\n    /* Receiving VoIP Metrics */\n    if (rb_voip_mtc) {\n\tsess->stat.tx.voip_mtc.loss_rate = rb_voip_mtc->loss_rate;\n\tsess->stat.tx.voip_mtc.discard_rate = rb_voip_mtc->discard_rate;\n\tsess->stat.tx.voip_mtc.burst_den = rb_voip_mtc->burst_den;\n\tsess->stat.tx.voip_mtc.gap_den = rb_voip_mtc->gap_den;\n\tsess->stat.tx.voip_mtc.burst_dur = pj_ntohs(rb_voip_mtc->burst_dur);\n\tsess->stat.tx.voip_mtc.gap_dur = pj_ntohs(rb_voip_mtc->gap_dur);\n\tsess->stat.tx.voip_mtc.rnd_trip_delay = \n\t\t\t\t\tpj_ntohs(rb_voip_mtc->rnd_trip_delay);\n\tsess->stat.tx.voip_mtc.end_sys_delay = \n\t\t\t\t\tpj_ntohs(rb_voip_mtc->end_sys_delay);\n\t/* signal & noise level encoded in two's complement form */\n\tsess->stat.tx.voip_mtc.signal_lvl = (pj_int8_t)\n\t\t\t\t    ((rb_voip_mtc->signal_lvl > 127)?\n\t\t\t\t     ((int)rb_voip_mtc->signal_lvl - 256) : \n\t\t\t\t     rb_voip_mtc->signal_lvl);\n\tsess->stat.tx.voip_mtc.noise_lvl  = (pj_int8_t)\n\t\t\t\t    ((rb_voip_mtc->noise_lvl > 127)?\n\t\t\t\t     ((int)rb_voip_mtc->noise_lvl - 256) : \n\t\t\t\t     rb_voip_mtc->noise_lvl);\n\tsess->stat.tx.voip_mtc.rerl = rb_voip_mtc->rerl;\n\tsess->stat.tx.voip_mtc.gmin = rb_voip_mtc->gmin;\n\tsess->stat.tx.voip_mtc.r_factor = rb_voip_mtc->r_factor;\n\tsess->stat.tx.voip_mtc.ext_r_factor = rb_voip_mtc->ext_r_factor;\n\tsess->stat.tx.voip_mtc.mos_lq = rb_voip_mtc->mos_lq;\n\tsess->stat.tx.voip_mtc.mos_cq = rb_voip_mtc->mos_cq;\n\tsess->stat.tx.voip_mtc.rx_config = rb_voip_mtc->rx_config;\n\tsess->stat.tx.voip_mtc.jb_nom = pj_ntohs(rb_voip_mtc->jb_nom);\n\tsess->stat.tx.voip_mtc.jb_max = pj_ntohs(rb_voip_mtc->jb_max);\n\tsess->stat.tx.voip_mtc.jb_abs_max = pj_ntohs(rb_voip_mtc->jb_abs_max);\n\n\tpj_gettimeofday(&sess->stat.tx.voip_mtc.update);\n    }\n}\n\n/* Place seq into a 32-bit sequence number space based upon a\n * heuristic for its most likely location.\n */\nstatic pj_uint32_t extend_seq(pjmedia_rtcp_xr_session *sess,\n\t\t\t      const pj_uint16_t seq)\n{\n\n    pj_uint32_t extended_seq, seq_a, seq_b, diff_a, diff_b;\n    if(sess->uninitialized_src_ref_seq) {\n\t/* This is the first sequence number received.  Place\n\t * it in the middle of the extended sequence number\n\t * space.\n\t */\n\tsess->src_ref_seq = seq | 0x80000000u;\n\tsess->uninitialized_src_ref_seq = PJ_FALSE;\n\textended_seq = sess->src_ref_seq;\n    } else {\n\t/* Prior sequence numbers have been received.\n\t * Propose two candidates for the extended sequence\n\t * number: seq_a is without wraparound, seq_b with\n\t * wraparound.\n\t */\n\tseq_a = seq | (sess->src_ref_seq & 0xFFFF0000u);\n\tif(sess->src_ref_seq < seq_a) {\n\t    seq_b  = seq_a - 0x00010000u;\n\t    diff_a = seq_a - sess->src_ref_seq;\n\t    diff_b = sess->src_ref_seq - seq_b;\n\t} else {\n\t    seq_b  = seq_a + 0x00010000u;\n\t    diff_a = sess->src_ref_seq - seq_a;\n\t    diff_b = seq_b - sess->src_ref_seq;\n\t}\n\n\t/* Choose the closer candidate.  If they are equally\n\t * close, the choice is somewhat arbitrary: we choose\n\t * the candidate for which no rollover is necessary.\n\t */\n\tif(diff_a < diff_b) {\n\t    extended_seq = seq_a;\n\t} else {\n\t    extended_seq = seq_b;\n\t}\n\n\t/* Set the reference sequence number to be this most\n\t * recently-received sequence number.\n\t */\n\tsess->src_ref_seq = extended_seq;\n    }\n\n    /* Return our best guess for a 32-bit sequence number that\n     * corresponds to the 16-bit number we were given.\n     */\n    return extended_seq;\n}\n\nvoid pjmedia_rtcp_xr_rx_rtp( pjmedia_rtcp_xr_session *sess,\n\t\t\t     unsigned seq, \n\t\t\t     int lost,\n\t\t\t     int dup,\n\t\t\t     int discarded,\n\t\t\t     int jitter,\n\t\t\t     int toh, pj_bool_t toh_ipv4)\n{\n    pj_uint32_t ext_seq;\n\n    /* Get 32 bit version of sequence */\n    ext_seq = extend_seq(sess, (pj_uint16_t)seq);\n\n    /* Update statistics summary */\n    sess->stat.rx.stat_sum.count++;\n\n    if (sess->stat.rx.stat_sum.begin_seq == 0 || \n\tsess->stat.rx.stat_sum.begin_seq > ext_seq)\n    {\n\tsess->stat.rx.stat_sum.begin_seq = ext_seq;\n    }\n\n    if (sess->stat.rx.stat_sum.end_seq == 0 || \n\tsess->stat.rx.stat_sum.end_seq < ext_seq)\n    {\n\tsess->stat.rx.stat_sum.end_seq = ext_seq;\n    }\n\n    if (lost >= 0) {\n\tsess->stat.rx.stat_sum.l = PJ_TRUE;\n\tif (lost > 0)\n\t    sess->stat.rx.stat_sum.lost++;\n    }\n\n    if (dup >= 0) {\n\tsess->stat.rx.stat_sum.d = PJ_TRUE;\n\tif (dup > 0)\n\t    sess->stat.rx.stat_sum.dup++;\n    }\n\n    if (jitter >= 0) {\n\tsess->stat.rx.stat_sum.j = PJ_TRUE;\n\tpj_math_stat_update(&sess->stat.rx.stat_sum.jitter, jitter);\n    }\n\n    if (toh >= 0) {\n\tsess->stat.rx.stat_sum.t = toh_ipv4? 1 : 2;\n\tpj_math_stat_update(&sess->stat.rx.stat_sum.toh, toh);\n    }\n\n    /* Update burst metrics.\n     * There are two terms introduced in the RFC 3611: gap & burst.\n     * Gap represents good stream condition, lost+discard rate <= 1/Gmin.\n     * Burst represents the opposite, lost+discard rate > 1/Gmin.\n     */\n    if (lost >= 0 && discarded >= 0) {\n\tif(lost > 0) {\n\t    sess->voip_mtc_stat.loss_count++;\n\t}\n\tif(discarded > 0) {\n\t    sess->voip_mtc_stat.discard_count++;\n\t}\n\tif(!lost && !discarded) {\n\t    /* Number of good packets since last lost/discarded */\n\t    sess->voip_mtc_stat.pkt++;\n\t}\n\telse {\n\t    if(sess->voip_mtc_stat.pkt >= sess->stat.rx.voip_mtc.gmin) {\n\t\t/* Gap condition */\n\t\tif(sess->voip_mtc_stat.lost == 1) {\n\t\t    /* Gap -> Gap */\n\t\t    sess->voip_mtc_stat.c14++;\n\t\t}\n\t\telse {\n\t\t    /* Burst -> Gap */\n\t\t    sess->voip_mtc_stat.c13++;\n\t\t}\n\t\tsess->voip_mtc_stat.lost = 1;\n\t\tsess->voip_mtc_stat.c11 += sess->voip_mtc_stat.pkt;\n\t    }\n\t    else {\n\t\t/* Burst condition */\n\t\tsess->voip_mtc_stat.lost++;\n\t\tif(sess->voip_mtc_stat.pkt == 0) {\n\t\t    /* Consecutive losts */\n\t\t    sess->voip_mtc_stat.c33++;\n\t\t}\n\t\telse {\n\t\t    /* Any good packets, but still bursting */\n\t\t    sess->voip_mtc_stat.c23++;\n\t\t    sess->voip_mtc_stat.c22 += (sess->voip_mtc_stat.pkt - 1);\n\t\t}\n\t    }\n\n\t    sess->voip_mtc_stat.pkt = 0;\n\t}\n    }\n}\n\nvoid pjmedia_rtcp_xr_tx_rtp( pjmedia_rtcp_xr_session *session, \n\t\t\t     unsigned ptsize )\n{\n    PJ_UNUSED_ARG(session);\n    PJ_UNUSED_ARG(ptsize);\n}\n\nPJ_DEF(pj_status_t) pjmedia_rtcp_xr_update_info( \n\t\t\t\t\t pjmedia_rtcp_xr_session *sess,\n\t\t\t\t\t unsigned info,\n\t\t\t\t\t pj_int32_t val)\n{\n    int v = val;\n\n    switch(info) {\n\tcase PJMEDIA_RTCP_XR_INFO_SIGNAL_LVL:\n\t    sess->stat.rx.voip_mtc.signal_lvl = (pj_int8_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_NOISE_LVL:\n\t    sess->stat.rx.voip_mtc.noise_lvl = (pj_int8_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_RERL:\n\t    sess->stat.rx.voip_mtc.rerl = (pj_uint8_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_R_FACTOR:\n\t    sess->stat.rx.voip_mtc.ext_r_factor = (pj_uint8_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_MOS_LQ:\n\t    sess->stat.rx.voip_mtc.mos_lq = (pj_uint8_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_MOS_CQ:\n\t    sess->stat.rx.voip_mtc.mos_cq = (pj_uint8_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_CONF_PLC:\n\t    if (v >= 0 && v <= 3) {\n\t\tsess->stat.rx.voip_mtc.rx_config &= 0x3F;\n\t\tsess->stat.rx.voip_mtc.rx_config |= (pj_uint8_t) (v << 6);\n\t    }\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_CONF_JBA:\n\t    if (v >= 0 && v <= 3) {\n\t\tsess->stat.rx.voip_mtc.rx_config &= 0xCF;\n\t\tsess->stat.rx.voip_mtc.rx_config |= (pj_uint8_t) (v << 4);\n\t    }\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_CONF_JBR:\n\t    if (v >= 0 && v <= 15) {\n\t\tsess->stat.rx.voip_mtc.rx_config &= 0xF0;\n\t\tsess->stat.rx.voip_mtc.rx_config |= (pj_uint8_t) v;\n\t    }\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_JB_NOM:\n\t    sess->stat.rx.voip_mtc.jb_nom = (pj_uint16_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_JB_MAX:\n\t    sess->stat.rx.voip_mtc.jb_max = (pj_uint16_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_JB_ABS_MAX:\n\t    sess->stat.rx.voip_mtc.jb_abs_max = (pj_uint16_t) v;\n\t    break;\n\n\tdefault:\n\t    return PJ_EINVAL;\n    }\n\n    return PJ_SUCCESS;\n}\n\n#endif\n"], "fixing_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n\n#include <pjmedia/rtcp_xr.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/rtcp.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/sock.h>\n#include <pj/string.h>\n\n#if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR != 0)\n\n#define THIS_FILE \"rtcp_xr.c\"\n\n\n#if PJ_HAS_HIGH_RES_TIMER==0\n#   error \"High resolution timer needs to be enabled\"\n#endif\n\n\n/* RTCP XR payload type */\n#define RTCP_XR\t\t    207\n\n/* RTCP XR block types */\n#define BT_LOSS_RLE\t    1\n#define BT_DUP_RLE\t    2\n#define BT_RCPT_TIMES\t    3\n#define BT_RR_TIME\t    4\n#define BT_DLRR\t\t    5\n#define BT_STATS\t    6\n#define BT_VOIP_METRICS\t    7\n\n\n#define DEFAULT_GMIN\t    16\n\n\n#if 0\n#   define TRACE_(x)\tPJ_LOG(3,x)\n#else\n#   define TRACE_(x)\t;\n#endif\n\nvoid pjmedia_rtcp_xr_init( pjmedia_rtcp_xr_session *session, \n\t\t\t   struct pjmedia_rtcp_session *parent_session,\n\t\t\t   pj_uint8_t gmin,\n\t\t\t   unsigned frames_per_packet)\n{\n    pj_bzero(session, sizeof(pjmedia_rtcp_xr_session));\n\n    session->name = parent_session->name;\n    session->rtcp_session = parent_session;\n    pj_memcpy(&session->pkt.common, &session->rtcp_session->rtcp_sr_pkt.common,\n\t      sizeof(pjmedia_rtcp_common));\n    session->pkt.common.pt = RTCP_XR;\n\n    /* Init config */\n    session->stat.rx.voip_mtc.gmin = (pj_uint8_t)(gmin? gmin : DEFAULT_GMIN);\n    session->ptime = session->rtcp_session->pkt_size * 1000 / \n\t\t     session->rtcp_session->clock_rate;\n    session->frames_per_packet = frames_per_packet;\n\n    /* Init Statistics Summary fields which have non-zero default */\n    session->stat.rx.stat_sum.jitter.min = (unsigned) -1;\n    session->stat.rx.stat_sum.toh.min = (unsigned) -1;\n\n    /* Init VoIP Metrics fields which have non-zero default */\n    session->stat.rx.voip_mtc.signal_lvl = 127;\n    session->stat.rx.voip_mtc.noise_lvl = 127;\n    session->stat.rx.voip_mtc.rerl = 127;\n    session->stat.rx.voip_mtc.r_factor = 127;\n    session->stat.rx.voip_mtc.ext_r_factor = 127;\n    session->stat.rx.voip_mtc.mos_lq = 127;\n    session->stat.rx.voip_mtc.mos_cq = 127;\n\n    session->stat.tx.voip_mtc.signal_lvl = 127;\n    session->stat.tx.voip_mtc.noise_lvl = 127;\n    session->stat.tx.voip_mtc.rerl = 127;\n    session->stat.tx.voip_mtc.r_factor = 127;\n    session->stat.tx.voip_mtc.ext_r_factor = 127;\n    session->stat.tx.voip_mtc.mos_lq = 127;\n    session->stat.tx.voip_mtc.mos_cq = 127;\n}\n\nvoid pjmedia_rtcp_xr_fini(pjmedia_rtcp_xr_session *session)\n{\n    PJ_UNUSED_ARG(session);\n}\n\nPJ_DEF(void) pjmedia_rtcp_build_rtcp_xr( pjmedia_rtcp_xr_session *sess, \n\t\t\t\t\t unsigned rpt_types,\n\t\t\t\t\t void **rtcp_pkt, int *len)\n{\n    pj_uint16_t size = 0;\n\n    /* Receiver Reference Time Report Block */\n    /* Build this block if we have received packets since last build */\n    if ((rpt_types == 0 || (rpt_types & PJMEDIA_RTCP_XR_RR_TIME)) &&\n\tsess->rx_last_rr != sess->rtcp_session->stat.rx.pkt)\n    {\n\tpjmedia_rtcp_xr_rb_rr_time *r;\n\tpjmedia_rtcp_ntp_rec ntp;\n\n\tr = (pjmedia_rtcp_xr_rb_rr_time*) &sess->pkt.buf[size];\n\tpj_bzero(r, sizeof(pjmedia_rtcp_xr_rb_rr_time));\n\n\t/* Init block header */\n\tr->header.bt = BT_RR_TIME;\n\tr->header.specific = 0;\n\tr->header.length = pj_htons(2);\n\n\t/* Generate block contents */\n\tpjmedia_rtcp_get_ntp_time(sess->rtcp_session, &ntp);\n\tr->ntp_sec = pj_htonl(ntp.hi);\n\tr->ntp_frac = pj_htonl(ntp.lo);\n\n\t/* Finally */\n\tsize += sizeof(pjmedia_rtcp_xr_rb_rr_time);\n\tsess->rx_last_rr = sess->rtcp_session->stat.rx.pkt;\n    }\n\n    /* DLRR Report Block */\n    /* Build this block if we have received RR NTP (rx_lrr) before */\n    if ((rpt_types == 0 || (rpt_types & PJMEDIA_RTCP_XR_DLRR)) && \n\tsess->rx_lrr)\n    {\n\tpjmedia_rtcp_xr_rb_dlrr *r;\n\tpjmedia_rtcp_xr_rb_dlrr_item *dlrr_item;\n\tpj_timestamp ts;\n\n\tr = (pjmedia_rtcp_xr_rb_dlrr*) &sess->pkt.buf[size];\n\tpj_bzero(r, sizeof(pjmedia_rtcp_xr_rb_dlrr));\n\n\t/* Init block header */\n\tr->header.bt = BT_DLRR;\n\tr->header.specific = 0;\n\tr->header.length = pj_htons(sizeof(pjmedia_rtcp_xr_rb_dlrr)/4 - 1);\n\n\t/* Generate block contents */\n\tdlrr_item = &r->item;\n\tdlrr_item->ssrc = pj_htonl(sess->rtcp_session->peer_ssrc);\n\tdlrr_item->lrr = pj_htonl(sess->rx_lrr);\n\n\t/* Calculate DLRR */\n\tif (sess->rx_lrr != 0) {\n\t    pj_get_timestamp(&ts);\n\t    ts.u64 -= sess->rx_lrr_time.u64;\n\t\n\t    /* Convert DLRR time to 1/65536 seconds resolution */\n\t    ts.u64 = (ts.u64 << 16) / sess->rtcp_session->ts_freq.u64;\n\t    dlrr_item->dlrr = pj_htonl(ts.u32.lo);\n\t} else {\n\t    dlrr_item->dlrr = 0;\n\t}\n\n\t/* Finally */\n\tsize += sizeof(pjmedia_rtcp_xr_rb_dlrr);\n    }\n\n    /* Statistics Summary Block */\n    /* Build this block if we have received packets since last build */\n    if ((rpt_types == 0 || (rpt_types & PJMEDIA_RTCP_XR_STATS)) &&\n\tsess->stat.rx.stat_sum.count > 0)\n    {\n\tpjmedia_rtcp_xr_rb_stats *r;\n\tpj_uint8_t specific = 0;\n\n\tr = (pjmedia_rtcp_xr_rb_stats*) &sess->pkt.buf[size];\n\tpj_bzero(r, sizeof(pjmedia_rtcp_xr_rb_stats));\n\n\t/* Init block header */\n\tspecific |= sess->stat.rx.stat_sum.l ? (1 << 7) : 0;\n\tspecific |= sess->stat.rx.stat_sum.d ? (1 << 6) : 0;\n\tspecific |= sess->stat.rx.stat_sum.j ? (1 << 5) : 0;\n\tspecific |= (sess->stat.rx.stat_sum.t & 3) << 3;\n\tr->header.bt = BT_STATS;\n\tr->header.specific = specific;\n\tr->header.length = pj_htons(9);\n\n\t/* Generate block contents */\n\tr->ssrc = pj_htonl(sess->rtcp_session->peer_ssrc);\n\tr->begin_seq = pj_htons((pj_uint16_t)\n\t\t\t\t(sess->stat.rx.stat_sum.begin_seq & 0xFFFF));\n\tr->end_seq = pj_htons((pj_uint16_t)\n\t\t\t      (sess->stat.rx.stat_sum.end_seq & 0xFFFF));\n\tif (sess->stat.rx.stat_sum.l) {\n\t    r->lost = pj_htonl(sess->stat.rx.stat_sum.lost);\n\t}\n\tif (sess->stat.rx.stat_sum.d) {\n\t    r->dup = pj_htonl(sess->stat.rx.stat_sum.dup);\n\t}\n\tif (sess->stat.rx.stat_sum.j) {\n\t    r->jitter_min = pj_htonl(sess->stat.rx.stat_sum.jitter.min);\n\t    r->jitter_max = pj_htonl(sess->stat.rx.stat_sum.jitter.max);\n\t    r->jitter_mean = \n\t\tpj_htonl((unsigned)sess->stat.rx.stat_sum.jitter.mean);\n\t    r->jitter_dev = \n\t\tpj_htonl(pj_math_stat_get_stddev(&sess->stat.rx.stat_sum.jitter));\n\t}\n\tif (sess->stat.rx.stat_sum.t) {\n\t    r->toh_min = sess->stat.rx.stat_sum.toh.min;\n\t    r->toh_max = sess->stat.rx.stat_sum.toh.max;\n\t    r->toh_mean = (unsigned) sess->stat.rx.stat_sum.toh.mean;\n\t    r->toh_dev = pj_math_stat_get_stddev(&sess->stat.rx.stat_sum.toh);\n\t}\n\n\t/* Reset TX statistics summary each time built */\n\tpj_bzero(&sess->stat.rx.stat_sum, sizeof(sess->stat.rx.stat_sum));\n\tsess->stat.rx.stat_sum.jitter.min = (unsigned) -1;\n\tsess->stat.rx.stat_sum.toh.min = (unsigned) -1;\n\n\t/* Finally */\n\tsize += sizeof(pjmedia_rtcp_xr_rb_stats);\n\tpj_gettimeofday(&sess->stat.rx.stat_sum.update);\n    }\n\n    /* Voip Metrics Block */\n    /* Build this block if we have received packets */\n    if ((rpt_types == 0 || (rpt_types & PJMEDIA_RTCP_XR_VOIP_METRICS)) &&\n\tsess->rtcp_session->stat.rx.pkt)\n    {\n\tpjmedia_rtcp_xr_rb_voip_mtc *r;\n\tpj_uint32_t c11;\n\tpj_uint32_t c13;\n\tpj_uint32_t c14;\n\tpj_uint32_t c22;\n\tpj_uint32_t c23;\n\tpj_uint32_t c31;\n\tpj_uint32_t c32;\n\tpj_uint32_t c33;\n\tpj_uint32_t ctotal, m;\n\tunsigned est_extra_delay;\n\n\tr = (pjmedia_rtcp_xr_rb_voip_mtc*) &sess->pkt.buf[size];\n\tpj_bzero(r, sizeof(pjmedia_rtcp_xr_rb_voip_mtc));\n\n\t/* Init block header */\n\tr->header.bt = BT_VOIP_METRICS;\n\tr->header.specific = 0;\n\tr->header.length = pj_htons(8);\n\n\t/* Use temp vars for easiness. */\n\tc11 = sess->voip_mtc_stat.c11;\n\tc13 = sess->voip_mtc_stat.c13;\n\tc14 = sess->voip_mtc_stat.c14;\n\tc22 = sess->voip_mtc_stat.c22;\n\tc23 = sess->voip_mtc_stat.c23;\n\tc33 = sess->voip_mtc_stat.c33;\n\tm = sess->ptime * sess->frames_per_packet;\n\n\t/* Calculate additional transition counts. */\n\tc31 = c13;\n\tc32 = c23;\n\tctotal = c11 + c14 + c13 + c22 + c23 + c31 + c32 + c33;\n\n\tif (ctotal) {\n\t    pj_uint32_t p32, p23;\n\n\t    //original version:\n\t    //p32 = c32 / (c31 + c32 + c33);\n\t    if (c31 + c32 + c33 == 0)\n\t\tp32 = 0;\n\t    else\n\t\tp32 = (c32 << 16) / (c31 + c32 + c33);\n\n\t    //original version:\n\t    //if ((c22 + c23) < 1) {\n\t    //    p23 = 1;\n\t    //} else {\n\t    //    p23 = 1 - c22 / (c22 + c23);\n\t    //}\n\t    if (c23 == 0) {\n\t        p23 = 0;\n\t    } else {\n\t        p23 = (c23 << 16) / (c22 + c23);\n\t    }\n\n\t    /* Calculate loss/discard densities, scaled of 0-256 */\n\t    if (c11 == 0)\n\t\tsess->stat.rx.voip_mtc.gap_den = 0;\n\t    else\n\t\tsess->stat.rx.voip_mtc.gap_den = (pj_uint8_t)\n\t\t\t\t\t\t ((c14 << 8) / (c11 + c14));\n\t    if (p23 == 0)\n\t\tsess->stat.rx.voip_mtc.burst_den = 0;\n\t    else\n\t\tsess->stat.rx.voip_mtc.burst_den = (pj_uint8_t)\n\t\t\t\t\t\t   ((p23 << 8) / (p23 + p32));\n\n\t    /* Calculate (average) durations, in ms */\n\t    if (c13 == 0) {\n\t\tc13 = 1;\n\t\tctotal += 1;\n\t    }\n\t    sess->stat.rx.voip_mtc.gap_dur = (pj_uint16_t)\n\t\t\t\t\t    ((c11+c14+c13) * m / c13);\n\t    sess->stat.rx.voip_mtc.burst_dur = (pj_uint16_t)\n\t\t\t\t\t    ((ctotal - (c11+c14+c13)) * m / c13);\n\n\t    /* Callculate loss/discard rates, scaled 0-256 */\n\t    sess->stat.rx.voip_mtc.loss_rate = (pj_uint8_t)\n\t\t\t((sess->voip_mtc_stat.loss_count << 8) / ctotal);\n\t    sess->stat.rx.voip_mtc.discard_rate = (pj_uint8_t)\n\t\t\t((sess->voip_mtc_stat.discard_count << 8) / ctotal);\n\t} else {\n\t    /* No lost/discarded packet yet. */\n\t    sess->stat.rx.voip_mtc.gap_den = 0;\n\t    sess->stat.rx.voip_mtc.burst_den = 0;\n\t    sess->stat.rx.voip_mtc.gap_dur = 0;\n\t    sess->stat.rx.voip_mtc.burst_dur = 0;\n\t    sess->stat.rx.voip_mtc.loss_rate = 0;\n\t    sess->stat.rx.voip_mtc.discard_rate = 0;\n\t}\n\n\t/* Set round trip delay (in ms) to RTT calculated after receiving\n\t * DLRR or DLSR.\n\t */\n\tif (sess->stat.rtt.last)\n\t    sess->stat.rx.voip_mtc.rnd_trip_delay = (pj_uint16_t)\n\t\t\t\t    (sess->stat.rtt.last / 1000);\n\telse if (sess->rtcp_session->stat.rtt.last)\n\t    sess->stat.rx.voip_mtc.rnd_trip_delay = (pj_uint16_t)\n\t\t\t\t    (sess->rtcp_session->stat.rtt.last / 1000);\n\t\n\t/* End system delay = RTT/2 + current jitter buffer size + \n\t *                    EXTRA (estimated extra delay)\n\t * EXTRA will cover additional delay introduced by other components of\n\t * audio engine, e.g: sound device, codec, AEC, PLC, WSOLA.\n\t * Since it is difficult to get the exact value of EXTRA, estimation\n\t * is taken to be totally around 30ms + sound device latency.\n\t */\n\test_extra_delay = 30;\n\n#if !PJMEDIA_AUDIO_DEV_HAS_NULL_AUDIO\n\test_extra_delay += PJMEDIA_SND_DEFAULT_REC_LATENCY + \n\t\t\t   PJMEDIA_SND_DEFAULT_PLAY_LATENCY;\n#endif\n\n\tsess->stat.rx.voip_mtc.end_sys_delay = (pj_uint16_t)\n\t\t\t\t (sess->stat.rx.voip_mtc.rnd_trip_delay / 2 +\n\t\t\t\t sess->stat.rx.voip_mtc.jb_nom + \n\t\t\t\t est_extra_delay);\n\n\t/* Generate block contents */\n\tr->ssrc\t\t    = pj_htonl(sess->rtcp_session->peer_ssrc);\n\tr->loss_rate\t    = sess->stat.rx.voip_mtc.loss_rate;\n\tr->discard_rate\t    = sess->stat.rx.voip_mtc.discard_rate;\n\tr->burst_den\t    = sess->stat.rx.voip_mtc.burst_den;\n\tr->gap_den\t    = sess->stat.rx.voip_mtc.gap_den;\n\tr->burst_dur\t    = pj_htons(sess->stat.rx.voip_mtc.burst_dur);\n\tr->gap_dur\t    = pj_htons(sess->stat.rx.voip_mtc.gap_dur);\n\tr->rnd_trip_delay   = pj_htons(sess->stat.rx.voip_mtc.rnd_trip_delay);\n\tr->end_sys_delay    = pj_htons(sess->stat.rx.voip_mtc.end_sys_delay);\n\t/* signal & noise level encoded in two's complement form */\n\tr->signal_lvl\t    = (pj_uint8_t) \n\t\t\t      ((sess->stat.rx.voip_mtc.signal_lvl >= 0)?\n\t\t\t       sess->stat.rx.voip_mtc.signal_lvl :\n\t\t\t       (sess->stat.rx.voip_mtc.signal_lvl + 256));\n\tr->noise_lvl\t    = (pj_uint8_t)\n\t\t\t      ((sess->stat.rx.voip_mtc.noise_lvl >= 0)?\n\t\t\t       sess->stat.rx.voip_mtc.noise_lvl :\n\t\t\t       (sess->stat.rx.voip_mtc.noise_lvl + 256));\n\tr->rerl\t\t    = sess->stat.rx.voip_mtc.rerl;\n\tr->gmin\t\t    = sess->stat.rx.voip_mtc.gmin;\n\tr->r_factor\t    = sess->stat.rx.voip_mtc.r_factor;\n\tr->ext_r_factor\t    = sess->stat.rx.voip_mtc.ext_r_factor;\n\tr->mos_lq\t    = sess->stat.rx.voip_mtc.mos_lq;\n\tr->mos_cq\t    = sess->stat.rx.voip_mtc.mos_cq;\n\tr->rx_config\t    = sess->stat.rx.voip_mtc.rx_config;\n\tr->jb_nom\t    = pj_htons(sess->stat.rx.voip_mtc.jb_nom);\n\tr->jb_max\t    = pj_htons(sess->stat.rx.voip_mtc.jb_max);\n\tr->jb_abs_max\t    = pj_htons(sess->stat.rx.voip_mtc.jb_abs_max);\n\n\t/* Finally */\n\tsize += sizeof(pjmedia_rtcp_xr_rb_voip_mtc);\n\tpj_gettimeofday(&sess->stat.rx.voip_mtc.update);\n    }\n\n    /* Add RTCP XR header size */\n    size += sizeof(sess->pkt.common);\n\n    /* Set RTCP XR header 'length' to packet size in 32-bit unit minus one */\n    sess->pkt.common.length = pj_htons((pj_uint16_t)(size/4 - 1));\n\n    /* Set the return values */\n    *rtcp_pkt = (void*) &sess->pkt;\n    *len = size;\n}\n\n\nvoid pjmedia_rtcp_xr_rx_rtcp_xr( pjmedia_rtcp_xr_session *sess,\n\t\t\t\t const void *pkt,\n\t\t\t\t pj_size_t size)\n{\n    const pjmedia_rtcp_xr_pkt\t      *rtcp_xr = (pjmedia_rtcp_xr_pkt*) pkt;\n    const pjmedia_rtcp_xr_rb_rr_time  *rb_rr_time = NULL;\n    const pjmedia_rtcp_xr_rb_dlrr     *rb_dlrr = NULL;\n    const pjmedia_rtcp_xr_rb_stats    *rb_stats = NULL;\n    const pjmedia_rtcp_xr_rb_voip_mtc *rb_voip_mtc = NULL;\n    const pjmedia_rtcp_xr_rb_header   *rb_hdr = (pjmedia_rtcp_xr_rb_header*) \n\t\t\t\t\t\trtcp_xr->buf;\n    unsigned pkt_len, rb_len;\n\n    if (rtcp_xr->common.pt != RTCP_XR)\n\treturn;\n\n    pkt_len = pj_ntohs((pj_uint16_t)rtcp_xr->common.length);\n\n    if ((pkt_len + 1) > (size / 4))\n\treturn;\n\n    /* Parse report rpt_types */\n    while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)\n    {\t\n\trb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);\n\n\t/* Just skip any block with length == 0 (no report content) */\n\tif (rb_len) {\n\t    switch (rb_hdr->bt) {\n\t\tcase BT_RR_TIME:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_rr_time) <=\n\t\t\t(char*)pkt + size) \n\t\t    {\n\t\t\trb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_DLRR:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_dlrr) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_STATS:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_stats) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_stats = (pjmedia_rtcp_xr_rb_stats*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_VOIP_METRICS:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_voip_mtc) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n\trb_hdr = (pjmedia_rtcp_xr_rb_header*)\n\t\t ((pj_int32_t*)rb_hdr + rb_len + 1);\n    }\n\n    /* Receiving RR Time */\n    if (rb_rr_time) {\n\t/* Save LRR from NTP timestamp of the RR time block report */\n\tsess->rx_lrr = ((pj_ntohl(rb_rr_time->ntp_sec) & 0x0000FFFF) << 16) | \n\t\t       ((pj_ntohl(rb_rr_time->ntp_frac) >> 16) & 0xFFFF);\n\n\t/* Calculate RR arrival time for DLRR */\n\tpj_get_timestamp(&sess->rx_lrr_time);\n\n\tTRACE_((sess->name, \"Rx RTCP SR: ntp_ts=%p\", sess->rx_lrr,\n\t       (pj_uint32_t)(sess->rx_lrr_time.u64*65536/\n\t\t\t     sess->rtcp_session->ts_freq.u64)));\n    }\n\n    /* Receiving DLRR */\n    if (rb_dlrr) {\n\tpj_uint32_t lrr, now, dlrr;\n\tpj_uint64_t eedelay;\n\tpjmedia_rtcp_ntp_rec ntp;\n\n\t/* LRR is the middle 32bit of NTP. It has 1/65536 second \n\t * resolution \n\t */\n\tlrr = pj_ntohl(rb_dlrr->item.lrr);\n\n\t/* DLRR is delay since LRR, also in 1/65536 resolution */\n\tdlrr = pj_ntohl(rb_dlrr->item.dlrr);\n\n\t/* Get current time, and convert to 1/65536 resolution */\n\tpjmedia_rtcp_get_ntp_time(sess->rtcp_session, &ntp);\n\tnow = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);\n\n\t/* End-to-end delay is (now-lrr-dlrr) */\n\teedelay = now - lrr - dlrr;\n\n\t/* Convert end to end delay to usec (keeping the calculation in\n         * 64bit space)::\n\t *   sess->ee_delay = (eedelay * 1000) / 65536;\n\t */\n\tif (eedelay < 4294) {\n\t    eedelay = (eedelay * 1000000) >> 16;\n\t} else {\n\t    eedelay = (eedelay * 1000) >> 16;\n\t    eedelay *= 1000;\n\t}\n\n\tTRACE_((sess->name, \"Rx RTCP XR DLRR: lrr=%p, dlrr=%p (%d:%03dms), \"\n\t\t\t   \"now=%p, rtt=%p\",\n\t\tlrr, dlrr, dlrr/65536, (dlrr%65536)*1000/65536,\n\t\tnow, (pj_uint32_t)eedelay));\n\t\n\t/* Only save calculation if \"now\" is greater than lrr, or\n\t * otherwise rtt will be invalid \n\t */\n\tif (now-dlrr >= lrr) {\n\t    unsigned rtt = (pj_uint32_t)eedelay;\n\t    \n\t    /* Check that eedelay value really makes sense. \n\t     * We allow up to 30 seconds RTT!\n\t     */\n\t    if (eedelay <= 30 * 1000 * 1000UL) {\n\t\t/* \"Normalize\" rtt value that is exceptionally high.\n\t\t * For such values, \"normalize\" the rtt to be three times\n\t\t * the average value.\n\t\t */\n\t\tif (rtt>((unsigned)sess->stat.rtt.mean*3) && sess->stat.rtt.n!=0)\n\t\t{\n\t\t    unsigned orig_rtt = rtt;\n\t\t    rtt = (unsigned)sess->stat.rtt.mean*3;\n\t\t    PJ_LOG(5,(sess->name, \n\t\t\t      \"RTT value %d usec is normalized to %d usec\",\n\t\t\t      orig_rtt, rtt));\n\t\t}\n    \t\n\t\tTRACE_((sess->name, \"RTCP RTT is set to %d usec\", rtt));\n\t\tpj_math_stat_update(&sess->stat.rtt, rtt);\n\t    }\n\t} else {\n\t    PJ_LOG(5, (sess->name, \"Internal RTCP NTP clock skew detected: \"\n\t\t\t\t   \"lrr=%p, now=%p, dlrr=%p (%d:%03dms), \"\n\t\t\t\t   \"diff=%d\",\n\t\t\t\t   lrr, now, dlrr, dlrr/65536,\n\t\t\t\t   (dlrr%65536)*1000/65536,\n\t\t\t\t   dlrr-(now-lrr)));\n\t}\n    }\n\n    /* Receiving Statistics Summary */\n    if (rb_stats) {\n\tpj_uint8_t flags = rb_stats->header.specific;\n\n\tpj_bzero(&sess->stat.tx.stat_sum, sizeof(sess->stat.tx.stat_sum));\n\n\t/* Range of packets sequence reported in this blocks */\n\tsess->stat.tx.stat_sum.begin_seq = pj_ntohs(rb_stats->begin_seq);\n\tsess->stat.tx.stat_sum.end_seq   = pj_ntohs(rb_stats->end_seq);\n\n\t/* Get flags of valid fields */\n\tsess->stat.tx.stat_sum.l = (flags & (1 << 7)) != 0;\n\tsess->stat.tx.stat_sum.d = (flags & (1 << 6)) != 0;\n\tsess->stat.tx.stat_sum.j = (flags & (1 << 5)) != 0;\n\tsess->stat.tx.stat_sum.t = (flags & (3 << 3)) != 0;\n\n\t/* Fetch the reports info */\n\tif (sess->stat.tx.stat_sum.l) {\n\t    sess->stat.tx.stat_sum.lost = pj_ntohl(rb_stats->lost);\n\t}\n\n\tif (sess->stat.tx.stat_sum.d) {\n\t    sess->stat.tx.stat_sum.dup = pj_ntohl(rb_stats->dup);\n\t}\n\n\tif (sess->stat.tx.stat_sum.j) {\n\t    sess->stat.tx.stat_sum.jitter.min = pj_ntohl(rb_stats->jitter_min);\n\t    sess->stat.tx.stat_sum.jitter.max = pj_ntohl(rb_stats->jitter_max);\n\t    sess->stat.tx.stat_sum.jitter.mean= pj_ntohl(rb_stats->jitter_mean);\n\t    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.jitter, \n\t\t\t\t    pj_ntohl(rb_stats->jitter_dev));\n\t}\n\n\tif (sess->stat.tx.stat_sum.t) {\n\t    sess->stat.tx.stat_sum.toh.min = rb_stats->toh_min;\n\t    sess->stat.tx.stat_sum.toh.max = rb_stats->toh_max;\n\t    sess->stat.tx.stat_sum.toh.mean= rb_stats->toh_mean;\n\t    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.toh, \n\t\t\t\t    pj_ntohl(rb_stats->toh_dev));\n\t}\n\n\tpj_gettimeofday(&sess->stat.tx.stat_sum.update);\n    }\n\n    /* Receiving VoIP Metrics */\n    if (rb_voip_mtc) {\n\tsess->stat.tx.voip_mtc.loss_rate = rb_voip_mtc->loss_rate;\n\tsess->stat.tx.voip_mtc.discard_rate = rb_voip_mtc->discard_rate;\n\tsess->stat.tx.voip_mtc.burst_den = rb_voip_mtc->burst_den;\n\tsess->stat.tx.voip_mtc.gap_den = rb_voip_mtc->gap_den;\n\tsess->stat.tx.voip_mtc.burst_dur = pj_ntohs(rb_voip_mtc->burst_dur);\n\tsess->stat.tx.voip_mtc.gap_dur = pj_ntohs(rb_voip_mtc->gap_dur);\n\tsess->stat.tx.voip_mtc.rnd_trip_delay = \n\t\t\t\t\tpj_ntohs(rb_voip_mtc->rnd_trip_delay);\n\tsess->stat.tx.voip_mtc.end_sys_delay = \n\t\t\t\t\tpj_ntohs(rb_voip_mtc->end_sys_delay);\n\t/* signal & noise level encoded in two's complement form */\n\tsess->stat.tx.voip_mtc.signal_lvl = (pj_int8_t)\n\t\t\t\t    ((rb_voip_mtc->signal_lvl > 127)?\n\t\t\t\t     ((int)rb_voip_mtc->signal_lvl - 256) : \n\t\t\t\t     rb_voip_mtc->signal_lvl);\n\tsess->stat.tx.voip_mtc.noise_lvl  = (pj_int8_t)\n\t\t\t\t    ((rb_voip_mtc->noise_lvl > 127)?\n\t\t\t\t     ((int)rb_voip_mtc->noise_lvl - 256) : \n\t\t\t\t     rb_voip_mtc->noise_lvl);\n\tsess->stat.tx.voip_mtc.rerl = rb_voip_mtc->rerl;\n\tsess->stat.tx.voip_mtc.gmin = rb_voip_mtc->gmin;\n\tsess->stat.tx.voip_mtc.r_factor = rb_voip_mtc->r_factor;\n\tsess->stat.tx.voip_mtc.ext_r_factor = rb_voip_mtc->ext_r_factor;\n\tsess->stat.tx.voip_mtc.mos_lq = rb_voip_mtc->mos_lq;\n\tsess->stat.tx.voip_mtc.mos_cq = rb_voip_mtc->mos_cq;\n\tsess->stat.tx.voip_mtc.rx_config = rb_voip_mtc->rx_config;\n\tsess->stat.tx.voip_mtc.jb_nom = pj_ntohs(rb_voip_mtc->jb_nom);\n\tsess->stat.tx.voip_mtc.jb_max = pj_ntohs(rb_voip_mtc->jb_max);\n\tsess->stat.tx.voip_mtc.jb_abs_max = pj_ntohs(rb_voip_mtc->jb_abs_max);\n\n\tpj_gettimeofday(&sess->stat.tx.voip_mtc.update);\n    }\n}\n\n/* Place seq into a 32-bit sequence number space based upon a\n * heuristic for its most likely location.\n */\nstatic pj_uint32_t extend_seq(pjmedia_rtcp_xr_session *sess,\n\t\t\t      const pj_uint16_t seq)\n{\n\n    pj_uint32_t extended_seq, seq_a, seq_b, diff_a, diff_b;\n    if(sess->uninitialized_src_ref_seq) {\n\t/* This is the first sequence number received.  Place\n\t * it in the middle of the extended sequence number\n\t * space.\n\t */\n\tsess->src_ref_seq = seq | 0x80000000u;\n\tsess->uninitialized_src_ref_seq = PJ_FALSE;\n\textended_seq = sess->src_ref_seq;\n    } else {\n\t/* Prior sequence numbers have been received.\n\t * Propose two candidates for the extended sequence\n\t * number: seq_a is without wraparound, seq_b with\n\t * wraparound.\n\t */\n\tseq_a = seq | (sess->src_ref_seq & 0xFFFF0000u);\n\tif(sess->src_ref_seq < seq_a) {\n\t    seq_b  = seq_a - 0x00010000u;\n\t    diff_a = seq_a - sess->src_ref_seq;\n\t    diff_b = sess->src_ref_seq - seq_b;\n\t} else {\n\t    seq_b  = seq_a + 0x00010000u;\n\t    diff_a = sess->src_ref_seq - seq_a;\n\t    diff_b = seq_b - sess->src_ref_seq;\n\t}\n\n\t/* Choose the closer candidate.  If they are equally\n\t * close, the choice is somewhat arbitrary: we choose\n\t * the candidate for which no rollover is necessary.\n\t */\n\tif(diff_a < diff_b) {\n\t    extended_seq = seq_a;\n\t} else {\n\t    extended_seq = seq_b;\n\t}\n\n\t/* Set the reference sequence number to be this most\n\t * recently-received sequence number.\n\t */\n\tsess->src_ref_seq = extended_seq;\n    }\n\n    /* Return our best guess for a 32-bit sequence number that\n     * corresponds to the 16-bit number we were given.\n     */\n    return extended_seq;\n}\n\nvoid pjmedia_rtcp_xr_rx_rtp( pjmedia_rtcp_xr_session *sess,\n\t\t\t     unsigned seq, \n\t\t\t     int lost,\n\t\t\t     int dup,\n\t\t\t     int discarded,\n\t\t\t     int jitter,\n\t\t\t     int toh, pj_bool_t toh_ipv4)\n{\n    pj_uint32_t ext_seq;\n\n    /* Get 32 bit version of sequence */\n    ext_seq = extend_seq(sess, (pj_uint16_t)seq);\n\n    /* Update statistics summary */\n    sess->stat.rx.stat_sum.count++;\n\n    if (sess->stat.rx.stat_sum.begin_seq == 0 || \n\tsess->stat.rx.stat_sum.begin_seq > ext_seq)\n    {\n\tsess->stat.rx.stat_sum.begin_seq = ext_seq;\n    }\n\n    if (sess->stat.rx.stat_sum.end_seq == 0 || \n\tsess->stat.rx.stat_sum.end_seq < ext_seq)\n    {\n\tsess->stat.rx.stat_sum.end_seq = ext_seq;\n    }\n\n    if (lost >= 0) {\n\tsess->stat.rx.stat_sum.l = PJ_TRUE;\n\tif (lost > 0)\n\t    sess->stat.rx.stat_sum.lost++;\n    }\n\n    if (dup >= 0) {\n\tsess->stat.rx.stat_sum.d = PJ_TRUE;\n\tif (dup > 0)\n\t    sess->stat.rx.stat_sum.dup++;\n    }\n\n    if (jitter >= 0) {\n\tsess->stat.rx.stat_sum.j = PJ_TRUE;\n\tpj_math_stat_update(&sess->stat.rx.stat_sum.jitter, jitter);\n    }\n\n    if (toh >= 0) {\n\tsess->stat.rx.stat_sum.t = toh_ipv4? 1 : 2;\n\tpj_math_stat_update(&sess->stat.rx.stat_sum.toh, toh);\n    }\n\n    /* Update burst metrics.\n     * There are two terms introduced in the RFC 3611: gap & burst.\n     * Gap represents good stream condition, lost+discard rate <= 1/Gmin.\n     * Burst represents the opposite, lost+discard rate > 1/Gmin.\n     */\n    if (lost >= 0 && discarded >= 0) {\n\tif(lost > 0) {\n\t    sess->voip_mtc_stat.loss_count++;\n\t}\n\tif(discarded > 0) {\n\t    sess->voip_mtc_stat.discard_count++;\n\t}\n\tif(!lost && !discarded) {\n\t    /* Number of good packets since last lost/discarded */\n\t    sess->voip_mtc_stat.pkt++;\n\t}\n\telse {\n\t    if(sess->voip_mtc_stat.pkt >= sess->stat.rx.voip_mtc.gmin) {\n\t\t/* Gap condition */\n\t\tif(sess->voip_mtc_stat.lost == 1) {\n\t\t    /* Gap -> Gap */\n\t\t    sess->voip_mtc_stat.c14++;\n\t\t}\n\t\telse {\n\t\t    /* Burst -> Gap */\n\t\t    sess->voip_mtc_stat.c13++;\n\t\t}\n\t\tsess->voip_mtc_stat.lost = 1;\n\t\tsess->voip_mtc_stat.c11 += sess->voip_mtc_stat.pkt;\n\t    }\n\t    else {\n\t\t/* Burst condition */\n\t\tsess->voip_mtc_stat.lost++;\n\t\tif(sess->voip_mtc_stat.pkt == 0) {\n\t\t    /* Consecutive losts */\n\t\t    sess->voip_mtc_stat.c33++;\n\t\t}\n\t\telse {\n\t\t    /* Any good packets, but still bursting */\n\t\t    sess->voip_mtc_stat.c23++;\n\t\t    sess->voip_mtc_stat.c22 += (sess->voip_mtc_stat.pkt - 1);\n\t\t}\n\t    }\n\n\t    sess->voip_mtc_stat.pkt = 0;\n\t}\n    }\n}\n\nvoid pjmedia_rtcp_xr_tx_rtp( pjmedia_rtcp_xr_session *session, \n\t\t\t     unsigned ptsize )\n{\n    PJ_UNUSED_ARG(session);\n    PJ_UNUSED_ARG(ptsize);\n}\n\nPJ_DEF(pj_status_t) pjmedia_rtcp_xr_update_info( \n\t\t\t\t\t pjmedia_rtcp_xr_session *sess,\n\t\t\t\t\t unsigned info,\n\t\t\t\t\t pj_int32_t val)\n{\n    int v = val;\n\n    switch(info) {\n\tcase PJMEDIA_RTCP_XR_INFO_SIGNAL_LVL:\n\t    sess->stat.rx.voip_mtc.signal_lvl = (pj_int8_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_NOISE_LVL:\n\t    sess->stat.rx.voip_mtc.noise_lvl = (pj_int8_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_RERL:\n\t    sess->stat.rx.voip_mtc.rerl = (pj_uint8_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_R_FACTOR:\n\t    sess->stat.rx.voip_mtc.ext_r_factor = (pj_uint8_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_MOS_LQ:\n\t    sess->stat.rx.voip_mtc.mos_lq = (pj_uint8_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_MOS_CQ:\n\t    sess->stat.rx.voip_mtc.mos_cq = (pj_uint8_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_CONF_PLC:\n\t    if (v >= 0 && v <= 3) {\n\t\tsess->stat.rx.voip_mtc.rx_config &= 0x3F;\n\t\tsess->stat.rx.voip_mtc.rx_config |= (pj_uint8_t) (v << 6);\n\t    }\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_CONF_JBA:\n\t    if (v >= 0 && v <= 3) {\n\t\tsess->stat.rx.voip_mtc.rx_config &= 0xCF;\n\t\tsess->stat.rx.voip_mtc.rx_config |= (pj_uint8_t) (v << 4);\n\t    }\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_CONF_JBR:\n\t    if (v >= 0 && v <= 15) {\n\t\tsess->stat.rx.voip_mtc.rx_config &= 0xF0;\n\t\tsess->stat.rx.voip_mtc.rx_config |= (pj_uint8_t) v;\n\t    }\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_JB_NOM:\n\t    sess->stat.rx.voip_mtc.jb_nom = (pj_uint16_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_JB_MAX:\n\t    sess->stat.rx.voip_mtc.jb_max = (pj_uint16_t) v;\n\t    break;\n\n\tcase PJMEDIA_RTCP_XR_INFO_JB_ABS_MAX:\n\t    sess->stat.rx.voip_mtc.jb_abs_max = (pj_uint16_t) v;\n\t    break;\n\n\tdefault:\n\t    return PJ_EINVAL;\n    }\n\n    return PJ_SUCCESS;\n}\n\n#endif\n"], "filenames": ["pjmedia/src/pjmedia/rtcp_xr.c"], "buggy_code_start_loc": [439], "buggy_code_end_loc": [449], "fixing_code_start_loc": [439], "fixing_code_end_loc": [465], "type": "CWE-125", "message": "PJSIP is a free and open source multimedia communication library. In version 2.11.1 and prior, if incoming RTCP XR message contain block, the data field is not checked against the received packet size, potentially resulting in an out-of-bound read access. This affects all users that use PJMEDIA and RTCP XR. A malicious actor can send a RTCP XR message with an invalid packet size.", "other": {"cve": {"id": "CVE-2021-43845", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-27T18:15:07.460", "lastModified": "2023-01-27T19:56:11.017", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library. In version 2.11.1 and prior, if incoming RTCP XR message contain block, the data field is not checked against the received packet size, potentially resulting in an out-of-bound read access. This affects all users that use PJMEDIA and RTCP XR. A malicious actor can send a RTCP XR message with an invalid packet size."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto. En la versi\u00f3n 2.11.1 y anteriores, si el mensaje RTCP XR entrante contiene un bloque, el campo de datos no se comprueba con el tama\u00f1o del paquete recibido, resultando potencialmente en un acceso de lectura fuera de l\u00edmites. Esto afecta a todos los usuarios que usan PJMEDIA y RTCP XR. Un actor malicioso puede enviar un mensaje RTCP XR con un tama\u00f1o de paquete no v\u00e1lido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.11.1", "matchCriteriaId": "6BB0273A-3235-4BC7-A1BE-7D35BABD8617"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/f74c1fc22b760d2a24369aa72c74c4a9ab985859", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/pull/2924", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-r374-qrwv-86hh", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-37", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5285", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/f74c1fc22b760d2a24369aa72c74c4a9ab985859"}}