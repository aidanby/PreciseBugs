{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/* ATM ioctl handling */\n\n/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */\n/* 2003 John Levon  <levon@movementarian.org> */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/module.h>\n#include <linux/kmod.h>\n#include <linux/net.h>\t\t/* struct socket, struct proto_ops */\n#include <linux/atm.h>\t\t/* ATM stuff */\n#include <linux/atmdev.h>\n#include <linux/atmclip.h>\t/* CLIP_*ENCAP */\n#include <linux/atmarp.h>\t/* manifest constants */\n#include <linux/capability.h>\n#include <linux/sonet.h>\t/* for ioctls */\n#include <linux/atmsvc.h>\n#include <linux/atmmpc.h>\n#include <net/atmclip.h>\n#include <linux/atmlec.h>\n#include <linux/mutex.h>\n#include <asm/ioctls.h>\n#include <net/compat.h>\n\n#include \"resources.h\"\n#include \"signaling.h\"\t\t/* for WAITING and sigd_attach */\n#include \"common.h\"\n\n\nstatic DEFINE_MUTEX(ioctl_mutex);\nstatic LIST_HEAD(ioctl_list);\n\n\nvoid register_atm_ioctl(struct atm_ioctl *ioctl)\n{\n\tmutex_lock(&ioctl_mutex);\n\tlist_add_tail(&ioctl->list, &ioctl_list);\n\tmutex_unlock(&ioctl_mutex);\n}\nEXPORT_SYMBOL(register_atm_ioctl);\n\nvoid deregister_atm_ioctl(struct atm_ioctl *ioctl)\n{\n\tmutex_lock(&ioctl_mutex);\n\tlist_del(&ioctl->list);\n\tmutex_unlock(&ioctl_mutex);\n}\nEXPORT_SYMBOL(deregister_atm_ioctl);\n\nstatic int do_vcc_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\tunsigned long arg, int compat)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n\tint error;\n\tstruct list_head *pos;\n\tvoid __user *argp = (void __user *)arg;\n\tvoid __user *buf;\n\tint __user *len;\n\n\tvcc = ATM_SD(sock);\n\tswitch (cmd) {\n\tcase SIOCOUTQ:\n\t\tif (sock->state != SS_CONNECTED ||\n\t\t    !test_bit(ATM_VF_READY, &vcc->flags)) {\n\t\t\terror =  -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\terror = put_user(sk->sk_sndbuf - sk_wmem_alloc_get(sk),\n\t\t\t\t (int __user *)argp) ? -EFAULT : 0;\n\t\tgoto done;\n\tcase SIOCINQ:\n\t{\n\t\tstruct sk_buff *skb;\n\n\t\tif (sock->state != SS_CONNECTED) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\terror = put_user(skb ? skb->len : 0,\n\t\t\t\t (int __user *)argp) ? -EFAULT : 0;\n\t\tgoto done;\n\t}\n\tcase ATM_SETSC:\n\t\tnet_warn_ratelimited(\"ATM_SETSC is obsolete; used by %s:%d\\n\",\n\t\t\t\t     current->comm, task_pid_nr(current));\n\t\terror = 0;\n\t\tgoto done;\n\tcase ATMSIGD_CTRL:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terror = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * The user/kernel protocol for exchanging signalling\n\t\t * info uses kernel pointers as opaque references,\n\t\t * so the holder of the file descriptor can scribble\n\t\t * on the kernel... so we should make sure that we\n\t\t * have the same privileges that /proc/kcore needs\n\t\t */\n\t\tif (!capable(CAP_SYS_RAWIO)) {\n\t\t\terror = -EPERM;\n\t\t\tgoto done;\n\t\t}\n#ifdef CONFIG_COMPAT\n\t\t/* WTF? I don't even want to _think_ about making this\n\t\t   work for 32-bit userspace. TBH I don't really want\n\t\t   to think about it at all. dwmw2. */\n\t\tif (compat) {\n\t\t\tnet_warn_ratelimited(\"32-bit task cannot be atmsigd\\n\");\n\t\t\terror = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n#endif\n\t\terror = sigd_attach(vcc);\n\t\tif (!error)\n\t\t\tsock->state = SS_CONNECTED;\n\t\tgoto done;\n\tcase ATM_SETBACKEND:\n\tcase ATM_NEWBACKENDIF:\n\t{\n\t\tatm_backend_t backend;\n\t\terror = get_user(backend, (atm_backend_t __user *)argp);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tswitch (backend) {\n\t\tcase ATM_BACKEND_PPP:\n\t\t\trequest_module(\"pppoatm\");\n\t\t\tbreak;\n\t\tcase ATM_BACKEND_BR2684:\n\t\t\trequest_module(\"br2684\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase ATMMPC_CTRL:\n\tcase ATMMPC_DATA:\n\t\trequest_module(\"mpoa\");\n\t\tbreak;\n\tcase ATMARPD_CTRL:\n\t\trequest_module(\"clip\");\n\t\tbreak;\n\tcase ATMLEC_CTRL:\n\t\trequest_module(\"lec\");\n\t\tbreak;\n\t}\n\n\terror = -ENOIOCTLCMD;\n\n\tmutex_lock(&ioctl_mutex);\n\tlist_for_each(pos, &ioctl_list) {\n\t\tstruct atm_ioctl *ic = list_entry(pos, struct atm_ioctl, list);\n\t\tif (try_module_get(ic->owner)) {\n\t\t\terror = ic->ioctl(sock, cmd, arg);\n\t\t\tmodule_put(ic->owner);\n\t\t\tif (error != -ENOIOCTLCMD)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ioctl_mutex);\n\n\tif (error != -ENOIOCTLCMD)\n\t\tgoto done;\n\n\tif (cmd == ATM_GETNAMES) {\n\t\tif (IS_ENABLED(CONFIG_COMPAT) && compat) {\n#ifdef CONFIG_COMPAT\n\t\t\tstruct compat_atm_iobuf __user *ciobuf = argp;\n\t\t\tcompat_uptr_t cbuf;\n\t\t\tlen = &ciobuf->length;\n\t\t\tif (get_user(cbuf, &ciobuf->buffer))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf = compat_ptr(cbuf);\n#endif\n\t\t} else {\n\t\t\tstruct atm_iobuf __user *iobuf = argp;\n\t\t\tlen = &iobuf->length;\n\t\t\tif (get_user(buf, &iobuf->buffer))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\terror = atm_getnames(buf, len);\n\t} else {\n\t\tint number;\n\n\t\tif (IS_ENABLED(CONFIG_COMPAT) && compat) {\n#ifdef CONFIG_COMPAT\n\t\t\tstruct compat_atmif_sioc __user *csioc = argp;\n\t\t\tcompat_uptr_t carg;\n\n\t\t\tlen = &csioc->length;\n\t\t\tif (get_user(carg, &csioc->arg))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf = compat_ptr(carg);\n\t\t\tif (get_user(number, &csioc->number))\n\t\t\t\treturn -EFAULT;\n#endif\n\t\t} else {\n\t\t\tstruct atmif_sioc __user *sioc = argp;\n\n\t\t\tlen = &sioc->length;\n\t\t\tif (get_user(buf, &sioc->arg))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (get_user(number, &sioc->number))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\terror = atm_dev_ioctl(cmd, buf, len, number, compat);\n\t}\n\ndone:\n\treturn error;\n}\n\nint vcc_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\treturn do_vcc_ioctl(sock, cmd, arg, 0);\n}\n\n#ifdef CONFIG_COMPAT\n/*\n * FIXME:\n * The compat_ioctl handling is duplicated, using both these conversion\n * routines and the compat argument to the actual handlers. Both\n * versions are somewhat incomplete and should be merged, e.g. by\n * moving the ioctl number translation into the actual handlers and\n * killing the conversion code.\n *\n * -arnd, November 2009\n */\n#define ATM_GETLINKRATE32 _IOW('a', ATMIOC_ITF+1, struct compat_atmif_sioc)\n#define ATM_GETNAMES32    _IOW('a', ATMIOC_ITF+3, struct compat_atm_iobuf)\n#define ATM_GETTYPE32     _IOW('a', ATMIOC_ITF+4, struct compat_atmif_sioc)\n#define ATM_GETESI32\t  _IOW('a', ATMIOC_ITF+5, struct compat_atmif_sioc)\n#define ATM_GETADDR32\t  _IOW('a', ATMIOC_ITF+6, struct compat_atmif_sioc)\n#define ATM_RSTADDR32\t  _IOW('a', ATMIOC_ITF+7, struct compat_atmif_sioc)\n#define ATM_ADDADDR32\t  _IOW('a', ATMIOC_ITF+8, struct compat_atmif_sioc)\n#define ATM_DELADDR32\t  _IOW('a', ATMIOC_ITF+9, struct compat_atmif_sioc)\n#define ATM_GETCIRANGE32  _IOW('a', ATMIOC_ITF+10, struct compat_atmif_sioc)\n#define ATM_SETCIRANGE32  _IOW('a', ATMIOC_ITF+11, struct compat_atmif_sioc)\n#define ATM_SETESI32      _IOW('a', ATMIOC_ITF+12, struct compat_atmif_sioc)\n#define ATM_SETESIF32     _IOW('a', ATMIOC_ITF+13, struct compat_atmif_sioc)\n#define ATM_GETSTAT32     _IOW('a', ATMIOC_SARCOM+0, struct compat_atmif_sioc)\n#define ATM_GETSTATZ32    _IOW('a', ATMIOC_SARCOM+1, struct compat_atmif_sioc)\n#define ATM_GETLOOP32\t  _IOW('a', ATMIOC_SARCOM+2, struct compat_atmif_sioc)\n#define ATM_SETLOOP32\t  _IOW('a', ATMIOC_SARCOM+3, struct compat_atmif_sioc)\n#define ATM_QUERYLOOP32\t  _IOW('a', ATMIOC_SARCOM+4, struct compat_atmif_sioc)\n\nstatic struct {\n\tunsigned int cmd32;\n\tunsigned int cmd;\n} atm_ioctl_map[] = {\n\t{ ATM_GETLINKRATE32, ATM_GETLINKRATE },\n\t{ ATM_GETNAMES32,    ATM_GETNAMES },\n\t{ ATM_GETTYPE32,     ATM_GETTYPE },\n\t{ ATM_GETESI32,\t     ATM_GETESI },\n\t{ ATM_GETADDR32,     ATM_GETADDR },\n\t{ ATM_RSTADDR32,     ATM_RSTADDR },\n\t{ ATM_ADDADDR32,     ATM_ADDADDR },\n\t{ ATM_DELADDR32,     ATM_DELADDR },\n\t{ ATM_GETCIRANGE32,  ATM_GETCIRANGE },\n\t{ ATM_SETCIRANGE32,  ATM_SETCIRANGE },\n\t{ ATM_SETESI32,\t     ATM_SETESI },\n\t{ ATM_SETESIF32,     ATM_SETESIF },\n\t{ ATM_GETSTAT32,     ATM_GETSTAT },\n\t{ ATM_GETSTATZ32,    ATM_GETSTATZ },\n\t{ ATM_GETLOOP32,     ATM_GETLOOP },\n\t{ ATM_SETLOOP32,     ATM_SETLOOP },\n\t{ ATM_QUERYLOOP32,   ATM_QUERYLOOP },\n};\n\n#define NR_ATM_IOCTL ARRAY_SIZE(atm_ioctl_map)\n\nstatic int do_atm_iobuf(struct socket *sock, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct compat_atm_iobuf __user *iobuf32 = compat_ptr(arg);\n\tu32 data;\n\n\tif (get_user(data, &iobuf32->buffer))\n\t\treturn -EFAULT;\n\n\treturn atm_getnames(&iobuf32->length, compat_ptr(data));\n}\n\nstatic int do_atmif_sioc(struct socket *sock, unsigned int cmd,\n\t\t\t unsigned long arg)\n{\n\tstruct compat_atmif_sioc __user *sioc32 = compat_ptr(arg);\n\tint number;\n\tu32 data;\n\n\tif (get_user(data, &sioc32->arg) || get_user(number, &sioc32->number))\n\t\treturn -EFAULT;\n\treturn atm_dev_ioctl(cmd, compat_ptr(data), &sioc32->length, number, 0);\n}\n\nstatic int do_atm_ioctl(struct socket *sock, unsigned int cmd32,\n\t\t\tunsigned long arg)\n{\n\tint i;\n\tunsigned int cmd = 0;\n\n\tswitch (cmd32) {\n\tcase SONET_GETSTAT:\n\tcase SONET_GETSTATZ:\n\tcase SONET_GETDIAG:\n\tcase SONET_SETDIAG:\n\tcase SONET_CLRDIAG:\n\tcase SONET_SETFRAMING:\n\tcase SONET_GETFRAMING:\n\tcase SONET_GETFRSENSE:\n\t\treturn do_atmif_sioc(sock, cmd32, arg);\n\t}\n\n\tfor (i = 0; i < NR_ATM_IOCTL; i++) {\n\t\tif (cmd32 == atm_ioctl_map[i].cmd32) {\n\t\t\tcmd = atm_ioctl_map[i].cmd;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == NR_ATM_IOCTL)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase ATM_GETNAMES:\n\t\treturn do_atm_iobuf(sock, cmd, arg);\n\n\tcase ATM_GETLINKRATE:\n\tcase ATM_GETTYPE:\n\tcase ATM_GETESI:\n\tcase ATM_GETADDR:\n\tcase ATM_RSTADDR:\n\tcase ATM_ADDADDR:\n\tcase ATM_DELADDR:\n\tcase ATM_GETCIRANGE:\n\tcase ATM_SETCIRANGE:\n\tcase ATM_SETESI:\n\tcase ATM_SETESIF:\n\tcase ATM_GETSTAT:\n\tcase ATM_GETSTATZ:\n\tcase ATM_GETLOOP:\n\tcase ATM_SETLOOP:\n\tcase ATM_QUERYLOOP:\n\t\treturn do_atmif_sioc(sock, cmd, arg);\n\t}\n\n\treturn -EINVAL;\n}\n\nint vcc_compat_ioctl(struct socket *sock, unsigned int cmd,\n\t\t     unsigned long arg)\n{\n\tint ret;\n\n\tret = do_vcc_ioctl(sock, cmd, arg, 1);\n\tif (ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\treturn do_atm_ioctl(sock, cmd, arg);\n}\n#endif\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/* ATM ioctl handling */\n\n/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */\n/* 2003 John Levon  <levon@movementarian.org> */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/module.h>\n#include <linux/kmod.h>\n#include <linux/net.h>\t\t/* struct socket, struct proto_ops */\n#include <linux/atm.h>\t\t/* ATM stuff */\n#include <linux/atmdev.h>\n#include <linux/atmclip.h>\t/* CLIP_*ENCAP */\n#include <linux/atmarp.h>\t/* manifest constants */\n#include <linux/capability.h>\n#include <linux/sonet.h>\t/* for ioctls */\n#include <linux/atmsvc.h>\n#include <linux/atmmpc.h>\n#include <net/atmclip.h>\n#include <linux/atmlec.h>\n#include <linux/mutex.h>\n#include <asm/ioctls.h>\n#include <net/compat.h>\n\n#include \"resources.h\"\n#include \"signaling.h\"\t\t/* for WAITING and sigd_attach */\n#include \"common.h\"\n\n\nstatic DEFINE_MUTEX(ioctl_mutex);\nstatic LIST_HEAD(ioctl_list);\n\n\nvoid register_atm_ioctl(struct atm_ioctl *ioctl)\n{\n\tmutex_lock(&ioctl_mutex);\n\tlist_add_tail(&ioctl->list, &ioctl_list);\n\tmutex_unlock(&ioctl_mutex);\n}\nEXPORT_SYMBOL(register_atm_ioctl);\n\nvoid deregister_atm_ioctl(struct atm_ioctl *ioctl)\n{\n\tmutex_lock(&ioctl_mutex);\n\tlist_del(&ioctl->list);\n\tmutex_unlock(&ioctl_mutex);\n}\nEXPORT_SYMBOL(deregister_atm_ioctl);\n\nstatic int do_vcc_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\tunsigned long arg, int compat)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n\tint error;\n\tstruct list_head *pos;\n\tvoid __user *argp = (void __user *)arg;\n\tvoid __user *buf;\n\tint __user *len;\n\n\tvcc = ATM_SD(sock);\n\tswitch (cmd) {\n\tcase SIOCOUTQ:\n\t\tif (sock->state != SS_CONNECTED ||\n\t\t    !test_bit(ATM_VF_READY, &vcc->flags)) {\n\t\t\terror =  -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\terror = put_user(sk->sk_sndbuf - sk_wmem_alloc_get(sk),\n\t\t\t\t (int __user *)argp) ? -EFAULT : 0;\n\t\tgoto done;\n\tcase SIOCINQ:\n\t{\n\t\tstruct sk_buff *skb;\n\t\tint amount;\n\n\t\tif (sock->state != SS_CONNECTED) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tspin_lock_irq(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tamount = skb ? skb->len : 0;\n\t\tspin_unlock_irq(&sk->sk_receive_queue.lock);\n\t\terror = put_user(amount, (int __user *)argp) ? -EFAULT : 0;\n\t\tgoto done;\n\t}\n\tcase ATM_SETSC:\n\t\tnet_warn_ratelimited(\"ATM_SETSC is obsolete; used by %s:%d\\n\",\n\t\t\t\t     current->comm, task_pid_nr(current));\n\t\terror = 0;\n\t\tgoto done;\n\tcase ATMSIGD_CTRL:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terror = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * The user/kernel protocol for exchanging signalling\n\t\t * info uses kernel pointers as opaque references,\n\t\t * so the holder of the file descriptor can scribble\n\t\t * on the kernel... so we should make sure that we\n\t\t * have the same privileges that /proc/kcore needs\n\t\t */\n\t\tif (!capable(CAP_SYS_RAWIO)) {\n\t\t\terror = -EPERM;\n\t\t\tgoto done;\n\t\t}\n#ifdef CONFIG_COMPAT\n\t\t/* WTF? I don't even want to _think_ about making this\n\t\t   work for 32-bit userspace. TBH I don't really want\n\t\t   to think about it at all. dwmw2. */\n\t\tif (compat) {\n\t\t\tnet_warn_ratelimited(\"32-bit task cannot be atmsigd\\n\");\n\t\t\terror = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n#endif\n\t\terror = sigd_attach(vcc);\n\t\tif (!error)\n\t\t\tsock->state = SS_CONNECTED;\n\t\tgoto done;\n\tcase ATM_SETBACKEND:\n\tcase ATM_NEWBACKENDIF:\n\t{\n\t\tatm_backend_t backend;\n\t\terror = get_user(backend, (atm_backend_t __user *)argp);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tswitch (backend) {\n\t\tcase ATM_BACKEND_PPP:\n\t\t\trequest_module(\"pppoatm\");\n\t\t\tbreak;\n\t\tcase ATM_BACKEND_BR2684:\n\t\t\trequest_module(\"br2684\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase ATMMPC_CTRL:\n\tcase ATMMPC_DATA:\n\t\trequest_module(\"mpoa\");\n\t\tbreak;\n\tcase ATMARPD_CTRL:\n\t\trequest_module(\"clip\");\n\t\tbreak;\n\tcase ATMLEC_CTRL:\n\t\trequest_module(\"lec\");\n\t\tbreak;\n\t}\n\n\terror = -ENOIOCTLCMD;\n\n\tmutex_lock(&ioctl_mutex);\n\tlist_for_each(pos, &ioctl_list) {\n\t\tstruct atm_ioctl *ic = list_entry(pos, struct atm_ioctl, list);\n\t\tif (try_module_get(ic->owner)) {\n\t\t\terror = ic->ioctl(sock, cmd, arg);\n\t\t\tmodule_put(ic->owner);\n\t\t\tif (error != -ENOIOCTLCMD)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ioctl_mutex);\n\n\tif (error != -ENOIOCTLCMD)\n\t\tgoto done;\n\n\tif (cmd == ATM_GETNAMES) {\n\t\tif (IS_ENABLED(CONFIG_COMPAT) && compat) {\n#ifdef CONFIG_COMPAT\n\t\t\tstruct compat_atm_iobuf __user *ciobuf = argp;\n\t\t\tcompat_uptr_t cbuf;\n\t\t\tlen = &ciobuf->length;\n\t\t\tif (get_user(cbuf, &ciobuf->buffer))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf = compat_ptr(cbuf);\n#endif\n\t\t} else {\n\t\t\tstruct atm_iobuf __user *iobuf = argp;\n\t\t\tlen = &iobuf->length;\n\t\t\tif (get_user(buf, &iobuf->buffer))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\terror = atm_getnames(buf, len);\n\t} else {\n\t\tint number;\n\n\t\tif (IS_ENABLED(CONFIG_COMPAT) && compat) {\n#ifdef CONFIG_COMPAT\n\t\t\tstruct compat_atmif_sioc __user *csioc = argp;\n\t\t\tcompat_uptr_t carg;\n\n\t\t\tlen = &csioc->length;\n\t\t\tif (get_user(carg, &csioc->arg))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf = compat_ptr(carg);\n\t\t\tif (get_user(number, &csioc->number))\n\t\t\t\treturn -EFAULT;\n#endif\n\t\t} else {\n\t\t\tstruct atmif_sioc __user *sioc = argp;\n\n\t\t\tlen = &sioc->length;\n\t\t\tif (get_user(buf, &sioc->arg))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (get_user(number, &sioc->number))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\terror = atm_dev_ioctl(cmd, buf, len, number, compat);\n\t}\n\ndone:\n\treturn error;\n}\n\nint vcc_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\treturn do_vcc_ioctl(sock, cmd, arg, 0);\n}\n\n#ifdef CONFIG_COMPAT\n/*\n * FIXME:\n * The compat_ioctl handling is duplicated, using both these conversion\n * routines and the compat argument to the actual handlers. Both\n * versions are somewhat incomplete and should be merged, e.g. by\n * moving the ioctl number translation into the actual handlers and\n * killing the conversion code.\n *\n * -arnd, November 2009\n */\n#define ATM_GETLINKRATE32 _IOW('a', ATMIOC_ITF+1, struct compat_atmif_sioc)\n#define ATM_GETNAMES32    _IOW('a', ATMIOC_ITF+3, struct compat_atm_iobuf)\n#define ATM_GETTYPE32     _IOW('a', ATMIOC_ITF+4, struct compat_atmif_sioc)\n#define ATM_GETESI32\t  _IOW('a', ATMIOC_ITF+5, struct compat_atmif_sioc)\n#define ATM_GETADDR32\t  _IOW('a', ATMIOC_ITF+6, struct compat_atmif_sioc)\n#define ATM_RSTADDR32\t  _IOW('a', ATMIOC_ITF+7, struct compat_atmif_sioc)\n#define ATM_ADDADDR32\t  _IOW('a', ATMIOC_ITF+8, struct compat_atmif_sioc)\n#define ATM_DELADDR32\t  _IOW('a', ATMIOC_ITF+9, struct compat_atmif_sioc)\n#define ATM_GETCIRANGE32  _IOW('a', ATMIOC_ITF+10, struct compat_atmif_sioc)\n#define ATM_SETCIRANGE32  _IOW('a', ATMIOC_ITF+11, struct compat_atmif_sioc)\n#define ATM_SETESI32      _IOW('a', ATMIOC_ITF+12, struct compat_atmif_sioc)\n#define ATM_SETESIF32     _IOW('a', ATMIOC_ITF+13, struct compat_atmif_sioc)\n#define ATM_GETSTAT32     _IOW('a', ATMIOC_SARCOM+0, struct compat_atmif_sioc)\n#define ATM_GETSTATZ32    _IOW('a', ATMIOC_SARCOM+1, struct compat_atmif_sioc)\n#define ATM_GETLOOP32\t  _IOW('a', ATMIOC_SARCOM+2, struct compat_atmif_sioc)\n#define ATM_SETLOOP32\t  _IOW('a', ATMIOC_SARCOM+3, struct compat_atmif_sioc)\n#define ATM_QUERYLOOP32\t  _IOW('a', ATMIOC_SARCOM+4, struct compat_atmif_sioc)\n\nstatic struct {\n\tunsigned int cmd32;\n\tunsigned int cmd;\n} atm_ioctl_map[] = {\n\t{ ATM_GETLINKRATE32, ATM_GETLINKRATE },\n\t{ ATM_GETNAMES32,    ATM_GETNAMES },\n\t{ ATM_GETTYPE32,     ATM_GETTYPE },\n\t{ ATM_GETESI32,\t     ATM_GETESI },\n\t{ ATM_GETADDR32,     ATM_GETADDR },\n\t{ ATM_RSTADDR32,     ATM_RSTADDR },\n\t{ ATM_ADDADDR32,     ATM_ADDADDR },\n\t{ ATM_DELADDR32,     ATM_DELADDR },\n\t{ ATM_GETCIRANGE32,  ATM_GETCIRANGE },\n\t{ ATM_SETCIRANGE32,  ATM_SETCIRANGE },\n\t{ ATM_SETESI32,\t     ATM_SETESI },\n\t{ ATM_SETESIF32,     ATM_SETESIF },\n\t{ ATM_GETSTAT32,     ATM_GETSTAT },\n\t{ ATM_GETSTATZ32,    ATM_GETSTATZ },\n\t{ ATM_GETLOOP32,     ATM_GETLOOP },\n\t{ ATM_SETLOOP32,     ATM_SETLOOP },\n\t{ ATM_QUERYLOOP32,   ATM_QUERYLOOP },\n};\n\n#define NR_ATM_IOCTL ARRAY_SIZE(atm_ioctl_map)\n\nstatic int do_atm_iobuf(struct socket *sock, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct compat_atm_iobuf __user *iobuf32 = compat_ptr(arg);\n\tu32 data;\n\n\tif (get_user(data, &iobuf32->buffer))\n\t\treturn -EFAULT;\n\n\treturn atm_getnames(&iobuf32->length, compat_ptr(data));\n}\n\nstatic int do_atmif_sioc(struct socket *sock, unsigned int cmd,\n\t\t\t unsigned long arg)\n{\n\tstruct compat_atmif_sioc __user *sioc32 = compat_ptr(arg);\n\tint number;\n\tu32 data;\n\n\tif (get_user(data, &sioc32->arg) || get_user(number, &sioc32->number))\n\t\treturn -EFAULT;\n\treturn atm_dev_ioctl(cmd, compat_ptr(data), &sioc32->length, number, 0);\n}\n\nstatic int do_atm_ioctl(struct socket *sock, unsigned int cmd32,\n\t\t\tunsigned long arg)\n{\n\tint i;\n\tunsigned int cmd = 0;\n\n\tswitch (cmd32) {\n\tcase SONET_GETSTAT:\n\tcase SONET_GETSTATZ:\n\tcase SONET_GETDIAG:\n\tcase SONET_SETDIAG:\n\tcase SONET_CLRDIAG:\n\tcase SONET_SETFRAMING:\n\tcase SONET_GETFRAMING:\n\tcase SONET_GETFRSENSE:\n\t\treturn do_atmif_sioc(sock, cmd32, arg);\n\t}\n\n\tfor (i = 0; i < NR_ATM_IOCTL; i++) {\n\t\tif (cmd32 == atm_ioctl_map[i].cmd32) {\n\t\t\tcmd = atm_ioctl_map[i].cmd;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == NR_ATM_IOCTL)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase ATM_GETNAMES:\n\t\treturn do_atm_iobuf(sock, cmd, arg);\n\n\tcase ATM_GETLINKRATE:\n\tcase ATM_GETTYPE:\n\tcase ATM_GETESI:\n\tcase ATM_GETADDR:\n\tcase ATM_RSTADDR:\n\tcase ATM_ADDADDR:\n\tcase ATM_DELADDR:\n\tcase ATM_GETCIRANGE:\n\tcase ATM_SETCIRANGE:\n\tcase ATM_SETESI:\n\tcase ATM_SETESIF:\n\tcase ATM_GETSTAT:\n\tcase ATM_GETSTATZ:\n\tcase ATM_GETLOOP:\n\tcase ATM_SETLOOP:\n\tcase ATM_QUERYLOOP:\n\t\treturn do_atmif_sioc(sock, cmd, arg);\n\t}\n\n\treturn -EINVAL;\n}\n\nint vcc_compat_ioctl(struct socket *sock, unsigned int cmd,\n\t\t     unsigned long arg)\n{\n\tint ret;\n\n\tret = do_vcc_ioctl(sock, cmd, arg, 1);\n\tif (ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\treturn do_atm_ioctl(sock, cmd, arg);\n}\n#endif\n"], "filenames": ["net/atm/ioctl.c"], "buggy_code_start_loc": [75], "buggy_code_end_loc": [84], "fixing_code_start_loc": [76], "fixing_code_end_loc": [87], "type": "CWE-416", "message": "An issue was discovered in the Linux kernel before 6.6.8. do_vcc_ioctl in net/atm/ioctl.c has a use-after-free because of a vcc_recvmsg race condition.", "other": {"cve": {"id": "CVE-2023-51780", "sourceIdentifier": "cve@mitre.org", "published": "2024-01-11T19:15:12.500", "lastModified": "2024-02-01T18:51:15.553", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 6.6.8. do_vcc_ioctl in net/atm/ioctl.c has a use-after-free because of a vcc_recvmsg race condition."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en el kernel de Linux anterior a 6.6.8. do_vcc_ioctl en net/atm/ioctl.c tiene un use after free debido a una condici\u00f3n de ejecuci\u00f3n vcc_recvmsg."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartExcluding": "2.6.12", "versionEndExcluding": "6.6.8", "matchCriteriaId": "C5C35A7D-82A5-436F-925A-384D92679784"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.12:rc2:*:*:*:*:*:*", "matchCriteriaId": "4F76C298-81DC-43E4-8FC9-DC005A2116EF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.12:rc3:*:*:*:*:*:*", "matchCriteriaId": "0AB349B2-3F78-4197-882B-90ADB3BF645A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.12:rc4:*:*:*:*:*:*", "matchCriteriaId": "6AC88830-A9BC-4607-B572-A4B502FC9FD0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.12:rc5:*:*:*:*:*:*", "matchCriteriaId": "476CB3A5-D022-4F13-AAEF-CB6A5785516A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.12:rc6:*:*:*:*:*:*", "matchCriteriaId": "8CFD5CDD-1709-44C7-82BD-BAFDC46990D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc1:*:*:*:*:*:*", "matchCriteriaId": "3A0038DE-E183-4958-A6E3-CE3821FEAFBF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc2:*:*:*:*:*:*", "matchCriteriaId": "E31AD4FC-436C-44AB-BCAB-3A0B37F69EE0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc3:*:*:*:*:*:*", "matchCriteriaId": "C56C6E04-4F04-44A3-8DB8-93899903CFCF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc4:*:*:*:*:*:*", "matchCriteriaId": "5C78EDA4-8BE6-42FC-9512-49032D525A55"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc5:*:*:*:*:*:*", "matchCriteriaId": "32F2E5CA-13C6-4601-B530-D465CBF73D1C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.6.8", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/torvalds/linux/commit/24e90b9e34f9e039f56b5f25f6e6eb92cdd8f4b3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2024/01/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2024/01/msg00005.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/24e90b9e34f9e039f56b5f25f6e6eb92cdd8f4b3"}}